<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ffmpeg - ffmpeg media converter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/ffmpeg">ffmpeg_7.1.1-1ubuntu1.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ffmpeg - ffmpeg media converter

</pre><h4><b>SYNOPSIS</b></h4><pre>
       ffmpeg [<u>global_options</u>] {[<u>input_file_options</u>] -i <u>input_url</u>} ... {[<u>output_file_options</u>] <u>output_url</u>} ...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>ffmpeg</b> is a universal media converter. It can read a wide variety of inputs - including live
       grabbing/recording devices - filter, and transcode them into a plethora of output formats.

       <b>ffmpeg</b> reads from an arbitrary number of input "files" (which can be regular files, pipes, network
       streams, grabbing devices, etc.), specified by the "-i" option, and writes to an arbitrary number of
       output "files", which are specified by a plain output url. Anything found on the command line which
       cannot be interpreted as an option is considered to be an output url.

       Each input or output url can, in principle, contain any number of streams of different types
       (video/audio/subtitle/attachment/data). The allowed number and/or types of streams may be limited by the
       container format. Selecting which streams from which inputs will go into which output is either done
       automatically or with the "-map" option (see the Stream selection chapter).

       To refer to input files in options, you must use their indices (0-based). E.g.  the first input file is
       0, the second is 1, etc. Similarly, streams within a file are referred to by their indices. E.g. "2:3"
       refers to the fourth stream in the third input file. Also see the Stream specifiers chapter.

       As a general rule, options are applied to the next specified file. Therefore, order is important, and you
       can have the same option on the command line multiple times. Each occurrence is then applied to the next
       input or output file.  Exceptions from this rule are the global options (e.g. verbosity level), which
       should be specified first.

       Do not mix input and output files -- first specify all input files, then all output files. Also do not
       mix options which belong to different files. All options apply ONLY to the next input or output file and
       are reset between files.

       Some simple examples follow.

       •   Convert an input media file to a different format, by re-encoding media streams:

                   ffmpeg -i input.avi output.mp4

       •   Set the video bitrate of the output file to 64 kbit/s:

                   ffmpeg -i input.avi -b:v 64k -bufsize 64k output.mp4

       •   Force the frame rate of the output file to 24 fps:

                   ffmpeg -i input.avi -r 24 output.mp4

       •   Force  the  frame  rate of the input file (valid for raw formats only) to 1 fps and the frame rate of
           the output file to 24 fps:

                   ffmpeg -r 1 -i input.m2v -r 24 output.mp4

       The format option may be needed for raw input files.

</pre><h4><b>DETAILED</b> <b>DESCRIPTION</b></h4><pre>
       The transcoding process in <b>ffmpeg</b> for each output can be described by the following diagram:

                _______              ______________
               |       |            |              |
               | input |  demuxer   | encoded data |   decoder
               | file  | ---------&gt; | packets      | -----+
               |_______|            |______________|      |
                                                          v
                                                      _________
                                                     |         |
                                                     | decoded |
                                                     | frames  |
                                                     |_________|
                ________             ______________       |
               |        |           |              |      |
               | output | &lt;-------- | encoded data | &lt;----+
               | file   |   muxer   | packets      |   encoder
               |________|           |______________|

       <b>ffmpeg</b> calls the libavformat library (containing demuxers) to read input files and get packets containing
       encoded data from them. When there are multiple input files, <b>ffmpeg</b> tries to keep  them  synchronized  by
       tracking lowest timestamp on any active input stream.

       Encoded packets are then passed to the decoder (unless streamcopy is selected for the stream, see further
       for  a  description).  The  decoder  produces  uncompressed frames (raw video/PCM audio/...) which can be
       processed further by filtering (see next section). After filtering, the frames are passed to the encoder,
       which encodes them and outputs encoded packets. Finally, those are passed to the muxer, which writes  the
       encoded packets to the output file.

   <b>Filtering</b>
       Before  encoding,  <b>ffmpeg</b>  can  process  raw  audio  and  video frames using filters from the libavfilter
       library. Several chained filters  form  a  filter  graph.  <b>ffmpeg</b>  distinguishes  between  two  types  of
       filtergraphs: simple and complex.

       <u>Simple</u> <u>filtergraphs</u>

       Simple filtergraphs are those that have exactly one input and output, both of the same type. In the above
       diagram they can be represented by simply inserting an additional step between decoding and encoding:

                _________                        ______________
               |         |                      |              |
               | decoded |                      | encoded data |
               | frames  |\                   _ | packets      |
               |_________| \                  /||______________|
                            \   __________   /
                 simple     _\||          | /  encoder
                 filtergraph   | filtered |/
                               | frames   |
                               |__________|

       Simple filtergraphs are configured with the per-stream <b>-filter</b> option (with <b>-vf</b> and <b>-af</b> aliases for video
       and audio respectively).  A simple filtergraph for video can look for example like this:

                _______        _____________        _______        ________
               |       |      |             |      |       |      |        |
               | input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |
               |_______|      |_____________|      |_______|      |________|

       Note  that  some  filters  change  frame  properties but not frame contents. E.g. the "fps" filter in the
       example above changes number of frames, but does not touch the frame contents.  Another  example  is  the
       "setpts" filter, which only sets timestamps and otherwise passes the frames unchanged.

       <u>Complex</u> <u>filtergraphs</u>

       Complex  filtergraphs  are those which cannot be described as simply a linear processing chain applied to
       one stream. This is the case, for example, when the graph has more than one input and/or output, or  when
       output stream type is different from input. They can be represented with the following diagram:

                _________
               |         |
               | input 0 |\                    __________
               |_________| \                  |          |
                            \   _________    /| output 0 |
                             \ |         |  / |__________|
                _________     \| complex | /
               |         |     |         |/
               | input 1 |----&gt;| filter  |\
               |_________|     |         | \   __________
                              /| graph   |  \ |          |
                             / |         |   \| output 1 |
                _________   /  |_________|    |__________|
               |         | /
               | input 2 |/
               |_________|

       Complex  filtergraphs  are  configured with the <b>-filter_complex</b> option.  Note that this option is global,
       since a complex filtergraph, by its nature, cannot be unambiguously associated with a  single  stream  or
       file.

       The <b>-lavfi</b> option is equivalent to <b>-filter_complex</b>.

       A  trivial  example  of a complex filtergraph is the "overlay" filter, which has two video inputs and one
       video output, containing one video overlaid on top of the other. Its  audio  counterpart  is  the  "amix"
       filter.

   <b>Stream</b> <b>copy</b>
       Stream  copy  is  a mode selected by supplying the "copy" parameter to the <b>-codec</b> option. It makes <b>ffmpeg</b>
       omit the decoding and encoding step for the specified stream, so it does only demuxing and muxing. It  is
       useful  for  changing the container format or modifying container-level metadata. The diagram above will,
       in this case, simplify to this:

                _______              ______________            ________
               |       |            |              |          |        |
               | input |  demuxer   | encoded data |  muxer   | output |
               | file  | ---------&gt; | packets      | -------&gt; | file   |
               |_______|            |______________|          |________|

       Since there is no decoding or encoding, it is very fast and there is no quality loss. However,  it  might
       not  work  in  some  cases  because of many factors. Applying filters is obviously also impossible, since
       filters work on uncompressed data.

   <b>Loopback</b> <b>decoders</b>
       While decoders are normally associated with demuxer streams, it is also  possible  to  create  "loopback"
       decoders  that  decode  the output from some encoder and allow it to be fed back to complex filtergraphs.
       This is done with the "-dec" directive, which takes as a parameter the index of the  output  stream  that
       should  be decoded. Every such directive creates a new loopback decoder, indexed with successive integers
       starting at zero. These indices should then be used to refer to loopback decoders in complex  filtergraph
       link labels, as described in the documentation for <b>-filter_complex</b>.

       Decoding  AVOptions  can  be  passed  to  loopback decoders by placing them before "-dec", analogously to
       input/output options.

       E.g. the following example:

               ffmpeg -i INPUT                                        \
                 -map 0:v:0 -c:v libx264 -crf 45 -f null -            \
                 -threads 3 -dec 0:0                                  \
                 -filter_complex '[0:v][dec:0]hstack[stack]'          \
                 -map '[stack]' -c:v ffv1 OUTPUT

       reads an input video and

       •   (line 2) encodes it with "libx264" at low quality;

       •   (line 3) decodes this encoded stream using 3 threads;

       •   (line 4) places decoded video side by side with the original input video;

       •   (line 5) combined video is then losslessly encoded and written into <u>OUTPUT</u>.

</pre><h4><b>STREAM</b> <b>SELECTION</b></h4><pre>
       <b>ffmpeg</b> provides the "-map" option for manual control of stream selection in each output file.  Users  can
       skip  "-map" and let ffmpeg perform automatic stream selection as described below. The "-vn / -an / -sn /
       -dn" options can be used to skip inclusion of video,  audio,  subtitle  and  data  streams  respectively,
       whether  manually mapped or automatically selected, except for those streams which are outputs of complex
       filtergraphs.

   <b>Description</b>
       The sub-sections that follow describe the various rules that  are  involved  in  stream  selection.   The
       examples that follow next show how these rules are applied in practice.

       While  every effort is made to accurately reflect the behavior of the program, FFmpeg is under continuous
       development and the code may have changed since the time of this writing.

       <u>Automatic</u> <u>stream</u> <u>selection</u>

       In the absence of any map options for a particular output file, ffmpeg  inspects  the  output  format  to
       check  which  type  of  streams  can  be  included  in  it,  viz. video, audio and/or subtitles. For each
       acceptable stream type, ffmpeg will pick one stream, when available, from among all the inputs.

       It will select that stream based upon the following criteria:

       •   for video, it is the stream with the highest resolution,

       •   for audio, it is the stream with the most channels,

       •   for subtitles, it is the first subtitle stream found but  there's  a  caveat.   The  output  format's
           default  subtitle  encoder can be either text-based or image-based, and only a subtitle stream of the
           same type will be chosen.

       In the case where several streams of the same type rate equally, the stream  with  the  lowest  index  is
       chosen.

       Data or attachment streams are not automatically selected and can only be included using "-map".

       <u>Manual</u> <u>stream</u> <u>selection</u>

       When  "-map"  is  used,  only  user-mapped  streams  are  included in that output file, with one possible
       exception for filtergraph outputs described below.

       <u>Complex</u> <u>filtergraphs</u>

       If there are any complex filtergraph output streams with unlabeled pads, they will be added to the  first
       output file. This will lead to a fatal error if the stream type is not supported by the output format. In
       the  absence of the map option, the inclusion of these streams leads to the automatic stream selection of
       their types being skipped. If map options are present, these filtergraph streams are included in addition
       to the mapped streams.

       Complex filtergraph output streams with labeled pads must be mapped once and exactly once.

       <u>Stream</u> <u>handling</u>

       Stream handling is independent of stream selection, with an  exception  for  subtitles  described  below.
       Stream  handling  is  set  via the "-codec" option addressed to streams within a specific <u>output</u> file. In
       particular, codec options are applied by ffmpeg after the  stream  selection  process  and  thus  do  not
       influence  the  latter.  If  no  "-codec"  option  is specified for a stream type, ffmpeg will select the
       default encoder registered by the output file muxer.

       An exception exists for subtitles. If a subtitle encoder is specified  for  an  output  file,  the  first
       subtitle  stream  found  of  any  type,  text or image, will be included. ffmpeg does not validate if the
       specified encoder can convert the selected stream or if the converted stream  is  acceptable  within  the
       output  format.  This  applies  generally  as  well:  when  the user sets an encoder manually, the stream
       selection process cannot check if the encoded stream can be muxed into the output file.   If  it  cannot,
       ffmpeg will abort and <u>all</u> output files will fail to be processed.

   <b>Examples</b>
       The  following  examples  illustrate  the  behavior,  quirks and limitations of ffmpeg's stream selection
       methods.

       They assume the following three input files.

               input file 'A.avi'
                     stream 0: video 640x360
                     stream 1: audio 2 channels

               input file 'B.mp4'
                     stream 0: video 1920x1080
                     stream 1: audio 2 channels
                     stream 2: subtitles (text)
                     stream 3: audio 5.1 channels
                     stream 4: subtitles (text)

               input file 'C.mkv'
                     stream 0: video 1280x720
                     stream 1: audio 2 channels
                     stream 2: subtitles (image)

       Example: automatic stream selection

               ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov

       There are three output files specified, and for the first two, no "-map" options are set, so ffmpeg  will
       select streams for these two files automatically.

       <u>out1.mkv</u>  is  a Matroska container file and accepts video, audio and subtitle streams, so ffmpeg will try
       to select one of each type.For video, it will select  "stream  0"  from  <u>B.mp4</u>,  which  has  the  highest
       resolution  among  all  the input video streams.For audio, it will select "stream 3" from <u>B.mp4</u>, since it
       has the greatest number of channels.For subtitles, it will select "stream 2" from  <u>B.mp4</u>,  which  is  the
       first subtitle stream from among <u>A.avi</u> and <u>B.mp4</u>.

       <u>out2.wav</u> accepts only audio streams, so only "stream 3" from <u>B.mp4</u> is selected.

       For  <u>out3.mov</u>,  since  a  "-map"  option is set, no automatic stream selection will occur. The "-map 1:a"
       option will select all audio streams from the second input <u>B.mp4</u>. No other streams will  be  included  in
       this output file.

       For  the  first  two  outputs,  all  included streams will be transcoded. The encoders chosen will be the
       default ones registered by each output format, which may not  match  the  codec  of  the  selected  input
       streams.

       For  the  third  output, codec option for audio streams has been set to "copy", so no decoding-filtering-
       encoding operations will occur, or <u>can</u> occur.  Packets of selected streams shall  be  conveyed  from  the
       input file and muxed within the output file.

       Example: automatic subtitles selection

               ffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv

       Although  <u>out1.mkv</u>  is  a  Matroska container file which accepts subtitle streams, only a video and audio
       stream shall be selected. The subtitle stream of <u>C.mkv</u> is image-based and the default subtitle encoder of
       the Matroska muxer is text-based, so a transcode operation for the subtitles  is  expected  to  fail  and
       hence the stream isn't selected. However, in <u>out2.mkv</u>, a subtitle encoder is specified in the command and
       so,  the  subtitle  stream  is  selected, in addition to the video stream. The presence of "-an" disables
       audio stream selection for <u>out2.mkv</u>.

       Example: unlabeled filtergraph outputs

               ffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex "overlay" out1.mp4 out2.srt

       A filtergraph is setup here using the "-filter_complex" option and consists of a single video filter. The
       "overlay" filter requires exactly two video inputs, but none are specified, so the  first  two  available
       video  streams  are  used,  those of <u>A.avi</u> and <u>C.mkv</u>. The output pad of the filter has no label and so is
       sent to the first output file <u>out1.mp4</u>. Due to this, automatic selection of the video stream is  skipped,
       which  would  have  selected  the stream in <u>B.mp4</u>. The audio stream with most channels viz. "stream 3" in
       <u>B.mp4</u>, is chosen automatically. No subtitle stream is chosen however, since the MP4 format has no default
       subtitle encoder registered, and the user hasn't specified a subtitle encoder.

       The 2nd output file, <u>out2.srt</u>, only accepts text-based  subtitle  streams.  So,  even  though  the  first
       subtitle  stream  available  belongs to <u>C.mkv</u>, it is image-based and hence skipped.  The selected stream,
       "stream 2" in <u>B.mp4</u>, is the first text-based subtitle stream.

       Example: labeled filtergraph outputs

               ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex "[1:v]hue=s=0[outv];overlay;aresample" \
                      -map '[outv]' -an        out1.mp4 \
                                               out2.mkv \
                      -map '[outv]' -map 1:a:0 out3.mkv

       The above command will fail, as the output pad labelled "[outv]" has been  mapped  twice.   None  of  the
       output files shall be processed.

               ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex "[1:v]hue=s=0[outv];overlay;aresample" \
                      -an        out1.mp4 \
                                 out2.mkv \
                      -map 1:a:0 out3.mkv

       This  command above will also fail as the hue filter output has a label, "[outv]", and hasn't been mapped
       anywhere.

       The command should be modified as follows,

               ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex "[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample" \
                       -map '[outv1]' -an        out1.mp4 \
                                                 out2.mkv \
                       -map '[outv2]' -map 1:a:0 out3.mkv

       The video stream from <u>B.mp4</u> is sent to the hue filter, whose  output  is  cloned  once  using  the  split
       filter, and both outputs labelled. Then a copy each is mapped to the first and third output files.

       The  overlay  filter,  requiring two video inputs, uses the first two unused video streams. Those are the
       streams from <u>A.avi</u> and <u>C.mkv</u>. The overlay output isn't labelled, so it is sent to the first  output  file
       <u>out1.mp4</u>, regardless of the presence of the "-map" option.

       The  aresample  filter  is sent the first unused audio stream, that of <u>A.avi</u>. Since this filter output is
       also unlabelled, it too is mapped to the first  output  file.  The  presence  of  "-an"  only  suppresses
       automatic  or  manual  stream  selection of audio streams, not outputs sent from filtergraphs. Both these
       mapped streams shall be ordered before the mapped stream in <u>out1.mp4</u>.

       The video, audio and subtitle streams mapped to "out2.mkv" are entirely determined  by  automatic  stream
       selection.

       <u>out3.mkv</u> consists of the cloned video output from the hue filter and the first audio stream from <u>B.mp4</u>.

</pre><h4><b>OPTIONS</b></h4><pre>
       All  the  numerical  options, if not specified otherwise, accept a string representing a number as input,
       which may be followed by one of the SI unit prefixes, for example: 'K', 'M', or 'G'.

       If 'i' is appended to the SI unit prefix, the complete prefix will be interpreted as a  unit  prefix  for
       binary  multiples,  which  are based on powers of 1024 instead of powers of 1000. Appending 'B' to the SI
       unit prefix multiplies the value by 8. This allows using, for example: 'KB', 'MiB', 'G' and 'B' as number
       suffixes.

       Options which do not take arguments are boolean options, and set the corresponding value  to  true.  They
       can  be  set  to  false  by  prefixing the option name with "no". For example using "-nofoo" will set the
       boolean option with name "foo" to false.

       Options that take arguments support a special syntax where the argument given  on  the  command  line  is
       interpreted  as  a  path to the file from which the actual argument value is loaded. To use this feature,
       add a forward slash '/' immediately before the option name (after the leading dash). E.g.

               ffmpeg -i INPUT -/filter:v filter.script OUTPUT

       will load a filtergraph description from the file named <u>filter.script</u>.

   <b>Stream</b> <b>specifiers</b>
       Some options are applied per-stream, e.g. bitrate or codec.  Stream  specifiers  are  used  to  precisely
       specify which stream(s) a given option belongs to.

       A  stream  specifier  is a string generally appended to the option name and separated from it by a colon.
       E.g. "-codec:a:1 ac3" contains the "a:1"  stream  specifier,  which  matches  the  second  audio  stream.
       Therefore, it would select the ac3 codec for the second audio stream.

       A  stream  specifier  can  match  several streams, so that the option is applied to all of them. E.g. the
       stream specifier in "-b:a 128k" matches all audio streams.

       An empty stream specifier matches all streams. For example, "-codec copy" or "-codec:  copy"  would  copy
       all the streams without reencoding.

       Possible forms of stream specifiers are:

       <u>stream_index</u>
           Matches  the  stream  with  this index. E.g. "-threads:1 4" would set the thread count for the second
           stream to 4. If <u>stream_index</u> is used as an additional stream specifier (see below), then  it  selects
           stream  number  <u>stream_index</u> from the matching streams. Stream numbering is based on the order of the
           streams as detected by libavformat except when a  stream  group  specifier  or  program  ID  is  also
           specified. In this case it is based on the ordering of the streams in the group or program.

       <u>stream_type</u><b>[:</b><u>additional_stream_specifier</u><b>]</b>
           <u>stream_type</u> is one of following: 'v' or 'V' for video, 'a' for audio, 's' for subtitle, 'd' for data,
           and  't' for attachments. 'v' matches all video streams, 'V' only matches video streams which are not
           attached pictures, video thumbnails or cover arts. If <u>additional_stream_specifier</u> is  used,  then  it
           matches  streams  which  both have this type and match the <u>additional_stream_specifier</u>. Otherwise, it
           matches all streams of the specified type.

       <b>g:</b><u>group_specifier</u><b>[:</b><u>additional_stream_specifier</u><b>]</b>
           Matches   streams   which   are   in   the   group   with   the   specifier   <u>group_specifier</u>.     if
           <u>additional_stream_specifier</u>  is  used,  then  it matches streams which both are part of the group and
           match the <u>additional_stream_specifier</u>.  <u>group_specifier</u> may be one of the following:

           <u>group_index</u>
               Match the stream with this group index.

           <b>#</b><u>group_id</u> <b>or</b> <b>i:</b><u>group_id</u>
               Match the stream with this group id.

       <b>p:</b><u>program_id</u><b>[:</b><u>additional_stream_specifier</u><b>]</b>
           Matches streams which are in the program with the id <u>program_id</u>.  If  <u>additional_stream_specifier</u>  is
           used,   then   it   matches   streams   which   both   are   part   of  the  program  and  match  the
           <u>additional_stream_specifier</u>.

       <b>#</b><u>stream_id</u> <b>or</b> <b>i:</b><u>stream_id</u>
           Match the stream by stream id (e.g. PID in MPEG-TS container).

       <b>m:</b><u>key</u><b>[:</b><u>value</u><b>]</b>
           Matches streams with the metadata tag <u>key</u> having the specified value. If <u>value</u> is not given,  matches
           streams  that  contain the given tag with any value. The colon character ':' in <u>key</u> or <u>value</u> needs to
           be backslash-escaped.

       <b>disp:</b><u>dispositions</u><b>[:</b><u>additional_stream_specifier</u><b>]</b>
           Matches streams with the given disposition(s). <u>dispositions</u> is a list of one or more dispositions (as
           printed by the <b>-dispositions</b> option) joined with '+'.

       <b>u</b>   Matches streams with usable configuration, the codec must be defined and  the  essential  information
           such as video dimension or audio sample rate must be present.

           Note that in <b>ffmpeg</b>, matching by metadata will only work properly for input files.

   <b>Generic</b> <b>options</b>
       These options are shared amongst the ff* tools.

       <b>-L</b>  Show license.

       <b>-h,</b> <b>-?,</b> <b>-help,</b> <b>--help</b> <b>[</b><u>arg</u><b>]</b>
           Show help. An optional parameter may be specified to print help about a specific item. If no argument
           is specified, only basic (non advanced) tool options are shown.

           Possible values of <u>arg</u> are:

           <b>long</b>
               Print advanced tool options in addition to the basic tool options.

           <b>full</b>
               Print  complete  list  of  options,  including shared and private options for encoders, decoders,
               demuxers, muxers, filters, etc.

           <b>decoder=</b><u>decoder_name</u>
               Print detailed information about the decoder named <u>decoder_name</u>. Use the <b>-decoders</b> option to  get
               a list of all decoders.

           <b>encoder=</b><u>encoder_name</u>
               Print  detailed information about the encoder named <u>encoder_name</u>. Use the <b>-encoders</b> option to get
               a list of all encoders.

           <b>demuxer=</b><u>demuxer_name</u>
               Print detailed information about the demuxer named <u>demuxer_name</u>. Use the <b>-formats</b> option to get a
               list of all demuxers and muxers.

           <b>muxer=</b><u>muxer_name</u>
               Print detailed information about the muxer named <u>muxer_name</u>. Use the <b>-formats</b>  option  to  get  a
               list of all muxers and demuxers.

           <b>filter=</b><u>filter_name</u>
               Print  detailed  information about the filter named <u>filter_name</u>. Use the <b>-filters</b> option to get a
               list of all filters.

           <b>bsf=</b><u>bitstream_filter_name</u>
               Print detailed information about the bitstream filter named <u>bitstream_filter_name</u>.  Use the <b>-bsfs</b>
               option to get a list of all bitstream filters.

           <b>protocol=</b><u>protocol_name</u>
               Print detailed information about the protocol named <u>protocol_name</u>.  Use the <b>-protocols</b> option  to
               get a list of all protocols.

       <b>-version</b>
           Show version.

       <b>-buildconf</b>
           Show the build configuration, one option per line.

       <b>-formats</b>
           Show available formats (including devices).

       <b>-demuxers</b>
           Show available demuxers.

       <b>-muxers</b>
           Show available muxers.

       <b>-devices</b>
           Show available devices.

       <b>-codecs</b>
           Show all codecs known to libavcodec.

           Note  that  the  term  'codec'  is  used throughout this documentation as a shortcut for what is more
           correctly called a media bitstream format.

       <b>-decoders</b>
           Show available decoders.

       <b>-encoders</b>
           Show all available encoders.

       <b>-bsfs</b>
           Show available bitstream filters.

       <b>-protocols</b>
           Show available protocols.

       <b>-filters</b>
           Show available libavfilter filters.

       <b>-pix_fmts</b>
           Show available pixel formats.

       <b>-sample_fmts</b>
           Show available sample formats.

       <b>-layouts</b>
           Show channel names and standard channel layouts.

       <b>-dispositions</b>
           Show stream dispositions.

       <b>-colors</b>
           Show recognized color names.

       <b>-sources</b> <u>device</u><b>[,</b><u>opt1</u><b>=</b><u>val1</u><b>[,</b><u>opt2</u><b>=</b><u>val2</u><b>]...]</b>
           Show autodetected sources of the input device.  Some  devices  may  provide  system-dependent  source
           names that cannot be autodetected.  The returned list cannot be assumed to be always complete.

                   ffmpeg -sources pulse,server=192.168.0.4

       <b>-sinks</b> <u>device</u><b>[,</b><u>opt1</u><b>=</b><u>val1</u><b>[,</b><u>opt2</u><b>=</b><u>val2</u><b>]...]</b>
           Show  autodetected  sinks of the output device.  Some devices may provide system-dependent sink names
           that cannot be autodetected.  The returned list cannot be assumed to be always complete.

                   ffmpeg -sinks pulse,server=192.168.0.4

       <b>-loglevel</b> <b>[</b><u>flags</u><b>+]</b><u>loglevel</u> <b>|</b> <b>-v</b> <b>[</b><u>flags</u><b>+]</b><u>loglevel</u>
           Set logging level and flags used by the library.

           The optional <u>flags</u> prefix can consist of the following values:

           <b>repeat</b>
               Indicates that repeated log output should not be compressed to  the  first  line  and  the  "Last
               message repeated n times" line will be omitted.

           <b>level</b>
               Indicates that log output should add a "[level]" prefix to each message line. This can be used as
               an alternative to log coloring, e.g. when dumping the log to file.

           Flags  can also be used alone by adding a '+'/'-' prefix to set/reset a single flag without affecting
           other <u>flags</u> or changing <u>loglevel</u>. When setting both <u>flags</u> and <u>loglevel</u>, a '+' separator  is  expected
           between the last <u>flags</u> value and before <u>loglevel</u>.

           <u>loglevel</u> is a string or a number containing one of the following values:

           <b>quiet,</b> <b>-8</b>
               Show nothing at all; be silent.

           <b>panic,</b> <b>0</b>
               Only  show fatal errors which could lead the process to crash, such as an assertion failure. This
               is not currently used for anything.

           <b>fatal,</b> <b>8</b>
               Only show fatal errors. These are errors after which the process absolutely cannot continue.

           <b>error,</b> <b>16</b>
               Show all errors, including ones which can be recovered from.

           <b>warning,</b> <b>24</b>
               Show all warnings and errors. Any message related to possibly incorrect or unexpected events will
               be shown.

           <b>info,</b> <b>32</b>
               Show informative messages during processing. This is in addition to warnings and errors. This  is
               the default value.

           <b>verbose,</b> <b>40</b>
               Same as "info", except more verbose.

           <b>debug,</b> <b>48</b>
               Show everything, including debugging information.

           <b>trace,</b> <b>56</b>

           For example to enable repeated log output, add the "level" prefix, and set <u>loglevel</u> to "verbose":

                   ffmpeg -loglevel repeat+level+verbose -i input output

           Another  example  that  enables repeated log output without affecting current state of "level" prefix
           flag or <u>loglevel</u>:

                   ffmpeg [...] -loglevel +repeat

           By default the program logs to stderr. If coloring is supported by the terminal, colors are  used  to
           mark   errors   and  warnings.  Log  coloring  can  be  disabled  setting  the  environment  variable
           <b>AV_LOG_FORCE_NOCOLOR</b>, or can be forced setting the environment variable <b>AV_LOG_FORCE_COLOR</b>.

       <b>-report</b>
           Dump full command line and log output to a file named "<u>program</u>-<u>YYYYMMDD</u>-<u>HHMMSS</u>.log"  in  the  current
           directory.  This file can be useful for bug reports.  It also implies "-loglevel debug".

           Setting  the  environment  variable  <b>FFREPORT</b>  to  any  value  has the same effect. If the value is a
           ':'-separated key=value sequence, these options will affect the report; option values must be escaped
           if they contain special characters or the options delimiter ':' (see  the  ``Quoting  and  escaping''
           section in the ffmpeg-utils manual).

           The following options are recognized:

           <b>file</b>
               set  the  file  name  to  use  for  the  report; %p is expanded to the name of the program, %t is
               expanded to a timestamp, "%%" is expanded to a plain "%"

           <b>level</b>
               set the log verbosity level using a numerical value (see "-loglevel").

           For example, to output a report to a file named <u>ffreport.log</u> using a log level of 32 (alias  for  log
           level "info"):

                   FFREPORT=file=ffreport.log:level=32 ffmpeg -i input output

           Errors in parsing the environment variable are not fatal, and will not appear in the report.

       <b>-hide_banner</b>
           Suppress printing banner.

           All  FFmpeg  tools  will  normally  show a copyright notice, build options and library versions. This
           option can be used to suppress printing this information.

       <b>-cpuflags</b> <b>flags</b> <b>(</b><u>global</u><b>)</b>
           Allows setting and clearing cpu flags. This option is intended for testing. Do not use it unless  you
           know what you're doing.

                   ffmpeg -cpuflags -sse+mmx ...
                   ffmpeg -cpuflags mmx ...
                   ffmpeg -cpuflags 0 ...

           Possible flags for this option are:

           <b>x86</b>
               <b>mmx</b>
               <b>mmxext</b>
               <b>sse</b>
               <b>sse2</b>
               <b>sse2slow</b>
               <b>sse3</b>
               <b>sse3slow</b>
               <b>ssse3</b>
               <b>atom</b>
               <b>sse4.1</b>
               <b>sse4.2</b>
               <b>avx</b>
               <b>avx2</b>
               <b>xop</b>
               <b>fma3</b>
               <b>fma4</b>
               <b>3dnow</b>
               <b>3dnowext</b>
               <b>bmi1</b>
               <b>bmi2</b>
               <b>cmov</b>
           <b>ARM</b>
               <b>armv5te</b>
               <b>armv6</b>
               <b>armv6t2</b>
               <b>vfp</b>
               <b>vfpv3</b>
               <b>neon</b>
               <b>setend</b>
           <b>AArch64</b>
               <b>armv8</b>
               <b>vfp</b>
               <b>neon</b>
           <b>PowerPC</b>
               <b>altivec</b>
           <b>Specific</b> <b>Processors</b>
               <b>pentium2</b>
               <b>pentium3</b>
               <b>pentium4</b>
               <b>k6</b>
               <b>k62</b>
               <b>athlon</b>
               <b>athlonxp</b>
               <b>k8</b>
       <b>-cpucount</b> <u>count</u> <b>(</b><u>global</u><b>)</b>
           Override  detection  of CPU count. This option is intended for testing. Do not use it unless you know
           what you're doing.

                   ffmpeg -cpucount 2

       <b>-max_alloc</b> <u>bytes</u>
           Set the maximum size limit for allocating a block on the heap by ffmpeg's family of malloc functions.
           Exercise <b>extreme</b> <b>caution</b> when using this option.  Don't  use  if  you  do  not  understand  the  full
           consequence of doing so.  Default is INT_MAX.

   <b>AVOptions</b>
       These  options are provided directly by the libavformat, libavdevice and libavcodec libraries. To see the
       list of available AVOptions, use the <b>-help</b> option. They are separated into two categories:

       <b>generic</b>
           These options can be set for any container,  codec  or  device.  Generic  options  are  listed  under
           AVFormatContext options for containers/devices and under AVCodecContext options for codecs.

       <b>private</b>
           These  options are specific to the given container, device or codec. Private options are listed under
           their corresponding containers/devices/codecs.

       For example to write an ID3v2.3 header instead of a default ID3v2.4 to an MP3 file, use the <b>id3v2_version</b>
       private option of the MP3 muxer:

               ffmpeg -i input.flac -id3v2_version 3 out.mp3

       All codec AVOptions are per-stream, and thus a stream specifier should be attached to them:

               ffmpeg -i multichannel.mxf -map 0:v:0 -map 0:a:0 -map 0:a:0 -c:a:0 ac3 -b:a:0 640k -ac:a:1 2 -c:a:1 aac -b:2 128k out.mp4

       In the above example, a multichannel audio stream is mapped twice for  output.   The  first  instance  is
       encoded with codec ac3 and bitrate 640k.  The second instance is downmixed to 2 channels and encoded with
       codec aac. A bitrate of 128k is specified for it using absolute index of the output stream.

       Note: the <b>-nooption</b> syntax cannot be used for boolean AVOptions, use <b>-option</b> <b>0</b>/<b>-option</b> <b>1</b>.

       Note: the old undocumented way of specifying per-stream AVOptions by prepending v/a/s to the options name
       is now obsolete and will be removed soon.

   <b>Main</b> <b>options</b>
       <b>-f</b> <u>fmt</u> <b>(</b><u>input/output</u><b>)</b>
           Force  input  or output file format. The format is normally auto detected for input files and guessed
           from the file extension for output files, so this option is not needed in most cases.

       <b>-i</b> <u>url</u> <b>(</b><u>input</u><b>)</b>
           input file url

       <b>-y</b> <b>(</b><u>global</u><b>)</b>
           Overwrite output files without asking.

       <b>-n</b> <b>(</b><u>global</u><b>)</b>
           Do not overwrite output files, and exit immediately if a specified output file already exists.

       <b>-stream_loop</b> <u>number</u> <b>(</b><u>input</u><b>)</b>
           Set number of times input stream shall be looped. Loop 0 means no loop, loop -1 means infinite loop.

       <b>-recast_media</b> <b>(</b><u>global</u><b>)</b>
           Allow forcing a decoder of a different media type than the one detected or designated by the demuxer.
           Useful for decoding media data muxed as data streams.

       <b>-c[:</b><u>stream_specifier</u><b>]</b> <u>codec</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
       <b>-codec[:</b><u>stream_specifier</u><b>]</b> <u>codec</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Select an encoder (when used before an output file) or a decoder (when used before an input file) for
           one or more streams. <u>codec</u> is the name of a decoder/encoder or a special value "copy"  (output  only)
           to indicate that the stream is not to be re-encoded.

           For example

                   ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT

           encodes all video streams with libx264 and copies all audio streams.

           For each stream, the last matching "c" option is applied, so

                   ffmpeg -i INPUT -map 0 -c copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT

           will  copy all the streams except the second video, which will be encoded with libx264, and the 138th
           audio, which will be encoded with libvorbis.

       <b>-t</b> <u>duration</u> <b>(</b><u>input/output</u><b>)</b>
           When used as an input option (before "-i"), limit the <u>duration</u> of data read from the input file.

           When used as an output option (before an output url), stop writing  the  output  after  its  duration
           reaches <u>duration</u>.

           <u>duration</u>  must be a time duration specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>.

           -to and -t are mutually exclusive and -t has priority.

       <b>-to</b> <u>position</u> <b>(</b><u>input/output</u><b>)</b>
           Stop writing the output or reading  the  input  at  <u>position</u>.   <u>position</u>  must  be  a  time  duration
           specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>.

           -to and -t are mutually exclusive and -t has priority.

       <b>-fs</b> <u>limit_size</u> <b>(</b><u>output</u><b>)</b>
           Set  the file size limit, expressed in bytes. No further chunk of bytes is written after the limit is
           exceeded. The size of the output file is slightly more than the requested file size.

       <b>-ss</b> <u>position</u> <b>(</b><u>input/output</u><b>)</b>
           When used as an input option (before "-i"), seeks in this input file to <u>position</u>. Note that  in  most
           formats  it  is  not  possible  to seek exactly, so <b>ffmpeg</b> will seek to the closest seek point before
           <u>position</u>.  When transcoding and <b>-accurate_seek</b> is enabled (the default), this extra  segment  between
           the  seek  point  and  <u>position</u>  will  be  decoded  and  discarded.  When  doing  stream copy or when
           <b>-noaccurate_seek</b> is used, it will be preserved.

           When used as an output option (before an output url), decodes but discards input until the timestamps
           reach <u>position</u>.

           <u>position</u> must be a time duration specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b>  <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>.

       <b>-sseof</b> <u>position</u> <b>(</b><u>input</u><b>)</b>
           Like  the  "-ss" option but relative to the "end of file". That is negative values are earlier in the
           file, 0 is at EOF.

       <b>-isync</b> <u>input_index</u> <b>(</b><u>input</u><b>)</b>
           Assign an input as a sync source.

           This will take the difference between the start times of the target and reference inputs  and  offset
           the  timestamps of the target file by that difference. The source timestamps of the two inputs should
           derive from the same clock source for expected results. If "copyts" is set then "start_at_zero"  must
           also be set. If either of the inputs has no starting timestamp then no sync adjustment is made.

           Acceptable  values  are  those that refer to a valid ffmpeg input index. If the sync reference is the
           target index itself or <u>-1</u>, then no adjustment is made to target timestamps. A sync reference may  not
           itself be synced to any other input.

           Default value is <u>-1</u>.

       <b>-itsoffset</b> <u>offset</u> <b>(</b><u>input</u><b>)</b>
           Set the input time offset.

           <u>offset</u>  must  be  a time duration specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>.

           The offset is added to the timestamps of the input files. Specifying a positive offset means that the
           corresponding streams are delayed by the time duration specified in <u>offset</u>.

       <b>-itsscale</b> <u>scale</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Rescale input timestamps. <u>scale</u> should be a floating point number.

       <b>-timestamp</b> <u>date</u> <b>(</b><u>output</u><b>)</b>
           Set the recording timestamp in the container.

           <u>date</u> must be a date specification, see <b>the</b> <b>Date</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>.

       <b>-metadata[:metadata_specifier]</b> <u>key</u><b>=</b><u>value</u> <b>(</b><u>output,per-metadata</u><b>)</b>
           Set a metadata key/value pair.

           An optional <u>metadata_specifier</u> may be given to set metadata on streams,  chapters  or  programs.  See
           "-map_metadata" documentation for details.

           This  option  overrides  metadata set with "-map_metadata". It is also possible to delete metadata by
           using an empty value.

           For example, for setting the title in the output file:

                   ffmpeg -i in.avi -metadata title="my title" out.flv

           To set the language of the first audio stream:

                   ffmpeg -i INPUT -metadata:s:a:0 language=eng OUTPUT

       <b>-disposition[:stream_specifier]</b> <u>value</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Sets the disposition for a stream.

           By default, the disposition is copied from the input stream, unless the  output  stream  this  option
           applies to is fed by a complex filtergraph - in that case the disposition is unset by default.

           <u>value</u> is a sequence of items separated by '+' or '-'. The first item may also be prefixed with '+' or
           '-', in which case this option modifies the default value. Otherwise (the first item is not prefixed)
           this options overrides the default value. A '+' prefix adds the given disposition, '-' removes it. It
           is also possible to clear the disposition by setting it to 0.

           If  no  "-disposition"  options  were specified for an output file, ffmpeg will automatically set the
           'default' disposition on the first stream of each type, when there are multiple streams of this  type
           in the output file and no stream of that type is already marked as default.

           The "-dispositions" option lists the known dispositions.

           For example, to make the second audio stream the default stream:

                   ffmpeg -i in.mkv -c copy -disposition:a:1 default out.mkv

           To  make  the  second  subtitle stream the default stream and remove the default disposition from the
           first subtitle stream:

                   ffmpeg -i in.mkv -c copy -disposition:s:0 0 -disposition:s:1 default out.mkv

           To add an embedded cover/thumbnail:

                   ffmpeg -i in.mp4 -i IMAGE -map 0 -map 1 -c copy -c:v:1 png -disposition:v:1 attached_pic out.mp4

           Not all muxers support embedded thumbnails, and those who do, only support a few formats,  like  JPEG
           or PNG.

       <b>-program</b> <b>[title=</b><u>title</u><b>:][program_num=</b><u>program_num</u><b>:]st=</b><u>stream</u><b>[:st=</b><u>stream</u><b>...]</b> <b>(</b><u>output</u><b>)</b>
           Creates a program with the specified <u>title</u>, <u>program_num</u> and adds the specified <u>stream</u>(s) to it.

       <b>-stream_group</b>
       <b>[map=</b><u>input_file_id</u><b>=</b><u>stream_group</u><b>][type=</b><u>type</u><b>:]st=</b><u>stream</u><b>[:st=</b><u>stream</u><b>][:stg=</b><u>stream_group</u><b>][:id=</b><u>stream_group_id</u><b>...]</b>
       <b>(</b><u>output</u><b>)</b>
           Creates  a  stream  group  of  the  specified <u>type</u> and <u>stream_group_id</u>, or by <u>map</u>ping an input group,
           adding the specified <u>stream</u>(s) and/or previously defined <u>stream_group</u>(s) to it.

           <u>type</u> can be one of the following:

           <b>iamf_audio_element</b>
               Groups <u>stream</u>s that belong to the same IAMF Audio Element

               For this group <u>type</u>, the following options are available

               <b>audio_element_type</b>
                   The Audio Element type. The following values are supported:

                   <b>channel</b>
                       Scalable channel audio representation

                   <b>scene</b>
                       Ambisonics representation

               <b>demixing</b>
                   Demixing information used to reconstruct  a  scalable  channel  audio  representation.   This
                   option must be separated from the rest with a ',', and takes the following key=value options

                   <b>parameter_id</b>
                       An identifier parameters blocks in frames may refer to

                   <b>dmixp_mode</b>
                       A pre-defined combination of demixing parameters

               <b>recon_gain</b>
                   Recon  gain  information  used  to reconstruct a scalable channel audio representation.  This
                   option must be separated from the rest with a ',', and takes the following key=value options

                   <b>parameter_id</b>
                       An identifier parameters blocks in frames may refer to

               <b>layer</b>
                   A layer defining a Channel Layout in the Audio Element.  This option must be  separated  from
                   the  rest  with a ','. Several ',' separated entries can be defined, and at least one must be
                   set.

                   It takes the following ":"-separated key=value options

                   <b>ch_layout</b>
                       The layer's channel layout

                   <b>flags</b>
                       The following flags are available:

                       <b>recon_gain</b>
                           Wether to signal if recon_gain is present as  metadata  in  parameter  blocks  within
                           frames

                   <b>output_gain</b>
                   <b>output_gain_flags</b>
                       Which channels output_gain applies to. The following flags are available:

                       <b>FL</b>
                       <b>FR</b>
                       <b>BL</b>
                       <b>BR</b>
                       <b>TFL</b>
                       <b>TFR</b>
                   <b>ambisonics_mode</b>
                       The ambisonics mode. This has no effect if audio_element_type is set to channel.

                       The following values are supported:

                       <b>mono</b>
                           Each ambisonics channel is coded as an individual mono stream in the group

               <b>default_w</b>
                   Default weight value

           <b>iamf_mix_presentation</b>
               Groups <u>stream</u>s that belong to all IAMF Audio Element the same IAMF Mix Presentation references

               For this group <u>type</u>, the following options are available

               <b>submix</b>
                   A  sub-mix  within  the Mix Presentation.  This option must be separated from the rest with a
                   ','. Several ',' separated entries can be defined, and at least one must be set.

                   It takes the following ":"-separated key=value options

                   <b>parameter_id</b>
                       An identifier parameters blocks in frames may refer to,  for  post-processing  the  mixed
                       audio signal to generate the audio signal for playback

                   <b>parameter_rate</b>
                       The  sample  rate  duration  fields  in  parameters  blocks  in frames that refer to this
                       <u>parameter_id</u> are expressed as

                   <b>default_mix_gain</b>
                       Default mix gain value to apply when there are  no  parameter  blocks  sharing  the  same
                       <u>parameter_id</u> for a given frame

                   <b>element</b>
                       References  an  Audio  Element used in this Mix Presentation to generate the final output
                       audio signal for playback.  This option must be separated  from  the  rest  with  a  '|'.
                       Several '|' separated entries can be defined, and at least one must be set.

                       It takes the following ":"-separated key=value options:

                       <b>stg</b> The <u>stream_group_id</u> for an Audio Element which this sub-mix refers to

                       <b>parameter_id</b>
                           An  identifier  parameters blocks in frames may refer to, for applying any processing
                           to the referenced and rendered Audio Element before being summed with other processed
                           Audio Elements

                       <b>parameter_rate</b>
                           The sample rate duration fields in parameters blocks in frames  that  refer  to  this
                           <u>parameter_id</u> are expressed as

                       <b>default_mix_gain</b>
                           Default  mix  gain value to apply when there are no parameter blocks sharing the same
                           <u>parameter_id</u> for a given frame

                       <b>annotations</b>
                           A key=value string describing the sub-mix element where "key" is a string  conforming
                           to  BCP-47 that specifies the language for the "value" string. "key" must be the same
                           as the one in the mix's <u>annotations</u>

                       <b>headphones_rendering_mode</b>
                           Indicates whether the  input  channel-based  Audio  Element  is  rendered  to  stereo
                           loudspeakers  or spatialized with a binaural renderer when played back on headphones.
                           This has no effect if the referenced Audio Element's  <u>audio_element_type</u>  is  set  to
                           channel.

                           The following values are supported:

                           <b>stereo</b>
                           <b>binaural</b>
                   <b>layout</b>
                       Specifies  the  layouts  for this sub-mix on which the loudness information was measured.
                       This option must be separated from the rest with a '|'. Several '|' separated entries can
                       be defined, and at least one must be set.

                       It takes the following ":"-separated key=value options:

                       <b>layout_type</b>
                           <b>loudspeakers</b>
                               The layout follows the loudspeaker sound system convention of ITU-2051-3.

                           <b>binaural</b>
                               The layout is binaural.

                       <b>sound_system</b>
                           Channel layout matching one of Sound Systems A to J of  ITU-2051-3,  plus  7.1.2  and
                           3.1.2 This has no effect if <u>layout_type</u> is set to binaural.

                       <b>integrated_loudness</b>
                           The program integrated loudness information, as defined in ITU-1770-4.

                       <b>digital_peak</b>
                           The digital (sampled) peak value of the audio signal, as defined in ITU-1770-4.

                       <b>true_peak</b>
                           The true peak of the audio signal, as defined in ITU-1770-4.

                       <b>dialog_anchored_loudness</b>
                           The Dialogue loudness information, as defined in ITU-1770-4.

                       <b>album_anchored_loudness</b>
                           The Album loudness information, as defined in ITU-1770-4.

               <b>annotations</b>
                   A  key=value  string  string  describing the mix where "key" is a string conforming to BCP-47
                   that specifies the language for the "value" string. "key" must be the same as the ones in all
                   sub-mix element's <u>annotations</u>s

           E.g. to create an scalable 5.1 IAMF file from several WAV input files

                   ffmpeg -i front.wav -i back.wav -i center.wav -i lfe.wav
                   -map 0:0 -map 1:0 -map 2:0 -map 3:0 -c:a opus
                   -stream_group type=iamf_audio_element:id=1:st=0:st=1:st=2:st=3,
                   demixing=parameter_id=998,
                   recon_gain=parameter_id=101,
                   layer=ch_layout=stereo,
                   layer=ch_layout=5.1,
                   -stream_group type=iamf_mix_presentation:id=2:stg=0:annotations=en-us=Mix_Presentation,
                   submix=parameter_id=100:parameter_rate=48000|element=stg=0:parameter_id=100:annotations=en-us=Scalable_Submix|layout=sound_system=stereo|layout=sound_system=5.1
                   -streamid 0:0 -streamid 1:1 -streamid 2:2 -streamid 3:3 output.iamf

           To copy the two stream groups (Audio Element and Mix Presentation) from an input IAMF file with  four
           streams into an mp4 output

                   ffmpeg -i input.iamf -c:a copy -stream_group map=0=0:st=0:st=1:st=2:st=3 -stream_group map=0=1:stg=0
                   -streamid 0:0 -streamid 1:1 -streamid 2:2 -streamid 3:3 output.mp4

       <b>-target</b> <u>type</u> <b>(</b><u>output</u><b>)</b>
           Specify  target  file  type  ("vcd",  "svcd", "dvd", "dv", "dv50"). <u>type</u> may be prefixed with "pal-",
           "ntsc-" or "film-" to use the corresponding standard. All the format options (bitrate, codecs, buffer
           sizes) are then set automatically. You can just type:

                   ffmpeg -i myfile.avi -target vcd /tmp/vcd.mpg

           Nevertheless you can specify additional options as long as you know they do  not  conflict  with  the
           standard, as in:

                   ffmpeg -i myfile.avi -target vcd -bf 2 /tmp/vcd.mpg

           The parameters set for each target are as follows.

           <b>VCD</b>

                   &lt;pal&gt;:
                   -f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324
                   -s 352x288 -r 25
                   -codec:v mpeg1video -g 15 -b:v 1150k -maxrate:v 1150k -minrate:v 1150k -bufsize:v 327680
                   -ar 44100 -ac 2
                   -codec:a mp2 -b:a 224k

                   &lt;ntsc&gt;:
                   -f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324
                   -s 352x240 -r 30000/1001
                   -codec:v mpeg1video -g 18 -b:v 1150k -maxrate:v 1150k -minrate:v 1150k -bufsize:v 327680
                   -ar 44100 -ac 2
                   -codec:a mp2 -b:a 224k

                   &lt;film&gt;:
                   -f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324
                   -s 352x240 -r 24000/1001
                   -codec:v mpeg1video -g 18 -b:v 1150k -maxrate:v 1150k -minrate:v 1150k -bufsize:v 327680
                   -ar 44100 -ac 2
                   -codec:a mp2 -b:a 224k

           <b>SVCD</b>

                   &lt;pal&gt;:
                   -f svcd -packetsize 2324
                   -s 480x576 -pix_fmt yuv420p -r 25
                   -codec:v mpeg2video -g 15 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1
                   -ar 44100
                   -codec:a mp2 -b:a 224k

                   &lt;ntsc&gt;:
                   -f svcd -packetsize 2324
                   -s 480x480 -pix_fmt yuv420p -r 30000/1001
                   -codec:v mpeg2video -g 18 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1
                   -ar 44100
                   -codec:a mp2 -b:a 224k

                   &lt;film&gt;:
                   -f svcd -packetsize 2324
                   -s 480x480 -pix_fmt yuv420p -r 24000/1001
                   -codec:v mpeg2video -g 18 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1
                   -ar 44100
                   -codec:a mp2 -b:a 224k

           <b>DVD</b>

                   &lt;pal&gt;:
                   -f dvd -muxrate 10080k -packetsize 2048
                   -s 720x576 -pix_fmt yuv420p -r 25
                   -codec:v mpeg2video -g 15 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008
                   -ar 48000
                   -codec:a ac3 -b:a 448k

                   &lt;ntsc&gt;:
                   -f dvd -muxrate 10080k -packetsize 2048
                   -s 720x480 -pix_fmt yuv420p -r 30000/1001
                   -codec:v mpeg2video -g 18 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008
                   -ar 48000
                   -codec:a ac3 -b:a 448k

                   &lt;film&gt;:
                   -f dvd -muxrate 10080k -packetsize 2048
                   -s 720x480 -pix_fmt yuv420p -r 24000/1001
                   -codec:v mpeg2video -g 18 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008
                   -ar 48000
                   -codec:a ac3 -b:a 448k

           <b>DV</b>

                   &lt;pal&gt;:
                   -f dv
                   -s 720x576 -pix_fmt yuv420p -r 25
                   -ar 48000 -ac 2

                   &lt;ntsc&gt;:
                   -f dv
                   -s 720x480 -pix_fmt yuv411p -r 30000/1001
                   -ar 48000 -ac 2

                   &lt;film&gt;:
                   -f dv
                   -s 720x480 -pix_fmt yuv411p -r 24000/1001
                   -ar 48000 -ac 2

           The  "dv50"  target is identical to the "dv" target except that the pixel format set is "yuv422p" for
           all three standards.

           Any user-set value for a parameter above will override the target preset value.  In  that  case,  the
           output may not comply with the target standard.

       <b>-dn</b> <b>(</b><u>input/output</u><b>)</b>
           As  an  input  option,  blocks  all data streams of a file from being filtered or being automatically
           selected or mapped for any output. See "-discard" option to disable streams individually.

           As an output option, disables data recording i.e. automatic selection or mapping of any data  stream.
           For full manual control see the "-map" option.

       <b>-dframes</b> <u>number</u> <b>(</b><u>output</u><b>)</b>
           Set  the number of data frames to output. This is an obsolete alias for "-frames:d", which you should
           use instead.

       <b>-frames[:</b><u>stream_specifier</u><b>]</b> <u>framecount</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Stop writing to the stream after <u>framecount</u> frames.

       <b>-q[:</b><u>stream_specifier</u><b>]</b> <u>q</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-qscale[:</b><u>stream_specifier</u><b>]</b> <u>q</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Use fixed quality scale (VBR). The meaning of <u>q</u>/<u>qscale</u> is codec-dependent.  If <u>qscale</u> is used without
           a <u>stream_specifier</u> then it applies only to the video stream, this is to maintain  compatibility  with
           previous behavior and as specifying the same codec specific value to 2 different codecs that is audio
           and video generally is not what is intended when no stream_specifier is used.

       <b>-filter[:</b><u>stream_specifier</u><b>]</b> <u>filtergraph</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Create the filtergraph specified by <u>filtergraph</u> and use it to filter the stream.

           <u>filtergraph</u>  is a description of the filtergraph to apply to the stream, and must have a single input
           and a single output of the same type of the stream. In the filtergraph, the input  is  associated  to
           the label "in", and the output to the label "out". See the ffmpeg-filters manual for more information
           about the filtergraph syntax.

           See  the  <b>-filter_complex</b>  <b>option</b>  if  you  want  to  create filtergraphs with multiple inputs and/or
           outputs.

       <b>-reinit_filter[:</b><u>stream_specifier</u><b>]</b> <u>integer</u> <b>(</b><u>input,per-stream</u><b>)</b>
           This boolean option determines if the filtergraph(s) to which this stream is fed  gets  reinitialized
           when  input  frame  parameters change mid-stream. This option is enabled by default as most video and
           all audio filters cannot handle deviation in input frame properties.  Upon reinitialization, existing
           filter state is lost, like e.g. the frame count "n" reference available in some filters.  Any  frames
           buffered   at   time   of  reinitialization  are  lost.   The  properties  where  a  change  triggers
           reinitialization are, for video, frame resolution or pixel format; for audio, sample  format,  sample
           rate, channel count or channel layout.

       <b>-filter_threads</b> <u>nb_threads</u> <b>(</b><u>global</u><b>)</b>
           Defines  how  many threads are used to process a filter pipeline. Each pipeline will produce a thread
           pool with this many threads available  for  parallel  processing.   The  default  is  the  number  of
           available CPUs.

       <b>-pre[:</b><u>stream_specifier</u><b>]</b> <u>preset_name</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Specify the preset for matching stream(s).

       <b>-stats</b> <b>(</b><u>global</u><b>)</b>
           Print encoding progress/statistics. It is on by default, to explicitly disable it you need to specify
           "-nostats".

       <b>-stats_period</b> <u>time</u> <b>(</b><u>global</u><b>)</b>
           Set period at which encoding progress/statistics are updated. Default is 0.5 seconds.

       <b>-progress</b> <u>url</u> <b>(</b><u>global</u><b>)</b>
           Send program-friendly progress information to <u>url</u>.

           Progress  information  is  written periodically and at the end of the encoding process. It is made of
           "<u>key</u>=<u>value</u>" lines. <u>key</u> consists of only alphanumeric characters.  The  last  key  of  a  sequence  of
           progress information is always "progress".

           The update period is set using "-stats_period".

       <b>-stdin</b>
           Enable  interaction  on  standard  input. On by default unless standard input is used as an input. To
           explicitly disable interaction you need to specify "-nostdin".

           Disabling interaction on standard input is useful, for  example,  if  ffmpeg  is  in  the  background
           process  group. Roughly the same result can be achieved with "ffmpeg ... &lt; /dev/null" but it requires
           a shell.

       <b>-debug_ts</b> <b>(</b><u>global</u><b>)</b>
           Print timestamp/latency information. It is off by default. This option is mostly useful  for  testing
           and  debugging  purposes,  and the output format may change from one version to another, so it should
           not be employed by portable scripts.

           See also the option "-fdebug ts".

       <b>-attach</b> <u>filename</u> <b>(</b><u>output</u><b>)</b>
           Add an attachment to the output file. This is supported by a few formats like Matroska for e.g. fonts
           used in rendering subtitles. Attachments are implemented as a specific type of stream, so this option
           will add a new stream to the file. It is then possible to use per-stream options on  this  stream  in
           the  usual  way.  Attachment  streams  created  with  this option will be created after all the other
           streams (i.e. those created with "-map" or automatic mappings).

           Note that for Matroska you also have to set the mimetype metadata tag:

                   ffmpeg -i INPUT -attach DejaVuSans.ttf -metadata:s:2 mimetype=application/x-truetype-font out.mkv

           (assuming that the attachment stream will be third in the output file).

       <b>-dump_attachment[:</b><u>stream_specifier</u><b>]</b> <u>filename</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Extract the matching attachment stream into a file named <u>filename</u>. If <u>filename</u>  is  empty,  then  the
           value of the "filename" metadata tag will be used.

           E.g. to extract the first attachment to a file named 'out.ttf':

                   ffmpeg -dump_attachment:t:0 out.ttf -i INPUT

           To extract all attachments to files determined by the "filename" tag:

                   ffmpeg -dump_attachment:t "" -i INPUT

           Technical note -- attachments are implemented as codec extradata, so this option can actually be used
           to extract extradata from any stream, not just attachments.

   <b>Video</b> <b>Options</b>
       <b>-vframes</b> <u>number</u> <b>(</b><u>output</u><b>)</b>
           Set the number of video frames to output. This is an obsolete alias for "-frames:v", which you should
           use instead.

       <b>-r[:</b><u>stream_specifier</u><b>]</b> <u>fps</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set frame rate (Hz value, fraction or abbreviation).

           As an input option, ignore any timestamps stored in the file and instead generate timestamps assuming
           constant  frame  rate <u>fps</u>.  This is not the same as the <b>-framerate</b> option used for some input formats
           like image2 or v4l2 (it used to be the same in older versions of FFmpeg).  If in doubt use <b>-framerate</b>
           instead of the input option <b>-r</b>.

           As an output option:

           <b>video</b> <b>encoding</b>
               Duplicate or drop frames right before encoding them to achieve constant output frame rate <u>fps</u>.

           <b>video</b> <b>streamcopy</b>
               Indicate to the muxer that <u>fps</u> is the stream frame rate. No data is dropped or duplicated in this
               case. This may produce invalid files if <u>fps</u> does not  match  the  actual  stream  frame  rate  as
               determined by packet timestamps.  See also the "setts" bitstream filter.

       <b>-fpsmax[:</b><u>stream_specifier</u><b>]</b> <u>fps</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set maximum frame rate (Hz value, fraction or abbreviation).

           Clamps  output frame rate when output framerate is auto-set and is higher than this value.  Useful in
           batch processing or when input framerate is wrongly detected as very high.  It cannot be set together
           with "-r". It is ignored during streamcopy.

       <b>-s[:</b><u>stream_specifier</u><b>]</b> <u>size</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set frame size.

           As an input option, this is a shortcut for the <b>video_size</b> private option, recognized by some demuxers
           for which the frame size is either not stored in the file or is configurable --  e.g.  raw  video  or
           video grabbers.

           As  an  output  option,  this  inserts  the  "scale"  video  filter  to  the <u>end</u> of the corresponding
           filtergraph. Please use the "scale" filter directly to insert it  at  the  beginning  or  some  other
           place.

           The format is <b>wxh</b> (default - same as source).

       <b>-aspect[:</b><u>stream_specifier</u><b>]</b> <u>aspect</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set the video display aspect ratio specified by <u>aspect</u>.

           <u>aspect</u>  can be a floating point number string, or a string of the form <u>num</u>:<u>den</u>, where <u>num</u> and <u>den</u> are
           the numerator and denominator of the aspect ratio. For example "4:3", "16:9", "1.3333", and  "1.7777"
           are valid argument values.

           If  used  together  with <b>-vcodec</b> <b>copy</b>, it will affect the aspect ratio stored at container level, but
           not the aspect ratio stored in encoded frames, if it exists.

       <b>-display_rotation[:</b><u>stream_specifier</u><b>]</b> <u>rotation</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Set video rotation metadata.

           <u>rotation</u> is a decimal number specifying the amount in degree by which the  video  should  be  rotated
           counter-clockwise before being displayed.

           This  option  overrides  the rotation/display transform metadata stored in the file, if any. When the
           video is being transcoded (rather than copied) and  "-autorotate"  is  enabled,  the  video  will  be
           rotated  at  the filtering stage. Otherwise, the metadata will be written into the output file if the
           muxer supports it.

           If the "-display_hflip" and/or "-display_vflip"  options  are  given,  they  are  applied  after  the
           rotation specified by this option.

       <b>-display_hflip[:</b><u>stream_specifier</u><b>]</b> <b>(</b><u>input,per-stream</u><b>)</b>
           Set whether on display the image should be horizontally flipped.

           See the "-display_rotation" option for more details.

       <b>-display_vflip[:</b><u>stream_specifier</u><b>]</b> <b>(</b><u>input,per-stream</u><b>)</b>
           Set whether on display the image should be vertically flipped.

           See the "-display_rotation" option for more details.

       <b>-vn</b> <b>(</b><u>input/output</u><b>)</b>
           As  an  input  option,  blocks all video streams of a file from being filtered or being automatically
           selected or mapped for any output. See "-discard" option to disable streams individually.

           As an output option, disables video recording i.e.  automatic  selection  or  mapping  of  any  video
           stream. For full manual control see the "-map" option.

       <b>-vcodec</b> <u>codec</u> <b>(</b><u>output</u><b>)</b>
           Set the video codec. This is an alias for "-codec:v".

       <b>-pass[:</b><u>stream_specifier</u><b>]</b> <u>n</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Select  the  pass  number  (1  or 2). It is used to do two-pass video encoding. The statistics of the
           video are recorded in the first pass into a log file (see also the option -passlogfile), and  in  the
           second  pass  that log file is used to generate the video at the exact requested bitrate.  On pass 1,
           you may just deactivate audio and set output to null, examples for Windows and Unix:

                   ffmpeg -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y NUL
                   ffmpeg -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y /dev/null

       <b>-passlogfile[:</b><u>stream_specifier</u><b>]</b> <u>prefix</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set two-pass log file name prefix to <u>prefix</u>, the default file name  prefix  is  ``ffmpeg2pass''.  The
           complete file name will be <u>PREFIX-N.log</u>, where N is a number specific to the output stream

       <b>-vf</b> <u>filtergraph</u> <b>(</b><u>output</u><b>)</b>
           Create the filtergraph specified by <u>filtergraph</u> and use it to filter the stream.

           This is an alias for "-filter:v", see the <b>-filter</b> <b>option</b>.

       <b>-autorotate</b>
           Automatically  rotate  the video according to file metadata. Enabled by default, use <b>-noautorotate</b> to
           disable it.

       <b>-autoscale</b>
           Automatically scale the video according to the resolution of first frame.  Enabled  by  default,  use
           <b>-noautoscale</b>  to  disable it. When autoscale is disabled, all output frames of filter graph might not
           be in the same resolution and may  be  inadequate  for  some  encoder/muxer.  Therefore,  it  is  not
           recommended  to  disable it unless you really know what you are doing.  Disable autoscale at your own
           risk.

   <b>Advanced</b> <b>Video</b> <b>options</b>
       <b>-pix_fmt[:</b><u>stream_specifier</u><b>]</b> <u>format</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set pixel format. Use "-pix_fmts" to show all the supported pixel formats.   If  the  selected  pixel
           format can not be selected, ffmpeg will print a warning and select the best pixel format supported by
           the  encoder.  If <u>pix_fmt</u> is prefixed by a "+", ffmpeg will exit with an error if the requested pixel
           format can not be selected, and automatic conversions inside filtergraphs are disabled.   If  <u>pix_fmt</u>
           is  a  single  "+", ffmpeg selects the same pixel format as the input (or graph output) and automatic
           conversions are disabled.

       <b>-sws_flags</b> <u>flags</u> <b>(</b><u>input/output</u><b>)</b>
           Set default flags for the libswscale library. These flags are used by automatically inserted  "scale"
           filters and those within simple filtergraphs, if not overridden within the filtergraph definition.

           See the <b>ffmpeg-scaler</b> <b>manual</b> for a list of scaler options.

       <b>-rc_override[:</b><u>stream_specifier</u><b>]</b> <u>override</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Rate control override for specific intervals, formatted as "int,int,int" list separated with slashes.
           Two  first  values are the beginning and end frame numbers, last one is quantizer to use if positive,
           or quality factor if negative.

       <b>-vstats</b>
           Dump video coding statistics to <u>vstats_HHMMSS.log</u>. See the <b>vstats</b> <b>file</b> <b>format</b> section for the  format
           description.

       <b>-vstats_file</b> <u>file</u>
           Dump video coding statistics to <u>file</u>. See the <b>vstats</b> <b>file</b> <b>format</b> section for the format description.

       <b>-vstats_version</b> <u>file</u>
           Specify  which  version of the vstats format to use. Default is 2. See the <b>vstats</b> <b>file</b> <b>format</b> section
           for the format description.

       <b>-vtag</b> <u>fourcc/tag</u> <b>(</b><u>output</u><b>)</b>
           Force video tag/fourcc. This is an alias for "-tag:v".

       <b>-force_key_frames[:</b><u>stream_specifier</u><b>]</b> <u>time</u><b>[,</b><u>time</u><b>...]</b> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-force_key_frames[:</b><u>stream_specifier</u><b>]</b> <b>expr:</b><u>expr</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-force_key_frames[:</b><u>stream_specifier</u><b>]</b> <b>source</b> <b>(</b><u>output,per-stream</u><b>)</b>
           <u>force_key_frames</u> can take arguments of the following form:

           <u>time</u><b>[,</b><u>time</u><b>...]</b>
               If the argument consists of timestamps, ffmpeg will round the  specified  times  to  the  nearest
               output  timestamp  as  per  the  encoder time base and force a keyframe at the first frame having
               timestamp equal or greater than the computed timestamp. Note that if the encoder time base is too
               coarse, then the keyframes may be forced on frames with timestamps lower than the specified time.
               The default encoder time base is the inverse of the output framerate but may be set otherwise via
               "-enc_time_base".

               If one of the times is ""chapters"[<u>delta</u>]", it is expanded into the time of the beginning of  all
               chapters  in  the  file,  shifted  by  <u>delta</u>, expressed as a time in seconds.  This option can be
               useful to ensure that a seek point is present at a chapter mark or any other designated place  in
               the output file.

               For  example, to insert a key frame at 5 minutes, plus key frames 0.1 second before the beginning
               of every chapter:

                       -force_key_frames 0:05:00,chapters-0.1

           <b>expr:</b><u>expr</u>
               If the argument is prefixed with "expr:", the string <u>expr</u> is interpreted like an  expression  and
               is evaluated for each frame. A key frame is forced in case the evaluation is non-zero.

               The expression in <u>expr</u> can contain the following constants:

               <b>n</b>   the number of current processed frame, starting from 0

               <b>n_forced</b>
                   the number of forced frames

               <b>prev_forced_n</b>
                   the number of the previous forced frame, it is "NAN" when no keyframe was forced yet

               <b>prev_forced_t</b>
                   the time of the previous forced frame, it is "NAN" when no keyframe was forced yet

               <b>t</b>   the time of the current processed frame

               For example to force a key frame every 5 seconds, you can specify:

                       -force_key_frames expr:gte(t,n_forced*5)

               To force a key frame 5 seconds after the time of the last forced one, starting from second 13:

                       -force_key_frames expr:if(isnan(prev_forced_t),gte(t,13),gte(t,prev_forced_t+5))

           <b>source</b>
               If  the argument is "source", ffmpeg will force a key frame if the current frame being encoded is
               marked as a key frame in its source.  In cases where this  particular  source  frame  has  to  be
               dropped, enforce the next available frame to become a key frame instead.

           Note  that  forcing  too  many  keyframes  is  very  harmful  for the lookahead algorithms of certain
           encoders: using fixed-GOP options or similar would be more efficient.

       <b>-apply_cropping[:</b><u>stream_specifier</u><b>]</b> <u>source</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Automatically crop the video after decoding according to file metadata.  Default is <u>all</u>.

           <b>none</b> <b>(0)</b>
               Don't apply any cropping metadata.

           <b>all</b> <b>(1)</b>
               Apply both codec and container level croppping. This is the default mode.

           <b>codec</b> <b>(2)</b>
               Apply codec level croppping.

           <b>container</b> <b>(3)</b>
               Apply container level croppping.

       <b>-copyinkf[:</b><u>stream_specifier</u><b>]</b> <b>(</b><u>output,per-stream</u><b>)</b>
           When doing stream copy, copy also non-key frames found at the beginning.

       <b>-init_hw_device</b> <u>type</u><b>[=</b><u>name</u><b>][:</b><u>device</u><b>[,</b><u>key=value</u><b>...]]</b>
           Initialise a new hardware device of type <u>type</u> called <u>name</u>, using the given device parameters.  If  no
           name is specified it will receive a default name of the form "<u>type</u>%d".

           The meaning of <u>device</u> and the following arguments depends on the device type:

           <b>cuda</b>
               <u>device</u> is the number of the CUDA device.

               The following options are recognized:

               <b>primary_ctx</b>
                   If set to 1, uses the primary device context instead of creating a new one.

               Examples:

               <u>-init_hw_device</u> <u>cuda:1</u>
                   Choose the second device on the system.

               <u>-init_hw_device</u> <u>cuda:0,primary_ctx=1</u>
                   Choose the first device and use the primary device context.

           <b>dxva2</b>
               <u>device</u> is the number of the Direct3D 9 display adapter.

           <b>d3d11va</b>
               <u>device</u>  is  the  number of the Direct3D 11 display adapter.  If not specified, it will attempt to
               use the default Direct3D 11 display adapter or  the  first  Direct3D  11  display  adapter  whose
               hardware VendorId is specified by <b>vendor_id</b>.

               Examples:

               <u>-init_hw_device</u> <u>d3d11va</u>
                   Create a d3d11va device on the default Direct3D 11 display adapter.

               <u>-init_hw_device</u> <u>d3d11va:1</u>
                   Create a d3d11va device on the Direct3D 11 display adapter specified by index 1.

               <u>-init_hw_device</u> <u>d3d11va:,vendor_id=0x8086</u>
                   Create  a  d3d11va device on the first Direct3D 11 display adapter whose hardware VendorId is
                   0x8086.

           <b>vaapi</b>
               <u>device</u> is either an X11 display name, a DRM render node or  a  DirectX  adapter  index.   If  not
               specified,  it  will  attempt  to  open the default X11 display (<u>$DISPLAY</u>) and then the first DRM
               render node (<u>/dev/dri/renderD128</u>), or the default DirectX adapter on Windows.

               The following options are recognized:

               <b>kernel_driver</b>
                   When <u>device</u> is not specified, use this option to  specify  the  name  of  the  kernel  driver
                   associated  with  the  desired  device.  This  option  is  available  only  when the hardware
                   acceleration method <u>drm</u> and <u>vaapi</u> are enabled.

               <b>vendor_id</b>
                   When <u>device</u> and <u>kernel_driver</u> are not specified, use this option to  specify  the  vendor  id
                   associated  with  the  desired  device.  This  option  is  available  only  when the hardware
                   acceleration method <u>drm</u> and <u>vaapi</u> are enabled and <u>kernel_driver</u> is not specified.

               Examples:

               <u>-init_hw_device</u> <u>vaapi</u>
                   Create a vaapi device on the default device.

               <u>-init_hw_device</u> <u>vaapi:/dev/dri/renderD129</u>
                   Create a vaapi device on DRM render node <u>/dev/dri/renderD129</u>.

               <u>-init_hw_device</u> <u>vaapi:1</u>
                   Create a vaapi device on DirectX adapter 1.

               <u>-init_hw_device</u> <u>vaapi:,kernel_driver=i915</u>
                   Create a vaapi device on a device associated with kernel driver <b>i915</b>.

               <u>-init_hw_device</u> <u>vaapi:,vendor_id=0x8086</u>
                   Create a vaapi device on a device associated with vendor id <b>0x8086</b>.

           <b>vdpau</b>
               <u>device</u> is an X11 display name.  If not specified, it will attempt to open the default X11 display
               (<u>$DISPLAY</u>).

           <b>qsv</b> <u>device</u> selects a value in <b>MFX_IMPL_*</b>. Allowed values are:

               <b>auto</b>
               <b>sw</b>
               <b>hw</b>
               <b>auto_any</b>
               <b>hw_any</b>
               <b>hw2</b>
               <b>hw3</b>
               <b>hw4</b>

               If not specified, <b>auto_any</b> is used.  (Note that it may be easier to achieve  the  desired  result
               for  QSV  by  creating  the  platform-appropriate  subdevice (<b>dxva2</b> or <b>d3d11va</b> or <b>vaapi</b>) and then
               deriving a QSV device from that.)

               The following options are recognized:

               <b>child_device</b>
                   Specify a DRM render node on Linux or DirectX adapter on Windows.

               <b>child_device_type</b>
                   Choose platform-appropriate subdevice type. On Windows <b>d3d11va</b> is used as  default  subdevice
                   type  when  "--enable-libvpl"  is  specified  at configuration time, <b>dxva2</b> is used as default
                   subdevice type when "--enable-libmfx" is specified at configuration time. On Linux  user  can
                   use <b>vaapi</b> only as subdevice type.

               Examples:

               <u>-init_hw_device</u> <u>qsv:hw,child_device=/dev/dri/renderD129</u>
                   Create a QSV device with <b>MFX_IMPL_HARDWARE</b> on DRM render node <u>/dev/dri/renderD129</u>.

               <u>-init_hw_device</u> <u>qsv:hw,child_device=1</u>
                   Create a QSV device with <b>MFX_IMPL_HARDWARE</b> on DirectX adapter 1.

               <u>-init_hw_device</u> <u>qsv:hw,child_device_type=d3d11va</u>
                   Choose the GPU subdevice with type <b>d3d11va</b> and create QSV device with <b>MFX_IMPL_HARDWARE</b>.

               <u>-init_hw_device</u> <u>qsv:hw,child_device_type=dxva2</u>
                   Choose the GPU subdevice with type <b>dxva2</b> and create QSV device with <b>MFX_IMPL_HARDWARE</b>.

               <u>-init_hw_device</u> <u>qsv:hw,child_device=1,child_device_type=d3d11va</u>
                   Create a QSV device with <b>MFX_IMPL_HARDWARE</b> on DirectX adapter 1 with subdevice type <b>d3d11va</b>.

               <u>-init_hw_device</u> <u>vaapi=va:/dev/dri/renderD129</u> <u>-init_hw_device</u> <u>qsv=hw1@va</u>
                   Create  a  VAAPI device called <b>va</b> on <u>/dev/dri/renderD129</u>, then derive a QSV device called <b>hw1</b>
                   from device <b>va</b>.

           <b>opencl</b>
               <u>device</u> selects the platform and device as <u>platform_index.device_index</u>.

               The set of devices can also be filtered using the key-value pairs to find only  devices  matching
               particular platform or device strings.

               The strings usable as filters are:

               <b>platform_profile</b>
               <b>platform_version</b>
               <b>platform_name</b>
               <b>platform_vendor</b>
               <b>platform_extensions</b>
               <b>device_name</b>
               <b>device_vendor</b>
               <b>driver_version</b>
               <b>device_version</b>
               <b>device_profile</b>
               <b>device_extensions</b>
               <b>device_type</b>

               The indices and filters must together uniquely select a device.

               Examples:

               <u>-init_hw_device</u> <u>opencl:0.1</u>
                   Choose the second device on the first platform.

               <u>-init_hw_device</u> <u>opencl:,device_name=Foo9000</u>
                   Choose the device with a name containing the string <u>Foo9000</u>.

               <u>-init_hw_device</u> <u>opencl:1,device_type=gpu,device_extensions=cl_khr_fp16</u>
                   Choose the GPU device on the second platform supporting the <u>cl_khr_fp16</u> extension.

           <b>vulkan</b>
               If  <u>device</u>  is  an  integer,  it  selects  the  device by its index in a system-dependent list of
               devices.  If <u>device</u> is any other string, it selects the first device with a name containing  that
               string as a substring.

               The following options are recognized:

               <b>debug</b>
                   If set to 1, enables the validation layer, if installed.

               <b>linear_images</b>
                   If set to 1, images allocated by the hwcontext will be linear and locally mappable.

               <b>instance_extensions</b>
                   A plus separated list of additional instance extensions to enable.

               <b>device_extensions</b>
                   A plus separated list of additional device extensions to enable.

               Examples:

               <u>-init_hw_device</u> <u>vulkan:1</u>
                   Choose the second device on the system.

               <u>-init_hw_device</u> <u>vulkan:RADV</u>
                   Choose the first device with a name containing the string <u>RADV</u>.

               <u>-init_hw_device</u> <u>vulkan:0,instance_extensions=VK_KHR_wayland_surface+VK_KHR_xcb_surface</u>
                   Choose the first device and enable the Wayland and XCB instance extensions.

       <b>-init_hw_device</b> <u>type</u><b>[=</b><u>name</u><b>]@</b><u>source</u>
           Initialise  a new hardware device of type <u>type</u> called <u>name</u>, deriving it from the existing device with
           the name <u>source</u>.

       <b>-init_hw_device</b> <b>list</b>
           List all hardware device types supported in this build of ffmpeg.

       <b>-filter_hw_device</b> <u>name</u>
           Pass the hardware device called <u>name</u> to all filters in any filter graph.  This can be used to set the
           device to upload to with the "hwupload" filter, or the device to map  to  with  the  "hwmap"  filter.
           Other  filters  may  also  make use of this parameter when they require a hardware device.  Note that
           this is typically only required when the input is not already  in  hardware  frames  -  when  it  is,
           filters will derive the device they require from the context of the frames they receive as input.

           This is a global setting, so all filters will receive the same device.

       <b>-hwaccel[:</b><u>stream_specifier</u><b>]</b> <u>hwaccel</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Use hardware acceleration to decode the matching stream(s). The allowed values of <u>hwaccel</u> are:

           <b>none</b>
               Do not use any hardware acceleration (the default).

           <b>auto</b>
               Automatically select the hardware acceleration method.

           <b>vdpau</b>
               Use VDPAU (Video Decode and Presentation API for Unix) hardware acceleration.

           <b>dxva2</b>
               Use DXVA2 (DirectX Video Acceleration) hardware acceleration.

           <b>d3d11va</b>
               Use D3D11VA (DirectX Video Acceleration) hardware acceleration.

           <b>vaapi</b>
               Use VAAPI (Video Acceleration API) hardware acceleration.

           <b>qsv</b> Use the Intel QuickSync Video acceleration for video transcoding.

               Unlike  most  other  values,  this  option  does  not  enable  accelerated decoding (that is used
               automatically whenever a qsv decoder is selected), but accelerated transcoding,  without  copying
               the frames into the system memory.

               For  it  to  work,  both the decoder and the encoder must support QSV acceleration and no filters
               must be used.

           This option has no effect if the selected hwaccel is not available or not  supported  by  the  chosen
           decoder.

           Note  that  most  acceleration methods are intended for playback and will not be faster than software
           decoding on modern CPUs. Additionally, <b>ffmpeg</b> will usually need to copy the decoded frames  from  the
           GPU  memory into the system memory, resulting in further performance loss. This option is thus mainly
           useful for testing.

       <b>-hwaccel_device[:</b><u>stream_specifier</u><b>]</b> <u>hwaccel_device</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Select a device to use for hardware acceleration.

           This option only makes sense when the <b>-hwaccel</b> option is also specified.  It can either refer  to  an
           existing  device  created  with  <b>-init_hw_device</b>  by  name,  or  it  can  create  a  new device as if
           <b>-init_hw_device</b> <u>type</u>:<u>hwaccel_device</u> were called immediately before.

       <b>-hwaccels</b>
           List all  hardware  acceleration  components  enabled  in  this  build  of  ffmpeg.   Actual  runtime
           availability depends on the hardware and its suitable driver being installed.

       <b>-fix_sub_duration_heartbeat[:</b><u>stream_specifier</u><b>]</b>
           Set  a  specific  output  video  stream  as the heartbeat stream according to which to split and push
           through currently in-progress subtitle upon receipt of a random access packet.

           This lowers the latency of subtitles for which the end packet or the following subtitle has  not  yet
           been  received.  As a drawback, this will most likely lead to duplication of subtitle events in order
           to cover the full duration, so when dealing with use cases where latency of when the  subtitle  event
           is passed on to output is not relevant this option should not be utilized.

           Requires  <b>-fix_sub_duration</b>  to  be  set  for the relevant input subtitle stream for this to have any
           effect, as well as for the input subtitle stream having to be directly mapped to the same  output  in
           which the heartbeat stream resides.

   <b>Audio</b> <b>Options</b>
       <b>-aframes</b> <u>number</u> <b>(</b><u>output</u><b>)</b>
           Set the number of audio frames to output. This is an obsolete alias for "-frames:a", which you should
           use instead.

       <b>-ar[:</b><u>stream_specifier</u><b>]</b> <u>freq</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set  the  audio  sampling  frequency. For output streams it is set by default to the frequency of the
           corresponding input stream. For input streams this option only makes sense for audio grabbing devices
           and raw demuxers and is mapped to the corresponding demuxer options.

       <b>-aq</b> <u>q</u> <b>(</b><u>output</u><b>)</b>
           Set the audio quality (codec-specific, VBR). This is an alias for -q:a.

       <b>-ac[:</b><u>stream_specifier</u><b>]</b> <u>channels</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set the number of audio channels. For output streams it is set by default  to  the  number  of  input
           audio  channels.  For  input  streams this option only makes sense for audio grabbing devices and raw
           demuxers and is mapped to the corresponding demuxer options.

       <b>-an</b> <b>(</b><u>input/output</u><b>)</b>
           As an input option, blocks all audio streams of a file from being  filtered  or  being  automatically
           selected or mapped for any output. See "-discard" option to disable streams individually.

           As  an  output  option,  disables  audio  recording  i.e. automatic selection or mapping of any audio
           stream. For full manual control see the "-map" option.

       <b>-acodec</b> <u>codec</u> <b>(</b><u>input/output</u><b>)</b>
           Set the audio codec. This is an alias for "-codec:a".

       <b>-sample_fmt[:</b><u>stream_specifier</u><b>]</b> <u>sample_fmt</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set the audio sample format. Use "-sample_fmts" to get a list of supported sample formats.

       <b>-af</b> <u>filtergraph</u> <b>(</b><u>output</u><b>)</b>
           Create the filtergraph specified by <u>filtergraph</u> and use it to filter the stream.

           This is an alias for "-filter:a", see the <b>-filter</b> <b>option</b>.

   <b>Advanced</b> <b>Audio</b> <b>options</b>
       <b>-atag</b> <u>fourcc/tag</u> <b>(</b><u>output</u><b>)</b>
           Force audio tag/fourcc. This is an alias for "-tag:a".

       <b>-ch_layout[:</b><u>stream_specifier</u><b>]</b> <u>layout</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Alias for "-channel_layout".

       <b>-channel_layout[:</b><u>stream_specifier</u><b>]</b> <u>layout</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set the audio channel layout. For output streams it is set by default to the  input  channel  layout.
           For  input  streams  it  overrides  the  channel  layout  of  the input. Not all decoders respect the
           overridden channel layout. This option also sets the channel layout for audio  grabbing  devices  and
           raw demuxers and is mapped to the corresponding demuxer option.

       <b>-guess_layout_max</b> <u>channels</u> <b>(</b><u>input,per-stream</u><b>)</b>
           If  some  input  channel  layout  is  not  known,  try to guess only if it corresponds to at most the
           specified number of channels. For example, 2 tells to <b>ffmpeg</b> to recognize 1 channel  as  mono  and  2
           channels as stereo but not 6 channels as 5.1. The default is to always try to guess. Use 0 to disable
           all  guessing. Using the "-channel_layout" option to explicitly specify an input layout also disables
           guessing.

   <b>Subtitle</b> <b>options</b>
       <b>-scodec</b> <u>codec</u> <b>(</b><u>input/output</u><b>)</b>
           Set the subtitle codec. This is an alias for "-codec:s".

       <b>-sn</b> <b>(</b><u>input/output</u><b>)</b>
           As an input option, blocks all subtitle streams of a file from being filtered or being  automatically
           selected or mapped for any output. See "-discard" option to disable streams individually.

           As  an output option, disables subtitle recording i.e. automatic selection or mapping of any subtitle
           stream. For full manual control see the "-map" option.

   <b>Advanced</b> <b>Subtitle</b> <b>options</b>
       <b>-fix_sub_duration</b>
           Fix subtitles durations. For each subtitle, wait for the next packet in the same  stream  and  adjust
           the  duration of the first to avoid overlap. This is necessary with some subtitles codecs, especially
           DVB subtitles, because the duration in the original packet is only a rough estimate and  the  end  is
           actually  marked  by an empty subtitle frame. Failing to use this option when necessary can result in
           exaggerated durations or muxing failures due to non-monotonic timestamps.

           Note that this option will delay the output of all data until the next subtitle packet is decoded: it
           may increase memory consumption and latency a lot.

       <b>-canvas_size</b> <u>size</u>
           Set the size of the canvas used to render subtitles.

   <b>Advanced</b> <b>options</b>
       <b>-map</b> <b>[-]</b><u>input_file_id</u><b>[:</b><u>stream_specifier</u><b>][:</b><u>view_specifier</u><b>][:?]</b> <b>|</b> <u>[linklabel]</u> <b>(</b><u>output</u><b>)</b>
           Create one or more streams in the output file. This option has two  forms  for  specifying  the  data
           source(s):  the  first  selects  one  or more streams from some input file (specified with "-i"), the
           second takes an output from some complex filtergraph (specified with "-filter_complex").

           In the first form, an output stream is created for every stream from the input file  with  the  index
           <u>input_file_id</u>.  If  <u>stream_specifier</u>  is  given, only those streams that match the specifier are used
           (see the <b>Stream</b> <b>specifiers</b> section for the <u>stream_specifier</u> syntax).

           A "-" character before the stream identifier creates a  "negative"  mapping.   It  disables  matching
           streams from already created mappings.

           An  optional  <u>view_specifier</u>  may  be  given  after  the  stream specifier, which for multiview video
           specifies the view to be used. The view specifier may have one of the following formats:

           <b>view:</b><u>view_id</u>
               select a view by its ID; <u>view_id</u> may be set to 'all' to use all the views  interleaved  into  one
               stream;

           <b>vidx:</b><u>view_idx</u>
               select a view by its index; i.e. 0 is the base view, 1 is the first non-base view, etc.

           <b>vpos:</b><u>position</u>
               select a view by its display position; <u>position</u> may be "left" or "right"

           The  default  for  transcoding  is  to  only  use the base view, i.e. the equivalent of "vidx:0". For
           streamcopy, view specifiers are not supported and all views are always copied.

           A trailing "?" after the stream index will allow the map to  be  optional:  if  the  map  matches  no
           streams  the map will be ignored instead of failing. Note the map will still fail if an invalid input
           file index is used; such as if the map refers to a non-existent input.

           An alternative <u>[linklabel]</u> form will map outputs from complex filter graphs (see the  <b>-filter_complex</b>
           option) to the output file.  <u>linklabel</u> must correspond to a defined output link label in the graph.

           This  option  may be specified multiple times, each adding more streams to the output file. Any given
           input stream may also be mapped any number of times as a source for different output streams, e.g. in
           order to use different encoding options and/or filters. The streams are created in the output in  the
           same order in which the "-map" options are given on the commandline.

           Using this option disables the default mappings for this output file.

           Examples:

           <u>map</u> <u>everything</u>
               To map ALL streams from the first input file to output

                       ffmpeg -i INPUT -map 0 output

           <u>select</u> <u>specific</u> <u>stream</u>
               If  you  have  two audio streams in the first input file, these streams are identified by <u>0:0</u> and
               <u>0:1</u>. You can use "-map" to select which streams to place in an output file. For example:

                       ffmpeg -i INPUT -map 0:1 out.wav

               will map the second input stream in <u>INPUT</u> to the (single) output stream in <u>out.wav</u>.

           <u>create</u> <u>multiple</u> <u>streams</u>
               To select the stream with index 2 from input file <u>a.mov</u> (specified by the  identifier  <u>0:2</u>),  and
               stream  with  index  6  from  input <u>b.mov</u> (specified by the identifier <u>1:6</u>), and copy them to the
               output file <u>out.mov</u>:

                       ffmpeg -i a.mov -i b.mov -c copy -map 0:2 -map 1:6 out.mov

           <u>create</u> <u>multiple</u> <u>streams</u> <u>2</u>
               To select all video and the third audio stream from an input file:

                       ffmpeg -i INPUT -map 0:v -map 0:a:2 OUTPUT

           <u>negative</u> <u>map</u>
               To map all the streams except the second audio, use negative mappings

                       ffmpeg -i INPUT -map 0 -map -0:a:1 OUTPUT

           <u>optional</u> <u>map</u>
               To map the video and audio streams from the first input, and using the trailing "?",  ignore  the
               audio mapping if no audio streams exist in the first input:

                       ffmpeg -i INPUT -map 0:v -map 0:a? OUTPUT

           <u>map</u> <u>by</u> <u>language</u>
               To pick the English audio stream:

                       ffmpeg -i INPUT -map 0:m:language:eng OUTPUT

       <b>-ignore_unknown</b>
           Ignore input streams with unknown type instead of failing if copying such streams is attempted.

       <b>-copy_unknown</b>
           Allow  input  streams  with  unknown  type to be copied instead of failing if copying such streams is
           attempted.

       <b>-map_metadata[:</b><u>metadata_spec_out</u><b>]</b> <u>infile</u><b>[:</b><u>metadata_spec_in</u><b>]</b> <b>(</b><u>output,per-metadata</u><b>)</b>
           Set metadata information of the next output file from <u>infile</u>. Note that those are file indices (zero-
           based), not filenames.  Optional <u>metadata_spec_in/out</u> parameters specify, which metadata to copy.   A
           metadata specifier can have the following forms:

           <u>g</u>   global metadata, i.e. metadata that applies to the whole file

           <u>s</u><b>[:</b><u>stream_spec</u><b>]</b>
               per-stream  metadata.  <u>stream_spec</u>  is  a  stream specifier as described in the <b>Stream</b> <b>specifiers</b>
               chapter. In an input metadata specifier, the first matching stream is copied from. In  an  output
               metadata specifier, all matching streams are copied to.

           <u>c</u><b>:</b><u>chapter_index</u>
               per-chapter metadata. <u>chapter_index</u> is the zero-based chapter index.

           <u>p</u><b>:</b><u>program_index</u>
               per-program metadata. <u>program_index</u> is the zero-based program index.

           If metadata specifier is omitted, it defaults to global.

           By  default, global metadata is copied from the first input file, per-stream and per-chapter metadata
           is copied along with streams/chapters. These default mappings are disabled by creating any mapping of
           the relevant type. A negative file index can be used to create a dummy  mapping  that  just  disables
           automatic copying.

           For example to copy metadata from the first stream of the input file to global metadata of the output
           file:

                   ffmpeg -i in.ogg -map_metadata 0:s:0 out.mp3

           To do the reverse, i.e. copy global metadata to all audio streams:

                   ffmpeg -i in.mkv -map_metadata:s:a 0:g out.mkv

           Note that simple 0 would work as well in this example, since global metadata is assumed by default.

       <b>-map_chapters</b> <u>input_file_index</u> <b>(</b><u>output</u><b>)</b>
           Copy  chapters  from  input  file  with index <u>input_file_index</u> to the next output file. If no chapter
           mapping is specified, then chapters are copied from the first input file with at least  one  chapter.
           Use a negative file index to disable any chapter copying.

       <b>-benchmark</b> <b>(</b><u>global</u><b>)</b>
           Show  benchmarking  information  at  the end of an encode.  Shows real, system and user time used and
           maximum memory consumption.  Maximum memory consumption is not supported  on  all  systems,  it  will
           usually display as 0 if not supported.

       <b>-benchmark_all</b> <b>(</b><u>global</u><b>)</b>
           Show  benchmarking  information  during the encode.  Shows real, system and user time used in various
           steps (audio/video encode/decode).

       <b>-timelimit</b> <u>duration</u> <b>(</b><u>global</u><b>)</b>
           Exit after ffmpeg has been running for <u>duration</u> seconds in CPU user time.

       <b>-dump</b> <b>(</b><u>global</u><b>)</b>
           Dump each input packet to stderr.

       <b>-hex</b> <b>(</b><u>global</u><b>)</b>
           When dumping packets, also dump the payload.

       <b>-readrate</b> <u>speed</u> <b>(</b><u>input</u><b>)</b>
           Limit input read speed.

           Its value is a floating-point positive number which represents the  maximum  duration  of  media,  in
           seconds,  that  should  be  ingested  in  one  second  of  wallclock time.  Default value is zero and
           represents no imposed limitation on speed of ingestion.  Value 1 represents real-time  speed  and  is
           equivalent to "-re".

           Mainly  used  to  simulate  a  capture  device  or live input stream (e.g. when reading from a file).
           Should not be used with a low value when input is an actual capture device or live stream as  it  may
           cause packet loss.

           It is useful for when flow speed of output packets is important, such as live streaming.

       <b>-re</b> <b>(</b><u>input</u><b>)</b>
           Read input at native frame rate. This is equivalent to setting "-readrate 1".

       <b>-readrate_initial_burst</b> <u>seconds</u>
           Set an initial read burst time, in seconds, after which <b>-re/-readrate</b> will be enforced.

       <b>-vsync</b> <u>parameter</u> <b>(</b><u>global</u><b>)</b>
       <b>-fps_mode[:</b><u>stream_specifier</u><b>]</b> <u>parameter</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set  video  sync  method  /  framerate  mode. vsync is applied to all output video streams but can be
           overridden for a stream by setting fps_mode. vsync is deprecated and will be removed in the future.

           For compatibility reasons some of the values  for  vsync  can  be  specified  as  numbers  (shown  in
           parentheses in the following table).

           <b>passthrough</b> <b>(0)</b>
               Each frame is passed with its timestamp from the demuxer to the muxer.

           <b>cfr</b> <b>(1)</b>
               Frames will be duplicated and dropped to achieve exactly the requested constant frame rate.

           <b>vfr</b> <b>(2)</b>
               Frames  are  passed through with their timestamp or dropped so as to prevent 2 frames from having
               the same timestamp.

           <b>auto</b> <b>(-1)</b>
               Chooses between cfr and vfr depending on muxer capabilities. This is the default method.

           Note that the timestamps may be further modified by the muxer, after this.  For example, in the  case
           that the format option <b>avoid_negative_ts</b> is enabled.

           With -map you can select from which stream the timestamps should be taken. You can leave either video
           or audio unchanged and sync the remaining stream(s) to the unchanged one.

       <b>-frame_drop_threshold</b> <u>parameter</u>
           Frame drop threshold, which specifies how much behind video frames can be before they are dropped. In
           frame  rate  units,  so  1.0  is  one  frame.   The default is -1.1. One possible usecase is to avoid
           framedrops in case of noisy timestamps  or  to  increase  frame  drop  precision  in  case  of  exact
           timestamps.

       <b>-apad</b> <u>parameters</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Pad  the  output  audio  stream(s). This is the same as applying "-af apad".  Argument is a string of
           filter parameters composed the same as with the "apad" filter.  "-shortest"  must  be  set  for  this
           output for the option to take effect.

       <b>-copyts</b>
           Do  not  process  input  timestamps,  but  keep  their  values  without  trying  to sanitize them. In
           particular, do not remove the initial start time offset value.

           Note that, depending on the <b>vsync</b> option or on specific muxer processing (e.g.  in  case  the  format
           option  <b>avoid_negative_ts</b>  is  enabled)  the output timestamps may mismatch with the input timestamps
           even when this option is selected.

       <b>-start_at_zero</b>
           When used with <b>copyts</b>, shift input timestamps so they start at zero.

           This means that using e.g. "-ss 50" will make output timestamps start at 50  seconds,  regardless  of
           what timestamp the input file started at.

       <b>-copytb</b> <u>mode</u>
           Specify  how  to set the encoder timebase when stream copying.  <u>mode</u> is an integer numeric value, and
           can assume one of the following values:

           <b>1</b>   Use the demuxer timebase.

               The time base is copied to the output encoder from  the  corresponding  input  demuxer.  This  is
               sometimes  required  to  avoid non monotonically increasing timestamps when copying video streams
               with variable frame rate.

           <b>0</b>   Use the decoder timebase.

               The time base is copied to the output encoder from the corresponding input decoder.

           <b>-1</b>  Try to make the choice automatically, in order to generate a sane output.

           Default value is -1.

       <b>-enc_time_base[:</b><u>stream_specifier</u><b>]</b> <u>timebase</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set the encoder timebase. <u>timebase</u> can assume one of the following values:

           <b>0</b>   Assign a default value according to the media type.

               For video - use 1/framerate, for audio - use 1/samplerate.

           <b>demux</b>
               Use the timebase from the demuxer.

           <b>filter</b>
               Use the timebase from the filtergraph.

           <b>a</b> <b>positive</b> <b>number</b>
               Use the provided number as the timebase.

               This field can be provided as a ratio of two integers (e.g. 1:24, 1:48000) or as a decimal number
               (e.g. 0.04166, 2.0833e-5)

           Default value is 0.

       <b>-bitexact</b> <b>(</b><u>input/output</u><b>)</b>
           Enable bitexact mode for (de)muxer and (de/en)coder

       <b>-shortest</b> <b>(</b><u>output</u><b>)</b>
           Finish encoding when the shortest output stream ends.

           Note that this option may require buffering frames,  which  introduces  extra  latency.  The  maximum
           amount of this latency may be controlled with the "-shortest_buf_duration" option.

       <b>-shortest_buf_duration</b> <u>duration</u> <b>(</b><u>output</u><b>)</b>
           The  "-shortest"  option may require buffering potentially large amounts of data when at least one of
           the streams is "sparse" (i.e. has large gaps  between  frames  –  this  is  typically  the  case  for
           subtitles).

           This option controls the maximum duration of buffered frames in seconds.  Larger values may allow the
           "-shortest" option to produce more accurate results, but increase memory use and latency.

           The default value is 10 seconds.

       <b>-dts_delta_threshold</b> <u>threshold</u>
           Timestamp discontinuity delta threshold, expressed as a decimal number of seconds.

           The  timestamp  discontinuity  correction  enabled  by  this  option is only applied to input formats
           accepting timestamp discontinuity (for which the "AVFMT_TS_DISCONT" flag is  enabled),  e.g.  MPEG-TS
           and  HLS,  and  is  automatically  disabled  when  employing the "-copyts" option (unless wrapping is
           detected).

           If a timestamp discontinuity is detected whose absolute value is greater than <u>threshold</u>, ffmpeg  will
           remove  the discontinuity by decreasing/increasing the current DTS and PTS by the corresponding delta
           value.

           The default value is 10.

       <b>-dts_error_threshold</b> <u>threshold</u>
           Timestamp error delta threshold, expressed as a decimal number of seconds.

           The timestamp correction enabled by this option is  only  applied  to  input  formats  not  accepting
           timestamp discontinuity (for which the "AVFMT_TS_DISCONT" flag is not enabled).

           If  a timestamp discontinuity is detected whose absolute value is greater than <u>threshold</u>, ffmpeg will
           drop the PTS/DTS timestamp value.

           The default value is "3600*30" (30 hours), which is arbitrarily picked and quite conservative.

       <b>-muxdelay</b> <u>seconds</u> <b>(</b><u>output</u><b>)</b>
           Set the maximum demux-decode delay.

       <b>-muxpreload</b> <u>seconds</u> <b>(</b><u>output</u><b>)</b>
           Set the initial demux-decode delay.

       <b>-streamid</b> <u>output-stream-index</u><b>:</b><u>new-value</u> <b>(</b><u>output</u><b>)</b>
           Assign a new stream-id value to an output stream. This option should be specified prior to the output
           filename to which it applies.  For the situation where multiple output files exist, a streamid may be
           reassigned to a different value.

           For example, to set the stream 0 PID to 33 and the stream 1 PID to 36 for an output mpegts file:

                   ffmpeg -i inurl -streamid 0:33 -streamid 1:36 out.ts

       <b>-bsf[:</b><u>stream_specifier</u><b>]</b> <u>bitstream_filters</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Apply bitstream filters to matching streams. The filters are applied to each packet as it is received
           from the demuxer (when used as an input option) or before it is sent to the muxer (when  used  as  an
           output option).

           <u>bitstream_filters</u> is a comma-separated list of bitstream filter specifications, each of the form

                   &lt;filter&gt;[=&lt;optname0&gt;=&lt;optval0&gt;:&lt;optname1&gt;=&lt;optval1&gt;:...]

           Any  of  the  ',=:'  characters  that  are  to be a part of an option value need to be escaped with a
           backslash.

           Use the "-bsfs" option to get the list of bitstream filters.

           E.g.

                   ffmpeg -bsf:v h264_mp4toannexb -i h264.mp4 -c:v copy -an out.h264

           applies the "h264_mp4toannexb" bitstream filter (which  converts  MP4-encapsulated  H.264  stream  to
           Annex B) to the <u>input</u> video stream.

           On the other hand,

                   ffmpeg -i file.mov -an -vn -bsf:s mov2textsub -c:s copy -f rawvideo sub.txt

           applies  the  "mov2textsub"  bitstream  filter (which extracts text from MOV subtitles) to the <u>output</u>
           subtitle stream. Note, however, that since both examples use "-c copy", it matters little whether the
           filters are applied on input or output - that would change if transcoding was happening.

       <b>-tag[:</b><u>stream_specifier</u><b>]</b> <u>codec_tag</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Force a tag/fourcc for matching streams.

       <b>-timecode</b> <u>hh</u><b>:</b><u>mm</u><b>:</b><u>ss</u><b>SEP</b><u>ff</u>
           Specify Timecode for writing. <u>SEP</u> is ':' for non drop timecode and ';' (or '.') for drop.

                   ffmpeg -i input.mpg -timecode 01:02:03.04 -r 30000/1001 -s ntsc output.mpg

       <b>-filter_complex</b> <u>filtergraph</u> <b>(</b><u>global</u><b>)</b>
           Define a complex filtergraph, i.e. one with arbitrary number of inputs  and/or  outputs.  For  simple
           graphs  --  those  with  one  input  and  one  output  of  the  same type -- see the <b>-filter</b> options.
           <u>filtergraph</u> is a description of the filtergraph, as described in the ``Filtergraph  syntax''  section
           of  the  ffmpeg-filters  manual. This option may be specified multiple times - each use creates a new
           complex filtergraph.

           Inputs to a complex filtergraph may come from different source types, distinguished by the format  of
           the corresponding link label:

           •   To  connect  an input stream, use "[file_index:stream_specifier]" (i.e. the same syntax as <b>-map</b>).
               If <u>stream_specifier</u> matches multiple streams, the first one will be used.  For  multiview  video,
               the stream specifier may be followed by the view specifier, see documentation for the <b>-map</b> option
               for its syntax.

           •   To  connect  a  loopback  decoder  use  [dec:<u>dec_idx</u>], where <u>dec_idx</u> is the index of the loopback
               decoder to be connected to given input. For multiview video, the decoder index may be followed by
               the view specifier, see documentation for the <b>-map</b> option for its syntax.

           •   To connect an output from another complex filtergraph, use its  link  label.  E.g  the  following
               example:

                       ffmpeg -i input.mkv \
                         -filter_complex '[0:v]scale=size=hd1080,split=outputs=2[for_enc][orig_scaled]' \
                         -c:v libx264 -map '[for_enc]' output.mkv \
                         -dec 0:0 \
                         -filter_complex '[dec:0][orig_scaled]hstack[stacked]' \
                         -map '[stacked]' -c:v ffv1 comparison.mkv

               reads an input video and

               •   (line  2)  uses  a  complex  filtergraph with one input and two outputs to scale the video to
                   1920x1080 and duplicate the result to both outputs;

               •   (line 3) encodes one scaled output with "libx264" and writes the result to <u>output.mkv</u>;

               •   (line 4) decodes this encoded stream with a loopback decoder;

               •   (line 5) places the output of the loopback decoder (i.e. the "libx264"-encoded video) side by
                   side with the scaled original input;

               •   (line 6) combined video is then losslessly encoded and written into <u>comparison.mkv</u>.

               Note that the two filtergraphs cannot be combined into one, because then there would be  a  cycle
               in  the  transcoding  pipeline (filtergraph output goes to encoding, from there to decoding, then
               back to the same graph), and such cycles are not allowed.

           An unlabeled input will be connected to the first unused input stream of the matching type.

           Output link labels are referred to with <b>-map</b>. Unlabeled outputs are added to the first output file.

           Note that with this option it is possible to use only lavfi sources without normal input files.

           For example, to overlay an image over video

                   ffmpeg -i video.mkv -i image.png -filter_complex '[0:v][1:v]overlay[out]' -map
                   '[out]' out.mkv

           Here "[0:v]" refers to the first video stream in the first input file, which is linked to  the  first
           (main) input of the overlay filter. Similarly the first video stream in the second input is linked to
           the second (overlay) input of overlay.

           Assuming there is only one video stream in each input file, we can omit input labels, so the above is
           equivalent to

                   ffmpeg -i video.mkv -i image.png -filter_complex 'overlay[out]' -map
                   '[out]' out.mkv

           Furthermore we can omit the output label and the single output from the filter graph will be added to
           the output file automatically, so we can simply write

                   ffmpeg -i video.mkv -i image.png -filter_complex 'overlay' out.mkv

           As  a  special  exception, you can use a bitmap subtitle stream as input: it will be converted into a
           video with the same size as the largest video in the file, or 720x576 if no video  is  present.  Note
           that  this  is an experimental and temporary solution. It will be removed once libavfilter has proper
           support for subtitles.

           For example, to hardcode subtitles on top of a DVB-T recording stored in MPEG-TS format, delaying the
           subtitles by 1 second:

                   ffmpeg -i input.ts -filter_complex \
                     '[#0x2ef] setpts=PTS+1/TB [sub] ; [#0x2d0] [sub] overlay' \
                     -sn -map '#0x2dc' output.mkv

           (0x2d0, 0x2dc and 0x2ef are the MPEG-TS PIDs of respectively the video, audio and subtitles  streams;
           0:0, 0:3 and 0:7 would have worked too)

           To generate 5 seconds of pure red video using lavfi "color" source:

                   ffmpeg -filter_complex 'color=c=red' -t 5 out.mkv

       <b>-filter_complex_threads</b> <u>nb_threads</u> <b>(</b><u>global</u><b>)</b>
           Defines  how  many threads are used to process a filter_complex graph.  Similar to filter_threads but
           used for "-filter_complex" graphs only.  The default is the number of available CPUs.

       <b>-lavfi</b> <u>filtergraph</u> <b>(</b><u>global</u><b>)</b>
           Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. Equivalent  to
           <b>-filter_complex</b>.

       <b>-accurate_seek</b> <b>(</b><u>input</u><b>)</b>
           This option enables or disables accurate seeking in input files with the <b>-ss</b> option. It is enabled by
           default,  so  seeking  is accurate when transcoding. Use <b>-noaccurate_seek</b> to disable it, which may be
           useful e.g. when copying some streams and transcoding the others.

       <b>-seek_timestamp</b> <b>(</b><u>input</u><b>)</b>
           This option enables or disables seeking by timestamp in input  files  with  the  <b>-ss</b>  option.  It  is
           disabled  by  default.  If enabled, the argument to the <b>-ss</b> option is considered an actual timestamp,
           and is not offset by the start time of the file. This matters only for files which do not start  from
           timestamp 0, such as transport streams.

       <b>-thread_queue_size</b> <u>size</u> <b>(</b><u>input/output</u><b>)</b>
           For  input,  this  option  sets  the  maximum  number of queued packets when reading from the file or
           device. With low latency / high rate live streams, packets may be discarded if they are not read in a
           timely manner; setting this value can force ffmpeg to use a separate input thread and read packets as
           soon as they arrive. By default ffmpeg only does this if multiple inputs are specified.

           For output, this option specified the maximum number of packets that may be  queued  to  each  muxing
           thread.

       <b>-sdp_file</b> <u>file</u> <b>(</b><u>global</u><b>)</b>
           Print  sdp  information  for  an  output stream to <u>file</u>.  This allows dumping sdp information when at
           least one output isn't an rtp stream. (Requires at least one of the output formats to be rtp).

       <b>-discard</b> <b>(</b><u>input</u><b>)</b>
           Allows discarding specific streams or frames from streams.  Any input stream can be fully  discarded,
           using  value  "all" whereas selective discarding of frames from a stream occurs at the demuxer and is
           not supported by all demuxers.

           <b>none</b>
               Discard no frame.

           <b>default</b>
               Default, which discards no frames.

           <b>noref</b>
               Discard all non-reference frames.

           <b>bidir</b>
               Discard all bidirectional frames.

           <b>nokey</b>
               Discard all frames excepts keyframes.

           <b>all</b> Discard all frames.

       <b>-abort_on</b> <u>flags</u> <b>(</b><u>global</u><b>)</b>
           Stop and abort on various conditions. The following flags are available:

           <b>empty_output</b>
               No packets were passed to the muxer, the output is empty.

           <b>empty_output_stream</b>
               No packets were passed to the muxer in some of the output streams.

       <b>-max_error_rate</b> <b>(</b><u>global</u><b>)</b>
           Set fraction of decoding frame failures across all inputs which when crossed ffmpeg will return  exit
           code  69.  Crossing  this  threshold  does not terminate processing. Range is a floating-point number
           between 0 to 1. Default is 2/3.

       <b>-xerror</b> <b>(</b><u>global</u><b>)</b>
           Stop and exit on error

       <b>-max_muxing_queue_size</b> <u>packets</u> <b>(</b><u>output,per-stream</u><b>)</b>
           When transcoding audio and/or video streams, ffmpeg will not begin writing into the output  until  it
           has  one packet for each such stream. While waiting for that to happen, packets for other streams are
           buffered. This option sets the size of this buffer, in packets, for the matching output stream.

           The default value of this option should be high enough for most uses, so only touch  this  option  if
           you are sure that you need it.

       <b>-muxing_queue_data_threshold</b> <u>bytes</u> <b>(</b><u>output,per-stream</u><b>)</b>
           This  is a minimum threshold until which the muxing queue size is not taken into account. Defaults to
           50 megabytes per stream, and is based on the overall size of packets passed to the muxer.

       <b>-auto_conversion_filters</b> <b>(</b><u>global</u><b>)</b>
           Enable automatically inserting format conversion  filters  in  all  filter  graphs,  including  those
           defined  by <b>-vf</b>, <b>-af</b>, <b>-filter_complex</b> and <b>-lavfi</b>. If filter format negotiation requires a conversion,
           the initialization of the filters will fail.  Conversions can still be  performed  by  inserting  the
           relevant  conversion filter (scale, aresample) in the graph.  On by default, to explicitly disable it
           you need to specify "-noauto_conversion_filters".

       <b>-bits_per_raw_sample[:</b><u>stream_specifier</u><b>]</b> <u>value</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Declare the number of bits per raw sample in the given output stream to  be  <u>value</u>.  Note  that  this
           option  sets  the information provided to the encoder/muxer, it does not change the stream to conform
           to this value. Setting values that do not match the stream properties may result in encoding failures
           or invalid output files.

       <b>-stats_enc_pre[:</b><u>stream_specifier</u><b>]</b> <u>path</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-stats_enc_post[:</b><u>stream_specifier</u><b>]</b> <u>path</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-stats_mux_pre[:</b><u>stream_specifier</u><b>]</b> <u>path</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Write per-frame encoding information about the matching streams into the file given by <u>path</u>.

           <b>-stats_enc_pre</b> writes information about raw video or audio frames right  before  they  are  sent  for
           encoding,  while  <b>-stats_enc_post</b>  writes information about encoded packets as they are received from
           the encoder.  <b>-stats_mux_pre</b> writes information about packets just as they are about to  be  sent  to
           the  muxer. Every frame or packet produces one line in the specified file. The format of this line is
           controlled by <b>-stats_enc_pre_fmt</b> / <b>-stats_enc_post_fmt</b> / <b>-stats_mux_pre_fmt</b>.

           When stats for multiple streams are written into a single file, the lines corresponding to  different
           streams  will  be  interleaved.  The  precise  order  of  this  interleaving is not specified and not
           guaranteed to remain stable between different invocations of the program, even with the same options.

       <b>-stats_enc_pre_fmt[:</b><u>stream_specifier</u><b>]</b> <u>format_spec</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-stats_enc_post_fmt[:</b><u>stream_specifier</u><b>]</b> <u>format_spec</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-stats_mux_pre_fmt[:</b><u>stream_specifier</u><b>]</b> <u>format_spec</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Specify the format for the lines written with <b>-stats_enc_pre</b> / <b>-stats_enc_post</b> / <b>-stats_mux_pre</b>.

           <u>format_spec</u> is a string that may contain directives of the  form  <u>{fmt}</u>.  <u>format_spec</u>  is  backslash-
           escaped --- use \{, \}, and \\ to write a literal {, }, or \, respectively, into the output.

           The directives given with <u>fmt</u> may be one of the following:

           <b>fidx</b>
               Index of the output file.

           <b>sidx</b>
               Index of the output stream in the file.

           <b>n</b>   Frame  number.  Pre-encoding: number of frames sent to the encoder so far.  Post-encoding: number
               of packets received from the encoder so far.  Muxing: number of packets submitted  to  the  muxer
               for this stream so far.

           <b>ni</b>  Input  frame number. Index of the input frame (i.e. output by a decoder) that corresponds to this
               output frame or packet. -1 if unavailable.

           <b>tb</b>  Timebase in which this frame/packet's timestamps are expressed, as  a  rational  number  <u>num/den</u>.
               Note that encoder and muxer may use different timebases.

           <b>tbi</b> Timebase for <u>ptsi</u>, as a rational number <u>num/den</u>. Available when <u>ptsi</u> is available, <u>0/1</u> otherwise.

           <b>pts</b> Presentation  timestamp  of  the  frame  or  packet,  as  an integer. Should be multiplied by the
               timebase to compute presentation time.

           <b>ptsi</b>
               Presentation timestamp of the input frame (see <u>ni</u>), as an integer. Should be multiplied by <u>tbi</u> to
               compute presentation time. Printed as (2^63 - 1 = 9223372036854775807) when not available.

           <b>t</b>   Presentation time of the frame or packet, as a decimal number. Equal to <u>pts</u> multiplied by <u>tb</u>.

           <b>ti</b>  Presentation time of the input frame (see <u>ni</u>), as a decimal number. Equal to <u>ptsi</u>  multiplied  by
               <u>tbi</u>. Printed as inf when not available.

           <b>dts</b> <b>(</b><u>packet</u><b>)</b>
               Decoding  timestamp of the packet, as an integer. Should be multiplied by the timebase to compute
               presentation time.

           <b>dt</b> <b>(</b><u>packet</u><b>)</b>
               Decoding time of the frame or packet, as a decimal number. Equal to <u>dts</u> multiplied by <u>tb</u>.

           <b>sn</b> <b>(</b><u>frame,audio</u><b>)</b>
               Number of audio samples sent to the encoder so far.

           <b>samp</b> <b>(</b><u>frame,audio</u><b>)</b>
               Number of audio samples in the frame.

           <b>size</b> <b>(</b><u>packet</u><b>)</b>
               Size of the encoded packet in bytes.

           <b>br</b> <b>(</b><u>packet</u><b>)</b>
               Current bitrate in bits per second.

           <b>abr</b> <b>(</b><u>packet</u><b>)</b>
               Average bitrate for the whole stream so far, in bits per second, -1 if it cannot be determined at
               this point.

           <b>key</b> <b>(</b><u>packet</u><b>)</b>
               Character 'K' if the packet contains a keyframe, character 'N' otherwise.

           Directives tagged with <u>packet</u> may only be used with <b>-stats_enc_post_fmt</b> and <b>-stats_mux_pre_fmt</b>.

           Directives tagged with <u>frame</u> may only be used with <b>-stats_enc_pre_fmt</b>.

           Directives tagged with <u>audio</u> may only be used with audio streams.

           The default format strings are:

           <b>pre-encoding</b>
               {fidx} {sidx} {n} {t}

           <b>post-encoding</b>
               {fidx} {sidx} {n} {t}

           In the future, new items may be added to the end of the default formatting strings. Users who  depend
           on the format staying exactly the same, should prescribe it manually.

           Note that stats for different streams written into the same file may have different formats.

   <b>Preset</b> <b>files</b>
       A  preset  file  contains  a  sequence of <u>option</u>=<u>value</u> pairs, one for each line, specifying a sequence of
       options which would be awkward to specify on the  command  line.  Lines  starting  with  the  hash  ('#')
       character  are ignored and are used to provide comments. Check the <u>presets</u> directory in the FFmpeg source
       tree for examples.

       There are two types of preset files: ffpreset and avpreset files.

       <u>ffpreset</u> <u>files</u>

       ffpreset files are specified with the "vpre", "apre", "spre", and "fpre" options. The "fpre" option takes
       the filename of the preset instead of a preset name as input and can be used for any kind of  codec.  For
       the  "vpre",  "apre",  and  "spre"  options,  the  options  specified in a preset file are applied to the
       currently selected codec of the same type as the preset option.

       The argument passed to the "vpre", "apre", and "spre" preset options identifies the preset  file  to  use
       according to the following rules:

       First  ffmpeg  searches  for  a  file named <u>arg</u>.ffpreset in the directories <u>$FFMPEG_DATADIR</u> (if set), and
       <u>$HOME/.ffmpeg</u>, and in the datadir defined at configuration time (usually  <u>PREFIX/share/ffmpeg</u>)  or  in  a
       <u>ffpresets</u>  folder  along  the  executable  on  win32,  in  that  order.  For  example, if the argument is
       "libvpx-1080p", it will search for the file <u>libvpx-1080p.ffpreset</u>.

       If no such file is found, then ffmpeg will search for a file named <u>codec_name</u>-<u>arg</u>.ffpreset in the  above-
       mentioned directories, where <u>codec_name</u> is the name of the codec to which the preset file options will be
       applied.  For example, if you select the video codec with "-vcodec libvpx" and use "-vpre 1080p", then it
       will search for the file <u>libvpx-1080p.ffpreset</u>.

       <u>avpreset</u> <u>files</u>

       avpreset files are specified with the "pre" option. They work similar to ffpreset files,  but  they  only
       allow encoder- specific options. Therefore, an <u>option</u>=<u>value</u> pair specifying an encoder cannot be used.

       When  the  "pre"  option  is  specified,  ffmpeg  will  look  for  files with the suffix .avpreset in the
       directories <u>$AVCONV_DATADIR</u> (if set), and <u>$HOME/.avconv</u>, and in the datadir defined at configuration time
       (usually <u>PREFIX/share/ffmpeg</u>), in that order.

       First ffmpeg searches for a file named <u>codec_name</u>-<u>arg</u>.avpreset in the above-mentioned directories,  where
       <u>codec_name</u> is the name of the codec to which the preset file options will be applied. For example, if you
       select  the  video  codec  with  "-vcodec  libvpx" and use "-pre 1080p", then it will search for the file
       <u>libvpx-1080p.avpreset</u>.

       If no such file is found, then ffmpeg will search for a file named <u>arg</u>.avpreset in the same directories.

   <b>vstats</b> <b>file</b> <b>format</b>
       The "-vstats" and "-vstats_file" options enable generation of a  file  containing  statistics  about  the
       generated video outputs.

       The "-vstats_version" option controls the format version of the generated file.

       With version 1 the format is:

               frame= &lt;FRAME&gt; q= &lt;FRAME_QUALITY&gt; PSNR= &lt;PSNR&gt; f_size= &lt;FRAME_SIZE&gt; s_size= &lt;STREAM_SIZE&gt;kB time= &lt;TIMESTAMP&gt; br= &lt;BITRATE&gt;kbits/s avg_br= &lt;AVERAGE_BITRATE&gt;kbits/s

       With version 2 the format is:

               out= &lt;OUT_FILE_INDEX&gt; st= &lt;OUT_FILE_STREAM_INDEX&gt; frame= &lt;FRAME_NUMBER&gt; q= &lt;FRAME_QUALITY&gt;f PSNR= &lt;PSNR&gt; f_size= &lt;FRAME_SIZE&gt; s_size= &lt;STREAM_SIZE&gt;kB time= &lt;TIMESTAMP&gt; br= &lt;BITRATE&gt;kbits/s avg_br= &lt;AVERAGE_BITRATE&gt;kbits/s

       The value corresponding to each key is described below:

       <b>avg_br</b>
           average bitrate expressed in Kbits/s

       <b>br</b>  bitrate expressed in Kbits/s

       <b>frame</b>
           number of encoded frame

       <b>out</b> out file index

       <b>PSNR</b>
           Peak Signal to Noise Ratio

       <b>q</b>   quality of the frame

       <b>f_size</b>
           encoded packet size expressed as number of bytes

       <b>s_size</b>
           stream size expressed in KiB

       <b>st</b>  out file stream index

       <b>time</b>
           time of the packet

       <b>type</b>
           picture type

       See also the <b>-stats_enc</b> <b>options</b> for an alternative way to show encoding statistics.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Video</b> <b>and</b> <b>Audio</b> <b>grabbing</b>
       If you specify the input format and device then ffmpeg can grab video and audio directly.

               ffmpeg -f oss -i /dev/dsp -f video4linux2 -i /dev/video0 /tmp/out.mpg

       Or with an ALSA audio source (mono input, card id 1) instead of OSS:

               ffmpeg -f alsa -ac 1 -i hw:1 -f video4linux2 -i /dev/video0 /tmp/out.mpg

       Note that you must activate the right video source and channel before launching ffmpeg with any TV viewer
       such  as &lt;<b><a href="http://linux.bytesex.org/xawtv/">http://linux.bytesex.org/xawtv/</a></b>&gt; by Gerd Knorr. You also have to set the audio recording levels
       correctly with a standard mixer.

   <b>X11</b> <b>grabbing</b>
       Grab the X11 display with ffmpeg via

               ffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0 /tmp/out.mpg

       0.0 is display.screen number of your X11 server, same as the DISPLAY environment variable.

               ffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0+10,20 /tmp/out.mpg

       0.0 is display.screen number of your X11 server, same as the DISPLAY  environment  variable.  10  is  the
       x-offset and 20 the y-offset for the grabbing.

   <b>Video</b> <b>and</b> <b>Audio</b> <b>file</b> <b>format</b> <b>conversion</b>
       Any supported file format and protocol can serve as input to ffmpeg:

       Examples:

       •   You can use YUV files as input:

                   ffmpeg -i /tmp/test%d.Y /tmp/out.mpg

           It will use the files:

                   /tmp/test0.Y, /tmp/test0.U, /tmp/test0.V,
                   /tmp/test1.Y, /tmp/test1.U, /tmp/test1.V, etc...

           The  Y  files use twice the resolution of the U and V files. They are raw files, without header. They
           can be generated by all decent video decoders. You must specify the size of the  image  with  the  <b>-s</b>
           option if ffmpeg cannot guess it.

       •   You can input from a raw YUV420P file:

                   ffmpeg -i /tmp/test.yuv /tmp/out.avi

           test.yuv  is a file containing raw YUV planar data. Each frame is composed of the Y plane followed by
           the U and V planes at half vertical and horizontal resolution.

       •   You can output to a raw YUV420P file:

                   ffmpeg -i mydivx.avi hugefile.yuv

       •   You can set several input files and output files:

                   ffmpeg -i /tmp/a.wav -s 640x480 -i /tmp/a.yuv /tmp/a.mpg

           Converts the audio file a.wav and the raw YUV video file a.yuv to MPEG file a.mpg.

       •   You can also do audio and video conversions at the same time:

                   ffmpeg -i /tmp/a.wav -ar 22050 /tmp/a.mp2

           Converts a.wav to MPEG audio at 22050 Hz sample rate.

       •   You can encode to several formats at the same time and define a mapping from input stream  to  output
           streams:

                   ffmpeg -i /tmp/a.wav -map 0:a -b:a 64k /tmp/a.mp2 -map 0:a -b:a 128k /tmp/b.mp2

           Converts  a.wav  to  a.mp2  at  64 kbits and to b.mp2 at 128 kbits. '-map file:index' specifies which
           input stream is used for each output stream, in the order of the definition of output streams.

       •   You can transcode decrypted VOBs:

                   ffmpeg -i snatch_1.vob -f avi -c:v mpeg4 -b:v 800k -g 300 -bf 2 -c:a libmp3lame -b:a 128k snatch.avi

           This is a typical DVD ripping example; the input is a VOB file, the output an AVI  file  with  MPEG-4
           video  and  MP3  audio.  Note  that  in  this  command  we use B-frames so the MPEG-4 stream is DivX5
           compatible, and GOP size is 300 which means one intra frame  every  10  seconds  for  29.97fps  input
           video.  Furthermore,  the  audio  stream is MP3-encoded so you need to enable LAME support by passing
           "--enable-libmp3lame" to configure.  The mapping is particularly useful for DVD  transcoding  to  get
           the desired audio language.

           NOTE: To see the supported input formats, use "ffmpeg -demuxers".

       •   You can extract images from a video, or create a video from many images:

           For extracting images from a video:

                   ffmpeg -i foo.avi -r 1 -s WxH -f image2 foo-%03d.jpeg

           This  will  extract  one  video  frame  per second from the video and will output them in files named
           <u>foo-001.jpeg</u>, <u>foo-002.jpeg</u>, etc. Images will be rescaled to fit the new WxH values.

           If you want to extract just a limited number of frames, you can use the above command in  combination
           with  the  "-frames:v"  or "-t" option, or in combination with -ss to start extracting from a certain
           point in time.

           For creating a video from many images:

                   ffmpeg -f image2 -framerate 12 -i foo-%03d.jpeg -s WxH foo.avi

           The syntax "foo-%03d.jpeg" specifies to use a decimal number composed of  three  digits  padded  with
           zeroes  to express the sequence number. It is the same syntax supported by the C printf function, but
           only formats accepting a normal integer are suitable.

           When importing an image sequence, -i also supports expanding shell-like wildcard patterns  (globbing)
           internally, by selecting the image2-specific "-pattern_type glob" option.

           For example, for creating a video from filenames matching the glob pattern "foo-*.jpeg":

                   ffmpeg -f image2 -pattern_type glob -framerate 12 -i 'foo-*.jpeg' -s WxH foo.avi

       •   You can put many streams of the same type in the output:

                   ffmpeg -i test1.avi -i test2.avi -map 1:1 -map 1:0 -map 0:1 -map 0:0 -c copy -y test12.nut

           The  resulting  output  file  <u>test12.nut</u>  will contain the first four streams from the input files in
           reverse order.

       •   To force CBR video output:

                   ffmpeg -i myfile.avi -b 4000k -minrate 4000k -maxrate 4000k -bufsize 1835k out.m2v

       •   The four options lmin, lmax, mblmin and mblmax use 'lambda' units, but  you  may  use  the  QP2LAMBDA
           constant to easily convert from 'q' units:

                   ffmpeg -i src.ext -lmax 21*QP2LAMBDA dst.ext

</pre><h4><b>SYNTAX</b></h4><pre>
       This section documents the syntax and formats employed by the FFmpeg libraries and tools.

   <b>Quoting</b> <b>and</b> <b>escaping</b>
       FFmpeg  adopts  the  following quoting and escaping mechanism, unless explicitly specified. The following
       rules are applied:

       •   <b>'</b> and <b>\</b> are special characters (respectively used for quoting and escaping).  In  addition  to  them,
           there  might  be  other  special  characters  depending on the specific syntax where the escaping and
           quoting are employed.

       •   A special character is escaped by prefixing it with a <b>\</b>.

       •   All characters enclosed between <b>''</b> are included literally in the parsed string. The quote character <b>'</b>
           itself cannot be quoted, so you may need to close the quote and escape it.

       •   Leading and trailing whitespaces, unless escaped or quoted, are removed from the parsed string.

       Note that you may need to add a second level of escaping when using the command line or a  script,  which
       depends on the syntax of the adopted shell language.

       The  function  "av_get_token"  defined  in  <u>libavutil/avstring.h</u>  can  be used to parse a token quoted or
       escaped according to the rules defined above.

       The tool <u>tools/ffescape</u> in the FFmpeg source tree can be used to automatically quote or escape  a  string
       in a script.

       <u>Examples</u>

       •   Escape the string "Crime d'Amour" containing the "'" special character:

                   Crime d\'Amour

       •   The string above contains a quote, so the "'" needs to be escaped when quoting it:

                   'Crime d'\''Amour'

       •   Include leading or trailing whitespaces using quoting:

                   '  this string starts and ends with whitespaces  '

       •   Escaping and quoting can be mixed together:

                   ' The string '\'string\'' is a string '

       •   To include a literal <b>\</b> you can use either escaping or quoting:

                   'c:\foo' can be written as c:\\foo

   <b>Date</b>
       The accepted syntax is:

               [(YYYY-MM-DD|YYYYMMDD)[T|t| ]]((HH:MM:SS[.m...]]])|(HHMMSS[.m...]]]))[Z]
               now

       If the value is "now" it takes the current time.

       Time  is  local time unless Z is appended, in which case it is interpreted as UTC.  If the year-month-day
       part is not specified it takes the current year-month-day.

   <b>Time</b> <b>duration</b>
       There are two accepted syntaxes for expressing time duration.

               [-][&lt;HH&gt;:]&lt;MM&gt;:&lt;SS&gt;[.&lt;m&gt;...]

       <u>HH</u> expresses the number of hours, <u>MM</u> the number of minutes for a maximum of 2 digits, and <u>SS</u>  the  number
       of seconds for a maximum of 2 digits. The <u>m</u> at the end expresses decimal value for <u>SS</u>.

       <u>or</u>

               [-]&lt;S&gt;+[.&lt;m&gt;...][s|ms|us]

       <u>S</u> expresses the number of seconds, with the optional decimal part <u>m</u>.  The optional literal suffixes <b>s</b>, <b>ms</b>
       or <b>us</b> indicate to interpret the value as seconds, milliseconds or microseconds, respectively.

       In both expressions, the optional <b>-</b> indicates negative duration.

       <u>Examples</u>

       The following examples are all valid time duration:

       <b>55</b>  55 seconds

       <b>0.2</b> 0.2 seconds

       <b>200ms</b>
           200 milliseconds, that's 0.2s

       <b>200000us</b>
           200000 microseconds, that's 0.2s

       <b>12:03:45</b>
           12 hours, 03 minutes and 45 seconds

       <b>23.189</b>
           23.189 seconds

   <b>Video</b> <b>size</b>
       Specify the size of the sourced video, it may be a string of the form <u>width</u>x<u>height</u>, or the name of a size
       abbreviation.

       The following abbreviations are recognized:

       <b>ntsc</b>
           720x480

       <b>pal</b> 720x576

       <b>qntsc</b>
           352x240

       <b>qpal</b>
           352x288

       <b>sntsc</b>
           640x480

       <b>spal</b>
           768x576

       <b>film</b>
           352x240

       <b>ntsc-film</b>
           352x240

       <b>sqcif</b>
           128x96

       <b>qcif</b>
           176x144

       <b>cif</b> 352x288

       <b>4cif</b>
           704x576

       <b>16cif</b>
           1408x1152

       <b>qqvga</b>
           160x120

       <b>qvga</b>
           320x240

       <b>vga</b> 640x480

       <b>svga</b>
           800x600

       <b>xga</b> 1024x768

       <b>uxga</b>
           1600x1200

       <b>qxga</b>
           2048x1536

       <b>sxga</b>
           1280x1024

       <b>qsxga</b>
           2560x2048

       <b>hsxga</b>
           5120x4096

       <b>wvga</b>
           852x480

       <b>wxga</b>
           1366x768

       <b>wsxga</b>
           1600x1024

       <b>wuxga</b>
           1920x1200

       <b>woxga</b>
           2560x1600

       <b>wqsxga</b>
           3200x2048

       <b>wquxga</b>
           3840x2400

       <b>whsxga</b>
           6400x4096

       <b>whuxga</b>
           7680x4800

       <b>cga</b> 320x200

       <b>ega</b> 640x350

       <b>hd480</b>
           852x480

       <b>hd720</b>
           1280x720

       <b>hd1080</b>
           1920x1080

       <b>2k</b>  2048x1080

       <b>2kflat</b>
           1998x1080

       <b>2kscope</b>
           2048x858

       <b>4k</b>  4096x2160

       <b>4kflat</b>
           3996x2160

       <b>4kscope</b>
           4096x1716

       <b>nhd</b> 640x360

       <b>hqvga</b>
           240x160

       <b>wqvga</b>
           400x240

       <b>fwqvga</b>
           432x240

       <b>hvga</b>
           480x320

       <b>qhd</b> 960x540

       <b>2kdci</b>
           2048x1080

       <b>4kdci</b>
           4096x2160

       <b>uhd2160</b>
           3840x2160

       <b>uhd4320</b>
           7680x4320

   <b>Video</b> <b>rate</b>
       Specify the frame rate of a video, expressed as the number of frames generated per second. It has to be a
       string  in  the  format <u>frame_rate_num</u>/<u>frame_rate_den</u>, an integer number, a float number or a valid video
       frame rate abbreviation.

       The following abbreviations are recognized:

       <b>ntsc</b>
           30000/1001

       <b>pal</b> 25/1

       <b>qntsc</b>
           30000/1001

       <b>qpal</b>
           25/1

       <b>sntsc</b>
           30000/1001

       <b>spal</b>
           25/1

       <b>film</b>
           24/1

       <b>ntsc-film</b>
           24000/1001

   <b>Ratio</b>
       A ratio can be expressed as an expression, or in the form <u>numerator</u>:<u>denominator</u>.

       Note that a ratio with infinite (1/0) or negative value is considered valid, so you should check  on  the
       returned value if you want to exclude those values.

       The undefined value can be expressed using the "0:0" string.

   <b>Color</b>
       It can be the name of a color as defined below (case insensitive match) or a "[0x|#]RRGGBB[AA]" sequence,
       possibly followed by @ and a string representing the alpha component.

       The  alpha  component  may  be  a  string composed by "0x" followed by an hexadecimal number or a decimal
       number between 0.0 and 1.0, which represents the opacity value (<b>0x00</b> or <b>0.0</b> means completely transparent,
       <b>0xff</b> or <b>1.0</b> completely opaque). If the alpha component is not specified then <b>0xff</b> is assumed.

       The string <b>random</b> will result in a random color.

       The following names of colors are recognized:

       <b>AliceBlue</b>
           0xF0F8FF

       <b>AntiqueWhite</b>
           0xFAEBD7

       <b>Aqua</b>
           0x00FFFF

       <b>Aquamarine</b>
           0x7FFFD4

       <b>Azure</b>
           0xF0FFFF

       <b>Beige</b>
           0xF5F5DC

       <b>Bisque</b>
           0xFFE4C4

       <b>Black</b>
           0x000000

       <b>BlanchedAlmond</b>
           0xFFEBCD

       <b>Blue</b>
           0x0000FF

       <b>BlueViolet</b>
           0x8A2BE2

       <b>Brown</b>
           0xA52A2A

       <b>BurlyWood</b>
           0xDEB887

       <b>CadetBlue</b>
           0x5F9EA0

       <b>Chartreuse</b>
           0x7FFF00

       <b>Chocolate</b>
           0xD2691E

       <b>Coral</b>
           0xFF7F50

       <b>CornflowerBlue</b>
           0x6495ED

       <b>Cornsilk</b>
           0xFFF8DC

       <b>Crimson</b>
           0xDC143C

       <b>Cyan</b>
           0x00FFFF

       <b>DarkBlue</b>
           0x00008B

       <b>DarkCyan</b>
           0x008B8B

       <b>DarkGoldenRod</b>
           0xB8860B

       <b>DarkGray</b>
           0xA9A9A9

       <b>DarkGreen</b>
           0x006400

       <b>DarkKhaki</b>
           0xBDB76B

       <b>DarkMagenta</b>
           0x8B008B

       <b>DarkOliveGreen</b>
           0x556B2F

       <b>Darkorange</b>
           0xFF8C00

       <b>DarkOrchid</b>
           0x9932CC

       <b>DarkRed</b>
           0x8B0000

       <b>DarkSalmon</b>
           0xE9967A

       <b>DarkSeaGreen</b>
           0x8FBC8F

       <b>DarkSlateBlue</b>
           0x483D8B

       <b>DarkSlateGray</b>
           0x2F4F4F

       <b>DarkTurquoise</b>
           0x00CED1

       <b>DarkViolet</b>
           0x9400D3

       <b>DeepPink</b>
           0xFF1493

       <b>DeepSkyBlue</b>
           0x00BFFF

       <b>DimGray</b>
           0x696969

       <b>DodgerBlue</b>
           0x1E90FF

       <b>FireBrick</b>
           0xB22222

       <b>FloralWhite</b>
           0xFFFAF0

       <b>ForestGreen</b>
           0x228B22

       <b>Fuchsia</b>
           0xFF00FF

       <b>Gainsboro</b>
           0xDCDCDC

       <b>GhostWhite</b>
           0xF8F8FF

       <b>Gold</b>
           0xFFD700

       <b>GoldenRod</b>
           0xDAA520

       <b>Gray</b>
           0x808080

       <b>Green</b>
           0x008000

       <b>GreenYellow</b>
           0xADFF2F

       <b>HoneyDew</b>
           0xF0FFF0

       <b>HotPink</b>
           0xFF69B4

       <b>IndianRed</b>
           0xCD5C5C

       <b>Indigo</b>
           0x4B0082

       <b>Ivory</b>
           0xFFFFF0

       <b>Khaki</b>
           0xF0E68C

       <b>Lavender</b>
           0xE6E6FA

       <b>LavenderBlush</b>
           0xFFF0F5

       <b>LawnGreen</b>
           0x7CFC00

       <b>LemonChiffon</b>
           0xFFFACD

       <b>LightBlue</b>
           0xADD8E6

       <b>LightCoral</b>
           0xF08080

       <b>LightCyan</b>
           0xE0FFFF

       <b>LightGoldenRodYellow</b>
           0xFAFAD2

       <b>LightGreen</b>
           0x90EE90

       <b>LightGrey</b>
           0xD3D3D3

       <b>LightPink</b>
           0xFFB6C1

       <b>LightSalmon</b>
           0xFFA07A

       <b>LightSeaGreen</b>
           0x20B2AA

       <b>LightSkyBlue</b>
           0x87CEFA

       <b>LightSlateGray</b>
           0x778899

       <b>LightSteelBlue</b>
           0xB0C4DE

       <b>LightYellow</b>
           0xFFFFE0

       <b>Lime</b>
           0x00FF00

       <b>LimeGreen</b>
           0x32CD32

       <b>Linen</b>
           0xFAF0E6

       <b>Magenta</b>
           0xFF00FF

       <b>Maroon</b>
           0x800000

       <b>MediumAquaMarine</b>
           0x66CDAA

       <b>MediumBlue</b>
           0x0000CD

       <b>MediumOrchid</b>
           0xBA55D3

       <b>MediumPurple</b>
           0x9370D8

       <b>MediumSeaGreen</b>
           0x3CB371

       <b>MediumSlateBlue</b>
           0x7B68EE

       <b>MediumSpringGreen</b>
           0x00FA9A

       <b>MediumTurquoise</b>
           0x48D1CC

       <b>MediumVioletRed</b>
           0xC71585

       <b>MidnightBlue</b>
           0x191970

       <b>MintCream</b>
           0xF5FFFA

       <b>MistyRose</b>
           0xFFE4E1

       <b>Moccasin</b>
           0xFFE4B5

       <b>NavajoWhite</b>
           0xFFDEAD

       <b>Navy</b>
           0x000080

       <b>OldLace</b>
           0xFDF5E6

       <b>Olive</b>
           0x808000

       <b>OliveDrab</b>
           0x6B8E23

       <b>Orange</b>
           0xFFA500

       <b>OrangeRed</b>
           0xFF4500

       <b>Orchid</b>
           0xDA70D6

       <b>PaleGoldenRod</b>
           0xEEE8AA

       <b>PaleGreen</b>
           0x98FB98

       <b>PaleTurquoise</b>
           0xAFEEEE

       <b>PaleVioletRed</b>
           0xD87093

       <b>PapayaWhip</b>
           0xFFEFD5

       <b>PeachPuff</b>
           0xFFDAB9

       <b>Peru</b>
           0xCD853F

       <b>Pink</b>
           0xFFC0CB

       <b>Plum</b>
           0xDDA0DD

       <b>PowderBlue</b>
           0xB0E0E6

       <b>Purple</b>
           0x800080

       <b>Red</b> 0xFF0000

       <b>RosyBrown</b>
           0xBC8F8F

       <b>RoyalBlue</b>
           0x4169E1

       <b>SaddleBrown</b>
           0x8B4513

       <b>Salmon</b>
           0xFA8072

       <b>SandyBrown</b>
           0xF4A460

       <b>SeaGreen</b>
           0x2E8B57

       <b>SeaShell</b>
           0xFFF5EE

       <b>Sienna</b>
           0xA0522D

       <b>Silver</b>
           0xC0C0C0

       <b>SkyBlue</b>
           0x87CEEB

       <b>SlateBlue</b>
           0x6A5ACD

       <b>SlateGray</b>
           0x708090

       <b>Snow</b>
           0xFFFAFA

       <b>SpringGreen</b>
           0x00FF7F

       <b>SteelBlue</b>
           0x4682B4

       <b>Tan</b> 0xD2B48C

       <b>Teal</b>
           0x008080

       <b>Thistle</b>
           0xD8BFD8

       <b>Tomato</b>
           0xFF6347

       <b>Turquoise</b>
           0x40E0D0

       <b>Violet</b>
           0xEE82EE

       <b>Wheat</b>
           0xF5DEB3

       <b>White</b>
           0xFFFFFF

       <b>WhiteSmoke</b>
           0xF5F5F5

       <b>Yellow</b>
           0xFFFF00

       <b>YellowGreen</b>
           0x9ACD32

   <b>Channel</b> <b>Layout</b>
       A channel layout specifies the spatial disposition of the channels in a multi-channel  audio  stream.  To
       specify a channel layout, FFmpeg makes use of a special syntax.

       Individual channels are identified by an id, as given by the table below:

       <b>FL</b>  front left

       <b>FR</b>  front right

       <b>FC</b>  front center

       <b>LFE</b> low frequency

       <b>BL</b>  back left

       <b>BR</b>  back right

       <b>FLC</b> front left-of-center

       <b>FRC</b> front right-of-center

       <b>BC</b>  back center

       <b>SL</b>  side left

       <b>SR</b>  side right

       <b>TC</b>  top center

       <b>TFL</b> top front left

       <b>TFC</b> top front center

       <b>TFR</b> top front right

       <b>TBL</b> top back left

       <b>TBC</b> top back center

       <b>TBR</b> top back right

       <b>DL</b>  downmix left

       <b>DR</b>  downmix right

       <b>WL</b>  wide left

       <b>WR</b>  wide right

       <b>SDL</b> surround direct left

       <b>SDR</b> surround direct right

       <b>LFE2</b>
           low frequency 2

       Standard channel layout compositions can be specified by using the following identifiers:

       <b>mono</b>
           FC

       <b>stereo</b>
           FL+FR

       <b>2.1</b> FL+FR+LFE

       <b>3.0</b> FL+FR+FC

       <b>3.0(back)</b>
           FL+FR+BC

       <b>4.0</b> FL+FR+FC+BC

       <b>quad</b>
           FL+FR+BL+BR

       <b>quad(side)</b>
           FL+FR+SL+SR

       <b>3.1</b> FL+FR+FC+LFE

       <b>5.0</b> FL+FR+FC+BL+BR

       <b>5.0(side)</b>
           FL+FR+FC+SL+SR

       <b>4.1</b> FL+FR+FC+LFE+BC

       <b>5.1</b> FL+FR+FC+LFE+BL+BR

       <b>5.1(side)</b>
           FL+FR+FC+LFE+SL+SR

       <b>6.0</b> FL+FR+FC+BC+SL+SR

       <b>6.0(front)</b>
           FL+FR+FLC+FRC+SL+SR

       <b>3.1.2</b>
           FL+FR+FC+LFE+TFL+TFR

       <b>hexagonal</b>
           FL+FR+FC+BL+BR+BC

       <b>6.1</b> FL+FR+FC+LFE+BC+SL+SR

       <b>6.1</b> FL+FR+FC+LFE+BL+BR+BC

       <b>6.1(front)</b>
           FL+FR+LFE+FLC+FRC+SL+SR

       <b>7.0</b> FL+FR+FC+BL+BR+SL+SR

       <b>7.0(front)</b>
           FL+FR+FC+FLC+FRC+SL+SR

       <b>7.1</b> FL+FR+FC+LFE+BL+BR+SL+SR

       <b>7.1(wide)</b>
           FL+FR+FC+LFE+BL+BR+FLC+FRC

       <b>7.1(wide-side)</b>
           FL+FR+FC+LFE+FLC+FRC+SL+SR

       <b>5.1.2</b>
           FL+FR+FC+LFE+BL+BR+TFL+TFR

       <b>octagonal</b>
           FL+FR+FC+BL+BR+BC+SL+SR

       <b>cube</b>
           FL+FR+BL+BR+TFL+TFR+TBL+TBR

       <b>5.1.4</b>
           FL+FR+FC+LFE+BL+BR+TFL+TFR+TBL+TBR

       <b>7.1.2</b>
           FL+FR+FC+LFE+BL+BR+SL+SR+TFL+TFR

       <b>7.1.4</b>
           FL+FR+FC+LFE+BL+BR+SL+SR+TFL+TFR+TBL+TBR

       <b>7.2.3</b>
           FL+FR+FC+LFE+BL+BR+SL+SR+TFL+TFR+TBC+LFE2

       <b>9.1.4</b>
           FL+FR+FC+LFE+BL+BR+FLC+FRC+SL+SR+TFL+TFR+TBL+TBR

       <b>hexadecagonal</b>
           FL+FR+FC+BL+BR+BC+SL+SR+WL+WR+TBL+TBR+TBC+TFC+TFL+TFR

       <b>downmix</b>
           DL+DR

       <b>22.2</b>
           FL+FR+FC+LFE+BL+BR+FLC+FRC+BC+SL+SR+TC+TFL+TFC+TFR+TBL+TBC+TBR+LFE2+TSL+TSR+BFC+BFL+BFR

       A custom channel layout can be specified as a sequence of terms, separated by '+'.  Each term can be:

       •   the  name  of a single channel (e.g. <b>FL</b>, <b>FR</b>, <b>FC</b>, <b>LFE</b>, etc.), each optionally containing a custom name
           after a '@', (e.g. <b>FL@Left</b>, <b>FR@Right</b>, <b>FC@Center</b>, <b>LFE@Low_Frequency</b>, etc.)

       A standard channel layout can be specified by the following:

       •   the name of a single channel (e.g. <b>FL</b>, <b>FR</b>, <b>FC</b>, <b>LFE</b>, etc.)

       •   the name of a standard channel layout (e.g. <b>mono</b>, <b>stereo</b>, <b>4.0</b>, <b>quad</b>, <b>5.0</b>, etc.)

       •   a number of channels, in decimal, followed by 'c', yielding  the  default  channel  layout  for  that
           number  of  channels (see the function "av_channel_layout_default"). Note that not all channel counts
           have a default layout.

       •   a number of channels, in decimal, followed by 'C',  yielding  an  unknown  channel  layout  with  the
           specified  number of channels. Note that not all channel layout specification strings support unknown
           channel layouts.

       •   a  channel  layout  mask,  in  hexadecimal  starting  with  "0x"  (see  the   "AV_CH_*"   macros   in
           <u>libavutil/channel_layout.h</u>.

       Before  libavutil version 53 the trailing character "c" to specify a number of channels was optional, but
       now it is required, while a channel layout mask can also be specified as a decimal number (if and only if
       not followed by "c" or "C").

       See also the function "av_channel_layout_from_string" defined in <u>libavutil/channel_layout.h</u>.

</pre><h4><b>EXPRESSION</b> <b>EVALUATION</b></h4><pre>
       When evaluating an arithmetic expression, FFmpeg uses an internal formula evaluator, implemented  through
       the <u>libavutil/eval.h</u> interface.

       An expression may contain unary, binary operators, constants, and functions.

       Two  expressions  <u>expr1</u>  and  <u>expr2</u>  can be combined to form another expression "<u>expr1</u>;<u>expr2</u>".  <u>expr1</u> and
       <u>expr2</u> are evaluated in turn, and the new expression evaluates to the value of <u>expr2</u>.

       The following binary operators are available: "+", "-", "*", "/", "^".

       The following unary operators are available: "+", "-".

       Some internal variables can be used to store and load intermediary results. They can  be  accessed  using
       the "ld" and "st" functions with an index argument varying from 0 to 9 to specify which internal variable
       to access.

       The following functions are available:

       <b>abs(x)</b>
           Compute absolute value of <u>x</u>.

       <b>acos(x)</b>
           Compute arccosine of <u>x</u>.

       <b>asin(x)</b>
           Compute arcsine of <u>x</u>.

       <b>atan(x)</b>
           Compute arctangent of <u>x</u>.

       <b>atan2(y,</b> <b>x)</b>
           Compute principal value of the arc tangent of <u>y</u>/<u>x</u>.

       <b>between(x,</b> <b>min,</b> <b>max)</b>
           Return 1 if <u>x</u> is greater than or equal to <u>min</u> and lesser than or equal to <u>max</u>, 0 otherwise.

       <b>bitand(x,</b> <b>y)</b>
       <b>bitor(x,</b> <b>y)</b>
           Compute bitwise and/or operation on <u>x</u> and <u>y</u>.

           The  results  of  the  evaluation  of  <u>x</u> and <u>y</u> are converted to integers before executing the bitwise
           operation.

           Note that both the conversion to  integer  and  the  conversion  back  to  floating  point  can  lose
           precision. Beware of unexpected results for large numbers (usually 2^53 and larger).

       <b>ceil(expr)</b>
           Round the value of expression <u>expr</u> upwards to the nearest integer. For example, "ceil(1.5)" is "2.0".

       <b>clip(x,</b> <b>min,</b> <b>max)</b>
           Return the value of <u>x</u> clipped between <u>min</u> and <u>max</u>.

       <b>cos(x)</b>
           Compute cosine of <u>x</u>.

       <b>cosh(x)</b>
           Compute hyperbolic cosine of <u>x</u>.

       <b>eq(x,</b> <b>y)</b>
           Return 1 if <u>x</u> and <u>y</u> are equivalent, 0 otherwise.

       <b>exp(x)</b>
           Compute exponential of <u>x</u> (with base "e", the Euler's number).

       <b>floor(expr)</b>
           Round  the  value  of expression <u>expr</u> downwards to the nearest integer. For example, "floor(-1.5)" is
           "-2.0".

       <b>gauss(x)</b>
           Compute Gauss function of <u>x</u>, corresponding to "exp(-x*x/2) / sqrt(2*PI)".

       <b>gcd(x,</b> <b>y)</b>
           Return the greatest common divisor of <u>x</u> and <u>y</u>. If both <u>x</u> and <u>y</u> are 0 or either or both are less  than
           zero then behavior is undefined.

       <b>gt(x,</b> <b>y)</b>
           Return 1 if <u>x</u> is greater than <u>y</u>, 0 otherwise.

       <b>gte(x,</b> <b>y)</b>
           Return 1 if <u>x</u> is greater than or equal to <u>y</u>, 0 otherwise.

       <b>hypot(x,</b> <b>y)</b>
           This  function  is  similar  to  the C function with the same name; it returns "sqrt(<u>x</u>*<u>x</u> + <u>y</u>*<u>y</u>)", the
           length of the hypotenuse of a right triangle with sides of length <u>x</u> and <u>y</u>, or  the  distance  of  the
           point (<u>x</u>, <u>y</u>) from the origin.

       <b>if(x,</b> <b>y)</b>
           Evaluate  <u>x</u>,  and  if  the  result  is  non-zero  return  the result of the evaluation of <u>y</u>, return 0
           otherwise.

       <b>if(x,</b> <b>y,</b> <b>z)</b>
           Evaluate <u>x</u>, and if the result is non-zero return the evaluation result of <u>y</u>, otherwise the evaluation
           result of <u>z</u>.

       <b>ifnot(x,</b> <b>y)</b>
           Evaluate <u>x</u>, and if the result is zero return the result of the evaluation of <u>y</u>, return 0 otherwise.

       <b>ifnot(x,</b> <b>y,</b> <b>z)</b>
           Evaluate <u>x</u>, and if the result is zero return the evaluation result of  <u>y</u>,  otherwise  the  evaluation
           result of <u>z</u>.

       <b>isinf(x)</b>
           Return 1.0 if <u>x</u> is +/-INFINITY, 0.0 otherwise.

       <b>isnan(x)</b>
           Return 1.0 if <u>x</u> is NAN, 0.0 otherwise.

       <b>ld(idx)</b>
           Load  the  value  of  the  internal variable with index <u>idx</u>, which was previously stored with st(<u>idx</u>,
           <u>expr</u>).  The function returns the loaded value.

       <b>lerp(x,</b> <b>y,</b> <b>z)</b>
           Return linear interpolation between <u>x</u> and <u>y</u> by amount of <u>z</u>.

       <b>log(x)</b>
           Compute natural logarithm of <u>x</u>.

       <b>lt(x,</b> <b>y)</b>
           Return 1 if <u>x</u> is lesser than <u>y</u>, 0 otherwise.

       <b>lte(x,</b> <b>y)</b>
           Return 1 if <u>x</u> is lesser than or equal to <u>y</u>, 0 otherwise.

       <b>max(x,</b> <b>y)</b>
           Return the maximum between <u>x</u> and <u>y</u>.

       <b>min(x,</b> <b>y)</b>
           Return the minimum between <u>x</u> and <u>y</u>.

       <b>mod(x,</b> <b>y)</b>
           Compute the remainder of division of <u>x</u> by <u>y</u>.

       <b>not(expr)</b>
           Return 1.0 if <u>expr</u> is zero, 0.0 otherwise.

       <b>pow(x,</b> <b>y)</b>
           Compute the power of <u>x</u> elevated <u>y</u>, it is equivalent to "(<u>x</u>)^(<u>y</u>)".

       <b>print(t)</b>
       <b>print(t,</b> <b>l)</b>
           Print the value of expression <u>t</u> with loglevel <u>l</u>. If <u>l</u> is not specified then a default  log  level  is
           used.  Return the value of the expression printed.

       <b>random(idx)</b>
           Return  a  pseudo random value between 0.0 and 1.0. <u>idx</u> is the index of the internal variable used to
           save the seed/state, which can be previously stored with st(idx).

           To initialize the seed, you need to store the seed value as a 64-bit unsigned integer in the internal
           variable with index <u>idx</u>.

           For example, to store the seed with value 42 in the internal variable with index 0 and  print  a  few
           random values:

                   st(0,42); print(<a href="../man0/random.0.html">random</a>(0)); print(<a href="../man0/random.0.html">random</a>(0)); print(<a href="../man0/random.0.html">random</a>(0))

       <b>randomi(idx,</b> <b>min,</b> <b>max)</b>
           Return  a  pseudo  random value in the interval between <u>min</u> and <u>max</u>. <u>idx</u> is the index of the internal
           variable which will be used to save the seed/state, which can be previously stored with st(idx).

           To initialize the seed, you need to store the seed value as a 64-bit unsigned integer in the internal
           variable with index <u>idx</u>.

       <b>root(expr,</b> <b>max)</b>
           Find an input value for which the function represented by <u>expr</u>  with  argument  <u><b><a href="../man0/ld.0.html">ld</a></b>(0)</u>  is  0  in  the
           interval 0..<u>max</u>.

           The expression in <u>expr</u> must denote a continuous function or the result is undefined.

           <u><b><a href="../man0/ld.0.html">ld</a></b>(0)</u>  is  used  to represent the function input value, which means that the given expression will be
           evaluated multiple times with various input values that the expression can access through <a href="../man0/ld.0.html">ld</a>(0). When
           the expression evaluates to 0 then the corresponding input value will be returned.

       <b>round(expr)</b>
           Round the value of expression <u>expr</u> to the nearest integer. For example, "round(1.5)" is "2.0".

       <b>sgn(x)</b>
           Compute sign of <u>x</u>.

       <b>sin(x)</b>
           Compute sine of <u>x</u>.

       <b>sinh(x)</b>
           Compute hyperbolic sine of <u>x</u>.

       <b>sqrt(expr)</b>
           Compute the square root of <u>expr</u>. This is equivalent to "(<u>expr</u>)^.5".

       <b>squish(x)</b>
           Compute expression "1/(1 + exp(4*x))".

       <b>st(idx,</b> <b>expr)</b>
           Store the value of the expression <u>expr</u> in an internal  variable.  <u>idx</u>  specifies  the  index  of  the
           variable  where  to  store the value, and it is a value ranging from 0 to 9. The function returns the
           value stored in the internal variable.

           The stored value can be retrieved with ld(var).

           Note: variables are currently not shared between expressions.

       <b>tan(x)</b>
           Compute tangent of <u>x</u>.

       <b>tanh(x)</b>
           Compute hyperbolic tangent of <u>x</u>.

       <b>taylor(expr,</b> <b>x)</b>
       <b>taylor(expr,</b> <b>x,</b> <b>idx)</b>
           Evaluate a Taylor series at <u>x</u>, given an  expression  representing  the  ld(idx)-th  derivative  of  a
           function at 0.

           When the series does not converge the result is undefined.

           <u>ld(idx)</u> is used to represent the derivative order in <u>expr</u>, which means that the given expression will
           be evaluated multiple times with various input values that the expression can access through ld(idx).
           If <u>idx</u> is not specified then 0 is assumed.

           Note, when you have the derivatives at y instead of 0, "taylor(expr, x-y)" can be used.

       <b><a href="../man0/time.0.html">time</a>(0)</b>
           Return the current (wallclock) time in seconds.

       <b>trunc(expr)</b>
           Round the value of expression <u>expr</u> towards zero to the nearest integer. For example, "trunc(-1.5)" is
           "-1.0".

       <b>while(cond,</b> <b>expr)</b>
           Evaluate  expression  <u>expr</u>  while  the expression <u>cond</u> is non-zero, and returns the value of the last
           <u>expr</u> evaluation, or NAN if <u>cond</u> was always false.

       The following constants are available:

       <b>PI</b>  area of the unit disc, approximately 3.14

       <b>E</b>   <b><a href="../man1/exp.1.html">exp</a></b>(1) (Euler's number), approximately 2.718

       <b>PHI</b> golden ratio (1+<b><a href="../man5/sqrt.5.html">sqrt</a></b>(5))/2, approximately 1.618

       Assuming that an expression is considered "true" if it has a non-zero value, note that:

       "*" works like AND

       "+" works like OR

       For example the construct:

               if (A AND B) then C

       is equivalent to:

               if(A*B, C)

       In your C code, you can extend the list of unary and binary functions, and define  recognized  constants,
       so that they are available for your expressions.

       The  evaluator  also  recognizes  the  International  System unit prefixes.  If 'i' is appended after the
       prefix, binary prefixes are used, which are based on powers of 1024 instead of powers of 1000.   The  'B'
       postfix  multiplies  the  value  by 8, and can be appended after a unit prefix or used alone. This allows
       using for example 'KB', 'MiB', 'G' and 'B' as number postfix.

       The list of available International System prefixes follows, with indication of the corresponding  powers
       of 10 and of 2.

       <b>y</b>   10^-24 / 2^-80

       <b>z</b>   10^-21 / 2^-70

       <b>a</b>   10^-18 / 2^-60

       <b>f</b>   10^-15 / 2^-50

       <b>p</b>   10^-12 / 2^-40

       <b>n</b>   10^-9 / 2^-30

       <b>u</b>   10^-6 / 2^-20

       <b>m</b>   10^-3 / 2^-10

       <b>c</b>   10^-2

       <b>d</b>   10^-1

       <b>h</b>   10^2

       <b>k</b>   10^3 / 2^10

       <b>K</b>   10^3 / 2^10

       <b>M</b>   10^6 / 2^20

       <b>G</b>   10^9 / 2^30

       <b>T</b>   10^12 / 2^40

       <b>P</b>   10^15 / 2^50

       <b>E</b>   10^18 / 2^60

       <b>Z</b>   10^21 / 2^70

       <b>Y</b>   10^24 / 2^80

</pre><h4><b>CODEC</b> <b>OPTIONS</b></h4><pre>
       libavcodec  provides  some  generic global options, which can be set on all the encoders and decoders. In
       addition, each codec may support so-called private options, which are specific for a given codec.

       Sometimes, a global option may only affect a specific kind of codec, and may be nonsensical or ignored by
       another, so you need to be aware of the meaning of the specified options. Also  some  options  are  meant
       only for decoding or encoding.

       Options may be set by specifying -<u>option</u> <u>value</u> in the FFmpeg tools, or by setting the value explicitly in
       the "AVCodecContext" options or using the <u>libavutil/opt.h</u> API for programmatic use.

       The list of supported options follow:

       <b>b</b> <u>integer</u> <b>(</b><u>encoding,audio,video</u><b>)</b>
           Set bitrate in bits/s. Default value is 200K.

       <b>ab</b> <u>integer</u> <b>(</b><u>encoding,audio</u><b>)</b>
           Set audio bitrate (in bits/s). Default value is 128K.

       <b>bt</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set  video  bitrate  tolerance  (in  bits/s).  In  1-pass  mode,  bitrate tolerance specifies how far
           ratecontrol is willing to deviate from the target average bitrate  value.  This  is  not  related  to
           min/max bitrate. Lowering tolerance too much has an adverse effect on quality.

       <b>flags</b> <u>flags</u> <b>(</b><u>decoding/encoding,audio,video,subtitles</u><b>)</b>
           Set generic flags.

           Possible values:

           <b>mv4</b> Use four motion vector by macroblock (mpeg4).

           <b>qpel</b>
               Use 1/4 pel motion compensation.

           <b>loop</b>
               Use loop filter.

           <b>qscale</b>
               Use fixed qscale.

           <b>pass1</b>
               Use internal 2pass ratecontrol in first pass mode.

           <b>pass2</b>
               Use internal 2pass ratecontrol in second pass mode.

           <b>gray</b>
               Only decode/encode grayscale.

           <b>psnr</b>
               Set error[?] variables during encoding.

           <b>truncated</b>
               Input bitstream might be randomly truncated.

           <b>drop_changed</b>
               Don't  output  frames  whose  parameters  differ  from  first  decoded  frame  in  stream.  Error
               AVERROR_INPUT_CHANGED is returned when a frame is dropped.

           <b>ildct</b>
               Use interlaced DCT.

           <b>low_delay</b>
               Force low delay.

           <b>global_header</b>
               Place global headers in extradata instead of every keyframe.

           <b>bitexact</b>
               Only write platform-, build- and time-independent data. (except (I)DCT).  This ensures that  file
               and  data  checksums  are  reproducible  and  match  between  platforms.  Its  primary use is for
               regression testing.

           <b>aic</b> Apply H263 advanced intra coding / mpeg4 ac prediction.

           <b>ilme</b>
               Apply interlaced motion estimation.

           <b>cgop</b>
               Use closed gop.

           <b>output_corrupt</b>
               Output even potentially corrupted frames.

       <b>time_base</b> <u>rational</u> <u>number</u>
           Set codec time base.

           It is the fundamental unit of time (in seconds) in terms of which frame timestamps  are  represented.
           For  fixed-fps  content,  timebase  should  be  "1  /  frame_rate" and timestamp increments should be
           identically 1.

       <b>g</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set the group of picture (GOP) size. Default value is 12.

       <b>ar</b> <u>integer</u> <b>(</b><u>decoding/encoding,audio</u><b>)</b>
           Set audio sampling rate (in Hz).

       <b>ac</b> <u>integer</u> <b>(</b><u>decoding/encoding,audio</u><b>)</b>
           Set number of audio channels.

       <b>cutoff</b> <u>integer</u> <b>(</b><u>encoding,audio</u><b>)</b>
           Set cutoff bandwidth. (Supported only  by  selected  encoders,  see  their  respective  documentation
           sections.)

       <b>frame_size</b> <u>integer</u> <b>(</b><u>encoding,audio</u><b>)</b>
           Set audio frame size.

           Each  submitted  frame  except the last must contain exactly frame_size samples per channel. May be 0
           when the codec has CODEC_CAP_VARIABLE_FRAME_SIZE set, in that case the frame size is not  restricted.
           It is set by some decoders to indicate constant frame size.

       <b>frame_number</b> <u>integer</u>
           Set the frame number.

       <b>delay</b> <u>integer</u>
       <b>qcomp</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set  video  quantizer  scale compression (VBR). It is used as a constant in the ratecontrol equation.
           Recommended range for default rc_eq: 0.0-1.0.

       <b>qblur</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set video quantizer scale blur (VBR).

       <b>qmin</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set min video quantizer scale (VBR). Must be included between -1 and 69, default value is 2.

       <b>qmax</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set max video quantizer scale (VBR). Must be included between -1 and 1024, default value is 31.

       <b>qdiff</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set max difference between the quantizer scale (VBR).

       <b>bf</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set max number of B frames between non-B-frames.

           Must be an integer between -1 and 16. 0 means that B-frames are disabled. If a value of -1  is  used,
           it will choose an automatic value depending on the encoder.

           Default value is 0.

       <b>b_qfactor</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set qp factor between P and B frames.

       <b>codec_tag</b> <u>integer</u>
       <b>bug</b> <u>flags</u> <b>(</b><u>decoding,video</u><b>)</b>
           Workaround not auto detected encoder bugs.

           Possible values:

           <b>autodetect</b>
           <b>xvid_ilace</b>
               Xvid interlacing bug (autodetected if fourcc==XVIX)

           <b>ump4</b>
               (autodetected if fourcc==UMP4)

           <b>no_padding</b>
               padding bug (autodetected)

           <b>amv</b>
           <b>qpel_chroma</b>
           <b>std_qpel</b>
               old standard qpel (autodetected per fourcc/version)

           <b>qpel_chroma2</b>
           <b>direct_blocksize</b>
               direct-qpel-blocksize bug (autodetected per fourcc/version)

           <b>edge</b>
               edge padding bug (autodetected per fourcc/version)

           <b>hpel_chroma</b>
           <b>dc_clip</b>
           <b>ms</b>  Workaround various bugs in microsoft broken decoders.

           <b>trunc</b>
               trancated frames

       <b>strict</b> <u>integer</u> <b>(</b><u>decoding/encoding,audio,video</u><b>)</b>
           Specify how strictly to follow the standards.

           Possible values:

           <b>very</b>
               strictly conform to an older more strict version of the spec or reference software

           <b>strict</b>
               strictly conform to all the things in the spec no matter what consequences

           <b>normal</b>
           <b>unofficial</b>
               allow unofficial extensions

           <b>experimental</b>
               allow  non  standardized  experimental things, experimental (unfinished/work in progress/not well
               tested) decoders and encoders.  Note: experimental decoders can pose a security risk, do not  use
               this for decoding untrusted input.

       <b>b_qoffset</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set QP offset between P and B frames.

       <b>err_detect</b> <u>flags</u> <b>(</b><u>decoding,audio,video</u><b>)</b>
           Set error detection flags.

           Possible values:

           <b>crccheck</b>
               verify embedded CRCs

           <b>bitstream</b>
               detect bitstream specification deviations

           <b>buffer</b>
               detect improper bitstream length

           <b>explode</b>
               abort decoding on minor error detection

           <b>ignore_err</b>
               ignore decoding errors, and continue decoding.  This is useful if you want to analyze the content
               of  a video and thus want everything to be decoded no matter what. This option will not result in
               a video that is pleasing to watch in case of errors.

           <b>careful</b>
               consider things that violate the spec and have not been seen in the wild as errors

           <b>compliant</b>
               consider all spec non compliancies as errors

           <b>aggressive</b>
               consider things that a sane encoder should not do as an error

       <b>has_b_frames</b> <u>integer</u>
       <b>block_align</b> <u>integer</u>
       <b>rc_override_count</b> <u>integer</u>
       <b>maxrate</b> <u>integer</u> <b>(</b><u>encoding,audio,video</u><b>)</b>
           Set max bitrate tolerance (in bits/s). Requires bufsize to be set.

       <b>minrate</b> <u>integer</u> <b>(</b><u>encoding,audio,video</u><b>)</b>
           Set min bitrate tolerance (in bits/s). Most useful in setting up a CBR encode. It is  of  little  use
           elsewise.

       <b>bufsize</b> <u>integer</u> <b>(</b><u>encoding,audio,video</u><b>)</b>
           Set ratecontrol buffer size (in bits).

       <b>i_qfactor</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set QP factor between P and I frames.

       <b>i_qoffset</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set QP offset between P and I frames.

       <b>dct</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set DCT algorithm.

           Possible values:

           <b>auto</b>
               autoselect a good one (default)

           <b>fastint</b>
               fast integer

           <b>int</b> accurate integer

           <b>mmx</b>
           <b>altivec</b>
           <b>faan</b>
               floating point AAN DCT

       <b>lumi_mask</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Compress bright areas stronger than medium ones.

       <b>tcplx_mask</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set temporal complexity masking.

       <b>scplx_mask</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set spatial complexity masking.

       <b>p_mask</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set inter masking.

       <b>dark_mask</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
           Compress dark areas stronger than medium ones.

       <b>idct</b> <u>integer</u> <b>(</b><u>decoding/encoding,video</u><b>)</b>
           Select IDCT implementation.

           Possible values:

           <b>auto</b>
           <b>int</b>
           <b>simple</b>
           <b>simplemmx</b>
           <b>simpleauto</b>
               Automatically pick a IDCT compatible with the simple one

           <b>arm</b>
           <b>altivec</b>
           <b>sh4</b>
           <b>simplearm</b>
           <b>simplearmv5te</b>
           <b>simplearmv6</b>
           <b>simpleneon</b>
           <b>xvid</b>
           <b>faani</b>
               floating point AAN IDCT

       <b>slice_count</b> <u>integer</u>
       <b>ec</b> <u>flags</u> <b>(</b><u>decoding,video</u><b>)</b>
           Set error concealment strategy.

           Possible values:

           <b>guess_mvs</b>
               iterative motion vector (MV) search (slow)

           <b>deblock</b>
               use strong deblock filter for damaged MBs

           <b>favor_inter</b>
               favor predicting from the previous frame instead of the current

       <b>bits_per_coded_sample</b> <u>integer</u>
       <b>aspect</b> <u>rational</u> <u>number</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set sample aspect ratio.

       <b>sar</b> <u>rational</u> <u>number</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set sample aspect ratio. Alias to <u>aspect</u>.

       <b>debug</b> <u>flags</u> <b>(</b><u>decoding/encoding,audio,video,subtitles</u><b>)</b>
           Print specific debug info.

           Possible values:

           <b>pict</b>
               picture info

           <b>rc</b>  rate control

           <b>bitstream</b>
           <b>mb_type</b>
               macroblock (MB) type

           <b>qp</b>  per-block quantization parameter (QP)

           <b>dct_coeff</b>
           <b>green_metadata</b>
               display complexity metadata for the upcoming frame, GoP or for a given duration.

           <b>skip</b>
           <b>startcode</b>
           <b>er</b>  error recognition

           <b>mmco</b>
               memory management control operations (H.264)

           <b>bugs</b>
           <b>buffers</b>
               picture buffer allocations

           <b>thread_ops</b>
               threading operations

           <b>nomc</b>
               skip motion compensation

       <b>cmp</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set full pel me compare function.

           Possible values:

           <b>sad</b> sum of absolute differences, fast (default)

           <b>sse</b> sum of squared errors

           <b>satd</b>
               sum of absolute Hadamard transformed differences

           <b>dct</b> sum of absolute DCT transformed differences

           <b>psnr</b>
               sum of squared quantization errors (avoid, low quality)

           <b>bit</b> number of bits needed for the block

           <b>rd</b>  rate distortion optimal, slow

           <b>zero</b>
               0

           <b>vsad</b>
               sum of absolute vertical differences

           <b>vsse</b>
               sum of squared vertical differences

           <b>nsse</b>
               noise preserving sum of squared differences

           <b>w53</b> 5/3 wavelet, only used in snow

           <b>w97</b> 9/7 wavelet, only used in snow

           <b>dctmax</b>
           <b>chroma</b>
       <b>subcmp</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set sub pel me compare function.

           Possible values:

           <b>sad</b> sum of absolute differences, fast (default)

           <b>sse</b> sum of squared errors

           <b>satd</b>
               sum of absolute Hadamard transformed differences

           <b>dct</b> sum of absolute DCT transformed differences

           <b>psnr</b>
               sum of squared quantization errors (avoid, low quality)

           <b>bit</b> number of bits needed for the block

           <b>rd</b>  rate distortion optimal, slow

           <b>zero</b>
               0

           <b>vsad</b>
               sum of absolute vertical differences

           <b>vsse</b>
               sum of squared vertical differences

           <b>nsse</b>
               noise preserving sum of squared differences

           <b>w53</b> 5/3 wavelet, only used in snow

           <b>w97</b> 9/7 wavelet, only used in snow

           <b>dctmax</b>
           <b>chroma</b>
       <b>mbcmp</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set macroblock compare function.

           Possible values:

           <b>sad</b> sum of absolute differences, fast (default)

           <b>sse</b> sum of squared errors

           <b>satd</b>
               sum of absolute Hadamard transformed differences

           <b>dct</b> sum of absolute DCT transformed differences

           <b>psnr</b>
               sum of squared quantization errors (avoid, low quality)

           <b>bit</b> number of bits needed for the block

           <b>rd</b>  rate distortion optimal, slow

           <b>zero</b>
               0

           <b>vsad</b>
               sum of absolute vertical differences

           <b>vsse</b>
               sum of squared vertical differences

           <b>nsse</b>
               noise preserving sum of squared differences

           <b>w53</b> 5/3 wavelet, only used in snow

           <b>w97</b> 9/7 wavelet, only used in snow

           <b>dctmax</b>
           <b>chroma</b>
       <b>ildctcmp</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set interlaced dct compare function.

           Possible values:

           <b>sad</b> sum of absolute differences, fast (default)

           <b>sse</b> sum of squared errors

           <b>satd</b>
               sum of absolute Hadamard transformed differences

           <b>dct</b> sum of absolute DCT transformed differences

           <b>psnr</b>
               sum of squared quantization errors (avoid, low quality)

           <b>bit</b> number of bits needed for the block

           <b>rd</b>  rate distortion optimal, slow

           <b>zero</b>
               0

           <b>vsad</b>
               sum of absolute vertical differences

           <b>vsse</b>
               sum of squared vertical differences

           <b>nsse</b>
               noise preserving sum of squared differences

           <b>w53</b> 5/3 wavelet, only used in snow

           <b>w97</b> 9/7 wavelet, only used in snow

           <b>dctmax</b>
           <b>chroma</b>
       <b>dia_size</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set diamond type &amp; size for motion estimation.

           <b>(1024,</b> <b>INT_MAX)</b>
               full motion estimation(slowest)

           <b>(768,</b> <b>1024]</b>
               umh motion estimation

           <b>(512,</b> <b>768]</b>
               hex motion estimation

           <b>(256,</b> <b>512]</b>
               l2s diamond motion estimation

           <b>[2,256]</b>
               var diamond motion estimation

           <b>(-1,</b>  <b>2)</b>
               small diamond motion estimation

           <b>-1</b>  funny diamond motion estimation

           <b>(INT_MIN,</b> <b>-1)</b>
               sab diamond motion estimation

       <b>last_pred</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set amount of motion predictors from the previous frame.

       <b>precmp</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set pre motion estimation compare function.

           Possible values:

           <b>sad</b> sum of absolute differences, fast (default)

           <b>sse</b> sum of squared errors

           <b>satd</b>
               sum of absolute Hadamard transformed differences

           <b>dct</b> sum of absolute DCT transformed differences

           <b>psnr</b>
               sum of squared quantization errors (avoid, low quality)

           <b>bit</b> number of bits needed for the block

           <b>rd</b>  rate distortion optimal, slow

           <b>zero</b>
               0

           <b>vsad</b>
               sum of absolute vertical differences

           <b>vsse</b>
               sum of squared vertical differences

           <b>nsse</b>
               noise preserving sum of squared differences

           <b>w53</b> 5/3 wavelet, only used in snow

           <b>w97</b> 9/7 wavelet, only used in snow

           <b>dctmax</b>
           <b>chroma</b>
       <b>pre_dia_size</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set diamond type &amp; size for motion estimation pre-pass.

       <b>subq</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set sub pel motion estimation quality.

       <b>me_range</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set limit motion vectors range (1023 for DivX player).

       <b>global_quality</b> <u>integer</u> <b>(</b><u>encoding,audio,video</u><b>)</b>
       <b>slice_flags</b> <u>integer</u>
       <b>mbd</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set macroblock decision algorithm (high quality mode).

           Possible values:

           <b>simple</b>
               use mbcmp (default)

           <b>bits</b>
               use fewest bits

           <b>rd</b>  use best rate distortion

       <b>rc_init_occupancy</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set number of bits which should be loaded into the rc buffer before decoding starts.

       <b>flags2</b> <u>flags</u> <b>(</b><u>decoding/encoding,audio,video,subtitles</u><b>)</b>
           Possible values:

           <b>fast</b>
               Allow non spec compliant speedup tricks.

           <b>noout</b>
               Skip bitstream encoding.

           <b>ignorecrop</b>
               Ignore cropping information from sps.

           <b>local_header</b>
               Place global headers at every keyframe instead of in extradata.

           <b>chunks</b>
               Frame data might be split into multiple chunks.

           <b>showall</b>
               Show all frames before the first keyframe.

           <b>export_mvs</b>
               Export  motion  vectors into frame side-data (see "AV_FRAME_DATA_MOTION_VECTORS") for codecs that
               support it. See also <u>doc/examples/export_mvs.c</u>.

           <b>skip_manual</b>
               Do not skip samples and export skip information as frame side data.

           <b>ass_ro_flush_noop</b>
               Do not reset ASS ReadOrder field on flush.

           <b>icc_profiles</b>
               Generate/parse embedded ICC profiles from/to colorimetry tags.

       <b>export_side_data</b> <u>flags</u> <b>(</b><u>decoding/encoding,audio,video,subtitles</u><b>)</b>
           Possible values:

           <b>mvs</b> Export motion vectors into frame side-data (see "AV_FRAME_DATA_MOTION_VECTORS") for  codecs  that
               support it. See also <u>doc/examples/export_mvs.c</u>.

           <b>prft</b>
               Export  encoder Producer Reference Time into packet side-data (see "AV_PKT_DATA_PRFT") for codecs
               that support it.

           <b>venc_params</b>
               Export video encoding parameters through frame side data  (see  "AV_FRAME_DATA_VIDEO_ENC_PARAMS")
               for codecs that support it. At present, those are H.264 and VP9.

           <b>film_grain</b>
               Export  film  grain  parameters  through frame side data (see "AV_FRAME_DATA_FILM_GRAIN_PARAMS").
               Supported at present by AV1 decoders.

       <b>threads</b> <u>integer</u> <b>(</b><u>decoding/encoding,video</u><b>)</b>
           Set the number of threads to be used, in case  the  selected  codec  implementation  supports  multi-
           threading.

           Possible values:

           <b>auto,</b> <b>0</b>
               automatically select the number of threads to set

           Default value is <b>auto</b>.

       <b>dc</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set intra_dc_precision.

       <b>nssew</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set nsse weight.

       <b>skip_top</b> <u>integer</u> <b>(</b><u>decoding,video</u><b>)</b>
           Set number of macroblock rows at the top which are skipped.

       <b>skip_bottom</b> <u>integer</u> <b>(</b><u>decoding,video</u><b>)</b>
           Set number of macroblock rows at the bottom which are skipped.

       <b>profile</b> <u>integer</u> <b>(</b><u>encoding,audio,video</u><b>)</b>
           Set  encoder codec profile. Default value is <b>unknown</b>. Encoder specific profiles are documented in the
           relevant encoder documentation.

       <b>level</b> <u>integer</u> <b>(</b><u>encoding,audio,video</u><b>)</b>
           Set the encoder level. This level depends on the specific codec, and might correspond to the  profile
           level. It is set by default to <b>unknown</b>.

           Possible values:

           <b>unknown</b>
       <b>lowres</b> <u>integer</u> <b>(</b><u>decoding,audio,video</u><b>)</b>
           Decode at 1= 1/2, 2=1/4, 3=1/8 resolutions.

       <b>mblmin</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set min macroblock lagrange factor (VBR).

       <b>mblmax</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set max macroblock lagrange factor (VBR).

       <b>skip_loop_filter</b> <u>integer</u> <b>(</b><u>decoding,video</u><b>)</b>
       <b>skip_idct</b>        <u>integer</u> <b>(</b><u>decoding,video</u><b>)</b>
       <b>skip_frame</b>       <u>integer</u> <b>(</b><u>decoding,video</u><b>)</b>
           Make decoder discard processing depending on the frame type selected by the option value.

           <b>skip_loop_filter</b>  skips  frame  loop filtering, <b>skip_idct</b> skips frame IDCT/dequantization, <b>skip_frame</b>
           skips decoding.

           Possible values:

           <b>none</b>
               Discard no frame.

           <b>default</b>
               Discard useless frames like 0-sized frames.

           <b>noref</b>
               Discard all non-reference frames.

           <b>bidir</b>
               Discard all bidirectional frames.

           <b>nokey</b>
               Discard all frames excepts keyframes.

           <b>nointra</b>
               Discard all frames except I frames.

           <b>all</b> Discard all frames.

           Default value is <b>default</b>.

       <b>bidir_refine</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Refine the two motion vectors used in bidirectional macroblocks.

       <b>keyint_min</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set minimum interval between IDR-frames.

       <b>refs</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Set reference frames to consider for motion compensation.

       <b>trellis</b> <u>integer</u> <b>(</b><u>encoding,audio,video</u><b>)</b>
           Set rate-distortion optimal quantization.

       <b>mv0_threshold</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
       <b>compression_level</b> <u>integer</u> <b>(</b><u>encoding,audio,video</u><b>)</b>
       <b>bits_per_raw_sample</b> <u>integer</u>
       <b>channel_layout</b> <u>integer</u> <b>(</b><u>decoding/encoding,audio</u><b>)</b>
           See <b>the</b> <b>Channel</b> <b>Layout</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for the required syntax.

       <b>rc_max_vbv_use</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
       <b>rc_min_vbv_use</b> <u>float</u> <b>(</b><u>encoding,video</u><b>)</b>
       <b>color_primaries</b> <u>integer</u> <b>(</b><u>decoding/encoding,video</u><b>)</b>
           Possible values:

           <b>bt709</b>
               BT.709

           <b>bt470m</b>
               BT.470 M

           <b>bt470bg</b>
               BT.470 BG

           <b>smpte170m</b>
               SMPTE 170 M

           <b>smpte240m</b>
               SMPTE 240 M

           <b>film</b>
               Film

           <b>bt2020</b>
               BT.2020

           <b>smpte428</b>
           <b>smpte428_1</b>
               SMPTE ST 428-1

           <b>smpte431</b>
               SMPTE 431-2

           <b>smpte432</b>
               SMPTE 432-1

           <b>jedec-p22</b>
               JEDEC P22

       <b>color_trc</b> <u>integer</u> <b>(</b><u>decoding/encoding,video</u><b>)</b>
           Possible values:

           <b>bt709</b>
               BT.709

           <b>gamma22</b>
               BT.470 M

           <b>gamma28</b>
               BT.470 BG

           <b>smpte170m</b>
               SMPTE 170 M

           <b>smpte240m</b>
               SMPTE 240 M

           <b>linear</b>
               Linear

           <b>log</b>
           <b>log100</b>
               Log

           <b>log_sqrt</b>
           <b>log316</b>
               Log square root

           <b>iec61966_2_4</b>
           <b>iec61966-2-4</b>
               IEC 61966-2-4

           <b>bt1361</b>
           <b>bt1361e</b>
               BT.1361

           <b>iec61966_2_1</b>
           <b>iec61966-2-1</b>
               IEC 61966-2-1

           <b>bt2020_10</b>
           <b>bt2020_10bit</b>
               BT.2020 - 10 bit

           <b>bt2020_12</b>
           <b>bt2020_12bit</b>
               BT.2020 - 12 bit

           <b>smpte2084</b>
               SMPTE ST 2084

           <b>smpte428</b>
           <b>smpte428_1</b>
               SMPTE ST 428-1

           <b>arib-std-b67</b>
               ARIB STD-B67

       <b>colorspace</b> <u>integer</u> <b>(</b><u>decoding/encoding,video</u><b>)</b>
           Possible values:

           <b>rgb</b> RGB

           <b>bt709</b>
               BT.709

           <b>fcc</b> FCC

           <b>bt470bg</b>
               BT.470 BG

           <b>smpte170m</b>
               SMPTE 170 M

           <b>smpte240m</b>
               SMPTE 240 M

           <b>ycocg</b>
               YCOCG

           <b>bt2020nc</b>
           <b>bt2020_ncl</b>
               BT.2020 NCL

           <b>bt2020c</b>
           <b>bt2020_cl</b>
               BT.2020 CL

           <b>smpte2085</b>
               SMPTE 2085

           <b>chroma-derived-nc</b>
               Chroma-derived NCL

           <b>chroma-derived-c</b>
               Chroma-derived CL

           <b>ictcp</b>
               ICtCp

       <b>color_range</b> <u>integer</u> <b>(</b><u>decoding/encoding,video</u><b>)</b>
           If used as input parameter, it serves as a hint to the decoder,  which  color_range  the  input  has.
           Possible values:

           <b>tv</b>
           <b>mpeg</b>
           <b>limited</b>
               MPEG (219*2^(n-8))

           <b>pc</b>
           <b>jpeg</b>
           <b>full</b>
               JPEG (2^n-1)

       <b>chroma_sample_location</b> <u>integer</u> <b>(</b><u>decoding/encoding,video</u><b>)</b>
           Possible values:

           <b>left</b>
           <b>center</b>
           <b>topleft</b>
           <b>top</b>
           <b>bottomleft</b>
           <b>bottom</b>
       <b>log_level_offset</b> <u>integer</u>
           Set the log level offset.

       <b>slices</b> <u>integer</u> <b>(</b><u>encoding,video</u><b>)</b>
           Number of slices, used in parallelized encoding.

       <b>thread_type</b> <u>flags</u> <b>(</b><u>decoding/encoding,video</u><b>)</b>
           Select which multithreading methods to use.

           Use  of  <b>frame</b>  will increase decoding delay by one frame per thread, so clients which cannot provide
           future frames should not use it.

           Possible values:

           <b>slice</b>
               Decode more than one part of a single frame at once.

               Multithreading using slices works only when the video was encoded with slices.

           <b>frame</b>
               Decode more than one frame at once.

           Default value is <b>slice+frame</b>.

       <b>audio_service_type</b> <u>integer</u> <b>(</b><u>encoding,audio</u><b>)</b>
           Set audio service type.

           Possible values:

           <b>ma</b>  Main Audio Service

           <b>ef</b>  Effects

           <b>vi</b>  Visually Impaired

           <b>hi</b>  Hearing Impaired

           <b>di</b>  Dialogue

           <b>co</b>  Commentary

           <b>em</b>  Emergency

           <b>vo</b>  Voice Over

           <b>ka</b>  Karaoke

       <b>request_sample_fmt</b> <u>sample_fmt</u> <b>(</b><u>decoding,audio</u><b>)</b>
           Set sample format audio decoders should prefer. Default value is "none".

       <b>pkt_timebase</b> <u>rational</u> <u>number</u>
       <b>sub_charenc</b> <u>encoding</u> <b>(</b><u>decoding,subtitles</u><b>)</b>
           Set the input subtitles character encoding.

       <b>field_order</b>  <u>field_order</u> <b>(</b><u>video</u><b>)</b>
           Set/override the field order of the video.  Possible values:

           <b>progressive</b>
               Progressive video

           <b>tt</b>  Interlaced video, top field coded and displayed first

           <b>bb</b>  Interlaced video, bottom field coded and displayed first

           <b>tb</b>  Interlaced video, top coded first, bottom displayed first

           <b>bt</b>  Interlaced video, bottom coded first, top displayed first

       <b>skip_alpha</b> <u>bool</u> <b>(</b><u>decoding,video</u><b>)</b>
           Set to 1 to disable processing alpha (transparency). This works like  the  <b>gray</b>  flag  in  the  <b>flags</b>
           option which skips chroma information instead of alpha. Default is 0.

       <b>codec_whitelist</b> <u>list</u> <b>(</b><u>input</u><b>)</b>
           "," separated list of allowed decoders. By default all are allowed.

       <b>dump_separator</b> <u>string</u> <b>(</b><u>input</u><b>)</b>
           Separator  used  to separate the fields printed on the command line about the Stream parameters.  For
           example, to separate the fields with newlines and indentation:

                   ffprobe -dump_separator "
                                             "  -i <a href="file:~/videos/matrixbench_mpeg2.mpg">~/videos/matrixbench_mpeg2.mpg</a>

       <b>max_pixels</b> <u>integer</u> <b>(</b><u>decoding/encoding,video</u><b>)</b>
           Maximum number of pixels per image. This value can be used to avoid out of  memory  failures  due  to
           large images.

       <b>apply_cropping</b> <u>bool</u> <b>(</b><u>decoding,video</u><b>)</b>
           Enable  cropping  if cropping parameters are multiples of the required alignment for the left and top
           parameters. If the alignment is not met the cropping will be partially applied to maintain alignment.
           Default is 1 (enabled).  Note: The required alignment depends on if "AV_CODEC_FLAG_UNALIGNED" is  set
           and  the  CPU.  "AV_CODEC_FLAG_UNALIGNED"  cannot  be  changed  from  the command line. Also hardware
           decoders will not apply left/top Cropping.

</pre><h4><b>DECODERS</b></h4><pre>
       Decoders are configured elements in FFmpeg which allow the decoding of multimedia streams.

       When you configure your FFmpeg build, all the supported native decoders are enabled by default.  Decoders
       requiring  an  external library must be enabled manually via the corresponding "--enable-lib" option. You
       can list all available decoders using the configure option "--list-decoders".

       You can disable all the decoders with the configure option "--disable-decoders" and selectively enable  /
       disable single decoders with the options "--enable-decoder=<u>DECODER</u>" / "--disable-decoder=<u>DECODER</u>".

       The option "-decoders" of the ff* tools will display the list of enabled decoders.

</pre><h4><b>VIDEO</b> <b>DECODERS</b></h4><pre>
       A description of some of the currently available video decoders follows.

   <b>av1</b>
       AOMedia Video 1 (AV1) decoder.

       <u>Options</u>

       <b>operating_point</b>
           Select an operating point of a scalable AV1 bitstream (0 - 31). Default is 0.

   <b>hevc</b>
       HEVC (AKA ITU-T H.265 or ISO/IEC 23008-2) decoder.

       The decoder supports MV-HEVC multiview streams with at most two views. Views to be output are selected by
       supplying  a  list  of  view  IDs  to  the  decoder  (the <b>view_ids</b> option). This option may be set either
       statically before decoder init, or from the get_format() callback - useful for the  case  when  the  view
       count or IDs change dynamically during decoding.

       Only the base layer is decoded by default.

       Note  that  if  you are using the "ffmpeg" CLI tool, you should be using view specifiers as documented in
       its manual, rather than the options documented here.

       <u>Options</u>

       <b>view_ids</b> <b>(MV-HEVC)</b>
           Specify a list of view IDs that should be output. This option can also be set to a single '-1', which
           will cause all views defined in the VPS to be decoded and output.

       <b>view_ids_available</b> <b>(MV-HEVC)</b>
           This option may be read by the caller to retrieve an array of view IDs available in the  active  VPS.
           The array is empty for single-layer video.

           The  value  of  this option is guaranteed to be accurate when read from the get_format() callback. It
           may also be set at other times (e.g. after opening the decoder), but the value is informational  only
           and may be incorrect (e.g. when the stream contains multiple distinct VPS NALUs).

       <b>view_pos_available</b> <b>(MV-HEVC)</b>
           This  option  may  be  read  by  the  caller  to retrieve an array of view positions (left, right, or
           unspecified) available in the active VPS, as "AVStereo3DView" values. When the  array  is  available,
           its elements apply to the corresponding elements of <b>view_ids_available</b>, i.e.  "view_pos_available[i]"
           contains the position of view with ID "view_ids_available[i]".

           Same validity restrictions as for <b>view_ids_available</b> apply to this option.

   <b>rawvideo</b>
       Raw video decoder.

       This decoder decodes rawvideo streams.

       <u>Options</u>

       <b>top</b> <u>top_field_first</u>
           Specify the assumed field type of the input video.

           <b>-1</b>  the video is assumed to be progressive (default)

           <b>0</b>   bottom-field-first is assumed

           <b>1</b>   top-field-first is assumed

   <b>libdav1d</b>
       dav1d AV1 decoder.

       libdav1d  allows  libavcodec  to  decode  the  AOMedia Video 1 (AV1) codec.  Requires the presence of the
       libdav1d headers and library during configuration.  You need  to  explicitly  configure  the  build  with
       "--enable-libdav1d".

       <u>Options</u>

       The following options are supported by the libdav1d wrapper.

       <b>framethreads</b>
           Set amount of frame threads to use during decoding. The default value is 0 (autodetect).  This option
           is deprecated for libdav1d &gt;= 1.0 and will be removed in the future. Use the option "max_frame_delay"
           and the global option "threads" instead.

       <b>tilethreads</b>
           Set  amount of tile threads to use during decoding. The default value is 0 (autodetect).  This option
           is deprecated for libdav1d &gt;= 1.0 and will be removed in the future. Use the global option  "threads"
           instead.

       <b>max_frame_delay</b>
           Set max amount of frames the decoder may buffer internally. The default value is 0 (autodetect).

       <b>filmgrain</b>
           Apply  film  grain to the decoded video if present in the bitstream. Defaults to the internal default
           of the library.  This option is deprecated and will be removed in the future. See the  global  option
           "export_side_data" to export Film Grain parameters instead of applying it.

       <b>oppoint</b>
           Select  an  operating point of a scalable AV1 bitstream (0 - 31). Defaults to the internal default of
           the library.

       <b>alllayers</b>
           Output all spatial layers of a scalable AV1 bitstream. The default value is false.

   <b>libdavs2</b>
       AVS2-P2/IEEE1857.4 video decoder wrapper.

       This decoder allows libavcodec to decode AVS2 streams with davs2 library.

   <b>libuavs3d</b>
       AVS3-P2/IEEE1857.10 video decoder.

       libuavs3d allows libavcodec to decode AVS3 streams.  Requires the presence of the libuavs3d  headers  and
       library during configuration.  You need to explicitly configure the build with "--enable-libuavs3d".

       <u>Options</u>

       The following option is supported by the libuavs3d wrapper.

       <b>frame_threads</b>
           Set amount of frame threads to use during decoding. The default value is 0 (autodetect).

   <b>libxevd</b>
       eXtra-fast Essential Video Decoder (XEVD) MPEG-5 EVC decoder wrapper.

       This  decoder  requires the presence of the libxevd headers and library during configuration. You need to
       explicitly configure the build with <b>--enable-libxevd</b>.

       The xevd project website is at &lt;<b>https://github.com/mpeg5/xevd</b>&gt;.

       <u>Options</u>

       The following options are supported by the libxevd wrapper.  The xevd-equivalent options  or  values  are
       listed in parentheses for easy migration.

       To  get a more accurate and extensive documentation of the libxevd options, invoke the command  "xevd_app
       --help" or consult the libxevd documentation.

       <b>threads</b> <b>(</b><u>threads</u><b>)</b>
           Force to use a specific number of threads

   <b>QSV</b> <b>Decoders</b>
       The family of Intel QuickSync Video decoders (VC1, MPEG-2, H.264, HEVC, JPEG/MJPEG, VP8, VP9, AV1, VVC).

       <u>Common</u> <u>Options</u>

       The following options are supported by all qsv decoders.

       <u>async_depth</u>
           Internal parallelization depth, the higher the value the higher the latency.

       <u>gpu_copy</u>
           A GPU-accelerated copy between video and system memory

           <b>default</b>
           <b>on</b>
           <b>off</b>

       <u>HEVC</u> <u>Options</u>

       Extra options for hevc_qsv.

       <u>load_plugin</u>
           A user plugin to load in an internal session

           <b>none</b>
           <b>hevc_sw</b>
           <b>hevc_hw</b>
       <u>load_plugins</u>
           A :-separate list of hexadecimal plugin UIDs to load in an internal session

   <b>v210</b>
       Uncompressed 4:2:2 10-bit decoder.

       <u>Options</u>

       <b>custom_stride</b>
           Set the line size of the v210 data in bytes. The default value is 0 (autodetect).  You  can  use  the
           special -1 value for a strideless v210 as seen in BOXX files.

</pre><h4><b>AUDIO</b> <b>DECODERS</b></h4><pre>
       A description of some of the currently available audio decoders follows.

   <b>ac3</b>
       AC-3 audio decoder.

       This decoder implements part of ATSC A/52:2010 and ETSI TS 102 366, as well as the undocumented RealAudio
       3 (a.k.a. dnet).

       <u>AC-3</u> <u>Decoder</u> <u>Options</u>

       <b>-drc_scale</b> <u>value</u>
           Dynamic  Range  Scale  Factor. The factor to apply to dynamic range values from the AC-3 stream. This
           factor is applied exponentially. The default value is 1.  There are 3 notable scale factor ranges:

           <b>drc_scale</b> <b>==</b> <b>0</b>
               DRC disabled. Produces full range audio.

           <b>0</b> <b>&lt;</b> <b>drc_scale</b> <b>&lt;=</b> <b>1</b>
               DRC enabled.  Applies a fraction of the stream DRC value.  Audio  reproduction  is  between  full
               range and full compression.

           <b>drc_scale</b> <b>&gt;</b> <b>1</b>
               DRC  enabled.  Applies  drc_scale asymmetrically.  Loud sounds are fully compressed.  Soft sounds
               are enhanced.

   <b>flac</b>
       FLAC audio decoder.

       This decoder aims to implement the complete FLAC specification from Xiph.

       <u>FLAC</u> <u>Decoder</u> <u>options</u>

       <b>-use_buggy_lpc</b>
           The lavc FLAC encoder used to produce buggy streams with high lpc values (like  the  default  value).
           This  option  makes  it possible to decode such streams correctly by using lavc's old buggy lpc logic
           for decoding.

   <b>ffwavesynth</b>
       Internal wave synthesizer.

       This decoder generates wave patterns according to predefined sequences. Its use is  purely  internal  and
       the format of the data it accepts is not publicly documented.

   <b>libcelt</b>
       libcelt decoder wrapper.

       libcelt  allows libavcodec to decode the Xiph CELT ultra-low delay audio codec.  Requires the presence of
       the libcelt headers and library during configuration.  You need to explicitly configure  the  build  with
       "--enable-libcelt".

   <b>libgsm</b>
       libgsm decoder wrapper.

       libgsm  allows  libavcodec  to  decode the GSM full rate audio codec. Requires the presence of the libgsm
       headers  and  library  during  configuration.  You  need  to  explicitly   configure   the   build   with
       "--enable-libgsm".

       This decoder supports both the ordinary GSM and the Microsoft variant.

   <b>libilbc</b>
       libilbc decoder wrapper.

       libilbc  allows  libavcodec  to  decode  the  Internet Low Bitrate Codec (iLBC) audio codec. Requires the
       presence of the libilbc headers and library during configuration. You need to  explicitly  configure  the
       build with "--enable-libilbc".

       <u>Options</u>

       The following option is supported by the libilbc wrapper.

       <b>enhance</b>
           Enable the enhancement of the decoded audio when set to 1. The default value is 0 (disabled).

   <b>libopencore-amrnb</b>
       libopencore-amrnb decoder wrapper.

       libopencore-amrnb  allows  libavcodec  to decode the Adaptive Multi-Rate Narrowband audio codec. Using it
       requires the presence of the libopencore-amrnb headers and library  during  configuration.  You  need  to
       explicitly configure the build with "--enable-libopencore-amrnb".

       An FFmpeg native decoder for AMR-NB exists, so users can decode AMR-NB without this library.

   <b>libopencore-amrwb</b>
       libopencore-amrwb decoder wrapper.

       libopencore-amrwb  allows  libavcodec  to  decode  the Adaptive Multi-Rate Wideband audio codec. Using it
       requires the presence of the libopencore-amrwb headers and library  during  configuration.  You  need  to
       explicitly configure the build with "--enable-libopencore-amrwb".

       An FFmpeg native decoder for AMR-WB exists, so users can decode AMR-WB without this library.

   <b>libopus</b>
       libopus decoder wrapper.

       libopus  allows  libavcodec  to  decode  the  Opus Interactive Audio Codec.  Requires the presence of the
       libopus headers and library during configuration.  You  need  to  explicitly  configure  the  build  with
       "--enable-libopus".

       An FFmpeg native decoder for Opus exists, so users can decode Opus without this library.

</pre><h4><b>SUBTITLES</b> <b>DECODERS</b></h4><pre>
   <b>libaribb24</b>
       ARIB STD-B24 caption decoder.

       Implements profiles A and C of the ARIB STD-B24 standard.

       <u>libaribb24</u> <u>Decoder</u> <u>Options</u>

       <b>-aribb24-base-path</b> <u>path</u>
           Sets  the  base  path for the libaribb24 library. This is utilized for reading of configuration files
           (for custom unicode conversions), and for dumping of non-text symbols as images under that location.

           Unset by default.

       <b>-aribb24-skip-ruby-text</b> <u>boolean</u>
           Tells the decoder wrapper to skip text blocks that contain half-height ruby text.

           Enabled by default.

   <b>libaribcaption</b>
       Yet another ARIB STD-B24 caption decoder using external <u>libaribcaption</u> library.

       Implements profiles A and C of the Japanse  ARIB  STD-B24  standard,  Brazilian  ABNT  NBR  15606-1,  and
       Philippines version of ISDB-T.

       Requires the presence of the libaribcaption headers and library (&lt;<b>https://github.com/xqq/libaribcaption</b>&gt;)
       during  configuration.   You  need  to explicitly configure the build with "--enable-libaribcaption".  If
       both <u>libaribb24</u> and <u>libaribcaption</u> are enabled, <u>libaribcaption</u> decoder precedes.

       <u>libaribcaption</u> <u>Decoder</u> <u>Options</u>

       <b>-sub_type</b> <u>subtitle_type</u>
           Specifies the format of the decoded subtitles.

           <b>bitmap</b>
               Graphical image.

           <b>ass</b> ASS formatted text.

           <b>text</b>
               Simple text based output without formatting.

           The default is <u>ass</u> as same as <u>libaribb24</u> decoder.  Some present players (e.g., <u>mpv</u>) expect ASS format
           for ARIB caption.

       <b>-caption_encoding</b> <u>encoding_scheme</u>
           Specifies the encoding scheme of input subtitle text.

           <b>auto</b>
               Automatically detect text encoding (default).

           <b>jis</b> 8bit-char JIS encoding defined in ARIB STD B24.  This encoding used in Japan for ISDB captions.

           <b>utf8</b>
               UTF-8 encoding defined in ARIB STD  B24.   This  encoding  is  used  in  Philippines  for  ISDB-T
               captions.

           <b>latin</b>
               Latin character encoding defined in ABNT NBR 15606-1.  This encoding is used in South America for
               SBTVD / ISDB-Tb captions.

       <b>-font</b> <u>font_name[,font_name2,...]</u>
           Specify  comma-separated  list  of  font  family  names  to  be  used for <u>bitmap</u> or <u>ass</u> type subtitle
           rendering.  Only first font name is used for <u>ass</u> type subtitle.

           If not specified, use internaly defined default font family.

       <b>-ass_single_rect</b> <u>boolean</u>
           ARIB STD-B24 specifies that some captions may be displayed at different positions at a  time  (multi-
           rectangle  subtitle).   Since  some players (e.g., old <u>mpv</u>) can't handle multiple ASS rectangles in a
           single AVSubtitle, or  multiple  ASS  rectangles  of  indeterminate  duration  with  the  same  start
           timestamp,  this  option  can change the behavior so that all the texts are displayed in a single ASS
           rectangle.

           The default is <u>false</u>.

           If your player cannot handle AVSubtitles with multiple ASS rectangles properly, set  this  option  to
           <u>true</u> or define <b>ASS_SINGLE_RECT=1</b> to change default behavior at compilation.

       <b>-force_outline_text</b> <u>boolean</u>
           Specify  whether  always  render  outline  text  for  all  characters regardless of the indication by
           charactor style.

           The default is <u>false</u>.

       <b>-outline_width</b> <u>number</u> <b>(0.0</b> <b>-</b> <b>3.0)</b>
           Specify width for outline text, in dots (relative).

           The default is <u>1.5</u>.

       <b>-ignore_background</b> <u>boolean</u>
           Specify whether to ignore background color rendering.

           The default is <u>false</u>.

       <b>-ignore_ruby</b> <u>boolean</u>
           Specify whether to ignore rendering for ruby-like (furigana) characters.

           The default is <u>false</u>.

       <b>-replace_drcs</b> <u>boolean</u>
           Specify whether to render replaced DRCS characters as Unicode characters.

           The default is <u>true</u>.

       <b>-replace_msz_ascii</b> <u>boolean</u>
           Specify whether to replace MSZ (Middle Size;  half  width)  fullwidth  alphanumerics  with  halfwidth
           alphanumerics.

           The default is <u>true</u>.

       <b>-replace_msz_japanese</b> <u>boolean</u>
           Specify  whether  to replace some MSZ (Middle Size; half width) fullwidth japanese special characters
           with halfwidth ones.

           The default is <u>true</u>.

       <b>-replace_msz_glyph</b> <u>boolean</u>
           Specify whether to replace MSZ (Middle Size; half width) characters  with  halfwidth  glyphs  if  the
           fonts  supports  it.   This  option  works  under  FreeType or DirectWrite renderer with Adobe-Japan1
           compliant fonts.  e.g., IBM Plex Sans JP, Morisawa BIZ UDGothic, Morisawa BIZ UDMincho, Yu Gothic, Yu
           Mincho, and Meiryo.

           The default is <u>true</u>.

       <b>-canvas_size</b> <u>image_size</u>
           Specify the resolution of the canvas to render subtitles to; usually, this should be  frame  size  of
           input video.  This only applies when "-subtitle_type" is set to <u>bitmap</u>.

           The libaribcaption decoder assumes input frame size for bitmap rendering as below:

           1.  PROFILE_A : 1440 x 1080 with SAR (PAR) 4:3

           2.  PROFILE_C : 320 x 180 with SAR (PAR) 1:1

           If  actual  frame  size  of input video does not match above assumption, the rendered captions may be
           distorted.  To make the captions undistorted, add "-canvas_size" option to specify actual input video
           size.

           Note that the "-canvas_size" option is not required for video with different  size  but  same  aspect
           ratio.  In such cases, the caption will be stretched or shrunk to actual video size if "-canvas_size"
           option is not specified.  If "-canvas_size" option is specified with different size, the caption will
           be stretched or shrunk as specified size with calculated SAR.

       <u>libaribcaption</u> <u>decoder</u> <u>usage</u> <u>examples</u>

       Display MPEG-TS file with ARIB subtitle by "ffplay" tool:

               ffplay -sub_type bitmap MPEG.TS

       Display MPEG-TS file with input frame size 1920x1080 by "ffplay" tool:

               ffplay -sub_type bitmap -canvas_size 1920x1080 MPEG.TS

       Embed ARIB subtitle in transcoded video:

               ffmpeg -sub_type bitmap -i src.m2t -filter_complex "[0:v][0:s]overlay" -vcodec h264 dest.mp4

   <b>dvbsub</b>
       <u>Options</u>

       <b>compute_clut</b>
           <b>-2</b>  Compute clut once if no matching CLUT is in the stream.

           <b>-1</b>  Compute clut if no matching CLUT is in the stream.

           <b>0</b>   Never compute CLUT

           <b>1</b>   Always compute CLUT and override the one provided in the stream.

       <b>dvb_substream</b>
           Selects the dvb substream, or all substreams if -1 which is default.

   <b>dvdsub</b>
       This codec decodes the bitmap subtitles used in DVDs; the same subtitles can also be found in VobSub file
       pairs and in some Matroska files.

       <u>Options</u>

       <b>palette</b>
           Specify  the  global  palette  used  by  the  bitmaps. When stored in VobSub, the palette is normally
           specified in the index file; in Matroska, the palette is stored in the codec extra-data in  the  same
           format as in VobSub. In DVDs, the palette is stored in the IFO file, and therefore not available when
           reading from dumped VOB files.

           The  format for this option is a string containing 16 24-bits hexadecimal numbers (without 0x prefix)
           separated by commas, for example "0d00ee, ee450d, 101010, eaeaea,  0ce60b,  ec14ed,  ebff0b,  0d617a,
           7b7b7b, d1d1d1, 7b2a0e, 0d950c, 0f007b, cf0dec, cfa80c, 7c127b".

       <b>ifo_palette</b>
           Specify the IFO file from which the global palette is obtained.  (experimental)

       <b>forced_subs_only</b>
           Only  decode  subtitle  entries marked as forced. Some titles have forced and non-forced subtitles in
           the same track. Setting this flag to 1 will only keep the forced subtitles. Default value is 0.

   <b>libzvbi-teletext</b>
       Libzvbi allows libavcodec to decode DVB teletext pages and DVB teletext subtitles. Requires the  presence
       of  the libzvbi headers and library during configuration. You need to explicitly configure the build with
       "--enable-libzvbi".

       <u>Options</u>

       <b>txt_page</b>
           List of teletext page numbers to decode. Pages that do not match the specified list are dropped.  You
           may  use  the  special  "*"  string  to  match  all pages, or "subtitle" to match all subtitle pages.
           Default value is *.

       <b>txt_default_region</b>
           Set default character set used for decoding, a value between 0 and 87 (see ETS 300 706,  Section  15,
           Table  32).  Default  value is -1, which does not override the libzvbi default. This option is needed
           for some legacy level 1.0 transmissions which cannot signal the proper charset.

       <b>txt_chop_top</b>
           Discards the top teletext line. Default value is 1.

       <b>txt_format</b>
           Specifies the format of the decoded subtitles.

           <b>bitmap</b>
               The default format, you should use this for teletext pages, because certain graphics  and  colors
               cannot be expressed in simple text or even ASS.

           <b>text</b>
               Simple text based output without formatting.

           <b>ass</b> Formatted  ASS  output,  subtitle  pages  and  teletext  pages  are returned in different styles,
               subtitle pages are stripped down to text, but an effort is made to keep the  text  alignment  and
               the formatting.

       <b>txt_left</b>
           X offset of generated bitmaps, default is 0.

       <b>txt_top</b>
           Y offset of generated bitmaps, default is 0.

       <b>txt_chop_spaces</b>
           Chops  leading  and  trailing  spaces and removes empty lines from the generated text. This option is
           useful for teletext based subtitles where empty spaces may be present at the start or at the  end  of
           the  lines  or empty lines may be present between the subtitle lines because of double-sized teletext
           characters.  Default value is 1.

       <b>txt_duration</b>
           Sets the display duration of the decoded teletext pages or subtitles in milliseconds.  Default  value
           is -1 which means infinity or until the next subtitle event comes.

       <b>txt_transparent</b>
           Force  transparent  background  of  the generated teletext bitmaps. Default value is 0 which means an
           opaque background.

       <b>txt_opacity</b>
           Sets the opacity (0-255) of the teletext background. If <b>txt_transparent</b> is not set, it  only  affects
           characters  between  a  start  box  and  an  end  box,  typically  subtitles.  Default  value is 0 if
           <b>txt_transparent</b> is set, 255 otherwise.

</pre><h4><b>ENCODERS</b></h4><pre>
       Encoders are configured elements in FFmpeg which allow the encoding of multimedia streams.

       When you configure your FFmpeg build, all the supported native encoders are enabled by default.  Encoders
       requiring  an  external library must be enabled manually via the corresponding "--enable-lib" option. You
       can list all available encoders using the configure option "--list-encoders".

       You can disable all the encoders with the configure option "--disable-encoders" and selectively enable  /
       disable single encoders with the options "--enable-encoder=<u>ENCODER</u>" / "--disable-encoder=<u>ENCODER</u>".

       The option "-encoders" of the ff* tools will display the list of enabled encoders.

</pre><h4><b>AUDIO</b> <b>ENCODERS</b></h4><pre>
       A description of some of the currently available audio encoders follows.

   <b>aac</b>
       Advanced Audio Coding (AAC) encoder.

       This encoder is the default AAC encoder, natively implemented into FFmpeg.

       <u>Options</u>

       <b>b</b>   Set  bit  rate  in bits/s. Setting this automatically activates constant bit rate (CBR) mode. If this
           option is unspecified it is set to 128kbps.

       <b>q</b>   Set quality for variable bit rate (VBR) mode. This option is valid only using the <b>ffmpeg</b> command-line
           tool. For library interface users, use <b>global_quality</b>.

       <b>cutoff</b>
           Set cutoff frequency. If unspecified will allow the encoder  to  dynamically  adjust  the  cutoff  to
           improve clarity on low bitrates.

       <b>aac_coder</b>
           Set AAC encoder coding method. Possible values:

           <b>twoloop</b>
               Two loop searching (TLS) method. This is the default method.

               This  method first sets quantizers depending on band thresholds and then tries to find an optimal
               combination by adding or subtracting a specific value from  all  quantizers  and  adjusting  some
               individual  quantizer a little.  Will tune itself based on whether <b>aac_is</b>, <b>aac_ms</b> and <b>aac_pns</b> are
               enabled.

           <b>anmr</b>
               Average noise to mask ratio (ANMR) trellis-based solution.

               This is an experimental coder which currently produces a lower quality, is more unstable  and  is
               slower than the default twoloop coder but has potential.  Currently has no support for the <b>aac_is</b>
               or <b>aac_pns</b> options.  Not currently recommended.

           <b>fast</b>
               Constant quantizer method.

               Uses  a  cheaper  version of twoloop algorithm that doesn't try to do as many clever adjustments.
               Worse with low bitrates (less than 64kbps), but is better and much faster at higher bitrates.

       <b>aac_ms</b>
           Sets mid/side coding mode. The default value of "auto" will automatically use M/S  with  bands  which
           will  benefit from such coding. Can be forced for all bands using the value "enable", which is mainly
           useful for debugging or disabled using "disable".

       <b>aac_is</b>
           Sets intensity stereo coding tool usage. By default, it's enabled and will  automatically  toggle  IS
           for  similar  pairs of stereo bands if it's beneficial.  Can be disabled for debugging by setting the
           value to "disable".

       <b>aac_pns</b>
           Uses perceptual noise substitution to replace low entropy high  frequency  bands  with  imperceptible
           white  noise during the decoding process. By default, it's enabled, but can be disabled for debugging
           purposes by using "disable".

       <b>aac_tns</b>
           Enables the use of a multitap FIR filter which  spans  through  the  high  frequency  bands  to  hide
           quantization  noise during the encoding process and is reverted by the decoder. As well as decreasing
           unpleasant artifacts in the high range this also reduces the entropy in the high bands and allows for
           more bits to be used by the mid-low bands. By default it's enabled but can be disabled for  debugging
           by setting the option to "disable".

       <b>aac_ltp</b>
           Enables  the  use of the long term prediction extension which increases coding efficiency in very low
           bandwidth situations such as encoding of voice or solo piano music  by  extending  constant  harmonic
           peaks  in  bands  throughout  frames. This option is implied by profile:a aac_low and is incompatible
           with aac_pred. Use in conjunction with <b>-ar</b> to decrease the samplerate.

       <b>aac_pred</b>
           Enables the use of a more traditional style of prediction where the spectral coefficients transmitted
           are  replaced  by  the  difference  of  the  current  coefficients  minus  the  previous  "predicted"
           coefficients.  In  theory  and  sometimes in practice this can improve quality for low to mid bitrate
           audio.  This option implies the aac_main profile and is incompatible with aac_ltp.

       <b>profile</b>
           Sets the encoding profile, possible values:

           <b>aac_low</b>
               The default, AAC "Low-complexity" profile. Is the most compatible and produces decent quality.

           <b>mpeg2_aac_low</b>
               Equivalent to "-profile:a aac_low -aac_pns 0". PNS was introduced with the MPEG4 specifications.

           <b>aac_ltp</b>
               Long term prediction profile, is enabled by and will enable the  <b>aac_ltp</b>  option.  Introduced  in
               MPEG4.

           <b>aac_main</b>
               Main-type  prediction  profile,  is enabled by and will enable the <b>aac_pred</b> option. Introduced in
               MPEG2.

           If this option is unspecified it is set to <b>aac_low</b>.

   <b>ac3</b> <b>and</b> <b>ac3_fixed</b>
       AC-3 audio encoders.

       These encoders implement part of ATSC A/52:2010 and ETSI TS 102 366.

       The <u>ac3</u> encoder uses floating-point math, while the <u>ac3_fixed</u> encoder only uses fixed-point integer math.
       This does not mean that one is always faster, just that one or the  other  may  be  better  suited  to  a
       particular  system.  The  <u>ac3_fixed</u> encoder is not the default codec for any of the output formats, so it
       must be specified explicitly using the option "-acodec ac3_fixed" in order to use it.

       <u>AC-3</u> <u>Metadata</u>

       The AC-3 metadata options are used to set parameters that describe the audio, but in most  cases  do  not
       affect  the  audio  encoding itself. Some of the options do directly affect or influence the decoding and
       playback of the resulting bitstream, while others are just for  informational  purposes.  A  few  of  the
       options  will  add  bits  to the output stream that could otherwise be used for audio data, and will thus
       affect the quality of the output. Those will be indicated accordingly with a  note  in  the  option  list
       below.

       These parameters are described in detail in several publicly-available documents.

       *&lt;&lt;<b><a href="http://www.atsc.org/cms/standards/a_52-2010.pdf">http://www.atsc.org/cms/standards/a_52-2010.pdf</a></b>&gt;&gt;
       *&lt;&lt;<b><a href="http://www.atsc.org/cms/standards/a_54a_with_corr_1.pdf">http://www.atsc.org/cms/standards/a_54a_with_corr_1.pdf</a></b>&gt;&gt;
       *&lt;&lt;<b><a href="http://www.dolby.com/uploadedFiles/zz-_Shared_Assets/English_PDFs/Professional/18_Metadata.Guide.pdf">http://www.dolby.com/uploadedFiles/zz-_Shared_Assets/English_PDFs/Professional/18_Metadata.Guide.pdf</a></b>&gt;&gt;
       *&lt;&lt;<b><a href="http://www.dolby.com/uploadedFiles/zz-_Shared_Assets/English_PDFs/Professional/46_DDEncodingGuidelines.pdf">http://www.dolby.com/uploadedFiles/zz-_Shared_Assets/English_PDFs/Professional/46_DDEncodingGuidelines.pdf</a></b>&gt;&gt;

       Metadata Control Options

       <b>-per_frame_metadata</b> <u>boolean</u>
           Allow Per-Frame Metadata. Specifies if the encoder should check for changing metadata for each frame.

           <b>0</b>   The metadata values set at initialization will be used for every frame in the stream. (default)

           <b>1</b>   Metadata values can be changed before encoding each frame.

       Downmix Levels

       <b>-center_mixlev</b> <u>level</u>
           Center  Mix  Level. The amount of gain the decoder should apply to the center channel when downmixing
           to stereo. This field will only be written to the bitstream if a center channel is present. The value
           is specified as a scale factor. There are 3 valid values:

           <b>0.707</b>
               Apply -3dB gain

           <b>0.595</b>
               Apply -4.5dB gain (default)

           <b>0.500</b>
               Apply -6dB gain

       <b>-surround_mixlev</b> <u>level</u>
           Surround Mix Level. The amount of gain the decoder should  apply  to  the  surround  channel(s)  when
           downmixing  to  stereo.  This  field  will  only  be written to the bitstream if one or more surround
           channels are present. The value is specified as a scale factor.  There are 3 valid values:

           <b>0.707</b>
               Apply -3dB gain

           <b>0.500</b>
               Apply -6dB gain (default)

           <b>0.000</b>
               Silence Surround Channel(s)

       Audio Production Information

       Audio Production Information is optional information describing the mixing environment.  Either  none  or
       both of the fields are written to the bitstream.

       <b>-mixing_level</b> <u>number</u>
           Mixing  Level.  Specifies  peak sound pressure level (SPL) in the production environment when the mix
           was mastered. Valid values are 80 to 111, or -1 for unknown or not indicated. The  default  value  is
           -1,  but  that  value cannot be used if the Audio Production Information is written to the bitstream.
           Therefore, if the "room_type" option is not the default value, the "mixing_level" option must not  be
           -1.

       <b>-room_type</b> <u>type</u>
           Room  Type.  Describes  the equalization used during the final mixing session at the studio or on the
           dubbing stage. A large room is a dubbing stage with the industry  standard  X-curve  equalization;  a
           small  room  has  flat  equalization.   This  field  will not be written to the bitstream if both the
           "mixing_level" option and the "room_type" option have the default values.

           <b>0</b>
           <b>notindicated</b>
               Not Indicated (default)

           <b>1</b>
           <b>large</b>
               Large Room

           <b>2</b>
           <b>small</b>
               Small Room

       Other Metadata Options

       <b>-copyright</b> <u>boolean</u>
           Copyright Indicator. Specifies whether a copyright exists for this audio.

           <b>0</b>
           <b>off</b> No Copyright Exists (default)

           <b>1</b>
           <b>on</b>  Copyright Exists

       <b>-dialnorm</b> <u>value</u>
           Dialogue Normalization. Indicates how far the average dialogue level of the program is below  digital
           100% full scale (0 dBFS). This parameter determines a level shift during audio reproduction that sets
           the  average  volume  of  the  dialogue  to a preset level. The goal is to match volume level between
           program sources. A value of -31dB will result in no volume  level  change,  relative  to  the  source
           volume,  during  audio  reproduction. Valid values are whole numbers in the range -31 to -1, with -31
           being the default.

       <b>-dsur_mode</b> <u>mode</u>
           Dolby Surround Mode. Specifies whether the stereo signal uses Dolby Surround (Pro Logic). This  field
           will  only be written to the bitstream if the audio stream is stereo. Using this option does <b>NOT</b> mean
           the encoder will actually apply Dolby Surround processing.

           <b>0</b>
           <b>notindicated</b>
               Not Indicated (default)

           <b>1</b>
           <b>off</b> Not Dolby Surround Encoded

           <b>2</b>
           <b>on</b>  Dolby Surround Encoded

       <b>-original</b> <u>boolean</u>
           Original Bit Stream Indicator. Specifies whether this audio is from the original  source  and  not  a
           copy.

           <b>0</b>
           <b>off</b> Not Original Source

           <b>1</b>
           <b>on</b>  Original Source (default)

       <u>Extended</u> <u>Bitstream</u> <u>Information</u>

       The extended bitstream options are part of the Alternate Bit Stream Syntax as specified in Annex D of the
       A/52:2010 standard. It is grouped into 2 parts.  If any one parameter in a group is specified, all values
       in  that  group will be written to the bitstream.  Default values are used for those that are written but
       have not been specified.  If the mixing levels are written, the decoder will use these values instead  of
       the  ones specified in the "center_mixlev" and "surround_mixlev" options if it supports the Alternate Bit
       Stream Syntax.

       Extended Bitstream Information - Part 1

       <b>-dmix_mode</b> <u>mode</u>
           Preferred Stereo Downmix Mode. Allows the user to select  either  Lt/Rt  (Dolby  Surround)  or  Lo/Ro
           (normal stereo) as the preferred stereo downmix mode.

           <b>0</b>
           <b>notindicated</b>
               Not Indicated (default)

           <b>1</b>
           <b>ltrt</b>
               Lt/Rt Downmix Preferred

           <b>2</b>
           <b>loro</b>
               Lo/Ro Downmix Preferred

       <b>-ltrt_cmixlev</b> <u>level</u>
           Lt/Rt  Center  Mix  Level.  The  amount  of  gain the decoder should apply to the center channel when
           downmixing to stereo in Lt/Rt mode.

           <b>1.414</b>
               Apply +3dB gain

           <b>1.189</b>
               Apply +1.5dB gain

           <b>1.000</b>
               Apply 0dB gain

           <b>0.841</b>
               Apply -1.5dB gain

           <b>0.707</b>
               Apply -3.0dB gain

           <b>0.595</b>
               Apply -4.5dB gain (default)

           <b>0.500</b>
               Apply -6.0dB gain

           <b>0.000</b>
               Silence Center Channel

       <b>-ltrt_surmixlev</b> <u>level</u>
           Lt/Rt Surround Mix Level. The amount of gain the decoder should apply to the surround channel(s) when
           downmixing to stereo in Lt/Rt mode.

           <b>0.841</b>
               Apply -1.5dB gain

           <b>0.707</b>
               Apply -3.0dB gain

           <b>0.595</b>
               Apply -4.5dB gain

           <b>0.500</b>
               Apply -6.0dB gain (default)

           <b>0.000</b>
               Silence Surround Channel(s)

       <b>-loro_cmixlev</b> <u>level</u>
           Lo/Ro Center Mix Level. The amount of gain the decoder  should  apply  to  the  center  channel  when
           downmixing to stereo in Lo/Ro mode.

           <b>1.414</b>
               Apply +3dB gain

           <b>1.189</b>
               Apply +1.5dB gain

           <b>1.000</b>
               Apply 0dB gain

           <b>0.841</b>
               Apply -1.5dB gain

           <b>0.707</b>
               Apply -3.0dB gain

           <b>0.595</b>
               Apply -4.5dB gain (default)

           <b>0.500</b>
               Apply -6.0dB gain

           <b>0.000</b>
               Silence Center Channel

       <b>-loro_surmixlev</b> <u>level</u>
           Lo/Ro Surround Mix Level. The amount of gain the decoder should apply to the surround channel(s) when
           downmixing to stereo in Lo/Ro mode.

           <b>0.841</b>
               Apply -1.5dB gain

           <b>0.707</b>
               Apply -3.0dB gain

           <b>0.595</b>
               Apply -4.5dB gain

           <b>0.500</b>
               Apply -6.0dB gain (default)

           <b>0.000</b>
               Silence Surround Channel(s)

       Extended Bitstream Information - Part 2

       <b>-dsurex_mode</b> <u>mode</u>
           Dolby  Surround  EX  Mode. Indicates whether the stream uses Dolby Surround EX (7.1 matrixed to 5.1).
           Using this option does <b>NOT</b> mean the encoder will actually apply Dolby Surround EX processing.

           <b>0</b>
           <b>notindicated</b>
               Not Indicated (default)

           <b>1</b>
           <b>on</b>  Dolby Surround EX Off

           <b>2</b>
           <b>off</b> Dolby Surround EX On

       <b>-dheadphone_mode</b> <u>mode</u>
           Dolby Headphone Mode. Indicates whether the  stream  uses  Dolby  Headphone  encoding  (multi-channel
           matrixed  to  2.0 for use with headphones). Using this option does <b>NOT</b> mean the encoder will actually
           apply Dolby Headphone processing.

           <b>0</b>
           <b>notindicated</b>
               Not Indicated (default)

           <b>1</b>
           <b>on</b>  Dolby Headphone Off

           <b>2</b>
           <b>off</b> Dolby Headphone On

       <b>-ad_conv_type</b> <u>type</u>
           A/D Converter Type. Indicates whether the audio has passed through HDCD A/D conversion.

           <b>0</b>
           <b>standard</b>
               Standard A/D Converter (default)

           <b>1</b>
           <b>hdcd</b>
               HDCD A/D Converter

       <u>Other</u> <u>AC-3</u> <u>Encoding</u> <u>Options</u>

       <b>-stereo_rematrixing</b> <u>boolean</u>
           Stereo Rematrixing. Enables/Disables use of rematrixing for stereo input. This is  an  optional  AC-3
           feature  that  increases  quality  by  selectively encoding the left/right channels as mid/side. This
           option is enabled by default, and it is highly recommended that it be  left  as  enabled  except  for
           testing purposes.

       <b>cutoff</b> <u>frequency</u>
           Set  lowpass  cutoff  frequency.  If unspecified, the encoder selects a default determined by various
           other encoding parameters.

       <u>Floating-Point-Only</u> <u>AC-3</u> <u>Encoding</u> <u>Options</u>

       These options are only valid for the floating-point encoder and do not exist for the fixed-point  encoder
       due to the corresponding features not being implemented in fixed-point.

       <b>-channel_coupling</b> <u>boolean</u>
           Enables/Disables use of channel coupling, which is an optional AC-3 feature that increases quality by
           combining  high  frequency  information from multiple channels into a single channel. The per-channel
           high frequency information is sent with less accuracy in both the frequency and  time  domains.  This
           allows  more bits to be used for lower frequencies while preserving enough information to reconstruct
           the high frequencies. This option is enabled by default for the  floating-point  encoder  and  should
           generally be left as enabled except for testing purposes or to increase encoding speed.

           <b>-1</b>
           <b>auto</b>
               Selected by Encoder (default)

           <b>0</b>
           <b>off</b> Disable Channel Coupling

           <b>1</b>
           <b>on</b>  Enable Channel Coupling

       <b>-cpl_start_band</b> <u>number</u>
           Coupling  Start  Band. Sets the channel coupling start band, from 1 to 15. If a value higher than the
           bandwidth is used, it will be reduced to 1 less than the coupling end band.  If  <u>auto</u>  is  used,  the
           start  band will be determined by the encoder based on the bit rate, sample rate, and channel layout.
           This option has no effect if channel coupling is disabled.

           <b>-1</b>
           <b>auto</b>
               Selected by Encoder (default)

   <b>flac</b>
       FLAC (Free Lossless Audio Codec) Encoder

       <u>Options</u>

       The following options are supported by FFmpeg's flac encoder.

       <b>compression_level</b>
           Sets the compression level, which chooses defaults for  many  other  options  if  they  are  not  set
           explicitly. Valid values are from 0 to 12, 5 is the default.

       <b>frame_size</b>
           Sets the size of the frames in samples per channel.

       <b>lpc_coeff_precision</b>
           Sets the LPC coefficient precision, valid values are from 1 to 15, 15 is the default.

       <b>lpc_type</b>
           Sets the first stage LPC algorithm

           <b>none</b>
               LPC is not used

           <b>fixed</b>
               fixed LPC coefficients

           <b>levinson</b>
           <b>cholesky</b>
       <b>lpc_passes</b>
           Number of passes to use for Cholesky factorization during LPC analysis

       <b>min_partition_order</b>
           The minimum partition order

       <b>max_partition_order</b>
           The maximum partition order

       <b>prediction_order_method</b>
           <b>estimation</b>
           <b>2level</b>
           <b>4level</b>
           <b>8level</b>
           <b>search</b>
               Bruteforce search

           <b>log</b>
       <b>ch_mode</b>
           Channel mode

           <b>auto</b>
               The mode is chosen automatically for each frame

           <b>indep</b>
               Channels are independently coded

           <b>left_side</b>
           <b>right_side</b>
           <b>mid_side</b>
       <b>exact_rice_parameters</b>
           Chooses if rice parameters are calculated exactly or approximately.  if set to 1 then they are chosen
           exactly, which slows the code down slightly and improves compression slightly.

       <b>multi_dim_quant</b>
           Multi Dimensional Quantization. If set to 1 then a 2nd stage LPC algorithm is applied after the first
           stage to finetune the coefficients. This is quite slow and slightly improves compression.

   <b>opus</b>
       Opus encoder.

       This  is  a native FFmpeg encoder for the Opus format. Currently, it's in development and only implements
       the CELT part of the codec. Its quality is usually worse and at best is equal to the libopus encoder.

       <u>Options</u>

       <b>b</b>   Set bit rate in bits/s. If unspecified it uses the number of channels and the layout to make  a  good
           guess.

       <b>opus_delay</b>
           Sets the maximum delay in milliseconds. Lower delays than 20ms will very quickly decrease quality.

   <b>libfdk_aac</b>
       libfdk-aac AAC (Advanced Audio Coding) encoder wrapper.

       The libfdk-aac library is based on the Fraunhofer FDK AAC code from the Android project.

       Requires  the presence of the libfdk-aac headers and library during configuration. You need to explicitly
       configure the build with "--enable-libfdk-aac". The library is also incompatible  with  GPL,  so  if  you
       allow the use of GPL, you should configure with "--enable-gpl --enable-nonfree --enable-libfdk-aac".

       This encoder has support for the AAC-HE profiles.

       VBR  encoding, enabled through the <b>vbr</b> or <b>flags</b> <b>+qscale</b> options, is experimental and only works with some
       combinations of parameters.

       Support for encoding 7.1 audio is only available with libfdk-aac 0.1.3 or higher.

       For more information see the fdk-aac project at &lt;<b><a href="http://sourceforge.net/p/opencore-amr/fdk-aac/">http://sourceforge.net/p/opencore-amr/fdk-aac/</a></b>&gt;.

       <u>Options</u>

       The following options are mapped on the shared FFmpeg codec options.

       <b>b</b>   Set bit rate in bits/s. If the bitrate is not explicitly specified, it  is  automatically  set  to  a
           suitable value depending on the selected profile.

           In case VBR mode is enabled the option is ignored.

       <b>ar</b>  Set audio sampling rate (in Hz).

       <b>channels</b>
           Set the number of audio channels.

       <b>flags</b> <b>+qscale</b>
           Enable fixed quality, VBR (Variable Bit Rate) mode.  Note that VBR is implicitly enabled when the <b>vbr</b>
           value is positive.

       <b>cutoff</b>
           Set  cutoff  frequency.  If  not specified (or explicitly set to 0) it will use a value automatically
           computed by the library. Default value is 0.

       <b>profile</b>
           Set audio profile.

           The following profiles are recognized:

           <b>aac_low</b>
               Low Complexity AAC (LC)

           <b>aac_he</b>
               High Efficiency AAC (HE-AAC)

           <b>aac_he_v2</b>
               High Efficiency AAC version 2 (HE-AACv2)

           <b>aac_ld</b>
               Low Delay AAC (LD)

           <b>aac_eld</b>
               Enhanced Low Delay AAC (ELD)

           If not specified it is set to <b>aac_low</b>.

       The following are private options of the libfdk_aac encoder.

       <b>afterburner</b>
           Enable afterburner feature if set to 1, disabled if set to 0. This improves the quality but also  the
           required processing power.

           Default value is 1.

       <b>eld_sbr</b>
           Enable SBR (Spectral Band Replication) for ELD if set to 1, disabled if set to 0.

           Default value is 0.

       <b>eld_v2</b>
           Enable ELDv2 (LD-MPS extension for ELD stereo signals) for ELDv2 if set to 1, disabled if set to 0.

           Note         that         option        is        available        when        fdk-aac        version
           (AACENCODER_LIB_VL0.AACENCODER_LIB_VL1.AACENCODER_LIB_VL2) &gt; (4.0.0).

           Default value is 0.

       <b>signaling</b>
           Set SBR/PS signaling style.

           It can assume one of the following values:

           <b>default</b>
               choose signaling implicitly (explicit hierarchical by  default,  implicit  if  global  header  is
               disabled)

           <b>implicit</b>
               implicit backwards compatible signaling

           <b>explicit_sbr</b>
               explicit SBR, implicit PS signaling

           <b>explicit_hierarchical</b>
               explicit hierarchical signaling

           Default value is <b>default</b>.

       <b>latm</b>
           Output LATM/LOAS encapsulated data if set to 1, disabled if set to 0.

           Default value is 0.

       <b>header_period</b>
           Set  StreamMuxConfig  and PCE repetition period (in frames) for sending in-band configuration buffers
           within LATM/LOAS transport layer.

           Must be a 16-bits non-negative integer.

           Default value is 0.

       <b>vbr</b> Set VBR mode, from 1 to 5. 1 is lowest quality (though still pretty good) and 5 is highest quality. A
           value of 0 will disable VBR, and CBR (Constant Bit Rate) is enabled.

           Currently only the <b>aac_low</b> profile supports VBR encoding.

           VBR modes 1-5 correspond to roughly the following average bit rates:

           <b>1</b>   32 kbps/channel

           <b>2</b>   40 kbps/channel

           <b>3</b>   48-56 kbps/channel

           <b>4</b>   64 kbps/channel

           <b>5</b>   about 80-96 kbps/channel

           Default value is 0.

       <b>frame_length</b>
           Set the audio frame length in samples. Default value is the internal default of the library. Refer to
           the library's documentation for information about supported values.

       <u>Examples</u>

       •   Use <b>ffmpeg</b> to convert an audio file to VBR AAC in an M4A (MP4) container:

                   ffmpeg -i input.wav -codec:a libfdk_aac -vbr 3 output.m4a

       •   Use <b>ffmpeg</b> to convert an audio file to CBR 64k kbps AAC, using the High-Efficiency AAC profile:

                   ffmpeg -i input.wav -c:a libfdk_aac -profile:a aac_he -b:a 64k output.m4a

   <b>liblc3</b>
       liblc3 LC3 (Low Complexity Communication Codec) encoder wrapper.

       Requires the presence of the liblc3 headers and library during configuration.   You  need  to  explicitly
       configure the build with "--enable-liblc3".

       This  encoder  has  support  for the Bluetooth SIG LC3 codec for the LE Audio protocol, and the following
       features of LC3plus:

       •   Frame duration of 2.5 and 5ms.

       •   High-Resolution mode, 48 KHz, and 96 kHz sampling rates.

       For more information see the liblc3 project at &lt;<b>https://github.com/google/liblc3</b>&gt;.

       <u>Options</u>

       The following options are mapped on the shared FFmpeg codec options.

       <b>b</b> <u>bitrate</u>
           Set the bit rate in bits/s. This will determine the fixed size of the encoded frames, for a  selected
           frame duration.

       <b>ar</b> <u>frequency</u>
           Set the audio sampling rate (in Hz).

       <b>channels</b>
           Set the number of audio channels.

       <b>frame_duration</b>
           Set  the  audio  frame  duration in milliseconds. Default value is 10ms.  Allowed frame durations are
           2.5ms, 5ms, 7.5ms and 10ms.  LC3 (Bluetooth LE Audio), allows 7.5ms and 10ms; and LC3plus 2.5ms,  5ms
           and 10ms.

           The  10ms  frame  duration  is  available  in  LC3 and LC3 plus standard.  In this mode, the produced
           bitstream can be referenced either as LC3 or LC3plus.

       <b>high_resolution</b> <u>boolean</u>
           Enable the high-resolution mode if set to 1. The high-resolution mode is available with  all  LC3plus
           frame durations and for a sampling rate of 48 KHz, and 96 KHz.

           The encoder automatically turns off this mode at lower sampling rates and activates it at 96 KHz.

           This mode should be preferred at high bitrates. In this mode, the audio bandwidth is always up to the
           Nyquist frequency, compared to LC3 at 48 KHz, which limits the bandwidth to 20 KHz.

   <b>libmp3lame</b>
       LAME (Lame Ain't an MP3 Encoder) MP3 encoder wrapper.

       Requires  the presence of the libmp3lame headers and library during configuration. You need to explicitly
       configure the build with "--enable-libmp3lame".

       See <b>libshine</b> for a fixed-point MP3 encoder, although with a lower quality.

       <u>Options</u>

       The following options are supported by the libmp3lame wrapper. The <b>lame</b>-equivalent  of  the  options  are
       listed in parentheses.

       <b>b</b> <b>(</b><u>-b</u><b>)</b>
           Set bitrate expressed in bits/s for CBR or ABR. LAME "bitrate" is expressed in kilobits/s.

       <b>q</b> <b>(</b><u>-V</u><b>)</b>
           Set  constant  quality setting for VBR. This option is valid only using the <b>ffmpeg</b> command-line tool.
           For library interface users, use <b>global_quality</b>.

       <b>compression_level</b> <b>(</b><u>-q</u><b>)</b>
           Set algorithm quality. Valid arguments are integers in the 0-9 range, with 0 meaning highest  quality
           but slowest, and 9 meaning fastest while producing the worst quality.

       <b>cutoff</b> <b>(</b><u>--lowpass</u><b>)</b>
           Set lowpass cutoff frequency. If unspecified, the encoder dynamically adjusts the cutoff.

       <b>reservoir</b>
           Enable  use of bit reservoir when set to 1. Default value is 1. LAME has this enabled by default, but
           can be overridden by use <b>--nores</b> option.

       <b>joint_stereo</b> <b>(</b><u>-m</u> <u>j</u><b>)</b>
           Enable the encoder to use (on a frame by frame basis) either L/R stereo or mid/side  stereo.  Default
           value is 1.

       <b>abr</b> <b>(</b><u>--abr</u><b>)</b>
           Enable  the  encoder  to  use  ABR  when set to 1. The <b>lame</b> <b>--abr</b> sets the target bitrate, while this
           options only tells FFmpeg to use ABR still relies on <b>b</b> to set bitrate.

       <b>copyright</b> <b>(</b><u>-c</u><b>)</b>
           Set MPEG audio copyright flag when set to 1. The default value is 0 (disabled).

       <b>original</b> <b>(</b><u>-o</u><b>)</b>
           Set MPEG audio original flag when set to 1. The default value is 1 (enabled).

   <b>libopencore-amrnb</b>
       OpenCORE Adaptive Multi-Rate Narrowband encoder.

       Requires the presence of the libopencore-amrnb headers and library  during  configuration.  You  need  to
       explicitly configure the build with "--enable-libopencore-amrnb --enable-version3".

       This  is  a mono-only encoder. Officially it only supports 8000Hz sample rate, but you can override it by
       setting <b>strict</b> to <b>unofficial</b> or lower.

       <u>Options</u>

       <b>b</b>   Set bitrate in bits per second. Only the following bitrates are supported, otherwise libavcodec  will
           round to the nearest valid bitrate.

           <b>4750</b>
           <b>5150</b>
           <b>5900</b>
           <b>6700</b>
           <b>7400</b>
           <b>7950</b>
           <b>10200</b>
           <b>12200</b>
       <b>dtx</b> Allow  discontinuous  transmission  (generate  comfort  noise)  when set to 1. The default value is 0
           (disabled).

   <b>libopus</b>
       libopus Opus Interactive Audio Codec encoder wrapper.

       Requires the presence of the libopus headers and library during configuration.  You  need  to  explicitly
       configure the build with "--enable-libopus".

       <u>Option</u> <u>Mapping</u>

       Most  libopus  options are modelled after the <b>opusenc</b> utility from opus-tools. The following is an option
       mapping chart describing options supported by  the  libopus  wrapper,  and  their  <b>opusenc</b>-equivalent  in
       parentheses.

       <b>b</b> <b>(</b><u>bitrate</u><b>)</b>
           Set  the  bit  rate  in bits/s.  FFmpeg's <b>b</b> option is expressed in bits/s, while <b>opusenc</b>'s <b>bitrate</b> in
           kilobits/s.

       <b>vbr</b> <b>(</b><u>vbr</u><b>,</b> <u>hard-cbr</u><b>,</b> <b>and</b> <u>cvbr</u><b>)</b>
           Set VBR mode. The FFmpeg <b>vbr</b> option has the following valid arguments, with  the  <b>opusenc</b>  equivalent
           options in parentheses:

           <b>off</b> <b>(</b><u>hard-cbr</u><b>)</b>
               Use constant bit rate encoding.

           <b>on</b> <b>(</b><u>vbr</u><b>)</b>
               Use variable bit rate encoding (the default).

           <b>constrained</b> <b>(</b><u>cvbr</u><b>)</b>
               Use constrained variable bit rate encoding.

       <b>compression_level</b> <b>(</b><u>comp</u><b>)</b>
           Set  encoding algorithm complexity. Valid options are integers in the 0-10 range. 0 gives the fastest
           encodes but lower quality, while 10 gives the highest quality but slowest encoding.  The  default  is
           10.

       <b>frame_duration</b> <b>(</b><u>framesize</u><b>)</b>
           Set  maximum  frame  size,  or  duration of a frame in milliseconds. The argument must be exactly the
           following: 2.5, 5, 10, 20, 40, 60. Smaller frame sizes achieve lower latency but less  quality  at  a
           given  bitrate.  Sizes greater than 20ms are only interesting at fairly low bitrates.  The default is
           20ms.

       <b>packet_loss</b> <b>(</b><u>expect-loss</u><b>)</b>
           Set expected packet loss percentage. The default is 0.

       <b>fec</b> <b>(</b><u>n/a</u><b>)</b>
           Enable inband forward error correction. <b>packet_loss</b> must be non-zero to take advantage - frequency of
           FEC 'side-data' is proportional to expected packet loss.  Default is disabled.

       <b>application</b> <b>(N.A.)</b>
           Set intended application type. Valid options are listed below:

           <b>voip</b>
               Favor improved speech intelligibility.

           <b>audio</b>
               Favor faithfulness to the input (the default).

           <b>lowdelay</b>
               Restrict to only the lowest delay modes by disabling voice-optimized modes.

       <b>cutoff</b> <b>(N.A.)</b>
           Set cutoff bandwidth in Hz. The argument must be exactly one of  the  following:  4000,  6000,  8000,
           12000,  or  20000,  corresponding  to  narrowband, mediumband, wideband, super wideband, and fullband
           respectively. The default is 0 (cutoff disabled). Note that libopus  forces  a  wideband  cutoff  for
           bitrates &lt; 15 kbps, unless CELT-only (<b>application</b> set to <b>lowdelay</b>) mode is used.

       <b>mapping_family</b> <b>(</b><u>mapping_family</u><b>)</b>
           Set  channel  mapping family to be used by the encoder. The default value of -1 uses mapping family 0
           for mono and stereo inputs, and mapping family 1 otherwise. The default also  disables  the  surround
           masking and LFE bandwidth optimzations in libopus, and requires that the input contains 8 channels or
           fewer.

           Other  values  include  0  for  mono  and stereo, 1 for surround sound with masking and LFE bandwidth
           optimizations, and 255 for independent streams with an unspecified channel layout.

       <b>apply_phase_inv</b> <b>(N.A.)</b> <b>(requires</b> <b>libopus</b> <b>&gt;=</b> <b>1.2)</b>
           If set to 0, disables the use of phase inversion for intensity stereo, improving the quality of  mono
           downmixes, but slightly reducing normal stereo quality. The default is 1 (phase inversion enabled).

   <b>libshine</b>
       Shine Fixed-Point MP3 encoder wrapper.

       Shine  is  a  fixed-point  MP3 encoder. It has a far better performance on platforms without an FPU, e.g.
       armel CPUs, and some phones and tablets.  However, as it is more targeted on performance than quality, it
       is not on par with LAME  and  other  production-grade  encoders  quality-wise.  Also,  according  to  the
       project's  homepage, this encoder may not be free of bugs as the code was written a long time ago and the
       project was dead for at least 5 years.

       This encoder only supports stereo and mono input. This is also CBR-only.

       The original project (last updated in early 2007) is at  &lt;<b><a href="http://sourceforge.net/projects/libshine-fxp/">http://sourceforge.net/projects/libshine-fxp/</a></b>&gt;.
       We only support the updated fork by the Savonet/Liquidsoap project at &lt;<b>https://github.com/savonet/shine</b>&gt;.

       Requires  the  presence  of the libshine headers and library during configuration. You need to explicitly
       configure the build with "--enable-libshine".

       See also <b>libmp3lame</b>.

       <u>Options</u>

       The following options are supported by the libshine wrapper. The <b>shineenc</b>-equivalent of the  options  are
       listed in parentheses.

       <b>b</b> <b>(</b><u>-b</u><b>)</b>
           Set bitrate expressed in bits/s for CBR. <b>shineenc</b> <b>-b</b> option is expressed in kilobits/s.

   <b>libtwolame</b>
       TwoLAME MP2 encoder wrapper.

       Requires  the presence of the libtwolame headers and library during configuration. You need to explicitly
       configure the build with "--enable-libtwolame".

       <u>Options</u>

       The following options are supported by the libtwolame wrapper. The <b>twolame</b>-equivalent options follow  the
       FFmpeg ones and are in parentheses.

       <b>b</b> <b>(</b><u>-b</u><b>)</b>
           Set  bitrate  expressed in bits/s for CBR. <b>twolame</b> <b>b</b> option is expressed in kilobits/s. Default value
           is 128k.

       <b>q</b> <b>(</b><u>-V</u><b>)</b>
           Set quality for experimental VBR support. Maximum value range is from -50 to 50, useful range is from
           -10 to 10. The higher the value, the better the quality. This option is valid only using  the  <b>ffmpeg</b>
           command-line tool. For library interface users, use <b>global_quality</b>.

       <b>mode</b> <b>(</b><u>--mode</u><b>)</b>
           Set the mode of the resulting audio. Possible values:

           <b>auto</b>
               Choose mode automatically based on the input. This is the default.

           <b>stereo</b>
               Stereo

           <b>joint_stereo</b>
               Joint stereo

           <b>dual_channel</b>
               Dual channel

           <b>mono</b>
               Mono

       <b>psymodel</b> <b>(</b><u>--psyc-mode</u><b>)</b>
           Set  psychoacoustic  model  to  use  in  encoding.  The argument must be an integer between -1 and 4,
           inclusive. The higher the value, the better the quality. The default value is 3.

       <b>energy_levels</b> <b>(</b><u>--energy</u><b>)</b>
           Enable energy levels extensions when set to 1. The default value is 0 (disabled).

       <b>error_protection</b> <b>(</b><u>--protect</u><b>)</b>
           Enable CRC error protection when set to 1. The default value is 0 (disabled).

       <b>copyright</b> <b>(</b><u>--copyright</u><b>)</b>
           Set MPEG audio copyright flag when set to 1. The default value is 0 (disabled).

       <b>original</b> <b>(</b><u>--original</u><b>)</b>
           Set MPEG audio original flag when set to 1. The default value is 0 (disabled).

   <b>libvo-amrwbenc</b>
       VisualOn Adaptive Multi-Rate Wideband encoder.

       Requires the presence of the libvo-amrwbenc  headers  and  library  during  configuration.  You  need  to
       explicitly configure the build with "--enable-libvo-amrwbenc --enable-version3".

       This  is a mono-only encoder. Officially it only supports 16000Hz sample rate, but you can override it by
       setting <b>strict</b> to <b>unofficial</b> or lower.

       <u>Options</u>

       <b>b</b>   Set bitrate in bits/s. Only the following bitrates are supported, otherwise libavcodec will round  to
           the nearest valid bitrate.

           <b>6600</b>
           <b>8850</b>
           <b>12650</b>
           <b>14250</b>
           <b>15850</b>
           <b>18250</b>
           <b>19850</b>
           <b>23050</b>
           <b>23850</b>
       <b>dtx</b> Allow  discontinuous  transmission  (generate  comfort  noise)  when set to 1. The default value is 0
           (disabled).

   <b>libvorbis</b>
       libvorbis encoder wrapper.

       Requires the presence of  the  libvorbisenc  headers  and  library  during  configuration.  You  need  to
       explicitly configure the build with "--enable-libvorbis".

       <u>Options</u>

       The  following  options  are supported by the libvorbis wrapper. The <b>oggenc</b>-equivalent of the options are
       listed in parentheses.

       To get a more accurate and extensive documentation of the libvorbis options, consult  the  libvorbisenc's
       and  <b>oggenc</b>'s  documentations.   See  &lt;<b><a href="http://xiph.org/vorbis/">http://xiph.org/vorbis/</a></b>&gt;, &lt;<b><a href="http://wiki.xiph.org/Vorbis-tools">http://wiki.xiph.org/Vorbis-tools</a></b>&gt;, and
       <b><a href="../man1/oggenc.1.html">oggenc</a></b>(1).

       <b>b</b> <b>(</b><u>-b</u><b>)</b>
           Set bitrate expressed in bits/s for ABR. <b>oggenc</b> <b>-b</b> is expressed in kilobits/s.

       <b>q</b> <b>(</b><u>-q</u><b>)</b>
           Set constant quality setting for VBR. The value should be a float number in  the  range  of  -1.0  to
           10.0. The higher the value, the better the quality. The default value is <b>3.0</b>.

           This  option  is  valid  only  using  the <b>ffmpeg</b> command-line tool.  For library interface users, use
           <b>global_quality</b>.

       <b>cutoff</b> <b>(</b><u>--advanced-encode-option</u> <u>lowpass_frequency=N</u><b>)</b>
           Set cutoff bandwidth in Hz, a value of 0 disables cutoff. <b>oggenc</b>'s related  option  is  expressed  in
           kHz. The default value is <b>0</b> (cutoff disabled).

       <b>minrate</b> <b>(</b><u>-m</u><b>)</b>
           Set minimum bitrate expressed in bits/s. <b>oggenc</b> <b>-m</b> is expressed in kilobits/s.

       <b>maxrate</b> <b>(</b><u>-M</u><b>)</b>
           Set  maximum  bitrate expressed in bits/s. <b>oggenc</b> <b>-M</b> is expressed in kilobits/s. This only has effect
           on ABR mode.

       <b>iblock</b> <b>(</b><u>--advanced-encode-option</u> <u>impulse_noisetune=N</u><b>)</b>
           Set noise floor bias for impulse blocks. The value is a float number from -15.0 to  0.0.  A  negative
           bias  instructs  the  encoder  to pay special attention to the crispness of transients in the encoded
           audio. The tradeoff for better transient response is a higher bitrate.

   <b>mjpeg</b>
       Motion JPEG encoder.

       <u>Options</u>

       <b>huffman</b>
           Set the huffman encoding strategy. Possible values:

           <b>default</b>
               Use the default huffman tables. This is the default strategy.

           <b>optimal</b>
               Compute and use optimal huffman tables.

   <b>wavpack</b>
       WavPack lossless audio encoder.

       <u>Options</u>

       The equivalent options for <b>wavpack</b> command line utility are listed in parentheses.

       Shared options

       The following shared options are effective for this encoder. Only special  notes  about  this  particular
       encoder will be documented here. For the general meaning of the options, see <b>the</b> <b>Codec</b> <b>Options</b> <b>chapter</b>.

       <b>frame_size</b> <b>(</b><u>--blocksize</u><b>)</b>
           For  this  encoder,  the  range  for  this option is between 128 and 131072. Default is automatically
           decided based on sample rate and number of channel.

           For the complete formula of calculating default, see <u>libavcodec/wavpackenc.c</u>.

       <b>compression_level</b> <b>(</b><u>-f</u><b>,</b> <u>-h</u><b>,</b> <u>-hh</u><b>,</b> <b>and</b> <u>-x</u><b>)</b>

       Private options

       <b>joint_stereo</b> <b>(</b><u>-j</u><b>)</b>
           Set whether to enable joint stereo. Valid values are:

           <b>on</b> <b>(</b><u>1</u><b>)</b>
               Force mid/side audio encoding.

           <b>off</b> <b>(</b><u>0</u><b>)</b>
               Force left/right audio encoding.

           <b>auto</b>
               Let the encoder decide automatically.

       <b>optimize_mono</b>
           Set whether to enable optimization for mono. This option is  only  effective  for  non-mono  streams.
           Available values:

           <b>on</b>  enabled

           <b>off</b> disabled

</pre><h4><b>VIDEO</b> <b>ENCODERS</b></h4><pre>
       A description of some of the currently available video encoders follows.

   <b>a64_multi,</b> <b>a64_multi5</b>
       A64 / Commodore 64 multicolor charset encoder. "a64_multi5" is extended with 5th color (colram).

   <b>Cinepak</b>
       Cinepak aka CVID encoder.  Compatible with Windows 3.1 and vintage MacOS.

       <u>Options</u>

       <b>g</b> <u>integer</u>
           Keyframe interval.  A keyframe is inserted at least every "-g" frames, sometimes sooner.

       <b>q:v</b> <u>integer</u>
           Quality factor. Lower is better. Higher gives lower bitrate.  The following table lists bitrates when
           encoding akiyo_cif.y4m for various values of "-q:v" with "-g 100":

           <b>"-q:v</b> <b>1"</b> <b>1918</b> <b>kb/s</b>
           <b>"-q:v</b> <b>2"</b> <b>1735</b> <b>kb/s</b>
           <b>"-q:v</b> <b>4"</b> <b>1500</b> <b>kb/s</b>
           <b>"-q:v</b> <b>10"</b> <b>1041</b> <b>kb/s</b>
           <b>"-q:v</b> <b>20"</b> <b>826</b> <b>kb/s</b>
           <b>"-q:v</b> <b>40"</b> <b>553</b> <b>kb/s</b>
           <b>"-q:v</b> <b>100"</b> <b>394</b> <b>kb/s</b>
           <b>"-q:v</b> <b>200"</b> <b>312</b> <b>kb/s</b>
           <b>"-q:v</b> <b>400"</b> <b>266</b> <b>kb/s</b>
           <b>"-q:v</b> <b>1000"</b> <b>237</b> <b>kb/s</b>
       <b>max_extra_cb_iterations</b> <u>integer</u>
           Max extra codebook recalculation passes, more is better and slower.

       <b>skip_empty_cb</b> <u>boolean</u>
           Avoid wasting bytes, ignore vintage MacOS decoder.

       <b>max_strips</b> <u>integer</u>
       <b>min_strips</b> <u>integer</u>
           The  minimum  and  maximum  number  of  strips to use.  Wider range sometimes improves quality.  More
           strips is generally better quality but costs more bits.  Fewer strips tend to yield  more  keyframes.
           Vintage compatible is 1..3.

       <b>strip_number_adaptivity</b> <u>integer</u>
           How much number of strips is allowed to change between frames.  Higher is better but slower.

   <b>GIF</b>
       GIF image/animation encoder.

       <u>Options</u>

       <b>gifflags</b> <u>integer</u>
           Sets the flags used for GIF encoding.

           <b>offsetting</b>
               Enables picture offsetting.

               Default is enabled.

           <b>transdiff</b>
               Enables transparency detection between frames.

               Default is enabled.

       <b>gifimage</b> <u>integer</u>
           Enables encoding one full GIF image per frame, rather than an animated GIF.

           Default value is <b>0</b>.

       <b>global_palette</b> <u>integer</u>
           Writes a palette to the global GIF header where feasible.

           If  disabled,  every  frame  will  always  have  a palette written, even if there is a global palette
           supplied.

           Default value is <b>1</b>.

   <b>Hap</b>
       Vidvox Hap video encoder.

       <u>Options</u>

       <b>format</b> <u>integer</u>
           Specifies the Hap format to encode.

           <b>hap</b>
           <b>hap_alpha</b>
           <b>hap_q</b>

           Default value is <b>hap</b>.

       <b>chunks</b> <u>integer</u>
           Specifies the number of chunks to split frames into, between 1 and  64.  This  permits  multithreaded
           decoding  of large frames, potentially at the cost of data-rate. The encoder may modify this value to
           divide frames evenly.

           Default value is <u>1</u>.

       <b>compressor</b> <u>integer</u>
           Specifies the second-stage compressor to use. If set to <b>none</b>, <b>chunks</b> will be limited to 1, as chunked
           uncompressed frames offer no benefit.

           <b>none</b>
           <b>snappy</b>

           Default value is <b>snappy</b>.

   <b>jpeg2000</b>
       The native jpeg 2000 encoder is lossy by default, the "-q:v" option can  be  used  to  set  the  encoding
       quality. Lossless encoding can be selected with "-pred 1".

       <u>Options</u>

       <b>format</b> <u>integer</u>
           Can be set to either "j2k" or "jp2" (the default) that makes it possible to store non-rgb pix_fmts.

       <b>tile_width</b> <u>integer</u>
           Sets tile width. Range is 1 to 1073741824. Default is 256.

       <b>tile_height</b> <u>integer</u>
           Sets tile height. Range is 1 to 1073741824. Default is 256.

       <b>pred</b> <u>integer</u>
           Allows setting the discrete wavelet transform (DWT) type

           <b>dwt97int</b> <b>(Lossy)</b>
           <b>dwt53</b> <b>(Lossless)</b>

           Default is "dwt97int"

       <b>sop</b> <u>boolean</u>
           Enable this to add SOP marker at the start of each packet. Disabled by default.

       <b>eph</b> <u>boolean</u>
           Enable this to add EPH marker at the end of each packet header. Disabled by default.

       <b>prog</b> <u>integer</u>
           Sets the progression order to be used by the encoder.  Possible values are:

           <b>lrcp</b>
           <b>rlcp</b>
           <b>rpcl</b>
           <b>pcrl</b>
           <b>cprl</b>

           Set to "lrcp" by default.

       <b>layer_rates</b> <u>string</u>
           By  default, when this option is not used, compression is done using the quality metric.  This option
           allows for compression using compression ratio.  The  compression  ratio  for  each  level  could  be
           specified.  The  compression  ratio  of  a  layer  "l"  species  the what ratio of total file size is
           contained in the first "l" layers.

           Example usage:

                   ffmpeg -i input.bmp -c:v jpeg2000 -layer_rates "100,10,1" output.j2k

           This would compress the image to contain 3 layers, where the data contained in the first layer  would
           be  compressed  by  1000 times, compressed by 100 in the first two layers, and shall contain all data
           while using all 3 layers.

   <b>librav1e</b>
       rav1e AV1 encoder wrapper.

       Requires the presence of the rav1e headers and library during  configuration.   You  need  to  explicitly
       configure the build with "--enable-librav1e".

       <u>Options</u>

       <b>qmax</b>
           Sets the maximum quantizer to use when using bitrate mode.

       <b>qmin</b>
           Sets the minimum quantizer to use when using bitrate mode.

       <b>qp</b>  Uses quantizer mode to encode at the given quantizer (0-255).

       <b>speed</b>
           Selects the speed preset (0-10) to encode with.

       <b>tiles</b>
           Selects how many tiles to encode with.

       <b>tile-rows</b>
           Selects how many rows of tiles to encode with.

       <b>tile-columns</b>
           Selects how many columns of tiles to encode with.

       <b>rav1e-params</b>
           Set  rav1e  options  using a list of <u>key</u>=<u>value</u> pairs separated by ":". See <b>rav1e</b> <b>--help</b> for a list of
           options.

           For example to specify librav1e encoding options with <b>-rav1e-params</b>:

                   ffmpeg -i input -c:v librav1e -b:v 500K -rav1e-params speed=5:low_latency=true output.mp4

   <b>libaom-av1</b>
       libaom AV1 encoder wrapper.

       Requires the presence of the libaom headers and library during configuration.   You  need  to  explicitly
       configure the build with "--enable-libaom".

       <u>Options</u>

       The wrapper supports the following standard libavcodec options:

       <b>b</b>   Set  bitrate  target in bits/second.  By default this will use variable-bitrate mode.  If <b>maxrate</b> and
           <b>minrate</b> are also set to the same value then it will use constant-bitrate mode, otherwise  if  <b>crf</b>  is
           set as well then it will use constrained-quality mode.

       <b>g</b> <b>keyint_min</b>
           Set  key  frame  placement.   The  GOP size sets the maximum distance between key frames; if zero the
           output stream will be intra-only.  The minimum distance is ignored unless it is the same as  the  GOP
           size,  in  which  case  key  frames  will  always appear at a fixed interval.  Not set by default, so
           without this option the library has completely free choice about where to place key frames.

       <b>qmin</b> <b>qmax</b>
           Set minimum/maximum quantisation values.  Valid range is from 0 to 63 (warning: this does  not  match
           the  quantiser  values  actually  used  by  AV1 - divide by four to map real quantiser values to this
           range).  Defaults to min/max (no constraint).

       <b>minrate</b> <b>maxrate</b> <b>bufsize</b> <b>rc_init_occupancy</b>
           Set rate control buffering parameters.  Not used if not set  -  defaults  to  unconstrained  variable
           bitrate.

       <b>threads</b>
           Set  the  number  of  threads to use while encoding.  This may require the <b>tiles</b> or <b>row-mt</b> options to
           also be set to actually use the specified number of threads fully. Defaults to the number of hardware
           threads supported by the host machine.

       <b>profile</b>
           Set the encoding profile.  Defaults to using the profile which  matches  the  bit  depth  and  chroma
           subsampling of the input.

       The wrapper also has some specific options:

       <b>cpu-used</b>
           Set  the  quality/encoding  speed  tradeoff.   Valid  range is from 0 to 8, higher numbers indicating
           greater speed and lower quality.  The default value is 1, which will be slow and high quality.

       <b>auto-alt-ref</b>
           Enable use of alternate reference frames.  Defaults to the internal default of the library.

       <b>arnr-max-frames</b> <b>(</b><u>frames</u><b>)</b>
           Set altref noise reduction max frame count. Default is -1.

       <b>arnr-strength</b> <b>(</b><u>strength</u><b>)</b>
           Set altref noise reduction filter strength. Range is -1 to 6. Default is -1.

       <b>aq-mode</b> <b>(</b><u>aq-mode</u><b>)</b>
           Set adaptive quantization mode. Possible values:

           <b>none</b> <b>(</b><u>0</u><b>)</b>
               Disabled.

           <b>variance</b> <b>(</b><u>1</u><b>)</b>
               Variance-based.

           <b>complexity</b> <b>(</b><u>2</u><b>)</b>
               Complexity-based.

           <b>cyclic</b> <b>(</b><u>3</u><b>)</b>
               Cyclic refresh.

       <b>tune</b> <b>(</b><u>tune</u><b>)</b>
           Set the distortion metric the encoder is tuned with. Default is "psnr".

           <b>psnr</b> <b>(</b><u>0</u><b>)</b>
           <b>ssim</b> <b>(</b><u>1</u><b>)</b>
       <b>lag-in-frames</b>
           Set the maximum number of frames which the encoder may keep in flight at any one time  for  lookahead
           purposes.  Defaults to the internal default of the library.

       <b>error-resilience</b>
           Enable error resilience features:

           <b>default</b>
               Improve resilience against losses of whole frames.

           Not enabled by default.

       <b>crf</b> Set  the quality/size tradeoff for constant-quality (no bitrate target) and constrained-quality (with
           maximum bitrate target) modes. Valid range is 0 to 63, higher numbers indicating  lower  quality  and
           smaller output size.  Only used if set; by default only the bitrate target is used.

       <b>static-thresh</b>
           Set  a  change  threshold  on  blocks  below  which  they will be skipped by the encoder.  Defined in
           arbitrary units as a nonnegative integer, defaulting to zero (no blocks are skipped).

       <b>drop-threshold</b>
           Set a threshold for dropping frames when close to rate control bounds.  Defined as  a  percentage  of
           the  target buffer - when the rate control buffer falls below this percentage, frames will be dropped
           until it has refilled above the threshold.  Defaults to zero (no frames are dropped).

       <b>denoise-noise-level</b> <b>(</b><u>level</u><b>)</b>
           Amount of noise to be removed for grain synthesis. Grain synthesis is disabled if this option is  not
           set or set to 0.

       <b>denoise-block-size</b> <b>(</b><u>pixels</u><b>)</b>
           Block  size  used  for denoising for grain synthesis. If not set, AV1 codec uses the default value of
           32.

       <b>undershoot-pct</b> <b>(</b><u>pct</u><b>)</b>
           Set datarate undershoot (min) percentage of the target bitrate. Range is -1 to 100.  Default is -1.

       <b>overshoot-pct</b> <b>(</b><u>pct</u><b>)</b>
           Set datarate overshoot (max) percentage of the target bitrate. Range is -1 to 1000.  Default is -1.

       <b>minsection-pct</b> <b>(</b><u>pct</u><b>)</b>
           Minimum percentage variation of the GOP bitrate from the target bitrate.  If  minsection-pct  is  not
           set,  the libaomenc wrapper computes it as follows: "(minrate * 100 / bitrate)".  Range is -1 to 100.
           Default is -1 (unset).

       <b>maxsection-pct</b> <b>(</b><u>pct</u><b>)</b>
           Maximum percentage variation of the GOP bitrate from the target bitrate.  If  maxsection-pct  is  not
           set, the libaomenc wrapper computes it as follows: "(maxrate * 100 / bitrate)".  Range is -1 to 5000.
           Default is -1 (unset).

       <b>frame-parallel</b> <b>(</b><u>boolean</u><b>)</b>
           Enable frame parallel decodability features. Default is true.

       <b>tiles</b>
           Set  the  number  of  tiles  to encode the input video with, as columns x rows.  Larger numbers allow
           greater parallelism in both encoding and decoding, but may decrease coding efficiency.   Defaults  to
           the  minimum  number of tiles required by the size of the input video (this is 1x1 (that is, a single
           tile) for sizes up to and including 4K).

       <b>tile-columns</b> <b>tile-rows</b>
           Set the number of tiles as log2 of the number of tile rows and columns.  Provided  for  compatibility
           with libvpx/VP9.

       <b>row-mt</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>1.0.0-759-g90a15f4f2)</b>
           Enable row based multi-threading. Disabled by default.

       <b>enable-cdef</b> <b>(</b><u>boolean</u><b>)</b>
           Enable Constrained Directional Enhancement Filter. The libaom-av1 encoder enables CDEF by default.

       <b>enable-restoration</b> <b>(</b><u>boolean</u><b>)</b>
           Enable Loop Restoration Filter. Default is true for libaom-av1.

       <b>enable-global-motion</b> <b>(</b><u>boolean</u><b>)</b>
           Enable the use of global motion for block prediction. Default is true.

       <b>enable-intrabc</b> <b>(</b><u>boolean</u><b>)</b>
           Enable block copy mode for intra block prediction. This mode is useful for screen content. Default is
           true.

       <b>enable-rect-partitions</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable rectangular partitions. Default is true.

       <b>enable-1to4-partitions</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable 1:4/4:1 partitions. Default is true.

       <b>enable-ab-partitions</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable AB shape partitions. Default is true.

       <b>enable-angle-delta</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable angle delta intra prediction. Default is true.

       <b>enable-cfl-intra</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable chroma predicted from luma intra prediction. Default is true.

       <b>enable-filter-intra</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable filter intra predictor. Default is true.

       <b>enable-intra-edge-filter</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable intra edge filter. Default is true.

       <b>enable-smooth-intra</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable smooth intra prediction mode. Default is true.

       <b>enable-paeth-intra</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable paeth predictor in intra prediction. Default is true.

       <b>enable-palette</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable palette prediction mode. Default is true.

       <b>enable-flip-idtx</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable   extended   transform   type,   including   FLIPADST_DCT,   DCT_FLIPADST,  FLIPADST_FLIPADST,
           ADST_FLIPADST, FLIPADST_ADST, IDTX, V_DCT, H_DCT, V_ADST, H_ADST, V_FLIPADST, H_FLIPADST. Default  is
           true.

       <b>enable-tx64</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable 64-pt transform. Default is true.

       <b>reduced-tx-type-set</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Use reduced set of transform types. Default is false.

       <b>use-intra-dct-only</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Use DCT only for INTRA modes. Default is false.

       <b>use-inter-dct-only</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Use DCT only for INTER modes. Default is false.

       <b>use-intra-default-tx-only</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Use Default-transform only for INTRA modes. Default is false.

       <b>enable-ref-frame-mvs</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable temporal mv prediction. Default is true.

       <b>enable-reduced-reference-set</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Use reduced set of single and compound references. Default is false.

       <b>enable-obmc</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable obmc. Default is true.

       <b>enable-dual-filter</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable dual filter. Default is true.

       <b>enable-diff-wtd-comp</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable difference-weighted compound. Default is true.

       <b>enable-dist-wtd-comp</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable distance-weighted compound. Default is true.

       <b>enable-onesided-comp</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable one sided compound. Default is true.

       <b>enable-interinter-wedge</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable interinter wedge compound. Default is true.

       <b>enable-interintra-wedge</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable interintra wedge compound. Default is true.

       <b>enable-masked-comp</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable masked compound. Default is true.

       <b>enable-interintra-comp</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable interintra compound. Default is true.

       <b>enable-smooth-interintra</b> <b>(</b><u>boolean</u><b>)</b> <b>(Requires</b> <b>libaom</b> <b>&gt;=</b> <b>v2.0.0)</b>
           Enable smooth interintra mode. Default is true.

       <b>aom-params</b>
           Set libaom options using a list of <u>key</u>=<u>value</u> pairs separated by ":". For a list of supported options,
           see <b>aomenc</b> <b>--help</b> under the section "AV1 Specific Options".

           For example to specify libaom encoding options with <b>-aom-params</b>:

                   ffmpeg -i input -c:v libaom-av1 -b:v 500K -aom-params tune=psnr:enable-tpl-model=1 output.mp4

   <b>libsvtav1</b>
       SVT-AV1 encoder wrapper.

       Requires  the  presence  of the SVT-AV1 headers and library during configuration.  You need to explicitly
       configure the build with "--enable-libsvtav1".

       <u>Options</u>

       <b>profile</b>
           Set the encoding profile.

           <b>main</b>
           <b>high</b>
           <b>professional</b>
       <b>level</b>
           Set the operating point level. For example: '4.0'

       <b>hielevel</b>
           Set the Hierarchical prediction levels.

           <b>3level</b>
           <b>4level</b>
               This is the default.

       <b>tier</b>
           Set the operating point tier.

           <b>main</b>
               This is the default.

           <b>high</b>
       <b>qmax</b>
           Set the maximum quantizer to use when using a bitrate mode.

       <b>qmin</b>
           Set the minimum quantizer to use when using a bitrate mode.

       <b>crf</b> Constant rate factor value used in crf rate control mode (0-63).

       <b>qp</b>  Set the quantizer used in cqp rate control mode (0-63).

       <b>sc_detection</b>
           Enable scene change detection.

       <b>la_depth</b>
           Set number of frames to look ahead (0-120).

       <b>preset</b>
           Set the quality-speed tradeoff, in the range 0 to 13.  Higher values are faster but lower quality.

       <b>tile_rows</b>
           Set log2 of the number of rows of tiles to use (0-6).

       <b>tile_columns</b>
           Set log2 of the number of columns of tiles to use (0-4).

       <b>svtav1-params</b>
           Set SVT-AV1 options using a list of <u>key</u>=<u>value</u> pairs separated by ":". See the  SVT-AV1  encoder  user
           guide for a list of accepted parameters.

   <b>libjxl</b>
       libjxl JPEG XL encoder wrapper.

       Requires  the  presence  of  the  libjxl headers and library during configuration. You need to explicitly
       configure the build with "--enable-libjxl".

       <u>Options</u>

       The libjxl wrapper supports the following options:

       <b>distance</b>
           Set the target Butteraugli distance. This is a quality setting: lower distance yields higher quality,
           with distance=1.0 roughly  comparable  to  libjpeg  Quality  90  for  photographic  content.  Setting
           distance=0.0  yields true lossless encoding. Valid values range between 0.0 and 15.0, and sane values
           rarely exceed 5.0. Setting distance=0.1 usually attains transparency for most input. The  default  is
           1.0.

       <b>effort</b>
           Set  the  encoding  effort  used.  Higher  effort  values produce more consistent quality and usually
           produces a better quality/bpp curve, at the cost of more CPU time required. Valid values range from 1
           to 9, and the default is 7.

       <b>modular</b>
           Force the encoder to use Modular mode instead of choosing automatically. The default is to use VarDCT
           for lossy encoding and Modular for lossless. VarDCT  is  generally  superior  to  Modular  for  lossy
           encoding but does not support lossless encoding.

   <b>libkvazaar</b>
       Kvazaar H.265/HEVC encoder.

       Requires  the presence of the libkvazaar headers and library during configuration. You need to explicitly
       configure the build with <b>--enable-libkvazaar</b>.

       <u>Options</u>

       <b>b</b>   Set target video bitrate in bit/s and enable rate control.

       <b>kvazaar-params</b>
           Set kvazaar parameters  as  a  list  of  <u>name</u>=<u>value</u>  pairs  separated  by  commas  (,).  See  kvazaar
           documentation for a list of options.

   <b>libopenh264</b>
       Cisco libopenh264 H.264/MPEG-4 AVC encoder wrapper.

       This  encoder requires the presence of the libopenh264 headers and library during configuration. You need
       to explicitly configure the build with "--enable-libopenh264". The library is detected using <b>pkg-config</b>.

       For more information about the library see &lt;<b><a href="http://www.openh264.org">http://www.openh264.org</a></b>&gt;.

       <u>Options</u>

       The following FFmpeg global options affect the configurations of the libopenh264 encoder.

       <b>b</b>   Set the bitrate (as a number of bits per second).

       <b>g</b>   Set the GOP size.

       <b>maxrate</b>
           Set the max bitrate (as a number of bits per second).

       <b>flags</b> <b>+global_header</b>
           Set global header in the bitstream.

       <b>slices</b>
           Set the number of slices, used in parallelized encoding. Default value is 0. This is only  used  when
           <b>slice_mode</b> is set to <b>fixed</b>.

       <b>loopfilter</b>
           Enable loop filter, if set to 1 (automatically enabled). To disable set a value of 0.

       <b>profile</b>
           Set   profile   restrictions.   If   set   to   the   value   of   <b>main</b>   enable   CABAC   (set   the
           "SEncParamExt.iEntropyCodingModeFlag" flag to 1).

       <b>max_nal_size</b>
           Set maximum NAL size in bytes.

       <b>allow_skip_frames</b>
           Allow skipping frames to hit the target bitrate if set to 1.

   <b>libtheora</b>
       libtheora Theora encoder wrapper.

       Requires the presence of the libtheora headers and library during configuration. You need  to  explicitly
       configure the build with "--enable-libtheora".

       For more information about the libtheora project see &lt;<b><a href="http://www.theora.org/">http://www.theora.org/</a></b>&gt;.

       <u>Options</u>

       The  following  global  options are mapped to internal libtheora options which affect the quality and the
       bitrate of the encoded stream.

       <b>b</b>   Set the video bitrate in bit/s for CBR (Constant Bit Rate) mode.  In case  VBR  (Variable  Bit  Rate)
           mode is enabled this option is ignored.

       <b>flags</b>
           Used  to  enable  constant  quality  mode  (VBR)  encoding through the <b>qscale</b> flag, and to enable the
           "pass1" and "pass2" modes.

       <b>g</b>   Set the GOP size.

       <b>global_quality</b>
           Set the global quality as an integer in lambda units.

           Only relevant when VBR mode is enabled with "flags +qscale". The value is converted to  QP  units  by
           dividing  it  by  "FF_QP2LAMBDA",  clipped in the [0 - 10] range, and then multiplied by 6.3 to get a
           value in the native libtheora range [0-63]. A higher value corresponds to a higher quality.

       <b>q</b>   Enable VBR mode when set to a non-negative value, and set constant quality value as a double floating
           point value in QP units.

           The value is clipped in the [0-10] range, and then multiplied by 6.3 to get a  value  in  the  native
           libtheora range [0-63].

           This  option  is  valid  only  using  the  <b>ffmpeg</b> command-line tool. For library interface users, use
           <b>global_quality</b>.

       <u>Examples</u>

       •   Set maximum constant quality (VBR) encoding with <b>ffmpeg</b>:

                   ffmpeg -i INPUT -codec:v libtheora -q:v 10 OUTPUT.ogg

       •   Use <b>ffmpeg</b> to convert a CBR 1000 kbps Theora video stream:

                   ffmpeg -i INPUT -codec:v libtheora -b:v 1000k OUTPUT.ogg

   <b>libvpx</b>
       VP8/VP9 format supported through libvpx.

       Requires the presence of the libvpx headers and library during configuration.   You  need  to  explicitly
       configure the build with "--enable-libvpx".

       <u>Options</u>

       The  following  options  are supported by the libvpx wrapper. The <b>vpxenc</b>-equivalent options or values are
       listed in parentheses for easy migration.

       To reduce the duplication of documentation, only the private options and some  others  requiring  special
       attention  are  documented here. For the documentation of the undocumented generic options, see <b>the</b> <b>Codec</b>
       <b>Options</b> <b>chapter</b>.

       To get more documentation of the libvpx options, invoke the command <b>ffmpeg</b> <b>-h</b> <b>encoder=libvpx</b>,  <b>ffmpeg</b>  <b>-h</b>
       <b>encoder=libvpx-vp9</b> or <b>vpxenc</b> <b>--help</b>. Further information is available in the libvpx API documentation.

       <b>b</b> <b>(</b><u>target-bitrate</u><b>)</b>
           Set  bitrate  in  bits/s.  Note that FFmpeg's <b>b</b> option is expressed in bits/s, while <b>vpxenc</b>'s <b>target-</b>
           <b>bitrate</b> is in kilobits/s.

       <b>g</b> <b>(</b><u>kf-max-dist</u><b>)</b>
       <b>keyint_min</b> <b>(</b><u>kf-min-dist</u><b>)</b>
       <b>qmin</b> <b>(</b><u>min-q</u><b>)</b>
           Minimum (Best Quality) Quantizer.

       <b>qmax</b> <b>(</b><u>max-q</u><b>)</b>
           Maximum (Worst Quality) Quantizer.  Can be changed per-frame.

       <b>bufsize</b> <b>(</b><u>buf-sz</u><b>,</b> <u>buf-optimal-sz</u><b>)</b>
           Set ratecontrol buffer size (in bits). Note <b>vpxenc</b>'s  options  are  specified  in  milliseconds,  the
           libvpx wrapper converts this value as follows: "buf-sz = bufsize * 1000 / bitrate", "buf-optimal-sz =
           bufsize * 1000 / bitrate * 5 / 6".

       <b>rc_init_occupancy</b> <b>(</b><u>buf-initial-sz</u><b>)</b>
           Set  number  of  bits which should be loaded into the rc buffer before decoding starts. Note <b>vpxenc</b>'s
           option  is  specified  in  milliseconds,  the  libvpx  wrapper  converts  this  value   as   follows:
           "rc_init_occupancy * 1000 / bitrate".

       <b>undershoot-pct</b>
           Set datarate undershoot (min) percentage of the target bitrate.

       <b>overshoot-pct</b>
           Set datarate overshoot (max) percentage of the target bitrate.

       <b>skip_threshold</b> <b>(</b><u>drop-frame</u><b>)</b>
       <b>qcomp</b> <b>(</b><u>bias-pct</u><b>)</b>
       <b>maxrate</b> <b>(</b><u>maxsection-pct</u><b>)</b>
           Set  GOP  max  bitrate  in  bits/s.  Note  <b>vpxenc</b>'s option is specified as a percentage of the target
           bitrate, the libvpx wrapper converts this value as follows: "(maxrate * 100 / bitrate)".

       <b>minrate</b> <b>(</b><u>minsection-pct</u><b>)</b>
           Set GOP min bitrate in bits/s. Note <b>vpxenc</b>'s option is  specified  as  a  percentage  of  the  target
           bitrate, the libvpx wrapper converts this value as follows: "(minrate * 100 / bitrate)".

       <b>minrate,</b> <b>maxrate,</b> <b>b</b> <u>end-usage=cbr</u>
           "(minrate == maxrate == bitrate)".

       <b>crf</b> <b>(</b><u>end-usage=cq</u><b>,</b> <u>cq-level</u><b>)</b>
       <b>tune</b> <b>(</b><u>tune</u><b>)</b>
           <b>psnr</b> <b>(</b><u>psnr</u><b>)</b>
           <b>ssim</b> <b>(</b><u>ssim</u><b>)</b>
       <b>quality,</b> <b>deadline</b> <b>(</b><u>deadline</u><b>)</b>
           <b>best</b>
               Use  best  quality deadline. Poorly named and quite slow, this option should be avoided as it may
               give worse quality output than good.

           <b>good</b>
               Use good quality deadline. This is a good trade-off between speed and quality when used with  the
               <b>cpu-used</b> option.

           <b>realtime</b>
               Use realtime quality deadline.

       <b>speed,</b> <b>cpu-used</b> <b>(</b><u>cpu-used</u><b>)</b>
           Set quality/speed ratio modifier. Higher values speed up the encode at the cost of quality.

       <b>nr</b> <b>(</b><u>noise-sensitivity</u><b>)</b>
       <b>static-thresh</b>
           Set a change threshold on blocks below which they will be skipped by the encoder.

       <b>slices</b> <b>(</b><u>token-parts</u><b>)</b>
           Note  that FFmpeg's <b>slices</b> option gives the total number of partitions, while <b>vpxenc</b>'s <b>token-parts</b> is
           given as log2(partitions).

       <b>max-intra-rate</b>
           Set maximum I-frame bitrate as a percentage of the target bitrate. A value of 0 means unlimited.

       <b>force_key_frames</b>
           "VPX_EFLAG_FORCE_KF"

       <b>Alternate</b> <b>reference</b> <b>frame</b> <b>related</b>
           <b>auto-alt-ref</b>
               Enable use of alternate reference frames (2-pass only).  Values greater than 1 enable multi-layer
               alternate reference frames (VP9 only).

           <b>arnr-maxframes</b>
               Set altref noise reduction max frame count.

           <b>arnr-type</b>
               Set altref noise reduction filter type: backward, forward, centered.

           <b>arnr-strength</b>
               Set altref noise reduction filter strength.

           <b>rc-lookahead,</b> <b>lag-in-frames</b> <b>(</b><u>lag-in-frames</u><b>)</b>
               Set number of frames to look ahead for frametype and ratecontrol.

           <b>min-gf-interval</b>
               Set minimum golden/alternate reference frame interval (VP9 only).

       <b>error-resilient</b>
           Enable error resiliency features.

       <b>sharpness</b> <u>integer</u>
           Increase sharpness at the expense of lower PSNR.  The valid range is [0, 7].

       <b>ts-parameters</b>
           Sets the temporal scalability configuration using a :-separated list of key=value pairs. For example,
           to specify temporal scalability parameters with "ffmpeg":

                   ffmpeg -i INPUT -c:v libvpx -ts-parameters ts_number_layers=3:\
                   ts_target_bitrate=250,500,1000:ts_rate_decimator=4,2,1:\
                   ts_periodicity=4:ts_layer_id=0,2,1,2:ts_layering_mode=3 OUTPUT

           Below is a brief explanation of each of the parameters, please refer to "struct vpx_codec_enc_cfg" in
           "vpx/vpx_encoder.h" for more details.

           <b>ts_number_layers</b>
               Number of temporal coding layers.

           <b>ts_target_bitrate</b>
               Target bitrate for each temporal layer (in kbps).  (bitrate should  be  inclusive  of  the  lower
               temporal layer).

           <b>ts_rate_decimator</b>
               Frame rate decimation factor for each temporal layer.

           <b>ts_periodicity</b>
               Length of the sequence defining frame temporal layer membership.

           <b>ts_layer_id</b>
               Template defining the membership of frames to temporal layers.

           <b>ts_layering_mode</b>
               (optional)  Selecting  the  temporal structure from a set of pre-defined temporal layering modes.
               Currently supports the following options.

               <b>0</b>   No temporal layering flags are provided internally, relies on flags  being  passed  in  using
                   "metadata" field in "AVFrame" with following keys.

                   <b>vp8-flags</b>
                       Sets the flags passed into the encoder to indicate the referencing scheme for the current
                       frame.  Refer to function "vpx_codec_encode" in "vpx/vpx_encoder.h" for more details.

                   <b>temporal_id</b>
                       Explicitly sets the temporal id of the current frame to encode.

               <b>2</b>   Two temporal layers. 0-1...

               <b>3</b>   Three temporal layers. 0-2-1-2...; with single reference frame.

               <b>4</b>   Same  as  option  "3",  except  there is a dependency between the two temporal layer 2 frames
                   within the temporal period.

       <b>VP8-specific</b> <b>options</b>
           <b>screen-content-mode</b>
               Screen content mode, one of: 0 (off), 1 (screen), 2 (screen with more aggressive rate control).

       <b>VP9-specific</b> <b>options</b>
           <b>lossless</b>
               Enable lossless mode.

           <b>tile-columns</b>
               Set number of tile columns to use. Note this is given as log2(tile_columns). For example, 8  tile
               columns would be requested by setting the <b>tile-columns</b> option to 3.

           <b>tile-rows</b>
               Set  number of tile rows to use. Note this is given as log2(tile_rows).  For example, 4 tile rows
               would be requested by setting the <b>tile-rows</b> option to 2.

           <b>frame-parallel</b>
               Enable frame parallel decodability features.

           <b>aq-mode</b>
               Set adaptive quantization mode (0: off (default), 1: variance 2: complexity, 3:  cyclic  refresh,
               4: equator360).

           <b>colorspace</b> <u>color-space</u>
               Set input color space. The VP9 bitstream supports signaling the following colorspaces:

               <b>rgb</b> <u><b>sRGB</b></u>
               <b>bt709</b> <u><b>bt709</b></u>
               <b>unspecified</b> <u><b>unknown</b></u>
               <b>bt470bg</b> <u><b>bt601</b></u>
               <b>smpte170m</b> <u><b>smpte170</b></u>
               <b>smpte240m</b> <u><b>smpte240</b></u>
               <b>bt2020_ncl</b> <u><b>bt2020</b></u>
           <b>row-mt</b> <u>boolean</u>
               Enable row based multi-threading.

           <b>tune-content</b>
               Set content type: default (0), screen (1), film (2).

           <b>corpus-complexity</b>
               Corpus VBR mode is a variant of standard VBR where the complexity distribution midpoint is passed
               in rather than calculated for a specific clip or chunk.

               The valid range is [0, 10000]. 0 (default) uses standard VBR.

           <b>enable-tpl</b> <u>boolean</u>
               Enable temporal dependency model.

           <b>ref-frame-config</b>
               Using   per-frame   metadata,  set  members  of  the  structure  "vpx_svc_ref_frame_config_t"  in
               "vpx/vp8cx.h" to fine-control referencing schemes and frame buffer management.  Use a :-separated
               list of key=value pairs.  For example,

                       av_dict_set(&amp;av_frame-&gt;metadata, "ref-frame-config", \
                       "rfc_update_buffer_slot=7:rfc_lst_fb_idx=0:rfc_gld_fb_idx=1:rfc_alt_fb_idx=2:rfc_reference_last=0:rfc_reference_golden=0:rfc_reference_alt_ref=0");

               <b>rfc_update_buffer_slot</b>
                   Indicates the buffer slot number to update

               <b>rfc_update_last</b>
                   Indicates whether to update the LAST frame

               <b>rfc_update_golden</b>
                   Indicates whether to update GOLDEN frame

               <b>rfc_update_alt_ref</b>
                   Indicates whether to update ALT_REF frame

               <b>rfc_lst_fb_idx</b>
                   LAST frame buffer index

               <b>rfc_gld_fb_idx</b>
                   GOLDEN frame buffer index

               <b>rfc_alt_fb_idx</b>
                   ALT_REF frame buffer index

               <b>rfc_reference_last</b>
                   Indicates whether to reference LAST frame

               <b>rfc_reference_golden</b>
                   Indicates whether to reference GOLDEN frame

               <b>rfc_reference_alt_ref</b>
                   Indicates whether to reference ALT_REF frame

               <b>rfc_reference_duration</b>
                   Indicates frame duration

       For more information about libvpx see: &lt;<b><a href="http://www.webmproject.org/">http://www.webmproject.org/</a></b>&gt;

   <b>libvvenc</b>
       VVenC H.266/VVC encoder wrapper.

       This encoder requires the presence of the libvvenc headers and library during configuration. You need  to
       explicitly configure the build with <b>--enable-libvvenc</b>.

       The VVenC project website is at &lt;<b>https://github.com/fraunhoferhhi/vvenc</b>&gt;.

       <u>Supported</u> <u>Pixel</u> <u>Formats</u>

       VVenC  supports  only  10-bit  color  spaces as input. But the internal (encoded) bit depth can be set to
       8-bit or 10-bit at runtime.

       <u>Options</u>

       <b>b</b>   Sets target video bitrate.

       <b>g</b>   Set the GOP size. Currently support for g=1 (Intra only) or default.

       <b>preset</b>
           Set the VVenC preset.

       <b>levelidc</b>
           Set level idc.

       <b>tier</b>
           Set vvc tier.

       <b>qp</b>  Set constant quantization parameter.

       <b>subopt</b> <u>boolean</u>
           Set subjective (perceptually motivated) optimization. Default is 1 (on).

       <b>bitdepth8</b> <u>boolean</u>
           Set 8bit coding mode instead of using 10bit. Default is 0 (off).

       <b>period</b>
           set (intra) refresh period in seconds.

       <b>vvenc-params</b>
           Set vvenc options using a list of <u>key</u>=<u>value</u> couples separated by  ":".  See  <b>vvencapp</b>  <b>--fullhelp</b>  or
           <b>vvencFFapp</b> <b>--fullhelp</b> for a list of options.

           For example, the options might be provided as:

                   intraperiod=64:decodingrefreshtype=idr:poc0idr=1:internalbitdepth=8

           For example the encoding options might be provided with <b>-vvenc-params</b>:

                   ffmpeg -i input -c:v libvvenc -b 1M -vvenc-params intraperiod=64:decodingrefreshtype=idr:poc0idr=1:internalbitdepth=8 output.mp4

   <b>libwebp</b>
       libwebp WebP Image encoder wrapper

       libwebp  is  Google's  official  encoder for WebP images. It can encode in either lossy or lossless mode.
       Lossy images are essentially a wrapper around a VP8 frame. Lossless images are a separate codec developed
       by Google.

       <u>Pixel</u> <u>Format</u>

       Currently, libwebp only supports YUV420 for lossy and RGB for lossless due to limitations of  the  format
       and  libwebp.  Alpha  is supported for either mode.  Because of API limitations, if RGB is passed in when
       encoding lossy or YUV is passed in  for  encoding  lossless,  the  pixel  format  will  automatically  be
       converted using functions from libwebp. This is not ideal and is done only for convenience.

       <u>Options</u>

       <b>-lossless</b> <u>boolean</u>
           Enables/Disables use of lossless mode. Default is 0.

       <b>-compression_level</b> <u>integer</u>
           For  lossy,  this  is a quality/speed tradeoff. Higher values give better quality for a given size at
           the cost of increased encoding time. For lossless, this is a size/speed tradeoff. Higher values  give
           smaller  size  at  the  cost of increased encoding time. More specifically, it controls the number of
           extra algorithms and compression tools used, and varies the combination of these tools. This maps  to
           the <u>method</u> option in libwebp. The valid range is 0 to 6.  Default is 4.

       <b>-quality</b> <u>float</u>
           For  lossy encoding, this controls image quality. For lossless encoding, this controls the effort and
           time spent in compression.  Range is 0 to 100. Default is 75.

       <b>-preset</b> <u>type</u>
           Configuration preset. This does some automatic settings based on the general type of the image.

           <b>none</b>
               Do not use a preset.

           <b>default</b>
               Use the encoder default.

           <b>picture</b>
               Digital picture, like portrait, inner shot

           <b>photo</b>
               Outdoor photograph, with natural lighting

           <b>drawing</b>
               Hand or line drawing, with high-contrast details

           <b>icon</b>
               Small-sized colorful images

           <b>text</b>
               Text-like

   <b>libx264,</b> <b>libx264rgb</b>
       x264 H.264/MPEG-4 AVC encoder wrapper.

       This encoder requires the presence of the libx264 headers and library during configuration. You  need  to
       explicitly configure the build with "--enable-libx264".

       libx264  supports  an  impressive  number  of features, including 8x8 and 4x4 adaptive spatial transform,
       adaptive  B-frame  placement,  CAVLC/CABAC  entropy  coding,  interlacing  (MBAFF),  lossless  mode,  psy
       optimizations for detail retention (adaptive quantization, psy-RD, psy-trellis).

       Many  libx264 encoder options are mapped to FFmpeg global codec options, while unique encoder options are
       provided through private options. Additionally the <b>x264opts</b> and <b>x264-params</b> private options allows one to
       pass a list of key=value tuples as accepted by the libx264 "x264_param_parse" function.

       The x264 project website is at &lt;<b><a href="http://www.videolan.org/developers/x264.html">http://www.videolan.org/developers/x264.html</a></b>&gt;.

       The libx264rgb encoder is the same as libx264, except it  accepts  packed  RGB  pixel  formats  as  input
       instead of YUV.

       <u>Supported</u> <u>Pixel</u> <u>Formats</u>

       x264 supports 8- to 10-bit color spaces. The exact bit depth is controlled at x264's configure time.

       <u>Options</u>

       The  following  options  are  supported by the libx264 wrapper. The <b>x264</b>-equivalent options or values are
       listed in parentheses for easy migration.

       To reduce the duplication of documentation, only the private options and some  others  requiring  special
       attention  are  documented here. For the documentation of the undocumented generic options, see <b>the</b> <b>Codec</b>
       <b>Options</b> <b>chapter</b>.

       To get a more accurate and extensive documentation of  the  libx264  options,  invoke  the  command  <b>x264</b>
       <b>--fullhelp</b> or consult the libx264 documentation.

       In  the  list  below,  note  that  the  <b>x264</b>  option  name  is  shown in parentheses after the libavcodec
       corresponding name, in case there is a direct mapping.

       <b>b</b> <b>(</b><u>bitrate</u><b>)</b>
           Set bitrate in bits/s. Note that FFmpeg's <b>b</b> option is expressed in bits/s, while <b>x264</b>'s <b>bitrate</b> is in
           kilobits/s.

       <b>bf</b> <b>(</b><u>bframes</u><b>)</b>
           Number of B-frames between I and P-frames

       <b>g</b> <b>(</b><u>keyint</u><b>)</b>
           Maximum GOP size

       <b>qmin</b> <b>(</b><u>qpmin</u><b>)</b>
           Minimum quantizer scale

       <b>qmax</b> <b>(</b><u>qpmax</u><b>)</b>
           Maximum quantizer scale

       <b>qdiff</b> <b>(</b><u>qpstep</u><b>)</b>
           Maximum difference between quantizer scales

       <b>qblur</b> <b>(</b><u>qblur</u><b>)</b>
           Quantizer curve blur

       <b>qcomp</b> <b>(</b><u>qcomp</u><b>)</b>
           Quantizer curve compression factor

       <b>refs</b> <b>(</b><u>ref</u><b>)</b>
           Number of reference frames each P-frame can use. The range is <u>0-16</u>.

       <b>level</b> <b>(</b><u>level</u><b>)</b>
           Set the "x264_param_t.i_level_idc" value in case the value is positive, it is ignored otherwise.

           This value can be set using the "AVCodecContext" API (e.g.  by  setting  the  "AVCodecContext"  value
           directly),  and is specified as an integer mapped on a corresponding level (e.g. the value 31 maps to
           H.264 level IDC "3.1", as defined in the "x264_levels" table). It  is  ignored  when  set  to  a  non
           positive value.

           Alternatively it can be set as a private option, overriding the value set in "AVCodecContext", and in
           this case must be specified as the level IDC identifier (e.g. "3.1"), as defined by H.264 Annex A.

       <b>sc_threshold</b> <b>(</b><u>scenecut</u><b>)</b>
           Sets the threshold for the scene change detection.

       <b>trellis</b> <b>(</b><u>trellis</u><b>)</b>
           Performs Trellis quantization to increase efficiency. Enabled by default.

       <b>nr</b> <b>(</b><u>nr</u><b>)</b>
           Noise reduction

       <b>me_range</b> <b>(</b><u>merange</u><b>)</b>
           Maximum range of the motion search in pixels.

       <b>me_method</b> <b>(</b><u>me</u><b>)</b>
           Set motion estimation method. Possible values in the decreasing order of speed:

           <b>dia</b> <b>(</b><u>dia</u><b>)</b>
           <b>epzs</b> <b>(</b><u>dia</u><b>)</b>
               Diamond search with radius 1 (fastest). <b>epzs</b> is an alias for <b>dia</b>.

           <b>hex</b> <b>(</b><u>hex</u><b>)</b>
               Hexagonal search with radius 2.

           <b>umh</b> <b>(</b><u>umh</u><b>)</b>
               Uneven multi-hexagon search.

           <b>esa</b> <b>(</b><u>esa</u><b>)</b>
               Exhaustive search.

           <b>tesa</b> <b>(</b><u>tesa</u><b>)</b>
               Hadamard exhaustive search (slowest).

       <b>forced-idr</b>
           Normally, when forcing a I-frame type, the encoder can select any type of I-frame. This option forces
           it to choose an IDR-frame.

       <b>subq</b> <b>(</b><u>subme</u><b>)</b>
           Sub-pixel motion estimation method.

       <b>b_strategy</b> <b>(</b><u>b-adapt</u><b>)</b>
           Adaptive B-frame placement decision algorithm. Use only on first-pass.

       <b>keyint_min</b> <b>(</b><u>min-keyint</u><b>)</b>
           Minimum GOP size.

       <b>coder</b>
           Set entropy encoder. Possible values:

           <b>ac</b>  Enable CABAC.

           <b>vlc</b> Enable CAVLC and disable CABAC. It generates the same effect as <b>x264</b>'s <b>--no-cabac</b> option.

       <b>cmp</b> Set full pixel motion estimation comparison algorithm. Possible values:

           <b>chroma</b>
               Enable chroma in motion estimation.

           <b>sad</b> Ignore chroma in motion estimation. It generates the same effect as <b>x264</b>'s <b>--no-chroma-me</b> option.

       <b>threads</b> <b>(</b><u>threads</u><b>)</b>
           Number of encoding threads.

       <b>thread_type</b>
           Set multithreading technique. Possible values:

           <b>slice</b>
               Slice-based multithreading. It generates the same effect as <b>x264</b>'s <b>--sliced-threads</b> option.

           <b>frame</b>
               Frame-based multithreading.

       <b>flags</b>
           Set  encoding  flags.  It  can  be  used  to  disable closed GOP and enable open GOP by setting it to
           "-cgop". The result is similar to the behavior of <b>x264</b>'s <b>--open-gop</b> option.

       <b>rc_init_occupancy</b> <b>(</b><u>vbv-init</u><b>)</b>
           Initial VBV buffer occupancy

       <b>preset</b> <b>(</b><u>preset</u><b>)</b>
           Set the encoding preset.

       <b>tune</b> <b>(</b><u>tune</u><b>)</b>
           Set tuning of the encoding params.

       <b>profile</b> <b>(</b><u>profile</u><b>)</b>
           Set profile restrictions.

       <b>fastfirstpass</b>
           Enable fast settings when encoding first pass, when set to 1. When set to 0, it has the  same  effect
           of <b>x264</b>'s <b>--slow-firstpass</b> option.

       <b>crf</b> <b>(</b><u>crf</u><b>)</b>
           Set the quality for constant quality mode.

       <b>crf_max</b> <b>(</b><u>crf-max</u><b>)</b>
           In CRF mode, prevents VBV from lowering quality beyond this point.

       <b>qp</b> <b>(</b><u>qp</u><b>)</b>
           Set constant quantization rate control method parameter.

       <b>aq-mode</b> <b>(</b><u>aq-mode</u><b>)</b>
           Set AQ method. Possible values:

           <b>none</b> <b>(</b><u>0</u><b>)</b>
               Disabled.

           <b>variance</b> <b>(</b><u>1</u><b>)</b>
               Variance AQ (complexity mask).

           <b>autovariance</b> <b>(</b><u>2</u><b>)</b>
               Auto-variance AQ (experimental).

       <b>aq-strength</b> <b>(</b><u>aq-strength</u><b>)</b>
           Set AQ strength, reduce blocking and blurring in flat and textured areas.

       <b>psy</b> Use  psychovisual  optimizations  when  set  to  1.  When  set to 0, it has the same effect as <b>x264</b>'s
           <b>--no-psy</b> option.

       <b>psy-rd</b> <b>(</b><u>psy-rd</u><b>)</b>
           Set strength of psychovisual optimization, in <u>psy-rd</u>:<u>psy-trellis</u> format.

       <b>rc-lookahead</b> <b>(</b><u>rc-lookahead</u><b>)</b>
           Set number of frames to look ahead for frametype and ratecontrol.

       <b>weightb</b>
           Enable weighted prediction for B-frames when set to 1. When set to 0,  it  has  the  same  effect  as
           <b>x264</b>'s <b>--no-weightb</b> option.

       <b>weightp</b> <b>(</b><u>weightp</u><b>)</b>
           Set weighted prediction method for P-frames. Possible values:

           <b>none</b> <b>(</b><u>0</u><b>)</b>
               Disabled

           <b>simple</b> <b>(</b><u>1</u><b>)</b>
               Enable only weighted refs

           <b>smart</b> <b>(</b><u>2</u><b>)</b>
               Enable both weighted refs and duplicates

       <b>ssim</b> <b>(</b><u>ssim</u><b>)</b>
           Enable calculation and printing SSIM stats after the encoding.

       <b>intra-refresh</b> <b>(</b><u>intra-refresh</u><b>)</b>
           Enable the use of Periodic Intra Refresh instead of IDR frames when set to 1.

       <b>avcintra-class</b> <b>(</b><u>class</u><b>)</b>
           Configure the encoder to generate AVC-Intra.  Valid values are 50, 100 and 200

       <b>bluray-compat</b> <b>(</b><u>bluray-compat</u><b>)</b>
           Configure  the  encoder  to  be  compatible  with the bluray standard.  It is a shorthand for setting
           "bluray-compat=1 force-cfr=1".

       <b>b-bias</b> <b>(</b><u>b-bias</u><b>)</b>
           Set the influence on how often B-frames are used.

       <b>b-pyramid</b> <b>(</b><u>b-pyramid</u><b>)</b>
           Set method for keeping of some B-frames as references. Possible values:

           <b>none</b> <b>(</b><u>none</u><b>)</b>
               Disabled.

           <b>strict</b> <b>(</b><u>strict</u><b>)</b>
               Strictly hierarchical pyramid.

           <b>normal</b> <b>(</b><u>normal</u><b>)</b>
               Non-strict (not Blu-ray compatible).

       <b>mixed-refs</b>
           Enable the use of one reference per partition, as opposed to one reference per macroblock when set to
           1. When set to 0, it has the same effect as <b>x264</b>'s <b>--no-mixed-refs</b> option.

       <b>8x8dct</b>
           Enable adaptive spatial transform (high profile 8x8 transform) when set to 1. When set to 0,  it  has
           the same effect as <b>x264</b>'s <b>--no-8x8dct</b> option.

       <b>fast-pskip</b>
           Enable  early  SKIP  detection  on  P-frames  when set to 1. When set to 0, it has the same effect as
           <b>x264</b>'s <b>--no-fast-pskip</b> option.

       <b>aud</b> <b>(</b><u>aud</u><b>)</b>
           Enable use of access unit delimiters when set to 1.

       <b>mbtree</b>
           Enable use macroblock tree ratecontrol when set to 1. When set to 0, it has the same effect as <b>x264</b>'s
           <b>--no-mbtree</b> option.

       <b>deblock</b> <b>(</b><u>deblock</u><b>)</b>
           Set loop filter parameters, in <u>alpha</u>:<u>beta</u> form.

       <b>cplxblur</b> <b>(</b><u>cplxblur</u><b>)</b>
           Set fluctuations reduction in QP (before curve compression).

       <b>partitions</b> <b>(</b><u>partitions</u><b>)</b>
           Set partitions to consider as a comma-separated list of values.  Possible values in the list:

           <b>p8x8</b>
               8x8 P-frame partition.

           <b>p4x4</b>
               4x4 P-frame partition.

           <b>b8x8</b>
               4x4 B-frame partition.

           <b>i8x8</b>
               8x8 I-frame partition.

           <b>i4x4</b>
               4x4 I-frame partition.  (Enabling <b>p4x4</b> requires  <b>p8x8</b>  to  be  enabled.  Enabling  <b>i8x8</b>  requires
               adaptive spatial transform (<b>8x8dct</b> option) to be enabled.)

           <b>none</b> <b>(</b><u>none</u><b>)</b>
               Do not consider any partitions.

           <b>all</b> <b>(</b><u>all</u><b>)</b>
               Consider every partition.

       <b>direct-pred</b> <b>(</b><u>direct</u><b>)</b>
           Set direct MV prediction mode. Possible values:

           <b>none</b> <b>(</b><u>none</u><b>)</b>
               Disable MV prediction.

           <b>spatial</b> <b>(</b><u>spatial</u><b>)</b>
               Enable spatial predicting.

           <b>temporal</b> <b>(</b><u>temporal</u><b>)</b>
               Enable temporal predicting.

           <b>auto</b> <b>(</b><u>auto</u><b>)</b>
               Automatically decided.

       <b>slice-max-size</b> <b>(</b><u>slice-max-size</u><b>)</b>
           Set  the  limit  of  the  size  of each slice in bytes. If not specified but RTP payload size (<b>ps</b>) is
           specified, that is used.

       <b>stats</b> <b>(</b><u>stats</u><b>)</b>
           Set the file name for multi-pass stats.

       <b>nal-hrd</b> <b>(</b><u>nal-hrd</u><b>)</b>
           Set signal HRD information (requires <b>vbv-bufsize</b> to be set).  Possible values:

           <b>none</b> <b>(</b><u>none</u><b>)</b>
               Disable HRD information signaling.

           <b>vbr</b> <b>(</b><u>vbr</u><b>)</b>
               Variable bit rate.

           <b>cbr</b> <b>(</b><u>cbr</u><b>)</b>
               Constant bit rate (not allowed in MP4 container).

       <b>x264opts</b> <u>opts</u>
       <b>x264-params</b> <u>opts</u>
           Override the x264 configuration using a :-separated list of key=value options.

           The argument for both options is a list of <u>key</u>=<u>value</u> couples separated  by  ":".  With  <b>x264opts</b>  the
           value can be omitted, and the value 1 is assumed in that case.

           For  <u>filter</u>  and  <u>psy-rd</u> options values that use ":" as a separator themselves, use "," instead. They
           accept it as well since long ago but this is kept undocumented for some reason.

           For example, the options might be provided as:

                   level=30:bframes=0:weightp=0:cabac=0:ref=1:vbv-maxrate=768:vbv-bufsize=2000:analyse=all:me=umh:no-fast-pskip=1:subq=6:8x8dct=0:trellis=0

           For example to specify libx264 encoding options with <b>ffmpeg</b>:

                   ffmpeg -i foo.mpg -c:v libx264 -x264opts keyint=123:min-keyint=20 -an out.mkv

           To get the complete list of the libx264 options, invoke the command <b>x264</b> <b>--fullhelp</b>  or  consult  the
           libx264 documentation.

       <b>a53cc</b> <u>boolean</u>
           Import  closed  captions (which must be ATSC compatible format) into output.  Only the mpeg2 and h264
           decoders provide these. Default is 1 (on).

       <b>udu_sei</b> <u>boolean</u>
           Import user data unregistered SEI if available into output. Default is 0 (off).

       <b>mb_info</b> <u>boolean</u>
           Set mb_info data through AVFrameSideData, only useful when used from the API. Default is 0 (off).

       Encoding ffpresets for common usages are provided so they can be used with  the  general  presets  system
       (e.g. passing the <b>pre</b> option).

   <b>libx265</b>
       x265 H.265/HEVC encoder wrapper.

       This  encoder  requires the presence of the libx265 headers and library during configuration. You need to
       explicitly configure the build with <b>--enable-libx265</b>.

       <u>Options</u>

       <b>b</b>   Sets target video bitrate.

       <b>bf</b>
       <b>g</b>   Set the GOP size.

       <b>keyint_min</b>
           Minimum GOP size.

       <b>refs</b>
           Number of reference frames each P-frame can use. The range is from <u>1-16</u>.

       <b>preset</b>
           Set the x265 preset.

       <b>tune</b>
           Set the x265 tune parameter.

       <b>profile</b>
           Set profile restrictions.

       <b>crf</b> Set the quality for constant quality mode.

       <b>qp</b>  Set constant quantization rate control method parameter.

       <b>qmin</b>
           Minimum quantizer scale.

       <b>qmax</b>
           Maximum quantizer scale.

       <b>qdiff</b>
           Maximum difference between quantizer scales.

       <b>qblur</b>
           Quantizer curve blur

       <b>qcomp</b>
           Quantizer curve compression factor

       <b>i_qfactor</b>
       <b>b_qfactor</b>
       <b>forced-idr</b>
           Normally, when forcing a I-frame type, the encoder can select any type of I-frame. This option forces
           it to choose an IDR-frame.

       <b>udu_sei</b> <u>boolean</u>
           Import user data unregistered SEI if available into output. Default is 0 (off).

       <b>x265-params</b>
           Set x265 options using a list of <u>key</u>=<u>value</u> couples separated by ":". See <b>x265</b> <b>--help</b> for  a  list  of
           options.

           For example to specify libx265 encoding options with <b>-x265-params</b>:

                   ffmpeg -i input -c:v libx265 -x265-params crf=26:psy-rd=1 output.mp4

   <b>libxavs2</b>
       xavs2 AVS2-P2/IEEE1857.4 encoder wrapper.

       This  encoder requires the presence of the libxavs2 headers and library during configuration. You need to
       explicitly configure the build with <b>--enable-libxavs2</b>.

       The following standard libavcodec options are used:

       •   <b>b</b> / <b>bit_rate</b>

       •   <b>g</b> / <b>gop_size</b>

       •   <b>bf</b> / <b>max_b_frames</b>

       The encoder also has its own specific options:

       <u>Options</u>

       <b>lcu_row_threads</b>
           Set the number of parallel threads for rows from 1 to 8 (default 5).

       <b>initial_qp</b>
           Set the xavs2 quantization parameter from 1 to 63 (default 34). This is used to set  the  initial  qp
           for the first frame.

       <b>qp</b>  Set  the  xavs2  quantization  parameter  from 1 to 63 (default 34). This is used to set the qp value
           under constant-QP mode.

       <b>max_qp</b>
           Set the max qp for rate control from 1 to 63 (default 55).

       <b>min_qp</b>
           Set the min qp for rate control from 1 to 63 (default 20).

       <b>speed_level</b>
           Set the Speed level from 0 to 9 (default 0). Higher is better but slower.

       <b>log_level</b>
           Set the log level from -1 to 3 (default 0). -1: none, 0: error, 1: warning, 2: info, 3: debug.

       <b>xavs2-params</b>
           Set xavs2 options using a list of <u>key</u>=<u>value</u> couples separated by ":".

           For example to specify libxavs2 encoding options with <b>-xavs2-params</b>:

                   ffmpeg -i input -c:v libxavs2 -xavs2-params RdoqLevel=0 output.avs2

   <b>libxeve</b>
       eXtra-fast Essential Video Encoder (XEVE) MPEG-5 EVC encoder wrapper.   The  xeve-equivalent  options  or
       values are listed in parentheses for easy migration.

       This  encoder  requires the presence of the libxeve headers and library during configuration. You need to
       explicitly configure the build with <b>--enable-libxeve</b>.

           Many libxeve encoder options are mapped to FFmpeg global codec options, while unique encoder  options
           are  provided  through  private  options.  Additionally the xeve-params private options allows one to
           pass a list of key=value tuples as accepted by the libxeve "parse_xeve_params" function.

       The xeve project website is at &lt;<b>https://github.com/mpeg5/xeve</b>&gt;.

       <u>Options</u>

       The following options are supported by the libxeve wrapper.  The xeve-equivalent options  or  values  are
       listed in parentheses for easy migration.

           To  reduce  the  duplication  of  documentation,  only  the private options and some others requiring
           special attention are documented here. For the documentation of the undocumented generic options, see
           <b>the</b> <b>Codec</b> <b>Options</b> <b>chapter</b>.

           To get a more accurate and extensive  documentation  of  the  libxeve  options,  invoke  the  command
           "xeve_app --help" or consult the libxeve documentation.

       <b>b</b> <b>(</b><u>bitrate</u><b>)</b>
           Set target video bitrate in bits/s.  Note that FFmpeg's b option is expressed in bits/s, while xeve's
           bitrate is in kilobits/s.

       <b>bf</b> <b>(</b><u>bframes</u><b>)</b>
           Set the maximum number of B frames (1,3,7,15).

       <b>g</b> <b>(</b><u>keyint</u><b>)</b>
           Set the GOP size (I-picture period).

       <b>preset</b> <b>(</b><u>preset</u><b>)</b>
           Set  the  xeve preset.  Set the encoder preset value to determine encoding speed [fast, medium, slow,
           placebo]

       <b>tune</b> <b>(</b><u>tune</u><b>)</b>
           Set the encoder tune parameter [psnr, zerolatency]

       <b>profile</b> <b>(</b><u>profile</u><b>)</b>
           Set the encoder profile [0: baseline; 1: main]

       <b>crf</b> <b>(</b><u>crf</u><b>)</b>
           Set the quality for constant quality mode.  Constant rate factor &lt;10..49&gt; [default: 32]

       <b>qp</b> <b>(</b><u>qp</u><b>)</b>
           Set constant quantization rate control method parameter.  Quantization parameter qp &lt;0..51&gt; [default:
           32]

       <b>threads</b> <b>(</b><u>threads</u><b>)</b>
           Force to use a specific number of threads

   <b>libxvid</b>
       Xvid MPEG-4 Part 2 encoder wrapper.

       This encoder requires the presence of the libxvidcore headers and library during configuration. You  need
       to explicitly configure the build with "--enable-libxvid --enable-gpl".

       The  native "mpeg4" encoder supports the MPEG-4 Part 2 format, so users can encode to this format without
       this library.

       <u>Options</u>

       The following options are supported by the libxvid wrapper. Some of the following options are listed  but
       are  not  documented,  and  correspond  to  shared codec options. See <b>the</b> <b>Codec</b> <b>Options</b> <b>chapter</b> for their
       documentation. The other shared options which are not listed have no effect for the libxvid encoder.

       <b>b</b>
       <b>g</b>
       <b>qmin</b>
       <b>qmax</b>
       <b>mpeg_quant</b>
       <b>threads</b>
       <b>bf</b>
       <b>b_qfactor</b>
       <b>b_qoffset</b>
       <b>flags</b>
           Set specific encoding flags. Possible values:

           <b>mv4</b> Use four motion vector by macroblock.

           <b>aic</b> Enable high quality AC prediction.

           <b>gray</b>
               Only encode grayscale.

           <b>qpel</b>
               Enable quarter-pixel motion compensation.

           <b>cgop</b>
               Enable closed GOP.

           <b>global_header</b>
               Place global headers in extradata instead of every keyframe.

       <b>gmc</b> Enable the use of global motion compensation (GMC).  Default is 0 (disabled).

       <b>me_quality</b>
           Set motion estimation quality level. Possible values in decreasing  order  of  speed  and  increasing
           order of quality:

           <b>0</b>   Use no motion estimation (default).

           <b>1,</b> <b>2</b>
               Enable advanced diamond zonal search for 16x16 blocks and half-pixel refinement for 16x16 blocks.

           <b>3,</b> <b>4</b>
               Enable  all  of the things described above, plus advanced diamond zonal search for 8x8 blocks and
               half-pixel refinement for 8x8 blocks, also enable motion estimation on chroma planes  for  P  and
               B-frames.

           <b>5,</b> <b>6</b>
               Enable all of the things described above, plus extended 16x16 and 8x8 blocks search.

       <b>mbd</b> Set macroblock decision algorithm. Possible values in the increasing order of quality:

           <b>simple</b>
               Use macroblock comparing function algorithm (default).

           <b>bits</b>
               Enable rate distortion-based half pixel and quarter pixel refinement for 16x16 blocks.

           <b>rd</b>  Enable all of the things described above, plus rate distortion-based half pixel and quarter pixel
               refinement for 8x8 blocks, and rate distortion-based search using square pattern.

       <b>lumi_aq</b>
           Enable lumi masking adaptive quantization when set to 1. Default is 0 (disabled).

       <b>variance_aq</b>
           Enable variance adaptive quantization when set to 1. Default is 0 (disabled).

           When  combined  with  <b>lumi_aq</b>, the resulting quality will not be better than any of the two specified
           individually. In other words, the resulting quality will be the worse one of the two effects.

       <b>trellis</b>
           Set rate-distortion optimal quantization.

       <b>ssim</b>
           Set structural similarity (SSIM) displaying method. Possible values:

           <b>off</b> Disable displaying of SSIM information.

           <b>avg</b> Output average SSIM at the end of encoding to stdout. The format of showing the average SSIM is:

                       Average SSIM: %f

               For users who are not familiar with C, %f means a float number, or a decimal (e.g. 0.939232).

           <b>frame</b>
               Output both per-frame SSIM data during encoding and average  SSIM  at  the  end  of  encoding  to
               stdout. The format of per-frame information is:

                              SSIM: avg: %1.3f min: %1.3f max: %1.3f

               For  users  who are not familiar with C, %1.3f means a float number rounded to 3 digits after the
               dot (e.g. 0.932).

       <b>ssim_acc</b>
           Set SSIM accuracy. Valid options are integers within the  range  of  0-4,  while  0  gives  the  most
           accurate result and 4 computes the fastest.

   <b>MediaFoundation</b>
       This provides wrappers to encoders (both audio and video) in the MediaFoundation framework. It can access
       both  SW and HW encoders.  Video encoders can take input in either of nv12 or yuv420p form (some encoders
       support both, some support only either - in practice, nv12 is  the  safer  choice,  especially  among  HW
       encoders).

   <b>Microsoft</b> <b>RLE</b>
       Microsoft  RLE  aka  MSRLE  encoder.  Only 8-bit palette mode supported.  Compatible with Windows 3.1 and
       Windows 95.

       <u>Options</u>

       <b>g</b> <u>integer</u>
           Keyframe interval.  A keyframe is inserted at least every "-g" frames, sometimes sooner.

   <b>mpeg2</b>
       MPEG-2 video encoder.

       <u>Options</u>

       <b>profile</b>
           Select the mpeg2 profile to encode:

           <b>422</b>
           <b>high</b>
           <b>ss</b>  Spatially Scalable

           <b>snr</b> SNR Scalable

           <b>main</b>
           <b>simple</b>
       <b>level</b>
           Select the mpeg2 level to encode:

           <b>high</b>
           <b>high1440</b>
           <b>main</b>
           <b>low</b>
       <b>seq_disp_ext</b> <u>integer</u>
           Specifies if the encoder should write a sequence_display_extension to the output.

           <b>-1</b>
           <b>auto</b>
               Decide automatically to write it or not (this is the default) by  checking  if  the  data  to  be
               written is different from the default or unspecified values.

           <b>0</b>
           <b>never</b>
               Never write it.

           <b>1</b>
           <b>always</b>
               Always write it.

       <b>video_format</b> <u>integer</u>
           Specifies  the  video_format written into the sequence display extension indicating the source of the
           video pictures. The default is <b>unspecified</b>, can be <b>component</b>, <b>pal</b>, <b>ntsc</b>, <b>secam</b> or <b>mac</b>.   For  maximum
           compatibility, use <b>component</b>.

       <b>a53cc</b> <u>boolean</u>
           Import closed captions (which must be ATSC compatible format) into output.  Default is 1 (on).

   <b>png</b>
       PNG image encoder.

       <u>Private</u> <u>options</u>

       <b>dpi</b> <u>integer</u>
           Set physical density of pixels, in dots per inch, unset by default

       <b>dpm</b> <u>integer</u>
           Set physical density of pixels, in dots per meter, unset by default

   <b>ProRes</b>
       Apple ProRes encoder.

       FFmpeg  contains  2 ProRes encoders, the prores-aw and prores-ks encoder.  The used encoder can be chosen
       with the "-vcodec" option.

       <u>Private</u> <u>Options</u> <u>for</u> <u>prores-ks</u>

       <b>profile</b> <u>integer</u>
           Select the ProRes profile to encode

           <b>proxy</b>
           <b>lt</b>
           <b>standard</b>
           <b>hq</b>
           <b>4444</b>
           <b>4444xq</b>
       <b>quant_mat</b> <u>integer</u>
           Select quantization matrix.

           <b>auto</b>
           <b>default</b>
           <b>proxy</b>
           <b>lt</b>
           <b>standard</b>
           <b>hq</b>

           If set to <u>auto</u>, the matrix matching the profile will be picked.  If not set, the matrix providing the
           highest quality, <u>default</u>, will be picked.

       <b>bits_per_mb</b> <u>integer</u>
           How many bits to allot for coding one macroblock. Different profiles use between 200  and  2400  bits
           per macroblock, the maximum is 8000.

       <b>mbs_per_slice</b> <u>integer</u>
           Number  of  macroblocks  in  each  slice  (1-8);  the  default value (8) should be good in almost all
           situations.

       <b>vendor</b> <u>string</u>
           Override the 4-byte vendor ID.  A custom vendor ID like <u>apl0</u> would claim the stream was  produced  by
           the Apple encoder.

       <b>alpha_bits</b> <u>integer</u>
           Specify number of bits for alpha component.  Possible values are <u>0</u>, <u>8</u> and <u>16</u>.  Use <u>0</u> to disable alpha
           plane coding.

       <u>Speed</u> <u>considerations</u>

       In the default mode of operation the encoder has to honor frame constraints (i.e. not produce frames with
       size  bigger than requested) while still making output picture as good as possible.  A frame containing a
       lot of small details is harder  to  compress  and  the  encoder  would  spend  more  time  searching  for
       appropriate quantizers for each slice.

       Setting a higher <b>bits_per_mb</b> limit will improve the speed.

       For  the  fastest  encoding  speed set the <b>qscale</b> parameter (4 is the recommended value) and do not set a
       size constraint.

   <b>QSV</b> <b>Encoders</b>
       The family of Intel QuickSync Video encoders (MPEG-2, H.264, HEVC, JPEG/MJPEG, VP9, AV1)

       <u>Ratecontrol</u> <u>Method</u>

       The ratecontrol method is selected as follows:

       •   When <b>global_quality</b> is specified, a quality-based mode is used.  Specifically this means either

           -   <u>CQP</u> - constant quantizer scale, when the <b>qscale</b> codec  flag  is  also  set  (the  <b>-qscale</b>  ffmpeg
               option).

           -   <u>LA_ICQ</u> - intelligent constant quality with lookahead, when the <b>look_ahead</b> option is also set.

           -   <u>ICQ</u>  --  intelligent  constant quality otherwise. For the ICQ modes, global quality range is 1 to
               51, with 1 being the best quality.

       •   Otherwise when the desired average bitrate is specified with the <b>b</b> option, a  bitrate-based  mode  is
           used.

           -   <u>LA</u> - VBR with lookahead, when the <b>look_ahead</b> option is specified.

           -   <u>VCM</u> - video conferencing mode, when the <b>vcm</b> option is set.

           -   <u>CBR</u> - constant bitrate, when <b>maxrate</b> is specified and equal to the average bitrate.

           -   <u>VBR</u> - variable bitrate, when <b>maxrate</b> is specified, but is higher than the average bitrate.

           -   <u>AVBR</u>  -  average VBR mode, when <b>maxrate</b> is not specified, both <b>avbr_accuracy</b> and <b>avbr_convergence</b>
               are set to non-zero. This mode is available for H264 and HEVC on Windows.

       •   Otherwise the default ratecontrol method <u>CQP</u> is used.

       Note that depending on your system, a different mode than the one you specified may be  selected  by  the
       encoder. Set the verbosity level to <u>verbose</u> or higher to see the actual settings used by the QSV runtime.

       <u>Global</u> <u>Options</u> <u>-&gt;</u> <u>MSDK</u> <u>Options</u>

       Additional libavcodec global options are mapped to MSDK options as follows:

       •   <b>g/gop_size</b> -&gt; <b>GopPicSize</b>

       •   <b>bf/max_b_frames</b>+1 -&gt; <b>GopRefDist</b>

       •   <b>rc_init_occupancy/rc_initial_buffer_occupancy</b> -&gt; <b>InitialDelayInKB</b>

       •   <b>slices</b> -&gt; <b>NumSlice</b>

       •   <b>refs</b> -&gt; <b>NumRefFrame</b>

       •   <b>b_strategy/b_frame_strategy</b> -&gt; <b>BRefType</b>

       •   <b>cgop/CLOSED_GOP</b> codec flag -&gt; <b>GopOptFlag</b>

       •   For  the <u>CQP</u> mode, the <b>i_qfactor/i_qoffset</b> and <b>b_qfactor/b_qoffset</b> set the difference between <u>QPP</u> and
           <u>QPI</u>, and <u>QPP</u> and <u>QPB</u> respectively.

       •   Setting the <b>coder</b> option to the value <u>vlc</u> will make the H.264 encoder use CAVLC instead of CABAC.

       <u>Common</u> <u>Options</u>

       Following options are used by all qsv encoders.

       <u>async_depth</u>
           Specifies how many asynchronous operations an application performs before the application  explicitly
           synchronizes the result. If zero, the value is not specified.

       <u>preset</u>
           This option itemizes a range of choices from veryfast (best speed) to veryslow (best quality).

           <b>veryfast</b>
           <b>faster</b>
           <b>fast</b>
           <b>medium</b>
           <b>slow</b>
           <b>slower</b>
           <b>veryslow</b>
       <u>forced_idr</u>
           Forcing I frames as IDR frames.

       <u>low_power</u>
           For encoders set this flag to ON to reduce power consumption and GPU usage.

       <u>Runtime</u> <u>Options</u>

       Following options can be used durning qsv encoding.

       <u>global_quality</u>
       <u>i_quant_factor</u>
       <u>i_quant_offset</u>
       <u>b_quant_factor</u>
       <u>b_quant_offset</u>
           Supported in h264_qsv and hevc_qsv.  Change these value to reset qsv codec's qp configuration.

       <u>max_frame_size</u>
           Supported   in  h264_qsv  and  hevc_qsv.   Change  this  value  to  reset  qsv  codec's  MaxFrameSize
           configuration.

       <u>gop_size</u>
           Change this value to reset qsv codec's gop configuration.

       <u>int_ref_type</u>
       <u>int_ref_cycle_size</u>
       <u>int_ref_qp_delta</u>
       <u>int_ref_cycle_dist</u>
           Supported in h264_qsv  and  hevc_qsv.   Change  these  value  to  reset  qsv  codec's  Intra  Refresh
           configuration.

       <u>qmax</u>
       <u>qmin</u>
       <u>max_qp_i</u>
       <u>min_qp_i</u>
       <u>max_qp_p</u>
       <u>min_qp_p</u>
       <u>max_qp_b</u>
       <u>min_qp_b</u>
           Supported in h264_qsv.  Change these value to reset qsv codec's max/min qp configuration.

       <u>low_delay_brc</u>
           Supported  in  h264_qsv,  hevc_qsv and av1_qsv.  Change this value to reset qsv codec's low_delay_brc
           configuration.

       <u>framerate</u>
           Change this value to reset qsv codec's framerate configuration.

       <u>bit_rate</u>
       <u>rc_buffer_size</u>
       <u>rc_initial_buffer_occupancy</u>
       <u>rc_max_rate</u>
           Change these value to reset qsv codec's bitrate control configuration.

       <u>pic_timing_sei</u>
           Supported in  h264_qsv  and  hevc_qsv.   Change  this  value  to  reset  qsv  codec's  pic_timing_sei
           configuration.

       <u>qsv_params</u>
           Set QSV encoder parameters as a colon-separated list of key-value pairs.

           The <b>qsv_params</b> should be formatted as "key1=value1:key2=value2:...".

           These parameters are passed directly to the underlying Intel Quick Sync Video (QSV) encoder using the
           MFXSetParameter function.

           Example:

                   ffmpeg -i input.mp4 -c:v h264_qsv -qsv_params "CodingOption1=1:CodingOption2=2" output.mp4

           This  option  allows  fine-grained control over various encoder-specific settings provided by the QSV
           encoder.

       <u>H264</u> <u>options</u>

       These options are used by h264_qsv

       <u>extbrc</u>
           Extended bitrate control.

       <u>recovery_point_sei</u>
           Set this flag to insert the recovery point SEI message at the beginning of every intra refresh cycle.

       <u>rdo</u> Enable rate distortion optimization.

       <u>max_frame_size</u>
           Maximum encoded frame size in bytes.

       <u>max_frame_size_i</u>
           Maximum encoded frame size for I frames in bytes. If this value is set as larger than zero, then  for
           I frames the value set by max_frame_size is ignored.

       <u>max_frame_size_p</u>
           Maximum  encoded frame size for P frames in bytes. If this value is set as larger than zero, then for
           P frames the value set by max_frame_size is ignored.

       <u>max_slice_size</u>
           Maximum encoded slice size in bytes.

       <u>bitrate_limit</u>
           Toggle bitrate limitations.  Modifies bitrate to be in the range imposed by the QSV encoder.  Setting
           this  flag  off  may lead to violation of HRD conformance. Mind that specifying bitrate below the QSV
           encoder range might significantly affect quality. If on this option takes effect in non CQP modes: if
           bitrate is not in the range imposed by the QSV encoder, it will be changed to be in the range.

       <u>mbbrc</u>
           Setting this flag enables macroblock level bitrate control that generally improves subjective  visual
           quality.  Enabling  this  flag  may  have negative impact on performance and objective visual quality
           metric.

       <u>low_delay_brc</u>
           Setting this flag turns on or off LowDelayBRC feautre in qsv plugin,  which  provides  more  accurate
           bitrate  control  to  minimize the variance of bitstream size frame by frame. Value: -1-default 0-off
           1-on

       <u>adaptive_i</u>
           This flag controls insertion of I frames by the QSV encoder. Turn ON this flag to allow  changing  of
           frame type from P and B to I.

       <u>adaptive_b</u>
           This flag controls changing of frame type from B to P.

       <u>p_strategy</u>
           Enable P-pyramid: 0-default 1-simple 2-pyramid(bf need to be set to 0).

       <u>b_strategy</u>
           This option controls usage of B frames as reference.

       <u>dblk_idc</u>
           This option disable deblocking. It has value in range 0~2.

       <u>cavlc</u>
           If set, CAVLC is used; if unset, CABAC is used for encoding.

       <u>vcm</u> Video conferencing mode, please see ratecontrol method.

       <u>idr_interval</u>
           Distance (in I-frames) between IDR frames.

       <u>pic_timing_sei</u>
           Insert picture timing SEI with pic_struct_syntax element.

       <u>single_sei_nal_unit</u>
           Put all the SEI messages into one NALU.

       <u>max_dec_frame_buffering</u>
           Maximum number of frames buffered in the DPB.

       <u>look_ahead</u>
           Use VBR algorithm with look ahead.

       <u>look_ahead_depth</u>
           Depth of look ahead in number frames.

       <u>look_ahead_downsampling</u>
           Downscaling factor for the frames saved for the lookahead analysis.

           <b>unknown</b>
           <b>auto</b>
           <b>off</b>
           <b>2x</b>
           <b>4x</b>
       <u>int_ref_type</u>
           Specifies  intra  refresh  type.  The  major goal of intra refresh is improvement of error resilience
           without significant impact on encoded bitstream size caused by I frames.  The  SDK  encoder  achieves
           this by encoding part of each frame in refresh cycle using intra MBs. <u>none</u> means no refresh. <u>vertical</u>
           means  vertical refresh, by column of MBs. <u>horizontal</u> means horizontal refresh, by rows of MBs. <u>slice</u>
           means horizontal refresh by slices without  overlapping.  In  case  of  <u>slice</u>,  in_ref_cycle_size  is
           ignored. To enable intra refresh, B frame should be set to 0.

       <u>int_ref_cycle_size</u>
           Specifies number of pictures within refresh cycle starting from 2. 0 and 1 are invalid values.

       <u>int_ref_qp_delta</u>
           Specifies  QP  difference  for  inserted intra MBs. This is signed value in [-51, 51] range if target
           encoding bit-depth for luma samples is 8 and this range is [-63, 63] for 10 bit-depth  or  [-75,  75]
           for 12 bit-depth respectively.

       <u>int_ref_cycle_dist</u>
           Distance between the beginnings of the intra-refresh cycles in frames.

       <u>profile</u>
           <b>unknown</b>
           <b>baseline</b>
           <b>main</b>
           <b>high</b>
       <u>a53cc</u>
           Use A53 Closed Captions (if available).

       <u>aud</u> Insert the Access Unit Delimiter NAL.

       <u>mfmode</u>
           Multi-Frame Mode.

           <b>off</b>
           <b>auto</b>
       <u>repeat_pps</u>
           Repeat pps for every frame.

       <u>max_qp_i</u>
           Maximum video quantizer scale for I frame.

       <u>min_qp_i</u>
           Minimum video quantizer scale for I frame.

       <u>max_qp_p</u>
           Maximum video quantizer scale for P frame.

       <u>min_qp_p</u>
           Minimum video quantizer scale for P frame.

       <u>max_qp_b</u>
           Maximum video quantizer scale for B frame.

       <u>min_qp_b</u>
           Minimum video quantizer scale for B frame.

       <u>scenario</u>
           Provides a hint to encoder about the scenario for the encoding session.

           <b>unknown</b>
           <b>displayremoting</b>
           <b>videoconference</b>
           <b>archive</b>
           <b>livestreaming</b>
           <b>cameracapture</b>
           <b>videosurveillance</b>
           <b>gamestreaming</b>
           <b>remotegaming</b>
       <u>avbr_accuracy</u>
           Accuracy of the AVBR ratecontrol (unit of tenth of percent).

       <u>avbr_convergence</u>
           Convergence of the AVBR ratecontrol (unit of 100 frames)

           The parameters <u>avbr_accuracy</u> and <u>avbr_convergence</u> are for the average variable bitrate control (AVBR)
           algorithm.   The  algorithm  focuses on overall encoding quality while meeting the specified bitrate,
           <u>target_bitrate</u>, within the accuracy range <u>avbr_accuracy</u>, after a <u>avbr_Convergence</u> period. This method
           does not follow HRD and the instant bitrate is not capped or padded.

       <u>skip_frame</u>
           Use per-frame metadata "qsv_skip_frame" to skip frame when encoding. This option defines the usage of
           this metadata.

           <b>no_skip</b>
               Frame skipping is disabled.

           <b>insert_dummy</b>
               Encoder inserts into bitstream frame where all macroblocks are encoded as skipped.

           <b>insert_nothing</b>
               Similar to insert_dummy, but encoder inserts nothing into bitstream. The skipped frames are still
               used in brc. For example, gop still include skipped frames, and the frames after  skipped  frames
               will be larger in size.

           <b>brc_only</b>
               skip_frame metadata indicates the number of missed frames before the current frame.

       <u>HEVC</u> <u>Options</u>

       These options are used by hevc_qsv

       <u>extbrc</u>
           Extended bitrate control.

       <u>recovery_point_sei</u>
           Set this flag to insert the recovery point SEI message at the beginning of every intra refresh cycle.

       <u>rdo</u> Enable rate distortion optimization.

       <u>max_frame_size</u>
           Maximum encoded frame size in bytes.

       <u>max_frame_size_i</u>
           Maximum  encoded frame size for I frames in bytes. If this value is set as larger than zero, then for
           I frames the value set by max_frame_size is ignored.

       <u>max_frame_size_p</u>
           Maximum encoded frame size for P frames in bytes. If this value is set as larger than zero, then  for
           P frames the value set by max_frame_size is ignored.

       <u>max_slice_size</u>
           Maximum encoded slice size in bytes.

       <u>mbbrc</u>
           Setting  this flag enables macroblock level bitrate control that generally improves subjective visual
           quality. Enabling this flag may have negative impact on  performance  and  objective  visual  quality
           metric.

       <u>low_delay_brc</u>
           Setting  this  flag  turns  on or off LowDelayBRC feautre in qsv plugin, which provides more accurate
           bitrate control to minimize the variance of bitstream size frame by frame.  Value:  -1-default  0-off
           1-on

       <u>adaptive_i</u>
           This  flag  controls insertion of I frames by the QSV encoder. Turn ON this flag to allow changing of
           frame type from P and B to I.

       <u>adaptive_b</u>
           This flag controls changing of frame type from B to P.

       <u>p_strategy</u>
           Enable P-pyramid: 0-default 1-simple 2-pyramid(bf need to be set to 0).

       <u>b_strategy</u>
           This option controls usage of B frames as reference.

       <u>dblk_idc</u>
           This option disable deblocking. It has value in range 0~2.

       <u>idr_interval</u>
           Distance (in I-frames) between IDR frames.

           <b>begin_only</b>
               Output an IDR-frame only at the beginning of the stream.

       <u>load_plugin</u>
           A user plugin to load in an internal session.

           <b>none</b>
           <b>hevc_sw</b>
           <b>hevc_hw</b>
       <u>load_plugins</u>
           A :-separate list of hexadecimal plugin UIDs to load in an internal session.

       <u>look_ahead_depth</u>
           Depth of look ahead in number frames, available when extbrc option is enabled.

       <u>profile</u>
           Set the encoding profile (scc requires libmfx &gt;= 1.32).

           <b>unknown</b>
           <b>main</b>
           <b>main10</b>
           <b>mainsp</b>
           <b>rext</b>
           <b>scc</b>
       <u>tier</u>
           Set the encoding tier (only level &gt;= 4 can support high tier).  This option only  takes  effect  when
           the level option is specified.

           <b>main</b>
           <b>high</b>
       <u>gpb</u> 1: GPB (generalized P/B frame)

           0: regular P frame.

       <u>tile_cols</u>
           Number of columns for tiled encoding.

       <u>tile_rows</u>
           Number of rows for tiled encoding.

       <u>aud</u> Insert the Access Unit Delimiter NAL.

       <u>pic_timing_sei</u>
           Insert picture timing SEI with pic_struct_syntax element.

       <u>transform_skip</u>
           Turn this option ON to enable transformskip. It is supported on platform equal or newer than ICL.

       <u>int_ref_type</u>
           Specifies  intra  refresh  type.  The  major goal of intra refresh is improvement of error resilience
           without significant impact on encoded bitstream size caused by I frames.  The  SDK  encoder  achieves
           this by encoding part of each frame in refresh cycle using intra MBs. <u>none</u> means no refresh. <u>vertical</u>
           means  vertical refresh, by column of MBs. <u>horizontal</u> means horizontal refresh, by rows of MBs. <u>slice</u>
           means horizontal refresh by slices without  overlapping.  In  case  of  <u>slice</u>,  in_ref_cycle_size  is
           ignored. To enable intra refresh, B frame should be set to 0.

       <u>int_ref_cycle_size</u>
           Specifies number of pictures within refresh cycle starting from 2. 0 and 1 are invalid values.

       <u>int_ref_qp_delta</u>
           Specifies  QP  difference  for  inserted intra MBs. This is signed value in [-51, 51] range if target
           encoding bit-depth for luma samples is 8 and this range is [-63, 63] for 10 bit-depth  or  [-75,  75]
           for 12 bit-depth respectively.

       <u>int_ref_cycle_dist</u>
           Distance between the beginnings of the intra-refresh cycles in frames.

       <u>max_qp_i</u>
           Maximum video quantizer scale for I frame.

       <u>min_qp_i</u>
           Minimum video quantizer scale for I frame.

       <u>max_qp_p</u>
           Maximum video quantizer scale for P frame.

       <u>min_qp_p</u>
           Minimum video quantizer scale for P frame.

       <u>max_qp_b</u>
           Maximum video quantizer scale for B frame.

       <u>min_qp_b</u>
           Minimum video quantizer scale for B frame.

       <u>scenario</u>
           Provides a hint to encoder about the scenario for the encoding session.

           <b>unknown</b>
           <b>displayremoting</b>
           <b>videoconference</b>
           <b>archive</b>
           <b>livestreaming</b>
           <b>cameracapture</b>
           <b>videosurveillance</b>
           <b>gamestreaming</b>
           <b>remotegaming</b>
       <u>avbr_accuracy</u>
           Accuracy of the AVBR ratecontrol (unit of tenth of percent).

       <u>avbr_convergence</u>
           Convergence of the AVBR ratecontrol (unit of 100 frames)

           The parameters <u>avbr_accuracy</u> and <u>avbr_convergence</u> are for the average variable bitrate control (AVBR)
           algorithm.   The  algorithm  focuses on overall encoding quality while meeting the specified bitrate,
           <u>target_bitrate</u>, within the accuracy range <u>avbr_accuracy</u>, after a <u>avbr_Convergence</u> period. This method
           does not follow HRD and the instant bitrate is not capped or padded.

       <u>skip_frame</u>
           Use per-frame metadata "qsv_skip_frame" to skip frame when encoding. This option defines the usage of
           this metadata.

           <b>no_skip</b>
               Frame skipping is disabled.

           <b>insert_dummy</b>
               Encoder inserts into bitstream frame where all macroblocks are encoded as skipped.

           <b>insert_nothing</b>
               Similar to insert_dummy, but encoder inserts nothing into bitstream. The skipped frames are still
               used in brc. For example, gop still include skipped frames, and the frames after  skipped  frames
               will be larger in size.

           <b>brc_only</b>
               skip_frame metadata indicates the number of missed frames before the current frame.

       <u>MPEG2</u> <u>Options</u>

       These options are used by mpeg2_qsv

       <u>profile</u>
           <b>unknown</b>
           <b>simple</b>
           <b>main</b>
           <b>high</b>

       <u>VP9</u> <u>Options</u>

       These options are used by vp9_qsv

       <u>profile</u>
           <b>unknown</b>
           <b>profile0</b>
           <b>profile1</b>
           <b>profile2</b>
           <b>profile3</b>
       <u>tile_cols</u>
           Number of columns for tiled encoding (requires libmfx &gt;= 1.29).

       <u>tile_rows</u>
           Number of rows for tiled encoding (requires libmfx  &gt;= 1.29).

       <u>AV1</u> <u>Options</u>

       These options are used by av1_qsv (requires libvpl).

       <u>profile</u>
           <b>unknown</b>
           <b>main</b>
       <u>tile_cols</u>
           Number of columns for tiled encoding.

       <u>tile_rows</u>
           Number of rows for tiled encoding.

       <u>adaptive_i</u>
           This  flag  controls insertion of I frames by the QSV encoder. Turn ON this flag to allow changing of
           frame type from P and B to I.

       <u>adaptive_b</u>
           This flag controls changing of frame type from B to P.

       <u>b_strategy</u>
           This option controls usage of B frames as reference.

       <u>extbrc</u>
           Extended bitrate control.

       <u>look_ahead_depth</u>
           Depth of look ahead in number frames, available when extbrc option is enabled.

       <u>low_delay_brc</u>
           Setting this flag turns on or off LowDelayBRC feautre in qsv plugin,  which  provides  more  accurate
           bitrate  control  to  minimize the variance of bitstream size frame by frame. Value: -1-default 0-off
           1-on

       <u>max_frame_size</u>
           Set the allowed max size in bytes for each frame. If the frame size exceeds the  limitation,  encoder
           will adjust the QP value to control the frame size.  Invalid in CQP rate control mode.

       <u>max_frame_size_i</u>
           Maximum  encoded frame size for I frames in bytes. If this value is set as larger than zero, then for
           I frames the value set by max_frame_size is ignored.

       <u>max_frame_size_p</u>
           Maximum encoded frame size for P frames in bytes. If this value is set as larger than zero, then  for
           P frames the value set by max_frame_size is ignored.

   <b>snow</b>
       <u>Options</u>

       <b>iterative_dia_size</b>
           dia size for the iterative motion estimation

   <b>VAAPI</b> <b>encoders</b>
       Wrappers for hardware encoders accessible via VAAPI.

       These  encoders  only accept input in VAAPI hardware surfaces.  If you have input in software frames, use
       the <b>hwupload</b> filter to upload them to the GPU.

       The following standard libavcodec options are used:

       •   <b>g</b> / <b>gop_size</b>

       •   <b>bf</b> / <b>max_b_frames</b>

       •   <b>profile</b>

           If not set, this will be determined automatically from  the  format  of  the  input  frames  and  the
           profiles supported by the driver.

       •   <b>level</b>

       •   <b>b</b> / <b>bit_rate</b>

       •   <b>maxrate</b> / <b>rc_max_rate</b>

       •   <b>bufsize</b> / <b>rc_buffer_size</b>

       •   <b>rc_init_occupancy</b> / <b>rc_initial_buffer_occupancy</b>

       •   <b>compression_level</b>

           Speed / quality tradeoff: higher values are faster / worse quality.

       •   <b>q</b> / <b>global_quality</b>

           Size / quality tradeoff: higher values are smaller / worse quality.

       •   <b>qmin</b>

       •   <b>qmax</b>

       •   <b>i_qfactor</b> / <b>i_quant_factor</b>

       •   <b>i_qoffset</b> / <b>i_quant_offset</b>

       •   <b>b_qfactor</b> / <b>b_quant_factor</b>

       •   <b>b_qoffset</b> / <b>b_quant_offset</b>

       •   <b>slices</b>

       All encoders support the following options:

       <b>low_power</b>
           Some  drivers/platforms  offer  a  second encoder for some codecs intended to use less power than the
           default encoder; setting this option will attempt to use that encoder.  Note that it  may  support  a
           reduced feature set, so some other options may not be available in this mode.

       <b>idr_interval</b>
           Set  the number of normal intra frames between full-refresh (IDR) frames in open-GOP mode.  The intra
           frames are still IRAPs, but will not include  global  headers  and  may  have  non-decodable  leading
           pictures.

       <b>b_depth</b>
           Set  the  B-frame reference depth.  When set to one (the default), all B-frames will refer only to P-
           or I-frames.  When set to greater values multiple layers of B-frames will be present, frames in  each
           layer only referring to frames in higher layers.

       <b>async_depth</b>
           Maximum  processing  parallelism.  Increase  this  to improve single channel performance. This option
           doesn't work if driver doesn't implement vaSyncBuffer function. Please make  sure  there  are  enough
           hw_frames allocated if a large number of async_depth is used.

       <b>max_frame_size</b>
           Set  the  allowed max size in bytes for each frame. If the frame size exceeds the limitation, encoder
           will adjust the QP value to control the frame size.  Invalid in CQP rate control mode.

       <b>rc_mode</b>
           Set the rate control mode to use.  A given driver may only support a subset of modes.

           Possible modes:

           <b>auto</b>
               Choose the mode automatically based on driver  support  and  the  other  options.   This  is  the
               default.

           <b>CQP</b> Constant-quality.

           <b>CBR</b> Constant-bitrate.

           <b>VBR</b> Variable-bitrate.

           <b>ICQ</b> Intelligent constant-quality.

           <b>QVBR</b>
               Quality-defined variable-bitrate.

           <b>AVBR</b>
               Average variable bitrate.

       <b>blbrc</b>
           Enable  block  level  rate  control, which assigns different bitrate block by block.  Invalid for CQP
           mode.

       Each encoder also has its own specific options:

       <b>av1_vaapi</b>
           <b>profile</b> sets the value of <u>seq_profile</u>.  <b>tier</b> sets the value of <u>seq_tier</u>.  <b>level</b>  sets  the  value  of
           <u>seq_level_idx</u>.

           <b>tiles</b>
               Set  the  number  of  tiles to encode the input video with, as columns x rows.  (default is auto,
               which means use minimal tile column/row number).

           <b>tile_groups</b>
               Set tile groups number. All the tiles will be distributed as evenly  as  possible  to  each  tile
               group. (default is 1).

       <b>h264_vaapi</b>
           <b>profile</b>  sets  the  value  of  <u>profile_idc</u>  and  the  <u>constraint_set*_flag</u>s.  <b>level</b> sets the value of
           <u>level_idc</u>.

           <b>coder</b>
               Set entropy encoder (default is <u>cabac</u>).  Possible values:

               <b>ac</b>
               <b>cabac</b>
                   Use CABAC.

               <b>vlc</b>
               <b>cavlc</b>
                   Use CAVLC.

           <b>aud</b> Include access unit delimiters in the stream (not included by default).

           <b>sei</b> Set SEI message types to include.  Some combination of the following values:

               <b>identifier</b>
                   Include a <u>user_data_unregistered</u> message containing information about the encoder.

               <b>timing</b>
                   Include picture timing parameters (<u>buffering_period</u> and <u>pic_timing</u> messages).

               <b>recovery_point</b>
                   Include recovery points where appropriate (<u>recovery_point</u> messages).

       <b>hevc_vaapi</b>
           <b>profile</b> and <b>level</b> set the values of <u>general_profile_idc</u> and <u>general_level_idc</u> respectively.

           <b>aud</b> Include access unit delimiters in the stream (not included by default).

           <b>tier</b>
               Set <u>general_tier_flag</u>.  This may affect the level chosen for the stream if it is  not  explicitly
               specified.

           <b>sei</b> Set SEI message types to include.  Some combination of the following values:

               <b>hdr</b> Include  HDR  metadata  if  the  input  frames  have  it (<u>mastering_display_colour_volume</u> and
                   <u>content_light_level</u> messages).

           <b>tiles</b>
               Set the number of tiles to encode the input video with, as columns x rows.  Larger numbers  allow
               greater parallelism in both encoding and decoding, but may decrease coding efficiency.

       <b>mjpeg_vaapi</b>
           Only  baseline  DCT  encoding  is  supported.   The encoder always uses the standard quantisation and
           huffman tables - <b>global_quality</b> scales the standard quantisation table (range 1-100).

           For YUV, 4:2:0, 4:2:2 and 4:4:4 subsampling modes are supported.  RGB is  also  supported,  and  will
           create an RGB JPEG.

           <b>jfif</b>
               Include JFIF header in each frame (not included by default).

           <b>huffman</b>
               Include  standard huffman tables (on by default).  Turning this off will save a few hundred bytes
               in each output frame, but may lose compatibility with some JPEG decoders which don't fully handle
               MJPEG.

       <b>mpeg2_vaapi</b>
           <b>profile</b> and <b>level</b> set the value of <u>profile_and_level_indication</u>.

       <b>vp8_vaapi</b>
           B-frames are not supported.

           <b>global_quality</b> sets the <u>q_idx</u> used for non-key frames (range 0-127).

           <b>loop_filter_level</b>
           <b>loop_filter_sharpness</b>
               Manually set the loop filter parameters.

       <b>vp9_vaapi</b>
           <b>global_quality</b> sets the <u>q_idx</u> used for P-frames (range 0-255).

           <b>loop_filter_level</b>
           <b>loop_filter_sharpness</b>
               Manually set the loop filter parameters.

           B-frames are supported, but the output stream is always in encode order rather  than  display  order.
           If  B-frames  are  enabled, it may be necessary to use the <b>vp9_raw_reorder</b> bitstream filter to modify
           the output stream to display frames in the correct order.

           Only normal frames are produced - the <b>vp9_superframe</b> bitstream filter may be required  to  produce  a
           stream usable with all decoders.

   <b>vbn</b>
       Vizrt Binary Image encoder.

       This  format is used by the broadcast vendor Vizrt for quick texture streaming.  Advanced features of the
       format such as LZW compression of texture data or generation of mipmaps are not supported.

       <u>Options</u>

       <b>format</b> <u>string</u>
           Sets the texture compression used by the VBN file. Can be <u>dxt1</u>, <u>dxt5</u> or <u>raw</u>. Default is <u>dxt5</u>.

   <b>vc2</b>
       SMPTE VC-2 (previously BBC Dirac Pro). This codec was primarily aimed at  professional  broadcasting  but
       since it supports yuv420, yuv422 and yuv444 at 8 (limited range or full range), 10 or 12 bits, this makes
       it suitable for other tasks which require low overhead and low compression (like screen recording).

       <u>Options</u>

       <b>b</b>   Sets  target  video  bitrate.  Usually  that's around 1:6 of the uncompressed video bitrate (e.g. for
           1920x1080 50fps yuv422p10 that's around 400Mbps). Higher values (close to the  uncompressed  bitrate)
           turn on lossless compression mode.

       <b>field_order</b>
           Enables  field  coding when set (e.g. to tt - top field first) for interlaced inputs. Should increase
           compression with interlaced content as it splits the fields and encodes each separately.

       <b>wavelet_depth</b>
           Sets the total amount of wavelet transforms to apply, between 1 and 5 (default).  Lower values reduce
           compression and quality. Less capable decoders may not be able to handle values of <b>wavelet_depth</b> over
           3.

       <b>wavelet_type</b>
           Sets the transform type. Currently only <u>5_3</u> (LeGall) and  <u>9_7</u>  (Deslauriers-Dubuc)  are  implemented,
           with 9_7 being the one with better compression and thus is the default.

       <b>slice_width</b>
       <b>slice_height</b>
           Sets  the  slice  size for each slice. Larger values result in better compression.  For compatibility
           with other more limited decoders use <b>slice_width</b> of 32 and <b>slice_height</b> of 8.

       <b>tolerance</b>
           Sets the undershoot tolerance of the rate control system in percent. This is to prevent an  expensive
           search from being run.

       <b>qm</b>  Sets the quantization matrix preset to use by default or when <b>wavelet_depth</b> is set to 5

           -   <u>default</u>  Uses  the  default quantization matrix from the specifications, extended with values for
               the fifth level. This provides a good balance between keeping detail and omitting artifacts.

           -   <u>flat</u> Use a completely zeroed out quantization  matrix.  This  increases  PSNR  but  might  reduce
               perception. Use in bogus benchmarks.

           -   <u>color</u> Reduces detail but attempts to preserve color at extremely low bitrates.

</pre><h4><b>SUBTITLES</b> <b>ENCODERS</b></h4><pre>
   <b>dvdsub</b>
       This  codec encodes the bitmap subtitle format that is used in DVDs.  Typically they are stored in VOBSUB
       file pairs (*.idx + *.sub), and they can also be used in Matroska files.

       <u>Options</u>

       <b>palette</b>
           Specify the global palette used by the bitmaps.

           The format for this option is a string containing 16 24-bits hexadecimal numbers (without 0x  prefix)
           separated  by  commas,  for  example "0d00ee, ee450d, 101010, eaeaea, 0ce60b, ec14ed, ebff0b, 0d617a,
           7b7b7b, d1d1d1, 7b2a0e, 0d950c, 0f007b, cf0dec, cfa80c, 7c127b".

       <b>even_rows_fix</b>
           When set to 1, enable a work-around that makes the number of pixel rows even in all subtitles.   This
           fixes  a problem with some players that cut off the bottom row if the number is odd.  The work-around
           just adds a fully transparent row if needed.  The overhead is low, typically one byte per subtitle on
           average.

           By default, this work-around is disabled.

</pre><h4><b>BITSTREAM</b> <b>FILTERS</b></h4><pre>
       When you configure your FFmpeg build, all the supported bitstream filters are enabled by default. You can
       list all available ones using the configure option "--list-bsfs".

       You can disable all the bitstream filters using the configure option  "--disable-bsfs",  and  selectively
       enable  any  bitstream  filter  using  the  option  "--enable-bsf=BSF",  or  you can disable a particular
       bitstream filter using the option "--disable-bsf=BSF".

       The option "-bsfs" of the ff* tools will display the list of all the supported bitstream filters included
       in your build.

       The ff* tools have a -bsf option applied per stream, taking a  comma-separated  list  of  filters,  whose
       parameters follow the filter name after a '='.

               ffmpeg -i INPUT -c:v copy -bsf:v filter1[=opt1=str1:opt2=str2][,filter2] OUTPUT

       Below is a description of the currently available bitstream filters, with their parameters, if any.

   <b>aac_adtstoasc</b>
       Convert MPEG-2/4 AAC ADTS to an MPEG-4 Audio Specific Configuration bitstream.

       This  filter  creates  an  MPEG-4  AudioSpecificConfig  from an MPEG-2/4 ADTS header and removes the ADTS
       header.

       This filter is required for example when copying an AAC  stream  from  a  raw  ADTS  AAC  or  an  MPEG-TS
       container  to  MP4A-LATM,  to  an  FLV  file, or to MOV/MP4 files and related formats such as 3GP or M4A.
       Please note that it is auto-inserted for MP4A-LATM and MOV/MP4 and related formats.

   <b>av1_metadata</b>
       Modify metadata embedded in an AV1 stream.

       <b>td</b>  Insert or remove temporal delimiter OBUs in all temporal units of the stream.

           <b>insert</b>
               Insert a TD at the beginning of every TU which does not already have one.

           <b>remove</b>
               Remove the TD from the beginning of every TU which has one.

       <b>color_primaries</b>
       <b>transfer_characteristics</b>
       <b>matrix_coefficients</b>
           Set the color description fields in the stream (see AV1 section 6.4.2).

       <b>color_range</b>
           Set the color range in the stream (see AV1 section 6.4.2; note that this cannot be  set  for  streams
           using BT.709 primaries, sRGB transfer characteristic and identity (RGB) matrix coefficients).

           <b>tv</b>  Limited range.

           <b>pc</b>  Full range.

       <b>chroma_sample_position</b>
           Set the chroma sample location in the stream (see AV1 section 6.4.2).  This can only be set for 4:2:0
           streams.

           <b>vertical</b>
               Left position (matching the default in MPEG-2 and H.264).

           <b>colocated</b>
               Top-left position.

       <b>tick_rate</b>
           Set the tick rate (<u>time_scale</u> <u>/</u> <u>num_units_in_display_tick</u>) in the timing info in the sequence header.

       <b>num_ticks_per_picture</b>
           Set  the number of ticks in each picture, to indicate that the stream has a fixed framerate.  Ignored
           if <b>tick_rate</b> is not also set.

       <b>delete_padding</b>
           Deletes Padding OBUs.

   <b>chomp</b>
       Remove zero padding at the end of a packet.

   <b>dca_core</b>
       Extract the core from a DCA/DTS stream, dropping extensions such as DTS-HD.

   <b>dovi_rpu</b>
       Manipulate Dolby Vision metadata in a HEVC/AV1 bitstream, optionally enabling metadata compression.

       <b>strip</b>
           If enabled, strip all Dolby Vision metadata (configuration record + RPU data blocks) from the stream.

       <b>compression</b>
           Which compression level to enable.

           <b>none</b>
               No metadata compression.

           <b>limited</b>
               Limited metadata compression scheme. Should  be  compatible  with  most  devices.   This  is  the
               default.

           <b>extended</b>
               Extended  metadata  compression.  Devices  are not required to support this. Note that this level
               currently behaves the same as <b>limited</b> in libavcodec.

   <b>dump_extra</b>
       Add extradata to the beginning of the filtered packets except when said  packets  already  exactly  begin
       with the extradata that is intended to be added.

       <b>freq</b>
           The additional argument specifies which packets should be filtered.  It accepts the values:

           <b>k</b>
           <b>keyframe</b>
               add extradata to all key packets

           <b>e</b>
           <b>all</b> add extradata to all packets

       If not specified it is assumed <b>k</b>.

       For  example  the  following  <b>ffmpeg</b>  command  forces  a  global header (thus disabling individual packet
       headers) in the H.264 packets generated by the "libx264" encoder, but corrects them by adding the  header
       stored in extradata to the key packets:

               ffmpeg -i INPUT -map 0 -flags:v +global_header -c:v libx264 -bsf:v dump_extra out.ts

   <b>dv_error_marker</b>
       Blocks in DV which are marked as damaged are replaced by blocks of the specified color.

       <b>color</b>
           The color to replace damaged blocks by

       <b>sta</b> A  16  bit  mask  which  specifies which of the 16 possible error status values are to be replaced by
           colored blocks. 0xFFFE is the default which replaces all non 0 error status values.

           <b>ok</b>  No error, no concealment

           <b>err</b> Error, No concealment

           <b>res</b> Reserved

           <b>notok</b>
               Error or concealment

           <b>notres</b>
               Not reserved

           <b>Aa,</b> <b>Ba,</b> <b>Ca,</b> <b>Ab,</b> <b>Bb,</b> <b>Cb,</b> <b>A,</b> <b>B,</b> <b>C,</b> <b>a,</b> <b>b,</b> <b>erri,</b> <b>erru</b>
               The specific error status code

           see            page            44-46            or             section             5.5             of
           &lt;<b><a href="http://web.archive.org/web/20060927044735/http">http://web.archive.org/web/20060927044735/http</a>://www.smpte.org/smpte_store/standards/pdf/s314m.pdf</b>&gt;

   <b>eac3_core</b>
       Extract the core from a E-AC-3 stream, dropping extra channels.

   <b>extract_extradata</b>
       Extract the in-band extradata.

       Certain codecs allow the long-term headers (e.g. MPEG-2 sequence headers, or H.264/HEVC (VPS/)SPS/PPS) to
       be  transmitted either "in-band" (i.e. as a part of the bitstream containing the coded frames) or "out of
       band" (e.g. on the container level). This latter form is called "extradata" in FFmpeg terminology.

       This bitstream filter detects the in-band headers and makes them available as extradata.

       <b>remove</b>
           When this option is enabled, the long-term headers are removed from the bitstream after extraction.

   <b>filter_units</b>
       Remove units with types in or not in a given set from the stream.

       <b>pass_types</b>
           List of unit types or ranges of unit types to pass  through  while  removing  all  others.   This  is
           specified as a '|'-separated list of unit type values or ranges of values with '-'.

       <b>remove_types</b>
           Identical to <b>pass_types</b>, except the units in the given set removed and all others passed through.

       The types used by pass_types and remove_types correspond to NAL unit types (nal_unit_type) in H.264, HEVC
       and  H.266 (see Table 7-1 in the H.264 and HEVC specifications or Table 5 in the H.266 specification), to
       marker values for JPEG (without 0xFF prefix) and to start codes without start code prefix (i.e. the  byte
       following the 0x000001) for MPEG-2.  For VP8 and VP9, every unit has type zero.

       Extradata is unchanged by this transformation, but note that if the stream contains inline parameter sets
       then the output may be unusable if they are removed.

       For example, to remove all non-VCL NAL units from an H.264 stream:

               ffmpeg -i INPUT -c:v copy -bsf:v 'filter_units=pass_types=1-5' OUTPUT

       To remove all AUDs, SEI and filler from an H.265 stream:

               ffmpeg -i INPUT -c:v copy -bsf:v 'filter_units=remove_types=35|38-40' OUTPUT

       To remove all user data from a MPEG-2 stream, including Closed Captions:

               ffmpeg -i INPUT -c:v copy -bsf:v 'filter_units=remove_types=178' OUTPUT

       To remove all SEI from a H264 stream, including Closed Captions:

               ffmpeg -i INPUT -c:v copy -bsf:v 'filter_units=remove_types=6' OUTPUT

       To remove all prefix and suffix SEI from a HEVC stream, including Closed Captions and dynamic HDR:

               ffmpeg -i INPUT -c:v copy -bsf:v 'filter_units=remove_types=39|40' OUTPUT

   <b>hapqa_extract</b>
       Extract  Rgb  or  Alpha  part  of  an HAPQA file, without recompression, in order to create an HAPQ or an
       HAPAlphaOnly file.

       <b>texture</b>
           Specifies the texture to keep.

           <b>color</b>
           <b>alpha</b>

       Convert HAPQA to HAPQ

               ffmpeg -i hapqa_inputfile.mov -c copy -bsf:v hapqa_extract=texture=color -tag:v HapY -metadata:s:v:0 encoder="HAPQ" hapq_file.mov

       Convert HAPQA to HAPAlphaOnly

               ffmpeg -i hapqa_inputfile.mov -c copy -bsf:v hapqa_extract=texture=alpha -tag:v HapA -metadata:s:v:0 encoder="HAPAlpha Only" hapalphaonly_file.mov

   <b>h264_metadata</b>
       Modify metadata embedded in an H.264 stream.

       <b>aud</b> Insert or remove AUD NAL units in all access units of the stream.

           <b>pass</b>
           <b>insert</b>
           <b>remove</b>

           Default is pass.

       <b>sample_aspect_ratio</b>
           Set the sample aspect ratio of the stream in the VUI parameters.  See H.264 table E-1.

       <b>overscan_appropriate_flag</b>
           Set whether the stream is suitable for display using overscan or not (see H.264 section E.2.1).

       <b>video_format</b>
       <b>video_full_range_flag</b>
           Set the video format in the stream (see H.264 section E.2.1 and table E-2).

       <b>colour_primaries</b>
       <b>transfer_characteristics</b>
       <b>matrix_coefficients</b>
           Set the colour description in the stream (see H.264 section E.2.1 and tables E-3, E-4 and E-5).

       <b>chroma_sample_loc_type</b>
           Set the chroma sample location in the stream (see H.264 section E.2.1 and figure E-1).

       <b>tick_rate</b>
           Set the tick rate (time_scale / num_units_in_tick) in the VUI parameters.  This is the smallest  time
           unit  representable  in the stream, and in many cases represents the field rate of the stream (double
           the frame rate).

       <b>fixed_frame_rate_flag</b>
           Set whether the stream has fixed framerate - typically this indicates that the framerate  is  exactly
           half  the tick rate, but the exact meaning is dependent on interlacing and the picture structure (see
           H.264 section E.2.1 and table E-6).

       <b>zero_new_constraint_set_flags</b>
           Zero constraint_set4_flag and constraint_set5_flag in the SPS. These bits were reserved in a previous
           version of the H.264 spec, and thus some hardware decoders require these to be zero.  The  result  of
           zeroing this is still a valid bitstream.

       <b>crop_left</b>
       <b>crop_right</b>
       <b>crop_top</b>
       <b>crop_bottom</b>
           Set  the frame cropping offsets in the SPS.  These values will replace the current ones if the stream
           is already cropped.

           These fields are set in pixels.  Note that some sizes may not  be  representable  if  the  chroma  is
           subsampled or the stream is interlaced (see H.264 section 7.4.2.1.1).

       <b>sei_user_data</b>
           Insert  a  string as SEI unregistered user data.  The argument must be of the form <u>UUID+string</u>, where
           the UUID is as hex digits possibly separated by hyphens, and the string can be anything.

           For example, <b>086f3693-b7b3-4f2c-9653-21492feee5b8+hello</b> will insert the string  ``hello''  associated
           with the given UUID.

       <b>delete_filler</b>
           Deletes both filler NAL units and filler SEI messages.

       <b>display_orientation</b>
           Insert,  extract or remove Display orientation SEI messages.  See H.264 section D.1.27 and D.2.27 for
           syntax and semantics.

           <b>pass</b>
           <b>insert</b>
           <b>remove</b>
           <b>extract</b>

           Default is pass.

           Insert mode works in  conjunction  with  "rotate"  and  "flip"  options.   Any  pre-existing  Display
           orientation  messages  will  be  removed in insert or remove mode.  Extract mode attaches the display
           matrix to the packet as side data.

       <b>rotate</b>
           Set rotation in display orientation SEI (anticlockwise angle in degrees).  Range  is  -360  to  +360.
           Default is NaN.

       <b>flip</b>
           Set flip in display orientation SEI.

           <b>horizontal</b>
           <b>vertical</b>

           Default is unset.

       <b>level</b>
           Set the level in the SPS.  Refer to H.264 section A.3 and tables A-1 to A-5.

           The  argument must be the name of a level (for example, <b>4.2</b>), a level_idc value (for example, <b>42</b>), or
           the special name <b>auto</b> indicating that the filter should attempt to guess the  level  from  the  input
           stream properties.

   <b>h264_mp4toannexb</b>
       Convert an H.264 bitstream from length prefixed mode to start code prefixed mode (as defined in the Annex
       B of the ITU-T H.264 specification).

       This  is  required  by  some  streaming  formats,  typically  the  MPEG-2  transport stream format (muxer
       "mpegts").

       For example to remux an MP4 file containing an H.264 stream to mpegts format with <b>ffmpeg</b>, you can use the
       command:

               ffmpeg -i INPUT.mp4 -codec copy -bsf:v h264_mp4toannexb OUTPUT.ts

       Please note that this filter is auto-inserted for MPEG-TS (muxer "mpegts") and raw H.264  (muxer  "h264")
       output formats.

   <b>h264_redundant_pps</b>
       This  applies  a specific fixup to some Blu-ray streams which contain redundant PPSs modifying irrelevant
       parameters of the stream which confuse other transformations which require correct extradata.

   <b>hevc_metadata</b>
       Modify metadata embedded in an HEVC stream.

       <b>aud</b> Insert or remove AUD NAL units in all access units of the stream.

           <b>insert</b>
           <b>remove</b>
       <b>sample_aspect_ratio</b>
           Set the sample aspect ratio in the stream in the VUI parameters.

       <b>video_format</b>
       <b>video_full_range_flag</b>
           Set the video format in the stream (see H.265 section E.3.1 and table E.2).

       <b>colour_primaries</b>
       <b>transfer_characteristics</b>
       <b>matrix_coefficients</b>
           Set the colour description in the stream (see H.265 section E.3.1 and tables E.3, E.4 and E.5).

       <b>chroma_sample_loc_type</b>
           Set the chroma sample location in the stream (see H.265 section E.3.1 and figure E.1).

       <b>tick_rate</b>
           Set the tick rate in the VPS and VUI  parameters  (time_scale  /  num_units_in_tick).  Combined  with
           <b>num_ticks_poc_diff_one</b>,  this  can set a constant framerate in the stream.  Note that it is likely to
           be overridden by container parameters when the stream is in a container.

       <b>num_ticks_poc_diff_one</b>
           Set   poc_proportional_to_timing_flag   in   VPS   and   VUI   and   use   this    value    to    set
           num_ticks_poc_diff_one_minus1  (see  H.265  sections 7.4.3.1 and E.3.1).  Ignored if <b>tick_rate</b> is not
           also set.

       <b>crop_left</b>
       <b>crop_right</b>
       <b>crop_top</b>
       <b>crop_bottom</b>
           Set the conformance window cropping offsets in the SPS.  These values will replace the  current  ones
           if the stream is already cropped.

           These  fields  are  set  in  pixels.   Note that some sizes may not be representable if the chroma is
           subsampled (H.265 section 7.4.3.2.1).

       <b>width</b>
       <b>height</b>
           Set width and height after crop.

       <b>level</b>
           Set the level in the VPS and SPS.  See H.265 section A.4 and tables A.6 and A.7.

           The argument must be the name of a level (for example, <b>5.1</b>), a <u>general_level_idc</u> value (for  example,
           <b>153</b>  for  level 5.1), or the special name <b>auto</b> indicating that the filter should attempt to guess the
           level from the input stream properties.

   <b>hevc_mp4toannexb</b>
       Convert an HEVC/H.265 bitstream from length prefixed mode to start code prefixed mode (as defined in  the
       Annex B of the ITU-T H.265 specification).

       This  is  required  by  some  streaming  formats,  typically  the  MPEG-2  transport stream format (muxer
       "mpegts").

       For example to remux an MP4 file containing an HEVC stream to mpegts format with <b>ffmpeg</b>, you can use  the
       command:

               ffmpeg -i INPUT.mp4 -codec copy -bsf:v hevc_mp4toannexb OUTPUT.ts

       Please  note  that  this  filter  is auto-inserted for MPEG-TS (muxer "mpegts") and raw HEVC/H.265 (muxer
       "h265" or "hevc") output formats.

   <b>imxdump</b>
       Modifies the bitstream to fit in MOV and to be usable by the Final Cut  Pro  decoder.  This  filter  only
       applies  to  the  mpeg2video  codec,  and  is  likely  not  needed for Final Cut Pro 7 and newer with the
       appropriate <b>-tag:v</b>.

       For example, to remux 30 MB/sec NTSC IMX to MOV:

               ffmpeg -i input.mxf -c copy -bsf:v imxdump -tag:v mx3n output.mov

   <b>mjpeg2jpeg</b>
       Convert MJPEG/AVI1 packets to full JPEG/JFIF packets.

       MJPEG is a video codec wherein each video frame is essentially a JPEG image. The individual frames can be
       extracted without loss, e.g. by

               ffmpeg -i ../some_mjpeg.avi -c:v copy frames_%d.jpg

       Unfortunately, these chunks are incomplete JPEG images, because they lack the DHT  segment  required  for
       decoding. Quoting from &lt;<b><a href="http://www.digitalpreservation.gov/formats/fdd/fdd000063.shtml">http://www.digitalpreservation.gov/formats/fdd/fdd000063.shtml</a></b>&gt;:

       Avery  Lee,  writing  in  the rec.video.desktop newsgroup in 2001, commented that "MJPEG, or at least the
       MJPEG in AVIs having the MJPG fourcc, is restricted JPEG with a fixed -- and *omitted* -- Huffman  table.
       The  JPEG  must  be  YCbCr  colorspace,  it  must  be  4:2:2, and it must use basic Huffman encoding, not
       arithmetic or progressive. . . . You can indeed extract the MJPEG frames and decode them with  a  regular
       JPEG  decoder,  but  you have to prepend the DHT segment to them, or else the decoder won't have any idea
       how to decompress the data. The exact table necessary is given in the OpenDML spec."

       This bitstream filter patches the header of frames extracted from an  MJPEG  stream  (carrying  the  AVI1
       header ID and lacking a DHT segment) to produce fully qualified JPEG images.

               ffmpeg -i mjpeg-movie.avi -c:v copy -bsf:v mjpeg2jpeg frame_%d.jpg
               exiftran -i -9 frame*.jpg
               ffmpeg -i frame_%d.jpg -c:v copy rotated.avi

   <b>mjpegadump</b>
       Add an MJPEG A header to the bitstream, to enable decoding by Quicktime.

   <b>mov2textsub</b>
       Extract  a  representable  text file from MOV subtitles, stripping the metadata header from each subtitle
       packet.

       See also the <b>text2movsub</b> filter.

   <b>mpeg2_metadata</b>
       Modify metadata embedded in an MPEG-2 stream.

       <b>display_aspect_ratio</b>
           Set the display aspect ratio in the stream.

           The following fixed values are supported:

           <b>4/3</b>
           <b>16/9</b>
           <b>221/100</b>

           Any other value will result in square pixels being signalled instead (see  H.262  section  6.3.3  and
           table 6-3).

       <b>frame_rate</b>
           Set  the  frame rate in the stream.  This is constructed from a table of known values combined with a
           small multiplier and divisor - if the supplied  value  is  not  exactly  representable,  the  nearest
           representable value will be used instead (see H.262 section 6.3.3 and table 6-4).

       <b>video_format</b>
           Set the video format in the stream (see H.262 section 6.3.6 and table 6-6).

       <b>colour_primaries</b>
       <b>transfer_characteristics</b>
       <b>matrix_coefficients</b>
           Set the colour description in the stream (see H.262 section 6.3.6 and tables 6-7, 6-8 and 6-9).

   <b>mpeg4_unpack_bframes</b>
       Unpack DivX-style packed B-frames.

       DivX-style  packed  B-frames  are  not  valid  MPEG-4 and were only a workaround for the broken Video for
       Windows subsystem.  They use more space, can cause minor AV sync issues, require more CPU power to decode
       (unless the player has some decoded picture queue to compensate the 2,0,2,0 frame per packet  style)  and
       cause trouble if copied into a standard container like mp4 or mpeg-ps/ts, because MPEG-4 decoders may not
       be able to decode them, since they are not valid MPEG-4.

       For  example to fix an AVI file containing an MPEG-4 stream with DivX-style packed B-frames using <b>ffmpeg</b>,
       you can use the command:

               ffmpeg -i INPUT.avi -codec copy -bsf:v mpeg4_unpack_bframes OUTPUT.avi

   <b>noise</b>
       Damages the contents of packets or simply drops them without damaging the  container.  Can  be  used  for
       fuzzing or testing error resilience/concealment.

       Parameters:

       <b>amount</b>
           Accepts  an  expression whose evaluation per-packet determines how often bytes in that packet will be
           modified. A value below 0 will result in a variable frequency.  Default is  0  which  results  in  no
           modification.  However,  if neither amount nor drop is specified, amount will be set to <u>-1</u>. See below
           for accepted variables.

       <b>drop</b>
           Accepts an expression evaluated per-packet whose value determines whether  that  packet  is  dropped.
           Evaluation  to  a  positive value results in the packet being dropped. Evaluation to a negative value
           results in a variable chance of it being dropped, roughly inverse in proportion to the  magnitude  of
           the value. Default is 0 which results in no drops. See below for accepted variables.

       <b>dropamount</b>
           Accepts  a non-negative integer, which assigns a variable chance of it being dropped, roughly inverse
           in proportion to the value. Default is 0 which results in no drops. This option is kept for backwards
           compatibility and is equivalent to setting drop to a negative value  with  the  same  magnitude  i.e.
           "dropamount=4" is the same as "drop=-4". Ignored if drop is also specified.

       Both "amount" and "drop" accept expressions containing the following variables:

       <b>n</b>   The index of the packet, starting from zero.

       <b>tb</b>  The timebase for packet timestamps.

       <b>pts</b> Packet presentation timestamp.

       <b>dts</b> Packet decoding timestamp.

       <b>nopts</b>
           Constant representing AV_NOPTS_VALUE.

       <b>startpts</b>
           First non-AV_NOPTS_VALUE PTS seen in the stream.

       <b>startdts</b>
           First non-AV_NOPTS_VALUE DTS seen in the stream.

       <b>duration</b>
       <b>d</b>   Packet duration, in timebase units.

       <b>pos</b> Packet position in input; may be -1 when unknown or not set.

       <b>size</b>
           Packet size, in bytes.

       <b>key</b> Whether packet is marked as a keyframe.

       <b>state</b>
           A pseudo random integer, primarily derived from the content of packet payload.

       <u>Examples</u>

       Apply modification to every byte but don't drop any packets.

               ffmpeg -i INPUT -c copy -bsf noise=1 output.mkv

       Drop  every  video  packet  not  marked  as  a  keyframe after timestamp 30s but do not modify any of the
       remaining packets.

               ffmpeg -i INPUT -c copy -bsf:v noise=drop='gt(t\,30)*not(key)' output.mkv

       Drop one second of audio every 10 seconds and add some random noise to the rest.

               ffmpeg -i INPUT -c copy -bsf:a noise=amount=-1:drop='between(mod(t\,10)\,9\,10)' output.mkv

   <b>null</b>
       This bitstream filter passes the packets through unchanged.

   <b>pcm_rechunk</b>
       Repacketize PCM audio to a fixed number of samples per packet or a fixed packet rate per second. This  is
       similar to the <b>asetnsamples</b> <b>audio</b> <b>filter</b> but works on audio packets instead of audio frames.

       <b>nb_out_samples,</b> <b>n</b>
           Set  the  number  of  samples  per  each output audio packet. The number is intended as the number of
           samples <u>per</u> <u>each</u> <u>channel</u>. Default value is 1024.

       <b>pad,</b> <b>p</b>
           If set to 1, the filter will pad the last audio packet with silence, so that it will contain the same
           number of samples (or roughly the same number of samples,  see  <b>frame_rate</b>)  as  the  previous  ones.
           Default value is 1.

       <b>frame_rate,</b> <b>r</b>
           This option makes the filter output a fixed number of packets per second instead of a fixed number of
           samples  per  packet.  If the audio sample rate is not divisible by the frame rate then the number of
           samples will not be constant but will vary slightly so that each packet will start as  close  to  the
           frame boundary as possible. Using this option has precedence over <b>nb_out_samples</b>.

       You can generate the well known 1602-1601-1602-1601-1602 pattern of 48kHz audio for NTSC frame rate using
       the <b>frame_rate</b> option.

               ffmpeg -f lavfi -i sine=r=48000:d=1 -c pcm_s16le -bsf pcm_rechunk=r=30000/1001 -f framecrc -

   <b>pgs_frame_merge</b>
       Merge  a  sequence  of  PGS  Subtitle  segments ending with an "end of display set" segment into a single
       packet.

       This is required by some containers that support PGS subtitles (muxer "matroska").

   <b>prores_metadata</b>
       Modify color property metadata embedded in prores stream.

       <b>color_primaries</b>
           Set the color primaries.  Available values are:

           <b>auto</b>
               Keep the same color primaries property (default).

           <b>unknown</b>
           <b>bt709</b>
           <b>bt470bg</b>
               BT601 625

           <b>smpte170m</b>
               BT601 525

           <b>bt2020</b>
           <b>smpte431</b>
               DCI P3

           <b>smpte432</b>
               P3 D65

       <b>transfer_characteristics</b>
           Set the color transfer.  Available values are:

           <b>auto</b>
               Keep the same transfer characteristics property (default).

           <b>unknown</b>
           <b>bt709</b>
               BT 601, BT 709, BT 2020

           <b>smpte2084</b>
               SMPTE ST 2084

           <b>arib-std-b67</b>
               ARIB STD-B67

       <b>matrix_coefficients</b>
           Set the matrix coefficient.  Available values are:

           <b>auto</b>
               Keep the same colorspace property (default).

           <b>unknown</b>
           <b>bt709</b>
           <b>smpte170m</b>
               BT 601

           <b>bt2020nc</b>

       Set Rec709 colorspace for each frame of the file

               ffmpeg -i INPUT -c copy -bsf:v prores_metadata=color_primaries=bt709:color_trc=bt709:colorspace=bt709 output.mov

       Set Hybrid Log-Gamma parameters for each frame of the file

               ffmpeg -i INPUT -c copy -bsf:v prores_metadata=color_primaries=bt2020:color_trc=arib-std-b67:colorspace=bt2020nc output.mov

   <b>remove_extra</b>
       Remove extradata from packets.

       It accepts the following parameter:

       <b>freq</b>
           Set which frame types to remove extradata from.

           <b>k</b>   Remove extradata from non-keyframes only.

           <b>keyframe</b>
               Remove extradata from keyframes only.

           <b>e,</b> <b>all</b>
               Remove extradata from all frames.

   <b>setts</b>
       Set PTS and DTS in packets.

       It accepts the following parameters:

       <b>ts</b>
       <b>pts</b>
       <b>dts</b> Set expressions for PTS, DTS or both.

       <b>duration</b>
           Set expression for duration.

       <b>time_base</b>
           Set output time base.

       The expressions are evaluated through the eval API and can contain the following constants:

       <b>N</b>   The count of the input packet. Starting from 0.

       <b>TS</b>  The demux timestamp in input in case of "ts" or "dts" option or presentation  timestamp  in  case  of
           "pts" option.

       <b>POS</b> The original position in the file of the packet, or undefined if undefined for the current packet

       <b>DTS</b> The demux timestamp in input.

       <b>PTS</b> The presentation timestamp in input.

       <b>DURATION</b>
           The duration in input.

       <b>STARTDTS</b>
           The DTS of the first packet.

       <b>STARTPTS</b>
           The PTS of the first packet.

       <b>PREV_INDTS</b>
           The previous input DTS.

       <b>PREV_INPTS</b>
           The previous input PTS.

       <b>PREV_INDURATION</b>
           The previous input duration.

       <b>PREV_OUTDTS</b>
           The previous output DTS.

       <b>PREV_OUTPTS</b>
           The previous output PTS.

       <b>PREV_OUTDURATION</b>
           The previous output duration.

       <b>NEXT_DTS</b>
           The next input DTS.

       <b>NEXT_PTS</b>
           The next input PTS.

       <b>NEXT_DURATION</b>
           The next input duration.

       <b>TB</b>  The timebase of stream packet belongs.

       <b>TB_OUT</b>
           The output timebase.

       <b>SR</b>  The sample rate of stream packet belongs.

       <b>NOPTS</b>
           The AV_NOPTS_VALUE constant.

       For example, to set PTS equal to DTS (not recommended if B-frames are involved):

               ffmpeg -i INPUT -c:a copy -bsf:a setts=pts=DTS out.mkv

   <b>showinfo</b>
       Log basic packet information. Mainly useful for testing, debugging, and development.

   <b>text2movsub</b>
       Convert text subtitles to MOV subtitles (as used by the "mov_text" codec) with metadata headers.

       See also the <b>mov2textsub</b> filter.

   <b>trace_headers</b>
       Log  trace  output containing all syntax elements in the coded stream headers (everything above the level
       of individual coded blocks).  This can be useful for debugging low-level stream issues.

       Supports AV1, H.264, H.265, (M)JPEG, MPEG-2 and VP9, but depending on the build only a  subset  of  these
       may be available.

   <b>truehd_core</b>
       Extract the core from a TrueHD stream, dropping ATMOS data.

   <b>vp9_metadata</b>
       Modify metadata embedded in a VP9 stream.

       <b>color_space</b>
           Set the color space value in the frame header.  Note that any frame set to RGB will be implicitly set
           to PC range and that RGB is incompatible with profiles 0 and 2.

           <b>unknown</b>
           <b>bt601</b>
           <b>bt709</b>
           <b>smpte170</b>
           <b>smpte240</b>
           <b>bt2020</b>
           <b>rgb</b>
       <b>color_range</b>
           Set  the  color range value in the frame header.  Note that any value imposed by the color space will
           take precedence over this value.

           <b>tv</b>
           <b>pc</b>

   <b>vp9_superframe</b>
       Merge VP9 invisible (alt-ref) frames back into VP9 superframes. This fixes merging of split/segmented VP9
       streams where the alt-ref frame was split from its visible counterpart.

   <b>vp9_superframe_split</b>
       Split VP9 superframes into single frames.

   <b>vp9_raw_reorder</b>
       Given a VP9 stream with correct timestamps but possibly out of order,  insert  additional  show-existing-
       frame packets to correct the ordering.

</pre><h4><b>FORMAT</b> <b>OPTIONS</b></h4><pre>
       The  libavformat  library  provides  some  generic global options, which can be set on all the muxers and
       demuxers. In addition each muxer or demuxer may support so-called private options, which are specific for
       that component.

       Options may be set by specifying -<u>option</u> <u>value</u> in the FFmpeg tools, or by setting the value explicitly in
       the "AVFormatContext" options or using the <u>libavutil/opt.h</u> API for programmatic use.

       The list of supported options follows:

       <b>avioflags</b> <u>flags</u> <b>(</b><u>input/output</u><b>)</b>
           Possible values:

           <b>direct</b>
               Reduce buffering.

       <b>probesize</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Set probing size in bytes, i.e. the size of the data to analyze to get stream information.  A  higher
           value  will  enable  detecting  more  information  in  case it is dispersed into the stream, but will
           increase latency. Must be an integer not lesser than 32. It is 5000000 by default.

       <b>max_probe_packets</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Set the maximum number of buffered packets when probing a codec.  Default is 2500 packets.

       <b>packetsize</b> <u>integer</u> <b>(</b><u>output</u><b>)</b>
           Set packet size.

       <b>fflags</b> <u>flags</u>
           Set format flags. Some are implemented for a limited number of formats.

           Possible values for input files:

           <b>discardcorrupt</b>
               Discard corrupted packets.

           <b>fastseek</b>
               Enable fast, but inaccurate seeks for some formats.

           <b>genpts</b>
               Generate missing PTS if DTS is present.

           <b>igndts</b>
               Ignore DTS if PTS is also set. In case the PTS is set, the DTS value is set  to  NOPTS.  This  is
               ignored when the "nofillin" flag is set.

           <b>ignidx</b>
               Ignore index.

           <b>nobuffer</b>
               Reduce the latency introduced by buffering during initial input streams analysis.

           <b>nofillin</b>
               Do not fill in missing values in packet fields that can be exactly calculated.

           <b>noparse</b>
               Disable AVParsers, this needs "+nofillin" too.

           <b>sortdts</b>
               Try to interleave output packets by DTS. At present, available only for AVIs with an index.

           Possible values for output files:

           <b>autobsf</b>
               Automatically apply bitstream filters as required by the output format. Enabled by default.

           <b>bitexact</b>
               Only  write  platform-,  build-  and  time-independent  data.   This  ensures  that file and data
               checksums are reproducible and match  between  platforms.  Its  primary  use  is  for  regression
               testing.

           <b>flush_packets</b>
               Write out packets immediately.

           <b>shortest</b>
               Stop muxing at the end of the shortest stream.  It may be needed to increase max_interleave_delta
               to avoid flushing the longer streams before EOF.

       <b>seek2any</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Allow seeking to non-keyframes on demuxer level when supported if set to 1.  Default is 0.

       <b>analyzeduration</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Specify  how  many microseconds are analyzed to probe the input. A higher value will enable detecting
           more accurate information, but will increase latency. It  defaults  to  5,000,000  microseconds  =  5
           seconds.

       <b>cryptokey</b> <u>hexadecimal</u> <u>string</u> <b>(</b><u>input</u><b>)</b>
           Set decryption key.

       <b>indexmem</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Set max memory used for timestamp index (per stream).

       <b>rtbufsize</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Set max memory used for buffering real-time frames.

       <b>fdebug</b> <u>flags</u> <b>(</b><u>input/output</u><b>)</b>
           Print specific debug info.

           Possible values:

           <b>ts</b>
       <b>max_delay</b> <u>integer</u> <b>(</b><u>input/output</u><b>)</b>
           Set maximum muxing or demuxing delay in microseconds.

       <b>fpsprobesize</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Set number of frames used to probe fps.

       <b>audio_preload</b> <u>integer</u> <b>(</b><u>output</u><b>)</b>
           Set microseconds by which audio packets should be interleaved earlier.

       <b>chunk_duration</b> <u>integer</u> <b>(</b><u>output</u><b>)</b>
           Set microseconds for each chunk.

       <b>chunk_size</b> <u>integer</u> <b>(</b><u>output</u><b>)</b>
           Set size in bytes for each chunk.

       <b>err_detect,</b> <b>f_err_detect</b> <u>flags</u> <b>(</b><u>input</u><b>)</b>
           Set error detection flags. "f_err_detect" is deprecated and should be used only via the <b>ffmpeg</b> tool.

           Possible values:

           <b>crccheck</b>
               Verify embedded CRCs.

           <b>bitstream</b>
               Detect bitstream specification deviations.

           <b>buffer</b>
               Detect improper bitstream length.

           <b>explode</b>
               Abort decoding on minor error detection.

           <b>careful</b>
               Consider things that violate the spec and have not been seen in the wild as errors.

           <b>compliant</b>
               Consider all spec non compliancies as errors.

           <b>aggressive</b>
               Consider things that a sane encoder should not do as an error.

       <b>max_interleave_delta</b> <u>integer</u> <b>(</b><u>output</u><b>)</b>
           Set  maximum  buffering  duration  for  interleaving.  The duration is expressed in microseconds, and
           defaults to 10000000 (10 seconds).

           To ensure all the streams are interleaved correctly, libavformat will wait until it has at least  one
           packet  for each stream before actually writing any packets to the output file. When some streams are
           "sparse" (i.e. there are large gaps  between  successive  packets),  this  can  result  in  excessive
           buffering.

           This  field  specifies the maximum difference between the timestamps of the first and the last packet
           in the muxing queue, above which libavformat will output a packet regardless of whether it has queued
           a packet for all the streams.

           If set to 0, libavformat will continue buffering packets until it  has  a  packet  for  each  stream,
           regardless of the maximum timestamp difference between the buffered packets.

       <b>use_wallclock_as_timestamps</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Use wallclock as timestamps if set to 1. Default is 0.

       <b>avoid_negative_ts</b> <u>integer</u> <b>(</b><u>output</u><b>)</b>
           Possible values:

           <b>make_non_negative</b>
               Shift  timestamps  to  make them non-negative.  Also note that this affects only leading negative
               timestamps, and not non-monotonic negative timestamps.

           <b>make_zero</b>
               Shift timestamps so that the first timestamp is 0.

           <b>auto</b> <b>(default)</b>
               Enables shifting when required by the target format.

           <b>disabled</b>
               Disables shifting of timestamp.

           When shifting is enabled, all output timestamps are shifted by the same  amount.  Audio,  video,  and
           subtitles desynching and relative timestamp differences are preserved compared to how they would have
           been without shifting.

       <b>skip_initial_bytes</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Set number of bytes to skip before reading header and frames if set to 1.  Default is 0.

       <b>correct_ts_overflow</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Correct single timestamp overflows if set to 1. Default is 1.

       <b>flush_packets</b> <u>integer</u> <b>(</b><u>output</u><b>)</b>
           Flush  the  underlying  I/O  stream  after  each  packet.  Default is -1 (auto), which means that the
           underlying protocol will decide, 1 enables it, and has the effect of reducing the latency, 0 disables
           it and may increase IO throughput in some cases.

       <b>output_ts_offset</b> <u>offset</u> <b>(</b><u>output</u><b>)</b>
           Set the output time offset.

           <u>offset</u> must be a time duration specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b>  <b>in</b>  <b>the</b>  <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>.

           The offset is added by the muxer to the output timestamps.

           Specifying  a  positive  offset means that the corresponding streams are delayed bt the time duration
           specified in <u>offset</u>. Default value is 0 (meaning that no offset is applied).

       <b>format_whitelist</b> <u>list</u> <b>(</b><u>input</u><b>)</b>
           "," separated list of allowed demuxers. By default all are allowed.

       <b>dump_separator</b> <u>string</u> <b>(</b><u>input</u><b>)</b>
           Separator used to separate the fields printed on the command line about the Stream  parameters.   For
           example, to separate the fields with newlines and indentation:

                   ffprobe -dump_separator "
                                             "  -i <a href="file:~/videos/matrixbench_mpeg2.mpg">~/videos/matrixbench_mpeg2.mpg</a>

       <b>max_streams</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Specifies the maximum number of streams. This can be used to reject files that would require too many
           resources due to a large number of streams.

       <b>skip_estimate_duration_from_pts</b> <u>bool</u> <b>(</b><u>input</u><b>)</b>
           Skip  estimation  of  input duration if it requires an additional probing for PTS at end of file.  At
           present, applicable for MPEG-PS and MPEG-TS.

       <b>duration_probesize</b> <u>integer</u> <b>(</b><u>input</u><b>)</b>
           Set probing size, in bytes, for input duration estimation when it  actually  requires  an  additional
           probing for PTS at end of file (at present: MPEG-PS and MPEG-TS).  It is aimed at users interested in
           better  durations  probing  for  itself, or indirectly because using the concat demuxer, for example.
           The typical use case is an MPEG-TS CBR with a high bitrate, high video buffering and ending  cleaning
           with  similar  PTS  for  video and audio: in such a scenario, the large physical gap between the last
           video packet and the last audio packet makes it necessary to read many bytes  in  order  to  get  the
           video stream duration.  Another use case is where the default probing behaviour only reaches a single
           video  frame  which is not the last one of the stream due to frame reordering, so the duration is not
           accurate.  Setting this option has a performance impact even for small files because the probing size
           is fixed.  Default behaviour is a general purpose trade-off, largely adaptive, but the  probing  size
           will not be extended to get streams durations at all costs.  Must be an integer not lesser than 1, or
           0 for default behaviour.

       <b>strict,</b> <b>f_strict</b> <u>integer</u> <b>(</b><u>input/output</u><b>)</b>
           Specify  how  strictly  to follow the standards. "f_strict" is deprecated and should be used only via
           the <b>ffmpeg</b> tool.

           Possible values:

           <b>very</b>
               strictly conform to an older more strict version of the spec or reference software

           <b>strict</b>
               strictly conform to all the things in the spec no matter what consequences

           <b>normal</b>
           <b>unofficial</b>
               allow unofficial extensions

           <b>experimental</b>
               allow non standardized experimental things, experimental (unfinished/work  in  progress/not  well
               tested)  decoders and encoders.  Note: experimental decoders can pose a security risk, do not use
               this for decoding untrusted input.

   <b>Format</b> <b>stream</b> <b>specifiers</b>
       Format stream specifiers allow selection of one or more streams that match specific properties.

       The exact semantics of stream specifiers is defined  by  the  avformat_match_stream_specifier()  function
       declared  in  the  <u>libavformat/avformat.h</u>  header  and documented in the <b>Stream</b> <b>specifiers</b> <b>section</b> <b>in</b> <b>the</b>
       <b><a href="../man1/ffmpeg.1.html">ffmpeg</a>(1)</b> <b>manual</b>.

</pre><h4><b>DEMUXERS</b></h4><pre>
       Demuxers are configured elements in FFmpeg that can read the multimedia streams from a particular type of
       file.

       When you configure your FFmpeg build, all the supported demuxers are enabled by default. You can list all
       available ones using the configure option "--list-demuxers".

       You can disable all the demuxers using the configure option "--disable-demuxers", and selectively  enable
       a   single   demuxer   with  the  option  "--enable-demuxer=<u>DEMUXER</u>",  or  disable  it  with  the  option
       "--disable-demuxer=<u>DEMUXER</u>".

       The option "-demuxers" of the ff* tools will display the list of enabled demuxers. Use "-formats" to view
       a combined list of enabled demuxers and muxers.

       The description of some of the currently available demuxers follows.

   <b>aa</b>
       Audible Format 2, 3, and 4 demuxer.

       This demuxer is used to demux Audible Format 2, 3, and 4 (.aa) files.

   <b>aac</b>
       Raw Audio Data Transport Stream AAC demuxer.

       This demuxer is used to demux an ADTS input containing a single AAC stream alongwith any ID3v1/2  or  APE
       tags in it.

   <b>apng</b>
       Animated Portable Network Graphics demuxer.

       This  demuxer is used to demux APNG files.  All headers, but the PNG signature, up to (but not including)
       the first fcTL chunk are transmitted as extradata.  Frames are then split as being all the chunks between
       two fcTL ones, or between the last fcTL and IEND chunks.

       <b>-ignore_loop</b> <u>bool</u>
           Ignore the loop variable in the file if set. Default is enabled.

       <b>-max_fps</b> <u>int</u>
           Maximum framerate in frames per second. Default of 0 imposes no limit.

       <b>-default_fps</b> <u>int</u>
           Default framerate in frames per second when none is specified in the  file  (0  meaning  as  fast  as
           possible). Default is 15.

   <b>asf</b>
       Advanced Systems Format demuxer.

       This demuxer is used to demux ASF files and MMS network streams.

       <b>-no_resync_search</b> <u>bool</u>
           Do not try to resynchronize by looking for a certain optional start code.

   <b>concat</b>
       Virtual concatenation script demuxer.

       This  demuxer  reads a list of files and other directives from a text file and demuxes them one after the
       other, as if all their packets had been muxed together.

       The timestamps in the files are adjusted so that the first file starts at 0 and  each  next  file  starts
       where  the  previous one finishes. Note that it is done globally and may cause gaps if all streams do not
       have exactly the same length.

       All files must have the same streams (same codecs, same time base, etc.).

       The duration of each file is used to adjust the timestamps of the next file: if the duration is incorrect
       (because it was computed using the bit-rate or because the file is truncated, for example), it can  cause
       artifacts. The "duration" directive can be used to override the duration stored in each file.

       <u>Syntax</u>

       The  script  is  a text file in extended-ASCII, with one directive per line.  Empty lines, leading spaces
       and lines starting with '#' are ignored. The following directive is recognized:

       <b>"file</b> <b>path"</b>
           Path to a file to read; special characters and spaces  must  be  escaped  with  backslash  or  single
           quotes.

           All subsequent file-related directives apply to that file.

       <b>"ffconcat</b> <b>version</b> <b>1.0"</b>
           Identify the script type and version.

           To make FFmpeg recognize the format automatically, this directive must appear exactly as is (no extra
           space or byte-order-mark) on the very first line of the script.

       <b>"duration</b> <b>dur"</b>
           Duration of the file. This information can be specified from the file; specifying it here may be more
           efficient or help if the information from the file is not available or accurate.

           If the duration is set for all files, then it is possible to seek in the whole concatenated video.

       <b>"inpoint</b> <b>timestamp"</b>
           In  point of the file. When the demuxer opens the file it instantly seeks to the specified timestamp.
           Seeking is done so that all streams can be presented successfully at In point.

           This directive works best with intra frame codecs, because for non-intra frame ones you will  usually
           get  extra packets before the actual In point and the decoded content will most likely contain frames
           before In point too.

           For each file, packets before the file In point will have timestamps less than the  calculated  start
           timestamp  of  the  file  (negative in case of the first file), and the duration of the files (if not
           specified by the "duration" directive) will be reduced based on their specified In point.

           Because of potential packets before the specified In point, packet timestamps may overlap between two
           concatenated files.

       <b>"outpoint</b> <b>timestamp"</b>
           Out point of the file. When the demuxer reaches the  specified  decoding  timestamp  in  any  of  the
           streams,  it  handles  it  as  an  end  of file condition and skips the current and all the remaining
           packets from all streams.

           Out point is exclusive, which means that  the  demuxer  will  not  output  packets  with  a  decoding
           timestamp greater or equal to Out point.

           This  directive  works  best  with  intra  frame  codecs  and  formats  where all streams are tightly
           interleaved. For non-intra frame codecs you will usually get  additional  packets  with  presentation
           timestamp  after  Out  point  therefore the decoded content will most likely contain frames after Out
           point too. If your streams are not tightly interleaved you may not  get  all  the  packets  from  all
           streams before Out point and you may only will be able to decode the earliest stream until Out point.

           The  duration  of  the  files (if not specified by the "duration" directive) will be reduced based on
           their specified Out point.

       <b>"file_packet_metadata</b> <b>key=value"</b>
           Metadata of the packets of the file. The specified metadata will be set for each file packet. You can
           specify this  directive  multiple  times  to  add  multiple  metadata  entries.   This  directive  is
           deprecated, use "file_packet_meta" instead.

       <b>"file_packet_meta</b> <b>key</b> <b>value"</b>
           Metadata of the packets of the file. The specified metadata will be set for each file packet. You can
           specify this directive multiple times to add multiple metadata entries.

       <b>"option</b> <b>key</b> <b>value"</b>
           Option to access, open and probe the file.  Can be present multiple times.

       <b>"stream"</b>
           Introduce  a  stream in the virtual file.  All subsequent stream-related directives apply to the last
           introduced stream.  Some streams properties must be set in order to allow  identifying  the  matching
           streams  in  the  subfiles.  If no streams are defined in the script, the streams from the first file
           are copied.

       <b>"exact_stream_id</b> <b>id"</b>
           Set the id of the stream.  If this directive is given, the string with the corresponding  id  in  the
           subfiles  will  be  used.   This is especially useful for MPEG-PS (VOB) files, where the order of the
           streams is not reliable.

       <b>"stream_meta</b> <b>key</b> <b>value"</b>
           Metadata for the stream.  Can be present multiple times.

       <b>"stream_codec</b> <b>value"</b>
           Codec for the stream.

       <b>"stream_extradata</b> <b>hex_string"</b>
           Extradata for the string, encoded in hexadecimal.

       <b>"chapter</b> <b>id</b> <b>start</b> <b>end"</b>
           Add a chapter. <u>id</u> is an unique identifier, possibly small and consecutive.

       <u>Options</u>

       This demuxer accepts the following option:

       <b>safe</b>
           If set to 1, reject unsafe file paths and directives.  A file path is considered safe if it does  not
           contain  a protocol specification and is relative and all components only contain characters from the
           portable character set (letters, digits, period, underscore and hyphen) and have  no  period  at  the
           beginning of a component.

           If set to 0, any file name is accepted.

           The default is 1.

       <b>auto_convert</b>
           If  set  to  1, try to perform automatic conversions on packet data to make the streams concatenable.
           The default is 1.

           Currently, the only conversion is adding the h264_mp4toannexb bitstream filter to  H.264  streams  in
           MP4 format. This is necessary in particular if there are resolution changes.

       <b>segment_time_metadata</b>
           If set to 1, every packet will contain the <u>lavf.concat.start_time</u> and the <u>lavf.concat.duration</u> packet
           metadata  values  which  are  the  start_time and the duration of the respective file segments in the
           concatenated output expressed in microseconds. The duration metadata is only set if it is known based
           on the concat file.  The default is 0.

       <u>Examples</u>

       •   Use absolute filenames and include some comments:

                   # my first filename
                   file /mnt/share/file-1.wav
                   # my second filename including whitespace
                   file '/mnt/share/file 2.wav'
                   # my third filename including whitespace plus single quote
                   file '/mnt/share/file 3'\''.wav'

       •   Allow for input format auto-probing, use safe filenames and set the duration of the first file:

                   ffconcat version 1.0

                   file file-1.wav
                   duration 20.0

                   file subdir/file-2.wav

   <b>dash</b>
       Dynamic Adaptive Streaming over HTTP demuxer.

       This demuxer presents all AVStreams found in the manifest.  By setting the discard flags on AVStreams the
       caller can decide which streams to actually receive.   Each  stream  mirrors  the  "id"  and  "bandwidth"
       properties from the "&lt;Representation&gt;" as metadata keys named "id" and "variant_bitrate" respectively.

       <u>Options</u>

       This demuxer accepts the following option:

       <b>cenc_decryption_key</b>
           16-byte  key,  in  hex,  to  decrypt  files  encrypted using ISO Common Encryption (CENC/AES-128 CTR;
           ISO/IEC 23001-7).

   <b>dvdvideo</b>
       DVD-Video demuxer, powered by libdvdnav and libdvdread.

       Can directly ingest DVD titles, specifically sequential PGCs, into a conversion  pipeline.  Menu  assets,
       such as background video or audio, can also be demuxed given the menu's coordinates (at best effort).

       Block  devices  (DVD  drives),  ISO  files,  and  directory  structures  are accepted.  Activate with "-f
       dvdvideo" in front of one of these inputs.

       This demuxer does NOT have decryption code of any kind. You are on your own working with encrypted  DVDs,
       and should not expect support on the matter.

       Underlying  playback  is handled by libdvdnav, and structure parsing by libdvdread.  FFmpeg must be built
       with  GPL  library  support  available  as  well  as  the  configure  switches  "--enable-libdvdnav"  and
       "--enable-libdvdread".

       You will need to provide either the desired "title number" or exact PGC/PG coordinates.  Many open-source
       DVD  players and tools can aid in providing this information.  If not specified, the demuxer will default
       to title 1 which works for many discs.  However, due to the flexibility of the format, it is  recommended
       to check manually.  There are many discs that are authored strangely or with invalid headers.

       If  the  input  is  a  real  DVD drive, please note that there are some drives which may silently fail on
       reading bad sectors from the disc, returning random bits instead which is effectively corrupt data.  This
       is especially prominent on aging or rotting discs.  A second pass and integrity checks would be needed to
       detect the corruption.  This is not an FFmpeg issue.

       <u>Background</u>

       DVD-Video  is  not  a  directly accessible, linear container format in the traditional sense. Instead, it
       allows for complex and programmatic playback of carefully  muxed  MPEG-PS  streams  that  are  stored  in
       headerless  VOB  files.   To  the  end-user,  these  streams are known simply as "titles", but the actual
       logical playback sequence is defined by one or more "PGCs", or Program Group Chains,  within  the  title.
       The  PGC  is  in turn comprised of multiple "PGs", or Programs", which are the actual video segments (and
       for a typical video feature, sequentially ordered). The PGC  structure,  along  with  stream  layout  and
       metadata,  are  stored in IFO files that need to be parsed. PGCs can be thought of as playlists in easier
       terms.

       An actual DVD player relies on user GUI interaction via menus and an internal VM to drive  the  direction
       of  demuxing. Generally, the user would either navigate (via menus) or automatically be redirected to the
       PGC of their choice. During this process and the subsequent playback, the DVD player's internal  VM  also
       maintains  a  state and executes instructions that can create jumps to different sectors during playback.
       This is why libdvdnav is involved, as a linear read of the MPEG-PS blobs on the disc (VOBs) is not enough
       to produce the right sequence in many cases.

       There are many other DVD structures (a long subject) that will not be discussed here.   NAV  packets,  in
       particular,  are handled by this demuxer to build accurate timing but not emitted as a stream. For a good
       high-level                        understanding,                        refer                         to:
       &lt;<b>https://code.videolan.org/videolan/libdvdnav/-/blob/master/doc/dvd_structures</b>&gt;

       <u>Options</u>

       This demuxer accepts the following options:

       <b>title</b> <u>int</u>
           The  title  number to play. Must be set if <b>pgc</b> and <b>pg</b> are not set.  Not applicable to menus.  Default
           is 0 (auto), which currently only selects the first available title (title 1) and notifies  the  user
           about the implications.

       <b>chapter_start</b> <u>int</u>
           The chapter, or PTT (part-of-title), number to start at. Not applicable to menus.  Default is 1.

       <b>chapter_end</b> <u>int</u>
           The  chapter, or PTT (part-of-title), number to end at. Not applicable to menus.  Default is 0, which
           is a special value to signal end at the last possible chapter.

       <b>angle</b> <u>int</u>
           The video angle number, referring to what is essentially an additional video stream that is  composed
           from alternate frames interleaved in the VOBs.  Not applicable to menus.  Default is 1.

       <b>region</b> <u>int</u>
           The  region  code  to  use  for playback. Some discs may use this to default playback at a particular
           angle in different regions. This option will not affect the region code of a real DVD drive, if  used
           as an input. Not applicable to menus.  Default is 0, "world".

       <b>menu</b> <u>bool</u>
           Demux  menu  assets  instead  of navigating a title. Requires exact coordinates of the menu (<b>menu_lu</b>,
           <b>menu_vts</b>, <b>pgc</b>, <b>pg</b>).  Default is false.

       <b>menu_lu</b> <u>int</u>
           The menu language to demux. In DVD, menus are grouped by language.  Default is 1, the first  language
           unit.

       <b>menu_vts</b> <u>int</u>
           The VTS where the menu lives, or 0 if it is a VMG menu (root-level).  Default is 1, menu of the first
           VTS.

       <b>pgc</b> <u>int</u>
           The  entry  PGC  to  start  playback, in conjunction with <b>pg</b>.  Alternative to setting <b>title</b>.  Chapter
           markers are not supported  at  this  time.   Must  be  explicitly  set  for  menus.   Default  is  0,
           automatically resolve from value of <b>title</b>.

       <b>pg</b> <u>int</u>
           The  entry  PG  to  start  playback, in conjunction with <b>pgc</b>.  Alternative to setting <b>title</b>.  Chapter
           markers are not supported at this time.  Default is 1, the first PG of the PGC.

       <b>preindex</b> <u>bool</u>
           Enable this to have accurate chapter (PTT) markers and duration measurement, which  requires  a  slow
           second  pass read in order to index the chapter marker timestamps from NAV packets. This is non-ideal
           extra work for real optical drives.  It is recommended and faster to use this option with a backup of
           the DVD structure stored on a hard drive. Not compatible with <b>pgc</b> and <b>pg</b>.  Default is 0, false.

       <b>trim</b> <u>bool</u>
           Skip padding cells (i.e. cells shorter than 1 second) from the beginning.   There  exist  many  discs
           with  filler  segments  at  the beginning of the PGC, often with junk data intended for controlling a
           real DVD player's buffering speed and with no other material data value.  Not  applicable  to  menus.
           Default is 1, true.

       <u>Examples</u>

       •   Open title 3 from a given DVD structure:

                   ffmpeg -f dvdvideo -title 3 -i &lt;path to DVD&gt; ...

       •   Open chapters 3-6 from title 1 from a given DVD structure:

                   ffmpeg -f dvdvideo -chapter_start 3 -chapter_end 6 -title 1 -i &lt;path to DVD&gt; ...

       •   Open only chapter 5 from title 1 from a given DVD structure:

                   ffmpeg -f dvdvideo -chapter_start 5 -chapter_end 5 -title 1 -i &lt;path to DVD&gt; ...

       •   Demux menu with language 1 from VTS 1, PGC 1, starting at PG 1:

                   ffmpeg -f dvdvideo -menu 1 -menu_lu 1 -menu_vts 1 -pgc 1 -pg 1 -i &lt;path to DVD&gt; ...

   <b>ea</b>
       Electronic Arts Multimedia format demuxer.

       This format is used by various Electronic Arts games.

       <u>Options</u>

       <b>merge_alpha</b> <u>bool</u>
           Normally  the  VP6 alpha channel (if exists) is returned as a secondary video stream, by setting this
           option you can make the demuxer return a single video stream which  contains  the  alpha  channel  in
           addition to the ordinary video.

   <b>imf</b>
       Interoperable Master Format demuxer.

       This   demuxer  presents  audio  and  video  streams  found  in  an  IMF  Composition,  as  specified  in
       &lt;<b>https://doi.org/10.5594/SMPTE.ST2067-2.2020</b>&gt;.

               ffmpeg [-assetmaps &lt;path of ASSETMAP1&gt;,&lt;path of ASSETMAP2&gt;,...] -i &lt;path of CPL&gt; ...

       If "-assetmaps" is not specified, the demuxer looks for a file called <u>ASSETMAP.xml</u> in the same  directory
       as the CPL.

   <b>flv,</b> <b>live_flv,</b> <b>kux</b>
       Adobe Flash Video Format demuxer.

       This demuxer is used to demux FLV files and RTMP network streams. In case of live network streams, if you
       force  format, you may use live_flv option instead of flv to survive timestamp discontinuities.  KUX is a
       flv variant used on the Youku platform.

               ffmpeg -f flv -i myfile.flv ...
               ffmpeg -f live_flv -i rtmp://&lt;any.server&gt;/anything/key ....

       <b>-flv_metadata</b> <u>bool</u>
           Allocate the streams according to the onMetaData array content.

       <b>-flv_ignore_prevtag</b> <u>bool</u>
           Ignore the size of previous tag value.

       <b>-flv_full_metadata</b> <u>bool</u>
           Output all context of the onMetadata.

   <b>gif</b>
       Animated GIF demuxer.

       It accepts the following options:

       <b>min_delay</b>
           Set the minimum valid delay between frames in hundredths of seconds.  Range is  0  to  6000.  Default
           value is 2.

       <b>max_gif_delay</b>
           Set  the  maximum  valid  delay between frames in hundredth of seconds.  Range is 0 to 65535. Default
           value is 65535 (nearly eleven minutes), the maximum value allowed by the specification.

       <b>default_delay</b>
           Set the default delay between frames in hundredths of seconds.  Range is 0 to 6000. Default value  is
           10.

       <b>ignore_loop</b>
           GIF  files  can contain information to loop a certain number of times (or infinitely). If <b>ignore_loop</b>
           is set to 1, then the loop setting from the input will be ignored and looping will not occur. If  set
           to  0, then looping will occur and will cycle the number of times according to the GIF. Default value
           is 1.

       For example, with the overlay filter, place an infinitely looping GIF over another video:

               ffmpeg -i input.mp4 -ignore_loop 0 -i input.gif -filter_complex overlay=shortest=1 out.mkv

       Note that in the above example the shortest option for overlay filter is used to end the output video  at
       the  length  of the shortest input file, which in this case is <u>input.mp4</u> as the GIF in this example loops
       infinitely.

   <b>hls</b>
       HLS demuxer

       Apple HTTP Live Streaming demuxer.

       This demuxer presents all AVStreams from all variant streams.  The id field is set to the bitrate variant
       index number. By setting the discard flags on AVStreams (by pressing 'a' or 'v' in  ffplay),  the  caller
       can  decide  which variant streams to actually receive.  The total bitrate of the variant that the stream
       belongs to is available in a metadata key named "variant_bitrate".

       It accepts the following options:

       <b>live_start_index</b>
           segment index to start live streams at (negative values are from the end).

       <b>prefer_x_start</b>
           prefer to use #EXT-X-START if it's in playlist instead of live_start_index.

       <b>allowed_extensions</b>
           ',' separated list of file extensions that hls is allowed to access.

       <b>extension_picky</b>
           This blocks disallowed extensions from probing It  also  requires  all  available  segments  to  have
           matching  extensions  to the format except mpegts, which is always allowed.  It is recommended to set
           the whitelists correctly instead of depending on extensions Enabled by default.

       <b>max_reload</b>
           Maximum number of times a insufficient list is attempted to be reloaded.  Default value is 1000.

       <b>m3u8_hold_counters</b>
           The maximum number of times to load m3u8 when it refreshes without new segments.   Default  value  is
           1000.

       <b>http_persistent</b>
           Use persistent HTTP connections. Applicable only for HTTP streams.  Enabled by default.

       <b>http_multiple</b>
           Use  multiple  HTTP  connections  for  downloading  HTTP  segments.   Enabled by default for HTTP/1.1
           servers.

       <b>http_seekable</b>
           Use HTTP partial requests for downloading HTTP segments.  0 = disable, 1 = enable, -1 = auto, Default
           is auto.

       <b>seg_format_options</b>
           Set options for the demuxer of media segments using a list of key=value pairs separated by ":".

       <b>seg_max_retry</b>
           Maximum number of times to reload a segment on error, useful when segment skip on  network  error  is
           not desired.  Default value is 0.

   <b>image2</b>
       Image file demuxer.

       This  demuxer  reads  from  a  list of image files specified by a pattern.  The syntax and meaning of the
       pattern is specified by the option <u>pattern_type</u>.

       The pattern may contain a suffix which is used to  automatically  determine  the  format  of  the  images
       contained in the files.

       The  size,  the  pixel  format,  and  the  format of each image must be the same for all the files in the
       sequence.

       This demuxer accepts the following options:

       <b>framerate</b>
           Set the frame rate for the video stream. It defaults to 25.

       <b>loop</b>
           If set to 1, loop over the input. Default value is 0.

       <b>pattern_type</b>
           Select the pattern type used to interpret the provided filename.

           <u>pattern_type</u> accepts one of the following values.

           <b>none</b>
               Disable pattern matching, therefore the video will only contain the specified image.  You  should
               use  this  option  if you do not want to create sequences from multiple images and your filenames
               may contain special pattern characters.

           <b>sequence</b>
               Select a sequence pattern type, used to  specify  a  sequence  of  files  indexed  by  sequential
               numbers.

               A  sequence  pattern  may  contain the string "%d" or "%0<u>N</u>d", which specifies the position of the
               characters representing a sequential number in each filename matched by the pattern. If the  form
               "%d0<u>N</u>d"  is  used,  the  string representing the number in each filename is 0-padded and <u>N</u> is the
               total number of 0-padded digits representing  the  number.  The  literal  character  '%'  can  be
               specified in the pattern with the string "%%".

               If the sequence pattern contains "%d" or "%0<u>N</u>d", the first filename of the file list specified by
               the   pattern   must   contain   a   number   inclusively   contained  between  <u>start_number</u>  and
               <u>start_number</u>+<u>start_number_range</u>-1, and all the following numbers must be sequential.

               For example  the  pattern  "img-%03d.bmp"  will  match  a  sequence  of  filenames  of  the  form
               <u>img-001.bmp</u>,  <u>img-002.bmp</u>,  ...,  <u>img-010.bmp</u>,  etc.;  the  pattern "i%%m%%g-%d.jpg" will match a
               sequence of filenames of the form <u>i%m%g-1.jpg</u>, <u>i%m%g-2.jpg</u>, ..., <u>i%m%g-10.jpg</u>, etc.

               Note that the pattern must not necessarily contain "%d" or  "%0<u>N</u>d",  for  example  to  convert  a
               single image file <u>img.jpeg</u> you can employ the command:

                       ffmpeg -i img.jpeg img.png

           <b>glob</b>
               Select a glob wildcard pattern type.

               The  pattern  is  interpreted  like  a glob() pattern. This is only selectable if libavformat was
               compiled with globbing support.

           <b>glob_sequence</b> <u>(deprecated,</u> <u>will</u> <u>be</u> <u>removed)</u>
               Select a mixed glob wildcard/sequence pattern.

               If your version of libavformat was compiled with  globbing  support,  and  the  provided  pattern
               contains  at  least one glob meta character among "%*?[]{}" that is preceded by an unescaped "%",
               the pattern is interpreted like a glob() pattern, otherwise it is  interpreted  like  a  sequence
               pattern.

               All  glob  special  characters  "%*?[]{}"  must be prefixed with "%". To escape a literal "%" you
               shall use "%%".

               For example the pattern "foo-%*.jpeg" will  match  all  the  filenames  prefixed  by  "foo-"  and
               terminating  with  ".jpeg",  and  "foo-%?%?%?.jpeg"  will  match  all the filenames prefixed with
               "foo-", followed by a sequence of three characters, and terminating with ".jpeg".

               This pattern type is deprecated in favor of <u>glob</u> and <u>sequence</u>.

           Default value is <u>glob_sequence</u>.

       <b>pixel_format</b>
           Set the pixel format of the images to read. If not specified the pixel format  is  guessed  from  the
           first image file in the sequence.

       <b>start_number</b>
           Set  the  index of the file matched by the image file pattern to start to read from. Default value is
           0.

       <b>start_number_range</b>
           Set the index interval range to check when looking for the first image file in the sequence, starting
           from <u>start_number</u>. Default value is 5.

       <b>ts_from_file</b>
           If set to 1, will set frame timestamp to modification time of image file.  Note  that  monotonity  of
           timestamps  is  not provided: images go in the same order as without this option. Default value is 0.
           If set to 2, will set frame timestamp to the modification  time  of  the  image  file  in  nanosecond
           precision.

       <b>video_size</b>
           Set  the  video size of the images to read. If not specified the video size is guessed from the first
           image file in the sequence.

       <b>export_path_metadata</b>
           If set to 1, will add two extra fields to the metadata found in input, making them also available for
           other filters (see <u>drawtext</u> filter for examples). Default value is 0. The extra fields are  described
           below:

           <b>lavf.image2dec.source_path</b>
               Corresponds to the full path to the input file being read.

           <b>lavf.image2dec.source_basename</b>
               Corresponds to the name of the file being read.

       <u>Examples</u>

       •   Use <b>ffmpeg</b> for creating a video from the images in the file sequence <u>img-001.jpeg</u>, <u>img-002.jpeg</u>, ...,
           assuming an input frame rate of 10 frames per second:

                   ffmpeg -framerate 10 -i 'img-%03d.jpeg' out.mkv

       •   As above, but start by reading from a file with index 100 in the sequence:

                   ffmpeg -framerate 10 -start_number 100 -i 'img-%03d.jpeg' out.mkv

       •   Read  images  matching  the  "*.png" glob pattern , that is all the files terminating with the ".png"
           suffix:

                   ffmpeg -framerate 10 -pattern_type glob -i "*.png" out.mkv

   <b>libgme</b>
       The Game Music Emu library is a collection of video game music file emulators.

       See &lt;<b>https://bitbucket.org/mpyne/game-music-emu/overview</b>&gt; for more information.

       It accepts the following options:

       <b>track_index</b>
           Set the index of which track to demux. The demuxer can only export one track.  Track indexes start at
           0. Default is to pick the first track. Number of tracks is exported as <u>tracks</u> metadata entry.

       <b>sample_rate</b>
           Set the sampling rate of the exported track. Range is 1000 to 999999. Default is 44100.

       <b>max_size</b> <u>(bytes)</u>
           The demuxer buffers the entire file into memory. Adjust this value to set the  maximum  buffer  size,
           which in turn, acts as a ceiling for the size of files that can be read.  Default is 50 MiB.

   <b>libmodplug</b>
       ModPlug based module demuxer

       See &lt;<b>https://github.com/Konstanty/libmodplug</b>&gt;

       It  will  export  one 2-channel 16-bit 44.1 kHz audio stream.  Optionally, a "pal8" 16-color video stream
       can be exported with or without printed metadata.

       It accepts the following options:

       <b>noise_reduction</b>
           Apply a simple low-pass filter. Can be 1 (on) or 0 (off). Default is 0.

       <b>reverb_depth</b>
           Set amount of reverb. Range 0-100. Default is 0.

       <b>reverb_delay</b>
           Set delay in ms, clamped to 40-250 ms. Default is 0.

       <b>bass_amount</b>
           Apply bass expansion a.k.a. XBass or megabass. Range is 0 (quiet) to 100 (loud). Default is 0.

       <b>bass_range</b>
           Set cutoff i.e. upper-bound for bass frequencies. Range is 10-100 Hz. Default is 0.

       <b>surround_depth</b>
           Apply a Dolby Pro-Logic surround effect. Range is 0 (quiet) to 100 (heavy). Default is 0.

       <b>surround_delay</b>
           Set surround delay in ms, clamped to 5-40 ms. Default is 0.

       <b>max_size</b>
           The demuxer buffers the entire file into memory. Adjust this value to set the  maximum  buffer  size,
           which  in  turn,  acts as a ceiling for the size of files that can be read. Range is 0 to 100 MiB.  0
           removes buffer size limit (not recommended). Default is 5 MiB.

       <b>video_stream_expr</b>
           String which is evaluated using the eval  API  to  assign  colors  to  the  generated  video  stream.
           Variables  which  can  be  used are "x", "y", "w", "h", "t", "speed", "tempo", "order", "pattern" and
           "row".

       <b>video_stream</b>
           Generate video stream. Can be 1 (on) or 0 (off). Default is 0.

       <b>video_stream_w</b>
           Set video frame width in 'chars' where one char indicates 8 pixels. Range is 20-512. Default is 30.

       <b>video_stream_h</b>
           Set video frame height in 'chars' where one char indicates 8 pixels. Range is 20-512. Default is 30.

       <b>video_stream_ptxt</b>
           Print metadata on video stream. Includes "speed", "tempo", "order", "pattern", "row" and  "ts"  (time
           in ms). Can be 1 (on) or 0 (off). Default is 1.

   <b>libopenmpt</b>
       libopenmpt based module demuxer

       See &lt;<b>https://lib.openmpt.org/libopenmpt/</b>&gt; for more information.

       Some files have multiple subsongs (tracks) this can be set with the <b>subsong</b> option.

       It accepts the following options:

       <b>subsong</b>
           Set  the  subsong  index.  This  can  be  either  'all', 'auto', or the index of the subsong. Subsong
           indexes start at 0. The default is 'auto'.

           The default value is to let libopenmpt choose.

       <b>layout</b>
           Set the channel layout. Valid values are 1, 2, and 4 channel layouts.  The default value is STEREO.

       <b>sample_rate</b>
           Set the sample rate for libopenmpt to output.  Range is from 1000 to INT_MAX. The  value  default  is
           48000.

   <b>mov/mp4/3gp</b>
       Demuxer  for  Quicktime File Format &amp; ISO/IEC Base Media File Format (ISO/IEC 14496-12 or MPEG-4 Part 12,
       ISO/IEC 15444-12 or JPEG 2000 Part 12).

       Registered extensions: mov, mp4, m4a, 3gp, 3g2, mj2, psp, m4b, ism, ismv, isma, f4v

       <u>Options</u>

       This demuxer accepts the following options:

       <b>enable_drefs</b>
           Enable loading of external tracks,  disabled  by  default.   Enabling  this  can  theoretically  leak
           information in some use cases.

       <b>use_absolute_path</b>
           Allows  loading  of  external  tracks via absolute paths, disabled by default.  Enabling this poses a
           security risk. It should only be enabled if the source is known to be non-malicious.

       <b>seek_streams_individually</b>
           When seeking, identify the closest point in each stream individually and demux packets in that stream
           from identified point. This can lead to a different sequence of packets compared to demuxing linearly
           from the beginning. Default is true.

       <b>ignore_editlist</b>
           Ignore any edit list atoms. The demuxer, by  default,  modifies  the  stream  index  to  reflect  the
           timeline described by the edit list. Default is false.

       <b>advanced_editlist</b>
           Modify the stream index to reflect the timeline described by the edit list. "ignore_editlist" must be
           set  to  false for this option to be effective.  If both "ignore_editlist" and this option are set to
           false, then only the start of the stream index is modified to reflect initial dwell time or  starting
           timestamp described by the edit list. Default is true.

       <b>ignore_chapters</b>
           Don't  parse chapters. This includes GoPro 'HiLight' tags/moments. Note that chapters are only parsed
           when input is seekable. Default is false.

       <b>use_mfra_for</b>
           For seekable fragmented input, set fragment's starting timestamp from media  fragment  random  access
           box, if present.

           Following options are available:

           <b>auto</b>
               Auto-detect whether to set mfra timestamps as PTS or DTS <u>(default)</u>

           <b>dts</b> Set mfra timestamps as DTS

           <b>pts</b> Set mfra timestamps as PTS

           <b>0</b>   Don't use mfra box to set timestamps

       <b>use_tfdt</b>
           For fragmented input, set fragment's starting timestamp to "baseMediaDecodeTime" from the "tfdt" box.
           Default  is  enabled,  which  will  prefer  to  use  the  "tfdt"  box  to set DTS. Disable to use the
           "earliest_presentation_time" from the "sidx" box.  In either case, the timestamp from the "mfra"  box
           will be used if it's available and "use_mfra_for" is set to pts or dts.

       <b>export_all</b>
           Export  unrecognized  boxes within the <u>udta</u> box as metadata entries. The first four characters of the
           box type are set as the key. Default is false.

       <b>export_xmp</b>
           Export entire contents of <u>XMP</u><b>_</b> box and <u>uuid</u> box as a string with key "xmp". Note that if "export_all"
           is set and this option isn't, the contents of <u>XMP</u><b>_</b> box  are  still  exported  but  with  key  "XMP_".
           Default is false.

       <b>activation_bytes</b>
           4-byte key required to decrypt Audible AAX and AAX+ files. See Audible AAX subsection below.

       <b>audible_fixed_key</b>
           Fixed key used for handling Audible AAX/AAX+ files. It has been pre-set so should not be necessary to
           specify.

       <b>decryption_key</b>
           16-byte  key,  in  hex,  to  decrypt  files  encrypted using ISO Common Encryption (CENC/AES-128 CTR;
           ISO/IEC 23001-7).

       <b>max_stts_delta</b>
           Very high sample deltas written in a trak's stts box may occasionally be intended  but  usually  they
           are  written  in  error  or  used to store a negative value for dts correction when treated as signed
           32-bit integers. This option lets the user set an upper limit, beyond which the delta is  clamped  to
           1. Values greater than the limit if negative when cast to int32 are used to adjust onward dts.

           Unit  is  the track time scale. Range is 0 to UINT_MAX. Default is "UINT_MAX - 48000*10" which allows
           up to a 10 second dts correction for 48 kHz audio  streams  while  accommodating  99.9%  of  "uint32"
           range.

       <b>interleaved_read</b>
           Interleave  packets from multiple tracks at demuxer level. For badly interleaved files, this prevents
           playback issues caused by large gaps between packets in different tracks,  as  MOV/MP4  do  not  have
           packet  placement  requirements.  However, this can cause excessive seeking on very badly interleaved
           files, due to seeking between tracks, so disabling it may prevent  I/O  issues,  at  the  expense  of
           playback.

       <u>Audible</u> <u>AAX</u>

       Audible  AAX  files  are encrypted M4B files, and they can be decrypted by specifying a 4 byte activation
       secret.

               ffmpeg -activation_bytes 1CEB00DA -i test.aax -vn -c:a copy output.mp4

   <b>mpegts</b>
       MPEG-2 transport stream demuxer.

       This demuxer accepts the following options:

       <b>resync_size</b>
           Set size limit for looking up a new synchronization. Default value is 65536.

       <b>skip_unknown_pmt</b>
           Skip PMTs for programs not defined in the PAT. Default value is 0.

       <b>fix_teletext_pts</b>
           Override teletext packet PTS and DTS values with the timestamps calculated from the PCR of the  first
           program  which  the  teletext  stream  is  part of and is not discarded. Default value is 1, set this
           option to 0 if you want your teletext packet PTS and DTS values untouched.

       <b>ts_packetsize</b>
           Output option carrying the raw packet size in bytes.  Show the detected raw packet  size,  cannot  be
           set by the user.

       <b>scan_all_pmts</b>
           Scan  and  combine  all  PMTs.  The  value  is an integer with value from -1 to 1 (-1 means automatic
           setting, 1 means enabled, 0 means disabled). Default value is -1.

       <b>merge_pmt_versions</b>
           Re-use existing streams when a PMT's version is updated and  elementary  streams  move  to  different
           PIDs. Default value is 0.

       <b>max_packet_size</b>
           Set  maximum  size,  in  bytes,  of packet emitted by the demuxer. Payloads above this size are split
           across multiple packets. Range is 1 to INT_MAX/2. Default is 204800 bytes.

   <b>mpjpeg</b>
       MJPEG encapsulated in multi-part MIME demuxer.

       This  demuxer  allows  reading  of  MJPEG,   where   each   frame   is   represented   as   a   part   of
       multipart/x-mixed-replace stream.

       <b>strict_mime_boundary</b>
           Default  implementation  applies a relaxed standard to multi-part MIME boundary detection, to prevent
           regression with numerous existing endpoints not generating a proper MIME MJPEG stream.  Turning  this
           option on by setting it to 1 will result in a stricter check of the boundary value.

   <b>rawvideo</b>
       Raw video demuxer.

       This  demuxer  allows  one  to read raw video data. Since there is no header specifying the assumed video
       parameters, the user must specify them in order to be able to decode the data correctly.

       This demuxer accepts the following options:

       <b>framerate</b>
           Set input video frame rate. Default value is 25.

       <b>pixel_format</b>
           Set the input video pixel format. Default value is "yuv420p".

       <b>video_size</b>
           Set the input video size. This value must be specified explicitly.

       For example to read a rawvideo file <u>input.raw</u> with <b>ffplay</b>, assuming a pixel format of  "rgb24",  a  video
       size of "320x240", and a frame rate of 10 images per second, use the command:

               ffplay -f rawvideo -pixel_format rgb24 -video_size 320x240 -framerate 10 input.raw

   <b>rcwt</b>
       RCWT  (Raw  Captions  With  Time) is a format native to ccextractor, a commonly used open source tool for
       processing 608/708 Closed Captions (CC) sources.  For more information on the format, see .

       This demuxer implements the specification as of March 2024, which has been  stable  and  unchanged  since
       April 2014.

       <u>Examples</u>

       •   Render CC to ASS using the built-in decoder:

                   ffmpeg -i CC.rcwt.bin CC.ass

           Note  that  if your output appears to be empty, you may have to manually set the decoder's <b>data_field</b>
           option to pick the desired CC substream.

       •   Convert an RCWT backup to Scenarist (SCC) format:

                   ffmpeg -i CC.rcwt.bin -c:s copy CC.scc

           Note that the SCC format does not support all of the possible CC extensions that  can  be  stored  in
           RCWT (such as EIA-708).

   <b>sbg</b>
       SBaGen script demuxer.

       This  demuxer  reads  the  script  language used by SBaGen &lt;<b><a href="http://uazu.net/sbagen/">http://uazu.net/sbagen/</a></b>&gt; to generate binaural
       beats sessions. A SBG script looks like that:

               -SE
               a: 300-2.5/3 440+4.5/0
               b: 300-2.5/0 440+4.5/3
               off: -
               NOW      == a
               +0:07:00 == b
               +0:14:00 == a
               +0:21:00 == b
               +0:30:00    off

       A SBG script can mix absolute and relative timestamps. If the script uses either only absolute timestamps
       (including the script start time) or only relative ones, then its layout is fixed, and the conversion  is
       straightforward.  On  the other hand, if the script mixes both kind of timestamps, then the <u>NOW</u> reference
       for relative timestamps will be taken from the current time of day at the time the script  is  read,  and
       the  script  layout will be frozen according to that reference. That means that if the script is directly
       played, the actual times will match the absolute timestamps up to the sound controller's clock  accuracy,
       but if the user somehow pauses the playback or seeks, all times will be shifted accordingly.

   <b>tedcaptions</b>
       JSON captions used for &lt;<b><a href="http://www.ted.com/">http://www.ted.com/</a></b>&gt;.

       TED  does  not  provide  links  to  the  captions,  but  they  can  be  guessed  from  the page. The file
       <u>tools/bookmarklets.html</u> from the FFmpeg source tree contains a bookmarklet to expose them.

       This demuxer accepts the following option:

       <b>start_time</b>
           Set the start time of the TED talk, in milliseconds. The default is 15000 (15s). It is used  to  sync
           the captions with the downloadable videos, because they include a 15s intro.

       Example: convert the captions to a format most players understand:

               ffmpeg -i <a href="http://www.ted.com/talks/subtitles/id/1/lang/en">http://www.ted.com/talks/subtitles/id/1/lang/en</a> talk1-en.srt

   <b>vapoursynth</b>
       Vapoursynth wrapper.

       Due  to  security  concerns,  Vapoursynth  scripts will not be autodetected so the input format has to be
       forced. For ff* CLI tools, add "-f vapoursynth" before the input "-i yourscript.vpy".

       This demuxer accepts the following option:

       <b>max_script_size</b>
           The demuxer buffers the entire script into memory. Adjust this value to set the maximum buffer  size,
           which in turn, acts as a ceiling for the size of scripts that can be read.  Default is 1 MiB.

   <b>w64</b>
       Sony Wave64 Audio demuxer.

       This demuxer accepts the following options:

       <b>max_size</b>
           See the same option for the <b>wav</b> demuxer.

   <b>wav</b>
       RIFF Wave Audio demuxer.

       This demuxer accepts the following options:

       <b>max_size</b>
           Specify  the maximum packet size in bytes for the demuxed packets. By default this is set to 0, which
           means that a sensible value is chosen based on the input format.

</pre><h4><b>MUXERS</b></h4><pre>
       Muxers are configured elements in FFmpeg which allow writing multimedia streams to a particular  type  of
       file.

       When  you  configure your FFmpeg build, all the supported muxers are enabled by default. You can list all
       available muxers using the configure option "--list-muxers".

       You can disable all the muxers with the configure option  "--disable-muxers"  and  selectively  enable  /
       disable single muxers with the options "--enable-muxer=<u>MUXER</u>" / "--disable-muxer=<u>MUXER</u>".

       The  option  "-muxers" of the ff* tools will display the list of enabled muxers. Use "-formats" to view a
       combined list of enabled demuxers and muxers.

       A description of some of the currently available muxers follows.

   <b>Raw</b> <b>muxers</b>
       This section covers raw muxers. They accept a single stream matching the designated codec.  They  do  not
       store  timestamps  or  metadata.  The recognized extension is the same as the muxer name unless indicated
       otherwise.

       It comprises the following muxers. The media type and  the  eventual  extensions  used  to  automatically
       selects the muxer from the output extensions are also shown.

       <b>ac3</b> <u>audio</u>
           Dolby Digital, also known as AC-3.

       <b>adx</b> <u>audio</u>
           CRI Middleware ADX audio.

           This  muxer  will write out the total sample count near the start of the first packet when the output
           is seekable and the count can be stored in 32 bits.

       <b>aptx</b> <u>audio</u>
           aptX (Audio Processing Technology for Bluetooth)

       <b>aptx_hd</b> <u>audio</u> <b>(aptxdh)</b>
           aptX HD (Audio Processing Technology for Bluetooth) audio

       <b>avs2</b> <u>video</u> <b>(avs,</b> <b>avs2)</b>
           AVS2-P2 (Audio Video Standard - Second generation - Part 2) / IEEE 1857.4 video

       <b>avs3</b> <u>video</u> <b>(avs3)</b>
           AVS3-P2 (Audio Video Standard - Third generation - Part 2) / IEEE 1857.10 video

       <b>cavsvideo</b> <u>video</u> <b>(cavs)</b>
           Chinese AVS (Audio Video Standard - First generation)

       <b>codec2raw</b> <u>audio</u>
           Codec 2 audio.

           No extension is registered so format name has to be supplied  e.g.  with  the  ffmpeg  CLI  tool  "-f
           codec2raw".

       <b>data</b> <u>any</u>
           Generic data muxer.

           This  muxer  accepts  a single stream with any codec of any type. The input stream has to be selected
           using the "-map" option with the <b>ffmpeg</b> CLI tool.

           No extension is registered so format name has to be supplied e.g. with the <b>ffmpeg</b> CLI tool "-f data".

       <b>dfpwm</b> <u>audio</u> <b>(dfpwm)</b>
           Raw DFPWM1a (Dynamic Filter Pulse With Modulation) audio muxer.

       <b>dirac</b> <u>video</u> <b>(drc,</b> <b>vc2)</b>
           BBC Dirac video.

           The Dirac Pro codec is a subset and is standardized as SMPTE VC-2.

       <b>dnxhd</b> <u>video</u> <b>(dnxhd,</b> <b>dnxhr)</b>
           Avid DNxHD video.

           It is standardized as SMPTE VC-3. Accepts DNxHR streams.

       <b>dts</b> <u>audio</u>
           DTS Coherent Acoustics (DCA) audio

       <b>eac3</b> <u>audio</u>
           Dolby Digital Plus, also known as Enhanced AC-3

       <b>evc</b> <u>video</u> <b>(evc)</b>
           MPEG-5 Essential Video Coding (EVC) / EVC / MPEG-5 Part 1 EVC video

       <b>g722</b> <u>audio</u>
           ITU-T G.722 audio

       <b>g723_1</b> <u>audio</u> <b>(tco,</b> <b>rco)</b>
           ITU-T G.723.1 audio

       <b>g726</b> <u>audio</u>
           ITU-T G.726 big-endian ("left-justified") audio.

           No extension is registered so format name has to be supplied e.g. with the <b>ffmpeg</b> CLI tool "-f g726".

       <b>g726le</b> <u>audio</u>
           ITU-T G.726 little-endian ("right-justified") audio.

           No extension is registered so format name has to be supplied  e.g.  with  the  <b>ffmpeg</b>  CLI  tool  "-f
           g726le".

       <b>gsm</b> <u>audio</u>
           Global System for Mobile Communications audio

       <b>h261</b> <u>video</u>
           ITU-T H.261 video

       <b>h263</b> <u>video</u>
           ITU-T H.263 / H.263-1996, H.263+ / H.263-1998 / H.263 version 2 video

       <b>h264</b> <u>video</u> <b>(h264,</b> <b>264)</b>
           ITU-T  H.264  /  MPEG-4  Part 10 AVC video. Bitstream shall be converted to Annex B syntax if it's in
           length-prefixed mode.

       <b>hevc</b> <u>video</u> <b>(hevc,</b> <b>h265,</b> <b>265)</b>
           ITU-T H.265 / MPEG-H Part 2 HEVC video. Bitstream shall be converted to Annex B  syntax  if  it's  in
           length-prefixed mode.

       <b>m4v</b> <u>video</u>
           MPEG-4 Part 2 video

       <b>mjpeg</b> <u>video</u> <b>(mjpg,</b> <b>mjpeg)</b>
           Motion JPEG video

       <b>mlp</b> <u>audio</u>
           Meridian Lossless Packing, also known as Packed PCM

       <b>mp2</b> <u>audio</u> <b>(mp2,</b> <b>m2a,</b> <b>mpa)</b>
           MPEG-1 Audio Layer II audio

       <b>mpeg1video</b> <u>video</u> <b>(mpg,</b> <b>mpeg,</b> <b>m1v)</b>
           MPEG-1 Part 2 video.

       <b>mpeg2video</b> <u>video</u> <b>(m2v)</b>
           ITU-T H.262 / MPEG-2 Part 2 video

       <b>obu</b> <u>video</u>
           AV1 low overhead Open Bitstream Units muxer.

           Temporal delimiter OBUs will be inserted in all temporal units of the stream.

       <b>rawvideo</b> <u>video</u> <b>(yuv,</b> <b>rgb)</b>
           Raw uncompressed video.

       <b>sbc</b> <u>audio</u> <b>(sbc,</b> <b>msbc)</b>
           Bluetooth SIG low-complexity subband codec audio

       <b>truehd</b> <u>audio</u> <b>(thd)</b>
           Dolby TrueHD audio

       <b>vc1</b> <u>video</u>
           SMPTE 421M / VC-1 video

       <u>Examples</u>

       •   Store raw video frames with the <b>rawvideo</b> muxer using <b>ffmpeg</b>:

                   ffmpeg -f lavfi -i testsrc -t 10 -s hd1080p testsrc.yuv

           Since  the  rawvideo  muxer do not store the information related to size and format, this information
           must be provided when demuxing the file:

                   ffplay -video_size 1920x1080 -pixel_format rgb24 -f rawvideo testsrc.rgb

   <b>Raw</b> <b>PCM</b> <b>muxers</b>
       This section covers raw PCM (Pulse-Code Modulation) audio muxers.

       They accept a single stream matching the designated codec. They do not store timestamps or metadata.  The
       recognized extension is the same as the muxer name.

       It  comprises  the  following  muxers. The optional additional extension used to automatically select the
       muxer from the output extension is also shown in parentheses.

       <b>alaw</b> <b>(al)</b>
           PCM A-law

       <b>f32be</b>
           PCM 32-bit floating-point big-endian

       <b>f32le</b>
           PCM 32-bit floating-point little-endian

       <b>f64be</b>
           PCM 64-bit floating-point big-endian

       <b>f64le</b>
           PCM 64-bit floating-point little-endian

       <b>mulaw</b> <b>(ul)</b>
           PCM mu-law

       <b>s16be</b>
           PCM signed 16-bit big-endian

       <b>s16le</b>
           PCM signed 16-bit little-endian

       <b>s24be</b>
           PCM signed 24-bit big-endian

       <b>s24le</b>
           PCM signed 24-bit little-endian

       <b>s32be</b>
           PCM signed 32-bit big-endian

       <b>s32le</b>
           PCM signed 32-bit little-endian

       <b>s8</b> <b>(sb)</b>
           PCM signed 8-bit

       <b>u16be</b>
           PCM unsigned 16-bit big-endian

       <b>u16le</b>
           PCM unsigned 16-bit little-endian

       <b>u24be</b>
           PCM unsigned 24-bit big-endian

       <b>u24le</b>
           PCM unsigned 24-bit little-endian

       <b>u32be</b>
           PCM unsigned 32-bit big-endian

       <b>u32le</b>
           PCM unsigned 32-bit little-endian

       <b>u8</b> <b>(ub)</b>
           PCM unsigned 8-bit

       <b>vidc</b>
           PCM Archimedes VIDC

   <b>MPEG-1/MPEG-2</b> <b>program</b> <b>stream</b> <b>muxers</b>
       This section covers formats belonging to the MPEG-1 and MPEG-2 Systems family.

       The MPEG-1 Systems format (also known as ISO/IEEC 11172-1 or MPEG-1 program stream) has been adopted  for
       the format of media track stored in VCD (Video Compact Disc).

       The  MPEG-2 Systems standard (also known as ISO/IEEC 13818-1) covers two containers formats, one known as
       transport stream and one known as program stream; only the latter is covered here.

       The MPEG-2 program stream format (also known as VOB due  to  the  corresponding  file  extension)  is  an
       extension  of  MPEG-1  program  stream:  in  addition to support different codecs for the audio and video
       streams, it also stores subtitles and navigation metadata.  MPEG-2 program stream has  been  adopted  for
       storing media streams in SVCD and DVD storage devices.

       This section comprises the following muxers.

       <b>mpeg</b> <b>(mpg,mpeg)</b>
           MPEG-1 Systems / MPEG-1 program stream muxer.

       <b>vcd</b> MPEG-1 Systems / MPEG-1 program stream (VCD) muxer.

           This  muxer  can  be  used  to generate tracks in the format accepted by the VCD (Video Compact Disc)
           storage devices.

           It is the same as the <b>mpeg</b> muxer with a few differences.

       <b>vob</b> MPEG-2 program stream (VOB) muxer.

       <b>dvd</b> MPEG-2 program stream (DVD VOB) muxer.

           This muxer can be used to generate tracks in the format accepted by the DVD (Digital Versatile  Disc)
           storage devices.

           This is the same as the <b>vob</b> muxer with a few differences.

       <b>svcd</b> <b>(vob)</b>
           MPEG-2 program stream (SVCD VOB) muxer.

           This  muxer  can  be  used to generate tracks in the format accepted by the SVCD (Super Video Compact
           Disc) storage devices.

           This is the same as the <b>vob</b> muxer with a few differences.

       <u>Options</u>

       <b>muxrate</b> <u>rate</u>
           Set user-defined mux rate expressed as a number of bits/s. If not specied the automatically  computed
           mux rate is employed. Default value is 0.

       <b>preload</b> <u>delay</u>
           Set initial demux-decode delay in microseconds. Default value is 500000.

   <b>MOV/MPEG-4/ISOMBFF</b> <b>muxers</b>
       This  section covers formats belonging to the QuickTime / MOV family, including the MPEG-4 Part 14 format
       and ISO base media file format (ISOBMFF). These formats share a common structure based on  the  ISO  base
       media file format (ISOBMFF).

       The MOV format was originally developed for use with Apple QuickTime.  It was later used as the basis for
       the MPEG-4 Part 1 (later Part 14) format, also known as ISO/IEC 14496-1. That format was then generalized
       into ISOBMFF, also named MPEG-4 Part 12 format, ISO/IEC 14496-12, or ISO/IEC 15444-12.

       It comprises the following muxers.

       <b>3gp</b> Third Generation Partnership Project (3GPP) format for 3G UMTS multimedia services

       <b>3g2</b> Third  Generation  Partnership  Project 2 (3GP2 or 3GPP2) format for 3G CDMA2000 multimedia services,
           similar to <b>3gp</b> with extensions and limitations

       <b>f4v</b> Adobe Flash Video format

       <b>ipod</b>
           MPEG-4 audio file format, as MOV/MP4 but limited to contain only audio streams, typically played with
           the Apple ipod device

       <b>ismv</b>
           Microsoft IIS (Internet Information Services) Smooth Streaming Audio/Video  (ISMV  or  ISMA)  format.
           This  is  based on MPEG-4 Part 14 format with a few incompatible variants, used to stream media files
           for the Microsoft IIS server.

       <b>mov</b> QuickTime player format identified by the ".mov" extension

       <b>mp4</b> MP4 or MPEG-4 Part 14 format

       <b>psp</b> PlayStation Portable MP4/MPEG-4 Part 14 format variant. This is based on MPEG-4 Part 14 format with a
           few incompatible variants, used to play files on PlayStation devices.

       <u>Fragmentation</u>

       The <b>mov</b>, <b>mp4</b>, and <b>ismv</b> muxers support fragmentation. Normally, a MOV/MP4 file has all the metadata  about
       all packets stored in one location.

       This data is usually written at the end of the file, but it can be moved to the start for better playback
       by adding "+faststart" to the "-movflags", or using the <b>qt-faststart</b> tool).

       A  fragmented  file consists of a number of fragments, where packets and metadata about these packets are
       stored together. Writing a fragmented file has the advantage that the  file  is  decodable  even  if  the
       writing  is  interrupted  (while  a normal MOV/MP4 is undecodable if it is not properly finished), and it
       requires less memory when writing very long files (since writing normal MOV/MP4 files stores  info  about
       every  single packet in memory until the file is closed). The downside is that it is less compatible with
       other applications.

       Fragmentation is enabled by setting one of the options that define how to cut the file into fragments:

       <b>frag_duration</b>
       <b>frag_size</b>
       <b>min_frag_duration</b>
       <b>movflags</b> <b>+frag_keyframe</b>
       <b>movflags</b> <b>+frag_custom</b>

       If more than one condition is specified, fragments are cut  when  one  of  the  specified  conditions  is
       fulfilled.  The  exception  to this is the option <b>min_frag_duration</b>, which has to be fulfilled for any of
       the other conditions to apply.

       <u>Options</u>

       <b>brand</b> <u>brand_string</u>
           Override major brand.

       <b>empty_hdlr_name</b> <u>bool</u>
           Enable to skip writing the name inside a "hdlr" box.  Default is "false".

       <b>encryption_key</b> <u>key</u>
           set the media encryption key in hexadecimal format

       <b>encryption_kid</b> <u>kid</u>
           set the media encryption key identifier in hexadecimal format

       <b>encryption_scheme</b> <u>scheme</u>
           configure the encryption scheme, allowed values are <b>none</b>, and <b>cenc-aes-ctr</b>

       <b>frag_duration</b> <u>duration</u>
           Create fragments that are <u>duration</u> microseconds long.

       <b>frag_interleave</b>  <u>number</u>
           Interleave  samples  within  fragments  (max  number  of  consecutive  samples,  lower   is   tighter
           interleaving, but with more overhead. It is set to 0 by default.

       <b>frag_size</b> <u>size</u>
           create fragments that contain up to <u>size</u> bytes of payload data

       <b>iods_audio_profile</b> <u>profile</u>
           specify iods number for the audio profile atom (from -1 to 255), default is -1

       <b>iods_video_profile</b> <u>profile</u>
           specify iods number for the video profile atom (from -1 to 255), default is -1

       <b>ism_lookahead</b> <u>num_entries</u>
           specify number of lookahead entries for ISM files (from 0 to 255), default is 0

       <b>min_frag_duration</b> <u>duration</u>
           do not create fragments that are shorter than <u>duration</u> microseconds long

       <b>moov_size</b> <u>bytes</u>
           Reserves space for the moov atom at the beginning of the file instead of placing the moov atom at the
           end. If the space reserved is insufficient, muxing will fail.

       <b>mov_gamma</b> <u>gamma</u>
           specify  gamma  value  for  gama atom (as a decimal number from 0 to 10), default is 0.0, must be set
           together with "+ movflags"

       <b>movflags</b> <u>flags</u>
           Set various muxing switches. The following flags can be used:

           <b>cmaf</b>
               write CMAF (Common Media Application Format) compatible fragmented MP4 output

           <b>dash</b>
               write DASH (Dynamic Adaptive Streaming over HTTP) compatible fragmented MP4 output

           <b>default_base_moof</b>
               Similarly to the <b>omit_tfhd_offset</b> flag, this flag avoids writing  the  absolute  base_data_offset
               field in tfhd atoms, but does so by using the new default-base-is-moof flag instead. This flag is
               new  from  14496-12:2012.  This  may  make the fragments easier to parse in certain circumstances
               (avoiding basing track fragment location calculations on the implicit end of the  previous  track
               fragment).

           <b>delay_moov</b>
               delay writing the initial moov until the first fragment is cut, or until the first fragment flush

           <b>disable_chpl</b>
               Disable  Nero  chapter  markers (chpl atom). Normally, both Nero chapters and a QuickTime chapter
               track are written to the file. With this option set, only the QuickTime  chapter  track  will  be
               written.  Nero  chapters  can  cause  failures  when the file is reprocessed with certain tagging
               programs, like mp3Tag 2.61a and iTunes 11.3, most likely other versions are affected as well.

           <b>faststart</b>
               Run a second pass moving the index (moov atom) to the beginning of the file. This  operation  can
               take  a  while, and will not work in various situations such as fragmented output, thus it is not
               enabled by default.

           <b>frag_custom</b>
               Allow the caller to manually choose when to cut fragments, by calling "av_write_frame(ctx, NULL)"
               to write a fragment with the packets written so far. (This is only useful with other applications
               integrating libavformat, not from <b>ffmpeg</b>.)

           <b>frag_discont</b>
               signal that the next fragment is discontinuous from earlier ones

           <b>frag_every_frame</b>
               fragment at every frame

           <b>frag_keyframe</b>
               start a new fragment at each video keyframe

           <b>global_sidx</b>
               write a global sidx index at the start of the file

           <b>isml</b>
               create a live smooth streaming feed (for pushing to a publishing point)

           <b>negative_cts_offsets</b>
               Enables utilization of version 1 of the CTTS box, in which the CTS offsets can be negative.  This
               enables  the initial sample to have DTS/CTS of zero, and reduces the need for edit lists for some
               cases such as video tracks with  B-frames.  Additionally,  eases  conformance  with  the  DASH-IF
               interoperability guidelines.

               This option is implicitly set when writing <b>ismv</b> (Smooth Streaming) files.

           <b>omit_tfhd_offset</b>
               Do not write any absolute base_data_offset in tfhd atoms. This avoids tying fragments to absolute
               byte positions in the file/streams.

           <b>prefer_icc</b>
               If writing colr atom prioritise usage of ICC profile if it exists in stream packet side data.

           <b>rtphint</b>
               add RTP hinting tracks to the output file

           <b>separate_moof</b>
               Write  a separate moof (movie fragment) atom for each track. Normally, packets for all tracks are
               written in a moof atom (which is slightly more efficient), but with this option  set,  the  muxer
               writes one moof/mdat pair for each track, making it easier to separate tracks.

           <b>skip_sidx</b>
               Skip  writing  of sidx atom. When bitrate overhead due to sidx atom is high, this option could be
               used for cases where sidx atom is not mandatory. When  the  <b>global_sidx</b>  flag  is  enabled,  this
               option is ignored.

           <b>skip_trailer</b>
               skip writing the mfra/tfra/mfro trailer for fragmented files

           <b>use_metadata_tags</b>
               use mdta atom for metadata

           <b>write_colr</b>
               write  colr atom even if the color info is unspecified. This flag is experimental, may be renamed
               or changed, do not use from scripts.

           <b>write_gama</b>
               write deprecated gama atom

           <b>hybrid_fragmented</b>
               For recoverability - write the output file as a fragmented file.  This  allows  the  intermediate
               file to be read while being written (in particular, if the writing process is aborted uncleanly).
               When  writing is finished, the file is converted to a regular, non-fragmented file, which is more
               compatible and allows easier and quicker seeking.

               If writing is aborted, the intermediate file can manually be  remuxed  to  get  a  regular,  non-
               fragmented file of what had been written into the unfinished file.

       <b>movie_timescale</b> <u>scale</u>
           Set the timescale written in the movie header box ("mvhd").  Range is 1 to INT_MAX. Default is 1000.

       <b>rtpflags</b> <u>flags</u>
           Add RTP hinting tracks to the output file.

           The following flags can be used:

           <b>h264_mode0</b>
               use mode 0 for H.264 in RTP

           <b>latm</b>
               use MP4A-LATM packetization instead of MPEG4-GENERIC for AAC

           <b>rfc2190</b>
               use RFC 2190 packetization instead of RFC 4629 for H.263

           <b>send_bye</b>
               send RTCP BYE packets when finishing

           <b>skip_rtcp</b>
               do not send RTCP sender reports

       <b>skip_iods</b> <u>bool</u>
           skip writing iods atom (default value is "true")

       <b>use_editlist</b> <u>bool</u>
           use edit list (default value is "auto")

       <b>use_stream_ids_as_track_ids</b> <u>bool</u>
           use stream ids as track ids (default value is "false")

       <b>video_track_timescale</b> <u>scale</u>
           Set  the  timescale  used  for  video  tracks.  Range  is 0 to INT_MAX. If set to 0, the timescale is
           automatically set based on the native stream time base. Default is 0.

       <b>write_btrt</b> <u>bool</u>
           Force or disable writing bitrate box inside stsd box of a track. The  box  contains  decoding  buffer
           size  (in  bytes), maximum bitrate and average bitrate for the track. The box will be skipped if none
           of these values can be computed.  Default is -1 or "auto", which will write the box only in MP4 mode.

       <b>write_prft</b> <u>option</u>
           Write producer time reference box (PRFT) with a specified time source for the NTP field in  the  PRFT
           box.  Set value as <b>wallclock</b> to specify timesource as wallclock time and <b>pts</b> to specify timesource as
           input packets' PTS values.

       <b>write_tmcd</b> <u>bool</u>
           Specify "on" to force writing a timecode track, "off" to disable it and "auto" to  write  a  timecode
           track only for mov and mp4 output (default).

           Setting  value to <b>pts</b> is applicable only for a live encoding use case, where PTS values are set as as
           wallclock time at the source. For example, an encoding use case with decklink  capture  source  where
           <b>video_pts</b> and <b>audio_pts</b> are set to <b>abs_wallclock</b>.

       <u>Examples</u>

       •   Push  Smooth  Streaming  content  in real time to a publishing point on IIS with the <b>ismv</b> muxer using
           <b>ffmpeg</b>:

                   ffmpeg -re &lt;&lt;normal input/transcoding options&gt;&gt; -movflags isml+frag_keyframe -f ismv <a href="http://server/publishingpoint.isml/Streams">http://server/publishingpoint.isml/Streams</a>(Encoder1)

   <b>a64</b>
       A64 Commodore 64 video muxer.

       This muxer accepts a single "a64_multi" or "a64_multi5" codec video stream.

   <b>ac4</b>
       Raw AC-4 audio muxer.

       This muxer accepts a single "ac4" audio stream.

       <u>Options</u>

       <b>write_crc</b> <u>bool</u>
           when enabled, write a CRC checksum for each packet to the output, default is "false"

   <b>adts</b>
       Audio Data Transport Stream muxer.

       It accepts a single AAC stream.

       <u>Options</u>

       <b>write_id3v2</b> <u>bool</u>
           Enable to write ID3v2.4 tags at the start of the stream. Default is disabled.

       <b>write_apetag</b> <u>bool</u>
           Enable to write APE tags at the end of the stream. Default is disabled.

       <b>write_mpeg2</b> <u>bool</u>
           Enable to set MPEG version bit in the ADTS frame header to 1 which indicates MPEG-2.  Default  is  0,
           which indicates MPEG-4.

   <b>aea</b>
       MD STUDIO audio muxer.

       This  muxer  accepts  a  single  ATRAC1 audio stream with either one or two channels and a sample rate of
       44100Hz.

       As AEA supports storing the track title, this muxer will also write the title from stream's  metadata  to
       the container.

   <b>aiff</b>
       Audio Interchange File Format muxer.

       <u>Options</u>

       <b>write_id3v2</b> <u>bool</u>
           Enable ID3v2 tags writing when set to 1. Default is 0 (disabled).

       <b>id3v2_version</b> <u>bool</u>
           Select  ID3v2  version  to  write.  Currently  only  version  3 and 4 (aka.  ID3v2.3 and ID3v2.4) are
           supported. The default is version 4.

   <b>alp</b>
       High Voltage Software's Lego Racers game audio muxer.

       It accepts a single ADPCM_IMA_ALP stream with no more than 2 channels and a sample rate not greater  than
       44100 Hz.

       Extensions: "tun", "pcm"

       <u>Options</u>

       <b>type</b> <u>type</u>
           Set file type.

           <u>type</u> accepts the following values:

           <b>tun</b> Set file type as music. Must have a sample rate of 22050 Hz.

           <b>pcm</b> Set file type as sfx.

           <b>auto</b>
               Set  file type as per output file extension. ".pcm" results in type "pcm" else type "tun" is set.
               <u>(default)</u>

   <b>amr</b>
       3GPP AMR (Adaptive Multi-Rate) audio muxer.

       It accepts a single audio stream containing an AMR NB stream.

   <b>amv</b>
       AMV (Actions Media Video) format muxer.

   <b>apm</b>
       Ubisoft Rayman 2 APM audio muxer.

       It accepts a single ADPCM IMA APM audio stream.

   <b>apng</b>
       Animated Portable Network Graphics muxer.

       It accepts a single APNG video stream.

       <u>Options</u>

       <b>final_delay</b> <u>delay</u>
           Force a delay expressed in seconds after the last frame of each repetition. Default value is 0.0.

       <b>plays</b> <u>repetitions</u>
           specify how many times to play the content, 0 causes an infinte loop, with 1 there is no loop

       <u>Examples</u>

       •   Use <b>ffmpeg</b> to generate an APNG output with 2 repetitions, and with a delay of half a second after the
           first repetition:

                   ffmpeg -i INPUT -final_delay 0.5 -plays 2 out.apng

   <b>argo_asf</b>
       Argonaut Games ASF audio muxer.

       It accepts a single ADPCM audio stream.

       <u>Options</u>

       <b>version_major</b> <u>version</u>
           override file major version, specified as an integer, default value is 2

       <b>version_minor</b> <u>version</u>
           override file minor version, specified as an integer, default value is 1

       <b>name</b> <u>name</u>
           Embed file name into file, if not specified use the output file name. The  name  is  truncated  to  8
           characters.

   <b>argo_cvg</b>
       Argonaut Games CVG audio muxer.

       It accepts a single one-channel ADPCM 22050Hz audio stream.

       The  <b>loop</b>  and  <b>reverb</b>  options set the corresponding flags in the header which can be later retrieved to
       process the audio stream accordingly.

       <u>Options</u>

       <b>skip_rate_check</b> <u>bool</u>
           skip sample rate check (default is "false")

       <b>loop</b> <u>bool</u>
           set loop flag (default is "false")

       <b>reverb</b> <u>boolean</u>
           set reverb flag (default is "true")

   <b>asf,</b> <b>asf_stream</b>
       Advanced / Active Systems (or Streaming) Format audio muxer.

       The <b>asf_stream</b> variant should be selected for streaming.

       Note that Windows Media Audio (wma) and Windows Media Video (wmv) use this muxer too.

       <u>Options</u>

       <b>packet_size</b> <u>size</u>
           Set the muxer packet size as a  number  of  bytes.  By  tuning  this  setting  you  may  reduce  data
           fragmentation  or  muxer  overhead  depending  on your source. Default value is 3200, minimum is 100,
           maximum is "64Ki".

   <b>ass</b>
       ASS/SSA (SubStation Alpha) subtitles muxer.

       It accepts a single ASS subtitles stream.

       <u>Options</u>

       <b>ignore_readorder</b> <u>bool</u>
           Write dialogue events immediately, even if they are out-of-order, default is "false", otherwise  they
           are cached until the expected time event is found.

   <b>ast</b>
       AST (Audio Stream) muxer.

       This format is used to play audio on some Nintendo Wii games.

       It accepts a single audio stream.

       The  <b>loopstart</b>  and  <b>loopend</b>  options  can  be  used  to define a section of the file to loop for players
       honoring such options.

       <u>Options</u>

       <b>loopstart</b> <u>start</u>
           Specify loop start position expressesd in milliseconds, from -1 to "INT_MAX", in case -1 is set  then
           no loop is specified (default -1) and the <b>loopend</b> value is ignored.

       <b>loopend</b> <u>end</u>
           Specify  loop end position expressed in milliseconds, from 0 to "INT_MAX", default is 0, in case 0 is
           set it assumes the total stream duration.

   <b>au</b>
       SUN AU audio muxer.

       It accepts a single audio stream.

   <b>avi</b>
       Audio Video Interleaved muxer.

       AVI is a proprietary format developed by Microsoft, and later formally specified  through  the  Open  DML
       specification.

       Because  of differences in players implementations, it might be required to set some options to make sure
       that the generated output can be correctly played by the target player.

       <u>Options</u>

       <b>flipped_raw_rgb</b> <u>bool</u>
           If set to "true", store positive height for raw RGB bitmaps, which indicates bitmap is stored bottom-
           up. Note that this option does not flip the bitmap which has to be done manually beforehand, e.g.  by
           using the <b>vflip</b> filter. Default is "false" and indicates bitmap is stored top down.

       <b>reserve_index_space</b> <u>size</u>
           Reserve  the  specified  amount  of bytes for the OpenDML master index of each stream within the file
           header. By default additional master indexes are embedded within the data  packets  if  there  is  no
           space  left  in  the  first  master  index  and are linked together as a chain of indexes. This index
           structure can cause problems for some use cases, e.g. third-party software strictly  relying  on  the
           OpenDML  index  specification  or when file seeking is slow. Reserving enough index space in the file
           header avoids these problems.

           The required index space depends on the output file size and should be about 16 bytes  per  gigabyte.
           When this option is omitted or set to zero the necessary index space is guessed.

           Default value is 0.

       <b>write_channel_mask</b> <u>bool</u>
           Write the channel layout mask into the audio stream header.

           This  option  is  enabled by default. Disabling the channel mask can be useful in specific scenarios,
           e.g. when merging multiple audio streams into one for compatibility with software that only  supports
           a single audio stream in AVI (see <b>the</b> <b>"amerge"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-filters</b> <b>manual</b>).

   <b>avif</b>
       AV1 (Alliance for Open Media Video codec 1) image format muxer.

       This muxers stores images encoded using the AV1 codec.

       It accepts one or two video streams. In case two video streams are provided, the second one shall contain
       a single plane storing the alpha mask.

       In  case  more  than  one  image is provided, the generated output is considered an animated AVIF and the
       number of loops can be specified with the <b>loop</b> option.

       This    is    based    on    the    specification    by    Alliance    for    Open    Media    at     url
       &lt;<b>https://aomediacodec.github.io/av1-avif</b>&gt;.

       <u>Options</u>

       <b>loop</b> <u>count</u>
           number of times to loop an animated AVIF, 0 specify an infinite loop, default is 0

       <b>movie_timescale</b> <u>timescale</u>
           Set the timescale written in the movie header box ("mvhd").  Range is 1 to INT_MAX. Default is 1000.

   <b>avm2</b>
       ShockWave Flash (SWF) / ActionScript Virtual Machine 2 (AVM2) format muxer.

       It accepts one audio stream, one video stream, or both.

   <b>bit</b>
       G.729 (.bit) file format muxer.

       It accepts a single G.729 audio stream.

   <b>caf</b>
       Apple CAF (Core Audio Format) muxer.

       It accepts a single audio stream.

   <b>codec2</b>
       Codec2 audio audio muxer.

       It accepts a single codec2 audio stream.

   <b>chromaprint</b>
       Chromaprint fingerprinter muxers.

       To enable compilation of this filter you need to configure FFmpeg with "--enable-chromaprint".

       This  muxer  feeds  audio data to the Chromaprint library, which generates a fingerprint for the provided
       audio data. See: &lt;<b>https://acoustid.org/chromaprint</b>&gt;

       It takes a single signed native-endian 16-bit raw audio stream of at most 2 channels.

       <u>Options</u>

       <b>algorithm</b> <u>version</u>
           Select version of algorithm to fingerprint  with.  Range  is  0  to  4.  Version  3  enables  silence
           detection. Default is 1.

       <b>fp_format</b> <u>format</u>
           Format to output the fingerprint as. Accepts the following options:

           <b>base64</b>
               Base64 compressed fingerprint <u>(default)</u>

           <b>compressed</b>
               Binary compressed fingerprint

           <b>raw</b> Binary raw fingerprint

       <b>silence_threshold</b> <u>threshold</u>
           Threshold  for  detecting  silence.  Range  is from -1 to 32767, where -1 disables silence detection.
           Silence detection can only be used with version 3 of the algorithm.

           Silence detection must be disabled for use with the AcoustID service. Default is -1.

   <b>crc</b>
       CRC (Cyclic Redundancy Check) muxer.

       This muxer computes and prints the Adler-32 CRC of all the input audio and video frames. By default audio
       frames are converted to signed 16-bit raw audio and video frames to raw video before computing the CRC.

       The output of the muxer consists of a single line of the form: CRC=0x<u>CRC</u>,  where  <u>CRC</u>  is  a  hexadecimal
       number 0-padded to 8 digits containing the CRC for all the decoded input frames.

       See also the <b>framecrc</b> muxer.

       <u>Examples</u>

       •   Use <b>ffmpeg</b> to compute the CRC of the input, and store it in the file <u>out.crc</u>:

                   ffmpeg -i INPUT -f crc out.crc

       •   Use <b>ffmpeg</b> to print the CRC to stdout with the command:

                   ffmpeg -i INPUT -f crc -

       •   You  can  select  the output format of each frame with <b>ffmpeg</b> by specifying the audio and video codec
           and format. For example, to compute the CRC of the input audio converted to PCM  unsigned  8-bit  and
           the input video converted to MPEG-2 video, use the command:

                   ffmpeg -i INPUT -c:a pcm_u8 -c:v mpeg2video -f crc -

   <b>dash</b>
       Dynamic Adaptive Streaming over HTTP (DASH) muxer.

       This  muxer  creates segments and manifest files according to the MPEG-DASH standard ISO/IEC 23009-1:2014
       and following standard updates.

       For more information see:

       •   ISO                                        DASH                                        Specification:
           &lt;<b><a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c065274_ISO_IEC_23009-1_2014.zip">http://standards.iso.org/ittf/PubliclyAvailableStandards/c065274_ISO_IEC_23009-1_2014.zip</a></b>&gt;

       •   WebM                                        DASH                                       Specification:
           &lt;<b>https://sites.google.com/a/webmproject.org/wiki/adaptive-streaming/webm-dash-specification</b>&gt;

       This muxer creates an MPD (Media Presentation Description) manifest  file  and  segment  files  for  each
       stream. Segment files are placed in the same directory of the MPD manifest file.

       The segment filename might contain pre-defined identifiers used in the manifest "SegmentTemplate" section
       as defined in section 5.3.9.4.4 of the standard.

       Available  identifiers  are "$RepresentationID$", "$Number$", "$Bandwidth$", and "$Time$". In addition to
       the standard identifiers, an ffmpeg-specific "$ext$" identifier is also supported. When specified, <b>ffmpeg</b>
       will replace "$ext$" in the file name with muxing format's extensions such as "mp4", "webm" etc.

       <u>Options</u>

       <b>adaptation_sets</b> <u>adaptation_sets</u>
           Assign streams to adaptation sets, specified in the MPD manifest "AdaptationSets" section.

           An adaptation set contains a  set  of  one  or  more  streams  accessed  as  a  single  subset,  e.g.
           corresponding  streams  encoded  at  different size selectable by the user depending on the available
           bandwidth, or to different audio streams with a different language.

           Each adaptation set is specified with the syntax:

                   id=&lt;index&gt;,streams=&lt;streams&gt;

           where <u>index</u> must be a numerical index, and <u>streams</u> is a sequence  of  ","-separated  stream  indices.
           Multiple adaptation sets can be specified, separated by spaces.

           To  map  all  video  (or  audio)  streams  to  an  adaptation set, "v" (or "a") can be used as stream
           identifier instead of IDs.

           When no assignment is defined, this defaults to an adaptation set for each stream.

           The following optional fields can also be specified:

           <b>descriptor</b>
               Define the descriptor as defined by ISO/IEC 23009-1:2014/Amd.2:2015.

               For example:

                       &lt;SupplementalProperty schemeIdUri=\"urn:mpeg:dash:srd:2014\" value=\"0,0,0,1,1,2,2\"/&gt;

               The descriptor string should be a self-closing XML tag.

           <b>frag_duration</b>
               Override the global fragment duration specified with the <b>frag_duration</b> option.

           <b>frag_type</b>
               Override the global fragment type specified with the <b>frag_type</b> option.

           <b>seg_duration</b>
               Override the global segment duration specified with the <b>seg_duration</b> option.

           <b>trick_id</b>
               Mark an adaptation set as containing streams meant to be used for Trick Mode for  the  referenced
               adaptation set.

           A few examples of possible values for the <b>adaptation_sets</b> option follow:

                   id=0,seg_duration=2,frag_duration=1,frag_type=duration,streams=v id=1,seg_duration=2,frag_type=none,streams=a

                   id=0,seg_duration=2,frag_type=none,streams=0 id=1,seg_duration=10,frag_type=none,trick_id=0,streams=1

       <b>dash_segment_type</b> <u>type</u>
           Set DASH segment files type.

           Possible values:

           <b>auto</b>
               The  dash  segment  files  format will be selected based on the stream codec. This is the default
               mode.

           <b>mp4</b> the dash segment files will be in ISOBMFF/MP4 format

           <b>webm</b>
               the dash segment files will be in WebM format

       <b>extra_window_size</b> <u>size</u>
           Set the maximum number of segments kept outside of the manifest before removing from disk.

       <b>format_options</b> <u>options_list</u>
           Set container format (mp4/webm) options using a ":"-separated list of  key=value  parameters.  Values
           containing ":" special characters must be escaped.

       <b>frag_duration</b> <u>duration</u>
           Set the length in seconds of fragments within segments, fractional value can also be set.

       <b>frag_type</b> <u>type</u>
           Set the type of interval for fragmentation.

           Possible values:

           <b>auto</b>
               set one fragment per segment

           <b>every_frame</b>
               fragment at every frame

           <b>duration</b>
               fragment at specific time intervals

           <b>pframes</b>
               fragment at keyframes and following P-Frame reordering (Video only, experimental)

       <b>global_sidx</b> <u>bool</u>
           Write global "SIDX" atom. Applicable only for single file, mp4 output, non-streaming mode.

       <b>hls_master_name</b> <u>file_name</u>
           HLS master playlist name. Default is <u>master.m3u8</u>.

       <b>hls_playlist</b> <u>bool</u>
           Generate  HLS  playlist  files.  The  master  playlist  is  generated  with filename specified by the
           <b>hls_master_name</b> option. One  media  playlist  file  is  generated  for  each  stream  with  filenames
           <u>media_0.m3u8</u>, <u>media_1.m3u8</u>, etc.

       <b>http_opts</b> <u>http_opts</u>
           Specify a list of ":"-separated key=value options to pass to the underlying HTTP protocol. Applicable
           only for HTTP output.

       <b>http_persistent</b> <u>bool</u>
           Use persistent HTTP connections. Applicable only for HTTP output.

       <b>http_user_agent</b> <u>user_agent</u>
           Override User-Agent field in HTTP header. Applicable only for HTTP output.

       <b>ignore_io_errors</b> <u>bool</u>
           Ignore  IO  errors  during open and write. Useful for long-duration runs with network output. This is
           disabled by default.

       <b>index_correction</b> <u>bool</u>
           Enable or disable segment index correction logic. Applicable only when <b>use_template</b>  is  enabled  and
           <b>use_timeline</b> is disabled. This is disabled by default.

           When  enabled,  the logic monitors the flow of segment indexes. If a streams's segment index value is
           not at the expected real time position, then the logic corrects that index value.

           Typically this logic is needed in live streaming use cases. The network  bandwidth  fluctuations  are
           common  during  long  run  streaming.  Each fluctuation can cause the segment indexes fall behind the
           expected real time position.

       <b>init_seg_name</b> <u>init_name</u>
           DASH-templated    name    to    use    for     the     initialization     segment.     Default     is
           "init-stream$RepresentationID$.$ext$".  "$ext$" is replaced with the file name extension specific for
           the segment format.

       <b>ldash</b> <u>bool</u>
           Enable Low-latency Dash by constraining the presence and values of some elements. This is disabled by
           default.

       <b>lhls</b> <u>bool</u>
           Enable Low-latency HLS (LHLS). Add "#EXT-X-PREFETCH" tag with current segment's  URI.  hls.js  player
           folks   are   trying   to   standardize   an   open  LHLS  spec.  The  draft  spec  is  available  at
           &lt;<b>https://github.com/video-dev/hlsjs-rfcs/blob/lhls-spec/proposals/0001-lhls.md</b>&gt;.

           This option tries to comply with the above open spec. It enables <b>streaming</b> and  <b>hls_playlist</b>  options
           automatically.  This is an experimental feature.

           Note:          This          is         not         Apple's         version         LHLS.         See
           &lt;<b>https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis</b>&gt;

       <b>master_m3u8_publish_rate</b> <u>segment_intervals_count</u>
           Publish master playlist repeatedly every after specified number of segment intervals.

       <b>max_playback_rate</b> <u>rate</u>
           Set the maximum playback rate indicated as appropriate for the purposes  of  automatically  adjusting
           playback latency and buffer occupancy during normal playback by clients.

       <b>media_seg_name</b> <u>segment_name</u>
           DASH-templated      name      to      use      for     the     media     segments.     Default     is
           "chunk-stream$RepresentationID$-$Number%05d$.$ext$". "$ext$" is replaced with the file name extension
           specific for the segment format.

       <b>method</b> <u>method</u>
           Use the given HTTP method to create output files. Generally set to "PUT" or "POST".

       <b>min_playback_rate</b> <u>rate</u>
           Set the minimum playback rate indicated as appropriate for the purposes  of  automatically  adjusting
           playback latency and buffer occupancy during normal playback by clients.

       <b>mpd_profile</b> <u>flags</u>
           Set one or more MPD manifest profiles.

           Possible values:

           <b>dash</b>
               MPEG-DASH ISO Base media file format live profile

           <b>dvb_dash</b>
               DVB-DASH profile

           Default value is "dash".

       <b>remove_at_exit</b> <u>bool</u>
           Enable or disable removal of all segments when finished. This is disabled by default.

       <b>seg_duration</b> <u>duration</u>
           Set  the  segment  length  in  seconds (fractional value can be set). The value is treated as average
           segment duration when the <b>use_template</b> option is enabled and the <b>use_timeline</b> option is disabled  and
           as minimum segment duration for all the other use cases.

           Default value is 5.

       <b>single_file</b> <u>bool</u>
           Enable  or  disable storing all segments in one file, accessed using byte ranges. This is disabled by
           default.

           The name of the single file can be specified with  the  <b>single_file_name</b>  option,  if  not  specified
           assume the basename of the manifest file with the output format extension.

       <b>single_file_name</b> <u>file_name</u>
           DASH-templated  name  to use for the manifest "baseURL" element. Imply that the <b>single_file</b> option is
           set to <u>true</u>. In the template, "$ext$" is replaced with the  file  name  extension  specific  for  the
           segment format.

       <b>streaming</b> <u>bool</u>
           Enable  or  disable  chunk  streaming  mode  of output. In chunk streaming mode, each frame will be a
           "moof" fragment which forms a chunk. This is disabled by default.

       <b>target_latency</b> <u>target_latency</u>
           Set an intended target latency in seconds for serving (fractional value can be set). Applicable  only
           when  the <b>streaming</b> and <b>write_prft</b> options are enabled. This is an informative fields clients can use
           to measure the latency of the service.

       <b>timeout</b> <u>timeout</u>
           Set timeout for socket I/O operations expressed in seconds (fractional value can be set).  Applicable
           only for HTTP output.

       <b>update_period</b> <u>period</u>
           Set  the  MPD  update  period,  for  dynamic  content. The unit is second. If set to 0, the period is
           automatically computed.

           Default value is 0.

       <b>use_template</b> <u>bool</u>
           Enable or disable use of "SegmentTemplate" instead of "SegmentList" in the manifest. This is  enabled
           by default.

       <b>use_timeline</b> <u>bool</u>
           Enable  or  disable  use  of "SegmentTimeline" within the "SegmentTemplate" manifest section. This is
           enabled by default.

       <b>utc_timing_url</b> <u>url</u>
           URL  of  the  page  that   will   return   the   UTC   timestamp   in   ISO   format,   for   example
           "https://time.akamai.com/?iso"

       <b>window_size</b> <u>size</u>
           Set  the  maximum number of segments kept in the manifest, discard the oldest one. This is useful for
           live streaming.

           If the value is 0, all segments are kept in the manifest. Default value is 0.

       <b>write_prft</b> <u>write_prft</u>
           Write Producer Reference Time elements on supported streams. This also enables writing prft boxes  in
           the  underlying  muxer.  Applicable  only  when  the  <u>utc_url</u> option is enabled. It is set to <u>auto</u> by
           default, in which case the muxer will attempt to enable it only in modes that require it.

       <u>Example</u>

       Generate a DASH output reading from an input source in realtime using <b>ffmpeg</b>.

       Two multimedia streams are generated from the input file, both containing a video stream encoded  through
       <b>libx264</b>,  and  an audio stream encoded with <b>libfdk_aac</b>. The first multimedia stream contains video with a
       bitrate of 800k and audio at the default rate, the second with video scaled to 320x170 pixels at 300k and
       audio resampled at 22005 Hz.

       The <b>window_size</b> option keeps only the latest 5 segments with the default duration of 5 seconds.

               ffmpeg -re -i &lt;input&gt; -map 0 -map 0 -c:a libfdk_aac -c:v libx264 \
               -b:v:0 800k -profile:v:0 main \
               -b:v:1 300k -s:v:1 320x170 -profile:v:1 baseline -ar:a:1 22050 \
               -bf 1 -keyint_min 120 -g 120 -sc_threshold 0 -b_strategy 0 \
               -use_timeline 1 -use_template 1 -window_size 5 \
               -adaptation_sets "id=0,streams=v id=1,streams=a" \
               -f dash /path/to/out.mpd

   <b>daud</b>
       D-Cinema audio muxer.

       It accepts a single 6-channels audio stream resampled at 96000 Hz encoded with the <b>pcm_24daud</b> codec.

       <u>Example</u>

       Use <b>ffmpeg</b> to mux input audio to a <b>5.1</b> channel layout resampled at 96000Hz:

               ffmpeg -i INPUT -af aresample=96000,pan=5.1 slow.302

       For ffmpeg versions before 7.0 you might have to use the <b>asetnsamples</b> filter to limit  the  muxed  packet
       size,  because  this  format  does not support muxing packets larger than 65535 bytes (3640 samples). For
       newer ffmpeg versions audio is automatically packetized to 36000 byte (2000 sample) packets.

   <b>dv</b>
       DV (Digital Video) muxer.

       It accepts exactly one <b>dvvideo</b> video stream and at most two <b>pcm_s16</b> audio streams. More  constraints  are
       defined  by  the property of the video, which must correspond to a DV video supported profile, and on the
       framerate.

       <u>Example</u>

       Use <b>ffmpeg</b> to convert the input:

               ffmpeg -i INPUT -s:v 720x480 -pix_fmt yuv411p -r 29.97 -ac 2 -ar 48000 -y out.dv

   <b>ffmetadata</b>
       FFmpeg metadata muxer.

       This muxer writes the streams metadata in the <b>ffmetadata</b> format.

       See <b>the</b> <b>Metadata</b> <b>chapter</b> for information about the format.

       <u>Example</u>

       Use <b>ffmpeg</b> to extract metadata from an input file to a <u>metadata.ffmeta</u> file in <b>ffmetadata</b> format:

               ffmpeg -i INPUT -f ffmetadata metadata.ffmeta

   <b>fifo</b>
       FIFO (First-In First-Out) muxer.

       The <b>fifo</b> pseudo-muxer allows the separation of encoding and muxing by using  a  first-in-first-out  queue
       and running the actual muxer in a separate thread.

       This  is  especially  useful  in  combination  with the <b>tee</b> muxer and can be used to send data to several
       destinations with different reliability/writing speed/latency.

       The target muxer is either selected from the output name or specified through the <b>fifo_format</b> option.

       The behavior of the <b>fifo</b> muxer if the queue fills up or if the output fails (e.g. if a packet  cannot  be
       written to the output) is selectable:

       •   Output  can  be transparently restarted with configurable delay between retries based on real time or
           time of the processed stream.

       •   Encoding can be blocked during temporary failure, or continue transparently dropping packets in  case
           the FIFO queue fills up.

       API  users  should be aware that callback functions ("interrupt_callback", "io_open" and "io_close") used
       within its "AVFormatContext" must be thread-safe.

       <u>Options</u>

       <b>attempt_recovery</b> <u>bool</u>
           If failure occurs, attempt to recover the output. This is especially useful when  used  with  network
           output,  since it makes it possible to restart streaming transparently. By default this option is set
           to "false".

       <b>drop_pkts_on_overflow</b> <u>bool</u>
           If set to "true", in case the fifo queue fills up, packets will be dropped rather than  blocking  the
           encoder.  This  makes  it  possible  to continue streaming without delaying the input, at the cost of
           omitting part of the stream. By default this option is set to "false", so in such cases  the  encoder
           will be blocked until the muxer processes some of the packets and none of them is lost.

       <b>fifo_format</b> <u>format_name</u>
           Specify the format name. Useful if it cannot be guessed from the output name suffix.

       <b>format_opts</b> <u>options</u>
           Specify  format  options  for  the  underlying  muxer.  Muxer  options  can be specified as a list of
           <u>key</u>=<u>value</u> pairs separated by ':'.

       <b>max_recovery_attempts</b> <u>count</u>
           Set maximum number of  successive  unsuccessful  recovery  attempts  after  which  the  output  fails
           permanently. By default this option is set to 0 (unlimited).

       <b>queue_size</b> <u>size</u>
           Specify size of the queue as a number of packets. Default value is 60.

       <b>recover_any_error</b> <u>bool</u>
           If  set to "true", recovery will be attempted regardless of type of the error causing the failure. By
           default this option is set to "false" and in case of certain (usually permanent) errors the  recovery
           is not attempted even when the <b>attempt_recovery</b> option is set to "true".

       <b>recovery_wait_streamtime</b> <u>bool</u>
           If  set  to  "false",  the real time is used when waiting for the recovery attempt (i.e. the recovery
           will be attempted after the time specified by the <b>recovery_wait_time</b> option).

           If set to "true", the time of the processed stream is taken into account instead (i.e.  the  recovery
           will be attempted after discarding the packets corresponding to the <b>recovery_wait_time</b> option).

           By default this option is set to "false".

       <b>recovery_wait_time</b> <u>duration</u>
           Specify waiting time in seconds before the next recovery attempt after previous unsuccessful recovery
           attempt. Default value is 5.

       <b>restart_with_keyframe</b> <u>bool</u>
           Specify whether to wait for the keyframe after recovering from queue overflow or failure. This option
           is set to "false" by default.

       <b>timeshift</b> <u>duration</u>
           Buffer  the  specified  amount  of  packets  and delay writing the output. Note that the value of the
           <b>queue_size</b> option must be big enough to store the packets for timeshift. At the end of the input  the
           fifo buffer is flushed at realtime speed.

       <u>Example</u>

       Use  <b>ffmpeg</b> to stream to an RTMP server, continue processing the stream at real-time rate even in case of
       temporary failure (network outage) and attempt to recover streaming every second indefinitely:

               ffmpeg -re -i ... -c:v libx264 -c:a aac -f fifo -fifo_format flv \
                 -drop_pkts_on_overflow 1 -attempt_recovery 1 -recovery_wait_time 1 \
                 -map 0:v -map 0:a rtmp://example.com/live/stream_name

   <b>film_cpk</b>
       Sega film (.cpk) muxer.

       This format was used as internal format for several Sega games.

       For     more     information     regarding      the      Sega      film      file      format,      visit
       &lt;<b><a href="http://wiki.multimedia.cx/index.php">http://wiki.multimedia.cx/index.php</a>?title=Sega_FILM</b>&gt;.

       It accepts at maximum one <b>cinepak</b> or raw video stream, and at maximum one audio stream.

   <b>filmstrip</b>
       Adobe Filmstrip muxer.

       This format is used by several Adobe tools to store a generated filmstrip export. It accepts a single raw
       video stream.

   <b>fits</b>
       Flexible Image Transport System (FITS) muxer.

       This image format is used to store astronomical data.

       For more information regarding the format, visit &lt;<b>https://fits.gsfc.nasa.gov</b>&gt;.

   <b>flac</b>
       Raw FLAC audio muxer.

       This  muxer  accepts  exactly  one  FLAC  audio  stream.  Additionally, it is possible to add images with
       disposition <b>attached_pic</b>.

       <u>Options</u>

       <b>write_header</b> <u>bool</u>
           write the file header if set to "true", default is "true"

       <u>Example</u>

       Use <b>ffmpeg</b> to store the audio stream from an  input  file,  together  with  several  pictures  used  with
       <b>attached_pic</b> disposition:

               ffmpeg -i INPUT -i pic1.png -i pic2.jpg -map 0:a -map 1 -map 2 -disposition:v attached_pic OUTPUT

   <b>flv</b>
       Adobe Flash Video Format muxer.

       <u>Options</u>

       <b>flvflags</b> <u>flags</u>
           Possible values:

           <b>aac_seq_header_detect</b>
               Place AAC sequence header based on audio stream data.

           <b>no_sequence_end</b>
               Disable sequence end tag.

           <b>no_metadata</b>
               Disable metadata tag.

           <b>no_duration_filesize</b>
               Disable  duration  and filesize in metadata when they are equal to zero at the end of stream. (Be
               used to non-seekable living stream).

           <b>add_keyframe_index</b>
               Used to facilitate seeking; particularly for HTTP pseudo streaming.

   <b>framecrc</b>
       Per-packet CRC (Cyclic Redundancy Check) testing format.

       This muxer computes and prints the Adler-32 CRC for each audio and video packet. By default audio  frames
       are converted to signed 16-bit raw audio and video frames to raw video before computing the CRC.

       The output of the muxer consists of a line for each audio and video packet of the form:

               &lt;stream_index&gt;, &lt;packet_dts&gt;, &lt;packet_pts&gt;, &lt;packet_duration&gt;, &lt;packet_size&gt;, 0x&lt;CRC&gt;

       <u>CRC</u> is a hexadecimal number 0-padded to 8 digits containing the CRC of the packet.

       <u>Examples</u>

       For  example  to compute the CRC of the audio and video frames in <u>INPUT</u>, converted to raw audio and video
       packets, and store it in the file <u>out.crc</u>:

               ffmpeg -i INPUT -f framecrc out.crc

       To print the information to stdout, use the command:

               ffmpeg -i INPUT -f framecrc -

       With <b>ffmpeg</b>, you can select the output format to which the audio and  video  frames  are  encoded  before
       computing  the  CRC  for each packet by specifying the audio and video codec. For example, to compute the
       CRC of each decoded input audio frame converted to PCM unsigned 8-bit and of  each  decoded  input  video
       frame converted to MPEG-2 video, use the command:

               ffmpeg -i INPUT -c:a pcm_u8 -c:v mpeg2video -f framecrc -

       See also the <b>crc</b> muxer.

   <b>framehash</b>
       Per-packet hash testing format.

       This muxer computes and prints a cryptographic hash for each audio and video packet. This can be used for
       packet-by-packet equality checks without having to individually do a binary comparison on each.

       By  default  audio  frames  are converted to signed 16-bit raw audio and video frames to raw video before
       computing the hash, but the output of explicit conversions to other codecs can also be used. It uses  the
       SHA-256 cryptographic hash function by default, but supports several other algorithms.

       The output of the muxer consists of a line for each audio and video packet of the form:

               &lt;stream_index&gt;, &lt;packet_dts&gt;, &lt;packet_pts&gt;, &lt;packet_duration&gt;, &lt;packet_size&gt;, &lt;hash&gt;

       <u>hash</u> is a hexadecimal number representing the computed hash for the packet.

       <b>hash</b> <u>algorithm</u>
           Use  the  cryptographic  hash  function  specified by the string <u>algorithm</u>.  Supported values include
           "MD5", "murmur3", "RIPEMD128", "RIPEMD160", "RIPEMD256", "RIPEMD320",  "SHA160",  "SHA224",  "SHA256"
           (default), "SHA512/224", "SHA512/256", "SHA384", "SHA512", "CRC32" and "adler32".

       <u>Examples</u>

       To  compute  the  SHA-256  hash  of the audio and video frames in <u>INPUT</u>, converted to raw audio and video
       packets, and store it in the file <u>out.sha256</u>:

               ffmpeg -i INPUT -f framehash out.sha256

       To print the information to stdout, using the MD5 hash function, use the command:

               ffmpeg -i INPUT -f framehash -hash md5 -

       See also the <b>hash</b> muxer.

   <b>framemd5</b>
       Per-packet MD5 testing format.

       This is a variant of the <b>framehash</b> muxer. Unlike that muxer, it defaults to using the MD5 hash function.

       <u>Examples</u>

       To compute the MD5 hash of the audio and video frames in <u>INPUT</u>, converted to raw audio and video packets,
       and store it in the file <u>out.md5</u>:

               ffmpeg -i INPUT -f framemd5 out.md5

       To print the information to stdout, use the command:

               ffmpeg -i INPUT -f framemd5 -

       See also the <b>framehash</b> and <b>md5</b> muxers.

   <b>gif</b>
       Animated GIF muxer.

       Note that the GIF format has a very large time base: the delay between two frames can  therefore  not  be
       smaller than one centi second.

       <u>Options</u>

       <b>loop</b> <u>bool</u>
           Set the number of times to loop the output. Use -1 for no loop, 0 for looping indefinitely (default).

       <b>final_delay</b> <u>delay</u>
           Force  the delay (expressed in centiseconds) after the last frame. Each frame ends with a delay until
           the next frame. The default is -1, which is a special value to tell the muxer to re-use the  previous
           delay. In case of a loop, you might want to customize this value to mark a pause for instance.

       <u>Example</u>

       Encode a gif looping 10 times, with a 5 seconds delay between the loops:

               ffmpeg -i INPUT -loop 10 -final_delay 500 out.gif

       Note 1: if you wish to extract the frames into separate GIF files, you need to force the <b>image2</b> muxer:

               ffmpeg -i INPUT -c:v gif -f image2 "out%d.gif"

   <b>gxf</b>
       General eXchange Format (GXF) muxer.

       GXF  was  developed  by  Grass Valley Group, then standardized by SMPTE as SMPTE 360M and was extended in
       SMPTE RDD 14-2007 to include high-definition video resolutions.

       It accepts at most one video stream with codec <b>mjpeg</b>, or  <b>mpeg1video</b>,  or  <b>mpeg2video</b>,  or  <b>dvvideo</b>  with
       resolution <b>512x480</b> or <b>608x576</b>, and several audio streams with rate 48000Hz and codec <b>pcm16_le</b>.

   <b>hash</b>
       Hash testing format.

       This  muxer computes and prints a cryptographic hash of all the input audio and video frames. This can be
       used for equality checks without having to do a complete binary comparison.

       By default audio frames are converted to signed 16-bit raw audio and video frames  to  raw  video  before
       computing  the  hash, but the output of explicit conversions to other codecs can also be used. Timestamps
       are ignored. It uses the SHA-256 cryptographic hash function  by  default,  but  supports  several  other
       algorithms.

       The  output  of  the muxer consists of a single line of the form: <u>algo</u>=<u>hash</u>, where <u>algo</u> is a short string
       representing the hash function used, and <u>hash</u> is a hexadecimal number representing the computed hash.

       <b>hash</b> <u>algorithm</u>
           Use the cryptographic hash function specified by the  string  <u>algorithm</u>.   Supported  values  include
           "MD5",  "murmur3",  "RIPEMD128",  "RIPEMD160", "RIPEMD256", "RIPEMD320", "SHA160", "SHA224", "SHA256"
           (default), "SHA512/224", "SHA512/256", "SHA384", "SHA512", "CRC32" and "adler32".

       <u>Examples</u>

       To compute the SHA-256 hash of the input converted to raw audio and video,  and  store  it  in  the  file
       <u>out.sha256</u>:

               ffmpeg -i INPUT -f hash out.sha256

       To print an MD5 hash to stdout use the command:

               ffmpeg -i INPUT -f hash -hash md5 -

       See also the <b>framehash</b> muxer.

   <b>hds</b>
       HTTP Dynamic Streaming (HDS) muxer.

       HTTP  dynamic streaming, or HDS, is an adaptive bitrate streaming method developed by Adobe. HDS delivers
       MP4 video content over HTTP connections. HDS can be used for on-demand streaming or live streaming.

       This muxer creates an .f4m (Adobe Flash Media Manifest File) manifest, an .abst  (Adobe  Bootstrap  File)
       for each stream, and segment files in a directory specified as the output.

       These  needs  to  be accessed by an HDS player throuhg HTTPS for it to be able to perform playback on the
       generated stream.

       <u>Options</u>

       <b>extra_window_size</b> <u>int</u>
           number of fragments kept outside of the manifest before removing from disk

       <b>min_frag_duration</b> <u>microseconds</u>
           minimum fragment duration (in microseconds), default value is 1 second (10000000)

       <b>remove_at_exit</b> <u>bool</u>
           remove all fragments when finished when set to "true"

       <b>window_size</b> <u>int</u>
           number of fragments kept in the manifest, if set to a value different from 0. By default all segments
           are kept in the output directory.

       <u>Example</u>

       Use <b>ffmpeg</b> to generate HDS files to the <u>output.hds</u> directory in real-time rate:

               ffmpeg -re -i INPUT -f hds -b:v 200k output.hds

   <b>hls</b>
       Apple HTTP Live Streaming muxer that  segments  MPEG-TS  according  to  the  HTTP  Live  Streaming  (HLS)
       specification.

       It  creates  a  playlist  file, and one or more segment files. The output filename specifies the playlist
       filename.

       By default, the muxer creates a file for each segment produced. These files have the  same  name  as  the
       playlist, followed by a sequential number and a .ts extension.

       Make  sure  to  require  a  closed  GOP  when  encoding  and to set the GOP size to fit your segment time
       constraint.

       For example, to convert an input file with <b>ffmpeg</b>:

               ffmpeg -i in.mkv -c:v h264 -flags +cgop -g 30 -hls_time 1 out.m3u8

       This example will produce the playlist, <u>out.m3u8</u>, and segment files: <u>out0.ts</u>, <u>out1.ts</u>, <u>out2.ts</u>, etc.

       See also the <b>segment</b> muxer, which provides a more generic and flexible implementation of a segmenter, and
       can be used to perform HLS segmentation.

       <u>Options</u>

       <b>hls_init_time</b> <u>duration</u>
           Set the initial target segment length. Default value is <u>0</u>.

           <u>duration</u> must be a time duration specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b>  <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>.

           Segment  will  be  cut on the next key frame after this time has passed on the first m3u8 list. After
           the initial playlist is filled, <b>ffmpeg</b> will cut segments at duration equal to <b>hls_time</b>.

       <b>hls_time</b> <u>duration</u>
           Set the target segment length. Default value is 2.

           <u>duration</u> must be a time duration specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b>  <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>.  Segment will be cut on the next key frame after this time has passed.

       <b>hls_list_size</b> <u>size</u>
           Set  the maximum number of playlist entries. If set to 0 the list file will contain all the segments.
           Default value is 5.

       <b>hls_delete_threshold</b> <u>size</u>
           Set the number of unreferenced segments to keep on disk before  "hls_flags  delete_segments"  deletes
           them.  Increase this to allow continue clients to download segments which were recently referenced in
           the playlist. Default value is 1, meaning segments older than <b>hls_list_size+1</b> will be deleted.

       <b>hls_start_number_source</b> <u>source</u>
           Start the playlist sequence number  ("#EXT-X-MEDIA-SEQUENCE")  according  to  the  specified  source.
           Unless <b>hls_flags</b> <b>single_file</b> is set, it also specifies source of starting sequence numbers of segment
           and  subtitle  filenames.  In  any  case,  if <b>hls_flags</b> <b>append_list</b> is set and read playlist sequence
           number is greater than the specified start sequence number, then that value will  be  used  as  start
           value.

           It accepts the following values:

           <b>generic</b> <b>(default)</b>
               Set the start numbers according to the <b>start_number</b> option value.

           <b>epoch</b>
               Set the start number as the seconds since epoch (1970-01-01 00:00:00).

           <b>epoch_us</b>
               Set the start number as the microseconds since epoch (1970-01-01 00:00:00).

           <b>datetime</b>
               Set the start number based on the current date/time as YYYYmmddHHMMSS. e.g. 20161231235759.

       <b>start_number</b> <u>number</u>
           Start  the  playlist  sequence  number  ("#EXT-X-MEDIA-SEQUENCE")  from  the  specified  <u>number</u>  when
           <b>hls_start_number_source</b> value is <u>generic</u>. (This is the default case.)  Unless  <b>hls_flags</b>  <b>single_file</b>
           is set, it also specifies starting sequence numbers of segment and subtitle filenames.  Default value
           is 0.

       <b>hls_allow_cache</b> <u>bool</u>
           Explicitly set whether the client MAY (1) or MUST NOT (0) cache media segments.

       <b>hls_base_url</b> <u>baseurl</u>
           Append <u>baseurl</u> to every entry in the playlist.  Useful to generate playlists with absolute paths.

           Note  that  the playlist sequence number must be unique for each segment and it is not to be confused
           with the segment filename sequence number which can be cyclic, for example  if  the  <b>wrap</b>  option  is
           specified.

       <b>hls_segment_filename</b> <u>filename</u>
           Set  the segment filename. Unless the <b>hls_flags</b> option is set with <b>single_file</b>, <u>filename</u> is used as a
           string format with the segment number appended.

           For example:

                   ffmpeg -i in.nut -hls_segment_filename 'file%03d.ts' out.m3u8

           will produce the playlist, <u>out.m3u8</u>, and segment files: <u>file000.ts</u>, <u>file001.ts</u>, <u>file002.ts</u>, etc.

           <u>filename</u> may contain a full path or relative path specification, but only the file name part  without
           any  path  will be contained in the m3u8 segment list.  Should a relative path be specified, the path
           of the created segment files will be relative to the current working directory.  When  <b>strftime_mkdir</b>
           is set, the whole expanded value of <u>filename</u> will be written into the m3u8 segment list.

           When  <b>var_stream_map</b>  is  set with two or more variant streams, the <u>filename</u> pattern must contain the
           string "%v", and this string will be expanded  to  the  position  of  variant  stream  index  in  the
           generated segment file names.

           For example:

                   ffmpeg -i in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \
                     -map 0:v -map 0:a -map 0:v -map 0:a -f hls -var_stream_map "v:0,a:0 v:1,a:1" \
                     -hls_segment_filename 'file_%v_%03d.ts' out_%v.m3u8

           will  produce  the playlists segment file sets: <u>file_0_000.ts</u>, <u>file_0_001.ts</u>, <u>file_0_002.ts</u>, etc. and
           <u>file_1_000.ts</u>, <u>file_1_001.ts</u>, <u>file_1_002.ts</u>, etc.

           The string "%v" may be present in the filename or in the last directory name containing the file, but
           only in one of them. (Additionally, %v may  appear  multiple  times  in  the  last  sub-directory  or
           filename.)  If the string %v is present in the directory name, then sub-directories are created after
           expanding the directory name pattern. This enables creation of segments  corresponding  to  different
           variant streams in subdirectories.

           For example:

                   ffmpeg -i in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \
                     -map 0:v -map 0:a -map 0:v -map 0:a -f hls -var_stream_map "v:0,a:0 v:1,a:1" \
                     -hls_segment_filename 'vs%v/file_%03d.ts' vs%v/out.m3u8

           will produce the playlists segment file sets: <u>vs0/file_000.ts</u>, <u>vs0/file_001.ts</u>, <u>vs0/file_002.ts</u>, etc.
           and <u>vs1/file_000.ts</u>, <u>vs1/file_001.ts</u>, <u>vs1/file_002.ts</u>, etc.

       <b>strftime</b> <u>bool</u>
           Use  strftime() on <u>filename</u> to expand the segment filename with localtime. The segment number is also
           available in this mode, but to use it, you need to set <b>second_level_segment_index</b> in the <b>hls_flag</b> and
           %%d will be the specifier.

           For example:

                   ffmpeg -i in.nut -strftime 1 -hls_segment_filename 'file-%Y%m%d-%s.ts' out.m3u8

           will   produce   the   playlist,   <u>out.m3u8</u>,   and   segment   files:    <u>file-20160215-1455569023.ts</u>,
           <u>file-20160215-1455569024.ts</u>,  etc.   Note:  On  some  systems/environments,  the  %s specifier is not
           available. See strftime() documentation.

           For example:

                   ffmpeg -i in.nut -strftime 1 -hls_flags second_level_segment_index -hls_segment_filename 'file-%Y%m%d-%%04d.ts' out.m3u8

           will produce the playlist, <u>out.m3u8</u>, and segment files: <u>file-20160215-0001.ts</u>, <u>file-20160215-0002.ts</u>,
           etc.

       <b>strftime_mkdir</b> <u>bool</u>
           Used together with <b>strftime</b>, it will create all subdirectories which  are  present  in  the  expanded
           values of option <b>hls_segment_filename</b>.

           For example:

                   ffmpeg -i in.nut -strftime 1 -strftime_mkdir 1 -hls_segment_filename '%Y%m%d/file-%Y%m%d-%s.ts' out.m3u8

           will  create  a  directory <u>201560215</u> (if it does not exist), and then produce the playlist, <u>out.m3u8</u>,
           and segment files: <u>20160215/file-20160215-1455569023.ts</u>, <u>20160215/file-20160215-1455569024.ts</u>, etc.

           For example:

                   ffmpeg -i in.nut -strftime 1 -strftime_mkdir 1 -hls_segment_filename '%Y/%m/%d/file-%Y%m%d-%s.ts' out.m3u8

           will create a directory hierarchy <u>2016/02/15</u> (if any of them do not  exist),  and  then  produce  the
           playlist,      <u>out.m3u8</u>,      and      segment     files:     <u>2016/02/15/file-20160215-1455569023.ts</u>,
           <u>2016/02/15/file-20160215-1455569024.ts</u>, etc.

       <b>hls_segment_options</b> <u>options_list</u>
           Set output format options using a :-separated list of key=value  parameters.  Values  containing  ":"
           special characters must be escaped.

       <b>hls_key_info_file</b> <u>key_info_file</u>
           Use  the  information  in  <u>key_info_file</u>  for  segment  encryption.  The  first line of <u>key_info_file</u>
           specifies the key URI written to the playlist. The key URL is  used  to  access  the  encryption  key
           during playback. The second line specifies the path to the key file used to obtain the key during the
           encryption  process. The key file is read as a single packed array of 16 octets in binary format. The
           optional third line specifies the initialization vector (IV) as  a  hexadecimal  string  to  be  used
           instead of the segment sequence number (default) for encryption. Changes to <u>key_info_file</u> will result
           in  segment  encryption  with  the  new key/IV and an entry in the playlist for the new key URI/IV if
           <b>hls_flags</b> <b>periodic_rekey</b> is enabled.

           Key info file format:

                   &lt;key URI&gt;
                   &lt;key file path&gt;
                   &lt;IV&gt; (optional)

           Example key URIs:

                   <a href="http://server/file.key">http://server/file.key</a>
                   /path/to/file.key
                   file.key

           Example key file paths:

                   file.key
                   /path/to/file.key

           Example IV:

                   0123456789ABCDEF0123456789ABCDEF

           Key info file example:

                   <a href="http://server/file.key">http://server/file.key</a>
                   /path/to/file.key
                   0123456789ABCDEF0123456789ABCDEF

           Example shell script:

                   #!<a href="file:/bin/sh">/bin/sh</a>
                   BASE_URL=${1:-'.'}
                   openssl rand 16 &gt; file.key
                   echo $BASE_URL/file.key &gt; file.keyinfo
                   echo file.key &gt;&gt; file.keyinfo
                   echo $(openssl rand -hex 16) &gt;&gt; file.keyinfo
                   ffmpeg -f lavfi -re -i testsrc -c:v h264 -hls_flags delete_segments \
                     -hls_key_info_file file.keyinfo out.m3u8

       <b>hls_enc</b> <u>bool</u>
           Enable (1) or disable (0) the AES128 encryption.  When enabled every segment generated  is  encrypted
           and the encryption key is saved as <u>playlist</u> <u>name</u>.key.

       <b>hls_enc_key</b> <u>key</u>
           Specify a 16-octet key to encrypt the segments, by default it is randomly generated.

       <b>hls_enc_key_url</b> <u>keyurl</u>
           If set, <u>keyurl</u> is prepended instead of <u>baseurl</u> to the key filename in the playlist.

       <b>hls_enc_iv</b> <u>iv</u>
           Specify the 16-octet initialization vector for every segment instead of the autogenerated ones.

       <b>hls_segment_type</b> <u>flags</u>
           Possible values:

           <b>mpegts</b>
               Output segment files in MPEG-2 Transport Stream format. This is compatible with all HLS versions.

           <b>fmp4</b>
               Output  segment  files in fragmented MP4 format, similar to MPEG-DASH.  fmp4 files may be used in
               HLS version 7 and above.

       <b>hls_fmp4_init_filename</b> <u>filename</u>
           Set filename for the fragment files header file, default filename is <u>init.mp4</u>.

           When <b>strftime</b> is enabled, <u>filename</u> is expanded to the segment filename with localtime.

           For example:

                   ffmpeg -i in.nut -hls_segment_type fmp4 -strftime 1 -hls_fmp4_init_filename "%s_init.mp4" out.m3u8

           will produce init like this <u>1602678741_init.mp4</u>.

       <b>hls_fmp4_init_resend</b> <u>bool</u>
           Resend init file after m3u8 file refresh every time, default is <u>0</u>.

           When <b>var_stream_map</b> is set with two or more variant streams, the <u>filename</u> pattern  must  contain  the
           string  "%v",  this  string specifies the position of variant stream index in the generated init file
           names.  The string "%v" may be present in the filename or in the last directory name  containing  the
           file.  If  the  string  is  present  in  the  directory  name, then sub-directories are created after
           expanding the directory name pattern. This enables creation of init files corresponding to  different
           variant streams in subdirectories.

       <b>hls_flags</b> <u>flags</u>
           Possible values:

           <b>single_file</b>
               If  this  flag  is  set, the muxer will store all segments in a single MPEG-TS file, and will use
               byte ranges in the playlist. HLS playlists generated with this way will have the  version  number
               4.

               For example:

                       ffmpeg -i in.nut -hls_flags single_file out.m3u8

               will produce the playlist, <u>out.m3u8</u>, and a single segment file, <u>out.ts</u>.

           <b>delete_segments</b>
               Segment  files removed from the playlist are deleted after a period of time equal to the duration
               of the segment plus the duration of the playlist.

           <b>append_list</b>
               Append new segments into the end of old segment list, and remove the  "#EXT-X-ENDLIST"  from  the
               old segment list.

           <b>round_durations</b>
               Round  the  duration  info  in the playlist file segment info to integer values, instead of using
               floating point.  If there are no other features requiring higher HLS versions be used, then  this
               will allow <b>ffmpeg</b> to output a HLS version 2 m3u8.

           <b>discont_start</b>
               Add the "#EXT-X-DISCONTINUITY" tag to the playlist, before the first segment's information.

           <b>omit_endlist</b>
               Do not append the "EXT-X-ENDLIST" tag at the end of the playlist.

           <b>periodic_rekey</b>
               The  file specified by "hls_key_info_file" will be checked periodically and detect updates to the
               encryption info. Be sure to replace this file atomically, including the file containing  the  AES
               encryption key.

           <b>independent_segments</b>
               Add  the  "#EXT-X-INDEPENDENT-SEGMENTS" tag to playlists that has video segments and when all the
               segments of that playlist are guaranteed to start with a key frame.

           <b>iframes_only</b>
               Add the "#EXT-X-I-FRAMES-ONLY" tag to playlists  that  has  video  segments  and  can  play  only
               I-frames in the "#EXT-X-BYTERANGE" mode.

           <b>split_by_time</b>
               Allow  segments  to start on frames other than key frames. This improves behavior on some players
               when the time between key frames is inconsistent, but may make things worse on  others,  and  can
               cause some oddities during seeking. This flag should be used with the <b>hls_time</b> option.

           <b>program_date_time</b>
               Generate "EXT-X-PROGRAM-DATE-TIME" tags.

           <b>second_level_segment_index</b>
               Make  it  possible  to  use  segment indexes as %%d in the <b>hls_segment_filename</b> option expression
               besides date/time values when <b>strftime</b> option is on. To get fixed  width  numbers  with  trailing
               zeroes, %%0xd format is available where x is the required width.

           <b>second_level_segment_size</b>
               Make  it  possible  to use segment sizes (counted in bytes) as %%s in <b>hls_segment_filename</b> option
               expression besides date/time values when strftime is on. To get fixed width numbers with trailing
               zeroes, %%0xs format is available where x is the required width.

           <b>second_level_segment_duration</b>
               Make  it  possible  to  use  segment  duration   (calculated   in   microseconds)   as   %%t   in
               <b>hls_segment_filename</b> option expression besides date/time values when strftime is on. To get fixed
               width numbers with trailing zeroes, %%0xt format is available where x is the required width.

               For example:

                       ffmpeg -i sample.mpeg \
                          -f hls -hls_time 3 -hls_list_size 5 \
                          -hls_flags second_level_segment_index+second_level_segment_size+second_level_segment_duration \
                          -strftime 1 -strftime_mkdir 1 -hls_segment_filename "segment_%Y%m%d%H%M%S_%%04d_%%08s_%%013t.ts" stream.m3u8

               will   produce   segments   like   this:   <u>segment_20170102194334_0003_00122200_0000003000000.ts</u>,
               <u>segment_20170102194334_0004_00120072_0000003000000.ts</u> etc.

           <b>temp_file</b>
               Write segment data to <u>filename.tmp</u> and rename to filename only once the segment is complete.

               A webserver serving up segments can be configured to reject requests to *.tmp to  prevent  access
               to in-progress segments before they have been added to the m3u8 playlist.

               This  flag  also  affects  how m3u8 playlist files are created. If this flag is set, all playlist
               files will be written into a temporary file and renamed after they  are  complete,  similarly  as
               segments  are  handled.  But playlists with "file" protocol and with <b>hls_playlist_type</b> type other
               than <b>vod</b> are always written into a temporary file regardless of this flag.

               Master playlist files specified with <b>master_pl_name</b>, if any, with  "file"  protocol,  are  always
               written into temporary file regardless of this flag if <b>master_pl_publish_rate</b> value is other than
               zero.

       <b>hls_playlist_type</b> <u>type</u>
           If  type is <b>event</b>, emit "#EXT-X-PLAYLIST-TYPE:EVENT" in the m3u8 header. This forces <b>hls_list_size</b> to
           0; the playlist can only be appended to.

           If type is <b>vod</b>, emit "#EXT-X-PLAYLIST-TYPE:VOD" in the m3u8 header. This forces <b>hls_list_size</b>  to  0;
           the playlist must not change.

       <b>method</b> <u>method</u>
           Use the given HTTP method to create the hls files.

           For example:

                   ffmpeg -re -i in.ts -f hls -method PUT <a href="http://example.com/live/out.m3u8">http://example.com/live/out.m3u8</a>

           will upload all the mpegts segment files to the HTTP server using the HTTP PUT method, and update the
           m3u8  files  every  "refresh" times using the same method. Note that the HTTP server must support the
           given method for uploading files.

       <b>http_user_agent</b> <u>agent</u>
           Override User-Agent field in HTTP header. Applicable only for HTTP output.

       <b>var_stream_map</b> <u>stream_map</u>
           Specify a map string defining how to group the audio,  video  and  subtitle  streams  into  different
           variant streams. The variant stream groups are separated by space.

           Expected  string  format is like this "a:0,v:0 a:1,v:1 ....". Here a:, v:, s: are the keys to specify
           audio, video and subtitle streams respectively.  Allowed values are 0 to 9  (limited  just  based  on
           practical usage).

           When there are two or more variant streams, the output filename pattern must contain the string "%v":
           this  string  specifies  the position of variant stream index in the output media playlist filenames.
           The string "%v" may be present in the filename or in the last directory name containing the file.  If
           the  string  is  present  in the directory name, then sub-directories are created after expanding the
           directory name pattern. This enables creation of variant streams in subdirectories.

           A few examples follow.

           •   Create two hls variant streams. The first variant stream will contain  video  stream  of  bitrate
               1000k  and audio stream of bitrate 64k and the second variant stream will contain video stream of
               bitrate 256k and audio stream of bitrate 32k. Here, two media playlist with file names <u>out_0.m3u8</u>
               and <u>out_1.m3u8</u> will be created.

                       ffmpeg -re -i in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \
                         -map 0:v -map 0:a -map 0:v -map 0:a -f hls -var_stream_map "v:0,a:0 v:1,a:1" \
                         <a href="http://example.com/live/out_">http://example.com/live/out_</a>%v.m3u8

           •   If you want something meaningful text instead of indexes in result names, you may  specify  names
               for each or some of the variants. The following example will create two hls variant streams as in
               the  previous  one.  But  here,  the  two  media  playlist  with  file  names  <u>out_my_hd.m3u8</u> and
               <u>out_my_sd.m3u8</u> will be created.

                       ffmpeg -re -i in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \
                         -map 0:v -map 0:a -map 0:v -map 0:a -f hls -var_stream_map "v:0,a:0,name:my_hd v:1,a:1,name:my_sd" \
                         <a href="http://example.com/live/out_">http://example.com/live/out_</a>%v.m3u8

           •   Create three hls variant streams. The first variant stream will be a video only stream with video
               bitrate 1000k, the second variant stream will be an audio only stream with bitrate  64k  and  the
               third  variant  stream  will be a video only stream with bitrate 256k. Here, three media playlist
               with file names <u>out_0.m3u8</u>, <u>out_1.m3u8</u> and <u>out_2.m3u8</u> will be created.

                       ffmpeg -re -i in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k \
                         -map 0:v -map 0:a -map 0:v -f hls -var_stream_map "v:0 a:0 v:1" \
                         <a href="http://example.com/live/out_">http://example.com/live/out_</a>%v.m3u8

           •   Create the variant streams in subdirectories. Here,  the  first  media  playlist  is  created  at
               <u><a href="http://example.com/live/vs_0/out.m3u8">http://example.com/live/vs_0/out.m3u8</a></u>         and         the         second        one        at
               <u><a href="http://example.com/live/vs_1/out.m3u8">http://example.com/live/vs_1/out.m3u8</a></u>.

                       ffmpeg -re -i in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \
                         -map 0:v -map 0:a -map 0:v -map 0:a -f hls -var_stream_map "v:0,a:0 v:1,a:1" \
                         <a href="http://example.com/live/vs_">http://example.com/live/vs_</a>%v/out.m3u8

           •   Create two audio only and two video only variant streams. In addition to the  "#EXT-X-STREAM-INF"
               tag  for each variant stream in the master playlist, the "#EXT-X-MEDIA" tag is also added for the
               two audio only variant streams and they are mapped to the two video  only  variant  streams  with
               audio  group names 'aud_low' and 'aud_high'.  By default, a single hls variant containing all the
               encoded streams is created.

                       ffmpeg -re -i in.ts -b:a:0 32k -b:a:1 64k -b:v:0 1000k -b:v:1 3000k  \
                         -map 0:a -map 0:a -map 0:v -map 0:v -f hls \
                         -var_stream_map "a:0,agroup:aud_low a:1,agroup:aud_high v:0,agroup:aud_low v:1,agroup:aud_high" \
                         -master_pl_name master.m3u8 \
                         <a href="http://example.com/live/out_">http://example.com/live/out_</a>%v.m3u8

           •   Create two audio only and one video only variant streams. In addition to the  "#EXT-X-STREAM-INF"
               tag  for each variant stream in the master playlist, the "#EXT-X-MEDIA" tag is also added for the
               two audio only variant streams and they are mapped to the one video  only  variant  streams  with
               audio  group  name  'aud_low', and the audio group have default stat is NO or YES.  By default, a
               single hls variant containing all the encoded streams is created.

                       ffmpeg -re -i in.ts -b:a:0 32k -b:a:1 64k -b:v:0 1000k \
                         -map 0:a -map 0:a -map 0:v -f hls \
                         -var_stream_map "a:0,agroup:aud_low,default:yes a:1,agroup:aud_low v:0,agroup:aud_low" \
                         -master_pl_name master.m3u8 \
                         <a href="http://example.com/live/out_">http://example.com/live/out_</a>%v.m3u8

           •   Create two audio only and one video only variant streams. In addition to the  "#EXT-X-STREAM-INF"
               tag  for each variant stream in the master playlist, the "#EXT-X-MEDIA" tag is also added for the
               two audio only variant streams and they are mapped to the one video  only  variant  streams  with
               audio  group  name  'aud_low',  and the audio group have default stat is NO or YES, and one audio
               have and language is named ENG, the other audio language is named CHN. By default, a  single  hls
               variant containing all the encoded streams is created.

                       ffmpeg -re -i in.ts -b:a:0 32k -b:a:1 64k -b:v:0 1000k \
                         -map 0:a -map 0:a -map 0:v -f hls \
                         -var_stream_map "a:0,agroup:aud_low,default:yes,language:ENG a:1,agroup:aud_low,language:CHN v:0,agroup:aud_low" \
                         -master_pl_name master.m3u8 \
                         <a href="http://example.com/live/out_">http://example.com/live/out_</a>%v.m3u8

           •   Create  a  single  variant stream. Add the "#EXT-X-MEDIA" tag with "TYPE=SUBTITLES" in the master
               playlist with webvtt subtitle group name 'subtitle'. Make  sure  the  input  file  has  one  text
               subtitle stream at least.

                       ffmpeg -y -i input_with_subtitle.mkv \
                        -b:v:0 5250k -c:v h264 -pix_fmt yuv420p -profile:v main -level 4.1 \
                        -b:a:0 256k \
                        -c:s webvtt -c:a mp2 -ar 48000 -ac 2 -map 0:v -map 0:a:0 -map 0:s:0 \
                        -f hls -var_stream_map "v:0,a:0,s:0,sgroup:subtitle" \
                        -master_pl_name master.m3u8 -t 300 -hls_time 10 -hls_init_time 4 -hls_list_size \
                        10 -master_pl_publish_rate 10 -hls_flags \
                        delete_segments+discont_start+split_by_time ./tmp/video.m3u8

       <b>cc_stream_map</b> <u>cc_stream_map</u>
           Map string which specifies different closed captions groups and their attributes. The closed captions
           stream groups are separated by space.

           Expected string format is like this "ccgroup:&lt;group name&gt;,instreamid:&lt;INSTREAM-ID&gt;,language:&lt;language
           code&gt;  ....".   'ccgroup'  and  'instreamid'  are  mandatory  attributes.  'language'  is an optional
           attribute.

           The closed captions groups configured using this option are mapped to different  variant  streams  by
           providing the same 'ccgroup' name in the <b>var_stream_map</b> string.

           For example:

                   ffmpeg -re -i in.ts -b:v:0 1000k -b:v:1 256k -b:a:0 64k -b:a:1 32k \
                     -a53cc:0 1 -a53cc:1 1 \
                     -map 0:v -map 0:a -map 0:v -map 0:a -f hls \
                     -cc_stream_map "ccgroup:cc,instreamid:CC1,language:en ccgroup:cc,instreamid:CC2,language:sp" \
                     -var_stream_map "v:0,a:0,ccgroup:cc v:1,a:1,ccgroup:cc" \
                     -master_pl_name master.m3u8 \
                     <a href="http://example.com/live/out_">http://example.com/live/out_</a>%v.m3u8

           will add two "#EXT-X-MEDIA" tags with "TYPE=CLOSED-CAPTIONS" in the master playlist for the INSTREAM-
           IDs  'CC1'  and 'CC2'. Also, it will add "CLOSED-CAPTIONS" attribute with group name 'cc' for the two
           output variant streams.

           If <b>var_stream_map</b> is not set, then the first available ccgroup in  <b>cc_stream_map</b>  is  mapped  to  the
           output variant stream.

           For example:

                   ffmpeg -re -i in.ts -b:v 1000k -b:a 64k -a53cc 1 -f hls \
                     -cc_stream_map "ccgroup:cc,instreamid:CC1,language:en" \
                     -master_pl_name master.m3u8 \
                     <a href="http://example.com/live/out.m3u8">http://example.com/live/out.m3u8</a>

           this  will  add "#EXT-X-MEDIA" tag with "TYPE=CLOSED-CAPTIONS" in the master playlist with group name
           'cc', language 'en' (english) and INSTREAM-ID 'CC1'. Also, it will  add  "CLOSED-CAPTIONS"  attribute
           with group name 'cc' for the output variant stream.

       <b>master_pl_name</b> <u>name</u>
           Create HLS master playlist with the given name.

           For example:

                   ffmpeg -re -i in.ts -f hls -master_pl_name master.m3u8 <a href="http://example.com/live/out.m3u8">http://example.com/live/out.m3u8</a>

           creates    an    HLS    master    playlist    with   name   <u>master.m3u8</u>   which   is   published   at
           &lt;<b><a href="http://example.com/live/">http://example.com/live/</a></b>&gt;.

       <b>master_pl_publish_rate</b> <u>count</u>
           Publish master play list repeatedly every after specified number of segment intervals.

           For example:

                   ffmpeg -re -i in.ts -f hls -master_pl_name master.m3u8 \
                   -hls_time 2 -master_pl_publish_rate 30 <a href="http://example.com/live/out.m3u8">http://example.com/live/out.m3u8</a>

           creates an HLS master playlist with name <u>master.m3u8</u> and keeps publishing it repeatedly  every  after
           30 segments i.e. every after 60s.

       <b>http_persistent</b> <u>bool</u>
           Use persistent HTTP connections. Applicable only for HTTP output.

       <b>timeout</b> <u>timeout</u>
           Set timeout for socket I/O operations. Applicable only for HTTP output.

       <b>ignore_io_errors</b> <u>bool</u>
           Ignore IO errors during open, write and delete. Useful for long-duration runs with network output.

       <b>headers</b> <u>headers</u>
           Set custom HTTP headers, can override built in default headers. Applicable only for HTTP output.

   <b>iamf</b>
       Immersive Audio Model and Formats (IAMF) muxer.

       IAMF  is  used  to  provide  immersive  audio content for presentation on a wide range of devices in both
       streaming  and   offline   applications.   These   applications   include   internet   audio   streaming,
       multicasting/broadcasting  services, file download, gaming, communication, virtual and augmented reality,
       and others. In these applications, audio may be played back on a wide range of devices, e.g., headphones,
       mobile phones, tablets, TVs, sound bars, home theater systems, and big screens.

       This format was promoted and desgined by Alliance for Open Media.

       For more information about this format, see &lt;<b>https://aomedia.org/iamf/</b>&gt;.

   <b>ico</b>
       ICO file muxer.

       Microsoft's icon file format (ICO) has some strict limitations that should be noted:

       •   Size cannot exceed 256 pixels in any dimension

       •   Only BMP and PNG images can be stored

       •   If a BMP image is used, it must be one of the following pixel formats:

                   BMP Bit Depth      FFmpeg Pixel Format
                   1bit               pal8
                   4bit               pal8
                   8bit               pal8
                   16bit              rgb555le
                   24bit              bgr24
                   32bit              bgra

       •   If a BMP image is used, it must use the BITMAPINFOHEADER DIB header

       •   If a PNG image is used, it must use the rgba pixel format

   <b>ilbc</b>
       Internet Low Bitrate Codec (iLBC) raw muxer.

       It accepts a single <b>ilbc</b> audio stream.

   <b>image2,</b> <b>image2pipe</b>
       Image file muxer.

       The <b>image2</b> muxer writes video frames to image files.

       The output filenames are specified by a pattern, which can  be  used  to  produce  sequentially  numbered
       series  of  files.  The pattern may contain the string "%d" or "%0<u>N</u>d", this string specifies the position
       of the characters representing a numbering in the filenames. If the  form  "%0<u>N</u>d"  is  used,  the  string
       representing  the  number  in  each  filename  is  0-padded to <u>N</u> digits. The literal character '%' can be
       specified in the pattern with the string "%%".

       If the pattern contains "%d" or "%0<u>N</u>d", the first filename of the file list specified  will  contain  the
       number 1, all the following numbers will be sequential.

       The  pattern  may contain a suffix which is used to automatically determine the format of the image files
       to write.

       For example the pattern "img-%03d.bmp" will specify a sequence of  filenames  of  the  form  <u>img-001.bmp</u>,
       <u>img-002.bmp</u>,  ...,  <u>img-010.bmp</u>, etc.  The pattern "img%%-%d.jpg" will specify a sequence of filenames of
       the form <u>img%-1.jpg</u>, <u>img%-2.jpg</u>, ..., <u>img%-10.jpg</u>, etc.

       The image muxer supports the .Y.U.V image file format. This format is special in that  each  image  frame
       consists  of  three  files,  for each of the YUV420P components. To read or write this image file format,
       specify the name of the '.Y' file. The muxer will automatically open the '.U' and '.V' files as required.

       The <b>image2pipe</b> muxer accepts the same options as the <b>image2</b> muxer, but ignores the  pattern  verification
       and expansion, as it is supposed to write to the command output rather than to an actual stored file.

       <u>Options</u>

       <b>frame_pts</b> <u>bool</u>
           If set to 1, expand the filename with the packet PTS (presentation time stamp).  Default value is 0.

       <b>start_number</b> <u>count</u>
           Start the sequence from the specified number. Default value is 1.

       <b>update</b> <u>bool</u>
           If  set  to  1,  the  filename  will always be interpreted as just a filename, not a pattern, and the
           corresponding file will be continuously overwritten with new images. Default value is 0.

       <b>strftime</b> <u>bool</u>
           If set to 1, expand the filename with date and time information from strftime(). Default value is 0.

       <b>atomic_writing</b> <u>bool</u>
           Write output to a temporary file, which is renamed to target  filename  once  writing  is  completed.
           Default is disabled.

       <b>protocol_opts</b> <u>options_list</u>
           Set protocol options as a :-separated list of key=value parameters. Values containing the ":" special
           character must be escaped.

       <u>Examples</u>

       •   Use  <b>ffmpeg</b>  for creating a sequence of files <u>img-001.jpeg</u>, <u>img-002.jpeg</u>, ..., taking one image every
           second from the input video:

                   ffmpeg -i in.avi -vsync cfr -r 1 -f image2 'img-%03d.jpeg'

           Note that with <b>ffmpeg</b>, if the format is not specified with the "-f" option and  the  output  filename
           specifies  an  image file format, the image2 muxer is automatically selected, so the previous command
           can be written as:

                   ffmpeg -i in.avi -vsync cfr -r 1 'img-%03d.jpeg'

           Note also that the pattern must not necessarily contain "%d" or  "%0<u>N</u>d",  for  example  to  create  a
           single image file <u>img.jpeg</u> from the start of the input video you can employ the command:

                   ffmpeg -i in.avi -f image2 -frames:v 1 img.jpeg

       •   The  <b>strftime</b>  option  allows  you  to  expand the filename with date and time information. Check the
           documentation of the strftime() function for the syntax.

           To generate image files from the strftime() "%Y-%m-%d_%H-%M-%S" pattern, the following <b>ffmpeg</b> command
           can be used:

                   ffmpeg -f v4l2 -r 1 -i /dev/video0 -f image2 -strftime 1 "%Y-%m-%d_%H-%M-%S.jpg"

       •   Set the file name with current frame's PTS:

                   ffmpeg -f v4l2 -r 1 -i /dev/video0 -copyts -f image2 -frame_pts true %d.jpg

       •   Publish contents of your desktop directly to a WebDAV server every second:

                   ffmpeg -f x11grab -framerate 1 -i :0.0 -q:v 6 -update 1 -protocol_opts method=PUT <a href="http://example.com/desktop.jpg">http://example.com/desktop.jpg</a>

   <b>ircam</b>
       Berkeley / IRCAM / CARL Sound Filesystem (BICSF) format muxer.

       The Berkeley/IRCAM/CARL Sound Format, developed in the 1980s, is a  result  of  the  merging  of  several
       different  earlier  sound file formats and systems including the csound system developed by Dr Gareth Loy
       at the Computer Audio Research Lab (CARL) at UC San Diego, the IRCAM sound file system developed  by  Rob
       Gross  and  Dan  Timis at the Institut de Recherche et Coordination Acoustique / Musique in Paris and the
       Berkeley Fast Filesystem.

       It was developed initially as part of the Berkeley/IRCAM/CARL  Sound  Filesystem,  a  suite  of  programs
       designed  to  implement  a  filesystem  for  audio  applications  running  under  Berkeley  UNIX.  It was
       particularly popular in academic music research centres, and was used a number of times in  the  creation
       of early computer-generated compositions.

       This muxer accepts a single audio stream containing PCM data.

   <b>ivf</b>
       On2 IVF muxer.

       IVF was developed by On2 Technologies (formerly known as Duck Corporation), to store internally developed
       codecs.

       This muxer accepts a single <b>vp8</b>, <b>vp9</b>, or <b>av1</b> video stream.

   <b>jacosub</b>
       JACOsub subtitle format muxer.

       This muxer accepts a single <b>jacosub</b> subtitles stream.

       For more information about the format, see &lt;<b><a href="http://unicorn.us.com/jacosub/jscripts.html">http://unicorn.us.com/jacosub/jscripts.html</a></b>&gt;.

   <b>kvag</b>
       Simon &amp; Schuster Interactive VAG muxer.

       This  custom  VAG  container  is  used by some Simon &amp; Schuster Interactive games such as "Real War", and
       "Real War: Rogue States".

       This muxer accepts a single <b>adpcm_ima_ssi</b> audio stream.

   <b>lc3</b>
       Bluetooth SIG Low Complexity Communication  Codec  audio  (LC3),  or  ETSI  TS  103  634  Low  Complexity
       Communication Codec plus (LC3plus).

       This muxer accepts a single <b>lc3</b> audio stream.

   <b>lrc</b>
       LRC lyrics file format muxer.

       LRC  (short  for LyRiCs) is a computer file format that synchronizes song lyrics with an audio file, such
       as MP3, Vorbis, or MIDI.

       This muxer accepts a single <b>subrip</b> or <b>text</b> subtitles stream.

       <u>Metadata</u>

       The following metadata tags are converted to the format corresponding metadata:

       <b>title</b>
       <b>album</b>
       <b>artist</b>
       <b>author</b>
       <b>creator</b>
       <b>encoder</b>
       <b>encoder_version</b>

       If <b>encoder_version</b> is not explicitly set, it is automatically set to the libavformat version.

   <b>matroska</b>
       Matroska container muxer.

       This muxer implements the matroska and webm container specs.

       <u>Metadata</u>

       The recognized metadata settings in this muxer are:

       <b>title</b>
           Set title name provided to a single track. This gets mapped to  the  FileDescription  element  for  a
           stream written as attachment.

       <b>language</b>
           Specify the language of the track in the Matroska languages form.

           The  language  can be either the 3 letters bibliographic ISO-639-2 (ISO 639-2/B) form (like "fre" for
           French), or a language code mixed with a country code for specialities in  languages  (like  "fre-ca"
           for Canadian French).

       <b>stereo_mode</b>
           Set stereo 3D video layout of two views in a single video track.

           The following values are recognized:

           <b>mono</b>
               video is not stereo

           <b>left_right</b>
               Both views are arranged side by side, Left-eye view is on the left

           <b>bottom_top</b>
               Both views are arranged in top-bottom orientation, Left-eye view is at bottom

           <b>top_bottom</b>
               Both views are arranged in top-bottom orientation, Left-eye view is on top

           <b>checkerboard_rl</b>
               Each view is arranged in a checkerboard interleaved pattern, Left-eye view being first

           <b>checkerboard_lr</b>
               Each view is arranged in a checkerboard interleaved pattern, Right-eye view being first

           <b>row_interleaved_rl</b>
               Each view is constituted by a row based interleaving, Right-eye view is first row

           <b>row_interleaved_lr</b>
               Each view is constituted by a row based interleaving, Left-eye view is first row

           <b>col_interleaved_rl</b>
               Both views are arranged in a column based interleaving manner, Right-eye view is first column

           <b>col_interleaved_lr</b>
               Both views are arranged in a column based interleaving manner, Left-eye view is first column

           <b>anaglyph_cyan_red</b>
               All frames are in anaglyph format viewable through red-cyan filters

           <b>right_left</b>
               Both views are arranged side by side, Right-eye view is on the left

           <b>anaglyph_green_magenta</b>
               All frames are in anaglyph format viewable through green-magenta filters

           <b>block_lr</b>
               Both eyes laced in one Block, Left-eye view is first

           <b>block_rl</b>
               Both eyes laced in one Block, Right-eye view is first

       For example a 3D WebM clip can be created using the following command line:

               ffmpeg -i sample_left_right_clip.mpg -an -c:v libvpx -metadata stereo_mode=left_right -y stereo_clip.webm

       <u>Options</u>

       <b>reserve_index_space</b> <u>size</u>
           By default, this muxer writes the index for seeking (called cues in Matroska terms) at the end of the
           file, because it cannot know in advance how much space to leave for the index at the beginning of the
           file.  However  for  some  use  cases  -- e.g.  streaming where seeking is possible but slow -- it is
           useful to put the index at the beginning of the file.

           If this option is set to a non-zero value, the muxer will reserve <u>size</u> bytes of  space  in  the  file
           header  and then try to write the cues there when the muxing finishes. If the reserved space does not
           suffice, no Cues will be written, the file will be finalized and writing the trailer will  return  an
           error.  A safe size for most use cases should be about 50kB per hour of video.

           Note  that  cues are only written if the output is seekable and this option will have no effect if it
           is not.

       <b>cues_to_front</b> <u>bool</u>
           If set, the muxer will write the index at the beginning of the file by  shifting  the  main  data  if
           necessary.  This  can  be combined with reserve_index_space in which case the data is only shifted if
           the initially reserved space turns out to be insufficient.

           This option is ignored if the output is unseekable.

       <b>cluster_size_limit</b> <u>size</u>
           Store at most the provided amount of bytes in a cluster.

           If not specified, the limit is set automatically to a sensible hardcoded fixed value.

       <b>cluster_time_limit</b> <u>duration</u>
           Store at most the provided number of milliseconds in a cluster.

           If not specified, the limit is set automatically to a sensible hardcoded fixed value.

       <b>dash</b> <u>bool</u>
           Create a WebM file conforming to WebM DASH specification. By default it is set to "false".

       <b>dash_track_number</b> <u>index</u>
           Track number for the DASH stream. By default it is set to 1.

       <b>live</b> <u>bool</u>
           Write files assuming it is a live stream. By default it is set to "false".

       <b>allow_raw_vfw</b> <u>bool</u>
           Allow raw VFW mode. By default it is set to "false".

       <b>flipped_raw_rgb</b> <u>bool</u>
           If set to "true", store positive height for raw RGB bitmaps, which indicates bitmap is stored bottom-
           up. Note that this option does not flip the bitmap which has to be done manually beforehand, e.g.  by
           using the <b>vflip</b> filter.  Default is "false" and indicates bitmap is stored top down.

       <b>write_crc32</b> <u>bool</u>
           Write  a  CRC32  element inside every Level 1 element. By default it is set to "true". This option is
           ignored for WebM.

       <b>default_mode</b> <u>mode</u>
           Control how the FlagDefault of the output tracks will be set.  It  influences  which  tracks  players
           should play by default. The default mode is <b>passthrough</b>.

           <b>infer</b>
               Every  track with disposition default will have the FlagDefault set.  Additionally, for each type
               of track (audio, video or subtitle), if no track with disposition default of  this  type  exists,
               then  the first track of this type will be marked as default (if existing). This ensures that the
               default flag is set in a sensible way even if the input originated from containers that lack  the
               concept of default tracks.

           <b>infer_no_subs</b>
               This  mode is the same as infer except that if no subtitle track with disposition default exists,
               no subtitle track will be marked as default.

           <b>passthrough</b>
               In this mode the FlagDefault is set if and only if the AV_DISPOSITION_DEFAULT flag is set in  the
               disposition of the corresponding stream.

   <b>md5</b>
       MD5 testing format.

       This is a variant of the <b>hash</b> muxer. Unlike that muxer, it defaults to using the MD5 hash function.

       See also the <b>hash</b> and <b>framemd5</b> muxers.

       <u>Examples</u>

       •   To  compute  the  MD5  hash  of  the input converted to raw audio and video, and store it in the file
           <u>out.md5</u>:

                   ffmpeg -i INPUT -f md5 out.md5

       •   To print the MD5 hash to stdout:

                   ffmpeg -i INPUT -f md5 -

   <b>microdvd</b>
       MicroDVD subtitle format muxer.

       This muxer accepts a single <b>microdvd</b> subtitles stream.

   <b>mmf</b>
       Synthetic music Mobile Application Format (SMAF) format muxer.

       SMAF is a music data format specified by Yamaha for portable electronic devices, such  as  mobile  phones
       and personal digital assistants.

       This muxer accepts a single <b>adpcm_yamaha</b> audio stream.

   <b>mp3</b>
       The MP3 muxer writes a raw MP3 stream with the following optional features:

       •   An  ID3v2  metadata header at the beginning (enabled by default). Versions 2.3 and 2.4 are supported,
           the "id3v2_version" private option controls which one is used (3 or 4). Setting "id3v2_version" to  0
           disables the ID3v2 header completely.

           The  muxer  supports  writing  attached pictures (APIC frames) to the ID3v2 header.  The pictures are
           supplied to the muxer in form of a video stream with a single packet. There  can  be  any  number  of
           those  streams,  each  will  correspond  to  a single APIC frame.  The stream metadata tags <u>title</u> and
           <u>comment</u> map to APIC <u>description</u> and <u>picture</u> <u>type</u> respectively. See  &lt;<b><a href="http://id3.org/id3v2.4.0-frames">http://id3.org/id3v2.4.0-frames</a></b>&gt;
           for allowed picture types.

           Note that the APIC frames must be written at the beginning, so the muxer will buffer the audio frames
           until  it  gets all the pictures. It is therefore advised to provide the pictures as soon as possible
           to avoid excessive buffering.

       •   A Xing/LAME frame right after the ID3v2 header (if present). It is enabled by default,  but  will  be
           written  only  if  the output is seekable. The "write_xing" private option can be used to disable it.
           The frame contains various information that may be useful to the decoder, like the audio duration  or
           encoder delay.

       •   A  legacy  ID3v1  tag  at  the  end  of  the  file  (disabled by default). It may be enabled with the
           "write_id3v1" private option, but as its capabilities are very limited, its usage is not recommended.

       Examples:

       Write an mp3 with an ID3v2.3 header and an ID3v1 footer:

               ffmpeg -i INPUT -id3v2_version 3 -write_id3v1 1 out.mp3

       To attach a picture to an mp3 file select both the audio and the picture stream with "map":

               ffmpeg -i input.mp3 -i cover.png -c copy -map 0 -map 1
               -metadata:s:v title="Album cover" -metadata:s:v comment="Cover (Front)" out.mp3

       Write a "clean" MP3 without any extra features:

               ffmpeg -i input.wav -write_xing 0 -id3v2_version 0 out.mp3

   <b>mpegts</b>
       MPEG transport stream muxer.

       This muxer implements ISO 13818-1 and part of ETSI EN 300 468.

       The recognized metadata settings in mpegts muxer are "service_provider" and "service_name". If  they  are
       not set the default for "service_provider" is <b>FFmpeg</b> and the default for "service_name" is <b>Service01</b>.

       <u>Options</u>

       The muxer options are:

       <b>mpegts_transport_stream_id</b> <u>integer</u>
           Set the <b>transport_stream_id</b>. This identifies a transponder in DVB.  Default is 0x0001.

       <b>mpegts_original_network_id</b> <u>integer</u>
           Set  the  <b>original_network_id</b>.  This is unique identifier of a network in DVB. Its main use is in the
           unique identification of a service through the path <b>Original_Network_ID,</b> <b>Transport_Stream_ID</b>. Default
           is 0x0001.

       <b>mpegts_service_id</b> <u>integer</u>
           Set the <b>service_id</b>, also known as program in DVB. Default is 0x0001.

       <b>mpegts_service_type</b> <u>integer</u>
           Set the program <b>service_type</b>. Default is "digital_tv".  Accepts the following options:

           <b>hex_value</b>
               Any hexadecimal value between 0x01 and 0xff as defined in ETSI 300 468.

           <b>digital_tv</b>
               Digital TV service.

           <b>digital_radio</b>
               Digital Radio service.

           <b>teletext</b>
               Teletext service.

           <b>advanced_codec_digital_radio</b>
               Advanced Codec Digital Radio service.

           <b>mpeg2_digital_hdtv</b>
               MPEG2 Digital HDTV service.

           <b>advanced_codec_digital_sdtv</b>
               Advanced Codec Digital SDTV service.

           <b>advanced_codec_digital_hdtv</b>
               Advanced Codec Digital HDTV service.

       <b>mpegts_pmt_start_pid</b> <u>integer</u>
           Set the first PID for PMTs. Default is 0x1000, minimum is 0x0020, maximum is 0x1ffa. This option  has
           no effect in m2ts mode where the PMT PID is fixed 0x0100.

       <b>mpegts_start_pid</b> <u>integer</u>
           Set  the  first  PID for elementary streams. Default is 0x0100, minimum is 0x0020, maximum is 0x1ffa.
           This option has no effect in m2ts mode where the elementary stream PIDs are fixed.

       <b>mpegts_m2ts_mode</b> <u>boolean</u>
           Enable m2ts mode if set to 1. Default value is -1 which disables m2ts mode.

       <b>muxrate</b> <u>integer</u>
           Set a constant muxrate. Default is VBR.

       <b>pes_payload_size</b> <u>integer</u>
           Set minimum PES packet payload in bytes. Default is 2930.

       <b>mpegts_flags</b> <u>flags</u>
           Set mpegts flags. Accepts the following options:

           <b>resend_headers</b>
               Reemit PAT/PMT before writing the next packet.

           <b>latm</b>
               Use LATM packetization for AAC.

           <b>pat_pmt_at_frames</b>
               Reemit PAT and PMT at each video frame.

           <b>system_b</b>
               Conform to System B (DVB) instead of System A (ATSC).

           <b>initial_discontinuity</b>
               Mark the initial packet of each stream as discontinuity.

           <b>nit</b> Emit NIT table.

           <b>omit_rai</b>
               Disable writing of random access indicator.

       <b>mpegts_copyts</b> <u>boolean</u>
           Preserve original timestamps, if value is set to 1. Default value is -1, which  results  in  shifting
           timestamps so that they start from 0.

       <b>omit_video_pes_length</b> <u>boolean</u>
           Omit the PES packet length for video packets. Default is 1 (true).

       <b>pcr_period</b> <u>integer</u>
           Override  the default PCR retransmission time in milliseconds. Default is -1 which means that the PCR
           interval will be determined automatically: 20 ms is used for CBR streams, the highest multiple of the
           frame duration which is less than 100 ms is used for VBR streams.

       <b>pat_period</b> <u>duration</u>
           Maximum time in seconds between PAT/PMT tables. Default is 0.1.

       <b>sdt_period</b> <u>duration</u>
           Maximum time in seconds between SDT tables. Default is 0.5.

       <b>nit_period</b> <u>duration</u>
           Maximum time in seconds between NIT tables. Default is 0.5.

       <b>tables_version</b> <u>integer</u>
           Set PAT, PMT, SDT and NIT version (default 0, valid values are from  0  to  31,  inclusively).   This
           option  allows  updating  stream structure so that standard consumer may detect the change. To do so,
           reopen output "AVFormatContext" (in case  of  API  usage)  or  restart  <b>ffmpeg</b>  instance,  cyclically
           changing <b>tables_version</b> value:

                   ffmpeg -i source1.ts -codec copy -f mpegts -tables_version 0 udp://1.1.1.1:1111
                   ffmpeg -i source2.ts -codec copy -f mpegts -tables_version 1 udp://1.1.1.1:1111
                   ...
                   ffmpeg -i source3.ts -codec copy -f mpegts -tables_version 31 udp://1.1.1.1:1111
                   ffmpeg -i source1.ts -codec copy -f mpegts -tables_version 0 udp://1.1.1.1:1111
                   ffmpeg -i source2.ts -codec copy -f mpegts -tables_version 1 udp://1.1.1.1:1111
                   ...

       <u>Example</u>

               ffmpeg -i file.mpg -c copy \
                    -mpegts_original_network_id 0x1122 \
                    -mpegts_transport_stream_id 0x3344 \
                    -mpegts_service_id 0x5566 \
                    -mpegts_pmt_start_pid 0x1500 \
                    -mpegts_start_pid 0x150 \
                    -metadata service_provider="Some provider" \
                    -metadata service_name="Some Channel" \
                    out.ts

   <b>mxf,</b> <b>mxf_d10,</b> <b>mxf_opatom</b>
       MXF muxer.

       <u>Options</u>

       The muxer options are:

       <b>store_user_comments</b> <u>bool</u>
           Set  if user comments should be stored if available or never.  IRT D-10 does not allow user comments.
           The default is thus to write them for mxf and mxf_opatom but not for mxf_d10

   <b>null</b>
       Null muxer.

       This muxer does not generate any output file, it is mainly useful for testing or benchmarking purposes.

       For example to benchmark decoding with <b>ffmpeg</b> you can use the command:

               ffmpeg -benchmark -i INPUT -f null out.null

       Note that the above command does not read or write the <u>out.null</u> file, but specifying the output  file  is
       required by the <b>ffmpeg</b> syntax.

       Alternatively you can write the command as:

               ffmpeg -benchmark -i INPUT -f null -

   <b>nut</b>
       <b>-syncpoints</b> <u>flags</u>
           Change the syncpoint usage in nut:

           <u>default</u> <b>use</b> <b>the</b> <b>normal</b> <b>low-overhead</b> <b>seeking</b> <b>aids.</b>
           <u>none</u> <b>do</b> <b>not</b> <b>use</b> <b>the</b> <b>syncpoints</b> <b>at</b> <b>all,</b> <b>reducing</b> <b>the</b> <b>overhead</b> <b>but</b> <b>making</b> <b>the</b> <b>stream</b> <b>non-seekable;</b>
                   Use of this option is not recommended, as the resulting files are very damage
                   sensitive and seeking is not possible. Also in general the overhead from
                   syncpoints is negligible. Note, -C&lt;write_index&gt; 0 can be used to disable
                   all growing data tables, allowing to mux endless streams with limited memory
                   and without these disadvantages.

           <u>timestamped</u> <b>extend</b> <b>the</b> <b>syncpoint</b> <b>with</b> <b>a</b> <b>wallclock</b> <b>field.</b>

           The <u>none</u> and <u>timestamped</u> flags are experimental.

       <b>-write_index</b> <u>bool</u>
           Write index at the end, the default is to write an index.

               ffmpeg -i INPUT -f_strict experimental -syncpoints none - | processor

   <b>ogg</b>
       Ogg container muxer.

       <b>-page_duration</b> <u>duration</u>
           Preferred  page  duration,  in  microseconds.  The  muxer  will  attempt  to  create  pages  that are
           approximately <u>duration</u> microseconds long. This allows the user to compromise between seek granularity
           and container overhead. The default is 1 second. A value of 0 will fill all segments, making pages as
           large as possible. A value of 1 will effectively use 1 packet-per-page in most situations,  giving  a
           small seek granularity at the cost of additional container overhead.

       <b>-serial_offset</b> <u>value</u>
           Serial  value  from which to set the streams serial number.  Setting it to different and sufficiently
           large values ensures that the produced ogg files can be safely chained.

   <b>rcwt</b>
       RCWT (Raw Captions With Time) is a format native to ccextractor, a commonly used  open  source  tool  for
       processing  608/708  Closed  Captions  (CC) sources.  It can be used to archive the original extracted CC
       bitstream and to produce a source file  for  later  processing  or  conversion.  The  format  allows  for
       interoperability  between  ccextractor and FFmpeg, is simple to parse, and can be used to create a backup
       of the CC presentation.

       This muxer implements the specification as of March 2024, which has been stable and unchanged since April
       2014.

       This muxer will have some nuances from the way that ccextractor muxes RCWT.  No compatibility issues when
       processing the output with ccextractor have been observed as a result of this so  far,  but  mileage  may
       vary and outputs will not be a bit-exact match.

       A         free         specification        of        RCWT        can        be        found        here:
       &lt;<b>https://github.com/CCExtractor/ccextractor/blob/master/docs/BINARY_FILE_FORMAT.TXT</b>&gt;

       <u>Examples</u>

       •   Extract Closed Captions to RCWT using lavfi:

                   ffmpeg -f lavfi -i "movie=INPUT.mkv[out+subcc]" -map 0:s:0 -c:s copy -f rcwt CC.rcwt.bin

   <b>segment,</b> <b>stream_segment,</b> <b>ssegment</b>
       Basic stream segmenter.

       This muxer outputs streams to a number of separate  files  of  nearly  fixed  duration.  Output  filename
       pattern  can  be  set  in  a fashion similar to <b>image2</b>, or by using a "strftime" template if the <b>strftime</b>
       option is enabled.

       "stream_segment" is a variant of the muxer used to write to streaming output formats, i.e. which  do  not
       require  global  headers,  and  is  recommended  for  outputting  e.g. to MPEG transport stream segments.
       "ssegment" is a shorter alias for "stream_segment".

       Every segment starts with a keyframe  of  the  selected  reference  stream,  which  is  set  through  the
       <b>reference_stream</b> option.

       Note  that  if  you  want  accurate  splitting  for  a  video file, you need to make the input key frames
       correspond to the exact splitting times expected by the segmenter, or the segment muxer  will  start  the
       new segment with the key frame found next after the specified start time.

       The segment muxer works best with a single constant frame rate video.

       Optionally  it  can generate a list of the created segments, by setting the option <u>segment_list</u>. The list
       type is specified by the <u>segment_list_type</u> option. The entry filenames in the segment  list  are  set  by
       default to the basename of the corresponding segment files.

       See also the <b>hls</b> muxer, which provides a more specific implementation for HLS segmentation.

       <u>Options</u>

       The segment muxer supports the following options:

       <b>increment_tc</b> <u>1|0</u>
           if  set  to  1, increment timecode between each segment If this is selected, the input need to have a
           timecode in the first video stream. Default value is 0.

       <b>reference_stream</b> <u>specifier</u>
           Set the reference stream, as specified by the string <u>specifier</u>.  If <u>specifier</u> is set to  "auto",  the
           reference  is  chosen  automatically.  Otherwise  it  must  be  a  stream specifier (see the ``Stream
           specifiers'' chapter in the ffmpeg manual) which specifies the reference stream. The default value is
           "auto".

       <b>segment_format</b> <u>format</u>
           Override the inner container format, by default it is guessed by the filename extension.

       <b>segment_format_options</b> <u>options_list</u>
           Set output format options using a :-separated list of key=value parameters. Values containing the ":"
           special character must be escaped.

       <b>segment_list</b> <u>name</u>
           Generate also a listfile named <u>name</u>. If not specified no listfile is generated.

       <b>segment_list_flags</b> <u>flags</u>
           Set flags affecting the segment list generation.

           It currently supports the following flags:

           <b>cache</b>
               Allow caching (only affects M3U8 list files).

           <b>live</b>
               Allow live-friendly file generation.

       <b>segment_list_size</b> <u>size</u>
           Update the list file so that it contains at most <u>size</u> segments. If 0 the list file will  contain  all
           the segments. Default value is 0.

       <b>segment_list_entry_prefix</b> <u>prefix</u>
           Prepend <u>prefix</u> to each entry. Useful to generate absolute paths.  By default no prefix is applied.

       <b>segment_list_type</b> <u>type</u>
           Select the listing format.

           The following values are recognized:

           <b>flat</b>
               Generate a flat list for the created segments, one segment per line.

           <b>csv,</b> <b>ext</b>
               Generate  a  list  for  the created segments, one segment per line, each line matching the format
               (comma-separated values):

                       &lt;segment_filename&gt;,&lt;segment_start_time&gt;,&lt;segment_end_time&gt;

               <u>segment_filename</u> is the name of the output file generated by the muxer according to the  provided
               pattern. CSV escaping (according to RFC4180) is applied if required.

               <u>segment_start_time</u>  and  <u>segment_end_time</u>  specify  the  segment  start and end time expressed in
               seconds.

               A list file with the suffix ".csv" or ".ext" will auto-select this format.

               <b>ext</b> is deprecated in favor or <b>csv</b>.

           <b>ffconcat</b>
               Generate an ffconcat file for the created segments. The resulting file  can  be  read  using  the
               FFmpeg <b>concat</b> demuxer.

               A list file with the suffix ".ffcat" or ".ffconcat" will auto-select this format.

           <b>m3u8</b>
               Generate      an      extended      M3U8      file,      version      3,      compliant      with
               &lt;<b><a href="http://tools.ietf.org/id/draft-pantos-http-live-streaming">http://tools.ietf.org/id/draft-pantos-http-live-streaming</a></b>&gt;.

               A list file with the suffix ".m3u8" will auto-select this format.

           If not specified the type is guessed from the list file name suffix.

       <b>segment_time</b> <u>time</u>
           Set segment duration to <u>time</u>, the value must be a duration specification. Default value is  "2".  See
           also the <b>segment_times</b> option.

           Note  that  splitting  may  not  be accurate, unless you force the reference stream key-frames at the
           given time. See the introductory notice and the examples below.

       <b>min_seg_duration</b> <u>time</u>
           Set minimum segment duration to <u>time</u>, the value must be a duration specification. This  prevents  the
           muxer  ending  segments  at  a duration below this value. Only effective with "segment_time". Default
           value is "0".

       <b>segment_atclocktime</b> <u>1|0</u>
           If set to "1" split at regular clock time intervals starting  from  00:00  o'clock.  The  <u>time</u>  value
           specified in <b>segment_time</b> is used for setting the length of the splitting interval.

           For  example  with <b>segment_time</b> set to "900" this makes it possible to create files at 12:00 o'clock,
           12:15, 12:30, etc.

           Default value is "0".

       <b>segment_clocktime_offset</b> <u>duration</u>
           Delay the segment splitting times with the specified duration when using <b>segment_atclocktime</b>.

           For example with <b>segment_time</b> set to "900" and <b>segment_clocktime_offset</b> set to "300"  this  makes  it
           possible to create files at 12:05, 12:20, 12:35, etc.

           Default value is "0".

       <b>segment_clocktime_wrap_duration</b> <u>duration</u>
           Force  the  segmenter  to only start a new segment if a packet reaches the muxer within the specified
           duration after the segmenting clock time. This way you can  make  the  segmenter  more  resilient  to
           backward  local time jumps, such as leap seconds or transition to standard time from daylight savings
           time.

           Default is the maximum possible duration which means starting a new segment regardless of the elapsed
           time since the last clock time.

       <b>segment_time_delta</b> <u>delta</u>
           Specify the accuracy time when selecting the start time  for  a  segment,  expressed  as  a  duration
           specification. Default value is "0".

           When delta is specified a key-frame will start a new segment if its PTS satisfies the relation:

                   PTS &gt;= start_time - time_delta

           This  option is useful when splitting video content, which is always split at GOP boundaries, in case
           a key frame is found just before the specified split time.

           In particular may be used in combination with the <u>ffmpeg</u> option <u>force_key_frames</u>. The key frame times
           specified by <u>force_key_frames</u> may not  be  set  accurately  because  of  rounding  issues,  with  the
           consequence  that  a key frame time may result set just before the specified time. For constant frame
           rate videos a value of 1/(2*<u>frame_rate</u>) should address the worst case mismatch between the  specified
           time and the time set by <u>force_key_frames</u>.

       <b>segment_times</b> <u>times</u>
           Specify  a list of split points. <u>times</u> contains a list of comma separated duration specifications, in
           increasing order. See also the <b>segment_time</b> option.

       <b>segment_frames</b> <u>frames</u>
           Specify a list of split video frame numbers. <u>frames</u>  contains  a  list  of  comma  separated  integer
           numbers, in increasing order.

           This  option  specifies to start a new segment whenever a reference stream key frame is found and the
           sequential number (starting from 0) of the frame is greater or equal to the next value in the list.

       <b>segment_wrap</b> <u>limit</u>
           Wrap around segment index once it reaches <u>limit</u>.

       <b>segment_start_number</b> <u>number</u>
           Set the sequence number of the first segment. Defaults to 0.

       <b>strftime</b> <u>1|0</u>
           Use the "strftime" function to define the name of the new segments to write. If this is selected, the
           output segment name must contain a "strftime" function template. Default value is 0.

       <b>break_non_keyframes</b> <u>1|0</u>
           If enabled, allow segments to start on frames other than keyframes. This improves  behavior  on  some
           players when the time between keyframes is inconsistent, but may make things worse on others, and can
           cause some oddities during seeking. Defaults to 0.

       <b>reset_timestamps</b> <u>1|0</u>
           Reset  timestamps  at  the  beginning of each segment, so that each segment will start with near-zero
           timestamps. It is meant to ease the playback of the  generated  segments.  May  not  work  with  some
           combinations of muxers/codecs. It is set to 0 by default.

       <b>initial_offset</b> <u>offset</u>
           Specify  timestamp  offset  to  apply  to  the  output packet timestamps. The argument must be a time
           duration specification, and defaults to 0.

       <b>write_empty_segments</b> <u>1|0</u>
           If enabled, write an empty segment if there are no packets during the period a segment would  usually
           span. Otherwise, the segment will be filled with the next packet written. Defaults to 0.

       Make  sure  to  require  a  closed  GOP  when  encoding  and to set the GOP size to fit your segment time
       constraint.

       <u>Examples</u>

       •   Remux the content of file <u>in.mkv</u> to a list of segments <u>out-000.nut</u>, <u>out-001.nut</u>, etc., and write  the
           list of generated segments to <u>out.list</u>:

                   ffmpeg -i in.mkv -codec hevc -flags +cgop -g 60 -map 0 -f segment -segment_list out.list out%03d.nut

       •   Segment input and set output format options for the output segments:

                   ffmpeg -i in.mkv -f segment -segment_time 10 -segment_format_options movflags=+faststart out%03d.mp4

       •   Segment the input file according to the split points specified by the <u>segment_times</u> option:

                   ffmpeg -i in.mkv -codec copy -map 0 -f segment -segment_list out.csv -segment_times 1,2,3,5,8,13,21 out%03d.nut

       •   Use  the  <b>ffmpeg</b>  <b>force_key_frames</b> option to force key frames in the input at the specified location,
           together with the segment option <b>segment_time_delta</b> to account for possible roundings  operated  when
           setting key frame times.

                   ffmpeg -i in.mkv -force_key_frames 1,2,3,5,8,13,21 -codec:v mpeg4 -codec:a pcm_s16le -map 0 \
                   -f segment -segment_list out.csv -segment_times 1,2,3,5,8,13,21 -segment_time_delta 0.05 out%03d.nut

           In order to force key frames on the input file, transcoding is required.

       •   Segment  the input file by splitting the input file according to the frame numbers sequence specified
           with the <b>segment_frames</b> option:

                   ffmpeg -i in.mkv -codec copy -map 0 -f segment -segment_list out.csv -segment_frames 100,200,300,500,800 out%03d.nut

       •   Convert the <u>in.mkv</u> to TS segments using the "libx264" and "aac" encoders:

                   ffmpeg -i in.mkv -map 0 -codec:v libx264 -codec:a aac -f ssegment -segment_list out.list out%03d.ts

       •   Segment the input file, and create an M3U8 live playlist (can be used as live HLS source):

                   ffmpeg -re -i in.mkv -codec copy -map 0 -f segment -segment_list playlist.m3u8 \
                   -segment_list_flags +live -segment_time 10 out%03d.mkv

   <b>smoothstreaming</b>
       Smooth Streaming muxer generates a set of files (Manifest, chunks) suitable for serving with conventional
       web server.

       <b>window_size</b>
           Specify the number of fragments kept in the manifest. Default 0 (keep all).

       <b>extra_window_size</b>
           Specify the number of fragments kept outside of the manifest before removing from disk. Default 5.

       <b>lookahead_count</b>
           Specify the number of lookahead fragments. Default 2.

       <b>min_frag_duration</b>
           Specify the minimum fragment duration (in microseconds). Default 5000000.

       <b>remove_at_exit</b>
           Specify whether to remove all fragments when finished. Default 0 (do not remove).

   <b>streamhash</b>
       Per stream hash testing format.

       This muxer computes and prints a cryptographic hash of all the input frames, on a per-stream basis.  This
       can be used for equality checks without having to do a complete binary comparison.

       By  default  audio  frames  are converted to signed 16-bit raw audio and video frames to raw video before
       computing the hash, but the output of explicit conversions to other codecs can also be  used.  Timestamps
       are  ignored.  It  uses  the  SHA-256  cryptographic hash function by default, but supports several other
       algorithms.

       The output of the muxer consists of one line per stream of  the  form:  <u>streamindex</u>,<u>streamtype</u>,<u>algo</u>=<u>hash</u>,
       where <u>streamindex</u> is the index of the mapped stream, <u>streamtype</u> is a single character indicating the type
       of  stream,  <u>algo</u> is a short string representing the hash function used, and <u>hash</u> is a hexadecimal number
       representing the computed hash.

       <b>hash</b> <u>algorithm</u>
           Use the cryptographic hash function specified by the  string  <u>algorithm</u>.   Supported  values  include
           "MD5",  "murmur3",  "RIPEMD128",  "RIPEMD160", "RIPEMD256", "RIPEMD320", "SHA160", "SHA224", "SHA256"
           (default), "SHA512/224", "SHA512/256", "SHA384", "SHA512", "CRC32" and "adler32".

       <u>Examples</u>

       To compute the SHA-256 hash of the input converted to raw audio and video,  and  store  it  in  the  file
       <u>out.sha256</u>:

               ffmpeg -i INPUT -f streamhash out.sha256

       To print an MD5 hash to stdout use the command:

               ffmpeg -i INPUT -f streamhash -hash md5 -

       See also the <b>hash</b> and <b>framehash</b> muxers.

   <b>tee</b>
       The tee muxer can be used to write the same data to several outputs, such as files or streams.  It can be
       used, for example, to stream a video over a network and save it to disk at the same time.

       It  is different from specifying several outputs to the <b>ffmpeg</b> command-line tool. With the tee muxer, the
       audio and video data will be encoded only once.  With conventional multiple  outputs,  multiple  encoding
       operations  in parallel are initiated, which can be a very expensive process. The tee muxer is not useful
       when using the libavformat API directly because it is then possible to feed the same packets  to  several
       muxers directly.

       Since  the  tee  muxer  does not represent any particular output format, ffmpeg cannot auto-select output
       streams. So all streams intended for output must be specified using "-map". See the examples below.

       Some encoders may need different options depending on the output format; the auto-detection of  this  can
       not  work  with  the  tee  muxer,  so  they  need  to  be  explicitly specified.  The main example is the
       <b>global_header</b> flag.

       The slave outputs are specified in the file name given to the muxer, separated by  '|'.  If  any  of  the
       slave name contains the '|' separator, leading or trailing spaces or any special character, those must be
       escaped (see <b>the</b> <b>"Quoting</b> <b>and</b> <b>escaping"</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>).

       <u>Options</u>

       <b>use_fifo</b> <u>bool</u>
           If set to 1, slave outputs will be processed in separate threads using the <b>fifo</b> muxer. This allows to
           compensate  for  different  speed/latency/reliability  of  outputs and setup transparent recovery. By
           default this feature is turned off.

       <b>fifo_options</b>
           Options to pass to fifo pseudo-muxer instances. See <b>fifo</b>.

       Muxer options can be specified for each slave by prepending them as a list of <u>key</u>=<u>value</u>  pairs  separated
       by  ':', between square brackets. If the options values contain a special character or the ':' separator,
       they must be escaped; note that this is a second level escaping.

       The following special options are also recognized:

       <b>f</b>   Specify the format name. Required if it cannot be guessed from the output URL.

       <b>bsfs[/</b><u>spec</u><b>]</b>
           Specify a list of bitstream filters to apply to the specified output.

           It is possible to specify to which streams a given bitstream filter applies, by  appending  a  stream
           specifier  to  the  option  separated  by  "/".  <u>spec</u>  must  be a stream specifier (see <b>Format</b> <b>stream</b>
           <b>specifiers</b>).

           If the stream specifier is not specified, the bitstream filters will be applied to all streams in the
           output. This will cause that output operation to fail if the output contains  streams  to  which  the
           bitstream  filter  cannot be applied e.g. "h264_mp4toannexb" being applied to an output containing an
           audio stream.

           Options for a bitstream filter must be specified in the form of "opt=value".

           Several bitstream filters can be specified, separated by ",".

       <b>use_fifo</b> <u>bool</u>
           This allows to override tee muxer use_fifo option for individual slave muxer.

       <b>fifo_options</b>
           This allows to override tee muxer fifo_options for individual slave muxer.  See <b>fifo</b>.

       <b>select</b>
           Select the streams that should be mapped to the slave output, specified by a stream specifier. If not
           specified, this defaults to all the mapped streams. This will cause that output operation to fail  if
           the output format does not accept all mapped streams.

           You may use multiple stream specifiers separated by commas (",") e.g.: "a:0,v"

       <b>onfail</b>
           Specify  behaviour  on  output  failure.  This  can  be  set  to either "abort" (which is default) or
           "ignore". "abort" will cause whole process to fail in case of failure on this slave output.  "ignore"
           will ignore failure on this output, so other outputs will continue without being affected.

       <u>Examples</u>

       •   Encode something and both archive it in a WebM file and stream it as MPEG-TS over UDP:

                   ffmpeg -i ... -c:v libx264 -c:a mp2 -f tee -map 0:v -map 0:a
                     "archive-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/"

       •   As  above,  but  continue streaming even if output to local file fails (for example local drive fills
           up):

                   ffmpeg -i ... -c:v libx264 -c:a mp2 -f tee -map 0:v -map 0:a
                     "[onfail=ignore]archive-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/"

       •   Use <b>ffmpeg</b> to encode the input, and send the output to three different destinations. The "dump_extra"
           bitstream filter is used to add extradata information to all the output video keyframes  packets,  as
           requested  by the MPEG-TS format. The select option is applied to <u>out.aac</u> in order to make it contain
           only audio packets.

                   ffmpeg -i ... -map 0 -flags +global_header -c:v libx264 -c:a aac
                          -f tee "[bsfs/v=dump_extra=freq=keyframe]out.ts|[movflags=+faststart]out.mp4|[select=a]out.aac"

       •   As above, but select only stream "a:1" for the audio output. Note that a second level  escaping  must
           be performed, as ":" is a special character used to separate options.

                   ffmpeg -i ... -map 0 -flags +global_header -c:v libx264 -c:a aac
                          -f tee "[bsfs/v=dump_extra=freq=keyframe]out.ts|[movflags=+faststart]out.mp4|[select=\'a:1\']out.aac"

   <b>webm_chunk</b>
       WebM Live Chunk Muxer.

       This  muxer  writes  out  WebM headers and chunks as separate files which can be consumed by clients that
       support WebM Live streams via DASH.

       <u>Options</u>

       This muxer supports the following options:

       <b>chunk_start_index</b>
           Index of the first chunk (defaults to 0).

       <b>header</b>
           Filename of the header where the initialization data will be written.

       <b>audio_chunk_duration</b>
           Duration of each audio chunk in milliseconds (defaults to 5000).

       <u>Example</u>

               ffmpeg -f v4l2 -i /dev/video0 \
                      -f alsa -i hw:0 \
                      -map 0:0 \
                      -c:v libvpx-vp9 \
                      -s 640x360 -keyint_min 30 -g 30 \
                      -f webm_chunk \
                      -header webm_live_video_360.hdr \
                      -chunk_start_index 1 \
                      webm_live_video_360_%d.chk \
                      -map 1:0 \
                      -c:a libvorbis \
                      -b:a 128k \
                      -f webm_chunk \
                      -header webm_live_audio_128.hdr \
                      -chunk_start_index 1 \
                      -audio_chunk_duration 1000 \
                      webm_live_audio_128_%d.chk

   <b>webm_dash_manifest</b>
       WebM DASH Manifest muxer.

       This muxer implements the WebM DASH Manifest specification to generate the DASH  manifest  XML.  It  also
       supports manifest generation for DASH live streams.

       For more information see:

       •   WebM                                        DASH                                       Specification:
           &lt;<b>https://sites.google.com/a/webmproject.org/wiki/adaptive-streaming/webm-dash-specification</b>&gt;

       •   ISO                                        DASH                                        Specification:
           &lt;<b><a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c065274_ISO_IEC_23009-1_2014.zip">http://standards.iso.org/ittf/PubliclyAvailableStandards/c065274_ISO_IEC_23009-1_2014.zip</a></b>&gt;

       <u>Options</u>

       This muxer supports the following options:

       <b>adaptation_sets</b>
           This  option  has  the  following syntax: "id=x,streams=a,b,c id=y,streams=d,e" where x and y are the
           unique identifiers of the adaptation sets and a,b,c,d and e are  the  indices  of  the  corresponding
           audio and video streams. Any number of adaptation sets can be added using this option.

       <b>live</b>
           Set this to 1 to create a live stream DASH Manifest. Default: 0.

       <b>chunk_start_index</b>
           Start  index  of  the  first  chunk. This will go in the <b>startNumber</b> attribute of the <b>SegmentTemplate</b>
           element in the manifest. Default: 0.

       <b>chunk_duration_ms</b>
           Duration of each chunk in milliseconds. This will go in the <b>duration</b> attribute of the <b>SegmentTemplate</b>
           element in the manifest. Default: 1000.

       <b>utc_timing_url</b>
           URL of the page that will return the UTC timestamp in ISO format. This will go in the <b>value</b> attribute
           of the <b>UTCTiming</b> element in the manifest.  Default: None.

       <b>time_shift_buffer_depth</b>
           Smallest time (in seconds)  shifting  buffer  for  which  any  Representation  is  guaranteed  to  be
           available. This will go in the <b>timeShiftBufferDepth</b> attribute of the <b>MPD</b> element. Default: 60.

       <b>minimum_update_period</b>
           Minimum update period (in seconds) of the manifest. This will go in the <b>minimumUpdatePeriod</b> attribute
           of the <b>MPD</b> element. Default: 0.

       <u>Example</u>

               ffmpeg -f webm_dash_manifest -i video1.webm \
                      -f webm_dash_manifest -i video2.webm \
                      -f webm_dash_manifest -i audio1.webm \
                      -f webm_dash_manifest -i audio2.webm \
                      -map 0 -map 1 -map 2 -map 3 \
                      -c copy \
                      -f webm_dash_manifest \
                      -adaptation_sets "id=0,streams=0,1 id=1,streams=2,3" \
                      manifest.xml

</pre><h4><b>METADATA</b></h4><pre>
       FFmpeg  is able to dump metadata from media files into a simple UTF-8-encoded INI-like text file and then
       load it back using the metadata muxer/demuxer.

       The file format is as follows:

       1.  A file consists of a header and a number of metadata tags divided into  sections,  each  on  its  own
           line.

       2.  The header is a <b>;FFMETADATA</b> string, followed by a version number (now 1).

       3.  Metadata tags are of the form <b>key=value</b>

       4.  Immediately after header follows global metadata

       5.  After global metadata there may be sections with per-stream/per-chapter metadata.

       6.  A  section  starts with the section name in uppercase (i.e. STREAM or CHAPTER) in brackets (<b>[</b>, <b>]</b>) and
           ends with next section or end of file.

       7.  At the beginning of a chapter section there may be an optional timebase  to  be  used  for  start/end
           values.  It  must  be  in  form  <b>TIMEBASE=</b><u>num</u><b>/</b><u>den</u>, where <u>num</u> and <u>den</u> are integers. If the timebase is
           missing then start/end times are assumed to be in nanoseconds.

           Next a chapter section must contain chapter start and end times in form <b>START=</b><u>num</u>, <b>END=</b><u>num</u>, where <u>num</u>
           is a positive integer.

       8.  Empty lines and lines starting with <b>;</b> or <b>#</b> are ignored.

       9.  Metadata keys or values containing special characters (<b>=</b>, <b>;</b>, <b>#</b>, <b>\</b> and a newline) must be escaped with
           a backslash <b>\</b>.

       10. Note that whitespace in metadata (e.g. <b>foo</b> <b>=</b> <b>bar</b>) is considered to be a  part  of  the  tag  (in  the
           example above key is <b>foo</b> , value is
            <b>bar</b>).

       A ffmetadata file might look like this:

               ;FFMETADATA1
               title=bike\\shed
               ;this is a comment
               artist=FFmpeg troll team

               [CHAPTER]
               TIMEBASE=1/1000
               START=0
               #chapter ends at 0:01:00
               END=60000
               title=chapter \#1
               [STREAM]
               title=multi\
               line

       By  using  the  ffmetadata  muxer and demuxer it is possible to extract metadata from an input file to an
       ffmetadata file, and then transcode the file into an output file with the edited ffmetadata file.

       Extracting an ffmetadata file with <u>ffmpeg</u> goes as follows:

               ffmpeg -i INPUT -f ffmetadata FFMETADATAFILE

       Reinserting edited metadata information from the FFMETADATAFILE file can be done as:

               ffmpeg -i INPUT -i FFMETADATAFILE -map_metadata 1 -codec copy OUTPUT

</pre><h4><b>PROTOCOL</b> <b>OPTIONS</b></h4><pre>
       The libavformat library provides some generic global options, which can be set on all the  protocols.  In
       addition each protocol may support so-called private options, which are specific for that component.

       Options may be set by specifying -<u>option</u> <u>value</u> in the FFmpeg tools, or by setting the value explicitly in
       the "AVFormatContext" options or using the <u>libavutil/opt.h</u> API for programmatic use.

       The list of supported options follows:

       <b>protocol_whitelist</b> <u>list</u> <b>(</b><u>input</u><b>)</b>
           Set a ","-separated list of allowed protocols. "ALL" matches all protocols. Protocols prefixed by "-"
           are disabled.  All protocols are allowed by default but protocols used by an another protocol (nested
           protocols) are restricted to a per protocol subset.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       Protocols  are  configured  elements  in  FFmpeg  that  enable  access to resources that require specific
       protocols.

       When you configure your FFmpeg build, all the supported protocols are enabled by default.  You  can  list
       all available ones using the configure option "--list-protocols".

       You  can  disable  all  the  protocols  using the configure option "--disable-protocols", and selectively
       enable a protocol using the option "--enable-protocol=<u>PROTOCOL</u>", or you can disable a particular protocol
       using the option "--disable-protocol=<u>PROTOCOL</u>".

       The option "-protocols" of the ff* tools will display the list of supported protocols.

       All protocols accept the following options:

       <b>rw_timeout</b>
           Maximum time to wait for (network) read/write operations to complete, in microseconds.

       A description of the currently available protocols follows.

   <b>amqp</b>
       Advanced Message Queueing Protocol (AMQP) version 0-9-1 is a broker based publish-subscribe communication
       protocol.

       FFmpeg must be compiled with --enable-librabbitmq to support AMQP. A separate AMQP broker  must  also  be
       run. An example open-source AMQP broker is RabbitMQ.

       After starting the broker, an FFmpeg client may stream data to the broker using the command:

               ffmpeg -re -i input -f mpegts amqp://[[user]:[password]@]hostname[:port][/vhost]

       Where  hostname  and  port  (default  is  5672)  is  the address of the broker. The client may also set a
       user/password for authentication. The default for both fields is "guest". Name of virtual host on  broker
       can be set with vhost. The default value is "/".

       Muliple subscribers may stream from the broker using the command:

               ffplay amqp://[[user]:[password]@]hostname[:port][/vhost]

       In  RabbitMQ  all  data  published  to the broker flows through a specific exchange, and each subscribing
       client has an assigned queue/buffer. When a packet arrives at an exchange, it may be copied to a client's
       queue depending on the exchange and routing_key fields.

       The following options are supported:

       <b>exchange</b>
           Sets the exchange to use on the broker. RabbitMQ has several predefined  exchanges:  "amq.direct"  is
           the  default  exchange,  where  the  publisher  and  subscriber  must  have  a  matching routing_key;
           "amq.fanout" is the same as a broadcast operation (i.e. the data is forwarded to all  queues  on  the
           fanout  exchange  independent  of  the  routing_key); and "amq.topic" is similar to "amq.direct", but
           allows for more complex pattern matching (refer to the RabbitMQ documentation).

       <b>routing_key</b>
           Sets the routing key. The default value is "amqp". The routing key is used on  the  "amq.direct"  and
           "amq.topic" exchanges to decide whether packets are written to the queue of a subscriber.

       <b>pkt_size</b>
           Maximum  size of each packet sent/received to the broker. Default is 131072.  Minimum is 4096 and max
           is any large value (representable by an int). When receiving packets, this sets  an  internal  buffer
           size  in  FFmpeg.  It  should  be  equal  to or greater than the size of the published packets to the
           broker. Otherwise the received message may be truncated causing decoding errors.

       <b>connection_timeout</b>
           The timeout in seconds during the initial connection to the broker. The default value is  rw_timeout,
           or 5 seconds if rw_timeout is not set.

       <b>delivery_mode</b> <u>mode</u>
           Sets the delivery mode of each message sent to broker.  The following values are accepted:

           <b>persistent</b>
               Delivery mode set to "persistent" (2). This is the default value.  Messages may be written to the
               broker's disk depending on its setup.

           <b>non-persistent</b>
               Delivery  mode  set  to  "non-persistent"  (1).  Messages will stay in broker's memory unless the
               broker is under memory pressure.

   <b>async</b>
       Asynchronous data filling wrapper for input stream.

       Fill data in a background thread, to decouple I/O operation from demux thread.

               async:&lt;URL&gt;
               async:<a href="http://host/resource">http://host/resource</a>
               async:cache:<a href="http://host/resource">http://host/resource</a>

   <b>bluray</b>
       Read BluRay playlist.

       The accepted options are:

       <b>angle</b>
           BluRay angle

       <b>chapter</b>
           Start chapter (1...N)

       <b>playlist</b>
           Playlist to read (BDMV/PLAYLIST/?????.mpls)

       Examples:

       Read longest playlist from BluRay mounted to /mnt/bluray:

               bluray:/mnt/bluray

       Read angle 2 of playlist 4 from BluRay mounted to /mnt/bluray, start from chapter 2:

               -playlist 4 -angle 2 -chapter 2 bluray:/mnt/bluray

   <b>cache</b>
       Caching wrapper for input stream.

       Cache the input stream to temporary file. It brings seeking capability to live streams.

       The accepted options are:

       <b>read_ahead_limit</b>
           Amount in bytes that may be read ahead when seeking isn't supported. Range is -1 to INT_MAX.  -1  for
           unlimited. Default is 65536.

       URL Syntax is

               cache:&lt;URL&gt;

   <b>concat</b>
       Physical concatenation protocol.

       Read and seek from many resources in sequence as if they were a unique resource.

       A URL accepted by this protocol has the syntax:

               concat:&lt;URL1&gt;|&lt;URL2&gt;|...|&lt;URLN&gt;

       where <u>URL1</u>, <u>URL2</u>, ..., <u>URLN</u> are the urls of the resource to be concatenated, each one possibly specifying
       a distinct protocol.

       For  example  to  read  a  sequence  of  files  <u>split1.mpeg</u>, <u>split2.mpeg</u>, <u>split3.mpeg</u> with <b>ffplay</b> use the
       command:

               ffplay concat:split1.mpeg\|split2.mpeg\|split3.mpeg

       Note that you may need to escape the character "|" which is special for many shells.

   <b>concatf</b>
       Physical concatenation protocol using a line break delimited list of resources.

       Read and seek from many resources in sequence as if they were a unique resource.

       A URL accepted by this protocol has the syntax:

               concatf:&lt;URL&gt;

       where <u>URL</u> is the url containing a line break delimited list of resources to  be  concatenated,  each  one
       possibly  specifying  a  distinct  protocol.  Special characters must be escaped with backslash or single
       quotes. See <b>the</b> <b>"Quoting</b> <b>and</b> <b>escaping"</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>.

       For example to read a sequence of files <u>split1.mpeg</u>, <u>split2.mpeg</u>, <u>split3.mpeg</u> listed  in  separate  lines
       within a file <u>split.txt</u> with <b>ffplay</b> use the command:

               ffplay concatf:split.txt

       Where <u>split.txt</u> contains the lines:

               split1.mpeg
               split2.mpeg
               split3.mpeg

   <b>crypto</b>
       AES-encrypted stream reading protocol.

       The accepted options are:

       <b>key</b> Set the AES decryption key binary block from given hexadecimal representation.

       <b>iv</b>  Set the AES decryption initialization vector binary block from given hexadecimal representation.

       Accepted URL formats:

               crypto:&lt;URL&gt;
               crypto+&lt;URL&gt;

   <b>data</b>
       Data in-line in the URI. See &lt;<b><a href="http://en.wikipedia.org/wiki/Data_URI_scheme">http://en.wikipedia.org/wiki/Data_URI_scheme</a></b>&gt;.

       For example, to convert a GIF file given inline with <b>ffmpeg</b>:

               ffmpeg -i "data:image/gif;base64,R0lGODdhCAAIAMIEAAAAAAAA//8AAP//AP///////////////ywAAAAACAAIAAADF0gEDLojDgdGiJdJqUX02iB4E8Q9jUMkADs=" smiley.png

   <b>fd</b>
       File descriptor access protocol.

       The accepted syntax is:

               fd: -fd &lt;file_descriptor&gt;

       If  <b>fd</b>  is  not  specified,  by  default  the  stdout file descriptor will be used for writing, stdin for
       reading. Unlike the pipe protocol, fd protocol has seek support if it corresponding to a regular file. fd
       protocol doesn't support pass file descriptor via URL for security.

       This protocol accepts the following options:

       <b>blocksize</b>
           Set I/O operation maximum block size, in bytes. Default value is  "INT_MAX",  which  results  in  not
           limiting  the  requested  block  size.   Setting  this value reasonably low improves user termination
           request reaction time, which is valuable if data transmission is slow.

       <b>fd</b>  Set file descriptor.

   <b>file</b>
       File access protocol.

       Read from or write to a file.

       A file URL can have the form:

               file:&lt;filename&gt;

       where <u>filename</u> is the path of the file to read.

       An URL that does not have a protocol prefix will be assumed to be a file URL. Depending on the build,  an
       URL  that  looks  like a Windows path with the drive letter at the beginning will also be assumed to be a
       file URL (usually not the case in builds for unix-like systems).

       For example to read from a file <u>input.mpeg</u> with <b>ffmpeg</b> use the command:

               ffmpeg -i file:input.mpeg output.mpeg

       This protocol accepts the following options:

       <b>truncate</b>
           Truncate existing files on write, if set to 1. A value of 0 prevents truncating. Default value is 1.

       <b>blocksize</b>
           Set I/O operation maximum block size, in bytes. Default value is  "INT_MAX",  which  results  in  not
           limiting  the  requested  block  size.   Setting  this value reasonably low improves user termination
           request reaction time, which is valuable for files on slow medium.

       <b>follow</b>
           If set to 1, the protocol will retry reading at the end of the  file,  allowing  reading  files  that
           still  are  being  written.  In  order  for  this to terminate, you either need to use the rw_timeout
           option, or use the interrupt callback (for API users).

       <b>seekable</b>
           Controls if seekability is advertised on the file. 0 means non-seekable, -1 means auto (seekable  for
           normal files, non-seekable for named pipes).

           Many  demuxers handle seekable and non-seekable resources differently, overriding this might speed up
           opening certain files at the cost of losing some features (e.g. accurate seeking).

   <b>ftp</b>
       FTP (File Transfer Protocol).

       Read from or write to remote resources using FTP protocol.

       Following syntax is required.

               ftp://[user[:password]@]server[:port]/path/to/remote/resource.mpeg

       This protocol accepts the following options.

       <b>timeout</b>
           Set timeout in microseconds of socket I/O operations used by the underlying low level  operation.  By
           default it is set to -1, which means that the timeout is not specified.

       <b>ftp-user</b>
           Set a user to be used for authenticating to the FTP server. This is overridden by the user in the FTP
           URL.

       <b>ftp-password</b>
           Set a password to be used for authenticating to the FTP server. This is overridden by the password in
           the FTP URL, or by <b>ftp-anonymous-password</b> if no user is set.

       <b>ftp-anonymous-password</b>
           Password used when login as anonymous user. Typically an e-mail address should be used.

       <b>ftp-write-seekable</b>
           Control  seekability  of  connection  during  encoding.  If  set  to 1 the resource is supposed to be
           seekable, if set to 0 it is assumed not to be seekable. Default value is 0.

       NOTE: Protocol can be used as output, but it is recommended to not do it, unless special  care  is  taken
       (tests,  customized server configuration etc.). Different FTP servers behave in different way during seek
       operation. ff* tools may produce incomplete content due to server limitations.

   <b>gopher</b>
       Gopher protocol.

   <b>gophers</b>
       Gophers protocol.

       The Gopher protocol with TLS encapsulation.

   <b>hls</b>
       Read Apple HTTP Live Streaming compliant segmented stream as a uniform one. The M3U8 playlists describing
       the segments can be remote HTTP resources or local files, accessed using the standard file protocol.  The
       nested protocol is declared by specifying "+<u>proto</u>" after the hls URI scheme name, where <u>proto</u>  is  either
       "file" or "http".

               hls+<a href="http://host/path/to/remote/resource.m3u8">http://host/path/to/remote/resource.m3u8</a>
               hls+file://path/to/local/resource.m3u8

       Using  this protocol is discouraged - the hls demuxer should work just as well (if not, please report the
       issues) and is more complete.  To use the hls demuxer instead, simply use the direct  URLs  to  the  m3u8
       files.

   <b>http</b>
       HTTP (Hyper Text Transfer Protocol).

       This protocol accepts the following options:

       <b>seekable</b>
           Control  seekability  of connection. If set to 1 the resource is supposed to be seekable, if set to 0
           it is assumed not to be seekable, if set to -1 it will try to autodetect if it is  seekable.  Default
           value is -1.

       <b>chunked_post</b>
           If set to 1 use chunked Transfer-Encoding for posts, default is 1.

       <b>http_proxy</b>
           set HTTP proxy to tunnel through e.g. <a href="http://example.com">http://example.com</a>:1234

       <b>headers</b>
           Set  custom  HTTP headers, can override built in default headers. The value must be a string encoding
           the headers.

       <b>content_type</b>
           Set a specific content type for the POST messages or for listen mode.

       <b>user_agent</b>
           Override the User-Agent header. If not specified the  protocol  will  use  a  string  describing  the
           libavformat build. ("Lavf/&lt;version&gt;")

       <b>referer</b>
           Set the Referer header. Include 'Referer: URL' header in HTTP request.

       <b>multiple_requests</b>
           Use persistent connections if set to 1, default is 0.

       <b>post_data</b>
           Set custom HTTP post data.

       <b>mime_type</b>
           Export the MIME type.

       <b>http_version</b>
           Exports the HTTP response version number. Usually "1.0" or "1.1".

       <b>cookies</b>
           Set  the cookies to be sent in future requests. The format of each cookie is the same as the value of
           a Set-Cookie HTTP response field. Multiple cookies can be delimited by a newline character.

       <b>icy</b> If set to 1 request ICY (SHOUTcast) metadata from the  server.  If  the  server  supports  this,  the
           metadata   has   to  be  retrieved  by  the  application  by  reading  the  <b>icy_metadata_headers</b>  and
           <b>icy_metadata_packet</b> options.  The default is 1.

       <b>icy_metadata_headers</b>
           If the server supports ICY metadata, this contains the ICY-specific HTTP reply headers, separated  by
           newline characters.

       <b>icy_metadata_packet</b>
           If  the server supports ICY metadata, and <b>icy</b> was set to 1, this contains the last non-empty metadata
           packet sent by the server. It should be polled in regular intervals  by  applications  interested  in
           mid-stream metadata updates.

       <b>metadata</b>
           Set  an  exported dictionary containing Icecast metadata from the bitstream, if present.  Only useful
           with the C API.

       <b>auth_type</b>
           Set HTTP authentication type. No  option  for  Digest,  since  this  method  requires  getting  nonce
           parameters from the server first and can't be used straight away like Basic.

           <b>none</b>
               Choose the HTTP authentication type automatically. This is the default.

           <b>basic</b>
               Choose the HTTP basic authentication.

               Basic authentication sends a Base64-encoded string that contains a user name and password for the
               client.  Base64 is not a form of encryption and should be considered the same as sending the user
               name and password in clear text (Base64 is a reversible encoding).  If a  resource  needs  to  be
               protected,  strongly  consider  using  an  authentication scheme other than basic authentication.
               HTTPS/TLS  should  be  used  with  basic  authentication.   Without  these  additional   security
               enhancements,  basic  authentication  should  not  be  used  to  protect  sensitive  or  valuable
               information.

       <b>send_expect_100</b>
           Send an Expect: 100-continue header for POST. If set to 1 it will send, if set to 0 it won't, if  set
           to -1 it will try to send if it is applicable. Default value is -1.

       <b>location</b>
           An exported dictionary containing the content location. Only useful with the C API.

       <b>offset</b>
           Set initial byte offset.

       <b>end_offset</b>
           Try to limit the request to bytes preceding this offset.

       <b>method</b>
           When used as a client option it sets the HTTP method for the request.

           When used as a server option it sets the HTTP method that is going to be expected from the client(s).
           If  the  expected  and  the  received HTTP method do not match the client will be given a Bad Request
           response.  When unset the HTTP method is not checked for now. This will be replaced by  autodetection
           in the future.

       <b>reconnect</b>
           Reconnect automatically when disconnected before EOF is hit.

       <b>reconnect_at_eof</b>
           If  set  then eof is treated like an error and causes reconnection, this is useful for live / endless
           streams.

       <b>reconnect_on_network_error</b>
           Reconnect automatically in case of TCP/TLS errors during connect.

       <b>reconnect_on_http_error</b>
           A comma separated list of HTTP status codes to reconnect on. The list  can  include  specific  status
           codes (e.g. '503') or the strings '4xx' / '5xx'.

       <b>reconnect_streamed</b>
           If set then even streamed/non seekable streams will be reconnected on errors.

       <b>reconnect_delay_max</b>
           Set the maximum delay in seconds after which to give up reconnecting.

       <b>reconnect_max_retries</b>
           Set the maximum number of times to retry a connection. Default unset.

       <b>reconnect_delay_total_max</b>
           Set the maximum total delay in seconds after which to give up reconnecting.

       <b>respect_retry_after</b>
           If  enabled,  and  a  Retry-After  header  is  encountered,  its requested reconnection delay will be
           honored, rather than using exponential backoff. Useful for 429 and 503 errors. Default enabled.

       <b>listen</b>
           If set to 1 enables experimental HTTP server. This can be used to send data when used  as  an  output
           option,  or read data from a client with HTTP POST when used as an input option.  If set to 2 enables
           experimental multi-client HTTP server. This is not yet implemented in ffmpeg.c and thus must  not  be
           used as a command line option.

                   # Server side (sending):
                   ffmpeg -i somefile.ogg -c copy -listen 1 -f ogg http://&lt;server&gt;:&lt;port&gt;

                   # Client side (receiving):
                   ffmpeg -i http://&lt;server&gt;:&lt;port&gt; -c copy somefile.ogg

                   # Client can also be done with wget:
                   wget http://&lt;server&gt;:&lt;port&gt; -O somefile.ogg

                   # Server side (receiving):
                   ffmpeg -listen 1 -i http://&lt;server&gt;:&lt;port&gt; -c copy somefile.ogg

                   # Client side (sending):
                   ffmpeg -i somefile.ogg -chunked_post 0 -c copy -f ogg http://&lt;server&gt;:&lt;port&gt;

                   # Client can also be done with wget:
                   wget --post-file=somefile.ogg http://&lt;server&gt;:&lt;port&gt;

       <b>resource</b>
           The resource requested by a client, when the experimental HTTP server is in use.

       <b>reply_code</b>
           The HTTP code returned to the client, when the experimental HTTP server is in use.

       <b>short_seek_size</b>
           Set  the  threshold,  in  bytes,  for  when  a  readahead should be prefered over a seek and new HTTP
           request. This is useful, for example, to make sure the same connection  is  used  for  reading  large
           video packets with small audio packets in between.

       <u>HTTP</u> <u>Cookies</u>

       Some HTTP requests will be denied unless cookie values are passed in with the request. The <b>cookies</b> option
       allows  these  cookies  to be specified. At the very least, each cookie must specify a value along with a
       path and domain.  HTTP requests that match both the domain and path will automatically include the cookie
       value in the HTTP Cookie header field. Multiple cookies can be delimited by a newline.

       The required syntax to play a stream specifying a cookie is:

               ffplay -cookies "nlqptid=nltid=tsn; path=/; domain=somedomain.com;" <a href="http://somedomain.com/somestream.m3u8">http://somedomain.com/somestream.m3u8</a>

   <b>Icecast</b>
       Icecast protocol (stream to Icecast servers)

       This protocol accepts the following options:

       <b>ice_genre</b>
           Set the stream genre.

       <b>ice_name</b>
           Set the stream name.

       <b>ice_description</b>
           Set the stream description.

       <b>ice_url</b>
           Set the stream website URL.

       <b>ice_public</b>
           Set if the stream should be public.  The default is 0 (not public).

       <b>user_agent</b>
           Override the User-Agent header. If not specified a string of the form "Lavf/&lt;version&gt;" will be used.

       <b>password</b>
           Set the Icecast mountpoint password.

       <b>content_type</b>
           Set the stream content type. This must be set if it is different from audio/mpeg.

       <b>legacy_icecast</b>
           This enables support for Icecast versions &lt; 2.4.0, that do not support the HTTP PUT  method  but  the
           SOURCE method.

       <b>tls</b> Establish a TLS (HTTPS) connection to Icecast.

               icecast://[&lt;username&gt;[:&lt;password&gt;]@]&lt;server&gt;:&lt;port&gt;/&lt;mountpoint&gt;

   <b>ipfs</b>
       InterPlanetary  File  System  (IPFS)  protocol  support.  One can access files stored on the IPFS network
       through so-called gateways. These are http(s) endpoints.  This protocol wraps the IPFS  native  protocols
       (ipfs://  and  ipns://)  to  be  sent to such a gateway. Users can (and should) host their own node which
       means this protocol will use one's local gateway to access files on the IPFS network.

       This protocol accepts the following options:

       <b>gateway</b>
           Defines the gateway to use. When not set, the protocol will first try locating the local  gateway  by
           looking at $IPFS_GATEWAY, $IPFS_PATH and "$HOME/.ipfs/", in that order.

       One can use this protocol in 2 ways. Using IPFS:

               ffplay ipfs://&lt;hash&gt;

       Or the IPNS protocol (IPNS is mutable IPFS):

               ffplay ipns://&lt;hash&gt;

   <b>mmst</b>
       MMS (Microsoft Media Server) protocol over TCP.

   <b>mmsh</b>
       MMS (Microsoft Media Server) protocol over HTTP.

       The required syntax is:

               mmsh://&lt;server&gt;[:&lt;port&gt;][/&lt;app&gt;][/&lt;playpath&gt;]

   <b>md5</b>
       MD5 output protocol.

       Computes  the  MD5  hash  of the data to be written, and on close writes this to the designated output or
       stdout if none is specified. It can be used to test muxers without writing an actual file.

       Some examples follow.

               # Write the MD5 hash of the encoded AVI file to the file output.avi.md5.
               ffmpeg -i input.flv -f avi -y md5:output.avi.md5

               # Write the MD5 hash of the encoded AVI file to stdout.
               ffmpeg -i input.flv -f avi -y md5:

       Note that some formats (typically MOV) require the output protocol to be seekable, so they will fail with
       the MD5 output protocol.

   <b>pipe</b>
       UNIX pipe access protocol.

       Read and write from UNIX pipes.

       The accepted syntax is:

               pipe:[&lt;number&gt;]

       If <b>fd</b> isn't specified, <u>number</u> is the number corresponding to the file descriptor of the pipe (e.g. 0  for
       stdin,  1  for  stdout, 2 for stderr).  If <u>number</u> is not specified, by default the stdout file descriptor
       will be used for writing, stdin for reading.

       For example to read from stdin with <b>ffmpeg</b>:

               cat test.wav | ffmpeg -i pipe:0
               # ...this is the same as...
               cat test.wav | ffmpeg -i pipe:

       For writing to stdout with <b>ffmpeg</b>:

               ffmpeg -i test.wav -f avi pipe:1 | cat &gt; test.avi
               # ...this is the same as...
               ffmpeg -i test.wav -f avi pipe: | cat &gt; test.avi

       This protocol accepts the following options:

       <b>blocksize</b>
           Set I/O operation maximum block size, in bytes. Default value is  "INT_MAX",  which  results  in  not
           limiting  the  requested  block  size.   Setting  this value reasonably low improves user termination
           request reaction time, which is valuable if data transmission is slow.

       <b>fd</b>  Set file descriptor.

       Note that some formats (typically MOV), require the output protocol to be seekable,  so  they  will  fail
       with the pipe output protocol.

   <b>prompeg</b>
       Pro-MPEG Code of Practice #3 Release 2 FEC protocol.

       The  Pro-MPEG  CoP#3  FEC  is  a  2D parity-check forward error correction mechanism for MPEG-2 Transport
       Streams sent over RTP.

       This protocol must be used in conjunction with the "rtp_mpegts" muxer and the "rtp" protocol.

       The required syntax is:

               -f rtp_mpegts -fec prompeg=&lt;option&gt;=&lt;val&gt;... rtp://&lt;hostname&gt;:&lt;port&gt;

       The destination UDP ports are "port + 2" for the column FEC stream and "port + 4" for the row FEC stream.

       This protocol accepts the following options:

       <b>l=</b><u>n</u> The number of columns (4-20, LxD &lt;= 100)

       <b>d=</b><u>n</u> The number of rows (4-20, LxD &lt;= 100)

       Example usage:

               -f rtp_mpegts -fec prompeg=l=8:d=4 rtp://&lt;hostname&gt;:&lt;port&gt;

   <b>rist</b>
       Reliable Internet Streaming Transport protocol

       The accepted options are:

       <b>rist_profile</b>
           Supported values:

           <b>simple</b>
           <b>main</b>
               This one is default.

           <b>advanced</b>
       <b>buffer_size</b>
           Set internal RIST buffer size in milliseconds for retransmission of data.  Default value is  0  which
           means the librist default (1 sec). Maximum value is 30 seconds.

       <b>fifo_size</b>
           Size  of  the librist receiver output fifo in number of packets. This must be a power of 2.  Defaults
           to 8192 (vs the librist default of 1024).

       <b>overrun_nonfatal=</b><u>1|0</u>
           Survive in case of librist fifo buffer overrun. Default value is 0.

       <b>pkt_size</b>
           Set maximum packet size for sending data. 1316 by default.

       <b>log_level</b>
           Set loglevel for RIST logging messages. You only need to set this if you explicitly  want  to  enable
           debug level messages or packet loss simulation, otherwise the regular loglevel is respected.

       <b>secret</b>
           Set override of encryption secret, by default is unset.

       <b>encryption</b>
           Set encryption type, by default is disabled.  Acceptable values are 128 and 256.

   <b>rtmp</b>
       Real-Time Messaging Protocol.

       The Real-Time Messaging Protocol (RTMP) is used for streaming multimedia content across a TCP/IP network.

       The required syntax is:

               rtmp://[&lt;username&gt;:&lt;password&gt;@]&lt;server&gt;[:&lt;port&gt;][/&lt;app&gt;][/&lt;instance&gt;][/&lt;playpath&gt;]

       The accepted parameters are:

       <b>username</b>
           An optional username (mostly for publishing).

       <b>password</b>
           An optional password (mostly for publishing).

       <b>server</b>
           The address of the RTMP server.

       <b>port</b>
           The number of the TCP port to use (by default is 1935).

       <b>app</b> It is the name of the application to access. It usually corresponds to the path where the application
           is  installed  on  the  RTMP server (e.g. <u>/ondemand/</u>, <u>/flash/live/</u>, etc.). You can override the value
           parsed from the URI through the "rtmp_app" option, too.

       <b>playpath</b>
           It is the path or name of the resource to play with reference to the application  specified  in  <u>app</u>,
           may be prefixed by "mp4:". You can override the value parsed from the URI through the "rtmp_playpath"
           option, too.

       <b>listen</b>
           Act as a server, listening for an incoming connection.

       <b>timeout</b>
           Maximum time to wait for the incoming connection. Implies listen.

       Additionally, the following parameters can be set via command line options (or in code via "AVOption"s):

       <b>rtmp_app</b>
           Name  of  application to connect on the RTMP server. This option overrides the parameter specified in
           the URI.

       <b>rtmp_buffer</b>
           Set the client buffer time in milliseconds. The default is 3000.

       <b>rtmp_conn</b>
           Extra arbitrary AMF connection parameters,  parsed  from  a  string,  e.g.  like  "B:1  S:authMe  O:1
           NN:code:1.23  NS:flag:ok O:0".  Each value is prefixed by a single character denoting the type, B for
           Boolean, N for number, S for string, O for object, or Z for null, followed by a colon.  For  Booleans
           the  data  must be either 0 or 1 for FALSE or TRUE, respectively.  Likewise for Objects the data must
           be 0 or 1 to end or begin an object,  respectively.  Data  items  in  subobjects  may  be  named,  by
           prefixing  the  type  with  'N'  and  specifying the name before the value (i.e. "NB:myFlag:1"). This
           option may be used multiple times to construct arbitrary AMF sequences.

       <b>rtmp_enhanced_codecs</b>
           Specify the list of codecs the client advertises to support in an enhanced RTMP stream.  This  option
           should  be  set to a comma separated list of fourcc values, like "hvc1,av01,vp09" for multiple codecs
           or "hvc1" for only one codec. The specified list will be presented in the  "fourCcLive"  property  of
           the Connect Command Message.

       <b>rtmp_flashver</b>
           Version  of  the  Flash  plugin  used  to  run  the  SWF  player. The default is LNX 9,0,124,2. (When
           publishing, the default is FMLE/3.0 (compatible; &lt;libavformat version&gt;).)

       <b>rtmp_flush_interval</b>
           Number of packets flushed in the same request (RTMPT only). The default is 10.

       <b>rtmp_live</b>
           Specify that the media is a live stream. No resuming or seeking in  live  streams  is  possible.  The
           default  value  is "any", which means the subscriber first tries to play the live stream specified in
           the playpath. If a live stream of that name is not found, it plays the  recorded  stream.  The  other
           possible values are "live" and "recorded".

       <b>rtmp_pageurl</b>
           URL of the web page in which the media was embedded. By default no value will be sent.

       <b>rtmp_playpath</b>
           Stream identifier to play or to publish. This option overrides the parameter specified in the URI.

       <b>rtmp_subscribe</b>
           Name of live stream to subscribe to. By default no value will be sent.  It is only sent if the option
           is specified or if rtmp_live is set to live.

       <b>rtmp_swfhash</b>
           SHA256 hash of the decompressed SWF file (32 bytes).

       <b>rtmp_swfsize</b>
           Size of the decompressed SWF file, required for SWFVerification.

       <b>rtmp_swfurl</b>
           URL of the SWF player for the media. By default no value will be sent.

       <b>rtmp_swfverify</b>
           URL to player swf file, compute hash/size automatically.

       <b>rtmp_tcurl</b>
           URL of the target stream. Defaults to proto://host[:port]/app.

       <b>tcp_nodelay=</b><u>1|0</u>
           Set TCP_NODELAY to disable Nagle's algorithm. Default value is 0.

           <u>Remark:</u>  <u>Writing</u>  <u>to</u>  <u>the</u>  <u>socket</u> <u>is</u> <u>currently</u> <u>not</u> <u>optimized</u> <u>to</u> <u>minimize</u> <u>system</u> <u>calls</u> <u>and</u> <u>reduces</u> <u>the</u>
           <u>efficiency</u> <u>/</u> <u>effect</u> <u>of</u> <u>TCP_NODELAY.</u>

       For example to read with <b>ffplay</b> a multimedia resource named "sample" from the application "vod"  from  an
       RTMP server "myserver":

               ffplay rtmp://myserver/vod/sample

       To publish to a password protected server, passing the playpath and app names separately:

               ffmpeg -re -i &lt;input&gt; -f flv -rtmp_playpath some/long/path -rtmp_app long/app/name rtmp://username:password@myserver/

   <b>rtmpe</b>
       Encrypted Real-Time Messaging Protocol.

       The  Encrypted  Real-Time  Messaging  Protocol  (RTMPE)  is  used for streaming multimedia content within
       standard cryptographic primitives, consisting of Diffie-Hellman key exchange and HMACSHA256, generating a
       pair of RC4 keys.

   <b>rtmps</b>
       Real-Time Messaging Protocol over a secure SSL connection.

       The Real-Time Messaging Protocol (RTMPS) is used for streaming multimedia  content  across  an  encrypted
       connection.

   <b>rtmpt</b>
       Real-Time Messaging Protocol tunneled through HTTP.

       The  Real-Time  Messaging Protocol tunneled through HTTP (RTMPT) is used for streaming multimedia content
       within HTTP requests to traverse firewalls.

   <b>rtmpte</b>
       Encrypted Real-Time Messaging Protocol tunneled through HTTP.

       The Encrypted Real-Time  Messaging  Protocol  tunneled  through  HTTP  (RTMPTE)  is  used  for  streaming
       multimedia content within HTTP requests to traverse firewalls.

   <b>rtmpts</b>
       Real-Time Messaging Protocol tunneled through HTTPS.

       The Real-Time Messaging Protocol tunneled through HTTPS (RTMPTS) is used for streaming multimedia content
       within HTTPS requests to traverse firewalls.

   <b>libsmbclient</b>
       libsmbclient permits one to manipulate CIFS/SMB network resources.

       Following syntax is required.

               smb://[[domain:]user[:password@]]server[/share[/path[/file]]]

       This protocol accepts the following options.

       <b>timeout</b>
           Set  timeout  in milliseconds of socket I/O operations used by the underlying low level operation. By
           default it is set to -1, which means that the timeout is not specified.

       <b>truncate</b>
           Truncate existing files on write, if set to 1. A value of 0 prevents truncating. Default value is 1.

       <b>workgroup</b>
           Set the workgroup used for making connections. By default workgroup is not specified.

       For more information see: &lt;<b><a href="http://www.samba.org/">http://www.samba.org/</a></b>&gt;.

   <b>libssh</b>
       Secure File Transfer Protocol via libssh

       Read from or write to remote resources using SFTP protocol.

       Following syntax is required.

               sftp://[user[:password]@]server[:port]/path/to/remote/resource.mpeg

       This protocol accepts the following options.

       <b>timeout</b>
           Set timeout of socket I/O operations used by the underlying low level operation. By default it is set
           to -1, which means that the timeout is not specified.

       <b>truncate</b>
           Truncate existing files on write, if set to 1. A value of 0 prevents truncating. Default value is 1.

       <b>private_key</b>
           Specify the path of the file containing private key to use during authorization.  By  default  libssh
           searches for keys in the <u><a href="file:~/.ssh/">~/.ssh/</a></u> directory.

       Example: Play a file stored on remote server.

               ffplay s<a href="ftp://user">ftp://user</a>:password@server_address:22/home/user/resource.mpeg

   <b>librtmp</b> <b>rtmp,</b> <b>rtmpe,</b> <b>rtmps,</b> <b>rtmpt,</b> <b>rtmpte</b>
       Real-Time Messaging Protocol and its variants supported through librtmp.

       Requires  the  presence  of  the librtmp headers and library during configuration. You need to explicitly
       configure the build with "--enable-librtmp". If enabled this will replace the native RTMP protocol.

       This protocol provides most client functions and a few server functions  needed  to  support  RTMP,  RTMP
       tunneled  in  HTTP  (RTMPT),  encrypted  RTMP (RTMPE), RTMP over SSL/TLS (RTMPS) and tunneled variants of
       these encrypted types (RTMPTE, RTMPTS).

       The required syntax is:

               &lt;rtmp_proto&gt;://&lt;server&gt;[:&lt;port&gt;][/&lt;app&gt;][/&lt;playpath&gt;] &lt;options&gt;

       where  <u>rtmp_proto</u>  is  one  of  the  strings  "rtmp",  "rtmpt",  "rtmpe",  "rtmps",  "rtmpte",   "rtmpts"
       corresponding to each RTMP variant, and <u>server</u>, <u>port</u>, <u>app</u> and <u>playpath</u> have the same meaning as specified
       for the RTMP native protocol.  <u>options</u> contains a list of space-separated options of the form <u>key</u>=<u>val</u>.

       See the librtmp manual page (man 3 librtmp) for more information.

       For example, to stream a file in real-time to an RTMP server using <b>ffmpeg</b>:

               ffmpeg -re -i myfile -f flv rtmp://myserver/live/mystream

       To play the same stream using <b>ffplay</b>:

               ffplay "rtmp://myserver/live/mystream live=1"

   <b>rtp</b>
       Real-time Transport Protocol.

       The required syntax for an RTP URL is: rtp://<u>hostname</u>[:<u>port</u>][?<u>option</u>=<u>val</u>...]

       <u>port</u> specifies the RTP port to use.

       The following URL options are supported:

       <b>ttl=</b><u>n</u>
           Set the TTL (Time-To-Live) value (for multicast only).

       <b>rtcpport=</b><u>n</u>
           Set the remote RTCP port to <u>n</u>.

       <b>localrtpport=</b><u>n</u>
           Set the local RTP port to <u>n</u>.

       <b>localrtcpport=</b><u>n</u><b>'</b>
           Set the local RTCP port to <u>n</u>.

       <b>pkt_size=</b><u>n</u>
           Set max packet size (in bytes) to <u>n</u>.

       <b>buffer_size=</b><u>size</u>
           Set the maximum UDP socket buffer size in bytes.

       <b>connect=0|1</b>
           Do a connect() on the UDP socket (if set to 1) or not (if set to 0).

       <b>sources=</b><u>ip</u><b>[,</b><u>ip</u><b>]</b>
           List allowed source IP addresses.

       <b>block=</b><u>ip</u><b>[,</b><u>ip</u><b>]</b>
           List disallowed (blocked) source IP addresses.

       <b>write_to_source=0|1</b>
           Send packets to the source address of the latest received packet (if set to 1) or to a default remote
           address (if set to 0).

       <b>localport=</b><u>n</u>
           Set the local RTP port to <u>n</u>.

       <b>localaddr=</b><u>addr</u>
           Local IP address of a network interface used for sending packets or joining multicast groups.

       <b>timeout=</b><u>n</u>
           Set timeout (in microseconds) of socket I/O operations to <u>n</u>.

           This is a deprecated option. Instead, <b>localrtpport</b> should be used.

       Important notes:

       1.  If <b>rtcpport</b> is not set the RTCP port will be set to the RTP port value plus 1.

       2.  If <b>localrtpport</b> (the local RTP port) is not set any available port will be used for the local RTP and
           RTCP ports.

       3.  If <b>localrtcpport</b> (the local RTCP port) is not set it will be set to the local RTP port value plus 1.

   <b>rtsp</b>
       Real-Time Streaming Protocol.

       RTSP  is  not  technically  a  protocol  handler  in  libavformat, it is a demuxer and muxer. The demuxer
       supports both normal RTSP (with data transferred over RTP; this is used by e.g. Apple and Microsoft)  and
       Real-RTSP (with data transferred over RDT).

       The  muxer  can  be used to send a stream using RTSP ANNOUNCE to a server supporting it (currently Darwin
       Streaming Server and Mischa Spiegelmock's &lt;<b>https://github.com/revmischa/rtsp-server</b>&gt;).

       The required syntax for a RTSP url is:

               rtsp://&lt;hostname&gt;[:&lt;port&gt;]/&lt;path&gt;

       Options can  be  set  on  the  <b>ffmpeg</b>/<b>ffplay</b>  command  line,  or  set  in  code  via  "AVOption"s  or  in
       "avformat_open_input".

       <u>Muxer</u>

       The following options are supported.

       <b>rtsp_transport</b>
           Set RTSP transport protocols.

           It accepts the following values:

           <b>udp</b> Use UDP as lower transport protocol.

           <b>tcp</b> Use TCP (interleaving within the RTSP control channel) as lower transport protocol.

           Default value is <b>0</b>.

       <b>rtsp_flags</b>
           Set RTSP flags.

           The following values are accepted:

           <b>latm</b>
               Use MP4A-LATM packetization instead of MPEG4-GENERIC for AAC.

           <b>rfc2190</b>
               Use RFC 2190 packetization instead of RFC 4629 for H.263.

           <b>skip_rtcp</b>
               Don't send RTCP sender reports.

           <b>h264_mode0</b>
               Use mode 0 for H.264 in RTP.

           <b>send_bye</b>
               Send RTCP BYE packets when finishing.

           Default value is <b>0</b>.

       <b>min_port</b>
           Set minimum local UDP port. Default value is 5000.

       <b>max_port</b>
           Set maximum local UDP port. Default value is 65000.

       <b>buffer_size</b>
           Set the maximum socket buffer size in bytes.

       <b>pkt_size</b>
           Set max send packet size (in bytes). Default value is 1472.

       <u>Demuxer</u>

       The following options are supported.

       <b>initial_pause</b>
           Do not start playing the stream immediately if set to 1. Default value is 0.

       <b>rtsp_transport</b>
           Set RTSP transport protocols.

           It accepts the following values:

           <b>udp</b> Use UDP as lower transport protocol.

           <b>tcp</b> Use TCP (interleaving within the RTSP control channel) as lower transport protocol.

           <b>udp_multicast</b>
               Use UDP multicast as lower transport protocol.

           <b>http</b>
               Use HTTP tunneling as lower transport protocol, which is useful for passing proxies.

           <b>https</b>
               Use  HTTPs  tunneling as lower transport protocol, which is useful for passing proxies and widely
               used for security consideration.

           Multiple lower transport protocols may be specified, in that case they are tried one at  a  time  (if
           the  setup  of  one  fails,  the next one is tried).  For the muxer, only the <b>tcp</b> and <b>udp</b> options are
           supported.

       <b>rtsp_flags</b>
           Set RTSP flags.

           The following values are accepted:

           <b>filter_src</b>
               Accept packets only from negotiated peer address and port.

           <b>listen</b>
               Act as a server, listening for an incoming connection.

           <b>prefer_tcp</b>
               Try TCP for RTP transport first, if TCP is available as RTSP RTP transport.

           <b>satip_raw</b>
               Export raw MPEG-TS stream instead of demuxing. The flag will simply write  out  the  raw  stream,
               with the original PAT/PMT/PIDs intact.

           Default value is <b>none</b>.

       <b>allowed_media_types</b>
           Set media types to accept from the server.

           The following flags are accepted:

           <b>video</b>
           <b>audio</b>
           <b>data</b>
           <b>subtitle</b>

           By default it accepts all media types.

       <b>min_port</b>
           Set minimum local UDP port. Default value is 5000.

       <b>max_port</b>
           Set maximum local UDP port. Default value is 65000.

       <b>listen_timeout</b>
           Set  maximum timeout (in seconds) to establish an initial connection. Setting <b>listen_timeout</b> &gt; 0 sets
           <b>rtsp_flags</b> to <b>listen</b>. Default is -1 which means an infinite timeout when <b>listen</b> mode is set.

       <b>reorder_queue_size</b>
           Set number of packets to buffer for handling of reordered packets.

       <b>timeout</b>
           Set socket TCP I/O timeout in microseconds.

       <b>user_agent</b>
           Override User-Agent header. If not specified, it defaults to the libavformat identifier string.

       <b>buffer_size</b>
           Set the maximum socket buffer size in bytes.

       When receiving data over UDP, the demuxer tries to reorder received packets (since they may arrive out of
       order, or packets may get lost totally). This can be disabled by setting the maximum  demuxing  delay  to
       zero (via the "max_delay" field of AVFormatContext).

       When  watching  multi-bitrate  Real-RTSP  streams  with <b>ffplay</b>, the streams to display can be chosen with
       "-vst" <u>n</u> and "-ast" <u>n</u> for video and audio respectively, and can be switched on the fly  by  pressing  "v"
       and "a".

       <u>Examples</u>

       The following examples all make use of the <b>ffplay</b> and <b>ffmpeg</b> tools.

       •   Watch a stream over UDP, with a max reordering delay of 0.5 seconds:

                   ffplay -max_delay 500000 -rtsp_transport udp rtsp://server/video.mp4

       •   Watch a stream tunneled over HTTP:

                   ffplay -rtsp_transport http rtsp://server/video.mp4

       •   Send a stream in realtime to a RTSP server, for others to watch:

                   ffmpeg -re -i &lt;input&gt; -f rtsp -muxdelay 0.1 rtsp://server/live.sdp

       •   Receive a stream in realtime:

                   ffmpeg -rtsp_flags listen -i rtsp://ownaddress/live.sdp &lt;output&gt;

   <b>sap</b>
       Session  Announcement  Protocol (RFC 2974). This is not technically a protocol handler in libavformat, it
       is a muxer and demuxer.  It is used for signalling of RTP streams, by announcing the SDP for the  streams
       regularly on a separate port.

       <u>Muxer</u>

       The syntax for a SAP url given to the muxer is:

               sap://&lt;destination&gt;[:&lt;port&gt;][?&lt;options&gt;]

       The  RTP  packets are sent to <u>destination</u> on port <u>port</u>, or to port 5004 if no port is specified.  <u>options</u>
       is a "&amp;"-separated list. The following options are supported:

       <b>announce_addr=</b><u>address</u>
           Specify the destination IP address for sending the announcements to.  If omitted,  the  announcements
           are  sent  to  the commonly used SAP announcement multicast address 224.2.127.254 (sap.mcast.net), or
           ff0e::2:7ffe if <u>destination</u> is an IPv6 address.

       <b>announce_port=</b><u>port</u>
           Specify the port to send the announcements on, defaults to 9875 if not specified.

       <b>ttl=</b><u>ttl</u>
           Specify the time to live value for the announcements and RTP packets, defaults to 255.

       <b>same_port=</b><u>0|1</u>
           If set to 1, send all RTP streams on the same port pair. If zero (the default), all streams are  sent
           on unique ports, with each stream on a port 2 numbers higher than the previous.  VLC/Live555 requires
           this  to  be  set to 1, to be able to receive the stream.  The RTP stack in libavformat for receiving
           requires all streams to be sent on unique ports.

       Example command lines follow.

       To broadcast a stream on the local subnet, for watching in VLC:

               ffmpeg -re -i &lt;input&gt; -f sap sap://224.0.0.255?same_port=1

       Similarly, for watching in <b>ffplay</b>:

               ffmpeg -re -i &lt;input&gt; -f sap sap://224.0.0.255

       And for watching in <b>ffplay</b>, over IPv6:

               ffmpeg -re -i &lt;input&gt; -f sap sap://[ff0e::1:2:3:4]

       <u>Demuxer</u>

       The syntax for a SAP url given to the demuxer is:

               sap://[&lt;address&gt;][:&lt;port&gt;]

       <u>address</u> is the multicast address to listen for announcements on, if omitted,  the  default  224.2.127.254
       (sap.mcast.net) is used. <u>port</u> is the port that is listened on, 9875 if omitted.

       The  demuxers listens for announcements on the given address and port.  Once an announcement is received,
       it tries to receive that particular stream.

       Example command lines follow.

       To play back the first stream announced on the normal SAP multicast address:

               ffplay sap://

       To play back the first stream announced on one the default IPv6 SAP multicast address:

               ffplay sap://[ff0e::2:7ffe]

   <b>sctp</b>
       Stream Control Transmission Protocol.

       The accepted URL syntax is:

               sctp://&lt;host&gt;:&lt;port&gt;[?&lt;options&gt;]

       The protocol accepts the following options:

       <b>listen</b>
           If set to any value, listen for an incoming connection. Outgoing connection is done by default.

       <b>max_streams</b>
           Set the maximum number of streams. By default no limit is set.

   <b>srt</b>
       Haivision Secure Reliable Transport Protocol via libsrt.

       The supported syntax for a SRT URL is:

               srt://&lt;hostname&gt;:&lt;port&gt;[?&lt;options&gt;]

       <u>options</u> contains a list of &amp;-separated options of the form <u>key</u>=<u>val</u>.

       or

               &lt;options&gt; srt://&lt;hostname&gt;:&lt;port&gt;

       <u>options</u> contains a list of '-<u>key</u> <u>val</u>' options.

       This protocol accepts the following options.

       <b>connect_timeout=</b><u>milliseconds</u>
           Connection timeout; SRT cannot connect for RTT &gt; 1500 msec (2 handshake exchanges) with  the  default
           connect  timeout of 3 seconds. This option applies to the caller and rendezvous connection modes. The
           connect timeout is 10 times the value set for the rendezvous mode (which can be used as a  workaround
           for this connection problem with earlier versions).

       <b>ffs=</b><u>bytes</u>
           Flight Flag Size (Window Size), in bytes. FFS is actually an internal parameter and you should set it
           to  not  less  than <b>recv_buffer_size</b> and <b>mss</b>. The default value is relatively large, therefore unless
           you set a very large receiver buffer, you do not need to change this option. Default value is 25600.

       <b>inputbw=</b><u>bytes/seconds</u>
           Sender nominal input rate, in bytes per seconds. Used along  with  <b>oheadbw</b>,  when  <b>maxbw</b>  is  set  to
           relative  (0),  to  calculate maximum sending rate when recovery packets are sent along with the main
           media stream: <b>inputbw</b> * (100 + <b>oheadbw</b>) / 100 if <b>inputbw</b> is not set while <b>maxbw</b> is  set  to  relative
           (0), the actual input rate is evaluated inside the library. Default value is 0.

       <b>iptos=</b><u>tos</u>
           IP Type of Service. Applies to sender only. Default value is 0xB8.

       <b>ipttl=</b><u>ttl</u>
           IP Time To Live. Applies to sender only. Default value is 64.

       <b>latency=</b><u>microseconds</u>
           Timestamp-based Packet Delivery Delay.  Used to absorb bursts of missed packet retransmissions.  This
           flag sets both <b>rcvlatency</b> and <b>peerlatency</b> to the same value. Note that prior to version 1.3.0 this is
           the only flag to set the latency, however this is effectively equivalent to setting <b>peerlatency</b>, when
           side  is  sender  and  <b>rcvlatency</b>  when side is receiver, and the bidirectional stream sending is not
           supported.

       <b>listen_timeout=</b><u>microseconds</u>
           Set socket listen timeout.

       <b>maxbw=</b><u>bytes/seconds</u>
           Maximum sending bandwidth, in bytes per seconds.  -1 infinite (CSRTCC limit is 30mbps) 0 relative  to
           input rate (see <b>inputbw</b>) &gt;0 absolute limit value Default value is 0 (relative)

       <b>mode=</b><u>caller|listener|rendezvous</u>
           Connection  mode.   <b>caller</b>  opens  client  connection.  <b>listener</b> starts server to listen for incoming
           connections.  <b>rendezvous</b> use Rendez-Vous connection mode.  Default value is caller.

       <b>mss=</b><u>bytes</u>
           Maximum Segment Size, in bytes. Used for buffer  allocation  and  rate  calculation  using  a  packet
           counter  assuming  fully  filled packets. The smallest MSS between the peers is used. This is 1500 by
           default in the overall internet.  This is the maximum  size  of  the  UDP  packet  and  can  be  only
           decreased, unless you have some unusual dedicated network settings. Default value is 1500.

       <b>nakreport=</b><u>1|0</u>
           If  set  to  1,  Receiver  will  send  `UMSG_LOSSREPORT` messages periodically until a lost packet is
           retransmitted or intentionally dropped. Default value is 1.

       <b>oheadbw=</b><u>percents</u>
           Recovery bandwidth overhead above input rate, in percents.  See <b>inputbw</b>. Default value is 25%.

       <b>passphrase=</b><u>string</u>
           HaiCrypt Encryption/Decryption Passphrase string, length from 10 to 79 characters. The passphrase  is
           the  shared secret between the sender and the receiver. It is used to generate the Key Encrypting Key
           using PBKDF2 (Password-Based Key Derivation Function). It is used only if <b>pbkeylen</b> is non-zero. It is
           used on the receiver only if the received data is encrypted.  The  configured  passphrase  cannot  be
           recovered (write-only).

       <b>enforced_encryption=</b><u>1|0</u>
           If  true,  both connection parties must have the same password set (including empty, that is, with no
           encryption). If the password doesn't match or  only  one  side  is  unencrypted,  the  connection  is
           rejected. Default is true.

       <b>kmrefreshrate=</b><u>packets</u>
           The  number  of  packets  to  be transmitted after which the encryption key is switched to a new key.
           Default is -1.  -1 means auto (0x1000000 in srt library). The range for this option  is  integers  in
           the 0 - "INT_MAX".

       <b>kmpreannounce=</b><u>packets</u>
           The  interval  between  when a new encryption key is sent and when switchover occurs. This value also
           applies to the subsequent interval between when switchover occurs and when the old encryption key  is
           decommissioned.  Default  is -1.  -1 means auto (0x1000 in srt library). The range for this option is
           integers in the 0 - "INT_MAX".

       <b>snddropdelay=</b><u>microseconds</u>
           The sender's extra delay before dropping packets. This delay is added to the default drop delay  time
           interval value.

           Special value -1: Do not drop packets on the sender at all.

       <b>payload_size=</b><u>bytes</u>
           Sets the maximum declared size of a packet transferred during the single call to the sending function
           in  Live  mode.  Use  0  if  this  value  isn't  used (which is default in file mode).  Default is -1
           (automatic), which typically means MPEG-TS; if you are going to use SRT to send any different kind of
           payload, such as, for example, wrapping a live stream in very small frames, then you can use a bigger
           maximum frame size, though not greater than 1456 bytes.

       <b>pkt_size=</b><u>bytes</u>
           Alias for <b>payload_size</b>.

       <b>peerlatency=</b><u>microseconds</u>
           The latency value (as described in <b>rcvlatency</b>) that is set by the sender side as a minimum value  for
           the receiver.

       <b>pbkeylen=</b><u>bytes</u>
           Sender  encryption  key  length,  in  bytes.   Only  can  be  set to 0, 16, 24 and 32.  Enable sender
           encryption if not 0.  Not required on receiver (set to 0), key size obtained from sender in  HaiCrypt
           handshake.  Default value is 0.

       <b>rcvlatency=</b><u>microseconds</u>
           The  time  that  should  elapse  since  the  moment when the packet was sent and the moment when it's
           delivered to the receiver application in the receiving function.  This time should be a  buffer  time
           large enough to cover the time spent for sending, unexpectedly extended RTT time, and the time needed
           to  retransmit  the lost UDP packet. The effective latency value will be the maximum of this options'
           value and the value of <b>peerlatency</b> set by the peer side. Before version 1.3.0  this  option  is  only
           available as <b>latency</b>.

       <b>recv_buffer_size=</b><u>bytes</u>
           Set UDP receive buffer size, expressed in bytes.

       <b>send_buffer_size=</b><u>bytes</u>
           Set UDP send buffer size, expressed in bytes.

       <b>timeout=</b><u>microseconds</u>
           Set  raise  error  timeouts  for  read,  write  and connect operations. Note that the SRT library has
           internal timeouts which can be controlled separately, the value set here is only a cap on those.

       <b>tlpktdrop=</b><u>1|0</u>
           Too-late Packet Drop. When enabled on receiver, it skips missing packets that have not been delivered
           in time and delivers the following packets to the application when their time-to-play  has  come.  It
           also  sends  a  fake ACK to the sender. When enabled on sender and enabled on the receiving peer, the
           sender drops the older packets that have no chance of being delivered in time. It  was  automatically
           enabled in the sender if the receiver supports it.

       <b>sndbuf=</b><u>bytes</u>
           Set send buffer size, expressed in bytes.

       <b>rcvbuf=</b><u>bytes</u>
           Set receive buffer size, expressed in bytes.

           Receive buffer must not be greater than <b>ffs</b>.

       <b>lossmaxttl=</b><u>packets</u>
           The value up to which the Reorder Tolerance may grow. When Reorder Tolerance is &gt; 0, then packet loss
           report  is  delayed  until  that  number of packets come in. Reorder Tolerance increases every time a
           "belated" packet has come, but it wasn't due to retransmission (that is, when  UDP  packets  tend  to
           come  out  of order), with the difference between the latest sequence and this packet's sequence, and
           not more than the value of this option. By default it's 0, which means that this mechanism is  turned
           off, and the loss report is always sent immediately upon experiencing a "gap" in sequences.

       <b>minversion</b>
           The  minimum SRT version that is required from the peer. A connection to a peer that does not satisfy
           the minimum version requirement will be rejected.

           The version format in hex is 0xXXYYZZ for x.y.z in human readable form.

       <b>streamid=</b><u>string</u>
           A string limited to 512 characters that can be set on the socket prior to connecting. This stream  ID
           will  be  able  to be retrieved by the listener side from the socket that is returned from srt_accept
           and was connected  by  a  socket  with  that  set  stream  ID.  SRT  does  not  enforce  any  special
           interpretation  of  the  contents  of  this  string.   This  option  doesn’t make sense in Rendezvous
           connection; the result might be that simply one side will override the value from the other side  and
           it’s the matter of luck which one would win

       <b>srt_streamid=</b><u>string</u>
           Alias for <b>streamid</b> to avoid conflict with ffmpeg command line option.

       <b>smoother=</b><u>live|file</u>
           The  type  of  Smoother  used  for  the  transmission  for  that socket, which is responsible for the
           transmission and congestion control. The Smoother type must be exactly the same  on  both  connecting
           parties, otherwise the connection is rejected.

       <b>messageapi=</b><u>1|0</u>
           When set, this socket uses the Message API, otherwise it uses Buffer API. Note that in live mode (see
           <b>transtype</b>) there’s only message API available. In File mode you can chose to use one of two modes:

           Stream  API  (default, when this option is false). In this mode you may send as many data as you wish
           with one sending instruction, or even use dedicated functions that read directly  from  a  file.  The
           internal  facility  will  take care of any speed and congestion control. When receiving, you can also
           receive as many data as desired, the data not extracted will be waiting for the next call.  There  is
           no boundary between data portions in the Stream mode.

           Message  API.  In this mode your single sending instruction passes exactly one piece of data that has
           boundaries (a message). Contrary to Live mode, this message may span across multiple UDP packets  and
           the  only  size  limitation is that it shall fit as a whole in the sending buffer. The receiver shall
           use as large buffer as necessary to receive the message, otherwise the message will not be given  up.
           When the message is not complete (not all packets received or there was a packet loss) it will not be
           given up.

       <b>transtype=</b><u>live|file</u>
           Sets  the  transmission  type  for the socket, in particular, setting this option sets multiple other
           parameters to their default values as required for a particular transmission type.

           live: Set options as for live transmission. In this mode, you should send by one sending  instruction
           only  so many data that fit in one UDP packet, and limited to the value defined first in <b>payload_size</b>
           (1316 is default in this mode). There is no speed control in this mode, only the  bandwidth  control,
           if configured, in order to not exceed the bandwidth with the overhead transmission (retransmitted and
           control packets).

           file: Set options as for non-live transmission. See <b>messageapi</b> for further explanations

       <b>linger=</b><u>seconds</u>
           The  number  of  seconds that the socket waits for unsent data when closing.  Default is -1. -1 means
           auto (off with 0 seconds in live mode, on with 180 seconds in file mode). The range for  this  option
           is integers in the 0 - "INT_MAX".

       <b>tsbpd=</b><u>1|0</u>
           When true, use Timestamp-based Packet Delivery mode. The default behavior depends on the transmission
           type: enabled in live mode, disabled in file mode.

       For more information see: &lt;<b>https://github.com/Haivision/srt</b>&gt;.

   <b>srtp</b>
       Secure Real-time Transport Protocol.

       The accepted options are:

       <b>srtp_in_suite</b>
       <b>srtp_out_suite</b>
           Select input and output encoding suites.

           Supported values:

           <b>AES_CM_128_HMAC_SHA1_80</b>
           <b>SRTP_AES128_CM_HMAC_SHA1_80</b>
           <b>AES_CM_128_HMAC_SHA1_32</b>
           <b>SRTP_AES128_CM_HMAC_SHA1_32</b>
       <b>srtp_in_params</b>
       <b>srtp_out_params</b>
           Set input and output encoding parameters, which are expressed by a base64-encoded representation of a
           binary  block. The first 16 bytes of this binary block are used as master key, the following 14 bytes
           are used as master salt.

   <b>subfile</b>
       Virtually extract a segment of a file or another stream.  The underlying stream must be seekable.

       Accepted options:

       <b>start</b>
           Start offset of the extracted segment, in bytes.

       <b>end</b> End offset of the extracted segment, in bytes.  If set to 0, extract till end of file.

       Examples:

       Extract a chapter from a DVD VOB file (start and end sectors obtained externally and multiplied by 2048):

               subfile,,start,153391104,end,268142592,,:/media/dvd/VIDEO_TS/VTS_08_1.VOB

       Play an AVI file directly from a TAR archive:

               subfile,,start,183241728,end,366490624,,:archive.tar

       Play a MPEG-TS file from start offset till end:

               subfile,,start,32815239,end,0,,:video.ts

   <b>tee</b>
       Writes the output to multiple protocols. The individual outputs are separated by |

               tee:file://path/to/local/this.avi|file://path/to/local/that.avi

   <b>tcp</b>
       Transmission Control Protocol.

       The required syntax for a TCP url is:

               tcp://&lt;hostname&gt;:&lt;port&gt;[?&lt;options&gt;]

       <u>options</u> contains a list of &amp;-separated options of the form <u>key</u>=<u>val</u>.

       The list of supported options follows.

       <b>listen=</b><u>2|1|0</u>
           Listen for an incoming connection. 0 disables listen, 1 enables  listen  in  single  client  mode,  2
           enables listen in multi-client mode. Default value is 0.

       <b>local_addr=</b><u>addr</u>
           Local IP address of a network interface used for tcp socket connect.

       <b>local_port=</b><u>port</u>
           Local port used for tcp socket connect.

       <b>timeout=</b><u>microseconds</u>
           Set raise error timeout, expressed in microseconds.

           This  option is only relevant in read mode: if no data arrived in more than this time interval, raise
           error.

       <b>listen_timeout=</b><u>milliseconds</u>
           Set listen timeout, expressed in milliseconds.

       <b>recv_buffer_size=</b><u>bytes</u>
           Set receive buffer size, expressed bytes.

       <b>send_buffer_size=</b><u>bytes</u>
           Set send buffer size, expressed bytes.

       <b>tcp_nodelay=</b><u>1|0</u>
           Set TCP_NODELAY to disable Nagle's algorithm. Default value is 0.

           <u>Remark:</u> <u>Writing</u> <u>to</u> <u>the</u> <u>socket</u> <u>is</u> <u>currently</u> <u>not</u> <u>optimized</u> <u>to</u> <u>minimize</u> <u>system</u>  <u>calls</u>  <u>and</u>  <u>reduces</u>  <u>the</u>
           <u>efficiency</u> <u>/</u> <u>effect</u> <u>of</u> <u>TCP_NODELAY.</u>

       <b>tcp_mss=</b><u>bytes</u>
           Set maximum segment size for outgoing TCP packets, expressed in bytes.

       The  following  example shows how to setup a listening TCP connection with <b>ffmpeg</b>, which is then accessed
       with <b>ffplay</b>:

               ffmpeg -i &lt;input&gt; -f &lt;format&gt; tcp://&lt;hostname&gt;:&lt;port&gt;?listen
               ffplay tcp://&lt;hostname&gt;:&lt;port&gt;

   <b>tls</b>
       Transport Layer Security (TLS) / Secure Sockets Layer (SSL)

       The required syntax for a TLS/SSL url is:

               tls://&lt;hostname&gt;:&lt;port&gt;[?&lt;options&gt;]

       The following parameters can be set via command line options (or in code via "AVOption"s):

       <b>ca_file,</b> <b>cafile=</b><u>filename</u>
           A file containing certificate authority (CA) root certificates to treat as trusted. If the linked TLS
           library contains a default this might not need to be specified for verification to work, but not  all
           libraries and setups have defaults built in.  The file must be in OpenSSL PEM format.

       <b>tls_verify=</b><u>1|0</u>
           If  enabled,  try  to  verify  the peer that we are communicating with.  Note, if using OpenSSL, this
           currently only makes sure that the peer certificate is signed by one of the root certificates in  the
           CA  database,  but  it  does  not validate that the certificate actually matches the host name we are
           trying to connect to. (With other backends, the host name is validated as well.)

           This is disabled by default since it requires a CA database to be provided  by  the  caller  in  many
           cases.

       <b>cert_file,</b> <b>cert=</b><u>filename</u>
           A file containing a certificate to use in the handshake with the peer.  (When operating as server, in
           listen  mode, this is more often required by the peer, while client certificates only are mandated in
           certain setups.)

       <b>key_file,</b> <b>key=</b><u>filename</u>
           A file containing the private key for the certificate.

       <b>listen=</b><u>1|0</u>
           If enabled, listen for connections on the provided port, and assume the server role in the  handshake
           instead of the client role.

       <b>http_proxy</b>
           The HTTP proxy to tunnel through, e.g. "<a href="http://example.com">http://example.com</a>:1234".  The proxy must support the CONNECT
           method.

       Example command lines:

       To create a TLS/SSL server that serves an input stream.

               ffmpeg -i &lt;input&gt; -f &lt;format&gt; tls://&lt;hostname&gt;:&lt;port&gt;?listen&amp;cert=&lt;server.crt&gt;&amp;key=&lt;server.key&gt;

       To play back a stream from the TLS/SSL server using <b>ffplay</b>:

               ffplay tls://&lt;hostname&gt;:&lt;port&gt;

   <b>udp</b>
       User Datagram Protocol.

       The required syntax for an UDP URL is:

               udp://&lt;hostname&gt;:&lt;port&gt;[?&lt;options&gt;]

       <u>options</u> contains a list of &amp;-separated options of the form <u>key</u>=<u>val</u>.

       In  case  threading is enabled on the system, a circular buffer is used to store the incoming data, which
       allows one to reduce loss of data due to UDP socket buffer overruns. The <u>fifo_size</u>  and  <u>overrun_nonfatal</u>
       options are related to this buffer.

       The list of supported options follows.

       <b>buffer_size=</b><u>size</u>
           Set  the  UDP  maximum  socket  buffer  size in bytes. This is used to set either the receive or send
           buffer size, depending on what the socket is used for.  Default is 32  KB  for  output,  384  KB  for
           input.  See also <u>fifo_size</u>.

       <b>bitrate=</b><u>bitrate</u>
           If  set  to  nonzero,  the  output  will  have the specified constant bitrate if the input has enough
           packets to sustain it.

       <b>burst_bits=</b><u>bits</u>
           When using <u>bitrate</u> this specifies the maximum number of bits in packet bursts.

       <b>localport=</b><u>port</u>
           Override the local UDP port to bind with.

       <b>localaddr=</b><u>addr</u>
           Local IP address of a network interface used for sending packets or joining multicast groups.

       <b>pkt_size=</b><u>size</u>
           Set the size in bytes of UDP packets.

       <b>reuse=</b><u>1|0</u>
           Explicitly allow or disallow reusing UDP sockets.

       <b>ttl=</b><u>ttl</u>
           Set the time to live value (for multicast only).

       <b>connect=</b><u>1|0</u>
           Initialize the UDP socket with connect(). In this case, the destination address can't be changed with
           ff_udp_set_remote_url later.  If the destination address isn't known at the start, this option can be
           specified in ff_udp_set_remote_url, too.  This allows finding out the source address for the  packets
           with  getsockname, and makes writes return with AVERROR(ECONNREFUSED) if "destination unreachable" is
           received.  For receiving, this gives the benefit of only receiving packets from  the  specified  peer
           address/port.

       <b>sources=</b><u>address</u><b>[,</b><u>address</u><b>]</b>
           Only  receive  packets  sent  from  the  specified addresses. In case of multicast, also subscribe to
           multicast traffic coming from these addresses only.

       <b>block=</b><u>address</u><b>[,</b><u>address</u><b>]</b>
           Ignore packets sent from the specified addresses. In case  of  multicast,  also  exclude  the  source
           addresses in the multicast subscription.

       <b>fifo_size=</b><u>units</u>
           Set  the UDP receiving circular buffer size, expressed as a number of packets with size of 188 bytes.
           If not specified defaults to 7*4096.

       <b>overrun_nonfatal=</b><u>1|0</u>
           Survive in case of UDP receiving circular buffer overrun. Default value is 0.

       <b>timeout=</b><u>microseconds</u>
           Set raise error timeout, expressed in microseconds.

           This option is only relevant in read mode: if no data arrived in more than this time interval,  raise
           error.

       <b>broadcast=</b><u>1|0</u>
           Explicitly allow or disallow UDP broadcasting.

           Note that broadcasting may not work properly on networks having a broadcast storm protection.

       <u>Examples</u>

       •   Use <b>ffmpeg</b> to stream over UDP to a remote endpoint:

                   ffmpeg -i &lt;input&gt; -f &lt;format&gt; udp://&lt;hostname&gt;:&lt;port&gt;

       •   Use  <b>ffmpeg</b>  to  stream  in  mpegts  format over UDP using 188 sized UDP packets, using a large input
           buffer:

                   ffmpeg -i &lt;input&gt; -f mpegts udp://&lt;hostname&gt;:&lt;port&gt;?pkt_size=188&amp;buffer_size=65535

       •   Use <b>ffmpeg</b> to receive over UDP from a remote endpoint:

                   ffmpeg -i udp://[&lt;multicast-address&gt;]:&lt;port&gt; ...

   <b>unix</b>
       Unix local socket

       The required syntax for a Unix socket URL is:

               unix://&lt;filepath&gt;

       The following parameters can be set via command line options (or in code via "AVOption"s):

       <b>timeout</b>
           Timeout in ms.

       <b>listen</b>
           Create the Unix socket in listening mode.

   <b>zmq</b>
       ZeroMQ asynchronous messaging using the libzmq library.

       This library supports unicast streaming to multiple clients without relying on an external server.

       The required syntax for streaming or connecting to a stream is:

               zmq:tcp://ip-address:port

       Example: Create a localhost stream on port 5555:

               ffmpeg -re -i input -f mpegts zmq:tcp://127.0.0.1:5555

       Multiple clients may connect to the stream using:

               ffplay zmq:tcp://127.0.0.1:5555

       Streaming to multiple clients is implemented using a ZeroMQ Pub-Sub pattern.  The server side binds to  a
       port and publishes data. Clients connect to the server (via IP address/port) and subscribe to the stream.
       The order in which the server and client start generally does not matter.

       ffmpeg must be compiled with the --enable-libzmq option to support this protocol.

       Options can be set on the <b>ffmpeg</b>/<b>ffplay</b> command line. The following options are supported:

       <b>pkt_size</b>
           Forces the maximum packet size for sending/receiving data. The default value is 131,072 bytes. On the
           server  side,  this  sets  the  maximum  size  of sent packets via ZeroMQ. On the clients, it sets an
           internal buffer size for receiving packets. Note that pkt_size on the clients should be equal  to  or
           greater than pkt_size on the server. Otherwise the received message may be truncated causing decoding
           errors.

</pre><h4><b>DEVICE</b> <b>OPTIONS</b></h4><pre>
       The libavdevice library provides the same interface as libavformat. Namely, an input device is considered
       like  a  demuxer, and an output device like a muxer, and the interface and generic device options are the
       same provided by libavformat (see the ffmpeg-formats manual).

       In addition each input or output device may support so-called private options,  which  are  specific  for
       that component.

       Options may be set by specifying -<u>option</u> <u>value</u> in the FFmpeg tools, or by setting the value explicitly in
       the device "AVFormatContext" options or using the <u>libavutil/opt.h</u> API for programmatic use.

</pre><h4><b>INPUT</b> <b>DEVICES</b></h4><pre>
       Input  devices are configured elements in FFmpeg which enable accessing the data coming from a multimedia
       device attached to your system.

       When you configure your FFmpeg build, all the supported input devices are enabled  by  default.  You  can
       list all available ones using the configure option "--list-indevs".

       You  can  disable  all  the  input devices using the configure option "--disable-indevs", and selectively
       enable an input device using the option "--enable-indev=<u>INDEV</u>", or you can  disable  a  particular  input
       device using the option "--disable-indev=<u>INDEV</u>".

       The option "-devices" of the ff* tools will display the list of supported input devices.

       A description of the currently available input devices follows.

   <b>alsa</b>
       ALSA (Advanced Linux Sound Architecture) input device.

       To enable this input device during configuration you need libasound installed on your system.

       This  device  allows  capturing  from an ALSA device. The name of the device to capture has to be an ALSA
       card identifier.

       An ALSA identifier has the syntax:

               hw:&lt;CARD&gt;[,&lt;DEV&gt;[,&lt;SUBDEV&gt;]]

       where the <u>DEV</u> and <u>SUBDEV</u> components are optional.

       The three arguments (in order: <u>CARD</u>,<u>DEV</u>,<u>SUBDEV</u>) specify card number  or  identifier,  device  number  and
       subdevice number (-1 means any).

       To  see  the  list  of  cards  currently recognized by your system check the files <u>/proc/asound/cards</u> and
       <u>/proc/asound/devices</u>.

       For example to capture with <b>ffmpeg</b> from an ALSA device with card id 0, you may run the command:

               ffmpeg -f alsa -i hw:0 alsaout.wav

       For more information see: &lt;<b><a href="http://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html">http://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html</a></b>&gt;

       <u>Options</u>

       <b>sample_rate</b>
           Set the sample rate in Hz. Default is 48000.

       <b>channels</b>
           Set the number of channels. Default is 2.

   <b>android_camera</b>
       Android camera input device.

       This input devices uses the Android Camera2 NDK API which is available on devices with API level 24+. The
       availability of android_camera is autodetected during configuration.

       This device allows capturing from all cameras on an Android device, which are integrated into the Camera2
       NDK API.

       The available cameras are enumerated internally and can be selected with the <u>camera_index</u> parameter.  The
       input file string is discarded.

       Generally the back facing camera has index 0 while the front facing camera has index 1.

       <u>Options</u>

       <b>video_size</b>
           Set  the  video  size  given as a string such as 640x480 or hd720.  Falls back to the first available
           configuration reported by Android if requested video size is not available or by default.

       <b>framerate</b>
           Set the video framerate.  Falls back to the first available  configuration  reported  by  Android  if
           requested framerate is not available or by default (-1).

       <b>camera_index</b>
           Set the index of the camera to use. Default is 0.

       <b>input_queue_size</b>
           Set the maximum number of frames to buffer. Default is 5.

   <b>avfoundation</b>
       AVFoundation input device.

       AVFoundation is the currently recommended framework by Apple for streamgrabbing on OSX &gt;= 10.7 as well as
       on iOS.

       The input filename has to be given in the following syntax:

               -i "[[VIDEO]:[AUDIO]]"

       The  first  entry selects the video input while the latter selects the audio input.  The stream has to be
       specified by the device name or the device index as shown by the device list.  Alternatively,  the  video
       and/or audio input device can be chosen by index using the

           B&lt;-video_device_index E&lt;lt&gt;INDEXE&lt;gt&gt;&gt;

       and/or

           B&lt;-audio_device_index E&lt;lt&gt;INDEXE&lt;gt&gt;&gt;

       , overriding any device name or index given in the input filename.

       All  available  devices  can  be  enumerated  by  using  <b>-list_devices</b> <b>true</b>, listing all device names and
       corresponding indices.

       There are two device name aliases:

       "default"
           Select the AVFoundation default device of the corresponding type.

       "none"
           Do not record the corresponding media type.  This is equivalent to specifying an empty device name or
           index.

       <u>Options</u>

       AVFoundation supports the following options:

       <b>-list_devices</b> <b>&lt;TRUE|FALSE&gt;</b>
           If set to true, a list of all available input devices is given showing all device names and indices.

       <b>-video_device_index</b> <b>&lt;INDEX&gt;</b>
           Specify the video device by its index. Overrides anything given in the input filename.

       <b>-audio_device_index</b> <b>&lt;INDEX&gt;</b>
           Specify the audio device by its index. Overrides anything given in the input filename.

       <b>-pixel_format</b> <b>&lt;FORMAT&gt;</b>
           Request the video device to use a specific pixel format.  If the specified format is not supported, a
           list of available formats is given and the first one in this list is used  instead.  Available  pixel
           formats are: "monob, rgb555be, rgb555le, rgb565be, rgb565le, rgb24, bgr24, 0rgb, bgr0, 0bgr, rgb0,
            bgr48be, uyvy422, yuva444p, yuva444p16le, yuv444p, yuv422p16, yuv422p10, yuv444p10,
            yuv420p, nv12, yuyv422, gray"

       <b>-framerate</b>
           Set the grabbing frame rate. Default is "ntsc", corresponding to a frame rate of "30000/1001".

       <b>-video_size</b>
           Set the video frame size.

       <b>-capture_cursor</b>
           Capture the mouse pointer. Default is 0.

       <b>-capture_mouse_clicks</b>
           Capture the screen mouse clicks. Default is 0.

       <b>-capture_raw_data</b>
           Capture  the raw device data. Default is 0.  Using this option may result in receiving the underlying
           data delivered to the AVFoundation framework. E.g. for muxed devices that sends raw DV  data  to  the
           framework  (like  tape-based  camcorders),  setting  this  option to false results in extracted video
           frames captured in the designated pixel format only. Setting this option to true results in receiving
           the raw DV stream untouched.

       <u>Examples</u>

       •   Print the list of AVFoundation supported devices and exit:

                   $ ffmpeg -f avfoundation -list_devices true -i ""

       •   Record video from video device 0 and audio from audio device 0 into out.avi:

                   $ ffmpeg -f avfoundation -i "0:0" out.avi

       •   Record video from video device 2 and audio from audio device 1 into out.avi:

                   $ ffmpeg -f avfoundation -video_device_index 2 -i ":1" out.avi

       •   Record video from the system default video device using the pixel format bgr0 and do not  record  any
           audio into out.avi:

                   $ ffmpeg -f avfoundation -pixel_format bgr0 -i "default:none" out.avi

       •   Record raw DV data from a suitable input device and write the output into out.dv:

                   $ ffmpeg -f avfoundation -capture_raw_data true -i "zr100:none" out.dv

   <b>bktr</b>
       BSD  video  input  device.  Deprecated  and  will  be  removed - please contact the developers if you are
       interested in maintaining it.

       <u>Options</u>

       <b>framerate</b>
           Set the frame rate.

       <b>video_size</b>
           Set the video frame size. Default is "vga".

       <b>standard</b>
           Available values are:

           <b>pal</b>
           <b>ntsc</b>
           <b>secam</b>
           <b>paln</b>
           <b>palm</b>
           <b>ntscj</b>

   <b>decklink</b>
       The decklink input device provides capture capabilities for Blackmagic DeckLink devices.

       To enable this input device, you need the Blackmagic DeckLink SDK and you  need  to  configure  with  the
       appropriate  "--extra-cflags"  and  "--extra-ldflags".  On Windows, you need to run the IDL files through
       <b>widl</b>.

       DeckLink is very picky about the formats it  supports.  Pixel  format  of  the  input  can  be  set  with
       <b>raw_format</b>.   Framerate  and  video  size  must be determined for your device with <b>-list_formats</b> <b>1</b>. Audio
       sample rate is always 48 kHz and the number of channels can be 2, 8 or 16. Note that all  audio  channels
       are bundled in one single audio track.

       <u>Options</u>

       <b>list_devices</b>
           If  set  to  <b>true</b>,  print  a list of devices and exit.  Defaults to <b>false</b>. This option is deprecated,
           please use the "-sources" option of ffmpeg to list the available input devices.

       <b>list_formats</b>
           If set to <b>true</b>, print a list of supported formats and exit.  Defaults to <b>false</b>.

       <b>format_code</b> <b>&lt;FourCC&gt;</b>
           This sets the input video format to the format given by the FourCC. To see the  supported  values  of
           your  device(s) use <b>list_formats</b>.  Note that there is a FourCC <b>'pal</b> <b>'</b> that can also be used as <b>pal</b> (3
           letters).  Default behavior is autodetection of the input video format, if the hardware supports it.

       <b>raw_format</b>
           Set the pixel format of the captured video.  Available values are:

           <b>auto</b>
               This is the default which means 8-bit YUV 422 or 8-bit ARGB  if  format  autodetection  is  used,
               8-bit YUV 422 otherwise.

           <b>uyvy422</b>
               8-bit YUV 422.

           <b>yuv422p10</b>
               10-bit YUV 422.

           <b>argb</b>
               8-bit RGB.

           <b>bgra</b>
               8-bit RGB.

           <b>rgb10</b>
               10-bit RGB.

       <b>teletext_lines</b>
           If  set  to nonzero, an additional teletext stream will be captured from the vertical ancillary data.
           Both SD PAL (576i) and HD (1080i or 1080p) sources are supported. In case of HD sources, OP47 packets
           are decoded.

           This option is a bitmask of the SD PAL VBI lines captured, specifically lines 6 to 22, and lines  318
           to  335. Line 6 is the LSB in the mask. Selected lines which do not contain teletext information will
           be ignored. You can use the special <b>all</b> constant to select all possible lines, or  <b>standard</b>  to  skip
           lines 6, 318 and 319, which are not compatible with all receivers.

           For  SD  sources,  ffmpeg  needs  to  be  compiled  with "--enable-libzvbi". For HD sources, on older
           (pre-4K) DeckLink card models you have to capture in 10 bit mode.

       <b>channels</b>
           Defines number of audio channels to capture. Must be <b>2</b>, <b>8</b> or <b>16</b>.  Defaults to <b>2</b>.

       <b>duplex_mode</b>
           Sets the decklink device  duplex/profile  mode.  Must  be  <b>unset</b>,  <b>half</b>,  <b>full</b>,  <b>one_sub_device_full</b>,
           <b>one_sub_device_half</b>, <b>two_sub_device_full</b>, <b>four_sub_device_half</b> Defaults to <b>unset</b>.

           Note:  DeckLink  SDK  11.0 have replaced the duplex property by a profile property.  For the DeckLink
           Duo 2 and DeckLink Quad 2, a profile is shared between  any  2  sub-devices  that  utilize  the  same
           connectors.  For  the  DeckLink 8K Pro, a profile is shared between all 4 sub-devices. So DeckLink 8K
           Pro support four profiles.

           Valid  profile  modes  for  DeckLink  8K  Pro(with  DeckLink  SDK  &gt;=   11.0):   <b>one_sub_device_full</b>,
           <b>one_sub_device_half</b>, <b>two_sub_device_full</b>, <b>four_sub_device_half</b>

           Valid profile modes for DeckLink Quad 2 and DeckLink Duo 2: <b>half</b>, <b>full</b>

       <b>timecode_format</b>
           Timecode type to include in the frame and video stream metadata. Must be <b>none</b>, <b>rp188vitc</b>, <b>rp188vitc2</b>,
           <b>rp188ltc</b>, <b>rp188hfr</b>, <b>rp188any</b>, <b>vitc</b>, <b>vitc2</b>, or <b>serial</b>.  Defaults to <b>none</b> (not included).

           In  order  to  properly  support  50/60 fps timecodes, the ordering of the queried timecode types for
           <b>rp188any</b> is HFR, VITC1, VITC2 and LTC for &gt;30 fps content. Note that this is  slightly  different  to
           the ordering used by the DeckLink API, which is HFR, VITC1, LTC, VITC2.

       <b>video_input</b>
           Sets  the video input source. Must be <b>unset</b>, <b>sdi</b>, <b>hdmi</b>, <b>optical_sdi</b>, <b>component</b>, <b>composite</b> or <b>s_video</b>.
           Defaults to <b>unset</b>.

       <b>audio_input</b>
           Sets the audio input source. Must be <b>unset</b>, <b>embedded</b>,  <b>aes_ebu</b>,  <b>analog</b>,  <b>analog_xlr</b>,  <b>analog_rca</b>  or
           <b>microphone</b>. Defaults to <b>unset</b>.

       <b>video_pts</b>
           Sets  the video packet timestamp source. Must be <b>video</b>, <b>audio</b>, <b>reference</b>, <b>wallclock</b> or <b>abs_wallclock</b>.
           Defaults to <b>video</b>.

       <b>audio_pts</b>
           Sets the audio packet timestamp source. Must be <b>video</b>, <b>audio</b>, <b>reference</b>, <b>wallclock</b> or  <b>abs_wallclock</b>.
           Defaults to <b>audio</b>.

       <b>draw_bars</b>
           If  set  to <b>true</b>, color bars are drawn in the event of a signal loss.  Defaults to <b>true</b>.  This option
           is deprecated, please use the "signal_loss_action" option.

       <b>signal_loss_action</b>
           Sets the action to take in the event of a signal loss. Accepts one of the following values:

           <b>1,</b> <b>none</b>
               Do nothing on signal loss. This usually results in black frames.

           <b>2,</b> <b>bars</b>
               Draw color bars on signal loss. Only supported for 8-bit input signals.

           <b>3,</b> <b>repeat</b>
               Repeat the last video frame on signal loss.

           Defaults to <b>bars</b>.

       <b>queue_size</b>
           Sets maximum input buffer size in bytes. If the buffering reaches this value, incoming frames will be
           dropped.  Defaults to <b>1073741824</b>.

       <b>audio_depth</b>
           Sets the audio sample bit depth. Must be <b>16</b> or <b>32</b>.  Defaults to <b>16</b>.

       <b>decklink_copyts</b>
           If set to <b>true</b>, timestamps are forwarded as they are without removing the initial  offset.   Defaults
           to <b>false</b>.

       <b>timestamp_align</b>
           Capture  start time alignment in seconds. If set to nonzero, input frames are dropped till the system
           timestamp aligns with configured value.   Alignment  difference  of  up  to  one  frame  duration  is
           tolerated.   This is useful for maintaining input synchronization across N different hardware devices
           deployed for 'N-way' redundancy. The system time of different hardware devices should be synchronized
           with protocols such as NTP or PTP, before using this option.  Note that this method is not foolproof.
           In some border cases input synchronization may not happen due to thread scheduling jitters in the OS.
           Either sync could go wrong by 1 frame or in a rarer case <b>timestamp_align</b> seconds.  Defaults to <b>0</b>.

       <b>wait_for_tc</b> <b>(</b><u>bool</u><b>)</b>
           Drop frames till a frame with timecode is received. Sometimes serial timecode isn't received with the
           first input frame. If that happens, the stored stream timecode will be inaccurate. If this option  is
           set to <b>true</b>, input frames are dropped till a frame with timecode is received.  Option <u>timecode_format</u>
           must be specified.  Defaults to <b>false</b>.

       <b>enable_klv(</b><u>bool</u><b>)</b>
           If  set  to  <b>true</b>,  extracts KLV data from VANC and outputs KLV packets.  KLV VANC packets are joined
           based on MID and PSC fields and aggregated into one KLV packet.  Defaults to <b>false</b>.

       <u>Examples</u>

       •   List input devices:

                   ffmpeg -sources decklink

       •   List supported formats:

                   ffmpeg -f decklink -list_formats 1 -i 'Intensity Pro'

       •   Capture video clip at 1080i50:

                   ffmpeg -format_code Hi50 -f decklink -i 'Intensity Pro' -c:a copy -c:v copy output.avi

       •   Capture video clip at 1080i50 10 bit:

                   ffmpeg -raw_format yuv422p10 -format_code Hi50 -f decklink -i 'UltraStudio Mini Recorder' -c:a copy -c:v copy output.avi

       •   Capture video clip at 1080i50 with 16 audio channels:

                   ffmpeg -channels 16 -format_code Hi50 -f decklink -i 'UltraStudio Mini Recorder' -c:a copy -c:v copy output.avi

   <b>dshow</b>
       Windows DirectShow input device.

       DirectShow support is enabled when FFmpeg is built with the mingw-w64 project.  Currently only audio  and
       video devices are supported.

       Multiple  devices  may be opened as separate inputs, but they may also be opened on the same input, which
       should improve synchronism between them.

       The input name should be in the format:

               &lt;TYPE&gt;=&lt;NAME&gt;[:&lt;TYPE&gt;=&lt;NAME&gt;]

       where <u>TYPE</u> can be either <u>audio</u> or <u>video</u>, and <u>NAME</u> is the device's name or alternative name..

       <u>Options</u>

       If no options are specified, the device's defaults  are  used.   If  the  device  does  not  support  the
       requested options, it will fail to open.

       <b>video_size</b>
           Set the video size in the captured video.

       <b>framerate</b>
           Set the frame rate in the captured video.

       <b>sample_rate</b>
           Set the sample rate (in Hz) of the captured audio.

       <b>sample_size</b>
           Set the sample size (in bits) of the captured audio.

       <b>channels</b>
           Set the number of channels in the captured audio.

       <b>list_devices</b>
           If set to <b>true</b>, print a list of devices and exit.

       <b>list_options</b>
           If set to <b>true</b>, print a list of selected device's options and exit.

       <b>video_device_number</b>
           Set video device number for devices with the same name (starts at 0, defaults to 0).

       <b>audio_device_number</b>
           Set audio device number for devices with the same name (starts at 0, defaults to 0).

       <b>pixel_format</b>
           Select pixel format to be used by DirectShow. This may only be set when the video codec is not set or
           set to rawvideo.

       <b>audio_buffer_size</b>
           Set  audio  device  buffer  size in milliseconds (which can directly impact latency, depending on the
           device).  Defaults to using the audio device's  default  buffer  size  (typically  some  multiple  of
           500ms).      Setting    this    value    too    low    can    degrade    performance.     See    also
           &lt;<b><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd377582">http://msdn.microsoft.com/en-us/library/windows/desktop/dd377582</a>(v=vs.85).aspx</b>&gt;

       <b>video_pin_name</b>
           Select video capture pin to use by name or alternative name.

       <b>audio_pin_name</b>
           Select audio capture pin to use by name or alternative name.

       <b>crossbar_video_input_pin_number</b>
           Select video input pin number for crossbar device. This will be routed to the crossbar device's Video
           Decoder output pin.  Note that changing this value can affect future invocations (sets a new default)
           until system reboot occurs.

       <b>crossbar_audio_input_pin_number</b>
           Select audio input pin number for crossbar device. This will be routed to the crossbar device's Audio
           Decoder output pin.  Note that changing this value can affect future invocations (sets a new default)
           until system reboot occurs.

       <b>show_video_device_dialog</b>
           If set to <b>true</b>, before capture starts, popup a display dialog to  the  end  user,  allowing  them  to
           change  video  filter  properties  and  configurations  manually.   Note  that  for crossbar devices,
           adjusting values in this dialog may be needed at times to  toggle  between  PAL  (25  fps)  and  NTSC
           (29.97)  input frame rates, sizes, interlacing, etc.  Changing these values can enable different scan
           rates/frame rates and avoiding green bars at the bottom, flickering scan lines, etc.  Note that  with
           some  devices, changing these properties can also affect future invocations (sets new defaults) until
           system reboot occurs.

       <b>show_audio_device_dialog</b>
           If set to <b>true</b>, before capture starts, popup a display dialog to  the  end  user,  allowing  them  to
           change audio filter properties and configurations manually.

       <b>show_video_crossbar_connection_dialog</b>
           If  set  to  <b>true</b>,  before  capture  starts, popup a display dialog to the end user, allowing them to
           manually modify crossbar pin routings, when it opens a video device.

       <b>show_audio_crossbar_connection_dialog</b>
           If set to <b>true</b>, before capture starts, popup a display dialog to  the  end  user,  allowing  them  to
           manually modify crossbar pin routings, when it opens an audio device.

       <b>show_analog_tv_tuner_dialog</b>
           If  set  to  <b>true</b>,  before  capture  starts, popup a display dialog to the end user, allowing them to
           manually modify TV channels and frequencies.

       <b>show_analog_tv_tuner_audio_dialog</b>
           If set to <b>true</b>, before capture starts, popup a display dialog to  the  end  user,  allowing  them  to
           manually modify TV audio (like mono vs. stereo, Language A,B or C).

       <b>audio_device_load</b>
           Load an audio capture filter device from file instead of searching it by name. It may load additional
           parameters  too, if the filter supports the serialization of its properties to.  To use this an audio
           capture source has to be specified, but it can be anything even fake one.

       <b>audio_device_save</b>
           Save the currently used audio capture filter device and its parameters (if the filter supports it) to
           a file.  If a file with the same name exists it will be overwritten.

       <b>video_device_load</b>
           Load a video capture filter device from file instead of searching it by name. It may load  additional
           parameters  too,  if the filter supports the serialization of its properties to.  To use this a video
           capture source has to be specified, but it can be anything even fake one.

       <b>video_device_save</b>
           Save the currently used video capture filter device and its parameters (if the filter supports it) to
           a file.  If a file with the same name exists it will be overwritten.

       <b>use_video_device_timestamps</b>
           If set to <b>false</b>, the timestamp for video frames will be derived from the  wallclock  instead  of  the
           timestamp  provided by the capture device. This allows working around devices that provide unreliable
           timestamps.

       <u>Examples</u>

       •   Print the list of DirectShow supported devices and exit:

                   $ ffmpeg -list_devices true -f dshow -i dummy

       •   Open video device <u>Camera</u>:

                   $ ffmpeg -f dshow -i video="Camera"

       •   Open second video device with name <u>Camera</u>:

                   $ ffmpeg -f dshow -video_device_number 1 -i video="Camera"

       •   Open video device <u>Camera</u> and audio device <u>Microphone</u>:

                   $ ffmpeg -f dshow -i video="Camera":audio="Microphone"

       •   Print the list of supported options in selected device and exit:

                   $ ffmpeg -list_options true -f dshow -i video="Camera"

       •   Specify pin names to capture by name or alternative name, specify alternative device name:

                   $ ffmpeg -f dshow -audio_pin_name "Audio Out" -video_pin_name 2 -i video=video="@device_pnp_\\?\pci#ven_1a0a&amp;dev_6200&amp;subsys_62021461&amp;rev_01#4&amp;e2c7dd6&amp;0&amp;00e1#{65e8773d-8f56-11d0-a3b9-00a0c9223196}\{ca465100-deb0-4d59-818f-8c477184adf6}":audio="Microphone"

       •   Configure a crossbar device, specifying crossbar pins, allow user to adjust video capture  properties
           at startup:

                   $ ffmpeg -f dshow -show_video_device_dialog true -crossbar_video_input_pin_number 0
                        -crossbar_audio_input_pin_number 3 -i video="AVerMedia BDA Analog Capture":audio="AVerMedia BDA Analog Capture"

   <b>fbdev</b>
       Linux framebuffer input device.

       The  Linux framebuffer is a graphic hardware-independent abstraction layer to show graphics on a computer
       monitor, typically on the console. It is accessed through a file device node, usually <u>/dev/fb0</u>.

       For more detailed information read the file Documentation/fb/framebuffer.txt included in the Linux source
       tree.

       See also &lt;<b><a href="http://linux-fbdev.sourceforge.net/">http://linux-fbdev.sourceforge.net/</a></b>&gt;, and <b><a href="../man1/fbset.1.html">fbset</a></b>(1).

       To record from the framebuffer device <u>/dev/fb0</u> with <b>ffmpeg</b>:

               ffmpeg -f fbdev -framerate 10 -i /dev/fb0 out.avi

       You can take a single screenshot image with the command:

               ffmpeg -f fbdev -framerate 1 -i /dev/fb0 -frames:v 1 screenshot.jpeg

       <u>Options</u>

       <b>framerate</b>
           Set the frame rate. Default is 25.

   <b>gdigrab</b>
       Win32 GDI-based screen capture device.

       This device allows you to capture a region of the display on Windows.

       Amongst options for the imput filenames are such elements as:

               desktop

       or

               title=&lt;window_title&gt;

       or

               hwnd=&lt;window_hwnd&gt;

       The first option will capture the entire desktop, or a fixed region of the desktop. The second and  third
       options will instead capture the contents of a single window, regardless of its position on the screen.

       For example, to grab the entire desktop using <b>ffmpeg</b>:

               ffmpeg -f gdigrab -framerate 6 -i desktop out.mpg

       Grab a 640x480 region at position "10,20":

               ffmpeg -f gdigrab -framerate 6 -offset_x 10 -offset_y 20 -video_size vga -i desktop out.mpg

       Grab the contents of the window named "Calculator"

               ffmpeg -f gdigrab -framerate 6 -i title=Calculator out.mpg

       <u>Options</u>

       <b>draw_mouse</b>
           Specify  whether to draw the mouse pointer. Use the value 0 to not draw the pointer. Default value is
           1.

       <b>framerate</b>
           Set the grabbing frame rate. Default value is "ntsc", corresponding to a frame rate of "30000/1001".

       <b>show_region</b>
           Show grabbed region on screen.

           If <u>show_region</u> is specified with 1, then the grabbing region will be indicated on screen.  With  this
           option, it is easy to know what is being grabbed if only a portion of the screen is grabbed.

           Note that <u>show_region</u> is incompatible with grabbing the contents of a single window.

           For example:

                   ffmpeg -f gdigrab -show_region 1 -framerate 6 -video_size cif -offset_x 10 -offset_y 20 -i desktop out.mpg

       <b>video_size</b>
           Set  the  video  frame size. The default is to capture the full screen if <u>desktop</u> is selected, or the
           full window size if <u>title=window_title</u> is selected.

       <b>offset_x</b>
           When capturing a region with <u>video_size</u>, set the distance  from  the  left  edge  of  the  screen  or
           desktop.

           Note  that  the  offset calculation is from the top left corner of the primary monitor on Windows. If
           you have a monitor positioned to the left of your primary monitor, you will need to  use  a  negative
           <u>offset_x</u> value to move the region to that monitor.

       <b>offset_y</b>
           When capturing a region with <u>video_size</u>, set the distance from the top edge of the screen or desktop.

           Note  that  the  offset calculation is from the top left corner of the primary monitor on Windows. If
           you have a monitor positioned above your primary monitor, you will need to use  a  negative  <u>offset_y</u>
           value to move the region to that monitor.

   <b>iec61883</b>
       FireWire DV/HDV input device using libiec61883.

       To  enable  this  input device, you need libiec61883, libraw1394 and libavc1394 installed on your system.
       Use the configure option "--enable-libiec61883" to compile with the device enabled.

       The iec61883 capture device supports capturing from a video device  connected  via  IEEE1394  (FireWire),
       using  libiec61883  and  the  new Linux FireWire stack (juju). This is the default DV/HDV input method in
       Linux Kernel 2.6.37 and later, since the old FireWire stack was removed.

       Specify the FireWire port to be used as input file, or "auto" to choose the first port connected.

       <u>Options</u>

       <b>dvtype</b>
           Override autodetection of DV/HDV. This should only be used if auto detection does  not  work,  or  if
           usage  of  a  different device type should be prohibited. Treating a DV device as HDV (or vice versa)
           will not work and result in undefined behavior.  The values <b>auto</b>, <b>dv</b> and <b>hdv</b> are supported.

       <b>dvbuffer</b>
           Set maximum size of buffer for incoming data, in frames. For DV, this is an exact value. For HDV,  it
           is not frame exact, since HDV does not have a fixed frame size.

       <b>dvguid</b>
           Select the capture device by specifying its GUID. Capturing will only be performed from the specified
           device  and  fails  if  no device with the given GUID is found. This is useful to select the input if
           multiple devices are connected at the same time.  Look at /sys/bus/firewire/devices to find  out  the
           GUIDs.

       <u>Examples</u>

       •   Grab and show the input of a FireWire DV/HDV device.

                   ffplay -f iec61883 -i auto

       •   Grab and record the input of a FireWire DV/HDV device, using a packet buffer of 100000 packets if the
           source is HDV.

                   ffmpeg -f iec61883 -i auto -dvbuffer 100000 out.mpg

   <b>jack</b>
       JACK input device.

       To enable this input device during configuration you need libjack installed on your system.

       A  JACK  input  device  creates  one or more JACK writable clients, one for each audio channel, with name
       <u>client_name</u>:input_<u>N</u>, where <u>client_name</u> is the name provided by the application, and <u>N</u> is a  number  which
       identifies the channel.  Each writable client will send the acquired data to the FFmpeg input device.

       Once  you  have  created  one or more JACK readable clients, you need to connect them to one or more JACK
       writable clients.

       To connect or disconnect JACK clients you can use the <b>jack_connect</b> and <b>jack_disconnect</b> programs, or do it
       through a graphical interface, for example with <b>qjackctl</b>.

       To list the JACK clients and their properties you can invoke the command <b>jack_lsp</b>.

       Follows an example which shows how to capture a JACK readable client with <b>ffmpeg</b>.

               # Create a JACK writable client with name "ffmpeg".
               $ ffmpeg -f jack -i ffmpeg -y out.wav

               # Start the sample jack_metro readable client.
               $ jack_metro -b 120 -d 0.2 -f 4000

               # List the current JACK clients.
               $ jack_lsp -c
               system:capture_1
               system:capture_2
               system:playback_1
               system:playback_2
               ffmpeg:input_1
               metro:120_bpm

               # Connect metro to the ffmpeg writable client.
               $ jack_connect metro:120_bpm ffmpeg:input_1

       For more information read: &lt;<b><a href="http://jackaudio.org/">http://jackaudio.org/</a></b>&gt;

       <u>Options</u>

       <b>channels</b>
           Set the number of channels. Default is 2.

   <b>kmsgrab</b>
       KMS video input device.

       Captures the KMS scanout framebuffer associated with a specified CRTC or plane as a DRM object  that  can
       be passed to other hardware functions.

       Requires either DRM master or CAP_SYS_ADMIN to run.

       If you don't understand what all of that means, you probably don't want this.  Look at <b>x11grab</b> instead.

       <u>Options</u>

       <b>device</b>
           DRM device to capture on.  Defaults to <b>/dev/dri/card0</b>.

       <b>format</b>
           Pixel format of the framebuffer.  This can be autodetected if you are running Linux 5.7 or later, but
           needs to be provided for earlier versions.  Defaults to <b>bgr0</b>, which is the most common format used by
           the Linux console and Xorg X server.

       <b>format_modifier</b>
           Format  modifier  to  signal on output frames.  This is necessary to import correctly into some APIs.
           It can be autodetected if you are running Linux 5.7 or later, but will need to be provided explicitly
           when needed in earlier versions.  See the libdrm documentation for possible values.

       <b>crtc_id</b>
           KMS CRTC ID to define the capture source.  The first active plane on the given CRTC will be used.

       <b>plane_id</b>
           KMS plane ID to define the capture source.  Defaults to the  first  active  plane  found  if  neither
           <b>crtc_id</b> nor <b>plane_id</b> are specified.

       <b>framerate</b>
           Framerate  to  capture at.  This is not synchronised to any page flipping or framebuffer changes - it
           just defines the interval at which the framebuffer is sampled.  Sampling faster than the  framebuffer
           update rate will generate independent frames with the same content.  Defaults to 30.

       <u>Examples</u>

       •   Capture from the first active plane, download the result to normal frames and encode.  This will only
           work  if the framebuffer is both linear and mappable - if not, the result may be scrambled or fail to
           download.

                   ffmpeg -f kmsgrab -i - -vf 'hwdownload,format=bgr0' output.mp4

       •   Capture from CRTC ID 42 at 60fps, map the result to VAAPI, convert to NV12 and encode as H.264.

                   ffmpeg -crtc_id 42 -framerate 60 -f kmsgrab -i - -vf 'hwmap=derive_device=vaapi,scale_vaapi=w=1920:h=1080:format=nv12' -c:v h264_vaapi output.mp4

       •   To capture only part of a plane the output can be cropped - this can be  used  to  capture  a  single
           window, as long as it has a known absolute position and size.  For example, to capture and encode the
           middle quarter of a 1920x1080 plane:

                   ffmpeg -f kmsgrab -i - -vf 'hwmap=derive_device=vaapi,crop=960:540:480:270,scale_vaapi=960:540:nv12' -c:v h264_vaapi output.mp4

   <b>lavfi</b>
       Libavfilter input virtual device.

       This input device reads data from the open output pads of a libavfilter filtergraph.

       For  each filtergraph open output, the input device will create a corresponding stream which is mapped to
       the generated output.  The filtergraph is specified through the option <b>graph</b>.

       <u>Options</u>

       <b>graph</b>
           Specify the filtergraph to use as input. Each video open output must be labelled by a  unique  string
           of  the  form  "out<u>N</u>",  where  <u>N</u> is a number starting from 0 corresponding to the mapped input stream
           generated by the device.  The first unlabelled output is automatically assigned to the "out0"  label,
           but all the others need to be specified explicitly.

           The  suffix  "+subcc"  can  be appended to the output label to create an extra stream with the closed
           captions packets attached to that output (experimental; only for EIA-608 /  CEA-708  for  now).   The
           subcc  streams  are  created  after all the normal streams, in the order of the corresponding stream.
           For example, if there is "out19+subcc", "out7+subcc" and up to "out42", the stream #43 is  subcc  for
           stream #7 and stream #44 is subcc for stream #19.

           If not specified defaults to the filename specified for the input device.

       <b>graph_file</b>
           Set  the  filename  of  the  filtergraph  to  be  read  and  sent to the other filters. Syntax of the
           filtergraph is the same as the one specified by the option <u>graph</u>.

       <b>dumpgraph</b>
           Dump graph to stderr.

       <u>Examples</u>

       •   Create a color video stream and play it back with <b>ffplay</b>:

                   ffplay -f lavfi -graph "color=c=pink [out0]" dummy

       •   As the previous example, but use filename for specifying the graph description, and omit  the  "out0"
           label:

                   ffplay -f lavfi color=c=pink

       •   Create three different video test filtered sources and play them:

                   ffplay -f lavfi -graph "testsrc [out0]; testsrc,hflip [out1]; testsrc,negate [out2]" test3

       •   Read an audio stream from a file using the amovie source and play it back with <b>ffplay</b>:

                   ffplay -f lavfi "amovie=test.wav"

       •   Read an audio stream and a video stream and play it back with <b>ffplay</b>:

                   ffplay -f lavfi "movie=test.avi[out0];amovie=test.wav[out1]"

       •   Dump decoded frames to images and Closed Captions to an RCWT backup:

                   ffmpeg -f lavfi -i "movie=test.ts[out0+subcc]" -map v frame%08d.png -map s -c copy -f rcwt subcc.bin

   <b>libcdio</b>
       Audio-CD input device based on libcdio.

       To  enable  this input device during configuration you need libcdio installed on your system. It requires
       the configure option "--enable-libcdio".

       This device allows playing and grabbing from an Audio-CD.

       For example to copy with <b>ffmpeg</b> the entire Audio-CD in <u>/dev/sr0</u>, you may run the command:

               ffmpeg -f libcdio -i /dev/sr0 cd.wav

       <u>Options</u>

       <b>speed</b>
           Set drive reading speed. Default value is 0.

           The  speed  is  specified  CD-ROM   speed   units.   The   speed   is   set   through   the   libcdio
           "cdio_cddap_speed_set"  function.  On many CD-ROM drives, specifying a value too large will result in
           using the fastest speed.

       <b>paranoia_mode</b>
           Set paranoia recovery mode flags. It accepts one of the following values:

           <b>disable</b>
           <b>verify</b>
           <b>overlap</b>
           <b>neverskip</b>
           <b>full</b>

           Default value is <b>disable</b>.

           For more information about the available recovery modes, consult the paranoia project documentation.

   <b>libdc1394</b>
       IIDC1394 input device, based on libdc1394 and libraw1394.

       Requires the configure option "--enable-libdc1394".

       <u>Options</u>

       <b>framerate</b>
           Set the frame rate. Default is "ntsc", corresponding to a frame rate of "30000/1001".

       <b>pixel_format</b>
           Select the pixel format. Default is "uyvy422".

       <b>video_size</b>
           Set the video size given as a string such as "640x480" or "hd720".  Default is "qvga".

   <b>openal</b>
       The OpenAL input device provides audio capture on all systems with a working OpenAL 1.1 implementation.

       To enable this input device during configuration, you need OpenAL headers and libraries installed on your
       system, and need to configure FFmpeg with "--enable-openal".

       OpenAL headers and libraries should be  provided  as  part  of  your  OpenAL  implementation,  or  as  an
       additional download (an SDK). Depending on your installation you may need to specify additional flags via
       the "--extra-cflags" and "--extra-ldflags" for allowing the build system to locate the OpenAL headers and
       libraries.

       An incomplete list of OpenAL implementations follows:

       <b>Creative</b>
           The  official  Windows  implementation,  providing  hardware  acceleration with supported devices and
           software fallback.  See &lt;<b><a href="http://openal.org/">http://openal.org/</a></b>&gt;.

       <b>OpenAL</b> <b>Soft</b>
           Portable, open source (LGPL) software implementation. Includes backends for  the  most  common  sound
           APIs     on     the     Windows,    Linux,    Solaris,    and    BSD    operating    systems.     See
           &lt;<b><a href="http://kcat.strangesoft.net/openal.html">http://kcat.strangesoft.net/openal.html</a></b>&gt;.

       <b>Apple</b>
           OpenAL   is   part   of   Core   Audio,   the   official   Mac   OS   X   Audio    interface.     See
           &lt;<b><a href="http://developer.apple.com/technologies/mac/audio-and-video.html">http://developer.apple.com/technologies/mac/audio-and-video.html</a></b>&gt;

       This device allows one to capture from an audio input device handled through OpenAL.

       You  need  to  specify the name of the device to capture in the provided filename. If the empty string is
       provided, the device will automatically select the default device. You can get the list of the  supported
       devices by using the option <u>list_devices</u>.

       <u>Options</u>

       <b>channels</b>
           Set  the  number  of  channels in the captured audio. Only the values <b>1</b> (monaural) and <b>2</b> (stereo) are
           currently supported.  Defaults to <b>2</b>.

       <b>sample_size</b>
           Set the sample size (in bits) of the  captured  audio.  Only  the  values  <b>8</b>  and  <b>16</b>  are  currently
           supported. Defaults to <b>16</b>.

       <b>sample_rate</b>
           Set the sample rate (in Hz) of the captured audio.  Defaults to <b>44.1k</b>.

       <b>list_devices</b>
           If set to <b>true</b>, print a list of devices and exit.  Defaults to <b>false</b>.

       <u>Examples</u>

       Print the list of OpenAL supported devices and exit:

               $ ffmpeg -list_devices true -f openal -i dummy out.ogg

       Capture from the OpenAL device <u>DR-BT101</u> <u>via</u> <u>PulseAudio</u>:

               $ ffmpeg -f openal -i 'DR-BT101 via PulseAudio' out.ogg

       Capture from the default device (note the empty string '' as filename):

               $ ffmpeg -f openal -i '' out.ogg

       Capture from two devices simultaneously, writing to two different files, within the same <b>ffmpeg</b> command:

               $ ffmpeg -f openal -i 'DR-BT101 via PulseAudio' out1.ogg -f openal -i 'ALSA Default' out2.ogg

       Note:  not  all OpenAL implementations support multiple simultaneous capture - try the latest OpenAL Soft
       if the above does not work.

   <b>oss</b>
       Open Sound System input device.

       The filename to provide to the input device is the device node representing the OSS input device, and  is
       usually set to <u>/dev/dsp</u>.

       For example to grab from <u>/dev/dsp</u> using <b>ffmpeg</b> use the command:

               ffmpeg -f oss -i /dev/dsp /tmp/oss.wav

       For more information about OSS see: &lt;<b><a href="http://manuals.opensound.com/usersguide/dsp.html">http://manuals.opensound.com/usersguide/dsp.html</a></b>&gt;

       <u>Options</u>

       <b>sample_rate</b>
           Set the sample rate in Hz. Default is 48000.

       <b>channels</b>
           Set the number of channels. Default is 2.

   <b>pulse</b>
       PulseAudio input device.

       To enable this output device you need to configure FFmpeg with "--enable-libpulse".

       The filename to provide to the input device is a source device or the string "default"

       To list the PulseAudio source devices and their properties you can invoke the command <b>pactl</b> <b>list</b> <b>sources</b>.

       More information about PulseAudio can be found on &lt;<b><a href="http://www.pulseaudio.org">http://www.pulseaudio.org</a></b>&gt;.

       <u>Options</u>

       <b>server</b>
           Connect to a specific PulseAudio server, specified by an IP address.  Default server is used when not
           provided.

       <b>name</b>
           Specify  the  application  name PulseAudio will use when showing active clients, by default it is the
           "LIBAVFORMAT_IDENT" string.

       <b>stream_name</b>
           Specify the stream name PulseAudio will use when showing active streams, by default it is "record".

       <b>sample_rate</b>
           Specify the samplerate in Hz, by default 48kHz is used.

       <b>channels</b>
           Specify the channels in use, by default 2 (stereo) is set.

       <b>frame_size</b>
           This option does nothing and is deprecated.

       <b>fragment_size</b>
           Specify the size in bytes of the minimal buffering fragment in PulseAudio, it will affect  the  audio
           latency. By default it is set to 50 ms amount of data.

       <b>wallclock</b>
           Set the initial PTS using the current time. Default is 1.

       <u>Examples</u>

       Record a stream from default device:

               ffmpeg -f pulse -i default /tmp/pulse.wav

   <b>sndio</b>
       sndio input device.

       To enable this input device during configuration you need libsndio installed on your system.

       The  filename  to provide to the input device is the device node representing the sndio input device, and
       is usually set to <u>/dev/audio0</u>.

       For example to grab from <u>/dev/audio0</u> using <b>ffmpeg</b> use the command:

               ffmpeg -f sndio -i /dev/audio0 /tmp/oss.wav

       <u>Options</u>

       <b>sample_rate</b>
           Set the sample rate in Hz. Default is 48000.

       <b>channels</b>
           Set the number of channels. Default is 2.

   <b>video4linux2,</b> <b>v4l2</b>
       Video4Linux2 input video device.

       "v4l2" can be used as alias for "video4linux2".

       If FFmpeg is built with v4l-utils support (by using  the  "--enable-libv4l2"  configure  option),  it  is
       possible to use it with the "-use_libv4l2" input device option.

       The  name of the device to grab is a file device node, usually Linux systems tend to automatically create
       such nodes when the device (e.g. an USB webcam) is plugged into the system, and has a name  of  the  kind
       <u>/dev/videoN</u>, where <u>N</u> is a number associated to the device.

       Video4Linux2  devices  usually support a limited set of <u>width</u>x<u>height</u> sizes and frame rates. You can check
       which are supported using <b>-list_formats</b> <b>all</b> for Video4Linux2  devices.   Some  devices,  like  TV  cards,
       support  one  or more standards. It is possible to list all the supported standards using <b>-list_standards</b>
       <b>all</b>.

       The time base for the timestamps is 1 microsecond. Depending on the kernel version and configuration, the
       timestamps may be derived from the real time clock (origin at the Unix  Epoch)  or  the  monotonic  clock
       (origin  usually  at boot time, unaffected by NTP or manual changes to the clock). The <b>-timestamps</b> <b>abs</b> or
       <b>-ts</b> <b>abs</b> option can be used to force conversion into the real time clock.

       Some usage examples of the video4linux2 device with <b>ffmpeg</b> and <b>ffplay</b>:

       •   List supported formats for a video4linux2 device:

                   ffplay -f video4linux2 -list_formats all /dev/video0

       •   Grab and show the input of a video4linux2 device:

                   ffplay -f video4linux2 -framerate 30 -video_size hd720 /dev/video0

       •   Grab and record the input of a video4linux2 device, leave the frame rate and size as previously set:

                   ffmpeg -f video4linux2 -input_format mjpeg -i /dev/video0 out.mpeg

       For more information about Video4Linux, check &lt;<b><a href="http://linuxtv.org/">http://linuxtv.org/</a></b>&gt;.

       <u>Options</u>

       <b>standard</b>
           Set the standard. Must be the name of a supported standard. To get a list of the supported standards,
           use the <b>list_standards</b> option.

       <b>channel</b>
           Set the input channel number. Default to -1, which means using the previously selected channel.

       <b>video_size</b>
           Set the video frame size. The argument must be a string in the form  <u>WIDTH</u>x<u>HEIGHT</u>  or  a  valid  size
           abbreviation.

       <b>pixel_format</b>
           Select the pixel format (only valid for raw video input).

       <b>input_format</b>
           Set the preferred pixel format (for raw video) or a codec name.  This option allows one to select the
           input format, when several are available.

       <b>framerate</b>
           Set the preferred video frame rate.

       <b>list_formats</b>
           List available formats (supported pixel formats, codecs, and frame sizes) and exit.

           Available values are:

           <b>all</b> Show all available (compressed and non-compressed) formats.

           <b>raw</b> Show only raw video (non-compressed) formats.

           <b>compressed</b>
               Show only compressed formats.

       <b>list_standards</b>
           List supported standards and exit.

           Available values are:

           <b>all</b> Show all supported standards.

       <b>timestamps,</b> <b>ts</b>
           Set type of timestamps for grabbed frames.

           Available values are:

           <b>default</b>
               Use timestamps from the kernel.

           <b>abs</b> Use absolute timestamps (wall clock).

           <b>mono2abs</b>
               Force conversion from monotonic to absolute timestamps.

           Default value is "default".

       <b>use_libv4l2</b>
           Use libv4l2 (v4l-utils) conversion functions. Default is 0.

   <b>vfwcap</b>
       VfW (Video for Windows) capture input device.

       The  filename  passed  as  input is the capture driver number, ranging from 0 to 9. You may use "list" as
       filename to print a list of drivers. Any other filename will be interpreted as device number 0.

       <u>Options</u>

       <b>video_size</b>
           Set the video frame size.

       <b>framerate</b>
           Set the grabbing frame rate. Default value is "ntsc", corresponding to a frame rate of "30000/1001".

   <b>x11grab</b>
       X11 video input device.

       To enable this input device during configuration you need libxcb installed on your  system.  It  will  be
       automatically detected during configuration.

       This device allows one to capture a region of an X11 display.

       The filename passed as input has the syntax:

               [&lt;hostname&gt;]:&lt;display_number&gt;.&lt;screen_number&gt;[+&lt;x_offset&gt;,&lt;y_offset&gt;]

       <u>hostname</u>:<u>display_number</u>.<u>screen_number</u> specifies the X11 display name of the screen to grab from. <u>hostname</u>
       can  be  omitted,  and  defaults  to  "localhost".  The environment variable <b>DISPLAY</b> contains the default
       display name.

       <u>x_offset</u> and <u>y_offset</u> specify the offsets of the grabbed area with respect to the top-left border of  the
       X11 screen. They default to 0.

       Check the X11 documentation (e.g. <b>man</b> <b>X</b>) for more detailed information.

       Use  the  <b>xdpyinfo</b>  program  for getting basic information about the properties of your X11 display (e.g.
       grep for "name" or "dimensions").

       For example to grab from <u>:0.0</u> using <b>ffmpeg</b>:

               ffmpeg -f x11grab -framerate 25 -video_size cif -i :0.0 out.mpg

       Grab at position "10,20":

               ffmpeg -f x11grab -framerate 25 -video_size cif -i :0.0+10,20 out.mpg

       <u>Options</u>

       <b>select_region</b>
           Specify whether to select the grabbing area graphically using the pointer.  A value of 1 prompts  the
           user  to  select  the  grabbing  area  graphically  by  clicking and dragging. A single click with no
           dragging will select the whole screen. A region with zero width or height will also select the  whole
           screen. This option overwrites the <u>video_size</u>, <u>grab_x</u>, and <u>grab_y</u> options. Default value is 0.

       <b>draw_mouse</b>
           Specify  whether  to  draw the mouse pointer. A value of 0 specifies not to draw the pointer. Default
           value is 1.

       <b>follow_mouse</b>
           Make the grabbed area follow the mouse. The argument can be "centered" or a number of pixels <u>PIXELS</u>.

           When it is specified with "centered", the grabbing region follows the mouse  pointer  and  keeps  the
           pointer  at  the  center of region; otherwise, the region follows only when the mouse pointer reaches
           within <u>PIXELS</u> (greater than zero) to the edge of region.

           For example:

                   ffmpeg -f x11grab -follow_mouse centered -framerate 25 -video_size cif -i :0.0 out.mpg

           To follow only when the mouse pointer reaches within 100 pixels to edge:

                   ffmpeg -f x11grab -follow_mouse 100 -framerate 25 -video_size cif -i :0.0 out.mpg

       <b>framerate</b>
           Set the grabbing frame rate. Default value is "ntsc", corresponding to a frame rate of "30000/1001".

       <b>show_region</b>
           Show grabbed region on screen.

           If <u>show_region</u> is specified with 1, then the grabbing region will be indicated on screen.  With  this
           option, it is easy to know what is being grabbed if only a portion of the screen is grabbed.

       <b>region_border</b>
           Set  the region border thickness if <b>-show_region</b> <b>1</b> is used.  Range is 1 to 128 and default is 3 (XCB-
           based x11grab only).

           For example:

                   ffmpeg -f x11grab -show_region 1 -framerate 25 -video_size cif -i :0.0+10,20 out.mpg

           With <u>follow_mouse</u>:

                   ffmpeg -f x11grab -follow_mouse centered -show_region 1 -framerate 25 -video_size cif -i :0.0 out.mpg

       <b>window_id</b>
           Grab this window, instead of the whole screen. Default value is 0, which maps  to  the  whole  screen
           (root window).

           The id of a window can be found using the <b>xwininfo</b> program, possibly with options -tree and -root.

           If  the window is later enlarged, the new area is not recorded. Video ends when the window is closed,
           unmapped (i.e., iconified) or shrunk beyond the video size (which  defaults  to  the  initial  window
           size).

           This option disables options <b>follow_mouse</b> and <b>select_region</b>.

       <b>video_size</b>
           Set the video frame size. Default is the full desktop or window.

       <b>grab_x</b>
       <b>grab_y</b>
           Set the grabbing region coordinates. They are expressed as offset from the top left corner of the X11
           window  and  correspond to the <u>x_offset</u> and <u>y_offset</u> parameters in the device name. The default value
           for both options is 0.

</pre><h4><b>OUTPUT</b> <b>DEVICES</b></h4><pre>
       Output devices are configured elements in FFmpeg that can write  multimedia  data  to  an  output  device
       attached to your system.

       When  you  configure  your FFmpeg build, all the supported output devices are enabled by default. You can
       list all available ones using the configure option "--list-outdevs".

       You can disable all the output devices using the configure option  "--disable-outdevs",  and  selectively
       enable  an output device using the option "--enable-outdev=<u>OUTDEV</u>", or you can disable a particular input
       device using the option "--disable-outdev=<u>OUTDEV</u>".

       The option "-devices" of the ff* tools will display the list of enabled output devices.

       A description of the currently available output devices follows.

   <b>alsa</b>
       ALSA (Advanced Linux Sound Architecture) output device.

       <u>Examples</u>

       •   Play a file on default ALSA device:

                   ffmpeg -i INPUT -f alsa default

       •   Play a file on soundcard 1, audio device 7:

                   ffmpeg -i INPUT -f alsa hw:1,7

   <b>AudioToolbox</b>
       AudioToolbox output device.

       Allows native output to CoreAudio devices on OSX.

       The output filename can be empty (or "-") to refer to the default system output device or a  number  that
       refers to the device index as shown using: "-list_devices true".

       Alternatively, the audio input device can be chosen by index using the

           B&lt;-audio_device_index E&lt;lt&gt;INDEXE&lt;gt&gt;&gt;

       , overriding any device name or index given in the input filename.

       All  available  devices can be enumerated by using <b>-list_devices</b> <b>true</b>, listing all device names, UIDs and
       corresponding indices.

       <u>Options</u>

       AudioToolbox supports the following options:

       <b>-audio_device_index</b> <b>&lt;INDEX&gt;</b>
           Specify the audio device by its index. Overrides anything given in the output filename.

       <u>Examples</u>

       •   Print the list of supported devices and output a sine wave to the default device:

                   $ ffmpeg -f lavfi -i sine=r=44100 -f audiotoolbox -list_devices true -

       •   Output a sine wave to the device with the index 2, overriding any output filename:

                   $ ffmpeg -f lavfi -i sine=r=44100 -f audiotoolbox -audio_device_index 2 -

   <b>caca</b>
       CACA output device.

       This output device allows one to show a video stream in CACA window.  Only one CACA window is allowed per
       application, so you can have only one instance of this output device in an application.

       To enable this output device you need to configure FFmpeg with "--enable-libcaca".  libcaca is a graphics
       library that outputs text instead of pixels.

       For more information about libcaca, check: &lt;<b><a href="http://caca.zoy.org/wiki/libcaca">http://caca.zoy.org/wiki/libcaca</a></b>&gt;

       <u>Options</u>

       <b>window_title</b>
           Set the CACA window title, if not specified default to the filename specified for the output device.

       <b>window_size</b>
           Set the CACA window size, can be a string of the form <u>width</u>x<u>height</u> or a video size abbreviation.   If
           not specified it defaults to the size of the input video.

       <b>driver</b>
           Set display driver.

       <b>algorithm</b>
           Set  dithering  algorithm.  Dithering is necessary because the picture being rendered has usually far
           more colours than  the  available  palette.   The  accepted  values  are  listed  with  "-list_dither
           algorithms".

       <b>antialias</b>
           Set  antialias  method.  Antialiasing  smoothens  the  rendered  image  and  avoids the commonly seen
           staircase effect.  The accepted values are listed with "-list_dither antialiases".

       <b>charset</b>
           Set which characters are going to be used when rendering text.  The accepted values are  listed  with
           "-list_dither charsets".

       <b>color</b>
           Set color to be used when rendering text.  The accepted values are listed with "-list_dither colors".

       <b>list_drivers</b>
           If set to <b>true</b>, print a list of available drivers and exit.

       <b>list_dither</b>
           List  available  dither  options  related to the argument.  The argument must be one of "algorithms",
           "antialiases", "charsets", "colors".

       <u>Examples</u>

       •   The following command shows the <b>ffmpeg</b> output is an CACA window, forcing its size to 80x25:

                   ffmpeg -i INPUT -c:v rawvideo -pix_fmt rgb24 -window_size 80x25 -f caca -

       •   Show the list of available drivers and exit:

                   ffmpeg -i INPUT -pix_fmt rgb24 -f caca -list_drivers true -

       •   Show the list of available dither colors and exit:

                   ffmpeg -i INPUT -pix_fmt rgb24 -f caca -list_dither colors -

   <b>decklink</b>
       The decklink output device provides playback capabilities for Blackmagic DeckLink devices.

       To enable this output device, you need the Blackmagic DeckLink SDK and you need  to  configure  with  the
       appropriate  "--extra-cflags"  and  "--extra-ldflags".  On Windows, you need to run the IDL files through
       <b>widl</b>.

       DeckLink is very picky about the formats it supports. Pixel format is always  uyvy422,  framerate,  field
       order and video size must be determined for your device with <b>-list_formats</b> <b>1</b>. Audio sample rate is always
       48 kHz.

       <u>Options</u>

       <b>list_devices</b>
           If  set  to  <b>true</b>,  print  a list of devices and exit.  Defaults to <b>false</b>. This option is deprecated,
           please use the "-sinks" option of ffmpeg to list the available output devices.

       <b>list_formats</b>
           If set to <b>true</b>, print a list of supported formats and exit.  Defaults to <b>false</b>.

       <b>preroll</b>
           Amount of time to preroll video in seconds.  Defaults to <b>0.5</b>.

       <b>duplex_mode</b>
           Sets the decklink device  duplex/profile  mode.  Must  be  <b>unset</b>,  <b>half</b>,  <b>full</b>,  <b>one_sub_device_full</b>,
           <b>one_sub_device_half</b>, <b>two_sub_device_full</b>, <b>four_sub_device_half</b> Defaults to <b>unset</b>.

           Note:  DeckLink  SDK  11.0 have replaced the duplex property by a profile property.  For the DeckLink
           Duo 2 and DeckLink Quad 2, a profile is shared between  any  2  sub-devices  that  utilize  the  same
           connectors.  For  the  DeckLink 8K Pro, a profile is shared between all 4 sub-devices. So DeckLink 8K
           Pro support four profiles.

           Valid  profile  modes  for  DeckLink  8K  Pro(with  DeckLink  SDK  &gt;=   11.0):   <b>one_sub_device_full</b>,
           <b>one_sub_device_half</b>, <b>two_sub_device_full</b>, <b>four_sub_device_half</b>

           Valid profile modes for DeckLink Quad 2 and DeckLink Duo 2: <b>half</b>, <b>full</b>

       <b>timing_offset</b>
           Sets the genlock timing pixel offset on the used output.  Defaults to <b>unset</b>.

       <b>link</b>
           Sets  the  SDI video link configuration on the used output. Must be <b>unset</b>, <b>single</b> link SDI, <b>dual</b> link
           SDI or <b>quad</b> link SDI.  Defaults to <b>unset</b>.

       <b>sqd</b> Enable Square Division Quad Split mode for Quad-link SDI output.   Must  be  <b>unset</b>,  <b>true</b>  or  <b>false</b>.
           Defaults to <b>unset</b>.

       <b>level_a</b>
           Enable SMPTE Level A mode on the used output.  Must be <b>unset</b>, <b>true</b> or <b>false</b>.  Defaults to <b>unset</b>.

       <b>vanc_queue_size</b>
           Sets maximum output buffer size in bytes for VANC data. If the buffering reaches this value, outgoing
           VANC data will be dropped.  Defaults to <b>1048576</b>.

       <u>Examples</u>

       •   List output devices:

                   ffmpeg -sinks decklink

       •   List supported formats:

                   ffmpeg -i test.avi -f decklink -list_formats 1 'DeckLink Mini Monitor'

       •   Play video clip:

                   ffmpeg -i test.avi -f decklink -pix_fmt uyvy422 'DeckLink Mini Monitor'

       •   Play video clip with non-standard framerate or video size:

                   ffmpeg -i test.avi -f decklink -pix_fmt uyvy422 -s 720x486 -r 24000/1001 'DeckLink Mini Monitor'

   <b>fbdev</b>
       Linux framebuffer output device.

       The  Linux framebuffer is a graphic hardware-independent abstraction layer to show graphics on a computer
       monitor, typically on the console. It is accessed through a file device node, usually <u>/dev/fb0</u>.

       For more detailed information read the file <u>Documentation/fb/framebuffer.txt</u> included in the Linux source
       tree.

       <u>Options</u>

       <b>xoffset</b>
       <b>yoffset</b>
           Set x/y coordinate of top left corner. Default is 0.

       <u>Examples</u>

       Play a file on framebuffer device  <u>/dev/fb0</u>.   Required  pixel  format  depends  on  current  framebuffer
       settings.

               ffmpeg -re -i INPUT -c:v rawvideo -pix_fmt bgra -f fbdev /dev/fb0

       See also &lt;<b><a href="http://linux-fbdev.sourceforge.net/">http://linux-fbdev.sourceforge.net/</a></b>&gt;, and <b><a href="../man1/fbset.1.html">fbset</a></b>(1).

   <b>opengl</b>
       OpenGL output device. Deprecated and will be removed.

       To enable this output device you need to configure FFmpeg with "--enable-opengl".

       This  output  device  allows  one to render to OpenGL context.  Context may be provided by application or
       default SDL window is created.

       When device renders to external context, application must  implement  handlers  for  following  messages:
       "AV_DEV_TO_APP_CREATE_WINDOW_BUFFER"     -     create     OpenGL     context     on    current    thread.
       "AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER"        -        make        OpenGL         context         current.
       "AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER"  -  swap  buffers.  "AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER" - destroy
       OpenGL context.  Application is also required to inform a device  about  current  resolution  by  sending
       "AV_APP_TO_DEV_WINDOW_SIZE" message.

       <u>Options</u>

       <b>background</b>
           Set background color. Black is a default.

       <b>no_window</b>
           Disables  default SDL window when set to non-zero value.  Application must provide OpenGL context and
           both "window_size_cb" and "window_swap_buffers_cb" callbacks when set.

       <b>window_title</b>
           Set the SDL window title, if not specified default to the filename specified for the  output  device.
           Ignored when <b>no_window</b> is set.

       <b>window_size</b>
           Set preferred window size, can be a string of the form widthxheight or a video size abbreviation.  If
           not  specified  it defaults to the size of the input video, downscaled according to the aspect ratio.
           Mostly usable when <b>no_window</b> is not set.

       <u>Examples</u>

       Play a file on SDL window using OpenGL rendering:

               ffmpeg  -i INPUT -f opengl "window title"

   <b>oss</b>
       OSS (Open Sound System) output device.

   <b>pulse</b>
       PulseAudio output device.

       To enable this output device you need to configure FFmpeg with "--enable-libpulse".

       More information about PulseAudio can be found on &lt;<b><a href="http://www.pulseaudio.org">http://www.pulseaudio.org</a></b>&gt;

       <u>Options</u>

       <b>server</b>
           Connect to a specific PulseAudio server, specified by an IP address.  Default server is used when not
           provided.

       <b>name</b>
           Specify the application name PulseAudio will use when showing active clients, by default  it  is  the
           "LIBAVFORMAT_IDENT" string.

       <b>stream_name</b>
           Specify  the stream name PulseAudio will use when showing active streams, by default it is set to the
           specified output name.

       <b>device</b>
           Specify the device to use. Default device is used when not provided.  List of output devices  can  be
           obtained with command <b>pactl</b> <b>list</b> <b>sinks</b>.

       <b>buffer_size</b>
       <b>buffer_duration</b>
           Control  the  size  and  duration  of  the  PulseAudio buffer. A small buffer gives more control, but
           requires more frequent updates.

           <b>buffer_size</b> specifies size in bytes while <b>buffer_duration</b> specifies duration in milliseconds.

           When both options are provided then the highest value is used  (duration  is  recalculated  to  bytes
           using  stream  parameters).  If they are set to 0 (which is default), the device will use the default
           PulseAudio duration value. By default PulseAudio set buffer duration to around 2 seconds.

       <b>prebuf</b>
           Specify pre-buffering size in bytes. The server does not start with playback before at  least  <b>prebuf</b>
           bytes  are  available  in  the  buffer.  By  default  this option is initialized to the same value as
           <b>buffer_size</b> or <b>buffer_duration</b> (whichever is bigger).

       <b>minreq</b>
           Specify minimum request size in bytes. The server does not request less than <b>minreq</b>  bytes  from  the
           client,  instead  waits  until  the  buffer  is  free  enough  to  request  more bytes at once. It is
           recommended to not set this option, which will initialize this to a value that is deemed sensible  by
           the server.

       <u>Examples</u>

       Play a file on default device on default server:

               ffmpeg  -i INPUT -f pulse "stream name"

   <b>sdl</b>
       SDL (Simple DirectMedia Layer) output device. Deprecated and will be removed.

       For monitoring purposes in FFmpeg, pipes and a video player such as ffplay can be used:

               ffmpeg -i INPUT -f nut -c:v rawvideo - | ffplay -

       "sdl2" can be used as alias for "sdl".

       This output device allows one to show a video stream in an SDL window. Only one SDL window is allowed per
       application, so you can have only one instance of this output device in an application.

       To enable this output device you need libsdl installed on your system when configuring your build.

       For more information about SDL, check: &lt;<b><a href="http://www.libsdl.org/">http://www.libsdl.org/</a></b>&gt;

       <u>Options</u>

       <b>window_borderless</b>
           Set SDL window border off.  Default value is 0 (enable window border).

       <b>window_enable_quit</b>
           Enable  quit  action  (using window button or keyboard key) when non-zero value is provided.  Default
           value is 1 (enable quit action).

       <b>window_fullscreen</b>
           Set fullscreen mode when non-zero value is provided.  Default value is zero.

       <b>window_size</b>
           Set the SDL window size, can be a string of the form <u>width</u>x<u>height</u> or a video size  abbreviation.   If
           not specified it defaults to the size of the input video, downscaled according to the aspect ratio.

       <b>window_title</b>
           Set the SDL window title, if not specified default to the filename specified for the output device.

       <b>window_x</b>
       <b>window_y</b>
           Set the position of the window on the screen.

       <u>Interactive</u> <u>commands</u>

       The window created by the device can be controlled through the following interactive commands.

       <b>q,</b> <b>ESC</b>
           Quit the device immediately.

       <u>Examples</u>

       The following command shows the <b>ffmpeg</b> output is an SDL window, forcing its size to the qcif format:

               ffmpeg -i INPUT -c:v rawvideo -pix_fmt yuv420p -window_size qcif -f sdl "SDL output"

   <b>sndio</b>
       sndio audio output device.

   <b>v4l2</b>
       Video4Linux2 output device.

   <b>xv</b>
       XV (XVideo) output device.

       This output device allows one to show a video stream in a X Window System window.

       <u>Options</u>

       <b>display_name</b>
           Specify the hardware display name, which determines the display and communications domain to be used.

           The   display   name   or   DISPLAY   environment   variable   can   be   a   string  in  the  format
           <u>hostname</u>[:<u>number</u>[.<u>screen_number</u>]].

           <u>hostname</u> specifies the name of the host machine on which the display is physically  attached.  <u>number</u>
           specifies  the  number of the display server on that host machine. <u>screen_number</u> specifies the screen
           to be used on that server.

           If unspecified, it defaults to the value of the DISPLAY environment variable.

           For  example,  "dual-headed:0.1"  would  specify  screen  1  of  display  0  on  the  machine   named
           ``dual-headed''.

           Check the X11 specification for more detailed information about the display name format.

       <b>window_id</b>
           When set to non-zero value then device doesn't create new window, but uses existing one with provided
           <u>window_id</u>. By default this options is set to zero and device creates its own window.

       <b>window_size</b>
           Set  the  created window size, can be a string of the form <u>width</u>x<u>height</u> or a video size abbreviation.
           If not specified it defaults to the size of the input video.  Ignored when <u>window_id</u> is set.

       <b>window_x</b>
       <b>window_y</b>
           Set the X and Y window offsets for the created window. They are both set to 0 by default. The  values
           may be ignored by the window manager.  Ignored when <u>window_id</u> is set.

       <b>window_title</b>
           Set  the  window  title,  if  not  specified default to the filename specified for the output device.
           Ignored when <u>window_id</u> is set.

       For more information about XVideo see &lt;<b><a href="http://www.x.org/">http://www.x.org/</a></b>&gt;.

       <u>Examples</u>

       •   Decode, display and encode video input with <b>ffmpeg</b> at the same time:

                   ffmpeg -i INPUT OUTPUT -f xv display

       •   Decode and display the input video to multiple X11 windows:

                   ffmpeg -i INPUT -f xv normal -vf negate -f xv negated

</pre><h4><b>RESAMPLER</b> <b>OPTIONS</b></h4><pre>
       The audio resampler supports the following named options.

       Options may be set by specifying -<u>option</u> <u>value</u> in  the  FFmpeg  tools,  <u>option</u>=<u>value</u>  for  the  aresample
       filter,  by setting the value explicitly in the "SwrContext" options or using the <u>libavutil/opt.h</u> API for
       programmatic use.

       <b>uchl,</b> <b>used_chlayout</b>
           Set used input channel layout. Default is unset. This option is only used for special remapping.

       <b>isr,</b> <b>in_sample_rate</b>
           Set the input sample rate. Default value is 0.

       <b>osr,</b> <b>out_sample_rate</b>
           Set the output sample rate. Default value is 0.

       <b>isf,</b> <b>in_sample_fmt</b>
           Specify the input sample format. It is set by default to "none".

       <b>osf,</b> <b>out_sample_fmt</b>
           Specify the output sample format. It is set by default to "none".

       <b>tsf,</b> <b>internal_sample_fmt</b>
           Set the internal sample format. Default value is "none".  This will automatically be chosen  when  it
           is not explicitly set.

       <b>ichl,</b> <b>in_chlayout</b>
       <b>ochl,</b> <b>out_chlayout</b>
           Set the input/output channel layout.

           See <b>the</b> <b>Channel</b> <b>Layout</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for the required syntax.

       <b>clev,</b> <b>center_mix_level</b>
           Set the center mix level. It is a value expressed in deciBel, and must be in the interval [-32,32].

       <b>slev,</b> <b>surround_mix_level</b>
           Set the surround mix level. It is a value expressed in deciBel, and must be in the interval [-32,32].

       <b>lfe_mix_level</b>
           Set LFE mix into non LFE level. It is used when there is a LFE input but no LFE output. It is a value
           expressed in deciBel, and must be in the interval [-32,32].

       <b>rmvol,</b> <b>rematrix_volume</b>
           Set rematrix volume. Default value is 1.0.

       <b>rematrix_maxval</b>
           Set maximum output value for rematrixing.  This can be used to prevent clipping vs. preventing volume
           reduction.  A value of 1.0 prevents clipping.

       <b>flags,</b> <b>swr_flags</b>
           Set flags used by the converter. Default value is 0.

           It supports the following individual flags:

           <b>res</b> force  resampling,  this  flag forces resampling to be used even when the input and output sample
               rates match.

       <b>dither_scale</b>
           Set the dither scale. Default value is 1.

       <b>dither_method</b>
           Set dither method. Default value is 0.

           Supported values:

           <b>rectangular</b>
               select rectangular dither

           <b>triangular</b>
               select triangular dither

           <b>triangular_hp</b>
               select triangular dither with high pass

           <b>lipshitz</b>
               select Lipshitz noise shaping dither.

           <b>shibata</b>
               select Shibata noise shaping dither.

           <b>low_shibata</b>
               select low Shibata noise shaping dither.

           <b>high_shibata</b>
               select high Shibata noise shaping dither.

           <b>f_weighted</b>
               select f-weighted noise shaping dither

           <b>modified_e_weighted</b>
               select modified-e-weighted noise shaping dither

           <b>improved_e_weighted</b>
               select improved-e-weighted noise shaping dither

       <b>resampler</b>
           Set resampling engine. Default value is swr.

           Supported values:

           <b>swr</b> select the native SW Resampler; filter options precision and cheby are  not  applicable  in  this
               case.

           <b>soxr</b>
               select  the  SoX  Resampler  (where  available);  compensation,  and  filter options filter_size,
               phase_shift, exact_rational, filter_type &amp; kaiser_beta, are not applicable in this case.

       <b>filter_size</b>
           For swr only, set resampling filter size, default value is 32.

       <b>phase_shift</b>
           For swr only, set resampling phase shift, default value is 10, and must be in the interval [0,30].

       <b>linear_interp</b>
           Use linear interpolation when enabled (the default). Disable it if you want to preserve speed instead
           of quality when exact_rational fails.

       <b>exact_rational</b>
           For swr only, when enabled, try to use exact phase_count based  on  input  and  output  sample  rate.
           However,  if  it  is  larger  than  "1 &lt;&lt; phase_shift", the phase_count will be "1 &lt;&lt; phase_shift" as
           fallback. Default is enabled.

       <b>cutoff</b>
           Set cutoff frequency (swr: 6dB point; soxr: 0dB point) ratio; must be a float value between 0 and  1.
           Default value is 0.97 with swr, and 0.91 with soxr (which, with a sample-rate of 44100, preserves the
           entire audio band to 20kHz).

       <b>precision</b>
           For  soxr  only, the precision in bits to which the resampled signal will be calculated.  The default
           value of 20 (which, with suitable dithering, is appropriate for a destination bit-depth of 16)  gives
           SoX's 'High Quality'; a value of 28 gives SoX's 'Very High Quality'.

       <b>cheby</b>
           For  soxr  only,  selects  passband  rolloff  none  (Chebyshev)  &amp; higher-precision approximation for
           'irrational' ratios. Default value is 0.

       <b>async</b>
           For swr only, simple 1 parameter audio sync to timestamps using stretching,  squeezing,  filling  and
           trimming.  Setting  this  to  1 will enable filling and trimming, larger values represent the maximum
           amount in samples that the data may be stretched or squeezed for each second.  Default  value  is  0,
           thus no compensation is applied to make the samples match the audio timestamps.

       <b>first_pts</b>
           For  swr  only,  assume  the  first pts should be this value. The time unit is 1 / sample rate.  This
           allows for padding/trimming at the start of stream. By default, no assumption is made about the first
           frame's expected pts, so no padding or trimming is done. For example, this could be set to 0  to  pad
           the  beginning  with  silence if an audio stream starts after the video stream or to trim any samples
           with a negative pts due to encoder delay.

       <b>min_comp</b>
           For swr only, set the minimum difference between timestamps and audio data (in  seconds)  to  trigger
           stretching/squeezing/filling  or trimming of the data to make it match the timestamps. The default is
           that stretching/squeezing/filling and trimming is disabled (<b>min_comp</b> = "FLT_MAX").

       <b>min_hard_comp</b>
           For swr only, set the minimum difference between timestamps and audio data (in  seconds)  to  trigger
           adding/dropping  samples  to make it match the timestamps.  This option effectively is a threshold to
           select between hard (trim/fill) and soft (squeeze/stretch) compensation. Note that  all  compensation
           is by default disabled through <b>min_comp</b>.  The default is 0.1.

       <b>comp_duration</b>
           For  swr  only,  set duration (in seconds) over which data is stretched/squeezed to make it match the
           timestamps. Must be a non-negative double float value, default value is 1.0.

       <b>max_soft_comp</b>
           For swr only, set maximum factor by which data is stretched/squeezed to make it match the timestamps.
           Must be a non-negative double float value, default value is 0.

       <b>matrix_encoding</b>
           Select matrixed stereo encoding.

           It accepts the following values:

           <b>none</b>
               select none

           <b>dolby</b>
               select Dolby

           <b>dplii</b>
               select Dolby Pro Logic II

           Default value is "none".

       <b>filter_type</b>
           For swr only, select resampling filter type. This only affects resampling operations.

           It accepts the following values:

           <b>cubic</b>
               select cubic

           <b>blackman_nuttall</b>
               select Blackman Nuttall windowed sinc

           <b>kaiser</b>
               select Kaiser windowed sinc

       <b>kaiser_beta</b>
           For swr only, set Kaiser window beta value. Must be a double float  value  in  the  interval  [2,16],
           default value is 9.

       <b>output_sample_bits</b>
           For swr only, set number of used output sample bits for dithering. Must be an integer in the interval
           [0,64], default value is 0, which means it's not used.

</pre><h4><b>SCALER</b> <b>OPTIONS</b></h4><pre>
       The video scaler supports the following named options.

       Options  may be set by specifying -<u>option</u> <u>value</u> in the FFmpeg tools, with a few API-only exceptions noted
       below.  For programmatic use, they can be set explicitly in  the  "SwsContext"  options  or  through  the
       <u>libavutil/opt.h</u> API.

       <b>sws_flags</b>
           Set  the scaler flags. This is also used to set the scaling algorithm. Only a single algorithm should
           be selected. Default value is <b>bicubic</b>.

           It accepts the following values:

           <b>fast_bilinear</b>
               Select fast bilinear scaling algorithm.

           <b>bilinear</b>
               Select bilinear scaling algorithm.

           <b>bicubic</b>
               Select bicubic scaling algorithm.

           <b>experimental</b>
               Select experimental scaling algorithm.

           <b>neighbor</b>
               Select nearest neighbor rescaling algorithm.

           <b>area</b>
               Select averaging area rescaling algorithm.

           <b>bicublin</b>
               Select bicubic scaling algorithm for the luma component, bilinear for chroma components.

           <b>gauss</b>
               Select Gaussian rescaling algorithm.

           <b>sinc</b>
               Select sinc rescaling algorithm.

           <b>lanczos</b>
               Select Lanczos rescaling algorithm. The default width (alpha) is 3 and can be changed by  setting
               "param0".

           <b>spline</b>
               Select natural bicubic spline rescaling algorithm.

           <b>print_info</b>
               Enable printing/debug logging.

           <b>accurate_rnd</b>
               Enable accurate rounding.

           <b>full_chroma_int</b>
               Enable full chroma interpolation.

           <b>full_chroma_inp</b>
               Select full chroma input.

           <b>bitexact</b>
               Enable bitexact output.

       <b>srcw</b> <u>(API</u> <u>only)</u>
           Set source width.

       <b>srch</b> <u>(API</u> <u>only)</u>
           Set source height.

       <b>dstw</b> <u>(API</u> <u>only)</u>
           Set destination width.

       <b>dsth</b> <u>(API</u> <u>only)</u>
           Set destination height.

       <b>src_format</b> <u>(API</u> <u>only)</u>
           Set source pixel format (must be expressed as an integer).

       <b>dst_format</b> <u>(API</u> <u>only)</u>
           Set destination pixel format (must be expressed as an integer).

       <b>src_range</b> <u>(boolean)</u>
           If  value  is set to 1, indicates source is full range. Default value is 0, which indicates source is
           limited range.

       <b>dst_range</b> <u>(boolean)</u>
           If value is set to 1, enable full range for destination. Default value is 0,  which  enables  limited
           range.

       <b>param0,</b> <b>param1</b>
           Set  scaling  algorithm  parameters. The specified values are specific of some scaling algorithms and
           ignored by others. The specified values are floating point number values.

       <b>sws_dither</b>
           Set the dithering algorithm. Accepts one of the following values. Default value is <b>auto</b>.

           <b>auto</b>
               automatic choice

           <b>none</b>
               no dithering

           <b>bayer</b>
               bayer dither

           <b>ed</b>  error diffusion dither

           <b>a_dither</b>
               arithmetic dither, based using addition

           <b>x_dither</b>
               arithmetic dither, based using xor (more random/less apparent patterning that a_dither).

       <b>alphablend</b>
           Set the alpha blending to use when the input has alpha but the output does  not.   Default  value  is
           <b>none</b>.

           <b>uniform_color</b>
               Blend onto a uniform background color

           <b>checkerboard</b>
               Blend onto a checkerboard

           <b>none</b>
               No blending

</pre><h4><b>FILTERING</b> <b>INTRODUCTION</b></h4><pre>
       Filtering in FFmpeg is enabled through the libavfilter library.

       In  libavfilter,  a  filter  can  have  multiple inputs and multiple outputs.  To illustrate the sorts of
       things that are possible, we consider the following filtergraph.

                               [main]
               input --&gt; split ---------------------&gt; overlay --&gt; output
                           |                             ^
                           |[tmp]                  [flip]|
                           +-----&gt; crop --&gt; vflip -------+

       This filtergraph splits the input stream in two streams, then sends one stream through  the  crop  filter
       and  the  vflip filter, before merging it back with the other stream by overlaying it on top. You can use
       the following command to achieve this:

               ffmpeg -i INPUT -vf "split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2" OUTPUT

       The result will be that the top half of the video is mirrored onto the bottom half of the output video.

       Filters in the same linear chain are separated by commas, and  distinct  linear  chains  of  filters  are
       separated  by  semicolons.  In  our  example,  <u>crop,vflip</u>  are in one linear chain, <u>split</u> and <u>overlay</u> are
       separately in another. The points where the linear chains join are labelled by names enclosed  in  square
       brackets. In the example, the split filter generates two outputs that are associated to the labels <u>[main]</u>
       and <u>[tmp]</u>.

       The  stream  sent to the second output of <u>split</u>, labelled as <u>[tmp]</u>, is processed through the <u>crop</u> filter,
       which crops away the lower half part of the video, and then vertically flipped. The <u>overlay</u> filter  takes
       in  input  the  first unchanged output of the split filter (which was labelled as <u>[main]</u>), and overlay on
       its lower half the output generated by the <u>crop,vflip</u> filterchain.

       Some filters take in input a list of parameters: they are specified after the filter name  and  an  equal
       sign, and are separated from each other by a colon.

       There  exist  so-called  <u>source</u> <u>filters</u> that do not have an audio/video input, and <u>sink</u> <u>filters</u> that will
       not have audio/video output.

</pre><h4><b>GRAPH</b></h4><pre>
       The <u>graph2dot</u> program included in the  FFmpeg  <u>tools</u>  directory  can  be  used  to  parse  a  filtergraph
       description and issue a corresponding textual representation in the dot language.

       Invoke the command:

               graph2dot -h

       to see how to use <u>graph2dot</u>.

       You can then pass the dot description to the <u>dot</u> program (from the graphviz suite of programs) and obtain
       a graphical representation of the filtergraph.

       For example the sequence of commands:

               echo &lt;GRAPH_DESCRIPTION&gt; | \
               tools/graph2dot -o graph.tmp &amp;&amp; \
               dot -Tpng graph.tmp -o graph.png &amp;&amp; \
               display graph.png

       can  be  used  to  create  and display an image representing the graph described by the <u>GRAPH_DESCRIPTION</u>
       string. Note that this string must be a complete  self-contained  graph,  with  its  inputs  and  outputs
       explicitly defined.  For example if your command line is of the form:

               ffmpeg -i infile -vf scale=640:360 outfile

       your <u>GRAPH_DESCRIPTION</u> string will need to be of the form:

               nullsrc,scale=640:360,nullsink

       you  may  also need to set the <u>nullsrc</u> parameters and add a <u>format</u> filter in order to simulate a specific
       input file.

</pre><h4><b>FILTERGRAPH</b> <b>DESCRIPTION</b></h4><pre>
       A filtergraph is a directed graph of connected filters. It can contain cycles, and there can be  multiple
       links between a pair of filters. Each link has one input pad on one side connecting it to one filter from
       which  it takes its input, and one output pad on the other side connecting it to one filter accepting its
       output.

       Each filter in a filtergraph is an instance of a  filter  class  registered  in  the  application,  which
       defines the features and the number of input and output pads of the filter.

       A filter with no input pads is called a "source", and a filter with no output pads is called a "sink".

   <b>Filtergraph</b> <b>syntax</b>
       A   filtergraph   has   a  textual  representation,  which  is  recognized  by  the  <b>-filter</b>/<b>-vf</b>/<b>-af</b>  and
       <b>-filter_complex</b> options in <b>ffmpeg</b> and <b>-vf</b>/<b>-af</b> in <b>ffplay</b>, and by the  avfilter_graph_parse_ptr()  function
       defined in <u>libavfilter/avfilter.h</u>.

       A  filterchain consists of a sequence of connected filters, each one connected to the previous one in the
       sequence. A filterchain is represented by a list of ","-separated filter descriptions.

       A filtergraph consists of a sequence of filterchains. A sequence of filterchains is represented by a list
       of ";"-separated filterchain descriptions.

       A       filter       is       represented       by       a       string        of        the        form:
       [<u>in_link_1</u>]...[<u>in_link_N</u>]<u>filter_name</u>@<u>id</u>=<u>arguments</u>[<u>out_link_1</u>]...[<u>out_link_M</u>]

       <u>filter_name</u>  is  the name of the filter class of which the described filter is an instance of, and has to
       be the name of one of the filter classes registered in the program optionally  followed  by  "@<u>id</u>".   The
       name of the filter class is optionally followed by a string "=<u>arguments</u>".

       <u>arguments</u>  is  a string which contains the parameters used to initialize the filter instance. It may have
       one of two forms:

       •   A ':'-separated list of <u>key=value</u> pairs.

       •   A ':'-separated list of <u>value</u>. In this case, the keys are assumed to be the option names in the order
           they are declared. E.g. the "fade" filter declares three options in this order --  <b>type</b>,  <b>start_frame</b>
           and  <b>nb_frames</b>.  Then  the  parameter  list <u>in:0:30</u> means that the value <u>in</u> is assigned to the option
           <b>type</b>, <u>0</u> to <b>start_frame</b> and <u>30</u> to <b>nb_frames</b>.

       •   A ':'-separated list of mixed direct <u>value</u> and long <u>key=value</u> pairs. The direct  <u>value</u>  must  precede
           the  <u>key=value</u>  pairs,  and  follow  the  same constraints order of the previous point. The following
           <u>key=value</u> pairs can be set in any preferred order.

       If the option value itself is a list of items (e.g. the "format" filter takes a list of  pixel  formats),
       the items in the list are usually separated by <b>|</b>.

       The list of arguments can be quoted using the character <b>'</b> as initial and ending mark, and the character <b>\</b>
       for  escaping  the  characters  within  the  quoted  text;  otherwise  the  argument string is considered
       terminated when the next special character (belonging to the set <b>[]=;,</b>) is encountered.

       A special syntax implemented in the <b>ffmpeg</b> CLI tool allows loading option values from files. This is done
       be prepending a slash '/' to the option name, then the supplied value is interpreted as a path from which
       the actual value is loaded. E.g.

               ffmpeg -i &lt;INPUT&gt; -vf drawtext=/text=/tmp/some_text &lt;OUTPUT&gt;

       will load the text to be drawn from <u>/tmp/some_text</u>. API users wishing  to  implement  a  similar  feature
       should use the "avfilter_graph_segment_*()" functions together with custom IO code.

       The  name  and  arguments of the filter are optionally preceded and followed by a list of link labels.  A
       link label allows one to name a link and associate it to a filter output  or  input  pad.  The  preceding
       labels  <u>in_link_1</u> ... <u>in_link_N</u>, are associated to the filter input pads, the following labels <u>out_link_1</u>
       ... <u>out_link_M</u>, are associated to the output pads.

       When two link labels with the same name are found in the filtergraph, a link  between  the  corresponding
       input and output pad is created.

       If  an  output pad is not labelled, it is linked by default to the first unlabelled input pad of the next
       filter in the filterchain.  For example in the filterchain

               nullsrc, split[L1], [L2]overlay, nullsink

       the split filter instance has two output pads, and the overlay filter instance two input pads. The  first
       output  pad  of  split  is labelled "L1", the first input pad of overlay is labelled "L2", and the second
       output pad of split is linked to the second input pad of overlay, which are both unlabelled.

       In a filter description, if the input label of the first filter is not specified, "in" is assumed; if the
       output label of the last filter is not specified, "out" is assumed.

       In a complete filterchain all  the  unlabelled  filter  input  and  output  pads  must  be  connected.  A
       filtergraph  is  considered  valid  if  all  the filter input and output pads of all the filterchains are
       connected.

       Leading and trailing whitespaces (space, tabs, or  line  feeds)  separating  tokens  in  the  filtergraph
       specification  are ignored. This means that the filtergraph can be expressed using empty lines and spaces
       to improve redability.

       For example, the filtergraph:

               testsrc,split[L1],hflip[L2];[L1][L2] hstack

       can be represented as:

               testsrc,
               split [L1], hflip [L2];

               [L1][L2] hstack

       Libavfilter will automatically insert <b>scale</b> filters where format conversion is required. It  is  possible
       to specify swscale flags for those automatically inserted scalers by prepending "sws_flags=<u>flags</u>;" to the
       filtergraph description.

       Here is a BNF description of the filtergraph syntax:

               &lt;NAME&gt;             ::= sequence of alphanumeric characters and '_'
               &lt;FILTER_NAME&gt;      ::= &lt;NAME&gt;["@"&lt;NAME&gt;]
               &lt;LINKLABEL&gt;        ::= "[" &lt;NAME&gt; "]"
               &lt;LINKLABELS&gt;       ::= &lt;LINKLABEL&gt; [&lt;LINKLABELS&gt;]
               &lt;FILTER_ARGUMENTS&gt; ::= sequence of chars (possibly quoted)
               &lt;FILTER&gt;           ::= [&lt;LINKLABELS&gt;] &lt;FILTER_NAME&gt; ["=" &lt;FILTER_ARGUMENTS&gt;] [&lt;LINKLABELS&gt;]
               &lt;FILTERCHAIN&gt;      ::= &lt;FILTER&gt; [,&lt;FILTERCHAIN&gt;]
               &lt;FILTERGRAPH&gt;      ::= [sws_flags=&lt;flags&gt;;] &lt;FILTERCHAIN&gt; [;&lt;FILTERGRAPH&gt;]

   <b>Notes</b> <b>on</b> <b>filtergraph</b> <b>escaping</b>
       Filtergraph  description  composition  entails several levels of escaping. See <b>the</b> <b>"Quoting</b> <b>and</b> <b>escaping"</b>
       <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for more information about the employed escaping procedure.

       A first level escaping affects the content of each filter option value, which  may  contain  the  special
       character ":" used to separate values, or one of the escaping characters "\'".

       A  second  level escaping affects the whole filter description, which may contain the escaping characters
       "\'" or the special characters "[],;" used by the filtergraph description.

       Finally, when you specify a filtergraph on a shell  commandline,  you  need  to  perform  a  third  level
       escaping for the shell special characters contained within it.

       For example, consider the following string to be embedded in the <b>drawtext</b> filter description <b>text</b> value:

               this is a 'string': may contain one, or more, special characters

       This string contains the "'" special escaping character, and the ":" special character, so it needs to be
       escaped in this way:

               text=this is a \'string\'\: may contain one, or more, special characters

       A  second  level  of  escaping  is  required  when  embedding  the  filter  description  in a filtergraph
       description, in order to escape all the filtergraph special characters. Thus the example above becomes:

               drawtext=text=this is a \\\'string\\\'\\: may contain one\, or more\, special characters

       (note that in addition to the "\'" escaping special characters, also "," needs to be escaped).

       Finally an additional level of escaping is needed when writing the filtergraph  description  in  a  shell
       command,  which  depends  on  the  escaping rules of the adopted shell. For example, assuming that "\" is
       special and needs to be escaped with another "\", the previous string will finally result in:

               -vf "drawtext=text=this is a \\\\\\'string\\\\\\'\\\\: may contain one\\, or more\\, special characters"

       In order to avoid cumbersome escaping when using a commandline tool accepting a filter  specification  as
       input, it is advisable to avoid direct inclusion of the filter or options specification in the shell.

       For example, in case of the <b>drawtext</b> <b>filter</b>, you might prefer to use the <b>textfile</b> option in place of <b>text</b>
       to specify the text to render.

</pre><h4><b>TIMELINE</b> <b>EDITING</b></h4><pre>
       Some  filters  support  a generic <b>enable</b> option. For the filters supporting timeline editing, this option
       can be set to an expression which is evaluated before sending a frame to the filter. If the evaluation is
       non-zero, the filter will be enabled, otherwise the frame will be sent unchanged to the  next  filter  in
       the filtergraph.

       The expression accepts the following values:

       <b>t</b>   timestamp expressed in seconds, NAN if the input timestamp is unknown

       <b>n</b>   sequential number of the input frame, starting from 0

       <b>pos</b> the position in the file of the input frame, NAN if unknown; deprecated, do not use

       <b>w</b>
       <b>h</b>   width and height of the input frame if video

       Additionally, these filters support an <b>enable</b> command that can be used to re-define the expression.

       Like any other filtering option, the <b>enable</b> option follows the same rules.

       For  example,  to  enable  a  blur  filter  (<b>smartblur</b>) from 10 seconds to 3 minutes, and a <b>curves</b> filter
       starting at 3 seconds:

               smartblur = enable='between(t,10,3*60)',
               curves    = enable='gte(t,3)' : preset=cross_process

       See "ffmpeg -filters" to view which filters have timeline support.

</pre><h4><b>CHANGING</b> <b>OPTIONS</b> <b>AT</b> <b>RUNTIME</b> <b>WITH</b> <b>A</b> <b>COMMAND</b></h4><pre>
       Some options can be changed during the operation of the filter using a command. These options are  marked
       'T'  on  the  output  of  <b>ffmpeg</b>  <b>-h</b> <b>filter=&lt;name</b> <b>of</b> <b>filter&gt;</b>.  The name of the command is the name of the
       option and the argument is the new value.

</pre><h4><b>OPTIONS</b> <b>FOR</b> <b>FILTERS</b> <b>WITH</b> <b>SEVERAL</b> <b>INPUTS</b></h4><pre>
       Some filters with several inputs support a common set of options.  These options can only be set by name,
       not with the short notation.

       <b>eof_action</b>
           The action to take when EOF is encountered on the secondary input; it accepts one  of  the  following
           values:

           <b>repeat</b>
               Repeat the last frame (the default).

           <b>endall</b>
               End both streams.

           <b>pass</b>
               Pass the main input through.

       <b>shortest</b>
           If set to 1, force the output to terminate when the shortest input terminates. Default value is 0.

       <b>repeatlast</b>
           If  set  to  1,  force  the filter to extend the last frame of secondary streams until the end of the
           primary stream. A value of 0 disables this behavior.  Default value is 1.

       <b>ts_sync_mode</b>
           How strictly to sync streams based on secondary input timestamps; it accepts  one  of  the  following
           values:

           <b>default</b>
               Frame from secondary input with the nearest lower or equal timestamp to the primary input frame.

           <b>nearest</b>
               Frame from secondary input with the absolute nearest timestamp to the primary input frame.

</pre><h4><b>AUDIO</b> <b>FILTERS</b></h4><pre>
       When   you   configure   your   FFmpeg  build,  you  can  disable  any  of  the  existing  filters  using
       "--disable-filters".  The configure output will show the audio filters included in your build.

       Below is a description of the currently available audio filters.

   <b>aap</b>
       Apply Affine Projection algorithm to the first audio stream using the second audio stream.

       This adaptive filter is used to estimate unknown audio based on multiple  input  audio  samples.   Affine
       projection algorithm can make trade-offs between computation complexity with convergence speed.

       A description of the accepted options follows.

       <b>order</b>
           Set the filter order.

       <b>projection</b>
           Set the projection order.

       <b>mu</b>  Set the filter mu.

       <b>delta</b>
           Set the coefficient to initialize internal covariance matrix.

       <b>out_mode</b>
           Set the filter output samples. It accepts the following values:

           <b>i</b>   Pass the 1st input.

           <b>d</b>   Pass the 2nd input.

           <b>o</b>   Pass difference between desired, 2nd input and error signal estimate.

           <b>n</b>   Pass difference between input, 1st input and error signal estimate.

           <b>e</b>   Pass error signal estimated samples.

               Default value is <u>o</u>.

       <b>precision</b>
           Set which precision to use when processing samples.

           <b>auto</b>
               Auto pick internal sample format depending on other filters.

           <b>float</b>
               Always use single-floating point precision sample format.

           <b>double</b>
               Always use double-floating point precision sample format.

   <b>acompressor</b>
       A  compressor  is mainly used to reduce the dynamic range of a signal.  Especially modern music is mostly
       compressed at a high ratio to improve the overall loudness. It's done to get the highest attention  of  a
       listener,  "fatten" the sound and bring more "power" to the track.  If a signal is compressed too much it
       may sound dull or "dead" afterwards or it may start to "pump" (which could be a powerful effect  but  can
       also  destroy a track completely).  The right compression is the key to reach a professional sound and is
       the high art of mixing and mastering. Because of its complex settings it may take a long time to get  the
       right feeling for this kind of effect.

       Compression  is  done  by  detecting  the  volume above a chosen level "threshold" and dividing it by the
       factor set with "ratio".  So if you set the threshold to -12dB and your signal reaches -6dB  a  ratio  of
       2:1  will  result in a signal at -9dB. Because an exact manipulation of the signal would cause distortion
       of the waveform the reduction can be levelled over the  time.  This  is  done  by  setting  "Attack"  and
       "Release".   "attack" determines how long the signal has to rise above the threshold before any reduction
       will occur and "release" sets the time the signal has to fall below the threshold to reduce the reduction
       again. Shorter signals than the chosen attack time will be left untouched.  The overall reduction of  the
       signal  can  be  made up afterwards with the "makeup" setting. So compressing the peaks of a signal about
       6dB and raising the makeup to this level results in a signal twice as loud than the  source.  To  gain  a
       softer  entry  in  the compression the "knee" flattens the hard edge at the threshold in the range of the
       chosen decibels.

       The filter accepts the following options:

       <b>level_in</b>
           Set input gain. Default is 1. Range is between 0.015625 and 64.

       <b>mode</b>
           Set mode of compressor operation. Can be "upward" or "downward".  Default is "downward".

       <b>threshold</b>
           If a signal of stream rises above this level it will affect the gain reduction.   By  default  it  is
           0.125. Range is between 0.00097563 and 1.

       <b>ratio</b>
           Set a ratio by which the signal is reduced. 1:2 means that if the level rose 4dB above the threshold,
           it will be only 2dB above after the reduction.  Default is 2. Range is between 1 and 20.

       <b>attack</b>
           Amount  of  milliseconds  the  signal  has  to rise above the threshold before gain reduction starts.
           Default is 20. Range is between 0.01 and 2000.

       <b>release</b>
           Amount of milliseconds the signal has to fall below  the  threshold  before  reduction  is  decreased
           again. Default is 250. Range is between 0.01 and 9000.

       <b>makeup</b>
           Set  the amount by how much signal will be amplified after processing.  Default is 1. Range is from 1
           to 64.

       <b>knee</b>
           Curve the sharp knee around the threshold to enter gain reduction more softly.  Default  is  2.82843.
           Range is between 1 and 8.

       <b>link</b>
           Choose  if  the "average" level between all channels of input stream or the louder("maximum") channel
           of input stream affects the reduction. Default is "average".

       <b>detection</b>
           Should the exact signal be taken in case of "peak" or an RMS one in case of "rms". Default  is  "rms"
           which is mostly smoother.

       <b>mix</b> How much to use compressed signal in output. Default is 1.  Range is between 0 and 1.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>acontrast</b>
       Simple audio dynamic range compression/expansion filter.

       The filter accepts the following options:

       <b>contrast</b>
           Set contrast. Default is 33. Allowed range is between 0 and 100.

   <b>acopy</b>
       Copy the input audio source unchanged to the output. This is mainly useful for testing purposes.

   <b>acrossfade</b>
       Apply  cross  fade  from one input audio stream to another input audio stream.  The cross fade is applied
       for specified duration near the end of first stream.

       The filter accepts the following options:

       <b>nb_samples,</b> <b>ns</b>
           Specify the number of samples for which the cross fade effect has to last.  At the end of  the  cross
           fade effect the first input audio will be completely silent. Default is 44100.

       <b>duration,</b> <b>d</b>
           Specify  the  duration of the cross fade effect. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b> for the accepted syntax.  By default the duration is determined by <u>nb_samples</u>.   If  set  this
           option is used instead of <u>nb_samples</u>.

       <b>overlap,</b> <b>o</b>
           Should first stream end overlap with second stream start. Default is enabled.

       <b>curve1</b>
           Set curve for cross fade transition for first stream.

       <b>curve2</b>
           Set curve for cross fade transition for second stream.

           For description of available curve types see <b>afade</b> filter description.

       <u>Examples</u>

       •   Cross fade from one input to another:

                   ffmpeg -i first.flac -i second.flac -filter_complex acrossfade=d=10:c1=exp:c2=exp output.flac

       •   Cross fade from one input to another but without overlapping:

                   ffmpeg -i first.flac -i second.flac -filter_complex acrossfade=d=10:o=0:c1=exp:c2=exp output.flac

   <b>acrossover</b>
       Split audio stream into several bands.

       This  filter  splits  audio stream into two or more frequency ranges.  Summing all streams back will give
       flat output.

       The filter accepts the following options:

       <b>split</b>
           Set split frequencies. Those must be positive and increasing.

       <b>order</b>
           Set filter order for each band split. This controls filter roll-off or steepness of  filter  transfer
           function.  Available values are:

           <b>2nd</b> 12 dB per octave.

           <b>4th</b> 24 dB per octave.

           <b>6th</b> 36 dB per octave.

           <b>8th</b> 48 dB per octave.

           <b>10th</b>
               60 dB per octave.

           <b>12th</b>
               72 dB per octave.

           <b>14th</b>
               84 dB per octave.

           <b>16th</b>
               96 dB per octave.

           <b>18th</b>
               108 dB per octave.

           <b>20th</b>
               120 dB per octave.

           Default is <u>4th</u>.

       <b>level</b>
           Set input gain level. Allowed range is from 0 to 1. Default value is 1.

       <b>gains</b>
           Set output gain for each band. Default value is 1 for all bands.

       <b>precision</b>
           Set which precision to use when processing samples.

           <b>auto</b>
               Auto pick internal sample format depending on other filters.

           <b>float</b>
               Always use single-floating point precision sample format.

           <b>double</b>
               Always use double-floating point precision sample format.

           Default value is "auto".

       <u>Examples</u>

       •   Split  input  audio  stream  into two bands (low and high) with split frequency of 1500 Hz, each band
           will be in separate stream:

                   ffmpeg -i in.flac -filter_complex 'acrossover=split=1500[LOW][HIGH]' -map '[LOW]' low.wav -map '[HIGH]' high.wav

       •   Same as above, but with higher filter order:

                   ffmpeg -i in.flac -filter_complex 'acrossover=split=1500:order=8th[LOW][HIGH]' -map '[LOW]' low.wav -map '[HIGH]' high.wav

       •   Same as above, but also with additional middle band (frequencies between 1500 and 8000):

                   ffmpeg -i in.flac -filter_complex 'acrossover=split=1500 8000:order=8th[LOW][MID][HIGH]' -map '[LOW]' low.wav -map '[MID]' mid.wav -map '[HIGH]' high.wav

   <b>acrusher</b>
       Reduce audio bit resolution.

       This filter is bit crusher with enhanced functionality. A bit crusher is used to audibly reduce number of
       bits an audio signal is sampled with. This doesn't change the bit depth at  all,  it  just  produces  the
       effect. Material reduced in bit depth sounds more harsh and "digital".  This filter is able to even round
       to  continuous  values instead of discrete bit depths.  Additionally it has a D/C offset which results in
       different crushing of the lower and the upper half of the signal.  An Anti-Aliasing setting  is  able  to
       produce "softer" crushing sounds.

       Another  feature  of  this  filter  is the logarithmic mode.  This setting switches from linear distances
       between bits to logarithmic ones.  The result is a much more "natural"  sounding  crusher  which  doesn't
       gate  low  signals  for  example. The human ear has a logarithmic perception, so this kind of crushing is
       much more pleasant.  Logarithmic crushing is also able to get anti-aliased.

       The filter accepts the following options:

       <b>level_in</b>
           Set level in.

       <b>level_out</b>
           Set level out.

       <b>bits</b>
           Set bit reduction.

       <b>mix</b> Set mixing amount.

       <b>mode</b>
           Can be linear: "lin" or logarithmic: "log".

       <b>dc</b>  Set DC.

       <b>aa</b>  Set anti-aliasing.

       <b>samples</b>
           Set sample reduction.

       <b>lfo</b> Enable LFO. By default disabled.

       <b>lforange</b>
           Set LFO range.

       <b>lforate</b>
           Set LFO rate.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>acue</b>
       Delay audio filtering until a given wallclock timestamp. See the <b>cue</b> filter.

   <b>adeclick</b>
       Remove impulsive noise from input audio.

       Samples detected as impulsive noise are replaced by interpolated samples using autoregressive modelling.

       <b>window,</b> <b>w</b>
           Set window size, in milliseconds. Allowed range is from 10 to 100. Default value is 55  milliseconds.
           This sets size of window which will be processed at once.

       <b>overlap,</b> <b>o</b>
           Set window overlap, in percentage of window size. Allowed range is from 50 to 95. Default value is 75
           percent.  Setting this to a very high value increases impulsive noise removal but makes whole process
           much slower.

       <b>arorder,</b> <b>a</b>
           Set  autoregression order, in percentage of window size. Allowed range is from 0 to 25. Default value
           is 2 percent. This option also controls quality of interpolated samples using neighbour good samples.

       <b>threshold,</b> <b>t</b>
           Set threshold value. Allowed range is from 1 to 100.  Default value is 2.  This controls the strength
           of impulsive noise which is going to be removed.  The lower value, the more samples will be  detected
           as impulsive noise.

       <b>burst,</b> <b>b</b>
           Set burst fusion, in percentage of window size. Allowed range is 0 to 10. Default value is 2.  If any
           two  samples  detected  as  noise  are  spaced less than this value then any sample between those two
           samples will be also detected as noise.

       <b>method,</b> <b>m</b>
           Set overlap method.

           It accepts the following values:

           <b>add,</b> <b>a</b>
               Select overlap-add method. Even not interpolated samples are slightly changed with this method.

           <b>save,</b> <b>s</b>
               Select overlap-save method. Not interpolated samples remain unchanged.

           Default value is "a".

   <b>adeclip</b>
       Remove clipped samples from input audio.

       Samples detected as clipped are replaced by interpolated samples using autoregressive modelling.

       <b>window,</b> <b>w</b>
           Set window size, in milliseconds. Allowed range is from 10 to 100.  Default value is 55 milliseconds.
           This sets size of window which will be processed at once.

       <b>overlap,</b> <b>o</b>
           Set window overlap, in percentage of window size. Allowed range is from 50 to 95. Default value is 75
           percent.

       <b>arorder,</b> <b>a</b>
           Set autoregression order, in percentage of window size. Allowed range is from 0 to 25. Default  value
           is 8 percent. This option also controls quality of interpolated samples using neighbour good samples.

       <b>threshold,</b> <b>t</b>
           Set  threshold  value.  Allowed range is from 1 to 100.  Default value is 10. Higher values make clip
           detection less aggressive.

       <b>hsize,</b> <b>n</b>
           Set size of histogram used to detect clips. Allowed range is from 100  to  9999.   Default  value  is
           1000. Higher values make clip detection less aggressive.

       <b>method,</b> <b>m</b>
           Set overlap method.

           It accepts the following values:

           <b>add,</b> <b>a</b>
               Select overlap-add method. Even not interpolated samples are slightly changed with this method.

           <b>save,</b> <b>s</b>
               Select overlap-save method. Not interpolated samples remain unchanged.

           Default value is "a".

   <b>adecorrelate</b>
       Apply decorrelation to input audio stream.

       The filter accepts the following options:

       <b>stages</b>
           Set decorrelation stages of filtering. Allowed range is from 1 to 16. Default value is 6.

       <b>seed</b>
           Set random seed used for setting delay in samples across channels.

   <b>adelay</b>
       Delay one or more audio channels.

       Samples in delayed channel are filled with silence.

       The filter accepts the following option:

       <b>delays</b>
           Set list of delays in milliseconds for each channel separated by '|'.  Unused delays will be silently
           ignored. If number of given delays is smaller than number of channels all remaining channels will not
           be delayed.  If you want to delay exact number of samples, append 'S' to number.  If you want instead
           to delay in seconds, append 's' to number.

       <b>all</b> Use  last  set  delay  for  all  remaining  channels. By default is disabled.  This option if enabled
           changes how option "delays" is interpreted.

       <u>Examples</u>

       •   Delay first channel by 1.5 seconds, the third channel by 0.5 seconds and  leave  the  second  channel
           (and any other channels that may be present) unchanged.

                   adelay=1500|0|500

       •   Delay  second  channel  by  500 samples, the third channel by 700 samples and leave the first channel
           (and any other channels that may be present) unchanged.

                   adelay=0|500S|700S

       •   Delay all channels by same number of samples:

                   adelay=delays=64S:all=1

   <b>adenorm</b>
       Remedy denormals in audio by adding extremely low-level noise.

       This filter shall be placed before any filter that can produce denormals.

       A description of the accepted parameters follows.

       <b>level</b>
           Set level of added noise in dB. Default is -351.  Allowed range is from -451 to -90.

       <b>type</b>
           Set type of added noise.

           <b>dc</b>  Add DC signal.

           <b>ac</b>  Add AC signal.

           <b>square</b>
               Add square signal.

           <b>pulse</b>
               Add pulse signal.

           Default is "dc".

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>aderivative,</b> <b>aintegral</b>
       Compute derivative/integral of audio stream.

       Applying both filters one after another produces original audio.

   <b>adrc</b>
       Apply spectral dynamic range controller filter to input audio stream.

       A description of the accepted options follows.

       <b>transfer</b>
           Set the transfer expression.

           The expression can contain the following constants:

           <b>ch</b>  current channel number

           <b>sn</b>  current sample number

           <b>nb_channels</b>
               number of channels

           <b>t</b>   timestamp expressed in seconds

           <b>sr</b>  sample rate

           <b>p</b>   current frequency power value, in dB

           <b>f</b>   current frequency in Hz

           Default value is "p".

       <b>attack</b>
           Set the attack in milliseconds. Default is  50  milliseconds.   Allowed  range  is  from  1  to  1000
           milliseconds.

       <b>release</b>
           Set  the  release  in  milliseconds.  Default  is  100 milliseconds.  Allowed range is from 5 to 2000
           milliseconds.

       <b>channels</b>
           Set which channels to filter, by default "all" channels in audio stream are filtered.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

       <u>Examples</u>

       •   Apply spectral compression to all frequencies with threshold of -50 dB and 1:6 ratio:

                   adrc=transfer='if(gt(p,-50),-50+(p-(-50))/6,p)':attack=50:release=100

       •   Similar to above but with 1:2 ratio and filtering only front center channel:

                   adrc=transfer='if(gt(p,-50),-50+(p-(-50))/2,p)':attack=50:release=100:channels=FC

       •   Apply spectral noise gate to all frequencies with threshold of -85 dB and with short attack time  and
           short release time:

                   adrc=transfer='if(lte(p,-85),p-800,p)':attack=1:release=5

       •   Apply spectral expansion to all frequencies with threshold of -10 dB and 1:2 ratio:

                   adrc=transfer='if(lt(p,-10),-10+(p-(-10))*2,p)':attack=50:release=100

       •   Apply limiter to max -60 dB to all frequencies, with attack of 2 ms and release of 10 ms:

                   adrc=transfer='min(p,-60)':attack=2:release=10

   <b>adynamicequalizer</b>
       Apply dynamic equalization to input audio stream.

       A description of the accepted options follows.

       <b>threshold</b>
           Set  the  detection  threshold  used to trigger equalization.  Threshold detection is using detection
           filter.  Default value is 0. Allowed range is from 0 to 100.

       <b>dfrequency</b>
           Set the detection frequency in Hz used for detection filter used to  trigger  equalization.   Default
           value is 1000 Hz. Allowed range is between 2 and 1000000 Hz.

       <b>dqfactor</b>
           Set  the detection resonance factor for detection filter used to trigger equalization.  Default value
           is 1. Allowed range is from 0.001 to 1000.

       <b>tfrequency</b>
           Set the target frequency of equalization filter.  Default value is 1000 Hz. Allowed range is  between
           2 and 1000000 Hz.

       <b>tqfactor</b>
           Set the target resonance factor for target equalization filter.  Default value is 1. Allowed range is
           from 0.001 to 1000.

       <b>attack</b>
           Set  the  amount  of milliseconds the signal from detection has to rise above the detection threshold
           before equalization starts.  Default is 20. Allowed range is between 1 and 2000.

       <b>release</b>
           Set the amount of milliseconds the signal from detection has to fall below  the  detection  threshold
           before equalization ends.  Default is 200. Allowed range is between 1 and 2000.

       <b>ratio</b>
           Set the ratio by which the equalization gain is raised.  Default is 1. Allowed range is between 0 and
           30.

       <b>makeup</b>
           Set  the  makeup  offset  by  which  the equalization gain is raised.  Default is 0. Allowed range is
           between 0 and 100.

       <b>range</b>
           Set the max allowed cut/boost amount. Default is 50.  Allowed range is from 1 to 200.

       <b>mode</b>
           Set the mode of filter operation, can be one of the following:

           <b>listen</b>
               Output only isolated detection signal.

           <b>cutbelow</b>
               Cut frequencies below detection threshold.

           <b>cutabove</b>
               Cut frequencies above detection threshold.

           <b>boostbelow</b>
               Boost frequencies below detection threshold.

           <b>boostabove</b>
               Boost frequencies above detection threshold.

           Default mode is <b>cutbelow</b>.

       <b>dftype</b>
           Set the type of detection filter, can be one of the following:

           <b>bandpass</b>
           <b>lowpass</b>
           <b>highpass</b>
           <b>peak</b>

           Default type is <b>bandpass</b>.

       <b>tftype</b>
           Set the type of target filter, can be one of the following:

           <b>bell</b>
           <b>lowshelf</b>
           <b>highshelf</b>

           Default type is <b>bell</b>.

       <b>auto</b>
           Automatically gather threshold from detection filter. By default is <b>disabled</b>.  This option is  useful
           to detect threshold in certain time frame of input audio stream, in such case option value is changed
           at runtime.

           Available values are:

           <b>disabled</b>
               Disable using automatically gathered threshold value.

           <b>off</b> Stop picking threshold value.

           <b>on</b>  Start picking threshold value.

           <b>adaptive</b>
               Adaptively pick threshold value, by calculating sliding window entropy.

       <b>precision</b>
           Set which precision to use when processing samples.

           <b>auto</b>
               Auto pick internal sample format depending on other filters.

           <b>float</b>
               Always use single-floating point precision sample format.

           <b>double</b>
               Always use double-floating point precision sample format.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>adynamicsmooth</b>
       Apply dynamic smoothing to input audio stream.

       A description of the accepted options follows.

       <b>sensitivity</b>
           Set  an  amount  of  sensitivity  to frequency fluctations. Default is 2.  Allowed range is from 0 to
           1e+06.

       <b>basefreq</b>
           Set a base frequency for smoothing. Default value is 22050.  Allowed range is from 2 to 1e+06.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>aecho</b>
       Apply echoing to the input audio.

       Echoes are reflected sound and can occur naturally amongst mountains (and sometimes large buildings) when
       talking or shouting; digital echo effects emulate this behaviour and are often used to help fill out  the
       sound of a single instrument or vocal. The time difference between the original signal and the reflection
       is  the  "delay",  and  the  loudness  of  the reflected signal is the "decay".  Multiple echoes can have
       different delays and decays.

       A description of the accepted parameters follows.

       <b>in_gain</b>
           Set input gain of reflected signal. Default is 0.6.

       <b>out_gain</b>
           Set output gain of reflected signal. Default is 0.3.

       <b>delays</b>
           Set list of time intervals in milliseconds between original signal and reflections separated by  '|'.
           Allowed range for each "delay" is "(0 - 90000.0]".  Default is 1000.

       <b>decays</b>
           Set  list of loudness of reflected signals separated by '|'.  Allowed range for each "decay" is "(0 -
           1.0]".  Default is 0.5.

       <u>Examples</u>

       •   Make it sound as if there are twice as many instruments as are actually playing:

                   aecho=0.8:0.88:60:0.4

       •   If delay is very short, then it sounds like a (metallic) robot playing music:

                   aecho=0.8:0.88:6:0.4

       •   A longer delay will sound like an open air concert in the mountains:

                   aecho=0.8:0.9:1000:0.3

       •   Same as above but with one more mountain:

                   aecho=0.8:0.9:1000|1800:0.3|0.25

   <b>aemphasis</b>
       Audio emphasis filter creates or restores material directly taken from LPs or emphased CDs with different
       filter curves. E.g. to store music on vinyl the signal has to be altered by a filter first  to  even  out
       the  disadvantages  of this recording medium.  Once the material is played back the inverse filter has to
       be applied to restore the distortion of the frequency response.

       The filter accepts the following options:

       <b>level_in</b>
           Set input gain.

       <b>level_out</b>
           Set output gain.

       <b>mode</b>
           Set filter mode. For restoring material use "reproduction" mode,  otherwise  use  "production"  mode.
           Default is "reproduction" mode.

       <b>type</b>
           Set filter type. Selects medium. Can be one of the following:

           <b>col</b> select Columbia.

           <b>emi</b> select EMI.

           <b>bsi</b> select BSI (78RPM).

           <b>riaa</b>
               select RIAA.

           <b>cd</b>  select Compact Disc (CD).

           <b>50fm</b>
               select 50µs (FM).

           <b>75fm</b>
               select 75µs (FM).

           <b>50kf</b>
               select 50µs (FM-KF).

           <b>75kf</b>
               select 75µs (FM-KF).

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>aeval</b>
       Modify an audio signal according to the specified expressions.

       This  filter  accepts  one  or  more  expressions (one for each channel), which are evaluated and used to
       modify a corresponding audio signal.

       It accepts the following parameters:

       <b>exprs</b>
           Set the '|'-separated expressions list for each separate channel. If the number of input channels  is
           greater  than  the  number  of  expressions,  the last specified expression is used for the remaining
           output channels.

       <b>channel_layout,</b> <b>c</b>
           Set output channel layout. If not specified, the  channel  layout  is  specified  by  the  number  of
           expressions. If set to <b>same</b>, it will use by default the same input channel layout.

       Each expression in <u>exprs</u> can contain the following constants and functions:

       <b>ch</b>  channel number of the current expression

       <b>n</b>   number of the evaluated sample, starting from 0

       <b>s</b>   sample rate

       <b>t</b>   time of the evaluated sample expressed in seconds

       <b>nb_in_channels</b>
       <b>nb_out_channels</b>
           input and output number of channels

       <b>val(CH)</b>
           the value of input channel with number <u>CH</u>

       Note: this filter is slow. For faster processing you should use a dedicated filter.

       <u>Examples</u>

       •   Half volume:

                   aeval=val(ch)/2:c=same

       •   Invert phase of the second channel:

                   aeval=<a href="../man0/val.0.html">val</a>(0)|-<a href="../man1/val.1.html">val</a>(1)

   <b>aexciter</b>
       An  exciter  is  used  to  produce high sound that is not present in the original signal. This is done by
       creating harmonic distortions of the signal which are restricted in  range  and  added  to  the  original
       signal.  An Exciter raises the upper end of an audio signal without simply raising the higher frequencies
       like an equalizer would do to create a more "crisp" or "brilliant" sound.

       The filter accepts the following options:

       <b>level_in</b>
           Set input level prior processing of signal.  Allowed range is from 0 to 64.  Default value is 1.

       <b>level_out</b>
           Set output level after processing of signal.  Allowed range is from 0 to 64.  Default value is 1.

       <b>amount</b>
           Set  the amount of harmonics added to original signal.  Allowed range is from 0 to 64.  Default value
           is 1.

       <b>drive</b>
           Set the amount of newly created harmonics.  Allowed range is from 0.1 to 10.  Default value is 8.5.

       <b>blend</b>
           Set the octave of newly created harmonics.  Allowed range is from -10 to 10.  Default value is 0.

       <b>freq</b>
           Set the lower frequency limit of producing harmonics in Hz.  Allowed range is from 2000 to 12000  Hz.
           Default is 7500 Hz.

       <b>ceil</b>
           Set  the  upper  frequency limit of producing harmonics.  Allowed range is from 9999 to 20000 Hz.  If
           value is lower than 10000 Hz no limit is applied.

       <b>listen</b>
           Mute the original signal and output only added harmonics.  By default is disabled.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>afade</b>
       Apply fade-in/out effect to input audio.

       A description of the accepted parameters follows.

       <b>type,</b> <b>t</b>
           Specify the effect type, can be either "in" for fade-in, or "out" for a fade-out effect.  Default  is
           "in".

       <b>start_sample,</b> <b>ss</b>
           Specify the number of the start sample for starting to apply the fade effect. Default is 0.

       <b>nb_samples,</b> <b>ns</b>
           Specify the number of samples for which the fade effect has to last. At the end of the fade-in effect
           the  output audio will have the same volume as the input audio, at the end of the fade-out transition
           the output audio will be silence. Default is 44100.

       <b>start_time,</b> <b>st</b>
           Specify the start time of the fade effect. Default is 0.  The value  must  be  specified  as  a  time
           duration;  see  <b>the</b>  <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for the accepted syntax.  If
           set this option is used instead of <u>start_sample</u>.

       <b>duration,</b> <b>d</b>
           Specify the duration of the fade effect. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>  <b>manual</b>
           for the accepted syntax.  At the end of the fade-in effect the output audio will have the same volume
           as  the  input  audio,  at  the  end of the fade-out transition the output audio will be silence.  By
           default the duration is determined by <u>nb_samples</u>.  If set this option is used instead of <u>nb_samples</u>.

       <b>curve</b>
           Set curve for fade transition.

           It accepts the following values:

           <b>tri</b> select triangular, linear slope (default)

           <b>qsin</b>
               select quarter of sine wave

           <b>hsin</b>
               select half of sine wave

           <b>esin</b>
               select exponential sine wave

           <b>log</b> select logarithmic

           <b>ipar</b>
               select inverted parabola

           <b>qua</b> select quadratic

           <b>cub</b> select cubic

           <b>squ</b> select square root

           <b>cbr</b> select cubic root

           <b>par</b> select parabola

           <b>exp</b> select exponential

           <b>iqsin</b>
               select inverted quarter of sine wave

           <b>ihsin</b>
               select inverted half of sine wave

           <b>dese</b>
               select double-exponential seat

           <b>desi</b>
               select double-exponential sigmoid

           <b>losi</b>
               select logistic sigmoid

           <b>sinc</b>
               select sine cardinal function

           <b>isinc</b>
               select inverted sine cardinal function

           <b>quat</b>
               select quartic

           <b>quatr</b>
               select quartic root

           <b>qsin2</b>
               select squared quarter of sine wave

           <b>hsin2</b>
               select squared half of sine wave

           <b>nofade</b>
               no fade applied

       <b>silence</b>
           Set the initial gain for fade-in or final gain for fade-out.  Default value is 0.0.

       <b>unity</b>
           Set the initial gain for fade-out or final gain for fade-in.  Default value is 1.0.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

       <u>Examples</u>

       •   Fade in first 15 seconds of audio:

                   afade=t=in:ss=0:d=15

       •   Fade out last 25 seconds of a 900 seconds audio:

                   afade=t=out:st=875:d=25

   <b>afftdn</b>
       Denoise audio samples with FFT.

       A description of the accepted parameters follows.

       <b>noise_reduction,</b> <b>nr</b>
           Set the noise reduction in dB, allowed range is 0.01 to 97.  Default value is 12 dB.

       <b>noise_floor,</b> <b>nf</b>
           Set the noise floor in dB, allowed range is -80 to -20.  Default value is -50 dB.

       <b>noise_type,</b> <b>nt</b>
           Set the noise type.

           It accepts the following values:

           <b>white,</b> <b>w</b>
               Select white noise.

           <b>vinyl,</b> <b>v</b>
               Select vinyl noise.

           <b>shellac,</b> <b>s</b>
               Select shellac noise.

           <b>custom,</b> <b>c</b>
               Select custom noise, defined in "bn" option.

               Default value is white noise.

       <b>band_noise,</b> <b>bn</b>
           Set custom band noise profile for every one of 15 bands.  Bands are separated by ' ' or '|'.

       <b>residual_floor,</b> <b>rf</b>
           Set the residual floor in dB, allowed range is -80 to -20.  Default value is -38 dB.

       <b>track_noise,</b> <b>tn</b>
           Enable noise floor tracking. By default is disabled.  With this enabled, noise floor is automatically
           adjusted.

       <b>track_residual,</b> <b>tr</b>
           Enable residual tracking. By default is disabled.

       <b>output_mode,</b> <b>om</b>
           Set the output mode.

           It accepts the following values:

           <b>input,</b> <b>i</b>
               Pass input unchanged.

           <b>output,</b> <b>o</b>
               Pass noise filtered out.

           <b>noise,</b> <b>n</b>
               Pass only noise.

               Default value is <u>output</u>.

       <b>adaptivity,</b> <b>ad</b>
           Set the adaptivity factor, used how fast to adapt gains adjustments per each frequency bin.  Value  <u>0</u>
           enables  instant  adaptation,  while  higher values react much slower.  Allowed range is from <u>0</u> to <u>1</u>.
           Default value is <u>0.5</u>.

       <b>floor_offset,</b> <b>fo</b>
           Set the noise floor offset factor. This option is used to adjust offset  applied  to  measured  noise
           floor. It is only effective when noise floor tracking is enabled.  Allowed range is from <u>-2.0</u> to <u>2.0</u>.
           Default value is <u>1.0</u>.

       <b>noise_link,</b> <b>nl</b>
           Set the noise link used for multichannel audio.

           It accepts the following values:

           <b>none</b>
               Use unchanged channel's noise floor.

           <b>min</b> Use measured min noise floor of all channels.

           <b>max</b> Use measured max noise floor of all channels.

           <b>average</b>
               Use measured average noise floor of all channels.

               Default value is <u>min</u>.

       <b>band_multiplier,</b> <b>bm</b>
           Set  the  band multiplier factor, used how much to spread bands across frequency bins.  Allowed range
           is from <u>0.2</u> to <u>5</u>. Default value is <u>1.25</u>.

       <b>sample_noise,</b> <b>sn</b>
           Toggle capturing and measurement of noise profile from input audio.

           It accepts the following values:

           <b>start,</b> <b>begin</b>
               Start sample noise capture.

           <b>stop,</b> <b>end</b>
               Stop sample noise capture and measure new noise band profile.

               Default value is "none".

       <b>gain_smooth,</b> <b>gs</b>
           Set gain smooth spatial radius, used to smooth gains applied to each frequency bin.  Useful to reduce
           random music noise artefacts.  Higher values increases smoothing of gains.  Allowed range is  from  0
           to 50.  Default value is 0.

       <u>Commands</u>

       This filter supports the some above mentioned options as <b>commands</b>.

       <u>Examples</u>

       •   Reduce white noise by 10dB, and use previously measured noise floor of -40dB:

                   afftdn=nr=10:nf=-40

       •   Reduce  white  noise  by 10dB, also set initial noise floor to -80dB and enable automatic tracking of
           noise floor so noise floor will gradually change during processing:

                   afftdn=nr=10:nf=-80:tn=1

       •   Reduce noise by 20dB, using noise floor of -40dB and using commands to take noise  profile  of  first
           0.4 seconds of input audio:

                   asendcmd=0.0 afftdn sn start,asendcmd=0.4 afftdn sn stop,afftdn=nr=20:nf=-40

   <b>afftfilt</b>
       Apply arbitrary expressions to samples in frequency domain.

       <b>real</b>
           Set frequency domain real expression for each separate channel separated by '|'. Default is "re".  If
           the number of input channels is greater than the number of expressions, the last specified expression
           is used for the remaining output channels.

       <b>imag</b>
           Set  frequency  domain  imaginary  expression  for each separate channel separated by '|'. Default is
           "im".

           Each expression in <u>real</u> and <u>imag</u> can contain the following constants and functions:

           <b>sr</b>  sample rate

           <b>b</b>   current frequency bin number

           <b>nb</b>  number of available bins

           <b>ch</b>  channel number of the current expression

           <b>chs</b> number of channels

           <b>pts</b> current frame pts

           <b>re</b>  current real part of frequency bin of current channel

           <b>im</b>  current imaginary part of frequency bin of current channel

           <b>real(b,</b> <b>ch)</b>
               Return the value of real part of frequency bin at location (<u>bin</u>,<u>channel</u>)

           <b>imag(b,</b> <b>ch)</b>
               Return the value of imaginary part of frequency bin at location (<u>bin</u>,<u>channel</u>)

       <b>win_size</b>
           Set window size. Allowed range is from 16 to 131072.  Default is 4096

       <b>win_func</b>
           Set window function.

           It accepts the following values:

           <b>rect</b>
           <b>bartlett</b>
           <b>hann,</b> <b>hanning</b>
           <b>hamming</b>
           <b>blackman</b>
           <b>welch</b>
           <b>flattop</b>
           <b>bharris</b>
           <b>bnuttall</b>
           <b>bhann</b>
           <b>sine</b>
           <b>nuttall</b>
           <b>lanczos</b>
           <b>gauss</b>
           <b>tukey</b>
           <b>dolph</b>
           <b>cauchy</b>
           <b>parzen</b>
           <b>poisson</b>
           <b>bohman</b>
           <b>kaiser</b>

           Default is "hann".

       <b>overlap</b>
           Set window overlap. If set to 1, the recommended overlap for selected window function will be picked.
           Default is 0.75.

       <u>Examples</u>

       •   Leave almost only low frequencies in audio:

                   afftfilt="'real=re * (1-clip((b/nb)*b,0,1))':imag='im * (1-clip((b/nb)*b,0,1))'"

       •   Apply robotize effect:

                   afftfilt="real='hypot(re,im)*<a href="../man0/sin.0.html">sin</a>(0)':imag='hypot(re,im)*<a href="../man0/cos.0.html">cos</a>(0)':win_size=512:overlap=0.75"

       •   Apply whisper effect:

                   afftfilt="real='hypot(re,im)*cos((<a href="../man0/random.0.html">random</a>(0)*2-1)*2*3.14)':imag='hypot(re,im)*sin((<a href="../man1/random.1.html">random</a>(1)*2-1)*2*3.14)':win_size=128:overlap=0.8"

       •   Apply phase shift:

                   afftfilt="real=re*<a href="../man1/cos.1.html">cos</a>(1)-im*<a href="../man1/sin.1.html">sin</a>(1):imag=re*<a href="../man1/sin.1.html">sin</a>(1)+im*<a href="../man1/cos.1.html">cos</a>(1)"

   <b>afir</b>
       Apply an arbitrary Finite Impulse Response filter.

       This filter is designed for applying long FIR filters, up to 60 seconds long.

       It can be used as component for digital crossover filters, room equalization,  cross  talk  cancellation,
       wavefield synthesis, auralization, ambiophonics, ambisonics and spatialization.

       This  filter uses the streams higher than first one as FIR coefficients.  If the non-first stream holds a
       single channel, it will be used for all input channels in the  first  stream,  otherwise  the  number  of
       channels in the non-first stream must be same as the number of channels in the first stream.

       It accepts the following parameters:

       <b>dry</b> Set dry gain. This sets input gain.

       <b>wet</b> Set wet gain. This sets final output gain.

       <b>length</b>
           Set Impulse Response filter length. Default is 1, which means whole IR is processed.

       <b>gtype</b>
           This option is deprecated, and does nothing.

       <b>irnorm</b>
           Set  norm  to  be  applied  to  IR coefficients before filtering.  Allowed range is from <u>-1</u> to <u>2</u>.  IR
           coefficients are normalized with calculated vector norm set by this option.  For negative values,  no
           norm is calculated, and IR coefficients are not modified at all.  Default is <u>1</u>.

       <b>irlink</b>
           For  multichannel  IR  if this option is set to <u>true</u>, all IR channels will be normalized with maximal
           measured gain of all IR channels coefficients as set by  "irnorm"  option.   When  disabled,  all  IR
           coefficients in each IR channel will be normalized independently.  Default is <u>true</u>.

       <b>irgain</b>
           Set  gain  to  be applied to IR coefficients before filtering.  Allowed range is 0 to 1. This gain is
           applied after any gain applied with <u>irnorm</u> option.

       <b>irfmt</b>
           Set format of IR stream. Can be "mono" or "input".  Default is "input".

       <b>maxir</b>
           Set max allowed Impulse Response filter duration in seconds. Default is 30 seconds.  Allowed range is
           0.1 to 60 seconds.

       <b>response</b>
           This option is deprecated, and does nothing.

       <b>channel</b>
           This option is deprecated, and does nothing.

       <b>size</b>
           This option is deprecated, and does nothing.

       <b>rate</b>
           This option is deprecated, and does nothing.

       <b>minp</b>
           Set minimal partition size used for convolution. Default is <u>8192</u>.  Allowed range is from <u>1</u> to  <u>65536</u>.
           Lower values decreases latency at cost of higher CPU usage.

       <b>maxp</b>
           Set  maximal partition size used for convolution. Default is <u>8192</u>.  Allowed range is from <u>8</u> to <u>65536</u>.
           Lower values may increase CPU usage.

       <b>nbirs</b>
           Set number of input impulse responses streams which will be switchable at runtime.  Allowed range  is
           from <u>1</u> to <u>32</u>. Default is <u>1</u>.

       <b>ir</b>  Set  IR  stream  which  will  be  used  for convolution, starting from <u>0</u>, should always be lower than
           supplied value by "nbirs" option. Default is <u>0</u>.  This option can be changed at runtime via <b>commands</b>.

       <b>precision</b>
           Set which precision to use when processing samples.

           <b>auto</b>
               Auto pick internal sample format depending on other filters.

           <b>float</b>
               Always use single-floating point precision sample format.

           <b>double</b>
               Always use double-floating point precision sample format.

           Default value is auto.

       <b>irload</b>
           Set when to load IR stream. Can be "init" or "access".  First  one  load  and  prepares  all  IRs  on
           initialization, second one once on first access of specific IR.  Default is "init".

       <u>Examples</u>

       •   Apply reverb to stream using mono IR file as second input, complete command using ffmpeg:

                   ffmpeg -i input.wav -i middle_tunnel_1way_mono.wav -lavfi afir output.wav

       •   Apply true stereo processing given input stereo stream, and two stereo impulse responses for left and
           right  channel,  the  impulse  response files are files with names l_ir.wav and r_ir.wav, and setting
           irnorm option value:

                   "pan=4C|c0=FL|c1=FL|c2=FR|c3=FR[a];amovie=l_ir.wav[LIR];amovie=r_ir.wav[RIR];[LIR][RIR]amerge[ir];[a][ir]afir=irfmt=input:irnorm=1.2,pan=stereo|FL&lt;c0+c2|FR&lt;c1+c3"

       •   Similar to above example, but with "irgain" explicitly set  to  estimated  value  and  with  "irnorm"
           disabled:

                   "pan=4C|c0=FL|c1=FL|c2=FR|c3=FR[a];amovie=l_ir.wav[LIR];amovie=r_ir.wav[RIR];[LIR][RIR]amerge[ir];[a][ir]afir=irfmt=input:irgain=-5dB:irnom=-1,pan=stereo|FL&lt;c0+c2|FR&lt;c1+c3"

   <b>aformat</b>
       Set  output  format  constraints  for  the input audio. The framework will negotiate the most appropriate
       format to minimize conversions.

       It accepts the following parameters:

       <b>sample_fmts,</b> <b>f</b>
           A '|'-separated list of requested sample formats.

       <b>sample_rates,</b> <b>r</b>
           A '|'-separated list of requested sample rates.

       <b>channel_layouts,</b> <b>cl</b>
           A '|'-separated list of requested channel layouts.

           See <b>the</b> <b>Channel</b> <b>Layout</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for the required syntax.

       If a parameter is omitted, all values are allowed.

       Force the output to either unsigned 8-bit or signed 16-bit stereo

               aformat=sample_fmts=u8|s16:channel_layouts=stereo

   <b>afreqshift</b>
       Apply frequency shift to input audio samples.

       The filter accepts the following options:

       <b>shift</b>
           Specify frequency shift. Allowed range is -INT_MAX to INT_MAX.  Default value is 0.0.

       <b>level</b>
           Set output gain applied to final output. Allowed range is from 0.0 to 1.0.  Default value is 1.0.

       <b>order</b>
           Set filter order used for filtering. Allowed range is from 1 to 16.  Default value is 8.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>afwtdn</b>
       Reduce broadband noise from input samples using Wavelets.

       A description of the accepted options follows.

       <b>sigma</b>
           Set the noise sigma, allowed range is from 0 to  1.   Default  value  is  0.   This  option  controls
           strength  of denoising applied to input samples.  Most useful way to set this option is via decibels,
           eg. -45dB.

       <b>levels</b>
           Set the number of wavelet levels of decomposition.  Allowed range is from 1 to 12.  Default value  is
           10.  Setting this too low make denoising performance very poor.

       <b>wavet</b>
           Set  wavelet  type for decomposition of input frame.  They are sorted by number of coefficients, from
           lowest to highest.  More coefficients means  worse  filtering  speed,  but  overall  better  quality.
           Available wavelets are:

           <b>sym2</b>
           <b>sym4</b>
           <b>rbior68</b>
           <b>deb10</b>
           <b>sym10</b>
           <b>coif5</b>
           <b>bl3</b>
       <b>percent</b>
           Set  percent  of full denoising. Allowed range is from 0 to 100 percent.  Default value is 85 percent
           or partial denoising.

       <b>profile</b>
           If enabled, first input frame will be used as noise profile.  If first  frame  samples  contain  non-
           noise performance will be very poor.

       <b>adaptive</b>
           If  enabled,  input  frames  are  analyzed  for  presence  of  noise.  If noise is detected with high
           possibility then input frame profile will be used for processing following frames,  until  new  noise
           frame is detected.

       <b>samples</b>
           Set size of single frame in number of samples. Allowed range is from 512 to 65536. Default frame size
           is 8192 samples.

       <b>softness</b>
           Set softness applied inside thresholding function. Allowed range is from 0 to 10. Default softness is
           1.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>agate</b>
       A  gate  is  mainly  used  to  reduce  lower  parts  of  a signal. This kind of signal processing reduces
       disturbing noise between useful signals.

       Gating is done by detecting the volume below a chosen level <u>threshold</u> and dividing it by the  factor  set
       with  <u>ratio</u>.  The bottom of the noise floor is set via <u>range</u>. Because an exact manipulation of the signal
       would cause distortion of the waveform the reduction can be levelled over time. This is done  by  setting
       <u>attack</u> and <u>release</u>.

       <u>attack</u> determines how long the signal has to fall below the threshold before any reduction will occur and
       <u>release</u>  sets the time the signal has to rise above the threshold to reduce the reduction again.  Shorter
       signals than the chosen attack time will be left untouched.

       <b>level_in</b>
           Set input level before filtering.  Default is 1. Allowed range is from 0.015625 to 64.

       <b>mode</b>
           Set the mode of operation. Can be "upward" or "downward".  Default is "downward". If set to  "upward"
           mode,  higher  parts  of  signal  will  be  amplified,  expanding  dynamic range in upward direction.
           Otherwise, in case of "downward" lower parts of signal will be reduced.

       <b>range</b>
           Set the level of gain reduction when the signal is below the threshold.  Default is 0.06125.  Allowed
           range is from 0 to 1.  Setting this to 0 disables reduction and then filter behaves like expander.

       <b>threshold</b>
           If  a  signal rises above this level the gain reduction is released.  Default is 0.125. Allowed range
           is from 0 to 1.

       <b>ratio</b>
           Set a ratio by which the signal is reduced.  Default is 2. Allowed range is from 1 to 9000.

       <b>attack</b>
           Amount of milliseconds the signal has to rise  above  the  threshold  before  gain  reduction  stops.
           Default is 20 milliseconds. Allowed range is from 0.01 to 9000.

       <b>release</b>
           Amount  of  milliseconds the signal has to fall below the threshold before the reduction is increased
           again. Default is 250 milliseconds.  Allowed range is from 0.01 to 9000.

       <b>makeup</b>
           Set amount of amplification of signal after processing.  Default is 1. Allowed range is from 1 to 64.

       <b>knee</b>
           Curve the sharp knee  around  the  threshold  to  enter  gain  reduction  more  softly.   Default  is
           2.828427125. Allowed range is from 1 to 8.

       <b>detection</b>
           Choose  if  exact  signal should be taken for detection or an RMS like one.  Default is "rms". Can be
           "peak" or "rms".

       <b>link</b>
           Choose if the average level between all  channels  or  the  louder  channel  affects  the  reduction.
           Default is "average". Can be "average" or "maximum".

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>aiir</b>
       Apply an arbitrary Infinite Impulse Response filter.

       It accepts the following parameters:

       <b>zeros,</b> <b>z</b>
           Set B/numerator/zeros/reflection coefficients.

       <b>poles,</b> <b>p</b>
           Set A/denominator/poles/ladder coefficients.

       <b>gains,</b> <b>k</b>
           Set channels gains.

       <b>dry_gain</b>
           Set input gain.

       <b>wet_gain</b>
           Set output gain.

       <b>format,</b> <b>f</b>
           Set coefficients format.

           <b>ll</b>  lattice-ladder function

           <b>sf</b>  analog transfer function

           <b>tf</b>  digital transfer function

           <b>zp</b>  Z-plane zeros/poles, cartesian (default)

           <b>pr</b>  Z-plane zeros/poles, polar radians

           <b>pd</b>  Z-plane zeros/poles, polar degrees

           <b>sp</b>  S-plane zeros/poles

       <b>process,</b> <b>r</b>
           Set type of processing.

           <b>d</b>   direct processing

           <b>s</b>   serial processing

           <b>p</b>   parallel processing

       <b>precision,</b> <b>e</b>
           Set filtering precision.

           <b>dbl</b> double-precision floating-point (default)

           <b>flt</b> single-precision floating-point

           <b>i32</b> 32-bit integers

           <b>i16</b> 16-bit integers

       <b>normalize,</b> <b>n</b>
           Normalize  filter coefficients, by default is enabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>mix</b> How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>response</b>
           Show IR frequency response, <a href="../manmagenta/magnitude.magenta.html">magnitude</a>(magenta), phase(green) and group  delay(yellow)  in  additional
           video stream.  By default it is disabled.

       <b>channel</b>
           Set  for  which IR channel to display frequency response. By default is first channel displayed. This
           option is used only when <u>response</u> is enabled.

       <b>size</b>
           Set video stream size. This option is used only when <u>response</u> is enabled.

       Coefficients in "tf" and "sf" format are separated by spaces and are in ascending order.

       Coefficients in  "zp"  format  are  separated  by  spaces  and  order  of  coefficients  doesn't  matter.
       Coefficients in "zp" format are complex numbers with <u>i</u> imaginary unit.

       Different  coefficients  and  gains  can  be provided for every channel, in such case use '|' to separate
       coefficients or gains. Last provided coefficients will be used for all remaining channels.

       <u>Examples</u>

       •   Apply 2 pole elliptic notch at around 5000Hz for 48000 Hz sample rate:

                   aiir=k=1:z=7.957584807809675810E-1 -2.575128568908332300 3.674839853930788710 -2.57512875289799137 7.957586296317130880E-1:p=1 -2.86950072432325953 3.63022088054647218 -2.28075678147272232 6.361362326477423500E-1:f=tf:r=d

       •   Same as above but in "zp" format:

                   aiir=k=0.79575848078096756:z=0.80918701+0.58773007i 0.80918701-0.58773007i 0.80884700+0.58784055i 0.80884700-0.58784055i:p=0.63892345+0.59951235i 0.63892345-0.59951235i 0.79582691+0.44198673i 0.79582691-0.44198673i:f=zp:r=s

       •   Apply 3-rd order analog normalized  Butterworth  low-pass  filter,  using  analog  transfer  function
           format:

                   aiir=z=1.3057 0 0 0:p=1.3057 2.3892 2.1860 1:f=sf:r=d

   <b>alimiter</b>
       The  limiter  prevents an input signal from rising over a desired threshold.  This limiter uses lookahead
       technology to prevent your signal from distorting.  It means that there is a small delay after the signal
       is processed. Keep in mind that the delay it produces is the attack time you set.

       The filter accepts the following options:

       <b>level_in</b>
           Set input gain. Default is 1.

       <b>level_out</b>
           Set output gain. Default is 1.

       <b>limit</b>
           Don't let signals above this level pass the limiter. Default is 1.

       <b>attack</b>
           The limiter will reach its attenuation level in this amount of time in  milliseconds.  Default  is  5
           milliseconds.

       <b>release</b>
           Come  back  from  limiting  to  attenuation  1.0  in  this  amount  of  milliseconds.   Default is 50
           milliseconds.

       <b>asc</b> When gain reduction is always needed ASC takes care of releasing to an average reduction level rather
           than reaching a reduction of 0 in the release time.

       <b>asc_level</b>
           Select how much the release time is affected by ASC, 0 means nearly no changes in release time  while
           1 produces higher release times.

       <b>level</b>
           Auto level output signal. Default is enabled.  This normalizes audio back to 0dB if enabled.

       <b>latency</b>
           Compensate  the  delay introduced by using the lookahead buffer set with attack parameter. Also flush
           the valid audio data in the lookahead buffer when the stream hits EOF.

       Depending on picked setting it is recommended to upsample input 2x or  4x  times  with  <b>aresample</b>  before
       applying this filter.

   <b>allpass</b>
       Apply  a  two-pole  all-pass filter with central frequency (in Hz) <u>frequency</u>, and filter-width <u>width</u>.  An
       all-pass filter changes the audio's frequency to phase relationship without  changing  its  frequency  to
       amplitude relationship.

       The filter accepts the following options:

       <b>frequency,</b> <b>f</b>
           Set frequency in Hz.

       <b>width_type,</b> <b>t</b>
           Set method to specify band-width of filter.

           <b>h</b>   Hz

           <b>q</b>   Q-Factor

           <b>o</b>   octave

           <b>s</b>   slope

           <b>k</b>   kHz

       <b>width,</b> <b>w</b>
           Specify the band-width of a filter in width_type units.

       <b>mix,</b> <b>m</b>
           How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>channels,</b> <b>c</b>
           Specify which channels to filter, by default all available are filtered.

       <b>normalize,</b> <b>n</b>
           Normalize biquad coefficients, by default is disabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>order,</b> <b>o</b>
           Set the filter order, can be 1 or 2. Default is 2.

       <b>transform,</b> <b>a</b>
           Set transform type of IIR filter.

           <b>di</b>
           <b>dii</b>
           <b>tdi</b>
           <b>tdii</b>
           <b>latt</b>
           <b>svf</b>
           <b>zdf</b>
       <b>precision,</b> <b>r</b>
           Set precision of filtering.

           <b>auto</b>
               Pick automatic sample format depending on surround filters.

           <b>s16</b> Always use signed 16-bit.

           <b>s32</b> Always use signed 32-bit.

           <b>f32</b> Always use float 32-bit.

           <b>f64</b> Always use float 64-bit.

       <u>Commands</u>

       This filter supports the following commands:

       <b>frequency,</b> <b>f</b>
           Change allpass frequency.  Syntax for the command is : "<u>frequency</u>"

       <b>width_type,</b> <b>t</b>
           Change allpass width_type.  Syntax for the command is : "<u>width_type</u>"

       <b>width,</b> <b>w</b>
           Change allpass width.  Syntax for the command is : "<u>width</u>"

       <b>mix,</b> <b>m</b>
           Change allpass mix.  Syntax for the command is : "<u>mix</u>"

   <b>aloop</b>
       Loop audio samples.

       The filter accepts the following options:

       <b>loop</b>
           Set the number of loops. Setting this value to -1 will result in infinite loops.  Default is 0.

       <b>size</b>
           Set maximal number of samples. Default is 0.

       <b>start</b>
           Set first sample of loop. Default is 0.

       <b>time</b>
           Set the time of loop start in seconds.  Only used if option named <u>start</u> is set to -1.

   <b>amerge</b>
       Merge two or more audio streams into a single multi-channel stream.

       The filter accepts the following options:

       <b>inputs</b>
           Set the number of inputs. Default is 2.

       If  the  channel  layouts of the inputs are disjoint, and therefore compatible, the channel layout of the
       output will be set accordingly and the channels will be reordered as necessary. If the channel layouts of
       the inputs are not disjoint, the output will have all the channels  of  the  first  input  then  all  the
       channels  of  the  second  input, in that order, and the channel layout of the output will be the default
       value corresponding to the total number of channels.

       For example, if the first input is in 2.1 (FL+FR+LF) and the second input is FC+BL+BR,  then  the  output
       will be in 5.1, with the channels in the following order: a1, a2, b1, a3, b2, b3 (a1 is the first channel
       of the first input, b1 is the first channel of the second input).

       On the other hand, if both input are in stereo, the output channels will be in the default order: a1, a2,
       b1,  b2,  and  the  channel  layout  will be arbitrarily set to 4.0, which may or may not be the expected
       value.

       All inputs must have the same sample rate, and format.

       If inputs do not have the same duration, the output will stop with the shortest.

       <u>Examples</u>

       •   Merge two mono files into a stereo stream:

                   amovie=left.wav [l] ; amovie=right.mp3 [r] ; [l] [r] amerge

       •   Multiple merges assuming 1 video stream and 6 audio streams in <u>input.mkv</u>:

                   ffmpeg -i input.mkv -filter_complex "[0:1][0:2][0:3][0:4][0:5][0:6] amerge=inputs=6" -c:a pcm_s16le output.mkv

   <b>amix</b>
       Mixes multiple audio inputs into a single output.

       Note that this filter only supports float  samples  (the  <u>amerge</u>  and  <u>pan</u>  audio  filters  support  many
       formats).  If the <u>amix</u> input has integer samples then <b>aresample</b> will be automatically inserted to perform
       the conversion to float samples.

       It accepts the following parameters:

       <b>inputs</b>
           The number of inputs. If unspecified, it defaults to 2.

       <b>duration</b>
           How to determine the end-of-stream.

           <b>longest</b>
               The duration of the longest input. (default)

           <b>shortest</b>
               The duration of the shortest input.

           <b>first</b>
               The duration of the first input.

       <b>dropout_transition</b>
           The transition time, in seconds, for volume renormalization when an input stream  ends.  The  default
           value is 2 seconds.

       <b>weights</b>
           Specify  weight  of  each  input audio stream as a sequence of numbers separated by a space. If fewer
           weights are specified compared to number of inputs, the last weight  is  assigned  to  the  remaining
           inputs.  Default weight for each input is 1.

       <b>normalize</b>
           Always  scale  inputs instead of only doing summation of samples.  Beware of heavy clipping if inputs
           are not normalized prior or after filtering by this filter if this option is disabled. By default  is
           enabled.

       <u>Examples</u>

       •   This  will mix 3 input audio streams to a single output with the same duration as the first input and
           a dropout transition time of 3 seconds:

                   ffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex amix=inputs=3:duration=first:dropout_transition=3 OUTPUT

       •   This will mix one vocal and one music input audio stream to a single output with the same duration as
           the longest input. The music will have quarter the weight as the  vocals,  and  the  inputs  are  not
           normalized:

                   ffmpeg -i VOCALS -i MUSIC -filter_complex amix=inputs=2:duration=longest:dropout_transition=0:weights="1 0.25":normalize=0 OUTPUT

       <u>Commands</u>

       This filter supports the following commands:

       <b>weights</b>
       <b>normalize</b>
           Syntax is same as option with same name.

   <b>amultiply</b>
       Multiply  first  audio  stream  with  second  audio  stream  and  store  result  in  output audio stream.
       Multiplication is done by multiplying each sample from first stream with sample  at  same  position  from
       second stream.

       With this element-wise multiplication one can create amplitude fades and amplitude modulations.

   <b>anequalizer</b>
       High-order parametric multiband equalizer for each channel.

       It accepts the following parameters:

       <b>params</b>
           This  option  string is in format: "c<u>chn</u> f=<u>cf</u> w=<u>w</u> g=<u>g</u> t=<u>f</u> | ..."  Each equalizer band is separated by
           '|'.

           <b>chn</b> Set channel number to which equalization will be applied.  If input doesn't have that channel the
               entry is ignored.

           <b>f</b>   Set central frequency for band.  If input doesn't have that frequency the entry is ignored.

           <b>w</b>   Set band width in Hertz.

           <b>g</b>   Set band gain in dB.

           <b>t</b>   Set filter type for band, optional, can be:

               <b>0</b>   Butterworth, this is default.

               <b>1</b>   Chebyshev type 1.

               <b>2</b>   Chebyshev type 2.

       <b>curves</b>
           With this option activated frequency response of anequalizer is displayed in video stream.

       <b>size</b>
           Set video stream size. Only useful if curves option is activated.

       <b>mgain</b>
           Set max gain that will be displayed. Only useful if curves option is activated.  Setting  this  to  a
           reasonable  value  makes  it possible to display gain which is derived from neighbour bands which are
           too close to each other and thus produce higher gain when both are activated.

       <b>fscale</b>
           Set frequency scale used to draw frequency response in video output.  Can be linear  or  logarithmic.
           Default is logarithmic.

       <b>colors</b>
           Set  color  for  each  channel curve which is going to be displayed in video stream.  This is list of
           color names separated by space or by '|'.  Unrecognised or missing colors will be replaced  by  white
           color.

       <u>Examples</u>

       •   Lower  gain  by  10  of central frequency 200Hz and width 100 Hz for first 2 channels using Chebyshev
           type 1 filter:

                   anequalizer=c0 f=200 w=100 g=-10 t=1|c1 f=200 w=100 g=-10 t=1

       <u>Commands</u>

       This filter supports the following commands:

       <b>change</b>
           Alter existing filter parameters.  Syntax for the commands is : "<u>fN</u>|f=<u>freq</u>|w=<u>width</u>|g=<u>gain</u>"

           <u>fN</u> is existing filter number, starting from 0, if no such filter  is  available  error  is  returned.
           <u>freq</u>  set  new  frequency  parameter.   <u>width</u>  set  new  width parameter in Hertz.  <u>gain</u> set new gain
           parameter in dB.

           Full filter  invocation  with  asendcmd  may  look  like  this:  asendcmd=c='4.0  anequalizer  change
           0|f=200|w=50|g=1',anequalizer=...

   <b>anlmdn</b>
       Reduce broadband noise in audio samples using Non-Local Means algorithm.

       Each  sample  is  adjusted by looking for other samples with similar contexts. This context similarity is
       defined by comparing their surrounding patches of size <b>p</b>. Patches are searched in an area of <b>r</b> around the
       sample.

       The filter accepts the following options:

       <b>strength,</b> <b>s</b>
           Set denoising strength. Allowed range is from 0.00001 to 10000. Default value is 0.00001.

       <b>patch,</b> <b>p</b>
           Set patch radius duration. Allowed range  is  from  1  to  100  milliseconds.   Default  value  is  2
           milliseconds.

       <b>research,</b> <b>r</b>
           Set  research  radius  duration.  Allowed  range  is  from 2 to 300 milliseconds.  Default value is 6
           milliseconds.

       <b>output,</b> <b>o</b>
           Set the output mode.

           It accepts the following values:

           <b>i</b>   Pass input unchanged.

           <b>o</b>   Pass noise filtered out.

           <b>n</b>   Pass only noise.

               Default value is <u>o</u>.

       <b>smooth,</b> <b>m</b>
           Set smooth factor. Default value is <u>11</u>. Allowed range is from <u>1</u> to <u>1000</u>.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>anlmf,</b> <b>anlms</b>
       Apply Normalized Least-Mean-(Squares|Fourth) algorithm to the first audio stream using the  second  audio
       stream.

       This  adaptive filter is used to mimic a desired filter by finding the filter coefficients that relate to
       producing the least mean square of the error signal (difference between  the  desired,  2nd  input  audio
       stream and the actual signal, the 1st input audio stream).

       A description of the accepted options follows.

       <b>order</b>
           Set filter order.

       <b>mu</b>  Set filter mu.

       <b>eps</b> Set the filter eps.

       <b>leakage</b>
           Set the filter leakage.

       <b>out_mode</b>
           It accepts the following values:

           <b>i</b>   Pass the 1st input.

           <b>d</b>   Pass the 2nd input.

           <b>o</b>   Pass difference between desired, 2nd input and error signal estimate.

           <b>n</b>   Pass difference between input, 1st input and error signal estimate.

           <b>e</b>   Pass error signal estimated samples.

               Default value is <u>o</u>.

       <b>precision</b>
           Set which precision to use when processing samples.

           <b>auto</b>
               Auto pick internal sample format depending on other filters.

           <b>float</b>
               Always use single-floating point precision sample format.

           <b>double</b>
               Always use double-floating point precision sample format.

       <u>Examples</u>

       •   One  of many usages of this filter is noise reduction, input audio is filtered with same samples that
           are delayed by fixed amount, one such example for stereo audio is:

                   asplit[a][b],[a]adelay=32S|32S[a],[b][a]anlms=order=128:leakage=0.0005:mu=.5:out_mode=o

       <u>Commands</u>

       This filter supports the same commands as options, excluding option "order".

   <b>anull</b>
       Pass the audio source unchanged to the output.

   <b>apad</b>
       Pad the end of an audio stream with silence.

       This can be used together with <b>ffmpeg</b> <b>-shortest</b> to extend audio streams to the same length as  the  video
       stream.

       A description of the accepted options follows.

       <b>packet_size</b>
           Set silence packet size. Default value is 4096.

       <b>pad_len</b>
           Set  the  number  of  samples of silence to add to the end. After the value is reached, the stream is
           terminated. This option is mutually exclusive with <b>whole_len</b>.

       <b>whole_len</b>
           Set the minimum total number of samples in the output audio stream. If the value is longer  than  the
           input  audio length, silence is added to the end, until the value is reached. This option is mutually
           exclusive with <b>pad_len</b>.

       <b>pad_dur</b>
           Specify the  duration  of  samples  of  silence  to  add.  See  <b>the</b>  <b>Time</b>  <b>duration</b>  <b>section</b>  <b>in</b>  <b>the</b>
           <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for the accepted syntax. Used only if set to non-negative value.

       <b>whole_dur</b>
           Specify  the  minimum total duration in the output audio stream. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b>
           <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for the accepted syntax. Used only if set to non-negative value. If the  value
           is longer than the input audio length, silence is added to the end, until the value is reached.  This
           option is mutually exclusive with <b>pad_dur</b>

       If  neither  the  <b>pad_len</b>  nor the <b>whole_len</b> nor <b>pad_dur</b> nor <b>whole_dur</b> option is set, the filter will add
       silence to the end of the input stream indefinitely.

       Note that for ffmpeg 4.4 and earlier a zero <b>pad_dur</b> or <b>whole_dur</b> also caused the filter  to  add  silence
       indefinitely.

       <u>Examples</u>

       •   Add 1024 samples of silence to the end of the input:

                   apad=pad_len=1024

       •   Make  sure  the  audio  output  will  contain  at  least 10000 samples, pad the input with silence if
           required:

                   apad=whole_len=10000

       •   Use <b>ffmpeg</b> to pad the audio input with silence, so that the  video  stream  will  always  result  the
           shortest and will be converted until the end in the output file when using the <b>shortest</b> option:

                   ffmpeg -i VIDEO -i AUDIO -filter_complex "[1:0]apad" -shortest OUTPUT

   <b>aphaser</b>
       Add a phasing effect to the input audio.

       A phaser filter creates series of peaks and troughs in the frequency spectrum.  The position of the peaks
       and troughs are modulated so that they vary over time, creating a sweeping effect.

       A description of the accepted parameters follows.

       <b>in_gain</b>
           Set input gain. Default is 0.4.

       <b>out_gain</b>
           Set output gain. Default is 0.74

       <b>delay</b>
           Set delay in milliseconds. Default is 3.0.

       <b>decay</b>
           Set decay. Default is 0.4.

       <b>speed</b>
           Set modulation speed in Hz. Default is 0.5.

       <b>type</b>
           Set modulation type. Default is triangular.

           It accepts the following values:

           <b>triangular,</b> <b>t</b>
           <b>sinusoidal,</b> <b>s</b>

   <b>aphaseshift</b>
       Apply phase shift to input audio samples.

       The filter accepts the following options:

       <b>shift</b>
           Specify phase shift. Allowed range is from -1.0 to 1.0.  Default value is 0.0.

       <b>level</b>
           Set output gain applied to final output. Allowed range is from 0.0 to 1.0.  Default value is 1.0.

       <b>order</b>
           Set filter order used for filtering. Allowed range is from 1 to 16.  Default value is 8.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>apsnr</b>
       Measure Audio Peak Signal-to-Noise Ratio.

       This  filter  takes  two  audio streams for input, and outputs first audio stream.  Results are in dB per
       channel at end of either input.

   <b>apsyclip</b>
       Apply Psychoacoustic clipper to input audio stream.

       The filter accepts the following options:

       <b>level_in</b>
           Set input gain. By default it is 1. Range is [0.015625 - 64].

       <b>level_out</b>
           Set output gain. By default it is 1. Range is [0.015625 - 64].

       <b>clip</b>
           Set the clipping start value. Default value is 0dBFS or 1.

       <b>diff</b>
           Output only difference samples, useful to hear introduced distortions.  By default is disabled.

       <b>adaptive</b>
           Set strength of adaptive distortion applied. Default value is 0.5.  Allowed range is from 0 to 1.

       <b>iterations</b>
           Set number of iterations of psychoacoustic clipper.  Allowed range is from 1 to 20. Default value  is
           10.

       <b>level</b>
           Auto level output signal. Default is disabled.  This normalizes audio back to 0dBFS if enabled.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>apulsator</b>
       Audio pulsator is something between an autopanner and a tremolo.  But it can produce funny stereo effects
       as  well.  Pulsator  changes  the  volume  of  the  left  and right channel based on a LFO (low frequency
       oscillator) with different waveforms and shifted phases.  This filter  have  the  ability  to  define  an
       offset  between  left and right channel. An offset of 0 means that both LFO shapes match each other.  The
       left and right channel are altered equally - a conventional tremolo.  An offset of  50%  means  that  the
       shape of the right channel is exactly shifted in phase (or moved backwards about half of the frequency) -
       pulsator  acts  as  an autopanner. At 1 both curves match again. Every setting in between moves the phase
       shift gapless between all stages and produces some "bypassing" sounds with sine and  triangle  waveforms.
       The  more you set the offset near 1 (starting from the 0.5) the faster the signal passes from the left to
       the right speaker.

       The filter accepts the following options:

       <b>level_in</b>
           Set input gain. By default it is 1. Range is [0.015625 - 64].

       <b>level_out</b>
           Set output gain. By default it is 1. Range is [0.015625 - 64].

       <b>mode</b>
           Set waveform shape the LFO will use. Can be one of: sine, triangle, square, sawup or sawdown. Default
           is sine.

       <b>amount</b>
           Set modulation. Define how much of original signal is affected by the LFO.

       <b>offset_l</b>
           Set left channel offset. Default is 0. Allowed range is [0 - 1].

       <b>offset_r</b>
           Set right channel offset. Default is 0.5. Allowed range is [0 - 1].

       <b>width</b>
           Set pulse width. Default is 1. Allowed range is [0 - 2].

       <b>timing</b>
           Set possible timing mode. Can be one of: bpm, ms or hz. Default is hz.

       <b>bpm</b> Set bpm. Default is 120. Allowed range is [30 - 300]. Only used if timing is set to bpm.

       <b>ms</b>  Set ms. Default is 500. Allowed range is [10 - 2000]. Only used if timing is set to ms.

       <b>hz</b>  Set frequency in Hz. Default is 2. Allowed range is [0.01 - 100]. Only used if timing is set to hz.

   <b>aresample</b>
       Resample the input audio to the specified parameters,  using  the  libswresample  library.  If  none  are
       specified then the filter will automatically convert between its input and output.

       This  filter  is also able to stretch/squeeze the audio data to make it match the timestamps or to inject
       silence / cut out audio to make it match the timestamps, do a combination of both or do neither.

       The filter accepts the syntax [<u>sample_rate</u>:]<u>resampler_options</u>, where <u>sample_rate</u> expresses a sample  rate
       and <u>resampler_options</u> is a list of <u>key</u>=<u>value</u> pairs, separated by ":". See the <b>"Resampler</b> <b>Options"</b> <b>section</b>
       <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-resampler.1.html">ffmpeg-resampler</a>(1)</b> <b>manual</b> for the complete list of supported options.

       <u>Examples</u>

       •   Resample the input audio to 44100Hz:

                   aresample=44100

       •   Stretch/squeeze  samples  to  the  given  timestamps,  with  a  maximum  of  1000  samples per second
           compensation:

                   aresample=async=1000

   <b>areverse</b>
       Reverse an audio clip.

       Warning: This filter requires memory to buffer the entire clip, so trimming is suggested.

       <u>Examples</u>

       •   Take the first 5 seconds of a clip, and reverse it.

                   atrim=end=5,areverse

   <b>arls</b>
       Apply Recursive Least Squares algorithm to the first audio stream using the second audio stream.

       This adaptive filter is used to mimic a desired filter by recursively  finding  the  filter  coefficients
       that  relate  to  producing  the  minimal weighted linear least squares cost function of the error signal
       (difference between the desired, 2nd input audio stream and  the  actual  signal,  the  1st  input  audio
       stream).

       A description of the accepted options follows.

       <b>order</b>
           Set the filter order.

       <b>lambda</b>
           Set the forgetting factor.

       <b>delta</b>
           Set the coefficient to initialize internal covariance matrix.

       <b>out_mode</b>
           Set the filter output samples. It accepts the following values:

           <b>i</b>   Pass the 1st input.

           <b>d</b>   Pass the 2nd input.

           <b>o</b>   Pass difference between desired, 2nd input and error signal estimate.

           <b>n</b>   Pass difference between input, 1st input and error signal estimate.

           <b>e</b>   Pass error signal estimated samples.

               Default value is <u>o</u>.

       <b>precision</b>
           Set which precision to use when processing samples.

           <b>auto</b>
               Auto pick internal sample format depending on other filters.

           <b>float</b>
               Always use single-floating point precision sample format.

           <b>double</b>
               Always use double-floating point precision sample format.

   <b>arnndn</b>
       Reduce noise from speech using Recurrent Neural Networks.

       This filter accepts the following options:

       <b>model,</b> <b>m</b>
           Set train model file to load. This option is always required.

       <b>mix</b> Set how much to mix filtered samples into final output.  Allowed range is from -1 to 1. Default value
           is  1.   Negative  values  are  special, they set how much to keep filtered noise in the final filter
           output. Set this option to -1 to hear actual noise removed from input signal.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>asdr</b>
       Measure Audio Signal-to-Distortion Ratio.

       This filter takes two audio streams for input, and outputs first audio stream.  Results  are  in  dB  per
       channel at end of either input.

   <b>asetnsamples</b>
       Set the number of samples per each output audio frame.

       The  last  output  packet  may  contain  a  different number of samples, as the filter will flush all the
       remaining samples when the input audio signals its end.

       The filter accepts the following options:

       <b>nb_out_samples,</b> <b>n</b>
           Set the number of frames per each output audio frame. The number is intended as the number of samples
           <u>per</u> <u>each</u> <u>channel</u>.  Default value is 1024.

       <b>pad,</b> <b>p</b>
           If set to 1, the filter will pad the last audio frame with  zeroes,  so  that  the  last  frame  will
           contain the same number of samples as the previous ones. Default value is 1.

       For example, to set the number of per-frame samples to 1234 and disable padding for the last frame, use:

               asetnsamples=n=1234:p=0

   <b>asetrate</b>
       Set the sample rate without altering the PCM data.  This will result in a change of speed and pitch.

       The filter accepts the following options:

       <b>sample_rate,</b> <b>r</b>
           Set the output sample rate. Default is 44100 Hz.

   <b>ashowinfo</b>
       Show a line containing various information for each input audio frame.  The input audio is not modified.

       The shown line contains a sequence of key/value pairs of the form <u>key</u>:<u>value</u>.

       The following values are shown in the output:

       <b>n</b>   The (sequential) number of the input frame, starting from 0.

       <b>pts</b> The  presentation  timestamp  of  the  input  frame, in time base units; the time base depends on the
           filter input pad, and is usually 1/<u>sample_rate</u>.

       <b>pts_time</b>
           The presentation timestamp of the input frame in seconds.

       <b>fmt</b> The sample format.

       <b>chlayout</b>
           The channel layout.

       <b>rate</b>
           The sample rate for the audio frame.

       <b>nb_samples</b>
           The number of samples (per channel) in the frame.

       <b>checksum</b>
           The Adler-32 checksum (printed in hexadecimal) of the audio data.  For  planar  audio,  the  data  is
           treated as if all the planes were concatenated.

       <b>plane_checksums</b>
           A list of Adler-32 checksums for each data plane.

   <b>asisdr</b>
       Measure Audio Scaled-Invariant Signal-to-Distortion Ratio.

       This  filter  takes  two  audio streams for input, and outputs first audio stream.  Results are in dB per
       channel at end of either input.

   <b>asoftclip</b>
       Apply audio soft clipping.

       Soft clipping is a type of distortion effect where the amplitude of a signal is saturated along a  smooth
       curve, rather than the abrupt shape of hard-clipping.

       This filter accepts the following options:

       <b>type</b>
           Set type of soft-clipping.

           It accepts the following values:

           <b>hard</b>
           <b>tanh</b>
           <b>atan</b>
           <b>cubic</b>
           <b>exp</b>
           <b>alg</b>
           <b>quintic</b>
           <b>sin</b>
           <b>erf</b>
       <b>threshold</b>
           Set threshold from where to start clipping. Default value is 0dB or 1.

       <b>output</b>
           Set gain applied to output. Default value is 0dB or 1.

       <b>param</b>
           Set additional parameter which controls sigmoid function.

       <b>oversample</b>
           Set oversampling factor.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>aspectralstats</b>
       Display frequency domain statistical information about the audio channels.  Statistics are calculated and
       stored as metadata for each audio channel and for each audio frame.

       It accepts the following option:

       <b>win_size</b>
           Set the window length in samples. Default value is 2048.  Allowed range is from 32 to 65536.

       <b>win_func</b>
           Set window function.

           It accepts the following values:

           <b>rect</b>
           <b>bartlett</b>
           <b>hann,</b> <b>hanning</b>
           <b>hamming</b>
           <b>blackman</b>
           <b>welch</b>
           <b>flattop</b>
           <b>bharris</b>
           <b>bnuttall</b>
           <b>bhann</b>
           <b>sine</b>
           <b>nuttall</b>
           <b>lanczos</b>
           <b>gauss</b>
           <b>tukey</b>
           <b>dolph</b>
           <b>cauchy</b>
           <b>parzen</b>
           <b>poisson</b>
           <b>bohman</b>
           <b>kaiser</b>

           Default is "hann".

       <b>overlap</b>
           Set window overlap. Allowed range is from 0 to 1. Default value is 0.5.

       <b>measure</b>
           Select  the  parameters  which  are  measured. The metadata keys can be used as flags, default is <b>all</b>
           which measures everything.  <b>none</b> disables all measurement.

       A list of each metadata key follows:

       <b>mean</b>
       <b>variance</b>
       <b>centroid</b>
       <b>spread</b>
       <b>skewness</b>
       <b>kurtosis</b>
       <b>entropy</b>
       <b>flatness</b>
       <b>crest</b>
       <b>flux</b>
       <b>slope</b>
       <b>decrease</b>
       <b>rolloff</b>

   <b>asr</b>
       Automatic Speech Recognition

       This filter uses PocketSphinx for speech recognition. To enable compilation of this filter, you  need  to
       configure FFmpeg with "--enable-pocketsphinx".

       It accepts the following options:

       <b>rate</b>
           Set sampling rate of input audio. Defaults is 16000.  This need to match speech models, otherwise one
           will get poor results.

       <b>hmm</b> Set dictionary containing acoustic model files.

       <b>dict</b>
           Set pronunciation dictionary.

       <b>lm</b>  Set language model file.

       <b>lmctl</b>
           Set language model set.

       <b>lmname</b>
           Set which language model to use.

       <b>logfn</b>
           Set output for log messages.

       The filter exports recognized speech as the frame metadata "lavfi.asr.text".

   <b>astats</b>
       Display  time  domain  statistical  information  about the audio channels.  Statistics are calculated and
       displayed for each audio channel and, where applicable, an overall figure is also given.

       It accepts the following option:

       <b>length</b>
           Short window length in seconds, used for peak and  trough  RMS  measurement.   Default  is  0.05  (50
           milliseconds). Allowed range is "[0 - 10]".

       <b>metadata</b>
           Set  metadata  injection.  All  the  metadata  keys  are prefixed with "lavfi.astats.X", where "X" is
           channel number starting from 1 or string "Overall". Default is disabled.

           Available  keys  for  each  channel  are:  <u>Bit_depth</u>  <u>Crest_factor</u>  <u>DC_offset</u>  <u>Dynamic_range</u>  <u>Entropy</u>
           <u>Flat_factor</u>   <u>Max_difference</u>   <u>Max_level</u>   <u>Mean_difference</u>   <u>Min_difference</u>   <u>Min_level</u>   <u>Noise_floor</u>
           <u>Noise_floor_count</u>  <u>Number_of_Infs</u>  <u>Number_of_NaNs</u>   <u>Number_of_denormals</u>   <u>Peak_count</u>   <u>Abs_Peak_count</u>
           <u>Peak_level</u> <u>RMS_difference</u> <u>RMS_peak</u> <u>RMS_trough</u> <u>Zero_crossings</u> <u>Zero_crossings_rate</u>

           and  for  "Overall": <u>Bit_depth</u> <u>DC_offset</u> <u>Entropy</u> <u>Flat_factor</u> <u>Max_difference</u> <u>Max_level</u> <u>Mean_difference</u>
           <u>Min_difference</u>    <u>Min_level</u>    <u>Noise_floor</u>    <u>Noise_floor_count</u>     <u>Number_of_Infs</u>     <u>Number_of_NaNs</u>
           <u>Number_of_denormals</u>  <u>Number_of_samples</u>  <u>Peak_count</u> <u>Abs_Peak_count</u> <u>Peak_level</u> <u>RMS_difference</u> <u>RMS_level</u>
           <u>RMS_peak</u> <u>RMS_trough</u>

           For example, a full key looks like "lavfi.astats.1.DC_offset" or "lavfi.astats.Overall.Peak_count".

           Read below for the description of the keys.

       <b>reset</b>
           Set the number of frames over which cumulative stats are calculated before being  reset.  Default  is
           disabled.

       <b>measure_perchannel</b>
           Select the parameters which are measured per channel. The metadata keys can be used as flags, default
           is <b>all</b> which measures everything.  <b>none</b> disables all per channel measurement.

       <b>measure_overall</b>
           Select  the parameters which are measured overall. The metadata keys can be used as flags, default is
           <b>all</b> which measures everything.  <b>none</b> disables all overall measurement.

       A description of the measure keys follow:

       <b>none</b>
           no measures

       <b>all</b> all measures

       <b>Bit_depth</b>
           overall bit depth of audio, i.e. number of bits used for each sample

       <b>Crest_factor</b>
           standard ratio of peak to RMS level (note: not in dB)

       <b>DC_offset</b>
           mean amplitude displacement from zero

       <b>Dynamic_range</b>
           measured dynamic range of audio in dB

       <b>Entropy</b>
           entropy measured across whole audio, entropy of value near 1.0 is typically measured for white noise

       <b>Flat_factor</b>
           flatness (i.e. consecutive samples with the same value) of the signal at its peak levels (i.e. either
           <u>Min_level</u> or <u>Max_level</u>)

       <b>Max_difference</b>
           maximal difference between two consecutive samples

       <b>Max_level</b>
           maximal sample level

       <b>Mean_difference</b>
           mean difference between two consecutive samples, i.e. the average  of  each  difference  between  two
           consecutive samples

       <b>Min_difference</b>
           minimal difference between two consecutive samples

       <b>Min_level</b>
           minimal sample level

       <b>Noise_floor</b>
           minimum local peak measured in dBFS over a short window

       <b>Noise_floor_count</b>
           number of occasions (not the number of samples) that the signal attained <u>Noise</u> <u>floor</u>

       <b>Number_of_Infs</b>
           number of samples with an infinite value

       <b>Number_of_NaNs</b>
           number of samples with a NaN (not a number) value

       <b>Number_of_denormals</b>
           number of samples with a subnormal value

       <b>Number_of_samples</b>
           number of samples

       <b>Peak_count</b>
           number  of  occasions  (not  the  number  of  samples)  that  the signal attained either <u>Min_level</u> or
           <u>Max_level</u>

       <b>Abs_Peak_count</b>
           number of occasions that the absolute samples taken from the signal attained max  absolute  value  of
           <u>Min_level</u> and <u>Max_level</u>

       <b>Peak_level</b>
           standard peak level measured in dBFS

       <b>RMS_difference</b>
           Root Mean Square difference between two consecutive samples

       <b>RMS_level</b>
           standard RMS level measured in dBFS

       <b>RMS_peak</b>
       <b>RMS_trough</b>
           peak and trough values for RMS level measured over a short window, measured in dBFS.

       <b>Zero</b> <b>crossings</b>
           number of points where the waveform crosses the zero level axis

       <b>Zero</b> <b>crossings</b> <b>rate</b>
           rate of Zero crossings and number of audio samples

   <b>asubboost</b>
       Boost subwoofer frequencies.

       The filter accepts the following options:

       <b>dry</b> Set  dry  gain,  how much of original signal is kept. Allowed range is from 0 to 1.  Default value is
           1.0.

       <b>wet</b> Set wet gain, how much of filtered signal is kept. Allowed range is from 0 to 1.   Default  value  is
           1.0.

       <b>boost</b>
           Set max boost factor. Allowed range is from 1 to 12. Default value is 2.

       <b>decay</b>
           Set delay line decay gain value. Allowed range is from 0 to 1.  Default value is 0.0.

       <b>feedback</b>
           Set delay line feedback gain value. Allowed range is from 0 to 1.  Default value is 0.9.

       <b>cutoff</b>
           Set cutoff frequency in Hertz. Allowed range is 50 to 900.  Default value is 100.

       <b>slope</b>
           Set slope amount for cutoff frequency. Allowed range is 0.0001 to 1.  Default value is 0.5.

       <b>delay</b>
           Set delay. Allowed range is from 1 to 100.  Default value is 20.

       <b>channels</b>
           Set the channels to process. Default value is all available.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>asubcut</b>
       Cut subwoofer frequencies.

       This  filter  allows  to  set  custom,  steeper  roll  off than highpass filter, and thus is able to more
       attenuate frequency content in stop-band.

       The filter accepts the following options:

       <b>cutoff</b>
           Set cutoff frequency in Hertz. Allowed range is 2 to 200.  Default value is 20.

       <b>order</b>
           Set filter order. Available values are from 3 to 20.  Default value is 10.

       <b>level</b>
           Set input gain level. Allowed range is from 0 to 1. Default value is 1.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>asupercut</b>
       Cut super frequencies.

       The filter accepts the following options:

       <b>cutoff</b>
           Set cutoff frequency in Hertz. Allowed range is 20000 to 192000.  Default value is 20000.

       <b>order</b>
           Set filter order. Available values are from 3 to 20.  Default value is 10.

       <b>level</b>
           Set input gain level. Allowed range is from 0 to 1. Default value is 1.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>asuperpass</b>
       Apply high order Butterworth band-pass filter.

       The filter accepts the following options:

       <b>centerf</b>
           Set center frequency in Hertz. Allowed range is 2 to 999999.  Default value is 1000.

       <b>order</b>
           Set filter order. Available values are from 4 to 20.  Default value is 4.

       <b>qfactor</b>
           Set Q-factor. Allowed range is from 0.01 to 100. Default value is 1.

       <b>level</b>
           Set input gain level. Allowed range is from 0 to 2. Default value is 1.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>asuperstop</b>
       Apply high order Butterworth band-stop filter.

       The filter accepts the following options:

       <b>centerf</b>
           Set center frequency in Hertz. Allowed range is 2 to 999999.  Default value is 1000.

       <b>order</b>
           Set filter order. Available values are from 4 to 20.  Default value is 4.

       <b>qfactor</b>
           Set Q-factor. Allowed range is from 0.01 to 100. Default value is 1.

       <b>level</b>
           Set input gain level. Allowed range is from 0 to 2. Default value is 1.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>atempo</b>
       Adjust audio tempo.

       The filter accepts exactly one parameter, the audio tempo. If not specified then the filter  will  assume
       nominal 1.0 tempo. Tempo must be in the [0.5, 100.0] range.

       Note  that tempo greater than 2 will skip some samples rather than blend them in.  If for any reason this
       is a concern it is always possible to daisy-chain several instances of  atempo  to  achieve  the  desired
       product tempo.

       <u>Examples</u>

       •   Slow down audio to 80% tempo:

                   atempo=0.8

       •   To speed up audio to 300% tempo:

                   atempo=3

       •   To speed up audio to 300% tempo by daisy-chaining two atempo instances:

                   atempo=<a href="../man3/sqrt.3.html">sqrt</a>(3),atempo=<a href="../man3/sqrt.3.html">sqrt</a>(3)

       <u>Commands</u>

       This filter supports the following commands:

       <b>tempo</b>
           Change filter tempo scale factor.  Syntax for the command is : "<u>tempo</u>"

   <b>atilt</b>
       Apply spectral tilt filter to audio stream.

       This filter apply any spectral roll-off slope over any specified frequency band.

       The filter accepts the following options:

       <b>freq</b>
           Set central frequency of tilt in Hz. Default is 10000 Hz.

       <b>slope</b>
           Set slope direction of tilt. Default is 0. Allowed range is from -1 to 1.

       <b>width</b>
           Set width of tilt. Default is 1000. Allowed range is from 100 to 10000.

       <b>order</b>
           Set order of tilt filter.

       <b>level</b>
           Set input volume level. Allowed range is from 0 to 4.  Default is 1.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>atrim</b>
       Trim the input so that the output contains one continuous subpart of the input.

       It accepts the following parameters:

       <b>start</b>
           Timestamp  (in seconds) of the start of the section to keep. I.e. the audio sample with the timestamp
           <u>start</u> will be the first sample in the output.

       <b>end</b> Specify time of the first audio sample that will  be  dropped,  i.e.  the  audio  sample  immediately
           preceding the one with the timestamp <u>end</u> will be the last sample in the output.

       <b>start_pts</b>
           Same as <u>start</u>, except this option sets the start timestamp in samples instead of seconds.

       <b>end_pts</b>
           Same as <u>end</u>, except this option sets the end timestamp in samples instead of seconds.

       <b>duration</b>
           The maximum duration of the output in seconds.

       <b>start_sample</b>
           The number of the first sample that should be output.

       <b>end_sample</b>
           The number of the first sample that should be dropped.

       <b>start</b>,  <b>end</b>, and <b>duration</b> are expressed as time duration specifications; see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b>
       <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>.

       Note that the first two sets of the  start/end  options  and  the  <b>duration</b>  option  look  at  the  frame
       timestamp,  while  the  _sample  options  simply  count  the  samples  that  pass  through the filter. So
       start/end_pts and start/end_sample will give different results when the timestamps are wrong, inexact  or
       do  not start at zero. Also note that this filter does not modify the timestamps. If you wish to have the
       output timestamps start at zero, insert the asetpts filter after the atrim filter.

       If multiple start or end options are set, this filter tries to be greedy and keep all samples that  match
       at  least  one  of  the  specified constraints. To keep only the part that matches all the constraints at
       once, chain multiple atrim filters.

       The defaults are such that all the input is kept. So it is possible to set e.g.  just the end  values  to
       keep everything before the specified time.

       Examples:

       •   Drop everything except the second minute of input:

                   ffmpeg -i INPUT -af atrim=60:120

       •   Keep only the first 1000 samples:

                   ffmpeg -i INPUT -af atrim=end_sample=1000

   <b>axcorrelate</b>
       Calculate normalized windowed cross-correlation between two input audio streams.

       Resulted  samples  are  always between -1 and 1 inclusive.  If result is 1 it means two input samples are
       highly correlated in that selected segment.  Result 0 means they are not correlated at all.  If result is
       -1 it means two input samples are out of phase, which means they cancel each other.

       The filter accepts the following options:

       <b>size</b>
           Set size of segment over which cross-correlation is calculated.  Default is  256.  Allowed  range  is
           from 2 to 131072.

       <b>algo</b>
           Set  algorithm  for  cross-correlation.  Can  be "slow" or "fast" or "best".  Default is "best". Fast
           algorithm assumes mean values over any given  segment  are  always  zero  and  thus  need  much  less
           calculations to make.  This is generally not true, but is valid for typical audio streams.

       <u>Examples</u>

       •   Calculate correlation between channels in stereo audio stream:

                   ffmpeg -i stereo.wav -af channelsplit,axcorrelate=size=1024:algo=fast correlation.wav

   <b>bandpass</b>
       Apply  a  two-pole  Butterworth  band-pass filter with central frequency <u>frequency</u>, and (3dB-point) band-
       width width.  The <u>csg</u> option selects a constant skirt gain (peak  gain  =  Q)  instead  of  the  default:
       constant 0dB peak gain.  The filter roll off at 6dB per octave (20dB per decade).

       The filter accepts the following options:

       <b>frequency,</b> <b>f</b>
           Set the filter's central frequency. Default is 3000.

       <b>csg</b> Constant skirt gain if set to 1. Defaults to 0.

       <b>width_type,</b> <b>t</b>
           Set method to specify band-width of filter.

           <b>h</b>   Hz

           <b>q</b>   Q-Factor

           <b>o</b>   octave

           <b>s</b>   slope

           <b>k</b>   kHz

       <b>width,</b> <b>w</b>
           Specify the band-width of a filter in width_type units.

       <b>mix,</b> <b>m</b>
           How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>channels,</b> <b>c</b>
           Specify which channels to filter, by default all available are filtered.

       <b>normalize,</b> <b>n</b>
           Normalize biquad coefficients, by default is disabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>transform,</b> <b>a</b>
           Set transform type of IIR filter.

           <b>di</b>
           <b>dii</b>
           <b>tdi</b>
           <b>tdii</b>
           <b>latt</b>
           <b>svf</b>
           <b>zdf</b>
       <b>precision,</b> <b>r</b>
           Set precision of filtering.

           <b>auto</b>
               Pick automatic sample format depending on surround filters.

           <b>s16</b> Always use signed 16-bit.

           <b>s32</b> Always use signed 32-bit.

           <b>f32</b> Always use float 32-bit.

           <b>f64</b> Always use float 64-bit.

       <b>block_size,</b> <b>b</b>
           Set  block  size  used  for reverse IIR processing. If this value is set to high enough value (higher
           than impulse response length truncated when reaches near zero values) filtering  will  become  linear
           phase otherwise if not big enough it will just produce nasty artifacts.

           Note that filter delay will be exactly this many samples when set to non-zero value.

       <u>Commands</u>

       This filter supports the following commands:

       <b>frequency,</b> <b>f</b>
           Change bandpass frequency.  Syntax for the command is : "<u>frequency</u>"

       <b>width_type,</b> <b>t</b>
           Change bandpass width_type.  Syntax for the command is : "<u>width_type</u>"

       <b>width,</b> <b>w</b>
           Change bandpass width.  Syntax for the command is : "<u>width</u>"

       <b>mix,</b> <b>m</b>
           Change bandpass mix.  Syntax for the command is : "<u>mix</u>"

   <b>bandreject</b>
       Apply  a  two-pole Butterworth band-reject filter with central frequency <u>frequency</u>, and (3dB-point) band-
       width <u>width</u>.  The filter roll off at 6dB per octave (20dB per decade).

       The filter accepts the following options:

       <b>frequency,</b> <b>f</b>
           Set the filter's central frequency. Default is 3000.

       <b>width_type,</b> <b>t</b>
           Set method to specify band-width of filter.

           <b>h</b>   Hz

           <b>q</b>   Q-Factor

           <b>o</b>   octave

           <b>s</b>   slope

           <b>k</b>   kHz

       <b>width,</b> <b>w</b>
           Specify the band-width of a filter in width_type units.

       <b>mix,</b> <b>m</b>
           How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>channels,</b> <b>c</b>
           Specify which channels to filter, by default all available are filtered.

       <b>normalize,</b> <b>n</b>
           Normalize biquad coefficients, by default is disabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>transform,</b> <b>a</b>
           Set transform type of IIR filter.

           <b>di</b>
           <b>dii</b>
           <b>tdi</b>
           <b>tdii</b>
           <b>latt</b>
           <b>svf</b>
           <b>zdf</b>
       <b>precision,</b> <b>r</b>
           Set precision of filtering.

           <b>auto</b>
               Pick automatic sample format depending on surround filters.

           <b>s16</b> Always use signed 16-bit.

           <b>s32</b> Always use signed 32-bit.

           <b>f32</b> Always use float 32-bit.

           <b>f64</b> Always use float 64-bit.

       <b>block_size,</b> <b>b</b>
           Set block size used for reverse IIR processing. If this value is set to  high  enough  value  (higher
           than  impulse  response  length truncated when reaches near zero values) filtering will become linear
           phase otherwise if not big enough it will just produce nasty artifacts.

           Note that filter delay will be exactly this many samples when set to non-zero value.

       <u>Commands</u>

       This filter supports the following commands:

       <b>frequency,</b> <b>f</b>
           Change bandreject frequency.  Syntax for the command is : "<u>frequency</u>"

       <b>width_type,</b> <b>t</b>
           Change bandreject width_type.  Syntax for the command is : "<u>width_type</u>"

       <b>width,</b> <b>w</b>
           Change bandreject width.  Syntax for the command is : "<u>width</u>"

       <b>mix,</b> <b>m</b>
           Change bandreject mix.  Syntax for the command is : "<u>mix</u>"

   <b>bass,</b> <b>lowshelf</b>
       Boost or cut the bass (lower) frequencies of the audio using a two-pole shelving filter with  a  response
       similar to that of a standard hi-fi's tone-controls. This is also known as shelving equalisation (EQ).

       The filter accepts the following options:

       <b>gain,</b> <b>g</b>
           Give  the  gain  at 0 Hz. Its useful range is about -20 (for a large cut) to +20 (for a large boost).
           Beware of clipping when using a positive gain.

       <b>frequency,</b> <b>f</b>
           Set the filter's central frequency and so can be used to extend or reduce the frequency range  to  be
           boosted or cut.  The default value is 100 Hz.

       <b>width_type,</b> <b>t</b>
           Set method to specify band-width of filter.

           <b>h</b>   Hz

           <b>q</b>   Q-Factor

           <b>o</b>   octave

           <b>s</b>   slope

           <b>k</b>   kHz

       <b>width,</b> <b>w</b>
           Determine how steep is the filter's shelf transition.

       <b>poles,</b> <b>p</b>
           Set number of poles. Default is 2.

       <b>mix,</b> <b>m</b>
           How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>channels,</b> <b>c</b>
           Specify which channels to filter, by default all available are filtered.

       <b>normalize,</b> <b>n</b>
           Normalize biquad coefficients, by default is disabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>transform,</b> <b>a</b>
           Set transform type of IIR filter.

           <b>di</b>
           <b>dii</b>
           <b>tdi</b>
           <b>tdii</b>
           <b>latt</b>
           <b>svf</b>
           <b>zdf</b>
       <b>precision,</b> <b>r</b>
           Set precision of filtering.

           <b>auto</b>
               Pick automatic sample format depending on surround filters.

           <b>s16</b> Always use signed 16-bit.

           <b>s32</b> Always use signed 32-bit.

           <b>f32</b> Always use float 32-bit.

           <b>f64</b> Always use float 64-bit.

       <b>block_size,</b> <b>b</b>
           Set  block  size  used  for reverse IIR processing. If this value is set to high enough value (higher
           than impulse response length truncated when reaches near zero values) filtering  will  become  linear
           phase otherwise if not big enough it will just produce nasty artifacts.

           Note that filter delay will be exactly this many samples when set to non-zero value.

       <u>Commands</u>

       This filter supports the following commands:

       <b>frequency,</b> <b>f</b>
           Change bass frequency.  Syntax for the command is : "<u>frequency</u>"

       <b>width_type,</b> <b>t</b>
           Change bass width_type.  Syntax for the command is : "<u>width_type</u>"

       <b>width,</b> <b>w</b>
           Change bass width.  Syntax for the command is : "<u>width</u>"

       <b>gain,</b> <b>g</b>
           Change bass gain.  Syntax for the command is : "<u>gain</u>"

       <b>mix,</b> <b>m</b>
           Change bass mix.  Syntax for the command is : "<u>mix</u>"

   <b>biquad</b>
       Apply a biquad IIR filter with the given coefficients.  Where <u>b0</u>, <u>b1</u>, <u>b2</u> and <u>a0</u>, <u>a1</u>, <u>a2</u> are the numerator
       and  denominator coefficients respectively.  and <u>channels</u>, <u>c</u> specify which channels to filter, by default
       all available are filtered.

       <u>Commands</u>

       This filter supports the following commands:

       <b>a0</b>
       <b>a1</b>
       <b>a2</b>
       <b>b0</b>
       <b>b1</b>
       <b>b2</b>  Change biquad parameter.  Syntax for the command is : "<u>value</u>"

       <b>mix,</b> <b>m</b>
           How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>channels,</b> <b>c</b>
           Specify which channels to filter, by default all available are filtered.

       <b>normalize,</b> <b>n</b>
           Normalize biquad coefficients, by default is disabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>transform,</b> <b>a</b>
           Set transform type of IIR filter.

           <b>di</b>
           <b>dii</b>
           <b>tdi</b>
           <b>tdii</b>
           <b>latt</b>
           <b>svf</b>
           <b>zdf</b>
       <b>precision,</b> <b>r</b>
           Set precision of filtering.

           <b>auto</b>
               Pick automatic sample format depending on surround filters.

           <b>s16</b> Always use signed 16-bit.

           <b>s32</b> Always use signed 32-bit.

           <b>f32</b> Always use float 32-bit.

           <b>f64</b> Always use float 64-bit.

       <b>block_size,</b> <b>b</b>
           Set block size used for reverse IIR processing. If this value is set to  high  enough  value  (higher
           than  impulse  response  length truncated when reaches near zero values) filtering will become linear
           phase otherwise if not big enough it will just produce nasty artifacts.

           Note that filter delay will be exactly this many samples when set to non-zero value.

   <b>bs2b</b>
       Bauer stereo to binaural transformation, which improves headphone listening of stereo audio records.

       To enable compilation of this filter you need to configure FFmpeg with "--enable-libbs2b".

       It accepts the following parameters:

       <b>profile</b>
           Pre-defined crossfeed level.

           <b>default</b>
               Default level (fcut=700, feed=50).

           <b>cmoy</b>
               Chu Moy circuit (fcut=700, feed=60).

           <b>jmeier</b>
               Jan Meier circuit (fcut=650, feed=95).

       <b>fcut</b>
           Cut frequency (in Hz).

       <b>feed</b>
           Feed level (in Hz).

   <b>channelmap</b>
       Remap input channels to new locations.

       It accepts the following parameters:

       <b>map</b> Map channels from input to output. The argument is a '|'-separated list  of  mappings,  each  in  the
           "<u>in_channel</u>-<u>out_channel</u>" or "<u>in_channel</u>" form. <u>in_channel</u> can be either the name of the input channel
           (e.g.  FL  for  front  left) or its index in the input channel layout. <u>out_channel</u> is the name of the
           output channel or its index in the output channel layout. If <u>out_channel</u> is  not  given  then  it  is
           implicitly  an  index,  starting  with  zero and increasing by one for each mapping. Mixing different
           types of mappings is not allowed and will result in a parse error.

       <b>channel_layout</b>
           The channel layout of the output stream. If not specified, then filter will guess  it  based  on  the
           <u>out_channel</u>  names  or the number of mappings.  Guessed layouts will not necessarily contain channels
           in the order of the mappings.

       If no mapping is present, the filter will implicitly map input channels to  output  channels,  preserving
       indices.

       <u>Examples</u>

       •   For example, assuming a 5.1+downmix input MOV file,

                   ffmpeg -i in.mov -filter 'channelmap=map=DL-FL|DR-FR' out.wav

           will create an output WAV file tagged as stereo from the downmix channels of the input.

       •   To fix a 5.1 WAV improperly encoded in AAC's native channel order

                   ffmpeg -i in.wav -filter 'channelmap=1|2|0|5|3|4:5.1' out.wav

   <b>channelsplit</b>
       Split each channel from an input audio stream into a separate output stream.

       It accepts the following parameters:

       <b>channel_layout</b>
           The channel layout of the input stream. The default is "stereo".

       <b>channels</b>
           A  channel  layout  describing  the  channels  to be extracted as separate output streams or "all" to
           extract each input channel as a separate stream. The default is "all".

           Choosing channels not present in channel layout in the input will result in an error.

       <u>Examples</u>

       •   For example, assuming a stereo input MP3 file,

                   ffmpeg -i in.mp3 -filter_complex channelsplit out.mkv

           will create an output Matroska file with two audio streams, one containing only the left channel  and
           the other the right channel.

       •   Split a 5.1 WAV file into per-channel files:

                   ffmpeg -i in.wav -filter_complex
                   'channelsplit=channel_layout=5.1[FL][FR][FC][LFE][SL][SR]'
                   -map '[FL]' front_left.wav -map '[FR]' front_right.wav -map '[FC]'
                   front_center.wav -map '[LFE]' lfe.wav -map '[SL]' side_left.wav -map '[SR]'
                   side_right.wav

       •   Extract only LFE from a 5.1 WAV file:

                   ffmpeg -i in.wav -filter_complex 'channelsplit=channel_layout=5.1:channels=LFE[LFE]'
                   -map '[LFE]' lfe.wav

   <b>chorus</b>
       Add a chorus effect to the audio.

       Can make a single vocal sound like a chorus, but can also be applied to instrumentation.

       Chorus  resembles  an  echo  effect with a short delay, but whereas with echo the delay is constant, with
       chorus, it is varied using using sinusoidal or triangular modulation.  The modulation depth  defines  the
       range  the modulated delay is played before or after the delay. Hence the delayed sound will sound slower
       or faster, that is the delayed sound tuned around the original one, like in a chorus  where  some  vocals
       are slightly off key.

       It accepts the following parameters:

       <b>in_gain</b>
           Set input gain. Default is 0.4.

       <b>out_gain</b>
           Set output gain. Default is 0.4.

       <b>delays</b>
           Set delays. A typical delay is around 40ms to 60ms.

       <b>decays</b>
           Set decays.

       <b>speeds</b>
           Set speeds.

       <b>depths</b>
           Set depths.

       <u>Examples</u>

       •   A single delay:

                   chorus=0.7:0.9:55:0.4:0.25:2

       •   Two delays:

                   chorus=0.6:0.9:50|60:0.4|0.32:0.25|0.4:2|1.3

       •   Fuller sounding chorus with three delays:

                   chorus=0.5:0.9:50|60|40:0.4|0.32|0.3:0.25|0.4|0.3:2|2.3|1.3

   <b>compand</b>
       Compress or expand the audio's dynamic range.

       It accepts the following parameters:

       <b>attacks</b>
       <b>decays</b>
           A list of times in seconds for each channel over which the instantaneous level of the input signal is
           averaged  to determine its volume. <u>attacks</u> refers to increase of volume and <u>decays</u> refers to decrease
           of volume. For most situations, the attack time (response to the  audio  getting  louder)  should  be
           shorter than the decay time, because the human ear is more sensitive to sudden loud audio than sudden
           soft  audio.  A typical value for attack is 0.3 seconds and a typical value for decay is 0.8 seconds.
           If specified number of attacks &amp; decays is lower than number of channels, the last  set  attack/decay
           will be used for all remaining channels.

       <b>points</b>
           A  list  of points for the transfer function, specified in dB relative to the maximum possible signal
           amplitude. Each key points list must be defined using the following syntax:  "x0/y0|x1/y1|x2/y2|...."
           or "x0/y0 x1/y1 x2/y2 ...."

           The  input  values must be in strictly increasing order but the transfer function does not have to be
           monotonically rising. The point "0/0" is assumed but may  be  overridden  (by  "0/out-dBn").  Typical
           values for the transfer function are "-70/-70|-60/-20|1/0".

       <b>soft-knee</b>
           Set the curve radius in dB for all joints. It defaults to 0.01.

       <b>gain</b>
           Set  the  additional gain in dB to be applied at all points on the transfer function. This allows for
           easy adjustment of the overall gain.  It defaults to 0.

       <b>volume</b>
           Set an initial volume, in dB, to be assumed for each channel when filtering starts. This permits  the
           user  to  supply a nominal level initially, so that, for example, a very large gain is not applied to
           initial signal levels before the companding has begun to operate. A typical value for audio which  is
           initially quiet is -90 dB. It defaults to 0.

       <b>delay</b>
           Set  a  delay, in seconds. The input audio is analyzed immediately, but audio is delayed before being
           fed to the volume adjuster. Specifying a delay approximately equal to the attack/decay  times  allows
           the filter to effectively operate in predictive rather than reactive mode. It defaults to 0.

       <u>Examples</u>

       •   Make music with both quiet and loud passages suitable for listening to in a noisy environment:

                   compand=.3|.3:1|1:-90/-60|-60/-40|-40/-30|-20/-20:6:0:-90:0.2

           Another example for audio with whisper and explosion parts:

                   compand=0|0:1|1:-90/-900|-70/-70|-30/-9|0/-3:6:0:0:0

       •   A noise gate for when the noise is at a lower level than the signal:

                   compand=.1|.1:.2|.2:-900/-900|-50.1/-900|-50/-50:.01:0:-90:.1

       •   Here is another noise gate, this time for when the noise is at a higher level than the signal (making
           it, in some ways, similar to squelch):

                   compand=.1|.1:.1|.1:-45.1/-45.1|-45/-900|0/-900:.01:45:-90:.1

       •   2:1 compression starting at -6dB:

                   compand=points=-80/-80|-6/-6|0/-3.8|20/3.5

       •   2:1 compression starting at -9dB:

                   compand=points=-80/-80|-9/-9|0/-5.3|20/2.9

       •   2:1 compression starting at -12dB:

                   compand=points=-80/-80|-12/-12|0/-6.8|20/1.9

       •   2:1 compression starting at -18dB:

                   compand=points=-80/-80|-18/-18|0/-9.8|20/0.7

       •   3:1 compression starting at -15dB:

                   compand=points=-80/-80|-15/-15|0/-10.8|20/-5.2

       •   Compressor/Gate:

                   compand=points=-80/-105|-62/-80|-15.4/-15.4|0/-12|20/-7.6

       •   Expander:

                   compand=attacks=0:points=-80/-169|-54/-80|-49.5/-64.6|-41.1/-41.1|-25.8/-15|-10.8/-4.5|0/0|20/8.3

       •   Hard limiter at -6dB:

                   compand=attacks=0:points=-80/-80|-6/-6|20/-6

       •   Hard limiter at -12dB:

                   compand=attacks=0:points=-80/-80|-12/-12|20/-12

       •   Hard noise gate at -35 dB:

                   compand=attacks=0:points=-80/-115|-35.1/-80|-35/-35|20/20

       •   Soft limiter:

                   compand=attacks=0:points=-80/-80|-12.4/-12.4|-6/-8|0/-6.8|20/-2.8

   <b>compensationdelay</b>
       Compensation  Delay  Line  is  a  metric  based delay to compensate differing positions of microphones or
       speakers.

       For example, you have recorded guitar with two microphones placed in  different  locations.  Because  the
       front of sound wave has fixed speed in normal conditions, the phasing of microphones can vary and depends
       on  their  location  and  interposition. The best sound mix can be achieved when these microphones are in
       phase (synchronized). Note that a distance of ~30 cm between microphones makes one microphone capture the
       signal in antiphase to the other microphone. That makes the final mix sound moody.  This filter helps  to
       solve phasing problems by adding different delays to each microphone track and make them synchronized.

       The  best  result  can be reached when you take one track as base and synchronize other tracks one by one
       with it.  Remember that synchronization/delay tolerance depends on sample rate, too.  Higher sample rates
       will give more tolerance.

       The filter accepts the following parameters:

       <b>mm</b>  Set millimeters distance. This is compensation distance for fine tuning.  Default is 0.

       <b>cm</b>  Set cm distance. This is compensation distance for tightening distance setup.  Default is 0.

       <b>m</b>   Set meters distance. This is compensation distance for hard distance setup.  Default is 0.

       <b>dry</b> Set dry amount. Amount of unprocessed (dry) signal.  Default is 0.

       <b>wet</b> Set wet amount. Amount of processed (wet) signal.  Default is 1.

       <b>temp</b>
           Set temperature in degrees Celsius. This is the temperature of the environment.  Default is 20.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>crossfeed</b>
       Apply headphone crossfeed filter.

       Crossfeed is the process of blending the left and right channels of stereo audio recording.  It is mainly
       used to reduce extreme stereo separation of low frequencies.

       The intent is to produce more speaker like sound to the listener.

       The filter accepts the following options:

       <b>strength</b>
           Set strength of crossfeed. Default is 0.2. Allowed range is from 0 to 1.  This sets gain of low shelf
           filter for side part of stereo image.  Default is -6dB. Max allowed is -30db when strength is set  to
           1.

       <b>range</b>
           Set  soundstage  wideness. Default is 0.5. Allowed range is from 0 to 1.  This sets cut off frequency
           of low shelf filter. Default is cut off near 1550 Hz. With range set to 1 cut off frequency is set to
           2100 Hz.

       <b>slope</b>
           Set curve slope of low shelf filter. Default is 0.5.  Allowed range is from 0.01 to 1.

       <b>level_in</b>
           Set input gain. Default is 0.9.

       <b>level_out</b>
           Set output gain. Default is 1.

       <b>block_size</b>
           Set block size used for reverse IIR processing. If this value is set to  high  enough  value  (higher
           than  impulse  response  length truncated when reaches near zero values) filtering will become linear
           phase otherwise if not big enough it will just produce nasty artifacts.

           Note that filter delay will be exactly this many samples when set to non-zero value.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>crystalizer</b>
       Simple algorithm for audio noise sharpening.

       This filter linearly increases differences between each audio sample.

       The filter accepts the following options:

       <b>i</b>   Sets the intensity of effect (default: 2.0). Must be in range between -10.0 to 0 (unchanged sound) to
           10.0 (maximum effect).  To inverse filtering use negative value.

       <b>c</b>   Enable clipping. By default is enabled.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>dcshift</b>
       Apply a DC shift to the audio.

       This can be useful to remove a DC offset (caused perhaps by a hardware problem in  the  recording  chain)
       from  the audio. The effect of a DC offset is reduced headroom and hence volume. The <b>astats</b> filter can be
       used to determine if a signal has a DC offset.

       <b>shift</b>
           Set the DC shift, allowed range is [-1, 1]. It indicates the amount to shift the audio.

       <b>limitergain</b>
           Optional. It should have a value much less than 1  (e.g.  0.05  or  0.02)  and  is  used  to  prevent
           clipping.

   <b>deesser</b>
       Apply de-essing to the audio samples.

       <b>i</b>   Set intensity for triggering de-essing. Allowed range is from 0 to 1.  Default is 0.

       <b>m</b>   Set amount of ducking on treble part of sound. Allowed range is from 0 to 1.  Default is 0.5.

       <b>f</b>   How much of original frequency content to keep when de-essing. Allowed range is from 0 to 1.  Default
           is 0.5.

       <b>s</b>   Set the output mode.

           It accepts the following values:

           <b>i</b>   Pass input unchanged.

           <b>o</b>   Pass ess filtered out.

           <b>e</b>   Pass only ess.

               Default value is <u>o</u>.

   <b>dialoguenhance</b>
       Enhance dialogue in stereo audio.

       This  filter  accepts  stereo input and produce surround (3.0) channels output.  The newly produced front
       center channel have enhanced speech dialogue originally available in both stereo channels.   This  filter
       outputs front left and front right channels same as available in stereo input.

       The filter accepts the following options:

       <b>original</b>
           Set the original center factor to keep in front center channel output.  Allowed range is from 0 to 1.
           Default value is 1.

       <b>enhance</b>
           Set the dialogue enhance factor to put in front center channel output.  Allowed range is from 0 to 3.
           Default value is 1.

       <b>voice</b>
           Set the voice detection factor.  Allowed range is from 2 to 32. Default value is 2.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>drmeter</b>
       Measure audio dynamic range.

       DR  values  of  14  and  higher  is  found in very dynamic material. DR of 8 to 13 is found in transition
       material. And anything less that 8 have very poor dynamics and is very compressed.

       The filter accepts the following options:

       <b>length</b>
           Set window length in seconds used to split audio  into  segments  of  equal  length.   Default  is  3
           seconds.

   <b>dynaudnorm</b>
       Dynamic Audio Normalizer.

       This filter applies a certain amount of gain to the input audio in order to bring its peak magnitude to a
       target  level  (e.g. 0 dBFS). However, in contrast to more "simple" normalization algorithms, the Dynamic
       Audio Normalizer *dynamically* re-adjusts the gain factor to the input audio.  This allows  for  applying
       extra  gain  to  the  "quiet"  sections  of  the  audio while avoiding distortions or clipping the "loud"
       sections. In other words: The Dynamic Audio Normalizer will "even out"  the  volume  of  quiet  and  loud
       sections,  in  the  sense  that  the  volume  of  each section is brought to the same target level. Note,
       however, that the  Dynamic  Audio  Normalizer  achieves  this  goal  *without*  applying  "dynamic  range
       compressing". It will retain 100% of the dynamic range *within* each section of the audio file.

       <b>framelen,</b> <b>f</b>
           Set  the  frame  length  in  milliseconds.  In  range  from  10 to 8000 milliseconds.  Default is 500
           milliseconds.  The Dynamic Audio Normalizer processes the input audio in small chunks, referred to as
           frames. This is required, because a peak magnitude has no meaning for just  a  single  sample  value.
           Instead,  we need to determine the peak magnitude for a contiguous sequence of sample values. While a
           "standard" normalizer would simply use the peak magnitude of the complete  file,  the  Dynamic  Audio
           Normalizer  determines  the  peak  magnitude  individually  for  each frame. The length of a frame is
           specified in milliseconds. By default, the Dynamic Audio  Normalizer  uses  a  frame  length  of  500
           milliseconds,  which  has been found to give good results with most files.  Note that the exact frame
           length, in number of samples, will be determined automatically, based on the  sampling  rate  of  the
           individual input audio file.

       <b>gausssize,</b> <b>g</b>
           Set  the  Gaussian  filter  window  size.  In range from 3 to 301, must be odd number. Default is 31.
           Probably the most important parameter of the Dynamic Audio Normalizer is the  "window  size"  of  the
           Gaussian  smoothing  filter.  The  filter's  window  size is specified in frames, centered around the
           current frame. For the sake of simplicity, this must be an  odd  number.  Consequently,  the  default
           value  of  31  takes  into  account  the current frame, as well as the 15 preceding frames and the 15
           subsequent frames. Using a larger window results in a stronger smoothing effect and thus in less gain
           variation, i.e. slower gain adaptation. Conversely, using  a  smaller  window  results  in  a  weaker
           smoothing  effect  and thus in more gain variation, i.e. faster gain adaptation.  In other words, the
           more you increase this value, the more the Dynamic Audio Normalizer will behave like a  "traditional"
           normalization  filter.  On the contrary, the more you decrease this value, the more the Dynamic Audio
           Normalizer will behave like a dynamic range compressor.

       <b>peak,</b> <b>p</b>
           Set the target peak value. This specifies the highest permissible magnitude level for the  normalized
           audio  input.  This filter will try to approach the target peak magnitude as closely as possible, but
           at the same time it also makes sure that the normalized signal will never exceed the peak  magnitude.
           A  frame's  maximum  local  gain factor is imposed directly by the target peak magnitude. The default
           value is 0.95 and thus leaves a headroom of 5%*.  It is not recommended to go above this value.

       <b>maxgain,</b> <b>m</b>
           Set the maximum gain factor. In range from  1.0  to  100.0.  Default  is  10.0.   The  Dynamic  Audio
           Normalizer determines the maximum possible (local) gain factor for each input frame, i.e. the maximum
           gain  factor that does not result in clipping or distortion. The maximum gain factor is determined by
           the frame's highest magnitude sample. However, the Dynamic Audio Normalizer additionally  bounds  the
           frame's maximum gain factor by a predetermined (global) maximum gain factor. This is done in order to
           avoid excessive gain factors in "silent" or almost silent frames. By default, the maximum gain factor
           is  10.0, For most inputs the default value should be sufficient and it usually is not recommended to
           increase this value. Though, for input with  an  extremely  low  overall  volume  level,  it  may  be
           necessary  to  allow  even higher gain factors. Note, however, that the Dynamic Audio Normalizer does
           not simply apply a "hard" threshold (i.e. cut off values above the threshold).  Instead, a  "sigmoid"
           threshold  function  will be applied. This way, the gain factors will smoothly approach the threshold
           value, but never exceed that value.

       <b>targetrms,</b> <b>r</b>
           Set the target RMS. In range from 0.0 to 1.0. Default is 0.0 - disabled.   By  default,  the  Dynamic
           Audio  Normalizer  performs  "peak" normalization.  This means that the maximum local gain factor for
           each frame is defined (only) by the frame's highest magnitude sample. This way, the  samples  can  be
           amplified  as  much  as  possible  without exceeding the maximum signal level, i.e. without clipping.
           Optionally, however, the Dynamic Audio Normalizer can also take into account the  frame's  root  mean
           square,  abbreviated  RMS. In electrical engineering, the RMS is commonly used to determine the power
           of a time-varying signal. It is therefore considered that the RMS is a better  approximation  of  the
           "perceived loudness" than just looking at the signal's peak magnitude. Consequently, by adjusting all
           frames  to  a  constant RMS value, a uniform "perceived loudness" can be established. If a target RMS
           value has been specified, a frame's local gain factor is defined as the factor that would  result  in
           exactly that RMS value.  Note, however, that the maximum local gain factor is still restricted by the
           frame's highest magnitude sample, in order to prevent clipping.

       <b>coupling,</b> <b>n</b>
           Enable  channels  coupling.  By  default  is  enabled.  By default, the Dynamic Audio Normalizer will
           amplify all channels by the same amount. This means the same gain  factor  will  be  applied  to  all
           channels, i.e.  the maximum possible gain factor is determined by the "loudest" channel.  However, in
           some  recordings, it may happen that the volume of the different channels is uneven, e.g. one channel
           may be "quieter" than the other one(s).  In this case, this option can be used to disable the channel
           coupling. This way, the gain factor will be determined independently for each channel, depending only
           on the individual channel's highest magnitude sample. This allows for harmonizing the volume  of  the
           different channels.

       <b>correctdc,</b> <b>c</b>
           Enable  DC  bias  correction.  By  default  is  disabled.   An audio signal (in the time domain) is a
           sequence of sample values.  In the Dynamic Audio Normalizer these sample values  are  represented  in
           the  -1.0  to  1.0  range,  regardless  of  the original input format. Normally, the audio signal, or
           "waveform", should be centered around the zero point.  That means if we calculate the mean  value  of
           all  samples in a file, or in a single frame, then the result should be 0.0 or at least very close to
           that value. If, however, there is a significant deviation of the  mean  value  from  0.0,  in  either
           positive  or  negative  direction,  this is referred to as a DC bias or DC offset. Since a DC bias is
           clearly undesirable, the Dynamic Audio Normalizer provides optional DC bias correction.  With DC bias
           correction enabled, the Dynamic Audio Normalizer will determine the mean value,  or  "DC  correction"
           offset,  of  each  input  frame  and  subtract that value from all of the frame's sample values which
           ensures those samples are centered around 0.0 again. Also, in order to  avoid  "gaps"  at  the  frame
           boundaries,  the  DC  correction  offset  values  will  be interpolated smoothly between neighbouring
           frames.

       <b>altboundary,</b> <b>b</b>
           Enable alternative boundary mode. By default is disabled.  The Dynamic Audio  Normalizer  takes  into
           account  a certain neighbourhood around each frame. This includes the preceding frames as well as the
           subsequent frames. However, for the "boundary" frames, located at the very beginning and at the  very
           end  of  the  audio file, not all neighbouring frames are available. In particular, for the first few
           frames in the audio file, the preceding frames are not known. And, similarly, for the last few frames
           in the audio file, the subsequent frames are not known. Thus, the question arises which gain  factors
           should  be  assumed  for  the  missing  frames in the "boundary" region. The Dynamic Audio Normalizer
           implements two modes to deal with this situation. The default boundary mode assumes a gain factor  of
           exactly  1.0  for the missing frames, resulting in a smooth "fade in" and "fade out" at the beginning
           and at the end of the input, respectively.

       <b>compress,</b> <b>s</b>
           Set the compress factor. In range from 0.0 to 30.0. Default is 0.0.  By default,  the  Dynamic  Audio
           Normalizer  does not apply "traditional" compression. This means that signal peaks will not be pruned
           and thus the full dynamic range will be retained within each local neighbourhood.  However,  in  some
           cases  it  may  be desirable to combine the Dynamic Audio Normalizer's normalization algorithm with a
           more "traditional" compression.  For this purpose, the Dynamic Audio Normalizer provides an  optional
           compression  (thresholding)  function. If (and only if) the compression feature is enabled, all input
           frames will be processed by a soft knee thresholding  function  prior  to  the  actual  normalization
           process.  Put simply, the thresholding function is going to prune all samples whose magnitude exceeds
           a certain threshold value.  However, the Dynamic Audio Normalizer  does  not  simply  apply  a  fixed
           threshold  value.  Instead,  the  threshold  value  will  be  adjusted for each individual frame.  In
           general, smaller parameters result in stronger compression, and vice versa.  Values below 3.0 are not
           recommended, because audible distortion may appear.

       <b>threshold,</b> <b>t</b>
           Set the target threshold value. This specifies the lowest permissible magnitude level for  the  audio
           input  which will be normalized.  If input frame volume is above this value frame will be normalized.
           Otherwise frame may not be normalized at all. The default value is set to 0, which  means  all  input
           frames  will  be  normalized.   This  option  is  mostly  useful if digital noise is not wanted to be
           amplified.

       <b>channels,</b> <b>h</b>
           Specify which channels to filter, by default all available channels are filtered.

       <b>overlap,</b> <b>o</b>
           Specify overlap for frames. If set to 0 (default) no frame overlapping is  done.   Using  &gt;0  and  &lt;1
           values  will  make  less  conservative  gain adjustments, like when framelen option is set to smaller
           value, if framelen option value is compensated for non-zero overlap then  gain  adjustments  will  be
           smoother across time compared to zero overlap case.

       <b>curve,</b> <b>v</b>
           Specify  the peak mapping curve expression which is going to be used when calculating gain applied to
           frames. The max output frame gain will still be limited by other  options  mentioned  previously  for
           this filter.

           The expression can contain the following constants:

           <b>ch</b>  current channel number

           <b>sn</b>  current sample number

           <b>nb_channels</b>
               number of channels

           <b>t</b>   timestamp expressed in seconds

           <b>sr</b>  sample rate

           <b>p</b>   current frame peak value

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>earwax</b>
       Make audio easier to listen to on headphones.

       This  filter  adds  `cues'  to  44.1kHz  stereo  (i.e. audio CD format) audio so that when listened to on
       headphones the stereo image is moved from inside your head (standard for headphones) to  outside  and  in
       front of the listener (standard for speakers).

       Ported from SoX.

   <b>equalizer</b>
       Apply  a  two-pole  peaking  equalisation (EQ) filter. With this filter, the signal-level at and around a
       selected frequency can be increased or decreased, whilst (unlike bandpass and bandreject filters) that at
       all other frequencies is unchanged.

       In order to produce complex equalisation curves, this filter can be given  several  times,  each  with  a
       different central frequency.

       The filter accepts the following options:

       <b>frequency,</b> <b>f</b>
           Set the filter's central frequency in Hz.

       <b>width_type,</b> <b>t</b>
           Set method to specify band-width of filter.

           <b>h</b>   Hz

           <b>q</b>   Q-Factor

           <b>o</b>   octave

           <b>s</b>   slope

           <b>k</b>   kHz

       <b>width,</b> <b>w</b>
           Specify the band-width of a filter in width_type units.

       <b>gain,</b> <b>g</b>
           Set the required gain or attenuation in dB.  Beware of clipping when using a positive gain.

       <b>mix,</b> <b>m</b>
           How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>channels,</b> <b>c</b>
           Specify which channels to filter, by default all available are filtered.

       <b>normalize,</b> <b>n</b>
           Normalize biquad coefficients, by default is disabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>transform,</b> <b>a</b>
           Set transform type of IIR filter.

           <b>di</b>
           <b>dii</b>
           <b>tdi</b>
           <b>tdii</b>
           <b>latt</b>
           <b>svf</b>
           <b>zdf</b>
       <b>precision,</b> <b>r</b>
           Set precision of filtering.

           <b>auto</b>
               Pick automatic sample format depending on surround filters.

           <b>s16</b> Always use signed 16-bit.

           <b>s32</b> Always use signed 32-bit.

           <b>f32</b> Always use float 32-bit.

           <b>f64</b> Always use float 64-bit.

       <b>block_size,</b> <b>b</b>
           Set  block  size  used  for reverse IIR processing. If this value is set to high enough value (higher
           than impulse response length truncated when reaches near zero values) filtering  will  become  linear
           phase otherwise if not big enough it will just produce nasty artifacts.

           Note that filter delay will be exactly this many samples when set to non-zero value.

       <u>Examples</u>

       •   Attenuate 10 dB at 1000 Hz, with a bandwidth of 200 Hz:

                   equalizer=f=1000:t=h:width=200:g=-10

       •   Apply 2 dB gain at 1000 Hz with Q 1 and attenuate 5 dB at 100 Hz with Q 2:

                   equalizer=f=1000:t=q:w=1:g=2,equalizer=f=100:t=q:w=2:g=-5

       <u>Commands</u>

       This filter supports the following commands:

       <b>frequency,</b> <b>f</b>
           Change equalizer frequency.  Syntax for the command is : "<u>frequency</u>"

       <b>width_type,</b> <b>t</b>
           Change equalizer width_type.  Syntax for the command is : "<u>width_type</u>"

       <b>width,</b> <b>w</b>
           Change equalizer width.  Syntax for the command is : "<u>width</u>"

       <b>gain,</b> <b>g</b>
           Change equalizer gain.  Syntax for the command is : "<u>gain</u>"

       <b>mix,</b> <b>m</b>
           Change equalizer mix.  Syntax for the command is : "<u>mix</u>"

   <b>extrastereo</b>
       Linearly  increases  the difference between left and right channels which adds some sort of "live" effect
       to playback.

       The filter accepts the following options:

       <b>m</b>   Sets the difference coefficient (default: 2.5). 0.0 means mono sound (average of both channels), with
           1.0 sound will be unchanged, with -1.0 left and right channels will be swapped.

       <b>c</b>   Enable clipping. By default is enabled.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>firequalizer</b>
       Apply FIR Equalization using arbitrary frequency response.

       The filter accepts the following option:

       <b>gain</b>
           Set gain curve equation (in dB). The expression can contain variables:

           <b>f</b>   the evaluated frequency

           <b>sr</b>  sample rate

           <b>ch</b>  channel number, set to 0 when multichannels evaluation is disabled

           <b>chid</b>
               channel id, see libavutil/channel_layout.h, set  to  the  first  channel  id  when  multichannels
               evaluation is disabled

           <b>chs</b> number of channels

           <b>chlayout</b>
               channel_layout, see libavutil/channel_layout.h

           and functions:

           <b>gain_interpolate(f)</b>
               interpolate gain on frequency f based on gain_entry

           <b>cubic_interpolate(f)</b>
               same as gain_interpolate, but smoother

           This option is also available as command. Default is gain_interpolate(f).

       <b>gain_entry</b>
           Set gain entry for gain_interpolate function. The expression can contain functions:

           <b>entry(f,</b> <b>g)</b>
               store gain entry at frequency f with value g

           This option is also available as command.

       <b>delay</b>
           Set filter delay in seconds. Higher value means more accurate.  Default is 0.01.

       <b>accuracy</b>
           Set filter accuracy in Hz. Lower value means more accurate.  Default is 5.

       <b>wfunc</b>
           Set window function. Acceptable values are:

           <b>rectangular</b>
               rectangular window, useful when gain curve is already smooth

           <b>hann</b>
               hann window (default)

           <b>hamming</b>
               hamming window

           <b>blackman</b>
               blackman window

           <b>nuttall3</b>
               3-terms continuous 1st derivative nuttall window

           <b>mnuttall3</b>
               minimum 3-terms discontinuous nuttall window

           <b>nuttall</b>
               4-terms continuous 1st derivative nuttall window

           <b>bnuttall</b>
               minimum 4-terms discontinuous nuttall (blackman-nuttall) window

           <b>bharris</b>
               blackman-harris window

           <b>tukey</b>
               tukey window

       <b>fixed</b>
           If  enabled,  use fixed number of audio samples. This improves speed when filtering with large delay.
           Default is disabled.

       <b>multi</b>
           Enable multichannels evaluation on gain. Default is disabled.

       <b>zero_phase</b>
           Enable zero phase mode by subtracting timestamp to compensate delay.  Default is disabled.

       <b>scale</b>
           Set scale used by gain. Acceptable values are:

           <b>linlin</b>
               linear frequency, linear gain

           <b>linlog</b>
               linear frequency, logarithmic (in dB) gain (default)

           <b>loglin</b>
               logarithmic (in octave scale where 20 Hz is 0) frequency, linear gain

           <b>loglog</b>
               logarithmic frequency, logarithmic gain

       <b>dumpfile</b>
           Set file for dumping, suitable for gnuplot.

       <b>dumpscale</b>
           Set scale for dumpfile. Acceptable values are same with scale option.  Default is linlog.

       <b>fft2</b>
           Enable 2-channel convolution using complex  FFT.  This  improves  speed  significantly.   Default  is
           disabled.

       <b>min_phase</b>
           Enable minimum phase impulse response. Default is disabled.

       <u>Examples</u>

       •   lowpass at 1000 Hz:

                   firequalizer=gain='if(lt(f,1000), 0, -INF)'

       •   lowpass at 1000 Hz with gain_entry:

                   firequalizer=gain_entry='entry(1000,0); entry(1001, -INF)'

       •   custom equalization:

                   firequalizer=gain_entry='entry(100,0); entry(400, -4); entry(1000, -6); entry(2000, 0)'

       •   higher delay with zero phase to compensate delay:

                   firequalizer=delay=0.1:fixed=on:zero_phase=on

       •   lowpass on left channel, highpass on right channel:

                   firequalizer=gain='if(eq(chid,1), gain_interpolate(f), if(eq(chid,2), gain_interpolate(1e6+f), 0))'
                   :gain_entry='entry(1000, 0); entry(1001,-INF); entry(1e6+1000,0)':multi=on

   <b>flanger</b>
       Apply a flanging effect to the audio.

       The filter accepts the following options:

       <b>delay</b>
           Set base delay in milliseconds. Range from 0 to 30. Default value is 0.

       <b>depth</b>
           Set added sweep delay in milliseconds. Range from 0 to 10. Default value is 2.

       <b>regen</b>
           Set percentage regeneration (delayed signal feedback). Range from -95 to 95.  Default value is 0.

       <b>width</b>
           Set percentage of delayed signal mixed with original. Range from 0 to 100.  Default value is 71.

       <b>speed</b>
           Set sweeps per second (Hz). Range from 0.1 to 10. Default value is 0.5.

       <b>shape</b>
           Set swept wave shape, can be <u>triangular</u> or <u>sinusoidal</u>.  Default value is <u>sinusoidal</u>.

       <b>phase</b>
           Set swept wave percentage-shift for multi channel. Range from 0 to 100.  Default value is 25.

       <b>interp</b>
           Set delay-line interpolation, <u>linear</u> or <u>quadratic</u>.  Default is <u>linear</u>.

   <b>haas</b>
       Apply Haas effect to audio.

       Note  that  this  makes most sense to apply on mono signals.  With this filter applied to mono signals it
       give some directionality and stretches its stereo image.

       The filter accepts the following options:

       <b>level_in</b>
           Set input level. By default is <u>1</u>, or 0dB

       <b>level_out</b>
           Set output level. By default is <u>1</u>, or 0dB.

       <b>side_gain</b>
           Set gain applied to side part of signal. By default is <u>1</u>.

       <b>middle_source</b>
           Set kind of middle source. Can be one of the following:

           <b>left</b>
               Pick left channel.

           <b>right</b>
               Pick right channel.

           <b>mid</b> Pick middle part signal of stereo image.

           <b>side</b>
               Pick side part signal of stereo image.

       <b>middle_phase</b>
           Change middle phase. By default is disabled.

       <b>left_delay</b>
           Set left channel delay. By default is <u>2.05</u> milliseconds.

       <b>left_balance</b>
           Set left channel balance. By default is <u>-1</u>.

       <b>left_gain</b>
           Set left channel gain. By default is <u>1</u>.

       <b>left_phase</b>
           Change left phase. By default is disabled.

       <b>right_delay</b>
           Set right channel delay. By defaults is <u>2.12</u> milliseconds.

       <b>right_balance</b>
           Set right channel balance. By default is <u>1</u>.

       <b>right_gain</b>
           Set right channel gain. By default is <u>1</u>.

       <b>right_phase</b>
           Change right phase. By default is enabled.

   <b>hdcd</b>
       Decodes High Definition Compatible Digital (HDCD) data. A 16-bit PCM stream with embedded HDCD  codes  is
       expanded into a 20-bit PCM stream.

       The  filter  supports  the  Peak  Extend  and Low-level Gain Adjustment features of HDCD, and detects the
       Transient Filter flag.

               ffmpeg -i HDCD16.flac -af hdcd OUT24.flac

       When using the filter with wav, note the default encoding for wav is  16-bit,  so  the  resulting  20-bit
       stream  will  be  truncated  back to 16-bit. Use something like <b>-acodec</b> <b>pcm_s24le</b> after the filter to get
       24-bit PCM output.

               ffmpeg -i HDCD16.wav -af hdcd OUT16.wav
               ffmpeg -i HDCD16.wav -af hdcd -c:a pcm_s24le OUT24.wav

       The filter accepts the following options:

       <b>disable_autoconvert</b>
           Disable any automatic format conversion or resampling in the filter graph.

       <b>process_stereo</b>
           Process the stereo channels together. If target_gain does not match  between  channels,  consider  it
           invalid and use the last valid target_gain.

       <b>cdt_ms</b>
           Set the code detect timer period in ms.

       <b>force_pe</b>
           Always extend peaks above -3dBFS even if PE isn't signaled.

       <b>analyze_mode</b>
           Replace  audio  with  a  solid  tone  and  adjust the amplitude to signal some specific aspect of the
           decoding process. The output file can be loaded in an audio editor  alongside  the  original  to  aid
           analysis.

           "analyze_mode=pe:force_pe=true" can be used to see all samples above the PE level.

           Modes are:

           <b>0,</b> <b>off</b>
               Disabled

           <b>1,</b> <b>lle</b>
               Gain adjustment level at each sample

           <b>2,</b> <b>pe</b>
               Samples where peak extend occurs

           <b>3,</b> <b>cdt</b>
               Samples where the code detect timer is active

           <b>4,</b> <b>tgm</b>
               Samples where the target gain does not match between channels

   <b>headphone</b>
       Apply head-related transfer functions (HRTFs) to create virtual loudspeakers around the user for binaural
       listening  via  headphones.   The  HRIRs are provided via additional streams, for each channel one stereo
       input stream is needed.

       The filter accepts the following options:

       <b>map</b> Set mapping of input streams for convolution.  The argument is a '|'-separated list of channel  names
           in order as they are given as additional stream inputs for filter.  This also specify number of input
           streams. Number of input streams must be not less than number of channels in first stream plus one.

       <b>gain</b>
           Set gain applied to audio. Value is in dB. Default is 0.

       <b>type</b>
           Set  processing  type.  Can  be  <u>time</u> or <u>freq</u>. <u>time</u> is processing audio in time domain which is slow.
           <u>freq</u> is processing audio in frequency domain which is fast.  Default is <u>freq</u>.

       <b>lfe</b> Set custom gain for LFE channels. Value is in dB. Default is 0.

       <b>size</b>
           Set size of frame in number of samples which will be processed  at  once.   Default  value  is  <u>1024</u>.
           Allowed range is from 1024 to 96000.

       <b>hrir</b>
           Set  format  of hrir stream.  Default value is <u>stereo</u>. Alternative value is <u>multich</u>.  If value is set
           to <u>stereo</u>, number of additional streams should be greater or equal to number  of  input  channels  in
           first  input stream.  Also each additional stream should have stereo number of channels.  If value is
           set to <u>multich</u>, number of additional streams should be exactly one. Also number of input channels  of
           additional stream should be equal or greater than twice number of channels of first input stream.

       <u>Examples</u>

       •   Full  example using wav files as coefficients with amovie filters for 7.1 downmix, each amovie filter
           use stereo file with IR coefficients as input.  The files give  coefficients  for  each  position  of
           virtual loudspeaker:

                   ffmpeg -i input.wav
                   -filter_complex "amovie=azi_270_ele_0_DFC.wav[sr];amovie=azi_90_ele_0_DFC.wav[sl];amovie=azi_225_ele_0_DFC.wav[br];amovie=azi_135_ele_0_DFC.wav[bl];amovie=azi_0_ele_0_DFC.wav,asplit[fc][lfe];amovie=azi_35_ele_0_DFC.wav[fl];amovie=azi_325_ele_0_DFC.wav[fr];[0:a][fl][fr][fc][lfe][bl][br][sl][sr]headphone=FL|FR|FC|LFE|BL|BR|SL|SR"
                   output.wav

       •   Full  example using wav files as coefficients with amovie filters for 7.1 downmix, but now in <u>multich</u>
           <u>hrir</u> format.

                   ffmpeg -i input.wav -filter_complex "amovie=minp.wav[hrirs];[0:a][hrirs]headphone=map=FL|FR|FC|LFE|BL|BR|SL|SR:hrir=multich"
                   output.wav

   <b>highpass</b>
       Apply a high-pass filter with 3dB point frequency.  The filter can be either single-pole, or  double-pole
       (the default).  The filter roll off at 6dB per pole per octave (20dB per pole per decade).

       The filter accepts the following options:

       <b>frequency,</b> <b>f</b>
           Set frequency in Hz. Default is 3000.

       <b>poles,</b> <b>p</b>
           Set number of poles. Default is 2.

       <b>width_type,</b> <b>t</b>
           Set method to specify band-width of filter.

           <b>h</b>   Hz

           <b>q</b>   Q-Factor

           <b>o</b>   octave

           <b>s</b>   slope

           <b>k</b>   kHz

       <b>width,</b> <b>w</b>
           Specify  the  band-width  of  a filter in width_type units.  Applies only to double-pole filter.  The
           default is 0.707q and gives a Butterworth response.

       <b>mix,</b> <b>m</b>
           How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>channels,</b> <b>c</b>
           Specify which channels to filter, by default all available are filtered.

       <b>normalize,</b> <b>n</b>
           Normalize biquad coefficients, by default is disabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>transform,</b> <b>a</b>
           Set transform type of IIR filter.

           <b>di</b>
           <b>dii</b>
           <b>tdi</b>
           <b>tdii</b>
           <b>latt</b>
           <b>svf</b>
           <b>zdf</b>
       <b>precision,</b> <b>r</b>
           Set precision of filtering.

           <b>auto</b>
               Pick automatic sample format depending on surround filters.

           <b>s16</b> Always use signed 16-bit.

           <b>s32</b> Always use signed 32-bit.

           <b>f32</b> Always use float 32-bit.

           <b>f64</b> Always use float 64-bit.

       <b>block_size,</b> <b>b</b>
           Set block size used for reverse IIR processing. If this value is set to  high  enough  value  (higher
           than  impulse  response  length truncated when reaches near zero values) filtering will become linear
           phase otherwise if not big enough it will just produce nasty artifacts.

           Note that filter delay will be exactly this many samples when set to non-zero value.

       <u>Commands</u>

       This filter supports the following commands:

       <b>frequency,</b> <b>f</b>
           Change highpass frequency.  Syntax for the command is : "<u>frequency</u>"

       <b>width_type,</b> <b>t</b>
           Change highpass width_type.  Syntax for the command is : "<u>width_type</u>"

       <b>width,</b> <b>w</b>
           Change highpass width.  Syntax for the command is : "<u>width</u>"

       <b>mix,</b> <b>m</b>
           Change highpass mix.  Syntax for the command is : "<u>mix</u>"

   <b>join</b>
       Join multiple input streams into one multi-channel stream.

       It accepts the following parameters:

       <b>inputs</b>
           The number of input streams. It defaults to 2.

       <b>channel_layout</b>
           The desired output channel layout. It defaults to stereo.

       <b>map</b> Map channels from inputs to output. The argument is a '|'-separated list of  mappings,  each  in  the
           "<u>input_idx</u>.<u>in_channel</u>-<u>out_channel</u>"  form.  <u>input_idx</u>  is  the  0-based  index  of  the  input stream.
           <u>in_channel</u> can be either the name of the input channel (e.g. FL for front left) or its index  in  the
           specified input stream. <u>out_channel</u> is the name of the output channel.

       The filter will attempt to guess the mappings when they are not specified explicitly. It does so by first
       trying  to  find  an  unused  matching  input  channel  and if that fails it picks the first unused input
       channel.

       Join 3 inputs (with properly set channel layouts):

               ffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex join=inputs=3 OUTPUT

       Build a 5.1 output from 6 single-channel streams:

               ffmpeg -i fl -i fr -i fc -i sl -i sr -i lfe -filter_complex
               'join=inputs=6:channel_layout=5.1:map=0.0-FL|1.0-FR|2.0-FC|3.0-SL|4.0-SR|5.0-LFE'
               out

   <b>ladspa</b>
       Load a LADSPA (Linux Audio Developer's Simple Plugin API) plugin.

       To enable compilation of this filter you need to configure FFmpeg with "--enable-ladspa".

       <b>file,</b> <b>f</b>
           Specifies the name of LADSPA plugin library to load.  If  the  environment  variable  <b>LADSPA_PATH</b>  is
           defined,  the  LADSPA  plugin  is  searched  in  each  one  of the directories specified by the colon
           separated list in <b>LADSPA_PATH</b>, otherwise in the standard LADSPA  paths,  which  are  in  this  order:
           <u>HOME/.ladspa/lib/</u>, <u>/usr/local/lib/ladspa/</u>, <u>/usr/lib/ladspa/</u>.

       <b>plugin,</b> <b>p</b>
           Specifies  the  plugin within the library. Some libraries contain only one plugin, but others contain
           many of them. If this is not set filter will list all available plugins within the specified library.

       <b>controls,</b> <b>c</b>
           Set the '|' separated list of controls which are zero or more floating point  values  that  determine
           the  behavior  of  the  loaded  plugin  (for  example delay, threshold or gain).  Controls need to be
           defined using the following syntax: c0=<u>value0</u>|c1=<u>value1</u>|c2=<u>value2</u>|..., where <u>valuei</u> is the value  set
           on  the  <u>i</u>-th  control.   Alternatively  they  can  be  also  defined  using  the  following  syntax:
           <u>value0</u>|<u>value1</u>|<u>value2</u>|..., where <u>valuei</u> is the value set on the <u>i</u>-th control.  If <b>controls</b> is  set  to
           "help", all available controls and their valid ranges are printed.

       <b>sample_rate,</b> <b>s</b>
           Specify the sample rate, default to 44100. Only used if plugin have zero inputs.

       <b>nb_samples,</b> <b>n</b>
           Set  the  number  of  samples per channel per each output frame, default is 1024. Only used if plugin
           have zero inputs.

       <b>duration,</b> <b>d</b>
           Set the minimum duration of the sourced audio. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b>  <b>the</b>  <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>  for  the accepted syntax.  Note that the resulting duration may be greater than the specified
           duration, as the generated audio is always cut at the end of a complete frame.  If not specified,  or
           the  expressed  duration  is  negative,  the audio is supposed to be generated forever.  Only used if
           plugin have zero inputs.

       <b>latency,</b> <b>l</b>
           Enable latency compensation, by default is disabled.  Only used if plugin have inputs.

       <u>Examples</u>

       •   List all available plugins within amp (LADSPA example plugin) library:

                   ladspa=file=amp

       •   List all available controls and their valid ranges for "vcf_notch" plugin from "VCF" library:

                   ladspa=f=vcf:p=vcf_notch:c=help

       •   Simulate low quality audio equipment using "Computer Music Toolkit" (CMT) plugin library:

                   ladspa=file=cmt:plugin=lofi:controls=c0=22|c1=12|c2=12

       •   Add reverberation to the audio using TAP-plugins (Tom's Audio Processing plugins):

                   ladspa=file=tap_reverb:tap_reverb

       •   Generate white noise, with 0.2 amplitude:

                   ladspa=file=cmt:noise_source_white:c=c0=.2

       •   Generate 20 bpm clicks using plugin "C* Click - Metronome" from the "C* Audio  Plugin  Suite"  (CAPS)
           library:

                   ladspa=file=caps:Click:c=c1=20'

       •   Apply "C* Eq10X2 - Stereo 10-band equaliser" effect:

                   ladspa=caps:Eq10X2:c=c0=-48|c9=-24|c3=12|c4=2

       •   Increase volume by 20dB using fast lookahead limiter from Steve Harris "SWH Plugins" collection:

                   ladspa=fast_lookahead_limiter_1913:fastLookaheadLimiter:20|0|2

       •   Attenuate low frequencies using Multiband EQ from Steve Harris "SWH Plugins" collection:

                   ladspa=mbeq_1197:mbeq:-24|-24|-24|0|0|0|0|0|0|0|0|0|0|0|0

       •   Reduce stereo image using "Narrower" from the "C* Audio Plugin Suite" (CAPS) library:

                   ladspa=caps:Narrower

       •   Another white noise, now using "C* Audio Plugin Suite" (CAPS) library:

                   ladspa=caps:White:.2

       •   Some fractal noise, using "C* Audio Plugin Suite" (CAPS) library:

                   ladspa=caps:Fractal:c=c1=1

       •   Dynamic volume normalization using "VLevel" plugin:

                   ladspa=vlevel-ladspa:vlevel_mono

       <u>Commands</u>

       This filter supports the following commands:

       <b>cN</b>  Modify the <u>N</u>-th control value.

           If the specified value is not valid, it is ignored and prior one is kept.

   <b>loudnorm</b>
       EBU  R128 loudness normalization. Includes both dynamic and linear normalization modes.  Support for both
       single pass (livestreams, files) and double pass (files) modes.  This algorithm can target IL,  LRA,  and
       maximum  true  peak. In dynamic mode, to accurately detect true peaks, the audio stream will be upsampled
       to 192 kHz.  Use the "-ar" option or "aresample" filter to explicitly set an output sample rate.

       The filter accepts the following options:

       <b>I,</b> <b>i</b>
           Set integrated loudness target.  Range is -70.0 - -5.0. Default value is -24.0.

       <b>LRA,</b> <b>lra</b>
           Set loudness range target.  Range is 1.0 - 50.0. Default value is 7.0.

       <b>TP,</b> <b>tp</b>
           Set maximum true peak.  Range is -9.0 - +0.0. Default value is -2.0.

       <b>measured_I,</b> <b>measured_i</b>
           Measured IL of input file.  Range is -99.0 - +0.0.

       <b>measured_LRA,</b> <b>measured_lra</b>
           Measured LRA of input file.  Range is  0.0 - 99.0.

       <b>measured_TP,</b> <b>measured_tp</b>
           Measured true peak of input file.  Range is  -99.0 - +99.0.

       <b>measured_thresh</b>
           Measured threshold of input file.  Range is -99.0 - +0.0.

       <b>offset</b>
           Set offset gain. Gain is applied before the true-peak limiter.  Range is  -99.0 - +99.0.  Default  is
           +0.0.

       <b>linear</b>
           Normalize  by  linearly  scaling  the source audio.  "measured_I", "measured_LRA", "measured_TP", and
           "measured_thresh" must all be specified. Target LRA shouldn't be lower than source LRA and the change
           in integrated loudness shouldn't result in a true peak which exceeds the target TP. If any  of  these
           conditions  aren't  met,  normalization  mode will revert to <u>dynamic</u>.  Options are "true" or "false".
           Default is "true".

       <b>dual_mono</b>
           Treat mono input files as "dual-mono". If a mono file is intended for playback on  a  stereo  system,
           its  EBU  R128  measurement  will  be  perceptually  incorrect.   If  set to "true", this option will
           compensate for this effect.  Multi-channel input files are not affected by this option.  Options  are
           true or false. Default is false.

       <b>print_format</b>
           Set print format for stats. Options are summary, json, or none.  Default value is none.

   <b>lowpass</b>
       Apply  a  low-pass  filter with 3dB point frequency.  The filter can be either single-pole or double-pole
       (the default).  The filter roll off at 6dB per pole per octave (20dB per pole per decade).

       The filter accepts the following options:

       <b>frequency,</b> <b>f</b>
           Set frequency in Hz. Default is 500.

       <b>poles,</b> <b>p</b>
           Set number of poles. Default is 2.

       <b>width_type,</b> <b>t</b>
           Set method to specify band-width of filter.

           <b>h</b>   Hz

           <b>q</b>   Q-Factor

           <b>o</b>   octave

           <b>s</b>   slope

           <b>k</b>   kHz

       <b>width,</b> <b>w</b>
           Specify the band-width of a filter in width_type units.  Applies only  to  double-pole  filter.   The
           default is 0.707q and gives a Butterworth response.

       <b>mix,</b> <b>m</b>
           How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>channels,</b> <b>c</b>
           Specify which channels to filter, by default all available are filtered.

       <b>normalize,</b> <b>n</b>
           Normalize biquad coefficients, by default is disabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>transform,</b> <b>a</b>
           Set transform type of IIR filter.

           <b>di</b>
           <b>dii</b>
           <b>tdi</b>
           <b>tdii</b>
           <b>latt</b>
           <b>svf</b>
           <b>zdf</b>
       <b>precision,</b> <b>r</b>
           Set precision of filtering.

           <b>auto</b>
               Pick automatic sample format depending on surround filters.

           <b>s16</b> Always use signed 16-bit.

           <b>s32</b> Always use signed 32-bit.

           <b>f32</b> Always use float 32-bit.

           <b>f64</b> Always use float 64-bit.

       <b>block_size,</b> <b>b</b>
           Set  block  size  used  for reverse IIR processing. If this value is set to high enough value (higher
           than impulse response length truncated when reaches near zero values) filtering  will  become  linear
           phase otherwise if not big enough it will just produce nasty artifacts.

           Note that filter delay will be exactly this many samples when set to non-zero value.

       <u>Examples</u>

       •   Lowpass only LFE channel, it LFE is not present it does nothing:

                   lowpass=c=LFE

       <u>Commands</u>

       This filter supports the following commands:

       <b>frequency,</b> <b>f</b>
           Change lowpass frequency.  Syntax for the command is : "<u>frequency</u>"

       <b>width_type,</b> <b>t</b>
           Change lowpass width_type.  Syntax for the command is : "<u>width_type</u>"

       <b>width,</b> <b>w</b>
           Change lowpass width.  Syntax for the command is : "<u>width</u>"

       <b>mix,</b> <b>m</b>
           Change lowpass mix.  Syntax for the command is : "<u>mix</u>"

   <b>lv2</b>
       Load a LV2 (LADSPA Version 2) plugin.

       To enable compilation of this filter you need to configure FFmpeg with "--enable-lv2".

       <b>plugin,</b> <b>p</b>
           Specifies the plugin URI. You may need to escape ':'.

       <b>controls,</b> <b>c</b>
           Set  the  '|'  separated list of controls which are zero or more floating point values that determine
           the behavior of the loaded plugin (for example delay, threshold or gain).   If  <b>controls</b>  is  set  to
           "help", all available controls and their valid ranges are printed.

       <b>sample_rate,</b> <b>s</b>
           Specify the sample rate, default to 44100. Only used if plugin have zero inputs.

       <b>nb_samples,</b> <b>n</b>
           Set  the  number  of  samples per channel per each output frame, default is 1024. Only used if plugin
           have zero inputs.

       <b>duration,</b> <b>d</b>
           Set the minimum duration of the sourced audio. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b>  <b>the</b>  <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>  for  the accepted syntax.  Note that the resulting duration may be greater than the specified
           duration, as the generated audio is always cut at the end of a complete frame.  If not specified,  or
           the  expressed  duration  is  negative,  the audio is supposed to be generated forever.  Only used if
           plugin have zero inputs.

       <u>Examples</u>

       •   Apply bass enhancer plugin from Calf:

                   lv2=p=http\\\\://calf.sourceforge.net/plugins/BassEnhancer:c=amount=2

       •   Apply vinyl plugin from Calf:

                   lv2=p=http\\\\://calf.sourceforge.net/plugins/Vinyl:c=drone=0.2|aging=0.5

       •   Apply bit crusher plugin from ArtyFX:

                   lv2=p=http\\\\://www.openavproductions.com/artyfx#bitta:c=crush=0.3

       <u>Commands</u>

       This filter supports all options that are exported by plugin as commands.

   <b>mcompand</b>
       Multiband Compress or expand the audio's dynamic range.

       The input audio is divided into bands using 4th order Linkwitz-Riley IIRs.  This is akin to the crossover
       of a loudspeaker, and results in flat frequency response when absent compander action.

       It accepts the following parameters:

       <b>args</b>
           This option syntax is:  attack,decay,[attack,decay..]  soft-knee  points  crossover_frequency  [delay
           [initial_volume  [gain]]]  |  attack,decay  ...  For explanation of each item refer to compand filter
           documentation.

   <b>pan</b>
       Mix channels with specific gain levels. The filter accepts the output channel layout followed by a set of
       channels definitions.

       This filter is also designed to efficiently remap the channels of an audio stream.

       The filter accepts parameters of the form: "<u>l</u>|<u>outdef</u>|<u>outdef</u>|..."

       <b>l</b>   output channel layout or number of channels

       <b>outdef</b>
           output channel specification, of the form: "<u>out_name</u>=[<u>gain</u>*]<u>in_name</u>[(+-)[<u>gain</u>*]<u>in_name</u>...]"

       <b>out_name</b>
           output channel to define, either a channel name (FL, FR, etc.) or a channel number (c0, c1, etc.)

       <b>gain</b>
           multiplicative coefficient for the channel, 1 leaving the volume unchanged

       <b>in_name</b>
           input channel to use, see out_name for details; it is not possible to mix named  and  numbered  input
           channels

       If  the  `=' in a channel specification is replaced by `&lt;', then the gains for that specification will be
       renormalized so that the total is 1, thus avoiding clipping noise.

       <u>Mixing</u> <u>examples</u>

       For example, if you want to down-mix from stereo to mono, but with a bigger factor for the left channel:

               pan=1c|c0=0.9*c0+0.1*c1

       A customized down-mix to stereo that works automatically for 3-, 4-, 5- and 7-channels surround:

               pan=stereo| FL &lt; FL + 0.5*FC + 0.6*BL + 0.6*SL | FR &lt; FR + 0.5*FC + 0.6*BR + 0.6*SR

       Note that <b>ffmpeg</b> integrates a default down-mix (and up-mix) system that should be  preferred  (see  "-ac"
       option) unless you have very specific needs.

       <u>Remapping</u> <u>examples</u>

       The channel remapping will be effective if, and only if:

       *&lt;gain coefficients are zeroes or ones,&gt;
       *&lt;only one input per channel output,&gt;

       If all these conditions are satisfied, the filter will notify the user ("Pure channel mapping detected"),
       and use an optimized and lossless method to do the remapping.

       For example, if you have a 5.1 source and want a stereo audio stream by dropping the extra channels:

               pan="stereo| c0=FL | c1=FR"

       Given the same source, you can also switch front left and front right channels and keep the input channel
       layout:

               pan="5.1| c0=c1 | c1=c0 | c2=c2 | c3=c3 | c4=c4 | c5=c5"

       If  the  input  is  a stereo audio stream, you can mute the front left channel (and still keep the stereo
       channel layout) with:

               pan="stereo|c1=c1"

       Still with a stereo audio stream input, you can copy the right channel in both front left and right:

               pan="stereo| c0=FR | c1=FR"

   <b>replaygain</b>
       ReplayGain scanner filter. This filter takes an audio stream as an input and outputs  it  unchanged.   At
       end of filtering it displays "track_gain" and "track_peak".

       The filter accepts the following exported read-only options:

       <b>track_gain</b>
           Exported track gain in dB at end of stream.

       <b>track_peak</b>
           Exported track peak at end of stream.

   <b>resample</b>
       Convert the audio sample format, sample rate and channel layout. It is not meant to be used directly.

   <b>rubberband</b>
       Apply time-stretching and pitch-shifting with librubberband.

       To enable compilation of this filter, you need to configure FFmpeg with "--enable-librubberband".

       The filter accepts the following options:

       <b>tempo</b>
           Set tempo scale factor.

       <b>pitch</b>
           Set pitch scale factor.

       <b>transients</b>
           Set transients detector.  Possible values are:

           <u>crisp</u>
           <u>mixed</u>
           <u>smooth</u>
       <b>detector</b>
           Set detector.  Possible values are:

           <u>compound</u>
           <u>percussive</u>
           <u>soft</u>
       <b>phase</b>
           Set phase.  Possible values are:

           <u>laminar</u>
           <u>independent</u>
       <b>window</b>
           Set processing window size.  Possible values are:

           <u>standard</u>
           <u>short</u>
           <u>long</u>
       <b>smoothing</b>
           Set smoothing.  Possible values are:

           <u>off</u>
           <u>on</u>
       <b>formant</b>
           Enable formant preservation when shift pitching.  Possible values are:

           <u>shifted</u>
           <u>preserved</u>
       <b>pitchq</b>
           Set pitch quality.  Possible values are:

           <u>quality</u>
           <u>speed</u>
           <u>consistency</u>
       <b>channels</b>
           Set channels.  Possible values are:

           <u>apart</u>
           <u>together</u>

       <u>Commands</u>

       This filter supports the following commands:

       <b>tempo</b>
           Change filter tempo scale factor.  Syntax for the command is : "<u>tempo</u>"

       <b>pitch</b>
           Change filter pitch scale factor.  Syntax for the command is : "<u>pitch</u>"

   <b>sidechaincompress</b>
       This  filter  acts  like  normal  compressor but has the ability to compress detected signal using second
       input signal.  It needs two input streams and returns one output stream.   First  input  stream  will  be
       processed depending on second stream signal.  The filtered signal then can be filtered with other filters
       in later stages of processing. See <b>pan</b> and <b>amerge</b> filter.

       The filter accepts the following options:

       <b>level_in</b>
           Set input gain. Default is 1. Range is between 0.015625 and 64.

       <b>mode</b>
           Set mode of compressor operation. Can be "upward" or "downward".  Default is "downward".

       <b>threshold</b>
           If  a  signal  of  second  stream  raises above this level it will affect the gain reduction of first
           stream.  By default is 0.125. Range is between 0.00097563 and 1.

       <b>ratio</b>
           Set a ratio about which the signal is reduced. 1:2 means that if  the  level  raised  4dB  above  the
           threshold, it will be only 2dB above after the reduction.  Default is 2. Range is between 1 and 20.

       <b>attack</b>
           Amount  of  milliseconds  the  signal  has  to rise above the threshold before gain reduction starts.
           Default is 20. Range is between 0.01 and 2000.

       <b>release</b>
           Amount of milliseconds the signal has to fall below  the  threshold  before  reduction  is  decreased
           again. Default is 250. Range is between 0.01 and 9000.

       <b>makeup</b>
           Set  the amount by how much signal will be amplified after processing.  Default is 1. Range is from 1
           to 64.

       <b>knee</b>
           Curve the sharp knee around the threshold to enter gain reduction more softly.  Default  is  2.82843.
           Range is between 1 and 8.

       <b>link</b>
           Choose  if  the  "average"  level  between all channels of side-chain stream or the louder("maximum")
           channel of side-chain stream affects the reduction. Default is "average".

       <b>detection</b>
           Should the exact signal be taken in case of "peak" or an RMS one in case of "rms". Default  is  "rms"
           which is mainly smoother.

       <b>level_sc</b>
           Set sidechain gain. Default is 1. Range is between 0.015625 and 64.

       <b>mix</b> How much to use compressed signal in output. Default is 1.  Range is between 0 and 1.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

       <u>Examples</u>

       •   Full  ffmpeg example taking 2 audio inputs, 1st input to be compressed depending on the signal of 2nd
           input and later compressed signal to be merged with 2nd input:

                   ffmpeg -i main.flac -i sidechain.flac -filter_complex "[1:a]asplit=2[sc][mix];[0:a][sc]sidechaincompress[compr];[compr][mix]amerge"

   <b>sidechaingate</b>
       A sidechain gate acts like a normal (wideband) gate but has the ability to  filter  the  detected  signal
       before  sending  it  to the gain reduction stage.  Normally a gate uses the full range signal to detect a
       level above the threshold.  For example: If you cut all lower frequencies from your sidechain signal  the
       gate  will decrease the volume of your track only if not enough highs appear. With this technique you are
       able to reduce the resonation of a natural drum or remove "rumbling" of  muted  strokes  from  a  heavily
       distorted  guitar.  It needs two input streams and returns one output stream.  First input stream will be
       processed depending on second stream signal.

       The filter accepts the following options:

       <b>level_in</b>
           Set input level before filtering.  Default is 1. Allowed range is from 0.015625 to 64.

       <b>mode</b>
           Set the mode of operation. Can be "upward" or "downward".  Default is "downward". If set to  "upward"
           mode,  higher  parts  of  signal  will  be  amplified,  expanding  dynamic range in upward direction.
           Otherwise, in case of "downward" lower parts of signal will be reduced.

       <b>range</b>
           Set the level of gain reduction when the signal is below the threshold.  Default is 0.06125.  Allowed
           range is from 0 to 1.  Setting this to 0 disables reduction and then filter behaves like expander.

       <b>threshold</b>
           If  a  signal rises above this level the gain reduction is released.  Default is 0.125. Allowed range
           is from 0 to 1.

       <b>ratio</b>
           Set a ratio about which the signal is reduced.  Default is 2. Allowed range is from 1 to 9000.

       <b>attack</b>
           Amount of milliseconds the signal has to rise  above  the  threshold  before  gain  reduction  stops.
           Default is 20 milliseconds. Allowed range is from 0.01 to 9000.

       <b>release</b>
           Amount  of  milliseconds the signal has to fall below the threshold before the reduction is increased
           again. Default is 250 milliseconds.  Allowed range is from 0.01 to 9000.

       <b>makeup</b>
           Set amount of amplification of signal after processing.  Default is 1. Allowed range is from 1 to 64.

       <b>knee</b>
           Curve the sharp knee  around  the  threshold  to  enter  gain  reduction  more  softly.   Default  is
           2.828427125. Allowed range is from 1 to 8.

       <b>detection</b>
           Choose if exact signal should be taken for detection or an RMS like one.  Default is rms. Can be peak
           or rms.

       <b>link</b>
           Choose  if  the  average  level  between  all  channels  or the louder channel affects the reduction.
           Default is average. Can be average or maximum.

       <b>level_sc</b>
           Set sidechain gain. Default is 1. Range is from 0.015625 to 64.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>silencedetect</b>
       Detect silence in an audio stream.

       This filter logs a message when it detects that the input audio volume  is  less  or  equal  to  a  noise
       tolerance value for a duration greater or equal to the minimum detected noise duration.

       The   printed   times   and   duration   are   expressed   in   seconds.   The  "lavfi.silence_start"  or
       "lavfi.silence_start.X" metadata key is set on the first frame whose  timestamp  equals  or  exceeds  the
       detection duration and it contains the timestamp of the first frame of the silence.

       The     "lavfi.silence_duration"     or    "lavfi.silence_duration.X"    and    "lavfi.silence_end"    or
       "lavfi.silence_end.X" metadata keys are set on the first frame after the silence. If <b>mono</b> is enabled, and
       each channel is evaluated separately, the ".X" suffixed keys are used, and "X" corresponds to the channel
       number.

       The filter accepts the following options:

       <b>noise,</b> <b>n</b>
           Set noise tolerance. Can be specified in dB (in case "dB" is appended  to  the  specified  value)  or
           amplitude ratio. Default is -60dB, or 0.001.

       <b>duration,</b> <b>d</b>
           Set  silence duration until notification (default is 2 seconds). See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b>
           <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for the accepted syntax.

       <b>mono,</b> <b>m</b>
           Process each channel separately, instead of combined. By default is disabled.

       <u>Examples</u>

       •   Detect 5 seconds of silence with -50dB noise tolerance:

                   silencedetect=n=-50dB:d=5

       •   Complete example with <b>ffmpeg</b> to detect silence with 0.0001 noise tolerance in <u>silence.mp3</u>:

                   ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -f null -

   <b>silenceremove</b>
       Remove silence from the beginning, middle or end of the audio.

       The filter accepts the following options:

       <b>start_periods</b>
           This value is used to indicate if audio should be trimmed at beginning of the audio. A value of  zero
           indicates no silence should be trimmed from the beginning. When specifying a non-zero value, it trims
           audio  up  until  it  finds  non-silence. Normally, when trimming silence from beginning of audio the
           <u>start_periods</u> will be 1 but it can be increased to higher values to trim all  audio  up  to  specific
           count of non-silence periods.  Default value is 0.

       <b>start_duration</b>
           Specify  the  amount  of  time  that  non-silence must be detected before it stops trimming audio. By
           increasing the duration, bursts of noises can be treated as silence and trimmed off. Default value is
           0.

       <b>start_threshold</b>
           This indicates what sample value should be treated as silence. For digital audio, a value of 0 may be
           fine but for audio recorded from analog, you may wish to increase the value to account for background
           noise.  Can be specified in dB (in case "dB" is appended to the specified value) or amplitude  ratio.
           Default value is 0.

       <b>start_silence</b>
           Specify max duration of silence at beginning that will be kept after trimming. Default is 0, which is
           equal to trimming all samples detected as silence.

       <b>start_mode</b>
           Specify mode of detection of silence end at start of multi-channel audio.  Can be <u>any</u> or <u>all</u>. Default
           is  <u>any</u>.   With  <u>any</u>, any sample from any channel that is detected as non-silence will trigger end of
           silence trimming at start of audio stream.  With <u>all</u>, only if every  sample  from  every  channel  is
           detected as non-silence will trigger end of silence trimming at start of audio stream, limited usage.

       <b>stop_periods</b>
           Set  the count for trimming silence from the end of audio. When specifying a positive value, it trims
           audio after it finds specified silence period.  To remove silence from the middle of a file,  specify
           a  <u>stop_periods</u>  that  is  negative.  This  value  is then treated as a positive value and is used to
           indicate the effect should restart processing as specified by <u>stop_periods</u>, making  it  suitable  for
           removing periods of silence in the middle of the audio.  Default value is 0.

       <b>stop_duration</b>
           Specify  a  duration  of silence that must exist before audio is not copied any more. By specifying a
           higher duration, silence that is wanted can be left in the audio.  Default value is 0.

       <b>stop_threshold</b>
           This is the same as <b>start_threshold</b> but for trimming silence from the end of audio.  Can be specified
           in dB (in case "dB" is appended to the specified value) or amplitude ratio. Default value is 0.

       <b>stop_silence</b>
           Specify max duration of silence at end that will be kept after trimming. Default is 0, which is equal
           to trimming all samples detected as silence.

       <b>stop_mode</b>
           Specify mode of detection of silence start after start of multi-channel audio.  Can be  <u>any</u>  or  <u>all</u>.
           Default is <u>all</u>.  With <u>any</u>, any sample from any channel that is detected as silence will trigger start
           of  silence trimming after start of audio stream, limited usage.  With <u>all</u>, only if every sample from
           every channel is detected as silence will trigger start of silence  trimming  after  start  of  audio
           stream.

       <b>detection</b>
           Set how is silence detected.

           <b>avg</b> Mean of absolute values of samples in moving window.

           <b>rms</b> Root squared mean of absolute values of samples in moving window.

           <b>peak</b>
               Maximum of absolute values of samples in moving window.

           <b>median</b>
               Median of absolute values of samples in moving window.

           <b>ptp</b> Absolute of max peak to min peak difference of samples in moving window.

           <b>dev</b> Standard deviation of values of samples in moving window.

           Default value is "rms".

       <b>window</b>
           Set duration in number of seconds used to calculate size of window in number of samples for detecting
           silence.  Using  0  will effectively disable any windowing and use only single sample per channel for
           silence detection.  In that case it may be needed to also set <b>start_silence</b>  and/or  <b>stop_silence</b>  to
           nonzero  values  with  also  <b>start_duration</b> and/or <b>stop_duration</b> to nonzero values.  Default value is
           0.02. Allowed range is from 0 to 10.

       <b>timestamp</b>
           Set processing mode of every audio frame output timestamp.

           <b>write</b>
               Full timestamps rewrite, keep only the start time for the first output frame.

           <b>copy</b>
               Non-dropped frames are left with same timestamp as input audio frame.

           Defaults value is "write".

       <u>Examples</u>

       •   The following example shows how this filter can be used to start a recording that  does  not  contain
           the  delay  at the start which usually occurs between pressing the record button and the start of the
           performance:

                   silenceremove=start_periods=1:start_duration=5:start_threshold=0.02

       •   Trim all silence encountered from beginning to end where there is more than 1 second  of  silence  in
           audio:

                   silenceremove=stop_periods=-1:stop_duration=1:stop_threshold=-90dB

       •   Trim  all  digital  silence  samples, using peak detection, from beginning to end where there is more
           than 0 samples of digital silence in audio and digital silence is detected in all  channels  at  same
           positions in stream:

                   silenceremove=window=0:detection=peak:stop_mode=all:start_mode=all:stop_periods=-1:stop_threshold=0

       •   Trim  every 2nd encountered silence period from beginning to end where there is more than 1 second of
           silence per silence period in audio:

                   silenceremove=stop_periods=-2:stop_duration=1:stop_threshold=-90dB

       •   Similar as above, but keep maximum of 0.5 seconds of silence from each trimmed period:

                   silenceremove=stop_periods=-2:stop_duration=1:stop_threshold=-90dB:stop_silence=0.5

       •   Similar as above, but keep maximum of 1.5 seconds of silence from start of audio:

                   silenceremove=stop_periods=-2:stop_duration=1:stop_threshold=-90dB:stop_silence=0.5:start_periods=1:start_duration=1:start_silence=1.5:stop_threshold=-90dB

       <u>Commands</u>

       This filter supports some above options as <b>commands</b>.

   <b>sofalizer</b>
       SOFAlizer uses head-related transfer functions (HRTFs) to create virtual loudspeakers around the user for
       binaural listening via headphones (audio formats up to 9 channels supported).  The HRTFs  are  stored  in
       SOFA  files (see &lt;<b><a href="http://www.sofacoustics.org/">http://www.sofacoustics.org/</a></b>&gt; for a database).  SOFAlizer is developed at the Acoustics
       Research Institute (ARI) of the Austrian Academy of Sciences.

       To enable compilation of this filter you need to configure FFmpeg with "--enable-libmysofa".

       The filter accepts the following options:

       <b>sofa</b>
           Set the SOFA file used for rendering.

       <b>gain</b>
           Set gain applied to audio. Value is in dB. Default is 0.

       <b>rotation</b>
           Set rotation of virtual loudspeakers in deg. Default is 0.

       <b>elevation</b>
           Set elevation of virtual speakers in deg. Default is 0.

       <b>radius</b>
           Set distance in meters between loudspeakers and the listener with near-field HRTFs. Default is 1.

       <b>type</b>
           Set processing type. Can be <u>time</u> or <u>freq</u>. <u>time</u> is processing audio in  time  domain  which  is  slow.
           <u>freq</u> is processing audio in frequency domain which is fast.  Default is <u>freq</u>.

       <b>speakers</b>
           Set  custom  positions  of  virtual loudspeakers. Syntax for this option is: &lt;CH&gt; &lt;AZIM&gt; &lt;ELEV&gt;[|&lt;CH&gt;
           &lt;AZIM&gt; &lt;ELEV&gt;|...].  Each virtual loudspeaker is described with short  channel  name  following  with
           azimuth  and  elevation  in  degrees.  Each virtual loudspeaker description is separated by '|'.  For
           example to override front left and front right channel positions use: 'speakers=FL 45 15|FR 345  15'.
           Descriptions with unrecognised channel names are ignored.

       <b>lfegain</b>
           Set custom gain for LFE channels. Value is in dB. Default is 0.

       <b>framesize</b>
           Set  custom  frame  size in number of samples. Default is 1024.  Allowed range is from 1024 to 96000.
           Only used if option <b>type</b> is set to <u>freq</u>.

       <b>normalize</b>
           Should all IRs be normalized upon importing SOFA file.  By default is enabled.

       <b>interpolate</b>
           Should nearest IRs be interpolated with neighbor IRs if exact position does not match. By default  is
           disabled.

       <b>minphase</b>
           Minphase all IRs upon loading of SOFA file. By default is disabled.

       <b>anglestep</b>
           Set neighbor search angle step. Only used if option <u>interpolate</u> is enabled.

       <b>radstep</b>
           Set neighbor search radius step. Only used if option <u>interpolate</u> is enabled.

       <u>Examples</u>

       •   Using ClubFritz6 sofa file:

                   sofalizer=sofa=/path/to/ClubFritz6.sofa:type=freq:radius=1

       •   Using ClubFritz12 sofa file and bigger radius with small rotation:

                   sofalizer=sofa=/path/to/ClubFritz12.sofa:type=freq:radius=2:rotation=5

       •   Similar  as  above  but with custom speaker positions for front left, front right, back left and back
           right and also with custom gain:

                   "sofalizer=sofa=/path/to/ClubFritz6.sofa:type=freq:radius=2:speakers=FL 45|FR 315|BL 135|BR 225:gain=28"

   <b>speechnorm</b>
       Speech Normalizer.

       This filter expands or compresses each half-cycle of audio samples (local set of samples all above or all
       below zero and between two nearest zero crossings) depending on threshold value, so audio reaches  target
       peak value under conditions controlled by below options.

       The filter accepts the following options:

       <b>peak,</b> <b>p</b>
           Set  the expansion target peak value. This specifies the highest allowed absolute amplitude level for
           the normalized audio input. Default value is 0.95. Allowed range is from 0.0 to 1.0.

       <b>expansion,</b> <b>e</b>
           Set the maximum expansion factor. Allowed range is from 1.0 to 50.0.  Default  value  is  2.0.   This
           option  controls  maximum  local half-cycle of samples expansion. The maximum expansion would be such
           that local peak value reaches target peak value but never to surpass it and that  ratio  between  new
           and previous peak value does not surpass this option value.

       <b>compression,</b> <b>c</b>
           Set  the  maximum  compression factor. Allowed range is from 1.0 to 50.0. Default value is 2.0.  This
           option controls maximum local half-cycle  of  samples  compression.  This  option  is  used  only  if
           <b>threshold</b>  option  is  set  to value greater than 0.0, then in such cases when local peak is lower or
           same as value set by <b>threshold</b> all samples belonging to that peak's half-cycle will be compressed  by
           current compression factor.

       <b>threshold,</b> <b>t</b>
           Set  the  threshold  value.  Default  value  is  0.0.  Allowed range is from 0.0 to 1.0.  This option
           specifies which half-cycles of samples will be compressed and which will be expanded.  Any half-cycle
           samples with their local peak value below or same as this option value will be compressed by  current
           compression  factor,  otherwise, if greater than threshold value they will be expanded with expansion
           factor so that it could reach peak target value but never surpass it.

       <b>raise,</b> <b>r</b>
           Set the expansion raising amount per each half-cycle of samples. Default  value  is  0.001.   Allowed
           range  is  from 0.0 to 1.0. This controls how fast expansion factor is raised per each new half-cycle
           until it reaches <b>expansion</b> value.  Setting this options too high may lead to distortions.

       <b>fall,</b> <b>f</b>
           Set the compression raising amount per each half-cycle of samples. Default value is  0.001.   Allowed
           range is from 0.0 to 1.0. This controls how fast compression factor is raised per each new half-cycle
           until it reaches <b>compression</b> value.

       <b>channels,</b> <b>h</b>
           Specify which channels to filter, by default all available channels are filtered.

       <b>invert,</b> <b>i</b>
           Enable  inverted  filtering, by default is disabled. This inverts interpretation of <b>threshold</b> option.
           When enabled any half-cycle of samples with their local peak value below or same as <b>threshold</b>  option
           will be expanded otherwise it will be compressed.

       <b>link,</b> <b>l</b>
           Link  channels when calculating gain applied to each filtered channel sample, by default is disabled.
           When disabled each filtered channel gain calculation is independent, otherwise when  this  option  is
           enabled the minimum of all possible gains for each filtered channel is used.

       <b>rms,</b> <b>m</b>
           Set  the  expansion target RMS value. This specifies the highest allowed RMS level for the normalized
           audio input. Default value is 0.0, thus disabled. Allowed range is from 0.0 to 1.0.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

       <u>Examples</u>

       •   Weak and slow amplification:

                   speechnorm=e=3:r=0.00001:l=1

       •   Moderate and slow amplification:

                   speechnorm=e=6.25:r=0.00001:l=1

       •   Strong and fast amplification:

                   speechnorm=e=12.5:r=0.0001:l=1

       •   Very strong and fast amplification:

                   speechnorm=e=25:r=0.0001:l=1

       •   Extreme and fast amplification:

                   speechnorm=e=50:r=0.0001:l=1

   <b>stereotools</b>
       This filter has some handy utilities to manage stereo signals, for converting M/S  stereo  recordings  to
       L/R signal while having control over the parameters or spreading the stereo image of master track.

       The filter accepts the following options:

       <b>level_in</b>
           Set input level before filtering for both channels. Defaults is 1.  Allowed range is from 0.015625 to
           64.

       <b>level_out</b>
           Set output level after filtering for both channels. Defaults is 1.  Allowed range is from 0.015625 to
           64.

       <b>balance_in</b>
           Set input balance between both channels. Default is 0.  Allowed range is from -1 to 1.

       <b>balance_out</b>
           Set output balance between both channels. Default is 0.  Allowed range is from -1 to 1.

       <b>softclip</b>
           Enable  softclipping. Results in analog distortion instead of harsh digital 0dB clipping. Disabled by
           default.

       <b>mutel</b>
           Mute the left channel. Disabled by default.

       <b>muter</b>
           Mute the right channel. Disabled by default.

       <b>phasel</b>
           Change the phase of the left channel. Disabled by default.

       <b>phaser</b>
           Change the phase of the right channel. Disabled by default.

       <b>mode</b>
           Set stereo mode. Available values are:

           <b>lr&gt;lr</b>
               Left/Right to Left/Right, this is default.

           <b>lr&gt;ms</b>
               Left/Right to Mid/Side.

           <b>ms&gt;lr</b>
               Mid/Side to Left/Right.

           <b>lr&gt;ll</b>
               Left/Right to Left/Left.

           <b>lr&gt;rr</b>
               Left/Right to Right/Right.

           <b>lr&gt;l+r</b>
               Left/Right to Left + Right.

           <b>lr&gt;rl</b>
               Left/Right to Right/Left.

           <b>ms&gt;ll</b>
               Mid/Side to Left/Left.

           <b>ms&gt;rr</b>
               Mid/Side to Right/Right.

           <b>ms&gt;rl</b>
               Mid/Side to Right/Left.

           <b>lr&gt;l-r</b>
               Left/Right to Left - Right.

       <b>slev</b>
           Set level of side signal. Default is 1.  Allowed range is from 0.015625 to 64.

       <b>sbal</b>
           Set balance of side signal. Default is 0.  Allowed range is from -1 to 1.

       <b>mlev</b>
           Set level of the middle signal. Default is 1.  Allowed range is from 0.015625 to 64.

       <b>mpan</b>
           Set middle signal pan. Default is 0. Allowed range is from -1 to 1.

       <b>base</b>
           Set stereo base between mono and inversed channels. Default is 0.  Allowed range is from -1 to 1.

       <b>delay</b>
           Set delay in milliseconds how much to delay left from right channel and vice  versa.  Default  is  0.
           Allowed range is from -20 to 20.

       <b>sclevel</b>
           Set S/C level. Default is 1. Allowed range is from 1 to 100.

       <b>phase</b>
           Set the stereo phase in degrees. Default is 0. Allowed range is from 0 to 360.

       <b>bmode_in,</b> <b>bmode_out</b>
           Set balance mode for balance_in/balance_out option.

           Can be one of the following:

           <b>balance</b>
               Classic balance mode. Attenuate one channel at time.  Gain is raised up to 1.

           <b>amplitude</b>
               Similar as classic mode above but gain is raised up to 2.

           <b>power</b>
               Equal power distribution, from -6dB to +6dB range.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

       <u>Examples</u>

       •   Apply karaoke like effect:

                   stereotools=mlev=0.015625

       •   Convert M/S signal to L/R:

                   "stereotools=mode=ms&gt;lr"

   <b>stereowiden</b>
       This  filter  enhance the stereo effect by suppressing signal common to both channels and by delaying the
       signal of left into right and vice versa, thereby widening the stereo effect.

       The filter accepts the following options:

       <b>delay</b>
           Time in milliseconds of the delay  of  left  signal  into  right  and  vice  versa.   Default  is  20
           milliseconds.

       <b>feedback</b>
           Amount  of  gain  in delayed signal into right and vice versa. Gives a delay effect of left signal in
           right output and vice versa which gives widening effect. Default is 0.3.

       <b>crossfeed</b>
           Cross feed of left into right with inverted phase. This helps in suppressing the mono. If  the  value
           is 1 it will cancel all the signal common to both channels. Default is 0.3.

       <b>drymix</b>
           Set level of input signal of original channel. Default is 0.8.

       <u>Commands</u>

       This filter supports the all above options except "delay" as <b>commands</b>.

   <b>superequalizer</b>
       Apply 18 band equalizer.

       The filter accepts the following options:

       <b>1b</b>  Set 65Hz band gain.

       <b>2b</b>  Set 92Hz band gain.

       <b>3b</b>  Set 131Hz band gain.

       <b>4b</b>  Set 185Hz band gain.

       <b>5b</b>  Set 262Hz band gain.

       <b>6b</b>  Set 370Hz band gain.

       <b>7b</b>  Set 523Hz band gain.

       <b>8b</b>  Set 740Hz band gain.

       <b>9b</b>  Set 1047Hz band gain.

       <b>10b</b> Set 1480Hz band gain.

       <b>11b</b> Set 2093Hz band gain.

       <b>12b</b> Set 2960Hz band gain.

       <b>13b</b> Set 4186Hz band gain.

       <b>14b</b> Set 5920Hz band gain.

       <b>15b</b> Set 8372Hz band gain.

       <b>16b</b> Set 11840Hz band gain.

       <b>17b</b> Set 16744Hz band gain.

       <b>18b</b> Set 20000Hz band gain.

   <b>surround</b>
       Apply audio surround upmix filter.

       This filter allows to produce multichannel output from audio stream.

       The filter accepts the following options:

       <b>chl_out</b>
           Set output channel layout. By default, this is <u>5.1</u>.

           See <b>the</b> <b>Channel</b> <b>Layout</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for the required syntax.

       <b>chl_in</b>
           Set input channel layout. By default, this is <u>stereo</u>.

           See <b>the</b> <b>Channel</b> <b>Layout</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for the required syntax.

       <b>level_in</b>
           Set input volume level. By default, this is <u>1</u>.

       <b>level_out</b>
           Set output volume level. By default, this is <u>1</u>.

       <b>lfe</b> Enable LFE channel output if output channel layout has it. By default, this is enabled.

       <b>lfe_low</b>
           Set LFE low cut off frequency. By default, this is <u>128</u> Hz.

       <b>lfe_high</b>
           Set LFE high cut off frequency. By default, this is <u>256</u> Hz.

       <b>lfe_mode</b>
           Set  LFE  mode,  can  be  <u>add</u> or <u>sub</u>. Default is <u>add</u>.  In <u>add</u> mode, LFE channel is created from input
           audio and added to output.  In <u>sub</u> mode, LFE channel is created from input audio and added to  output
           but also all non-LFE output channels are subtracted with output LFE channel.

       <b>smooth</b>
           Set  temporal smoothness strength, used to gradually change factors when transforming stereo sound in
           time. Allowed range is from <u>0.0</u> to <u>1.0</u>.  Useful to improve output quality with  <u>focus</u>  option  values
           greater than <u>0.0</u>.  Default is <u>0.0</u>. Only values inside this range and without edges are effective.

       <b>angle</b>
           Set angle of stereo surround transform, Allowed range is from <u>0</u> to <u>360</u>.  Default is <u>90</u>.

       <b>focus</b>
           Set focus of stereo surround transform, Allowed range is from <u>-1</u> to <u>1</u>.  Default is <u>0</u>.

       <b>fc_in</b>
           Set front center input volume. By default, this is <u>1</u>.

       <b>fc_out</b>
           Set front center output volume. By default, this is <u>1</u>.

       <b>fl_in</b>
           Set front left input volume. By default, this is <u>1</u>.

       <b>fl_out</b>
           Set front left output volume. By default, this is <u>1</u>.

       <b>fr_in</b>
           Set front right input volume. By default, this is <u>1</u>.

       <b>fr_out</b>
           Set front right output volume. By default, this is <u>1</u>.

       <b>sl_in</b>
           Set side left input volume. By default, this is <u>1</u>.

       <b>sl_out</b>
           Set side left output volume. By default, this is <u>1</u>.

       <b>sr_in</b>
           Set side right input volume. By default, this is <u>1</u>.

       <b>sr_out</b>
           Set side right output volume. By default, this is <u>1</u>.

       <b>bl_in</b>
           Set back left input volume. By default, this is <u>1</u>.

       <b>bl_out</b>
           Set back left output volume. By default, this is <u>1</u>.

       <b>br_in</b>
           Set back right input volume. By default, this is <u>1</u>.

       <b>br_out</b>
           Set back right output volume. By default, this is <u>1</u>.

       <b>bc_in</b>
           Set back center input volume. By default, this is <u>1</u>.

       <b>bc_out</b>
           Set back center output volume. By default, this is <u>1</u>.

       <b>lfe_in</b>
           Set LFE input volume. By default, this is <u>1</u>.

       <b>lfe_out</b>
           Set LFE output volume. By default, this is <u>1</u>.

       <b>allx</b>
           Set spread usage of stereo image across X axis for all channels.  Allowed range is from <u>-1</u> to <u>15</u>.  By
           default this value is negative <u>-1</u>, and thus unused.

       <b>ally</b>
           Set spread usage of stereo image across Y axis for all channels.  Allowed range is from <u>-1</u> to <u>15</u>.  By
           default this value is negative <u>-1</u>, and thus unused.

       <b>fcx,</b> <b>flx,</b> <b>frx,</b> <b>blx,</b> <b>brx,</b> <b>slx,</b> <b>srx,</b> <b>bcx</b>
           Set  spread  usage of stereo image across X axis for each channel.  Allowed range is from <u>0.06</u> to <u>15</u>.
           By default this value is <u>0.5</u>.

       <b>fcy,</b> <b>fly,</b> <b>fry,</b> <b>bly,</b> <b>bry,</b> <b>sly,</b> <b>sry,</b> <b>bcy</b>
           Set spread usage of stereo image across Y axis for each channel.  Allowed range is from <u>0.06</u>  to  <u>15</u>.
           By default this value is <u>0.5</u>.

       <b>win_size</b>
           Set window size. Allowed range is from <u>1024</u> to <u>65536</u>. Default size is <u>4096</u>.

       <b>win_func</b>
           Set window function.

           It accepts the following values:

           <b>rect</b>
           <b>bartlett</b>
           <b>hann,</b> <b>hanning</b>
           <b>hamming</b>
           <b>blackman</b>
           <b>welch</b>
           <b>flattop</b>
           <b>bharris</b>
           <b>bnuttall</b>
           <b>bhann</b>
           <b>sine</b>
           <b>nuttall</b>
           <b>lanczos</b>
           <b>gauss</b>
           <b>tukey</b>
           <b>dolph</b>
           <b>cauchy</b>
           <b>parzen</b>
           <b>poisson</b>
           <b>bohman</b>
           <b>kaiser</b>

           Default is "hann".

       <b>overlap</b>
           Set window overlap. If set to 1, the recommended overlap for selected window function will be picked.
           Default is 0.5.

   <b>tiltshelf</b>
       Boost  or  cut  the  lower  frequencies and cut or boost higher frequencies of the audio using a two-pole
       shelving filter with a response similar to that of a standard hi-fi's tone-controls.  This is also  known
       as shelving equalisation (EQ).

       The filter accepts the following options:

       <b>gain,</b> <b>g</b>
           Give  the  gain  at 0 Hz. Its useful range is about -20 (for a large cut) to +20 (for a large boost).
           Beware of clipping when using a positive gain.

       <b>frequency,</b> <b>f</b>
           Set the filter's central frequency and so can be used to extend or reduce the frequency range  to  be
           boosted or cut.  The default value is 3000 Hz.

       <b>width_type,</b> <b>t</b>
           Set method to specify band-width of filter.

           <b>h</b>   Hz

           <b>q</b>   Q-Factor

           <b>o</b>   octave

           <b>s</b>   slope

           <b>k</b>   kHz

       <b>width,</b> <b>w</b>
           Determine how steep is the filter's shelf transition.

       <b>poles,</b> <b>p</b>
           Set number of poles. Default is 2.

       <b>mix,</b> <b>m</b>
           How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>channels,</b> <b>c</b>
           Specify which channels to filter, by default all available are filtered.

       <b>normalize,</b> <b>n</b>
           Normalize biquad coefficients, by default is disabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>transform,</b> <b>a</b>
           Set transform type of IIR filter.

           <b>di</b>
           <b>dii</b>
           <b>tdi</b>
           <b>tdii</b>
           <b>latt</b>
           <b>svf</b>
           <b>zdf</b>
       <b>precision,</b> <b>r</b>
           Set precision of filtering.

           <b>auto</b>
               Pick automatic sample format depending on surround filters.

           <b>s16</b> Always use signed 16-bit.

           <b>s32</b> Always use signed 32-bit.

           <b>f32</b> Always use float 32-bit.

           <b>f64</b> Always use float 64-bit.

       <b>block_size,</b> <b>b</b>
           Set  block  size  used  for reverse IIR processing. If this value is set to high enough value (higher
           than impulse response length truncated when reaches near zero values) filtering  will  become  linear
           phase otherwise if not big enough it will just produce nasty artifacts.

           Note that filter delay will be exactly this many samples when set to non-zero value.

       <u>Commands</u>

       This filter supports some options as <b>commands</b>.

   <b>treble,</b> <b>highshelf</b>
       Boost  or  cut  treble  (upper) frequencies of the audio using a two-pole shelving filter with a response
       similar to that of a standard hi-fi's tone-controls. This is also known as shelving equalisation (EQ).

       The filter accepts the following options:

       <b>gain,</b> <b>g</b>
           Give the gain at whichever is the lower of ~22 kHz and the Nyquist frequency.  Its  useful  range  is
           about  -20  (for  a  large  cut) to +20 (for a large boost). Beware of clipping when using a positive
           gain.

       <b>frequency,</b> <b>f</b>
           Set the filter's central frequency and so can be used to extend or reduce the frequency range  to  be
           boosted or cut.  The default value is 3000 Hz.

       <b>width_type,</b> <b>t</b>
           Set method to specify band-width of filter.

           <b>h</b>   Hz

           <b>q</b>   Q-Factor

           <b>o</b>   octave

           <b>s</b>   slope

           <b>k</b>   kHz

       <b>width,</b> <b>w</b>
           Determine how steep is the filter's shelf transition.

       <b>poles,</b> <b>p</b>
           Set number of poles. Default is 2.

       <b>mix,</b> <b>m</b>
           How much to use filtered signal in output. Default is 1.  Range is between 0 and 1.

       <b>channels,</b> <b>c</b>
           Specify which channels to filter, by default all available are filtered.

       <b>normalize,</b> <b>n</b>
           Normalize biquad coefficients, by default is disabled.  Enabling it will normalize magnitude response
           at DC to 0dB.

       <b>transform,</b> <b>a</b>
           Set transform type of IIR filter.

           <b>di</b>
           <b>dii</b>
           <b>tdi</b>
           <b>tdii</b>
           <b>latt</b>
           <b>svf</b>
           <b>zdf</b>
       <b>precision,</b> <b>r</b>
           Set precision of filtering.

           <b>auto</b>
               Pick automatic sample format depending on surround filters.

           <b>s16</b> Always use signed 16-bit.

           <b>s32</b> Always use signed 32-bit.

           <b>f32</b> Always use float 32-bit.

           <b>f64</b> Always use float 64-bit.

       <b>block_size,</b> <b>b</b>
           Set  block  size  used  for reverse IIR processing. If this value is set to high enough value (higher
           than impulse response length truncated when reaches near zero values) filtering  will  become  linear
           phase otherwise if not big enough it will just produce nasty artifacts.

           Note that filter delay will be exactly this many samples when set to non-zero value.

       <u>Commands</u>

       This filter supports the following commands:

       <b>frequency,</b> <b>f</b>
           Change treble frequency.  Syntax for the command is : "<u>frequency</u>"

       <b>width_type,</b> <b>t</b>
           Change treble width_type.  Syntax for the command is : "<u>width_type</u>"

       <b>width,</b> <b>w</b>
           Change treble width.  Syntax for the command is : "<u>width</u>"

       <b>gain,</b> <b>g</b>
           Change treble gain.  Syntax for the command is : "<u>gain</u>"

       <b>mix,</b> <b>m</b>
           Change treble mix.  Syntax for the command is : "<u>mix</u>"

   <b>tremolo</b>
       Sinusoidal amplitude modulation.

       The filter accepts the following options:

       <b>f</b>   Modulation  frequency in Hertz. Modulation frequencies in the subharmonic range (20 Hz or lower) will
           result in a tremolo effect.  This filter may also be  used  as  a  ring  modulator  by  specifying  a
           modulation frequency higher than 20 Hz.  Range is 0.1 - 20000.0. Default value is 5.0 Hz.

       <b>d</b>   Depth of modulation as a percentage. Range is 0.0 - 1.0.  Default value is 0.5.

   <b>vibrato</b>
       Sinusoidal phase modulation.

       The filter accepts the following options:

       <b>f</b>   Modulation frequency in Hertz.  Range is 0.1 - 20000.0. Default value is 5.0 Hz.

       <b>d</b>   Depth of modulation as a percentage. Range is 0.0 - 1.0.  Default value is 0.5.

   <b>virtualbass</b>
       Apply audio Virtual Bass filter.

       This  filter  accepts stereo input and produce stereo with LFE (2.1) channels output.  The newly produced
       LFE channel have enhanced virtual bass originally  obtained  from  both  stereo  channels.   This  filter
       outputs front left and front right channels unchanged as available in stereo input.

       The filter accepts the following options:

       <b>cutoff</b>
           Set the virtual bass cutoff frequency. Default value is 250 Hz.  Allowed range is from 100 to 500 Hz.

       <b>strength</b>
           Set the virtual bass strength. Allowed range is from 0.5 to 3.  Default value is 3.

   <b>volume</b>
       Adjust the input audio volume.

       It accepts the following parameters:

       <b>volume</b>
           Set audio volume expression.

           Output values are clipped to the maximum value.

           The output audio volume is given by the relation:

                   &lt;output_volume&gt; = &lt;volume&gt; * &lt;input_volume&gt;

           The default value for <u>volume</u> is "1.0".

       <b>precision</b>
           This parameter represents the mathematical precision.

           It  determines  which input sample formats will be allowed, which affects the precision of the volume
           scaling.

           <b>fixed</b>
               8-bit fixed-point; this limits input sample format to U8, S16, and S32.

           <b>float</b>
               32-bit floating-point; this limits input sample format to FLT. (default)

           <b>double</b>
               64-bit floating-point; this limits input sample format to DBL.

       <b>replaygain</b>
           Choose the behaviour on encountering ReplayGain side data in input frames.

           <b>drop</b>
               Remove ReplayGain side data, ignoring its contents (the default).

           <b>ignore</b>
               Ignore ReplayGain side data, but leave it in the frame.

           <b>track</b>
               Prefer the track gain, if present.

           <b>album</b>
               Prefer the album gain, if present.

       <b>replaygain_preamp</b>
           Pre-amplification gain in dB to apply to the selected replaygain gain.

           Default value for <u>replaygain_preamp</u> is 0.0.

       <b>replaygain_noclip</b>
           Prevent clipping by limiting the gain applied.

           Default value for <u>replaygain_noclip</u> is 1.

       <b>eval</b>
           Set when the volume expression is evaluated.

           It accepts the following values:

           <b>once</b>
               only evaluate expression once during the filter initialization, or when  the  <b>volume</b>  command  is
               sent

           <b>frame</b>
               evaluate expression for each incoming frame

           Default value is <b>once</b>.

       The volume expression can contain the following parameters.

       <b>n</b>   frame number (starting at zero)

       <b>nb_channels</b>
           number of channels

       <b>nb_consumed_samples</b>
           number of samples consumed by the filter

       <b>nb_samples</b>
           number of samples in the current frame

       <b>pos</b> original frame position in the file; deprecated, do not use

       <b>pts</b> frame PTS

       <b>sample_rate</b>
           sample rate

       <b>startpts</b>
           PTS at start of stream

       <b>startt</b>
           time at start of stream

       <b>t</b>   frame time

       <b>tb</b>  timestamp timebase

       <b>volume</b>
           last set volume value

       Note  that  when  <b>eval</b>  is  set  to  <b>once</b>  only the <u>sample_rate</u> and <u>tb</u> variables are available, all other
       variables will evaluate to NAN.

       <u>Commands</u>

       This filter supports the following commands:

       <b>volume</b>
           Modify the volume expression.  The command accepts the same syntax of the corresponding option.

           If the specified expression is not valid, it is kept at its current value.

       <u>Examples</u>

       •   Halve the input audio volume:

                   volume=volume=0.5
                   volume=volume=1/2
                   volume=volume=-6.0206dB

           In all the above example the named key for <b>volume</b> can be omitted, for example like in:

                   volume=0.5

       •   Increase input audio power by 6 decibels using fixed-point precision:

                   volume=volume=6dB:precision=fixed

       •   Fade volume after time 10 with an annihilation period of 5 seconds:

                   volume='if(lt(t,10),1,max(1-(t-10)/5,0))':eval=frame

   <b>volumedetect</b>
       Detect the volume of the input video.

       The filter has no parameters. It supports only 16-bit signed  integer  samples,  so  the  input  will  be
       converted  when  needed. Statistics about the volume will be printed in the log when the input stream end
       is reached.

       In particular it will show the mean volume (root mean square), maximum volume (on  a  per-sample  basis),
       and  the  beginning of a histogram of the registered volume values (from the maximum value to a cumulated
       1/1000 of the samples).

       All volumes are in decibels relative to the maximum PCM value.

       <u>Examples</u>

       Here is an excerpt of the output:

               [Parsed_volumedetect_0  0xa23120] mean_volume: -27 dB
               [Parsed_volumedetect_0  0xa23120] max_volume: -4 dB
               [Parsed_volumedetect_0  0xa23120] histogram_4db: 6
               [Parsed_volumedetect_0  0xa23120] histogram_5db: 62
               [Parsed_volumedetect_0  0xa23120] histogram_6db: 286
               [Parsed_volumedetect_0  0xa23120] histogram_7db: 1042
               [Parsed_volumedetect_0  0xa23120] histogram_8db: 2551
               [Parsed_volumedetect_0  0xa23120] histogram_9db: 4609
               [Parsed_volumedetect_0  0xa23120] histogram_10db: 8409

       It means that:

       •   The mean square energy is approximately -27 dB, or 10^-2.7.

       •   The largest sample is at -4 dB, or more precisely between -4 dB and -5 dB.

       •   There are 6 samples at -4 dB, 62 at -5 dB, 286 at -6 dB, etc.

       In other words, raising the volume by +4 dB does not cause any clipping,  raising  it  by  +5  dB  causes
       clipping for 6 samples, etc.

</pre><h4><b>AUDIO</b> <b>SOURCES</b></h4><pre>
       Below is a description of the currently available audio sources.

   <b>abuffer</b>
       Buffer audio frames, and make them available to the filter chain.

       This  source  is  mainly  intended for a programmatic use, in particular through the interface defined in
       <u>libavfilter/buffersrc.h</u>.

       It accepts the following parameters:

       <b>time_base</b>
           The timebase which will be used for timestamps of submitted frames. It must  be  either  a  floating-
           point number or in <u>numerator</u>/<u>denominator</u> form.

       <b>sample_rate</b>
           The sample rate of the incoming audio buffers.

       <b>sample_fmt</b>
           The  sample  format  of the incoming audio buffers.  Either a sample format name or its corresponding
           integer representation from the enum AVSampleFormat in <u>libavutil/samplefmt.h</u>

       <b>channel_layout</b>
           The  channel  layout  of  the  incoming  audio  buffers.   Either  a   channel   layout   name   from
           channel_layout_map in <u>libavutil/channel_layout.c</u> or its corresponding integer representation from the
           AV_CH_LAYOUT_* macros in <u>libavutil/channel_layout.h</u>

       <b>channels</b>
           The  number  of  channels  of  the  incoming  audio buffers.  If both <u>channels</u> and <u>channel_layout</u> are
           specified, then they must be consistent.

       <u>Examples</u>

               abuffer=sample_rate=44100:sample_fmt=s16p:channel_layout=stereo

       will instruct the source to accept planar 16bit signed stereo at 44100Hz.  Since the sample  format  with
       name  "s16p"  corresponds  to  the number 6 and the "stereo" channel layout corresponds to the value 0x3,
       this is equivalent to:

               abuffer=sample_rate=44100:sample_fmt=6:channel_layout=0x3

   <b>aevalsrc</b>
       Generate an audio signal specified by an expression.

       This source accepts in input one or more expressions (one for each channel), which are evaluated and used
       to generate a corresponding audio signal.

       This source accepts the following options:

       <b>exprs</b>
           Set the '|'-separated expressions list for each separate channel. In case the  <b>channel_layout</b>  option
           is  not  specified,  the  selected  channel  layout  depends  on  the number of provided expressions.
           Otherwise the last specified expression is applied to the remaining output channels.

       <b>channel_layout,</b> <b>c</b>
           Set the channel layout. The number of channels in the specified layout must be equal to the number of
           specified expressions.

       <b>duration,</b> <b>d</b>
           Set the minimum duration of the sourced audio. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b>  <b>the</b>  <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>  for  the accepted syntax.  Note that the resulting duration may be greater than the specified
           duration, as the generated audio is always cut at the end of a complete frame.

           If not specified, or the expressed duration is negative,  the  audio  is  supposed  to  be  generated
           forever.

       <b>nb_samples,</b> <b>n</b>
           Set the number of samples per channel per each output frame, default to 1024.

       <b>sample_rate,</b> <b>s</b>
           Specify the sample rate, default to 44100.

       Each expression in <u>exprs</u> can contain the following constants:

       <b>n</b>   number of the evaluated sample, starting from 0

       <b>t</b>   time of the evaluated sample expressed in seconds, starting from 0

       <b>s</b>   sample rate

       <u>Examples</u>

       •   Generate silence:

                   aevalsrc=0

       •   Generate a sin signal with frequency of 440 Hz, set sample rate to 8000 Hz:

                   aevalsrc="sin(440*2*PI*t):s=8000"

       •   Generate a two channels signal, specify the channel layout (Front Center + Back Center) explicitly:

                   aevalsrc="sin(420*2*PI*t)|cos(430*2*PI*t):c=FC|BC"

       •   Generate white noise:

                   aevalsrc="-2+<a href="../man0/random.0.html">random</a>(0)"

       •   Generate an amplitude modulated signal:

                   aevalsrc="sin(10*2*PI*t)*sin(880*2*PI*t)"

       •   Generate 2.5 Hz binaural beats on a 360 Hz carrier:

                   aevalsrc="0.1*sin(2*PI*(360-2.5/2)*t) | 0.1*sin(2*PI*(360+2.5/2)*t)"

   <b>afdelaysrc</b>
       Generate a fractional delay FIR coefficients.

       The resulting stream can be used with <b>afir</b> filter for filtering the audio signal.

       The filter accepts the following options:

       <b>delay,</b> <b>d</b>
           Set the fractional delay. Default is 0.

       <b>sample_rate,</b> <b>r</b>
           Set the sample rate, default is 44100.

       <b>nb_samples,</b> <b>n</b>
           Set the number of samples per each frame. Default is 1024.

       <b>taps,</b> <b>t</b>
           Set the number of filter coefficients in output audio stream.  Default value is 0.

       <b>channel_layout,</b> <b>c</b>
           Specifies  the  channel layout, and can be a string representing a channel layout.  The default value
           of <u>channel_layout</u> is "stereo".

   <b>afireqsrc</b>
       Generate a FIR equalizer coefficients.

       The resulting stream can be used with <b>afir</b> filter for filtering the audio signal.

       The filter accepts the following options:

       <b>preset,</b> <b>p</b>
           Set equalizer preset.  Default preset is "flat".

           Available presets are:

           <b>custom</b>
           <b>flat</b>
           <b>acoustic</b>
           <b>bass</b>
           <b>beats</b>
           <b>classic</b>
           <b>clear</b>
           <b>deep</b> <b>bass</b>
           <b>dubstep</b>
           <b>electronic</b>
           <b>hard-style</b>
           <b>hip-hop</b>
           <b>jazz</b>
           <b>metal</b>
           <b>movie</b>
           <b>pop</b>
           <b>r&amp;b</b>
           <b>rock</b>
           <b>vocal</b> <b>booster</b>
       <b>gains,</b> <b>g</b>
           Set custom gains for each band. Only used if the  preset  option  is  set  to  "custom".   Gains  are
           separated  by  white  spaces and each gain is set in dBFS.  Default is "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
           0".

       <b>bands,</b> <b>b</b>
           Set the custom bands from where custon equalizer gains are set.  This must be in strictly  increasing
           order.  Only  used  if the preset option is set to "custom".  Bands are separated by white spaces and
           each band represent frequency in Hz.  Default is "25 40 63 100 160 250 400 630 1000  1600  2500  4000
           6300 10000 16000 24000".

       <b>taps,</b> <b>t</b>
           Set number of filter coefficients in output audio stream.  Default value is 4096.

       <b>sample_rate,</b> <b>r</b>
           Set sample rate of output audio stream, default is 44100.

       <b>nb_samples,</b> <b>n</b>
           Set number of samples per each frame in output audio stream. Default is 1024.

       <b>interp,</b> <b>i</b>
           Set interpolation method for FIR equalizer coefficients. Can be "linear" or "cubic".

       <b>phase,</b> <b>h</b>
           Set  phase  type  of  FIR  filter. Can be "linear" or "min": minimum-phase.  Default is minimum-phase
           filter.

   <b>afirsrc</b>
       Generate a FIR coefficients using frequency sampling method.

       The resulting stream can be used with <b>afir</b> filter for filtering the audio signal.

       The filter accepts the following options:

       <b>taps,</b> <b>t</b>
           Set number of filter coefficients in output audio stream.  Default value is 1025.

       <b>frequency,</b> <b>f</b>
           Set frequency points from where magnitude and phase are set.  This must be in non  decreasing  order,
           and first element must be 0, while last element must be 1. Elements are separated by white spaces.

       <b>magnitude,</b> <b>m</b>
           Set  magnitude  value  for  every frequency point set by <b>frequency</b>.  Number of values must be same as
           number of frequency points.  Values are separated by white spaces.

       <b>phase,</b> <b>p</b>
           Set phase value for every frequency point set by <b>frequency</b>.  Number of values must be same as  number
           of frequency points.  Values are separated by white spaces.

       <b>sample_rate,</b> <b>r</b>
           Set sample rate, default is 44100.

       <b>nb_samples,</b> <b>n</b>
           Set number of samples per each frame. Default is 1024.

       <b>win_func,</b> <b>w</b>
           Set window function. Default is blackman.

   <b>anullsrc</b>
       The  null  audio  source,  return  unprocessed  audio frames. It is mainly useful as a template and to be
       employed in analysis / debugging tools, or as the source for filters which ignore  the  input  data  (for
       example the sox synth filter).

       This source accepts the following options:

       <b>channel_layout,</b> <b>cl</b>
           Specifies the channel layout, and can be either an integer or a string representing a channel layout.
           The default value of <u>channel_layout</u> is "stereo".

           Check the channel_layout_map definition in <u>libavutil/channel_layout.c</u> for the mapping between strings
           and channel layout values.

       <b>sample_rate,</b> <b>r</b>
           Specifies the sample rate, and defaults to 44100.

       <b>nb_samples,</b> <b>n</b>
           Set the number of samples per requested frames.

       <b>duration,</b> <b>d</b>
           Set  the  duration  of the sourced audio. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>
           for the accepted syntax.

           If not specified, or the expressed duration is negative,  the  audio  is  supposed  to  be  generated
           forever.

       <u>Examples</u>

       •   Set the sample rate to 48000 Hz and the channel layout to AV_CH_LAYOUT_MONO.

                   anullsrc=r=48000:cl=4

       •   Do the same operation with a more obvious syntax:

                   anullsrc=r=48000:cl=mono

       All the parameters need to be explicitly defined.

   <b>flite</b>
       Synthesize a voice utterance using the libflite library.

       To enable compilation of this filter you need to configure FFmpeg with "--enable-libflite".

       Note that versions of the flite library prior to 2.0 are not thread-safe.

       The filter accepts the following options:

       <b>list_voices</b>
           If set to 1, list the names of the available voices and exit immediately. Default value is 0.

       <b>nb_samples,</b> <b>n</b>
           Set the maximum number of samples per frame. Default value is 512.

       <b>textfile</b>
           Set the filename containing the text to speak.

       <b>text</b>
           Set the text to speak.

       <b>voice,</b> <b>v</b>
           Set  the  voice  to  use  for  the speech synthesis. Default value is "kal". See also the <u>list_voices</u>
           option.

       <u>Examples</u>

       •   Read from file <u>speech.txt</u>, and synthesize the text using the standard flite voice:

                   flite=textfile=speech.txt

       •   Read the specified text selecting the "slt" voice:

                   flite=text='So fare thee well, poor devil of a Sub-Sub, whose commentator I am':voice=slt

       •   Input text to ffmpeg:

                   ffmpeg -f lavfi -i flite=text='So fare thee well, poor devil of a Sub-Sub, whose commentator I am':voice=slt

       •   Make <u>ffplay</u> speak the specified text, using "flite" and the "lavfi" device:

                   ffplay -f lavfi flite=text='No more be grieved for which that thou hast done.'

       For more information about libflite, check: &lt;<b><a href="http://www.festvox.org/flite/">http://www.festvox.org/flite/</a></b>&gt;

   <b>anoisesrc</b>
       Generate a noise audio signal.

       The filter accepts the following options:

       <b>sample_rate,</b> <b>r</b>
           Specify the sample rate. Default value is 48000 Hz.

       <b>amplitude,</b> <b>a</b>
           Specify the amplitude (0.0 - 1.0) of the generated audio stream. Default value is 1.0.

       <b>duration,</b> <b>d</b>
           Specify the duration of the generated audio stream. Not specifying this option results in noise  with
           an infinite length.

       <b>color,</b> <b>colour,</b> <b>c</b>
           Specify  the  color of noise. Available noise colors are white, pink, brown, blue, violet and velvet.
           Default color is white.

       <b>seed,</b> <b>s</b>
           Specify a value used to seed the PRNG.

       <b>nb_samples,</b> <b>n</b>
           Set the number of samples per each output frame, default is 1024.

       <b>density</b>
           Set the density (0.0 - 1.0) for the velvet noise generator, default is 0.05.

       <u>Examples</u>

       •   Generate 60 seconds of pink noise, with a 44.1 kHz sampling rate and an amplitude of 0.5:

                   anoisesrc=d=60:c=pink:r=44100:a=0.5

   <b>hilbert</b>
       Generate odd-tap Hilbert transform FIR coefficients.

       The resulting stream can be used with <b>afir</b> filter for phase-shifting the signal by 90 degrees.

       This is used in many matrix coding schemes and for analytic signal  generation.   The  process  is  often
       written as a multiplication by i (or j), the imaginary unit.

       The filter accepts the following options:

       <b>sample_rate,</b> <b>s</b>
           Set sample rate, default is 44100.

       <b>taps,</b> <b>t</b>
           Set length of FIR filter, default is 22051.

       <b>nb_samples,</b> <b>n</b>
           Set number of samples per each frame.

       <b>win_func,</b> <b>w</b>
           Set window function to be used when generating FIR coefficients.

   <b>sinc</b>
       Generate a sinc kaiser-windowed low-pass, high-pass, band-pass, or band-reject FIR coefficients.

       The resulting stream can be used with <b>afir</b> filter for filtering the audio signal.

       The filter accepts the following options:

       <b>sample_rate,</b> <b>r</b>
           Set sample rate, default is 44100.

       <b>nb_samples,</b> <b>n</b>
           Set number of samples per each frame. Default is 1024.

       <b>hp</b>  Set high-pass frequency. Default is 0.

       <b>lp</b>  Set  low-pass  frequency.  Default is 0.  If high-pass frequency is lower than low-pass frequency and
           low-pass frequency is higher than 0 then filter will create band-pass filter coefficients,  otherwise
           band-reject filter coefficients.

       <b>phase</b>
           Set filter phase response. Default is 50. Allowed range is from 0 to 100.

       <b>beta</b>
           Set Kaiser window beta.

       <b>att</b> Set stop-band attenuation. Default is 120dB, allowed range is from 40 to 180 dB.

       <b>round</b>
           Enable rounding, by default is disabled.

       <b>hptaps</b>
           Set number of taps for high-pass filter.

       <b>lptaps</b>
           Set number of taps for low-pass filter.

   <b>sine</b>
       Generate an audio signal made of a sine wave with amplitude 1/8.

       The audio signal is bit-exact.

       The filter accepts the following options:

       <b>frequency,</b> <b>f</b>
           Set the carrier frequency. Default is 440 Hz.

       <b>beep_factor,</b> <b>b</b>
           Enable  a  periodic beep every second with frequency <u>beep_factor</u> times the carrier frequency. Default
           is 0, meaning the beep is disabled.

       <b>sample_rate,</b> <b>r</b>
           Specify the sample rate, default is 44100.

       <b>duration,</b> <b>d</b>
           Specify the duration of the generated audio stream.

       <b>samples_per_frame</b>
           Set the number of samples per output frame.

           The expression can contain the following constants:

           <b>n</b>   The (sequential) number of the output audio frame, starting from 0.

           <b>pts</b> The PTS (Presentation TimeStamp) of the output audio frame, expressed in <u>TB</u> units.

           <b>t</b>   The PTS of the output audio frame, expressed in seconds.

           <b>TB</b>  The timebase of the output audio frames.

           Default is 1024.

       <u>Examples</u>

       •   Generate a simple 440 Hz sine wave:

                   sine

       •   Generate a 220 Hz sine wave with a 880 Hz beep each second, for 5 seconds:

                   sine=220:4:d=5
                   sine=f=220:b=4:d=5
                   sine=frequency=220:beep_factor=4:duration=5

       •   Generate a 1 kHz sine wave following "1602,1601,1602,1601,1602" NTSC pattern:

                   sine=1000:samples_per_frame='st(0,mod(n,5)); 1602-not(not(eq(<a href="../man0/ld.0.html">ld</a>(0),1)+eq(<a href="../man0/ld.0.html">ld</a>(0),3)))'

</pre><h4><b>AUDIO</b> <b>SINKS</b></h4><pre>
       Below is a description of the currently available audio sinks.

   <b>abuffersink</b>
       Buffer audio frames, and make them available to the end of filter chain.

       This sink is mainly intended for programmatic  use,  in  particular  through  the  interface  defined  in
       <u>libavfilter/buffersink.h</u> or the options system.

       It  accepts  a pointer to an AVABufferSinkContext structure, which defines the incoming buffers' formats,
       to be passed as the opaque parameter to "avfilter_init_filter" for initialization.

   <b>anullsink</b>
       Null audio sink; do absolutely nothing with the input audio. It is mainly useful as a  template  and  for
       use in analysis / debugging tools.

</pre><h4><b>VIDEO</b> <b>FILTERS</b></h4><pre>
       When   you   configure   your   FFmpeg  build,  you  can  disable  any  of  the  existing  filters  using
       "--disable-filters".  The configure output will show the video filters included in your build.

       Below is a description of the currently available video filters.

   <b>addroi</b>
       Mark a region of interest in a video frame.

       The frame data is passed through unchanged, but metadata is attached to the frame indicating  regions  of
       interest  which  can  affect the behaviour of later encoding.  Multiple regions can be marked by applying
       the filter multiple times.

       <b>x</b>   Region distance in pixels from the left edge of the frame.

       <b>y</b>   Region distance in pixels from the top edge of the frame.

       <b>w</b>   Region width in pixels.

       <b>h</b>   Region height in pixels.

           The parameters <u>x</u>, <u>y</u>, <u>w</u> and <u>h</u> are expressions, and may contain the following variables:

           <b>iw</b>  Width of the input frame.

           <b>ih</b>  Height of the input frame.

       <b>qoffset</b>
           Quantisation offset to apply within the region.

           This must be a real value in the range -1 to +1.  A value of zero indicates  no  quality  change.   A
           negative  value  asks  for  better quality (less quantisation), while a positive value asks for worse
           quality (greater quantisation).

           The range is calibrated so that the extreme values indicate the largest possible offset - if the rest
           of the frame is encoded with the worst possible quality, an offset of -1 indicates that  this  region
           should  be  encoded with the best possible quality anyway.  Intermediate values are then interpolated
           in some codec-dependent way.

           For example, in 10-bit H.264 the quantisation parameter varies between -12 and 51.  A typical qoffset
           value of -1/10 therefore indicates that this region should be encoded with a QP around  one-tenth  of
           the full range better than the rest of the frame.  So, if most of the frame were to be encoded with a
           QP  of  around  30, this region would get a QP of around 24 (an offset of approximately -1/10 * (51 -
           -12) = -6.3).  An extreme value of -1 would indicate that this region should be encoded with the best
           possible quality regardless of the treatment of the rest of the frame - that is, should be encoded at
           a QP of -12.

       <b>clear</b>
           If set to true, remove any existing regions of interest marked on the frame  before  adding  the  new
           one.

       <u>Examples</u>

       •   Mark the centre quarter of the frame as interesting.

                   addroi=iw/4:ih/4:iw/2:ih/2:-1/10

       •   Mark  the 100-pixel-wide region on the left edge of the frame as very uninteresting (to be encoded at
           much lower quality than the rest of the frame).

                   addroi=0:0:100:ih:+1/5

   <b>alphaextract</b>
       Extract the alpha component from the input as a grayscale video.  This  is  especially  useful  with  the
       <u>alphamerge</u> filter.

   <b>alphamerge</b>
       Add  or replace the alpha component of the primary input with the grayscale value of a second input. This
       is intended for use with <u>alphaextract</u> to allow the transmission or storage of frame sequences  that  have
       alpha in a format that doesn't support an alpha channel.

       For example, to reconstruct full frames from a normal YUV-encoded video and a separate video created with
       <u>alphaextract</u>, you might use:

               movie=in_alpha.mkv [alpha]; [in][alpha] alphamerge [out]

   <b>amplify</b>
       Amplify differences between current pixel and pixels of adjacent frames in same pixel location.

       This filter accepts the following options:

       <b>radius</b>
           Set frame radius. Default is 2. Allowed range is from 1 to 63.  For example radius of 3 will instruct
           filter to calculate average of 7 frames.

       <b>factor</b>
           Set factor to amplify difference. Default is 2. Allowed range is from 0 to 65535.

       <b>threshold</b>
           Set  threshold  for  difference amplification. Any difference greater or equal to this value will not
           alter source pixel. Default is 10.  Allowed range is from 0 to 65535.

       <b>tolerance</b>
           Set tolerance for difference amplification. Any difference lower to this value will not alter  source
           pixel. Default is 0.  Allowed range is from 0 to 65535.

       <b>low</b> Set  lower limit for changing source pixel. Default is 65535. Allowed range is from 0 to 65535.  This
           option controls maximum possible value that will decrease source pixel value.

       <b>high</b>
           Set high limit for changing source pixel. Default is 65535. Allowed range is from 0 to  65535.   This
           option controls maximum possible value that will increase source pixel value.

       <b>planes</b>
           Set which planes to filter. Default is all. Allowed range is from 0 to 15.

       <u>Commands</u>

       This filter supports the following <b>commands</b> that corresponds to option of same name:

       <b>factor</b>
       <b>threshold</b>
       <b>tolerance</b>
       <b>low</b>
       <b>high</b>
       <b>planes</b>

   <b>ass</b>
       Same  as  the <b>subtitles</b> filter, except that it doesn't require libavcodec and libavformat to work. On the
       other hand, it is limited to ASS (Advanced Substation Alpha) subtitles files.

       This filter accepts the following option in addition to the common options from the <b>subtitles</b> filter:

       <b>shaping</b>
           Set the shaping engine

           Available values are:

           <b>auto</b>
               The default libass shaping engine, which is the best available.

           <b>simple</b>
               Fast, font-agnostic shaper that can do only substitutions

           <b>complex</b>
               Slower shaper using OpenType for substitutions and positioning

           The default is "auto".

   <b>atadenoise</b>
       Apply an Adaptive Temporal Averaging Denoiser to the video input.

       The filter accepts the following options:

       <b>0a</b>  Set threshold A for 1st plane. Default is 0.02.  Valid range is 0 to 0.3.

       <b>0b</b>  Set threshold B for 1st plane. Default is 0.04.  Valid range is 0 to 5.

       <b>1a</b>  Set threshold A for 2nd plane. Default is 0.02.  Valid range is 0 to 0.3.

       <b>1b</b>  Set threshold B for 2nd plane. Default is 0.04.  Valid range is 0 to 5.

       <b>2a</b>  Set threshold A for 3rd plane. Default is 0.02.  Valid range is 0 to 0.3.

       <b>2b</b>  Set threshold B for 3rd plane. Default is 0.04.  Valid range is 0 to 5.

           Threshold A is designed to react on abrupt changes in the input signal and threshold B is designed to
           react on continuous changes in the input signal.

       <b>s</b>   Set number of frames filter will use for averaging. Default is 9. Must be odd  number  in  range  [5,
           129].

       <b>p</b>   Set what planes of frame filter will use for averaging. Default is all.

       <b>a</b>   Set  what variant of algorithm filter will use for averaging. Default is "p" parallel.  Alternatively
           can be set to "s" serial.

           Parallel can be faster then serial, while other way around is never true.  Parallel will abort  early
           on  first  change  being greater then thresholds, while serial will continue processing other side of
           frames if they are equal or below thresholds.

       <b>0s</b>
       <b>1s</b>
       <b>2s</b>  Set sigma for 1st plane, 2nd plane or 3rd plane. Default is 32767.  Valid range is from 0  to  32767.
           This  options  controls  weight  for each pixel in radius defined by size.  Default value means every
           pixel have same weight.  Setting this option to 0 effectively disables filtering.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options except option "s".  The command accepts the same syntax  of
       the corresponding option.

   <b>avgblur</b>
       Apply average blur filter.

       The filter accepts the following options:

       <b>sizeX</b>
           Set horizontal radius size.

       <b>planes</b>
           Set which planes to filter. By default all planes are filtered.

       <b>sizeY</b>
           Set vertical radius size, if zero it will be same as "sizeX".  Default is 0.

       <u>Commands</u>

       This  filter supports same commands as options.  The command accepts the same syntax of the corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>backgroundkey</b>
       Turns a static background into transparency.

       The filter accepts the following option:

       <b>threshold</b>
           Threshold for scene change detection.

       <b>similarity</b>
           Similarity percentage with the background.

       <b>blend</b>
           Set the blend amount for pixels that are not similar.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>bbox</b>
       Compute the bounding box for the non-black pixels in the input frame luma plane.

       This filter computes the bounding box containing all the pixels  with  a  luma  value  greater  than  the
       minimum allowed value.  The parameters describing the bounding box are printed on the filter log.

       The filter accepts the following option:

       <b>min_val</b>
           Set the minimal luma value. Default is 16.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>bilateral</b>
       Apply bilateral filter, spatial smoothing while preserving edges.

       The filter accepts the following options:

       <b>sigmaS</b>
           Set  sigma  of  gaussian function to calculate spatial weight.  Allowed range is 0 to 512. Default is
           0.1.

       <b>sigmaR</b>
           Set sigma of gaussian function to calculate range weight.  Allowed range is 0 to 1. Default is 0.1.

       <b>planes</b>
           Set planes to filter. Default is first only.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>bilateral_cuda</b>
       CUDA accelerated bilateral filter, an edge preserving filter.  This  filter  is  mathematically  accurate
       thanks  to the use of GPU acceleration.  For best output quality, use one to one chroma subsampling, i.e.
       yuv444p format.

       The filter accepts the following options:

       <b>sigmaS</b>
           Set sigma of gaussian function to calculate spatial weight, also called sigma space.   Allowed  range
           is 0.1 to 512. Default is 0.1.

       <b>sigmaR</b>
           Set  sigma  of  gaussian  function to calculate color range weight, also called sigma color.  Allowed
           range is 0.1 to 512. Default is 0.1.

       <b>window_size</b>
           Set window size of the bilateral function to determine the number of neighbours to loop on.   If  the
           number entered is even, one will be added automatically.  Allowed range is 1 to 255. Default is 1.

       <u>Examples</u>

       •   Apply the bilateral filter on a video.

                   ./ffmpeg -v verbose \
                   -hwaccel cuda -hwaccel_output_format cuda -i input.mp4  \
                   -init_hw_device cuda \
                   -filter_complex \
                   " \
                   [0:v]scale_cuda=format=yuv444p[scaled_video];
                   [scaled_video]bilateral_cuda=window_size=9:sigmaS=3.0:sigmaR=50.0" \
                   -an -sn -c:v h264_nvenc -cq 20 out.mp4

   <b>bitplanenoise</b>
       Show and measure bit plane noise.

       The filter accepts the following options:

       <b>bitplane</b>
           Set which plane to analyze. Default is 1.

       <b>filter</b>
           Filter out noisy pixels from "bitplane" set above.  Default is disabled.

   <b>blackdetect</b>
       Detect  video  intervals that are (almost) completely black. Can be useful to detect chapter transitions,
       commercials, or invalid recordings.

       The filter outputs its detection analysis to both the log as well as frame metadata. If a  black  segment
       of  at least the specified minimum duration is found, a line with the start and end timestamps as well as
       duration is printed to the log with level "info". In addition, a log line with level "debug"  is  printed
       per frame showing the black amount detected for that frame.

       The  filter also attaches metadata to the first frame of a black segment with key "lavfi.black_start" and
       to the first frame after the black segment ends with key "lavfi.black_end".  The  value  is  the  frame's
       timestamp. This metadata is added regardless of the minimum duration specified.

       The filter accepts the following options:

       <b>black_min_duration,</b> <b>d</b>
           Set  the  minimum  detected  black  duration expressed in seconds. It must be a non-negative floating
           point number.

           Default value is 2.0.

       <b>picture_black_ratio_th,</b> <b>pic_th</b>
           Set the threshold for considering a picture "black".  Express the minimum value for the ratio:

                   &lt;nb_black_pixels&gt; / &lt;nb_pixels&gt;

           for which a picture is considered black.  Default value is 0.98.

       <b>pixel_black_th,</b> <b>pix_th</b>
           Set the threshold for considering a pixel "black".

           The threshold expresses the maximum pixel luma value for which a pixel  is  considered  "black".  The
           provided value is scaled according to the following equation:

                   &lt;absolute_threshold&gt; = &lt;luma_minimum_value&gt; + &lt;pixel_black_th&gt; * &lt;luma_range_size&gt;

           <u>luma_range_size</u> and <u>luma_minimum_value</u> depend on the input video format, the range is [0-255] for YUV
           full-range formats and [16-235] for YUV non full-range formats.

           Default value is 0.10.

       The  following  example  sets  the  maximum  pixel threshold to the minimum value, and detects only black
       intervals of 2 or more seconds:

               blackdetect=d=2:pix_th=0.00

   <b>blackframe</b>
       Detect frames that are (almost) completely  black.  Can  be  useful  to  detect  chapter  transitions  or
       commercials. Output lines consist of the frame number of the detected frame, the percentage of blackness,
       the position in the file if known or -1 and the timestamp in seconds.

       In order to display the output lines, you need to set the loglevel at least to the AV_LOG_INFO value.

       This  filter  exports  frame  metadata "lavfi.blackframe.pblack".  The value represents the percentage of
       pixels in the picture that are below the threshold value.

       It accepts the following parameters:

       <b>amount</b>
           The percentage of the pixels that have to be below the threshold; it defaults to 98.

       <b>threshold,</b> <b>thresh</b>
           The threshold below which a pixel value is considered black; it defaults to 32.

   <b>blend</b>
       Blend two video frames into each other.

       The "blend" filter takes two input streams and outputs one stream, the first input is the "top" layer and
       second input is "bottom" layer.  By default, the output terminates when the longest input terminates.

       The "tblend" (time blend) filter takes two consecutive frames from one single  stream,  and  outputs  the
       result obtained by blending the new frame on top of the old frame.

       A description of the accepted options follows.

       <b>c0_mode</b>
       <b>c1_mode</b>
       <b>c2_mode</b>
       <b>c3_mode</b>
       <b>all_mode</b>
           Set  blend  mode  for  specific  pixel component or all pixel components in case of <u>all_mode</u>. Default
           value is "normal".

           Available values for component modes are:

           <b>addition</b>
           <b>and</b>
           <b>average</b>
           <b>bleach</b>
           <b>burn</b>
           <b>darken</b>
           <b>difference</b>
           <b>divide</b>
           <b>dodge</b>
           <b>exclusion</b>
           <b>extremity</b>
           <b>freeze</b>
           <b>geometric</b>
           <b>glow</b>
           <b>grainextract</b>
           <b>grainmerge</b>
           <b>hardlight</b>
           <b>hardmix</b>
           <b>hardoverlay</b>
           <b>harmonic</b>
           <b>heat</b>
           <b>interpolate</b>
           <b>lighten</b>
           <b>linearlight</b>
           <b>multiply</b>
           <b>multiply128</b>
           <b>negation</b>
           <b>normal</b>
           <b>or</b>
           <b>overlay</b>
           <b>phoenix</b>
           <b>pinlight</b>
           <b>reflect</b>
           <b>screen</b>
           <b>softdifference</b>
           <b>softlight</b>
           <b>stain</b>
           <b>subtract</b>
           <b>vividlight</b>
           <b>xor</b>
       <b>c0_opacity</b>
       <b>c1_opacity</b>
       <b>c2_opacity</b>
       <b>c3_opacity</b>
       <b>all_opacity</b>
           Set blend opacity for specific pixel component or all pixel components in case of  <u>all_opacity</u>.  Only
           used in combination with pixel component blend modes.

       <b>c0_expr</b>
       <b>c1_expr</b>
       <b>c2_expr</b>
       <b>c3_expr</b>
       <b>all_expr</b>
           Set  blend  expression for specific pixel component or all pixel components in case of <u>all_expr</u>. Note
           that related mode options will be ignored if those are set.

           The expressions can use the following variables:

           <b>N</b>   The sequential number of the filtered frame, starting from 0.

           <b>X</b>
           <b>Y</b>   the coordinates of the current sample

           <b>W</b>
           <b>H</b>   the width and height of currently filtered plane

           <b>SW</b>
           <b>SH</b>  Width and height scale for the plane being filtered. It is the ratio between  the  dimensions  of
               the  current  plane  to  the luma plane, e.g. for a "yuv420p" frame, the values are "1,1" for the
               luma plane and "0.5,0.5" for the chroma planes.

           <b>T</b>   Time of the current frame, expressed in seconds.

           <b>TOP,</b> <b>A</b>
               Value of pixel component at current location for first video frame (top layer).

           <b>BOTTOM,</b> <b>B</b>
               Value of pixel component at current location for second video frame (bottom layer).

       The "blend" filter also supports the <b>framesync</b> options.

       <u>Examples</u>

       •   Apply transition from bottom layer to top layer in first 10 seconds:

                   blend=all_expr='A*(if(gte(T,10),1,T/10))+B*(1-(if(gte(T,10),1,T/10)))'

       •   Apply linear horizontal transition from top layer to bottom layer:

                   blend=all_expr='A*(X/W)+B*(1-X/W)'

       •   Apply 1x1 checkerboard effect:

                   blend=all_expr='if(eq(mod(X,2),mod(Y,2)),A,B)'

       •   Apply uncover left effect:

                   blend=all_expr='if(gte(N*SW+X,W),A,B)'

       •   Apply uncover down effect:

                   blend=all_expr='if(gte(Y-N*SH,0),A,B)'

       •   Apply uncover up-left effect:

                   blend=all_expr='if(gte(T*SH*40+Y,H)*gte((T*40*SW+X)*W/H,W),A,B)'

       •   Split diagonally video and shows top and bottom layer on each side:

                   blend=all_expr='if(gt(X,Y*(W/H)),A,B)'

       •   Display differences between the current and the previous frame:

                   tblend=all_mode=grainextract

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>blockdetect</b>
       Determines blockiness of frames without altering the input frames.

       Based on Remco Muijs and Ihor Kirenko: "A no-reference  blocking  artifact  measure  for  adaptive  video
       processing." 2005 13th European signal processing conference.

       The filter accepts the following options:

       <b>period_min</b>
       <b>period_max</b>
           Set minimum and maximum values for determining pixel grids (periods).  Default values are [3,24].

       <b>planes</b>
           Set planes to filter. Default is first only.

       <u>Examples</u>

       •   Determine blockiness for the first plane and search for periods within [8,32]:

                   blockdetect=period_min=8:period_max=32:planes=1

   <b>blurdetect</b>
       Determines blurriness of frames without altering the input frames.

       Based  on  Marziliano,  Pina,  et  al. "A no-reference perceptual blur metric."  Allows for a block-based
       abbreviation.

       The filter accepts the following options:

       <b>low</b>
       <b>high</b>
           Set low and high threshold values used by the Canny thresholding algorithm.

           The high threshold selects the "strong" edge pixels, which are then connected through  8-connectivity
           with the "weak" edge pixels selected by the low threshold.

           <u>low</u> and <u>high</u> threshold values must be chosen in the range [0,1], and <u>low</u> should be lesser or equal to
           <u>high</u>.

           Default value for <u>low</u> is "20/255", and default value for <u>high</u> is "50/255".

       <b>radius</b>
           Define the radius to search around an edge pixel for local maxima.

       <b>block_pct</b>
           Determine blurriness only for the most significant blocks, given in percentage.

       <b>block_width</b>
           Determine  blurriness  for  blocks of width <u>block_width</u>. If set to any value smaller 1, no blocks are
           used and the whole image is processed as one no matter of <u>block_height</u>.

       <b>block_height</b>
           Determine blurriness for blocks of height <u>block_height</u>. If set to any value smaller 1, no blocks  are
           used and the whole image is processed as one no matter of <u>block_width</u>.

       <b>planes</b>
           Set planes to filter. Default is first only.

       <u>Examples</u>

       •   Determine blur for 80% of most significant 32x32 blocks:

                   blurdetect=block_width=32:block_height=32:block_pct=80

   <b>bm3d</b>
       Denoise frames using Block-Matching 3D algorithm.

       The filter accepts the following options.

       <b>sigma</b>
           Set  denoising  strength.  Default  value  is  1.   Allowed  range is from 0 to 999.9.  The denoising
           algorithm is very sensitive to sigma, so adjust it according to the source.

       <b>block</b>
           Set local patch size. This sets dimensions in 2D.

       <b>bstep</b>
           Set sliding step for processing blocks. Default value is 4.  Allowed range is from 1 to 64.   Smaller
           values allows processing more reference blocks and is slower.

       <b>group</b>
           Set  maximal number of similar blocks for 3rd dimension. Default value is 1.  When set to 1, no block
           matching is done. Larger values allows more blocks in single group.  Allowed range is from 1 to 256.

       <b>range</b>
           Set radius for search block matching. Default is 9.  Allowed range is from 1 to INT32_MAX.

       <b>mstep</b>
           Set step between two search locations for block matching. Default is 1.  Allowed range is from  1  to
           64. Smaller is slower.

       <b>thmse</b>
           Set threshold of mean square error for block matching. Valid range is 0 to INT32_MAX.

       <b>hdthr</b>
           Set  thresholding parameter for hard thresholding in 3D transformed domain.  Larger values results in
           stronger hard-thresholding filtering in frequency domain.

       <b>estim</b>
           Set filtering estimation mode. Can be "basic" or "final".  Default is "basic".

       <b>ref</b> If enabled, filter will use 2nd stream for block matching.  Default is disabled for "basic" value  of
           <u>estim</u> option, and always enabled if value of <u>estim</u> is "final".

       <b>planes</b>
           Set planes to filter. Default is all available except alpha.

       <u>Examples</u>

       •   Basic filtering with bm3d:

                   bm3d=sigma=3:block=4:bstep=2:group=1:estim=basic

       •   Same as above, but filtering only luma:

                   bm3d=sigma=3:block=4:bstep=2:group=1:estim=basic:planes=1

       •   Same as above, but with both estimation modes:

                   split[a][b],[a]bm3d=sigma=3:block=4:bstep=2:group=1:estim=basic[a],[b][a]bm3d=sigma=3:block=4:bstep=2:group=16:estim=final:ref=1

       •   Same as above, but prefilter with <b>nlmeans</b> filter instead:

                   split[a][b],[a]nlmeans=s=3:r=7:p=3[a],[b][a]bm3d=sigma=3:block=4:bstep=2:group=16:estim=final:ref=1

   <b>boxblur</b>
       Apply a boxblur algorithm to the input video.

       It accepts the following parameters:

       <b>luma_radius,</b> <b>lr</b>
       <b>luma_power,</b> <b>lp</b>
       <b>chroma_radius,</b> <b>cr</b>
       <b>chroma_power,</b> <b>cp</b>
       <b>alpha_radius,</b> <b>ar</b>
       <b>alpha_power,</b> <b>ap</b>

       A description of the accepted options follows.

       <b>luma_radius,</b> <b>lr</b>
       <b>chroma_radius,</b> <b>cr</b>
       <b>alpha_radius,</b> <b>ar</b>
           Set an expression for the box radius in pixels used for blurring the corresponding input plane.

           The  radius  value  must  be  a  non-negative  number,  and must not be greater than the value of the
           expression "min(w,h)/2" for the luma and alpha planes, and of "min(cw,ch)/2" for the chroma planes.

           Default value for <b>luma_radius</b> is "2". If not specified, <b>chroma_radius</b> and <b>alpha_radius</b> default to the
           corresponding value set for <b>luma_radius</b>.

           The expressions can contain the following constants:

           <b>w</b>
           <b>h</b>   The input width and height in pixels.

           <b>cw</b>
           <b>ch</b>  The input chroma image width and height in pixels.

           <b>hsub</b>
           <b>vsub</b>
               The horizontal and vertical chroma subsample values. For example, for the pixel format "yuv422p",
               <u>hsub</u> is 2 and <u>vsub</u> is 1.

       <b>luma_power,</b> <b>lp</b>
       <b>chroma_power,</b> <b>cp</b>
       <b>alpha_power,</b> <b>ap</b>
           Specify how many times the boxblur filter is applied to the corresponding plane.

           Default value for <b>luma_power</b> is 2. If not specified, <b>chroma_power</b>  and  <b>alpha_power</b>  default  to  the
           corresponding value set for <b>luma_power</b>.

           A value of 0 will disable the effect.

       <u>Examples</u>

       •   Apply a boxblur filter with the luma, chroma, and alpha radii set to 2:

                   boxblur=luma_radius=2:luma_power=1
                   boxblur=2:1

       •   Set the luma radius to 2, and alpha and chroma radius to 0:

                   boxblur=2:1:cr=0:ar=0

       •   Set the luma and chroma radii to a fraction of the video dimension:

                   boxblur=luma_radius=min(h\,w)/10:luma_power=1:chroma_radius=min(cw\,ch)/10:chroma_power=1

   <b>bwdif</b>
       Deinterlace the input video ("bwdif" stands for "Bob Weaver Deinterlacing Filter").

       Motion  adaptive  deinterlacing based on yadif with the use of w3fdif and cubic interpolation algorithms.
       It accepts the following parameters:

       <b>mode</b>
           The interlacing mode to adopt. It accepts one of the following values:

           <b>0,</b> <b>send_frame</b>
               Output one frame for each frame.

           <b>1,</b> <b>send_field</b>
               Output one frame for each field.

           The default value is "send_field".

       <b>parity</b>
           The picture field parity assumed for the input interlaced video. It  accepts  one  of  the  following
           values:

           <b>0,</b> <b>tff</b>
               Assume the top field is first.

           <b>1,</b> <b>bff</b>
               Assume the bottom field is first.

           <b>-1,</b> <b>auto</b>
               Enable automatic detection of field parity.

           The  default  value  is  "auto".   If  the interlacing is unknown or the decoder does not export this
           information, top field first will be assumed.

       <b>deint</b>
           Specify which frames to deinterlace. Accepts one of the following values:

           <b>0,</b> <b>all</b>
               Deinterlace all frames.

           <b>1,</b> <b>interlaced</b>
               Only deinterlace frames marked as interlaced.

           The default value is "all".

   <b>bwdif_cuda</b>
       Deinterlace the input video using the <b>bwdif</b> algorithm, but implemented in CUDA so that  it  can  work  as
       part of a GPU accelerated pipeline with nvdec and/or nvenc.

       It accepts the following parameters:

       <b>mode</b>
           The interlacing mode to adopt. It accepts one of the following values:

           <b>0,</b> <b>send_frame</b>
               Output one frame for each frame.

           <b>1,</b> <b>send_field</b>
               Output one frame for each field.

           The default value is "send_field".

       <b>parity</b>
           The  picture  field  parity  assumed  for the input interlaced video. It accepts one of the following
           values:

           <b>0,</b> <b>tff</b>
               Assume the top field is first.

           <b>1,</b> <b>bff</b>
               Assume the bottom field is first.

           <b>-1,</b> <b>auto</b>
               Enable automatic detection of field parity.

           The default value is "auto".  If the interlacing is unknown or  the  decoder  does  not  export  this
           information, top field first will be assumed.

       <b>deint</b>
           Specify which frames to deinterlace. Accepts one of the following values:

           <b>0,</b> <b>all</b>
               Deinterlace all frames.

           <b>1,</b> <b>interlaced</b>
               Only deinterlace frames marked as interlaced.

           The default value is "all".

   <b>ccrepack</b>
       Repack CEA-708 closed captioning side data

       This  filter  fixes  various  issues  seen with commerical encoders related to upstream malformed CEA-708
       payloads, specifically incorrect number of tuples (wrong cc_count for  the  target  FPS),  and  incorrect
       ordering of tuples (i.e. the CEA-608 tuples are not at the first entries in the payload).

   <b>cas</b>
       Apply Contrast Adaptive Sharpen filter to video stream.

       The filter accepts the following options:

       <b>strength</b>
           Set the sharpening strength. Default value is 0.

       <b>planes</b>
           Set planes to filter. Default value is to filter all planes except alpha plane.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>chromahold</b>
       Remove all color information for all colors except for certain one.

       The filter accepts the following options:

       <b>color</b>
           The color which will not be replaced with neutral chroma.

       <b>similarity</b>
           Similarity percentage with the above color.  0.01 matches only the exact key color, while 1.0 matches
           everything.

       <b>blend</b>
           Blend  percentage.   0.0 makes pixels either fully gray, or not gray at all.  Higher values result in
           more preserved color.

       <b>yuv</b> Signals that the color passed is already in YUV instead of RGB.

           Literal colors like "green" or "red" don't make sense with this enabled anymore.  This can be used to
           pass exact YUV values as hexadecimal numbers.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.  The command accepts the same syntax of the  corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>chromakey</b>
       YUV colorspace color/chroma keying.

       The filter accepts the following options:

       <b>color</b>
           The color which will be replaced with transparency.

       <b>similarity</b>
           Similarity percentage with the key color.

           0.01 matches only the exact key color, while 1.0 matches everything.

       <b>blend</b>
           Blend percentage.

           0.0 makes pixels either fully transparent, or not transparent at all.

           Higher  values  result  in  semi-transparent  pixels, with a higher transparency the more similar the
           pixels color is to the key color.

       <b>yuv</b> Signals that the color passed is already in YUV instead of RGB.

           Literal colors like "green" or "red" don't make sense with this enabled anymore.  This can be used to
           pass exact YUV values as hexadecimal numbers.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.  The command accepts the same syntax of the  corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

       <u>Examples</u>

       •   Make every green pixel in the input image transparent:

                   ffmpeg -i input.png -vf chromakey=green out.png

       •   Overlay a greenscreen-video on top of a static black background.

                   ffmpeg -f lavfi -i color=c=black:s=1280x720 -i video.mp4 -shortest -filter_complex "[1:v]chromakey=0x70de77:0.1:0.2[ckout];[0:v][ckout]overlay[out]" -map "[out]" output.mkv

   <b>chromakey_cuda</b>
       CUDA accelerated YUV colorspace color/chroma keying.

       This  filter  works  like  normal  chromakey  filter  but  operates on CUDA frames.  for more details and
       parameters see <b>chromakey</b>.

       <u>Examples</u>

       •   Make all the green pixels in the input video transparent and use it as an overlay for another video:

                   ./ffmpeg \
                       -hwaccel cuda -hwaccel_output_format cuda -i input_green.mp4  \
                       -hwaccel cuda -hwaccel_output_format cuda -i base_video.mp4 \
                       -init_hw_device cuda \
                       -filter_complex \
                       " \
                           [0:v]chromakey_cuda=0x25302D:0.1:0.12:1[overlay_video]; \
                           [1:v]scale_cuda=format=yuv420p[base]; \
                           [base][overlay_video]overlay_cuda" \
                       -an -sn -c:v h264_nvenc -cq 20 output.mp4

       •   Process two software sources, explicitly uploading the frames:

                   ./ffmpeg -init_hw_device cuda=cuda -filter_hw_device cuda \
                       -f lavfi -i color=size=800x600:color=white,format=yuv420p \
                       -f lavfi -i yuvtestsrc=size=200x200,format=yuv420p \
                       -filter_complex \
                       " \
                           [0]hwupload[under]; \
                           [1]hwupload,chromakey_cuda=green:0.1:0.12[over]; \
                           [under][over]overlay_cuda" \
                       -c:v hevc_nvenc -cq 18 -preset slow output.mp4

   <b>chromanr</b>
       Reduce chrominance noise.

       The filter accepts the following options:

       <b>thres</b>
           Set threshold for averaging chrominance values.  Sum of absolute difference  of  Y,  U  and  V  pixel
           components of current pixel and neighbour pixels lower than this threshold will be used in averaging.
           Luma component is left unchanged and is copied to output.  Default value is 30. Allowed range is from
           1 to 200.

       <b>sizew</b>
           Set horizontal radius of rectangle used for averaging.  Allowed range is from 1 to 100. Default value
           is 5.

       <b>sizeh</b>
           Set  vertical  radius of rectangle used for averaging.  Allowed range is from 1 to 100. Default value
           is 5.

       <b>stepw</b>
           Set horizontal step when averaging. Default value is 1.  Allowed range  is  from  1  to  50.   Mostly
           useful to speed-up filtering.

       <b>steph</b>
           Set  vertical step when averaging. Default value is 1.  Allowed range is from 1 to 50.  Mostly useful
           to speed-up filtering.

       <b>threy</b>
           Set Y threshold for averaging chrominance values.  Set  finer  control  for  max  allowed  difference
           between  Y  components  of current pixel and neigbour pixels.  Default value is 200. Allowed range is
           from 1 to 200.

       <b>threu</b>
           Set U threshold for averaging chrominance values.  Set  finer  control  for  max  allowed  difference
           between  U  components  of current pixel and neigbour pixels.  Default value is 200. Allowed range is
           from 1 to 200.

       <b>threv</b>
           Set V threshold for averaging chrominance values.  Set  finer  control  for  max  allowed  difference
           between  V  components  of current pixel and neigbour pixels.  Default value is 200. Allowed range is
           from 1 to 200.

       <b>distance</b>
           Set distance type used in calculations.

           <b>manhattan</b>
               Absolute difference.

           <b>euclidean</b>
               Difference squared.

           Default distance type is manhattan.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.  The command accepts the same syntax of the  corresponding
       option.

   <b>chromashift</b>
       Shift chroma pixels horizontally and/or vertically.

       The filter accepts the following options:

       <b>cbh</b> Set amount to shift chroma-blue horizontally.

       <b>cbv</b> Set amount to shift chroma-blue vertically.

       <b>crh</b> Set amount to shift chroma-red horizontally.

       <b>crv</b> Set amount to shift chroma-red vertically.

       <b>edge</b>
           Set edge mode, can be <u>smear</u>, default, or <u>warp</u>.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>ciescope</b>
       Display CIE color diagram with pixels overlaid onto it.

       The filter accepts the following options:

       <b>system</b>
           Set color system.

           <b>ntsc,</b> <b>470m</b>
           <b>ebu,</b> <b>470bg</b>
           <b>smpte</b>
           <b>240m</b>
           <b>apple</b>
           <b>widergb</b>
           <b>cie1931</b>
           <b>rec709,</b> <b>hdtv</b>
           <b>uhdtv,</b> <b>rec2020</b>
           <b>dcip3</b>
       <b>cie</b> Set CIE system.

           <b>xyy</b>
           <b>ucs</b>
           <b>luv</b>
       <b>gamuts</b>
           Set what gamuts to draw.

           See "system" option for available values.

       <b>size,</b> <b>s</b>
           Set ciescope size, by default set to 512.

       <b>intensity,</b> <b>i</b>
           Set intensity used to map input pixel values to CIE diagram.

       <b>contrast</b>
           Set contrast used to draw tongue colors that are out of active color system gamut.

       <b>corrgamma</b>
           Correct gamma displayed on scope, by default enabled.

       <b>showwhite</b>
           Show white point on CIE diagram, by default disabled.

       <b>gamma</b>
           Set input gamma. Used only with XYZ input color space.

       <b>fill</b>
           Fill with CIE colors. By default is enabled.

   <b>codecview</b>
       Visualize information exported by some codecs.

       Some  codecs can export information through frames using side-data or other means. For example, some MPEG
       based codecs export motion vectors through the <u>export_mvs</u> flag in the codec <b>flags2</b> option.

       The filter accepts the following option:

       <b>block</b>
           Display block partition structure using the luma plane.

       <b>mv</b>  Set motion vectors to visualize.

           Available flags for <u>mv</u> are:

           <b>pf</b>  forward predicted MVs of P-frames

           <b>bf</b>  forward predicted MVs of B-frames

           <b>bb</b>  backward predicted MVs of B-frames

       <b>qp</b>  Display quantization parameters using the chroma planes.

       <b>mv_type,</b> <b>mvt</b>
           Set motion vectors type to visualize. Includes MVs from all frames  unless  specified  by  <u>frame_type</u>
           option.

           Available flags for <u>mv_type</u> are:

           <b>fp</b>  forward predicted MVs

           <b>bp</b>  backward predicted MVs

       <b>frame_type,</b> <b>ft</b>
           Set frame type to visualize motion vectors of.

           Available flags for <u>frame_type</u> are:

           <b>if</b>  intra-coded frames (I-frames)

           <b>pf</b>  predicted frames (P-frames)

           <b>bf</b>  bi-directionally predicted frames (B-frames)

       <u>Examples</u>

       •   Visualize forward predicted MVs of all frames using <b>ffplay</b>:

                   ffplay -flags2 +export_mvs input.mp4 -vf codecview=mv_type=fp

       •   Visualize multi-directionals MVs of P and B-Frames using <b>ffplay</b>:

                   ffplay -flags2 +export_mvs input.mp4 -vf codecview=mv=pf+bf+bb

   <b>colorbalance</b>
       Modify intensity of primary colors (red, green and blue) of input frames.

       The  filter  allows  an input frame to be adjusted in the shadows, midtones or highlights regions for the
       red-cyan, green-magenta or blue-yellow balance.

       A positive adjustment value shifts the balance towards the primary color, a negative  value  towards  the
       complementary color.

       The filter accepts the following options:

       <b>rs</b>
       <b>gs</b>
       <b>bs</b>  Adjust red, green and blue shadows (darkest pixels).

       <b>rm</b>
       <b>gm</b>
       <b>bm</b>  Adjust red, green and blue midtones (medium pixels).

       <b>rh</b>
       <b>gh</b>
       <b>bh</b>  Adjust red, green and blue highlights (brightest pixels).

           Allowed ranges for options are "[-1.0, 1.0]". Defaults are 0.

       <b>pl</b>  Preserve lightness when changing color balance. Default is disabled.

       <u>Examples</u>

       •   Add red color cast to shadows:

                   colorbalance=rs=.3

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>colorcontrast</b>
       Adjust color contrast between RGB components.

       The filter accepts the following options:

       <b>rc</b>  Set the red-cyan contrast. Defaults is 0.0. Allowed range is from -1.0 to 1.0.

       <b>gm</b>  Set the green-magenta contrast. Defaults is 0.0. Allowed range is from -1.0 to 1.0.

       <b>by</b>  Set the blue-yellow contrast. Defaults is 0.0. Allowed range is from -1.0 to 1.0.

       <b>rcw</b>
       <b>gmw</b>
       <b>byw</b> Set  the  weight  of each "rc", "gm", "by" option value. Default value is 0.0.  Allowed range is from
           0.0 to 1.0. If all weights are 0.0 filtering is disabled.

       <b>pl</b>  Set the amount of preserving lightness. Default value is 0.0. Allowed range is from 0.0 to 1.0.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>colorcorrect</b>
       Adjust color white balance selectively for blacks and whites.  This filter operates in YUV colorspace.

       The filter accepts the following options:

       <b>rl</b>  Set the red shadow spot. Allowed range is from -1.0 to 1.0.  Default value is 0.

       <b>bl</b>  Set the blue shadow spot. Allowed range is from -1.0 to 1.0.  Default value is 0.

       <b>rh</b>  Set the red highlight spot. Allowed range is from -1.0 to 1.0.  Default value is 0.

       <b>bh</b>  Set the blue highlight spot. Allowed range is from -1.0 to 1.0.  Default value is 0.

       <b>saturation</b>
           Set the amount of saturation. Allowed range is from -3.0 to 3.0.  Default value is 1.

       <b>analyze</b>
           If set to anything other than "manual" it will analyze every frame and  use  derived  parameters  for
           filtering output frame.

           Possible values are:

           <b>manual</b>
           <b>average</b>
           <b>minmax</b>
           <b>median</b>

           Default value is "manual".

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>colorchannelmixer</b>
       Adjust video input frames by re-mixing color channels.

       This  filter  modifies  a color channel by adding the values associated to the other channels of the same
       pixels. For example if the value to modify is red, the output value will be:

               &lt;red&gt;=&lt;red&gt;*&lt;rr&gt; + &lt;blue&gt;*&lt;rb&gt; + &lt;green&gt;*&lt;rg&gt; + &lt;alpha&gt;*&lt;ra&gt;

       The filter accepts the following options:

       <b>rr</b>
       <b>rg</b>
       <b>rb</b>
       <b>ra</b>  Adjust contribution of input red, green, blue and alpha channels for output red channel.  Default  is
           1 for <u>rr</u>, and 0 for <u>rg</u>, <u>rb</u> and <u>ra</u>.

       <b>gr</b>
       <b>gg</b>
       <b>gb</b>
       <b>ga</b>  Adjust  contribution  of input red, green, blue and alpha channels for output green channel.  Default
           is 1 for <u>gg</u>, and 0 for <u>gr</u>, <u>gb</u> and <u>ga</u>.

       <b>br</b>
       <b>bg</b>
       <b>bb</b>
       <b>ba</b>  Adjust contribution of input red, green, blue and alpha channels for output blue channel.  Default is
           1 for <u>bb</u>, and 0 for <u>br</u>, <u>bg</u> and <u>ba</u>.

       <b>ar</b>
       <b>ag</b>
       <b>ab</b>
       <b>aa</b>  Adjust contribution of input red, green, blue and alpha channels for output alpha  channel.   Default
           is 1 for <u>aa</u>, and 0 for <u>ar</u>, <u>ag</u> and <u>ab</u>.

           Allowed ranges for options are "[-2.0, 2.0]".

       <b>pc</b>  Set preserve color mode. The accepted values are:

           <b>none</b>
               Disable color preserving, this is default.

           <b>lum</b> Preserve luminance.

           <b>max</b> Preserve max value of RGB triplet.

           <b>avg</b> Preserve average value of RGB triplet.

           <b>sum</b> Preserve sum value of RGB triplet.

           <b>nrm</b> Preserve normalized value of RGB triplet.

           <b>pwr</b> Preserve power value of RGB triplet.

       <b>pa</b>  Set  the  preserve color amount when changing colors. Allowed range is from "[0.0, 1.0]".  Default is
           0.0, thus disabled.

       <u>Examples</u>

       •   Convert source to grayscale:

                   colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3

       •   Simulate sepia tones:

                   colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>colorize</b>
       Overlay a solid color on the video stream.

       The filter accepts the following options:

       <b>hue</b> Set the color hue. Allowed range is from 0 to 360.  Default value is 0.

       <b>saturation</b>
           Set the color saturation. Allowed range is from 0 to 1.  Default value is 0.5.

       <b>lightness</b>
           Set the color lightness. Allowed range is from 0 to 1.  Default value is 0.5.

       <b>mix</b> Set the mix of source lightness. By default is set to 1.0.  Allowed range is from 0.0 to 1.0.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>colorkey</b>
       RGB colorspace color keying.  This filter operates on 8-bit  RGB  format  frames  by  setting  the  alpha
       component  of  each pixel which falls within the similarity radius of the key color to 0. The alpha value
       for pixels outside the similarity radius depends on the value of the blend option.

       The filter accepts the following options:

       <b>color</b>
           Set the color for which alpha will be set to 0 (full  transparency).   See  <b>"Color"</b>  <b>section</b>  <b>in</b>  <b>the</b>
           <b>ffmpeg-utils</b> <b>manual</b>.  Default is "black".

       <b>similarity</b>
           Set  the  radius  from  the  key  color  within  which other colors also have full transparency.  The
           computed distance is related to the unit fractional distance in 3D space between the  RGB  values  of
           the  key  color  and the pixel's color. Range is 0.01 to 1.0. 0.01 matches within a very small radius
           around the exact key color, while 1.0 matches everything.  Default is 0.01.

       <b>blend</b>
           Set how the alpha value for pixels that fall outside the similarity radius is  computed.   0.0  makes
           pixels  either  fully  transparent or fully opaque.  Higher values result in semi-transparent pixels,
           with greater transparency the more similar the pixel color is to the key color.  Range is 0.0 to 1.0.
           Default is 0.0.

       <u>Examples</u>

       •   Make every green pixel in the input image transparent:

                   ffmpeg -i input.png -vf colorkey=green out.png

       •   Overlay a greenscreen-video on top of a static background image.

                   ffmpeg -i background.png -i video.mp4 -filter_complex "[1:v]colorkey=0x3BBD1E:0.3:0.2[ckout];[0:v][ckout]overlay[out]" -map "[out]" output.flv

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.  The command accepts the same syntax of the  corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>colorhold</b>
       Remove all color information for all RGB colors except for certain one.

       The filter accepts the following options:

       <b>color</b>
           The color which will not be replaced with neutral gray.

       <b>similarity</b>
           Similarity percentage with the above color.  0.01 matches only the exact key color, while 1.0 matches
           everything.

       <b>blend</b>
           Blend percentage. 0.0 makes pixels fully gray.  Higher values result in more preserved color.

       <u>Commands</u>

       This  filter supports same <b>commands</b> as options.  The command accepts the same syntax of the corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>colorlevels</b>
       Adjust video input frames using levels.

       The filter accepts the following options:

       <b>rimin</b>
       <b>gimin</b>
       <b>bimin</b>
       <b>aimin</b>
           Adjust red, green, blue and alpha input black point.  Allowed ranges for options are  "[-1.0,  1.0]".
           Defaults are 0.

       <b>rimax</b>
       <b>gimax</b>
       <b>bimax</b>
       <b>aimax</b>
           Adjust  red,  green, blue and alpha input white point.  Allowed ranges for options are "[-1.0, 1.0]".
           Defaults are 1.

           Input levels are used to lighten highlights (bright tones), darken shadows (dark tones),  change  the
           balance of bright and dark tones.

       <b>romin</b>
       <b>gomin</b>
       <b>bomin</b>
       <b>aomin</b>
           Adjust  red,  green,  blue  and alpha output black point.  Allowed ranges for options are "[0, 1.0]".
           Defaults are 0.

       <b>romax</b>
       <b>gomax</b>
       <b>bomax</b>
       <b>aomax</b>
           Adjust red, green, blue and alpha output white point.  Allowed ranges for  options  are  "[0,  1.0]".
           Defaults are 1.

           Output levels allows manual selection of a constrained output level range.

       <b>preserve</b>
           Set preserve color mode. The accepted values are:

           <b>none</b>
               Disable color preserving, this is default.

           <b>lum</b> Preserve luminance.

           <b>max</b> Preserve max value of RGB triplet.

           <b>avg</b> Preserve average value of RGB triplet.

           <b>sum</b> Preserve sum value of RGB triplet.

           <b>nrm</b> Preserve normalized value of RGB triplet.

           <b>pwr</b> Preserve power value of RGB triplet.

       <u>Examples</u>

       •   Make video output darker:

                   colorlevels=rimin=0.058:gimin=0.058:bimin=0.058

       •   Increase contrast:

                   colorlevels=rimin=0.039:gimin=0.039:bimin=0.039:rimax=0.96:gimax=0.96:bimax=0.96

       •   Make video output lighter:

                   colorlevels=rimax=0.902:gimax=0.902:bimax=0.902

       •   Increase brightness:

                   colorlevels=romin=0.5:gomin=0.5:bomin=0.5

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>colormap</b>
       Apply custom color maps to video stream.

       This  filter  needs three input video streams.  First stream is video stream that is going to be filtered
       out.  Second and third video stream specify color patches for source color to target color mapping.

       The filter accepts the following options:

       <b>patch_size</b>
           Set the source and target video stream patch size in pixels.

       <b>nb_patches</b>
           Set the max number of used patches from source and target video stream.  Default value is  number  of
           patches available in additional video streams.  Max allowed number of patches is 64.

       <b>type</b>
           Set the adjustments used for target colors. Can be "relative" or "absolute".  Defaults is "absolute".

       <b>kernel</b>
           Set the kernel used to measure color differences between mapped colors.

           The accepted values are:

           <b>euclidean</b>
           <b>weuclidean</b>

           Default is "euclidean".

   <b>colormatrix</b>
       Convert color matrix.

       The filter accepts the following options:

       <b>src</b>
       <b>dst</b> Specify the source and destination color matrix. Both values must be specified.

           The accepted values are:

           <b>bt709</b>
               BT.709

           <b>fcc</b> FCC

           <b>bt601</b>
               BT.601

           <b>bt470</b>
               BT.470

           <b>bt470bg</b>
               BT.470BG

           <b>smpte170m</b>
               SMPTE-170M

           <b>smpte240m</b>
               SMPTE-240M

           <b>bt2020</b>
               BT.2020

       For example to convert from BT.601 to SMPTE-240M, use the command:

               colormatrix=bt601:smpte240m

   <b>colorspace</b>
       Convert colorspace, transfer characteristics or color primaries.  Input video needs to have an even size.

       The filter accepts the following options:

       <b>all</b> Specify all color properties at once.

           The accepted values are:

           <b>bt470m</b>
               BT.470M

           <b>bt470bg</b>
               BT.470BG

           <b>bt601-6-525</b>
               BT.601-6 525

           <b>bt601-6-625</b>
               BT.601-6 625

           <b>bt709</b>
               BT.709

           <b>smpte170m</b>
               SMPTE-170M

           <b>smpte240m</b>
               SMPTE-240M

           <b>bt2020</b>
               BT.2020

       <b>space</b>
           Specify output colorspace.

           The accepted values are:

           <b>bt709</b>
               BT.709

           <b>fcc</b> FCC

           <b>bt470bg</b>
               BT.470BG or BT.601-6 625

           <b>smpte170m</b>
               SMPTE-170M or BT.601-6 525

           <b>smpte240m</b>
               SMPTE-240M

           <b>ycgco</b>
               YCgCo

           <b>bt2020ncl</b>
               BT.2020 with non-constant luminance

       <b>trc</b> Specify output transfer characteristics.

           The accepted values are:

           <b>bt709</b>
               BT.709

           <b>bt470m</b>
               BT.470M

           <b>bt470bg</b>
               BT.470BG

           <b>gamma22</b>
               Constant gamma of 2.2

           <b>gamma28</b>
               Constant gamma of 2.8

           <b>smpte170m</b>
               SMPTE-170M, BT.601-6 625 or BT.601-6 525

           <b>smpte240m</b>
               SMPTE-240M

           <b>srgb</b>
               SRGB

           <b>iec61966-2-1</b>
               iec61966-2-1

           <b>iec61966-2-4</b>
               iec61966-2-4

           <b>xvycc</b>
               xvycc

           <b>bt2020-10</b>
               BT.2020 for 10-bits content

           <b>bt2020-12</b>
               BT.2020 for 12-bits content

       <b>primaries</b>
           Specify output color primaries.

           The accepted values are:

           <b>bt709</b>
               BT.709

           <b>bt470m</b>
               BT.470M

           <b>bt470bg</b>
               BT.470BG or BT.601-6 625

           <b>smpte170m</b>
               SMPTE-170M or BT.601-6 525

           <b>smpte240m</b>
               SMPTE-240M

           <b>film</b>
               film

           <b>smpte431</b>
               SMPTE-431

           <b>smpte432</b>
               SMPTE-432

           <b>bt2020</b>
               BT.2020

           <b>jedec-p22</b>
               JEDEC P22 phosphors

       <b>range</b>
           Specify output color range.

           The accepted values are:

           <b>tv</b>  TV (restricted) range

           <b>mpeg</b>
               MPEG (restricted) range

           <b>pc</b>  PC (full) range

           <b>jpeg</b>
               JPEG (full) range

       <b>format</b>
           Specify output color format.

           The accepted values are:

           <b>yuv420p</b>
               YUV 4:2:0 planar 8-bits

           <b>yuv420p10</b>
               YUV 4:2:0 planar 10-bits

           <b>yuv420p12</b>
               YUV 4:2:0 planar 12-bits

           <b>yuv422p</b>
               YUV 4:2:2 planar 8-bits

           <b>yuv422p10</b>
               YUV 4:2:2 planar 10-bits

           <b>yuv422p12</b>
               YUV 4:2:2 planar 12-bits

           <b>yuv444p</b>
               YUV 4:4:4 planar 8-bits

           <b>yuv444p10</b>
               YUV 4:4:4 planar 10-bits

           <b>yuv444p12</b>
               YUV 4:4:4 planar 12-bits

       <b>fast</b>
           Do  a  fast  conversion, which skips gamma/primary correction. This will take significantly less CPU,
           but will be mathematically incorrect. To get output compatible with that produced by the  colormatrix
           filter, use fast=1.

       <b>dither</b>
           Specify dithering mode.

           The accepted values are:

           <b>none</b>
               No dithering

           <b>fsb</b> Floyd-Steinberg dithering

       <b>wpadapt</b>
           Whitepoint adaptation mode.

           The accepted values are:

           <b>bradford</b>
               Bradford whitepoint adaptation

           <b>vonkries</b>
               von Kries whitepoint adaptation

           <b>identity</b>
               identity whitepoint adaptation (i.e. no whitepoint adaptation)

       <b>iall</b>
           Override all input properties at once. Same accepted values as <b>all</b>.

       <b>ispace</b>
           Override input colorspace. Same accepted values as <b>space</b>.

       <b>iprimaries</b>
           Override input color primaries. Same accepted values as <b>primaries</b>.

       <b>itrc</b>
           Override input transfer characteristics. Same accepted values as <b>trc</b>.

       <b>irange</b>
           Override input color range. Same accepted values as <b>range</b>.

       The  filter  converts the transfer characteristics, color space and color primaries to the specified user
       values. The output value, if not specified, is set to a default value based on  the  "all"  property.  If
       that  property  is  also  not  specified, the filter will log an error. The output color range and format
       default to the same value as the input color range and format. The input transfer characteristics,  color
       space,  color primaries and color range should be set on the input data. If any of these are missing, the
       filter will log an error and no conversion will take place.

       For example to convert the input to SMPTE-240M, use the command:

               colorspace=smpte240m

   <b>colorspace_cuda</b>
       CUDA accelerated implementation of the colorspace filter.

       It is by no means feature complete compared to the software colorspace filter, and at  the  current  time
       only supports color range conversion between jpeg/full and mpeg/limited range.

       The filter accepts the following options:

       <b>range</b>
           Specify output color range.

           The accepted values are:

           <b>tv</b>  TV (restricted) range

           <b>mpeg</b>
               MPEG (restricted) range

           <b>pc</b>  PC (full) range

           <b>jpeg</b>
               JPEG (full) range

   <b>colortemperature</b>
       Adjust color temperature in video to simulate variations in ambient color temperature.

       The filter accepts the following options:

       <b>temperature</b>
           Set the temperature in Kelvin. Allowed range is from 1000 to 40000.  Default value is 6500 K.

       <b>mix</b> Set mixing with filtered output. Allowed range is from 0 to 1.  Default value is 1.

       <b>pl</b>  Set the amount of preserving lightness. Allowed range is from 0 to 1.  Default value is 0.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>convolution</b>
       Apply convolution of 3x3, 5x5, 7x7 or horizontal/vertical up to 49 elements.

       The filter accepts the following options:

       <b>0m</b>
       <b>1m</b>
       <b>2m</b>
       <b>3m</b>  Set  matrix  for  each  plane.  Matrix is sequence of 9, 25 or 49 signed integers in <u>square</u> mode, and
           from 1 to 49 odd number of signed integers in <u>row</u> mode.

       <b>0rdiv</b>
       <b>1rdiv</b>
       <b>2rdiv</b>
       <b>3rdiv</b>
           Set multiplier for calculated value for each plane.  If unset or 0, it will be 1/sum  of  all  matrix
           elements.

       <b>0bias</b>
       <b>1bias</b>
       <b>2bias</b>
       <b>3bias</b>
           Set  bias for each plane. This value is added to the result of the multiplication.  Useful for making
           the overall image brighter or darker. Default is 0.0.

       <b>0mode</b>
       <b>1mode</b>
       <b>2mode</b>
       <b>3mode</b>
           Set matrix mode for each plane. Can be <u>square</u>, <u>row</u> or <u>column</u>.  Default is <u>square</u>.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

       <u>Examples</u>

       •   Apply sharpen:

                   convolution="0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1 5 -1 0 -1 0"

       •   Apply blur:

                   convolution="1 1 1 1 1 1 1 1 1:1 1 1 1 1 1 1 1 1:1 1 1 1 1 1 1 1 1:1 1 1 1 1 1 1 1 1:1/9:1/9:1/9:1/9"

       •   Apply edge enhance:

                   convolution="0 0 0 -1 1 0 0 0 0:0 0 0 -1 1 0 0 0 0:0 0 0 -1 1 0 0 0 0:0 0 0 -1 1 0 0 0 0:5:1:1:1:0:128:128:128"

       •   Apply edge detect:

                   convolution="0 1 0 1 -4 1 0 1 0:0 1 0 1 -4 1 0 1 0:0 1 0 1 -4 1 0 1 0:0 1 0 1 -4 1 0 1 0:5:5:5:1:0:128:128:128"

       •   Apply laplacian edge detector which includes diagonals:

                   convolution="1 1 1 1 -8 1 1 1 1:1 1 1 1 -8 1 1 1 1:1 1 1 1 -8 1 1 1 1:1 1 1 1 -8 1 1 1 1:5:5:5:1:0:128:128:0"

       •   Apply emboss:

                   convolution="-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2"

   <b>convolve</b>
       Apply 2D convolution of video stream in frequency domain using second stream as impulse.

       The filter accepts the following options:

       <b>planes</b>
           Set which planes to process.

       <b>impulse</b>
           Set which impulse video frames will be processed, can be <u>first</u> or <u>all</u>. Default is <u>all</u>.

       The "convolve" filter also supports the <b>framesync</b> options.

   <b>copy</b>
       Copy the input video source unchanged to the output. This is mainly useful for testing purposes.

   <b>coreimage</b>
       Video filtering on GPU using Apple's CoreImage API on OSX.

       Hardware acceleration is based on an OpenGL context.  Usually,  this  means  it  is  processed  by  video
       hardware.  However,  software-based  OpenGL  implementations  exist which means there is no guarantee for
       hardware processing. It depends on the respective OSX.

       There are many filters and image generators provided by Apple that come with a large variety of  options.
       The filter has to be referenced by its name along with its options.

       The coreimage filter accepts the following options:

       <b>list_filters</b>
           List all available filters and generators along with all their respective options as well as possible
           minimum and maximum values along with the default values.

                   list_filters=true

       <b>filter</b>
           Specify  all  filters  by their respective name and options.  Use <u>list_filters</u> to determine all valid
           filter names and options.  Numerical options are specified by a float  value  and  are  automatically
           clamped  to their respective value range.  Vector and color options have to be specified by a list of
           space separated float values. Character escaping has to be done.  A special option name "default"  is
           available to use default options for a filter.

           It  is  required  to  specify  either  "default"  or at least one of the filter options.  All omitted
           options are used with their default values.  The syntax of the filter string is as follows:

                   filter=&lt;NAME&gt;@&lt;OPTION&gt;=&lt;VALUE&gt;[@&lt;OPTION&gt;=&lt;VALUE&gt;][@...][#&lt;NAME&gt;@&lt;OPTION&gt;=&lt;VALUE&gt;[@&lt;OPTION&gt;=&lt;VALUE&gt;][@...]][#...]

       <b>output_rect</b>
           Specify a rectangle where the output of the filter chain is copied into the input image. It is  given
           by a list of space separated float values:

                   output_rect=x\ y\ width\ height

           If not given, the output rectangle equals the dimensions of the input image.  The output rectangle is
           automatically  cropped  at  the  borders  of  the  input  image.  Negative  values are valid for each
           component.

                   output_rect=25\ 25\ 100\ 100

       Several filters can be chained for successive processing without GPU-HOST  transfers  allowing  for  fast
       processing  of  complex  filter  chains.   Currently,  only filters with zero (generators) or exactly one
       (filters) input image and one output image are supported. Also, transition filters are not yet usable  as
       intended.

       Some  filters  generate  output images with additional padding depending on the respective filter kernel.
       The padding is automatically removed to ensure the filter output has the same size as the input image.

       For image generators, the size of the output image is determined by the  previous  output  image  of  the
       filter  chain  or  the  input image of the whole filterchain, respectively. The generators do not use the
       pixel information of this image to generate their output. However, the generated output is  blended  onto
       this image, resulting in partial or complete coverage of the output image.

       The  <b>coreimagesrc</b>  video  source  can be used for generating input images which are directly fed into the
       filter chain. By using it, providing input images by another video  source  or  an  input  video  is  not
       required.

       <u>Examples</u>

       •   List all filters available:

                   coreimage=list_filters=true

       •   Use the CIBoxBlur filter with default options to blur an image:

                   coreimage=filter=CIBoxBlur@default

       •   Use a filter chain with CISepiaTone at default values and CIVignetteEffect with its center at 100x100
           and a radius of 50 pixels:

                   coreimage=filter=CIBoxBlur@default#CIVignetteEffect@inputCenter=100\ 100@inputRadius=50

       •   Use  nullsrc and CIQRCodeGenerator to create a QR code for the FFmpeg homepage, given as complete and
           escaped command-line for Apple's standard bash shell:

                   ffmpeg -f lavfi -i nullsrc=s=100x100,coreimage=filter=CIQRCodeGenerator@inputMessage=https\\\\\://FFmpeg.org/@inputCorrectionLevel=H -frames:v 1 QRCode.png

   <b>corr</b>
       Obtain the correlation between two input videos.

       This filter takes two input videos.

       Both input videos must have the same resolution and pixel format for this filter to work correctly.  Also
       it assumes that both inputs have the same number of frames, which are compared one by one.

       The obtained per component, average, min and max correlation is printed through the logging system.

       The filter stores the calculated correlation of each frame in frame metadata.

       This filter also supports the <b>framesync</b> options.

       In the below example the input file <u>main.mpg</u> being processed is compared with the reference file <u>ref.mpg</u>.

               ffmpeg -i main.mpg -i ref.mpg -lavfi corr -f null -

   <b>cover_rect</b>
       Cover a rectangular object

       It accepts the following options:

       <b>cover</b>
           Filepath of the optional cover image, needs to be in yuv420.

       <b>mode</b>
           Set covering mode.

           It accepts the following values:

           <b>cover</b>
               cover it by the supplied image

           <b>blur</b>
               cover it by interpolating the surrounding pixels

           Default value is <u>blur</u>.

       <u>Examples</u>

       •   Cover a rectangular object by the supplied image of a given video using <b>ffmpeg</b>:

                   ffmpeg -i file.ts -vf find_rect=newref.pgm,cover_rect=cover.jpg:mode=cover new.mkv

   <b>crop</b>
       Crop the input video to given dimensions.

       It accepts the following parameters:

       <b>w,</b> <b>out_w</b>
           The  width  of  the output video. It defaults to "iw".  This expression is evaluated only once during
           the filter configuration, or when the <b>w</b> or <b>out_w</b> command is sent.

       <b>h,</b> <b>out_h</b>
           The height of the output video. It defaults to "ih".  This expression is evaluated only  once  during
           the filter configuration, or when the <b>h</b> or <b>out_h</b> command is sent.

       <b>x</b>   The  horizontal  position,  in  the input video, of the left edge of the output video. It defaults to
           "(in_w-out_w)/2".  This expression is evaluated per-frame.

       <b>y</b>   The vertical position, in the input video, of the top edge of  the  output  video.   It  defaults  to
           "(in_h-out_h)/2".  This expression is evaluated per-frame.

       <b>keep_aspect</b>
           If  set  to 1 will force the output display aspect ratio to be the same of the input, by changing the
           output sample aspect ratio. It defaults to 0.

       <b>exact</b>
           Enable exact cropping. If enabled, subsampled videos will be cropped  at  exact  width/height/x/y  as
           specified and will not be rounded to nearest smaller value.  It defaults to 0.

       The <u>out_w</u>, <u>out_h</u>, <u>x</u>, <u>y</u> parameters are expressions containing the following constants:

       <b>x</b>
       <b>y</b>   The computed values for <u>x</u> and <u>y</u>. They are evaluated for each new frame.

       <b>in_w</b>
       <b>in_h</b>
           The input width and height.

       <b>iw</b>
       <b>ih</b>  These are the same as <u>in_w</u> and <u>in_h</u>.

       <b>out_w</b>
       <b>out_h</b>
           The output (cropped) width and height.

       <b>ow</b>
       <b>oh</b>  These are the same as <u>out_w</u> and <u>out_h</u>.

       <b>a</b>   same as <u>iw</u> / <u>ih</u>

       <b>sar</b> input sample aspect ratio

       <b>dar</b> input display aspect ratio, it is the same as (<u>iw</u> / <u>ih</u>) * <u>sar</u>

       <b>hsub</b>
       <b>vsub</b>
           horizontal and vertical chroma subsample values. For example for the pixel format "yuv422p" <u>hsub</u> is 2
           and <u>vsub</u> is 1.

       <b>n</b>   The number of the input frame, starting from 0.

       <b>pos</b> the position in the file of the input frame, NAN if unknown; deprecated, do not use

       <b>t</b>   The timestamp expressed in seconds. It's NAN if the input timestamp is unknown.

       The  expression  for  <u>out_w</u>  may depend on the value of <u>out_h</u>, and the expression for <u>out_h</u> may depend on
       <u>out_w</u>, but they cannot depend on <u>x</u> and <u>y</u>, as <u>x</u> and <u>y</u> are evaluated after <u>out_w</u> and <u>out_h</u>.

       The <u>x</u> and <u>y</u> parameters specify the expressions for the position of the  top-left  corner  of  the  output
       (non-cropped)  area.  They  are  evaluated  for  each  frame.  If the evaluated value is not valid, it is
       approximated to the nearest valid value.

       The expression for <u>x</u> may depend on <u>y</u>, and the expression for <u>y</u> may depend on <u>x</u>.

       <u>Examples</u>

       •   Crop area with size 100x100 at position (12,34).

                   crop=100:100:12:34

           Using named options, the example above becomes:

                   crop=w=100:h=100:x=12:y=34

       •   Crop the central input area with size 100x100:

                   crop=100:100

       •   Crop the central input area with size 2/3 of the input video:

                   crop=2/3*in_w:2/3*in_h

       •   Crop the input video central square:

                   crop=out_w=in_h
                   crop=in_h

       •   Delimit the rectangle with the top-left corner placed at position 100:100 and the right-bottom corner
           corresponding to the right-bottom corner of the input image.

                   crop=in_w-100:in_h-100:100:100

       •   Crop 10 pixels from the left and right borders, and 20 pixels from the top and bottom borders

                   crop=in_w-2*10:in_h-2*20

       •   Keep only the bottom right quarter of the input image:

                   crop=in_w/2:in_h/2:in_w/2:in_h/2

       •   Crop height for getting Greek harmony:

                   crop=in_w:1/PHI*in_w

       •   Apply trembling effect:

                   crop=in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2 +((in_h-out_h)/2)*sin(n/7)

       •   Apply erratic camera effect depending on timestamp:

                   crop=in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(t*10):(in_h-out_h)/2 +((in_h-out_h)/2)*sin(t*13)

       •   Set x depending on the value of y:

                   crop=in_w/2:in_h/2:y:10+10*sin(n/10)

       <u>Commands</u>

       This filter supports the following commands:

       <b>w,</b> <b>out_w</b>
       <b>h,</b> <b>out_h</b>
       <b>x</b>
       <b>y</b>   Set width/height of the output video and the horizontal/vertical position in the  input  video.   The
           command accepts the same syntax of the corresponding option.

           If the specified expression is not valid, it is kept at its current value.

   <b>cropdetect</b>
       Auto-detect the crop size.

       It  calculates  the  necessary  cropping parameters and prints the recommended parameters via the logging
       system. The detected dimensions correspond to the non-black or video area of the input video according to
       <u>mode</u>.

       It accepts the following parameters:

       <b>mode</b>
           Depending on <u>mode</u> crop detection is based on either the mere black value of surrounding pixels  or  a
           combination of motion vectors and edge pixels.

           <b>black</b>
               Detect black pixels surrounding the playing video. For fine control use option <u>limit</u>.

           <b>mvedges</b>
               Detect  the  playing  video  by  the motion vectors inside the video and scanning for edge pixels
               typically forming the border of a playing video.

       <b>limit</b>
           Set higher black value threshold, which can be optionally specified from nothing  (0)  to  everything
           (255  for  8-bit based formats). An intensity value greater to the set value is considered non-black.
           It defaults to 24.  You can also specify a value between 0.0 and 1.0 which will be  scaled  depending
           on the bitdepth of the pixel format.

       <b>round</b>
           The  value  which  the  width/height  should  be  divisible  by.  It  defaults  to  16. The offset is
           automatically adjusted to center the video. Use 2 to get  only  even  dimensions  (needed  for  4:2:2
           video). 16 is best when encoding to most video codecs.

       <b>skip</b>
           Set  the  number  of  initial  frames  for  which evaluation is skipped.  Default is 2. Range is 0 to
           INT_MAX.

       <b>reset_count,</b> <b>reset</b>
           Set the counter that determines after how many frames cropdetect will reset the  previously  detected
           largest video area and start over to detect the current optimal crop area. Default value is 0.

           This  can be useful when channel logos distort the video area. 0 indicates 'never reset', and returns
           the largest area encountered during playback.

       <b>mv_threshold</b>
           Set motion in pixel units as threshold for motion detection. It defaults to 8.

       <b>low</b>
       <b>high</b>
           Set low and high threshold values used by the Canny thresholding algorithm.

           The high threshold selects the "strong" edge pixels, which are then connected through  8-connectivity
           with the "weak" edge pixels selected by the low threshold.

           <u>low</u> and <u>high</u> threshold values must be chosen in the range [0,1], and <u>low</u> should be lesser or equal to
           <u>high</u>.

           Default value for <u>low</u> is "5/255", and default value for <u>high</u> is "15/255".

       <u>Examples</u>

       •   Find video area surrounded by black borders:

                   ffmpeg -i file.mp4 -vf cropdetect,metadata=mode=print -f null -

       •   Find an embedded video area, generate motion vectors beforehand:

                   ffmpeg -i file.mp4 -vf mestimate,cropdetect=mode=mvedges,metadata=mode=print -f null -

       •   Find an embedded video area, use motion vectors from decoder:

                   ffmpeg -flags2 +export_mvs -i file.mp4 -vf cropdetect=mode=mvedges,metadata=mode=print -f null -

       <u>Commands</u>

       This filter supports the following commands:

       <b>limit</b>
           The  command accepts the same syntax of the corresponding option.  If the specified expression is not
           valid, it is kept at its current value.

   <b>cue</b>
       Delay video filtering until a given wallclock timestamp. The filter first passes  on  <b>preroll</b>  amount  of
       frames,  then it buffers at most <b>buffer</b> amount of frames and waits for the cue. After reaching the cue it
       forwards the buffered frames and also any subsequent frames coming in its input.

       The filter can be used synchronize the output of multiple ffmpeg processes for  realtime  output  devices
       like  decklink. By putting the delay in the filtering chain and pre-buffering frames the process can pass
       on data to output almost immediately after the target wallclock timestamp is reached.

       Perfect frame accuracy cannot be guaranteed, but the result is good enough for some use cases.

       <b>cue</b> The cue timestamp expressed in a UNIX timestamp in microseconds. Default is 0.

       <b>preroll</b>
           The duration of content to pass on as preroll expressed in seconds. Default is 0.

       <b>buffer</b>
           The maximum duration of content to buffer before waiting for the cue expressed in seconds. Default is
           0.

   <b>curves</b>
       Apply color adjustments using curves.

       This filter is similar to the Adobe Photoshop and GIMP curves tools. Each component (red, green and blue)
       has its values defined by <u>N</u> key points tied from each other using a smooth curve. The  x-axis  represents
       the  pixel  values  from  the  input  frame, and the y-axis the new pixel values to be set for the output
       frame.

       By default, a component curve is defined by the two points <u>(0;0)</u> and <u>(1;1)</u>. This creates a straight  line
       where each original pixel value is "adjusted" to its own value, which means no change to the image.

       The filter allows you to redefine these two points and add some more. A new curve will be defined to pass
       smoothly  through  all  these new coordinates. The new defined points need to be strictly increasing over
       the x-axis, and their <u>x</u> and <u>y</u> values must be in the <u>[0;1]</u> interval.  The  curve  is  formed  by  using  a
       natural or monotonic cubic spline interpolation, depending on the <u>interp</u> option (default: "natural"). The
       "natural" spline produces a smoother curve in general while the monotonic ("pchip") spline guarantees the
       transitions  between  the specified points to be monotonic. If the computed curves happened to go outside
       the vector spaces, the values will be clipped accordingly.

       The filter accepts the following options:

       <b>preset</b>
           Select one of the available color presets. This option can be  used  in  addition  to  the  <b>r</b>,  <b>g</b>,  <b>b</b>
           parameters;  in  this case, the later options takes priority on the preset values.  Available presets
           are:

           <b>none</b>
           <b>color_negative</b>
           <b>cross_process</b>
           <b>darker</b>
           <b>increase_contrast</b>
           <b>lighter</b>
           <b>linear_contrast</b>
           <b>medium_contrast</b>
           <b>negative</b>
           <b>strong_contrast</b>
           <b>vintage</b>

           Default is "none".

       <b>master,</b> <b>m</b>
           Set the master key points. These points will define a second pass mapping. It is sometimes  called  a
           "luminance"  or  "value"  mapping.  It  can  be  used  with <b>r</b>, <b>g</b>, <b>b</b> or <b>all</b> since it acts like a post-
           processing LUT.

       <b>red,</b> <b>r</b>
           Set the key points for the red component.

       <b>green,</b> <b>g</b>
           Set the key points for the green component.

       <b>blue,</b> <b>b</b>
           Set the key points for the blue component.

       <b>all</b> Set the key points for all components (not including master).  Can be used in addition to  the  other
           key points component options. In this case, the unset component(s) will fallback on this <b>all</b> setting.

       <b>psfile</b>
           Specify a Photoshop curves file (".acv") to import the settings from.

       <b>plot</b>
           Save Gnuplot script of the curves in specified file.

       <b>interp</b>
           Specify the kind of interpolation. Available algorithms are:

           <b>natural</b>
               Natural   cubic   spline   using  a  piece-wise  cubic  polynomial  that  is  twice  continuously
               differentiable.

           <b>pchip</b>
               Monotonic cubic spline using a piecewise cubic Hermite interpolating polynomial (PCHIP).

       To avoid some filtergraph syntax conflicts, each key points list need to be defined using  the  following
       syntax: "x0/y0 x1/y1 x2/y2 ...".

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

       <u>Examples</u>

       •   Increase slightly the middle level of blue:

                   curves=blue='0/0 0.5/0.58 1/1'

       •   Vintage effect:

                   curves=r='0/0.11 .42/.51 1/0.95':g='0/0 0.50/0.48 1/1':b='0/0.22 .49/.44 1/0.8'

           Here we obtain the following coordinates for each components:

           <u>red</u> "(0;0.11) (0.42;0.51) (1;0.95)"

           <u>green</u>
               "(0;0) (0.50;0.48) (1;1)"

           <u>blue</u>
               "(0;0.22) (0.49;0.44) (1;0.80)"

       •   The previous example can also be achieved with the associated built-in preset:

                   curves=preset=vintage

       •   Or simply:

                   curves=vintage

       •   Use a Photoshop preset and redefine the points of the green component:

                   curves=psfile='MyCurvesPresets/purple.acv':green='0/0 0.45/0.53 1/1'

       •   Check out the curves of the "cross_process" profile using <b>ffmpeg</b> and <b>gnuplot</b>:

                   ffmpeg -f lavfi -i color -vf curves=cross_process:plot=/tmp/curves.plt -frames:v 1 -f null -
                   gnuplot -p /tmp/curves.plt

   <b>datascope</b>
       Video data analysis filter.

       This filter shows hexadecimal pixel values of part of video.

       The filter accepts the following options:

       <b>size,</b> <b>s</b>
           Set output video size.

       <b>x</b>   Set x offset from where to pick pixels.

       <b>y</b>   Set y offset from where to pick pixels.

       <b>mode</b>
           Set scope mode, can be one of the following:

           <b>mono</b>
               Draw hexadecimal pixel values with white color on black background.

           <b>color</b>
               Draw hexadecimal pixel values with input video pixel color on black background.

           <b>color2</b>
               Draw  hexadecimal  pixel  values  on  color background picked from input video, the text color is
               picked in such way so its always visible.

       <b>axis</b>
           Draw rows and columns numbers on left and top of video.

       <b>opacity</b>
           Set background opacity.

       <b>format</b>
           Set display number format. Can be "hex", or "dec". Default is "hex".

       <b>components</b>
           Set pixel components to display. By default all pixel components are displayed.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options excluding "size" option.

   <b>dblur</b>
       Apply Directional blur filter.

       The filter accepts the following options:

       <b>angle</b>
           Set angle of directional blur. Default is 45.

       <b>radius</b>
           Set radius of directional blur. Default is 5.

       <b>planes</b>
           Set which planes to filter. By default all planes are filtered.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.  The command accepts the same syntax of the  corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>dctdnoiz</b>
       Denoise frames using 2D DCT (frequency domain filtering).

       This filter is not designed for real time.

       The filter accepts the following options:

       <b>sigma,</b> <b>s</b>
           Set the noise sigma constant.

           This <u>sigma</u> defines a hard threshold of "3 * sigma"; every DCT coefficient (absolute value) below this
           threshold with be dropped.

           If you need a more advanced filtering, see <b>expr</b>.

           Default is 0.

       <b>overlap</b>
           Set  number  overlapping  pixels for each block. Since the filter can be slow, you may want to reduce
           this value, at the cost of a less effective filter and the risk of various artefacts.

           If the overlapping value doesn't permit processing the whole input width or height, a warning will be
           displayed and according borders won't be denoised.

           Default value is <u>blocksize</u>-1, which is the best possible setting.

       <b>expr,</b> <b>e</b>
           Set the coefficient factor expression.

           For each coefficient of a DCT block, this expression will be evaluated as a multiplier value for  the
           coefficient.

           If this is option is set, the <b>sigma</b> option will be ignored.

           The absolute value of the coefficient can be accessed through the <u>c</u> variable.

       <b>n</b>   Set  the  <u>blocksize</u>  using  the  number of bits. "1&lt;&lt;<u>n</u>" defines the <u>blocksize</u>, which is the width and
           height of the processed blocks.

           The default value is <u>3</u> (8x8) and can be raised to <u>4</u> for a <u>blocksize</u> of 16x16. Note that changing this
           setting has huge consequences on the speed processing. Also, a larger block size does not necessarily
           means a better de-noising.

       <u>Examples</u>

       Apply a denoise with a <b>sigma</b> of 4.5:

               dctdnoiz=4.5

       The same operation can be achieved using the expression system:

               dctdnoiz=e='gte(c, 4.5*3)'

       Violent denoise using a block size of "16x16":

               dctdnoiz=15:n=4

   <b>deband</b>
       Remove banding artifacts from input video.  It works by replacing banded pixels  with  average  value  of
       referenced pixels.

       The filter accepts the following options:

       <b>1thr</b>
       <b>2thr</b>
       <b>3thr</b>
       <b>4thr</b>
           Set  banding detection threshold for each plane. Default is 0.02.  Valid range is 0.00003 to 0.5.  If
           difference between current pixel and reference pixel is less than threshold, it will be considered as
           banded.

       <b>range,</b> <b>r</b>
           Banding detection range in pixels. Default is 16. If positive, random number in range 0 to set  value
           will  be  used.  If  negative,  exact  absolute value will be used.  The range defines square of four
           pixels around current pixel.

       <b>direction,</b> <b>d</b>
           Set direction in radians from which four pixel will be compared. If positive, random direction from 0
           to set direction will be picked. If negative, exact of absolute value will  be  picked.  For  example
           direction  0,  -PI or -2*PI radians will pick only pixels on same row and -PI/2 will pick only pixels
           on same column.

       <b>blur,</b> <b>b</b>
           If enabled, current pixel is compared with average value of all four surrounding pixels. The  default
           is  enabled.  If  disabled  current  pixel is compared with all four surrounding pixels. The pixel is
           considered banded if only all four differences with surrounding pixels are less than threshold.

       <b>coupling,</b> <b>c</b>
           If enabled, current pixel is changed if and only if all pixel components  are  banded,  e.g.  banding
           detection threshold is triggered for all color components.  The default is disabled.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>deblock</b>
       Remove blocking artifacts from input video.

       The filter accepts the following options:

       <b>filter</b>
           Set  filter type, can be <u>weak</u> or <u>strong</u>. Default is <u>strong</u>.  This controls what kind of deblocking is
           applied.

       <b>block</b>
           Set size of block, allowed range is from 4 to 512. Default is <u>8</u>.

       <b>alpha</b>
       <b>beta</b>
       <b>gamma</b>
       <b>delta</b>
           Set blocking detection thresholds. Allowed range is 0 to 1.  Defaults are: <u>0.098</u> for <u>alpha</u>  and  <u>0.05</u>
           for  the  rest.   Using  higher  threshold  gives  more  deblocking strength.  Setting <u>alpha</u> controls
           threshold detection at exact edge of block.  Remaining options controls threshold detection near  the
           edge. Each one for below/above or left/right. Setting any of those to <u>0</u> disables deblocking.

       <b>planes</b>
           Set planes to filter. Default is to filter all available planes.

       <u>Examples</u>

       •   Deblock using weak filter and block size of 4 pixels.

                   deblock=filter=weak:block=4

       •   Deblock using strong filter, block size of 4 pixels and custom thresholds for deblocking more edges.

                   deblock=filter=strong:block=4:alpha=0.12:beta=0.07:gamma=0.06:delta=0.05

       •   Similar as above, but filter only first plane.

                   deblock=filter=strong:block=4:alpha=0.12:beta=0.07:gamma=0.06:delta=0.05:planes=1

       •   Similar as above, but filter only second and third plane.

                   deblock=filter=strong:block=4:alpha=0.12:beta=0.07:gamma=0.06:delta=0.05:planes=6

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>decimate</b>
       Drop duplicated frames at regular intervals.

       The filter accepts the following options:

       <b>cycle</b>
           Set  the  number of frames from which one will be dropped. Setting this to <u>N</u> means one frame in every
           batch of <u>N</u> frames will be dropped.  Default is 5.

       <b>dupthresh</b>
           Set the threshold for duplicate detection. If the difference metric for a frame is less than or equal
           to this value, then it is declared as duplicate. Default is 1.1

       <b>scthresh</b>
           Set scene change threshold. Default is 15.

       <b>blockx</b>
       <b>blocky</b>
           Set the size of the x and y-axis blocks used during metric calculations.  Larger blocks  give  better
           noise  suppression, but also give worse detection of small movements. Must be a power of two. Default
           is 32.

       <b>ppsrc</b>
           Mark main input as a pre-processed input and activate clean source  input  stream.  This  allows  the
           input  to  be  pre-processed  with  various filters to help the metrics calculation while keeping the
           frame selection lossless. When set to 1, the first stream is for the  pre-processed  input,  and  the
           second stream is the clean source from where the kept frames are chosen. Default is 0.

       <b>chroma</b>
           Set whether or not chroma is considered in the metric calculations. Default is 1.

       <b>mixed</b>
           Set  whether  or  not the input only partially contains content to be decimated.  Default is "false".
           If enabled video output stream will be in variable frame rate.

   <b>deconvolve</b>
       Apply 2D deconvolution of video stream in frequency domain using second stream as impulse.

       The filter accepts the following options:

       <b>planes</b>
           Set which planes to process.

       <b>impulse</b>
           Set which impulse video frames will be processed, can be <u>first</u> or <u>all</u>. Default is <u>all</u>.

       <b>noise</b>
           Set noise when doing divisions. Default is <u>0.0000001</u>. Useful when width and height are not  same  and
           not power of 2 or if stream prior to convolving had noise.

       The "deconvolve" filter also supports the <b>framesync</b> options.

   <b>dedot</b>
       Reduce cross-luminance (dot-crawl) and cross-color (rainbows) from video.

       It accepts the following options:

       <b>m</b>   Set  mode  of operation. Can be combination of <u>dotcrawl</u> for cross-luminance reduction and/or <u>rainbows</u>
           for cross-color reduction.

       <b>lt</b>  Set spatial luma threshold. Lower values increases reduction of cross-luminance.

       <b>tl</b>  Set tolerance for temporal luma. Higher values increases reduction of cross-luminance.

       <b>tc</b>  Set tolerance for chroma temporal variation. Higher values increases reduction of cross-color.

       <b>ct</b>  Set temporal chroma threshold. Lower values increases reduction of cross-color.

   <b>deflate</b>
       Apply deflate effect to the video.

       This filter replaces the pixel by the <a href="../man3x3/local.3x3.html">local</a>(3x3) average by taking into account only  values  lower  than
       the pixel.

       It accepts the following options:

       <b>threshold0</b>
       <b>threshold1</b>
       <b>threshold2</b>
       <b>threshold3</b>
           Limit the maximum change for each plane, default is 65535.  If 0, plane will remain unchanged.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>deflicker</b>
       Remove temporal frame luminance variations.

       It accepts the following options:

       <b>size,</b> <b>s</b>
           Set moving-average filter size in frames. Default is 5. Allowed range is 2 - 129.

       <b>mode,</b> <b>m</b>
           Set averaging mode to smooth temporal luminance variations.

           Available values are:

           <b>am</b>  Arithmetic mean

           <b>gm</b>  Geometric mean

           <b>hm</b>  Harmonic mean

           <b>qm</b>  Quadratic mean

           <b>cm</b>  Cubic mean

           <b>pm</b>  Power mean

           <b>median</b>
               Median

       <b>bypass</b>
           Do not actually modify frame. Useful when one only wants metadata.

   <b>dejudder</b>
       Remove judder produced by partially interlaced telecined content.

       Judder  can be introduced, for instance, by <b>pullup</b> filter. If the original source was partially telecined
       content then the output of "pullup,dejudder" will have a variable frame rate.  May  change  the  recorded
       frame  rate  of  the  container.  Aside from that change, this filter will not affect constant frame rate
       video.

       The option available in this filter is:

       <b>cycle</b>
           Specify the length of the window over which the judder repeats.

           Accepts any integer greater than 1. Useful values are:

           <b>4</b>   If the original was telecined from 24 to 30 fps (Film to NTSC).

           <b>5</b>   If the original was telecined from 25 to 30 fps (PAL to NTSC).

           <b>20</b>  If a mixture of the two.

           The default is <b>4</b>.

   <b>delogo</b>
       Suppress a TV station logo by a simple interpolation of the surrounding  pixels.  Just  set  a  rectangle
       covering  the  logo and watch it disappear (and sometimes something even uglier appear - your mileage may
       vary).

       It accepts the following parameters:

       <b>x</b>
       <b>y</b>   Specify the top left corner coordinates of the logo. They must be specified.

       <b>w</b>
       <b>h</b>   Specify the width and height of the logo to clear. They must be specified.

       <b>show</b>
           When set to 1, a green rectangle is drawn on the screen to simplify finding the right <u>x</u>, <u>y</u>, <u>w</u>, and  <u>h</u>
           parameters.  The default value is 0.

           The  rectangle  is  drawn  on  the outermost pixels which will be (partly) replaced with interpolated
           values. The values of the next pixels immediately outside this rectangle in each  direction  will  be
           used to compute the interpolated pixel values inside the rectangle.

       <u>Examples</u>

       •   Set a rectangle covering the area with top left corner coordinates 0,0 and size 100x77:

                   delogo=x=0:y=0:w=100:h=77

   <b>derain</b>
       Remove  the  rain  in  the input image/video by applying the derain methods based on convolutional neural
       networks. Supported models:

       •   Recurrent      Squeeze-and-Excitation      Context      Aggregation      Net      (RESCAN).       See
           &lt;<b><a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Xia_Li_Recurrent_Squeeze-and-Excitation_Context_ECCV_2018_paper.pdf">http://openaccess.thecvf.com/content_ECCV_2018/papers/Xia_Li_Recurrent_Squeeze-and-Excitation_Context_ECCV_2018_paper.pdf</a></b>&gt;.

       Training    as    well    as   model   generation   scripts   are   provided   in   the   repository   at
       &lt;<b>https://github.com/XueweiMeng/derain_filter.git</b>&gt;.

       The filter accepts the following options:

       <b>filter_type</b>
           Specify which filter to use. This option accepts the following values:

           <b>derain</b>
               Derain filter. To conduct derain filter, you need to use a derain model.

           <b>dehaze</b>
               Dehaze filter. To conduct dehaze filter, you need to use a dehaze model.

           Default value is <b>derain</b>.

       <b>dnn_backend</b>
           Specify which DNN backend to use for model loading and execution. This option accepts  the  following
           values:

           <b>tensorflow</b>
               TensorFlow  backend. To enable this backend you need to install the TensorFlow for C library (see
               &lt;<b>https://www.tensorflow.org/install/lang_c</b>&gt;) and configure FFmpeg with "--enable-libtensorflow"

       <b>model</b>
           Set path to model file specifying network architecture  and  its  parameters.   Note  that  different
           backends use different file formats. TensorFlow can load files for only its format.

       To get full functionality (such as async execution), please use the <b>dnn_processing</b> filter.

   <b>deshake</b>
       Attempt  to  fix small changes in horizontal and/or vertical shift. This filter helps remove camera shake
       from hand-holding a camera, bumping a tripod, moving on a vehicle, etc.

       The filter accepts the following options:

       <b>x</b>
       <b>y</b>
       <b>w</b>
       <b>h</b>   Specify a rectangular area where to limit the search for motion vectors.  If desired the  search  for
           motion  vectors  can  be  limited  to a rectangular area of the frame defined by its top left corner,
           width and height. These parameters have the same meaning as the drawbox filter which can be  used  to
           visualise the position of the bounding box.

           This  is  useful when simultaneous movement of subjects within the frame might be confused for camera
           motion by the motion vector search.

           If any or all of <u>x</u>, <u>y</u>, <u>w</u> and <u>h</u> are set to -1 then the full frame is used. This allows  later  options
           to be set without specifying the bounding box for the motion vector search.

           Default - search the whole frame.

       <b>rx</b>
       <b>ry</b>  Specify the maximum extent of movement in x and y directions in the range 0-64 pixels. Default 16.

       <b>edge</b>
           Specify how to generate pixels to fill blanks at the edge of the frame. Available values are:

           <b>blank,</b> <b>0</b>
               Fill zeroes at blank locations

           <b>original,</b> <b>1</b>
               Original image at blank locations

           <b>clamp,</b> <b>2</b>
               Extruded edge value at blank locations

           <b>mirror,</b> <b>3</b>
               Mirrored edge at blank locations

           Default value is <b>mirror</b>.

       <b>blocksize</b>
           Specify the blocksize to use for motion search. Range 4-128 pixels, default 8.

       <b>contrast</b>
           Specify  the  contrast  threshold  for  blocks.  Only  blocks  with  more than the specified contrast
           (difference between darkest and lightest pixels) will be considered. Range 1-255, default 125.

       <b>search</b>
           Specify the search strategy. Available values are:

           <b>exhaustive,</b> <b>0</b>
               Set exhaustive search

           <b>less,</b> <b>1</b>
               Set less exhaustive search.

           Default value is <b>exhaustive</b>.

       <b>filename</b>
           If set then a detailed log of the motion search is written to the specified file.

   <b>despill</b>
       Remove unwanted contamination  of  foreground  colors,  caused  by  reflected  color  of  greenscreen  or
       bluescreen.

       This filter accepts the following options:

       <b>type</b>
           Set what type of despill to use.

       <b>mix</b> Set how spillmap will be generated.

       <b>expand</b>
           Set how much to get rid of still remaining spill.

       <b>red</b> Controls amount of red in spill area.

       <b>green</b>
           Controls amount of green in spill area.  Should be -1 for greenscreen.

       <b>blue</b>
           Controls amount of blue in spill area.  Should be -1 for bluescreen.

       <b>brightness</b>
           Controls brightness of spill area, preserving colors.

       <b>alpha</b>
           Modify alpha from generated spillmap.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>detelecine</b>
       Apply  an  exact  inverse of the telecine operation. It requires a predefined pattern specified using the
       pattern option which must be the same as that passed to the telecine filter.

       This filter accepts the following options:

       <b>first_field</b>
           <b>top,</b> <b>t</b>
               top field first

           <b>bottom,</b> <b>b</b>
               bottom field first The default value is "top".

       <b>pattern</b>
           A string of numbers representing the pulldown pattern you wish to apply.  The default value is 23.

       <b>start_frame</b>
           A number representing position of the first frame with respect to the telecine pattern. This is to be
           used if the stream is cut. The default value is 0.

   <b>dilation</b>
       Apply dilation effect to the video.

       This filter replaces the pixel by the <a href="../man3x3/local.3x3.html">local</a>(3x3) maximum.

       It accepts the following options:

       <b>threshold0</b>
       <b>threshold1</b>
       <b>threshold2</b>
       <b>threshold3</b>
           Limit the maximum change for each plane, default is 65535.  If 0, plane will remain unchanged.

       <b>coordinates</b>
           Flag which specifies the pixel to refer to. Default is 255 i.e. all eight pixels are used.

           Flags to local 3x3 coordinates maps like this:

               1 2 3
               4   5
               6 7 8

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>displace</b>
       Displace pixels as indicated by second and third input stream.

       It takes three input streams and outputs one stream, the first input is the source, and second and  third
       input are displacement maps.

       The  second input specifies how much to displace pixels along the x-axis, while the third input specifies
       how much to displace pixels along the y-axis.  If one of displacement map streams terminates, last  frame
       from that displacement map will be used.

       Note that once generated, displacements maps can be reused over and over again.

       A description of the accepted options follows.

       <b>edge</b>
           Set displace behavior for pixels that are out of range.

           Available values are:

           <b>blank</b>
               Missing pixels are replaced by black pixels.

           <b>smear</b>
               Adjacent pixels will spread out to replace missing pixels.

           <b>wrap</b>
               Out of range pixels are wrapped so they point to pixels of other side.

           <b>mirror</b>
               Out of range pixels will be replaced with mirrored pixels.

           Default is <b>smear</b>.

       <u>Examples</u>

       •   Add ripple effect to rgb input of video size hd720:

                   ffmpeg -i INPUT -f lavfi -i nullsrc=s=hd720,lutrgb=128:128:128 -f lavfi -i nullsrc=s=hd720,geq='r=128+30*sin(2*PI*X/400+T):g=128+30*sin(2*PI*X/400+T):b=128+30*sin(2*PI*X/400+T)' -lavfi '[0][1][2]displace' OUTPUT

       •   Add wave effect to rgb input of video size hd720:

                   ffmpeg -i INPUT -f lavfi -i nullsrc=hd720,geq='r=128+80*(sin(sqrt((X-W/2)*(X-W/2)+(Y-H/2)*(Y-H/2))/220*2*PI+T)):g=128+80*(sin(sqrt((X-W/2)*(X-W/2)+(Y-H/2)*(Y-H/2))/220*2*PI+T)):b=128+80*(sin(sqrt((X-W/2)*(X-W/2)+(Y-H/2)*(Y-H/2))/220*2*PI+T))' -lavfi '[1]split[x][y],[0][x][y]displace' OUTPUT

   <b>dnn_classify</b>
       Do classification with deep neural networks based on bounding boxes.

       The filter accepts the following options:

       <b>dnn_backend</b>
           Specify  which  DNN backend to use for model loading and execution. This option accepts only openvino
           now, tensorflow backends will be added.

       <b>model</b>
           Set path to model file specifying network architecture  and  its  parameters.   Note  that  different
           backends use different file formats.

       <b>input</b>
           Set the input name of the dnn network.

       <b>output</b>
           Set the output name of the dnn network.

       <b>confidence</b>
           Set the confidence threshold (default: 0.5).

       <b>labels</b>
           Set  path to label file specifying the mapping between label id and name.  Each label name is written
           in one line, tailing spaces and empty lines are skipped.  The first line is the name of label  id  0,
           and  the second line is the name of label id 1, etc.  The label id is considered as name if the label
           file is not provided.

       <b>backend_configs</b>
           Set the configs to be passed into backend

           For  tensorflow  backend,  you  can  set  its  configs   with   <b>sess_config</b>   options,   please   use
           tools/python/tf_sess_config.py to get the configs for your system.

   <b>dnn_detect</b>
       Do object detection with deep neural networks.

       The filter accepts the following options:

       <b>dnn_backend</b>
           Specify  which  DNN backend to use for model loading and execution. This option accepts only openvino
           now, tensorflow backends will be added.

       <b>model</b>
           Set path to model file specifying network architecture  and  its  parameters.   Note  that  different
           backends use different file formats.

       <b>input</b>
           Set the input name of the dnn network.

       <b>output</b>
           Set the output name of the dnn network.

       <b>confidence</b>
           Set the confidence threshold (default: 0.5).

       <b>labels</b>
           Set  path to label file specifying the mapping between label id and name.  Each label name is written
           in one line, tailing spaces and empty lines are skipped.  The first line is the name of  label  id  0
           (usually  it  is  'background'), and the second line is the name of label id 1, etc.  The label id is
           considered as name if the label file is not provided.

       <b>backend_configs</b>
           Set the configs to be passed into backend. To use async execution, set async  (default:  set).   Roll
           back to sync execution if the backend does not support async.

   <b>dnn_processing</b>
       Do  image  processing with deep neural networks. It works together with another filter which converts the
       pixel format of the Frame to what the dnn network requires.

       The filter accepts the following options:

       <b>dnn_backend</b>
           Specify which DNN backend to use for model loading and execution. This option accepts  the  following
           values:

           <b>tensorflow</b>
               TensorFlow  backend. To enable this backend you need to install the TensorFlow for C library (see
               &lt;<b>https://www.tensorflow.org/install/lang_c</b>&gt;) and configure FFmpeg with "--enable-libtensorflow"

           <b>openvino</b>
               OpenVINO backend. To enable this backend you need to build and install the OpenVINO for C library
               (see     &lt;<b>https://github.com/openvinotoolkit/openvino/blob/master/build-instruction.md</b>&gt;)      and
               configure FFmpeg with "--enable-libopenvino" (--extra-cflags=-I... --extra-ldflags=-L... might be
               needed if the header files and libraries are not installed into system path)

           <b>torch</b>
               Libtorch  backend. To enable this backend you need to build and install Libtroch for C++ library.
               Please download cxx11 ABI version (see &lt;<b>https://pytorch.org/get-started/locally</b>&gt;)  and  configure
               FFmpeg       with       "--enable-libtorch       --extra-cflags=-I/libtorch_root/libtorch/include
               --extra-cflags=-I/libtorch_root/libtorch/include/torch/csrc/api/include
               --extra-ldflags=-L/libtorch_root/libtorch/lib/"

       <b>model</b>
           Set path to model file specifying network architecture  and  its  parameters.   Note  that  different
           backends  use  different  file  formats. TensorFlow, OpenVINO and Libtorch backend can load files for
           only its format.

       <b>input</b>
           Set the input name of the dnn network.

       <b>output</b>
           Set the output name of the dnn network.

       <b>backend_configs</b>
           Set the configs to be passed into backend. To use async execution, set async  (default:  set).   Roll
           back to sync execution if the backend does not support async.

           For   tensorflow   backend,   you   can   set  its  configs  with  <b>sess_config</b>  options,  please  use
           tools/python/tf_sess_config.py to get the configs of TensorFlow backend for your system.

       <u>Examples</u>

       •   Remove rain in rgb24 frame with can.pb (see <b>derain</b> filter):

                   ./ffmpeg -i rain.jpg -vf format=rgb24,dnn_processing=dnn_backend=tensorflow:model=can.pb:input=x:output=y derain.jpg

       •   Handle the Y channel with srcnn.pb (see <b>sr</b>  filter)  for  frame  with  yuv420p  (planar  YUV  formats
           supported):

                   ./ffmpeg -i 480p.jpg -vf format=yuv420p,scale=w=iw*2:h=ih*2,dnn_processing=dnn_backend=tensorflow:model=srcnn.pb:input=x:output=y -y srcnn.jpg

       •   Handle  the  Y  channel  with  espcn.pb (see <b>sr</b> filter), which changes frame size, for format yuv420p
           (planar YUV formats supported), please use  tools/python/tf_sess_config.py  to  get  the  configs  of
           TensorFlow backend for your system.

                   ./ffmpeg -i 480p.jpg -vf format=yuv420p,dnn_processing=dnn_backend=tensorflow:model=espcn.pb:input=x:output=y:backend_configs=sess_config=0x10022805320e09cdccccccccccec3f20012a01303801 -y tmp.espcn.jpg

   <b>drawbox</b>
       Draw a colored box on the input image.

       It accepts the following parameters:

       <b>x</b>
       <b>y</b>   The expressions which specify the top left corner coordinates of the box. It defaults to 0.

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           The expressions which specify the width and height of the box; if 0 they are interpreted as the input
           width and height. It defaults to 0.

       <b>color,</b> <b>c</b>
           Specify  the  color  of  the  box  to write. For the general syntax of this option, check the <b>"Color"</b>
           <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>. If the special value "invert" is used, the box edge color is  the
           same as the video with inverted luma.

       <b>thickness,</b> <b>t</b>
           The expression which sets the thickness of the box edge.  A value of "fill" will create a filled box.
           Default value is 3.

           See below for the list of accepted constants.

       <b>replace</b>
           Applicable  if  the  input  has alpha. With value 1, the pixels of the painted box will overwrite the
           video's color and alpha pixels.  Default is 0, which composites the box onto the input,  leaving  the
           video's alpha intact.

       The parameters for <u>x</u>, <u>y</u>, <u>w</u> and <u>h</u> and <u>t</u> are expressions containing the following constants:

       <b>dar</b> The input display aspect ratio, it is the same as (<u>w</u> / <u>h</u>) * <u>sar</u>.

       <b>hsub</b>
       <b>vsub</b>
           horizontal and vertical chroma subsample values. For example for the pixel format "yuv422p" <u>hsub</u> is 2
           and <u>vsub</u> is 1.

       <b>in_h,</b> <b>ih</b>
       <b>in_w,</b> <b>iw</b>
           The input width and height.

       <b>sar</b> The input sample aspect ratio.

       <b>x</b>
       <b>y</b>   The x and y offset coordinates where the box is drawn.

       <b>w</b>
       <b>h</b>   The width and height of the drawn box.

       <b>box_source</b>
           Box  source  can be set as side_data_detection_bboxes if you want to use box data in detection bboxes
           of side data.

           If <u>box_source</u> is set, the <u>x</u>, <u>y</u>, <u>width</u> and <u>height</u> will be ignored and still use box data in  detection
           bboxes of side data. So please do not use this parameter if you were not sure about the box source.

       <b>t</b>   The thickness of the drawn box.

           These constants allow the <u>x</u>, <u>y</u>, <u>w</u>, <u>h</u> and <u>t</u> expressions to refer to each other, so you may for example
           specify "y=x/dar" or "h=w/dar".

       <u>Examples</u>

       •   Draw a black box around the edge of the input image:

                   drawbox

       •   Draw a box with color red and an opacity of 50%:

                   drawbox=10:20:200:60:<a href="mailto:red@0.5">red@0.5</a>

           The previous example can be specified as:

                   drawbox=x=10:y=20:w=200:h=60:color=<a href="mailto:red@0.5">red@0.5</a>

       •   Fill the box with pink color:

                   drawbox=x=10:y=10:w=100:h=100:color=<a href="mailto:pink@0.5">pink@0.5</a>:t=fill

       •   Draw a 2-pixel red 2.40:1 mask:

                   drawbox=x=-t:y=0.5*(ih-iw/2.4)-t:w=iw+t*2:h=iw/2.4+t*2:t=2:c=red

       <u>Commands</u>

       This  filter supports same commands as options.  The command accepts the same syntax of the corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>drawgraph</b>
       Draw a graph using input video metadata.

       It accepts the following parameters:

       <b>m1</b>  Set 1st frame metadata key from which metadata values will be used to draw a graph.

       <b>fg1</b> Set 1st foreground color expression.

       <b>m2</b>  Set 2nd frame metadata key from which metadata values will be used to draw a graph.

       <b>fg2</b> Set 2nd foreground color expression.

       <b>m3</b>  Set 3rd frame metadata key from which metadata values will be used to draw a graph.

       <b>fg3</b> Set 3rd foreground color expression.

       <b>m4</b>  Set 4th frame metadata key from which metadata values will be used to draw a graph.

       <b>fg4</b> Set 4th foreground color expression.

       <b>min</b> Set minimal value of metadata value.

       <b>max</b> Set maximal value of metadata value.

       <b>bg</b>  Set graph background color. Default is white.

       <b>mode</b>
           Set graph mode.

           Available values for mode is:

           <b>bar</b>
           <b>dot</b>
           <b>line</b>

           Default is "line".

       <b>slide</b>
           Set slide mode.

           Available values for slide is:

           <b>frame</b>
               Draw new frame when right border is reached.

           <b>replace</b>
               Replace old columns with new ones.

           <b>scroll</b>
               Scroll from right to left.

           <b>rscroll</b>
               Scroll from left to right.

           <b>picture</b>
               Draw single picture.

           Default is "frame".

       <b>size</b>
           Set size of graph video. For the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-</b>
           <b>utils</b> <b>manual</b>.  The default value is "900x256".

       <b>rate,</b> <b>r</b>
           Set the output frame rate. Default value is 25.

           The foreground color expressions can use the following variables:

           <b>MIN</b> Minimal value of metadata value.

           <b>MAX</b> Maximal value of metadata value.

           <b>VAL</b> Current metadata key value.

           The color is defined as 0xAABBGGRR.

       Example using metadata from <b>signalstats</b> filter:

               signalstats,drawgraph=lavfi.signalstats.YAVG:min=0:max=255

       Example using metadata from <b>ebur128</b> filter:

               ebur128=metadata=1,adrawgraph=lavfi.r128.M:min=-120:max=5

   <b>drawgrid</b>
       Draw a grid on the input image.

       It accepts the following parameters:

       <b>x</b>
       <b>y</b>   The expressions which specify the coordinates of some point of grid intersection (meant to  configure
           offset). Both default to 0.

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           The expressions which specify the width and height of the grid cell, if 0 they are interpreted as the
           input width and height, respectively, minus "thickness", so image gets framed. Default to 0.

       <b>color,</b> <b>c</b>
           Specify  the  color  of the grid. For the general syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b>
           <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>. If the special value "invert" is used, the grid color is  the  same  as  the
           video with inverted luma.

       <b>thickness,</b> <b>t</b>
           The expression which sets the thickness of the grid line. Default value is 1.

           See below for the list of accepted constants.

       <b>replace</b>
           Applicable  if  the input has alpha. With 1 the pixels of the painted grid will overwrite the video's
           color and alpha pixels.  Default is 0, which composites the grid onto the input, leaving the  video's
           alpha intact.

       The parameters for <u>x</u>, <u>y</u>, <u>w</u> and <u>h</u> and <u>t</u> are expressions containing the following constants:

       <b>dar</b> The input display aspect ratio, it is the same as (<u>w</u> / <u>h</u>) * <u>sar</u>.

       <b>hsub</b>
       <b>vsub</b>
           horizontal and vertical chroma subsample values. For example for the pixel format "yuv422p" <u>hsub</u> is 2
           and <u>vsub</u> is 1.

       <b>in_h,</b> <b>ih</b>
       <b>in_w,</b> <b>iw</b>
           The input grid cell width and height.

       <b>sar</b> The input sample aspect ratio.

       <b>x</b>
       <b>y</b>   The x and y coordinates of some point of grid intersection (meant to configure offset).

       <b>w</b>
       <b>h</b>   The width and height of the drawn cell.

       <b>t</b>   The thickness of the drawn cell.

           These constants allow the <u>x</u>, <u>y</u>, <u>w</u>, <u>h</u> and <u>t</u> expressions to refer to each other, so you may for example
           specify "y=x/dar" or "h=w/dar".

       <u>Examples</u>

       •   Draw a grid with cell 100x100 pixels, thickness 2 pixels, with color red and an opacity of 50%:

                   drawgrid=width=100:height=100:thickness=2:color=<a href="mailto:red@0.5">red@0.5</a>

       •   Draw a white 3x3 grid with an opacity of 50%:

                   drawgrid=w=iw/3:h=ih/3:t=2:c=<a href="mailto:white@0.5">white@0.5</a>

       <u>Commands</u>

       This  filter supports same commands as options.  The command accepts the same syntax of the corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>drawtext</b>
       Draw a text string or text from a specified file on top of a video, using the libfreetype library.

       To enable compilation of this filter, you  need  to  configure  FFmpeg  with  "--enable-libfreetype"  and
       "--enable-libharfbuzz".  To enable default font fallback and the <u>font</u> option you need to configure FFmpeg
       with  "--enable-libfontconfig".   To  enable  the  <u>text_shaping</u> option, you need to configure FFmpeg with
       "--enable-libfribidi".

       <u>Syntax</u>

       It accepts the following parameters:

       <b>box</b> Used to draw a box around text using the background color.  The value must be either 1 (enable) or  0
           (disable).  The default value of <u>box</u> is 0.

       <b>boxborderw</b>
           Set  the  width of the border to be drawn around the box using <u>boxcolor</u>.  The value must be specified
           using one of the following formats:

           *&lt;"boxborderw=10" set the width of all the borders to 10&gt;
           *&lt;"boxborderw=10|20" set the width of the top and bottom borders to 10&gt;
                   and the width of the left and right borders to 20

           *&lt;"boxborderw=10|20|30" set the width of the top border to 10, the width&gt;
                   of the bottom border to 30 and the width of the left and right borders to 20

           *&lt;"boxborderw=10|20|30|40" set the borders width to 10 (top), 20 (right),&gt;
                   30 (bottom), 40 (left)

           The default value of <u>boxborderw</u> is "0".

       <b>boxcolor</b>
           The color to be used for drawing box around text. For the syntax of this option,  check  the  <b>"Color"</b>
           <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

           The default value of <u>boxcolor</u> is "white".

       <b>line_spacing</b>
           Set the line spacing in pixels. The default value of <u>line_spacing</u> is 0.

       <b>text_align</b>
           Set  the vertical and horizontal alignment of the text with respect to the box boundaries.  The value
           is combination of flags, one for the vertical alignment (T=top, M=middle, B=bottom) and one  for  the
           horizontal alignment (L=left, C=center, R=right).  Please note that tab characters are only supported
           with the left horizontal alignment.

       <b>y_align</b>
           Specify what the <u>y</u> value is referred to. Possible values are:

           *&lt;"text" the top of the highest glyph of the first text line is placed at <u>y</u>&gt;
           *&lt;"baseline" the baseline of the first text line is placed at <u>y</u>&gt;
           *&lt;"font" the baseline of the first text line is placed at <u>y</u> plus the&gt;
                   ascent (in pixels) defined in the font metrics

           The default value of <u>y_align</u> is "text" for backward compatibility.

       <b>borderw</b>
           Set  the  width  of  the  border to be drawn around the text using <u>bordercolor</u>.  The default value of
           <u>borderw</u> is 0.

       <b>bordercolor</b>
           Set the color to be used for drawing border around text. For the syntax of  this  option,  check  the
           <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

           The default value of <u>bordercolor</u> is "black".

       <b>expansion</b>
           Select how the <u>text</u> is expanded. Can be either "none", "strftime" (deprecated) or "normal" (default).
           See the <b>drawtext_expansion,</b> <b>Text</b> <b>expansion</b> section below for details.

       <b>basetime</b>
           Set  a  start time for the count. Value is in microseconds. Only applied in the deprecated "strftime"
           expansion mode. To emulate in normal expansion mode use the "pts" function, supplying the start  time
           (in seconds) as the second argument.

       <b>fix_bounds</b>
           If true, check and fix text coords to avoid clipping.

       <b>fontcolor</b>
           The  color  to be used for drawing fonts. For the syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b>
           <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

           The default value of <u>fontcolor</u> is "black".

       <b>fontcolor_expr</b>
           String which is expanded the same way as <u>text</u> to obtain dynamic  <u>fontcolor</u>  value.  By  default  this
           option has empty value and is not processed. When this option is set, it overrides <u>fontcolor</u> option.

       <b>font</b>
           The font family to be used for drawing text. By default Sans.

       <b>fontfile</b>
           The font file to be used for drawing text. The path must be included.  This parameter is mandatory if
           the fontconfig support is disabled.

       <b>alpha</b>
           Draw the text applying alpha blending. The value can be a number between 0.0 and 1.0.  The expression
           accepts the same variables <u>x,</u> <u>y</u> as well.  The default value is 1.  Please see <u>fontcolor_expr</u>.

       <b>fontsize</b>
           The font size to be used for drawing text.  The default value of <u>fontsize</u> is 16.

       <b>text_shaping</b>
           If set to 1, attempt to shape the text (for example, reverse the order of right-to-left text and join
           Arabic  characters) before drawing it.  Otherwise, just draw the text exactly as given.  By default 1
           (if supported).

       <b>ft_load_flags</b>
           The flags to be used for loading the fonts.

           The flags map the corresponding flags  supported  by  libfreetype,  and  are  a  combination  of  the
           following values:

           <u>default</u>
           <u>no_scale</u>
           <u>no_hinting</u>
           <u>render</u>
           <u>no_bitmap</u>
           <u>vertical_layout</u>
           <u>force_autohint</u>
           <u>crop_bitmap</u>
           <u>pedantic</u>
           <u>ignore_global_advance_width</u>
           <u>no_recurse</u>
           <u>ignore_transform</u>
           <u>monochrome</u>
           <u>linear_design</u>
           <u>no_autohint</u>

           Default value is "default".

           For more information consult the documentation for the FT_LOAD_* libfreetype flags.

       <b>shadowcolor</b>
           The color to be used for drawing a shadow behind the drawn text. For the syntax of this option, check
           the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

           The default value of <u>shadowcolor</u> is "black".

       <b>boxw</b>
           Set  the  width  of  the  box  to  be  drawn  around  text.   The  default  value of <u>boxw</u> is computed
           automatically to match the text width

       <b>boxh</b>
           Set the height of the box  to  be  drawn  around  text.   The  default  value  of  <u>boxh</u>  is  computed
           automatically to match the text height

       <b>shadowx</b>
       <b>shadowy</b>
           The  x  and y offsets for the text shadow position with respect to the position of the text. They can
           be either positive or negative values. The default value for both is "0".

       <b>start_number</b>
           The starting frame number for the n/frame_num variable. The default value is "0".

       <b>tabsize</b>
           The size in number of spaces to use for rendering the tab.  Default value is 4.

       <b>timecode</b>
           Set the initial timecode representation in "hh:mm:ss[:;.]ff" format. It can be used with  or  without
           text parameter. <u>timecode_rate</u> option must be specified.

       <b>timecode_rate,</b> <b>rate,</b> <b>r</b>
           Set  the timecode frame rate (timecode only). Value will be rounded to nearest integer. Minimum value
           is "1".  Drop-frame timecode is supported for frame rates 30 &amp; 60.

       <b>tc24hmax</b>
           If set to 1, the output of the  timecode  option  will  wrap  around  at  24  hours.   Default  is  0
           (disabled).

       <b>text</b>
           The text string to be drawn. The text must be a sequence of UTF-8 encoded characters.  This parameter
           is mandatory if no file is specified with the parameter <u>textfile</u>.

       <b>textfile</b>
           A text file containing text to be drawn. The text must be a sequence of UTF-8 encoded characters.

           This parameter is mandatory if no text string is specified with the parameter <u>text</u>.

           If both <u>text</u> and <u>textfile</u> are specified, an error is thrown.

       <b>text_source</b>
           Text  source  should  be  set as side_data_detection_bboxes if you want to use text data in detection
           bboxes of side data.

           If text source is set, <u>text</u> and <u>textfile</u> will be ignored and still use text data in detection  bboxes
           of side data. So please do not use this parameter if you are not sure about the text source.

       <b>reload</b>
           The <u>textfile</u> will be reloaded at specified frame interval.  Be sure to update <u>textfile</u> atomically, or
           it may be read partially, or even fail.  Range is 0 to INT_MAX. Default is 0.

       <b>x</b>
       <b>y</b>   The  expressions  which specify the offsets where text will be drawn within the video frame. They are
           relative to the top/left border of the output image.

           The default value of <u>x</u> and <u>y</u> is "0".

           See below for the list of accepted constants and functions.

       The parameters for <u>x</u> and <u>y</u> are expressions containing the following constants and functions:

       <b>dar</b> input display aspect ratio, it is the same as (<u>w</u> / <u>h</u>) * <u>sar</u>

       <b>hsub</b>
       <b>vsub</b>
           horizontal and vertical chroma subsample values. For example for the pixel format "yuv422p" <u>hsub</u> is 2
           and <u>vsub</u> is 1.

       <b>line_h,</b> <b>lh</b>
           the height of each text line

       <b>main_h,</b> <b>h,</b> <b>H</b>
           the input height

       <b>main_w,</b> <b>w,</b> <b>W</b>
           the input width

       <b>max_glyph_a,</b> <b>ascent</b>
           the maximum distance from the baseline to the highest/upper grid coordinate used  to  place  a  glyph
           outline  point,  for  all the rendered glyphs.  It is a positive value, due to the grid's orientation
           with the Y axis upwards.

       <b>max_glyph_d,</b> <b>descent</b>
           the maximum distance from the baseline to the lowest grid coordinate used to place  a  glyph  outline
           point,  for  all  the rendered glyphs.  This is a negative value, due to the grid's orientation, with
           the Y axis upwards.

       <b>max_glyph_h</b>
           maximum glyph height, that is the maximum height for all the glyphs contained in the  rendered  text,
           it is equivalent to <u>ascent</u> - <u>descent</u>.

       <b>max_glyph_w</b>
           maximum glyph width, that is the maximum width for all the glyphs contained in the rendered text

       <b>font_a</b>
           the ascent size defined in the font metrics

       <b>font_d</b>
           the descent size defined in the font metrics

       <b>top_a</b>
           the maximum ascender of the glyphs of the first text line

       <b>bottom_d</b>
           the maximum descender of the glyphs of the last text line

       <b>n</b>   the number of input frame, starting from 0

       <b>rand(min,</b> <b>max)</b>
           return a random number included between <u>min</u> and <u>max</u>

       <b>sar</b> The input sample aspect ratio.

       <b>t</b>   timestamp expressed in seconds, NAN if the input timestamp is unknown

       <b>text_h,</b> <b>th</b>
           the height of the rendered text

       <b>text_w,</b> <b>tw</b>
           the width of the rendered text

       <b>x</b>
       <b>y</b>   the x and y offset coordinates where the text is drawn.

           These parameters allow the <u>x</u> and <u>y</u> expressions to refer to each other, so you can for example specify
           "y=x/dar".

       <b>pict_type</b>
           A one character description of the current frame's picture type.

       <b>pkt_pos</b>
           The  current packet's position in the input file or stream (in bytes, from the start of the input). A
           value of -1 indicates this info is not available.

       <b>duration</b>
           The current packet's duration, in seconds.

       <b>pkt_size</b>
           The current packet's size (in bytes).

       <u>Text</u> <u>expansion</u>

       If <b>expansion</b> is set to "strftime", the filter recognizes sequences accepted by the "strftime" C  function
       in the provided text and expands them accordingly. Check the documentation of "strftime". This feature is
       deprecated in favor of "normal" expansion with the "gmtime" or "localtime" expansion functions.

       If <b>expansion</b> is set to "none", the text is printed verbatim.

       If <b>expansion</b> is set to "normal" (which is the default), the following expansion mechanism is used.

       The backslash character <b>\</b>, followed by any character, always expands to the second character.

       Sequences  of  the  form  "%{...}" are expanded. The text between the braces is a function name, possibly
       followed by arguments separated by ':'.  If the arguments contain special characters or  delimiters  (':'
       or '}'), they should be escaped.

       Note  that  they  probably  must  also be escaped as the value for the <b>text</b> option in the filter argument
       string and as the filter argument in the filtergraph description, and possibly also for the  shell,  that
       makes up to four levels of escaping; using a text file with the <b>textfile</b> option avoids these problems.

       The following functions are available:

       <b>expr,</b> <b>e</b>
           The expression evaluation result.

           It must take one argument specifying the expression to be evaluated, which accepts the same constants
           and functions as the <u>x</u> and <u>y</u> values. Note that not all constants should be used, for example the text
           size  is  not  known  when evaluating the expression, so the constants <u>text_w</u> and <u>text_h</u> will have an
           undefined value.

       <b>expr_int_format,</b> <b>eif</b>
           Evaluate the expression's value and output as formatted integer.

           The first argument is the expression to be evaluated, just as for  the  <u>expr</u>  function.   The  second
           argument  specifies  the output format. Allowed values are <b>x</b>, <b>X</b>, <b>d</b> and <b>u</b>. They are treated exactly as
           in the "printf" function.  The third parameter is optional and sets the number of positions taken  by
           the output.  It can be used to add padding with zeros from the left.

       <b>gmtime</b>
           The time at which the filter is running, expressed in UTC.  It can accept an argument: a "strftime" C
           function  format  string.  The format string is extended to support the variable <u>%[1-6]N</u> which prints
           fractions of the second with optionally specified number of digits.

       <b>localtime</b>
           The time at which the filter is running, expressed  in  the  local  time  zone.   It  can  accept  an
           argument:  a  "strftime"  C  function  format  string.   The format string is extended to support the
           variable <u>%[1-6]N</u> which prints fractions of the second with optionally specified number of digits.

       <b>metadata</b>
           Frame metadata. Takes one or two arguments.

           The first argument is mandatory and specifies the metadata key.

           The second argument is optional and specifies a default value, used when  the  metadata  key  is  not
           found or empty.

           Available  metadata  can  be  identified by inspecting entries starting with TAG included within each
           frame section printed by running "ffprobe -show_frames".

           String metadata generated in filters leading to the drawtext filter are also available.

       <b>n,</b> <b>frame_num</b>
           The frame number, starting from 0.

       <b>pict_type</b>
           A one character description of the current picture type.

       <b>pts</b> The timestamp of the current frame.  It can take up to three arguments.

           The first argument is the format of the timestamp; it defaults to "flt"  for  seconds  as  a  decimal
           number  with  microsecond  accuracy;  "hms"  stands  for  a  formatted <u>[-]HH:MM:SS.mmm</u> timestamp with
           millisecond accuracy.  "gmtime" stands for  the  timestamp  of  the  frame  formatted  as  UTC  time;
           "localtime" stands for the timestamp of the frame formatted as local time zone time.

           The second argument is an offset added to the timestamp.

           If  the  format  is set to "hms", a third argument "24HH" may be supplied to present the hour part of
           the formatted timestamp in 24h format (00-23).

           If the format is set to "localtime" or "gmtime", a third argument may be  supplied:  a  "strftime"  C
           function format string.  By default, <u>YYYY-MM-DD</u> <u>HH:MM:SS</u> format will be used.

       <u>Commands</u>

       This filter supports altering parameters via commands:

       <b>reinit</b>
           Alter existing filter parameters.

           Syntax for the argument is the same as for filter invocation, e.g.

                   fontsize=56:fontcolor=green:text='Hello World'

           Full filter invocation with sendcmd would look like this:

                   sendcmd=c='56.0 drawtext reinit fontsize=56\:fontcolor=green\:text=Hello\\ World'

           If  the entire argument can't be parsed or applied as valid values then the filter will continue with
           its existing parameters.

       The following options are also supported as <b>commands</b>:

       *&lt;x&gt;
       *&lt;y&gt;
       *&lt;alpha&gt;
       *&lt;fontsize&gt;
       *&lt;fontcolor&gt;
       *&lt;boxcolor&gt;
       *&lt;bordercolor&gt;
       *&lt;shadowcolor&gt;
       *&lt;box&gt;
       *&lt;boxw&gt;
       *&lt;boxh&gt;
       *&lt;boxborderw&gt;
       *&lt;line_spacing&gt;
       *&lt;text_align&gt;
       *&lt;shadowx&gt;
       *&lt;shadowy&gt;
       *&lt;borderw&gt;

       <u>Examples</u>

       •   Draw "Test Text" with font FreeSerif, using the default values for the optional parameters.

                   drawtext="fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf: text='Test Text'"

       •   Draw 'Test Text' with font FreeSerif of size 24 at position x=100 and y=50 (counting  from  the  top-
           left  corner  of the screen), text is yellow with a red box around it. Both the text and the box have
           an opacity of 20%.

                   drawtext="fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf: text='Test Text':\
                             x=100: y=50: fontsize=24: fontcolor=<a href="mailto:yellow@0.2">yellow@0.2</a>: box=1: boxcolor=<a href="mailto:red@0.2">red@0.2</a>"

           Note that the double quotes are not necessary if spaces are not used within the parameter list.

       •   Show the text at the center of the video frame:

                   drawtext="fontsize=30:fontfile=FreeSerif.ttf:text='hello world':x=(w-text_w)/2:y=(h-text_h)/2"

       •   Show the text at a random position, switching to a new position every 30 seconds:

                   drawtext="fontsize=30:fontfile=FreeSerif.ttf:text='hello world':x=if(eq(mod(t\,30)\,0)\,rand(0\,(w-text_w))\,x):y=if(eq(mod(t\,30)\,0)\,rand(0\,(h-text_h))\,y)"

       •   Show a text line sliding from right to left in the last row of the video frame. The file <u>LONG_LINE</u> is
           assumed to contain a single line with no newlines.

                   drawtext="fontsize=15:fontfile=FreeSerif.ttf:text=LONG_LINE:y=h-line_h:x=-50*t"

       •   Show the content of file <u>CREDITS</u> off the bottom of the frame and scroll up.

                   drawtext="fontsize=20:fontfile=FreeSerif.ttf:textfile=CREDITS:y=h-20*t"

       •   Draw a single green letter "g", at the center of the input video.  The glyph baseline  is  placed  at
           half screen height.

                   drawtext="fontsize=60:fontfile=FreeSerif.ttf:fontcolor=green:text=g:x=(w-max_glyph_w)/2:y=h/2-ascent"

       •   Show text for 1 second every 3 seconds:

                   drawtext="fontfile=FreeSerif.ttf:fontcolor=white:x=100:y=x/dar:enable=lt(mod(t\,3)\,1):text='blink'"

       •   Use fontconfig to set the font. Note that the colons need to be escaped.

                   drawtext='fontfile=Linux Libertine O-40\\:style=Semibold:text=FFmpeg'

       •   Draw "Test Text" with font size dependent on height of the video.

                   drawtext="text='Test Text': fontsize=h/30: x=(w-text_w)/2: y=(h-text_h*2)"

       •   Print the date of a real-time encoding (see documentation for the "strftime" C function):

                   drawtext='fontfile=FreeSans.ttf:text=%{localtime\:%a %b %d %Y}'

       •   Show text fading in and out (appearing/disappearing):

                   #!<a href="file:/bin/sh">/bin/sh</a>
                   DS=1.0 # display start
                   DE=10.0 # display end
                   FID=1.5 # fade in duration
                   FOD=5 # fade out duration
                   ffplay -f lavfi "color,drawtext=text=TEST:fontsize=50:fontfile=FreeSerif.ttf:fontcolor_expr=ff0000%{eif\\\\: clip(255*(1*between(t\\, $DS + $FID\\, $DE - $FOD) + ((t - $DS)/$FID)*between(t\\, $DS\\, $DS + $FID) + (-(t - $DE)/$FOD)*between(t\\, $DE - $FOD\\, $DE) )\\, 0\\, 255) \\\\: x\\\\: 2 }"

       •   Horizontally align multiple separate texts. Note that <b>max_glyph_a</b> and the <b>fontsize</b> value are included
           in the <b>y</b> offset.

                   drawtext=fontfile=FreeSans.ttf:text=DOG:fontsize=24:x=10:y=20+24-max_glyph_a,
                   drawtext=fontfile=FreeSans.ttf:text=cow:fontsize=24:x=80:y=20+24-max_glyph_a

       •   Plot  special  <u>lavf.image2dec.source_basename</u>  metadata  onto  each  frame  if  such metadata exists.
           Otherwise, plot the string "NA". Note that image2 demuxer must have  option  <b>-export_path_metadata</b>  <b>1</b>
           for the special metadata fields to be available for filters.

                   drawtext="fontsize=20:fontcolor=white:fontfile=FreeSans.ttf:text='%{metadata\:lavf.image2dec.source_basename\:NA}':x=10:y=10"

       For more information about libfreetype, check: &lt;<b><a href="http://www.freetype.org/">http://www.freetype.org/</a></b>&gt;.

       For             more             information             about             fontconfig,             check:
       &lt;<b><a href="http://freedesktop.org/software/fontconfig/fontconfig-user.html">http://freedesktop.org/software/fontconfig/fontconfig-user.html</a></b>&gt;.

       For more information about libfribidi, check: &lt;<b><a href="http://fribidi.org/">http://fribidi.org/</a></b>&gt;.

       For more information about libharfbuzz, check: &lt;<b>https://github.com/harfbuzz/harfbuzz</b>&gt;.

   <b>edgedetect</b>
       Detect and draw edges. The filter uses the Canny Edge Detection algorithm.

       The filter accepts the following options:

       <b>low</b>
       <b>high</b>
           Set low and high threshold values used by the Canny thresholding algorithm.

           The high threshold selects the "strong" edge pixels, which are then connected through  8-connectivity
           with the "weak" edge pixels selected by the low threshold.

           <u>low</u> and <u>high</u> threshold values must be chosen in the range [0,1], and <u>low</u> should be lesser or equal to
           <u>high</u>.

           Default value for <u>low</u> is "20/255", and default value for <u>high</u> is "50/255".

       <b>mode</b>
           Define the drawing mode.

           <b>wires</b>
               Draw white/gray wires on black background.

           <b>colormix</b>
               Mix the colors to create a paint/cartoon effect.

           <b>canny</b>
               Apply Canny edge detector on all selected planes.

           Default value is <u>wires</u>.

       <b>planes</b>
           Select planes for filtering. By default all available planes are filtered.

       <u>Examples</u>

       •   Standard edge detection with custom values for the hysteresis thresholding:

                   edgedetect=low=0.1:high=0.4

       •   Painting effect without thresholding:

                   edgedetect=mode=colormix:high=0

   <b>elbg</b>
       Apply a posterize effect using the ELBG (Enhanced LBG) algorithm.

       For  each input image, the filter will compute the optimal mapping from the input to the output given the
       codebook length, that is the number of distinct output colors.

       This filter accepts the following options.

       <b>codebook_length,</b> <b>l</b>
           Set codebook length. The value must be a positive integer, and  represents  the  number  of  distinct
           output colors. Default value is 256.

       <b>nb_steps,</b> <b>n</b>
           Set the maximum number of iterations to apply for computing the optimal mapping. The higher the value
           the better the result and the higher the computation time. Default value is 1.

       <b>seed,</b> <b>s</b>
           Set  a  random  seed,  must  be an integer included between 0 and UINT32_MAX. If not specified, or if
           explicitly set to -1, the filter will try to use a good random seed on a best effort basis.

       <b>pal8</b>
           Set pal8 output pixel format. This option does not  work  with  codebook  length  greater  than  256.
           Default is disabled.

       <b>use_alpha</b>
           Include  alpha values in the quantization calculation. Allows creating palettized output images (e.g.
           PNG8) with multiple alpha smooth blending.

   <b>entropy</b>
       Measure graylevel entropy in histogram of color channels of video frames.

       It accepts the following parameters:

       <b>mode</b>
           Can be either <u>normal</u> or <u>diff</u>. Default is <u>normal</u>.

           <u>diff</u> mode measures  entropy  of  histogram  delta  values,  absolute  differences  between  neighbour
           histogram values.

   <b>epx</b>
       Apply the EPX magnification filter which is designed for pixel art.

       It accepts the following option:

       <b>n</b>   Set the scaling dimension: 2 for "2xEPX", 3 for "3xEPX".  Default is 3.

   <b>eq</b>
       Set brightness, contrast, saturation and approximate gamma adjustment.

       The filter accepts the following options:

       <b>contrast</b>
           Set  the contrast expression. The value must be a float value in range -1000.0 to 1000.0. The default
           value is "1".

       <b>brightness</b>
           Set the brightness expression. The value must be a float value in range  -1.0  to  1.0.  The  default
           value is "0".

       <b>saturation</b>
           Set  the  saturation  expression. The value must be a float in range 0.0 to 3.0. The default value is
           "1".

       <b>gamma</b>
           Set the gamma expression. The value must be a float in range 0.1 to 10.0.  The default value is "1".

       <b>gamma_r</b>
           Set the gamma expression for red. The value must be a float in range 0.1 to 10.0. The  default  value
           is "1".

       <b>gamma_g</b>
           Set the gamma expression for green. The value must be a float in range 0.1 to 10.0. The default value
           is "1".

       <b>gamma_b</b>
           Set  the gamma expression for blue. The value must be a float in range 0.1 to 10.0. The default value
           is "1".

       <b>gamma_weight</b>
           Set the gamma weight expression. It can be used to reduce the effect of a high gamma value on  bright
           image  areas,  e.g.  keep  them  from getting overamplified and just plain white. The value must be a
           float in range 0.0 to 1.0. A value of 0.0 turns the gamma correction  all  the  way  down  while  1.0
           leaves it at its full strength. Default is "1".

       <b>eval</b>
           Set when the expressions for brightness, contrast, saturation and gamma expressions are evaluated.

           It accepts the following values:

           <b>init</b>
               only evaluate expressions once during the filter initialization or when a command is processed

           <b>frame</b>
               evaluate expressions for each incoming frame

           Default value is <b>init</b>.

       The expressions accept the following parameters:

       <b>n</b>   frame count of the input frame starting from 0

       <b>pos</b> byte  position  of the corresponding packet in the input file, NAN if unspecified; deprecated, do not
           use

       <b>r</b>   frame rate of the input video, NAN if the input frame rate is unknown

       <b>t</b>   timestamp expressed in seconds, NAN if the input timestamp is unknown

       <u>Commands</u>

       The filter supports the following commands:

       <b>contrast</b>
           Set the contrast expression.

       <b>brightness</b>
           Set the brightness expression.

       <b>saturation</b>
           Set the saturation expression.

       <b>gamma</b>
           Set the gamma expression.

       <b>gamma_r</b>
           Set the gamma_r expression.

       <b>gamma_g</b>
           Set gamma_g expression.

       <b>gamma_b</b>
           Set gamma_b expression.

       <b>gamma_weight</b>
           Set gamma_weight expression.

           The command accepts the same syntax of the corresponding option.

           If the specified expression is not valid, it is kept at its current value.

   <b>erosion</b>
       Apply erosion effect to the video.

       This filter replaces the pixel by the <a href="../man3x3/local.3x3.html">local</a>(3x3) minimum.

       It accepts the following options:

       <b>threshold0</b>
       <b>threshold1</b>
       <b>threshold2</b>
       <b>threshold3</b>
           Limit the maximum change for each plane, default is 65535.  If 0, plane will remain unchanged.

       <b>coordinates</b>
           Flag which specifies the pixel to refer to. Default is 255 i.e. all eight pixels are used.

           Flags to local 3x3 coordinates maps like this:

               1 2 3
               4   5
               6 7 8

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>estdif</b>
       Deinterlace the input video ("estdif" stands for "Edge Slope Tracing Deinterlacing Filter").

       Spatial only filter that uses edge slope tracing algorithm to interpolate missing lines.  It accepts  the
       following parameters:

       <b>mode</b>
           The interlacing mode to adopt. It accepts one of the following values:

           <b>frame</b>
               Output one frame for each frame.

           <b>field</b>
               Output one frame for each field.

           The default value is "field".

       <b>parity</b>
           The  picture  field  parity  assumed  for the input interlaced video. It accepts one of the following
           values:

           <b>tff</b> Assume the top field is first.

           <b>bff</b> Assume the bottom field is first.

           <b>auto</b>
               Enable automatic detection of field parity.

           The default value is "auto".  If the interlacing is unknown or  the  decoder  does  not  export  this
           information, top field first will be assumed.

       <b>deint</b>
           Specify which frames to deinterlace. Accepts one of the following values:

           <b>all</b> Deinterlace all frames.

           <b>interlaced</b>
               Only deinterlace frames marked as interlaced.

           The default value is "all".

       <b>rslope</b>
           Specify the search radius for edge slope tracing. Default value is 1.  Allowed range is from 1 to 15.

       <b>redge</b>
           Specify the search radius for best edge matching. Default value is 2.  Allowed range is from 0 to 15.

       <b>ecost</b>
           Specify the edge cost for edge matching. Default value is 2.  Allowed range is from 0 to 50.

       <b>mcost</b>
           Specify the middle cost for edge matching. Default value is 1.  Allowed range is from 0 to 50.

       <b>dcost</b>
           Specify the distance cost for edge matching. Default value is 1.  Allowed range is from 0 to 50.

       <b>interp</b>
           Specify  the  interpolation  used.  Default is 4-point interpolation. It accepts one of the following
           values:

           <b>2p</b>  Two-point interpolation.

           <b>4p</b>  Four-point interpolation.

           <b>6p</b>  Six-point interpolation.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>exposure</b>
       Adjust exposure of the video stream.

       The filter accepts the following options:

       <b>exposure</b>
           Set the exposure correction in EV. Allowed range is from -3.0 to 3.0 EV Default value is 0 EV.

       <b>black</b>
           Set the black level correction. Allowed range is from -1.0 to 1.0.  Default value is 0.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>extractplanes</b>
       Extract color channel components from input video stream into separate grayscale video streams.

       The filter accepts the following option:

       <b>planes</b>
           Set plane(s) to extract.

           Available values for planes are:

           <b>y</b>
           <b>u</b>
           <b>v</b>
           <b>a</b>
           <b>r</b>
           <b>g</b>
           <b>b</b>

           Choosing planes not available in the input will result in an error.  That  means  you  cannot  select
           "r", "g", "b" planes with "y", "u", "v" planes at same time.

       <u>Examples</u>

       •   Extract luma, u and v color channel component from input video frame into 3 grayscale outputs:

                   ffmpeg -i video.avi -filter_complex 'extractplanes=y+u+v[y][u][v]' -map '[y]' y.avi -map '[u]' u.avi -map '[v]' v.avi

   <b>fade</b>
       Apply a fade-in/out effect to the input video.

       It accepts the following parameters:

       <b>type,</b> <b>t</b>
           The effect type can be either "in" for a fade-in, or "out" for a fade-out effect.  Default is "in".

       <b>start_frame,</b> <b>s</b>
           Specify the number of the frame to start applying the fade effect at. Default is 0.

       <b>nb_frames,</b> <b>n</b>
           The  number  of frames that the fade effect lasts. At the end of the fade-in effect, the output video
           will have the same intensity as the input video.  At the end of the fade-out transition,  the  output
           video will be filled with the selected <b>color</b>.  Default is 25.

       <b>alpha</b>
           If set to 1, fade only alpha channel, if one exists on the input.  Default value is 0.

       <b>start_time,</b> <b>st</b>
           Specify  the  timestamp  (in  seconds)  of  the  frame  to  start  to  apply the fade effect. If both
           start_frame and start_time are specified, the fade will start at whichever comes last.  Default is 0.

       <b>duration,</b> <b>d</b>
           The number of seconds for which the fade effect has to last. At the end of  the  fade-in  effect  the
           output  video  will have the same intensity as the input video, at the end of the fade-out transition
           the output video will be filled with  the  selected  <b>color</b>.   If  both  duration  and  nb_frames  are
           specified, duration is used. Default is 0 (nb_frames is used by default).

       <b>color,</b> <b>c</b>
           Specify the color of the fade. Default is "black".

       <u>Examples</u>

       •   Fade in the first 30 frames of video:

                   fade=in:0:30

           The command above is equivalent to:

                   fade=t=in:s=0:n=30

       •   Fade out the last 45 frames of a 200-frame video:

                   fade=out:155:45
                   fade=type=out:start_frame=155:nb_frames=45

       •   Fade in the first 25 frames and fade out the last 25 frames of a 1000-frame video:

                   fade=in:0:25, fade=out:975:25

       •   Make the first 5 frames yellow, then fade in from frame 5-24:

                   fade=in:5:20:color=yellow

       •   Fade in alpha over first 25 frames of video:

                   fade=in:0:25:alpha=1

       •   Make the first 5.5 seconds black, then fade in for 0.5 seconds:

                   fade=t=in:st=5.5:d=0.5

   <b>feedback</b>
       Apply feedback video filter.

       This  filter  pass  cropped  input  frames to 2nd output.  From there it can be filtered with other video
       filters.  After filter receives frame from 2nd input, that frame is combined on  top  of  original  frame
       from 1st input and passed to 1st output.

       The typical usage is filter only part of frame.

       The filter accepts the following options:

       <b>x</b>
       <b>y</b>   Set the top left crop position.

       <b>w</b>
       <b>h</b>   Set the crop size.

       <u>Examples</u>

       •   Blur only top left rectangular part of video frame size 100x100 with gblur filter.

                   [in][blurin]feedback=x=0:y=0:w=100:h=100[out][blurout];[blurout]gblur=8[blurin]

       •   Draw black box on top left part of video frame of size 100x100 with drawbox filter.

                   [in][blurin]feedback=x=0:y=0:w=100:h=100[out][blurout];[blurout]drawbox=x=0:y=0:w=100:h=100:t=100[blurin]

       •   Pixelize rectangular part of video frame of size 100x100 with pixelize filter.

                   [in][blurin]feedback=x=320:y=240:w=100:h=100[out][blurout];[blurout]pixelize[blurin]

   <b>fftdnoiz</b>
       Denoise frames using 3D FFT (frequency domain filtering).

       The filter accepts the following options:

       <b>sigma</b>
           Set  the  noise  sigma  constant. This sets denoising strength.  Default value is 1. Allowed range is
           from 0 to 30.  Using very high sigma with low overlap may give blocking artifacts.

       <b>amount</b>
           Set amount of denoising. By default all detected noise is reduced.  Default value is 1. Allowed range
           is from 0 to 1.

       <b>block</b>
           Set size of block in pixels, Default is 32, can be 8 to 256.

       <b>overlap</b>
           Set block overlap. Default is 0.5. Allowed range is from 0.2 to 0.8.

       <b>method</b>
           Set denoising method. Default is "wiener", can also be "hard".

       <b>prev</b>
           Set number of previous frames to use for denoising. By default is set to 0.

       <b>next</b>
           Set number of next frames to to use for denoising. By default is set to 0.

       <b>planes</b>
           Set planes which will be filtered, by default are all available filtered except alpha.

   <b>fftfilt</b>
       Apply arbitrary expressions to samples in frequency domain

       <b>dc_Y</b>
           Adjust the dc value (gain) of the luma plane of the image. The filter accepts  an  integer  value  in
           range 0 to 1000. The default value is set to 0.

       <b>dc_U</b>
           Adjust  the dc value (gain) of the 1st chroma plane of the image. The filter accepts an integer value
           in range 0 to 1000. The default value is set to 0.

       <b>dc_V</b>
           Adjust the dc value (gain) of the 2nd chroma plane of the image. The filter accepts an integer  value
           in range 0 to 1000. The default value is set to 0.

       <b>weight_Y</b>
           Set the frequency domain weight expression for the luma plane.

       <b>weight_U</b>
           Set the frequency domain weight expression for the 1st chroma plane.

       <b>weight_V</b>
           Set the frequency domain weight expression for the 2nd chroma plane.

       <b>eval</b>
           Set when the expressions are evaluated.

           It accepts the following values:

           <b>init</b>
               Only evaluate expressions once during the filter initialization.

           <b>frame</b>
               Evaluate expressions for each incoming frame.

           Default value is <b>init</b>.

           The filter accepts the following variables:

       <b>X</b>
       <b>Y</b>   The coordinates of the current sample.

       <b>W</b>
       <b>H</b>   The width and height of the image.

       <b>N</b>   The number of input frame, starting from 0.

       <b>WS</b>
       <b>HS</b>  The size of FFT array for horizontal and vertical processing.

       <u>Examples</u>

       •   High-pass:

                   fftfilt=dc_Y=128:weight_Y='squish(1-(Y+X)/100)'

       •   Low-pass:

                   fftfilt=dc_Y=0:weight_Y='squish((Y+X)/100-1)'

       •   Sharpen:

                   fftfilt=dc_Y=0:weight_Y='1+squish(1-(Y+X)/100)'

       •   Blur:

                   fftfilt=dc_Y=0:weight_Y='exp(-4 * ((Y+X)/(W+H)))'

   <b>field</b>
       Extract  a  single  field from an interlaced image using stride arithmetic to avoid wasting CPU time. The
       output frames are marked as non-interlaced.

       The filter accepts the following options:

       <b>type</b>
           Specify whether to extract the top (if the value is 0 or "top") or the bottom field (if the value  is
           1 or "bottom").

   <b>fieldhint</b>
       Create new frames by copying the top and bottom fields from surrounding frames supplied as numbers by the
       hint file.

       <b>hint</b>
           Set file containing hints: absolute/relative frame numbers.

           There  must be one line for each frame in a clip. Each line must contain two numbers separated by the
           comma, optionally followed by "-" or "+".  Numbers supplied on each line of file can not  be  out  of
           [N-1,N+1]  where N is current frame number for "absolute" mode or out of [-1, 1] range for "relative"
           mode. First number tells from which frame to pick up top field and second  number  tells  from  which
           frame to pick up bottom field.

           If  optionally  followed  by  "+"  output frame will be marked as interlaced, else if followed by "-"
           output frame will be marked as progressive,  else  it  will  be  marked  same  as  input  frame.   If
           optionally  followed  by "t" output frame will use only top field, or in case of "b" it will use only
           bottom field.  If line starts with "#" or ";" that line is skipped.

       <b>mode</b>
           Can be item "absolute" or "relative" or "pattern". Default is "absolute".  The "pattern" mode is same
           as "relative" mode, except at last entry of file if there are more frames to process than "hint" file
           is seek back to start.

       Example of first several lines of "hint" file for "relative" mode:

               0,0 - # first frame
               1,0 - # second frame, use third's frame top field and second's frame bottom field
               1,0 - # third frame, use fourth's frame top field and third's frame bottom field
               1,0 -
               0,0 -
               0,0 -
               1,0 -
               1,0 -
               1,0 -
               0,0 -
               0,0 -
               1,0 -
               1,0 -
               1,0 -
               0,0 -

   <b>fieldmatch</b>
       Field matching filter for inverse telecine. It is meant to reconstruct  the  progressive  frames  from  a
       telecined  stream.  The filter does not drop duplicated frames, so to achieve a complete inverse telecine
       "fieldmatch" needs to be followed by a decimation filter such as <b>decimate</b> in the filtergraph.

       The separation of the field matching and the decimation  is  notably  motivated  by  the  possibility  of
       inserting  a  de-interlacing filter fallback between the two.  If the source has mixed telecined and real
       interlaced content, "fieldmatch" will not be able to match fields for the interlaced  parts.   But  these
       remaining  combed  frames  will  be marked as interlaced, and thus can be de-interlaced by a later filter
       such as <b>yadif</b> before decimation.

       In addition to the various configuration options,  "fieldmatch"  can  take  an  optional  second  stream,
       activated through the <b>ppsrc</b> option. If enabled, the frames reconstruction will be based on the fields and
       frames  from  this  second  stream.  This allows the first input to be pre-processed in order to help the
       various algorithms of the filter, while keeping the output lossless  (assuming  the  fields  are  matched
       properly). Typically, a field-aware denoiser, or brightness/contrast adjustments can help.

       Note that this filter uses the same algorithms as TIVTC/TFM (AviSynth project) and VIVTC/VFM (VapourSynth
       project).  The  later is a light clone of TFM from which "fieldmatch" is based on. While the semantic and
       usage are very close, some behaviour and options names can differ.

       The <b>decimate</b> filter currently only works for  constant  frame  rate  input.   If  your  input  has  mixed
       telecined (30fps) and progressive content with a lower framerate like 24fps use the following filterchain
       to produce the necessary cfr stream: "dejudder,fps=30000/1001,fieldmatch,decimate".

       The filter accepts the following options:

       <b>order</b>
           Specify the assumed field order of the input stream. Available values are:

           <b>auto</b>
               Auto detect parity (use FFmpeg's internal parity value).

           <b>bff</b> Assume bottom field first.

           <b>tff</b> Assume top field first.

           Note that it is sometimes recommended not to trust the parity announced by the stream.

           Default value is <u>auto</u>.

       <b>mode</b>
           Set  the  matching  mode  or  strategy  to use. <b>pc</b> mode is the safest in the sense that it won't risk
           creating jerkiness due to duplicate frames when possible, but if  there  are  bad  edits  or  blended
           fields  it  will end up outputting combed frames when a good match might actually exist. On the other
           hand, <b>pcn_ub</b> mode is the most risky in terms of creating jerkiness, but will  almost  always  find  a
           good  frame  if there is one. The other values are all somewhere in between <b>pc</b> and <b>pcn_ub</b> in terms of
           risking jerkiness and creating duplicate frames versus finding good  matches  in  sections  with  bad
           edits, orphaned fields, blended fields, etc.

           More details about p/c/n/u/b are available in <b>p/c/n/u/b</b> <b>meaning</b> section.

           Available values are:

           <b>pc</b>  2-way matching (p/c)

           <b>pc_n</b>
               2-way matching, and trying 3rd match if still combed (p/c + n)

           <b>pc_u</b>
               2-way matching, and trying 3rd match (same order) if still combed (p/c + u)

           <b>pc_n_ub</b>
               2-way matching, trying 3rd match if still combed, and trying 4th/5th matches if still combed (p/c
               + n + u/b)

           <b>pcn</b> 3-way matching (p/c/n)

           <b>pcn_ub</b>
               3-way  matching,  and  trying  4th/5th  matches  if all 3 of the original matches are detected as
               combed (p/c/n + u/b)

           The parenthesis at the end indicate the matches that would be used for that mode  assuming  <b>order</b>=<u>tff</u>
           (and <b>field</b> on <u>auto</u> or <u>top</u>).

           In terms of speed <b>pc</b> mode is by far the fastest and <b>pcn_ub</b> is the slowest.

           Default value is <u>pc_n</u>.

       <b>ppsrc</b>
           Mark  the  main  input  stream as a pre-processed input, and enable the secondary input stream as the
           clean source to pick the fields from. See the filter introduction for more details. It is similar  to
           the <b>clip2</b> feature from VFM/TFM.

           Default value is 0 (disabled).

       <b>field</b>
           Set  the  field  to  match  from. It is recommended to set this to the same value as <b>order</b> unless you
           experience matching failures with that setting. In certain circumstances changing the field  that  is
           used to match from can have a large impact on matching performance. Available values are:

           <b>auto</b>
               Automatic (same value as <b>order</b>).

           <b>bottom</b>
               Match from the bottom field.

           <b>top</b> Match from the top field.

           Default value is <u>auto</u>.

       <b>mchroma</b>
           Set  whether  or not chroma is included during the match comparisons. In most cases it is recommended
           to leave this enabled. You should set this to 0 only if your clip has bad  chroma  problems  such  as
           heavy  rainbowing  or other artifacts. Setting this to 0 could also be used to speed things up at the
           cost of some accuracy.

           Default value is 1.

       <b>y0</b>
       <b>y1</b>  These define an exclusion band which excludes the lines between <b>y0</b> and <b>y1</b> from being included in  the
           field  matching  decision. An exclusion band can be used to ignore subtitles, a logo, or other things
           that may interfere with the matching. <b>y0</b> sets the starting scan line and <b>y1</b> sets the ending line; all
           lines in between <b>y0</b> and <b>y1</b> (including <b>y0</b> and <b>y1</b>) will be ignored. Setting <b>y0</b> and <b>y1</b> to the same value
           will disable the feature.  <b>y0</b> and <b>y1</b> defaults to 0.

       <b>scthresh</b>
           Set the scene change detection threshold as a percentage of maximum change on the  luma  plane.  Good
           values  are in the "[8.0, 14.0]" range. Scene change detection is only relevant in case <b>combmatch</b>=<u>sc</u>.
           The range for <b>scthresh</b> is "[0.0, 100.0]".

           Default value is 12.0.

       <b>combmatch</b>
           When <b>combatch</b> is not <u>none</u>, "fieldmatch" will take into account the  combed  scores  of  matches  when
           deciding what match to use as the final match. Available values are:

           <b>none</b>
               No final matching based on combed scores.

           <b>sc</b>  Combed scores are only used when a scene change is detected.

           <b>full</b>
               Use combed scores all the time.

           Default is <u>sc</u>.

       <b>combdbg</b>
           Force  "fieldmatch"  to calculate the combed metrics for certain matches and print them. This setting
           is known as <b>micout</b> in TFM/VFM vocabulary.  Available values are:

           <b>none</b>
               No forced calculation.

           <b>pcn</b> Force p/c/n calculations.

           <b>pcnub</b>
               Force p/c/n/u/b calculations.

           Default value is <u>none</u>.

       <b>cthresh</b>
           This is the area combing threshold used for combed frame detection.  This  essentially  controls  how
           "strong"  or  "visible"  combing  must  be  to  be detected.  Larger values mean combing must be more
           visible and smaller values mean combing can be less visible or strong and still  be  detected.  Valid
           settings  are  from  -1 (every pixel will be detected as combed) to 255 (no pixel will be detected as
           combed). This is basically a pixel difference value. A good range is "[8, 12]".

           Default value is 9.

       <b>chroma</b>
           Sets whether or not chroma is considered in the combed frame decision.  Only  disable  this  if  your
           source  has  chroma  problems  (rainbowing,  etc.)  that  are  causing  problems for the combed frame
           detection with chroma enabled. Actually, using <b>chroma</b>=<u>0</u> is usually more reliable, except for the case
           where there is chroma only combing in the source.

           Default value is 0.

       <b>blockx</b>
       <b>blocky</b>
           Respectively set the x-axis and y-axis size of the window used during combed  frame  detection.  This
           has to do with the size of the area in which <b>combpel</b> pixels are required to be detected as combed for
           a  frame to be declared combed. See the <b>combpel</b> parameter description for more info.  Possible values
           are any number that is a power of 2 starting at 4 and going up to 512.

           Default value is 16.

       <b>combpel</b>
           The number of combed pixels inside any of the <b>blocky</b> by <b>blockx</b> size blocks on the frame for the frame
           to be detected as combed. While <b>cthresh</b> controls how "visible" the  combing  must  be,  this  setting
           controls  "how  much" combing there must be in any localized area (a window defined by the <b>blockx</b> and
           <b>blocky</b> settings) on the frame. Minimum value is 0 and maximum is "blocky x blockx" (at which point no
           frames will ever be detected as combed). This setting is known as <b>MI</b> in TFM/VFM vocabulary.

           Default value is 80.

       <u>p/c/n/u/b</u> <u>meaning</u>

       p/c/n

       We assume the following telecined stream:

               Top fields:     1 2 2 3 4
               Bottom fields:  1 2 3 4 4

       The numbers correspond to the progressive frame the fields relate to. Here,  the  first  two  frames  are
       progressive, the 3rd and 4th are combed, and so on.

       When  "fieldmatch"  is  configured  to  run  a matching from bottom (<b>field</b>=<u>bottom</u>) this is how this input
       stream get transformed:

               Input stream:
                               T     1 2 2 3 4
                               B     1 2 3 4 4   &lt;-- matching reference

               Matches:              c c n n c

               Output stream:
                               T     1 2 3 4 4
                               B     1 2 3 4 4

       As a result of the field matching, we can see that some frames get duplicated.   To  perform  a  complete
       inverse  telecine,  you  need  to  rely on a decimation filter after this operation. See for instance the
       <b>decimate</b> filter.

       The same operation now matching from top fields (<b>field</b>=<u>top</u>) looks like this:

               Input stream:
                               T     1 2 2 3 4   &lt;-- matching reference
                               B     1 2 3 4 4

               Matches:              c c p p c

               Output stream:
                               T     1 2 2 3 4
                               B     1 2 2 3 4

       In these examples, we can see what <u>p</u>, <u>c</u> and <u>n</u> mean; basically, they refer to the frame and field  of  the
       opposite parity:

       *&lt;<u>p</u> matches the field of the opposite parity in the previous frame&gt;
       *&lt;<u>c</u> matches the field of the opposite parity in the current frame&gt;
       *&lt;<u>n</u> matches the field of the opposite parity in the next frame&gt;

       u/b

       The <u>u</u> and <u>b</u> matching are a bit special in the sense that they match from the opposite parity flag. In the
       following  examples,  we assume that we are currently matching the 2nd frame (Top:2, bottom:2). According
       to the match, a 'x' is placed above and below each matched fields.

       With bottom matching (<b>field</b>=<u>bottom</u>):

               Match:           c         p           n          b          u

                                x       x               x        x          x
                 Top          1 2 2     1 2 2       1 2 2      1 2 2      1 2 2
                 Bottom       1 2 3     1 2 3       1 2 3      1 2 3      1 2 3
                                x         x           x        x              x

               Output frames:
                                2          1          2          2          2
                                2          2          2          1          3

       With top matching (<b>field</b>=<u>top</u>):

               Match:           c         p           n          b          u

                                x         x           x        x              x
                 Top          1 2 2     1 2 2       1 2 2      1 2 2      1 2 2
                 Bottom       1 2 3     1 2 3       1 2 3      1 2 3      1 2 3
                                x       x               x        x          x

               Output frames:
                                2          2          2          1          2
                                2          1          3          2          2

       <u>Examples</u>

       Simple IVTC of a top field first telecined stream:

               fieldmatch=order=tff:combmatch=none, decimate

       Advanced IVTC, with fallback on <b>yadif</b> for still combed frames:

               fieldmatch=order=tff:combmatch=full, yadif=deint=interlaced, decimate

   <b>fieldorder</b>
       Transform the field order of the input video.

       It accepts the following parameters:

       <b>order</b>
           The output field order. Valid values are <u>tff</u> for top field first or <u>bff</u> for bottom field first.

       The default value is <b>tff</b>.

       The transformation is done by shifting the picture content up or  down  by  one  line,  and  filling  the
       remaining  line  with  appropriate  picture content.  This method is consistent with most broadcast field
       order converters.

       If the input video is not flagged as being interlaced, or it is already flagged as being of the  required
       output field order, then this filter does not alter the incoming video.

       It is very useful when converting to or from PAL DV material, which is bottom field first.

       For example:

               ffmpeg -i in.vob -vf "fieldorder=bff" out.dv

   <b>fillborders</b>
       Fill  borders  of  the  input  video, without changing video stream dimensions.  Sometimes video can have
       garbage at the four edges and you may not want to crop video input to keep size multiple of some number.

       This filter accepts the following options:

       <b>left</b>
           Number of pixels to fill from left border.

       <b>right</b>
           Number of pixels to fill from right border.

       <b>top</b> Number of pixels to fill from top border.

       <b>bottom</b>
           Number of pixels to fill from bottom border.

       <b>mode</b>
           Set fill mode.

           It accepts the following values:

           <b>smear</b>
               fill pixels using outermost pixels

           <b>mirror</b>
               fill pixels using mirroring (half sample symmetric)

           <b>fixed</b>
               fill pixels with constant value

           <b>reflect</b>
               fill pixels using reflecting (whole sample symmetric)

           <b>wrap</b>
               fill pixels using wrapping

           <b>fade</b>
               fade pixels to constant value

           <b>margins</b>
               fill pixels at top and bottom with weighted averages pixels near borders

           Default is <u>smear</u>.

       <b>color</b>
           Set color for pixels in fixed or fade mode. Default is <u>black</u>.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.  The command accepts the same syntax of the  corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>find_rect</b>
       Find a rectangular object in the input video.

       The object to search for must be specified as a gray8 image specified with the <b>object</b> option.

       For each possible match, a score is computed. If the score reaches the specified threshold, the object is
       considered found.

       If the input video contains multiple instances of the object, the filter will find only one of them.

       When an object is found, the following metadata entries are set in the matching frame:

       <b>lavfi.rect.w</b>
           width of object

       <b>lavfi.rect.h</b>
           height of object

       <b>lavfi.rect.x</b>
           x position of object

       <b>lavfi.rect.y</b>
           y position of object

       <b>lavfi.rect.score</b>
           match score of the found object

       It accepts the following options:

       <b>object</b>
           Filepath of the object image, needs to be in gray8.

       <b>threshold</b>
           Detection threshold, expressed as a decimal number in the range 0-1.

           A  threshold  value  of  0.01  means  only exact matches, a threshold of 0.99 means almost everything
           matches.

           Default value is 0.5.

       <b>mipmaps</b>
           Number of mipmaps, default is 3.

       <b>xmin,</b> <b>ymin,</b> <b>xmax,</b> <b>ymax</b>
           Specifies the rectangle in which to search.

       <b>discard</b>
           Discard frames where object is not detected. Default is disabled.

       <u>Examples</u>

       •   Cover a rectangular object by the supplied image of a given video using <b>ffmpeg</b>:

                   ffmpeg -i file.ts -vf find_rect=newref.pgm,cover_rect=cover.jpg:mode=cover new.mkv

       •   Find the position of an object in each frame using <b>ffprobe</b> and write it to a log file:

                   ffprobe -f lavfi movie=test.mp4,find_rect=object=object.pgm:threshold=0.3 \
                     -show_entries frame=pkt_pts_time:frame_tags=lavfi.rect.x,lavfi.rect.y \
                     -of csv -o find_rect.csv

   <b>floodfill</b>
       Flood area with values of same pixel components with another values.

       It accepts the following options:

       <b>x</b>   Set pixel x coordinate.

       <b>y</b>   Set pixel y coordinate.

       <b>s0</b>  Set source #0 component value.

       <b>s1</b>  Set source #1 component value.

       <b>s2</b>  Set source #2 component value.

       <b>s3</b>  Set source #3 component value.

       <b>d0</b>  Set destination #0 component value.

       <b>d1</b>  Set destination #1 component value.

       <b>d2</b>  Set destination #2 component value.

       <b>d3</b>  Set destination #3 component value.

   <b>format</b>
       Convert the input video to one of the specified pixel formats.  Libavfilter will try to pick one that  is
       suitable as input to the next filter.

       It accepts the following parameters:

       <b>pix_fmts</b>
           A '|'-separated list of pixel format names, such as "pix_fmts=yuv420p|monow|rgb24".

       <b>color_spaces</b>
           A '|'-separated list of color space names, such as "color_spaces=bt709|bt470bg|bt2020nc".

       <b>color_ranges</b>
           A '|'-separated list of color range names, such as "color_spaces=tv|pc".

       <u>Examples</u>

       •   Convert the input video to the <u>yuv420p</u> format

                   format=pix_fmts=yuv420p

           Convert the input video to any of the formats in the list

                   format=pix_fmts=yuv420p|yuv444p|yuv410p

   <b>fps</b>
       Convert the video to specified constant frame rate by duplicating or dropping frames as necessary.

       It accepts the following parameters:

       <b>fps</b> The desired output frame rate. It accepts expressions containing the following constants:

           <b>source_fps</b>
               The input's frame rate

           <b>ntsc</b>
               NTSC frame rate of "30000/1001"

           <b>pal</b> PAL frame rate of 25.0

           <b>film</b>
               Film frame rate of 24.0

           <b>ntsc_film</b>
               NTSC-film frame rate of "24000/1001"

           The default is 25.

       <b>start_time</b>
           Assume  the  first PTS should be the given value, in seconds. This allows for padding/trimming at the
           start of stream. By default, no assumption is made about  the  first  frame's  expected  PTS,  so  no
           padding  or  trimming  is  done.   For  example,  this  could  be  set to 0 to pad the beginning with
           duplicates of the first frame if a video stream starts after the audio stream or to trim  any  frames
           with a negative PTS.

       <b>round</b>
           Timestamp (PTS) rounding method.

           Possible values are:

           <b>zero</b>
               round towards 0

           <b>inf</b> round away from 0

           <b>down</b>
               round towards -infinity

           <b>up</b>  round towards +infinity

           <b>near</b>
               round to nearest

           The default is "near".

       <b>eof_action</b>
           Action performed when reading the last frame.

           Possible values are:

           <b>round</b>
               Use same timestamp rounding method as used for other frames.

           <b>pass</b>
               Pass through last frame if input duration has not been reached yet.

           The default is "round".

       Alternatively, the options can be specified as a flat string: <u>fps</u>[:<u>start_time</u>[:<u>round</u>]].

       See also the <b>setpts</b> filter.

       <u>Examples</u>

       •   A typical usage in order to set the fps to 25:

                   fps=fps=25

       •   Sets the fps to 24, using abbreviation and rounding method to round to nearest:

                   fps=fps=film:round=near

   <b>framepack</b>
       Pack  two different video streams into a stereoscopic video, setting proper metadata on supported codecs.
       The two views should have the same size and framerate and processing will stop  when  the  shorter  video
       ends. Please note that you may conveniently adjust view properties with the <b>scale</b> and <b>fps</b> filters.

       It accepts the following parameters:

       <b>format</b>
           The desired packing format. Supported values are:

           <b>sbs</b> The views are next to each other (default).

           <b>tab</b> The views are on top of each other.

           <b>lines</b>
               The views are packed by line.

           <b>columns</b>
               The views are packed by column.

           <b>frameseq</b>
               The views are temporally interleaved.

       Some examples:

               # Convert left and right views into a frame-sequential video
               ffmpeg -i LEFT -i RIGHT -filter_complex framepack=frameseq OUTPUT

               # Convert views into a side-by-side video with the same output resolution as the input
               ffmpeg -i LEFT -i RIGHT -filter_complex [0:v]scale=w=iw/2[left],[1:v]scale=w=iw/2[right],[left][right]framepack=sbs OUTPUT

   <b>framerate</b>
       Change the frame rate by interpolating new video output frames from the source frames.

       This  filter is not designed to function correctly with interlaced media. If you wish to change the frame
       rate of interlaced media then you are required to deinterlace before this filter and  re-interlace  after
       this filter.

       A description of the accepted options follows.

       <b>fps</b> Specify the output frames per second. This option can also be specified as a value alone. The default
           is 50.

       <b>interp_start</b>
           Specify  the start of a range where the output frame will be created as a linear interpolation of two
           frames. The range is [0-255], the default is 15.

       <b>interp_end</b>
           Specify the end of a range where the output frame will be created as a linear  interpolation  of  two
           frames. The range is [0-255], the default is 240.

       <b>scene</b>
           Specify  the level at which a scene change is detected as a value between 0 and 100 to indicate a new
           scene; a low value reflects a low probability for the current frame to introduce a new scene, while a
           higher value means the current frame is more likely to be one.  The default is 8.2.

       <b>flags</b>
           Specify flags influencing the filter process.

           Available value for <u>flags</u> is:

           <b>scene_change_detect,</b> <b>scd</b>
               Enable scene change detection using the value of the option  <u>scene</u>.   This  flag  is  enabled  by
               default.

   <b>framestep</b>
       Select one frame every N-th frame.

       This filter accepts the following option:

       <b>step</b>
           Select  frame after every "step" frames.  Allowed values are positive integers higher than 0. Default
           value is 1.

   <b>freezedetect</b>
       Detect frozen video.

       This filter logs a message and sets  frame  metadata  when  it  detects  that  the  input  video  has  no
       significant  change  in  content during a specified duration.  Video freeze detection calculates the mean
       average absolute difference of all the components of video frames and compares it to a noise floor.

       The printed times and duration are expressed in seconds. The  "lavfi.freezedetect.freeze_start"  metadata
       key  is  set  on the first frame whose timestamp equals or exceeds the detection duration and it contains
       the  timestamp  of  the  first  frame  of  the  freeze.  The   "lavfi.freezedetect.freeze_duration"   and
       "lavfi.freezedetect.freeze_end" metadata keys are set on the first frame after the freeze.

       The filter accepts the following options:

       <b>noise,</b> <b>n</b>
           Set noise tolerance. Can be specified in dB (in case "dB" is appended to the specified value) or as a
           difference ratio between 0 and 1. Default is -60dB, or 0.001.

       <b>duration,</b> <b>d</b>
           Set freeze duration until notification (default is 2 seconds).

   <b>freezeframes</b>
       Freeze video frames.

       This filter freezes video frames using frame from 2nd input.

       The filter accepts the following options:

       <b>first</b>
           Set number of first frame from which to start freeze.

       <b>last</b>
           Set number of last frame from which to end freeze.

       <b>replace</b>
           Set number of frame from 2nd input which will be used instead of replaced frames.

   <b>frei0r</b>
       Apply a frei0r effect to the input video.

       To enable the compilation of this filter, you need to install the frei0r header and configure FFmpeg with
       "--enable-frei0r".

       It accepts the following parameters:

       <b>filter_name</b>
           The name of the frei0r effect to load. If the environment variable <b>FREI0R_PATH</b> is defined, the frei0r
           effect  is  searched  for  in  each  of  the  directories  specified  by  the colon-separated list in
           <b>FREI0R_PATH</b>.  Otherwise, the standard frei0r paths are searched, in this order:  <u>HOME/.frei0r-1/lib/</u>,
           <u>/usr/local/lib/frei0r-1/</u>, <u>/usr/lib/frei0r-1/</u>.

       <b>filter_params</b>
           A '|'-separated list of parameters to pass to the frei0r effect.

       A frei0r effect parameter can be a boolean (its value is either "y" or "n"), a double, a color (specified
       as  <u>R</u>/<u>G</u>/<u>B</u>,  where  <u>R</u>,  <u>G</u>,  and  <u>B</u>  are  floating point numbers between 0.0 and 1.0, inclusive) or a color
       description as specified in the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>, a position (specified as <u>X</u>/<u>Y</u>,
       where <u>X</u> and <u>Y</u> are floating point numbers) and/or a string.

       The number and types of parameters depend on the loaded effect. If an effect parameter is not  specified,
       the default value is set.

       <u>Examples</u>

       •   Apply the distort0r effect, setting the first two double parameters:

                   frei0r=filter_name=distort0r:filter_params=0.5|0.01

       •   Apply the colordistance effect, taking a color as the first parameter:

                   frei0r=colordistance:0.2/0.3/0.4
                   frei0r=colordistance:violet
                   frei0r=colordistance:0x112233

       •   Apply the perspective effect, specifying the top left and top right image positions:

                   frei0r=perspective:0.2/0.2|0.8/0.2

       For more information, see &lt;<b><a href="http://frei0r.dyne.org">http://frei0r.dyne.org</a></b>&gt;

       <u>Commands</u>

       This filter supports the <b>filter_params</b> option as <b>commands</b>.

   <b>fspp</b>
       Apply fast and simple postprocessing. It is a faster version of <b>spp</b>.

       It  splits (I)DCT into horizontal/vertical passes. Unlike the simple post- processing filter, one of them
       is performed once per block, not per pixel.  This allows for much higher speed.

       The filter accepts the following options:

       <b>quality</b>
           Set quality. This option defines the number of levels for averaging. It accepts  an  integer  in  the
           range 4-5. Default value is 4.

       <b>qp</b>  Force a constant quantization parameter. It accepts an integer in range 0-63.  If not set, the filter
           will use the QP from the video stream (if available).

       <b>strength</b>
           Set  filter  strength.  It  accepts an integer in range -15 to 32. Lower values mean more details but
           also more artifacts, while higher values make the image smoother but also blurrier. Default value  is
           0 − PSNR optimal.

       <b>use_bframe_qp</b>
           Enable the use of the QP from the B-Frames if set to 1. Using this option may cause flicker since the
           B-Frames have often larger QP. Default is 0 (not enabled).

   <b>fsync</b>
       Synchronize video frames with an external mapping from a file.

       For  each  input  PTS  given  in  the  map file it either drops or creates as many frames as necessary to
       recreate the sequence of output frames given in the map file.

       This filter is useful to recreate the output frames of a framerate conversion by the <b>fps</b> filter, recorded
       into a map file using the ffmpeg option "-stats_mux_pre", and do further processing to the  corresponding
       frames e.g. quality comparison.

       Each  line  of the map file must contain three items per input frame, the input PTS (decimal), the output
       PTS (decimal) and the output  TIMEBASE  (decimal/decimal),  seperated  by  a  space.   This  file  format
       corresponds to the output of "-stats_mux_pre_fmt="{ptsi} {pts} {tb}"".

       The filter assumes the map file is sorted by increasing input PTS.

       The filter accepts the following options:

       <b>file,</b> <b>f</b>
           The filename of the map file to be used.

       Example:

               # Convert a video to 25 fps and record a MAP_FILE file with the default format of this filter
               ffmpeg -i INPUT -vf fps=fps=25 -stats_mux_pre MAP_FILE -stats_mux_pre_fmt "{ptsi} {pts} {tb}" OUTPUT

               # Sort MAP_FILE by increasing input PTS
               sort -n MAP_FILE

               # Use INPUT, OUTPUT and the MAP_FILE from above to compare the corresponding frames in INPUT and OUTPUT via SSIM
               ffmpeg -i INPUT -i OUTPUT -filter_complex '[0:v]fsync=file=MAP_FILE[ref];[1:v][ref]ssim' -f null -

   <b>gblur</b>
       Apply Gaussian blur filter.

       The filter accepts the following options:

       <b>sigma</b>
           Set horizontal sigma, standard deviation of Gaussian blur. Default is 0.5.

       <b>steps</b>
           Set number of steps for Gaussian approximation. Default is 1.

       <b>planes</b>
           Set which planes to filter. By default all planes are filtered.

       <b>sigmaV</b>
           Set vertical sigma, if negative it will be same as "sigma".  Default is -1.

       <u>Commands</u>

       This  filter supports same commands as options.  The command accepts the same syntax of the corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>geq</b>
       Apply generic equation to each pixel.

       The filter accepts the following options:

       <b>lum_expr,</b> <b>lum</b>
           Set the luma expression.

       <b>cb_expr,</b> <b>cb</b>
           Set the chrominance blue expression.

       <b>cr_expr,</b> <b>cr</b>
           Set the chrominance red expression.

       <b>alpha_expr,</b> <b>a</b>
           Set the alpha expression.

       <b>red_expr,</b> <b>r</b>
           Set the red expression.

       <b>green_expr,</b> <b>g</b>
           Set the green expression.

       <b>blue_expr,</b> <b>b</b>
           Set the blue expression.

       The colorspace is selected according to the specified options.  If  one  of  the  <b>lum_expr</b>,  <b>cb_expr</b>,  or
       <b>cr_expr</b>  options  is  specified,  the  filter will automatically select a YCbCr colorspace. If one of the
       <b>red_expr</b>, <b>green_expr</b>, or <b>blue_expr</b> options is specified, it will select an RGB colorspace.

       If one of the chrominance expression is not defined, it  falls  back  on  the  other  one.  If  no  alpha
       expression  is  specified  it  will  evaluate  to  opaque  value.  If none of chrominance expressions are
       specified, they will evaluate to the luma expression.

       The expressions can use the following variables and functions:

       <b>N</b>   The sequential number of the filtered frame, starting from 0.

       <b>X</b>
       <b>Y</b>   The coordinates of the current sample.

       <b>W</b>
       <b>H</b>   The width and height of the image.

       <b>SW</b>
       <b>SH</b>  Width and height scale depending on the currently  filtered  plane.  It  is  the  ratio  between  the
           corresponding  luma  plane  number of pixels and the current plane ones. E.g. for YUV4:2:0 the values
           are "1,1" for the luma plane, and "0.5,0.5" for chroma planes.

       <b>T</b>   Time of the current frame, expressed in seconds.

       <b>p(x,</b> <b>y)</b>
           Return the value of the pixel at location (<u>x</u>,<u>y</u>) of the current plane.

       <b>lum(x,</b> <b>y)</b>
           Return the value of the pixel at location (<u>x</u>,<u>y</u>) of the luma plane.

       <b>cb(x,</b> <b>y)</b>
           Return the value of the pixel at location (<u>x</u>,<u>y</u>) of the blue-difference  chroma  plane.  Return  0  if
           there is no such plane.

       <b>cr(x,</b> <b>y)</b>
           Return the value of the pixel at location (<u>x</u>,<u>y</u>) of the red-difference chroma plane. Return 0 if there
           is no such plane.

       <b>r(x,</b> <b>y)</b>
       <b>g(x,</b> <b>y)</b>
       <b>b(x,</b> <b>y)</b>
           Return the value of the pixel at location (<u>x</u>,<u>y</u>) of the red/green/blue component. Return 0 if there is
           no such component.

       <b>alpha(x,</b> <b>y)</b>
           Return  the  value  of  the  pixel at location (<u>x</u>,<u>y</u>) of the alpha plane. Return 0 if there is no such
           plane.

       <b>psum(x,y),</b> <b>lumsum(x,</b> <b>y),</b> <b>cbsum(x,y),</b> <b>crsum(x,y),</b> <b>rsum(x,y),</b> <b>gsum(x,y),</b> <b>bsum(x,y),</b> <b>alphasum(x,y)</b>
           Sum of sample values in the rectangle from (0,0) to (x,y), this  allows  obtaining  sums  of  samples
           within a rectangle. See the functions without the sum postfix.

       <b>interpolation</b>
           Set one of interpolation methods:

           <b>nearest,</b> <b>n</b>
           <b>bilinear,</b> <b>b</b>

           Default is bilinear.

       For  functions,  if  <u>x</u>  and <u>y</u> are outside the area, the value will be automatically clipped to the closer
       edge.

       Please note that this filter can use multiple threads  in  which  case  each  slice  will  have  its  own
       expression  state.  If  you want to use only a single expression state because your expressions depend on
       previous state then you should limit the number of filter threads to 1.

       <u>Examples</u>

       •   Flip the image horizontally:

                   geq=p(W-X\,Y)

       •   Generate a bidimensional sine wave, with angle "PI/3" and a wavelength of 100 pixels:

                   geq=128 + 100*sin(2*(PI/100)*(cos(PI/3)*(X-50*T) + sin(PI/3)*Y)):128:128

       •   Generate a fancy enigmatic moving light:

                   nullsrc=s=256x256,geq=<a href="../man1/random.1.html">random</a>(1)/hypot(X-cos(N*0.07)*W/2-W/2\,Y-sin(N*0.09)*H/2-H/2)^2*1000000*sin(N*0.02):128:128

       •   Generate a quick emboss effect:

                   format=gray,geq=lum_expr='(p(X,Y)+(256-p(X-4,Y-4)))/2'

       •   Modify RGB components depending on pixel position:

                   geq=r='X/W*r(X,Y)':g='(1-X/W)*g(X,Y)':b='(H-Y)/H*b(X,Y)'

       •   Create a radial gradient that is the same size as the input (also see the <b>vignette</b> filter):

                   geq=lum=255*gauss((X/W-0.5)*3)*gauss((Y/H-0.5)*3)/<a href="../man0/gauss.0.html">gauss</a>(0)/<a href="../man0/gauss.0.html">gauss</a>(0),format=gray

   <b>gradfun</b>
       Fix the banding artifacts that are sometimes introduced into nearly flat regions by truncation  to  8-bit
       color depth.  Interpolate the gradients that should go where the bands are, and dither them.

       It is designed for playback only.  Do not use it prior to lossy compression, because compression tends to
       lose the dither and bring back the bands.

       It accepts the following parameters:

       <b>strength</b>
           The  maximum  amount  by  which  the filter will change any one pixel. This is also the threshold for
           detecting nearly flat regions. Acceptable values range from .51 to 64; the default value is 1.2. Out-
           of-range values will be clipped to the valid range.

       <b>radius</b>
           The neighborhood to fit the gradient to. A larger radius  makes  for  smoother  gradients,  but  also
           prevents  the filter from modifying the pixels near detailed regions. Acceptable values are 8-32; the
           default value is 16. Out-of-range values will be clipped to the valid range.

       Alternatively, the options can be specified as a flat string: <u>strength</u>[:<u>radius</u>]

       <u>Examples</u>

       •   Apply the filter with a 3.5 strength and radius of 8:

                   gradfun=3.5:8

       •   Specify radius, omitting the strength (which will fall-back to the default value):

                   gradfun=radius=8

   <b>graphmonitor</b>
       Show various filtergraph stats.

       With this filter one can debug complete filtergraph.  Especially issues with links  filling  with  queued
       frames.

       The filter accepts the following options:

       <b>size,</b> <b>s</b>
           Set video output size. Default is <u>hd720</u>.

       <b>opacity,</b> <b>o</b>
           Set video opacity. Default is <u>0.9</u>. Allowed range is from <u>0</u> to <u>1</u>.

       <b>mode,</b> <b>m</b>
           Set output mode flags.

           Available values for flags are:

           <b>full</b>
               No any filtering. Default.

           <b>compact</b>
               Show only filters with queued frames.

           <b>nozero</b>
               Show only filters with non-zero stats.

           <b>noeof</b>
               Show only filters with non-eof stat.

           <b>nodisabled</b>
               Show only filters that are enabled in timeline.

       <b>flags,</b> <b>f</b>
           Set flags which enable which stats are shown in video.

           Available values for flags are:

           <b>none</b>
               All flags turned off.

           <b>all</b> All flags turned on.

           <b>queue</b>
               Display number of queued frames in each link.

           <b>frame_count_in</b>
               Display number of frames taken from filter.

           <b>frame_count_out</b>
               Display number of frames given out from filter.

           <b>frame_count_delta</b>
               Display delta number of frames between above two values.

           <b>pts</b> Display current filtered frame pts.

           <b>pts_delta</b>
               Display pts delta between current and previous frame.

           <b>time</b>
               Display current filtered frame time.

           <b>time_delta</b>
               Display time delta between current and previous frame.

           <b>timebase</b>
               Display time base for filter link.

           <b>format</b>
               Display used format for filter link.

           <b>size</b>
               Display video size or number of audio channels in case of audio used by filter link.

           <b>rate</b>
               Display video frame rate or sample rate in case of audio used by filter link.

           <b>eof</b> Display link output status.

           <b>sample_count_in</b>
               Display number of samples taken from filter.

           <b>sample_count_out</b>
               Display number of samples given out from filter.

           <b>sample_count_delta</b>
               Display delta number of samples between above two values.

           <b>disabled</b>
               Show the timeline filter status.

       <b>rate,</b> <b>r</b>
           Set  upper  limit  for  video rate of output stream, Default value is <u>25</u>.  This guarantee that output
           video frame rate will not be higher than this value.

   <b>grayworld</b>
       A color constancy filter that applies color correction based on the grayworld assumption

       See:
       &lt;<b>https://www.researchgate.net/publication/275213614_A_New_Color_Correction_Method_for_Underwater_Imaging</b>&gt;

       The algorithm  uses linear light, so input data should be linearized beforehand (and  possibly  correctly
       tagged).

               ffmpeg -i INPUT -vf zscale=transfer=linear,grayworld,zscale=transfer=bt709,format=yuv420p OUTPUT

   <b>greyedge</b>
       A  color  constancy  variation  filter  which  estimates  scene  illumination via grey edge algorithm and
       corrects the scene colors accordingly.

       See: &lt;<b>https://staff.science.uva.nl/th.gevers/pub/GeversTIP07.pdf</b>&gt;

       The filter accepts the following options:

       <b>difford</b>
           The order of differentiation to be applied on the scene. Must  be  chosen  in  the  range  [0,2]  and
           default value is 1.

       <b>minknorm</b>
           The  Minkowski  parameter  to  be  used for calculating the Minkowski distance. Must be chosen in the
           range [0,20] and default value is 1. Set to 0 for getting max value instead of calculating  Minkowski
           distance.

       <b>sigma</b>
           The  standard  deviation  of  Gaussian  blur  to be applied on the scene. Must be chosen in the range
           [0,1024.0] and default value = 1. floor( <u>sigma</u> * <b><a href="../man3/break_off_sigma.3.html">break_off_sigma</a></b>(3) ) can't be equal to 0 if  <u>difford</u>
           is greater than 0.

       <u>Examples</u>

       •   Grey Edge:

                   greyedge=difford=1:minknorm=5:sigma=2

       •   Max Edge:

                   greyedge=difford=1:minknorm=0:sigma=2

   <b>guided</b>
       Apply guided filter for edge-preserving smoothing, dehazing and so on.

       The filter accepts the following options:

       <b>radius</b>
           Set the box radius in pixels.  Allowed range is 1 to 20. Default is 3.

       <b>eps</b> Set regularization parameter (with square).  Allowed range is 0 to 1. Default is 0.01.

       <b>mode</b>
           Set filter mode. Can be "basic" or "fast".  Default is "basic".

       <b>sub</b> Set  subsampling  ratio  for  "fast" mode.  Range is 2 to 64. Default is 4.  No subsampling occurs in
           "basic" mode.

       <b>guidance</b>
           Set guidance mode. Can be "off" or "on". Default is "off".  If "off", single input is  required.   If
           "on",  two  inputs  of the same resolution and pixel format are required.  The second input serves as
           the guidance.

       <b>planes</b>
           Set planes to filter. Default is first only.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

       <u>Examples</u>

       •   Edge-preserving smoothing with guided filter:

                   ffmpeg -i in.png -vf guided out.png

       •   Dehazing,  structure-transferring  filtering,  detail  enhancement  with  guided  filter.   For   the
           generation    of    guidance    image,    refer    to   paper   "Guided   Image   Filtering".    See:
           &lt;<b><a href="http://kaiminghe.com/publications/pami12guidedfilter.pdf">http://kaiminghe.com/publications/pami12guidedfilter.pdf</a></b>&gt;.

                   ffmpeg -i in.png -i guidance.png -filter_complex guided=guidance=on out.png

   <b>haldclut</b>
       Apply a Hald CLUT to a video stream.

       First input is the video stream to process, and second one is the Hald CLUT.  The Hald CLUT input can  be
       a simple picture or a complete video stream.

       The filter accepts the following options:

       <b>clut</b>
           Set  which CLUT video frames will be processed from second input stream, can be <u>first</u> or <u>all</u>. Default
           is <u>all</u>.

       <b>shortest</b>
           Force termination when the shortest input terminates. Default is 0.

       <b>repeatlast</b>
           Continue applying the last CLUT after the end of the stream. A value of 0 disable  the  filter  after
           the last frame of the CLUT is reached.  Default is 1.

       "haldclut" also has the same interpolation options as <b>lut3d</b> (both filters share the same internals).

       This filter also supports the <b>framesync</b> options.

       More  information  about  the  Hald  CLUT can be found on Eskil Steenberg's website (Hald CLUT author) at
       &lt;<b><a href="http://www.quelsolaar.com/technology/clut.html">http://www.quelsolaar.com/technology/clut.html</a></b>&gt;.

       <u>Commands</u>

       This filter supports the "interp" option as <b>commands</b>.

       <u>Workflow</u> <u>examples</u>

       Hald CLUT video stream

       Generate an identity Hald CLUT stream altered with various effects:

               ffmpeg -f lavfi -i B&lt;haldclutsrc&gt;=8 -vf "hue=H=2*PI*t:s=sin(2*PI*t)+1, curves=cross_process" -t 10 -c:v ffv1 clut.nut

       Note: make sure you use a lossless codec.

       Then use it with "haldclut" to apply it on some random stream:

               ffmpeg -f lavfi -i mandelbrot -i clut.nut -filter_complex '[0][1] haldclut' -t 20 mandelclut.mkv

       The Hald CLUT will be applied to the 10 first seconds (duration of <u>clut.nut</u>), then the latest picture  of
       that CLUT stream will be applied to the remaining frames of the "mandelbrot" stream.

       Hald CLUT with preview

       A Hald CLUT is supposed to be a squared image of "Level*Level*Level" by "Level*Level*Level" pixels. For a
       given  Hald CLUT, FFmpeg will select the biggest possible square starting at the top left of the picture.
       The remaining padding pixels (bottom or right) will be ignored. This area can be used to add a preview of
       the Hald CLUT.

       Typically, the following generated Hald CLUT will be supported by the "haldclut" filter:

               ffmpeg -f lavfi -i B&lt;haldclutsrc&gt;=8 -vf "
                  pad=iw+320 [padded_clut];
                  smptebars=s=320x256, split [a][b];
                  [padded_clut][a] overlay=W-320:h, curves=color_negative [main];
                  [main][b] overlay=W-320" -frames:v 1 clut.png

       It contains the original and a preview of the effect of the CLUT: SMPTE color bars are displayed  on  the
       right-top, and below the same color bars processed by the color changes.

       Then, the effect of this Hald CLUT can be visualized with:

               ffplay input.mkv -vf "movie=clut.png, [in] haldclut"

   <b>hflip</b>
       Flip the input video horizontally.

       For example, to horizontally flip the input video with <b>ffmpeg</b>:

               ffmpeg -i in.avi -vf "hflip" out.avi

   <b>histeq</b>
       This filter applies a global color histogram equalization on a per-frame basis.

       It  can  be  used  to  correct  video  that  has  a  compressed  range  of pixel intensities.  The filter
       redistributes the pixel intensities to equalize their distribution across the intensity range. It may  be
       viewed  as  an  "automatically  adjusting  contrast  filter".  This  filter is useful only for correcting
       degraded or poorly captured source video.

       The filter accepts the following options:

       <b>strength</b>
           Determine the amount of equalization to be applied.  As the strength is reduced, the distribution  of
           pixel  intensities more-and-more approaches that of the input frame. The value must be a float number
           in the range [0,1] and defaults to 0.200.

       <b>intensity</b>
           Set the maximum intensity that can generated and scale the output values appropriately.  The strength
           should be set as desired and then the intensity can be limited if needed to  avoid  washing-out.  The
           value must be a float number in the range [0,1] and defaults to 0.210.

       <b>antibanding</b>
           Set the antibanding level. If enabled the filter will randomly vary the luminance of output pixels by
           a  small amount to avoid banding of the histogram. Possible values are "none", "weak" or "strong". It
           defaults to "none".

   <b>histogram</b>
       Compute and draw a color distribution histogram for the input video.

       The computed histogram is a representation of the color component distribution in an image.

       Standard histogram displays the color components distribution in an image.  Displays color graph for each
       color component. Shows distribution of the Y, U, V, A or R, G, B components, depending on  input  format,
       in the current frame. Below each graph a color component scale meter is shown.

       The filter accepts the following options:

       <b>level_height</b>
           Set height of level. Default value is 200.  Allowed range is [50, 2048].

       <b>scale_height</b>
           Set height of color scale. Default value is 12.  Allowed range is [0, 40].

       <b>display_mode</b>
           Set display mode.  It accepts the following values:

           <b>stack</b>
               Per color component graphs are placed below each other.

           <b>parade</b>
               Per color component graphs are placed side by side.

           <b>overlay</b>
               Presents information identical to that in the "parade", except that the graphs representing color
               components are superimposed directly over one another.

           Default is "stack".

       <b>levels_mode</b>
           Set mode. Can be either "linear", or "logarithmic".  Default is "linear".

       <b>components</b>
           Set what color components to display.  Default is 7.

       <b>fgopacity</b>
           Set foreground opacity. Default is 0.7.

       <b>bgopacity</b>
           Set background opacity. Default is 0.5.

       <b>colors_mode</b>
           Set colors mode.  It accepts the following values:

           <b>whiteonblack</b>
           <b>blackonwhite</b>
           <b>whiteongray</b>
           <b>blackongray</b>
           <b>coloronblack</b>
           <b>coloronwhite</b>
           <b>colorongray</b>
           <b>blackoncolor</b>
           <b>whiteoncolor</b>
           <b>grayoncolor</b>

           Default is "whiteonblack".

       <u>Examples</u>

       •   Calculate and draw histogram:

                   ffplay -i input -vf histogram

   <b>hqdn3d</b>
       This  is  a  high  precision/quality  3d  denoise filter. It aims to reduce image noise, producing smooth
       images and making still images really still. It should enhance compressibility.

       It accepts the following optional parameters:

       <b>luma_spatial</b>
           A non-negative floating point number which specifies spatial luma strength.  It defaults to 4.0.

       <b>chroma_spatial</b>
           A non-negative floating point number  which  specifies  spatial  chroma  strength.   It  defaults  to
           3.0*<u>luma_spatial</u>/4.0.

       <b>luma_tmp</b>
           A floating point number which specifies luma temporal strength. It defaults to 6.0*<u>luma_spatial</u>/4.0.

       <b>chroma_tmp</b>
           A   floating   point   number   which   specifies   chroma   temporal   strength.   It   defaults  to
           <u>luma_tmp</u>*<u>chroma_spatial</u>/<u>luma_spatial</u>.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.  The command accepts the same syntax of the  corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>hwdownload</b>
       Download hardware frames to system memory.

       The  input  must  be  in  hardware frames, and the output a non-hardware format.  Not all formats will be
       supported on the output - it may be necessary to insert an additional <b>format</b> filter immediately following
       in the graph to get the output in a supported format.

   <b>hwmap</b>
       Map hardware frames to system memory or to another device.

       This filter has several different modes of operation; which one is used depends on the input  and  output
       formats:

       •   Hardware frame input, normal frame output

           Map the input frames to system memory and pass them to the output.  If the original hardware frame is
           later  required (for example, after overlaying something else on part of it), the <b>hwmap</b> filter can be
           used again in the next mode to retrieve it.

       •   Normal frame input, hardware frame output

           If the input is actually a software-mapped hardware frame, then  unmap  it  -  that  is,  return  the
           original hardware frame.

           Otherwise,  a  device  must be provided.  Create new hardware surfaces on that device for the output,
           then map them back to the software format at the input and give those frames to the preceding filter.
           This will then act like the <b>hwupload</b> filter, but may be able to avoid an  additional  copy  when  the
           input is already in a compatible format.

       •   Hardware frame input and output

           A  device  must  be  supplied  for the output, either directly or with the <b>derive_device</b> option.  The
           input and output devices must be of different types and compatible - the exact  meaning  of  this  is
           system-dependent, but typically it means that they must refer to the same underlying hardware context
           (for example, refer to the same graphics card).

           If the input frames were originally created on the output device, then unmap to retrieve the original
           frames.

           Otherwise,  map  the  frames  to  the  output  device  -  create  new  hardware  frames on the output
           corresponding to the frames on the input.

       The following additional parameters are accepted:

       <b>mode</b>
           Set the frame mapping mode.  Some combination of:

           <u>read</u>
               The mapped frame should be readable.

           <u>write</u>
               The mapped frame should be writeable.

           <u>overwrite</u>
               The mapping will always overwrite the entire frame.

               This may improve performance in some cases, as the original contents of the  frame  need  not  be
               loaded.

           <u>direct</u>
               The mapping must not involve any copying.

               Indirect  mappings  to  copies of frames are created in some cases where either direct mapping is
               not possible or it would have unexpected properties.  Setting this flag ensures that the  mapping
               is direct and will fail if that is not possible.

           Defaults to <u>read+write</u> if not specified.

       <b>derive_device</b> <u>type</u>
           Rather  than  using  the  device supplied at initialisation, instead derive a new device of type <u>type</u>
           from the device the input frames exist on.

       <b>reverse</b>
           In a hardware to hardware mapping, map in reverse - create frames in the sink and map  them  back  to
           the  source.   This  may  be necessary in some cases where a mapping in one direction is required but
           only the opposite direction is supported by the devices being used.

           This option is dangerous - it may break the preceding filter in  undefined  ways  if  there  are  any
           additional  constraints  on  that  filter's  output.   Do  not use it without fully understanding the
           implications of its use.

   <b>hwupload</b>
       Upload system memory frames to hardware surfaces.

       The device to upload to must be supplied when the filter is initialised.  If  using  ffmpeg,  select  the
       appropriate  device  with  the  <b>-filter_hw_device</b> option or with the <b>derive_device</b> option.  The input and
       output devices must be of different types and compatible - the exact meaning of this is system-dependent,
       but typically it means that they must refer to the same underlying hardware context (for  example,  refer
       to the same graphics card).

       The following additional parameters are accepted:

       <b>derive_device</b> <u>type</u>
           Rather  than  using  the  device supplied at initialisation, instead derive a new device of type <u>type</u>
           from the device the input frames exist on.

   <b>hwupload_cuda</b>
       Upload system memory frames to a CUDA device.

       It accepts the following optional parameters:

       <b>device</b>
           The number of the CUDA device to use

   <b>hqx</b>
       Apply a high-quality magnification filter designed for pixel art. This filter was originally  created  by
       Maxim Stepin.

       It accepts the following option:

       <b>n</b>   Set the scaling dimension: 2 for "hq2x", 3 for "hq3x" and 4 for "hq4x".  Default is 3.

   <b>hstack</b>
       Stack input videos horizontally.

       All streams must be of same pixel format and of same height.

       Note that this filter is faster than using <b>overlay</b> and <b>pad</b> filter to create same output.

       The filter accepts the following option:

       <b>inputs</b>
           Set number of input streams. Default is 2.

       <b>shortest</b>
           If set to 1, force the output to terminate when the shortest input terminates. Default value is 0.

   <b>hsvhold</b>
       Turns a certain HSV range into gray values.

       This filter measures color difference between set HSV color in options and ones measured in video stream.
       Depending on options, output colors can be changed to be gray or not.

       The filter accepts the following options:

       <b>hue</b> Set  the hue value which will be used in color difference calculation.  Allowed range is from -360 to
           360. Default value is 0.

       <b>sat</b> Set the saturation value which will be used in color difference calculation.  Allowed range  is  from
           -1 to 1. Default value is 0.

       <b>val</b> Set  the  value  which  will be used in color difference calculation.  Allowed range is from -1 to 1.
           Default value is 0.

       <b>similarity</b>
           Set similarity percentage with the key color.  Allowed range is from 0 to 1. Default value is 0.01.

           0.00001 matches only the exact key color, while 1.0 matches everything.

       <b>blend</b>
           Blend percentage.  Allowed range is from 0 to 1. Default value is 0.

           0.0 makes pixels either fully gray, or not gray at all.

           Higher values result in more gray pixels, with a higher gray pixel the more similar the pixels  color
           is to the key color.

   <b>hsvkey</b>
       Turns a certain HSV range into transparency.

       This filter measures color difference between set HSV color in options and ones measured in video stream.
       Depending on options, output colors can be changed to transparent by adding alpha channel.

       The filter accepts the following options:

       <b>hue</b> Set  the hue value which will be used in color difference calculation.  Allowed range is from -360 to
           360. Default value is 0.

       <b>sat</b> Set the saturation value which will be used in color difference calculation.  Allowed range  is  from
           -1 to 1. Default value is 0.

       <b>val</b> Set  the  value  which  will be used in color difference calculation.  Allowed range is from -1 to 1.
           Default value is 0.

       <b>similarity</b>
           Set similarity percentage with the key color.  Allowed range is from 0 to 1. Default value is 0.01.

           0.00001 matches only the exact key color, while 1.0 matches everything.

       <b>blend</b>
           Blend percentage.  Allowed range is from 0 to 1. Default value is 0.

           0.0 makes pixels either fully transparent, or not transparent at all.

           Higher values result in semi-transparent pixels, with a higher  transparency  the  more  similar  the
           pixels color is to the key color.

   <b>hue</b>
       Modify the hue and/or the saturation of the input.

       It accepts the following parameters:

       <b>h</b>   Specify the hue angle as a number of degrees. It accepts an expression, and defaults to "0".

       <b>s</b>   Specify the saturation in the [-10,10] range. It accepts an expression and defaults to "1".

       <b>H</b>   Specify the hue angle as a number of radians. It accepts an expression, and defaults to "0".

       <b>b</b>   Specify the brightness in the [-10,10] range. It accepts an expression and defaults to "0".

       <b>h</b> and <b>H</b> are mutually exclusive, and can't be specified at the same time.

       The <b>b</b>, <b>h</b>, <b>H</b> and <b>s</b> option values are expressions containing the following constants:

       <b>n</b>   frame count of the input frame starting from 0

       <b>pts</b> presentation timestamp of the input frame expressed in time base units

       <b>r</b>   frame rate of the input video, NAN if the input frame rate is unknown

       <b>t</b>   timestamp expressed in seconds, NAN if the input timestamp is unknown

       <b>tb</b>  time base of the input video

       <u>Examples</u>

       •   Set the hue to 90 degrees and the saturation to 1.0:

                   hue=h=90:s=1

       •   Same command but expressing the hue in radians:

                   hue=H=PI/2:s=1

       •   Rotate hue and make the saturation swing between 0 and 2 over a period of 1 second:

                   hue="H=2*PI*t: s=sin(2*PI*t)+1"

       •   Apply a 3 seconds saturation fade-in effect starting at 0:

                   hue="s=min(t/3\,1)"

           The general fade-in expression can be written as:

                   hue="s=min(0\, max((t-START)/DURATION\, 1))"

       •   Apply a 3 seconds saturation fade-out effect starting at 5 seconds:

                   hue="s=max(0\, min(1\, (8-t)/3))"

           The general fade-out expression can be written as:

                   hue="s=max(0\, min(1\, (START+DURATION-t)/DURATION))"

       <u>Commands</u>

       This filter supports the following commands:

       <b>b</b>
       <b>s</b>
       <b>h</b>
       <b>H</b>   Modify  the  hue and/or the saturation and/or brightness of the input video.  The command accepts the
           same syntax of the corresponding option.

           If the specified expression is not valid, it is kept at its current value.

   <b>huesaturation</b>
       Apply hue-saturation-intensity adjustments to input video stream.

       This filter operates in RGB colorspace.

       This filter accepts the following options:

       <b>hue</b> Set the hue shift in degrees to apply. Default is 0.  Allowed range is from -180 to 180.

       <b>saturation</b>
           Set the saturation shift. Default is 0.  Allowed range is from -1 to 1.

       <b>intensity</b>
           Set the intensity shift. Default is 0.  Allowed range is from -1 to 1.

       <b>colors</b>
           Set which primary and complementary colors are  going  to  be  adjusted.   This  options  is  set  by
           providing one or multiple values.  This can select multiple colors at once. By default all colors are
           selected.

           <b>r</b>   Adjust reds.

           <b>y</b>   Adjust yellows.

           <b>g</b>   Adjust greens.

           <b>c</b>   Adjust cyans.

           <b>b</b>   Adjust blues.

           <b>m</b>   Adjust magentas.

           <b>a</b>   Adjust all colors.

       <b>strength</b>
           Set strength of filtering. Allowed range is from 0 to 100.  Default value is 1.

       <b>rw,</b> <b>gw,</b> <b>bw</b>
           Set  weight for each RGB component. Allowed range is from 0 to 1.  By default is set to 0.333, 0.334,
           0.333.  Those options are used in saturation and lightess processing.

       <b>lightness</b>
           Set preserving lightness, by default is disabled.  Adjusting hues can change lightness from  original
           RGB triplet, with this option enabled lightness is kept at same value.

   <b>hysteresis</b>
       Grow  first  stream  into  second  stream by connecting components.  This makes it possible to build more
       robust edge masks.

       This filter accepts the following options:

       <b>planes</b>
           Set which planes will be processed as bitmap, unprocessed planes will be copied  from  first  stream.
           By default value 0xf, all planes will be processed.

       <b>threshold</b>
           Set  threshold  which is used in filtering. If pixel component value is higher than this value filter
           algorithm for connecting components is activated.  By default value is 0.

       The "hysteresis" filter also supports the <b>framesync</b> options.

   <b>iccdetect</b>
       Detect the colorspace   from  an  embedded  ICC  profile  (if  present),  and  update  the  frame's  tags
       accordingly.

       This filter accepts the following options:

       <b>force</b>
           If  true,  the  frame's existing colorspace tags will always be overridden by values detected from an
           ICC profile. Otherwise, they will only be assigned if they contain "unknown". Enabled by default.

   <b>iccgen</b>
       Generate ICC profiles and attach them to frames.

       This filter accepts the following options:

       <b>color_primaries</b>
       <b>color_trc</b>
           Configure the colorspace that the ICC profile will be generated for.  The  default  value  of  "auto"
           infers the value from the input frame's metadata, defaulting to BT.709/sRGB as appropriate.

           See  the <b>setparams</b> filter for a list of possible values, but note that "unknown" are not valid values
           for this filter.

       <b>force</b>
           If true, an ICC profile will be generated even if it would overwrite an already existing ICC profile.
           Disabled by default.

   <b>identity</b>
       Obtain the identity score between two input videos.

       This filter takes two input videos.

       Both input videos must have the same resolution and pixel format for this filter to work correctly.  Also
       it assumes that both inputs have the same number of frames, which are compared one by one.

       The obtained per component, average, min and max identity score is printed through the logging system.

       The filter stores the calculated identity scores of each frame in frame metadata.

       This filter also supports the <b>framesync</b> options.

       In the below example the input file <u>main.mpg</u> being processed is compared with the reference file <u>ref.mpg</u>.

               ffmpeg -i main.mpg -i ref.mpg -lavfi identity -f null -

   <b>idet</b>
       Detect video interlacing type.

       This  filter  tries to detect if the input frames are interlaced, progressive, top or bottom field first.
       It will also try to detect fields that are repeated between adjacent frames (a sign of telecine).

       Single frame detection considers only immediately adjacent frames when classifying each frame.   Multiple
       frame detection incorporates the classification history of previous frames.

       The filter will log these metadata values:

       <b>single.current_frame</b>
           Detected  type  of  current  frame  using  single-frame detection. One of: ``tff'' (top field first),
           ``bff'' (bottom field first), ``progressive'', or ``undetermined''

       <b>single.tff</b>
           Cumulative number of frames detected as top field first using single-frame detection.

       <b>multiple.tff</b>
           Cumulative number of frames detected as top field first using multiple-frame detection.

       <b>single.bff</b>
           Cumulative number of frames detected as bottom field first using single-frame detection.

       <b>multiple.current_frame</b>
           Detected type of current frame using multiple-frame detection. One of:  ``tff''  (top  field  first),
           ``bff'' (bottom field first), ``progressive'', or ``undetermined''

       <b>multiple.bff</b>
           Cumulative number of frames detected as bottom field first using multiple-frame detection.

       <b>single.progressive</b>
           Cumulative number of frames detected as progressive using single-frame detection.

       <b>multiple.progressive</b>
           Cumulative number of frames detected as progressive using multiple-frame detection.

       <b>single.undetermined</b>
           Cumulative number of frames that could not be classified using single-frame detection.

       <b>multiple.undetermined</b>
           Cumulative number of frames that could not be classified using multiple-frame detection.

       <b>repeated.current_frame</b>
           Which  field  in  the  current  frame  is  repeated  from  the  last. One of ``neither'', ``top'', or
           ``bottom''.

       <b>repeated.neither</b>
           Cumulative number of frames with no repeated field.

       <b>repeated.top</b>
           Cumulative number of frames with the top field repeated from the previous frame's top field.

       <b>repeated.bottom</b>
           Cumulative number of frames with the bottom field repeated from the previous frame's bottom field.

       The filter accepts the following options:

       <b>intl_thres</b>
           Set interlacing threshold.

       <b>prog_thres</b>
           Set progressive threshold.

       <b>rep_thres</b>
           Threshold for repeated field detection.

       <b>half_life</b>
           Number of frames after which a given frame's contribution to  the  statistics  is  halved  (i.e.,  it
           contributes  only  0.5  to its classification). The default of 0 means that all frames seen are given
           full weight of 1.0 forever.

       <b>analyze_interlaced_flag</b>
           When this is not 0 then idet will use the specified number of frames to determine if  the  interlaced
           flag is accurate, it will not count undetermined frames.  If the flag is found to be accurate it will
           be  used without any further computations, if it is found to be inaccurate it will be cleared without
           any further computations. This allows inserting the idet filter as  a  low  computational  method  to
           clean up the interlaced flag

       <u>Examples</u>

       Inspect the field order of the first 360 frames in a video, in verbose detail:

               ffmpeg -i INPUT -filter:v idet,metadata=mode=print -frames:v 360 -an -f null -

       The  idet  filter will add analysis metadata to each frame, which will then be discarded. At the end, the
       filter will also print a final report with statistics.

   <b>il</b>
       Deinterleave or interleave fields.

       This filter allows one to process interlaced images fields  without  deinterlacing  them.  Deinterleaving
       splits  the  input  frame into 2 fields (so called half pictures). Odd lines are moved to the top half of
       the output image, even lines to the bottom half.  You can process (filter) them  independently  and  then
       re-interleave them.

       The filter accepts the following options:

       <b>luma_mode,</b> <b>l</b>
       <b>chroma_mode,</b> <b>c</b>
       <b>alpha_mode,</b> <b>a</b>
           Available values for <u>luma_mode</u>, <u>chroma_mode</u> and <u>alpha_mode</u> are:

           <b>none</b>
               Do nothing.

           <b>deinterleave,</b> <b>d</b>
               Deinterleave fields, placing one above the other.

           <b>interleave,</b> <b>i</b>
               Interleave fields. Reverse the effect of deinterleaving.

           Default value is "none".

       <b>luma_swap,</b> <b>ls</b>
       <b>chroma_swap,</b> <b>cs</b>
       <b>alpha_swap,</b> <b>as</b>
           Swap luma/chroma/alpha fields. Exchange even &amp; odd lines. Default value is 0.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>inflate</b>
       Apply inflate effect to the video.

       This  filter  replaces the pixel by the <a href="../man3x3/local.3x3.html">local</a>(3x3) average by taking into account only values higher than
       the pixel.

       It accepts the following options:

       <b>threshold0</b>
       <b>threshold1</b>
       <b>threshold2</b>
       <b>threshold3</b>
           Limit the maximum change for each plane, default is 65535.  If 0, plane will remain unchanged.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>interlace</b>
       Simple interlacing filter from progressive contents. This interleaves upper (or  lower)  lines  from  odd
       frames with lower (or upper) lines from even frames, halving the frame rate and preserving image height.

                  Original        Original             New Frame
                  Frame 'j'      Frame 'j+1'             (tff)
                 ==========      ===========       ==================
                   Line 0  --------------------&gt;    Frame 'j' Line 0
                   Line 1          Line 1  ----&gt;   Frame 'j+1' Line 1
                   Line 2 ---------------------&gt;    Frame 'j' Line 2
                   Line 3          Line 3  ----&gt;   Frame 'j+1' Line 3
                    ...             ...                   ...
               New Frame + 1 will be generated by Frame 'j+2' and Frame 'j+3' and so on

       It accepts the following optional parameters:

       <b>scan</b>
           This  determines  whether  the  interlaced  frame is taken from the even (tff - default) or odd (bff)
           lines of the progressive frame.

       <b>lowpass</b>
           Vertical lowpass filter to avoid twitter interlacing and reduce moire patterns.

           <b>0,</b> <b>off</b>
               Disable vertical lowpass filter

           <b>1,</b> <b>linear</b>
               Enable linear filter (default)

           <b>2,</b> <b>complex</b>
               Enable complex filter. This will slightly less reduce twitter and moire but better retain  detail
               and subjective sharpness impression.

   <b>kerndeint</b>
       Deinterlace  input video by applying Donald Graft's adaptive kernel deinterling. Work on interlaced parts
       of a video to produce progressive frames.

       The description of the accepted parameters follows.

       <b>thresh</b>
           Set the threshold which affects the filter's tolerance when determining  if  a  pixel  line  must  be
           processed. It must be an integer in the range [0,255] and defaults to 10. A value of 0 will result in
           applying the process on every pixels.

       <b>map</b> Paint pixels exceeding the threshold value to white if set to 1.  Default is 0.

       <b>order</b>
           Set the fields order. Swap fields if set to 1, leave fields alone if 0. Default is 0.

       <b>sharp</b>
           Enable additional sharpening if set to 1. Default is 0.

       <b>twoway</b>
           Enable twoway sharpening if set to 1. Default is 0.

       <u>Examples</u>

       •   Apply default values:

                   kerndeint=thresh=10:map=0:order=0:sharp=0:twoway=0

       •   Enable additional sharpening:

                   kerndeint=sharp=1

       •   Paint processed pixels in white:

                   kerndeint=map=1

   <b>kirsch</b>
       Apply kirsch operator to input video stream.

       The filter accepts the following option:

       <b>planes</b>
           Set  which  planes  will  be processed, unprocessed planes will be copied.  By default value 0xf, all
           planes will be processed.

       <b>scale</b>
           Set value which will be multiplied with filtered result.

       <b>delta</b>
           Set value which will be added to filtered result.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>lagfun</b>
       Slowly update darker pixels.

       This filter makes short flashes of light appear longer.  This filter accepts the following options:

       <b>decay</b>
           Set factor for decaying. Default is .95. Allowed range is from 0 to 1.

       <b>planes</b>
           Set which planes to filter. Default is all. Allowed range is from 0 to 15.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>lenscorrection</b>
       Correct radial lens distortion

       This filter can be used to correct for radial distortion as can result from the use of wide angle lenses,
       and thereby re-rectify the image. To find the right parameters one can use tools available for example as
       part of opencv or simply trial-and-error.  To use opencv use the calibration sample  (under  samples/cpp)
       from the opencv sources and extract the k1 and k2 coefficients from the resulting matrix.

       Note  that  effectively  the same filter is available in the open-source tools Krita and Digikam from the
       KDE project.

       In contrast to the <b>vignette</b> filter, which can also  be  used  to  compensate  lens  errors,  this  filter
       corrects  the  distortion of the image, whereas <b>vignette</b> corrects the brightness distribution, so you may
       want to use both filters together in certain cases, though you will have to take care of  ordering,  i.e.
       whether vignetting should be applied before or after lens correction.

       <u>Options</u>

       The filter accepts the following options:

       <b>cx</b>  Relative x-coordinate of the focal point of the image, and thereby the center of the distortion. This
           value has a range [0,1] and is expressed as fractions of the image width. Default is 0.5.

       <b>cy</b>  Relative y-coordinate of the focal point of the image, and thereby the center of the distortion. This
           value has a range [0,1] and is expressed as fractions of the image height. Default is 0.5.

       <b>k1</b>  Coefficient  of  the quadratic correction term. This value has a range [-1,1]. 0 means no correction.
           Default is 0.

       <b>k2</b>  Coefficient of the double quadratic correction term. This value has  a  range  [-1,1].   0  means  no
           correction. Default is 0.

       <b>i</b>   Set interpolation type. Can be "nearest" or "bilinear".  Default is "nearest".

       <b>fc</b>  Specify the color of the unmapped pixels. For the syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b>
           <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>. Default color is "black@0".

       The formula that generates the correction is:

       <u>r_src</u> = <u>r_tgt</u> * (1 + <u>k1</u> * (<u>r_tgt</u> / <u>r_0</u>)^2 + <u>k2</u> * (<u>r_tgt</u> / <u>r_0</u>)^4)

       where  <u>r_0</u>  is  halve of the image diagonal and <u>r_src</u> and <u>r_tgt</u> are the distances from the focal point in
       the source and target images, respectively.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>lensfun</b>
       Apply lens correction via the lensfun library (&lt;<b><a href="http://lensfun.sourceforge.net/">http://lensfun.sourceforge.net/</a></b>&gt;).

       The "lensfun" filter requires the camera make, camera model, and lens model to apply the lens correction.
       The filter will load the lensfun database and query it to find the corresponding camera and lens  entries
       in  the  database.  As  long as these entries can be found with the given options, the filter can perform
       corrections on frames. Note that incomplete strings will result in the filter  choosing  the  best  match
       with  the  given options, and the filter will output the chosen camera and lens models (logged with level
       "info"). You must provide the make, camera model, and lens model as they are required.

       To obtain a list of available makes and models, leave out one or both of "make" and "model" options.  The
       filter will send the full list to the log with level "INFO".  The first column is the make and the second
       column  is  the model.  To obtain a list of available lenses, set any values for make and model and leave
       out the "lens_model" option. The filter will send the full list of lenses in the log with  level  "INFO".
       The ffmpeg tool will exit after the list is printed.

       The filter accepts the following options:

       <b>make</b>
           The make of the camera (for example, "Canon"). This option is required.

       <b>model</b>
           The model of the camera (for example, "Canon EOS 100D"). This option is required.

       <b>lens_model</b>
           The model of the lens (for example, "Canon EF-S 18-55mm f/3.5-5.6 IS STM"). This option is required.

       <b>db_path</b>
           The  full  path to the lens database folder. If not set, the filter will attempt to load the database
           from the install path when the library was built. Default is unset.

       <b>mode</b>
           The type of correction to apply. The following values are valid options:

           <b>vignetting</b>
               Enables fixing lens vignetting.

           <b>geometry</b>
               Enables fixing lens geometry. This is the default.

           <b>subpixel</b>
               Enables fixing chromatic aberrations.

           <b>vig_geo</b>
               Enables fixing lens vignetting and lens geometry.

           <b>vig_subpixel</b>
               Enables fixing lens vignetting and chromatic aberrations.

           <b>distortion</b>
               Enables fixing both lens geometry and chromatic aberrations.

           <b>all</b> Enables all possible corrections.

       <b>focal_length</b>
           The focal length of the image/video (zoom; expected constant for video). For example, a 18--55mm lens
           has focal length range of [18--55], so a value in that range should be chosen when using  that  lens.
           Default 18.

       <b>aperture</b>
           The  aperture  of  the image/video (expected constant for video). Note that aperture is only used for
           vignetting correction. Default 3.5.

       <b>focus_distance</b>
           The focus distance of the image/video (expected constant for video). Note that focus distance is only
           used for vignetting and only slightly affects the vignetting correction process. If unknown, leave it
           at the default value (which is 1000).

       <b>scale</b>
           The scale factor which is applied after transformation. After  correction  the  video  is  no  longer
           necessarily  rectangular.  This  parameter  controls  how much of the resulting image is visible. The
           value 0 means that a value will be chosen automatically such that there is little or no unmapped area
           in the output image. 1.0 means that no additional scaling is done. Lower values may result in more of
           the corrected image being visible, while higher values may avoid unmapped areas in the output.

       <b>target_geometry</b>
           The target geometry of the output image/video. The following values are valid options:

           <b>rectilinear</b> <b>(default)</b>
           <b>fisheye</b>
           <b>panoramic</b>
           <b>equirectangular</b>
           <b>fisheye_orthographic</b>
           <b>fisheye_stereographic</b>
           <b>fisheye_equisolid</b>
           <b>fisheye_thoby</b>
       <b>reverse</b>
           Apply the reverse of image correction (instead of correcting distortion, apply it).

       <b>interpolation</b>
           The type of interpolation used when correcting distortion. The following values are valid options:

           <b>nearest</b>
           <b>linear</b> <b>(default)</b>
           <b>lanczos</b>

       <u>Examples</u>

       •   Apply lens correction with make "Canon", camera model "Canon EOS 100D", and lens  model  "Canon  EF-S
           18-55mm f/3.5-5.6 IS STM" with focal length of "18" and aperture of "8.0".

                   ffmpeg -i input.mov -vf lensfun=make=Canon:model="Canon EOS 100D":lens_model="Canon EF-S 18-55mm f/3.5-5.6 IS STM":focal_length=18:aperture=8 -c:v h264 -b:v 8000k output.mov

       •   Apply the same as before, but only for the first 5 seconds of video.

                   ffmpeg -i input.mov -vf lensfun=make=Canon:model="Canon EOS 100D":lens_model="Canon EF-S 18-55mm f/3.5-5.6 IS STM":focal_length=18:aperture=8:enable='lte(t\,5)' -c:v h264 -b:v 8000k output.mov

   <b>libplacebo</b>
       Flexible         GPU-accelerated        processing        filter        based        on        libplacebo
       (&lt;<b>https://code.videolan.org/videolan/libplacebo</b>&gt;).

       <u>Options</u>

       The options for this filter are divided into the following sections:

       Output mode

       These options control the overall output mode. By default, libplacebo will try  to  preserve  the  source
       colorimetry  and size as best as it can, but it will apply any embedded film grain, dolby vision metadata
       or anamorphic SAR present in source frames.

       <b>inputs</b>
           Set the number of inputs. This can be used, alongside the "idx" variable, to  allow  placing/blending
           multiple  inputs  inside  the output frame. This effectively enables functionality similar to <b>hstack</b>,
           <b>overlay</b>, etc.

       <b>w</b>
       <b>h</b>   Set the output video dimension expression. Default values are "iw" and "ih".

           Allows for the same expressions as the <b>scale</b> filter.

       <b>crop_x</b>
       <b>crop_y</b>
           Set the input crop x/y expressions, default values are "(iw-cw)/2" and "(ih-ch)/2".

       <b>crop_w</b>
       <b>crop_h</b>
           Set the input crop width/height expressions, default values are "iw" and "ih".

       <b>pos_x</b>
       <b>pos_y</b>
           Set the output placement x/y expressions, default values are "(ow-pw)/2" and "(oh-ph)/2".

       <b>pos_w</b>
       <b>pos_h</b>
           Set the output placement width/height expressions, default values are "ow" and "oh".

       <b>fps</b> Set the output frame rate. This can be rational, e.g. "60000/1001". If  set  to  the  special  string
           "none"  (the  default),  input  timestamps  will  instead be passed through to the output unmodified.
           Otherwise, the input video frames will be interpolated as necessary  to  rescale  the  video  to  the
           specified target framerate, in a manner as determined by the <b>frame_mixer</b> option.

       <b>format</b>
           Set  the  output format override. If unset (the default), frames will be output in the same format as
           the respective input frames. Otherwise, format conversion will be performed.

       <b>force_original_aspect_ratio</b>
       <b>force_divisible_by</b>
           Work the same as the identical <b>scale</b> filter options.

       <b>normalize_sar</b>
           If enabled, output frames will always  have  a  pixel  aspect  ratio  of  1:1.  This  will  introduce
           additional  padding/cropping  as  necessary.  If disabled (the default), any aspect ratio mismatches,
           including those from e.g. anamorphic video sources, are forwarded to the output pixel aspect ratio.

       <b>pad_crop_ratio</b>
           Specifies a ratio (between 0.0 and 1.0) between padding and cropping when the input aspect ratio does
           not match the output aspect ratio and <b>normalize_sar</b> is in effect. The default of 0.0 always pads  the
           content  with black borders, while a value of 1.0 always crops off parts of the content. Intermediate
           values are possible, leading to a mix of the two approaches.

       <b>fillcolor</b>
           Set the color used to fill the output area not covered by the output image, for example as  a  result
           of  <b>normalize_sar</b>.  For  the  general syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-</b>
           <b>utils</b> <b>manual</b>. Defaults to "black".

       <b>corner_rounding</b>
           Render frames with rounded corners. The value, given as a float ranging from 0.0  to  1.0,  indicates
           the  relative  degree  of rounding, from fully square to fully circular. In other words, it gives the
           radius divided by half the smaller side length. Defaults to 0.0.

       <b>extra_opts</b>
           Pass extra libplacebo internal configuration options. These can be specified as a list  of  <u>key</u>=<u>value</u>
           pairs  separated  by  ':'.  The following example shows how to configure a custom filter kernel ("EWA
           LanczosSharp") and use it to double the input image resolution:

                   -vf "libplacebo=w=iw*2:h=ih*2:extra_opts='upscaler=custom\:upscaler_preset=ewa_lanczos\:upscaler_blur=0.9812505644269356'"

       <b>colorspace</b>
       <b>color_primaries</b>
       <b>color_trc</b>
       <b>range</b>
           Configure the colorspace that output frames will be delivered in. The default value of "auto" outputs
           frames in the same format as the input frames, leading to no change. For any other value,  conversion
           will be performed.

           See the <b>setparams</b> filter for a list of possible values.

       <b>apply_filmgrain</b>
           Apply  film  grain  (e.g.  AV1  or  H.274) if present in source frames, and strip it from the output.
           Enabled by default.

       <b>apply_dolbyvision</b>
           Apply Dolby Vision RPU metadata if present in source frames, and strip it from the output. Enabled by
           default. Note that Dolby Vision will always output  BT.2020+PQ,  overriding  the  usual  input  frame
           metadata. These will also be picked as the values of "auto" for the respective frame output options.

       In  addition  to  the  expression  constants documented for the <b>scale</b> filter, the <b>crop_w</b>, <b>crop_h</b>, <b>crop_x</b>,
       <b>crop_y</b>, <b>pos_w</b>, <b>pos_h</b>, <b>pos_x</b> and <b>pos_y</b> options can also contain the following constants:

       <b>in_idx,</b> <b>idx</b>
           The (0-based) numeric index of the currently active input stream.

       <b>crop_w,</b> <b>cw</b>
       <b>crop_h,</b> <b>ch</b>
           The computed values of <b>crop_w</b> and <b>crop_h</b>.

       <b>pos_w,</b> <b>pw</b>
       <b>pos_h,</b> <b>ph</b>
           The computed values of <b>pos_w</b> and <b>pos_h</b>.

       <b>in_t,</b> <b>t</b>
           The input frame timestamp, in seconds. NAN if input timestamp is unknown.

       <b>out_t,</b> <b>ot</b>
           The input frame timestamp, in seconds. NAN if input timestamp is unknown.

       <b>n</b>   The input frame number, starting with 0.

       Scaling

       The options in this section control how libplacebo performs upscaling  and  (if  necessary)  downscaling.
       Note  that  libplacebo will always internally operate on 4:4:4 content, so any sub-sampled chroma formats
       such as "yuv420p" will necessarily be upsampled and downsampled as part of the  rendering  process.  That
       means scaling might be in effect even if the source and destination resolution are the same.

       <b>upscaler</b>
       <b>downscaler</b>
           Configure  the  filter  kernel  used  for  upscaling  and  downscaling.  The  respective defaults are
           "spline36" and "mitchell". For a full list of possible values, pass "help" to these options. The most
           important values are:

           <b>none</b>
               Forces the use of built-in GPU texture sampling (typically bilinear).  Extremely  fast  but  poor
               quality, especially when downscaling.

           <b>bilinear</b>
               Bilinear  interpolation.  Can generally be done for free on GPUs, except when doing so would lead
               to aliasing. Fast and low quality.

           <b>nearest</b>
               Nearest-neighbour interpolation. Sharp but highly aliasing.

           <b>oversample</b>
               Algorithm that looks visually similar to nearest-neighbour interpolation but  tries  to  preserve
               pixel  aspect  ratio.  Good for pixel art, since it results in minimal distortion of the artistic
               appearance.

           <b>lanczos</b>
               Standard sinc-sinc interpolation kernel.

           <b>spline36</b>
               Cubic spline approximation of lanczos. No difference in performance, but has very  slightly  less
               ringing.

           <b>ewa_lanczos</b>
               Elliptically  weighted  average  version  of  lanczos, based on a jinc-sinc kernel.  This is also
               popularly referred to as just "Jinc scaling". Slow but very high quality.

           <b>gaussian</b>
               Gaussian kernel. Has certain ideal mathematical properties, but subjectively very blurry.

           <b>mitchell</b>
               Cubic BC spline with parameters recommended by Mitchell and Netravali. Very little ringing.

       <b>frame_mixer</b>
           Controls the kernel used for mixing frames temporally. The default value is  "none",  which  disables
           frame  mixing.  For  a  full  list of possible values, pass "help" to this option. The most important
           values are:

           <b>none</b>
               Disables frame mixing, giving a result equivalent to "nearest neighbour" semantics.

           <b>oversample</b>
               Oversamples the input video to create a "Smooth Motion"-type effect: if  an  output  frame  would
               exactly  fall on the transition between two video frames, it is blended according to the relative
               overlap. This is the recommended option whenever preserving the original subjective appearance is
               desired.

           <b>mitchell_clamp</b>
               Larger filter kernel that smoothly interpolates multiple frames in a manner designed to eliminate
               ringing and other artefacts as much as possible. This is the recommended option wherever  maximum
               visual smoothness is desired.

           <b>linear</b>
               Linear blend/fade between frames. Especially useful for constructing e.g.  slideshows.

       <b>lut_entries</b>
           Configures  the  size  of scaler LUTs, ranging from 1 to 256. The default of 0 will pick libplacebo's
           internal default, typically 64.

       <b>antiringing</b>
           Enables anti-ringing (for non-EWA filters). The value (between 0.0 and 1.0) configures  the  strength
           of the anti-ringing algorithm. May increase aliasing if set too high. Disabled by default.

       <b>sigmoid</b>
           Enable sigmoidal compression during upscaling. Reduces ringing slightly.  Enabled by default.

       Debanding

       Libplacebo  comes  with  a built-in debanding filter that is good at counteracting many common sources of
       banding and blocking. Turning this on is highly recommended whenever quality is desired.

       <b>deband</b>
           Enable (fast) debanding algorithm. Disabled by default.

       <b>deband_iterations</b>
           Number  of  deband  iterations  of  the  debanding  algorithm.  Each  iteration  is  performed   with
           progressively  increased radius (and diminished threshold).  Recommended values are in the range 1 to
           4. Defaults to 1.

       <b>deband_threshold</b>
           Debanding filter strength. Higher numbers lead to more aggressive debanding.  Defaults to 4.0.

       <b>deband_radius</b>
           Debanding filter radius. A higher radius is better for slow gradients, while a lower radius is better
           for steep gradients. Defaults to 16.0.

       <b>deband_grain</b>
           Amount of extra output grain to add. Helps hide imperfections. Defaults to 6.0.

       Color adjustment

       A collection of subjective color controls. Not very rigorous, so the  exact  effect  will  vary  somewhat
       depending on the input primaries and colorspace.

       <b>brightness</b>
           Brightness boost, between -1.0 and 1.0. Defaults to 0.0.

       <b>contrast</b>
           Contrast gain, between 0.0 and 16.0. Defaults to 1.0.

       <b>saturation</b>
           Saturation gain, between 0.0 and 16.0. Defaults to 1.0.

       <b>hue</b> Hue  shift  in  radians,  between -3.14 and 3.14. Defaults to 0.0. This will rotate the UV subvector,
           defaulting to BT.709 coefficients for RGB inputs.

       <b>gamma</b>
           Gamma adjustment, between 0.0 and 16.0. Defaults to 1.0.

       <b>cones</b>
           Cone model to use for color blindness simulation. Accepts any combination of "l", "m" and  "s".  Here
           are some examples:

           <b>m</b>   Deuteranomaly / deuteranopia (affecting 3%-4% of the population)

           <b>l</b>   Protanomaly / protanopia (affecting 1%-2% of the population)

           <b>l+m</b> Monochromacy (very rare)

           <b>l+m+s</b>
               Achromatopsy (complete loss of daytime vision, extremely rare)

       <b>cone-strength</b>
           Gain  factor  for  the cones specified by "cones", between 0.0 and 10.0. A value of 1.0 results in no
           change to color vision. A value of 0.0 (the default) simulates complete loss of those  cones.  Values
           above 1.0 result in exaggerating the differences between cones, which may help compensate for reduced
           color vision.

       Peak detection

       To  help  deal  with  sources that only have static HDR10 metadata (or no tagging whatsoever), libplacebo
       uses its own internal frame analysis compute shader to analyze source frames and adapt the  tone  mapping
       function  in  realtime. If this is too slow, or if exactly reproducible frame-perfect results are needed,
       it's recommended to turn this feature off.

       <b>peak_detect</b>
           Enable HDR peak detection. Ignores static MaxCLL/MaxFALL values in favor of  dynamic  detection  from
           the  input.  Note  that the detected values do not get written back to the output frames, they merely
           guide the internal tone mapping process. Enabled by default.

       <b>smoothing_period</b>
           Peak detection smoothing period, between 0.0 and 1000.0.  Higher  values  result  in  peak  detection
           becoming less responsive to changes in the input. Defaults to 100.0.

       <b>minimum_peak</b>
           Lower bound on the detected peak (relative to SDR white), between 0.0 and 100.0. Defaults to 1.0.

       <b>scene_threshold_low</b>
       <b>scene_threshold_high</b>
           Lower  and  upper thresholds for scene change detection. Expressed in a logarithmic scale between 0.0
           and 100.0. Default to 5.5 and 10.0, respectively. Setting either to a negative  value  disables  this
           functionality.

       <b>percentile</b>
           Which  percentile  of  the  frame  brightness  histogram  to use as the source peak for tone-mapping.
           Defaults to 99.995, a fairly conservative value.  Setting this  to  100.0  disables  frame  histogram
           measurement and instead uses the true peak brightness for tone-mapping.

       Tone mapping

       The  options  in this section control how libplacebo performs tone-mapping and gamut-mapping when dealing
       with mismatches between wide-gamut or HDR content.  In general,  libplacebo  relies  on  accurate  source
       tagging and mastering display gamut information to produce the best results.

       <b>gamut_mode</b>
           How to handle out-of-gamut colors that can occur as a result of colorimetric gamut mapping.

           <b>clip</b>
               Do nothing, simply clip out-of-range colors to the RGB volume. Low quality but extremely fast.

           <b>perceptual</b>
               Perceptually soft-clip colors to the gamut volume. This is the default.

           <b>relative</b>
               Relative colorimetric hard-clip. Similar to "perceptual" but without the soft knee.

           <b>saturation</b>
               Saturation  mapping,  maps  primaries directly to primaries in RGB space.  Not recommended except
               for artificial computer graphics for which a bright, saturated display is desired.

           <b>absolute</b>
               Absolute colorimetric hard-clip. Performs no adjustment of the white point.

           <b>desaturate</b>
               Hard-desaturates out-of-gamut colors  towards  white,  while  preserving  the  luminance.  Has  a
               tendency to distort the visual appearance of bright objects.

           <b>darken</b>
               Linearly  reduces  content  brightness  to  preserves saturated details, followed by clipping the
               remaining out-of-gamut colors.

           <b>warn</b>
               Highlight out-of-gamut pixels (by inverting/marking them).

           <b>linear</b>
               Linearly reduces chromaticity of the entire image to make it fit within the target color  volume.
               Be careful when using this on BT.2020 sources without proper mastering metadata, as doing so will
               lead to excessive desaturation.

       <b>tonemapping</b>
           Tone-mapping algorithm to use. Available values are:

           <b>auto</b>
               Automatic selection based on internal heuristics. This is the default.

           <b>clip</b>
               Performs  no tone-mapping, just clips out-of-range colors. Retains perfect color accuracy for in-
               range colors but completely destroys out-of-range information.  Does not perform any black  point
               adaptation. Not configurable.

           <b>st2094-40</b>
               EETF  from SMPTE ST 2094-40 Annex B, which applies the Bezier curves from HDR10+ dynamic metadata
               based on Bezier curves to perform tone-mapping. The OOTF used is  adjusted  based  on  the  ratio
               between the targeted and actual display peak luminances.

           <b>st2094-10</b>
               EETF from SMPTE ST 2094-10 Annex B.2, which takes into account the input signal average luminance
               in  addition  to the maximum/minimum. The configurable contrast parameter influences the slope of
               the linear output segment, defaulting to 1.0 for no increase/decrease in contrast. Note that this
               does not currently include the subjective gain/offset/gamma controls defined in Annex B.3.

           <b>bt.2390</b>
               EETF from the ITU-R Report BT.2390, a hermite spline roll-off with linear segment. The knee point
               offset is configurable. Note that this parameter defaults to 1.0, rather than the  value  of  0.5
               from the ITU-R spec.

           <b>bt.2446a</b>
               EETF from ITU-R Report BT.2446, method A. Designed for well-mastered HDR sources. Can be used for
               both forward and inverse tone mapping. Not configurable.

           <b>spline</b>
               Simple spline consisting of two polynomials, joined by a single pivot point.  The parameter gives
               the pivot point (in PQ space), defaulting to 0.30.  Can be used for both forward and inverse tone
               mapping.

           <b>reinhard</b>
               Simple  non-linear,  global  tone  mapping  algorithm. The parameter specifies the local contrast
               coefficient at the display peak. Essentially, a parameter of 0.5 implies that the reference white
               will be about half as bright as when clipping. Defaults to 0.5, which  results  in  the  simplest
               formulation of this function.

           <b>mobius</b>
               Generalization  of the reinhard tone mapping algorithm to support an additional linear slope near
               black. The tone mapping parameter indicates the trade-off between the linear section and the non-
               linear section. Essentially, for a given parameter <u>x</u>, every color value below <u>x</u>  will  be  mapped
               linearly,  while  higher  values  get  non-linearly  tone-mapped. Values near 1.0 make this curve
               behave like "clip", while values near 0.0 make this curve behave  like  "reinhard".  The  default
               value  is 0.3, which provides a good balance between colorimetric accuracy and preserving out-of-
               gamut details.

           <b>hable</b>
               Piece-wise, filmic tone-mapping algorithm developed  by  John  Hable  for  use  in  Uncharted  2,
               inspired  by  a  similar  tone-mapping  algorithm used by Kodak.  Popularized by its use in video
               games with HDR rendering. Preserves both dark and bright details very well, but  comes  with  the
               drawback  of  changing  the  average  brightness  quite significantly. This is sort of similar to
               "reinhard" with parameter 0.24.

           <b>gamma</b>
               Fits a gamma (power) function to transfer between the source and target color spaces, effectively
               resulting in a perceptual hard-knee joining two roughly linear sections. This  preserves  details
               at  all scales fairly accurately, but can result in an image with a muted or dull appearance. The
               parameter is used as the cutoff point, defaulting to 0.5.

           <b>linear</b>
               Linearly stretches the input range to the output range, in  PQ  space.  This  will  preserve  all
               details  accurately, but results in a significantly different average brightness. Can be used for
               inverse tone-mapping in addition to regular  tone-mapping.  The  parameter  can  be  used  as  an
               additional linear gain coefficient (defaulting to 1.0).

       <b>tonemapping_param</b>
           For tunable tone mapping functions, this parameter can be used to fine-tune the curve behavior. Refer
           to  the documentation of "tonemapping". The default value of 0.0 is replaced by the curve's preferred
           default setting.

       <b>inverse_tonemapping</b>
           If enabled, this filter will also attempt stretching SDR signals to fill HDR  output  color  volumes.
           Disabled by default.

       <b>tonemapping_lut_size</b>
           Size  of  the tone-mapping LUT, between 2 and 1024. Defaults to 256. Note that this figure is squared
           when combined with "peak_detect".

       <b>contrast_recovery</b>
           Contrast recovery strength. If set to a value above 0.0, the source image will be divided into  high-
           frequency  and low-frequency components, and a portion of the high-frequency image is added back onto
           the tone-mapped output.  May cause excessive ringing artifacts for some HDR sources, but can  improve
           the subjective sharpness and detail left over in the image after tone-mapping.  Defaults to 0.30.

       <b>contrast_smoothness</b>
           Contrast recovery lowpass kernel size. Defaults to 3.5. Increasing or decreasing this will affect the
           visual appearance substantially. Has no effect when "contrast_recovery" is disabled.

       Dithering

       By  default,  libplacebo  will  dither whenever necessary, which includes rendering to any integer format
       below 16-bit precision. It's recommended to always leave this on,  since  not  doing  so  may  result  in
       visible  banding  in  the  output,  even  if the "debanding" filter is enabled. If maximum performance is
       needed, use "ordered_fixed" instead of disabling dithering.

       <b>dithering</b>
           Dithering method to use. Accepts the following values:

           <b>none</b>
               Disables dithering completely. May result in visible banding.

           <b>blue</b>
               Dither with pseudo-blue noise. This is the default.

           <b>ordered</b>
               Tunable ordered dither pattern.

           <b>ordered_fixed</b>
               Faster ordered dither with a fixed size of 6. Texture-less.

           <b>white</b>
               Dither with white noise. Texture-less.

       <b>dither_lut_size</b>
           Dither LUT size, as log base2 between 1 and 8. Defaults to 6, corresponding to a LUT size of "64x64".

       <b>dither_temporal</b>
           Enables temporal dithering. Disabled by default.

       Custom shaders

       libplacebo supports a number of custom shaders based on the mpv .hook GLSL syntax. A collection  of  such
       shaders can be found here: &lt;<b>https://github.com/mpv-player/mpv/wiki/User-Scripts#user-shaders</b>&gt;

       A  full  description  of  the mpv shader format is beyond the scope of this section, but a summary can be
       found here: &lt;<b>https://mpv.io/manual/master/#options-glsl-shader</b>&gt;

       <b>custom_shader_path</b>
           Specifies a path to a custom shader file to load at runtime.

       <b>custom_shader_bin</b>
           Specifies a complete custom shader as a raw string.

       Debugging / performance

       All of the options in this section default off. They may be of assistance when attempting to squeeze  the
       maximum performance at the cost of quality.

       <b>skip_aa</b>
           Disable anti-aliasing when downscaling.

       <b>polar_cutoff</b>
           Truncate polar (EWA) scaler kernels below this absolute magnitude, between 0.0 and 1.0.

       <b>disable_linear</b>
           Disable linear light scaling.

       <b>disable_builtin</b>
           Disable built-in GPU sampling (forces LUT).

       <b>disable_fbos</b>
           Forcibly  disable  FBOs,  resulting  in  loss  of  almost all functionality, but offering the maximum
           possible speed.

       <u>Commands</u>

       This filter supports almost all of the above options as <b>commands</b>.

       <u>Examples</u>

       •   Tone-map input to standard gamut BT.709 output:

                   libplacebo=colorspace=bt709:color_primaries=bt709:color_trc=bt709:range=tv

       •   Rescale input to fit into standard 1080p, with high quality scaling:

                   libplacebo=w=1920:h=1080:force_original_aspect_ratio=decrease:normalize_sar=true:upscaler=ewa_lanczos:downscaler=ewa_lanczos

       •   Interpolate low FPS / VFR input to smoothed constant 60 fps output:

                   libplacebo=fps=60:frame_mixer=mitchell_clamp

       •   Convert input to standard sRGB JPEG:

                   libplacebo=format=yuv420p:colorspace=bt470bg:color_primaries=bt709:color_trc=iec61966-2-1:range=pc

       •   Use higher quality debanding settings:

                   libplacebo=deband=true:deband_iterations=3:deband_radius=8:deband_threshold=6

       •   Run this filter on the CPU, on systems with Mesa installed  (and  with  the  most  expensive  options
           disabled):

                   ffmpeg ... -init_hw_device vulkan:llvmpipe ... -vf libplacebo=upscaler=none:downscaler=none:peak_detect=false

       •   Suppress  CPU-based  AV1/H.274  film grain application in the decoder, in favor of doing it with this
           filter. Note that this is only a gain if the frames are either already on the GPU, or if you're using
           libplacebo for other purposes, since otherwise the VRAM roundtrip will more than offset any  expected
           speedup.

                   ffmpeg -export_side_data +film_grain ... -vf libplacebo=apply_filmgrain=true

       •   Interop with VAAPI hwdec to avoid round-tripping through RAM:

                   ffmpeg -init_hw_device vulkan -hwaccel vaapi -hwaccel_output_format vaapi ... -vf libplacebo

   <b>libvmaf</b>
       Calculate  the  VMAF (Video Multi-Method Assessment Fusion) score for a reference/distorted pair of input
       videos.

       The first input is the distorted video, and the second input is the reference video.

       The obtained VMAF score is printed through the logging system.

       It requires Netflix's vmaf library (libvmaf) as a pre-requisite.  After installing the library it can  be
       enabled using: "./configure --enable-libvmaf".

       The filter has following options:

       <b>model</b>
           A  `|`  delimited  list  of  vmaf  models.  Each model can be configured with a number of parameters.
           Default value: "version=vmaf_v0.6.1"

       <b>feature</b>
           A `|` delimited list of features. Each feature can be configured with a number of parameters.

       <b>log_path</b>
           Set the file path to be used to store log files.

       <b>log_fmt</b>
           Set the format of the log file (xml, json, csv, or sub).

       <b>pool</b>
           Set the pool method to be used for computing vmaf.  Options  are  "min",  "harmonic_mean"  or  "mean"
           (default).

       <b>n_threads</b>
           Set number of threads to be used when initializing libvmaf.  Default value: 0, no threads.

       <b>n_subsample</b>
           Set frame subsampling interval to be used.

       This filter also supports the <b>framesync</b> options.

       <u>Examples</u>

       •   In  the  examples  below,  a  distorted  video  <u>distorted.mpg</u>  is  compared  with  a  reference  file
           <u>reference.mpg</u>.

       •   Basic usage:

                   ffmpeg -i distorted.mpg -i reference.mpg -lavfi libvmaf=log_path=output.xml -f null -

       •   Example with multiple models:

                   ffmpeg -i distorted.mpg -i reference.mpg -lavfi libvmaf='model=version=vmaf_v0.6.1\\:name=vmaf|version=vmaf_v0.6.1neg\\:name=vmaf_neg' -f null -

       •   Example with multiple additional features:

                   ffmpeg -i distorted.mpg -i reference.mpg -lavfi libvmaf='feature=name=psnr|name=ciede' -f null -

       •   Example with options and different containers:

                   ffmpeg -i distorted.mpg -i reference.mkv -lavfi "[0:v]settb=AVTB,setpts=PTS-STARTPTS[main];[1:v]settb=AVTB,setpts=PTS-STARTPTS[ref];[main][ref]libvmaf=log_fmt=json:log_path=output.json" -f null -

   <b>libvmaf_cuda</b>
       This is the CUDA variant of the <b>libvmaf</b> filter. It only accepts CUDA frames.

       It requires Netflix's vmaf library (libvmaf) as a pre-requisite.  After installing the library it can  be
       enabled using: "./configure --enable-nonfree --enable-ffnvcodec --enable-libvmaf".

       <u>Examples</u>

       •   Basic usage showing CUVID hardware decoding and CUDA scaling with <b>scale_cuda</b>:

                   ffmpeg \
                       -hwaccel cuda -hwaccel_output_format cuda -codec:v av1_cuvid -i dis.obu \
                       -hwaccel cuda -hwaccel_output_format cuda -codec:v av1_cuvid -i ref.obu \
                       -filter_complex "
                           [0:v]scale_cuda=format=yuv420p[dis]; \
                           [1:v]scale_cuda=format=yuv420p[ref]; \
                           [dis][ref]libvmaf_cuda=log_fmt=json:log_path=output.json
                       " \
                       -f null -

   <b>limitdiff</b>
       Apply limited difference filter using second and optionally third video stream.

       The filter accepts the following options:

       <b>threshold</b>
           Set  the  threshold  to  use  when  allowing certain differences between video streams.  Any absolute
           difference value lower or exact than this threshold will  pick  pixel  components  from  first  video
           stream.

       <b>elasticity</b>
           Set  the  elasticity  of soft thresholding when processing video streams.  This value multiplied with
           first one sets second threshold.   Any  absolute  difference  value  greater  or  exact  than  second
           threshold will pick pixel components from second video stream. For values between those two threshold
           linear interpolation between first and second video stream will be used.

       <b>reference</b>
           Enable  the  reference  (third)  video stream processing. By default is disabled.  If set, this video
           stream will be used for calculating absolute difference with first video stream.

       <b>planes</b>
           Specify which planes will be processed. Defaults to all available.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b> except option <b>reference</b>.

   <b>limiter</b>
       Limits the pixel components values to the specified range [min, max].

       The filter accepts the following options:

       <b>min</b> Lower bound. Defaults to the lowest allowed value for the input.

       <b>max</b> Upper bound. Defaults to the highest allowed value for the input.

       <b>planes</b>
           Specify which planes will be processed. Defaults to all available.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>loop</b>
       Loop video frames.

       The filter accepts the following options:

       <b>loop</b>
           Set the number of loops. Setting this value to -1 will result in infinite loops.  Default is 0.

       <b>size</b>
           Set maximal size in number of frames. Default is 0.

       <b>start</b>
           Set first frame of loop. Default is 0.

       <b>time</b>
           Set the time of loop start in seconds.  Only used if option named <u>start</u> is set to -1.

       <u>Examples</u>

       •   Loop single first frame infinitely:

                   loop=loop=-1:size=1:start=0

       •   Loop single first frame 10 times:

                   loop=loop=10:size=1:start=0

       •   Loop 10 first frames 5 times:

                   loop=loop=5:size=10:start=0

   <b>lut1d</b>
       Apply a 1D LUT to an input video.

       The filter accepts the following options:

       <b>file</b>
           Set the 1D LUT file name.

           Currently supported formats:

           <b>cube</b>
               Iridas

           <b>csp</b> cineSpace

       <b>interp</b>
           Select interpolation mode.

           Available values are:

           <b>nearest</b>
               Use values from the nearest defined point.

           <b>linear</b>
               Interpolate values using the linear interpolation.

           <b>cosine</b>
               Interpolate values using the cosine interpolation.

           <b>cubic</b>
               Interpolate values using the cubic interpolation.

           <b>spline</b>
               Interpolate values using the spline interpolation.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>lut3d</b>
       Apply a 3D LUT to an input video.

       The filter accepts the following options:

       <b>file</b>
           Set the 3D LUT file name.

           Currently supported formats:

           <b>3dl</b> AfterEffects

           <b>cube</b>
               Iridas

           <b>dat</b> DaVinci

           <b>m3d</b> Pandora

           <b>csp</b> cineSpace

       <b>interp</b>
           Select interpolation mode.

           Available values are:

           <b>nearest</b>
               Use values from the nearest defined point.

           <b>trilinear</b>
               Interpolate values using the 8 points defining a cube.

           <b>tetrahedral</b>
               Interpolate values using a tetrahedron.

           <b>pyramid</b>
               Interpolate values using a pyramid.

           <b>prism</b>
               Interpolate values using a prism.

       <u>Commands</u>

       This filter supports the "interp" option as <b>commands</b>.

   <b>lumakey</b>
       Turn certain luma values into transparency.

       The filter accepts the following options:

       <b>threshold</b>
           Set the luma which will be used as base for transparency.  Default value is 0.

       <b>tolerance</b>
           Set the range of luma values to be keyed out.  Default value is 0.01.

       <b>softness</b>
           Set the range of softness. Default value is 0.  Use this to control gradual transition from  zero  to
           full transparency.

       <u>Commands</u>

       This  filter supports same <b>commands</b> as options.  The command accepts the same syntax of the corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>lut,</b> <b>lutrgb,</b> <b>lutyuv</b>
       Compute a look-up table for binding each pixel component input value to an output value, and apply it  to
       the input video.

       <u>lutyuv</u> applies a lookup table to a YUV input video, <u>lutrgb</u> to an RGB input video.

       These filters accept the following parameters:

       <b>c0</b>  set first pixel component expression

       <b>c1</b>  set second pixel component expression

       <b>c2</b>  set third pixel component expression

       <b>c3</b>  set fourth pixel component expression, corresponds to the alpha component

       <b>r</b>   set red component expression

       <b>g</b>   set green component expression

       <b>b</b>   set blue component expression

       <b>a</b>   alpha component expression

       <b>y</b>   set Y/luma component expression

       <b>u</b>   set U/Cb component expression

       <b>v</b>   set V/Cr component expression

       Each  of  them specifies the expression to use for computing the lookup table for the corresponding pixel
       component values.

       The exact component associated to each of the <u>c*</u> options depends on the format in input.

       The <u>lut</u> filter requires either YUV or RGB pixel formats in input, <u>lutrgb</u> requires RGB  pixel  formats  in
       input, and <u>lutyuv</u> requires YUV.

       The expressions can contain the following constants and functions:

       <b>w</b>
       <b>h</b>   The input width and height.

       <b>val</b> The input value for the pixel component.

       <b>clipval</b>
           The input value, clipped to the <u>minval</u>-<u>maxval</u> range.

       <b>maxval</b>
           The maximum value for the pixel component.

       <b>minval</b>
           The minimum value for the pixel component.

       <b>negval</b>
           The  negated  value for the pixel component value, clipped to the <u>minval</u>-<u>maxval</u> range; it corresponds
           to the expression "maxval-clipval+minval".

       <b>clip(val)</b>
           The computed value in <u>val</u>, clipped to the <u>minval</u>-<u>maxval</u> range.

       <b>gammaval(gamma)</b>
           The computed gamma correction value of the pixel component value, clipped to the <u>minval</u>-<u>maxval</u> range.
           It                  corresponds                  to                  the                   expression
           "pow((clipval-minval)/(maxval-minval)\,<u>gamma</u>)*(maxval-minval)+minval"

       All expressions default to "clipval".

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

       <u>Examples</u>

       •   Negate input video:

                   lutrgb="r=maxval+minval-val:g=maxval+minval-val:b=maxval+minval-val"
                   lutyuv="y=maxval+minval-val:u=maxval+minval-val:v=maxval+minval-val"

           The above is the same as:

                   lutrgb="r=negval:g=negval:b=negval"
                   lutyuv="y=negval:u=negval:v=negval"

       •   Negate luma:

                   lutyuv=y=negval

       •   Remove chroma components, turning the video into a graytone image:

                   lutyuv="u=128:v=128"

       •   Apply a luma burning effect:

                   lutyuv="y=2*val"

       •   Remove green and blue components:

                   lutrgb="g=0:b=0"

       •   Set a constant alpha channel value on input:

                   format=rgba,lutrgb=a="maxval-minval/2"

       •   Correct luma gamma by a factor of 0.5:

                   lutyuv=y=gammaval(0.5)

       •   Discard least significant bits of luma:

                   lutyuv=y='bitand(val, 128+64+32)'

       •   Technicolor like effect:

                   lutyuv=u='(val-maxval/2)*2+maxval/2':v='(val-maxval/2)*2+maxval/2'

   <b>lut2,</b> <b>tlut2</b>
       The "lut2" filter takes two input streams and outputs one stream.

       The "tlut2" (time lut2) filter takes two consecutive frames from one single stream.

       This filter accepts the following parameters:

       <b>c0</b>  set first pixel component expression

       <b>c1</b>  set second pixel component expression

       <b>c2</b>  set third pixel component expression

       <b>c3</b>  set fourth pixel component expression, corresponds to the alpha component

       <b>d</b>   set  output  bit  depth,  only available for "lut2" filter. By default is 0, which means bit depth is
           automatically picked from first input format.

       The "lut2" filter also supports the <b>framesync</b> options.

       Each of them specifies the expression to use for computing the lookup table for the  corresponding  pixel
       component values.

       The exact component associated to each of the <u>c*</u> options depends on the format in inputs.

       The expressions can contain the following constants:

       <b>w</b>
       <b>h</b>   The input width and height.

       <b>x</b>   The first input value for the pixel component.

       <b>y</b>   The second input value for the pixel component.

       <b>bdx</b> The first input video bit depth.

       <b>bdy</b> The second input video bit depth.

       All expressions default to "x".

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b> except option "d".

       <u>Examples</u>

       •   Highlight differences between two RGB video streams:

                   lut2='ifnot(x-y,0,pow(2,bdx)-1):ifnot(x-y,0,pow(2,bdx)-1):ifnot(x-y,0,pow(2,bdx)-1)'

       •   Highlight differences between two YUV video streams:

                   lut2='ifnot(x-y,0,pow(2,bdx)-1):ifnot(x-y,pow(2,bdx-1),pow(2,bdx)-1):ifnot(x-y,pow(2,bdx-1),pow(2,bdx)-1)'

       •   Show max difference between two video streams:

                   lut2='if(lt(x,y),0,if(gt(x,y),pow(2,bdx)-1,pow(2,bdx-1))):if(lt(x,y),0,if(gt(x,y),pow(2,bdx)-1,pow(2,bdx-1))):if(lt(x,y),0,if(gt(x,y),pow(2,bdx)-1,pow(2,bdx-1)))'

   <b>maskedclamp</b>
       Clamp the first input stream with the second input and third input stream.

       Returns the value of first stream to be between second input stream - "undershoot" and third input stream
       + "overshoot".

       This filter accepts the following options:

       <b>undershoot</b>
           Default value is 0.

       <b>overshoot</b>
           Default value is 0.

       <b>planes</b>
           Set  which  planes  will be processed as bitmap, unprocessed planes will be copied from first stream.
           By default value 0xf, all planes will be processed.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>maskedmax</b>
       Merge the second and third input stream into output stream  using  absolute  differences  between  second
       input  stream  and  first input stream and absolute difference between third input stream and first input
       stream. The picked value will be from second input stream if second absolute difference is  greater  than
       first one or from third input stream otherwise.

       This filter accepts the following options:

       <b>planes</b>
           Set  which  planes  will be processed as bitmap, unprocessed planes will be copied from first stream.
           By default value 0xf, all planes will be processed.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>maskedmerge</b>
       Merge the first input stream with the second input stream using per pixel  weights  in  the  third  input
       stream.

       A value of 0 in the third stream pixel component means that pixel component from first stream is returned
       unchanged,  while  maximum value (eg. 255 for 8-bit videos) means that pixel component from second stream
       is returned unchanged. Intermediate values define the amount of merging between both input stream's pixel
       components.

       This filter accepts the following options:

       <b>planes</b>
           Set which planes will be processed as bitmap, unprocessed planes will be copied  from  first  stream.
           By default value 0xf, all planes will be processed.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>maskedmin</b>
       Merge  the  second  and  third  input stream into output stream using absolute differences between second
       input stream and first input stream and absolute difference between third input stream  and  first  input
       stream.  The  picked  value  will  be from second input stream if second absolute difference is less than
       first one or from third input stream otherwise.

       This filter accepts the following options:

       <b>planes</b>
           Set which planes will be processed as bitmap, unprocessed planes will be copied  from  first  stream.
           By default value 0xf, all planes will be processed.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>maskedthreshold</b>
       Pick pixels comparing absolute difference of two video streams with fixed threshold.

       If  absolute  difference  between pixel component of first and second video stream is equal or lower than
       user supplied threshold than pixel component from first video stream is picked, otherwise pixel component
       from second video stream is picked.

       This filter accepts the following options:

       <b>threshold</b>
           Set threshold used when picking pixels from absolute difference from two input video streams.

       <b>planes</b>
           Set which planes will be processed as bitmap, unprocessed planes will be copied from  second  stream.
           By default value 0xf, all planes will be processed.

       <b>mode</b>
           Set mode of filter operation. Can be "abs" or "diff".  Default is "abs".

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>maskfun</b>
       Create mask from input video.

       For example it is useful to create motion masks after "tblend" filter.

       This filter accepts the following options:

       <b>low</b> Set low threshold. Any pixel component lower or exact than this value will be set to 0.

       <b>high</b>
           Set  high  threshold. Any pixel component higher than this value will be set to max value allowed for
           current pixel format.

       <b>planes</b>
           Set planes to filter, by default all available planes are filtered.

       <b>fill</b>
           Fill all frame pixels with this value.

       <b>sum</b> Set max average pixel value for frame. If sum of all pixel components is higher  that  this  average,
           output  frame  will  be  completely filled with value set by <u>fill</u> option.  Typically useful for scene
           changes when used in combination with "tblend" filter.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>mcdeint</b>
       Apply motion-compensation deinterlacing.

       It needs one field per frame as input and must thus be used together with yadif=1/3 or equivalent.

       This filter accepts the following options:

       <b>mode</b>
           Set the deinterlacing mode.

           It accepts one of the following values:

           <b>fast</b>
           <b>medium</b>
           <b>slow</b>
               use iterative motion estimation

           <b>extra_slow</b>
               like <b>slow</b>, but use multiple reference frames.

           Default value is <b>fast</b>.

       <b>parity</b>
           Set the picture field parity assumed for the input video. It must be one of the following values:

           <b>0,</b> <b>tff</b>
               assume top field first

           <b>1,</b> <b>bff</b>
               assume bottom field first

           Default value is <b>bff</b>.

       <b>qp</b>  Set per-block quantization parameter (QP) used by the internal encoder.

           Higher values should result in a smoother motion vector field but less  optimal  individual  vectors.
           Default value is 1.

   <b>median</b>
       Pick median pixel from certain rectangle defined by radius.

       This filter accepts the following options:

       <b>radius</b>
           Set horizontal radius size. Default value is 1.  Allowed range is integer from 1 to 127.

       <b>planes</b>
           Set which planes to process. Default is 15, which is all available planes.

       <b>radiusV</b>
           Set  vertical  radius size. Default value is 0.  Allowed range is integer from 0 to 127.  If it is 0,
           value will be picked from horizontal "radius" option.

       <b>percentile</b>
           Set median percentile. Default value is 0.5.  Default value of 0.5 will pick  always  median  values,
           while 0 will pick minimum values, and 1 maximum values.

       <u>Commands</u>

       This  filter supports same <b>commands</b> as options.  The command accepts the same syntax of the corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

   <b>mergeplanes</b>
       Merge color channel components from several video streams.

       The filter accepts up to 4 input streams, and merge selected input planes to the output video.

       This filter accepts the following options:

       <b>mapping</b>
           Set input to output plane mapping. Default is 0.

           The mappings is specified as a bitmap. It should be specified as a hexadecimal  number  in  the  form
           0xAa[Bb[Cc[Dd]]].  'Aa'  describes the mapping for the first plane of the output stream. 'A' sets the
           number of the input stream to use (from 0 to 3), and 'a' the plane number of the corresponding  input
           to  use (from 0 to 3). The rest of the mappings is similar, 'Bb' describes the mapping for the output
           stream second plane, 'Cc' describes the mapping for the output stream third plane and 'Dd'  describes
           the mapping for the output stream fourth plane.

       <b>format</b>
           Set output pixel format. Default is "yuva444p".

       <b>map0s</b>
       <b>map1s</b>
       <b>map2s</b>
       <b>map3s</b>
           Set input to output stream mapping for output Nth plane. Default is 0.

       <b>map0p</b>
       <b>map1p</b>
       <b>map2p</b>
       <b>map3p</b>
           Set input to output plane mapping for output Nth plane. Default is 0.

       <u>Examples</u>

       •   Merge three gray video streams of same width and height into single video stream:

                   [a0][a1][a2]mergeplanes=0x001020:yuv444p

       •   Merge 1st yuv444p stream and 2nd gray video stream into yuva444p video stream:

                   [a0][a1]mergeplanes=0x00010210:yuva444p

       •   Swap Y and A plane in yuva444p stream:

                   format=yuva444p,mergeplanes=0x03010200:yuva444p

       •   Swap U and V plane in yuv420p stream:

                   format=yuv420p,mergeplanes=0x000201:yuv420p

       •   Cast a rgb24 clip to yuv444p:

                   format=rgb24,mergeplanes=0x000102:yuv444p

   <b>mestimate</b>
       Estimate  and  export motion vectors using block matching algorithms.  Motion vectors are stored in frame
       side data to be used by other filters.

       This filter accepts the following options:

       <b>method</b>
           Specify the motion estimation method. Accepts one of the following values:

           <b>esa</b> Exhaustive search algorithm.

           <b>tss</b> Three step search algorithm.

           <b>tdls</b>
               Two dimensional logarithmic search algorithm.

           <b>ntss</b>
               New three step search algorithm.

           <b>fss</b> Four step search algorithm.

           <b>ds</b>  Diamond search algorithm.

           <b>hexbs</b>
               Hexagon-based search algorithm.

           <b>epzs</b>
               Enhanced predictive zonal search algorithm.

           <b>umh</b> Uneven multi-hexagon search algorithm.

           Default value is <b>esa</b>.

       <b>mb_size</b>
           Macroblock size. Default 16.

       <b>search_param</b>
           Search parameter. Default 7.

   <b>midequalizer</b>
       Apply Midway Image Equalization effect using two video streams.

       Midway Image Equalization adjusts a pair of images to have the same histogram,  while  maintaining  their
       dynamics as much as possible. It's useful for e.g. matching exposures from a pair of stereo cameras.

       This  filter  has  two inputs and one output, which must be of same pixel format, but may be of different
       sizes. The output of filter is first input adjusted with midway histogram of both inputs.

       This filter accepts the following option:

       <b>planes</b>
           Set which planes to process. Default is 15, which is all available planes.

   <b>minterpolate</b>
       Convert the video to specified frame rate using motion interpolation.

       This filter accepts the following options:

       <b>fps</b> Specify the output frame rate. This can be rational e.g. "60000/1001". Frames are dropped if  <u>fps</u>  is
           lower than source fps. Default 60.

       <b>mi_mode</b>
           Motion interpolation mode. Following values are accepted:

           <b>dup</b> Duplicate previous or next frame for interpolating new ones.

           <b>blend</b>
               Blend source frames. Interpolated frame is mean of previous and next frames.

           <b>mci</b> Motion compensated interpolation. Following options are effective when this mode is selected:

               <b>mc_mode</b>
                   Motion compensation mode. Following values are accepted:

                   <b>obmc</b>
                       Overlapped block motion compensation.

                   <b>aobmc</b>
                       Adaptive   overlapped  block  motion  compensation.  Window  weighting  coefficients  are
                       controlled adaptively according to the reliabilities of the neighboring motion vectors to
                       reduce oversmoothing.

                   Default mode is <b>obmc</b>.

               <b>me_mode</b>
                   Motion estimation mode. Following values are accepted:

                   <b>bidir</b>
                       Bidirectional motion estimation. Motion vectors are estimated for each  source  frame  in
                       both forward and backward directions.

                   <b>bilat</b>
                       Bilateral  motion  estimation.  Motion  vectors  are  estimated directly for interpolated
                       frame.

                   Default mode is <b>bilat</b>.

               <b>me</b>  The algorithm to be used for motion estimation. Following values are accepted:

                   <b>esa</b> Exhaustive search algorithm.

                   <b>tss</b> Three step search algorithm.

                   <b>tdls</b>
                       Two dimensional logarithmic search algorithm.

                   <b>ntss</b>
                       New three step search algorithm.

                   <b>fss</b> Four step search algorithm.

                   <b>ds</b>  Diamond search algorithm.

                   <b>hexbs</b>
                       Hexagon-based search algorithm.

                   <b>epzs</b>
                       Enhanced predictive zonal search algorithm.

                   <b>umh</b> Uneven multi-hexagon search algorithm.

                   Default algorithm is <b>epzs</b>.

               <b>mb_size</b>
                   Macroblock size. Default 16.

               <b>search_param</b>
                   Motion estimation search parameter. Default 32.

               <b>vsbmc</b>
                   Enable variable-size block motion compensation. Motion estimation  is  applied  with  smaller
                   block sizes at object boundaries in order to make them less blurry. Default is 0 (disabled).

       <b>scd</b> Scene  change  detection  method.  Scene change leads motion vectors to be in random direction. Scene
           change detection replace interpolated frames by duplicate ones. May not be needed  for  other  modes.
           Following values are accepted:

           <b>none</b>
               Disable scene change detection.

           <b>fdiff</b>
               Frame difference. Corresponding pixel values are compared and if it satisfies <u>scd_threshold</u> scene
               change is detected.

           Default method is <b>fdiff</b>.

       <b>scd_threshold</b>
           Scene change detection threshold. Default is 10..

   <b>mix</b>
       Mix several video input streams into one video stream.

       A description of the accepted options follows.

       <b>inputs</b>
           The number of inputs. If unspecified, it defaults to 2.

       <b>weights</b>
           Specify  weight of each input video stream as sequence.  Each weight is separated by space. If number
           of weights is smaller than number of <u>frames</u> last specified weight will  be  used  for  all  remaining
           unset weights.

       <b>scale</b>
           Specify  scale,  if  it  is  set  it will be multiplied with sum of each weight multiplied with pixel
           values to give final destination pixel value. By default <u>scale</u> is auto scaled to sum of weights.

       <b>planes</b>
           Set which planes to filter. Default is all. Allowed range is from 0 to 15.

       <b>duration</b>
           Specify how end of stream is determined.

           <b>longest</b>
               The duration of the longest input. (default)

           <b>shortest</b>
               The duration of the shortest input.

           <b>first</b>
               The duration of the first input.

       <u>Commands</u>

       This filter supports the following commands:

       <b>weights</b>
       <b>scale</b>
       <b>planes</b>
           Syntax is same as option with same name.

   <b>monochrome</b>
       Convert video to gray using custom color filter.

       A description of the accepted options follows.

       <b>cb</b>  Set the chroma blue spot. Allowed range is from -1 to 1.  Default value is 0.

       <b>cr</b>  Set the chroma red spot. Allowed range is from -1 to 1.  Default value is 0.

       <b>size</b>
           Set the color filter size. Allowed range is from .1 to 10.  Default value is 1.

       <b>high</b>
           Set the highlights strength. Allowed range is from 0 to 1.  Default value is 0.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>morpho</b>
       This filter allows to apply main morphological grayscale transforms,  erode  and  dilate  with  arbitrary
       structures set in second input stream.

       Unlike  naive  implementation  and much slower performance in <b>erosion</b> and <b>dilation</b> filters, when speed is
       critical "morpho" filter should be used instead.

       A description of accepted options follows,

       <b>mode</b>
           Set morphological transform to apply, can be:

           <b>erode</b>
           <b>dilate</b>
           <b>open</b>
           <b>close</b>
           <b>gradient</b>
           <b>tophat</b>
           <b>blackhat</b>

           Default is "erode".

       <b>planes</b>
           Set planes to filter, by default all planes except alpha are filtered.

       <b>structure</b>
           Set which structure video frames will be processed from second input stream, can  be  <u>first</u>  or  <u>all</u>.
           Default is <u>all</u>.

       The "morpho" filter also supports the <b>framesync</b> options.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>mpdecimate</b>
       Drop frames that do not differ greatly from the previous frame in order to reduce frame rate.

       The  main  use of this filter is for very-low-bitrate encoding (e.g. streaming over dialup modem), but it
       could in theory be used for fixing movies that were inverse-telecined incorrectly.

       A description of the accepted options follows.

       <b>max</b> Set the maximum number of consecutive frames which can be  dropped  (if  positive),  or  the  minimum
           interval  between  dropped frames (if negative). If the value is 0, the frame is dropped disregarding
           the number of previous sequentially dropped frames.

           Default value is 0.

       <b>keep</b>
           Set the maximum number of consecutive similar frames to ignore before to start dropping them.  If the
           value is 0, the frame is dropped disregarding the number of previous sequentially similar frames.

           Default value is 0.

       <b>hi</b>
       <b>lo</b>
       <b>frac</b>
           Set the dropping threshold values.

           Values for <b>hi</b> and <b>lo</b> are for 8x8 pixel blocks and represent actual  pixel  value  differences,  so  a
           threshold  of  64  corresponds  to  1  unit  of  difference  for  each  pixel, or the same spread out
           differently over the block.

           A frame is a candidate for dropping if no 8x8 blocks differ by more than a threshold of <b>hi</b>, and if no
           more than <b>frac</b> blocks (1 meaning the whole image) differ by more than a threshold of <b>lo</b>.

           Default value for <b>hi</b> is 64*12, default value for <b>lo</b> is 64*5, and default value for <b>frac</b> is 0.33.

   <b>msad</b>
       Obtain the MSAD (Mean Sum of Absolute Differences) between two input videos.

       This filter takes two input videos.

       Both input videos must have the same resolution and pixel format for this filter to work correctly.  Also
       it assumes that both inputs have the same number of frames, which are compared one by one.

       The obtained per component, average, min and max MSAD is printed through the logging system.

       The filter stores the calculated MSAD of each frame in frame metadata.

       This filter also supports the <b>framesync</b> options.

       In the below example the input file <u>main.mpg</u> being processed is compared with the reference file <u>ref.mpg</u>.

               ffmpeg -i main.mpg -i ref.mpg -lavfi msad -f null -

   <b>multiply</b>
       Multiply first video stream pixels values with second video stream pixels values.

       The filter accepts the following options:

       <b>scale</b>
           Set the scale applied to second video stream. By default is 1.  Allowed range is from 0 to 9.

       <b>offset</b>
           Set the offset applied to second video stream. By default is 0.5.  Allowed range is from -1 to 1.

       <b>planes</b>
           Specify planes from input video stream that will be processed.  By default all planes are processed.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>negate</b>
       Negate (invert) the input video.

       It accepts the following option:

       <b>components</b>
           Set components to negate.

           Available values for components are:

           <b>y</b>
           <b>u</b>
           <b>v</b>
           <b>a</b>
           <b>r</b>
           <b>g</b>
           <b>b</b>
       <b>negate_alpha</b>
           With value 1, it negates the alpha component, if present. Default value is 0.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>nlmeans</b>
       Denoise frames using Non-Local Means algorithm.

       Each  pixel  is  adjusted  by  looking for other pixels with similar contexts. This context similarity is
       defined by comparing their surrounding patches of size <b>p</b>x<b>p</b>. Patches are searched in an area of <b>r</b>x<b>r</b> around
       the pixel.

       Note that the research area defines centers for patches, which means some patches will be made of  pixels
       outside that research area.

       The filter accepts the following options.

       <b>s</b>   Set denoising strength. Default is 1.0. Must be in range [1.0, 30.0].

       <b>p</b>   Set patch size. Default is 7. Must be odd number in range [0, 99].

       <b>pc</b>  Same as <b>p</b> but for chroma planes.

           The default value is <u>0</u> and means automatic.

       <b>r</b>   Set research size. Default is 15. Must be odd number in range [0, 99].

       <b>rc</b>  Same as <b>r</b> but for chroma planes.

           The default value is <u>0</u> and means automatic.

   <b>nnedi</b>
       Deinterlace video using neural network edge directed interpolation.

       This filter accepts the following options:

       <b>weights</b>
           Mandatory  option,  without  binary  file  filter  can  not  work.  Currently file can be found here:
           https://github.com/dubhater/vapoursynth-nnedi3/blob/master/src/nnedi3_weights.bin

       <b>deint</b>
           Set which frames to deinterlace, by default it is "all".  Can be "all" or "interlaced".

       <b>field</b>
           Set mode of operation.

           Can be one of the following:

           <b>af</b>  Use frame flags, both fields.

           <b>a</b>   Use frame flags, single field.

           <b>t</b>   Use top field only.

           <b>b</b>   Use bottom field only.

           <b>tf</b>  Use both fields, top first.

           <b>bf</b>  Use both fields, bottom first.

       <b>planes</b>
           Set which planes to process, by default filter process all frames.

       <b>nsize</b>
           Set size of local neighborhood around each pixel, used by the predictor neural network.

           Can be one of the following:

           <b>s8x6</b>
           <b>s16x6</b>
           <b>s32x6</b>
           <b>s48x6</b>
           <b>s8x4</b>
           <b>s16x4</b>
           <b>s32x4</b>
       <b>nns</b> Set the number of neurons in predictor neural network.  Can be one of the following:

           <b>n16</b>
           <b>n32</b>
           <b>n64</b>
           <b>n128</b>
           <b>n256</b>
       <b>qual</b>
           Controls the number of different neural network predictions that are blended together to compute  the
           final output value. Can be "fast", default or "slow".

       <b>etype</b>
           Set which set of weights to use in the predictor.  Can be one of the following:

           <b>a,</b> <b>abs</b>
               weights trained to minimize absolute error

           <b>s,</b> <b>mse</b>
               weights trained to minimize squared error

       <b>pscrn</b>
           Controls  whether  or  not  the  prescreener  neural network is used to decide which pixels should be
           processed by the predictor neural network and which can be handled  by  simple  cubic  interpolation.
           The  prescreener  is  trained  to  know whether cubic interpolation will be sufficient for a pixel or
           whether it should be predicted by the predictor nn.  The computational complexity of the  prescreener
           nn  is  much  less  than  that  of  the  predictor  nn.  Since  most  pixels  can be handled by cubic
           interpolation, using the prescreener generally results in much faster processing.  The prescreener is
           pretty accurate, so the difference between using it and not using it is almost always unnoticeable.

           Can be one of the following:

           <b>none</b>
           <b>original</b>
           <b>new</b>
           <b>new2</b>
           <b>new3</b>

           Default is "new".

       <u>Commands</u>

       This filter supports same <b>commands</b> as options, excluding <u>weights</u> option.

   <b>noformat</b>
       Force libavfilter not to use any of the specified pixel formats for the input to the next filter.

       It accepts the following parameters:

       <b>pix_fmts</b>
           A '|'-separated list of pixel format names, such as pix_fmts=yuv420p|monow|rgb24".

       <u>Examples</u>

       •   Force libavfilter to use a format different from <u>yuv420p</u> for the input to the vflip filter:

                   noformat=pix_fmts=yuv420p,vflip

       •   Convert the input video to any of the formats not contained in the list:

                   noformat=yuv420p|yuv444p|yuv410p

   <b>noise</b>
       Add noise on video input frame.

       The filter accepts the following options:

       <b>all_seed</b>
       <b>c0_seed</b>
       <b>c1_seed</b>
       <b>c2_seed</b>
       <b>c3_seed</b>
           Set noise seed for specific pixel component or all pixel components  in  case  of  <u>all_seed</u>.  Default
           value is 123457.

       <b>all_strength,</b> <b>alls</b>
       <b>c0_strength,</b> <b>c0s</b>
       <b>c1_strength,</b> <b>c1s</b>
       <b>c2_strength,</b> <b>c2s</b>
       <b>c3_strength,</b> <b>c3s</b>
           Set noise strength for specific pixel component or all pixel components in case <u>all_strength</u>. Default
           value is 0. Allowed range is [0, 100].

       <b>all_flags,</b> <b>allf</b>
       <b>c0_flags,</b> <b>c0f</b>
       <b>c1_flags,</b> <b>c1f</b>
       <b>c2_flags,</b> <b>c2f</b>
       <b>c3_flags,</b> <b>c3f</b>
           Set  pixel  component  flags  or  set  flags  for  all components if <u>all_flags</u>.  Available values for
           component flags are:

           <b>a</b>   averaged temporal noise (smoother)

           <b>p</b>   mix random noise with a (semi)regular pattern

           <b>t</b>   temporal noise (noise pattern changes between frames)

           <b>u</b>   uniform noise (gaussian otherwise)

       <u>Examples</u>

       Add temporal and uniform noise to input video:

               noise=alls=20:allf=t+u

   <b>normalize</b>
       Normalize    RGB     video     (aka     histogram     stretching,     contrast     stretching).      See:
       https://en.wikipedia.org/wiki/Normalization_(image_processing)

       For  each  channel  of  each frame, the filter computes the input range and maps it linearly to the user-
       specified output range. The output range defaults to the full dynamic  range  from  pure  black  to  pure
       white.

       Temporal  smoothing  can  be  used  on the input range to reduce flickering (rapid changes in brightness)
       caused when small dark or bright objects enter or leave the scene. This is similar to  the  auto-exposure
       (automatic  gain  control) on a video camera, and, like a video camera, it may cause a period of over- or
       under-exposure of the video.

       The R,G,B channels can be normalized independently, which  may  cause  some  color  shifting,  or  linked
       together  as  a  single  channel,  which  prevents  color  shifting.  Linked normalization preserves hue.
       Independent normalization does not, so it can be used to remove some color casts. Independent and  linked
       normalization can be combined in any ratio.

       The normalize filter accepts the following options:

       <b>blackpt</b>
       <b>whitept</b>
           Colors  which  define the output range. The minimum input value is mapped to the <u>blackpt</u>. The maximum
           input value is mapped to the <u>whitept</u>.  The defaults are  black  and  white  respectively.  Specifying
           white  for  <u>blackpt</u>  and black for <u>whitept</u> will give color-inverted, normalized video. Shades of grey
           can be used to reduce the dynamic range (contrast). Specifying saturated colors here can create  some
           interesting effects.

       <b>smoothing</b>
           The  number  of  previous  frames  to  use for temporal smoothing. The input range of each channel is
           smoothed using a rolling average over the current  frame  and  the  <u>smoothing</u>  previous  frames.  The
           default is 0 (no temporal smoothing).

       <b>independence</b>
           Controls the ratio of independent (color shifting) channel normalization to linked (color preserving)
           normalization. 0.0 is fully linked, 1.0 is fully independent. Defaults to 1.0 (fully independent).

       <b>strength</b>
           Overall  strength  of  the filter. 1.0 is full strength. 0.0 is a rather expensive no-op. Defaults to
           1.0 (full strength).

       <u>Commands</u>

       This filter supports same <b>commands</b> as options, excluding <u>smoothing</u> option.  The command accepts the  same
       syntax of the corresponding option.

       If the specified expression is not valid, it is kept at its current value.

       <u>Examples</u>

       Stretch  video  contrast to use the full dynamic range, with no temporal smoothing; may flicker depending
       on the source content:

               normalize=blackpt=black:whitept=white:smoothing=0

       As above, but with 50 frames of temporal smoothing; flicker should be reduced, depending  on  the  source
       content:

               normalize=blackpt=black:whitept=white:smoothing=50

       As above, but with hue-preserving linked channel normalization:

               normalize=blackpt=black:whitept=white:smoothing=50:independence=0

       As above, but with half strength:

               normalize=blackpt=black:whitept=white:smoothing=50:independence=0:strength=0.5

       Map the darkest input color to red, the brightest input color to cyan:

               normalize=blackpt=red:whitept=cyan

   <b>null</b>
       Pass the video source unchanged to the output.

   <b>ocr</b>
       Optical Character Recognition

       This  filter  uses Tesseract for optical character recognition. To enable compilation of this filter, you
       need to configure FFmpeg with "--enable-libtesseract".

       It accepts the following options:

       <b>datapath</b>
           Set datapath to tesseract data. Default is to use whatever was set at installation.

       <b>language</b>
           Set language, default is "eng".

       <b>whitelist</b>
           Set character whitelist.

       <b>blacklist</b>
           Set character blacklist.

       The filter exports recognized text as the frame metadata "lavfi.ocr.text".  The filter exports confidence
       of recognized words as the frame metadata "lavfi.ocr.confidence".

   <b>ocv</b>
       Apply a video transform using libopencv.

       To  enable  this  filter,  install  the  libopencv  library  and  headers  and  configure   FFmpeg   with
       "--enable-libopencv".

       It accepts the following parameters:

       <b>filter_name</b>
           The name of the libopencv filter to apply.

       <b>filter_params</b>
           The parameters to pass to the libopencv filter. If not specified, the default values are assumed.

       Refer     to     the     official    libopencv    documentation    for    more    precise    information:
       &lt;<b><a href="http://docs.opencv.org/master/modules/imgproc/doc/filtering.html">http://docs.opencv.org/master/modules/imgproc/doc/filtering.html</a></b>&gt;

       Several libopencv filters are supported; see the following subsections.

       <u>dilate</u>

       Dilate an image by using a specific structuring  element.   It  corresponds  to  the  libopencv  function
       "cvDilate".

       It accepts the parameters: <u>struct_el</u>|<u>nb_iterations</u>.

       <u>struct_el</u> represents a structuring element, and has the syntax: <u>cols</u>x<u>rows</u>+<u>anchor_x</u>x<u>anchor_y</u>/<u>shape</u>

       <u>cols</u>  and <u>rows</u> represent the number of columns and rows of the structuring element, <u>anchor_x</u> and <u>anchor_y</u>
       the anchor point, and <u>shape</u> the shape for  the  structuring  element.  <u>shape</u>  must  be  "rect",  "cross",
       "ellipse", or "custom".

       If  the  value  for  <u>shape</u> is "custom", it must be followed by a string of the form "=<u>filename</u>". The file
       with name <u>filename</u> is assumed to represent a binary image, with each printable character corresponding to
       a bright pixel. When a custom <u>shape</u> is used, <u>cols</u> and <u>rows</u> are ignored, the number or columns and rows of
       the read file are assumed instead.

       The default value for <u>struct_el</u> is "3x3+0x0/rect".

       <u>nb_iterations</u> specifies the number of times the transform is applied to the image, and defaults to 1.

       Some examples:

               # Use the default values
               ocv=dilate

               # Dilate using a structuring element with a 5x5 cross, iterating two times
               ocv=filter_name=dilate:filter_params=5x5+2x2/cross|2

               # Read the shape from the file diamond.shape, iterating two times.
               # The file diamond.shape may contain a pattern of characters like this
               #   *
               #  ***
               # *****
               #  ***
               #   *
               # The specified columns and rows are ignored
               # but the anchor point coordinates are not
               ocv=dilate:0x0+2x2/custom=diamond.shape|2

       <u>erode</u>

       Erode an image by using a specific  structuring  element.   It  corresponds  to  the  libopencv  function
       "cvErode".

       It  accepts  the  parameters:  <u>struct_el</u>:<u>nb_iterations</u>,  with the same syntax and semantics as the <b>dilate</b>
       filter.

       <u>smooth</u>

       Smooth the input video.

       The filter takes the following parameters: <u>type</u>|<u>param1</u>|<u>param2</u>|<u>param3</u>|<u>param4</u>.

       <u>type</u> is the type of  smooth  filter  to  apply,  and  must  be  one  of  the  following  values:  "blur",
       "blur_no_scale", "median", "gaussian", or "bilateral". The default value is "gaussian".

       The  meaning  of  <u>param1</u>, <u>param2</u>, <u>param3</u>, and <u>param4</u> depends on the smooth type. <u>param1</u> and <u>param2</u> accept
       integer positive values or 0. <u>param3</u> and <u>param4</u> accept floating point values.

       The default value for <u>param1</u> is 3. The default value for the other parameters is 0.

       These parameters correspond to the parameters assigned to the libopencv function "cvSmooth".

   <b>oscilloscope</b>
       2D Video Oscilloscope.

       Useful to measure spatial impulse, step responses, chroma delays, etc.

       It accepts the following parameters:

       <b>x</b>   Set scope center x position.

       <b>y</b>   Set scope center y position.

       <b>s</b>   Set scope size, relative to frame diagonal.

       <b>t</b>   Set scope tilt/rotation.

       <b>o</b>   Set trace opacity.

       <b>tx</b>  Set trace center x position.

       <b>ty</b>  Set trace center y position.

       <b>tw</b>  Set trace width, relative to width of frame.

       <b>th</b>  Set trace height, relative to height of frame.

       <b>c</b>   Set which components to trace. By default it traces first three components.

       <b>g</b>   Draw trace grid. By default is enabled.

       <b>st</b>  Draw some statistics. By default is enabled.

       <b>sc</b>  Draw scope. By default is enabled.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.  The command accepts the same syntax of the  corresponding
       option.

       If the specified expression is not valid, it is kept at its current value.

       <u>Examples</u>

       •   Inspect full first row of video frame.

                   oscilloscope=x=0.5:y=0:s=1

       •   Inspect full last row of video frame.

                   oscilloscope=x=0.5:y=1:s=1

       •   Inspect full 5th line of video frame of height 1080.

                   oscilloscope=x=0.5:y=5/1080:s=1

       •   Inspect full last column of video frame.

                   oscilloscope=x=1:y=0.5:s=1:t=1

   <b>overlay</b>
       Overlay one video on top of another.

       It  takes two inputs and has one output. The first input is the "main" video on which the second input is
       overlaid.

       It accepts the following parameters:

       A description of the accepted options follows.

       <b>x</b>
       <b>y</b>   Set the expression for the x and y coordinates of the overlaid video on the main video. Default value
           is "0" for both expressions. In case the expression is invalid, it is set to a  huge  value  (meaning
           that the overlay will not be displayed within the output visible area).

       <b>eof_action</b>
           See <b>framesync</b>.

       <b>eval</b>
           Set when the expressions for <b>x</b>, and <b>y</b> are evaluated.

           It accepts the following values:

           <b>init</b>
               only evaluate expressions once during the filter initialization or when a command is processed

           <b>frame</b>
               evaluate expressions for each incoming frame

           Default value is <b>frame</b>.

       <b>shortest</b>
           See <b>framesync</b>.

       <b>format</b>
           Set the format for the output video.

           It accepts the following values:

           <b>yuv420</b>
               force YUV 4:2:0 8-bit planar output

           <b>yuv420p10</b>
               force YUV 4:2:0 10-bit planar output

           <b>yuv422</b>
               force YUV 4:2:2 8-bit planar output

           <b>yuv422p10</b>
               force YUV 4:2:2 10-bit planar output

           <b>yuv444</b>
               force YUV 4:4:4 8-bit planar output

           <b>yuv444p10</b>
               force YUV 4:4:4 10-bit planar output

           <b>rgb</b> force RGB 8-bit packed output

           <b>gbrp</b>
               force RGB 8-bit planar output

           <b>auto</b>
               automatically pick format

           Default value is <b>yuv420</b>.

       <b>repeatlast</b>
           See <b>framesync</b>.

       <b>alpha</b>
           Set format of alpha of the overlaid video, it can be <u>straight</u> or <u>premultiplied</u>. Default is <u>straight</u>.

       The <b>x</b>, and <b>y</b> expressions can contain the following parameters.

       <b>main_w,</b> <b>W</b>
       <b>main_h,</b> <b>H</b>
           The main input width and height.

       <b>overlay_w,</b> <b>w</b>
       <b>overlay_h,</b> <b>h</b>
           The overlay input width and height.

       <b>x</b>
       <b>y</b>   The computed values for <u>x</u> and <u>y</u>. They are evaluated for each new frame.

       <b>hsub</b>
       <b>vsub</b>
           horizontal  and  vertical  chroma  subsample  values  of the output format. For example for the pixel
           format "yuv422p" <u>hsub</u> is 2 and <u>vsub</u> is 1.

       <b>n</b>   the number of input frame, starting from 0

       <b>pos</b> the position in the file of the input frame, NAN if unknown; deprecated, do not use

       <b>t</b>   The timestamp, expressed in seconds. It's NAN if the input timestamp is unknown.

       This filter also supports the <b>framesync</b> options.

       Note that the <u>n</u>, <u>t</u> variables are available only when evaluation is done <u>per</u> <u>frame</u>, and will  evaluate  to
       NAN when <b>eval</b> is set to <b>init</b>.

       Be  aware  that  frames  are  taken  from  each  input  video in timestamp order, hence, if their initial
       timestamps differ, it is a good idea to pass the two inputs through a <u>setpts=PTS-STARTPTS</u> filter to  have
       them begin in the same zero timestamp, as the example for the <u>movie</u> filter does.

       You can chain together more overlays but you should test the efficiency of such approach.

       <u>Commands</u>

       This filter supports the following commands:

       <b>x</b>
       <b>y</b>   Modify  the  x  and y of the overlay input.  The command accepts the same syntax of the corresponding
           option.

           If the specified expression is not valid, it is kept at its current value.

       <u>Examples</u>

       •   Draw the overlay at 10 pixels from the bottom right corner of the main video:

                   overlay=main_w-overlay_w-10:main_h-overlay_h-10

           Using named options the example above becomes:

                   overlay=x=main_w-overlay_w-10:y=main_h-overlay_h-10

       •   Insert a transparent PNG logo in the bottom left corner of the input, using the <b>ffmpeg</b> tool with  the
           "-filter_complex" option:

                   ffmpeg -i input -i logo -filter_complex 'overlay=10:main_h-overlay_h-10' output

       •   Insert 2 different transparent PNG logos (second logo on bottom right corner) using the <b>ffmpeg</b> tool:

                   ffmpeg -i input -i logo1 -i logo2 -filter_complex 'overlay=x=10:y=H-h-10,overlay=x=W-w-10:y=H-h-10' output

       •   Add a transparent color layer on top of the main video; "WxH" must specify the size of the main input
           to the overlay filter:

                   color=color=red@.3:size=WxH [over]; [in][over] overlay [out]

       •   Play  an  original video and a filtered version (here with the deshake filter) side by side using the
           <b>ffplay</b> tool:

                   ffplay input.avi -vf 'split[a][b]; [a]pad=iw*2:ih[src]; [b]deshake[filt]; [src][filt]overlay=w'

           The above command is the same as:

                   ffplay input.avi -vf 'split[b], pad=iw*2[src], [b]deshake, [src]overlay=w'

       •   Make a sliding overlay appearing from the left to the right top part of  the  screen  starting  since
           time 2:

                   overlay=x='if(gte(t,2), -w+(t-2)*20, NAN)':y=0

       •   Compose output by putting two input videos side to side:

                   ffmpeg -i left.avi -i right.avi -filter_complex "
                   nullsrc=size=200x100 [background];
                   [0:v] setpts=PTS-STARTPTS, scale=100x100 [left];
                   [1:v] setpts=PTS-STARTPTS, scale=100x100 [right];
                   [background][left]       overlay=shortest=1       [background+left];
                   [background+left][right] overlay=shortest=1:x=100 [left+right]
                   "

       •   Mask 10-20 seconds of a video by applying the delogo filter to a section

                   ffmpeg -i test.avi -codec:v:0 wmv2 -ar 11025 -b:v 9000k
                   -vf '[in]split[split_main][split_delogo];[split_delogo]trim=start=360:end=371,delogo=0:0:640:480[delogoed];[split_main][delogoed]overlay=eof_action=pass[out]'
                   masked.avi

       •   Chain several overlays in cascade:

                   nullsrc=s=200x200 [bg];
                   testsrc=s=100x100, split=4 [in0][in1][in2][in3];
                   [in0] lutrgb=r=0, [bg]   overlay=0:0     [mid0];
                   [in1] lutrgb=g=0, [mid0] overlay=100:0   [mid1];
                   [in2] lutrgb=b=0, [mid1] overlay=0:100   [mid2];
                   [in3] null,       [mid2] overlay=100:100 [out0]

   <b>overlay_cuda</b>
       Overlay one video on top of another.

       This  is the CUDA variant of the <b>overlay</b> filter.  It only accepts CUDA frames. The underlying input pixel
       formats have to match.

       It takes two inputs and has one output. The first input is the "main" video on which the second input  is
       overlaid.

       It accepts the following parameters:

       <b>x</b>
       <b>y</b>   Set expressions for the x and y coordinates of the overlaid video on the main video.

           They can contain the following parameters:

           <b>main_w,</b> <b>W</b>
           <b>main_h,</b> <b>H</b>
               The main input width and height.

           <b>overlay_w,</b> <b>w</b>
           <b>overlay_h,</b> <b>h</b>
               The overlay input width and height.

           <b>x</b>
           <b>y</b>   The computed values for <u>x</u> and <u>y</u>. They are evaluated for each new frame.

           <b>n</b>   The ordinal index of the main input frame, starting from 0.

           <b>pos</b> The byte offset position in the file of the main input frame, NAN if unknown.  Deprecated, do not
               use.

           <b>t</b>   The timestamp of the main input frame, expressed in seconds, NAN if unknown.

           Default value is "0" for both expressions.

       <b>eval</b>
           Set when the expressions for <b>x</b> and <b>y</b> are evaluated.

           It accepts the following values:

           <b>init</b>
               Evaluate expressions once during filter initialization or when a command is processed.

           <b>frame</b>
               Evaluate expressions for each incoming frame

           Default value is <b>frame</b>.

       <b>eof_action</b>
           See <b>framesync</b>.

       <b>shortest</b>
           See <b>framesync</b>.

       <b>repeatlast</b>
           See <b>framesync</b>.

       This filter also supports the <b>framesync</b> options.

   <b>owdenoise</b>
       Apply Overcomplete Wavelet denoiser.

       The filter accepts the following options:

       <b>depth</b>
           Set depth.

           Larger depth values will denoise lower frequency components more, but slow down filtering.

           Must be an int in the range 8-16, default is 8.

       <b>luma_strength,</b> <b>ls</b>
           Set luma strength.

           Must be a double value in the range 0-1000, default is 1.0.

       <b>chroma_strength,</b> <b>cs</b>
           Set chroma strength.

           Must be a double value in the range 0-1000, default is 1.0.

   <b>pad</b>
       Add paddings to the input image, and place the original input at the provided <u>x</u>, <u>y</u> coordinates.

       It accepts the following parameters:

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           Specify  an  expression  for  the  size of the output image with the paddings added. If the value for
           <u>width</u> or <u>height</u> is 0, the corresponding input size is used for the output.

           The <u>width</u> expression can reference the value set by the <u>height</u> expression, and vice versa.

           The default value of <u>width</u> and <u>height</u> is 0.

       <b>x</b>
       <b>y</b>   Specify the offsets to place the input image at within the padded area, with respect to the  top/left
           border of the output image.

           The <u>x</u> expression can reference the value set by the <u>y</u> expression, and vice versa.

           The default value of <u>x</u> and <u>y</u> is 0.

           If  <u>x</u>  or  <u>y</u>  evaluate to a negative number, they'll be changed so the input image is centered on the
           padded area.

       <b>color</b>
           Specify the color of the padded area. For the syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b>
           <b>ffmpeg-utils</b> <b>manual</b>.

           The default value of <u>color</u> is "black".

       <b>eval</b>
           Specify when to evaluate  <u>width</u>, <u>height</u>, <u>x</u> and <u>y</u> expression.

           It accepts the following values:

           <b>init</b>
               Only evaluate expressions once during the filter initialization or when a command is processed.

           <b>frame</b>
               Evaluate expressions for each incoming frame.

           Default value is <b>init</b>.

       <b>aspect</b>
           Pad to aspect instead to a resolution.

       The value for the <u>width</u>, <u>height</u>, <u>x</u>, and <u>y</u> options are expressions containing the following constants:

       <b>in_w</b>
       <b>in_h</b>
           The input video width and height.

       <b>iw</b>
       <b>ih</b>  These are the same as <u>in_w</u> and <u>in_h</u>.

       <b>out_w</b>
       <b>out_h</b>
           The output width and height (the size of the padded area), as  specified  by  the  <u>width</u>  and  <u>height</u>
           expressions.

       <b>ow</b>
       <b>oh</b>  These are the same as <u>out_w</u> and <u>out_h</u>.

       <b>x</b>
       <b>y</b>   The x and y offsets as specified by the <u>x</u> and <u>y</u> expressions, or NAN if not yet specified.

       <b>a</b>   same as <u>iw</u> / <u>ih</u>

       <b>sar</b> input sample aspect ratio

       <b>dar</b> input display aspect ratio, it is the same as (<u>iw</u> / <u>ih</u>) * <u>sar</u>

       <b>hsub</b>
       <b>vsub</b>
           The  horizontal and vertical chroma subsample values. For example for the pixel format "yuv422p" <u>hsub</u>
           is 2 and <u>vsub</u> is 1.

       <u>Examples</u>

       •   Add paddings with the color "violet" to the input video. The output video size is  640x480,  and  the
           top-left corner of the input video is placed at column 0, row 40

                   pad=640:480:0:40:violet

           The example above is equivalent to the following command:

                   pad=width=640:height=480:x=0:y=40:color=violet

       •   Pad  the  input  to  get  an  output with dimensions increased by 3/2, and put the input video at the
           center of the padded area:

                   pad="3/2*iw:3/2*ih:(ow-iw)/2:(oh-ih)/2"

       •   Pad the input to get a squared output with size equal to the maximum value between  the  input  width
           and height, and put the input video at the center of the padded area:

                   pad="max(iw\,ih):ow:(ow-iw)/2:(oh-ih)/2"

       •   Pad the input to get a final w/h ratio of 16:9:

                   pad="ih*16/9:ih:(ow-iw)/2:(oh-ih)/2"

       •   In  case of anamorphic video, in order to set the output display aspect correctly, it is necessary to
           use <u>sar</u> in the expression, according to the relation:

                   (ih * X / ih) * sar = output_dar
                   X = output_dar / sar

           Thus the previous example needs to be modified to:

                   pad="ih*16/9/sar:ih:(ow-iw)/2:(oh-ih)/2"

       •   Double the output size and put the input video in the bottom-right corner of the output padded area:

                   pad="2*iw:2*ih:ow-iw:oh-ih"

   <b>palettegen</b>
       Generate one palette for a whole video stream.

       It accepts the following options:

       <b>max_colors</b>
           Set the maximum number of colors to quantize in the palette.  Note: the palette  will  still  contain
           256 colors; the unused palette entries will be black.

       <b>reserve_transparent</b>
           Create  a  palette  of  255  colors  maximum and reserve the last one for transparency. Reserving the
           transparency color is useful for GIF optimization.  If not set, the maximum of colors in the  palette
           will be 256. You probably want to disable this option for a standalone image.  Set by default.

       <b>transparency_color</b>
           Set the color that will be used as background for transparency.

       <b>stats_mode</b>
           Set statistics mode.

           It accepts the following values:

           <b>full</b>
               Compute full frame histograms.

           <b>diff</b>
               Compute  histograms only for the part that differs from previous frame. This might be relevant to
               give more importance to the moving part of your input if the background is static.

           <b>single</b>
               Compute new histogram for each frame.

           Default value is <u>full</u>.

       The filter also exports the frame metadata "lavfi.color_quant_ratio" ("nb_color_in / nb_color_out") which
       you can use to evaluate the degree of color quantization of the palette. This information is also visible
       at <u>info</u> logging level.

       <u>Examples</u>

       •   Generate a representative palette of a given video using <b>ffmpeg</b>:

                   ffmpeg -i input.mkv -vf palettegen palette.png

   <b>paletteuse</b>
       Use a palette to downsample an input video stream.

       The filter takes two inputs: one video stream and a palette. The palette must be a 256 pixels image.

       It accepts the following options:

       <b>dither</b>
           Select dithering mode. Available algorithms are:

           <b>bayer</b>
               Ordered 8x8 bayer dithering (deterministic)

           <b>heckbert</b>
               Dithering as defined by Paul Heckbert in 1982 (simple error diffusion).  Note: this dithering  is
               sometimes considered "wrong" and is included as a reference.

           <b>floyd_steinberg</b>
               Floyd and Steingberg dithering (error diffusion)

           <b>sierra2</b>
               Frankie Sierra dithering v2 (error diffusion)

           <b>sierra2_4a</b>
               Frankie Sierra dithering v2 "Lite" (error diffusion)

           <b>sierra3</b>
               Frankie Sierra dithering v3 (error diffusion)

           <b>burkes</b>
               Burkes dithering (error diffusion)

           <b>atkinson</b>
               Atkinson dithering by Bill Atkinson at Apple Computer (error diffusion)

           <b>none</b>
               Disable dithering.

           Default is <u>sierra2_4a</u>.

       <b>bayer_scale</b>
           When  <u>bayer</u>  dithering  is  selected,  this  option  defines  the  scale of the pattern (how much the
           crosshatch pattern is visible). A low value means more visible pattern for less banding,  and  higher
           value means less visible pattern at the cost of more banding.

           The option must be an integer value in the range [0,5]. Default is <u>2</u>.

       <b>diff_mode</b>
           If set, define the zone to process

           <b>rectangle</b>
               Only  the  changing  rectangle  will  be  reprocessed. This is similar to GIF cropping/offsetting
               compression mechanism. This option can be useful for speed  if  only  a  part  of  the  image  is
               changing,  and  has  use  cases  such  as  limiting the scope of the error diffusal <b>dither</b> to the
               rectangle that bounds the moving scene (it leads  to  more  deterministic  output  if  the  scene
               doesn't change much, and as a result less moving noise and better GIF compression).

           Default is <u>none</u>.

       <b>new</b> Take new palette for each output frame.

       <b>alpha_threshold</b>
           Sets  the  alpha  threshold  for  transparency.  Alpha values above this threshold will be treated as
           completely opaque, and values below this threshold will be treated as completely transparent.

           The option must be an integer value in the range [0,255]. Default is <u>128</u>.

       <u>Examples</u>

       •   Use a palette (generated for example with <b>palettegen</b>) to encode a GIF using <b>ffmpeg</b>:

                   ffmpeg -i input.mkv -i palette.png -lavfi paletteuse output.gif

   <b>perspective</b>
       Correct perspective of video not recorded perpendicular to the screen.

       A description of the accepted parameters follows.

       <b>x0</b>
       <b>y0</b>
       <b>x1</b>
       <b>y1</b>
       <b>x2</b>
       <b>y2</b>
       <b>x3</b>
       <b>y3</b>  Set coordinates expression for top left, top right, bottom left and bottom  right  corners.   Default
           values  are "0:0:W:0:0:H:W:H" with which perspective will remain unchanged.  If the "sense" option is
           set to "source", then the specified points will be sent to the corners of  the  destination.  If  the
           "sense"  option is set to "destination", then the corners of the source will be sent to the specified
           coordinates.

           The expressions can use the following variables:

           <b>W</b>
           <b>H</b>   the width and height of video frame.

           <b>in</b>  Input frame count.

           <b>on</b>  Output frame count.

       <b>interpolation</b>
           Set interpolation for perspective correction.

           It accepts the following values:

           <b>linear</b>
           <b>cubic</b>

           Default value is <b>linear</b>.

       <b>sense</b>
           Set interpretation of coordinate options.

           It accepts the following values:

           <b>0,</b> <b>source</b>
               Send point in the source specified by the given coordinates to the corners of the destination.

           <b>1,</b> <b>destination</b>
               Send the corners of  the  source  to  the  point  in  the  destination  specified  by  the  given
               coordinates.

               Default value is <b>source</b>.

       <b>eval</b>
           Set when the expressions for coordinates <b>x0,y0,...x3,y3</b> are evaluated.

           It accepts the following values:

           <b>init</b>
               only evaluate expressions once during the filter initialization or when a command is processed

           <b>frame</b>
               evaluate expressions for each incoming frame

           Default value is <b>init</b>.

   <b>phase</b>
       Delay interlaced video by one field time so that the field order changes.

       The  intended use is to fix PAL movies that have been captured with the opposite field order to the film-
       to-video transfer.

       A description of the accepted parameters follows.

       <b>mode</b>
           Set phase mode.

           It accepts the following values:

           <b>t</b>   Capture field order top-first, transfer bottom-first.  Filter will delay the bottom field.

           <b>b</b>   Capture field order bottom-first, transfer top-first.  Filter will delay the top field.

           <b>p</b>   Capture and transfer with the same field order. This mode only exists for  the  documentation  of
               the  other  options  to  refer  to,  but if you actually select it, the filter will faithfully do
               nothing.

           <b>a</b>   Capture field order determined automatically by field flags, transfer opposite.   Filter  selects
               among  <b>t</b>  and  <b>b</b>  modes  on  a frame by frame basis using field flags. If no field information is
               available, then this works just like <b>u</b>.

           <b>u</b>   Capture unknown or varying, transfer opposite.  Filter selects among <b>t</b> and <b>b</b> on a frame by  frame
               basis  by analyzing the images and selecting the alternative that produces best match between the
               fields.

           <b>T</b>   Capture top-first, transfer unknown or varying.   Filter  selects  among  <b>t</b>  and  <b>p</b>  using  image
               analysis.

           <b>B</b>   Capture  bottom-first,  transfer  unknown  or  varying.  Filter selects among <b>b</b> and <b>p</b> using image
               analysis.

           <b>A</b>   Capture determined by field flags, transfer unknown or varying.  Filter selects among <b>t</b>, <b>b</b> and  <b>p</b>
               using  field flags and image analysis. If no field information is available, then this works just
               like <b>U</b>. This is the default mode.

           <b>U</b>   Both capture and transfer unknown or varying.  Filter selects  among  <b>t</b>,  <b>b</b>  and  <b>p</b>  using  image
               analysis only.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>photosensitivity</b>
       Reduce various flashes in video, so to help users with epilepsy.

       It accepts the following options:

       <b>frames,</b> <b>f</b>
           Set how many frames to use when filtering. Default is 30.

       <b>threshold,</b> <b>t</b>
           Set detection threshold factor. Default is 1.  Lower is stricter.

       <b>skip</b>
           Set how many pixels to skip when sampling frames. Default is 1.  Allowed range is from 1 to 1024.

       <b>bypass</b>
           Leave frames unchanged. Default is disabled.

   <b>pixdesctest</b>
       Pixel format descriptor test filter, mainly useful for internal testing. The output video should be equal
       to the input video.

       For example:

               format=monow, pixdesctest

       can be used to test the monowhite pixel format descriptor definition.

   <b>pixelize</b>
       Apply pixelization to video stream.

       The filter accepts the following options:

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           Set block dimensions that will be used for pixelization.  Default value is 16.

       <b>mode,</b> <b>m</b>
           Set the mode of pixelization used.

           Possible values are:

           <b>avg</b>
           <b>min</b>
           <b>max</b>

           Default value is "avg".

       <b>planes,</b> <b>p</b>
           Set what planes to filter. Default is to filter all planes.

       <u>Commands</u>

       This filter supports all options as <b>commands</b>.

   <b>pixscope</b>
       Display  sample  values of color channels. Mainly useful for checking color and levels. Minimum supported
       resolution is 640x480.

       The filters accept the following options:

       <b>x</b>   Set scope X position, relative offset on X axis.

       <b>y</b>   Set scope Y position, relative offset on Y axis.

       <b>w</b>   Set scope width.

       <b>h</b>   Set scope height.

       <b>o</b>   Set window opacity. This window also holds statistics about pixel area.

       <b>wx</b>  Set window X position, relative offset on X axis.

       <b>wy</b>  Set window Y position, relative offset on Y axis.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>pp</b>
       Enable the specified chain of  postprocessing  subfilters  using  libpostproc.  This  library  should  be
       automatically selected with a GPL build ("--enable-gpl").  Subfilters must be separated by '/' and can be
       disabled  by  prepending a '-'.  Each subfilter and some options have a short and a long name that can be
       used interchangeably, i.e. dr/dering are the same.

       The filters accept the following options:

       <b>subfilters</b>
           Set postprocessing subfilters string.

       All subfilters share common options to determine their scope:

       <b>a/autoq</b>
           Honor the quality commands for this subfilter.

       <b>c/chrom</b>
           Do chrominance filtering, too (default).

       <b>y/nochrom</b>
           Do luma filtering only (no chrominance).

       <b>n/noluma</b>
           Do chrominance filtering only (no luma).

       These options can be appended after the subfilter name, separated by a '|'.

       Available subfilters are:

       <b>hb/hdeblock[|difference[|flatness]]</b>
           Horizontal deblocking filter

           <b>difference</b>
               Difference factor where higher values mean more deblocking (default: 32).

           <b>flatness</b>
               Flatness threshold where lower values mean more deblocking (default: 39).

       <b>vb/vdeblock[|difference[|flatness]]</b>
           Vertical deblocking filter

           <b>difference</b>
               Difference factor where higher values mean more deblocking (default: 32).

           <b>flatness</b>
               Flatness threshold where lower values mean more deblocking (default: 39).

       <b>ha/hadeblock[|difference[|flatness]]</b>
           Accurate horizontal deblocking filter

           <b>difference</b>
               Difference factor where higher values mean more deblocking (default: 32).

           <b>flatness</b>
               Flatness threshold where lower values mean more deblocking (default: 39).

       <b>va/vadeblock[|difference[|flatness]]</b>
           Accurate vertical deblocking filter

           <b>difference</b>
               Difference factor where higher values mean more deblocking (default: 32).

           <b>flatness</b>
               Flatness threshold where lower values mean more deblocking (default: 39).

       The horizontal and vertical deblocking filters share the difference and flatness values so you cannot set
       different horizontal and vertical thresholds.

       <b>h1/x1hdeblock</b>
           Experimental horizontal deblocking filter

       <b>v1/x1vdeblock</b>
           Experimental vertical deblocking filter

       <b>dr/dering</b>
           Deringing filter

       <b>tn/tmpnoise[|threshold1[|threshold2[|threshold3]]],</b> <b>temporal</b> <b>noise</b> <b>reducer</b>
           <b>threshold1</b>
               larger -&gt; stronger filtering

           <b>threshold2</b>
               larger -&gt; stronger filtering

           <b>threshold3</b>
               larger -&gt; stronger filtering

       <b>al/autolevels[:f/fullyrange],</b> <b>automatic</b> <b>brightness</b> <b>/</b> <b>contrast</b> <b>correction</b>
           <b>f/fullyrange</b>
               Stretch luma to "0-255".

       <b>lb/linblenddeint</b>
           Linear blend deinterlacing filter that deinterlaces the given block by filtering all lines with a "(1
           2 1)" filter.

       <b>li/linipoldeint</b>
           Linear interpolating deinterlacing filter that deinterlaces the given block by linearly interpolating
           every second line.

       <b>ci/cubicipoldeint</b>
           Cubic interpolating deinterlacing filter deinterlaces the  given  block  by  cubically  interpolating
           every second line.

       <b>md/mediandeint</b>
           Median  deinterlacing  filter  that deinterlaces the given block by applying a median filter to every
           second line.

       <b>fd/ffmpegdeint</b>
           FFmpeg deinterlacing filter that deinterlaces the given block by filtering every second line  with  a
           "(-1 4 2 4 -1)" filter.

       <b>l5/lowpass5</b>
           Vertically  applied  FIR  lowpass deinterlacing filter that deinterlaces the given block by filtering
           all lines with a "(-1 2 6 2 -1)" filter.

       <b>fq/forceQuant[|quantizer]</b>
           Overrides the quantizer table from the input with the constant quantizer you specify.

           <b>quantizer</b>
               Quantizer to use

       <b>de/default</b>
           Default pp filter combination ("hb|a,vb|a,dr|a")

       <b>fa/fast</b>
           Fast pp filter combination ("h1|a,v1|a,dr|a")

       <b>ac</b>  High quality pp filter combination ("ha|a|128|7,va|a,dr|a")

       <u>Examples</u>

       •   Apply horizontal and vertical deblocking, deringing and automatic brightness/contrast:

                   pp=hb/vb/dr/al

       •   Apply default filters without brightness/contrast correction:

                   pp=de/-al

       •   Apply default filters and temporal denoiser:

                   pp=default/tmpnoise|1|2|3

       •   Apply deblocking on luma only, and switch vertical deblocking on or off  automatically  depending  on
           available CPU time:

                   pp=hb|y/vb|a

   <b>pp7</b>
       Apply  Postprocessing  filter  7.  It  is variant of the <b>spp</b> filter, similar to spp = 6 with 7 point DCT,
       where only the center sample is used after IDCT.

       The filter accepts the following options:

       <b>qp</b>  Force a constant quantization parameter. It accepts an integer in range 0 to  63.  If  not  set,  the
           filter will use the QP from the video stream (if available).

       <b>mode</b>
           Set thresholding mode. Available modes are:

           <b>hard</b>
               Set hard thresholding.

           <b>soft</b>
               Set soft thresholding (better de-ringing effect, but likely blurrier).

           <b>medium</b>
               Set medium thresholding (good results, default).

   <b>premultiply</b>
       Apply alpha premultiply effect to input video stream using first plane of second stream as alpha.

       Both streams must have same dimensions and same pixel format.

       The filter accepts the following option:

       <b>planes</b>
           Set  which  planes  will  be processed, unprocessed planes will be copied.  By default value 0xf, all
           planes will be processed.

       <b>inplace</b>
           Do not require 2nd input for processing, instead use alpha plane from input stream.

   <b>prewitt</b>
       Apply prewitt operator to input video stream.

       The filter accepts the following option:

       <b>planes</b>
           Set which planes will be processed, unprocessed planes will be copied.  By  default  value  0xf,  all
           planes will be processed.

       <b>scale</b>
           Set value which will be multiplied with filtered result.

       <b>delta</b>
           Set value which will be added to filtered result.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>pseudocolor</b>
       Alter frame colors in video with pseudocolors.

       This filter accepts the following options:

       <b>c0</b>  set pixel first component expression

       <b>c1</b>  set pixel second component expression

       <b>c2</b>  set pixel third component expression

       <b>c3</b>  set pixel fourth component expression, corresponds to the alpha component

       <b>index,</b> <b>i</b>
           set component to use as base for altering colors

       <b>preset,</b> <b>p</b>
           Pick one of built-in LUTs. By default is set to none.

           Available LUTs:

           <b>magma</b>
           <b>inferno</b>
           <b>plasma</b>
           <b>viridis</b>
           <b>turbo</b>
           <b>cividis</b>
           <b>range1</b>
           <b>range2</b>
           <b>shadows</b>
           <b>highlights</b>
           <b>solar</b>
           <b>nominal</b>
           <b>preferred</b>
           <b>total</b>
           <b>spectral</b>
           <b>cool</b>
           <b>heat</b>
           <b>fiery</b>
           <b>blues</b>
           <b>green</b>
           <b>helix</b>
       <b>opacity</b>
           Set opacity of output colors. Allowed range is from 0 to 1.  Default value is set to 1.

       Each  of  the  expression  options specifies the expression to use for computing the lookup table for the
       corresponding pixel component values.

       The expressions can contain the following constants and functions:

       <b>w</b>
       <b>h</b>   The input width and height.

       <b>val</b> The input value for the pixel component.

       <b>ymin,</b> <b>umin,</b> <b>vmin,</b> <b>amin</b>
           The minimum allowed component value.

       <b>ymax,</b> <b>umax,</b> <b>vmax,</b> <b>amax</b>
           The maximum allowed component value.

       All expressions default to "val".

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

       <u>Examples</u>

       •   Change too high luma values to gradient:

                   pseudocolor="'if(between(val,ymax,amax),lerp(ymin,ymax,(val-ymax)/(amax-ymax)),-1):if(between(val,ymax,amax),lerp(umax,umin,(val-ymax)/(amax-ymax)),-1):if(between(val,ymax,amax),lerp(vmin,vmax,(val-ymax)/(amax-ymax)),-1):-1'"

   <b>psnr</b>
       Obtain the average, maximum and minimum PSNR (Peak Signal to Noise Ratio) between two input videos.

       This filter takes in input two input videos, the first input is  considered  the  "main"  source  and  is
       passed unchanged to the output. The second input is used as a "reference" video for computing the PSNR.

       Both  video inputs must have the same resolution and pixel format for this filter to work correctly. Also
       it assumes that both inputs have the same number of frames, which are compared one by one.

       The obtained average PSNR is printed through the logging system.

       The filter stores the accumulated MSE (mean squared  error)  of  each  frame,  and  at  the  end  of  the
       processing  it  is averaged across all frames equally, and the following formula is applied to obtain the
       PSNR:

               PSNR = 10*log10(MAX^2/MSE)

       Where MAX is the average of the maximum values of each component of the image.

       The description of the accepted parameters follows.

       <b>stats_file,</b> <b>f</b>
           If specified the filter will use the named file to save the  PSNR  of  each  individual  frame.  When
           filename equals "-" the data is sent to standard output.

       <b>stats_version</b>
           Specifies  which  version  of the stats file format to use. Details of each format are written below.
           Default value is 1.

       <b>stats_add_max</b>
           Determines whether the max value is  output  to  the  stats  log.   Default  value  is  0.   Requires
           stats_version &gt;= 2. If this is set and stats_version &lt; 2, the filter will return an error.

       This filter also supports the <b>framesync</b> options.

       The  file printed if <u>stats_file</u> is selected, contains a sequence of key/value pairs of the form <u>key</u>:<u>value</u>
       for each compared couple of frames.

       If a <u>stats_version</u> greater than 1 is specified, a header line precedes the list of per-frame-pair  stats,
       with key value pairs following the frame format with the following parameters:

       <b>psnr_log_version</b>
           The version of the log file format. Will match <u>stats_version</u>.

       <b>fields</b>
           A comma separated list of the per-frame-pair parameters included in the log.

       A description of each shown per-frame-pair parameter follows:

       <b>n</b>   sequential number of the input frame, starting from 1

       <b>mse_avg</b>
           Mean  Square  Error  pixel-by-pixel  average difference of the compared frames, averaged over all the
           image components.

       <b>mse_y,</b> <b>mse_u,</b> <b>mse_v,</b> <b>mse_r,</b> <b>mse_g,</b> <b>mse_b,</b> <b>mse_a</b>
           Mean Square Error pixel-by-pixel  average  difference  of  the  compared  frames  for  the  component
           specified by the suffix.

       <b>psnr_y,</b> <b>psnr_u,</b> <b>psnr_v,</b> <b>psnr_r,</b> <b>psnr_g,</b> <b>psnr_b,</b> <b>psnr_a</b>
           Peak Signal to Noise ratio of the compared frames for the component specified by the suffix.

       <b>max_avg,</b> <b>max_y,</b> <b>max_u,</b> <b>max_v</b>
           Maximum allowed value for each channel, and average over all channels.

       <u>Examples</u>

       •   For example:

                   movie=ref_movie.mpg, setpts=PTS-STARTPTS [main];
                   [main][ref] psnr="stats_file=stats.log" [out]

           On this example the input file being processed is compared with the reference file <u>ref_movie.mpg</u>. The
           PSNR of each individual frame is stored in <u>stats.log</u>.

       •   Another example with different containers:

                   ffmpeg -i main.mpg -i ref.mkv -lavfi  "[0:v]settb=AVTB,setpts=PTS-STARTPTS[main];[1:v]settb=AVTB,setpts=PTS-STARTPTS[ref];[main][ref]psnr" -f null -

   <b>pullup</b>
       Pulldown  reversal  (inverse  telecine)  filter,  capable of handling mixed hard-telecine, 24000/1001 fps
       progressive, and 30000/1001 fps progressive content.

       The pullup filter is designed to take advantage of future context in making its decisions. This filter is
       stateless in the sense that it does not lock onto a pattern to follow, but it instead  looks  forward  to
       the following fields in order to identify matches and rebuild progressive frames.

       To  produce  content  with an even framerate, insert the fps filter after pullup, use "fps=24000/1001" if
       the input frame rate is 29.97fps, "fps=24" for 30fps and the (rare) telecined 25fps input.

       The filter accepts the following options:

       <b>jl</b>
       <b>jr</b>
       <b>jt</b>
       <b>jb</b>  These options set the amount of "junk" to ignore at the left, right, top, and bottom  of  the  image,
           respectively.  Left and right are in units of 8 pixels, while top and bottom are in units of 2 lines.
           The default is 8 pixels on each side.

       <b>sb</b>  Set the strict breaks. Setting this option to 1 will reduce  the  chances  of  filter  generating  an
           occasional mismatched frame, but it may also cause an excessive number of frames to be dropped during
           high motion sequences.  Conversely, setting it to -1 will make filter match fields more easily.  This
           may  help  processing  of video where there is slight blurring between the fields, but may also cause
           there to be interlaced frames in the output.  Default value is 0.

       <b>mp</b>  Set the metric plane to use. It accepts the following values:

           <b>l</b>   Use luma plane.

           <b>u</b>   Use chroma blue plane.

           <b>v</b>   Use chroma red plane.

           This option may be set to use chroma plane instead of the  default  luma  plane  for  doing  filter's
           computations.  This may improve accuracy on very clean source material, but more likely will decrease
           accuracy, especially if there is chroma noise (rainbow effect) or  any  grayscale  video.   The  main
           purpose  of  setting <b>mp</b> to a chroma plane is to reduce CPU load and make pullup usable in realtime on
           slow machines.

       For best results (without duplicated frames in the output file) it is  necessary  to  change  the  output
       frame rate. For example, to inverse telecine NTSC input:

               ffmpeg -i input -vf pullup -r 24000/1001 ...

   <b>qp</b>
       Change video quantization parameters (QP).

       The filter accepts the following option:

       <b>qp</b>  Set expression for quantization parameter.

       The expression is evaluated through the eval API and can contain, among others, the following constants:

       <u>known</u>
           1 if index is not 129, 0 otherwise.

       <u>qp</u>  Sequential index starting from -129 to 128.

       <u>Examples</u>

       •   Some equation like:

                   qp=2+2*sin(PI*qp)

   <b>qrencode</b>
       Generate a QR code using the libqrencode library (see &lt;<b>https://fukuchi.org/works/qrencode/</b>&gt;), and overlay
       it on top of the current frame.

       To enable the compilation of this filter, you need to configure FFmpeg with "--enable-libqrencode".

       The  QR code is generated from the provided text or text pattern. The corresponding QR code is scaled and
       overlayed into the video output according to the specified options.

       In case no text is specified, no QR code is overlaied.

       This filter accepts the following options:

       <b>qrcode_width,</b> <b>q</b>
       <b>padded_qrcode_width,</b> <b>Q</b>
           Specify an expression for the  width  of  the  rendered  QR  code,  with  and  without  padding.  The
           <u>qrcode_width</u>  expression  can reference the value set by the <u>padded_qrcode_width</u> expression, and vice
           versa.  By default <u>padded_qrcode_width</u> is set to <u>qrcode_width</u>, meaning that there is no padding.

           These expressions are evaluated for each new frame.

           See the <b>qrencode</b> <b>Expressions</b> section for details.

       <b>x</b>
       <b>y</b>   Specify an expression for positioning the padded QR code  top-left  corner.   The  <u>x</u>  expression  can
           reference the value set by the <u>y</u> expression, and vice.

           By default <u>x</u> and <u>y</u> are set set to <u>0</u>, meaning that the QR code is placed in the top left corner of the
           input.

           These expressions are evaluated for each new frame.

           See the <b>qrencode</b> <b>Expressions</b> section for details.

       <b>case_sensitive,</b> <b>cs</b>
           Instruct libqrencode to use case sensitive encoding. This is enabled by default. This can be disabled
           to reduce the QR encoding size.

       <b>level,</b> <b>l</b>
           Specify  the  QR  encoding error correction level. With an higher correction level, the encoding size
           will increase but the code will be more robust to corruption.  Lower level is <u>L</u>.

           It accepts the following values:

           <b>L</b>
           <b>M</b>
           <b>Q</b>
           <b>H</b>
       <b>expansion</b>
           Select how the input text is expanded. Can be either "none", or "normal" (default). See the  <b>qrencode</b>
           <b>Text</b> <b>expansion</b> section below for details.

       <b>text</b>
       <b>textfile</b>
           Define the text to be rendered. In case neither is specified, no QR is encoded (just an empty colored
           frame).

           In  case  expansion  is enabled, the text is treated as a text template, using the qrencode expansion
           mechanism. See the <b>qrencode</b> <b>Text</b> <b>expansion</b> section below for details.

       <b>background_color,</b> <b>bc</b>
       <b>foreground_color,</b> <b>fc</b>
           Set the QR code and background color. The default value of <u>foreground_color</u> is "black",  the  default
           value of <u>background_color</u> is "white".

           For the syntax of the color options, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

       <u>qrencode</u> <u>Expressions</u>

       The expressions set by the options contain the following constants and functions.

       <b>dar</b> input display aspect ratio, it is the same as (<u>w</u> / <u>h</u>) * <u>sar</u>

       <b>duration</b>
           the current frame's duration, in seconds

       <b>hsub</b>
       <b>vsub</b>
           horizontal and vertical chroma subsample values. For example for the pixel format "yuv422p" <u>hsub</u> is 2
           and <u>vsub</u> is 1.

       <b>main_h,</b> <b>H</b>
           the input height

       <b>main_w,</b> <b>W</b>
           the input width

       <b>n</b>   the number of input frame, starting from 0

       <b>pict_type</b>
           a number representing the picture type

       <b>qr_w,</b> <b>w</b>
           the width of the encoded QR code

       <b>rendered_qr_w,</b> <b>q</b>
       <b>rendered_padded_qr_w,</b> <b>Q</b>
           the width of the rendered QR code, without and without padding.

           These parameters allow the <u>q</u> and <u>Q</u> expressions to refer to each other, so you can for example specify
           "q=3/4*Q".

       <b>rand(min,</b> <b>max)</b>
           return a random number included between <u>min</u> and <u>max</u>

       <b>sar</b> the input sample aspect ratio

       <b>t</b>   timestamp expressed in seconds, NAN if the input timestamp is unknown

       <b>x</b>
       <b>y</b>   the x and y offset coordinates where the text is drawn.

           These parameters allow the <u>x</u> and <u>y</u> expressions to refer to each other, so you can for example specify
           "y=x/dar".

       <u>qrencode</u> <u>Text</u> <u>expansion</u>

       If <b>expansion</b> is set to "none", the text is printed verbatim.

       If <b>expansion</b> is set to "normal" (which is the default), the following expansion mechanism is used.

       The backslash character <b>\</b>, followed by any character, always expands to the second character.

       Sequences  of  the  form  "%{...}" are expanded. The text between the braces is a function name, possibly
       followed by arguments separated by ':'.  If the arguments contain special characters or  delimiters  (':'
       or '}'), they should be escaped.

       Note  that  they  probably  must  also be escaped as the value for the <b>text</b> option in the filter argument
       string and as the filter argument in the filtergraph description, and possibly also for the  shell,  that
       makes up to four levels of escaping; using a text file with the <b>textfile</b> option avoids these problems.

       The following functions are available:

       <b>n,</b> <b>frame_num</b>
           return the frame number

       <b>pts</b> Return the presentation timestamp of the current frame.

           It can take up to two arguments.

           The  first  argument  is  the  format of the timestamp; it defaults to "flt" for seconds as a decimal
           number with microsecond accuracy;  "hms"  stands  for  a  formatted  <u>[-]HH:MM:SS.mmm</u>  timestamp  with
           millisecond  accuracy.   "gmtime"  stands  for  the  timestamp  of  the  frame formatted as UTC time;
           "localtime" stands for the timestamp of the frame formatted as local time zone time. If the format is
           set to "hms24hh", the time is formatted in 24h format (00-23).

           The second argument is an offset added to the timestamp.

           If the format is set to "localtime" or "gmtime", a third argument may be  supplied:  a  "strftime"  C
           function format string. By default, <u>YYYY-MM-DD</u> <u>HH:MM:SS</u> format will be used.

       <b>expr,</b> <b>e</b>
           Evaluate the expression's value and output as a double.

           It  must  take  one  argument  specifying the expression to be evaluated, accepting the constants and
           functions defined in <b>qrencode_expressions</b>.

       <b>expr_formatted,</b> <b>ef</b>
           Evaluate the expression's value and output as a formatted string.

           The first argument is the expression to be evaluated, just as for  the  <u>expr</u>  function.   The  second
           argument  specifies  the output format. Allowed values are <b>x</b>, <b>X</b>, <b>d</b> and <b>u</b>. They are treated exactly as
           in the "printf" function.  The third parameter is optional and sets the number of positions taken  by
           the output.  It can be used to add padding with zeros from the left.

       <b>gmtime</b>
           The time at which the filter is running, expressed in UTC.  It can accept an argument: a "strftime" C
           function  format  string.  The format string is extended to support the variable <u>%[1-6]N</u> which prints
           fractions of the second with optionally specified number of digits.

       <b>localtime</b>
           The time at which the filter is running, expressed  in  the  local  time  zone.   It  can  accept  an
           argument:  a  "strftime"  C  function  format  string.   The format string is extended to support the
           variable <u>%[1-6]N</u> which prints fractions of the second with optionally specified number of digits.

       <b>metadata</b>
           Frame metadata. Takes one or two arguments.

           The first argument is mandatory and specifies the metadata key.

           The second argument is optional and specifies a default value, used when  the  metadata  key  is  not
           found or empty.

           Available  metadata  can  be  identified by inspecting entries starting with TAG included within each
           frame section printed by running "ffprobe -show_frames".

           String metadata generated in filters leading to the qrencode filter are also available.

       <b>rand(min,</b> <b>max)</b>
           return a random number included between <u>min</u> and <u>max</u>

       <u>Examples</u>

       •   Generate a QR code encoding the specified text with the default  size,  overalaid  in  the  top  left
           corner of the input video, with the default size:

                   qrencode=text=www.ffmpeg.org

       •   Same as below, but select blue on pink colors:

                   qrencode=text=www.ffmpeg.org:bc=<a href="mailto:pink@0.5">pink@0.5</a>:fc=blue

       •   Place the QR code in the bottom right corner of the input video:

                   qrencode=text=www.ffmpeg.org:x=W-Q:y=H-Q

       •   Generate  a  QR code with width of 200 pixels and padding, making the padded width 4/3 of the QR code
           width:

                   qrencode=text=www.ffmpeg.org:q=200:Q=4/3*q

       •   Generate a QR code with padded width of 200 pixels and padding, making the QR code width 3/4  of  the
           padded width:

                   qrencode=text=www.ffmpeg.org:Q=200:q=3/4*Q

       •   Make the QR code a fraction of the input video width:

                   qrencode=text=www.ffmpeg.org:q=W/5

       •   Generate a QR code encoding the frame number:

                   qrencode=text=%{n}

       •   Generate a QR code encoding the GMT timestamp:

                   qrencode=text=%{gmtime}

       •   Generate a QR code encoding the timestamp expressed as a float:

                   qrencode=text=%{pts}

   <b>quirc</b>
       Identify  and  decode  a QR code using the libquirc library (see &lt;<b>https://github.com/dlbeer/quirc/</b>&gt;), and
       print the identified QR codes positions and payload as metadata.

       To enable the compilation of this filter, you need to configure FFmpeg with "--enable-libquirc".

       For each found QR code in the input video, some metadata entries are added with the prefix <u>lavfi.quirc.N</u>,
       where <u>N</u> is the index, starting from 0, associated to the QR code.

       A description of each metadata value follows:

       <b>lavfi.quirc.count</b>
           the number of found QR codes, it is not set in case none was found

       <b>lavfi.quirc.N.corner.M.x</b>
       <b>lavfi.quirc.N.coreer.M.y</b>
           the x/y positions of the four corners of the square containing the QR code, where <u>M</u> is the  index  of
           the corner starting from 0

       <b>lavfi.quirc.N.payload</b>
           the payload of the QR code

   <b>random</b>
       Flush  video  frames from internal cache of frames into a random order.  No frame is discarded.  Inspired
       by <b>frei0r</b> nervous filter.

       <b>frames</b>
           Set size in number of frames of internal cache, in range from 2 to 512. Default is 30.

       <b>seed</b>
           Set seed for random number generator, must be an integer included between 0 and "UINT32_MAX". If  not
           specified,  or  if  explicitly set to less than 0, the filter will try to use a good random seed on a
           best effort basis.

   <b>readeia608</b>
       Read closed captioning (EIA-608) information from the top lines of a video frame.

       This filter adds frame metadata for "lavfi.readeia608.X.cc" and "lavfi.readeia608.X.line", where  "X"  is
       the  number  of  the  identified line with EIA-608 data (starting from 0). A description of each metadata
       value follows:

       <b>lavfi.readeia608.X.cc</b>
           The two bytes stored as EIA-608 data (printed in hexadecimal).

       <b>lavfi.readeia608.X.line</b>
           The number of the line on which the EIA-608 data was identified and read.

       This filter accepts the following options:

       <b>scan_min</b>
           Set the line to start scanning for EIA-608 data. Default is 0.

       <b>scan_max</b>
           Set the line to end scanning for EIA-608 data. Default is 29.

       <b>spw</b> Set the ratio of width reserved for sync code detection.  Default is 0.27. Allowed range is  "[0.1  -
           0.7]".

       <b>chp</b> Enable  checking the parity bit. In the event of a parity error, the filter will output 0x00 for that
           character. Default is false.

       <b>lp</b>  Lowpass lines prior to further processing. Default is enabled.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

       <u>Examples</u>

       •   Output a csv with presentation time and the first two lines of identified EIA-608 captioning data.

                   ffprobe -f lavfi -i movie=captioned_video.mov,readeia608 -show_entries frame=pts_time:frame_tags=lavfi.readeia608.0.cc,lavfi.readeia608.1.cc -of csv

   <b>readvitc</b>
       Read vertical interval timecode (VITC) information from the top lines of a video frame.

       The filter adds frame metadata key "lavfi.readvitc.tc_str" with the timecode value, if a  valid  timecode
       has  been  detected.  Further  metadata  key  "lavfi.readvitc.found"  is  set to 0/1 depending on whether
       timecode data has been found or not.

       This filter accepts the following options:

       <b>scan_max</b>
           Set the maximum number of lines to scan for VITC data. If the value is set to -1 the full video frame
           is scanned. Default is 45.

       <b>thr_b</b>
           Set the luma threshold for black. Accepts float numbers in the range [0.0,1.0], default value is 0.2.
           The value must be equal or less than "thr_w".

       <b>thr_w</b>
           Set the luma threshold for white. Accepts float numbers in the range [0.0,1.0], default value is 0.6.
           The value must be equal or greater than "thr_b".

       <u>Examples</u>

       •   Detect and draw VITC data onto the video frame; if no valid VITC is detected, draw "--:--:--:--" as a
           placeholder:

                   ffmpeg -i input.avi -filter:v 'readvitc,drawtext=fontfile=FreeMono.ttf:text=%{metadata\\:lavfi.readvitc.tc_str\\:--\\\\\\:--\\\\\\:--\\\\\\:--}:x=(w-tw)/2:y=400-ascent'

   <b>remap</b>
       Remap pixels using 2nd: Xmap and 3rd: Ymap input video stream.

       Destination pixel at position (X, Y) will be picked from source (x, y) position where x = Xmap(X, Y)  and
       y  =  Ymap(X,  Y).  If mapping values are out of range, zero value for pixel will be used for destination
       pixel.

       Xmap and Ymap input video streams must be of same dimensions. Output video  stream  will  have  Xmap/Ymap
       video stream dimensions.  Xmap and Ymap input video streams are 16bit depth, single channel.

       <b>format</b>
           Specify pixel format of output from this filter. Can be "color" or "gray".  Default is "color".

       <b>fill</b>
           Specify the color of the unmapped pixels. For the syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b>
           <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>. Default color is "black".

   <b>removegrain</b>
       The removegrain filter is a spatial denoiser for progressive video.

       <b>m0</b>  Set mode for the first plane.

       <b>m1</b>  Set mode for the second plane.

       <b>m2</b>  Set mode for the third plane.

       <b>m3</b>  Set mode for the fourth plane.

       Range of mode is from 0 to 24. Description of each mode follows:

       <u>0</u>   Leave input plane unchanged. Default.

       <u>1</u>   Clips the pixel with the minimum and maximum of the 8 neighbour pixels.

       <u>2</u>   Clips the pixel with the second minimum and maximum of the 8 neighbour pixels.

       <u>3</u>   Clips the pixel with the third minimum and maximum of the 8 neighbour pixels.

       <u>4</u>   Clips the pixel with the fourth minimum and maximum of the 8 neighbour pixels.  This is equivalent to
           a median filter.

       <u>5</u>   Line-sensitive clipping giving the minimal change.

       <u>6</u>   Line-sensitive clipping, intermediate.

       <u>7</u>   Line-sensitive clipping, intermediate.

       <u>8</u>   Line-sensitive clipping, intermediate.

       <u>9</u>   Line-sensitive clipping on a line where the neighbours pixels are the closest.

       <u>10</u>  Replaces the target pixel with the closest neighbour.

       <u>11</u>  [1 2 1] horizontal and vertical kernel blur.

       <u>12</u>  Same as mode 11.

       <u>13</u>  Bob mode, interpolates top field from the line where the neighbours pixels are the closest.

       <u>14</u>  Bob mode, interpolates bottom field from the line where the neighbours pixels are the closest.

       <u>15</u>  Bob mode, interpolates top field. Same as 13 but with a more complicated interpolation formula.

       <u>16</u>  Bob mode, interpolates bottom field. Same as 14 but with a more complicated interpolation formula.

       <u>17</u>  Clips  the pixel with the minimum and maximum of respectively the maximum and minimum of each pair of
           opposite neighbour pixels.

       <u>18</u>  Line-sensitive clipping using opposite neighbours whose greatest distance from the current  pixel  is
           minimal.

       <u>19</u>  Replaces the pixel with the average of its 8 neighbours.

       <u>20</u>  Averages the 9 pixels ([1 1 1] horizontal and vertical blur).

       <u>21</u>  Clips pixels using the averages of opposite neighbour.

       <u>22</u>  Same as mode 21 but simpler and faster.

       <u>23</u>  Small edge and halo removal, but reputed useless.

       <u>24</u>  Similar as 23.

   <b>removelogo</b>
       Suppress  a TV station logo, using an image file to determine which pixels comprise the logo. It works by
       filling in the pixels that comprise the logo with neighboring pixels.

       The filter accepts the following options:

       <b>filename,</b> <b>f</b>
           Set the filter bitmap file, which can be any image format supported by  libavformat.  The  width  and
           height of the image file must match those of the video stream being processed.

       Pixels  in  the  provided bitmap image with a value of zero are not considered part of the logo, non-zero
       pixels are considered part of the logo. If you use white (255) for the logo and black (0) for  the  rest,
       you  will  be  safe.  For making the filter bitmap, it is recommended to take a screen capture of a black
       frame with the logo visible, and then using a threshold filter followed  by  the  erode  filter  once  or
       twice.

       If  needed,  little  splotches  can  be fixed manually. Remember that if logo pixels are not covered, the
       filter quality will be much reduced. Marking too many pixels as part of the logo does not hurt  as  much,
       but  it  will  increase  the  amount  of  blurring  needed  to cover over the image and will destroy more
       information than necessary, and extra pixels will slow things down on a large logo.

   <b>repeatfields</b>
       This filter uses the repeat_field flag from the Video ES headers and hard repeats  fields  based  on  its
       value.

   <b>reverse</b>
       Reverse a video clip.

       Warning: This filter requires memory to buffer the entire clip, so trimming is suggested.

       <u>Examples</u>

       •   Take the first 5 seconds of a clip, and reverse it.

                   trim=end=5,reverse

   <b>rgbashift</b>
       Shift R/G/B/A pixels horizontally and/or vertically.

       The filter accepts the following options:

       <b>rh</b>  Set amount to shift red horizontally.

       <b>rv</b>  Set amount to shift red vertically.

       <b>gh</b>  Set amount to shift green horizontally.

       <b>gv</b>  Set amount to shift green vertically.

       <b>bh</b>  Set amount to shift blue horizontally.

       <b>bv</b>  Set amount to shift blue vertically.

       <b>ah</b>  Set amount to shift alpha horizontally.

       <b>av</b>  Set amount to shift alpha vertically.

       <b>edge</b>
           Set edge mode, can be <u>smear</u>, default, or <u>warp</u>.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>roberts</b>
       Apply roberts cross operator to input video stream.

       The filter accepts the following option:

       <b>planes</b>
           Set  which  planes  will  be processed, unprocessed planes will be copied.  By default value 0xf, all
           planes will be processed.

       <b>scale</b>
           Set value which will be multiplied with filtered result.

       <b>delta</b>
           Set value which will be added to filtered result.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>rotate</b>
       Rotate video by an arbitrary angle expressed in radians.

       The filter accepts the following options:

       A description of the optional parameters follows.

       <b>angle,</b> <b>a</b>
           Set an expression for the angle by which to rotate the input video clockwise, expressed as  a  number
           of  radians.  A  negative  value will result in a counter-clockwise rotation. By default it is set to
           "0".

           This expression is evaluated for each frame.

       <b>out_w,</b> <b>ow</b>
           Set the output width expression, default value is "iw".   This  expression  is  evaluated  just  once
           during configuration.

       <b>out_h,</b> <b>oh</b>
           Set  the  output  height  expression,  default value is "ih".  This expression is evaluated just once
           during configuration.

       <b>bilinear</b>
           Enable bilinear interpolation if set to 1, a value of 0 disables it. Default value is 1.

       <b>fillcolor,</b> <b>c</b>
           Set the color used to fill the output area not covered by the rotated image. For the  general  syntax
           of this option, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  If the special value "none" is
           selected then no background is printed (useful for example if the background is never shown).

           Default value is "black".

       The expressions for the angle and the output size can contain the following constants and functions:

       <b>n</b>   sequential  number  of  the  input frame, starting from 0. It is always NAN before the first frame is
           filtered.

       <b>t</b>   time in seconds of the input frame, it is set to 0 when the filter is configured. It  is  always  NAN
           before the first frame is filtered.

       <b>hsub</b>
       <b>vsub</b>
           horizontal and vertical chroma subsample values. For example for the pixel format "yuv422p" <u>hsub</u> is 2
           and <u>vsub</u> is 1.

       <b>in_w,</b> <b>iw</b>
       <b>in_h,</b> <b>ih</b>
           the input video width and height

       <b>out_w,</b> <b>ow</b>
       <b>out_h,</b> <b>oh</b>
           the output width and height, that is the size of the padded area as specified by the <u>width</u> and <u>height</u>
           expressions

       <b>rotw(a)</b>
       <b>roth(a)</b>
           the minimal width/height required for completely containing the input video rotated by <u>a</u> radians.

           These are only available when computing the <b>out_w</b> and <b>out_h</b> expressions.

       <u>Examples</u>

       •   Rotate the input by PI/6 radians clockwise:

                   rotate=PI/6

       •   Rotate the input by PI/6 radians counter-clockwise:

                   rotate=-PI/6

       •   Rotate the input by 45 degrees clockwise:

                   rotate=45*PI/180

       •   Apply a constant rotation with period T, starting from an angle of PI/3:

                   rotate=PI/3+2*PI*t/T

       •   Make the input video rotation oscillating with a period of T seconds and an amplitude of A radians:

                   rotate=A*sin(2*PI/T*t)

       •   Rotate  the  video, output size is chosen so that the whole rotating input video is always completely
           contained in the output:

                   rotate='2*PI*t:ow=hypot(iw,ih):oh=ow'

       •   Rotate the video, reduce the output size so that no background is ever shown:

                   rotate=2*PI*t:ow='min(iw,ih)/<a href="../man2/sqrt.2.html">sqrt</a>(2)':oh=ow:c=none

       <u>Commands</u>

       The filter supports the following commands:

       <b>a,</b> <b>angle</b>
           Set the angle expression.  The command accepts the same syntax of the corresponding option.

           If the specified expression is not valid, it is kept at its current value.

   <b>sab</b>
       Apply Shape Adaptive Blur.

       The filter accepts the following options:

       <b>luma_radius,</b> <b>lr</b>
           Set luma blur filter strength, must be a value in range 0.1-4.0, default  value  is  1.0.  A  greater
           value will result in a more blurred image, and in slower processing.

       <b>luma_pre_filter_radius,</b> <b>lpfr</b>
           Set luma pre-filter radius, must be a value in the 0.1-2.0 range, default value is 1.0.

       <b>luma_strength,</b> <b>ls</b>
           Set  luma  maximum difference between pixels to still be considered, must be a value in the 0.1-100.0
           range, default value is 1.0.

       <b>chroma_radius,</b> <b>cr</b>
           Set chroma blur filter strength, must be a value in range -0.9-4.0. A greater value will result in  a
           more blurred image, and in slower processing.

       <b>chroma_pre_filter_radius,</b> <b>cpfr</b>
           Set chroma pre-filter radius, must be a value in the -0.9-2.0 range.

       <b>chroma_strength,</b> <b>cs</b>
           Set  chroma  maximum  difference  between  pixels  to  still  be  considered,  must be a value in the
           -0.9-100.0 range.

       Each chroma option value, if not explicitly specified, is set to the corresponding luma option value.

   <b>scale</b>
       Scale (resize) the input video, using the libswscale library.

       The scale filter forces the output display aspect ratio to be the same of  the  input,  by  changing  the
       output sample aspect ratio.

       If  the  input  image  format is different from the format requested by the next filter, the scale filter
       will convert the input to the requested format.

       <u>Options</u>

       The filter accepts the following options, any of the options supported by the libswscale scaler, as  well
       as any of the <b>framesync</b> options.

       See <b>the</b> <b>ffmpeg-scaler</b> <b>manual</b> for the complete list of scaler options.

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           Set the output video dimension expression. Default value is the input dimension.

           If  the <u>width</u> or <u>w</u> value is 0, the input width is used for the output. If the <u>height</u> or <u>h</u> value is 0,
           the input height is used for the output.

           If one and only one of the values is -n with n &gt;= 1, the scale filter will use a value that maintains
           the aspect ratio of the input image, calculated from the other specified  dimension.  After  that  it
           will,  however,  make  sure  that  the calculated dimension is divisible by n and adjust the value if
           necessary.

           If both values are -n with n &gt;= 1, the behavior will be identical to both values being set  to  0  as
           previously detailed.

           See below for the list of accepted constants for use in the dimension expression.

       <b>eval</b>
           Specify when to evaluate <u>width</u> and <u>height</u> expression. It accepts the following values:

           <b>init</b>
               Only evaluate expressions once during the filter initialization or when a command is processed.

           <b>frame</b>
               Evaluate expressions for each incoming frame.

           Default value is <b>init</b>.

       <b>interl</b>
           Set the interlacing mode. It accepts the following values:

           <b>1</b>   Force interlaced aware scaling.

           <b>0</b>   Do not apply interlaced scaling.

           <b>-1</b>  Select  interlaced aware scaling depending on whether the source frames are flagged as interlaced
               or not.

           Default value is <b>0</b>.

       <b>flags</b>
           Set libswscale scaling flags. See <b>the</b> <b>ffmpeg-scaler</b> <b>manual</b> for the complete list of  values.  If  not
           explicitly specified the filter applies the default flags.

       <b>param0,</b> <b>param1</b>
           Set  libswscale  input parameters for scaling algorithms that need them. See <b>the</b> <b>ffmpeg-scaler</b> <b>manual</b>
           for the complete documentation. If not explicitly specified the filter applies empty parameters.

       <b>size,</b> <b>s</b>
           Set the video size. For the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b>
           <b>manual</b>.

       <b>in_color_matrix</b>
       <b>out_color_matrix</b>
           Set in/output YCbCr color space type.

           This allows the autodetected value to be overridden as well as allows forcing a specific  value  used
           for the output and encoder.

           If not specified, the color space type depends on the pixel format.

           Possible values:

           <b>auto</b>
               Choose automatically.

           <b>bt709</b>
               Format conforming to International Telecommunication Union (ITU) Recommendation BT.709.

           <b>fcc</b> Set  color  space conforming to the United States Federal Communications Commission (FCC) Code of
               Federal Regulations (CFR) Title 47 (2003) 73.682 (a).

           <b>bt601</b>
           <b>bt470</b>
           <b>smpte170m</b>
               Set color space conforming to:

               •   ITU Radiocommunication Sector (ITU-R) Recommendation BT.601

               •   ITU-R Rec. BT.470-6 (1998) Systems B, B1, and G

               •   Society of Motion Picture and Television Engineers (SMPTE) ST 170:2004

           <b>smpte240m</b>
               Set color space conforming to SMPTE ST 240:1999.

           <b>bt2020</b>
               Set color space conforming to ITU-R BT.2020 non-constant luminance system.

       <b>in_range</b>
       <b>out_range</b>
           Set in/output YCbCr sample range.

           This allows the autodetected value to be overridden as well as allows forcing a specific  value  used
           for the output and encoder. If not specified, the range depends on the pixel format. Possible values:

           <b>auto/unknown</b>
               Choose automatically.

           <b>jpeg/full/pc</b>
               Set full range (0-255 in case of 8-bit luma).

           <b>mpeg/limited/tv</b>
               Set "MPEG" range (16-235 in case of 8-bit luma).

       <b>in_chroma_loc</b>
       <b>out_chroma_loc</b>
           Set  in/output  chroma  sample  location.  If  not specified, center-sited chroma is used by default.
           Possible values:

           <b>auto,</b> <b>unknown</b>
           <b>left</b>
           <b>center</b>
           <b>topleft</b>
           <b>top</b>
           <b>bottomleft</b>
           <b>bottom</b>
       <b>force_original_aspect_ratio</b>
           Enable decreasing or increasing output video width or height if necessary to keep the original aspect
           ratio. Possible values:

           <b>disable</b>
               Scale the video as specified and disable this feature.

           <b>decrease</b>
               The output video dimensions will automatically be decreased if needed.

           <b>increase</b>
               The output video dimensions will automatically be increased if needed.

           One useful instance of this option is  that  when  you  know  a  specific  device's  maximum  allowed
           resolution, you can use this to limit the output video to that, while retaining the aspect ratio. For
           example,  device A allows 1280x720 playback, and your video is 1920x800. Using this option (set it to
           decrease) and specifying 1280x720 to the command line makes the output 1280x533.

           Please note that this is a different thing than specifying -1 for <b>w</b> or <b>h</b>, you still need  to  specify
           the output resolution for this option to work.

       <b>force_divisible_by</b>
           Ensures  that  both  the output dimensions, width and height, are divisible by the given integer when
           used together with <b>force_original_aspect_ratio</b>. This works similar to using  "-n"  in  the  <b>w</b>  and  <b>h</b>
           options.

           This  option  respects  the  value  set for <b>force_original_aspect_ratio</b>, increasing or decreasing the
           resolution accordingly. The video's aspect ratio may be slightly modified.

           This option can be handy if you need to have a video fit within or exceed a defined resolution  using
           <b>force_original_aspect_ratio</b> but also have encoder restrictions on width or height divisibility.

       The values of the <b>w</b> and <b>h</b> options are expressions containing the following constants:

       <u>in_w</u>
       <u>in_h</u>
           The input width and height

       <u>iw</u>
       <u>ih</u>  These are the same as <u>in_w</u> and <u>in_h</u>.

       <u>out_w</u>
       <u>out_h</u>
           The output (scaled) width and height

       <u>ow</u>
       <u>oh</u>  These are the same as <u>out_w</u> and <u>out_h</u>

       <u>a</u>   The same as <u>iw</u> / <u>ih</u>

       <u>sar</u> input sample aspect ratio

       <u>dar</u> The input display aspect ratio. Calculated from "(iw / ih) * sar".

       <u>hsub</u>
       <u>vsub</u>
           horizontal  and  vertical  input  chroma subsample values. For example for the pixel format "yuv422p"
           <u>hsub</u> is 2 and <u>vsub</u> is 1.

       <u>ohsub</u>
       <u>ovsub</u>
           horizontal and vertical output chroma subsample values. For example for the  pixel  format  "yuv422p"
           <u>hsub</u> is 2 and <u>vsub</u> is 1.

       <u>n</u>   The (sequential) number of the input frame, starting from 0.  Only available with "eval=frame".

       <u>t</u>   The  presentation timestamp of the input frame, expressed as a number of seconds. Only available with
           "eval=frame".

       <u>pos</u> The position (byte offset) of the  frame  in  the  input  stream,  or  NaN  if  this  information  is
           unavailable  and/or  meaningless  (for  example  in  case  of  synthetic video).  Only available with
           "eval=frame".  Deprecated, do not use.

       <u>ref_w,</u> <u>rw</u>
       <u>ref_h,</u> <u>rh</u>
       <u>ref_a</u>
       <u>ref_dar,</u> <u>rdar</u>
       <u>ref_n</u>
       <u>ref_t</u>
       <u>ref_pos</u>
           Eqvuialent to the above, but for a second reference input. If any of  these  variables  are  present,
           this filter accepts two inputs.

       <u>Examples</u>

       •   Scale the input video to a size of 200x100

                   scale=w=200:h=100

           This is equivalent to:

                   scale=200:100

           or:

                   scale=200x100

       •   Specify a size abbreviation for the output size:

                   scale=qcif

           which can also be written as:

                   scale=size=qcif

       •   Scale the input to 2x:

                   scale=w=2*iw:h=2*ih

       •   The above is the same as:

                   scale=2*in_w:2*in_h

       •   Scale the input to 2x with forced interlaced scaling:

                   scale=2*iw:2*ih:interl=1

       •   Scale the input to half size:

                   scale=w=iw/2:h=ih/2

       •   Increase the width, and set the height to the same size:

                   scale=3/2*iw:ow

       •   Seek Greek harmony:

                   scale=iw:1/PHI*iw
                   scale=ih*PHI:ih

       •   Increase the height, and set the width to 3/2 of the height:

                   scale=w=3/2*oh:h=3/5*ih

       •   Increase the size, making the size a multiple of the chroma subsample values:

                   scale="trunc(3/2*iw/hsub)*hsub:trunc(3/2*ih/vsub)*vsub"

       •   Increase the width to a maximum of 500 pixels, keeping the same aspect ratio as the input:

                   scale=w='min(500\, iw*3/2):h=-1'

       •   Make pixels square by combining scale and setsar:

                   scale='trunc(ih*dar):ih',setsar=1/1

       •   Make  pixels  square  by  combining  scale  and  setsar, making sure the resulting resolution is even
           (required by some codecs):

                   scale='trunc(ih*dar/2)*2:trunc(ih/2)*2',setsar=1/1

       •   Scale a subtitle stream (sub) to match the main video (main) in size before overlaying. ("scale2ref")

                   '[main]split[a][b]; [ref][a]scale=rw:rh[c]; [b][c]overlay'

       •   Scale a logo to 1/10th the height of a video, while preserving its display aspect ratio.

                   [logo-in][video-in]scale=w=oh*dar:h=rh/10[logo-out]

       <u>Commands</u>

       This filter supports the following commands:

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           Set the output video dimension expression.  The command accepts the same syntax of the  corresponding
           option.

           If the specified expression is not valid, it is kept at its current value.

   <b>scale_cuda</b>
       Scale  (resize)  and convert (pixel format) the input video, using accelerated CUDA kernels.  Setting the
       output width and height works in the same way as for the <b>scale</b> filter.

       The filter accepts the following options:

       <b>w</b>
       <b>h</b>   Set the output video dimension expression. Default value is the input dimension.

           Allows for the same expressions as the <b>scale</b> filter.

       <b>interp_algo</b>
           Sets the algorithm used for scaling:

           <u>nearest</u>
               Nearest neighbour

               Used by default if input parameters match the desired output.

           <u>bilinear</u>
               Bilinear

           <u>bicubic</u>
               Bicubic

               This is the default.

           <u>lanczos</u>
               Lanczos

       <b>format</b>
           Controls the output pixel format. By default, or if none is specified,  the  input  pixel  format  is
           used.

           The filter does not support converting between YUV and RGB pixel formats.

       <b>passthrough</b>
           If  set  to 0, every frame is processed, even if no conversion is necessary.  This mode can be useful
           to use the filter as a buffer for a downstream frame-consumer that exhausts the limited decoder frame
           pool.

           If set to 1, frames are passed through as-is if they match the desired output parameters. This is the
           default behaviour.

       <b>param</b>
           Algorithm-Specific parameter.

           Affects the curves of the bicubic algorithm.

       <b>force_original_aspect_ratio</b>
       <b>force_divisible_by</b>
           Work the same as the identical <b>scale</b> filter options.

       <u>Examples</u>

       •   Scale input to 720p, keeping aspect ratio and ensuring the output is yuv420p.

                   scale_cuda=-2:720:format=yuv420p

       •   Upscale to 4K using nearest neighbour algorithm.

                   scale_cuda=4096:2160:interp_algo=nearest

       •   Don't do any conversion or scaling, but copy all input frames into newly allocated ones.  This can be
           useful to deal with a filter and encode chain that otherwise exhausts the decoders frame pool.

                   scale_cuda=passthrough=0

   <b>scale_npp</b>
       Use the NVIDIA Performance Primitives (libnpp) to perform scaling and/or pixel format conversion on  CUDA
       video frames. Setting the output width and height works in the same way as for the <u>scale</u> filter.

       The following additional options are accepted:

       <b>format</b>
           The  pixel  format  of  the  output CUDA frames. If set to the string "same" (the default), the input
           format will be kept. Note that automatic format negotiation and conversion is not yet  supported  for
           hardware frames

       <b>interp_algo</b>
           The interpolation algorithm used for resizing. One of the following:

           <b>nn</b>  Nearest neighbour.

           <b>linear</b>
           <b>cubic</b>
           <b>cubic2p_bspline</b>
               2-parameter cubic (B=1, C=0)

           <b>cubic2p_catmullrom</b>
               2-parameter cubic (B=0, C=1/2)

           <b>cubic2p_b05c03</b>
               2-parameter cubic (B=1/2, C=3/10)

           <b>super</b>
               Supersampling

           <b>lanczos</b>
       <b>force_original_aspect_ratio</b>
           Enable decreasing or increasing output video width or height if necessary to keep the original aspect
           ratio. Possible values:

           <b>disable</b>
               Scale the video as specified and disable this feature.

           <b>decrease</b>
               The output video dimensions will automatically be decreased if needed.

           <b>increase</b>
               The output video dimensions will automatically be increased if needed.

           One  useful  instance  of  this  option  is  that  when  you know a specific device's maximum allowed
           resolution, you can use this to limit the output video to that, while retaining the aspect ratio. For
           example, device A allows 1280x720 playback, and your video is 1920x800. Using this option (set it  to
           decrease) and specifying 1280x720 to the command line makes the output 1280x533.

           Please  note  that this is a different thing than specifying -1 for <b>w</b> or <b>h</b>, you still need to specify
           the output resolution for this option to work.

       <b>force_divisible_by</b>
           Ensures that both the output dimensions, width and height, are divisible by the  given  integer  when
           used  together  with  <b>force_original_aspect_ratio</b>.  This  works  similar to using "-n" in the <b>w</b> and <b>h</b>
           options.

           This option respects the value set for  <b>force_original_aspect_ratio</b>,  increasing  or  decreasing  the
           resolution accordingly. The video's aspect ratio may be slightly modified.

           This  option can be handy if you need to have a video fit within or exceed a defined resolution using
           <b>force_original_aspect_ratio</b> but also have encoder restrictions on width or height divisibility.

       <b>eval</b>
           Specify when to evaluate <u>width</u> and <u>height</u> expression. It accepts the following values:

           <b>init</b>
               Only evaluate expressions once during the filter initialization or when a command is processed.

           <b>frame</b>
               Evaluate expressions for each incoming frame.

       The values of the <b>w</b> and <b>h</b> options are expressions containing the following constants:

       <u>in_w</u>
       <u>in_h</u>
           The input width and height

       <u>iw</u>
       <u>ih</u>  These are the same as <u>in_w</u> and <u>in_h</u>.

       <u>out_w</u>
       <u>out_h</u>
           The output (scaled) width and height

       <u>ow</u>
       <u>oh</u>  These are the same as <u>out_w</u> and <u>out_h</u>

       <u>a</u>   The same as <u>iw</u> / <u>ih</u>

       <u>sar</u> input sample aspect ratio

       <u>dar</u> The input display aspect ratio. Calculated from "(iw / ih) * sar".

       <u>n</u>   The (sequential) number of the input frame, starting from 0.  Only available with "eval=frame".

       <u>t</u>   The presentation timestamp of the input frame, expressed as a number of seconds. Only available  with
           "eval=frame".

       <u>pos</u> The  position  (byte  offset)  of  the  frame  in  the  input  stream,  or NaN if this information is
           unavailable and/or meaningless (for example  in  case  of  synthetic  video).   Only  available  with
           "eval=frame".  Deprecated, do not use.

   <b>scale2ref_npp</b>
       Use  the  NVIDIA  Performance Primitives (libnpp) to scale (resize) the input video, based on a reference
       video.

       See the <b>scale_npp</b> filter for available options, scale2ref_npp supports the same but  uses  the  reference
       video  instead of the main input as basis. scale2ref_npp also supports the following additional constants
       for the <b>w</b> and <b>h</b> options:

       <u>main_w</u>
       <u>main_h</u>
           The main input video's width and height

       <u>main_a</u>
           The same as <u>main_w</u> / <u>main_h</u>

       <u>main_sar</u>
           The main input video's sample aspect ratio

       <u>main_dar,</u> <u>mdar</u>
           The main input video's display aspect ratio. Calculated from "(main_w / main_h) * main_sar".

       <u>main_n</u>
           The (sequential) number of the main input frame, starting from 0.  Only available with "eval=frame".

       <u>main_t</u>
           The presentation timestamp of the main input frame, expressed as a number of seconds. Only  available
           with "eval=frame".

       <u>main_pos</u>
           The  position  (byte  offset)  of  the  frame in the main input stream, or NaN if this information is
           unavailable and/or meaningless (for example  in  case  of  synthetic  video).   Only  available  with
           "eval=frame".

       <u>Examples</u>

       •   Scale a subtitle stream (b) to match the main video (a) in size before overlaying

                   'scale2ref_npp[b][a];[a][b]overlay_cuda'

       •   Scale a logo to 1/10th the height of a video, while preserving its display aspect ratio.

                   [logo-in][video-in]scale2ref_npp=w=oh*mdar:h=ih/10[logo-out][video-out]

   <b>scale_vt</b>
       Scale and convert the color parameters using VTPixelTransferSession.

       The filter accepts the following options:

       <b>w</b>
       <b>h</b>   Set the output video dimension expression. Default value is the input dimension.

       <b>color_matrix</b>
           Set the output colorspace matrix.

       <b>color_primaries</b>
           Set the output color primaries.

       <b>color_transfer</b>
           Set the output transfer characteristics.

   <b>scharr</b>
       Apply scharr operator to input video stream.

       The filter accepts the following option:

       <b>planes</b>
           Set  which  planes  will  be processed, unprocessed planes will be copied.  By default value 0xf, all
           planes will be processed.

       <b>scale</b>
           Set value which will be multiplied with filtered result.

       <b>delta</b>
           Set value which will be added to filtered result.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>scroll</b>
       Scroll input video horizontally and/or vertically by constant speed.

       The filter accepts the following options:

       <b>horizontal,</b> <b>h</b>
           Set the horizontal scrolling speed. Default is 0. Allowed range is from -1  to  1.   Negative  values
           changes scrolling direction.

       <b>vertical,</b> <b>v</b>
           Set  the  vertical  scrolling  speed.  Default  is 0. Allowed range is from -1 to 1.  Negative values
           changes scrolling direction.

       <b>hpos</b>
           Set the initial horizontal scrolling position. Default is 0. Allowed range is from 0 to 1.

       <b>vpos</b>
           Set the initial vertical scrolling position. Default is 0. Allowed range is from 0 to 1.

       <u>Commands</u>

       This filter supports the following <b>commands</b>:

       <b>horizontal,</b> <b>h</b>
           Set the horizontal scrolling speed.

       <b>vertical,</b> <b>v</b>
           Set the vertical scrolling speed.

   <b>scdet</b>
       Detect video scene change.

       This filter sets frame metadata with mafd between frame, the scene score, and forward the  frame  to  the
       next filter, so they can use these metadata to detect scene change or others.

       In  addition,  this  filter  logs  a  message  and  sets frame metadata when it detects a scene change by
       <b>threshold</b>.

       "lavfi.scd.mafd" metadata keys are set with mafd for every frame.

       "lavfi.scd.score" metadata keys are set with scene change score for every frame to detect scene change.

       "lavfi.scd.time" metadata keys are set with current filtered frame time which detect  scene  change  with
       <b>threshold</b>.

       The filter accepts the following options:

       <b>threshold,</b> <b>t</b>
           Set  the  scene  change detection threshold as a percentage of maximum change. Good values are in the
           "[8.0, 14.0]" range. The range for <b>threshold</b> is "[0., 100.]".

           Default value is 10..

       <b>sc_pass,</b> <b>s</b>
           Set the flag to pass scene change frames to the next filter. Default value is 0 You can enable it  if
           you want to get snapshot of scene change frames only.

   <b>selectivecolor</b>
       Adjust  cyan,  magenta,  yellow  and black (CMYK) to certain ranges of colors (such as "reds", "yellows",
       "greens", "cyans", ...). The adjustment range is defined by the "purity"  of  the  color  (that  is,  how
       saturated it already is).

       This filter is similar to the Adobe Photoshop Selective Color tool.

       The filter accepts the following options:

       <b>correction_method</b>
           Select color correction method.

           Available values are:

           <b>absolute</b>
               Specified adjustments are applied "as-is" (added/subtracted to original pixel component value).

           <b>relative</b>
               Specified adjustments are relative to the original component value.

           Default is "absolute".

       <b>reds</b>
           Adjustments for red pixels (pixels where the red component is the maximum)

       <b>yellows</b>
           Adjustments for yellow pixels (pixels where the blue component is the minimum)

       <b>greens</b>
           Adjustments for green pixels (pixels where the green component is the maximum)

       <b>cyans</b>
           Adjustments for cyan pixels (pixels where the red component is the minimum)

       <b>blues</b>
           Adjustments for blue pixels (pixels where the blue component is the maximum)

       <b>magentas</b>
           Adjustments for magenta pixels (pixels where the green component is the minimum)

       <b>whites</b>
           Adjustments for white pixels (pixels where all components are greater than 128)

       <b>neutrals</b>
           Adjustments for all pixels except pure black and pure white

       <b>blacks</b>
           Adjustments for black pixels (pixels where all components are lesser than 128)

       <b>psfile</b>
           Specify a Photoshop selective color file (".asv") to import the settings from.

       All the adjustment settings (<b>reds</b>, <b>yellows</b>, ...) accept up to 4 space separated floating point adjustment
       values  in the [-1,1] range, respectively to adjust the amount of cyan, magenta, yellow and black for the
       pixels of its range.

       <u>Examples</u>

       •   Increase cyan by 50% and reduce yellow by 33% in every green areas, and increase magenta  by  27%  in
           blue areas:

                   selectivecolor=greens=.5 0 -.33 0:blues=0 .27

       •   Use a Photoshop selective color preset:

                   selectivecolor=psfile=MySelectiveColorPresets/Misty.asv

   <b>separatefields</b>
       The  "separatefields"  takes  a frame-based video input and splits each frame into its components fields,
       producing a new half height clip with twice the frame rate and twice the frame count.

       This filter use field-dominance information in frame to decide which of each  pair  of  fields  to  place
       first in the output.  If it gets it wrong use <b>setfield</b> filter before "separatefields" filter.

   <b>setdar,</b> <b>setsar</b>
       The "setdar" filter sets the Display Aspect Ratio for the filter output video.

       This  is  done  by  changing  the  specified  Sample (aka Pixel) Aspect Ratio, according to the following
       equation:

               &lt;DAR&gt; = &lt;HORIZONTAL_RESOLUTION&gt; / &lt;VERTICAL_RESOLUTION&gt; * &lt;SAR&gt;

       Keep in mind that the "setdar" filter does not modify the pixel dimensions of the video frame. Also,  the
       display  aspect ratio set by this filter may be changed by later filters in the filterchain, e.g. in case
       of scaling or if another "setdar" or a "setsar" filter is applied.

       The "setsar" filter sets the Sample (aka Pixel) Aspect Ratio for the filter output video.

       Note that as a consequence of the application of this filter, the output display aspect ratio will change
       according to the equation above.

       Keep in mind that the sample aspect ratio set by the "setsar" filter may be changed by later  filters  in
       the filterchain, e.g. if another "setsar" or a "setdar" filter is applied.

       It accepts the following parameters:

       <b>r,</b> <b>ratio,</b> <b>dar</b> <b>("setdar"</b> <b>only),</b> <b>sar</b> <b>("setsar"</b> <b>only)</b>
           Set the aspect ratio used by the filter.

           The  parameter  can  be  a  floating  point  number string, or an expression. If the parameter is not
           specified, the value "0" is assumed, meaning that the same input value is used.

       <b>max</b> Set the maximum integer value to use for expressing  numerator  and  denominator  when  reducing  the
           expressed aspect ratio to a rational.  Default value is 100.

       The parameter <u>sar</u> is an expression containing the following constants:

       <b>w,</b> <b>h</b>
           The input width and height.

       <b>a</b>   Same as <u>w</u> / <u>h</u>.

       <b>sar</b> The input sample aspect ratio.

       <b>dar</b> The input display aspect ratio. It is the same as (<u>w</u> / <u>h</u>) * <u>sar</u>.

       <b>hsub,</b> <b>vsub</b>
           Horizontal  and vertical chroma subsample values. For example, for the pixel format "yuv422p" <u>hsub</u> is
           2 and <u>vsub</u> is 1.

       <u>Examples</u>

       •   To change the display aspect ratio to 16:9, specify one of the following:

                   setdar=dar=1.77777
                   setdar=dar=16/9

       •   To change the sample aspect ratio to 10:11, specify:

                   setsar=sar=10/11

       •   To set a display aspect ratio of 16:9, and specify a maximum integer value  of  1000  in  the  aspect
           ratio reduction, use the command:

                   setdar=ratio=16/9:max=1000

   <b>setfield</b>
       Force field for the output video frame.

       The  "setfield" filter marks the interlace type field for the output frames. It does not change the input
       frame, but only sets the corresponding property, which affects how the  frame  is  treated  by  following
       filters (e.g. "fieldorder" or "yadif").

       The filter accepts the following options:

       <b>mode</b>
           Available values are:

           <b>auto</b>
               Keep the same field property.

           <b>bff</b> Mark the frame as bottom-field-first.

           <b>tff</b> Mark the frame as top-field-first.

           <b>prog</b>
               Mark the frame as progressive.

   <b>setparams</b>
       Force frame parameter for the output video frame.

       The  "setparams"  filter  marks  interlace  and color range for the output frames. It does not change the
       input frame, but only sets the corresponding  property,  which  affects  how  the  frame  is  treated  by
       filters/encoders.

       <b>field_mode</b>
           Available values are:

           <b>auto</b>
               Keep the same field property (default).

           <b>bff</b> Mark the frame as bottom-field-first.

           <b>tff</b> Mark the frame as top-field-first.

           <b>prog</b>
               Mark the frame as progressive.

       <b>range</b>
           Available values are:

           <b>auto</b>
               Keep the same color range property (default).

           <b>unspecified,</b> <b>unknown</b>
               Mark the frame as unspecified color range.

           <b>limited,</b> <b>tv,</b> <b>mpeg</b>
               Mark the frame as limited range.

           <b>full,</b> <b>pc,</b> <b>jpeg</b>
               Mark the frame as full range.

       <b>color_primaries</b>
           Set the color primaries.  Available values are:

           <b>auto</b>
               Keep the same color primaries property (default).

           <b>bt709</b>
           <b>unknown</b>
           <b>bt470m</b>
           <b>bt470bg</b>
           <b>smpte170m</b>
           <b>smpte240m</b>
           <b>film</b>
           <b>bt2020</b>
           <b>smpte428</b>
           <b>smpte431</b>
           <b>smpte432</b>
           <b>jedec-p22</b>
       <b>color_trc</b>
           Set the color transfer.  Available values are:

           <b>auto</b>
               Keep the same color trc property (default).

           <b>bt709</b>
           <b>unknown</b>
           <b>bt470m</b>
           <b>bt470bg</b>
           <b>smpte170m</b>
           <b>smpte240m</b>
           <b>linear</b>
           <b>log100</b>
           <b>log316</b>
           <b>iec61966-2-4</b>
           <b>bt1361e</b>
           <b>iec61966-2-1</b>
           <b>bt2020-10</b>
           <b>bt2020-12</b>
           <b>smpte2084</b>
           <b>smpte428</b>
           <b>arib-std-b67</b>
       <b>colorspace</b>
           Set the colorspace.  Available values are:

           <b>auto</b>
               Keep the same colorspace property (default).

           <b>gbr</b>
           <b>bt709</b>
           <b>unknown</b>
           <b>fcc</b>
           <b>bt470bg</b>
           <b>smpte170m</b>
           <b>smpte240m</b>
           <b>ycgco</b>
           <b>bt2020nc</b>
           <b>bt2020c</b>
           <b>smpte2085</b>
           <b>chroma-derived-nc</b>
           <b>chroma-derived-c</b>
           <b>ictcp</b>
       <b>chroma_location</b>
           Set the chroma sample location.  Available values are:

           <b>auto</b>
               Keep the same chroma location (default).

           <b>unspecified,</b> <b>unknown</b>
           <b>left</b>
           <b>center</b>
           <b>topleft</b>
           <b>top</b>
           <b>bottomleft</b>
           <b>bottom</b>

   <b>sharpen_npp</b>
       Use the NVIDIA Performance Primitives (libnpp) to perform image sharpening with border control.

       The following additional options are accepted:

       <b>border_type</b>
           Type of sampling to be used ad frame borders. One of the following:

           <b>replicate</b>
               Replicate pixel values.

   <b>shear</b>
       Apply shear transform to input video.

       This filter supports the following options:

       <b>shx</b> Shear factor in X-direction. Default value is 0.  Allowed range is from -2 to 2.

       <b>shy</b> Shear factor in Y-direction. Default value is 0.  Allowed range is from -2 to 2.

       <b>fillcolor,</b> <b>c</b>
           Set  the  color  used  to  fill the output area not covered by the transformed video. For the general
           syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  If  the  special  value
           "none"  is  selected  then  no  background  is printed (useful for example if the background is never
           shown).

           Default value is "black".

       <b>interp</b>
           Set interpolation type. Can be "bilinear" or "nearest". Default is "bilinear".

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>showinfo</b>
       Show a line containing various information for each input video frame.  The input video is not modified.

       This filter supports the following options:

       <b>checksum</b>
           Calculate checksums of each plane. By default enabled.

       <b>udu_sei_as_ascii</b>
           Try to print user data unregistered SEI as ascii character when possible, in hex format otherwise.

       The shown line contains a sequence of key/value pairs of the form <u>key</u>:<u>value</u>.

       The following values are shown in the output:

       <b>n</b>   The (sequential) number of the input frame, starting from 0.

       <b>pts</b> The Presentation TimeStamp of the input frame, expressed as a number of time  base  units.  The  time
           base unit depends on the filter input pad.

       <b>pts_time</b>
           The Presentation TimeStamp of the input frame, expressed as a number of seconds.

       <b>fmt</b> The pixel format name.

       <b>sar</b> The sample aspect ratio of the input frame, expressed in the form <u>num</u>/<u>den</u>.

       <b>s</b>   The  size  of  the  input frame. For the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b>
           <b>ffmpeg-utils</b> <b>manual</b>.

       <b>i</b>   The type of interlaced mode ("P" for "progressive", "T" for top field first,  "B"  for  bottom  field
           first).

       <b>iskey</b>
           This is 1 if the frame is a key frame, 0 otherwise.

       <b>type</b>
           The picture type of the input frame ("I" for an I-frame, "P" for a P-frame, "B" for a B-frame, or "?"
           for  an  unknown  type).   Also  refer  to  the  documentation of the "AVPictureType" enum and of the
           "av_get_picture_type_char" function defined in <u>libavutil/avutil.h</u>.

       <b>checksum</b>
           The Adler-32 checksum (printed in hexadecimal) of all the planes of the input frame.

       <b>plane_checksum</b>
           The Adler-32 checksum (printed in hexadecimal) of each plane of the input  frame,  expressed  in  the
           form "[<u>c0</u> <u>c1</u> <u>c2</u> <u>c3</u>]".

       <b>mean</b>
           The  mean value of pixels in each plane of the input frame, expressed in the form "[<u>mean0</u> <u>mean1</u> <u>mean2</u>
           <u>mean3</u>]".

       <b>stdev</b>
           The standard deviation of pixel values in each plane of  the  input  frame,  expressed  in  the  form
           "[<u>stdev0</u> <u>stdev1</u> <u>stdev2</u> <u>stdev3</u>]".

   <b>showpalette</b>
       Displays the 256 colors palette of each frame. This filter is only relevant for <u>pal8</u> pixel format frames.

       It accepts the following option:

       <b>s</b>   Set the size of the box used to represent one palette color entry. Default is 30 (for a "30x30" pixel
           box).

   <b>shuffleframes</b>
       Reorder and/or duplicate and/or drop video frames.

       It accepts the following parameters:

       <b>mapping</b>
           Set  the  destination  indexes  of input frames.  This is space or '|' separated list of indexes that
           maps input frames to output frames. Number of indexes also sets maximal value  that  each  index  may
           have.  '-1' index have special meaning and that is to drop frame.

       The first frame has the index 0. The default is to keep the input unchanged.

       <u>Examples</u>

       •   Swap second and third frame of every three frames of the input:

                   ffmpeg -i INPUT -vf "shuffleframes=0 2 1" OUTPUT

       •   Swap 10th and 1st frame of every ten frames of the input:

                   ffmpeg -i INPUT -vf "shuffleframes=9 1 2 3 4 5 6 7 8 0" OUTPUT

   <b>shufflepixels</b>
       Reorder pixels in video frames.

       This filter accepts the following options:

       <b>direction,</b> <b>d</b>
           Set shuffle direction. Can be forward or inverse direction.  Default direction is forward.

       <b>mode,</b> <b>m</b>
           Set shuffle mode. Can be horizontal, vertical or block mode.

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           Set  shuffle  block_size.  In case of horizontal shuffle mode only width part of size is used, and in
           case of vertical shuffle mode only height part of size is used.

       <b>seed,</b> <b>s</b>
           Set random seed used with shuffling pixels. Mainly useful to set to  be  able  to  reverse  filtering
           process  to  get  original  input.   For  example,  to  reverse  forward shuffle you need to use same
           parameters and exact same seed and to set direction to inverse.

   <b>shuffleplanes</b>
       Reorder and/or duplicate video planes.

       It accepts the following parameters:

       <b>map0</b>
           The index of the input plane to be used as the first output plane.

       <b>map1</b>
           The index of the input plane to be used as the second output plane.

       <b>map2</b>
           The index of the input plane to be used as the third output plane.

       <b>map3</b>
           The index of the input plane to be used as the fourth output plane.

       The first plane has the index 0. The default is to keep the input unchanged.

       <u>Examples</u>

       •   Swap the second and third planes of the input:

                   ffmpeg -i INPUT -vf shuffleplanes=0:2:1:3 OUTPUT

   <b>signalstats</b>
       Evaluate various visual metrics that assist in determining issues associated  with  the  digitization  of
       analog video media.

       By default the filter will log these metadata values:

       <b>YMIN</b>
           Display the minimal Y value contained within the input frame. Expressed in range of [0-255].

       <b>YLOW</b>
           Display the Y value at the 10% percentile within the input frame. Expressed in range of [0-255].

       <b>YAVG</b>
           Display the average Y value within the input frame. Expressed in range of [0-255].

       <b>YHIGH</b>
           Display the Y value at the 90% percentile within the input frame. Expressed in range of [0-255].

       <b>YMAX</b>
           Display the maximum Y value contained within the input frame. Expressed in range of [0-255].

       <b>UMIN</b>
           Display the minimal U value contained within the input frame. Expressed in range of [0-255].

       <b>ULOW</b>
           Display the U value at the 10% percentile within the input frame. Expressed in range of [0-255].

       <b>UAVG</b>
           Display the average U value within the input frame. Expressed in range of [0-255].

       <b>UHIGH</b>
           Display the U value at the 90% percentile within the input frame. Expressed in range of [0-255].

       <b>UMAX</b>
           Display the maximum U value contained within the input frame. Expressed in range of [0-255].

       <b>VMIN</b>
           Display the minimal V value contained within the input frame. Expressed in range of [0-255].

       <b>VLOW</b>
           Display the V value at the 10% percentile within the input frame. Expressed in range of [0-255].

       <b>VAVG</b>
           Display the average V value within the input frame. Expressed in range of [0-255].

       <b>VHIGH</b>
           Display the V value at the 90% percentile within the input frame. Expressed in range of [0-255].

       <b>VMAX</b>
           Display the maximum V value contained within the input frame. Expressed in range of [0-255].

       <b>SATMIN</b>
           Display  the  minimal  saturation  value  contained  within  the  input frame.  Expressed in range of
           [0-~181.02].

       <b>SATLOW</b>
           Display the saturation value at the 10% percentile within the input frame.   Expressed  in  range  of
           [0-~181.02].

       <b>SATAVG</b>
           Display the average saturation value within the input frame. Expressed in range of [0-~181.02].

       <b>SATHIGH</b>
           Display  the  saturation  value  at the 90% percentile within the input frame.  Expressed in range of
           [0-~181.02].

       <b>SATMAX</b>
           Display the maximum saturation value contained  within  the  input  frame.   Expressed  in  range  of
           [0-~181.02].

       <b>HUEMED</b>
           Display the median value for hue within the input frame. Expressed in range of [0-360].

       <b>HUEAVG</b>
           Display the average value for hue within the input frame. Expressed in range of [0-360].

       <b>YDIF</b>
           Display the average of sample value difference between all values of the Y plane in the current frame
           and corresponding values of the previous input frame.  Expressed in range of [0-255].

       <b>UDIF</b>
           Display the average of sample value difference between all values of the U plane in the current frame
           and corresponding values of the previous input frame.  Expressed in range of [0-255].

       <b>VDIF</b>
           Display the average of sample value difference between all values of the V plane in the current frame
           and corresponding values of the previous input frame.  Expressed in range of [0-255].

       <b>YBITDEPTH</b>
           Display bit depth of Y plane in current frame.  Expressed in range of [0-16].

       <b>UBITDEPTH</b>
           Display bit depth of U plane in current frame.  Expressed in range of [0-16].

       <b>VBITDEPTH</b>
           Display bit depth of V plane in current frame.  Expressed in range of [0-16].

       The filter accepts the following options:

       <b>stat</b>
       <b>out</b> <b>stat</b> specify an additional form of image analysis.  <b>out</b> output video with the specified type of pixel
           highlighted.

           Both options accept the following values:

           <b>tout</b>
               Identify <u>temporal</u> <u>outliers</u> pixels. A <u>temporal</u> <u>outlier</u> is a pixel unlike the neighboring pixels of
               the  same field. Examples of temporal outliers include the results of video dropouts, head clogs,
               or tape tracking issues.

           <b>vrep</b>
               Identify <u>vertical</u> <u>line</u> <u>repetition</u>. Vertical line  repetition  includes  similar  rows  of  pixels
               within  a  frame.  In  born-digital video vertical line repetition is common, but this pattern is
               uncommon in video digitized from an analog source. When it occurs in video that results from  the
               digitization of an analog source it can indicate concealment from a dropout compensator.

           <b>brng</b>
               Identify pixels that fall outside of legal broadcast range.

       <b>color,</b> <b>c</b>
           Set the highlight color for the <b>out</b> option. The default color is yellow.

       <u>Examples</u>

       •   Output data of various video metrics:

                   ffprobe -f lavfi movie=example.mov,signalstats="stat=tout+vrep+brng" -show_frames

       •   Output specific data about the minimum and maximum values of the Y plane per frame:

                   ffprobe -f lavfi movie=example.mov,signalstats -show_entries frame_tags=lavfi.signalstats.YMAX,lavfi.signalstats.YMIN

       •   Playback video while highlighting pixels that are outside of broadcast range in red.

                   ffplay example.mov -vf signalstats="out=brng:color=red"

       •   Playback video with signalstats metadata drawn over the frame.

                   ffplay example.mov -vf signalstats=stat=brng+vrep+tout,drawtext=fontfile=FreeSerif.ttf:textfile=signalstat_drawtext.txt

           The contents of signalstat_drawtext.txt used in the command are:

                   time %{pts:hms}
                   Y (%{metadata:lavfi.signalstats.YMIN}-%{metadata:lavfi.signalstats.YMAX})
                   U (%{metadata:lavfi.signalstats.UMIN}-%{metadata:lavfi.signalstats.UMAX})
                   V (%{metadata:lavfi.signalstats.VMIN}-%{metadata:lavfi.signalstats.VMAX})
                   saturation maximum: %{metadata:lavfi.signalstats.SATMAX}

   <b>signature</b>
       Calculates  the  MPEG-7  Video  Signature.  The  filter  can handle more than one input. In this case the
       matching between the inputs can be calculated additionally.  The filter always passes through  the  first
       input. The signature of each stream can be written into a file.

       It accepts the following options:

       <b>detectmode</b>
           Enable or disable the matching process.

           Available values are:

           <b>off</b> Disable the calculation of a matching (default).

           <b>full</b>
               Calculate  the  matching  for  the whole video and output whether the whole video matches or only
               parts.

           <b>fast</b>
               Calculate only until a matching is found or the video ends. Should be faster in some cases.

       <b>nb_inputs</b>
           Set the number of inputs. The option value must be a non negative integer.  Default value is 1.

       <b>filename</b>
           Set the path to which the output is written. If there is more than one input,  the  path  must  be  a
           prototype,  i.e.  must contain %d or %0nd (where n is a positive integer), that will be replaced with
           the input number. If no filename is specified, no output will be written. This is the default.

       <b>format</b>
           Choose the output format.

           Available values are:

           <b>binary</b>
               Use the specified binary representation (default).

           <b>xml</b> Use the specified xml representation.

       <b>th_d</b>
           Set threshold to detect one word as similar. The option value must be an integer greater  than  zero.
           The default value is 9000.

       <b>th_dc</b>
           Set  threshold to detect all words as similar. The option value must be an integer greater than zero.
           The default value is 60000.

       <b>th_xh</b>
           Set threshold to detect frames as similar. The option value must be an integer greater than zero. The
           default value is 116.

       <b>th_di</b>
           Set the minimum length of a sequence in frames to recognize it as matching sequence. The option value
           must be a non negative integer value.  The default value is 0.

       <b>th_it</b>
           Set the minimum relation, that matching frames to all frames must have.  The option value must  be  a
           double value between 0 and 1. The default value is 0.5.

       <u>Examples</u>

       •   To calculate the signature of an input video and store it in signature.bin:

                   ffmpeg -i input.mkv -vf signature=filename=signature.bin -map 0:v -f null -

       •   To  detect  whether  two  videos  match  and store the signatures in XML format in signature0.xml and
           signature1.xml:

                   ffmpeg -i input1.mkv -i input2.mkv -filter_complex "[0:v][1:v] signature=nb_inputs=2:detectmode=full:format=xml:filename=signature%d.xml" -map :v -f null -

   <b>siti</b>
       Calculate Spatial Information (SI) and Temporal Information (TI) scores for a video, as defined in  ITU-T
       Rec.  P.910  (11/21):  Subjective video quality assessment methods for multimedia applications. Available
       PDF at &lt;<b>https://www.itu.int/rec/T-REC-P.910-202111-S/en</b>&gt;.  Note that this is a legacy implementation that
       corresponds to a superseded recommendation.  Refer to ITU-T Rec. P.910 (07/22) for  the  latest  version:
       &lt;<b>https://www.itu.int/rec/T-REC-P.910-202207-I/en</b>&gt;

       It accepts the following option:

       <b>print_summary</b>
           If set to 1, Summary statistics will be printed to the console. Default 0.

       <u>Examples</u>

       •   To calculate SI/TI metrics and print summary:

                   ffmpeg -i input.mp4 -vf siti=print_summary=1 -f null -

   <b>smartblur</b>
       Blur the input video without impacting the outlines.

       It accepts the following options:

       <b>luma_radius,</b> <b>lr</b>
           Set  the  luma  radius. The option value must be a float number in the range [0.1,5.0] that specifies
           the variance of the gaussian filter used to blur the image (slower if larger). Default value is 1.0.

       <b>luma_strength,</b> <b>ls</b>
           Set the luma strength. The option value  must  be  a  float  number  in  the  range  [-1.0,1.0]  that
           configures  the  blurring. A value included in [0.0,1.0] will blur the image whereas a value included
           in [-1.0,0.0] will sharpen the image. Default value is 1.0.

       <b>luma_threshold,</b> <b>lt</b>
           Set the luma threshold used as a coefficient to determine whether a pixel should be blurred  or  not.
           The  option value must be an integer in the range [-30,30]. A value of 0 will filter all the image, a
           value included in [0,30] will filter flat areas and a value included in [-30,0]  will  filter  edges.
           Default value is 0.

       <b>chroma_radius,</b> <b>cr</b>
           Set  the chroma radius. The option value must be a float number in the range [0.1,5.0] that specifies
           the variance of the gaussian filter used to blur the image  (slower  if  larger).  Default  value  is
           <b>luma_radius</b>.

       <b>chroma_strength,</b> <b>cs</b>
           Set  the  chroma  strength.  The  option  value  must  be a float number in the range [-1.0,1.0] that
           configures the blurring. A value included in [0.0,1.0] will blur the image whereas a  value  included
           in [-1.0,0.0] will sharpen the image. Default value is <b>luma_strength</b>.

       <b>chroma_threshold,</b> <b>ct</b>
           Set the chroma threshold used as a coefficient to determine whether a pixel should be blurred or not.
           The  option value must be an integer in the range [-30,30]. A value of 0 will filter all the image, a
           value included in [0,30] will filter flat areas and a value included in [-30,0]  will  filter  edges.
           Default value is <b>luma_threshold</b>.

       <b>alpha_radius,</b> <b>ar</b>
           Set  the  alpha radius. The option value must be a float number in the range [0.1,5.0] that specifies
           the variance of the gaussian filter used to blur the image  (slower  if  larger).  Default  value  is
           <b>luma_radius</b>.

       <b>alpha_strength,</b> <b>as</b>
           Set  the  alpha  strength.  The  option  value  must  be  a float number in the range [-1.0,1.0] that
           configures the blurring. A value included in [0.0,1.0] will blur the image whereas a  value  included
           in [-1.0,0.0] will sharpen the image. Default value is <b>luma_strength</b>.

       <b>alpha_threshold,</b> <b>at</b>
           Set  the alpha threshold used as a coefficient to determine whether a pixel should be blurred or not.
           The option value must be an integer in the range [-30,30]. A value of 0 will filter all the image,  a
           value  included  in  [0,30] will filter flat areas and a value included in [-30,0] will filter edges.
           Default value is <b>luma_threshold</b>.

       If a chroma or alpha option is not explicitly set, the corresponding luma value is set.

   <b>sobel</b>
       Apply sobel operator to input video stream.

       The filter accepts the following option:

       <b>planes</b>
           Set which planes will be processed, unprocessed planes will be copied.  By  default  value  0xf,  all
           planes will be processed.

       <b>scale</b>
           Set value which will be multiplied with filtered result.

       <b>delta</b>
           Set value which will be added to filtered result.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>spp</b>
       Apply  a  simple postprocessing filter that compresses and decompresses the image at several (or - in the
       case of <b>quality</b> level 6 - all) shifts and average the results.

       The filter accepts the following options:

       <b>quality</b>
           Set quality. This option defines the number of levels for averaging. It accepts  an  integer  in  the
           range  0-6.  If  set to 0, the filter will have no effect. A value of 6 means the higher quality. For
           each increment of that value the speed drops by a factor of approximately 2.  Default value is 3.

       <b>qp</b>  Force a constant quantization parameter. If not set, the filter will use the QP from the video stream
           (if available).

       <b>mode</b>
           Set thresholding mode. Available modes are:

           <b>hard</b>
               Set hard thresholding (default).

           <b>soft</b>
               Set soft thresholding (better de-ringing effect, but likely blurrier).

       <b>use_bframe_qp</b>
           Enable the use of the QP from the B-Frames if set to 1. Using this option may cause flicker since the
           B-Frames have often larger QP. Default is 0 (not enabled).

       <u>Commands</u>

       This filter supports the following commands:

       <b>quality,</b> <b>level</b>
           Set quality level. The value "max" can be used to set the maximum level, currently 6.

   <b>sr</b>
       Scale the input by applying one of the super-resolution methods based on convolutional  neural  networks.
       Supported models:

       •   Super-Resolution Convolutional Neural Network model (SRCNN).  See &lt;<b>https://arxiv.org/abs/1501.00092</b>&gt;.

       •   Efficient      Sub-Pixel      Convolutional      Neural      Network      model     (ESPCN).      See
           &lt;<b>https://arxiv.org/abs/1609.05158</b>&gt;.

       Training  scripts  as   well   as   scripts   for   model   file   (.pb)   saving   can   be   found   at
       &lt;<b>https://github.com/XueweiMeng/sr/tree/sr_dnn_native</b>&gt;.        Original       repository       is       at
       &lt;<b>https://github.com/HighVoltageRocknRoll/sr.git</b>&gt;.

       The filter accepts the following options:

       <b>dnn_backend</b>
           Specify which DNN backend to use for model loading and execution. This option accepts  the  following
           values:

           <b>tensorflow</b>
               TensorFlow  backend. To enable this backend you need to install the TensorFlow for C library (see
               &lt;<b>https://www.tensorflow.org/install/lang_c</b>&gt;) and configure FFmpeg with "--enable-libtensorflow"

       <b>model</b>
           Set path to model file specifying network architecture  and  its  parameters.   Note  that  different
           backends use different file formats. TensorFlow, OpenVINO backend can load files for only its format.

       <b>scale_factor</b>
           Set scale factor for SRCNN model. Allowed values are 2, 3 and 4.  Default value is 2. Scale factor is
           necessary  for  SRCNN  model,  because  it accepts input upscaled using bicubic upscaling with proper
           scale factor.

       To get full functionality (such as async execution), please use the <b>dnn_processing</b> filter.

   <b>ssim</b>
       Obtain the SSIM (Structural SImilarity Metric) between two input videos.

       This filter takes in input two input videos, the first input is  considered  the  "main"  source  and  is
       passed unchanged to the output. The second input is used as a "reference" video for computing the SSIM.

       Both  video inputs must have the same resolution and pixel format for this filter to work correctly. Also
       it assumes that both inputs have the same number of frames, which are compared one by one.

       The filter stores the calculated SSIM of each frame.

       The description of the accepted parameters follows.

       <b>stats_file,</b> <b>f</b>
           If specified the filter will use the named file to save the  SSIM  of  each  individual  frame.  When
           filename equals "-" the data is sent to standard output.

       The  file printed if <u>stats_file</u> is selected, contains a sequence of key/value pairs of the form <u>key</u>:<u>value</u>
       for each compared couple of frames.

       A description of each shown parameter follows:

       <b>n</b>   sequential number of the input frame, starting from 1

       <b>Y,</b> <b>U,</b> <b>V,</b> <b>R,</b> <b>G,</b> <b>B</b>
           SSIM of the compared frames for the component specified by the suffix.

       <b>All</b> SSIM of the compared frames for the whole frame.

       <b>dB</b>  Same as above but in dB representation.

       This filter also supports the <b>framesync</b> options.

       <u>Examples</u>

       •   For example:

                   movie=ref_movie.mpg, setpts=PTS-STARTPTS [main];
                   [main][ref] ssim="stats_file=stats.log" [out]

           On this example the input file being processed is compared with the reference file <u>ref_movie.mpg</u>. The
           SSIM of each individual frame is stored in <u>stats.log</u>.

       •   Another example with both psnr and ssim at same time:

                   ffmpeg -i main.mpg -i ref.mpg -lavfi  "ssim;[0:v][1:v]psnr" -f null -

       •   Another example with different containers:

                   ffmpeg -i main.mpg -i ref.mkv -lavfi  "[0:v]settb=AVTB,setpts=PTS-STARTPTS[main];[1:v]settb=AVTB,setpts=PTS-STARTPTS[ref];[main][ref]ssim" -f null -

   <b>stereo3d</b>
       Convert between different stereoscopic image formats.

       The filters accept the following options:

       <b>in</b>  Set stereoscopic image format of input.

           Available values for input image formats are:

           <b>sbsl</b>
               side by side parallel (left eye left, right eye right)

           <b>sbsr</b>
               side by side crosseye (right eye left, left eye right)

           <b>sbs2l</b>
               side by side parallel with half width resolution (left eye left, right eye right)

           <b>sbs2r</b>
               side by side crosseye with half width resolution (right eye left, left eye right)

           <b>abl</b>
           <b>tbl</b> above-below (left eye above, right eye below)

           <b>abr</b>
           <b>tbr</b> above-below (right eye above, left eye below)

           <b>ab2l</b>
           <b>tb2l</b>
               above-below with half height resolution (left eye above, right eye below)

           <b>ab2r</b>
           <b>tb2r</b>
               above-below with half height resolution (right eye above, left eye below)

           <b>al</b>  alternating frames (left eye first, right eye second)

           <b>ar</b>  alternating frames (right eye first, left eye second)

           <b>irl</b> interleaved rows (left eye has top row, right eye starts on next row)

           <b>irr</b> interleaved rows (right eye has top row, left eye starts on next row)

           <b>icl</b> interleaved columns, left eye first

           <b>icr</b> interleaved columns, right eye first

               Default value is <b>sbsl</b>.

       <b>out</b> Set stereoscopic image format of output.

           <b>sbsl</b>
               side by side parallel (left eye left, right eye right)

           <b>sbsr</b>
               side by side crosseye (right eye left, left eye right)

           <b>sbs2l</b>
               side by side parallel with half width resolution (left eye left, right eye right)

           <b>sbs2r</b>
               side by side crosseye with half width resolution (right eye left, left eye right)

           <b>abl</b>
           <b>tbl</b> above-below (left eye above, right eye below)

           <b>abr</b>
           <b>tbr</b> above-below (right eye above, left eye below)

           <b>ab2l</b>
           <b>tb2l</b>
               above-below with half height resolution (left eye above, right eye below)

           <b>ab2r</b>
           <b>tb2r</b>
               above-below with half height resolution (right eye above, left eye below)

           <b>al</b>  alternating frames (left eye first, right eye second)

           <b>ar</b>  alternating frames (right eye first, left eye second)

           <b>irl</b> interleaved rows (left eye has top row, right eye starts on next row)

           <b>irr</b> interleaved rows (right eye has top row, left eye starts on next row)

           <b>arbg</b>
               anaglyph red/blue gray (red filter on left eye, blue filter on right eye)

           <b>argg</b>
               anaglyph red/green gray (red filter on left eye, green filter on right eye)

           <b>arcg</b>
               anaglyph red/cyan gray (red filter on left eye, cyan filter on right eye)

           <b>arch</b>
               anaglyph red/cyan half colored (red filter on left eye, cyan filter on right eye)

           <b>arcc</b>
               anaglyph red/cyan color (red filter on left eye, cyan filter on right eye)

           <b>arcd</b>
               anaglyph red/cyan color optimized with the least squares projection of dubois (red filter on left
               eye, cyan filter on right eye)

           <b>agmg</b>
               anaglyph green/magenta gray (green filter on left eye, magenta filter on right eye)

           <b>agmh</b>
               anaglyph green/magenta half colored (green filter on left eye, magenta filter on right eye)

           <b>agmc</b>
               anaglyph green/magenta colored (green filter on left eye, magenta filter on right eye)

           <b>agmd</b>
               anaglyph green/magenta color optimized with the least squares projection of dubois (green  filter
               on left eye, magenta filter on right eye)

           <b>aybg</b>
               anaglyph yellow/blue gray (yellow filter on left eye, blue filter on right eye)

           <b>aybh</b>
               anaglyph yellow/blue half colored (yellow filter on left eye, blue filter on right eye)

           <b>aybc</b>
               anaglyph yellow/blue colored (yellow filter on left eye, blue filter on right eye)

           <b>aybd</b>
               anaglyph  yellow/blue  color optimized with the least squares projection of dubois (yellow filter
               on left eye, blue filter on right eye)

           <b>ml</b>  mono output (left eye only)

           <b>mr</b>  mono output (right eye only)

           <b>chl</b> checkerboard, left eye first

           <b>chr</b> checkerboard, right eye first

           <b>icl</b> interleaved columns, left eye first

           <b>icr</b> interleaved columns, right eye first

           <b>hdmi</b>
               HDMI frame pack

           Default value is <b>arcd</b>.

       <u>Examples</u>

       •   Convert input video from side by side parallel to anaglyph yellow/blue dubois:

                   stereo3d=sbsl:aybd

       •   Convert input video from above below (left eye above, right eye below) to side by side crosseye.

                   stereo3d=abl:sbsr

   <b>streamselect,</b> <b>astreamselect</b>
       Select video or audio streams.

       The filter accepts the following options:

       <b>inputs</b>
           Set number of inputs. Default is 2.

       <b>map</b> Set input indexes to remap to outputs.

       <u>Commands</u>

       The "streamselect" and "astreamselect" filter supports the following commands:

       <b>map</b> Set input indexes to remap to outputs.

       <u>Examples</u>

       •   Select first 5 seconds 1st stream and rest of time 2nd stream:

                   sendcmd='5.0 streamselect map 1',streamselect=inputs=2:map=0

       •   Same as above, but for audio:

                   asendcmd='5.0 astreamselect map 1',astreamselect=inputs=2:map=0

   <b>subtitles</b>
       Draw subtitles on top of input video using the libass library.

       To enable compilation of this filter you need to configure FFmpeg  with  "--enable-libass".  This  filter
       also  requires  a  build  with  libavcodec  and  libavformat  to convert the passed subtitles file to ASS
       (Advanced Substation Alpha) subtitles format.

       The filter accepts the following options:

       <b>filename,</b> <b>f</b>
           Set the filename of the subtitle file to read. It must be specified.

       <b>original_size</b>
           Specify the size of the original video, the video for which the ASS file was composed. For the syntax
           of this option, check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Due to a misdesign in ASS
           aspect ratio arithmetic, this is necessary to correctly scale the fonts if the aspect ratio has  been
           changed.

       <b>fontsdir</b>
           Set  a  directory  path containing fonts that can be used by the filter.  These fonts will be used in
           addition to whatever the font provider uses.

       <b>alpha</b>
           Process alpha channel, by default alpha channel is untouched.

       <b>charenc</b>
           Set subtitles input character encoding. "subtitles" filter only. Only useful if not UTF-8.

       <b>stream_index,</b> <b>si</b>
           Set subtitles stream index. "subtitles" filter only.

       <b>force_style</b>
           Override default style or script info parameters of the subtitles. It accepts a string containing ASS
           style format "KEY=VALUE" couples separated by ",".

       <b>wrap_unicode</b>
           Break lines according to the Unicode Line Breaking Algorithm. Availability requires at  least  libass
           release 0.17.0 (or LIBASS_VERSION 0x01600010), <u>and</u> libass must have been built with libunibreak.

           The option is enabled by default except for native ASS.

       If the first key is not specified, it is assumed that the first value specifies the <b>filename</b>.

       For example, to render the file <u>sub.srt</u> on top of the input video, use the command:

               subtitles=sub.srt

       which is equivalent to:

               subtitles=filename=sub.srt

       To render the default subtitles stream from file <u>video.mkv</u>, use:

               subtitles=video.mkv

       To render the second subtitles stream from that file, use:

               subtitles=video.mkv:si=1

       To make the subtitles stream from <u>sub.srt</u> appear in 80% transparent blue "DejaVu Serif", use:

               subtitles=sub.srt:force_style='Fontname=DejaVu Serif,PrimaryColour=&amp;HCCFF0000'

   <b>super2xsai</b>
       Scale  the  input  by  2x  and  smooth  using  the  Super2xSaI  (Scale and Interpolate) pixel art scaling
       algorithm.

       Useful for enlarging pixel art images without reducing sharpness.

   <b>swaprect</b>
       Swap two rectangular objects in video.

       This filter accepts the following options:

       <b>w</b>   Set object width.

       <b>h</b>   Set object height.

       <b>x1</b>  Set 1st rect x coordinate.

       <b>y1</b>  Set 1st rect y coordinate.

       <b>x2</b>  Set 2nd rect x coordinate.

       <b>y2</b>  Set 2nd rect y coordinate.

           All expressions are evaluated once for each frame.

       The all options are expressions containing the following constants:

       <b>w</b>
       <b>h</b>   The input width and height.

       <b>a</b>   same as <u>w</u> / <u>h</u>

       <b>sar</b> input sample aspect ratio

       <b>dar</b> input display aspect ratio, it is the same as (<u>w</u> / <u>h</u>) * <u>sar</u>

       <b>n</b>   The number of the input frame, starting from 0.

       <b>t</b>   The timestamp expressed in seconds. It's NAN if the input timestamp is unknown.

       <b>pos</b> the position in the file of the input frame, NAN if unknown; deprecated, do not use

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>swapuv</b>
       Swap U &amp; V plane.

   <b>tblend</b>
       Blend successive video frames.

       See <b>blend</b>

   <b>telecine</b>
       Apply telecine process to the video.

       This filter accepts the following options:

       <b>first_field</b>
           <b>top,</b> <b>t</b>
               top field first

           <b>bottom,</b> <b>b</b>
               bottom field first The default value is "top".

       <b>pattern</b>
           A string of numbers representing the pulldown pattern you wish to apply.  The default value is 23.

               Some typical patterns:

               NTSC output (30i):
               27.5p: 32222
               24p: 23 (classic)
               24p: 2332 (preferred)
               20p: 33
               18p: 334
               16p: 3444

               PAL output (25i):
               27.5p: 12222
               24p: 222222222223 ("Euro pulldown")
               16.67p: 33
               16p: 33333334

   <b>thistogram</b>
       Compute and draw a color distribution histogram for the input video across time.

       Unlike <b>histogram</b> video filter which only shows histogram of single input  frame  at  certain  time,  this
       filter shows also past histograms of number of frames defined by "width" option.

       The computed histogram is a representation of the color component distribution in an image.

       The filter accepts the following options:

       <b>width,</b> <b>w</b>
           Set  width  of  single  color  component  output. Default value is 0.  Value of 0 means width will be
           picked from input video.  This also set number of passed histograms to keep.  Allowed  range  is  [0,
           8192].

       <b>display_mode,</b> <b>d</b>
           Set display mode.  It accepts the following values:

           <b>stack</b>
               Per color component graphs are placed below each other.

           <b>parade</b>
               Per color component graphs are placed side by side.

           <b>overlay</b>
               Presents information identical to that in the "parade", except that the graphs representing color
               components are superimposed directly over one another.

           Default is "stack".

       <b>levels_mode,</b> <b>m</b>
           Set mode. Can be either "linear", or "logarithmic".  Default is "linear".

       <b>components,</b> <b>c</b>
           Set what color components to display.  Default is 7.

       <b>bgopacity,</b> <b>b</b>
           Set background opacity. Default is 0.9.

       <b>envelope,</b> <b>e</b>
           Show envelope. Default is disabled.

       <b>ecolor,</b> <b>ec</b>
           Set envelope color. Default is "gold".

       <b>slide</b>
           Set slide mode.

           Available values for slide is:

           <b>frame</b>
               Draw new frame when right border is reached.

           <b>replace</b>
               Replace old columns with new ones.

           <b>scroll</b>
               Scroll from right to left.

           <b>rscroll</b>
               Scroll from left to right.

           <b>picture</b>
               Draw single picture.

           Default is "replace".

   <b>threshold</b>
       Apply threshold effect to video stream.

       This  filter  needs four video streams to perform thresholding.  First stream is stream we are filtering.
       Second stream is holding threshold values, third stream is holding min values, and last, fourth stream is
       holding max values.

       The filter accepts the following option:

       <b>planes</b>
           Set which planes will be processed, unprocessed planes will be copied.  By  default  value  0xf,  all
           planes will be processed.

       For  example if first stream pixel's component value is less then threshold value of pixel component from
       2nd threshold stream, third stream value will picked, otherwise fourth stream pixel component value  will
       be picked.

       Using color source filter one can perform various types of thresholding:

       <u>Commands</u>

       This filter supports the all options as <b>commands</b>.

       <u>Examples</u>

       •   Binary threshold, using gray color as threshold:

                   ffmpeg -i 320x240.avi -f lavfi -i color=gray -f lavfi -i color=black -f lavfi -i color=white -lavfi threshold output.avi

       •   Inverted binary threshold, using gray color as threshold:

                   ffmpeg -i 320x240.avi -f lavfi -i color=gray -f lavfi -i color=white -f lavfi -i color=black -lavfi threshold output.avi

       •   Truncate binary threshold, using gray color as threshold:

                   ffmpeg -i 320x240.avi -f lavfi -i color=gray -i 320x240.avi -f lavfi -i color=gray -lavfi threshold output.avi

       •   Threshold to zero, using gray color as threshold:

                   ffmpeg -i 320x240.avi -f lavfi -i color=gray -f lavfi -i color=white -i 320x240.avi -lavfi threshold output.avi

       •   Inverted threshold to zero, using gray color as threshold:

                   ffmpeg -i 320x240.avi -f lavfi -i color=gray -i 320x240.avi -f lavfi -i color=white -lavfi threshold output.avi

   <b>thumbnail</b>
       Select the most representative frame in a given sequence of consecutive frames.

       The filter accepts the following options:

       <b>n</b>   Set  the  frames  batch  size to analyze; in a set of <u>n</u> frames, the filter will pick one of them, and
           then handle the next batch of <u>n</u> frames until the end. Default is 100.

       <b>log</b> Set the log level to display picked frame stats.  Default is "info".

       Since the filter keeps track of the whole frames sequence, a bigger <u>n</u>  value  will  result  in  a  higher
       memory usage, so a high value is not recommended.

       <u>Examples</u>

       •   Extract one picture each 50 frames:

                   thumbnail=50

       •   Complete example of a thumbnail creation with <b>ffmpeg</b>:

                   ffmpeg -i in.avi -vf thumbnail,scale=300:200 -frames:v 1 out.png

   <b>tile</b>
       Tile several successive frames together.

       The <b>untile</b> filter can do the reverse.

       The filter accepts the following options:

       <b>layout</b>
           Set the grid size in the form "COLUMNSxROWS". Range is up to UINT_MAX cells.  Default is "6x5".

       <b>nb_frames</b>
           Set  the  maximum number of frames to render in the given area. It must be less than or equal to <u>w</u>x<u>h</u>.
           The default value is 0, meaning all the area will be used.

       <b>margin</b>
           Set the outer border margin in pixels. Range is 0 to 1024. Default is 0.

       <b>padding</b>
           Set the inner border thickness (i.e. the number of pixels between frames). For more advanced  padding
           options (such as having different values for the edges), refer to the pad video filter. Range is 0 to
           1024. Default is 0.

       <b>color</b>
           Specify the color of the unused area. For the syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b>
           <b>ffmpeg-utils</b> <b>manual</b>.  The default value of <u>color</u> is "black".

       <b>overlap</b>
           Set  the  number of frames to overlap when tiling several successive frames together.  The value must
           be between 0 and <u>nb_frames</u> <u>-</u> <u>1</u>. Default is 0.

       <b>init_padding</b>
           Set the number of frames to initially be empty before displaying first output frame.   This  controls
           how  soon will one get first output frame.  The value must be between 0 and <u>nb_frames</u> <u>-</u> <u>1</u>. Default is
           0.

       <u>Examples</u>

       •   Produce 8x8 PNG tiles of all keyframes (<b>-skip_frame</b> <b>nokey</b>) in a movie:

                   ffmpeg -skip_frame nokey -i file.avi -vf 'scale=128:72,tile=8x8' -an -vsync 0 keyframes%03d.png

           The <b>-vsync</b> <b>0</b> is necessary to prevent <b>ffmpeg</b> from duplicating each output  frame  to  accommodate  the
           originally detected frame rate.

       •   Display  5  pictures  in an area of "3x2" frames, with 7 pixels between them, and 2 pixels of initial
           margin, using mixed flat and named options:

                   tile=3x2:nb_frames=5:padding=7:margin=2

   <b>tiltandshift</b>
       Apply tilt-and-shift effect.

       What happens when you invert time and space?

       Normally a video is composed of several frames that represent a different instant of  time  and  shows  a
       scene  that  evolves  in  the  space  captured by the frame. This filter is the antipode of that concept,
       taking inspiration from tilt and shift photography.

       A filtered frame contains the whole timeline of events composing the sequence, and this  is  obtained  by
       placing  a  slice of pixels from each frame into a single one. However, since there are no infinite-width
       frames, this is done up the width of the input frame, and a video is  recomposed  by  shifting  away  one
       column  for  each  subsequent  frame. In order to map space to time, the filter tilts each input frame as
       well, so that motion is preserved. This is accomplished by progressively  selecting  a  different  column
       from each input frame.

       The end result is a sort of inverted parallax, so that far away objects move much faster that the ones in
       the front. The ideal conditions for this video effect are when there is either very little motion and the
       backgroud is static, or when there is a lot of motion and a very wide depth of field (e.g. wide panorama,
       while moving on a train).

       The filter accepts the following parameters:

       <b>tilt</b>
           Tilt  video  while  shifting (default). When unset, video will be sliding a static image, composed of
           the first column of each frame.

       <b>start</b>
           What to do at the start of filtering (see below).

       <b>end</b> What to do at the end of filtering (see below).

       <b>hold</b>
           How many columns should pass through before start of filtering.

       <b>pad</b> How many columns should be inserted before end of filtering.

       Normally the filter shifts and tilts from the very first frame, and stops when the last one is  received.
       However,  before  filtering starts, normal video may be preseved, so that the effect is slowly shifted in
       its place. Similarly, the last video frame may be reconstructed at the end. Alternatively it is  possible
       to just start and end with black.

       <b>none</b>
           Filtering starts immediately and ends when the last frame is received.

       <b>frame</b>
           The first frames or the very last frame are kept intact during processing.

       <b>black</b>
           Black is padded at the beginning or at the end of filtering.

   <b>tinterlace</b>
       Perform various types of temporal field interlacing.

       Frames are counted starting from 1, so the first input frame is considered odd.

       The filter accepts the following options:

       <b>mode</b>
           Specify  the  mode  of the interlacing. This option can also be specified as a value alone. See below
           for a list of values for this option.

           Available values are:

           <b>merge,</b> <b>0</b>
               Move odd frames into the upper field, even into the lower field, generating a double height frame
               at half frame rate.

                        ------&gt; time
                       Input:
                       Frame 1         Frame 2         Frame 3         Frame 4

                       11111           22222           33333           44444
                       11111           22222           33333           44444
                       11111           22222           33333           44444
                       11111           22222           33333           44444

                       Output:
                       11111                           33333
                       22222                           44444
                       11111                           33333
                       22222                           44444
                       11111                           33333
                       22222                           44444
                       11111                           33333
                       22222                           44444

           <b>drop_even,</b> <b>1</b>
               Only output odd frames, even frames are dropped, generating a frame with unchanged height at half
               frame rate.

                        ------&gt; time
                       Input:
                       Frame 1         Frame 2         Frame 3         Frame 4

                       11111           22222           33333           44444
                       11111           22222           33333           44444
                       11111           22222           33333           44444
                       11111           22222           33333           44444

                       Output:
                       11111                           33333
                       11111                           33333
                       11111                           33333
                       11111                           33333

           <b>drop_odd,</b> <b>2</b>
               Only output even frames, odd frames are dropped, generating a frame with unchanged height at half
               frame rate.

                        ------&gt; time
                       Input:
                       Frame 1         Frame 2         Frame 3         Frame 4

                       11111           22222           33333           44444
                       11111           22222           33333           44444
                       11111           22222           33333           44444
                       11111           22222           33333           44444

                       Output:
                                       22222                           44444
                                       22222                           44444
                                       22222                           44444
                                       22222                           44444

           <b>pad,</b> <b>3</b>
               Expand each frame to full height, but pad alternate lines with black,  generating  a  frame  with
               double height at the same input frame rate.

                        ------&gt; time
                       Input:
                       Frame 1         Frame 2         Frame 3         Frame 4

                       11111           22222           33333           44444
                       11111           22222           33333           44444
                       11111           22222           33333           44444
                       11111           22222           33333           44444

                       Output:
                       11111           .....           33333           .....
                       .....           22222           .....           44444
                       11111           .....           33333           .....
                       .....           22222           .....           44444
                       11111           .....           33333           .....
                       .....           22222           .....           44444
                       11111           .....           33333           .....
                       .....           22222           .....           44444

           <b>interleave_top,</b> <b>4</b>
               Interleave  the  upper  field from odd frames with the lower field from even frames, generating a
               frame with unchanged height at half frame rate.

                        ------&gt; time
                       Input:
                       Frame 1         Frame 2         Frame 3         Frame 4

                       11111&lt;-         22222           33333&lt;-         44444
                       11111           22222&lt;-         33333           44444&lt;-
                       11111&lt;-         22222           33333&lt;-         44444
                       11111           22222&lt;-         33333           44444&lt;-

                       Output:
                       11111                           33333
                       22222                           44444
                       11111                           33333
                       22222                           44444

           <b>interleave_bottom,</b> <b>5</b>
               Interleave the lower field from odd frames with the upper field from even  frames,  generating  a
               frame with unchanged height at half frame rate.

                        ------&gt; time
                       Input:
                       Frame 1         Frame 2         Frame 3         Frame 4

                       11111           22222&lt;-         33333           44444&lt;-
                       11111&lt;-         22222           33333&lt;-         44444
                       11111           22222&lt;-         33333           44444&lt;-
                       11111&lt;-         22222           33333&lt;-         44444

                       Output:
                       22222                           44444
                       11111                           33333
                       22222                           44444
                       11111                           33333

           <b>interlacex2,</b> <b>6</b>
               Double  frame rate with unchanged height. Frames are inserted each containing the second temporal
               field from the previous input frame and the first temporal field from the next input frame.  This
               mode  relies  on  the  top_field_first  flag.  Useful for interlaced video displays with no field
               synchronisation.

                        ------&gt; time
                       Input:
                       Frame 1         Frame 2         Frame 3         Frame 4

                       11111           22222           33333           44444
                        11111           22222           33333           44444
                       11111           22222           33333           44444
                        11111           22222           33333           44444

                       Output:
                       11111   22222   22222   33333   33333   44444   44444
                        11111   11111   22222   22222   33333   33333   44444
                       11111   22222   22222   33333   33333   44444   44444
                        11111   11111   22222   22222   33333   33333   44444

           <b>mergex2,</b> <b>7</b>
               Move odd frames into the upper field, even into the lower field, generating a double height frame
               at same frame rate.

                        ------&gt; time
                       Input:
                       Frame 1         Frame 2         Frame 3         Frame 4

                       11111           22222           33333           44444
                       11111           22222           33333           44444
                       11111           22222           33333           44444
                       11111           22222           33333           44444

                       Output:
                       11111           33333           33333           55555
                       22222           22222           44444           44444
                       11111           33333           33333           55555
                       22222           22222           44444           44444
                       11111           33333           33333           55555
                       22222           22222           44444           44444
                       11111           33333           33333           55555
                       22222           22222           44444           44444

           Numeric values are deprecated but are accepted for backward compatibility reasons.

           Default mode is "merge".

       <b>flags</b>
           Specify flags influencing the filter process.

           Available value for <u>flags</u> is:

           <b>low_pass_filter,</b> <b>vlpf</b>
               Enable linear vertical low-pass filtering in the filter.  Vertical low-pass filtering is required
               when creating an interlaced destination from a progressive source which  contains  high-frequency
               vertical detail. Filtering will reduce interlace 'twitter' and Moire patterning.

           <b>complex_filter,</b> <b>cvlpf</b>
               Enable  complex  vertical low-pass filtering.  This will slightly less reduce interlace 'twitter'
               and Moire patterning but better retain detail and subjective sharpness impression.

           <b>bypass_il</b>
               Bypass already interlaced frames, only adjust the frame rate.

           Vertical low-pass filtering and bypassing already interlaced frames can  only  be  enabled  for  <b>mode</b>
           <u>interleave_top</u> and <u>interleave_bottom</u>.

   <b>tmedian</b>
       Pick median pixels from several successive input video frames.

       The filter accepts the following options:

       <b>radius</b>
           Set radius of median filter.  Default is 1. Allowed range is from 1 to 127.

       <b>planes</b>
           Set which planes to filter. Default value is 15, by which all planes are processed.

       <b>percentile</b>
           Set  median  percentile.  Default value is 0.5.  Default value of 0.5 will pick always median values,
           while 0 will pick minimum values, and 1 maximum values.

       <u>Commands</u>

       This filter supports all above options as <b>commands</b>, excluding option "radius".

   <b>tmidequalizer</b>
       Apply Temporal Midway Video Equalization effect.

       Midway Video Equalization adjusts a  sequence  of  video  frames  to  have  the  same  histograms,  while
       maintaining  their  dynamics  as  much  as possible. It's useful for e.g. matching exposures from a video
       frames sequence.

       This filter accepts the following option:

       <b>radius</b>
           Set filtering radius. Default is 5. Allowed range is from 1 to 127.

       <b>sigma</b>
           Set filtering sigma. Default is 0.5. This controls strength of filtering.  Setting this option  to  0
           effectively does nothing.

       <b>planes</b>
           Set which planes to process. Default is 15, which is all available planes.

   <b>tmix</b>
       Mix successive video frames.

       A description of the accepted options follows.

       <b>frames</b>
           The number of successive frames to mix. If unspecified, it defaults to 3.

       <b>weights</b>
           Specify weight of each input video frame.  Each weight is separated by space. If number of weights is
           smaller than number of <u>frames</u> last specified weight will be used for all remaining unset weights.

       <b>scale</b>
           Specify  scale,  if  it  is  set  it will be multiplied with sum of each weight multiplied with pixel
           values to give final destination pixel value. By default <u>scale</u> is auto scaled to sum of weights.

       <b>planes</b>
           Set which planes to filter. Default is all. Allowed range is from 0 to 15.

       <u>Examples</u>

       •   Average 7 successive frames:

                   tmix=frames=7:weights="1 1 1 1 1 1 1"

       •   Apply simple temporal convolution:

                   tmix=frames=3:weights="-1 3 -1"

       •   Similar as above but only showing temporal differences:

                   tmix=frames=3:weights="-1 2 -1":scale=1

       <u>Commands</u>

       This filter supports the following commands:

       <b>weights</b>
       <b>scale</b>
       <b>planes</b>
           Syntax is same as option with same name.

   <b>tonemap</b>
       Tone map colors from different dynamic ranges.

       This filter expects data in single precision floating point, as it needs to operate on (and  can  output)
       out-of-range values. Another filter, such as <b>zscale</b>, is needed to convert the resulting frame to a usable
       format.

       The  tonemapping  algorithms  implemented  only  work on linear light, so input data should be linearized
       beforehand (and possibly correctly tagged).

               ffmpeg -i INPUT -vf zscale=transfer=linear,tonemap=clip,zscale=transfer=bt709,format=yuv420p OUTPUT

       <u>Options</u>

       The filter accepts the following options.

       <b>tonemap</b>
           Set the tone map algorithm to use.

           Possible values are:

           <u>none</u>
               Do not apply any tone map, only desaturate overbright pixels.

           <u>clip</u>
               Hard-clip any out-of-range values. Use it for perfect color accuracy for in-range  values,  while
               distorting out-of-range values.

           <u>linear</u>
               Stretch the entire reference gamut to a linear multiple of the display.

           <u>gamma</u>
               Fit a logarithmic transfer between the tone curves.

           <u>reinhard</u>
               Preserve overall image brightness with a simple curve, using nonlinear contrast, which results in
               flattening details and degrading color accuracy.

           <u>hable</u>
               Preserve  both  dark  and  bright details better than <u>reinhard</u>, at the cost of slightly darkening
               everything. Use it when detail preservation is more important than color and brightness accuracy.

           <u>mobius</u>
               Smoothly map out-of-range values, while retaining contrast and colors for  in-range  material  as
               much as possible. Use it when color accuracy is more important than detail preservation.

           Default is none.

       <b>param</b>
           Tune the tone mapping algorithm.

           This affects the following algorithms:

           <u>none</u>
               Ignored.

           <u>linear</u>
               Specifies the scale factor to use while stretching.  Default to 1.0.

           <u>gamma</u>
               Specifies the exponent of the function.  Default to 1.8.

           <u>clip</u>
               Specify an extra linear coefficient to multiply into the signal before clipping.  Default to 1.0.

           <u>reinhard</u>
               Specify the local contrast coefficient at the display peak.  Default to 0.5, which means that in-
               gamut values will be about half as bright as when clipping.

           <u>hable</u>
               Ignored.

           <u>mobius</u>
               Specify  the  transition  point  from linear to mobius transform. Every value below this point is
               guaranteed to be mapped 1:1. The higher the value, the more accurate the result will be,  at  the
               cost  of  losing  bright  details.   Default  to  0.3, which due to the steep initial slope still
               preserves in-range colors fairly accurately.

       <b>desat</b>
           Apply desaturation for highlights that exceed this level of brightness. The higher the parameter, the
           more color information will be preserved. This setting helps prevent unnaturally blown-out colors for
           super-highlights, by (smoothly) turning into white instead. This makes images feel more  natural,  at
           the cost of reducing information about out-of-range colors.

           The  default  of  2.0 is somewhat conservative and will mostly just apply to skies or directly sunlit
           surfaces. A setting of 0.0 disables this option.

           This option works only if the input frame has a supported color tag.

       <b>peak</b>
           Override signal/nominal/reference peak with this value. Useful when the embedded peak information  in
           display metadata is not reliable or when tone mapping from a lower range to a higher range.

   <b>tpad</b>
       Temporarily pad video frames.

       The filter accepts the following options:

       <b>start</b>
           Specify number of delay frames before input video stream. Default is 0.

       <b>stop</b>
           Specify number of padding frames after input video stream.  Set to -1 to pad indefinitely. Default is
           0.

       <b>start_mode</b>
           Set  kind  of  frames  added to beginning of stream.  Can be either <u>add</u> or <u>clone</u>.  With <u>add</u> frames of
           solid-color are added.  With <u>clone</u> frames are clones of first frame.  Default is <u>add</u>.

       <b>stop_mode</b>
           Set kind of frames added to end of stream.  Can be either <u>add</u> or <u>clone</u>.  With <u>add</u>  frames  of  solid-
           color are added.  With <u>clone</u> frames are clones of last frame.  Default is <u>add</u>.

       <b>start_duration,</b> <b>stop_duration</b>
           Specify  the  duration  of the start/stop delay. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b> for the accepted syntax.  These options override <u>start</u> and <u>stop</u>. Default is 0.

       <b>color</b>
           Specify the color of the padded area. For the syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b>
           <b>ffmpeg-utils</b> <b>manual</b>.

           The default value of <u>color</u> is "black".

   <b>transpose</b>
       Transpose rows with columns in the input video and optionally flip it.

       It accepts the following parameters:

       <b>dir</b> Specify the transposition direction.

           Can assume the following values:

           <b>0,</b> <b>4,</b> <b>cclock_flip</b>
               Rotate by 90 degrees counterclockwise and vertically flip (default), that is:

                       L.R     L.l
                       . . -&gt;  . .
                       l.r     R.r

           <b>1,</b> <b>5,</b> <b>clock</b>
               Rotate by 90 degrees clockwise, that is:

                       L.R     l.L
                       . . -&gt;  . .
                       l.r     r.R

           <b>2,</b> <b>6,</b> <b>cclock</b>
               Rotate by 90 degrees counterclockwise, that is:

                       L.R     R.r
                       . . -&gt;  . .
                       l.r     L.l

           <b>3,</b> <b>7,</b> <b>clock_flip</b>
               Rotate by 90 degrees clockwise and vertically flip, that is:

                       L.R     r.R
                       . . -&gt;  . .
                       l.r     l.L

           For values between 4-7, the transposition is only done if the input video geometry  is  portrait  and
           not landscape. These values are deprecated, the "passthrough" option should be used instead.

           Numerical values are deprecated, and should be dropped in favor of symbolic constants.

       <b>passthrough</b>
           Do  not  apply  the  transposition  if  the input geometry matches the one specified by the specified
           value. It accepts the following values:

           <b>none</b>
               Always apply transposition.

           <b>portrait</b>
               Preserve portrait geometry (when <u>height</u> &gt;= <u>width</u>).

           <b>landscape</b>
               Preserve landscape geometry (when <u>width</u> &gt;= <u>height</u>).

           Default value is "none".

       For example to rotate by 90 degrees clockwise and preserve portrait layout:

               transpose=dir=1:passthrough=portrait

       The command above can also be specified as:

               transpose=1:portrait

   <b>transpose_npp</b>
       Transpose rows with columns in the input video and optionally flip it.  For more in  depth  examples  see
       the <b>transpose</b> video filter, which shares mostly the same options.

       It accepts the following parameters:

       <b>dir</b> Specify the transposition direction.

           Can assume the following values:

           <b>cclock_flip</b>
               Rotate by 90 degrees counterclockwise and vertically flip. (default)

           <b>clock</b>
               Rotate by 90 degrees clockwise.

           <b>cclock</b>
               Rotate by 90 degrees counterclockwise.

           <b>clock_flip</b>
               Rotate by 90 degrees clockwise and vertically flip.

       <b>passthrough</b>
           Do  not  apply  the  transposition  if  the input geometry matches the one specified by the specified
           value. It accepts the following values:

           <b>none</b>
               Always apply transposition. (default)

           <b>portrait</b>
               Preserve portrait geometry (when <u>height</u> &gt;= <u>width</u>).

           <b>landscape</b>
               Preserve landscape geometry (when <u>width</u> &gt;= <u>height</u>).

   <b>trim</b>
       Trim the input so that the output contains one continuous subpart of the input.

       It accepts the following parameters:

       <b>start</b>
           Specify the time of the start of the kept section, i.e. the frame with the timestamp  <u>start</u>  will  be
           the first frame in the output.

       <b>end</b> Specify  the  time  of the first frame that will be dropped, i.e. the frame immediately preceding the
           one with the timestamp <u>end</u> will be the last frame in the output.

       <b>start_pts</b>
           This is the same as <u>start</u>, except this option sets the start timestamp in timebase units  instead  of
           seconds.

       <b>end_pts</b>
           This  is  the  same  as  <u>end</u>,  except this option sets the end timestamp in timebase units instead of
           seconds.

       <b>duration</b>
           The maximum duration of the output in seconds.

       <b>start_frame</b>
           The number of the first frame that should be passed to the output.

       <b>end_frame</b>
           The number of the first frame that should be dropped.

       <b>start</b>, <b>end</b>, and <b>duration</b> are expressed as time duration specifications; see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b>  <b>in</b>
       <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b> for the accepted syntax.

       Note  that  the  first  two  sets  of  the  start/end  options  and the <b>duration</b> option look at the frame
       timestamp, while the _frame variants simply count the frames that pass through the filter. Also note that
       this filter does not modify the timestamps. If you wish for the  output  timestamps  to  start  at  zero,
       insert a setpts filter after the trim filter.

       If  multiple  start  or  end options are set, this filter tries to be greedy and keep all the frames that
       match at least one of the specified constraints. To keep only the part that matches all  the  constraints
       at once, chain multiple trim filters.

       The  defaults  are such that all the input is kept. So it is possible to set e.g.  just the end values to
       keep everything before the specified time.

       Examples:

       •   Drop everything except the second minute of input:

                   ffmpeg -i INPUT -vf trim=60:120

       •   Keep only the first second:

                   ffmpeg -i INPUT -vf trim=duration=1

   <b>unpremultiply</b>
       Apply alpha unpremultiply effect to input video stream using first plane of second stream as alpha.

       Both streams must have same dimensions and same pixel format.

       The filter accepts the following option:

       <b>planes</b>
           Set which planes will be processed, unprocessed planes will be copied.  By  default  value  0xf,  all
           planes will be processed.

           If  the  format  has 1 or 2 components, then luma is bit 0.  If the format has 3 or 4 components: for
           RGB formats bit 0 is green, bit 1 is blue and bit 2 is red; for YUV formats bit 0 is luma, bit  1  is
           chroma-U and bit 2 is chroma-V.  If present, the alpha channel is always the last bit.

       <b>inplace</b>
           Do not require 2nd input for processing, instead use alpha plane from input stream.

   <b>unsharp</b>
       Sharpen or blur the input video.

       It accepts the following parameters:

       <b>luma_msize_x,</b> <b>lx</b>
           Set the luma matrix horizontal size. It must be an odd integer between 3 and 23. The default value is
           5.

       <b>luma_msize_y,</b> <b>ly</b>
           Set  the  luma matrix vertical size. It must be an odd integer between 3 and 23. The default value is
           5.

       <b>luma_amount,</b> <b>la</b>
           Set the luma effect strength. It must be a floating point number, reasonable values lay between  -1.5
           and 1.5.

           Negative  values  will  blur  the input video, while positive values will sharpen it, a value of zero
           will disable the effect.

           Default value is 1.0.

       <b>chroma_msize_x,</b> <b>cx</b>
           Set the chroma matrix horizontal size. It must be an odd integer between 3 and 23. The default  value
           is 5.

       <b>chroma_msize_y,</b> <b>cy</b>
           Set the chroma matrix vertical size. It must be an odd integer between 3 and 23. The default value is
           5.

       <b>chroma_amount,</b> <b>ca</b>
           Set  the  chroma  effect  strength. It must be a floating point number, reasonable values lay between
           -1.5 and 1.5.

           Negative values will blur the input video, while positive values will sharpen it,  a  value  of  zero
           will disable the effect.

           Default value is 0.0.

       <b>alpha_msize_x,</b> <b>ax</b>
           Set  the  alpha matrix horizontal size. It must be an odd integer between 3 and 23. The default value
           is 5.

       <b>alpha_msize_y,</b> <b>ay</b>
           Set the alpha matrix vertical size. It must be an odd integer between 3 and 23. The default value  is
           5.

       <b>alpha_amount,</b> <b>aa</b>
           Set the alpha effect strength. It must be a floating point number, reasonable values lay between -1.5
           and 1.5.

           Negative  values  will  blur  the input video, while positive values will sharpen it, a value of zero
           will disable the effect.

           Default value is 0.0.

       All parameters are optional and default to the equivalent of the string '5:5:1.0:5:5:0.0'.

       <u>Examples</u>

       •   Apply strong luma sharpen effect:

                   unsharp=luma_msize_x=7:luma_msize_y=7:luma_amount=2.5

       •   Apply a strong blur of both luma and chroma parameters:

                   unsharp=7:7:-2:7:7:-2

   <b>untile</b>
       Decompose a video made of tiled images into the individual images.

       The frame rate of the output video is the frame rate of the input  video  multiplied  by  the  number  of
       tiles.

       This filter does the reverse of <b>tile</b>.

       The filter accepts the following options:

       <b>layout</b>
           Set  the  grid  size (i.e. the number of lines and columns). For the syntax of this option, check the
           <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

       <u>Examples</u>

       •   Produce a 1-second video from a still image file made  of  25  frames  stacked  vertically,  like  an
           analogic film reel:

                   ffmpeg -r 1 -i image.jpg -vf untile=1x25 movie.mkv

   <b>uspp</b>
       Apply ultra slow/simple postprocessing filter that compresses and decompresses the image at several (or -
       in the case of <b>quality</b> level 8 - all) shifts and average the results.

       The  way  this  differs  from  the behavior of spp is that uspp actually encodes &amp; decodes each case with
       libavcodec Snow, whereas spp uses a simplified intra only 8x8 DCT similar to MJPEG.

       This filter is not available in ffmpeg versions between 5.0 and 6.0.

       The filter accepts the following options:

       <b>quality</b>
           Set quality. This option defines the number of levels for averaging. It accepts  an  integer  in  the
           range  0-8.  If  set to 0, the filter will have no effect. A value of 8 means the higher quality. For
           each increment of that value the speed drops by a factor of approximately 2.  Default value is 3.

       <b>qp</b>  Force a constant quantization parameter. If not set, the filter will use the QP from the video stream
           (if available).

       <b>codec</b>
           Use specified codec instead of snow.

   <b>v360</b>
       Convert 360 videos between various formats.

       The filter accepts the following options:

       <b>input</b>
       <b>output</b>
           Set format of the input/output video.

           Available formats:

           <b>e</b>
           <b>equirect</b>
               Equirectangular projection.

           <b>c3x2</b>
           <b>c6x1</b>
           <b>c1x6</b>
               Cubemap with 3x2/6x1/1x6 layout.

               Format specific options:

               <b>in_pad</b>
               <b>out_pad</b>
                   Set padding proportion for the input/output cubemap. Values in decimals.

                   Example values:

                   <b>0</b>   No padding.

                   <b>0.01</b>
                       1% of face is padding. For example, with 1920x1280 resolution face size would be  640x640
                       and padding would be 3 pixels from each side. (640 * 0.01 = 6 pixels)

                   Default value is <b>@samp{0</b>}.  Maximum value is <b>@samp{0.1</b>}.

               <b>fin_pad</b>
               <b>fout_pad</b>
                   Set fixed padding for the input/output cubemap. Values in pixels.

                   Default value is <b>@samp{0</b>}. If greater than zero it overrides other padding options.

               <b>in_forder</b>
               <b>out_forder</b>
                   Set order of faces for the input/output cubemap. Choose one direction for each position.

                   Designation of directions:

                   <b>r</b>   right

                   <b>l</b>   left

                   <b>u</b>   up

                   <b>d</b>   down

                   <b>f</b>   forward

                   <b>b</b>   back

                   Default value is <b>@samp{rludfb</b>}.

               <b>in_frot</b>
               <b>out_frot</b>
                   Set rotation of faces for the input/output cubemap. Choose one angle for each position.

                   Designation of angles:

                   <b>0</b>   0 degrees clockwise

                   <b>1</b>   90 degrees clockwise

                   <b>2</b>   180 degrees clockwise

                   <b>3</b>   270 degrees clockwise

                   Default value is <b>@samp{000000</b>}.

           <b>eac</b> Equi-Angular Cubemap.

           <b>flat</b>
           <b>gnomonic</b>
           <b>rectilinear</b>
               Regular video.

               Format specific options:

               <b>h_fov</b>
               <b>v_fov</b>
               <b>d_fov</b>
                   Set output horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

               <b>ih_fov</b>
               <b>iv_fov</b>
               <b>id_fov</b>
                   Set input horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

           <b>dfisheye</b>
               Dual fisheye.

               Format specific options:

               <b>h_fov</b>
               <b>v_fov</b>
               <b>d_fov</b>
                   Set output horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

               <b>ih_fov</b>
               <b>iv_fov</b>
               <b>id_fov</b>
                   Set input horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

           <b>barrel</b>
           <b>fb</b>
           <b>barrelsplit</b>
               Facebook's 360 formats.

           <b>sg</b>  Stereographic format.

               Format specific options:

               <b>h_fov</b>
               <b>v_fov</b>
               <b>d_fov</b>
                   Set output horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

               <b>ih_fov</b>
               <b>iv_fov</b>
               <b>id_fov</b>
                   Set input horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

           <b>mercator</b>
               Mercator format.

           <b>ball</b>
               Ball format, gives significant distortion toward the back.

           <b>hammer</b>
               Hammer-Aitoff map projection format.

           <b>sinusoidal</b>
               Sinusoidal map projection format.

           <b>fisheye</b>
               Fisheye projection.

               Format specific options:

               <b>h_fov</b>
               <b>v_fov</b>
               <b>d_fov</b>
                   Set output horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

               <b>ih_fov</b>
               <b>iv_fov</b>
               <b>id_fov</b>
                   Set input horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

           <b>pannini</b>
               Pannini projection.

               Format specific options:

               <b>h_fov</b>
                   Set output pannini parameter.

               <b>ih_fov</b>
                   Set input pannini parameter.

           <b>cylindrical</b>
               Cylindrical projection.

               Format specific options:

               <b>h_fov</b>
               <b>v_fov</b>
               <b>d_fov</b>
                   Set output horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

               <b>ih_fov</b>
               <b>iv_fov</b>
               <b>id_fov</b>
                   Set input horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

           <b>perspective</b>
               Perspective projection. <u>(output</u> <u>only)</u>

               Format specific options:

               <b>v_fov</b>
                   Set perspective parameter.

           <b>tetrahedron</b>
               Tetrahedron projection.

           <b>tsp</b> Truncated square pyramid projection.

           <b>he</b>
           <b>hequirect</b>
               Half equirectangular projection.

           <b>equisolid</b>
               Equisolid format.

               Format specific options:

               <b>h_fov</b>
               <b>v_fov</b>
               <b>d_fov</b>
                   Set output horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

               <b>ih_fov</b>
               <b>iv_fov</b>
               <b>id_fov</b>
                   Set input horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

           <b>og</b>  Orthographic format.

               Format specific options:

               <b>h_fov</b>
               <b>v_fov</b>
               <b>d_fov</b>
                   Set output horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

               <b>ih_fov</b>
               <b>iv_fov</b>
               <b>id_fov</b>
                   Set input horizontal/vertical/diagonal field of view. Values in degrees.

                   If diagonal field of view is set it overrides horizontal and vertical field of view.

           <b>octahedron</b>
               Octahedron projection.

           <b>cylindricalea</b>
               Cylindrical Equal Area projection.

       <b>interp</b>
           Set interpolation method.<u>Note:</u> <u>more</u> <u>complex</u> <u>interpolation</u> <u>methods</u> <u>require</u> <u>much</u> <u>more</u> <u>memory</u> <u>to</u> <u>run.</u>

           Available methods:

           <b>near</b>
           <b>nearest</b>
               Nearest neighbour.

           <b>line</b>
           <b>linear</b>
               Bilinear interpolation.

           <b>lagrange9</b>
               Lagrange9 interpolation.

           <b>cube</b>
           <b>cubic</b>
               Bicubic interpolation.

           <b>lanc</b>
           <b>lanczos</b>
               Lanczos interpolation.

           <b>sp16</b>
           <b>spline16</b>
               Spline16 interpolation.

           <b>gauss</b>
           <b>gaussian</b>
               Gaussian interpolation.

           <b>mitchell</b>
               Mitchell interpolation.

           Default value is <b>@samp{line</b>}.

       <b>w</b>
       <b>h</b>   Set the output video resolution.

           Default resolution depends on formats.

       <b>in_stereo</b>
       <b>out_stereo</b>
           Set the input/output stereo format.

           <b>2d</b>  2D mono

           <b>sbs</b> Side by side

           <b>tb</b>  Top bottom

           Default value is <b>@samp{2d</b>} for input and output format.

       <b>yaw</b>
       <b>pitch</b>
       <b>roll</b>
           Set rotation for the output video. Values in degrees.

       <b>rorder</b>
           Set rotation order for the output video. Choose one item for each position.

           <b>y,</b> <b>Y</b>
               yaw

           <b>p,</b> <b>P</b>
               pitch

           <b>r,</b> <b>R</b>
               roll

           Default value is <b>@samp{ypr</b>}.

       <b>h_flip</b>
       <b>v_flip</b>
       <b>d_flip</b>
           Flip  the  output video horizontally(swaps left-right)/vertically(swaps up-down)/in-depth(swaps back-
           forward). Boolean values.

       <b>ih_flip</b>
       <b>iv_flip</b>
           Set if input video is flipped horizontally/vertically. Boolean values.

       <b>in_trans</b>
           Set if input video is transposed. Boolean value, by default disabled.

       <b>out_trans</b>
           Set if output video needs to be transposed. Boolean value, by default disabled.

       <b>h_offset</b>
       <b>v_offset</b>
           Set output horizontal/vertical off-axis offset. Default is set to 0.  Allowed range is from -1 to 1.

       <b>alpha_mask</b>
           Build mask in alpha plane for all unmapped pixels by marking them fully transparent.  Boolean  value,
           by default disabled.

       <b>reset_rot</b>
           Reset rotation of output video. Boolean value, by default disabled.

       <u>Examples</u>

       •   Convert equirectangular video to cubemap with 3x2 layout and 1% padding using bicubic interpolation:

                   ffmpeg -i input.mkv -vf v360=e:c3x2:cubic:out_pad=0.01 output.mkv

       •   Extract back view of Equi-Angular Cubemap:

                   ffmpeg -i input.mkv -vf v360=eac:flat:yaw=180 output.mkv

       •   Convert  transposed  and  horizontally  flipped Equi-Angular Cubemap in side-by-side stereo format to
           equirectangular top-bottom stereo format:

                   v360=eac:equirect:in_stereo=sbs:in_trans=1:ih_flip=1:out_stereo=tb

       <u>Commands</u>

       This filter supports subset of above options as <b>commands</b>.

   <b>vaguedenoiser</b>
       Apply a wavelet based denoiser.

       It transforms each frame from the video input into the wavelet  domain,  using  Cohen-Daubechies-Feauveau
       9/7.  Then  it  applies some filtering to the obtained coefficients. It does an inverse wavelet transform
       after.  Due to wavelet properties, it should give a nice smoothed  result,  and  reduced  noise,  without
       blurring picture features.

       This filter accepts the following options:

       <b>threshold</b>
           The filtering strength. The higher, the more filtered the video will be.  Hard thresholding can use a
           higher threshold than soft thresholding before the video looks overfiltered. Default value is 2.

       <b>method</b>
           The filtering method the filter will use.

           It accepts the following values:

           <b>hard</b>
               All values under the threshold will be zeroed.

           <b>soft</b>
               All values under the threshold will be zeroed. All values above will be reduced by the threshold.

           <b>garrote</b>
               Scales or nullifies coefficients - intermediary between (more) soft and (less) hard thresholding.

           Default is garrote.

       <b>nsteps</b>
           Number  of  times,  the  wavelet  will  decompose  the  picture. Picture can't be decomposed beyond a
           particular point (typically, 8 for a 640x480 frame - as 2^9 = 512 &gt; 480). Valid values  are  integers
           between 1 and 32. Default value is 6.

       <b>percent</b>
           Partial of full denoising (limited coefficients shrinking), from 0 to 100. Default value is 85.

       <b>planes</b>
           A list of the planes to process. By default all planes are processed.

       <b>type</b>
           The threshold type the filter will use.

           It accepts the following values:

           <b>universal</b>
               Threshold used is same for all decompositions.

           <b>bayes</b>
               Threshold used depends also on each decomposition coefficients.

           Default is universal.

   <b>varblur</b>
       Apply  variable  blur  filter by using 2nd video stream to set blur radius.  The 2nd stream must have the
       same dimensions.

       This filter accepts the following options:

       <b>min_r</b>
           Set min allowed radius. Allowed range is from 0 to 254. Default is 0.

       <b>max_r</b>
           Set max allowed radius. Allowed range is from 1 to 255. Default is 8.

       <b>planes</b>
           Set which planes to process. By default, all are used.

       The "varblur" filter also supports the <b>framesync</b> options.

       <u>Commands</u>

       This filter supports all the above options as <b>commands</b>.

   <b>vectorscope</b>
       Display 2 color component values in the two dimensional graph (which is called a vectorscope).

       This filter accepts the following options:

       <b>mode,</b> <b>m</b>
           Set vectorscope mode.

           It accepts the following values:

           <b>gray</b>
           <b>tint</b>
               Gray values are displayed on graph, higher brightness means more pixels have same component color
               value on location in graph. This is the default mode.

           <b>color</b>
               Gray values are displayed on graph. Surrounding pixels values which  are  not  present  in  video
               frame  are  drawn  in gradient of 2 color components which are set by option "x" and "y". The 3rd
               color component is static.

           <b>color2</b>
               Actual color components values present in video frame are displayed on graph.

           <b>color3</b>
               Similar as color2 but higher frequency of same values "x" and "y" on  graph  increases  value  of
               another color component, which is luminance by default values of "x" and "y".

           <b>color4</b>
               Actual  colors present in video frame are displayed on graph. If two different colors map to same
               position on graph then color with higher value of component not present in graph is picked.

           <b>color5</b>
               Gray values are displayed on graph. Similar to "color" but with 3rd color component  picked  from
               radial gradient.

       <b>x</b>   Set which color component will be represented on X-axis. Default is 1.

       <b>y</b>   Set which color component will be represented on Y-axis. Default is 2.

       <b>intensity,</b> <b>i</b>
           Set  intensity,  used  by  modes:  gray,  color, color3 and color5 for increasing brightness of color
           component which represents frequency of (X, Y) location in graph.

       <b>envelope,</b> <b>e</b>
           <b>none</b>
               No envelope, this is default.

           <b>instant</b>
               Instant envelope, even darkest single pixel will be clearly highlighted.

           <b>peak</b>
               Hold maximum and minimum values presented in graph over time. This way you can still spot out  of
               range values without constantly looking at vectorscope.

           <b>peak+instant</b>
               Peak and instant envelope combined together.

       <b>graticule,</b> <b>g</b>
           Set what kind of graticule to draw.

           <b>none</b>
           <b>green</b>
           <b>color</b>
           <b>invert</b>
       <b>opacity,</b> <b>o</b>
           Set graticule opacity.

       <b>flags,</b> <b>f</b>
           Set graticule flags.

           <b>white</b>
               Draw graticule for white point.

           <b>black</b>
               Draw graticule for black point.

           <b>name</b>
               Draw color points short names.

       <b>bgopacity,</b> <b>b</b>
           Set background opacity.

       <b>lthreshold,</b> <b>l</b>
           Set  low  threshold for color component not represented on X or Y axis.  Values lower than this value
           will be ignored. Default is 0.  Note this value is multiplied with  actual  max  possible  value  one
           pixel component can have. So for 8-bit input and low threshold value of 0.1 actual threshold is 0.1 *
           255 = 25.

       <b>hthreshold,</b> <b>h</b>
           Set high threshold for color component not represented on X or Y axis.  Values higher than this value
           will  be  ignored.  Default  is  1.  Note this value is multiplied with actual max possible value one
           pixel component can have. So for 8-bit input and high threshold value of 0.9 actual threshold is  0.9
           * 255 = 230.

       <b>colorspace,</b> <b>c</b>
           Set what kind of colorspace to use when drawing graticule.

           <b>auto</b>
           <b>601</b>
           <b>709</b>

           Default is auto.

       <b>tint0,</b> <b>t0</b>
       <b>tint1,</b> <b>t1</b>
           Set color tint for gray/tint vectorscope mode. By default both options are zero.  This means no tint,
           and output will remain gray.

   <b>vidstabdetect</b>
       Analyze video stabilization/deshaking. Perform pass 1 of 2, see <b>vidstabtransform</b> for pass 2.

       This  filter  generates  a  file  with  relative  translation  and  rotation  transform information about
       subsequent frames, which is then used by the <b>vidstabtransform</b> filter.

       To enable compilation of this filter you need to configure FFmpeg with "--enable-libvidstab".

       This filter accepts the following options:

       <b>result</b>
           Set the path to the file used to write the transforms information.  Default value is <u>transforms.trf</u>.

       <b>shakiness</b>
           Set how shaky the video is and how quick the camera is. It accepts an integer in the  range  1-10,  a
           value of 1 means little shakiness, a value of 10 means strong shakiness. Default value is 5.

       <b>accuracy</b>
           Set  the  accuracy of the detection process. It must be a value in the range 1-15. A value of 1 means
           low accuracy, a value of 15 means high accuracy. Default value is 15.

       <b>stepsize</b>
           Set stepsize of the search process. The region around minimum is scanned  with  1  pixel  resolution.
           Default value is 6.

       <b>mincontrast</b>
           Set  minimum  contrast.  Below  this value a local measurement field is discarded. Must be a floating
           point value in the range 0-1. Default value is 0.3.

       <b>tripod</b>
           Set reference frame number for tripod mode.

           If enabled, the motion of the frames is compared  to  a  reference  frame  in  the  filtered  stream,
           identified  by the specified number. The idea is to compensate all movements in a more-or-less static
           scene and keep the camera view absolutely still.

           If set to 0, it is disabled. The frames are counted starting from 1.

       <b>show</b>
           Show fields and transforms in the resulting frames. It accepts an integer in the range  0-2.  Default
           value is 0, which disables any visualization.

       <b>fileformat</b>
           Format for the transforms data file to be written.  Acceptable values are

           <b>ascii</b>
               Human-readable plain text

           <b>binary</b>
               Binary format, roughly 40% smaller than "ascii". (<u>default</u>)

       <u>Examples</u>

       •   Use default values:

                   vidstabdetect

       •   Analyze strongly shaky movie and put the results in file <u>mytransforms.trf</u>:

                   vidstabdetect=shakiness=10:accuracy=15:result="mytransforms.trf"

       •   Visualize the result of internal transformations in the resulting video:

                   vidstabdetect=show=1

       •   Analyze a video with medium shakiness using <b>ffmpeg</b>:

                   ffmpeg -i input -vf vidstabdetect=shakiness=5:show=1 dummy.avi

   <b>vidstabtransform</b>
       Video stabilization/deshaking: pass 2 of 2, see <b>vidstabdetect</b> for pass 1.

       Read  a  file  with  transform  information  for  each frame and apply/compensate them. Together with the
       <b>vidstabdetect</b> filter this can be used to deshake videos. See  also  &lt;<b><a href="http://public.hronopik.de/vid.stab">http://public.hronopik.de/vid.stab</a></b>&gt;.
       It is important to also use the <b>unsharp</b> filter, see below.

       To enable compilation of this filter you need to configure FFmpeg with "--enable-libvidstab".

       <u>Options</u>

       <b>input</b>
           Set path to the file used to read the transforms. Default value is <u>transforms.trf</u>.

       <b>smoothing</b>
           Set the number of frames (value*2 + 1) used for lowpass filtering the camera movements. Default value
           is 10.

           For  example  a  number  of 10 means that 21 frames are used (10 in the past and 10 in the future) to
           smoothen the motion in the video.  A  larger  value  leads  to  a  smoother  video,  but  limits  the
           acceleration  of  the  camera  (pan/tilt  movements).  0  is  a special case where a static camera is
           simulated.

       <b>optalgo</b>
           Set the camera path optimization algorithm.

           Accepted values are:

           <b>gauss</b>
               gaussian kernel low-pass filter on camera motion (default)

           <b>avg</b> averaging on transformations

       <b>maxshift</b>
           Set maximal number of pixels to translate frames. Default value is -1, meaning no limit.

       <b>maxangle</b>
           Set maximal angle in radians (degree*PI/180) to rotate frames. Default value is -1, meaning no limit.

       <b>crop</b>
           Specify how to deal with borders that may be visible due to movement compensation.

           Available values are:

           <b>keep</b>
               keep image information from previous frame (default)

           <b>black</b>
               fill the border black

       <b>invert</b>
           Invert transforms if set to 1. Default value is 0.

       <b>relative</b>
           Consider transforms as relative to previous frame if set to 1, absolute if set to 0. Default value is
           0.

       <b>zoom</b>
           Set percentage to zoom. A positive value will result in a zoom-in effect, a negative value in a zoom-
           out effect. Default value is 0 (no zoom).

       <b>optzoom</b>
           Set optimal zooming to avoid borders.

           Accepted values are:

           <b>0</b>   disabled

           <b>1</b>   optimal static zoom value is determined (only very strong movements will lead to visible borders)
               (default)

           <b>2</b>   optimal adaptive zoom value is determined (no borders will be visible), see <b>zoomspeed</b>

           Note that the value given at zoom is added to the one calculated here.

       <b>zoomspeed</b>
           Set percent to zoom maximally each frame (enabled when <b>optzoom</b> is set to 2). Range is from  0  to  5,
           default value is 0.25.

       <b>interpol</b>
           Specify type of interpolation.

           Available values are:

           <b>no</b>  no interpolation

           <b>linear</b>
               linear only horizontal

           <b>bilinear</b>
               linear in both directions (default)

           <b>bicubic</b>
               cubic in both directions (slow)

       <b>tripod</b>
           Enable  virtual  tripod  mode  if  set to 1, which is equivalent to "relative=0:smoothing=0". Default
           value is 0.

           Use also "tripod" option of <b>vidstabdetect</b>.

       <b>debug</b>
           Increase log verbosity if set to 1. Also the detected global motions are  written  to  the  temporary
           file <u>global_motions.trf</u>. Default value is 0.

       <u>Examples</u>

       •   Use <b>ffmpeg</b> for a typical stabilization with default values:

                   ffmpeg -i inp.mpeg -vf vidstabtransform,unsharp=5:5:0.8:3:3:0.4 inp_stabilized.mpeg

           Note the use of the <b>unsharp</b> filter which is always recommended.

       •   Zoom in a bit more and load transform data from a given file:

                   vidstabtransform=zoom=5:input="mytransforms.trf"

       •   Smoothen the video even more:

                   vidstabtransform=smoothing=30

   <b>vflip</b>
       Flip the input video vertically.

       For example, to vertically flip a video with <b>ffmpeg</b>:

               ffmpeg -i in.avi -vf "vflip" out.avi

   <b>vfrdet</b>
       Detect variable frame rate video.

       This filter tries to detect if the input is variable or constant frame rate.

       At  end  it  will  output  number of frames detected as having variable delta pts, and ones with constant
       delta pts.  If there was frames with variable delta, than it will also show min, max  and  average  delta
       encountered.

   <b>vibrance</b>
       Boost or alter saturation.

       The filter accepts the following options:

       <b>intensity</b>
           Set  strength  of  boost  if  positive  value  or strength of alter if negative value.  Default is 0.
           Allowed range is from -2 to 2.

       <b>rbal</b>
           Set the red balance. Default is 1. Allowed range is from -10 to 10.

       <b>gbal</b>
           Set the green balance. Default is 1. Allowed range is from -10 to 10.

       <b>bbal</b>
           Set the blue balance. Default is 1. Allowed range is from -10 to 10.

       <b>rlum</b>
           Set the red luma coefficient.

       <b>glum</b>
           Set the green luma coefficient.

       <b>blum</b>
           Set the blue luma coefficient.

       <b>alternate</b>
           If "intensity" is negative and this is set to 1, colors will change, otherwise colors  will  be  less
           saturated, more towards gray.

       <u>Commands</u>

       This filter supports the all above options as <b>commands</b>.

   <b>vif</b>
       Obtain the average VIF (Visual Information Fidelity) between two input videos.

       This filter takes two input videos.

       Both  input videos must have the same resolution and pixel format for this filter to work correctly. Also
       it assumes that both inputs have the same number of frames, which are compared one by one.

       The obtained average VIF score is printed through the logging system.

       The filter stores the calculated VIF score of each frame.

       This filter also supports the <b>framesync</b> options.

       In the below example the input file <u>main.mpg</u> being processed is compared with the reference file <u>ref.mpg</u>.

               ffmpeg -i main.mpg -i ref.mpg -lavfi vif -f null -

   <b>vignette</b>
       Make or reverse a natural vignetting effect.

       The filter accepts the following options:

       <b>angle,</b> <b>a</b>
           Set lens angle expression as a number of radians.

           The value is clipped in the "[0,PI/2]" range.

           Default value: "PI/5"

       <b>x0</b>
       <b>y0</b>  Set center coordinates expressions. Respectively "w/2" and "h/2" by default.

       <b>mode</b>
           Set forward/backward mode.

           Available modes are:

           <b>forward</b>
               The larger the distance from the central point, the darker the image becomes.

           <b>backward</b>
               The larger the distance from the central point, the brighter the image becomes.  This can be used
               to reverse a vignette effect, though there is no automatic detection to extract  the  lens  <b>angle</b>
               and other settings (yet). It can also be used to create a burning effect.

           Default value is <b>forward</b>.

       <b>eval</b>
           Set evaluation mode for the expressions (<b>angle</b>, <b>x0</b>, <b>y0</b>).

           It accepts the following values:

           <b>init</b>
               Evaluate expressions only once during the filter initialization.

           <b>frame</b>
               Evaluate  expressions  for  each  incoming  frame. This is way slower than the <b>init</b> mode since it
               requires all the scalers to be re-computed, but it allows advanced dynamic expressions.

           Default value is <b>init</b>.

       <b>dither</b>
           Set dithering to reduce the circular banding effects. Default is 1 (enabled).

       <b>aspect</b>
           Set vignette aspect. This setting allows one to adjust the shape of the vignette.  Setting this value
           to the SAR of the input will make a rectangular vignetting following the dimensions of the video.

           Default is "1/1".

       <u>Expressions</u>

       The <b>alpha</b>, <b>x0</b> and <b>y0</b> expressions can contain the following parameters.

       <b>w</b>
       <b>h</b>   input width and height

       <b>n</b>   the number of input frame, starting from 0

       <b>pts</b> the PTS (Presentation TimeStamp) time of the filtered video frame, expressed  in  <u>TB</u>  units,  NAN  if
           undefined

       <b>r</b>   frame rate of the input video, NAN if the input frame rate is unknown

       <b>t</b>   the PTS (Presentation TimeStamp) of the filtered video frame, expressed in seconds, NAN if undefined

       <b>tb</b>  time base of the input video

       <u>Examples</u>

       •   Apply simple strong vignetting effect:

                   vignette=PI/4

       •   Make a flickering vignetting:

                   vignette='PI/4+<a href="../man1/random.1.html">random</a>(1)*PI/50':eval=frame

   <b>vmafmotion</b>
       Obtain the average VMAF motion score of a video.  It is one of the component metrics of VMAF.

       The obtained average motion score is printed through the logging system.

       The filter accepts the following options:

       <b>stats_file</b>
           If  specified, the filter will use the named file to save the motion score of each frame with respect
           to the previous frame.  When filename equals "-" the data is sent to standard output.

       Example:

               ffmpeg -i ref.mpg -vf vmafmotion -f null -

   <b>vstack</b>
       Stack input videos vertically.

       All streams must be of same pixel format and of same width.

       Note that this filter is faster than using <b>overlay</b> and <b>pad</b> filter to create same output.

       The filter accepts the following options:

       <b>inputs</b>
           Set number of input streams. Default is 2.

       <b>shortest</b>
           If set to 1, force the output to terminate when the shortest input terminates. Default value is 0.

   <b>w3fdif</b>
       Deinterlace the input video ("w3fdif" stands for "Weston 3 Field Deinterlacing Filter").

       Based on the process described by Martin Weston for BBC R&amp;D, and implemented based  on  the  de-interlace
       algorithm  written  by  Jim  Easterbrook for BBC R&amp;D, the Weston 3 field deinterlacing filter uses filter
       coefficients calculated by BBC R&amp;D.

       This filter uses field-dominance information in frame to decide which of each pair  of  fields  to  place
       first in the output.  If it gets it wrong use <b>setfield</b> filter before "w3fdif" filter.

       There  are  two  sets  of  filter  coefficients,  so  called  "simple" and "complex". Which set of filter
       coefficients is used can be set by passing an optional parameter:

       <b>filter</b>
           Set the interlacing filter coefficients. Accepts one of the following values:

           <b>simple</b>
               Simple filter coefficient set.

           <b>complex</b>
               More-complex filter coefficient set.

           Default value is <b>complex</b>.

       <b>mode</b>
           The interlacing mode to adopt. It accepts one of the following values:

           <b>frame</b>
               Output one frame for each frame.

           <b>field</b>
               Output one frame for each field.

           The default value is "field".

       <b>parity</b>
           The picture field parity assumed for the input interlaced video. It  accepts  one  of  the  following
           values:

           <b>tff</b> Assume the top field is first.

           <b>bff</b> Assume the bottom field is first.

           <b>auto</b>
               Enable automatic detection of field parity.

           The  default  value  is  "auto".   If  the interlacing is unknown or the decoder does not export this
           information, top field first will be assumed.

       <b>deint</b>
           Specify which frames to deinterlace. Accepts one of the following values:

           <b>all</b> Deinterlace all frames,

           <b>interlaced</b>
               Only deinterlace frames marked as interlaced.

           Default value is <b>all</b>.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>waveform</b>
       Video waveform monitor.

       The waveform monitor plots color component intensity. By default luma only. Each column of  the  waveform
       corresponds to a column of pixels in the source video.

       It accepts the following options:

       <b>mode,</b> <b>m</b>
           Can  be  either  "row",  or  "column".  Default is "column".  In row mode, the graph on the left side
           represents color component value 0 and the right side represents value = 255. In column mode, the top
           side represents color component value = 0 and bottom side represents value = 255.

       <b>intensity,</b> <b>i</b>
           Set intensity. Smaller values are useful to find out how  many  values  of  the  same  luminance  are
           distributed across input rows/columns.  Default value is 0.04. Allowed range is [0, 1].

       <b>mirror,</b> <b>r</b>
           Set  mirroring  mode.  0 means unmirrored, 1 means mirrored.  In mirrored mode, higher values will be
           represented on the left side for "row"  mode  and  at  the  top  for  "column"  mode.  Default  is  1
           (mirrored).

       <b>display,</b> <b>d</b>
           Set display mode.  It accepts the following values:

           <b>overlay</b>
               Presents information identical to that in the "parade", except that the graphs representing color
               components are superimposed directly over one another.

               This  display  mode  makes  it easier to spot relative differences or similarities in overlapping
               areas of the color components that are supposed to be identical, such as neutral  whites,  grays,
               or blacks.

           <b>stack</b>
               Display separate graph for the color components side by side in "row" mode or one below the other
               in "column" mode.

           <b>parade</b>
               Display  separate  graph  for the color components side by side in "column" mode or one below the
               other in "row" mode.

               Using this display mode makes it easy to spot color casts in the highlights  and  shadows  of  an
               image, by comparing the contours of the top and the bottom graphs of each waveform. Since whites,
               grays,  and  blacks  are  characterized by exactly equal amounts of red, green, and blue, neutral
               areas of the picture should display three waveforms of roughly equal width/height.  If  not,  the
               correction is easy to perform by making level adjustments the three waveforms.

           Default is "stack".

       <b>components,</b> <b>c</b>
           Set  which color components to display. Default is 1, which means only luma or red color component if
           input is in RGB colorspace. If is set for example to 7 it will display all  3  (if)  available  color
           components.

       <b>envelope,</b> <b>e</b>
           <b>none</b>
               No envelope, this is default.

           <b>instant</b>
               Instant  envelope, minimum and maximum values presented in graph will be easily visible even with
               small "step" value.

           <b>peak</b>
               Hold minimum and maximum values presented in graph across time. This way you can still  spot  out
               of range values without constantly looking at waveforms.

           <b>peak+instant</b>
               Peak and instant envelope combined together.

       <b>filter,</b> <b>f</b>
           <b>lowpass</b>
               No filtering, this is default.

           <b>flat</b>
               Luma and chroma combined together.

           <b>aflat</b>
               Similar as above, but shows difference between blue and red chroma.

           <b>xflat</b>
               Similar as above, but use different colors.

           <b>yflat</b>
               Similar as above, but again with different colors.

           <b>chroma</b>
               Displays only chroma.

           <b>color</b>
               Displays actual color value on waveform.

           <b>acolor</b>
               Similar as above, but with luma showing frequency of chroma values.

       <b>graticule,</b> <b>g</b>
           Set which graticule to display.

           <b>none</b>
               Do not display graticule.

           <b>green</b>
               Display green graticule showing legal broadcast ranges.

           <b>orange</b>
               Display orange graticule showing legal broadcast ranges.

           <b>invert</b>
               Display invert graticule showing legal broadcast ranges.

       <b>opacity,</b> <b>o</b>
           Set graticule opacity.

       <b>flags,</b> <b>fl</b>
           Set graticule flags.

           <b>numbers</b>
               Draw numbers above lines. By default enabled.

           <b>dots</b>
               Draw dots instead of lines.

       <b>scale,</b> <b>s</b>
           Set scale used for displaying graticule.

           <b>digital</b>
           <b>millivolts</b>
           <b>ire</b>

           Default is digital.

       <b>bgopacity,</b> <b>b</b>
           Set background opacity.

       <b>tint0,</b> <b>t0</b>
       <b>tint1,</b> <b>t1</b>
           Set  tint  for output.  Only used with lowpass filter and when display is not overlay and input pixel
           formats are not RGB.

       <b>fitmode,</b> <b>fm</b>
           Set sample aspect ratio of video output frames.  Can be used to  configure  waveform  so  it  is  not
           streched too much in one of directions.

           <b>none</b>
               Set sample aspect ration to 1/1.

           <b>size</b>
               Set sample aspect ratio to match input size of video

           Default is <b>none</b>.

       <b>input</b>
           Set  input formats for filter to pick from.  Can be <b>all</b>, for selecting from all available formats, or
           <b>first</b>, for selecting first available format.  Default is <b>first</b>.

   <b>weave,</b> <b>doubleweave</b>
       The "weave" takes a field-based video input and join  each  two  sequential  fields  into  single  frame,
       producing a new double height clip with half the frame rate and half the frame count.

       The "doubleweave" works same as "weave" but without halving frame rate and frame count.

       It accepts the following option:

       <b>first_field</b>
           Set first field. Available values are:

           <b>top,</b> <b>t</b>
               Set the frame as top-field-first.

           <b>bottom,</b> <b>b</b>
               Set the frame as bottom-field-first.

       <u>Examples</u>

       •   Interlace video using <b>select</b> and <b>separatefields</b> filter:

                   separatefields,select=eq(mod(n,4),0)+eq(mod(n,4),3),weave

   <b>xbr</b>
       Apply  the  xBR  high-quality  magnification  filter which is designed for pixel art. It follows a set of
       edge-detection rules, see &lt;<b>https://forums.libretro.com/t/xbr-algorithm-tutorial/123</b>&gt;.

       It accepts the following option:

       <b>n</b>   Set the scaling dimension: 2 for "2xBR", 3 for "3xBR" and 4 for "4xBR".  Default is 3.

   <b>xcorrelate</b>
       Apply normalized cross-correlation between first and second input video stream.

       Second input video stream dimensions must be lower than first input video stream.

       The filter accepts the following options:

       <b>planes</b>
           Set which planes to process.

       <b>secondary</b>
           Set which secondary video frames will be processed from second input video stream, can  be  <u>first</u>  or
           <u>all</u>. Default is <u>all</u>.

       The "xcorrelate" filter also supports the <b>framesync</b> options.

   <b>xfade</b>
       Apply  cross  fade  from one input video stream to another input video stream.  The cross fade is applied
       for specified duration.

       Both inputs must be constant frame-rate and have the  same  resolution,  pixel  format,  frame  rate  and
       timebase.

       The filter accepts the following options:

       <b>transition</b>
           Set one of available transition effects:

           <b>custom</b>
           <b>fade</b>
           <b>wipeleft</b>
           <b>wiperight</b>
           <b>wipeup</b>
           <b>wipedown</b>
           <b>slideleft</b>
           <b>slideright</b>
           <b>slideup</b>
           <b>slidedown</b>
           <b>circlecrop</b>
           <b>rectcrop</b>
           <b>distance</b>
           <b>fadeblack</b>
           <b>fadewhite</b>
           <b>radial</b>
           <b>smoothleft</b>
           <b>smoothright</b>
           <b>smoothup</b>
           <b>smoothdown</b>
           <b>circleopen</b>
           <b>circleclose</b>
           <b>vertopen</b>
           <b>vertclose</b>
           <b>horzopen</b>
           <b>horzclose</b>
           <b>dissolve</b>
           <b>pixelize</b>
           <b>diagtl</b>
           <b>diagtr</b>
           <b>diagbl</b>
           <b>diagbr</b>
           <b>hlslice</b>
           <b>hrslice</b>
           <b>vuslice</b>
           <b>vdslice</b>
           <b>hblur</b>
           <b>fadegrays</b>
           <b>wipetl</b>
           <b>wipetr</b>
           <b>wipebl</b>
           <b>wipebr</b>
           <b>squeezeh</b>
           <b>squeezev</b>
           <b>zoomin</b>
           <b>fadefast</b>
           <b>fadeslow</b>
           <b>hlwind</b>
           <b>hrwind</b>
           <b>vuwind</b>
           <b>vdwind</b>
           <b>coverleft</b>
           <b>coverright</b>
           <b>coverup</b>
           <b>coverdown</b>
           <b>revealleft</b>
           <b>revealright</b>
           <b>revealup</b>
           <b>revealdown</b>

           Default transition effect is fade.

       <b>duration</b>
           Set cross fade duration in seconds.  Range is 0 to 60 seconds.  Default duration is 1 second.

       <b>offset</b>
           Set cross fade start relative to first input stream in seconds.  Default offset is 0.

       <b>expr</b>
           Set expression for custom transition effect.

           The expressions can use the following variables and functions:

           <b>X</b>
           <b>Y</b>   The coordinates of the current sample.

           <b>W</b>
           <b>H</b>   The width and height of the image.

           <b>P</b>   Progress of transition effect.

           <b>PLANE</b>
               Currently processed plane.

           <b>A</b>   Return value of first input at current location and plane.

           <b>B</b>   Return value of second input at current location and plane.

           <b>a0(x,</b> <b>y)</b>
           <b>a1(x,</b> <b>y)</b>
           <b>a2(x,</b> <b>y)</b>
           <b>a3(x,</b> <b>y)</b>
               Return  the  value  of  the pixel at location (<u>x</u>,<u>y</u>) of the first/second/third/fourth component of
               first input.

           <b>b0(x,</b> <b>y)</b>
           <b>b1(x,</b> <b>y)</b>
           <b>b2(x,</b> <b>y)</b>
           <b>b3(x,</b> <b>y)</b>
               Return the value of the pixel at location (<u>x</u>,<u>y</u>) of  the  first/second/third/fourth  component  of
               second input.

       <u>Examples</u>

       •   Cross  fade  from  one  input  video  to  another  input  video, with fade transition and duration of
           transition of 2 seconds starting at offset of 5 seconds:

                   ffmpeg -i first.mp4 -i second.mp4 -filter_complex xfade=transition=fade:duration=2:offset=5 output.mp4

   <b>xmedian</b>
       Pick median pixels from several input videos.

       The filter accepts the following options:

       <b>inputs</b>
           Set number of inputs.  Default is 3. Allowed range is from 3 to 255.  If number  of  inputs  is  even
           number, than result will be mean value between two median values.

       <b>planes</b>
           Set which planes to filter. Default value is 15, by which all planes are processed.

       <b>percentile</b>
           Set  median  percentile.  Default value is 0.5.  Default value of 0.5 will pick always median values,
           while 0 will pick minimum values, and 1 maximum values.

       <u>Commands</u>

       This filter supports all above options as <b>commands</b>, excluding option "inputs".

   <b>xpsnr</b>
       Obtain the average (across all input frames) and minimum  (across  all  color  plane  averages)  eXtended
       Perceptually weighted peak Signal-to-Noise Ratio (XPSNR) between two input videos.

       The XPSNR is a low-complexity psychovisually motivated distortion measurement algorithm for assessing the
       difference between two video streams or images. This is especially useful for objectively quantifying the
       distortions  caused  by  video  and  image  codecs,  as  an  alternative to a formal subjective test. The
       logarithmic XPSNR output values are in a similar range as  those  of  traditional  <b>psnr</b>  assessments  but
       better  reflect  human  impressions  of  visual  coding quality. More details on the XPSNR measure, which
       essentially represents a blockwise weighted variant of the PSNR measure, can be found  in  the  following
       freely available papers:

       •   C.  R. Helmrich, M. Siekmann, S. Becker, S. Bosse, D. Marpe, and T. Wiegand, "XPSNR: A Low-Complexity
           Extension of the Perceptually Weighted Peak Signal-to-Noise Ratio for High-Resolution  Video  Quality
           Assessment,"  in  Proc.  IEEE Int. Conf. Acoustics, Speech, Sig. Process. (ICASSP), virt./online, May
           2020. &lt;<b>www.ecodis.de/xpsnr.htm</b>&gt;

       •   C. R. Helmrich, S. Bosse, H. Schwarz, D. Marpe, and T. Wiegand, "A Study of the Extended Perceptually
           Weighted Peak Signal-to-Noise Ratio (XPSNR) for Video Compression with Different Resolutions and  Bit
           Depths,"   ITU   Journal:   ICT   Discoveries,   vol.   3,   no.    1,   pp.   65  -  72,  May  2020.
           &lt;<b><a href="http://handle.itu.int/11.1002/pub/8153d78b-en">http://handle.itu.int/11.1002/pub/8153d78b-en</a></b>&gt;

       When publishing the results of XPSNR assessments obtained using, e.g., this FFmpeg filter, a reference to
       the above papers as a means of documentation is  strongly  encouraged.  The  filter  requires  two  input
       videos.  The first input is considered a (usually not distorted) reference source and is passed unchanged
       to the output, whereas the second input is a (distorted) test signal. Except for the bit depth, these two
       video inputs must have the same pixel format. In addition, for  best  performance,  both  compared  input
       videos should be in YCbCr color format.

       The  obtained  overall  XPSNR  values  mentioned above are printed through the logging system. In case of
       input with multiple color planes, we suggest reporting of the minimum XPSNR average.

       The following parameter, which behaves like the one for the <b>psnr</b> filter, is accepted:

       <b>stats_file,</b> <b>f</b>
           If specified, the filter will use the named file to save the XPSNR value of each individual frame and
           color plane. When the file name equals "-", that data is sent to standard output.

       This filter also supports the <b>framesync</b> options.

       <u>Examples</u>

       •   XPSNR analysis of two 1080p HD videos, ref_source.yuv and  test_video.yuv,  both  at  24  frames  per
           second, with color format 4:2:0, bit depth 8, and output of a logfile named "xpsnr.log":

                   ffmpeg -s 1920x1080 -framerate 24 -pix_fmt yuv420p -i ref_source.yuv -s 1920x1080 -framerate
                   24 -pix_fmt yuv420p -i test_video.yuv -lavfi xpsnr="stats_file=xpsnr.log" -f null -

       •   XPSNR  analysis  of two 2160p UHD videos, ref_source.yuv with bit depth 8 and test_video.yuv with bit
           depth 10, both at 60 frames per second with color format 4:2:0, no logfile output:

                   ffmpeg -s 3840x2160 -framerate 60 -pix_fmt yuv420p -i ref_source.yuv -s 3840x2160 -framerate
                   60 -pix_fmt yuv420p10le -i test_video.yuv -lavfi xpsnr="stats_file=-" -f null -

   <b>xstack</b>
       Stack video inputs into custom layout.

       All streams must be of same pixel format.

       The filter accepts the following options:

       <b>inputs</b>
           Set number of input streams. Default is 2.

       <b>layout</b>
           Specify layout of inputs.  This option requires the desired layout configuration to be explicitly set
           by the user.  This sets position of each video input in output. Each input is separated by '|'.   The
           first number represents the column, and the second number represents the row.  Numbers start at 0 and
           are  separated  by  '_'.  Optionally one can use wX and hX, where X is video input from which to take
           width or height.  Multiple values can be used when separated by '+'. In such case values  are  summed
           together.

           Note that if inputs are of different sizes gaps may appear, as not all of the output video frame will
           be  filled. Similarly, videos can overlap each other if their position doesn't leave enough space for
           the full frame of adjoining videos.

           For 2 inputs, a default layout of "0_0|w0_0" (equivalent to "grid=2x1") is set. In all other cases, a
           layout or a grid must be set by the user. Either "grid" or "layout"  can  be  specified  at  a  time.
           Specifying both will result in an error.

       <b>grid</b>
           Specify  a  fixed  size grid of inputs.  This option is used to create a fixed size grid of the input
           streams. Set the grid size in the form "COLUMNSxROWS". There must be "ROWS * COLUMNS"  input  streams
           and  they  will be arranged as a grid with "ROWS" rows and "COLUMNS" columns. When using this option,
           each input stream within a row must have the same height and all the rows must have the same width.

           If "grid" is set, then "inputs" option is ignored and is implicitly set to "ROWS * COLUMNS".

           For 2 inputs, a default grid of "2x1" (equivalent to "layout=0_0|w0_0") is set. In all other cases, a
           layout or a grid must be set by the user. Either "grid" or "layout"  can  be  specified  at  a  time.
           Specifying both will result in an error.

       <b>shortest</b>
           If set to 1, force the output to terminate when the shortest input terminates. Default value is 0.

       <b>fill</b>
           If  set  to valid color, all unused pixels will be filled with that color.  By default fill is set to
           none, so it is disabled.

       <u>Examples</u>

       •   Display 4 inputs into 2x2 grid.

           Layout:

                   input1(0, 0)  | input3(w0, 0)
                   input2(0, h0) | input4(w0, h0)

                   xstack=inputs=4:layout=0_0|0_h0|w0_0|w0_h0

           Note that if inputs are of different sizes, gaps or overlaps may occur.

       •   Display 4 inputs into 1x4 grid.

           Layout:

                   input1(0, 0)
                   input2(0, h0)
                   input3(0, h0+h1)
                   input4(0, h0+h1+h2)

                   xstack=inputs=4:layout=0_0|0_h0|0_h0+h1|0_h0+h1+h2

           Note that if inputs are of different widths, unused space will appear.

       •   Display 9 inputs into 3x3 grid.

           Layout:

                   input1(0, 0)       | input4(w0, 0)      | input7(w0+w3, 0)
                   input2(0, h0)      | input5(w0, h0)     | input8(w0+w3, h0)
                   input3(0, h0+h1)   | input6(w0, h0+h1)  | input9(w0+w3, h0+h1)

                   xstack=inputs=9:layout=0_0|0_h0|0_h0+h1|w0_0|w0_h0|w0_h0+h1|w0+w3_0|w0+w3_h0|w0+w3_h0+h1

           Note that if inputs are of different sizes, gaps or overlaps may occur.

       •   Display 16 inputs into 4x4 grid.

           Layout:

                   input1(0, 0)       | input5(w0, 0)       | input9 (w0+w4, 0)       | input13(w0+w4+w8, 0)
                   input2(0, h0)      | input6(w0, h0)      | input10(w0+w4, h0)      | input14(w0+w4+w8, h0)
                   input3(0, h0+h1)   | input7(w0, h0+h1)   | input11(w0+w4, h0+h1)   | input15(w0+w4+w8, h0+h1)
                   input4(0, h0+h1+h2)| input8(w0, h0+h1+h2)| input12(w0+w4, h0+h1+h2)| input16(w0+w4+w8, h0+h1+h2)

                   xstack=inputs=16:layout=0_0|0_h0|0_h0+h1|0_h0+h1+h2|w0_0|w0_h0|w0_h0+h1|w0_h0+h1+h2|w0+w4_0|
                   w0+w4_h0|w0+w4_h0+h1|w0+w4_h0+h1+h2|w0+w4+w8_0|w0+w4+w8_h0|w0+w4+w8_h0+h1|w0+w4+w8_h0+h1+h2

           Note that if inputs are of different sizes, gaps or overlaps may occur.

   <b>yadif</b>
       Deinterlace the input video ("yadif" means "yet another deinterlacing filter").

       It accepts the following parameters:

       <b>mode</b>
           The interlacing mode to adopt. It accepts one of the following values:

           <b>0,</b> <b>send_frame</b>
               Output one frame for each frame.

           <b>1,</b> <b>send_field</b>
               Output one frame for each field.

           <b>2,</b> <b>send_frame_nospatial</b>
               Like "send_frame", but it skips the spatial interlacing check.

           <b>3,</b> <b>send_field_nospatial</b>
               Like "send_field", but it skips the spatial interlacing check.

           The default value is "send_frame".

       <b>parity</b>
           The picture field parity assumed for the input interlaced video. It  accepts  one  of  the  following
           values:

           <b>0,</b> <b>tff</b>
               Assume the top field is first.

           <b>1,</b> <b>bff</b>
               Assume the bottom field is first.

           <b>-1,</b> <b>auto</b>
               Enable automatic detection of field parity.

           The  default  value  is  "auto".   If  the interlacing is unknown or the decoder does not export this
           information, top field first will be assumed.

       <b>deint</b>
           Specify which frames to deinterlace. Accepts one of the following values:

           <b>0,</b> <b>all</b>
               Deinterlace all frames.

           <b>1,</b> <b>interlaced</b>
               Only deinterlace frames marked as interlaced.

           The default value is "all".

   <b>yadif_cuda</b>
       Deinterlace the input video using the <b>yadif</b> algorithm, but implemented in CUDA so that  it  can  work  as
       part of a GPU accelerated pipeline with nvdec and/or nvenc.

       It accepts the following parameters:

       <b>mode</b>
           The interlacing mode to adopt. It accepts one of the following values:

           <b>0,</b> <b>send_frame</b>
               Output one frame for each frame.

           <b>1,</b> <b>send_field</b>
               Output one frame for each field.

           <b>2,</b> <b>send_frame_nospatial</b>
               Like "send_frame", but it skips the spatial interlacing check.

           <b>3,</b> <b>send_field_nospatial</b>
               Like "send_field", but it skips the spatial interlacing check.

           The default value is "send_frame".

       <b>parity</b>
           The  picture  field  parity  assumed  for the input interlaced video. It accepts one of the following
           values:

           <b>0,</b> <b>tff</b>
               Assume the top field is first.

           <b>1,</b> <b>bff</b>
               Assume the bottom field is first.

           <b>-1,</b> <b>auto</b>
               Enable automatic detection of field parity.

           The default value is "auto".  If the interlacing is unknown or  the  decoder  does  not  export  this
           information, top field first will be assumed.

       <b>deint</b>
           Specify which frames to deinterlace. Accepts one of the following values:

           <b>0,</b> <b>all</b>
               Deinterlace all frames.

           <b>1,</b> <b>interlaced</b>
               Only deinterlace frames marked as interlaced.

           The default value is "all".

   <b>yaepblur</b>
       Apply  blur  filter  while preserving edges ("yaepblur" means "yet another edge preserving blur filter").
       The algorithm is described in "J. S. Lee, Digital image enhancement and noise filtering by use  of  local
       statistics, IEEE Trans. Pattern Anal. Mach. Intell. PAMI-2, 1980."

       It accepts the following parameters:

       <b>radius,</b> <b>r</b>
           Set the window radius. Default value is 3.

       <b>planes,</b> <b>p</b>
           Set which planes to filter. Default is only the first plane.

       <b>sigma,</b> <b>s</b>
           Set blur strength. Default value is 128.

       <u>Commands</u>

       This filter supports same <b>commands</b> as options.

   <b>zoompan</b>
       Apply Zoom &amp; Pan effect.

       This filter accepts the following options:

       <b>zoom,</b> <b>z</b>
           Set the zoom expression. Range is 1-10. Default is 1.

       <b>x</b>
       <b>y</b>   Set the x and y expression. Default is 0.

       <b>d</b>   Set the duration expression in number of frames.  This sets for how many number of frames effect will
           last for single input image. Default is 90.

       <b>s</b>   Set the output image size, default is 'hd720'.

       <b>fps</b> Set the output frame rate, default is '25'.

       Each expression can contain the following constants:

       <b>in_w,</b> <b>iw</b>
           Input width.

       <b>in_h,</b> <b>ih</b>
           Input height.

       <b>out_w,</b> <b>ow</b>
           Output width.

       <b>out_h,</b> <b>oh</b>
           Output height.

       <b>in</b>  Input frame count.

       <b>on</b>  Output frame count.

       <b>in_time,</b> <b>it</b>
           The input timestamp expressed in seconds. It's NAN if the input timestamp is unknown.

       <b>out_time,</b> <b>time,</b> <b>ot</b>
           The output timestamp expressed in seconds.

       <b>x</b>
       <b>y</b>   Last calculated 'x' and 'y' position from 'x' and 'y' expression for current input frame.

       <b>px</b>
       <b>py</b>  'x'  and  'y'  of  last  output  frame of previous input frame or 0 when there was not yet such frame
           (first input frame).

       <b>zoom</b>
           Last calculated zoom from 'z' expression for current input frame.

       <b>pzoom</b>
           Last calculated zoom of last output frame of previous input frame.

       <b>duration</b>
           Number of output frames for current input frame. Calculated from 'd' expression for each input frame.

       <b>pduration</b>
           number of output frames created for previous input frame

       <b>a</b>   Rational number: input width / input height

       <b>sar</b> sample aspect ratio

       <b>dar</b> display aspect ratio

       <u>Examples</u>

       •   Zoom in up to 1.5x and pan at same time to some spot near center of picture:

                   zoompan=z='min(zoom+0.0015,1.5)':d=700:x='if(gte(zoom,1.5),x,x+1/a)':y='if(gte(zoom,1.5),y,y+1)':s=640x360

       •   Zoom in up to 1.5x and pan always at center of picture:

                   zoompan=z='min(zoom+0.0015,1.5)':d=700:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)'

       •   Same as above but without pausing:

                   zoompan=z='min(max(zoom,pzoom)+0.0015,1.5)':d=1:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)'

       •   Zoom in 2x into center of picture only for the first second of the input video:

                   zoompan=z='if(between(in_time,0,1),2,1)':d=1:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)'

   <b>zscale</b>
       Scale (resize) the input video, using the z.lib library: &lt;<b>https://github.com/sekrit-twc/zimg</b>&gt;. To  enable
       compilation of this filter, you need to configure FFmpeg with "--enable-libzimg".

       The  zscale  filter  forces  the output display aspect ratio to be the same as the input, by changing the
       output sample aspect ratio.

       If the input image format is different from the format requested by the next filter,  the  zscale  filter
       will convert the input to the requested format.

       <u>Options</u>

       The filter accepts the following options.

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           Set the output video dimension expression. Default value is the input dimension.

           If  the <u>width</u> or <u>w</u> value is 0, the input width is used for the output. If the <u>height</u> or <u>h</u> value is 0,
           the input height is used for the output.

           If one and only one of the values is -n with n &gt;=  1,  the  zscale  filter  will  use  a  value  that
           maintains  the  aspect ratio of the input image, calculated from the other specified dimension. After
           that it will, however, make sure that the calculated dimension is divisible by n and adjust the value
           if necessary.

           If both values are -n with n &gt;= 1, the behavior will be identical to both values being set  to  0  as
           previously detailed.

           See below for the list of accepted constants for use in the dimension expression.

       <b>size,</b> <b>s</b>
           Set the video size. For the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b>
           <b>manual</b>.

       <b>dither,</b> <b>d</b>
           Set the dither type.

           Possible values are:

           <u>none</u>
           <u>ordered</u>
           <u>random</u>
           <u>error_diffusion</u>

           Default is none.

       <b>filter,</b> <b>f</b>
           Set the resize filter type.

           Possible values are:

           <u>point</u>
           <u>bilinear</u>
           <u>bicubic</u>
           <u>spline16</u>
           <u>spline36</u>
           <u>lanczos</u>

           Default is bilinear.

       <b>range,</b> <b>r</b>
           Set the color range.

           Possible values are:

           <u>input</u>
           <u>limited</u>
           <u>full</u>

           Default is same as input.

       <b>primaries,</b> <b>p</b>
           Set the color primaries.

           Possible values are:

           <u>input</u>
           <u>709</u>
           <u>unspecified</u>
           <u>170m</u>
           <u>240m</u>
           <u>2020</u>

           Default is same as input.

       <b>transfer,</b> <b>t</b>
           Set the transfer characteristics.

           Possible values are:

           <u>input</u>
           <u>709</u>
           <u>unspecified</u>
           <u>601</u>
           <u>linear</u>
           <u>2020_10</u>
           <u>2020_12</u>
           <u>smpte2084</u>
           <u>iec61966-2-1</u>
           <u>arib-std-b67</u>

           Default is same as input.

       <b>matrix,</b> <b>m</b>
           Set the colorspace matrix.

           Possible value are:

           <u>input</u>
           <u>709</u>
           <u>unspecified</u>
           <u>470bg</u>
           <u>170m</u>
           <u>2020_ncl</u>
           <u>2020_cl</u>

           Default is same as input.

       <b>rangein,</b> <b>rin</b>
           Set the input color range.

           Possible values are:

           <u>input</u>
           <u>limited</u>
           <u>full</u>

           Default is same as input.

       <b>primariesin,</b> <b>pin</b>
           Set the input color primaries.

           Possible values are:

           <u>input</u>
           <u>709</u>
           <u>unspecified</u>
           <u>170m</u>
           <u>240m</u>
           <u>2020</u>

           Default is same as input.

       <b>transferin,</b> <b>tin</b>
           Set the input transfer characteristics.

           Possible values are:

           <u>input</u>
           <u>709</u>
           <u>unspecified</u>
           <u>601</u>
           <u>linear</u>
           <u>2020_10</u>
           <u>2020_12</u>

           Default is same as input.

       <b>matrixin,</b> <b>min</b>
           Set the input colorspace matrix.

           Possible value are:

           <u>input</u>
           <u>709</u>
           <u>unspecified</u>
           <u>470bg</u>
           <u>170m</u>
           <u>2020_ncl</u>
           <u>2020_cl</u>
       <b>chromal,</b> <b>c</b>
           Set the output chroma location.

           Possible values are:

           <u>input</u>
           <u>left</u>
           <u>center</u>
           <u>topleft</u>
           <u>top</u>
           <u>bottomleft</u>
           <u>bottom</u>
       <b>chromalin,</b> <b>cin</b>
           Set the input chroma location.

           Possible values are:

           <u>input</u>
           <u>left</u>
           <u>center</u>
           <u>topleft</u>
           <u>top</u>
           <u>bottomleft</u>
           <u>bottom</u>
       <b>npl</b> Set the nominal peak luminance.

       <b>param_a</b>
           Parameter  A  for  scaling  filters.  Parameter  "b"  for  bicubic, and the number of filter taps for
           lanczos.

       <b>param_b</b>
           Parameter B for scaling filters. Parameter "c" for bicubic.

       The values of the <b>w</b> and <b>h</b> options are expressions containing the following constants:

       <u>in_w</u>
       <u>in_h</u>
           The input width and height

       <u>iw</u>
       <u>ih</u>  These are the same as <u>in_w</u> and <u>in_h</u>.

       <u>out_w</u>
       <u>out_h</u>
           The output (scaled) width and height

       <u>ow</u>
       <u>oh</u>  These are the same as <u>out_w</u> and <u>out_h</u>

       <u>a</u>   The same as <u>iw</u> / <u>ih</u>

       <u>sar</u> input sample aspect ratio

       <u>dar</u> The input display aspect ratio. Calculated from "(iw / ih) * sar".

       <u>hsub</u>
       <u>vsub</u>
           horizontal and vertical input chroma subsample values. For example for  the  pixel  format  "yuv422p"
           <u>hsub</u> is 2 and <u>vsub</u> is 1.

       <u>ohsub</u>
       <u>ovsub</u>
           horizontal  and  vertical  output chroma subsample values. For example for the pixel format "yuv422p"
           <u>hsub</u> is 2 and <u>vsub</u> is 1.

       <u>Commands</u>

       This filter supports the following commands:

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           Set the output video dimension expression.  The command accepts the same syntax of the  corresponding
           option.

           If the specified expression is not valid, it is kept at its current value.

</pre><h4><b>OPENCL</b> <b>VIDEO</b> <b>FILTERS</b></h4><pre>
       Below is a description of the currently available OpenCL video filters.

       To enable compilation of these filters you need to configure FFmpeg with "--enable-opencl".

       Running  OpenCL  filters  requires  you  to  initialize  a hardware device and to pass that device to all
       filters in any filter graph.

       <b>-init_hw_device</b> <b>opencl[=</b><u>name</u><b>][:</b><u>device</u><b>[,</b><u>key=value</u><b>...]]</b>
           Initialise a new hardware device of type <u>opencl</u> called <u>name</u>, using the given device parameters.

       <b>-filter_hw_device</b> <u>name</u>
           Pass the hardware device called <u>name</u> to all filters in any filter graph.

       For more detailed information see &lt;<b>https://www.ffmpeg.org/ffmpeg.html#Advanced-Video-options</b>&gt;

       •   Example of choosing the first device on the second platform and running  avgblur_opencl  filter  with
           default parameters on it.

                   -init_hw_device opencl=gpu:1.0 -filter_hw_device gpu -i INPUT -vf "hwupload, avgblur_opencl, hwdownload" OUTPUT

       Since  OpenCL  filters  are  not  able  to access frame data in normal memory, all frame data needs to be
       uploaded(<b>hwupload</b>) to hardware surfaces connected to the appropriate device before being  used  and  then
       downloaded(<b>hwdownload</b>)  back  to normal memory. Note that <b>hwupload</b> will upload to a surface with the same
       layout as the software frame, so it may be necessary to add a <b>format</b> filter immediately before to get the
       input into the right format and <b>hwdownload</b> does not support all  formats  on  the  output  -  it  may  be
       necessary to insert an additional <b>format</b> filter immediately following in the graph to get the output in a
       supported format.

   <b>avgblur_opencl</b>
       Apply average blur filter.

       The filter accepts the following options:

       <b>sizeX</b>
           Set horizontal radius size.  Range is "[1, 1024]" and default value is 1.

       <b>planes</b>
           Set which planes to filter. Default value is 0xf, by which all planes are processed.

       <b>sizeY</b>
           Set vertical radius size. Range is "[1, 1024]" and default value is 0. If zero, "sizeX" value will be
           used.

       <u>Example</u>

       •   Apply average blur filter with horizontal and vertical size of 3, setting each pixel of the output to
           the  average  value  of  the  7x7  region centered on it in the input. For pixels on the edges of the
           image, the region does not extend beyond the image boundaries, and so  out-of-range  coordinates  are
           not used in the calculations.

                   -i INPUT -vf "hwupload, avgblur_opencl=3, hwdownload" OUTPUT

   <b>boxblur_opencl</b>
       Apply a boxblur algorithm to the input video.

       It accepts the following parameters:

       <b>luma_radius,</b> <b>lr</b>
       <b>luma_power,</b> <b>lp</b>
       <b>chroma_radius,</b> <b>cr</b>
       <b>chroma_power,</b> <b>cp</b>
       <b>alpha_radius,</b> <b>ar</b>
       <b>alpha_power,</b> <b>ap</b>

       A description of the accepted options follows.

       <b>luma_radius,</b> <b>lr</b>
       <b>chroma_radius,</b> <b>cr</b>
       <b>alpha_radius,</b> <b>ar</b>
           Set an expression for the box radius in pixels used for blurring the corresponding input plane.

           The  radius  value  must  be  a  non-negative  number,  and must not be greater than the value of the
           expression "min(w,h)/2" for the luma and alpha planes, and of "min(cw,ch)/2" for the chroma planes.

           Default value for <b>luma_radius</b> is "2". If not specified, <b>chroma_radius</b> and <b>alpha_radius</b> default to the
           corresponding value set for <b>luma_radius</b>.

           The expressions can contain the following constants:

           <b>w</b>
           <b>h</b>   The input width and height in pixels.

           <b>cw</b>
           <b>ch</b>  The input chroma image width and height in pixels.

           <b>hsub</b>
           <b>vsub</b>
               The horizontal and vertical chroma subsample values. For example, for the pixel format "yuv422p",
               <u>hsub</u> is 2 and <u>vsub</u> is 1.

       <b>luma_power,</b> <b>lp</b>
       <b>chroma_power,</b> <b>cp</b>
       <b>alpha_power,</b> <b>ap</b>
           Specify how many times the boxblur filter is applied to the corresponding plane.

           Default value for <b>luma_power</b> is 2. If not specified, <b>chroma_power</b>  and  <b>alpha_power</b>  default  to  the
           corresponding value set for <b>luma_power</b>.

           A value of 0 will disable the effect.

       <u>Examples</u>

       Apply  boxblur filter, setting each pixel of the output to the average value of box-radiuses <u>luma_radius</u>,
       <u>chroma_radius</u>, <u>alpha_radius</u> for each plane respectively. The filter will apply <u>luma_power</u>,  <u>chroma_power</u>,
       <u>alpha_power</u> times onto the corresponding plane. For pixels on the edges of the image, the radius does not
       extend beyond the image boundaries, and so out-of-range coordinates are not used in the calculations.

       •   Apply  a  boxblur filter with the luma, chroma, and alpha radius set to 2 and luma, chroma, and alpha
           power set to 3. The filter will run 3 times with box-radius set to 2 for every plane of the image.

                   -i INPUT -vf "hwupload, boxblur_opencl=luma_radius=2:luma_power=3, hwdownload" OUTPUT
                   -i INPUT -vf "hwupload, boxblur_opencl=2:3, hwdownload" OUTPUT

       •   Apply a boxblur filter with luma radius set to 2, luma_power to 1, chroma_radius to  4,  chroma_power
           to 5, alpha_radius to 3 and alpha_power to 7.

           For the luma plane, a 2x2 box radius will be run once.

           For the chroma plane, a 4x4 box radius will be run 5 times.

           For the alpha plane, a 3x3 box radius will be run 7 times.

                   -i INPUT -vf "hwupload, boxblur_opencl=2:1:4:5:3:7, hwdownload" OUTPUT

   <b>colorkey_opencl</b>
       RGB colorspace color keying.

       The filter accepts the following options:

       <b>color</b>
           The color which will be replaced with transparency.

       <b>similarity</b>
           Similarity percentage with the key color.

           0.01 matches only the exact key color, while 1.0 matches everything.

       <b>blend</b>
           Blend percentage.

           0.0 makes pixels either fully transparent, or not transparent at all.

           Higher  values  result  in  semi-transparent  pixels, with a higher transparency the more similar the
           pixels color is to the key color.

       <u>Examples</u>

       •   Make every semi-green pixel in the input transparent with some slight blending:

                   -i INPUT -vf "hwupload, colorkey_opencl=green:0.3:0.1, hwdownload" OUTPUT

   <b>convolution_opencl</b>
       Apply convolution of 3x3, 5x5, 7x7 matrix.

       The filter accepts the following options:

       <b>0m</b>
       <b>1m</b>
       <b>2m</b>
       <b>3m</b>  Set matrix for each plane.  Matrix is sequence of 9, 25 or 49 signed numbers.  Default value for each
           plane is "0 0 0 0 1 0 0 0 0".

       <b>0rdiv</b>
       <b>1rdiv</b>
       <b>2rdiv</b>
       <b>3rdiv</b>
           Set multiplier for calculated value for each plane.  If unset or 0, it will  be  sum  of  all  matrix
           elements.  The option value must be a float number greater or equal to 0.0. Default value is 1.0.

       <b>0bias</b>
       <b>1bias</b>
       <b>2bias</b>
       <b>3bias</b>
           Set  bias for each plane. This value is added to the result of the multiplication.  Useful for making
           the overall image brighter or darker.  The option value must be a float number greater  or  equal  to
           0.0. Default value is 0.0.

       <u>Examples</u>

       •   Apply sharpen:

                   -i INPUT -vf "hwupload, convolution_opencl=0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1 5 -1 0 -1 0, hwdownload" OUTPUT

       •   Apply blur:

                   -i INPUT -vf "hwupload, convolution_opencl=1 1 1 1 1 1 1 1 1:1 1 1 1 1 1 1 1 1:1 1 1 1 1 1 1 1 1:1 1 1 1 1 1 1 1 1:1/9:1/9:1/9:1/9, hwdownload" OUTPUT

       •   Apply edge enhance:

                   -i INPUT -vf "hwupload, convolution_opencl=0 0 0 -1 1 0 0 0 0:0 0 0 -1 1 0 0 0 0:0 0 0 -1 1 0 0 0 0:0 0 0 -1 1 0 0 0 0:5:1:1:1:0:128:128:128, hwdownload" OUTPUT

       •   Apply edge detect:

                   -i INPUT -vf "hwupload, convolution_opencl=0 1 0 1 -4 1 0 1 0:0 1 0 1 -4 1 0 1 0:0 1 0 1 -4 1 0 1 0:0 1 0 1 -4 1 0 1 0:5:5:5:1:0:128:128:128, hwdownload" OUTPUT

       •   Apply laplacian edge detector which includes diagonals:

                   -i INPUT -vf "hwupload, convolution_opencl=1 1 1 1 -8 1 1 1 1:1 1 1 1 -8 1 1 1 1:1 1 1 1 -8 1 1 1 1:1 1 1 1 -8 1 1 1 1:5:5:5:1:0:128:128:0, hwdownload" OUTPUT

       •   Apply emboss:

                   -i INPUT -vf "hwupload, convolution_opencl=-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2, hwdownload" OUTPUT

   <b>erosion_opencl</b>
       Apply erosion effect to the video.

       This filter replaces the pixel by the <a href="../man3x3/local.3x3.html">local</a>(3x3) minimum.

       It accepts the following options:

       <b>threshold0</b>
       <b>threshold1</b>
       <b>threshold2</b>
       <b>threshold3</b>
           Limit  the  maximum  change  for each plane. Range is "[0, 65535]" and default value is 65535.  If 0,
           plane will remain unchanged.

       <b>coordinates</b>
           Flag which specifies the pixel to refer to.  Range is "[0, 255]" and default value is 255,  i.e.  all
           eight pixels are used.

           Flags to local 3x3 coordinates region centered on "x":

               1 2 3

               4 x 5

               6 7 8

       <u>Example</u>

       •   Apply  erosion  filter  with  threshold0  set  to  30,  threshold1  set  40, threshold2 set to 50 and
           coordinates set to 231, setting each pixel of the output to the local minimum between pixels:  1,  2,
           3,  6,  7, 8 of the 3x3 region centered on it in the input. If the difference between input pixel and
           local minimum is more then threshold of the corresponding plane, output pixel will be  set  to  input
           pixel - threshold of corresponding plane.

                   -i INPUT -vf "hwupload, erosion_opencl=30:40:50:coordinates=231, hwdownload" OUTPUT

   <b>deshake_opencl</b>
       Feature-point based video stabilization filter.

       The filter accepts the following options:

       <b>tripod</b>
           Simulates  a tripod by preventing any camera movement whatsoever from the original frame. Defaults to
           0.

       <b>debug</b>
           Whether or not additional debug info should be displayed, both in the processed  output  and  in  the
           console.

           Note that in order to see console debug output you will also need to pass "-v verbose" to ffmpeg.

           Viewing point matches in the output video is only supported for RGB input.

           Defaults to 0.

       <b>adaptive_crop</b>
           Whether  or  not  to  do  a tiny bit of cropping at the borders to cut down on the amount of mirrored
           pixels.

           Defaults to 1.

       <b>refine_features</b>
           Whether or not feature points should be refined at a sub-pixel level.

           This can be turned off for a slight performance gain at the cost of precision.

           Defaults to 1.

       <b>smooth_strength</b>
           The strength of the smoothing applied to the camera path from 0.0 to 1.0.

           1.0 is the maximum smoothing strength while values less than that result in less smoothing.

           0.0 causes the filter to adaptively choose a smoothing strength on a per-frame basis.

           Defaults to 0.0.

       <b>smooth_window_multiplier</b>
           Controls the size of the smoothing  window  (the  number  of  frames  buffered  to  determine  motion
           information from).

           The  size  of  the  smoothing  window is determined by multiplying the framerate of the video by this
           number.

           Acceptable values range from 0.1 to 10.0.

           Larger values increase the amount of motion data available for determining how to smooth  the  camera
           path, potentially improving smoothness, but also increase latency and memory usage.

           Defaults to 2.0.

       <u>Examples</u>

       •   Stabilize a video with a fixed, medium smoothing strength:

                   -i INPUT -vf "hwupload, deshake_opencl=smooth_strength=0.5, hwdownload" OUTPUT

       •   Stabilize a video with debugging (both in console and in rendered video):

                   -i INPUT -filter_complex "[0:v]format=rgba, hwupload, deshake_opencl=debug=1, hwdownload, format=rgba, format=yuv420p" -v verbose OUTPUT

   <b>dilation_opencl</b>
       Apply dilation effect to the video.

       This filter replaces the pixel by the <a href="../man3x3/local.3x3.html">local</a>(3x3) maximum.

       It accepts the following options:

       <b>threshold0</b>
       <b>threshold1</b>
       <b>threshold2</b>
       <b>threshold3</b>
           Limit  the  maximum  change  for each plane. Range is "[0, 65535]" and default value is 65535.  If 0,
           plane will remain unchanged.

       <b>coordinates</b>
           Flag which specifies the pixel to refer to.  Range is "[0, 255]" and default value is 255,  i.e.  all
           eight pixels are used.

           Flags to local 3x3 coordinates region centered on "x":

               1 2 3

               4 x 5

               6 7 8

       <u>Example</u>

       •   Apply  dilation  filter  with  threshold0  set  to  30,  threshold1  set 40, threshold2 set to 50 and
           coordinates set to 231, setting each pixel of the output to the local maximum between pixels:  1,  2,
           3,  6,  7, 8 of the 3x3 region centered on it in the input. If the difference between input pixel and
           local maximum is more then threshold of the corresponding plane, output pixel will be  set  to  input
           pixel + threshold of corresponding plane.

                   -i INPUT -vf "hwupload, dilation_opencl=30:40:50:coordinates=231, hwdownload" OUTPUT

   <b>nlmeans_opencl</b>
       Non-local Means denoise filter through OpenCL, this filter accepts same options as <b>nlmeans</b>.

   <b>overlay_opencl</b>
       Overlay one video on top of another.

       It  takes two inputs and has one output. The first input is the "main" video on which the second input is
       overlaid.  This filter requires same memory layout for all the  inputs.  So,  format  conversion  may  be
       needed.

       The filter accepts the following options:

       <b>x</b>   Set the x coordinate of the overlaid video on the main video.  Default value is 0.

       <b>y</b>   Set the y coordinate of the overlaid video on the main video.  Default value is 0.

       <u>Examples</u>

       •   Overlay an image LOGO at the top-left corner of the INPUT video. Both inputs are yuv420p format.

                   -i INPUT -i LOGO -filter_complex "[0:v]hwupload[a], [1:v]format=yuv420p, hwupload[b], [a][b]overlay_opencl, hwdownload" OUTPUT

       •   The  inputs have same memory layout for color channels , the overlay has additional alpha plane, like
           INPUT is yuv420p, and the LOGO is yuva420p.

                   -i INPUT -i LOGO -filter_complex "[0:v]hwupload[a], [1:v]format=yuva420p, hwupload[b], [a][b]overlay_opencl, hwdownload" OUTPUT

   <b>pad_opencl</b>
       Add paddings to the input image, and place the original input at the provided <u>x</u>, <u>y</u> coordinates.

       It accepts the following options:

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           Specify an expression for the size of the output image with the paddings  added.  If  the  value  for
           <u>width</u> or <u>height</u> is 0, the corresponding input size is used for the output.

           The <u>width</u> expression can reference the value set by the <u>height</u> expression, and vice versa.

           The default value of <u>width</u> and <u>height</u> is 0.

       <b>x</b>
       <b>y</b>   Specify  the offsets to place the input image at within the padded area, with respect to the top/left
           border of the output image.

           The <u>x</u> expression can reference the value set by the <u>y</u> expression, and vice versa.

           The default value of <u>x</u> and <u>y</u> is 0.

           If <u>x</u> or <u>y</u> evaluate to a negative number, they'll be changed so the input image  is  centered  on  the
           padded area.

       <b>color</b>
           Specify the color of the padded area. For the syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b>
           <b>ffmpeg-utils</b> <b>manual</b>.

       <b>aspect</b>
           Pad to an aspect instead to a resolution.

       The value for the <u>width</u>, <u>height</u>, <u>x</u>, and <u>y</u> options are expressions containing the following constants:

       <b>in_w</b>
       <b>in_h</b>
           The input video width and height.

       <b>iw</b>
       <b>ih</b>  These are the same as <u>in_w</u> and <u>in_h</u>.

       <b>out_w</b>
       <b>out_h</b>
           The  output  width  and  height  (the  size of the padded area), as specified by the <u>width</u> and <u>height</u>
           expressions.

       <b>ow</b>
       <b>oh</b>  These are the same as <u>out_w</u> and <u>out_h</u>.

       <b>x</b>
       <b>y</b>   The x and y offsets as specified by the <u>x</u> and <u>y</u> expressions, or NAN if not yet specified.

       <b>a</b>   same as <u>iw</u> / <u>ih</u>

       <b>sar</b> input sample aspect ratio

       <b>dar</b> input display aspect ratio, it is the same as (<u>iw</u> / <u>ih</u>) * <u>sar</u>

   <b>prewitt_opencl</b>
       Apply the Prewitt operator (&lt;<b>https://en.wikipedia.org/wiki/Prewitt_operator</b>&gt;) to input video stream.

       The filter accepts the following option:

       <b>planes</b>
           Set which planes to filter. Default value is 0xf, by which all planes are processed.

       <b>scale</b>
           Set value which will be multiplied with filtered result.  Range is "[0.0, 65535]" and  default  value
           is 1.0.

       <b>delta</b>
           Set  value  which  will be added to filtered result.  Range is "[-65535, 65535]" and default value is
           0.0.

       <u>Example</u>

       •   Apply the Prewitt operator with scale set to 2 and delta set to 10.

                   -i INPUT -vf "hwupload, prewitt_opencl=scale=2:delta=10, hwdownload" OUTPUT

   <b>program_opencl</b>
       Filter video using an OpenCL program.

       <b>source</b>
           OpenCL program source file.

       <b>kernel</b>
           Kernel name in program.

       <b>inputs</b>
           Number of inputs to the filter.  Defaults to 1.

       <b>size,</b> <b>s</b>
           Size of output frames.  Defaults to the same as the first input.

       The "program_opencl" filter also supports the <b>framesync</b> options.

       The program source file must contain a kernel function with the given name, which will be  run  once  for
       each  plane  of  the  output.  Each run on a plane gets enqueued as a separate 2D global NDRange with one
       work-item for each pixel to be generated.  The global ID offset  for  each  work-item  is  therefore  the
       coordinates of a pixel in the destination image.

       The kernel function needs to take the following arguments:

       •   Destination image, <b>__</b><u>write_only</u> <u>image2d_t</u>.

           This image will become the output; the kernel should write all of it.

       •   Frame index, <u>unsigned</u> <u>int</u>.

           This is a counter starting from zero and increasing by one for each frame.

       •   Source images, <b>__</b><u>read_only</u> <u>image2d_t</u>.

           These  are  the  most  recent  images  on  each input.  The kernel may read from them to generate the
           output, but they can't be written to.

       Example programs:

       •   Copy the input to the output (output must be the same size as the input).

                   __kernel void copy(__write_only image2d_t destination,
                                      unsigned int index,
                                      __read_only  image2d_t source)
                   {
                       const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE;

                       int2 location = (int2)(<a href="../man0/get_global_id.0.html">get_global_id</a>(0), <a href="../man1/get_global_id.1.html">get_global_id</a>(1));

                       float4 value = read_imagef(source, sampler, location);

                       write_imagef(destination, location, value);
                   }

       •   Apply a simple transformation, rotating the input by an amount increasing  with  the  index  counter.
           Pixel  values  are  linearly  interpolated  by  the  sampler,  and  the output need not have the same
           dimensions as the input.

                   __kernel void rotate_image(__write_only image2d_t dst,
                                              unsigned int index,
                                              __read_only  image2d_t src)
                   {
                       const sampler_t sampler = (CLK_NORMALIZED_COORDS_FALSE |
                                                  CLK_FILTER_LINEAR);

                       float angle = (float)index / 100.0f;

                       float2 dst_dim = convert_float2(get_image_dim(dst));
                       float2 src_dim = convert_float2(get_image_dim(src));

                       float2 dst_cen = dst_dim / 2.0f;
                       float2 src_cen = src_dim / 2.0f;

                       int2   dst_loc = (int2)(<a href="../man0/get_global_id.0.html">get_global_id</a>(0), <a href="../man1/get_global_id.1.html">get_global_id</a>(1));

                       float2 dst_pos = convert_float2(dst_loc) - dst_cen;
                       float2 src_pos = {
                           cos(angle) * dst_pos.x - sin(angle) * dst_pos.y,
                           sin(angle) * dst_pos.x + cos(angle) * dst_pos.y
                       };
                       src_pos = src_pos * src_dim / dst_dim;

                       float2 src_loc = src_pos + src_cen;

                       if (src_loc.x &lt; 0.0f      || src_loc.y &lt; 0.0f ||
                           src_loc.x &gt; src_dim.x || src_loc.y &gt; src_dim.y)
                           write_imagef(dst, dst_loc, 0.5f);
                       else
                           write_imagef(dst, dst_loc, read_imagef(src, sampler, src_loc));
                   }

       •   Blend two inputs together, with the amount of each input used varying with the index counter.

                   __kernel void blend_images(__write_only image2d_t dst,
                                              unsigned int index,
                                              __read_only  image2d_t src1,
                                              __read_only  image2d_t src2)
                   {
                       const sampler_t sampler = (CLK_NORMALIZED_COORDS_FALSE |
                                                  CLK_FILTER_LINEAR);

                       float blend = (cos((float)index / 50.0f) + 1.0f) / 2.0f;

                       int2  dst_loc = (int2)(<a href="../man0/get_global_id.0.html">get_global_id</a>(0), <a href="../man1/get_global_id.1.html">get_global_id</a>(1));
                       int2 src1_loc = dst_loc * get_image_dim(src1) / get_image_dim(dst);
                       int2 src2_loc = dst_loc * get_image_dim(src2) / get_image_dim(dst);

                       float4 val1 = read_imagef(src1, sampler, src1_loc);
                       float4 val2 = read_imagef(src2, sampler, src2_loc);

                       write_imagef(dst, dst_loc, val1 * blend + val2 * (1.0f - blend));
                   }

   <b>remap_opencl</b>
       Remap pixels using 2nd: Xmap and 3rd: Ymap input video stream.

       Destination pixel at position (X, Y) will be picked from source (x, y) position where x = Xmap(X, Y)  and
       y  =  Ymap(X,  Y).  If mapping values are out of range, zero value for pixel will be used for destination
       pixel.

       Xmap and Ymap input video streams must be of same dimensions. Output video  stream  will  have  Xmap/Ymap
       video stream dimensions.  Xmap and Ymap input video streams are 32bit float pixel format, single channel.

       <b>interp</b>
           Specify interpolation used for remapping of pixels.  Allowed values are "near" and "linear".  Default
           value is "linear".

       <b>fill</b>
           Specify the color of the unmapped pixels. For the syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b>
           <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>. Default color is "black".

   <b>roberts_opencl</b>
       Apply the Roberts cross operator (&lt;<b>https://en.wikipedia.org/wiki/Roberts_cross</b>&gt;) to input video stream.

       The filter accepts the following option:

       <b>planes</b>
           Set which planes to filter. Default value is 0xf, by which all planes are processed.

       <b>scale</b>
           Set  value  which will be multiplied with filtered result.  Range is "[0.0, 65535]" and default value
           is 1.0.

       <b>delta</b>
           Set value which will be added to filtered result.  Range is "[-65535, 65535]" and  default  value  is
           0.0.

       <u>Example</u>

       •   Apply the Roberts cross operator with scale set to 2 and delta set to 10

                   -i INPUT -vf "hwupload, roberts_opencl=scale=2:delta=10, hwdownload" OUTPUT

   <b>sobel_opencl</b>
       Apply the Sobel operator (&lt;<b>https://en.wikipedia.org/wiki/Sobel_operator</b>&gt;) to input video stream.

       The filter accepts the following option:

       <b>planes</b>
           Set which planes to filter. Default value is 0xf, by which all planes are processed.

       <b>scale</b>
           Set  value  which will be multiplied with filtered result.  Range is "[0.0, 65535]" and default value
           is 1.0.

       <b>delta</b>
           Set value which will be added to filtered result.  Range is "[-65535, 65535]" and  default  value  is
           0.0.

       <u>Example</u>

       •   Apply sobel operator with scale set to 2 and delta set to 10

                   -i INPUT -vf "hwupload, sobel_opencl=scale=2:delta=10, hwdownload" OUTPUT

   <b>tonemap_opencl</b>
       Perform HDR(PQ/HLG) to SDR conversion with tone-mapping.

       It accepts the following parameters:

       <b>tonemap</b>
           Specify the tone-mapping operator to be used. Same as tonemap option in <b>tonemap</b>.

       <b>param</b>
           Tune the tone mapping algorithm. same as param option in <b>tonemap</b>.

       <b>desat</b>
           Apply desaturation for highlights that exceed this level of brightness. The higher the parameter, the
           more color information will be preserved. This setting helps prevent unnaturally blown-out colors for
           super-highlights,  by  (smoothly) turning into white instead. This makes images feel more natural, at
           the cost of reducing information about out-of-range colors.

           The default value is 0.5, and the algorithm here is a little different from the cpu  version  tonemap
           currently. A setting of 0.0 disables this option.

       <b>threshold</b>
           The  tonemapping algorithm parameters is fine-tuned per each scene. And a threshold is used to detect
           whether the scene has changed or not. If the distance between the current  frame  average  brightness
           and  the  current  running average exceeds a threshold value, we would re-calculate scene average and
           peak brightness.  The default value is 0.2.

       <b>format</b>
           Specify the output pixel format.

           Currently supported formats are:

           <u>p010</u>
           <u>nv12</u>
       <b>range,</b> <b>r</b>
           Set the output color range.

           Possible values are:

           <u>tv/mpeg</u>
           <u>pc/jpeg</u>

           Default is same as input.

       <b>primaries,</b> <b>p</b>
           Set the output color primaries.

           Possible values are:

           <u>bt709</u>
           <u>bt2020</u>

           Default is same as input.

       <b>transfer,</b> <b>t</b>
           Set the output transfer characteristics.

           Possible values are:

           <u>bt709</u>
           <u>bt2020</u>

           Default is bt709.

       <b>matrix,</b> <b>m</b>
           Set the output colorspace matrix.

           Possible value are:

           <u>bt709</u>
           <u>bt2020</u>

           Default is same as input.

       <u>Example</u>

       •   Convert HDR(PQ/HLG) video to bt2020-transfer-characteristic p010 format using linear operator.

                   -i INPUT -vf "format=p010,hwupload,tonemap_opencl=t=bt2020:tonemap=linear:format=p010,hwdownload,format=p010" OUTPUT

   <b>unsharp_opencl</b>
       Sharpen or blur the input video.

       It accepts the following parameters:

       <b>luma_msize_x,</b> <b>lx</b>
           Set the luma matrix horizontal size.  Range is "[1, 23]" and default value is 5.

       <b>luma_msize_y,</b> <b>ly</b>
           Set the luma matrix vertical size.  Range is "[1, 23]" and default value is 5.

       <b>luma_amount,</b> <b>la</b>
           Set the luma effect strength.  Range is "[-10, 10]" and default value is 1.0.

           Negative values will blur the input video, while positive values will sharpen it,  a  value  of  zero
           will disable the effect.

       <b>chroma_msize_x,</b> <b>cx</b>
           Set the chroma matrix horizontal size.  Range is "[1, 23]" and default value is 5.

       <b>chroma_msize_y,</b> <b>cy</b>
           Set the chroma matrix vertical size.  Range is "[1, 23]" and default value is 5.

       <b>chroma_amount,</b> <b>ca</b>
           Set the chroma effect strength.  Range is "[-10, 10]" and default value is 0.0.

           Negative  values  will  blur  the input video, while positive values will sharpen it, a value of zero
           will disable the effect.

       All parameters are optional and default to the equivalent of the string '5:5:1.0:5:5:0.0'.

       <u>Examples</u>

       •   Apply strong luma sharpen effect:

                   -i INPUT -vf "hwupload, unsharp_opencl=luma_msize_x=7:luma_msize_y=7:luma_amount=2.5, hwdownload" OUTPUT

       •   Apply a strong blur of both luma and chroma parameters:

                   -i INPUT -vf "hwupload, unsharp_opencl=7:7:-2:7:7:-2, hwdownload" OUTPUT

   <b>xfade_opencl</b>
       Cross fade two videos with custom transition effect by using OpenCL.

       It accepts the following options:

       <b>transition</b>
           Set one of possible transition effects.

           <b>custom</b>
               Select custom transition effect, the actual transition description will be picked from source and
               kernel options.

           <b>fade</b>
           <b>wipeleft</b>
           <b>wiperight</b>
           <b>wipeup</b>
           <b>wipedown</b>
           <b>slideleft</b>
           <b>slideright</b>
           <b>slideup</b>
           <b>slidedown</b>
               Default transition is fade.

       <b>source</b>
           OpenCL program source file for custom transition.

       <b>kernel</b>
           Set name of kernel to use for custom transition from program source file.

       <b>duration</b>
           Set duration of video transition.

       <b>offset</b>
           Set time of start of transition relative to first video.

       The program source file must contain a kernel function with the given name, which will be  run  once  for
       each  plane  of  the  output.  Each run on a plane gets enqueued as a separate 2D global NDRange with one
       work-item for each pixel to be generated.  The global ID offset  for  each  work-item  is  therefore  the
       coordinates of a pixel in the destination image.

       The kernel function needs to take the following arguments:

       •   Destination image, <b>__</b><u>write_only</u> <u>image2d_t</u>.

           This image will become the output; the kernel should write all of it.

       •   First Source image, <b>__</b><u>read_only</u> <u>image2d_t</u>.  Second Source image, <b>__</b><u>read_only</u> <u>image2d_t</u>.

           These  are  the  most  recent  images  on  each input.  The kernel may read from them to generate the
           output, but they can't be written to.

       •   Transition progress, <u>float</u>. This value is always between 0 and 1 inclusive.

       Example programs:

       •   Apply dots curtain transition effect:

                   __kernel void blend_images(__write_only image2d_t dst,
                                              __read_only  image2d_t src1,
                                              __read_only  image2d_t src2,
                                              float progress)
                   {
                       const sampler_t sampler = (CLK_NORMALIZED_COORDS_FALSE |
                                                  CLK_FILTER_LINEAR);
                       int2  p = (int2)(<a href="../man0/get_global_id.0.html">get_global_id</a>(0), <a href="../man1/get_global_id.1.html">get_global_id</a>(1));
                       float2 rp = (float2)(<a href="../man0/get_global_id.0.html">get_global_id</a>(0), <a href="../man1/get_global_id.1.html">get_global_id</a>(1));
                       float2 dim = (float2)(get_image_dim(src1).x, get_image_dim(src1).y);
                       rp = rp / dim;

                       float2 dots = (float2)(20.0, 20.0);
                       float2 center = (float2)(0,0);
                       float2 unused;

                       float4 val1 = read_imagef(src1, sampler, p);
                       float4 val2 = read_imagef(src2, sampler, p);
                       bool next = distance(fract(rp * dots, &amp;unused), (float2)(0.5, 0.5)) &lt; (progress / distance(rp, center));

                       write_imagef(dst, p, next ? val1 : val2);
                   }

</pre><h4><b>VAAPI</b> <b>VIDEO</b> <b>FILTERS</b></h4><pre>
       VAAPI Video filters are usually used with VAAPI decoder and VAAPI encoder.  Below  is  a  description  of
       VAAPI video filters.

       To enable compilation of these filters you need to configure FFmpeg with "--enable-vaapi".

       To  use  vaapi  filters,  you need to setup the vaapi device correctly. For more information, please read
       &lt;<b>https://trac.ffmpeg.org/wiki/Hardware/VAAPI</b>&gt;

   <b>overlay_vaapi</b>
       Overlay one video on the top of another.

       It takes two inputs and has one output. The first input is the "main" video on which the second input  is
       overlaid.

       The filter accepts the following options:

       <b>x</b>
       <b>y</b>   Set expressions for the x and y coordinates of the overlaid video on the main video.

           Default value is "0" for both expressions.

       <b>w</b>
       <b>h</b>   Set expressions for the width and height the overlaid video on the main video.

           Default values are 'overlay_iw' for 'w' and 'overlay_ih*w/overlay_iw' for 'h'.

           The expressions can contain the following parameters:

           <b>main_w,</b> <b>W</b>
           <b>main_h,</b> <b>H</b>
               The main input width and height.

           <b>overlay_iw</b>
           <b>overlay_ih</b>
               The overlay input width and height.

           <b>overlay_w,</b> <b>w</b>
           <b>overlay_h,</b> <b>h</b>
               The overlay output width and height.

           <b>overlay_x,</b> <b>x</b>
           <b>overlay_y,</b> <b>y</b>
               Position of the overlay layer inside of main

       <b>alpha</b>
           Set  transparency  of  overlaid  video.  Allowed  range  is  0.0  to  1.0.   Higher value means lower
           transparency.  Default value is 1.0.

       <b>eof_action</b>
           See <b>framesync</b>.

       <b>shortest</b>
           See <b>framesync</b>.

       <b>repeatlast</b>
           See <b>framesync</b>.

       This filter also supports the <b>framesync</b> options.

       <u>Examples</u>

       •   Overlay an image LOGO at the top-left corner of the INPUT video. Both  inputs  for  this  filter  are
           yuv420p format.

                   -i INPUT -i LOGO -filter_complex "[0:v]hwupload[a], [1:v]format=yuv420p, hwupload[b], [a][b]overlay_vaapi" OUTPUT

       •   Overlay  an  image  LOGO  at  the offset (200, 100) from the top-left corner of the INPUT video.  The
           inputs have same memory layout for color channels, the overlay has additional alpha plane, like INPUT
           is yuv420p, and the LOGO is yuva420p.

                   -i INPUT -i LOGO -filter_complex "[0:v]hwupload[a], [1:v]format=yuva420p, hwupload[b], [a][b]overlay_vaapi=x=200:y=100:w=400:h=300:alpha=1.0, hwdownload, format=nv12" OUTPUT

   <b>tonemap_vaapi</b>
       Perform HDR-to-SDR or HDR-to-HDR tone-mapping.  It currently only accepts HDR10 as input.

       It accepts the following parameters:

       <b>format</b>
           Specify the output pixel format.

           Default is nv12 for HDR-to-SDR tone-mapping and p010 for HDR-to-HDR tone-mapping.

       <b>primaries,</b> <b>p</b>
           Set the output color primaries.

           Default is bt709 for HDR-to-SDR tone-mapping and same as input for HDR-to-HDR tone-mapping.

       <b>transfer,</b> <b>t</b>
           Set the output transfer characteristics.

           Default is bt709 for HDR-to-SDR tone-mapping and same as input for HDR-to-HDR tone-mapping.

       <b>matrix,</b> <b>m</b>
           Set the output colorspace matrix.

           Default is bt709 for HDR-to-SDR tone-mapping and same as input for HDR-to-HDR tone-mapping.

       <b>display</b>
           Set the output mastering display colour volume. It is given by a '|'-separated list  of  two  values,
           two values are space separated. It set display primaries x &amp; y in G, B, R order, then white point x &amp;
           y, the nominal minimum &amp; maximum display luminances.

           HDR-to-HDR tone-mapping will be performed when this option is set.

       <b>light</b>
           Set  the output content light level information. It accepts 2 space-separated values, the first input
           is the maximum light level and the second input is the maximum average light level.

           It is ignored for HDR-to-SDR tone-mapping, and optional for HDR-to-HDR tone-mapping.

       <u>Example</u>

       •   Convert HDR(HDR10) video to bt2020-transfer-characteristic p010 format

                   tonemap_vaapi=format=p010:t=bt2020-10

       •   Convert HDR video to HDR video

                   tonemap_vaapi=display=7500\ 3000|34000\ 16000|13250\ 34500|15635\ 16450|500\ 10000000

   <b>hstack_vaapi</b>
       Stack input videos horizontally.

       This is the VA-API variant of the <b>hstack</b> filter, each input stream may have different height, this filter
       will scale down/up each input stream while keeping the original aspect.

       It accepts the following options:

       <b>inputs</b>
           See <b>hstack</b>.

       <b>shortest</b>
           See <b>hstack</b>.

       <b>height</b>
           Set height of output. If set to 0, this filter will set height of output to height of the first input
           stream. Default value is 0.

   <b>vstack_vaapi</b>
       Stack input videos vertically.

       This is the VA-API variant of the <b>vstack</b> filter, each input stream may have different width, this  filter
       will scale down/up each input stream while keeping the original aspect.

       It accepts the following options:

       <b>inputs</b>
           See <b>vstack</b>.

       <b>shortest</b>
           See <b>vstack</b>.

       <b>width</b>
           Set  width  of  output. If set to 0, this filter will set width of output to width of the first input
           stream. Default value is 0.

   <b>xstack_vaapi</b>
       Stack video inputs into custom layout.

       This is the VA-API variant of the <b>xstack</b> filter,  each input stream may have different size, this  filter
       will scale down/up each input stream to the given output size, or the size of the first input stream.

       It accepts the following options:

       <b>inputs</b>
           See <b>xstack</b>.

       <b>shortest</b>
           See <b>xstack</b>.

       <b>layout</b>
           See <b>xstack</b>.  Moreover, this permits the user to supply output size for each input stream.

                   xstack_vaapi=inputs=4:layout=0_0_1920x1080|0_h0_1920x1080|w0_0_1920x1080|w0_h0_1920x1080

       <b>grid</b>
           See <b>xstack</b>.

       <b>grid_tile_size</b>
           Set  output  size for each input stream when <b>grid</b> is set. If this option is not set, this filter will
           set output size by default to the size of the first input stream. For  the  syntax  of  this  option,
           check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

       <b>fill</b>
           See <b>xstack</b>.

   <b>pad_vaapi</b>
       Add paddings to the input image, and place the original input at the provided <u>x</u>, <u>y</u> coordinates.

       It accepts the following options:

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           Specify  an  expression  for  the  size of the output image with the paddings added. If the value for
           <u>width</u> or <u>height</u> is 0, the corresponding input size is used for the output.

           The <u>width</u> expression can reference the value set by the <u>height</u> expression, and vice versa.

           The default value of <u>width</u> and <u>height</u> is 0.

       <b>x</b>
       <b>y</b>   Specify the offsets to place the input image at within the padded area, with respect to the  top/left
           border of the output image.

           The <u>x</u> expression can reference the value set by the <u>y</u> expression, and vice versa.

           The default value of <u>x</u> and <u>y</u> is 0.

           If  <u>x</u>  or  <u>y</u>  evaluate to a negative number, they'll be changed so the input image is centered on the
           padded area.

       <b>color</b>
           Specify the color of the padded area. For the syntax of this option, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b>
           <b>ffmpeg-utils</b> <b>manual</b>.

       <b>aspect</b>
           Pad to an aspect instead to a resolution.

       The value for the <u>width</u>, <u>height</u>, <u>x</u>, and <u>y</u> options are expressions containing the following constants:

       <b>in_w</b>
       <b>in_h</b>
           The input video width and height.

       <b>iw</b>
       <b>ih</b>  These are the same as <u>in_w</u> and <u>in_h</u>.

       <b>out_w</b>
       <b>out_h</b>
           The output width and height (the size of the padded area), as  specified  by  the  <u>width</u>  and  <u>height</u>
           expressions.

       <b>ow</b>
       <b>oh</b>  These are the same as <u>out_w</u> and <u>out_h</u>.

       <b>x</b>
       <b>y</b>   The x and y offsets as specified by the <u>x</u> and <u>y</u> expressions, or NAN if not yet specified.

       <b>a</b>   same as <u>iw</u> / <u>ih</u>

       <b>sar</b> input sample aspect ratio

       <b>dar</b> input display aspect ratio, it is the same as (<u>iw</u> / <u>ih</u>) * <u>sar</u>

   <b>drawbox_vaapi</b>
       Draw a colored box on the input image.

       It accepts the following parameters:

       <b>x</b>
       <b>y</b>   The expressions which specify the top left corner coordinates of the box. It defaults to 0.

       <b>width,</b> <b>w</b>
       <b>height,</b> <b>h</b>
           The expressions which specify the width and height of the box; if 0 they are interpreted as the input
           width and height. It defaults to 0.

       <b>color,</b> <b>c</b>
           Specify  the  color  of  the  box  to write. For the general syntax of this option, check the <b>"Color"</b>
           <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

       <b>thickness,</b> <b>t</b>
           The expression which sets the thickness of the box edge.  A value of "fill" will create a filled box.
           Default value is 3.

           See below for the list of accepted constants.

       <b>replace</b>
           With value 1, the pixels of the painted box will  overwrite  the  video's  color  and  alpha  pixels.
           Default is 0, which composites the box onto the input video.

       The parameters for <u>x</u>, <u>y</u>, <u>w</u> and <u>h</u> and <u>t</u> are expressions containing the following constants:

       <b>in_h,</b> <b>ih</b>
       <b>in_w,</b> <b>iw</b>
           The input width and height.

       <b>x</b>
       <b>y</b>   The x and y offset coordinates where the box is drawn.

       <b>w</b>
       <b>h</b>   The width and height of the drawn box.

       <b>t</b>   The thickness of the drawn box.

       <u>Examples</u>

       •   Draw a black box around the edge of the input image:

                   drawbox

       •   Draw a box with color red and an opacity of 50%:

                   drawbox=10:20:200:60:<a href="mailto:red@0.5">red@0.5</a>

           The previous example can be specified as:

                   drawbox=x=10:y=20:w=200:h=60:color=<a href="mailto:red@0.5">red@0.5</a>

       •   Fill the box with pink color:

                   drawbox=x=10:y=10:w=100:h=100:color=<a href="mailto:pink@0.5">pink@0.5</a>:t=fill

       •   Draw a 2-pixel red 2.40:1 mask:

                   drawbox=x=-t:y=0.5*(ih-iw/2.4)-t:w=iw+t*2:h=iw/2.4+t*2:t=2:c=red

</pre><h4><b>VULKAN</b> <b>VIDEO</b> <b>FILTERS</b></h4><pre>
       Below is a description of the currently available Vulkan video filters.

       To  enable  compilation  of  these filters you need to configure FFmpeg with "--enable-vulkan" and either
       "--enable-libglslang" or "--enable-libshaderc".

       Running Vulkan filters requires you to initialize a hardware device  and  to  pass  that  device  to  all
       filters in any filter graph.

       <b>-init_hw_device</b> <b>vulkan[=</b><u>name</u><b>][:</b><u>device</u><b>[,</b><u>key=value</u><b>...]]</b>
           Initialise  a  new  hardware device of type <u>vulkan</u> called <u>name</u>, using the given device parameters and
           options in <u>key=value</u>. The following options are supported:

           <b>debug</b>
               Switches validation layers on if set to 1.

           <b>linear_images</b>
               Allocates linear images. Does not apply to decoding.

           <b>disable_multiplane</b>
               Disables multiplane images. Does not apply to decoding.

       <b>-filter_hw_device</b> <u>name</u>
           Pass the hardware device called <u>name</u> to all filters in any filter graph.

       For more detailed information see &lt;<b>https://www.ffmpeg.org/ffmpeg.html#Advanced-Video-options</b>&gt;

       •   Example of choosing the first device and running nlmeans_vulkan filter with default parameters on it.

                   -init_hw_device vulkan=vk:0 -filter_hw_device vk -i INPUT -vf "hwupload,nlmeans_vulkan,hwdownload" OUTPUT

       As Vulkan filters are not able to access frame data in normal memory, all frame data needs to be uploaded
       (<b>hwupload</b>) to hardware surfaces connected to the appropriate device before being used and then downloaded
       (<b>hwdownload</b>) back to normal memory. Note that <b>hwupload</b> will upload to a frame with the same layout as the
       software frame, so it may be necessary to add a <b>format</b> filter immediately before to get  the  input  into
       the  right  format and <b>hwdownload</b> does not support all formats on the output - it is usually necessary to
       insert an additional <b>format</b> filter immediately following in the graph to get the output  in  a  supported
       format.

   <b>avgblur_vulkan</b>
       Apply an average blur filter, implemented on the GPU using Vulkan.

       The filter accepts the following options:

       <b>sizeX</b>
           Set horizontal radius size.  Range is "[1, 32]" and default value is 3.

       <b>sizeY</b>
           Set vertical radius size. Range is "[1, 32]" and default value is 3.

       <b>planes</b>
           Set which planes to filter. Default value is 0xf, by which all planes are processed.

   <b>blend_vulkan</b>
       Blend two Vulkan frames into each other.

       The "blend" filter takes two input streams and outputs one stream, the first input is the "top" layer and
       second input is "bottom" layer.  By default, the output terminates when the longest input terminates.

       A description of the accepted options follows.

       <b>c0_mode</b>
       <b>c1_mode</b>
       <b>c2_mode</b>
       <b>c3_mode</b>
       <b>all_mode</b>
           Set  blend  mode  for  specific  pixel component or all pixel components in case of <u>all_mode</u>. Default
           value is "normal".

           Available values for component modes are:

           <b>normal</b>
           <b>multiply</b>

   <b>bwdif_vulkan</b>
       Deinterlacer using <b>bwdif</b>, the "Bob Weaver Deinterlacing Filter" algorithm, implemented on the  GPU  using
       Vulkan.

       It accepts the following parameters:

       <b>mode</b>
           The interlacing mode to adopt. It accepts one of the following values:

           <b>0,</b> <b>send_frame</b>
               Output one frame for each frame.

           <b>1,</b> <b>send_field</b>
               Output one frame for each field.

           The default value is "send_field".

       <b>parity</b>
           The  picture  field  parity  assumed  for the input interlaced video. It accepts one of the following
           values:

           <b>0,</b> <b>tff</b>
               Assume the top field is first.

           <b>1,</b> <b>bff</b>
               Assume the bottom field is first.

           <b>-1,</b> <b>auto</b>
               Enable automatic detection of field parity.

           The default value is "auto".  If the interlacing is unknown or  the  decoder  does  not  export  this
           information, top field first will be assumed.

       <b>deint</b>
           Specify which frames to deinterlace. Accepts one of the following values:

           <b>0,</b> <b>all</b>
               Deinterlace all frames.

           <b>1,</b> <b>interlaced</b>
               Only deinterlace frames marked as interlaced.

           The default value is "all".

   <b>chromaber_vulkan</b>
       Apply  an  effect  that emulates chromatic aberration. Works best with RGB inputs, but provides a similar
       effect with YCbCr inputs too.

       <b>dist_x</b>
           Horizontal displacement multiplier. Each chroma pixel's position will be multiplied by  this  amount,
           starting from the center of the image. Default is 0.

       <b>dist_y</b>
           Similarly, this sets the vertical displacement multiplier. Default is 0.

   <b>color_vulkan</b>
       Video source that creates a Vulkan frame of a solid color.  Useful for benchmarking, or overlaying.

       It accepts the following parameters:

       <b>color</b>
           The color to use. Either a name, or a hexadecimal value.  The default value is "black".

       <b>size</b>
           The size of the output frame. Default value is "1920x1080".

       <b>rate</b>
           The framerate to output at. Default value is 60 frames per second.

       <b>duration</b>
           The video duration. Default value is -0.000001.

       <b>sar</b> The video signal aspect ratio. Default value is "1/1".

       <b>format</b>
           The pixel format of the output Vulkan frames. Default value is "yuv444p".

       <b>out_range</b>
           Set the output YCbCr sample range.

           This  allows  the autodetected value to be overridden as well as allows forcing a specific value used
           for the output and encoder. If not specified, the range depends on the pixel format. Possible values:

           <b>auto/unknown</b>
               Choose automatically.

           <b>jpeg/full/pc</b>
               Set full range (0-255 in case of 8-bit luma).

           <b>mpeg/limited/tv</b>
               Set "MPEG" range (16-235 in case of 8-bit luma).

   <b>vflip_vulkan</b>
       Flips an image vertically.

   <b>hflip_vulkan</b>
       Flips an image horizontally.

   <b>flip_vulkan</b>
       Flips an image along both the vertical and horizontal axis.

   <b>gblur_vulkan</b>
       Apply Gaussian blur filter on Vulkan frames.

       The filter accepts the following options:

       <b>sigma</b>
           Set horizontal sigma, standard deviation of Gaussian blur. Default is 0.5.

       <b>sigmaV</b>
           Set vertical sigma, if negative it will be same as "sigma".  Default is -1.

       <b>planes</b>
           Set which planes to filter. By default all planes are filtered.

       <b>size</b>
           Set the kernel size along the horizontal axis. Default is 19.

       <b>sizeV</b>
           Set the kernel size along the vertical axis. Default is 0, which sets to use the same value as <u>size</u>.

   <b>nlmeans_vulkan</b>
       Denoise frames using Non-Local Means algorithm, implemented on the GPU using Vulkan.  Supports more pixel
       formats than <b>nlmeans</b> or <b>nlmeans_opencl</b>, including alpha channel support.

       The filter accepts the following options.

       <b>s</b>   Set denoising strength for all components. Default is 1.0. Must be in range [1.0, 100.0].

       <b>p</b>   Set patch size for all planes. Default is 7. Must be odd number in range [0, 99].

       <b>r</b>   Set research size. Default is 15. Must be odd number in range [0, 99].

       <b>t</b>   Set parallelism. Default is 36. Must be a number in the range [1, 168].  Larger values may  speed  up
           processing,  at  the  cost  of more VRAM.  Lower values will slow it down, reducing VRAM usage.  Only
           supported on GPUs with atomic float operations (RDNA3+, Ampere+).

       <b>s0</b>
       <b>s1</b>
       <b>s2</b>
       <b>s3</b>  Set denoising strength for a specific component. Default is <u>1</u>, equal to <b>s</b>.  Must  be  odd  number  in
           range [1, 100].

       <b>p0</b>
       <b>p1</b>
       <b>p2</b>
       <b>p3</b>  Set  patch  size for a specific component. Default is <u>7</u>, equal to <b>p</b>.  Must be odd number in range [0,
           99].

   <b>overlay_vulkan</b>
       Overlay one video on top of another.

       It takes two inputs and has one output. The first input is the "main" video on which the second input  is
       overlaid.   This  filter  requires  all inputs to use the same pixel format. So, format conversion may be
       needed.

       The filter accepts the following options:

       <b>x</b>   Set the x coordinate of the overlaid video on the main video.  Default value is 0.

       <b>y</b>   Set the y coordinate of the overlaid video on the main video.  Default value is 0.

   <b>transpose_vt</b>
       Transpose rows with columns in the input video and optionally flip it.  For more in  depth  examples  see
       the <b>transpose</b> video filter, which shares mostly the same options.

       It accepts the following parameters:

       <b>dir</b> Specify the transposition direction.

           Can assume the following values:

           <b>cclock_flip</b>
               Rotate by 90 degrees counterclockwise and vertically flip. (default)

           <b>clock</b>
               Rotate by 90 degrees clockwise.

           <b>cclock</b>
               Rotate by 90 degrees counterclockwise.

           <b>clock_flip</b>
               Rotate by 90 degrees clockwise and vertically flip.

           <b>hflip</b>
               Flip the input video horizontally.

           <b>vflip</b>
               Flip the input video vertically.

       <b>passthrough</b>
           Do  not  apply  the  transposition  if  the input geometry matches the one specified by the specified
           value. It accepts the following values:

           <b>none</b>
               Always apply transposition. (default)

           <b>portrait</b>
               Preserve portrait geometry (when <u>height</u> &gt;= <u>width</u>).

           <b>landscape</b>
               Preserve landscape geometry (when <u>width</u> &gt;= <u>height</u>).

   <b>transpose_vulkan</b>
       Transpose rows with columns in the input video and optionally flip it.  For more in  depth  examples  see
       the <b>transpose</b> video filter, which shares mostly the same options.

       It accepts the following parameters:

       <b>dir</b> Specify the transposition direction.

           Can assume the following values:

           <b>cclock_flip</b>
               Rotate by 90 degrees counterclockwise and vertically flip. (default)

           <b>clock</b>
               Rotate by 90 degrees clockwise.

           <b>cclock</b>
               Rotate by 90 degrees counterclockwise.

           <b>clock_flip</b>
               Rotate by 90 degrees clockwise and vertically flip.

       <b>passthrough</b>
           Do  not  apply  the  transposition  if  the input geometry matches the one specified by the specified
           value. It accepts the following values:

           <b>none</b>
               Always apply transposition. (default)

           <b>portrait</b>
               Preserve portrait geometry (when <u>height</u> &gt;= <u>width</u>).

           <b>landscape</b>
               Preserve landscape geometry (when <u>width</u> &gt;= <u>height</u>).

</pre><h4><b>QSV</b> <b>VIDEO</b> <b>FILTERS</b></h4><pre>
       Below is a description of the currently available QSV video filters.

       To enable  compilation  of  these  filters  you  need  to  configure  FFmpeg  with  "--enable-libmfx"  or
       "--enable-libvpl".

       To  use  QSV  filters,  you  need  to  setup  the QSV device correctly. For more information, please read
       &lt;<b>https://trac.ffmpeg.org/wiki/Hardware/QuickSync</b>&gt;

   <b>hstack_qsv</b>
       Stack input videos horizontally.

       This is the QSV variant of the <b>hstack</b> filter, each input stream may have different  height,  this  filter
       will scale down/up each input stream while keeping the original aspect.

       It accepts the following options:

       <b>inputs</b>
           See <b>hstack</b>.

       <b>shortest</b>
           See <b>hstack</b>.

       <b>height</b>
           Set height of output. If set to 0, this filter will set height of output to height of the first input
           stream. Default value is 0.

   <b>vstack_qsv</b>
       Stack input videos vertically.

       This  is  the  QSV  variant of the <b>vstack</b> filter, each input stream may have different width, this filter
       will scale down/up each input stream while keeping the original aspect.

       It accepts the following options:

       <b>inputs</b>
           See <b>vstack</b>.

       <b>shortest</b>
           See <b>vstack</b>.

       <b>width</b>
           Set width of output. If set to 0, this filter will set width of output to width of  the  first  input
           stream. Default value is 0.

   <b>xstack_qsv</b>
       Stack video inputs into custom layout.

       This is the QSV variant of the <b>xstack</b> filter.

       It accepts the following options:

       <b>inputs</b>
           See <b>xstack</b>.

       <b>shortest</b>
           See <b>xstack</b>.

       <b>layout</b>
           See <b>xstack</b>.  Moreover, this permits the user to supply output size for each input stream.

                   xstack_qsv=inputs=4:layout=0_0_1920x1080|0_h0_1920x1080|w0_0_1920x1080|w0_h0_1920x1080

       <b>grid</b>
           See <b>xstack</b>.

       <b>grid_tile_size</b>
           Set  output  size for each input stream when <b>grid</b> is set. If this option is not set, this filter will
           set output size by default to the size of the first input stream. For  the  syntax  of  this  option,
           check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

       <b>fill</b>
           See <b>xstack</b>.

</pre><h4><b>VIDEO</b> <b>SOURCES</b></h4><pre>
       Below is a description of the currently available video sources.

   <b>buffer</b>
       Buffer video frames, and make them available to the filter chain.

       This  source  is  mainly  intended for a programmatic use, in particular through the interface defined in
       <u>libavfilter/buffersrc.h</u>.

       It accepts the following parameters:

       <b>video_size</b>
           Specify the size (width and height) of the buffered video frames. For  the  syntax  of  this  option,
           check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

       <b>width</b>
           The input video width.

       <b>height</b>
           The input video height.

       <b>pix_fmt</b>
           A  string  representing  the  pixel  format  of  the  buffered  video  frames.   It  may  be a number
           corresponding to a pixel format, or a pixel format name.

       <b>time_base</b>
           Specify the timebase assumed by the timestamps of the buffered frames.

       <b>frame_rate</b>
           Specify the frame rate expected for the video stream.

       <b>colorspace</b>
           A string representing the color space of the buffered video frames.  It may be a number corresponding
           to a color space, or a color space name.

       <b>range</b>
           A string representing the color range of the buffered video frames.  It may be a number corresponding
           to a color range, or a color range name.

       <b>pixel_aspect,</b> <b>sar</b>
           The sample (pixel) aspect ratio of the input video.

       <b>hw_frames_ctx</b>
           When using a hardware pixel format, this should be a reference  to  an  AVHWFramesContext  describing
           input frames.

       For example:

               buffer=width=320:height=240:pix_fmt=yuv410p:time_base=1/24:sar=1

       will  instruct  the  source  to accept video frames with size 320x240 and with format "yuv410p", assuming
       1/24 as the timestamps timebase and square pixels (1:1 sample aspect ratio).  Since the pixel format with
       name  "yuv410p"  corresponds  to  the  number   6   (check   the   enum   AVPixelFormat   definition   in
       <u>libavutil/pixfmt.h</u>), this example corresponds to:

               buffer=size=320x240:pixfmt=6:time_base=1/24:pixel_aspect=1/1

       Alternatively, the options can be specified as a flat string, but this syntax is deprecated:

       <u>width</u>:<u>height</u>:<u>pix_fmt</u>:<u>time_base.num</u>:<u>time_base.den</u>:<u>pixel_aspect.num</u>:<u>pixel_aspect.den</u>

   <b>cellauto</b>
       Create a pattern generated by an elementary cellular automaton.

       The  initial  state of the cellular automaton can be defined through the <b>filename</b> and <b>pattern</b> options. If
       such options are not specified an initial state is created randomly.

       At each new frame a new row in the video is filled  with  the  result  of  the  cellular  automaton  next
       generation. The behavior when the whole frame is filled is defined by the <b>scroll</b> option.

       This source accepts the following options:

       <b>filename,</b> <b>f</b>
           Read  the  initial  cellular automaton state, i.e. the starting row, from the specified file.  In the
           file, each non-whitespace character is considered an alive cell, a newline will  terminate  the  row,
           and further characters in the file will be ignored.

       <b>pattern,</b> <b>p</b>
           Read the initial cellular automaton state, i.e. the starting row, from the specified string.

           Each non-whitespace character in the string is considered an alive cell, a newline will terminate the
           row, and further characters in the string will be ignored.

       <b>rate,</b> <b>r</b>
           Set the video rate, that is the number of frames generated per second.  Default is 25.

       <b>random_fill_ratio,</b> <b>ratio</b>
           Set the random fill ratio for the initial cellular automaton row. It is a floating point number value
           ranging from 0 to 1, defaults to 1/PHI.

           This option is ignored when a file or a pattern is specified.

       <b>random_seed,</b> <b>seed</b>
           Set  the  seed  for  filling  randomly  the  initial  row,  must be an integer included between 0 and
           UINT32_MAX. If not specified, or if explicitly set to -1, the filter will try to use  a  good  random
           seed on a best effort basis.

       <b>rule</b>
           Set the cellular automaton rule, it is a number ranging from 0 to 255.  Default value is 110.

       <b>size,</b> <b>s</b>
           Set  the  size  of the output video. For the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b>
           <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

           If <b>filename</b> or <b>pattern</b> is specified, the size is set by default to the width of the specified initial
           state row, and the height is set to <u>width</u> * PHI.

           If <b>size</b> is set, it must contain the width of the specified pattern string, and the specified  pattern
           will be centered in the larger row.

           If  a filename or a pattern string is not specified, the size value defaults to "320x518" (used for a
           randomly generated initial state).

       <b>scroll</b>
           If set to 1, scroll the output upward when all the rows in the output have been  already  filled.  If
           set to 0, the new generated row will be written over the top row just after the bottom row is filled.
           Defaults to 1.

       <b>start_full,</b> <b>full</b>
           If  set to 1, completely fill the output with generated rows before outputting the first frame.  This
           is the default behavior, for disabling set the value to 0.

       <b>stitch</b>
           If set to 1, stitch the left and right row  edges  together.   This  is  the  default  behavior,  for
           disabling set the value to 0.

       <u>Examples</u>

       •   Read the initial state from <u>pattern</u>, and specify an output of size 200x400.

                   cellauto=f=pattern:s=200x400

       •   Generate a random initial row with a width of 200 cells, with a fill ratio of 2/3:

                   cellauto=ratio=2/3:s=200x200

       •   Create a pattern generated by rule 18 starting by a single alive cell centered on an initial row with
           width 100:

                   cellauto=p=@s=100x400:full=0:rule=18

       •   Specify a more elaborated initial pattern:

                   cellauto=p='@@ @ @@':s=100x400:full=0:rule=18

   <b>coreimagesrc</b>
       Video source generated on GPU using Apple's CoreImage API on OSX.

       This  video source is a specialized version of the <b>coreimage</b> video filter.  Use a core image generator at
       the beginning of the applied filterchain to generate the content.

       The coreimagesrc video source accepts the following options:

       <b>list_generators</b>
           List all available generators along with all their respective options as well as possible minimum and
           maximum values along with the default values.

                   list_generators=true

       <b>size,</b> <b>s</b>
           Specify the size of the sourced video. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  The default value is "320x240".

       <b>rate,</b> <b>r</b>
           Specify  the frame rate of the sourced video, as the number of frames generated per second. It has to
           be a string in the format <u>frame_rate_num</u>/<u>frame_rate_den</u>, an integer number, a floating  point  number
           or a valid video frame rate abbreviation. The default value is "25".

       <b>sar</b> Set the sample aspect ratio of the sourced video.

       <b>duration,</b> <b>d</b>
           Set  the  duration  of the sourced video. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>
           for the accepted syntax.

           If not specified, or the expressed duration is negative,  the  video  is  supposed  to  be  generated
           forever.

       Additionally, all options of the <b>coreimage</b> video filter are accepted.  A complete filterchain can be used
       for  further processing of the generated input without CPU-HOST transfer. See <b>coreimage</b> documentation and
       examples for details.

       <u>Examples</u>

       •   Use CIQRCodeGenerator to create a QR code for the FFmpeg homepage,  given  as  complete  and  escaped
           command-line for Apple's standard bash shell:

                   ffmpeg -f lavfi -i coreimagesrc=s=100x100:filter=CIQRCodeGenerator@inputMessage=https\\\\\://FFmpeg.org/@inputCorrectionLevel=H -frames:v 1 QRCode.png

           This  example  is  equivalent to the QRCode example of <b>coreimage</b> without the need for a nullsrc video
           source.

   <b>ddagrab</b>
       Captures the Windows Desktop via Desktop Duplication API.

       The filter exclusively returns D3D11 Hardware Frames, for on-gpu encoding or processing. So  an  explicit
       <b>hwdownload</b> is needed for any kind of software processing.

       It accepts the following options:

       <b>output_idx</b>
           DXGI Output Index to capture.

           Usually corresponds to the index Windows has given the screen minus one, so it's starting at 0.

           Defaults to output 0.

       <b>draw_mouse</b>
           Whether to draw the mouse cursor.

           Defaults to true.

           Only  affects  hardware  cursors.  If  a  game or application renders its own cursor, it'll always be
           captured.

       <b>framerate</b>
           Maximum framerate at which the desktop will be captured - the interval between successive frames will
           not be smaller than the inverse of the framerate. When <u>dup_frames</u>  is  true  (the  default)  and  the
           desktop  is  not  being  updated  often enough, the filter will duplicate a previous frame. Note that
           there is no background buffering going on, so when the filter is not polled  often  enough  then  the
           actual inter-frame interval may be significantly larger.

           Defaults to 30 FPS.

       <b>video_size</b>
           Specify the size of the captured video.

           Defaults to the full size of the screen.

           Cropped from the bottom/right if smaller than screen size.

       <b>offset_x</b>
           Horizontal offset of the captured video.

       <b>offset_y</b>
           Vertical offset of the captured video.

       <b>output_fmt</b>
           Desired filter output format.  Defaults to 8 Bit BGRA.

           It accepts the following values:

           <b>auto</b>
               Passes all supported output formats to DDA and returns what DDA decides to use.

           <b>8bit</b>
           <b>bgra</b>
               8 Bit formats always work, and DDA will convert to them if necessary.

           <b>10bit</b>
           <b>x2bgr10</b>
               Filter initialization will fail if 10 bit format is requested but unavailable.

       <b>dup_frames</b>
           When  this option is set to true (the default), the filter will duplicate frames when the desktop has
           not been updated in order to maintain approximately constant target framerate. When  this  option  is
           set  to  false,  the  filter  will wait for the desktop to be updated (inter-frame intervals may vary
           significantly in this case).

       <u>Examples</u>

       Capture primary screen and encode using nvenc:

               ffmpeg -f lavfi -i ddagrab -c:v h264_nvenc -cq 18 output.mp4

       You can also skip the lavfi device and directly use the filter.  Also demonstrates downloading the  frame
       and encoding with libx264.  Explicit output format specification is required in this case:

               ffmpeg -filter_complex ddagrab=output_idx=1:framerate=60,hwdownload,format=bgra -c:v libx264 -crf 18 output.mp4

       If  you  want  to  capture only a subsection of the desktop, this can be achieved by specifying a smaller
       size and its offsets into the screen:

               ddagrab=video_size=800x600:offset_x=100:offset_y=100

   <b>gradients</b>
       Generate several gradients.

       <b>size,</b> <b>s</b>
           Set frame size. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>  <b>in</b>  <b>the</b>  <b>ffmpeg-utils</b>
           <b>manual</b>. Default value is "640x480".

       <b>rate,</b> <b>r</b>
           Set frame rate, expressed as number of frames per second. Default value is "25".

       <b>c0,</b> <b>c1,</b> <b>c2,</b> <b>c3,</b> <b>c4,</b> <b>c5,</b> <b>c6,</b> <b>c7</b>
           Set 8 colors. Default values for colors is to pick random one.

       <b>x0,</b> <b>y0,</b> <b>y0,</b> <b>y1</b>
           Set gradient line source and destination points. If negative or out of range, random ones are picked.

       <b>nb_colors,</b> <b>n</b>
           Set number of colors to use at once. Allowed range is from 2 to 8. Default value is 2.

       <b>seed</b>
           Set seed for picking gradient line points.

       <b>duration,</b> <b>d</b>
           Set  the  duration  of the sourced video. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>
           for the accepted syntax.

           If not specified, or the expressed duration is negative,  the  video  is  supposed  to  be  generated
           forever.

       <b>speed</b>
           Set speed of gradients rotation.

       <b>type,</b> <b>t</b>
           Set type of gradients.  Available values are:

           <b>linear</b>
           <b>radial</b>
           <b>circular</b>
           <b>spiral</b>
           <b>square</b>

           Default type is <u>linear</u>.

       <u>Commands</u>

       This source supports the some above options as <b>commands</b>.

   <b>mandelbrot</b>
       Generate  a  Mandelbrot  set fractal, and progressively zoom towards the point specified with <u>start_x</u> and
       <u>start_y</u>.

       This source accepts the following options:

       <b>end_pts</b>
           Set the terminal pts value. Default value is 400.

       <b>end_scale</b>
           Set the terminal scale value.  Must be a floating point value. Default value is 0.3.

       <b>inner</b>
           Set the inner coloring mode, that is the algorithm used  to  draw  the  Mandelbrot  fractal  internal
           region.

           It shall assume one of the following values:

           <b>black</b>
               Set black mode.

           <b>convergence</b>
               Show time until convergence.

           <b>mincol</b>
               Set color based on point closest to the origin of the iterations.

           <b>period</b>
               Set period mode.

           Default value is <u>mincol</u>.

       <b>bailout</b>
           Set the bailout value. Default value is 10.0.

       <b>maxiter</b>
           Set the maximum of iterations performed by the rendering algorithm. Default value is 7189.

       <b>outer</b>
           Set outer coloring mode.  It shall assume one of following values:

           <b>iteration_count</b>
               Set iteration count mode.

           <b>normalized_iteration_count</b>
               set normalized iteration count mode.

           Default value is <u>normalized_iteration_count</u>.

       <b>rate,</b> <b>r</b>
           Set frame rate, expressed as number of frames per second. Default value is "25".

       <b>size,</b> <b>s</b>
           Set  frame  size.  For  the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b>
           <b>manual</b>. Default value is "640x480".

       <b>start_scale</b>
           Set the initial scale value. Default value is 3.0.

       <b>start_x</b>
           Set the initial x position. Must be a floating point value between -100 and  100.  Default  value  is
           -0.743643887037158704752191506114774.

       <b>start_y</b>
           Set  the  initial  y  position. Must be a floating point value between -100 and 100. Default value is
           -0.131825904205311970493132056385139.

   <b>mptestsrc</b>
       Generate various test patterns, as generated by the MPlayer test filter.

       The size of the generated video is fixed, and is 256x256.   This  source  is  useful  in  particular  for
       testing encoding features.

       This source accepts the following options:

       <b>rate,</b> <b>r</b>
           Specify  the frame rate of the sourced video, as the number of frames generated per second. It has to
           be a string in the format <u>frame_rate_num</u>/<u>frame_rate_den</u>, an integer number, a floating  point  number
           or a valid video frame rate abbreviation. The default value is "25".

       <b>duration,</b> <b>d</b>
           Set  the  duration  of the sourced video. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>
           for the accepted syntax.

           If not specified, or the expressed duration is negative,  the  video  is  supposed  to  be  generated
           forever.

       <b>test,</b> <b>t</b>
           Set the number or the name of the test to perform. Supported tests are:

           <b>dc_luma</b>
           <b>dc_chroma</b>
           <b>freq_luma</b>
           <b>freq_chroma</b>
           <b>amp_luma</b>
           <b>amp_chroma</b>
           <b>cbp</b>
           <b>mv</b>
           <b>ring1</b>
           <b>ring2</b>
           <b>all</b>
           <b>max_frames,</b> <b>m</b>
               Set the maximum number of frames generated for each test, default value is 30.

           Default value is "all", which will cycle through the list of all tests.

       Some examples:

               mptestsrc=t=dc_luma

       will generate a "dc_luma" test pattern.

   <b>frei0r_src</b>
       Provide a frei0r source.

       To  enable  compilation  of  this  filter you need to install the frei0r header and configure FFmpeg with
       "--enable-frei0r".

       This source accepts the following parameters:

       <b>size</b>
           The size of the video to generate. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>  <b>in</b>
           <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

       <b>framerate</b>
           The  framerate  of  the  generated  video.  It  may  be  a string of the form <u>num</u>/<u>den</u> or a frame rate
           abbreviation.

       <b>filter_name</b>
           The name to the frei0r source to load. For more information regarding  frei0r  and  how  to  set  the
           parameters, read the <b>frei0r</b> section in the video filters documentation.

       <b>filter_params</b>
           A '|'-separated list of parameters to pass to the frei0r source.

       For  example,  to generate a frei0r partik0l source with size 200x200 and frame rate 10 which is overlaid
       on the overlay filter main input:

               frei0r_src=size=200x200:framerate=10:filter_name=partik0l:filter_params=1234 [overlay]; [in][overlay] overlay

   <b>life</b>
       Generate a life pattern.

       This source is based on a generalization of John Conway's life game.

       The sourced input represents a life grid, each pixel represents a  cell  which  can  be  in  one  of  two
       possible  states, alive or dead. Every cell interacts with its eight neighbours, which are the cells that
       are horizontally, vertically, or diagonally adjacent.

       At each interaction the grid evolves according to  the  adopted  rule,  which  specifies  the  number  of
       neighbor alive cells which will make a cell stay alive or born. The <b>rule</b> option allows one to specify the
       rule to adopt.

       This source accepts the following options:

       <b>filename,</b> <b>f</b>
           Set the file from which to read the initial grid state. In the file, each non-whitespace character is
           considered an alive cell, and newline is used to delimit the end of each row.

           If this option is not specified, the initial grid is generated randomly.

       <b>rate,</b> <b>r</b>
           Set the video rate, that is the number of frames generated per second.  Default is 25.

       <b>random_fill_ratio,</b> <b>ratio</b>
           Set  the  random  fill ratio for the initial random grid. It is a floating point number value ranging
           from 0 to 1, defaults to 1/PHI.  It is ignored when a file is specified.

       <b>random_seed,</b> <b>seed</b>
           Set the seed for filling the initial  random  grid,  must  be  an  integer  included  between  0  and
           UINT32_MAX.  If  not  specified, or if explicitly set to -1, the filter will try to use a good random
           seed on a best effort basis.

       <b>rule</b>
           Set the life rule.

           A rule can be specified with a code of the kind "S<u>NS</u>/B<u>NB</u>", where <u>NS</u> and <u>NB</u> are sequences  of  numbers
           in  the range 0-8, <u>NS</u> specifies the number of alive neighbor cells which make a live cell stay alive,
           and <u>NB</u> the number of alive neighbor cells which make a dead cell to become alive  (i.e.  to  "born").
           "s" and "b" can be used in place of "S" and "B", respectively.

           Alternatively a rule can be specified by an 18-bits integer. The 9 high order bits are used to encode
           the  next  cell  state  if  it  is  alive for each number of neighbor alive cells, the low order bits
           specify the rule for "borning" new cells. Higher order bits encode for an higher number  of  neighbor
           cells.   For  example the number 6153 = "(12&lt;&lt;9)+9" specifies a stay alive rule of 12 and a born rule
           of 9, which corresponds to "S23/B03".

           Default value is "S23/B3", which is the original Conway's game of life rule, and  will  keep  a  cell
           alive  if it has 2 or 3 neighbor alive cells, and will born a new cell if there are three alive cells
           around a dead cell.

       <b>size,</b> <b>s</b>
           Set the size of the output video. For the syntax of this option, check the <b>"Video</b>  <b>size"</b>  <b>section</b>  <b>in</b>
           <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

           If  <b>filename</b>  is specified, the size is set by default to the same size of the input file. If <b>size</b> is
           set, it must contain the size specified in the input file, and the initial grid defined in that  file
           is centered in the larger resulting area.

           If  a  filename is not specified, the size value defaults to "320x240" (used for a randomly generated
           initial grid).

       <b>stitch</b>
           If set to 1, stitch the left and right grid edges together,  and  the  top  and  bottom  edges  also.
           Defaults to 1.

       <b>mold</b>
           Set  cell mold speed. If set, a dead cell will go from <b>death_color</b> to <b>mold_color</b> with a step of <b>mold</b>.
           <b>mold</b> can have a value from 0 to 255.

       <b>life_color</b>
           Set the color of living (or new born) cells.

       <b>death_color</b>
           Set the color of dead cells. If <b>mold</b> is set, this is the first color used to represent a dead cell.

       <b>mold_color</b>
           Set mold color, for definitely dead and moldy cells.

           For the syntax of these 3 color options, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

       <u>Examples</u>

       •   Read a grid from <u>pattern</u>, and center it on a grid of size 300x300 pixels:

                   life=f=pattern:s=300x300

       •   Generate a random grid of size 200x200, with a fill ratio of 2/3:

                   life=ratio=2/3:s=200x200

       •   Specify a custom rule for evolving a randomly generated grid:

                   life=rule=S14/B34

       •   Full example with slow death effect (mold) using <b>ffplay</b>:

                   ffplay -f lavfi life=s=300x200:mold=10:r=60:ratio=0.1:death_color=#C83232:life_color=#00ff00,scale=1200:800:flags=16

   <b>perlin</b>
       Generate Perlin noise.

       Perlin noise is a kind of noise with local continuity in space. This can be  used  to  generate  patterns
       with continuity in space and time, e.g. to simulate smoke, fluids, or terrain.

       In  case more than one octave is specified through the <b>octaves</b> option, Perlin noise is generated as a sum
       of components, each one with doubled frequency. In this case the <b>persistence</b> option specify the ratio  of
       the  amplitude with respect to the previous component. More octave components enable to specify more high
       frequency details in the generated noise (e.g. small size variations  due  to  boulders  in  a  generated
       terrain).

       <u>Options</u>

       <b>size,</b> <b>s</b>
           Specify  the  size  (width  and  height) of the buffered video frames. For the syntax of this option,
           check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "320x240".

       <b>rate,</b> <b>r</b>
           Specify the frame rate expected for the video stream, expressed as a number  of  frames  per  second.
           Default value is 25.

       <b>octaves</b>
           Specify  the total number of components making up the noise, each one with doubled frequency. Default
           value is 1.

       <b>persistence</b>
           Set the ratio used to compute the amplitude of the next octave component with respect to the previous
           component amplitude. Default value is 1.

       <b>xscale</b>
       <b>yscale</b>
           Define a scale factor used to multiple the x, y coordinates. This can be useful to define  an  effect
           with a pattern stretched along the x or y axis. Default value is 1.

       <b>tscale</b>
           Define  a  scale  factor  used to multiple the time coordinate. This can be useful to change the time
           variation speed. Default value is 1.

       <b>random_mode</b>
           Set random mode used to compute initial pattern.

           Supported values are:

           <b>random</b>
               Compute and use random seed.

           <b>ken</b> Use the predefined initial pattern defined by Ken Perlin in the original article, can  be  useful
               to compare the output with other sources.

           <b>seed</b>
               Use the value specified by <b>random_seed</b> option.

           Default value is "random".

       <b>random_seed,</b> <b>seed</b>
           When  <b>random_mode</b> is set to <u>random_seed</u>, use this value to compute the initial pattern. Default value
           is 0.

       <u>Examples</u>

       •   Generate single component:

                   perlin

       •   Use Perlin noise with 7 components, each one with a halved contribution to total amplitude:

                   perlin=octaves=7:persistence=0.5

       •   Chain Perlin noise with the <b>lutyuv</b> to generate a black&amp;white effect:

                   perlin=octaves=3:tscale=0.3,lutyuv=y='if(lt(val\,128)\,255\,0)'

       •   Stretch noise along the y axis, and convert gray level to red-only signal:

                   perlin=octaves=7:tscale=0.4:yscale=0.3,lutrgb=r=val:b=0:g=0

   <b>qrencodesrc</b>
       Generate a QR code using the libqrencode library (see &lt;<b>https://fukuchi.org/works/qrencode/</b>&gt;).

       To enable the compilation of this source, you need to configure FFmpeg with "--enable-libqrencode".

       The QR code is generated from the provided text or text pattern. The corresponding QR code is scaled  and
       put in the video output according to the specified output size options.

       In  case  no  text  is  specified,  the QR code is not generated, but an empty colored output is returned
       instead.

       This source accepts the following options:

       <b>qrcode_width,</b> <b>q</b>
       <b>padded_qrcode_width,</b> <b>Q</b>
           Specify an expression for the  width  of  the  rendered  QR  code,  with  and  without  padding.  The
           <u>qrcode_width</u>  expression  can reference the value set by the <u>padded_qrcode_width</u> expression, and vice
           versa.  By default <u>padded_qrcode_width</u> is set to <u>qrcode_width</u>, meaning that there is no padding.

           These expressions  are  evaluated  only  once,  when  initializing  the  source.   See  the  <b>qrencode</b>
           <b>Expressions</b> section for details.

           Note that some of the constants are missing for the source (for example the <u>x</u> or <u>t</u> or ¸<u>n</u>), since they
           only makes sense when evaluating the expression for each frame rather than at initialization time.

       <b>rate,</b> <b>r</b>
           Specify  the frame rate of the sourced video, as the number of frames generated per second. It has to
           be a string in the format <u>frame_rate_num</u>/<u>frame_rate_den</u>, an integer number, a floating  point  number
           or a valid video frame rate abbreviation. The default value is "25".

       <b>case_sensitive,</b> <b>cs</b>
           Instruct libqrencode to use case sensitive encoding. This is enabled by default. This can be disabled
           to reduce the QR encoding size.

       <b>level,</b> <b>l</b>
           Specify  the  QR  encoding error correction level. With an higher correction level, the encoding size
           will increase but the code will be more robust to corruption.  Lower level is <u>L</u>.

           It accepts the following values:

           <b>L</b>
           <b>M</b>
           <b>Q</b>
           <b>H</b>
       <b>expansion</b>
           Select how the input text is expanded. Can be either "none", or "normal" (default). See the  <b>qrencode</b>
           <b>Text</b> <b>expansion</b> section for details.

       <b>text</b>
       <b>textfile</b>
           Define the text to be rendered. In case neither is specified, no QR is encoded (just an empty colored
           frame).

           In  case  expansion  is enabled, the text is treated as a text template, using the qrencode expansion
           mechanism. See the <b>qrencode</b> <b>Text</b> <b>expansion</b> section for details.

       <b>background_color,</b> <b>bc</b>
       <b>foreground_color,</b> <b>fc</b>
           Set the QR code and background color. The default value of <u>foreground_color</u> is "black",  the  default
           value of <u>background_color</u> is "white".

           For the syntax of the color options, check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

       <u>Examples</u>

       •   Generate a QR code encoding the specified text with the default size:

                   qrencodesrc=text=www.ffmpeg.org

       •   Same as below, but select blue on pink colors:

                   qrencodesrc=text=www.ffmpeg.org:bc=pink:fc=blue

       •   Generate  a  QR code with width of 200 pixels and padding, making the padded width 4/3 of the QR code
           width:

                   qrencodesrc=text=www.ffmpeg.org:q=200:Q=4/3*q

       •   Generate a QR code with padded width of 200 pixels and padding, making the QR code width 3/4  of  the
           padded width:

                   qrencodesrc=text=www.ffmpeg.org:Q=200:q=3/4*Q

       •   Generate a QR code encoding the frame number:

                   qrencodesrc=text=%{n}

       •   Generate a QR code encoding the GMT timestamp:

                   qrencodesrc=text=%{gmtime}

       •   Generate a QR code encoding the timestamp expressed as a float:

                   qrencodesrc=text=%{pts}

   <b>allrgb,</b>  <b>allyuv,</b>  <b>color,</b>  <b>colorchart,</b> <b>colorspectrum,</b> <b>haldclutsrc,</b> <b>nullsrc,</b> <b>pal75bars,</b> <b>pal100bars,</b> <b>rgbtestsrc,</b>
       <b>smptebars,</b> <b>smptehdbars,</b> <b>testsrc,</b> <b>testsrc2,</b> <b>yuvtestsrc</b>
       The "allrgb" source returns frames of size 4096x4096 of all rgb colors.

       The "allyuv" source returns frames of size 4096x4096 of all yuv colors.

       The "color" source provides an uniformly colored input.

       The "colorchart" source provides a colors checker chart.

       The "colorspectrum" source provides a color spectrum input.

       The "haldclutsrc" source provides an identity Hald CLUT. See also <b>haldclut</b> filter.

       The "nullsrc" source returns unprocessed video frames. It is mainly useful to be employed in  analysis  /
       debugging tools, or as the source for filters which ignore the input data.

       The  "pal75bars"  source  generates a color bars pattern, based on EBU PAL recommendations with 75% color
       levels.

       The "pal100bars" source generates a color bars pattern, based on EBU PAL recommendations with 100%  color
       levels.

       The  "rgbtestsrc" source generates an RGB test pattern useful for detecting RGB vs BGR issues. You should
       see a red, green and blue stripe from top to bottom.

       The "smptebars" source generates a color bars pattern,  based  on  the  SMPTE  Engineering  Guideline  EG
       1-1990.

       The "smptehdbars" source generates a color bars pattern, based on the SMPTE RP 219-2002.

       The  "testsrc" source generates a test video pattern, showing a color pattern, a scrolling gradient and a
       timestamp. This is mainly intended for testing purposes.

       The "testsrc2" source is similar to testsrc, but supports more pixel formats  instead  of  just  "rgb24".
       This allows using it as an input for other tests without requiring a format conversion.

       The  "yuvtestsrc"  source generates an YUV test pattern. You should see a y, cb and cr stripe from top to
       bottom.

       The sources accept the following parameters:

       <b>level</b>
           Specify the level of the Hald CLUT, only available in  the  "haldclutsrc"  source.  A  level  of  "N"
           generates  a picture of "N*N*N" by "N*N*N" pixels to be used as identity matrix for 3D lookup tables.
           Each component is coded on a "1/(N*N)" scale.

       <b>color,</b> <b>c</b>
           Specify the color of the source, only available in the "color" source. For the syntax of this option,
           check the <b>"Color"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.

       <b>size,</b> <b>s</b>
           Specify the size of the sourced video. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  The default value is "320x240".

           This option is not available with the "allrgb", "allyuv", and "haldclutsrc" filters.

       <b>rate,</b> <b>r</b>
           Specify  the frame rate of the sourced video, as the number of frames generated per second. It has to
           be a string in the format <u>frame_rate_num</u>/<u>frame_rate_den</u>, an integer number, a floating  point  number
           or a valid video frame rate abbreviation. The default value is "25".

       <b>duration,</b> <b>d</b>
           Set  the  duration  of the sourced video. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>
           for the accepted syntax.

           If not specified, or the expressed duration is negative,  the  video  is  supposed  to  be  generated
           forever.

           Since  the  frame  rate  is used as time base, all frames including the last one will have their full
           duration. If the specified duration is not a multiple of the frame duration, it will be rounded up.

       <b>sar</b> Set the sample aspect ratio of the sourced video.

       <b>alpha</b>
           Specify the alpha (opacity) of the background, only available in the  "testsrc2"  source.  The  value
           must be between 0 (fully transparent) and 255 (fully opaque, the default).

       <b>decimals,</b> <b>n</b>
           Set the number of decimals to show in the timestamp, only available in the "testsrc" source.

           The displayed timestamp value will correspond to the original timestamp value multiplied by the power
           of 10 of the specified value. Default value is 0.

       <b>type</b>
           Set  the  type of the color spectrum, only available in the "colorspectrum" source. Can be one of the
           following:

           <b>black</b>
           <b>white</b>
           <b>all</b>
       <b>patch_size</b>
           Set patch size of single color patch, only available in the "colorchart" source. Default is "64x64".

       <b>preset</b>
           Set colorchecker colors preset, only available in the "colorchart" source.

           Available values are:

           <b>reference</b>
           <b>skintones</b>

           Default value is "reference".

       <u>Examples</u>

       •   Generate a video with a duration of 5.3 seconds, with size 176x144 and a frame rate of 10 frames  per
           second:

                   testsrc=duration=5.3:size=qcif:rate=10

       •   The  following  graph description will generate a red source with an opacity of 0.2, with size "qcif"
           and a frame rate of 10 frames per second:

                   color=c=<a href="mailto:red@0.2">red@0.2</a>:s=qcif:r=10

       •   If the input content is to be ignored, "nullsrc" can be used. The following command  generates  noise
           in the luma plane by employing the "geq" filter:

                   nullsrc=s=256x256, geq=<a href="../man1/random.1.html">random</a>(1)*255:128:128

       <u>Commands</u>

       The "color" source supports the following commands:

       <b>c,</b> <b>color</b>
           Set the color of the created image. Accepts the same syntax of the corresponding <b>color</b> option.

   <b>openclsrc</b>
       Generate video using an OpenCL program.

       <b>source</b>
           OpenCL program source file.

       <b>kernel</b>
           Kernel name in program.

       <b>size,</b> <b>s</b>
           Size of frames to generate.  This must be set.

       <b>format</b>
           Pixel format to use for the generated frames.  This must be set.

       <b>rate,</b> <b>r</b>
           Number of frames generated every second.  Default value is '25'.

       For details of how the program loading works, see the <b>program_opencl</b> filter.

       Example programs:

       •   Generate  a  colour  ramp by setting pixel values from the position of the pixel in the output image.
           (Note that this will work with all pixel formats, but the generated output will not be the same.)

                   __kernel void ramp(__write_only image2d_t dst,
                                      unsigned int index)
                   {
                       int2 loc = (int2)(<a href="../man0/get_global_id.0.html">get_global_id</a>(0), <a href="../man1/get_global_id.1.html">get_global_id</a>(1));

                       float4 val;
                       val.xy = val.zw = convert_float2(loc) / convert_float2(get_image_dim(dst));

                       write_imagef(dst, loc, val);
                   }

       •   Generate a Sierpinski carpet pattern, panning by a single pixel each frame.

                   __kernel void sierpinski_carpet(__write_only image2d_t dst,
                                                   unsigned int index)
                   {
                       int2 loc = (int2)(<a href="../man0/get_global_id.0.html">get_global_id</a>(0), <a href="../man1/get_global_id.1.html">get_global_id</a>(1));

                       float4 value = 0.0f;
                       int x = loc.x + index;
                       int y = loc.y + index;
                       while (x &gt; 0 || y &gt; 0) {
                           if (x % 3 == 1 &amp;&amp; y % 3 == 1) {
                               value = 1.0f;
                               break;
                           }
                           x /= 3;
                           y /= 3;
                       }

                       write_imagef(dst, loc, value);
                   }

   <b>sierpinski</b>
       Generate a Sierpinski carpet/triangle fractal, and randomly pan around.

       This source accepts the following options:

       <b>size,</b> <b>s</b>
           Set frame size. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>  <b>in</b>  <b>the</b>  <b>ffmpeg-utils</b>
           <b>manual</b>. Default value is "640x480".

       <b>rate,</b> <b>r</b>
           Set frame rate, expressed as number of frames per second. Default value is "25".

       <b>seed</b>
           Set seed which is used for random panning.

       <b>jump</b>
           Set max jump for single pan destination. Allowed range is from 1 to 10000.

       <b>type</b>
           Set fractal type, can be default "carpet" or "triangle".

   <b>zoneplate</b>
       Generate a zoneplate test video pattern.

       This source accepts the following options:

       <b>size,</b> <b>s</b>
           Set  frame  size.  For  the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b>
           <b>manual</b>. Default value is "320x240".

       <b>rate,</b> <b>r</b>
           Set frame rate, expressed as number of frames per second. Default value is "25".

       <b>duration,</b> <b>d</b>
           Set the duration of the sourced video. See <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b>  <b>the</b>  <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>  <b>manual</b>
           for the accepted syntax.

           If  not  specified,  or  the  expressed  duration  is negative, the video is supposed to be generated
           forever.

       <b>sar</b> Set the sample aspect ratio of the sourced video.

       <b>precision</b>
           Set precision in bits for look-up table for sine calculations. Default value is 10.  Allowed range is
           from 4 to 16.

       <b>xo</b>  Set horizontal axis offset for output signal. Default value is 0.

       <b>yo</b>  Set vertical axis offset for output signal. Default value is 0.

       <b>to</b>  Set time axis offset for output signal. Default value is 0.

       <b>k0</b>  Set 0-order, constant added to signal phase. Default value is 0.

       <b>kx</b>  Set 1-order, phase factor multiplier for horizontal axis. Default value is 0.

       <b>ky</b>  Set 1-order, phase factor multiplier for vertical axis. Default value is 0.

       <b>kt</b>  Set 1-order, phase factor multiplier for time axis. Default value is 0.

       <b>kxt,</b> <b>kyt,</b> <b>kxy</b>
           Set phase factor multipliers for combination of spatial and temporal axis.  Default value is 0.

       <b>kx2</b> Set 2-order, phase factor multiplier for horizontal axis. Default value is 0.

       <b>ky2</b> Set 2-order, phase factor multiplier for vertical axis. Default value is 0.

       <b>kt2</b> Set 2-order, phase factor multiplier for time axis. Default value is 0.

       <b>ku</b>  Set the constant added to final phase to produce chroma-blue component of signal.  Default  value  is
           0.

       <b>kv</b>  Set the constant added to final phase to produce chroma-red component of signal.  Default value is 0.

       <u>Commands</u>

       This source supports the some above options as <b>commands</b>.

       <u>Examples</u>

       •   Generate horizontal color sine sweep:

                   zoneplate=ku=512:kv=0:kt2=0:kx2=256:s=wvga:xo=-426:kt=11

       •   Generate vertical color sine sweep:

                   zoneplate=ku=512:kv=0:kt2=0:ky2=156:s=wvga:yo=-240:kt=11

       •   Generate circular zone-plate:

                   zoneplate=ku=512:kv=100:kt2=0:ky2=256:kx2=556:s=wvga:yo=0:kt=11

</pre><h4><b>VIDEO</b> <b>SINKS</b></h4><pre>
       Below is a description of the currently available video sinks.

   <b>buffersink</b>
       Buffer video frames, and make them available to the end of the filter graph.

       This  sink  is  mainly  intended  for  programmatic  use,  in particular through the interface defined in
       <u>libavfilter/buffersink.h</u> or the options system.

       It accepts a pointer to an AVBufferSinkContext structure, which defines the incoming buffers' formats, to
       be passed as the opaque parameter to "avfilter_init_filter" for initialization.

   <b>nullsink</b>
       Null video sink: do absolutely nothing with the input video. It is mainly useful as a  template  and  for
       use in analysis / debugging tools.

</pre><h4><b>MULTIMEDIA</b> <b>FILTERS</b></h4><pre>
       Below is a description of the currently available multimedia filters.

   <b>a3dscope</b>
       Convert input audio to 3d scope video output.

       The filter accepts the following options:

       <b>rate,</b> <b>r</b>
           Set frame rate, expressed as number of frames per second. Default value is "25".

       <b>size,</b> <b>s</b>
           Specify  the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "hd720".

       <b>fov</b> Set the camera field of view. Default is 90 degrees.  Allowed range is from 40 to 150.

       <b>roll</b>
           Set the camera roll.

       <b>pitch</b>
           Set the camera pitch.

       <b>yaw</b> Set the camera yaw.

       <b>xzoom</b>
           Set the camera zoom on X-axis.

       <b>yzoom</b>
           Set the camera zoom on Y-axis.

       <b>zzoom</b>
           Set the camera zoom on Z-axis.

       <b>xpos</b>
           Set the camera position on X-axis.

       <b>ypos</b>
           Set the camera position on Y-axis.

       <b>zpos</b>
           Set the camera position on Z-axis.

       <b>length</b>
           Set the length of displayed audio waves in number of frames.

       <u>Commands</u>

       Filter supports the some above options as <b>commands</b>.

   <b>abitscope</b>
       Convert input audio to a video output, displaying the audio bit scope.

       The filter accepts the following options:

       <b>rate,</b> <b>r</b>
           Set frame rate, expressed as number of frames per second. Default value is "25".

       <b>size,</b> <b>s</b>
           Specify the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "1024x256".

       <b>colors</b>
           Specify list of colors separated by space or by '|' which will be used to draw channels. Unrecognized
           or missing colors will be replaced by white color.

       <b>mode,</b> <b>m</b>
           Set output mode. Can be "bars" or "trace". Default is "bars".

   <b>adrawgraph</b>
       Draw a graph using input audio metadata.

       See <b>drawgraph</b>

   <b>agraphmonitor</b>
       See <b>graphmonitor</b>.

   <b>ahistogram</b>
       Convert input audio to a video output, displaying the volume histogram.

       The filter accepts the following options:

       <b>dmode</b>
           Specify how histogram is calculated.

           It accepts the following values:

           <b>single</b>
               Use single histogram for all channels.

           <b>separate</b>
               Use separate histogram for each channel.

           Default is "single".

       <b>rate,</b> <b>r</b>
           Set frame rate, expressed as number of frames per second. Default value is "25".

       <b>size,</b> <b>s</b>
           Specify  the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "hd720".

       <b>scale</b>
           Set display scale.

           It accepts the following values:

           <b>log</b> logarithmic

           <b>sqrt</b>
               square root

           <b>cbrt</b>
               cubic root

           <b>lin</b> linear

           <b>rlog</b>
               reverse logarithmic

           Default is "log".

       <b>ascale</b>
           Set amplitude scale.

           It accepts the following values:

           <b>log</b> logarithmic

           <b>lin</b> linear

           Default is "log".

       <b>acount</b>
           Set how much frames to accumulate in histogram.  Default is 1. Setting this  to  -1  accumulates  all
           frames.

       <b>rheight</b>
           Set histogram ratio of window height.

       <b>slide</b>
           Set sonogram sliding.

           It accepts the following values:

           <b>replace</b>
               replace old rows with new ones.

           <b>scroll</b>
               scroll from top to bottom.

           Default is "replace".

       <b>hmode</b>
           Set histogram mode.

           It accepts the following values:

           <b>abs</b> Use absolute values of samples.

           <b>sign</b>
               Use untouched values of samples.

           Default is "abs".

   <b>aphasemeter</b>
       Measures phase of input audio, which is exported as metadata "lavfi.aphasemeter.phase", representing mean
       phase of current audio frame. A video output can also be produced and is enabled by default. The audio is
       passed through as first output.

       Audio  will  be  rematrixed to stereo if it has a different channel layout. Phase value is in range "[-1,
       1]" where -1 means left and right channels are completely out of phase and 1 means channels are in phase.

       The filter accepts the following options, all related to its video output:

       <b>rate,</b> <b>r</b>
           Set the output frame rate. Default value is 25.

       <b>size,</b> <b>s</b>
           Set the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>  <b>in</b>
           <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "800x400".

       <b>rc</b>
       <b>gc</b>
       <b>bc</b>  Specify the red, green, blue contrast. Default values are 2, 7 and 1.  Allowed range is "[0, 255]".

       <b>mpc</b> Set color which will be used for drawing median phase. If color is "none" which is default, no median
           phase value will be drawn.

       <b>video</b>
           Enable video output. Default is enabled.

       <u>phasing</u> <u>detection</u>

       The  filter  also detects out of phase and mono sequences in stereo streams.  It logs the sequence start,
       end and duration when it lasts longer or as long as the minimum set.

       The filter accepts the following options for this detection:

       <b>phasing</b>
           Enable mono and out of phase detection. Default is disabled.

       <b>tolerance,</b> <b>t</b>
           Set phase tolerance for mono detection, in amplitude ratio. Default is 0.  Allowed range is "[0, 1]".

       <b>angle,</b> <b>a</b>
           Set angle threshold for out of phase detection, in degree. Default is 170.  Allowed  range  is  "[90,
           180]".

       <b>duration,</b> <b>d</b>
           Set mono or out of phase duration until notification, expressed in seconds. Default is 2.

       <u>Examples</u>

       •   Complete example with <b>ffmpeg</b> to detect 1 second of mono with 0.001 phase tolerance:

                   ffmpeg -i stereo.wav -af aphasemeter=video=0:phasing=1:duration=1:tolerance=0.001 -f null -

   <b>avectorscope</b>
       Convert input audio to a video output, representing the audio vector scope.

       The  filter is used to measure the difference between channels of stereo audio stream. A monaural signal,
       consisting of identical left and right signal, results in straight vertical line. Any  stereo  separation
       is  visible  as  a  deviation from this line, creating a Lissajous figure.  If the straight (or deviation
       from it) but horizontal line appears this indicates that the left and right channels are out of phase.

       The filter accepts the following options:

       <b>mode,</b> <b>m</b>
           Set the vectorscope mode.

           Available values are:

           <b>lissajous</b>
               Lissajous rotated by 45 degrees.

           <b>lissajous_xy</b>
               Same as above but not rotated.

           <b>polar</b>
               Shape resembling half of circle.

           Default value is <b>lissajous</b>.

       <b>size,</b> <b>s</b>
           Set the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>  <b>in</b>
           <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "400x400".

       <b>rate,</b> <b>r</b>
           Set the output frame rate. Default value is 25.

       <b>rc</b>
       <b>gc</b>
       <b>bc</b>
       <b>ac</b>  Specify  the  red,  green,  blue and alpha contrast. Default values are 40, 160, 80 and 255.  Allowed
           range is "[0, 255]".

       <b>rf</b>
       <b>gf</b>
       <b>bf</b>
       <b>af</b>  Specify the red, green, blue and alpha fade. Default values are 15, 10, 5 and 5.   Allowed  range  is
           "[0, 255]".

       <b>zoom</b>
           Set  the  zoom factor. Default value is 1. Allowed range is "[0, 10]".  Values lower than <u>1</u> will auto
           adjust zoom factor to maximal possible value.

       <b>draw</b>
           Set the vectorscope drawing mode.

           Available values are:

           <b>dot</b> Draw dot for each sample.

           <b>line</b>
               Draw line between previous and current sample.

           <b>aaline</b>
               Draw anti-aliased line between previous and current sample.

           Default value is <b>dot</b>.

       <b>scale</b>
           Specify amplitude scale of audio samples.

           Available values are:

           <b>lin</b> Linear.

           <b>sqrt</b>
               Square root.

           <b>cbrt</b>
               Cubic root.

           <b>log</b> Logarithmic.

       <b>swap</b>
           Swap left channel axis with right channel axis.

       <b>mirror</b>
           Mirror axis.

           <b>none</b>
               No mirror.

           <b>x</b>   Mirror only x axis.

           <b>y</b>   Mirror only y axis.

           <b>xy</b>  Mirror both axis.

       <u>Examples</u>

       •   Complete example using <b>ffplay</b>:

                   ffplay -f lavfi 'amovie=input.mp3, asplit [a][out1];
                                [a] avectorscope=zoom=1.3:rc=2:gc=200:bc=10:rf=1:gf=8:bf=7 [out0]'

       <u>Commands</u>

       This filter supports the all above options as commands except options "size" and "rate".

   <b>bench,</b> <b>abench</b>
       Benchmark part of a filtergraph.

       The filter accepts the following options:

       <b>action</b>
           Start or stop a timer.

           Available values are:

           <b>start</b>
               Get the current time, set it as frame metadata  (using  the  key  "lavfi.bench.start_time"),  and
               forward the frame to the next filter.

           <b>stop</b>
               Get  the  current  time  and  fetch  the  "lavfi.bench.start_time"  metadata from the input frame
               metadata to get  the  time  difference.  Time  difference,  average,  maximum  and  minimum  time
               (respectively  "t",  "avg",  "max"  and  "min") are then printed. The timestamps are expressed in
               seconds.

       <u>Examples</u>

       •   Benchmark <b>selectivecolor</b> filter:

                   bench=start,selectivecolor=reds=-.2 .12 -.49,bench=stop

   <b>concat</b>
       Concatenate audio and video streams, joining them together one after the other.

       The filter works on segments of synchronized video and audio streams. All segments  must  have  the  same
       number of streams of each type, and that will also be the number of streams at output.

       The filter accepts the following options:

       <b>n</b>   Set the number of segments. Default is 2.

       <b>v</b>   Set  the  number  of  output video streams, that is also the number of video streams in each segment.
           Default is 1.

       <b>a</b>   Set the number of output audio streams, that is also the number of audio  streams  in  each  segment.
           Default is 0.

       <b>unsafe</b>
           Activate unsafe mode: do not fail if segments have a different format.

       The filter has <u>v</u>+<u>a</u> outputs: first <u>v</u> video outputs, then <u>a</u> audio outputs.

       There  are <u>n</u>x(<u>v</u>+<u>a</u>) inputs: first the inputs for the first segment, in the same order as the outputs, then
       the inputs for the second segment, etc.

       Related streams do not always have exactly the same duration, for various reasons including  codec  frame
       size  or  sloppy  authoring.  For  that  reason, related synchronized streams (e.g. a video and its audio
       track) should be concatenated at once. The concat filter will use the duration of the longest  stream  in
       each segment (except the last one), and if necessary pad shorter audio streams with silence.

       For this filter to work correctly, all segments must start at timestamp 0.

       All  corresponding  streams  must  have  the  same  parameters in all segments; the filtering system will
       automatically select a common pixel format for video streams, and a common sample format, sample rate and
       channel layout for audio streams, but other settings, such as resolution, must be converted explicitly by
       the user.

       Different frame rates are acceptable but will result in  variable  frame  rate  at  output;  be  sure  to
       configure the output file to handle it.

       <u>Examples</u>

       •   Concatenate  an opening, an episode and an ending, all in bilingual version (video in stream 0, audio
           in streams 1 and 2):

                   ffmpeg -i opening.mkv -i episode.mkv -i ending.mkv -filter_complex \
                     '[0:0] [0:1] [0:2] [1:0] [1:1] [1:2] [2:0] [2:1] [2:2]
                      concat=n=3:v=1:a=2 [v] [a1] [a2]' \
                     -map '[v]' -map '[a1]' -map '[a2]' output.mkv

       •   Concatenate two parts, handling audio and video separately, using the (a)movie sources, and adjusting
           the resolution:

                   movie=part1.mp4, scale=512:288 [v1] ; amovie=part1.mp4 [a1] ;
                   movie=part2.mp4, scale=512:288 [v2] ; amovie=part2.mp4 [a2] ;
                   [v1] [v2] concat [outv] ; [a1] [a2] concat=v=0:a=1 [outa]

           Note that a desync will happen at the stitch if the audio and video streams do not have  exactly  the
           same duration in the first file.

       <u>Commands</u>

       This filter supports the following commands:

       <b>next</b>
           Close the current segment and step to the next one

   <b>ebur128</b>
       EBU  R128  scanner filter. This filter takes an audio stream and analyzes its loudness level. By default,
       it logs a message at a frequency of 10Hz with the Momentary  loudness  (identified  by  "M"),  Short-term
       loudness ("S"), Integrated loudness ("I") and Loudness Range ("LRA").

       The  filter  can  only  analyze  streams which have sample format is double-precision floating point. The
       input stream will be converted to this specification, if needed. Users may need to insert aformat  and/or
       aresample filters after this filter to obtain the original parameters.

       The  filter also has a video output (see the <u>video</u> option) with a real time graph to observe the loudness
       evolution. The graphic contains the logged message mentioned above, so it is  not  printed  anymore  when
       this  option  is  set,  unless the verbose logging is set. The main graphing area contains the short-term
       loudness (3 seconds of analysis), and the  gauge  on  the  right  is  for  the  momentary  loudness  (400
       milliseconds), but can optionally be configured to instead display short-term loudness (see <u>gauge</u>).

       The  green  area  marks  a   +/-  1LU target range around the target loudness (-23LUFS by default, unless
       modified through <u>target</u>).

       More information about the Loudness Recommendation EBU R128 on &lt;<b><a href="http://tech.ebu.ch/loudness">http://tech.ebu.ch/loudness</a></b>&gt;.

       The filter accepts the following options:

       <b>video</b>
           Activate the video output. The audio stream is passed unchanged whether this option is set or no. The
           video stream will be the first output stream if activated. Default is 0.

       <b>size</b>
           Set the video size. This option is for video only. For the syntax of this option,  check  the  <b>"Video</b>
           <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default and minimum resolution is "640x480".

       <b>meter</b>
           Set  the  EBU scale meter. Default is 9. Common values are 9 and 18, respectively for EBU scale meter
           +9 and EBU scale meter +18. Any other integer value between this range is allowed.

       <b>metadata</b>
           Set metadata injection. If set to 1, the audio input will be segmented into 100ms output frames, each
           of them containing various loudness information in metadata.  All the metadata keys are prefixed with
           "lavfi.r128.".

           Default is 0.

       <b>framelog</b>
           Force the frame logging level.

           Available values are:

           <b>quiet</b>
               logging disabled

           <b>info</b>
               information logging level

           <b>verbose</b>
               verbose logging level

           By default, the logging level is set to <u>info</u>. If the <b>video</b>  or  the  <b>metadata</b>  options  are  set,  it
           switches to <u>verbose</u>.

       <b>peak</b>
           Set peak mode(s).

           Available modes can be cumulated (the option is a "flag" type). Possible values are:

           <b>none</b>
               Disable any peak mode (default).

           <b>sample</b>
               Enable sample-peak mode.

               Simple  peak  mode  looking  for  the  higher  sample  value.  It  logs a message for sample-peak
               (identified by "SPK").

           <b>true</b>
               Enable true-peak mode.

               If enabled, the peak lookup is done on an over-sampled version of the  input  stream  for  better
               peak  accuracy.  It  logs a message for true-peak.  (identified by "TPK") and true-peak per frame
               (identified by "FTPK").  This mode requires a build with "libswresample".

       <b>dualmono</b>
           Treat mono input files as "dual mono". If a mono file is intended for playback on  a  stereo  system,
           its  EBU  R128  measurement  will  be  perceptually  incorrect.   If  set to "true", this option will
           compensate for this effect.  Multi-channel input files are not affected by this option.

       <b>panlaw</b>
           Set a specific pan law to be used for  the  measurement  of  dual  mono  files.   This  parameter  is
           optional, and has a default value of -3.01dB.

       <b>target</b>
           Set  a specific target level (in LUFS) used as relative zero in the visualization.  This parameter is
           optional and has a default value of -23LUFS as specified by EBU  R128.  However,  material  published
           online may prefer a level of -16LUFS (e.g. for use with podcasts or video platforms).

       <b>gauge</b>
           Set  the value displayed by the gauge. Valid values are "momentary" and s "shortterm". By default the
           momentary value will be used, but in certain scenarios it may be more useful  to  observe  the  short
           term value instead (e.g.  live mixing).

       <b>scale</b>
           Sets the display scale for the loudness. Valid parameters are "absolute" (in LUFS) or "relative" (LU)
           relative to the target. This only affects the video output, not the summary or continuous log output.

       <b>integrated</b>
           Read-only exported value for measured integrated loudness, in LUFS.

       <b>range</b>
           Read-only exported value for measured loudness range, in LU.

       <b>lra_low</b>
           Read-only exported value for measured LRA low, in LUFS.

       <b>lra_high</b>
           Read-only exported value for measured LRA high, in LUFS.

       <b>sample_peak</b>
           Read-only exported value for measured sample peak, in dBFS.

       <b>true_peak</b>
           Read-only exported value for measured true peak, in dBFS.

       <u>Examples</u>

       •   Real-time graph using <b>ffplay</b>, with a EBU scale meter +18:

                   ffplay -f lavfi -i "amovie=input.mp3,ebur128=video=1:meter=18 [out0][out1]"

       •   Run an analysis with <b>ffmpeg</b>:

                   ffmpeg -nostats -i input.mp3 -filter_complex ebur128 -f null -

   <b>interleave,</b> <b>ainterleave</b>
       Temporally interleave frames from several inputs.

       "interleave" works with video inputs, "ainterleave" with audio.

       These filters read frames from several inputs and send the oldest queued frame to the output.

       Input streams must have well defined, monotonically increasing frame timestamp values.

       In  order to submit one frame to output, these filters need to enqueue at least one frame for each input,
       so they cannot work in case one input is not yet terminated and will not receive incoming frames.

       For example consider the case when one input is a "select" filter which always drops  input  frames.  The
       "interleave"  filter  will  keep reading from that input, but it will never be able to send new frames to
       output until the input sends an end-of-stream signal.

       Also, depending on inputs synchronization, the filters will drop frames in case one input  receives  more
       frames than the other ones, and the queue is already filled.

       These filters accept the following options:

       <b>nb_inputs,</b> <b>n</b>
           Set the number of different inputs, it is 2 by default.

       <b>duration</b>
           How to determine the end-of-stream.

           <b>longest</b>
               The duration of the longest input. (default)

           <b>shortest</b>
               The duration of the shortest input.

           <b>first</b>
               The duration of the first input.

       <u>Examples</u>

       •   Interleave frames belonging to different streams using <b>ffmpeg</b>:

                   ffmpeg -i bambi.avi -i pr0n.mkv -filter_complex "[0:v][1:v] interleave" out.avi

       •   Add flickering blur effect:

                   select='if(gt(<a href="../man0/random.0.html">random</a>(0), 0.2), 1, 2)':n=2 [tmp], boxblur=2:2, [tmp] interleave

   <b>latency,</b> <b>alatency</b>
       Measure filtering latency.

       Report previous filter filtering latency, delay in number of audio samples for audio filters or number of
       video frames for video filters.

       On  end  of  input stream, filter will report min and max measured latency for previous running filter in
       filtergraph.

   <b>metadata,</b> <b>ametadata</b>
       Manipulate frame metadata.

       This filter accepts the following options:

       <b>mode</b>
           Set mode of operation of the filter.

           Can be one of the following:

           <b>select</b>
               If both "value" and "key" is set, select frames which have such metadata. If only "key"  is  set,
               select every frame that has such key in metadata.

           <b>add</b> Add new metadata "key" and "value". If key is already available do nothing.

           <b>modify</b>
               Modify value of already present key.

           <b>delete</b>
               If "value" is set, delete only keys that have such value.  Otherwise, delete key. If "key" is not
               set, delete all metadata values in the frame.

           <b>print</b>
               Print  key  and  its  value  if metadata was found. If "key" is not set print all metadata values
               available in frame.

       <b>key</b> Set key used with all modes. Must be set for all modes except "print" and "delete".

       <b>value</b>
           Set metadata value which will be used. This option is mandatory for "modify" and "add" mode.

       <b>function</b>
           Which function to use when comparing metadata value and "value".

           Can be one of following:

           <b>same_str</b>
               Values are interpreted as strings, returns true if metadata value is same as "value".

           <b>starts_with</b>
               Values are interpreted as strings, returns true if metadata value starts with the "value"  option
               string.

           <b>less</b>
               Values are interpreted as floats, returns true if metadata value is less than "value".

           <b>equal</b>
               Values are interpreted as floats, returns true if "value" is equal with metadata value.

           <b>greater</b>
               Values are interpreted as floats, returns true if metadata value is greater than "value".

           <b>expr</b>
               Values  are  interpreted  as  floats,  returns true if expression from option "expr" evaluates to
               true.

           <b>ends_with</b>
               Values are interpreted as strings, returns true if metadata value ends with  the  "value"  option
               string.

       <b>expr</b>
           Set  expression  which is used when "function" is set to "expr".  The expression is evaluated through
           the eval API and can contain the following constants:

           <b>VALUE1,</b> <b>FRAMEVAL</b>
               Float representation of "value" from metadata key.

           <b>VALUE2,</b> <b>USERVAL</b>
               Float representation of "value" as supplied by user in "value" option.

       <b>file</b>
           If specified in "print" mode, output is written to the named file.  Instead  of  plain  filename  any
           writable url can be specified. Filename ``-'' is a shorthand for standard output. If "file" option is
           not set, output is written to the log with AV_LOG_INFO loglevel.

       <b>direct</b>
           Reduces buffering in print mode when output is written to a URL set using <u>file</u>.

       <u>Examples</u>

       •   Print all metadata values for frames with key "lavfi.signalstats.YDIF" with values between 0 and 1.

                   signalstats,metadata=print:key=lavfi.signalstats.YDIF:value=0:function=expr:expr='between(VALUE1,0,1)'

       •   Print silencedetect output to file <u>metadata.txt</u>.

                   silencedetect,ametadata=mode=print:file=metadata.txt

       •   Direct all metadata to a pipe with file descriptor 4.

                   metadata=mode=print:file='pipe\:4'

   <b>perms,</b> <b>aperms</b>
       Set read/write permissions for the output frames.

       These  filters  are  mainly  aimed  at  developers  to  test  direct  path in the following filter in the
       filtergraph.

       The filters accept the following options:

       <b>mode</b>
           Select the permissions mode.

           It accepts the following values:

           <b>none</b>
               Do nothing. This is the default.

           <b>ro</b>  Set all the output frames read-only.

           <b>rw</b>  Set all the output frames directly writable.

           <b>toggle</b>
               Make the frame read-only if writable, and writable if read-only.

           <b>random</b>
               Set each output frame read-only or writable randomly.

       <b>seed</b>
           Set the seed for the <u>random</u> mode, must be an integer included between  0  and  "UINT32_MAX".  If  not
           specified, or if explicitly set to -1, the filter will try to use a good random seed on a best effort
           basis.

       Note: in case of auto-inserted filter between the permission filter and the following one, the permission
       might  not  be received as expected in that following filter. Inserting a <b>format</b> or <b>aformat</b> filter before
       the perms/aperms filter can avoid this problem.

   <b>realtime,</b> <b>arealtime</b>
       Slow down filtering to match real time approximately.

       These filters will pause the filtering for a variable amount of time to match the output  rate  with  the
       input timestamps.  They are similar to the <b>re</b> option to "ffmpeg".

       They accept the following options:

       <b>limit</b>
           Time  limit  for  the pauses. Any pause longer than that will be considered a timestamp discontinuity
           and reset the timer. Default is 2 seconds.

       <b>speed</b>
           Speed factor for processing. The value must be a float larger than zero.  Values larger than 1.0 will
           result in faster  than  realtime  processing,  smaller  will  slow  processing  down.  The  <u>limit</u>  is
           automatically adapted accordingly. Default is 1.0.

           A processing speed faster than what is possible without these filters cannot be achieved.

       <u>Commands</u>

       Both filters supports the all above options as <b>commands</b>.

   <b>segment,</b> <b>asegment</b>
       Split single input stream into multiple streams.

       This filter does opposite of concat filters.

       "segment" works on video frames, "asegment" on audio samples.

       This filter accepts the following options:

       <b>timestamps</b>
           Timestamps  of output segments separated by '|'. The first segment will run from the beginning of the
           input stream. The last segment will run until the end of the input stream

       <b>frames,</b> <b>samples</b>
           Exact frame/sample count to split the segments.

       In all cases, prefixing an each segment with '+' will make it relative to the previous segment.

       <u>Examples</u>

       •   Split input audio stream into three output audio streams, starting at start of input audio stream and
           storing that in 1st output audio stream, then following at 60th second and storing than in 2nd output
           audio stream, and last after 150th second of input audio stream store in 3rd output audio stream:

                   asegment=timestamps="60|150"

   <b>select,</b> <b>aselect</b>
       Select frames to pass in output.

       This filter accepts the following options:

       <b>expr,</b> <b>e</b>
           Set expression, which is evaluated for each input frame.

           If the expression is evaluated to zero, the frame is discarded.

           If the evaluation result is negative or NaN, the frame is sent to the first output; otherwise  it  is
           sent to the output with index "ceil(val)-1", assuming that the input index starts from 0.

           For  example a value of 1.2 corresponds to the output with index "ceil(1.2)-1 = 2-1 = 1", that is the
           second output.

       <b>outputs,</b> <b>n</b>
           Set the number of outputs. The output to which to send the selected frame is based on the  result  of
           the evaluation. Default value is 1.

       The expression can contain the following constants:

       <b>n</b>   The (sequential) number of the filtered frame, starting from 0.

       <b>selected_n</b>
           The (sequential) number of the selected frame, starting from 0.

       <b>prev_selected_n</b>
           The sequential number of the last selected frame. It's NAN if undefined.

       <b>TB</b>  The timebase of the input timestamps.

       <b>pts</b> The PTS (Presentation TimeStamp) of the filtered frame, expressed in <u>TB</u> units. It's NAN if undefined.

       <b>t</b>   The PTS of the filtered frame, expressed in seconds. It's NAN if undefined.

       <b>prev_pts</b>
           The PTS of the previously filtered frame. It's NAN if undefined.

       <b>prev_selected_pts</b>
           The PTS of the last previously filtered frame. It's NAN if undefined.

       <b>prev_selected_t</b>
           The PTS of the last previously selected frame, expressed in seconds. It's NAN if undefined.

       <b>start_pts</b>
           The first PTS in the stream which is not NAN. It remains NAN if not found.

       <b>start_t</b>
           The first PTS, in seconds, in the stream which is not NAN. It remains NAN if not found.

       <b>pict_type</b> <u>(video</u> <u>only)</u>
           The type of the filtered frame. It can assume one of the following values:

           <b>I</b>
           <b>P</b>
           <b>B</b>
           <b>S</b>
           <b>SI</b>
           <b>SP</b>
           <b>BI</b>
       <b>interlace_type</b> <u>(video</u> <u>only)</u>
           The frame interlace type. It can assume one of the following values:

           <b>PROGRESSIVE</b>
               The frame is progressive (not interlaced).

           <b>TOPFIRST</b>
               The frame is top-field-first.

           <b>BOTTOMFIRST</b>
               The frame is bottom-field-first.

       <b>consumed_sample_n</b> <u>(audio</u> <u>only)</u>
           the number of selected samples before the current frame

       <b>samples_n</b> <u>(audio</u> <u>only)</u>
           the number of samples in the current frame

       <b>sample_rate</b> <u>(audio</u> <u>only)</u>
           the input sample rate

       <b>key</b> This is 1 if the filtered frame is a key-frame, 0 otherwise.

       <b>pos</b> the  position  in  the  file  of the filtered frame, -1 if the information is not available (e.g. for
           synthetic video); deprecated, do not use

       <b>scene</b> <u>(video</u> <u>only)</u>
           value between 0 and 1 to indicate a new scene; a low value reflects a low probability for the current
           frame to introduce a new scene, while a higher value means the current frame is more likely to be one
           (see the example below)

       <b>concatdec_select</b>
           The concat demuxer can select only part of a concat input file by setting an inpoint and an outpoint,
           but the output packets may not be  entirely  contained  in  the  selected  interval.  By  using  this
           variable,  it  is  possible  to  skip  frames  generated  by the concat demuxer which are not exactly
           contained in the selected interval.

           This works by comparing the frame pts against the <u>lavf.concat.start_time</u> and the <u>lavf.concat.duration</u>
           packet metadata values which are also present in the decoded frames.

           The <u>concatdec_select</u> variable is -1 if the frame pts is at least start_time and either  the  duration
           metadata  is missing or the frame pts is less than start_time + duration, 0 otherwise, and NaN if the
           start_time metadata is missing.

           That basically means that an input frame is selected if its pts is within the  interval  set  by  the
           concat demuxer.

       <b>iw</b> <u>(video</u> <u>only)</u>
           Represents the width of the input video frame.

       <b>ih</b> <u>(video</u> <u>only)</u>
           Represents the height of the input video frame.

       <b>view</b> <u>(video</u> <u>only)</u>
           View ID for multi-view video.

       The default value of the select expression is "1".

       <u>Examples</u>

       •   Select all frames in input:

                   select

           The example above is the same as:

                   select=1

       •   Skip all frames:

                   select=0

       •   Select only I-frames:

                   select='eq(pict_type\,I)'

       •   Select one frame every 100:

                   select='not(mod(n\,100))'

       •   Select only frames contained in the 10-20 time interval:

                   select=between(t\,10\,20)

       •   Select only I-frames contained in the 10-20 time interval:

                   select=between(t\,10\,20)*eq(pict_type\,I)

       •   Select frames with a minimum distance of 10 seconds:

                   select='isnan(prev_selected_t)+gte(t-prev_selected_t\,10)'

       •   Use aselect to select only audio frames with samples number &gt; 100:

                   aselect='gt(samples_n\,100)'

       •   Create a mosaic of the first scenes:

                   ffmpeg -i video.avi -vf select='gt(scene\,0.4)',scale=160:120,tile -frames:v 1 preview.png

           Comparing <u>scene</u> against a value between 0.3 and 0.5 is generally a sane choice.

       •   Send even and odd frames to separate outputs, and compose them:

                   select=n=2:e='mod(n, 2)+1' [odd][even]; [odd] pad=h=2*ih [tmp]; [tmp][even] overlay=y=h

       •   Select useful frames from an ffconcat file which is using inpoints and outpoints but where the source
           files are not intra frame only.

                   ffmpeg -copyts -vsync 0 -segment_time_metadata 1 -i input.ffconcat -vf select=concatdec_select -af aselect=concatdec_select output.avi

   <b>sendcmd,</b> <b>asendcmd</b>
       Send commands to filters in the filtergraph.

       These filters read commands to be sent to other filters in the filtergraph.

       "sendcmd"  must  be  inserted  between  two  video filters, "asendcmd" must be inserted between two audio
       filters, but apart from that they act the same way.

       The specification of commands can be provided in the filter arguments with the <u>commands</u> option, or  in  a
       file specified by the <u>filename</u> option.

       These filters accept the following options:

       <b>commands,</b> <b>c</b>
           Set the commands to be read and sent to the other filters.

       <b>filename,</b> <b>f</b>
           Set the filename of the commands to be read and sent to the other filters.

       <u>Commands</u> <u>syntax</u>

       A  commands  description consists of a sequence of interval specifications, comprising a list of commands
       to be executed when a particular event related to that interval occurs. The occurring event is  typically
       the current frame time entering or leaving a given time interval.

       An interval is specified by the following syntax:

               &lt;START&gt;[-&lt;END&gt;] &lt;COMMANDS&gt;;

       The  time  interval is specified by the <u>START</u> and <u>END</u> times.  <u>END</u> is optional and defaults to the maximum
       time.

       The current frame time is considered within the specified interval if it  is  included  in  the  interval
       [<u>START</u>, <u>END</u>), that is when the time is greater or equal to <u>START</u> and is lesser than <u>END</u>.

       <u>COMMANDS</u> consists of a sequence of one or more command specifications, separated by ",", relating to that
       interval.  The syntax of a command specification is given by:

               [&lt;FLAGS&gt;] &lt;TARGET&gt; &lt;COMMAND&gt; &lt;ARG&gt;

       <u>FLAGS</u> is optional and specifies the type of events relating to the time interval which enable sending the
       specified  command,  and  must  be  a  non-null  sequence of identifier flags separated by "+" or "|" and
       enclosed between "[" and "]".

       The following flags are recognized:

       <b>enter</b>
           The command is sent when the current frame timestamp enters the specified interval. In  other  words,
           the  command is sent when the previous frame timestamp was not in the given interval, and the current
           is.

       <b>leave</b>
           The command is sent when the current frame timestamp leaves the specified interval. In  other  words,
           the  command  is sent when the previous frame timestamp was in the given interval, and the current is
           not.

       <b>expr</b>
           The command <u>ARG</u> is interpreted as expression and result of expression is passed as <u>ARG</u>.

           The expression is evaluated through the eval API and can contain the following constants:

           <b>POS</b> Original position in the file of the frame, or undefined if  undefined  for  the  current  frame.
               Deprecated, do not use.

           <b>PTS</b> The presentation timestamp in input.

           <b>N</b>   The count of the input frame for video or audio, starting from 0.

           <b>T</b>   The time in seconds of the current frame.

           <b>TS</b>  The start time in seconds of the current command interval.

           <b>TE</b>  The end time in seconds of the current command interval.

           <b>TI</b>  The interpolated time of the current command interval, TI = (T - TS) / (TE - TS).

           <b>W</b>   The video frame width.

           <b>H</b>   The video frame height.

       If <u>FLAGS</u> is not specified, a default value of "[enter]" is assumed.

       <u>TARGET</u>  specifies  the  target  of the command, usually the name of the filter class or a specific filter
       instance name.

       <u>COMMAND</u> specifies the name of the command for the target filter.

       <u>ARG</u> is optional and specifies the optional list of argument for the given <u>COMMAND</u>.

       Between one interval specification and another, whitespaces, or sequences of characters starting with "#"
       until the end of line, are ignored and can be used to annotate comments.

       A simplified BNF description of the commands specification syntax follows:

               &lt;COMMAND_FLAG&gt;  ::= "enter" | "leave"
               &lt;COMMAND_FLAGS&gt; ::= &lt;COMMAND_FLAG&gt; [(+|"|")&lt;COMMAND_FLAG&gt;]
               &lt;COMMAND&gt;       ::= ["[" &lt;COMMAND_FLAGS&gt; "]"] &lt;TARGET&gt; &lt;COMMAND&gt; [&lt;ARG&gt;]
               &lt;COMMANDS&gt;      ::= &lt;COMMAND&gt; [,&lt;COMMANDS&gt;]
               &lt;INTERVAL&gt;      ::= &lt;START&gt;[-&lt;END&gt;] &lt;COMMANDS&gt;
               &lt;INTERVALS&gt;     ::= &lt;INTERVAL&gt;[;&lt;INTERVALS&gt;]

       <u>Examples</u>

       •   Specify audio tempo change at second 4:

                   asendcmd=c='4.0 atempo tempo 1.5',atempo

       •   Target a specific filter instance:

                   asendcmd=c='4.0 atempo@my tempo 1.5',atempo@my

       •   Specify a list of drawtext and hue commands in a file.

                   # show text in the interval 5-10
                   5.0-10.0 [enter] drawtext reinit 'fontfile=FreeSerif.ttf:text=hello world',
                            [leave] drawtext reinit 'fontfile=FreeSerif.ttf:text=';

                   # desaturate the image in the interval 15-20
                   15.0-20.0 [enter] hue s 0,
                             [enter] drawtext reinit 'fontfile=FreeSerif.ttf:text=nocolor',
                             [leave] hue s 1,
                             [leave] drawtext reinit 'fontfile=FreeSerif.ttf:text=color';

                   # apply an exponential saturation fade-out effect, starting from time 25
                   25 [enter] hue s exp(25-t)

           A filtergraph allowing to read and process the above command list stored in a file <u>test.cmd</u>,  can  be
           specified with:

                   sendcmd=f=test.cmd,drawtext=fontfile=FreeSerif.ttf:text='',hue

   <b>setpts,</b> <b>asetpts</b>
       Change the PTS (presentation timestamp) of the input frames.

       "setpts" works on video frames, "asetpts" on audio frames.

       This filter accepts the following options:

       <b>expr</b>
           The expression which is evaluated for each frame to construct its timestamp.

       The expression is evaluated through the eval API and can contain the following constants:

       <b>FRAME_RATE,</b> <b>FR</b>
           frame rate, only defined for constant frame-rate video

       <b>PTS</b> The presentation timestamp in input

       <b>N</b>   The  count  of the input frame for video or the number of consumed samples, not including the current
           frame for audio, starting from 0.

       <b>NB_CONSUMED_SAMPLES</b>
           The number of consumed samples, not including the current frame (only audio)

       <b>NB_SAMPLES,</b> <b>S</b>
           The number of samples in the current frame (only audio)

       <b>SAMPLE_RATE,</b> <b>SR</b>
           The audio sample rate.

       <b>STARTPTS</b>
           The PTS of the first frame.

       <b>STARTT</b>
           the time in seconds of the first frame

       <b>INTERLACED</b>
           State whether the current frame is interlaced.

       <b>T</b>   the time in seconds of the current frame

       <b>POS</b> original position in the file of the  frame,  or  undefined  if  undefined  for  the  current  frame;
           deprecated, do not use

       <b>PREV_INPTS</b>
           The previous input PTS.

       <b>PREV_INT</b>
           previous input time in seconds

       <b>PREV_OUTPTS</b>
           The previous output PTS.

       <b>PREV_OUTT</b>
           previous output time in seconds

       <b>RTCTIME</b>
           The wallclock (RTC) time in microseconds. This is deprecated, use <b><a href="../man0/time.0.html">time</a></b>(0) instead.

       <b>RTCSTART</b>
           The wallclock (RTC) time at the start of the movie in microseconds.

       <b>TB</b>  The timebase of the input timestamps.

       <b>T_CHANGE</b>
           Time of the first frame after command was applied or time of the first frame if no commands.

       <u>Examples</u>

       •   Start counting PTS from zero

                   setpts=PTS-STARTPTS

       •   Apply fast motion effect:

                   setpts=0.5*PTS

       •   Apply slow motion effect:

                   setpts=2.0*PTS

       •   Set fixed rate of 25 frames per second:

                   setpts=N/(25*TB)

       •   Apply a random jitter effect of +/-100 TB units:

                   setpts=PTS+randomi(0, -100\,100)

       •   Set fixed rate 25 fps with some jitter:

                   setpts='1/(25*TB) * (N + 0.05 * sin(N*2*PI/25))'

       •   Apply an offset of 10 seconds to the input PTS:

                   setpts=PTS+10/TB

       •   Generate timestamps from a "live source" and rebase onto the current timebase:

                   setpts='(RTCTIME - RTCSTART) / (TB * 1000000)'

       •   Generate timestamps by counting samples:

                   asetpts=N/SR/TB

       <u>Commands</u>

       Both filters support all above options as <b>commands</b>.

   <b>setrange</b>
       Force color range for the output video frame.

       The  "setrange" filter marks the color range property for the output frames. It does not change the input
       frame, but only sets the corresponding property, which affects how the  frame  is  treated  by  following
       filters.

       The filter accepts the following options:

       <b>range</b>
           Available values are:

           <b>auto</b>
               Keep the same color range property.

           <b>unspecified,</b> <b>unknown</b>
               Set the color range as unspecified.

           <b>limited,</b> <b>tv,</b> <b>mpeg</b>
               Set the color range as limited.

           <b>full,</b> <b>pc,</b> <b>jpeg</b>
               Set the color range as full.

   <b>settb,</b> <b>asettb</b>
       Set  the  timebase  to  use  for  the output frames timestamps.  It is mainly useful for testing timebase
       configuration.

       It accepts the following parameters:

       <b>expr,</b> <b>tb</b>
           The expression which is evaluated into the output timebase.

       The value for <b>tb</b> is an arithmetic expression representing a rational.  The  expression  can  contain  the
       constants  "AVTB"  (the  default  timebase), "intb" (the input timebase) and "sr" (the sample rate, audio
       only). Default value is "intb".

       <u>Examples</u>

       •   Set the timebase to 1/25:

                   settb=expr=1/25

       •   Set the timebase to 1/10:

                   settb=expr=0.1

       •   Set the timebase to 1001/1000:

                   settb=1+0.001

       •   Set the timebase to 2*intb:

                   settb=2*intb

       •   Set the default timebase value:

                   settb=AVTB

   <b>showcqt</b>
       Convert input audio to a video  output  representing  frequency  spectrum  logarithmically  using  Brown-
       Puckette  constant  Q  transform  algorithm with direct frequency domain coefficient calculation (but the
       transform itself is not really constant Q, instead the  Q  factor  is  actually  variable/clamped),  with
       musical tone scale, from E0 to D#10.

       The filter accepts the following options:

       <b>size,</b> <b>s</b>
           Specify  the  video  size  for  the output. It must be even. For the syntax of this option, check the
           <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "1920x1080".

       <b>fps,</b> <b>rate,</b> <b>r</b>
           Set the output frame rate. Default value is 25.

       <b>bar_h</b>
           Set the bargraph height. It must be even. Default value is -1  which  computes  the  bargraph  height
           automatically.

       <b>axis_h</b>
           Set  the  axis  height.  It  must  be  even.  Default  value  is  -1  which  computes the axis height
           automatically.

       <b>sono_h</b>
           Set the sonogram height. It must be even. Default value is -1  which  computes  the  sonogram  height
           automatically.

       <b>fullhd</b>
           Set the fullhd resolution. This option is deprecated, use <u>size</u>, <u>s</u> instead. Default value is 1.

       <b>sono_v,</b> <b>volume</b>
           Specify the sonogram volume expression. It can contain variables:

           <b>bar_v</b>
               the <u>bar_v</u> evaluated expression

           <b>frequency,</b> <b>freq,</b> <b>f</b>
               the frequency where it is evaluated

           <b>timeclamp,</b> <b>tc</b>
               the value of <u>timeclamp</u> option

           and functions:

           <b>a_weighting(f)</b>
               A-weighting of equal loudness

           <b>b_weighting(f)</b>
               B-weighting of equal loudness

           <b>c_weighting(f)</b>
               C-weighting of equal loudness.

           Default value is 16.

       <b>bar_v,</b> <b>volume2</b>
           Specify the bargraph volume expression. It can contain variables:

           <b>sono_v</b>
               the <u>sono_v</u> evaluated expression

           <b>frequency,</b> <b>freq,</b> <b>f</b>
               the frequency where it is evaluated

           <b>timeclamp,</b> <b>tc</b>
               the value of <u>timeclamp</u> option

           and functions:

           <b>a_weighting(f)</b>
               A-weighting of equal loudness

           <b>b_weighting(f)</b>
               B-weighting of equal loudness

           <b>c_weighting(f)</b>
               C-weighting of equal loudness.

           Default value is "sono_v".

       <b>sono_g,</b> <b>gamma</b>
           Specify  the  sonogram  gamma.  Lower  gamma makes the spectrum more contrast, higher gamma makes the
           spectrum having more range. Default value is 3.  Acceptable range is "[1, 7]".

       <b>bar_g,</b> <b>gamma2</b>
           Specify the bargraph gamma. Default value is 1. Acceptable range is "[1, 7]".

       <b>bar_t</b>
           Specify the bargraph transparency level. Lower value makes the bargraph sharper.  Default value is 1.
           Acceptable range is "[0, 1]".

       <b>timeclamp,</b> <b>tc</b>
           Specify the transform timeclamp. At low frequency, there is trade-off between accuracy in time domain
           and frequency domain. If timeclamp is lower, event in time  domain  is  represented  more  accurately
           (such as fast bass drum), otherwise event in frequency domain is represented more accurately (such as
           bass guitar). Acceptable range is "[0.002, 1]". Default value is 0.17.

       <b>attack</b>
           Set  attack  time  in  seconds.  The  default is 0 (disabled). Otherwise, it limits future samples by
           applying asymmetric windowing in time domain, useful when low latency is required. Accepted range  is
           "[0, 1]".

       <b>basefreq</b>
           Specify  the  transform  base frequency. Default value is 20.01523126408007475, which is frequency 50
           cents below E0. Acceptable range is "[10, 100000]".

       <b>endfreq</b>
           Specify the transform end frequency. Default value is 20495.59681441799654,  which  is  frequency  50
           cents above D#10. Acceptable range is "[10, 100000]".

       <b>coeffclamp</b>
           This option is deprecated and ignored.

       <b>tlength</b>
           Specify  the  transform  length in time domain. Use this option to control accuracy trade-off between
           time domain and frequency domain at every frequency sample.  It can contain variables:

           <b>frequency,</b> <b>freq,</b> <b>f</b>
               the frequency where it is evaluated

           <b>timeclamp,</b> <b>tc</b>
               the value of <u>timeclamp</u> option.

           Default value is "384*tc/(384+tc*f)".

       <b>count</b>
           Specify the transform count for every video frame. Default value is  6.   Acceptable  range  is  "[1,
           30]".

       <b>fcount</b>
           Specify  the  transform  count  for  every  single pixel. Default value is 0, which makes it computed
           automatically. Acceptable range is "[0, 10]".

       <b>fontfile</b>
           Specify font file for use with freetype to draw the axis. If not specified, use embedded  font.  Note
           that drawing with font file or embedded font is not implemented with custom <u>basefreq</u> and <u>endfreq</u>, use
           <u>axisfile</u> option instead.

       <b>font</b>
           Specify  fontconfig  pattern.  This  has  lower priority than <u>fontfile</u>. The ":" in the pattern may be
           replaced by "|" to avoid unnecessary escaping.

       <b>fontcolor</b>
           Specify font color expression. This  is  arithmetic  expression  that  should  return  integer  value
           0xRRGGBB. It can contain variables:

           <b>frequency,</b> <b>freq,</b> <b>f</b>
               the frequency where it is evaluated

           <b>timeclamp,</b> <b>tc</b>
               the value of <u>timeclamp</u> option

           and functions:

           <b>midi(f)</b>
               midi number of frequency f, some midi numbers: <a href="../man16/E0.16.html">E0</a>(16), <a href="../man24/C1.24.html">C1</a>(24), <a href="../man36/C2.36.html">C2</a>(36), <a href="../man69/A4.69.html">A4</a>(69)

           <b>r(x),</b> <b>g(x),</b> <b>b(x)</b>
               red, green, and blue value of intensity x.

           Default  value  is  "st(0,  (midi(f)-59.5)/12); st(1, if(between(<a href="../man0/ld.0.html">ld</a>(0),0,1), 0.5-0.5*cos(2*PI*<a href="../man0/ld.0.html">ld</a>(0)),
           0)); r(<a href="../man1/1-ld.1.html">1-ld</a>(1)) + b(<a href="../man1/ld.1.html">ld</a>(1))".

       <b>axisfile</b>
           Specify image file to draw the axis. This option override <u>fontfile</u> and <u>fontcolor</u> option.

       <b>axis,</b> <b>text</b>
           Enable/disable drawing text to the axis. If it is set to 0, drawing to the axis is disabled, ignoring
           <u>fontfile</u> and <u>axisfile</u> option.  Default value is 1.

       <b>csp</b> Set colorspace. The accepted values are:

           <b>unspecified</b>
               Unspecified (default)

           <b>bt709</b>
               BT.709

           <b>fcc</b> FCC

           <b>bt470bg</b>
               BT.470BG or BT.601-6 625

           <b>smpte170m</b>
               SMPTE-170M or BT.601-6 525

           <b>smpte240m</b>
               SMPTE-240M

           <b>bt2020ncl</b>
               BT.2020 with non-constant luminance

       <b>cscheme</b>
           Set  spectrogram  color   scheme.   This   is   list   of   floating   point   values   with   format
           "left_r|left_g|left_b|right_r|right_g|right_b".  The default is "1|0.5|0|0|0.5|1".

       <u>Examples</u>

       •   Playing audio while showing the spectrum:

                   ffplay -f lavfi 'amovie=a.mp3, asplit [a][out1]; [a] showcqt [out0]'

       •   Same as above, but with frame rate 30 fps:

                   ffplay -f lavfi 'amovie=a.mp3, asplit [a][out1]; [a] showcqt=fps=30:count=5 [out0]'

       •   Playing at 1280x720:

                   ffplay -f lavfi 'amovie=a.mp3, asplit [a][out1]; [a] showcqt=s=1280x720:count=4 [out0]'

       •   Disable sonogram display:

                   sono_h=0

       •   A1 and its harmonics: A1, A2, (near)E3, A3:

                   ffplay -f lavfi 'aevalsrc=0.1*sin(2*PI*55*t)+0.1*sin(4*PI*55*t)+0.1*sin(6*PI*55*t)+0.1*sin(8*PI*55*t),
                                    asplit[a][out1]; [a] showcqt [out0]'

       •   Same as above, but with more accuracy in frequency domain:

                   ffplay -f lavfi 'aevalsrc=0.1*sin(2*PI*55*t)+0.1*sin(4*PI*55*t)+0.1*sin(6*PI*55*t)+0.1*sin(8*PI*55*t),
                                    asplit[a][out1]; [a] showcqt=timeclamp=0.5 [out0]'

       •   Custom volume:

                   bar_v=10:sono_v=bar_v*a_weighting(f)

       •   Custom gamma, now spectrum is linear to the amplitude.

                   bar_g=2:sono_g=2

       •   Custom tlength equation:

                   tc=0.33:tlength='st(0,0.17); 384*tc / (384 / <a href="../man0/ld.0.html">ld</a>(0) + tc*f /(<a href="../man0/1-ld.0.html">1-ld</a>(0))) + 384*tc / (tc*f / <a href="../man0/ld.0.html">ld</a>(0) + 384 /(<a href="../man0/1-ld.0.html">1-ld</a>(0)))'

       •   Custom fontcolor and fontfile, C-note is colored green, others are colored blue:

                   fontcolor='if(mod(floor(midi(f)+0.5),12), 0x0000FF, <a href="../man1/g.1.html">g</a>(1))':fontfile=myfont.ttf

       •   Custom font using fontconfig:

                   font='Courier New,Monospace,mono|bold'

       •   Custom frequency range with custom axis using image file:

                   axisfile=myaxis.png:basefreq=40:endfreq=10000

   <b>showcwt</b>
       Convert  input  audio  to video output representing frequency spectrum using Continuous Wavelet Transform
       and Morlet wavelet.

       The filter accepts the following options:

       <b>size,</b> <b>s</b>
           Specify the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "640x512".

       <b>rate,</b> <b>r</b>
           Set the output frame rate. Default value is 25.

       <b>scale</b>
           Set the frequency scale used. Allowed values are:

           <b>linear</b>
           <b>log</b>
           <b>bark</b>
           <b>mel</b>
           <b>erbs</b>
           <b>sqrt</b>
           <b>cbrt</b>
           <b>qdrt</b>
           <b>fm</b>

           Default value is "linear".

       <b>iscale</b>
           Set the intensity scale used. Allowed values are:

           <b>linear</b>
           <b>log</b>
           <b>sqrt</b>
           <b>cbrt</b>
           <b>qdrt</b>

           Default value is "log".

       <b>min</b> Set the minimum frequency that will be used in output.  Default is 20 Hz.

       <b>max</b> Set the maximum frequency that will be used in output.  Default is 20000 Hz. The real frequency upper
           limit  depends on input audio's sample rate and such will be enforced on this value when it is set to
           value greater than Nyquist frequency.

       <b>imin</b>
           Set the minimum intensity that will be used in output.

       <b>imax</b>
           Set the maximum intensity that will be used in output.

       <b>logb</b>
           Set the logarithmic basis for brightness strength when mapping calculated magnitude values  to  pixel
           values.  Allowed range is from 0 to 1.  Default value is 0.0001.

       <b>deviation</b>
           Set  the  frequency  deviation.  Lower values than 1 are more frequency oriented, while higher values
           than 1 are more time oriented.  Allowed range is from 0 to 10.  Default value is 1.

       <b>pps</b> Set the number of pixel output per each second in one row.  Allowed range is from 1 to 1024.  Default
           value is 64.

       <b>mode</b>
           Set the output visual mode. Allowed values are:

           <b>magnitude</b>
               Show magnitude.

           <b>phase</b>
               Show only phase.

           <b>magphase</b>
               Show combination of magnitude and phase.  Magnitude is mapped to brightness and phase to color.

           <b>channel</b>
               Show unique color per channel magnitude.

           <b>stereo</b>
               Show unique color per stereo difference.

           Default value is "magnitude".

       <b>slide</b>
           Set the output slide method. Allowed values are:

           <b>replace</b>
           <b>scroll</b>
           <b>frame</b>
       <b>direction</b>
           Set the direction method for output slide method. Allowed values are:

           <b>lr</b>  Direction from left to right.

           <b>rl</b>  Direction from right to left.

           <b>ud</b>  Direction from up to down.

           <b>du</b>  Direction from down to up.

       <b>bar</b> Set the ratio of bargraph display to display size. Default is 0.

       <b>rotation</b>
           Set color rotation, must be in [-1.0, 1.0] range.  Default value is 0.

   <b>showfreqs</b>
       Convert input audio to video output representing the audio power spectrum.  Audio amplitude is on  Y-axis
       while frequency is on X-axis.

       The filter accepts the following options:

       <b>size,</b> <b>s</b>
           Specify  size  of video. For the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg-</b>
           <b>utils</b> <b>manual</b>.  Default is "1024x512".

       <b>rate,</b> <b>r</b>
           Set video rate. Default is 25.

       <b>mode</b>
           Set display mode.  This set how each frequency bin will be represented.

           It accepts the following values:

           <b>line</b>
           <b>bar</b>
           <b>dot</b>

           Default is "bar".

       <b>ascale</b>
           Set amplitude scale.

           It accepts the following values:

           <b>lin</b> Linear scale.

           <b>sqrt</b>
               Square root scale.

           <b>cbrt</b>
               Cubic root scale.

           <b>log</b> Logarithmic scale.

           Default is "log".

       <b>fscale</b>
           Set frequency scale.

           It accepts the following values:

           <b>lin</b> Linear scale.

           <b>log</b> Logarithmic scale.

           <b>rlog</b>
               Reverse logarithmic scale.

           Default is "lin".

       <b>win_size</b>
           Set window size. Allowed range is from 16 to 65536.

           Default is 2048

       <b>win_func</b>
           Set windowing function.

           It accepts the following values:

           <b>rect</b>
           <b>bartlett</b>
           <b>hanning</b>
           <b>hamming</b>
           <b>blackman</b>
           <b>welch</b>
           <b>flattop</b>
           <b>bharris</b>
           <b>bnuttall</b>
           <b>bhann</b>
           <b>sine</b>
           <b>nuttall</b>
           <b>lanczos</b>
           <b>gauss</b>
           <b>tukey</b>
           <b>dolph</b>
           <b>cauchy</b>
           <b>parzen</b>
           <b>poisson</b>
           <b>bohman</b>
           <b>kaiser</b>

           Default is "hanning".

       <b>overlap</b>
           Set window overlap. In range "[0, 1]". Default is 1, which means optimal overlap for selected  window
           function will be picked.

       <b>averaging</b>
           Set  time averaging. Setting this to 0 will display current maximal peaks.  Default is 1, which means
           time averaging is disabled.

       <b>colors</b>
           Specify list of colors separated by space or by '|' which will be used to draw  channel  frequencies.
           Unrecognized or missing colors will be replaced by white color.

       <b>cmode</b>
           Set channel display mode.

           It accepts the following values:

           <b>combined</b>
           <b>separate</b>

           Default is "combined".

       <b>minamp</b>
           Set minimum amplitude used in "log" amplitude scaler.

       <b>data</b>
           Set data display mode.

           It accepts the following values:

           <b>magnitude</b>
           <b>phase</b>
           <b>delay</b>

           Default is "magnitude".

       <b>channels</b>
           Set channels to use when processing audio. By default all are processed.

   <b>showspatial</b>
       Convert stereo input audio to a video output, representing the spatial relationship between two channels.

       The filter accepts the following options:

       <b>size,</b> <b>s</b>
           Specify  the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "512x512".

       <b>win_size</b>
           Set window size. Allowed range is from <u>1024</u> to <u>65536</u>. Default size is <u>4096</u>.

       <b>win_func</b>
           Set window function.

           It accepts the following values:

           <b>rect</b>
           <b>bartlett</b>
           <b>hann</b>
           <b>hanning</b>
           <b>hamming</b>
           <b>blackman</b>
           <b>welch</b>
           <b>flattop</b>
           <b>bharris</b>
           <b>bnuttall</b>
           <b>bhann</b>
           <b>sine</b>
           <b>nuttall</b>
           <b>lanczos</b>
           <b>gauss</b>
           <b>tukey</b>
           <b>dolph</b>
           <b>cauchy</b>
           <b>parzen</b>
           <b>poisson</b>
           <b>bohman</b>
           <b>kaiser</b>

           Default value is "hann".

       <b>rate,</b> <b>r</b>
           Set output framerate.

   <b>showspectrum</b>
       Convert input audio to a video output, representing the audio frequency spectrum.

       The filter accepts the following options:

       <b>size,</b> <b>s</b>
           Specify the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "640x512".

       <b>slide</b>
           Specify how the spectrum should slide along the window.

           It accepts the following values:

           <b>replace</b>
               the samples start again on the left when they reach the right

           <b>scroll</b>
               the samples scroll from right to left

           <b>fullframe</b>
               frames are only produced when the samples reach the right

           <b>rscroll</b>
               the samples scroll from left to right

           <b>lreplace</b>
               the samples start again on the right when they reach the left

           Default value is "replace".

       <b>mode</b>
           Specify display mode.

           It accepts the following values:

           <b>combined</b>
               all channels are displayed in the same row

           <b>separate</b>
               all channels are displayed in separate rows

           Default value is <b>combined</b>.

       <b>color</b>
           Specify display color mode.

           It accepts the following values:

           <b>channel</b>
               each channel is displayed in a separate color

           <b>intensity</b>
               each channel is displayed using the same color scheme

           <b>rainbow</b>
               each channel is displayed using the rainbow color scheme

           <b>moreland</b>
               each channel is displayed using the moreland color scheme

           <b>nebulae</b>
               each channel is displayed using the nebulae color scheme

           <b>fire</b>
               each channel is displayed using the fire color scheme

           <b>fiery</b>
               each channel is displayed using the fiery color scheme

           <b>fruit</b>
               each channel is displayed using the fruit color scheme

           <b>cool</b>
               each channel is displayed using the cool color scheme

           <b>magma</b>
               each channel is displayed using the magma color scheme

           <b>green</b>
               each channel is displayed using the green color scheme

           <b>viridis</b>
               each channel is displayed using the viridis color scheme

           <b>plasma</b>
               each channel is displayed using the plasma color scheme

           <b>cividis</b>
               each channel is displayed using the cividis color scheme

           <b>terrain</b>
               each channel is displayed using the terrain color scheme

           Default value is <b>channel</b>.

       <b>scale</b>
           Specify scale used for calculating intensity color values.

           It accepts the following values:

           <b>lin</b> linear

           <b>sqrt</b>
               square root, default

           <b>cbrt</b>
               cubic root

           <b>log</b> logarithmic

           <b>4thrt</b>
               4th root

           <b>5thrt</b>
               5th root

           Default value is <b>sqrt</b>.

       <b>fscale</b>
           Specify frequency scale.

           It accepts the following values:

           <b>lin</b> linear

           <b>log</b> logarithmic

           Default value is <b>lin</b>.

       <b>saturation</b>
           Set  saturation modifier for displayed colors. Negative values provide alternative color scheme. 0 is
           no saturation at all.  Saturation must be in [-10.0, 10.0] range.  Default value is 1.

       <b>win_func</b>
           Set window function.

           It accepts the following values:

           <b>rect</b>
           <b>bartlett</b>
           <b>hann</b>
           <b>hanning</b>
           <b>hamming</b>
           <b>blackman</b>
           <b>welch</b>
           <b>flattop</b>
           <b>bharris</b>
           <b>bnuttall</b>
           <b>bhann</b>
           <b>sine</b>
           <b>nuttall</b>
           <b>lanczos</b>
           <b>gauss</b>
           <b>tukey</b>
           <b>dolph</b>
           <b>cauchy</b>
           <b>parzen</b>
           <b>poisson</b>
           <b>bohman</b>
           <b>kaiser</b>

           Default value is "hann".

       <b>orientation</b>
           Set orientation of time vs frequency axis. Can be "vertical" or "horizontal". Default is "vertical".

       <b>overlap</b>
           Set ratio of overlap window. Default value is 0.  When value is 1 overlap is set to recommended  size
           for specific window function currently used.

       <b>gain</b>
           Set scale gain for calculating intensity color values.  Default value is 1.

       <b>data</b>
           Set which data to display. Can be "magnitude", default or "phase", or unwrapped phase: "uphase".

       <b>rotation</b>
           Set color rotation, must be in [-1.0, 1.0] range.  Default value is 0.

       <b>start</b>
           Set start frequency from which to display spectrogram. Default is 0.

       <b>stop</b>
           Set stop frequency to which to display spectrogram. Default is 0.

       <b>fps</b> Set upper frame rate limit. Default is "auto", unlimited.

       <b>legend</b>
           Draw time and frequency axes and legends. Default is disabled.

       <b>drange</b>
           Set  dynamic  range  used to calculate intensity color values. Default is 120 dBFS.  Allowed range is
           from 10 to 200.

       <b>limit</b>
           Set upper limit of input audio samples volume in dBFS. Default is 0 dBFS.  Allowed range is from -100
           to 100.

       <b>opacity</b>
           Set opacity strength when using pixel format output with alpha component.

       The usage is very similar to the showwaves filter; see the examples in that section.

       <u>Examples</u>

       •   Large window with logarithmic color scaling:

                   showspectrum=s=1280x480:scale=log

       •   Complete example for a colored and sliding spectrum per channel using <b>ffplay</b>:

                   ffplay -f lavfi 'amovie=input.mp3, asplit [a][out1];
                                [a] showspectrum=mode=separate:color=intensity:slide=1:scale=cbrt [out0]'

   <b>showspectrumpic</b>
       Convert input audio to a single video frame, representing the audio frequency spectrum.

       The filter accepts the following options:

       <b>size,</b> <b>s</b>
           Specify the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "4096x2048".

       <b>mode</b>
           Specify display mode.

           It accepts the following values:

           <b>combined</b>
               all channels are displayed in the same row

           <b>separate</b>
               all channels are displayed in separate rows

           Default value is <b>combined</b>.

       <b>color</b>
           Specify display color mode.

           It accepts the following values:

           <b>channel</b>
               each channel is displayed in a separate color

           <b>intensity</b>
               each channel is displayed using the same color scheme

           <b>rainbow</b>
               each channel is displayed using the rainbow color scheme

           <b>moreland</b>
               each channel is displayed using the moreland color scheme

           <b>nebulae</b>
               each channel is displayed using the nebulae color scheme

           <b>fire</b>
               each channel is displayed using the fire color scheme

           <b>fiery</b>
               each channel is displayed using the fiery color scheme

           <b>fruit</b>
               each channel is displayed using the fruit color scheme

           <b>cool</b>
               each channel is displayed using the cool color scheme

           <b>magma</b>
               each channel is displayed using the magma color scheme

           <b>green</b>
               each channel is displayed using the green color scheme

           <b>viridis</b>
               each channel is displayed using the viridis color scheme

           <b>plasma</b>
               each channel is displayed using the plasma color scheme

           <b>cividis</b>
               each channel is displayed using the cividis color scheme

           <b>terrain</b>
               each channel is displayed using the terrain color scheme

           Default value is <b>intensity</b>.

       <b>scale</b>
           Specify scale used for calculating intensity color values.

           It accepts the following values:

           <b>lin</b> linear

           <b>sqrt</b>
               square root, default

           <b>cbrt</b>
               cubic root

           <b>log</b> logarithmic

           <b>4thrt</b>
               4th root

           <b>5thrt</b>
               5th root

           Default value is <b>log</b>.

       <b>fscale</b>
           Specify frequency scale.

           It accepts the following values:

           <b>lin</b> linear

           <b>log</b> logarithmic

           Default value is <b>lin</b>.

       <b>saturation</b>
           Set  saturation modifier for displayed colors. Negative values provide alternative color scheme. 0 is
           no saturation at all.  Saturation must be in [-10.0, 10.0] range.  Default value is 1.

       <b>win_func</b>
           Set window function.

           It accepts the following values:

           <b>rect</b>
           <b>bartlett</b>
           <b>hann</b>
           <b>hanning</b>
           <b>hamming</b>
           <b>blackman</b>
           <b>welch</b>
           <b>flattop</b>
           <b>bharris</b>
           <b>bnuttall</b>
           <b>bhann</b>
           <b>sine</b>
           <b>nuttall</b>
           <b>lanczos</b>
           <b>gauss</b>
           <b>tukey</b>
           <b>dolph</b>
           <b>cauchy</b>
           <b>parzen</b>
           <b>poisson</b>
           <b>bohman</b>
           <b>kaiser</b>

           Default value is "hann".

       <b>orientation</b>
           Set orientation of time vs frequency axis. Can be "vertical" or "horizontal". Default is "vertical".

       <b>gain</b>
           Set scale gain for calculating intensity color values.  Default value is 1.

       <b>legend</b>
           Draw time and frequency axes and legends. Default is enabled.

       <b>rotation</b>
           Set color rotation, must be in [-1.0, 1.0] range.  Default value is 0.

       <b>start</b>
           Set start frequency from which to display spectrogram. Default is 0.

       <b>stop</b>
           Set stop frequency to which to display spectrogram. Default is 0.

       <b>drange</b>
           Set dynamic range used to calculate intensity color values. Default is 120 dBFS.   Allowed  range  is
           from 10 to 200.

       <b>limit</b>
           Set upper limit of input audio samples volume in dBFS. Default is 0 dBFS.  Allowed range is from -100
           to 100.

       <b>opacity</b>
           Set opacity strength when using pixel format output with alpha component.

       <u>Examples</u>

       •   Extract an audio spectrogram of a whole audio track in a 1024x1024 picture using <b>ffmpeg</b>:

                   ffmpeg -i audio.flac -lavfi showspectrumpic=s=1024x1024 spectrogram.png

   <b>showvolume</b>
       Convert input audio volume to a video output.

       The filter accepts the following options:

       <b>rate,</b> <b>r</b>
           Set video rate.

       <b>b</b>   Set border width, allowed range is [0, 5]. Default is 1.

       <b>w</b>   Set channel width, allowed range is [80, 8192]. Default is 400.

       <b>h</b>   Set channel height, allowed range is [1, 900]. Default is 20.

       <b>f</b>   Set fade, allowed range is [0, 1]. Default is 0.95.

       <b>c</b>   Set volume color expression.

           The expression can use the following variables:

           <b>VOLUME</b>
               Current max volume of channel in dB.

           <b>PEAK</b>
               Current peak.

           <b>CHANNEL</b>
               Current channel number, starting from 0.

       <b>t</b>   If set, displays channel names. Default is enabled.

       <b>v</b>   If set, displays volume values. Default is enabled.

       <b>o</b>   Set orientation, can be horizontal: "h" or vertical: "v", default is "h".

       <b>s</b>   Set step size, allowed range is [0, 5]. Default is 0, which means step is disabled.

       <b>p</b>   Set background opacity, allowed range is [0, 1]. Default is 0.

       <b>m</b>   Set metering mode, can be peak: "p" or rms: "r", default is "p".

       <b>ds</b>  Set display scale, can be linear: "lin" or log: "log", default is "lin".

       <b>dm</b>  In  second.   If  set  to &gt; 0., display a line for the max level in the previous seconds.  default is
           disabled: 0.

       <b>dmc</b> The color of the max line. Use when "dm" option is set to &gt; 0.  default is: "orange"

   <b>showwaves</b>
       Convert input audio to a video output, representing the samples waves.

       The filter accepts the following options:

       <b>size,</b> <b>s</b>
           Specify the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b>  <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "600x240".

       <b>mode</b>
           Set display mode.

           Available values are:

           <b>point</b>
               Draw a point for each sample.

           <b>line</b>
               Draw a vertical line for each sample.

           <b>p2p</b> Draw a point for each sample and a line between them.

           <b>cline</b>
               Draw a centered vertical line for each sample.

           Default value is "point".

       <b>n</b>   Set  the  number  of  samples  which are printed on the same column. A larger value will decrease the
           frame rate. Must be a positive integer. This option can be set only if the  value  for  <u>rate</u>  is  not
           explicitly specified.

       <b>rate,</b> <b>r</b>
           Set the (approximate) output frame rate. This is done by setting the option <u>n</u>. Default value is "25".

       <b>split_channels</b>
           Set if channels should be drawn separately or overlap. Default value is 0.

       <b>colors</b>
           Set colors separated by '|' which are going to be used for drawing of each channel.

       <b>scale</b>
           Set amplitude scale.

           Available values are:

           <b>lin</b> Linear.

           <b>log</b> Logarithmic.

           <b>sqrt</b>
               Square root.

           <b>cbrt</b>
               Cubic root.

           Default is linear.

       <b>draw</b>
           Set the draw mode. This is mostly useful to set for high <u>n</u>.

           Available values are:

           <b>scale</b>
               Scale pixel values for each drawn sample.

           <b>full</b>
               Draw every sample directly.

           Default value is "scale".

       <u>Examples</u>

       •   Output the input file audio and the corresponding video representation at the same time:

                   amovie=a.mp3,asplit[out0],showwaves[out1]

       •   Create a synthetic signal and show it with showwaves, forcing a frame rate of 30 frames per second:

                   aevalsrc=sin(1*2*PI*t)*sin(880*2*PI*t):cos(2*PI*200*t),asplit[out0],showwaves=r=30[out1]

   <b>showwavespic</b>
       Convert input audio to a single video frame, representing the samples waves.

       The filter accepts the following options:

       <b>size,</b> <b>s</b>
           Specify  the video size for the output. For the syntax of this option, check the <b>"Video</b> <b>size"</b> <b>section</b>
           <b>in</b> <b>the</b> <b>ffmpeg-utils</b> <b>manual</b>.  Default value is "600x240".

       <b>split_channels</b>
           Set if channels should be drawn separately or overlap. Default value is 0.

       <b>colors</b>
           Set colors separated by '|' which are going to be used for drawing of each channel.

       <b>scale</b>
           Set amplitude scale.

           Available values are:

           <b>lin</b> Linear.

           <b>log</b> Logarithmic.

           <b>sqrt</b>
               Square root.

           <b>cbrt</b>
               Cubic root.

           Default is linear.

       <b>draw</b>
           Set the draw mode.

           Available values are:

           <b>scale</b>
               Scale pixel values for each drawn sample.

           <b>full</b>
               Draw every sample directly.

           Default value is "scale".

       <b>filter</b>
           Set the filter mode.

           Available values are:

           <b>average</b>
               Use average samples values for each drawn sample.

           <b>peak</b>
               Use peak samples values for each drawn sample.

           Default value is "average".

       <u>Examples</u>

       •   Extract a channel split representation of the wave form of a whole audio track in a 1024x800  picture
           using <b>ffmpeg</b>:

                   ffmpeg -i audio.flac -lavfi showwavespic=split_channels=1:s=1024x800 waveform.png

   <b>sidedata,</b> <b>asidedata</b>
       Delete frame side data, or select frames based on it.

       This filter accepts the following options:

       <b>mode</b>
           Set mode of operation of the filter.

           Can be one of the following:

           <b>select</b>
               Select every frame with side data of "type".

           <b>delete</b>
               Delete side data of "type". If "type" is not set, delete all side data in the frame.

       <b>type</b>
           Set  side  data  type  used with all modes. Must be set for "select" mode. For the list of frame side
           data types, refer to the "AVFrameSideDataType" enum in  <u>libavutil/frame.h</u>.  For  example,  to  choose
           "AV_FRAME_DATA_PANSCAN" side data, you must specify "PANSCAN".

   <b>spectrumsynth</b>
       Synthesize  audio  from  2 input video spectrums, first input stream represents magnitude across time and
       second represents phase across time.  The filter will transform from frequency  domain  as  displayed  in
       videos back to time domain as presented in audio output.

       This  filter is primarily created for reversing processed <b>showspectrum</b> filter outputs, but can synthesize
       sound from other spectrograms too.  But in such case results are going to be poor if the  phase  data  is
       not  available,  because  in such cases phase data need to be recreated, usually it's just recreated from
       random noise.  For best results use gray only output ("channel" color mode in  <b>showspectrum</b>  filter)  and
       "log"  scale  for  magnitude  video and "lin" scale for phase video. To produce phase, for 2nd video, use
       "data" option. Inputs videos should generally use "fullframe" slide mode as that saves  resources  needed
       for decoding video.

       The filter accepts the following options:

       <b>sample_rate</b>
           Specify  sample  rate of output audio, the sample rate of audio from which spectrum was generated may
           differ.

       <b>channels</b>
           Set number of channels represented in input video spectrums.

       <b>scale</b>
           Set scale which was used when generating magnitude input spectrum.  Can be "lin" or "log". Default is
           "log".

       <b>slide</b>
           Set slide which was used when generating inputs spectrums.  Can be "replace",  "scroll",  "fullframe"
           or "rscroll".  Default is "fullframe".

       <b>win_func</b>
           Set window function used for resynthesis.

       <b>overlap</b>
           Set  window overlap. In range "[0, 1]". Default is 1, which means optimal overlap for selected window
           function will be picked.

       <b>orientation</b>
           Set orientation of input videos. Can be "vertical" or "horizontal".  Default is "vertical".

       <u>Examples</u>

       •   First create magnitude and phase videos from audio, assuming audio is stereo with 44100 sample  rate,
           then resynthesize videos back to audio with spectrumsynth:

                   ffmpeg -i input.flac -lavfi showspectrum=mode=separate:scale=log:overlap=0.875:color=channel:slide=fullframe:data=magnitude -an -c:v rawvideo magnitude.nut
                   ffmpeg -i input.flac -lavfi showspectrum=mode=separate:scale=lin:overlap=0.875:color=channel:slide=fullframe:data=phase -an -c:v rawvideo phase.nut
                   ffmpeg -i magnitude.nut -i phase.nut -lavfi spectrumsynth=channels=2:sample_rate=44100:win_func=hann:overlap=0.875:slide=fullframe output.flac

   <b>split,</b> <b>asplit</b>
       Split input into several identical outputs.

       "asplit" works with audio input, "split" with video.

       The  filter accepts a single parameter which specifies the number of outputs. If unspecified, it defaults
       to 2.

       <u>Examples</u>

       •   Create two separate outputs from the same input:

                   [in] split [out0][out1]

       •   To create 3 or more outputs, you need to specify the number of outputs, like in:

                   [in] asplit=3 [out0][out1][out2]

       •   Create two separate outputs from the same input, one cropped and one padded:

                   [in] split [splitout1][splitout2];
                   [splitout1] crop=100:100:0:0    [cropout];
                   [splitout2] pad=200:200:100:100 [padout];

       •   Create 5 copies of the input audio with <b>ffmpeg</b>:

                   ffmpeg -i INPUT -filter_complex asplit=5 OUTPUT

   <b>zmq,</b> <b>azmq</b>
       Receive commands sent through a libzmq client, and forward them to filters in the filtergraph.

       "zmq" and "azmq" work as a pass-through filters. "zmq" must be inserted between two video filters, "azmq"
       between two audio filters. Both are capable to send messages to any filter type.

       To enable these filters you need to install the libzmq library and  headers  and  configure  FFmpeg  with
       "--enable-libzmq".

       For more information about libzmq see: &lt;<b><a href="http://www.zeromq.org/">http://www.zeromq.org/</a></b>&gt;

       The  "zmq"  and  "azmq"  filters  work as a libzmq server, which receives messages sent through a network
       interface defined by the <b>bind_address</b> (or the abbreviation "<b>b</b>") option.  Default value of this option  is
       <u>tcp://localhost:5555</u>. You may want to alter this value to your needs, but do not forget to escape any ':'
       signs (see <b>filtergraph</b> <b>escaping</b>).

       The received message must be in the form:

               &lt;TARGET&gt; &lt;COMMAND&gt; [&lt;ARG&gt;]

       <u>TARGET</u>  specifies  the  target  of the command, usually the name of the filter class or a specific filter
       instance name. The default filter instance name uses the pattern  <b>Parsed_&lt;filter_name&gt;_&lt;index&gt;</b>,  but  you
       can override this by using the <b>filter_name@id</b> syntax (see <b>Filtergraph</b> <b>syntax</b>).

       <u>COMMAND</u> specifies the name of the command for the target filter.

       <u>ARG</u> is optional and specifies the optional argument list for the given <u>COMMAND</u>.

       Upon  reception, the message is processed and the corresponding command is injected into the filtergraph.
       Depending on the result, the filter will send a reply to the client, adopting the format:

               &lt;ERROR_CODE&gt; &lt;ERROR_REASON&gt;
               &lt;MESSAGE&gt;

       <u>MESSAGE</u> is optional.

       <u>Examples</u>

       Look at <u>tools/zmqsend</u> for an example of a zmq client which can be used  to  send  commands  processed  by
       these filters.

       Consider  the  following filtergraph generated by <b>ffplay</b>.  In this example the last overlay filter has an
       instance name. All other filters will have default instance names.

               ffplay -dumpgraph 1 -f lavfi "
               color=s=100x100:c=red  [l];
               color=s=100x100:c=blue [r];
               nullsrc=s=200x100, zmq [bg];
               [bg][l]   overlay     [bg+l];
               [bg+l][r] overlay@my=x=100 "

       To change the color of the left side of the video, the following command can be used:

               echo Parsed_color_0 c yellow | tools/zmqsend

       To change the right side:

               echo Parsed_color_1 c pink | tools/zmqsend

       To change the position of the right side:

               echo overlay@my x 150 | tools/zmqsend

</pre><h4><b>MULTIMEDIA</b> <b>SOURCES</b></h4><pre>
       Below is a description of the currently available multimedia sources.

   <b>amovie</b>
       This is the same as <b>movie</b> source, except it selects an audio stream by default.

   <b>avsynctest</b>
       Generate an Audio/Video Sync Test.

       Generated stream periodically shows flash video frame and emits beep in audio.   Useful  to  inspect  A/V
       sync issues.

       It accepts the following options:

       <b>size,</b> <b>s</b>
           Set output video size. Default value is "hd720".

       <b>framerate,</b> <b>fr</b>
           Set output video frame rate. Default value is 30.

       <b>samplerate,</b> <b>sr</b>
           Set output audio sample rate. Default value is 44100.

       <b>amplitude,</b> <b>a</b>
           Set output audio beep amplitude. Default value is 0.7.

       <b>period,</b> <b>p</b>
           Set output audio beep period in seconds. Default value is 3.

       <b>delay,</b> <b>dl</b>
           Set output video flash delay in number of frames. Default value is 0.

       <b>cycle,</b> <b>c</b>
           Enable cycling of video delays, by default is disabled.

       <b>duration,</b> <b>d</b>
           Set stream output duration. By default duration is unlimited.

       <b>fg,</b> <b>bg,</b> <b>ag</b>
           Set foreground/background/additional color.

       <u>Commands</u>

       This source supports the some above options as <b>commands</b>.

   <b>movie</b>
       Read audio and/or video stream(s) from a movie container.

       It accepts the following parameters:

       <b>filename</b>
           The  name  of  the  resource  to  read  (not  necessarily a file; it can also be a device or a stream
           accessed through some protocol).

       <b>format_name,</b> <b>f</b>
           Specifies the format assumed for the movie to read, and can be either the name of a container  or  an
           input device. If not specified, the format is guessed from <u>movie_name</u> or by probing.

       <b>seek_point,</b> <b>sp</b>
           Specifies  the  seek  point  in seconds. The frames will be output starting from this seek point. The
           parameter is evaluated with "av_strtod", so the numerical value may be suffixed by an IS postfix. The
           default value is "0".

       <b>streams,</b> <b>s</b>
           Specifies the streams to read. Several streams can be specified, separated by "+".  The  source  will
           then  have  as  many  outputs,  in the same order. The syntax is explained in the <b>"Stream</b> <b>specifiers"</b>
           <b>section</b> <b>in</b> <b>the</b> <b>ffmpeg</b> <b>manual</b>. Two special names, "dv" and "da" specify respectively the default (best
           suited) video and audio stream. Default is "dv", or "da" if the filter is called as "amovie".

       <b>stream_index,</b> <b>si</b>
           Specifies the index of the video stream to read. If the value is -1, the most suitable  video  stream
           will  be  automatically  selected.  The  default  value  is "-1". Deprecated. If the filter is called
           "amovie", it will select audio instead of video.

       <b>loop</b>
           Specifies how many times to read the stream in sequence.  If the value  is  0,  the  stream  will  be
           looped infinitely.  Default value is "1".

           Note  that  when  the  movie is looped the source timestamps are not changed, so it will generate non
           monotonically increasing timestamps.

       <b>discontinuity</b>
           Specifies the time difference between  frames  above  which  the  point  is  considered  a  timestamp
           discontinuity which is removed by adjusting the later timestamps.

       <b>dec_threads</b>
           Specifies the number of threads for decoding

       <b>format_opts</b>
           Specify  format  options  for the opened file. Format options can be specified as a list of <u>key</u>=<u>value</u>
           pairs  separated  by  ':'.  The  following  example  shows  how   to   add   protocol_whitelist   and
           protocol_blacklist options:

                   ffplay -f lavfi
                   "movie=filename='1.sdp':format_opts='protocol_whitelist=file,rtp,udp\:protocol_blacklist=http'"

       It allows overlaying a second video on top of the main input of a filtergraph, as shown in this graph:

               input -----------&gt; deltapts0 --&gt; overlay --&gt; output
                                                   ^
                                                   |
               movie --&gt; scale--&gt; deltapts1 -------+

       <u>Examples</u>

       •   Skip  3.2  seconds from the start of the AVI file in.avi, and overlay it on top of the input labelled
           "in":

                   movie=in.avi:seek_point=3.2, scale=180:-1, setpts=PTS-STARTPTS [over];
                   [in] setpts=PTS-STARTPTS [main];
                   [main][over] overlay=16:16 [out]

       •   Read from a video4linux2 device, and overlay it on top of the input labelled "in":

                   movie=/dev/video0:f=video4linux2, scale=180:-1, setpts=PTS-STARTPTS [over];
                   [in] setpts=PTS-STARTPTS [main];
                   [main][over] overlay=16:16 [out]

       •   Read the first video stream and the audio stream with id 0x81 from dvd.vob; the video is connected to
           the pad named "video" and the audio is connected to the pad named "audio":

                   movie=dvd.vob:s=v:0+#0x81 [video] [audio]

       <u>Commands</u>

       Both movie and amovie support the following commands:

       <b>seek</b>
           Perform seek using "av_seek_frame".  The syntax is: seek <u>stream_index</u>|<u>timestamp</u>|<u>flags</u>

           •   <u>stream_index</u>: If stream_index is -1, a default stream is selected, and <u>timestamp</u> is automatically
               converted from AV_TIME_BASE units to the stream specific time_base.

           •   <u>timestamp</u>: Timestamp in AVStream.time_base units or, if no stream is specified,  in  AV_TIME_BASE
               units.

           •   <u>flags</u>: Flags which select direction and seeking mode.

       <b>get_duration</b>
           Get movie duration in AV_TIME_BASE units.

</pre><h4><b>EXTERNAL</b> <b>LIBRARIES</b></h4><pre>
       FFmpeg can be hooked up with a number of external libraries to add support for more formats. None of them
       are  used  by  default,  their  use  has  to  be explicitly requested by passing the appropriate flags to
       <b>./configure</b>.

   <b>Alliance</b> <b>for</b> <b>Open</b> <b>Media</b> <b>(AOM)</b>
       FFmpeg can make use of the AOM library for AV1 decoding and encoding.

       Go  to  &lt;<b><a href="http://aomedia.org/">http://aomedia.org/</a></b>&gt;  and  follow  the  instructions  for  installing  the  library.  Then  pass
       "--enable-libaom" to configure to enable it.

   <b>AMD</b> <b>AMF/VCE</b>
       FFmpeg  can  use  the  AMD  Advanced Media Framework library for accelerated H.264 and HEVC(only windows)
       encoding on hardware with Video Coding Engine (VCE).

       To  enable  support  you  must   obtain   the   AMF   framework   header   files(version   1.4.9+)   from
       &lt;<b>https://github.com/GPUOpen-LibrariesAndSDKs/AMF.git</b>&gt;.

       Create  an  "AMF/"  directory in the system include path.  Copy the contents of "AMF/amf/public/include/"
       into that directory.  Then configure FFmpeg with "--enable-amf".

       Initialization of amf encoder occurs in this order: 1) trying to initialize through dx11(only windows) 2)
       trying to initialize through dx9(only windows) 3) trying to initialize through vulkan

       To use h.264(AMD VCE) encoder on linux amdgru-pro version 19.20+  and  amf-amdgpu-pro  package(amdgru-pro
       contains, but does not install automatically) are required.

       This driver can be installed using amdgpu-pro-install script in official amd driver archive.

   <b>AviSynth</b>
       FFmpeg can read AviSynth scripts as input. To enable support, pass "--enable-avisynth" to configure after
       installing   the  headers  provided  by  &lt;<b>https://github.com/AviSynth/AviSynthPlus</b>&gt;.   AviSynth+  can  be
       configured to install only the headers by either passing "-DHEADERS_ONLY:bool=on" to  the  normal  CMake-
       based build system, or by using the supplied "GNUmakefile".

       For   Windows,   supported   AviSynth   variants   are   &lt;<b><a href="http://avisynth.nl">http://avisynth.nl</a></b>&gt;   for   32-bit  builds  and
       &lt;<b><a href="http://avisynth.nl/index.php/AviSynth">http://avisynth.nl/index.php/AviSynth</a>+</b>&gt; for 32-bit and 64-bit builds.

       For     Linux,     macOS,     and     BSD,     the     only     supported     AviSynth     variant     is
       &lt;<b>https://github.com/AviSynth/AviSynthPlus</b>&gt;, starting with version 3.5.

           In  2016,  AviSynth+  added  support  for  building  with  GCC. However, due to the eccentricities of
           Windows' calling conventions, 32-bit GCC builds of AviSynth+ are not compatible with  typical  32-bit
           builds of FFmpeg.

           By  default, FFmpeg assumes compatibility with 32-bit MSVC builds of AviSynth+ since that is the most
           widely-used and entrenched build configuration.  Users can  override  this  and  enable  support  for
           32-bit  GCC  builds of AviSynth+ by passing "-DAVSC_WIN32_GCC32" to "--extra-cflags" when configuring
           FFmpeg.

           64-bit builds of FFmpeg are not affected, and can use either MSVC or GCC builds of AviSynth+  without
           any special flags.

           AviSynth(+)  is  loaded dynamically.  Distributors can build FFmpeg with "--enable-avisynth", and the
           binaries will work regardless of the end user having AviSynth installed.  If/when an end  user  would
           like  to  use AviSynth scripts, then they can install AviSynth(+) and FFmpeg will be able to find and
           use it to open scripts.

   <b>Chromaprint</b>
       FFmpeg  can  make  use  of  the  Chromaprint   library   for   generating   audio   fingerprints.    Pass
       "--enable-chromaprint" to configure to enable it. See &lt;<b>https://acoustid.org/chromaprint</b>&gt;.

   <b>codec2</b>
       FFmpeg can make use of the codec2 library for codec2 decoding and encoding.  There is currently no native
       decoder, so libcodec2 must be used for decoding.

       Go  to  &lt;<b><a href="http://freedv.org/">http://freedv.org/</a></b>&gt;,  download  "Codec 2 source archive".  Build and install using CMake. Debian
       users can install  the  libcodec2-dev  package  instead.   Once  libcodec2  is  installed  you  can  pass
       "--enable-libcodec2" to configure to enable it.

       The  easiest  way  to  use codec2 is with .c2 files, since they contain the mode information required for
       decoding.  To encode such a file, use a .c2 file extension and  give  the  libcodec2  encoder  the  -mode
       option:  "ffmpeg -i input.wav -mode 700C output.c2".  Playback is as simple as "ffplay output.c2".  For a
       list of supported modes, run "ffmpeg -h encoder=libcodec2".  Raw codec2 files  are  also  supported.   To
       make  sense  of them the mode in use needs to be specified as a format option: "ffmpeg -f codec2raw -mode
       1300 -i input.raw output.wav".

   <b>dav1d</b>
       FFmpeg can make use of the dav1d library for AV1 video decoding.

       Go to &lt;<b>https://code.videolan.org/videolan/dav1d</b>&gt; and follow the instructions for installing the  library.
       Then pass "--enable-libdav1d" to configure to enable it.

   <b>davs2</b>
       FFmpeg can make use of the davs2 library for AVS2-P2/IEEE1857.4 video decoding.

       Go to &lt;<b>https://github.com/pkuvcl/davs2</b>&gt; and follow the instructions for installing the library. Then pass
       "--enable-libdavs2" to configure to enable it.

           libdavs2     is     under     the     GNU    Public    License    Version    2    or    later    (see
           &lt;<b><a href="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</a></b>&gt;  for  details),  you  must  upgrade  FFmpeg's
           license to GPL in order to use it.

   <b>uavs3d</b>
       FFmpeg can make use of the uavs3d library for AVS3-P2/IEEE1857.10 video decoding.

       Go to &lt;<b>https://github.com/uavs3/uavs3d</b>&gt; and follow the instructions for installing the library. Then pass
       "--enable-libuavs3d" to configure to enable it.

   <b>Game</b> <b>Music</b> <b>Emu</b>
       FFmpeg  can  make  use  of  the Game Music Emu library to read audio from supported video game music file
       formats.      Pass      "--enable-libgme"      to      configure      to       enable       it.       See
       &lt;<b>https://bitbucket.org/mpyne/game-music-emu/overview</b>&gt;.

   <b>Intel</b> <b>QuickSync</b> <b>Video</b>
       FFmpeg  can  use Intel QuickSync Video (QSV) for accelerated decoding and encoding of multiple codecs. To
       use QSV, FFmpeg must be  linked  against  the  "libmfx"  dispatcher,  which  loads  the  actual  decoding
       libraries.

       The  dispatcher  is open source and can be downloaded from &lt;<b>https://github.com/lu-zero/mfx_dispatch.git</b>&gt;.
       FFmpeg needs to be configured with the "--enable-libmfx" option and "pkg-config"  needs  to  be  able  to
       locate the dispatcher's ".pc" files.

   <b>Kvazaar</b>
       FFmpeg can make use of the Kvazaar library for HEVC encoding.

       Go  to  &lt;<b>https://github.com/ultravideo/kvazaar</b>&gt;  and  follow the instructions for installing the library.
       Then pass "--enable-libkvazaar" to configure to enable it.

   <b>LAME</b>
       FFmpeg can make use of the LAME library for MP3 encoding.

       Go to &lt;<b><a href="http://lame.sourceforge.net/">http://lame.sourceforge.net/</a></b>&gt; and follow the instructions for installing the library.   Then  pass
       "--enable-libmp3lame" to configure to enable it.

   <b>LCEVCdec</b>
       FFmpeg  can  make  use  of  the  liblcevc_dec  library  for  LCEVC enhacement layer decoding on supported
       bitstreams.

       Go to &lt;<b>https://github.com/v-novaltd/LCEVCdec</b>&gt; and follow the instructions  for  installing  the  library.
       Then pass "--enable-liblcevc-dec" to configure to enable it.

           LCEVCdec is under the BSD-3-Clause-Clear License.

   <b>libilbc</b>
       iLBC  is  a  narrowband  speech codec that has been made freely available by Google as part of the WebRTC
       project. libilbc is a packaging friendly copy of the iLBC codec. FFmpeg  can  make  use  of  the  libilbc
       library for iLBC decoding and encoding.

       Go to &lt;<b>https://github.com/TimothyGu/libilbc</b>&gt; and follow the instructions for installing the library. Then
       pass "--enable-libilbc" to configure to enable it.

   <b>libjxl</b>
       JPEG  XL  is  an  image  format intended to fully replace legacy JPEG for an extended period of life. See
       &lt;<b>https://jpegxl.info/</b>&gt; for more information, and see &lt;<b>https://github.com/libjxl/libjxl</b>&gt; for  the  library
       source. You can pass "--enable-libjxl" to configure in order enable the libjxl wrapper.

   <b>libvpx</b>
       FFmpeg can make use of the libvpx library for VP8/VP9 decoding and encoding.

       Go  to  &lt;<b><a href="http://www.webmproject.org/">http://www.webmproject.org/</a></b>&gt;  and  follow the instructions for installing the library. Then pass
       "--enable-libvpx" to configure to enable it.

   <b>ModPlug</b>
       FFmpeg can make use of this library, originating in Modplug-XMMS, to read from MOD-like music files.  See
       &lt;<b>https://github.com/Konstanty/libmodplug</b>&gt;. Pass "--enable-libmodplug" to configure to enable it.

   <b>OpenCORE,</b> <b>VisualOn,</b> <b>and</b> <b>Fraunhofer</b> <b>libraries</b>
       Spun off Google Android sources, OpenCore, VisualOn and  Fraunhofer  libraries  provide  encoders  for  a
       number of audio codecs.

           OpenCORE     and     VisualOn    libraries    are    under    the    Apache    License    2.0    (see
           &lt;<b><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></b>&gt; for details), which is incompatible to the LGPL  version
           2.1 and GPL version 2. You have to upgrade FFmpeg's license to LGPL version 3 (or if you have enabled
           GPL components, GPL version 3) by passing "--enable-version3" to configure in order to use it.

           The  license  of the Fraunhofer AAC library is incompatible with the GPL.  Therefore, for GPL builds,
           you have to pass "--enable-nonfree" to configure in order to use it. To the best of our knowledge, it
           is compatible with the LGPL.

       <u>OpenCORE</u> <u>AMR</u>

       FFmpeg can make use of the OpenCORE libraries for AMR-NB decoding/encoding and AMR-WB decoding.

       Go to &lt;<b><a href="http://sourceforge.net/projects/opencore-amr/">http://sourceforge.net/projects/opencore-amr/</a></b>&gt; and follow  the  instructions  for  installing  the
       libraries.   Then  pass  "--enable-libopencore-amrnb" and/or "--enable-libopencore-amrwb" to configure to
       enable them.

       <u>VisualOn</u> <u>AMR-WB</u> <u>encoder</u> <u>library</u>

       FFmpeg can make use of the VisualOn AMR-WBenc library for AMR-WB encoding.

       Go to &lt;<b><a href="http://sourceforge.net/projects/opencore-amr/">http://sourceforge.net/projects/opencore-amr/</a></b>&gt; and follow  the  instructions  for  installing  the
       library.  Then pass "--enable-libvo-amrwbenc" to configure to enable it.

       <u>Fraunhofer</u> <u>AAC</u> <u>library</u>

       FFmpeg can make use of the Fraunhofer AAC library for AAC decoding &amp; encoding.

       Go  to  &lt;<b><a href="http://sourceforge.net/projects/opencore-amr/">http://sourceforge.net/projects/opencore-amr/</a></b>&gt;  and  follow  the instructions for installing the
       library.  Then pass "--enable-libfdk-aac" to configure to enable it.

       <u>LC3</u> <u>library</u>

       FFmpeg can make use of the Google LC3 library for LC3 decoding &amp; encoding.

       Go to &lt;<b>https://github.com/google/liblc3/</b>&gt; and follow the instructions for installing the  library.   Then
       pass "--enable-liblc3" to configure to enable it.

   <b>OpenH264</b>
       FFmpeg can make use of the OpenH264 library for H.264 decoding and encoding.

       Go  to  &lt;<b><a href="http://www.openh264.org/">http://www.openh264.org/</a></b>&gt;  and  follow  the  instructions  for installing the library. Then pass
       "--enable-libopenh264" to configure to enable it.

       For decoding, this library is much more limited than the built-in decoder in libavcodec; currently,  this
       library lacks support for decoding B-frames and some other main/high profile features. (It currently only
       supports  constrained  baseline  profile and CABAC.) Using it is mostly useful for testing and for taking
       advantage of Cisco's patent portfolio license (&lt;<b><a href="http://www.openh264.org/BINARY_LICENSE.txt">http://www.openh264.org/BINARY_LICENSE.txt</a></b>&gt;).

   <b>OpenJPEG</b>
       FFmpeg can use the OpenJPEG libraries for decoding/encoding J2K videos.  Go to &lt;<b><a href="http://www.openjpeg.org/">http://www.openjpeg.org/</a></b>&gt;
       to get the libraries and follow the installation instructions.  To enable using OpenJPEG in FFmpeg,  pass
       "--enable-libopenjpeg" to <u>./configure</u>.

   <b>rav1e</b>
       FFmpeg  can  make  use  of  rav1e  (Rust  AV1  Encoder)  via  its  C  bindings  to  encode videos.  Go to
       &lt;<b>https://github.com/xiph/rav1e/</b>&gt; and follow the instructions to build the  C  library.  To  enable  using
       rav1e in FFmpeg, pass "--enable-librav1e" to <u>./configure</u>.

   <b>SVT-AV1</b>
       FFmpeg can make use of the Scalable Video Technology for AV1 library for AV1 encoding.

       Go  to &lt;<b>https://gitlab.com/AOMediaCodec/SVT-AV1/</b>&gt; and follow the instructions for installing the library.
       Then pass "--enable-libsvtav1" to configure to enable it.

   <b>TwoLAME</b>
       FFmpeg can make use of the TwoLAME library for MP2 encoding.

       Go to &lt;<b><a href="http://www.twolame.org/">http://www.twolame.org/</a></b>&gt; and follow the  instructions  for  installing  the  library.   Then  pass
       "--enable-libtwolame" to configure to enable it.

   <b>VapourSynth</b>
       FFmpeg  can  read  VapourSynth  scripts  as  input.  To  enable  support,  pass "--enable-vapoursynth" to
       configure.  Vapoursynth  is  detected  via  "pkg-config".  Versions  42  or   greater   supported.    See
       &lt;<b><a href="http://www.vapoursynth.com/">http://www.vapoursynth.com/</a></b>&gt;.

       Due  to  security  concerns,  Vapoursynth  scripts will not be autodetected so the input format has to be
       forced. For ff* CLI tools, add "-f vapoursynth" before the input "-i yourscript.vpy".

   <b>x264</b>
       FFmpeg can make use of the x264 library for H.264 encoding.

       Go to &lt;<b><a href="http://www.videolan.org/developers/x264.html">http://www.videolan.org/developers/x264.html</a></b>&gt; and  follow  the  instructions  for  installing  the
       library. Then pass "--enable-libx264" to configure to enable it.

           x264     is     under     the     GNU     Public     License     Version     2    or    later    (see
           &lt;<b><a href="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</a></b>&gt;  for  details),  you  must  upgrade  FFmpeg's
           license to GPL in order to use it.

   <b>x265</b>
       FFmpeg can make use of the x265 library for HEVC encoding.

       Go to &lt;<b><a href="http://x265.org/developers.html">http://x265.org/developers.html</a></b>&gt; and follow the instructions for installing the library. Then pass
       "--enable-libx265" to configure to enable it.

           x265     is     under     the     GNU     Public     License     Version     2    or    later    (see
           &lt;<b><a href="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</a></b>&gt;  for  details),  you  must  upgrade  FFmpeg's
           license to GPL in order to use it.

   <b>xavs</b>
       FFmpeg can make use of the xavs library for AVS encoding.

       Go  to  &lt;<b><a href="http://xavs.sf.net/">http://xavs.sf.net/</a></b>&gt;  and  follow  the  instructions  for  installing  the  library.  Then  pass
       "--enable-libxavs" to configure to enable it.

   <b>xavs2</b>
       FFmpeg can make use of the xavs2 library for AVS2-P2/IEEE1857.4 video encoding.

       Go to &lt;<b>https://github.com/pkuvcl/xavs2</b>&gt; and follow the instructions for installing the library. Then pass
       "--enable-libxavs2" to configure to enable it.

           libxavs2    is    under    the    GNU    Public    License    Version     2     or     later     (see
           &lt;<b><a href="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</a></b>&gt;  for  details),  you  must  upgrade  FFmpeg's
           license to GPL in order to use it.

   <b>eXtra-fast</b> <b>Essential</b> <b>Video</b> <b>Encoder</b> <b>(XEVE)</b>
       FFmpeg can make use of the XEVE library for EVC video encoding.

       Go to &lt;<b>https://github.com/mpeg5/xeve</b>&gt; and follow the instructions for installing the XEVE  library.  Then
       pass "--enable-libxeve" to configure to enable it.

   <b>eXtra-fast</b> <b>Essential</b> <b>Video</b> <b>Decoder</b> <b>(XEVD)</b>
       FFmpeg can make use of the XEVD library for EVC video decoding.

       Go  to  &lt;<b>https://github.com/mpeg5/xevd</b>&gt; and follow the instructions for installing the XEVD library. Then
       pass "--enable-libxevd" to configure to enable it.

   <b>ZVBI</b>
       ZVBI is a VBI decoding library which can be used by FFmpeg to decode DVB teletext pages and DVB  teletext
       subtitles.

       Go  to &lt;<b><a href="http://sourceforge.net/projects/zapping/">http://sourceforge.net/projects/zapping/</a></b>&gt; and follow the instructions for installing the library.
       Then pass "--enable-libzvbi" to configure to enable it.

</pre><h4><b>SUPPORTED</b> <b>FILE</b> <b>FORMATS</b></h4><pre>
       You can use the "-formats" and "-codecs" options to have an exhaustive list.

   <b>File</b> <b>Formats</b>
       FFmpeg supports the following file formats through the "libavformat" library:

       <b>Name</b>  <b>:</b>  <b>Encoding</b> <b>@tab</b> <b>Decoding</b> <b>@tab</b> <b>Comments</b>
       <b>3dostr</b>                     <b>:</b>    <b>@tab</b> <b>X</b>
       <b>4xm</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab 4X Technologies format, used in some games.

       <b>8088flex</b> <b>TMV</b>               <b>:</b>    <b>@tab</b> <b>X</b>
       <b>AAX</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audible Enhanced Audio format, used in audiobooks.

       <b>AA</b>                         <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audible Format 2, 3, and 4, used in audiobooks.

       <b>ACT</b> <b>Voice</b>                  <b>:</b>    <b>@tab</b> <b>X</b>
               @tab contains G.729 audio

       <b>Adobe</b> <b>Filmstrip</b>            <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Audio</b> <b>IFF</b> <b>(AIFF)</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>American</b> <b>Laser</b> <b>Games</b> <b>MM</b>    <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Multimedia format used in games like Mad Dog McCree.

       <b>3GPP</b> <b>AMR</b>                   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Amazing</b> <b>Studio</b> <b>Packed</b> <b>Animation</b> <b>File</b>   <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Multimedia format used in game Heart Of Darkness.

       <b>Apple</b> <b>HTTP</b> <b>Live</b> <b>Streaming</b>  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Artworx</b> <b>Data</b> <b>Format</b>        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Interplay</b> <b>ACM</b>              <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio only format used in some Interplay games.

       <b>ADP</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used on the Nintendo Gamecube.

       <b>AFC</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used on the Nintendo Gamecube.

       <b>ADS/SS2</b>                    <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used on the PS2.

       <b>APNG</b>                       <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>ASF</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Advanced / Active Streaming Format.

       <b>AST</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Audio format used on the Nintendo Wii.

       <b>AVI</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>AviSynth</b>                   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>AVR</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used on Mac.

       <b>AVS</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Multimedia format used by the Creature Shock game.

       <b>Beam</b> <b>Software</b> <b>SIFF</b>         <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio and video format used in some games by Beam Software.

       <b>Bethesda</b> <b>Softworks</b> <b>VID</b>     <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used in some games from Bethesda Softworks.

       <b>Binary</b> <b>text</b>                <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Bink</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Multimedia format used by many games.

       <b>Bink</b> <b>Audio</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio only multimedia format used by some games.

       <b>Bitmap</b> <b>Brothers</b> <b>JV</b>         <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used in Z and Z95 games.

       <b>BRP</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Argonaut Games format.

       <b>Brute</b> <b>Force</b> <b>&amp;</b> <b>Ignorance</b>    <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used in the game Flash Traffic: City of Angels.

       <b>BFSTM</b>                      <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used on the Nintendo WiiU (based on BRSTM).

       <b>BRSTM</b>                      <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used on the Nintendo Wii.

       <b>BW64</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Broadcast Wave 64bit.

       <b>BWF</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>codec2</b> <b>(raw)</b>               <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Must be given -mode format option to decode correctly.

       <b>codec2</b> <b>(.c2</b> <b>files)</b>         <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Contains header with version and mode info, simplifying playback.

       <b>CRI</b> <b>ADX</b>                    <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Audio-only format used in console video games.

       <b>CRI</b> <b>AIX</b>                    <b>:</b>    <b>@tab</b> <b>X</b>
       <b>CRI</b> <b>HCA</b>                    <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio-only format used in console video games.

       <b>Discworld</b> <b>II</b> <b>BMV</b>           <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Interplay</b> <b>C93</b>              <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used in the game Cyberia from Interplay.

       <b>Delphine</b> <b>Software</b> <b>International</b> <b>CIN</b>  <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Multimedia format used by Delphine Software games.

       <b>Digital</b> <b>Speech</b> <b>Standard</b> <b>(DSS)</b>  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>CD+G</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Video format used by CD+G karaoke disks

       <b>Phantom</b> <b>Cine</b>               <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Commodore</b> <b>CDXL</b>             <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Amiga CD video format

       <b>Core</b> <b>Audio</b> <b>Format</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Apple Core Audio Format

       <b>CRC</b> <b>testing</b> <b>format</b>         <b>:</b>  <b>X</b> <b>@tab</b>
       <b>Creative</b> <b>Voice</b>             <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Created for the Sound Blaster Pro.

       <b>CRYO</b> <b>APC</b>                   <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used in some games by CRYO Interactive Entertainment.

       <b>D-Cinema</b> <b>audio</b>             <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Deluxe</b> <b>Paint</b> <b>Animation</b>     <b>:</b>    <b>@tab</b> <b>X</b>
       <b>DCSTR</b>                      <b>:</b>    <b>@tab</b> <b>X</b>
       <b>DFA</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab This format is used in Chronomaster game

       <b>DirectDraw</b> <b>Surface</b>         <b>:</b>    <b>@tab</b> <b>X</b>
       <b>DSD</b> <b>Stream</b> <b>File</b> <b>(DSF)</b>      <b>:</b>    <b>@tab</b> <b>X</b>
       <b>DV</b> <b>video</b>                   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>DXA</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab This format is used in the non-Windows version of the Feeble Files
                    game and different game cutscenes repacked for use with ScummVM.

       <b>Electronic</b> <b>Arts</b> <b>cdata</b>   <b>:</b>     <b>@tab</b> <b>X</b>
       <b>Electronic</b> <b>Arts</b> <b>Multimedia</b>   <b>:</b>     <b>@tab</b> <b>X</b>
               @tab Used in various EA games; files have extensions like WVE and UV2.

       <b>Ensoniq</b> <b>Paris</b> <b>Audio</b> <b>File</b>   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>FFM</b> <b>(FFserver</b> <b>live</b> <b>feed)</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Flash</b> <b>(SWF)</b>                <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Flash</b> <b>9</b> <b>(AVM2)</b>             <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Only embedded audio is decoded.

       <b>FLI/FLC/FLX</b> <b>animation</b>      <b>:</b>    <b>@tab</b> <b>X</b>
               @tab .fli/.flc files

       <b>Flash</b> <b>Video</b> <b>(FLV)</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Macromedia Flash video files

       <b>framecrc</b> <b>testing</b> <b>format</b>    <b>:</b>  <b>X</b> <b>@tab</b>
       <b>FunCom</b> <b>ISS</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used in various games from FunCom like The Longest Journey.

       <b>G.723.1</b>                    <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>G.726</b>                      <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b> <b>Both</b> <b>left-</b> <b>and</b> <b>right-justified.</b>
       <b>G.729</b> <b>BIT</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>G.729</b> <b>raw</b>                  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>GENH</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format for various games.

       <b>GIF</b> <b>Animation</b>              <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>GXF</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab General eXchange Format SMPTE 360M, used by Thomson Grass Valley
                    playout servers.

       <b>HNM</b>  <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Only version 4 supported, used in some games from Cryo Interactive

       <b>iCEDraw</b> <b>File</b>               <b>:</b>    <b>@tab</b> <b>X</b>
       <b>ICO</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Microsoft Windows ICO

       <b>id</b> <b>Quake</b> <b>II</b> <b>CIN</b> <b>video</b>      <b>:</b>    <b>@tab</b> <b>X</b>
       <b>id</b> <b>RoQ</b>                     <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Used in Quake III, Jedi Knight 2 and other computer games.

       <b>IEC61937</b> <b>encapsulation</b>  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>IFF</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Interchange File Format

       <b>IFV</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab A format used by some old CCTV DVRs.

       <b>iLBC</b>                       <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Interplay</b> <b>MVE</b>              <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Format used in various Interplay computer games.

       <b>Iterated</b> <b>Systems</b> <b>ClearVideo</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab I-frames only

       <b>IV8</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab A format generated by IndigoVision 8000 video server.

       <b>IVF</b> <b>(On2)</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab A format used by libvpx

       <b>Internet</b> <b>Video</b> <b>Recording</b>   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>IRCAM</b>                      <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>LAF</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Limitless Audio Format

       <b>LATM</b>                       <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>LMLM4</b>                      <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used by Linux Media Labs MPEG-4 PCI boards

       <b>LOAS</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
               @tab contains LATM multiplexed AAC audio

       <b>LRC</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>LVF</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>LXF</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab VR native stream format, used by Leitch/Harris' video servers.

       <b>Magic</b> <b>Lantern</b> <b>Video</b> <b>(MLV)</b>  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Matroska</b>                   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Matroska</b> <b>audio</b>             <b>:</b>  <b>X</b> <b>@tab</b>
       <b>FFmpeg</b> <b>metadata</b>            <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Metadata in text format.

       <b>MAXIS</b> <b>XA</b>                   <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used in Sim City 3000; file extension .xa.

       <b>MCA</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used in some games from Capcom; file extension .mca.

       <b>MD</b> <b>Studio</b>                  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Metal</b> <b>Gear</b> <b>Solid:</b> <b>The</b> <b>Twin</b> <b>Snakes</b>  <b>:</b>  <b>@tab</b> <b>X</b>
       <b>Megalux</b> <b>Frame</b>              <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used by Megalux Ultimate Paint

       <b>MobiClip</b> <b>MODS</b>              <b>:</b>    <b>@tab</b> <b>X</b>
       <b>MobiClip</b> <b>MOFLEX</b>            <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Mobotix</b> <b>.mxg</b>               <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Monkey's</b> <b>Audio</b>             <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Motion</b> <b>Pixels</b> <b>MVI</b>          <b>:</b>    <b>@tab</b> <b>X</b>
       <b>MOV/QuickTime/MP4</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab 3GP, 3GP2, PSP, iPod variants supported

       <b>MP2</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>MP3</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>MPEG-1</b> <b>System</b>              <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab muxed audio and video, VCD format supported

       <b>MPEG-PS</b> <b>(program</b> <b>stream)</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab also known as C&lt;VOB&gt; file, SVCD and DVD format supported

       <b>MPEG-TS</b> <b>(transport</b> <b>stream)</b>  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab also known as DVB Transport Stream

       <b>MPEG-4</b>                     <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab MPEG-4 is a variant of QuickTime.

       <b>MSF</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used on the PS3.

       <b>Mirillis</b> <b>FIC</b> <b>video</b>         <b>:</b>    <b>@tab</b> <b>X</b>
               @tab No cursor rendering.

       <b>MIDI</b> <b>Sample</b> <b>Dump</b> <b>Standard</b>  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>MIME</b> <b>multipart</b> <b>JPEG</b>        <b>:</b>  <b>X</b> <b>@tab</b>
       <b>MSN</b> <b>TCP</b> <b>webcam</b>             <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used by MSN Messenger webcam streams.

       <b>MTV</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Musepack</b>                   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Musepack</b> <b>SV8</b>               <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Material</b> <b>eXchange</b> <b>Format</b> <b>(MXF)</b>  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab SMPTE 377M, used by D-Cinema, broadcast industry.

       <b>Material</b> <b>eXchange</b> <b>Format</b> <b>(MXF),</b> <b>D-10</b> <b>Mapping</b>  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab SMPTE 386M, D-10/IMX Mapping.

       <b>NC</b> <b>camera</b> <b>feed</b>             <b>:</b>    <b>@tab</b> <b>X</b>
               @tab NC (AVIP NC4600) camera streams

       <b>NIST</b> <b>SPeech</b> <b>HEader</b> <b>REsources</b>  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Computerized</b> <b>Speech</b> <b>Lab</b> <b>NSP</b>  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>NTT</b> <b>TwinVQ</b> <b>(VQF)</b>           <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Nippon Telegraph and Telephone Corporation TwinVQ.

       <b>Nullsoft</b> <b>Streaming</b> <b>Video</b>   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>NuppelVideo</b>                <b>:</b>    <b>@tab</b> <b>X</b>
       <b>NUT</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab NUT Open Container Format

       <b>Ogg</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Playstation</b> <b>Portable</b> <b>PMP</b>   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Portable</b> <b>Voice</b> <b>Format</b>      <b>:</b>    <b>@tab</b> <b>X</b>
       <b>RK</b> <b>Audio</b> <b>(RKA)</b>             <b>:</b>    <b>@tab</b> <b>X</b>
       <b>TechnoTrend</b> <b>PVA</b>            <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used by TechnoTrend DVB PCI boards.

       <b>QCP</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>ADTS</b> <b>(AAC)</b>             <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>AC-3</b>                   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>AMR-NB</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>AMR-WB</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>APAC</b>                   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>aptX</b>                   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>aptX</b> <b>HD</b>                <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>Bonk</b>                   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>Chinese</b> <b>AVS</b> <b>video</b>      <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>DFPWM</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>Dirac</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>DNxHD</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>DTS</b>                    <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>DTS-HD</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>E-AC-3</b>                 <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>EVC</b>                    <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>FLAC</b>                   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>GSM</b>                    <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>H.261</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>H.263</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>H.264</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>HEVC</b>                   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>Ingenient</b> <b>MJPEG</b>        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>MJPEG</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>MLP</b>                    <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>MPEG</b>                   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>MPEG-1</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>MPEG-2</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>MPEG-4</b>                 <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>NULL</b>                   <b>:</b>  <b>X</b> <b>@tab</b>
       <b>raw</b> <b>video</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>id</b> <b>RoQ</b>                 <b>:</b>  <b>X</b> <b>@tab</b>
       <b>raw</b> <b>OBU</b>                    <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>OSQ</b>                    <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>SBC</b>                    <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>Shorten</b>                <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>TAK</b>                    <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>TrueHD</b>                 <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>VC-1</b>                   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>A-law</b>              <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>mu-law</b>             <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>Archimedes</b> <b>VIDC</b>    <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>signed</b> <b>8</b> <b>bit</b>       <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>signed</b> <b>16</b> <b>bit</b> <b>big-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>signed</b> <b>16</b> <b>bit</b> <b>little-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>signed</b> <b>24</b> <b>bit</b> <b>big-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>signed</b> <b>24</b> <b>bit</b> <b>little-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>signed</b> <b>32</b> <b>bit</b> <b>big-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>signed</b> <b>32</b> <b>bit</b> <b>little-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>signed</b> <b>64</b> <b>bit</b> <b>big-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>signed</b> <b>64</b> <b>bit</b> <b>little-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>unsigned</b> <b>8</b> <b>bit</b>     <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>unsigned</b> <b>16</b> <b>bit</b> <b>big-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>unsigned</b> <b>16</b> <b>bit</b> <b>little-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>unsigned</b> <b>24</b> <b>bit</b> <b>big-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>unsigned</b> <b>24</b> <b>bit</b> <b>little-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>unsigned</b> <b>32</b> <b>bit</b> <b>big-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>unsigned</b> <b>32</b> <b>bit</b> <b>little-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>16.8</b> <b>floating</b> <b>point</b> <b>little-endian</b>  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>24.0</b> <b>floating</b> <b>point</b> <b>little-endian</b>  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>floating-point</b> <b>32</b> <b>bit</b> <b>big-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>floating-point</b> <b>32</b> <b>bit</b> <b>little-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>floating-point</b> <b>64</b> <b>bit</b> <b>big-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>raw</b> <b>PCM</b> <b>floating-point</b> <b>64</b> <b>bit</b> <b>little-endian</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>RDT</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>REDCODE</b> <b>R3D</b>                <b>:</b>    <b>@tab</b> <b>X</b>
               @tab File format used by RED Digital cameras, contains JPEG 2000 frames and PCM audio.

       <b>RealMedia</b>                  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Redirector</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
       <b>RedSpark</b>                   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Renderware</b> <b>TeXture</b> <b>Dictionary</b>  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Resolume</b> <b>DXV</b>               <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Encoding is only supported for the DXT1 (Normal Quality, No Alpha) texture format.

       <b>RF64</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
       <b>RL2</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio and video format used in some games by Entertainment Software Partners.

       <b>RPL/ARMovie</b>                <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Lego</b> <b>Mindstorms</b> <b>RSO</b>        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>RSD</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>RTMP</b>                       <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Output is performed by publishing stream to RTMP server

       <b>RTP</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>RTSP</b>                       <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Sample</b> <b>Dump</b> <b>eXchange</b>       <b>:</b>    <b>@tab</b> <b>X</b>
       <b>SAP</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>SBG</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>SDNS</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
       <b>SDP</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>SER</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Digital</b> <b>Pictures</b> <b>SGA</b>       <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Sega</b> <b>FILM/CPK</b>              <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Used in many Sega Saturn console games.

       <b>Silicon</b> <b>Graphics</b> <b>Movie</b>     <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Sierra</b> <b>SOL</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
               @tab .sol files used in Sierra Online games.

       <b>Sierra</b> <b>VMD</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used in Sierra CD-ROM games.

       <b>Smacker</b>                    <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Multimedia format used by many games.

       <b>SMJPEG</b>                     <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Used in certain Loki game ports.

       <b>SMPTE</b> <b>337M</b> <b>encapsulation</b>   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Smush</b>                      <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Multimedia format used in some LucasArts games.

       <b>Sony</b> <b>OpenMG</b> <b>(OMA)</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Audio format used in Sony Sonic Stage and Sony Vegas.

       <b>Sony</b> <b>PlayStation</b> <b>STR</b>       <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Sony</b> <b>Wave64</b> <b>(W64)</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>SoX</b> <b>native</b> <b>format</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>SUN</b> <b>AU</b> <b>format</b>              <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>SUP</b> <b>raw</b> <b>PGS</b> <b>subtitles</b>      <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>SVAG</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used in Konami PS2 games.

       <b>TDSC</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Text</b> <b>files</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
       <b>THP</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used on the Nintendo GameCube.

       <b>Tiertex</b> <b>Limited</b> <b>SEQ</b>        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Tiertex .seq files used in the DOS CD-ROM version of the game Flashback.

       <b>True</b> <b>Audio</b>                 <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>VAG</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used in many Sony PS2 games.

       <b>VC-1</b> <b>test</b> <b>bitstream</b>        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Vidvox</b> <b>Hap</b>                 <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Vivo</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
       <b>VPK</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used in Sony PS games.

       <b>Marble</b> <b>WADY</b>                <b>:</b>    <b>@tab</b> <b>X</b>
       <b>WAV</b>                        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Waveform</b> <b>Archiver</b>          <b>:</b>    <b>@tab</b> <b>X</b>
       <b>WavPack</b>                    <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>WebM</b>                       <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Windows</b> <b>Televison</b> <b>(WTV)</b>    <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Wing</b> <b>Commander</b> <b>III</b> <b>movie</b>   <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Multimedia format used in Origin's Wing Commander III computer game.

       <b>Westwood</b> <b>Studios</b> <b>audio</b>     <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Multimedia format used in Westwood Studios games.

       <b>Westwood</b> <b>Studios</b> <b>VQA</b>       <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Multimedia format used in Westwood Studios games.

       <b>Wideband</b> <b>Single-bit</b> <b>Data</b> <b>(WSD)</b>  <b>:</b>    <b>@tab</b> <b>X</b>
       <b>WVE</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
       <b>Konami</b> <b>XMD</b>                 <b>:</b>    <b>@tab</b> <b>X</b>
       <b>XMV</b>                        <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Microsoft video container used in Xbox games.

       <b>XVAG</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Audio format used on the PS3.

       <b>xWMA</b>                       <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Microsoft audio container used by XAudio 2.

       <b>eXtended</b> <b>BINary</b> <b>text</b> <b>(XBIN)</b>  <b>:</b>  <b>@tab</b> <b>X</b>
       <b>YUV4MPEG</b> <b>pipe</b>              <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>Psygnosis</b> <b>YOP</b>              <b>:</b>    <b>@tab</b> <b>X</b>

       "X" means that the feature in that column (encoding / decoding) is supported.

   <b>Image</b> <b>Formats</b>
       FFmpeg can read and write images for each frame of a video sequence.  The  following  image  formats  are
       supported:

       <b>Name</b>  <b>:</b>  <b>Encoding</b> <b>@tab</b> <b>Decoding</b> <b>@tab</b> <b>Comments</b>
       <b>.Y.U.V</b>        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab one raw file per component

       <b>Alias</b> <b>PIX</b>     <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Alias/Wavefront PIX image format

       <b>animated</b> <b>GIF</b>  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>APNG</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Animated Portable Network Graphics

       <b>BMP</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Microsoft BMP image

       <b>BRender</b> <b>PIX</b>   <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Argonaut BRender 3D engine image format.

       <b>CRI</b>           <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Cintel RAW

       <b>DPX</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Digital Picture Exchange

       <b>EXR</b>           <b>:</b>    <b>@tab</b> <b>X</b>
               @tab OpenEXR

       <b>FITS</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Flexible Image Transport System

       <b>HDR</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Radiance HDR RGBE Image format

       <b>IMG</b>           <b>:</b>    <b>@tab</b> <b>X</b>
               @tab GEM Raster image

       <b>JPEG</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Progressive JPEG is not supported.

       <b>JPEG</b> <b>2000</b>     <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>JPEG-LS</b>       <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
       <b>LJPEG</b>         <b>:</b>  <b>X</b> <b>@tab</b>
               @tab Lossless JPEG

       <b>Media</b> <b>100</b>     <b>:</b>    <b>@tab</b> <b>X</b>
       <b>MSP</b>           <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Microsoft Paint image

       <b>PAM</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab PAM is a PNM extension with alpha support.

       <b>PBM</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Portable BitMap image

       <b>PCD</b>           <b>:</b>    <b>@tab</b> <b>X</b>
               @tab PhotoCD

       <b>PCX</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab PC Paintbrush

       <b>PFM</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Portable FloatMap image

       <b>PGM</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Portable GrayMap image

       <b>PGMYUV</b>        <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab PGM with U and V components in YUV 4:2:0

       <b>PGX</b>           <b>:</b>    <b>@tab</b> <b>X</b>
               @tab PGX file decoder

       <b>PHM</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Portable HalfFloatMap image

       <b>PIC</b>           <b>:</b>  <b>@tab</b> <b>X</b>
               @tab Pictor/PC Paint

       <b>PNG</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Portable Network Graphics image

       <b>PPM</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Portable PixelMap image

       <b>PSD</b>           <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Photoshop

       <b>PTX</b>           <b>:</b>    <b>@tab</b> <b>X</b>
               @tab V.Flash PTX format

       <b>QOI</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Quite OK Image format

       <b>SGI</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab SGI RGB image format

       <b>Sun</b> <b>Rasterfile</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Sun RAS image format

       <b>TIFF</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab YUV, JPEG and some extension is not supported yet.

       <b>Truevision</b> <b>Targa</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Targa (.TGA) image format

       <b>VBN</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Vizrt Binary Image format

       <b>WBMP</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab Wireless Application Protocol Bitmap image format

       <b>WebP</b>          <b>:</b>  <b>E</b> <b>@tab</b> <b>X</b>
               @tab WebP image format, encoding supported through external library libwebp

       <b>XBM</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab X BitMap image format

       <b>XFace</b>  <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab X-Face image format

       <b>XPM</b>   <b>:</b>    <b>@tab</b> <b>X</b>
               @tab X PixMap image format

       <b>XWD</b>   <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b>
               @tab X Window Dump image format

       "X" means that the feature in that column (encoding / decoding) is supported.

       "E" means that support is provided through an external library.

   <b>Video</b> <b>Codecs</b>
       <b>Name</b>  <b>:</b>  <b>Encoding</b> <b>@tab</b> <b>Decoding</b> <b>@tab</b> <b>Comments</b>
       <b>4X</b> <b>Movie</b>                <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in certain computer games.

       <b>8088flex</b> <b>TMV</b>            <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>A64</b> <b>multicolor</b>          <b>:</b>   <b>X</b>  <b>@tab</b>
               @tab Creates video suitable to be played on a commodore 64 (multicolor mode).

       <b>Amazing</b> <b>Studio</b> <b>PAF</b> <b>Video</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>American</b> <b>Laser</b> <b>Games</b> <b>MM</b>   <b>:</b>     <b>@tab</b> <b>X</b>
               @tab Used in games like Mad Dog McCree.

       <b>Amuse</b> <b>Graphics</b> <b>Movie</b>    <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>AMV</b> <b>Video</b>               <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Used in Chinese MP3 players.

       <b>ANSI/ASCII</b> <b>art</b>          <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Apple</b> <b>Intermediate</b> <b>Codec</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Apple</b> <b>MJPEG-B</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Apple</b> <b>Pixlet</b>            <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Apple</b> <b>ProRes</b>            <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: apch,apcn,apcs,apco,ap4h,ap4x

       <b>Apple</b> <b>QuickDraw</b>         <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: qdrw

       <b>Argonaut</b> <b>Video</b>          <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in some Argonaut games.

       <b>Asus</b> <b>v1</b>                 <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: ASV1

       <b>Asus</b> <b>v2</b>                 <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: ASV2

       <b>ATI</b> <b>VCR1</b>                <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: VCR1

       <b>ATI</b> <b>VCR2</b>                <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: VCR2

       <b>Auravision</b> <b>Aura</b>         <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Auravision</b> <b>Aura</b> <b>2</b>       <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Autodesk</b> <b>Animator</b> <b>Flic</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Autodesk</b> <b>RLE</b>            <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: AASC

       <b>AV1</b>                     <b>:</b>   <b>E</b>  <b>@tab</b>  <b>E</b>
               @tab Supported through external libraries libaom, libdav1d, librav1e and libsvtav1

       <b>Avid</b> <b>1:1</b> <b>10-bit</b> <b>RGB</b> <b>Packer</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: AVrp

       <b>AVS</b> <b>(Audio</b> <b>Video</b> <b>Standard)</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Video encoding used by the Creature Shock game.

       <b>AVS2-P2/IEEE1857.4</b>      <b>:</b>   <b>E</b>  <b>@tab</b>  <b>E</b>
               @tab Supported through external libraries libxavs2 and libdavs2

       <b>AVS3-P2/IEEE1857.10</b>     <b>:</b>      <b>@tab</b>  <b>E</b>
               @tab Supported through external library libuavs3d

       <b>AYUV</b>                    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Microsoft uncompressed packed 4:4:4:4

       <b>Beam</b> <b>Software</b> <b>VB</b>        <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Bethesda</b> <b>VID</b> <b>video</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in some games from Bethesda Softworks.

       <b>Bink</b> <b>Video</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>BitJazz</b> <b>SheerVideo</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Bitmap</b> <b>Brothers</b> <b>JV</b> <b>video</b>   <b>:</b>    <b>@tab</b> <b>X</b>
       <b>y41p</b> <b>Brooktree</b> <b>uncompressed</b> <b>4:1:1</b> <b>12-bit</b>      <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Brooktree</b> <b>ProSumer</b> <b>Video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: BT20

       <b>Brute</b> <b>Force</b> <b>&amp;</b> <b>Ignorance</b>    <b>:</b>    <b>@tab</b> <b>X</b>
               @tab Used in the game Flash Traffic: City of Angels.

       <b>C93</b> <b>video</b>               <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Codec used in Cyberia game.

       <b>CamStudio</b>               <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: CSCD

       <b>CD+G</b>                    <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Video codec for CD+G karaoke disks

       <b>CDXL</b>                    <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Amiga CD video codec

       <b>Chinese</b> <b>AVS</b> <b>video</b>       <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab AVS1-P2, JiZhun profile, encoding through external library libxavs

       <b>Delphine</b> <b>Software</b> <b>International</b> <b>CIN</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Codec used in Delphine Software International games.

       <b>Discworld</b> <b>II</b> <b>BMV</b> <b>Video</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>CineForm</b> <b>HD</b>             <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Canopus</b> <b>HQ</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Canopus</b> <b>HQA</b>             <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Canopus</b> <b>HQX</b>             <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Canopus</b> <b>Lossless</b> <b>Codec</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>CDToons</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Codec used in various Broderbund games.

       <b>Cinepak</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Cirrus</b> <b>Logic</b> <b>AccuPak</b>    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: CLJR

       <b>CPiA</b> <b>Video</b> <b>Format</b>       <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Creative</b> <b>YUV</b> <b>(CYUV)</b>     <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>DFA</b>                     <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Codec used in Chronomaster game.

       <b>Dirac</b>                   <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab supported though the native vc2 (Dirac Pro) encoder

       <b>Deluxe</b> <b>Paint</b> <b>Animation</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>DNxHD</b>                   <b>:</b>    <b>X</b> <b>@tab</b>  <b>X</b>
               @tab aka SMPTE VC3

       <b>Duck</b> <b>TrueMotion</b> <b>1.0</b>    <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: DUCK

       <b>Duck</b> <b>TrueMotion</b> <b>2.0</b>     <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: TM20

       <b>Duck</b> <b>TrueMotion</b> <b>2.0</b> <b>RT</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: TR20

       <b>DV</b> <b>(Digital</b> <b>Video)</b>      <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Dxtory</b> <b>capture</b> <b>format</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Feeble</b> <b>Files/ScummVM</b> <b>DXA</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Codec originally used in Feeble Files game.

       <b>Electronic</b> <b>Arts</b> <b>CMV</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in NHL 95 game.

       <b>Electronic</b> <b>Arts</b> <b>Madcow</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Electronic</b> <b>Arts</b> <b>TGV</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Electronic</b> <b>Arts</b> <b>TGQ</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Electronic</b> <b>Arts</b> <b>TQI</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Escape</b> <b>124</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Escape</b> <b>130</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>EVC</b> <b>/</b> <b>MPEG-5</b> <b>Part</b> <b>1</b>     <b>:</b>   <b>E</b>  <b>@tab</b>  <b>E</b>
               @tab encoding and decoding supported through external libraries libxeve and libxevd

       <b>FFmpeg</b> <b>video</b> <b>codec</b> <b>#1</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab lossless codec (fourcc: FFV1)

       <b>Flash</b> <b>Screen</b> <b>Video</b> <b>v1</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: FSV1

       <b>Flash</b> <b>Screen</b> <b>Video</b> <b>v2</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Flash</b> <b>Video</b> <b>(FLV)</b>       <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Sorenson H.263 used in Flash

       <b>FM</b> <b>Screen</b> <b>Capture</b> <b>Codec</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Forward</b> <b>Uncompressed</b>    <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Fraps</b>                   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Go2Meeting</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: G2M2, G2M3

       <b>Go2Webinar</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: G2M4

       <b>Gremlin</b> <b>Digital</b> <b>Video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>H.261</b>                   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>H.263</b> <b>/</b> <b>H.263-1996</b>      <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>H.263+</b> <b>/</b> <b>H.263-1998</b> <b>/</b> <b>H.263</b> <b>version</b> <b>2</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>H.264</b> <b>/</b> <b>AVC</b> <b>/</b> <b>MPEG-4</b> <b>AVC</b> <b>/</b> <b>MPEG-4</b> <b>part</b> <b>10</b>   <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab encoding supported through external library libx264 and OpenH264

       <b>HEVC</b>                    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab encoding supported through external library libx265 and libkvazaar

       <b>HNM</b> <b>version</b> <b>4</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>HuffYUV</b>                 <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>HuffYUV</b> <b>FFmpeg</b> <b>variant</b>  <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>IBM</b> <b>Ultimotion</b>          <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: ULTI

       <b>id</b> <b>Cinematic</b> <b>video</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in Quake II.

       <b>id</b> <b>RoQ</b> <b>video</b>            <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Used in Quake III, Jedi Knight 2, other computer games.

       <b>IFF</b> <b>ILBM</b>                <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab IFF interleaved bitmap

       <b>IFF</b> <b>ByteRun1</b>            <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab IFF run length encoded bitmap

       <b>Infinity</b> <b>IMM4</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Intel</b> <b>H.263</b>             <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Intel</b> <b>Indeo</b> <b>2</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Intel</b> <b>Indeo</b> <b>3</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Intel</b> <b>Indeo</b> <b>4</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Intel</b> <b>Indeo</b> <b>5</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Interplay</b> <b>C93</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in the game Cyberia from Interplay.

       <b>Interplay</b> <b>MVE</b> <b>video</b>     <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in Interplay .MVE files.

       <b>J2K</b>  <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Karl</b> <b>Morton's</b> <b>video</b> <b>codec</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Codec used in Worms games.

       <b>Kega</b> <b>Game</b> <b>Video</b> <b>(KGV1)</b>  <b>:</b>       <b>@tab</b>  <b>X</b>
               @tab Kega emulator screen capture codec.

       <b>Lagarith</b>                <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>LCEVC</b> <b>/</b> <b>MPEG-5</b> <b>LCEVC</b> <b>/</b> <b>MPEG-5</b> <b>Part</b> <b>2</b>  <b>:</b>      <b>@tab</b>  <b>E</b>
               @tab decoding supported through external library liblcevc-dec

       <b>LCL</b> <b>(LossLess</b> <b>Codec</b> <b>Library)</b> <b>MSZH</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>LCL</b> <b>(LossLess</b> <b>Codec</b> <b>Library)</b> <b>ZLIB</b>   <b>:</b>   <b>E</b>  <b>@tab</b>  <b>E</b>
       <b>LEAD</b> <b>MCMP</b>               <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>LOCO</b>                    <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>LucasArts</b> <b>SANM/Smush</b>    <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in LucasArts games / SMUSH animations.

       <b>lossless</b> <b>MJPEG</b>          <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>MagicYUV</b> <b>Video</b>          <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Mandsoft</b> <b>Screen</b> <b>Capture</b> <b>Codec</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Microsoft</b> <b>ATC</b> <b>Screen</b>    <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Also known as Microsoft Screen 3.

       <b>Microsoft</b> <b>Expression</b> <b>Encoder</b> <b>Screen</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Also known as Microsoft Titanium Screen 2.

       <b>Microsoft</b> <b>RLE</b>           <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Microsoft</b> <b>Screen</b> <b>1</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Also known as Windows Media Video V7 Screen.

       <b>Microsoft</b> <b>Screen</b> <b>2</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Also known as Windows Media Video V9 Screen.

       <b>Microsoft</b> <b>Video</b> <b>1</b>       <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Mimic</b>                   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in MSN Messenger Webcam streams.

       <b>Miro</b> <b>VideoXL</b>            <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: VIXL

       <b>MJPEG</b> <b>(Motion</b> <b>JPEG)</b>     <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Mobotix</b> <b>MxPEG</b> <b>video</b>     <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Motion</b> <b>Pixels</b> <b>video</b>     <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>MPEG-1</b> <b>video</b>            <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>MPEG-2</b> <b>video</b>            <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>MPEG-4</b> <b>part</b> <b>2</b>           <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab libxvidcore can be used alternatively for encoding.

       <b>MPEG-4</b> <b>part</b> <b>2</b> <b>Microsoft</b> <b>variant</b> <b>version</b> <b>1</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>MPEG-4</b> <b>part</b> <b>2</b> <b>Microsoft</b> <b>variant</b> <b>version</b> <b>2</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>MPEG-4</b> <b>part</b> <b>2</b> <b>Microsoft</b> <b>variant</b> <b>version</b> <b>3</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Newtek</b> <b>SpeedHQ</b>                <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Nintendo</b> <b>Gamecube</b> <b>THP</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>NotchLC</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>NuppelVideo/RTjpeg</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Video encoding used in NuppelVideo files.

       <b>On2</b> <b>VP3</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab still experimental

       <b>On2</b> <b>VP4</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: VP40

       <b>On2</b> <b>VP5</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: VP50

       <b>On2</b> <b>VP6</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: VP60,VP61,VP62

       <b>On2</b> <b>VP7</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: VP70,VP71

       <b>VP8</b>                     <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: VP80, encoding supported through external library libvpx

       <b>VP9</b>                     <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab encoding supported through external library libvpx

       <b>Pinnacle</b> <b>TARGA</b> <b>CineWave</b> <b>YUV16</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: Y216

       <b>Q-team</b> <b>QPEG</b>             <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourccs: QPEG, Q1.0, Q1.1

       <b>QuickTime</b> <b>8BPS</b> <b>video</b>    <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>QuickTime</b> <b>Animation</b> <b>(RLE)</b> <b>video</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: 'rle '

       <b>QuickTime</b> <b>Graphics</b> <b>(SMC)</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: 'smc '

       <b>QuickTime</b> <b>video</b> <b>(RPZA)</b>  <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: rpza

       <b>R10K</b> <b>AJA</b> <b>Kona</b> <b>10-bit</b> <b>RGB</b> <b>Codec</b>      <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>R210</b> <b>Quicktime</b> <b>Uncompressed</b> <b>RGB</b> <b>10-bit</b>      <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Raw</b> <b>Video</b>               <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>RealVideo</b> <b>1.0</b>           <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>RealVideo</b> <b>2.0</b>           <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>RealVideo</b> <b>3.0</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab still far from ideal

       <b>RealVideo</b> <b>4.0</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Renderware</b> <b>TXD</b> <b>(TeXture</b> <b>Dictionary)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Texture dictionaries used by the Renderware Engine.

       <b>RivaTuner</b> <b>Video</b>         <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: 'RTV1'

       <b>RL2</b> <b>video</b>               <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab used in some games by Entertainment Software Partners

       <b>ScreenPressor</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Screenpresso</b>            <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Screen</b> <b>Recorder</b> <b>Gold</b> <b>Codec</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Sierra</b> <b>VMD</b> <b>video</b>        <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in Sierra VMD files.

       <b>Silicon</b> <b>Graphics</b> <b>Motion</b> <b>Video</b> <b>Compressor</b> <b>1</b> <b>(MVC1)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Silicon</b> <b>Graphics</b> <b>Motion</b> <b>Video</b> <b>Compressor</b> <b>2</b> <b>(MVC2)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Silicon</b> <b>Graphics</b> <b>RLE</b> <b>8-bit</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Smacker</b> <b>video</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Video encoding used in Smacker.

       <b>SMPTE</b> <b>VC-1</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Snow</b>                    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab experimental wavelet codec (fourcc: SNOW)

       <b>Sony</b> <b>PlayStation</b> <b>MDEC</b> <b>(Motion</b> <b>DECoder)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Sorenson</b> <b>Vector</b> <b>Quantizer</b> <b>1</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab fourcc: SVQ1

       <b>Sorenson</b> <b>Vector</b> <b>Quantizer</b> <b>3</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: SVQ3

       <b>Sunplus</b> <b>JPEG</b> <b>(SP5X)</b>     <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: SP5X

       <b>TechSmith</b> <b>Screen</b> <b>Capture</b> <b>Codec</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: TSCC

       <b>TechSmith</b> <b>Screen</b> <b>Capture</b> <b>Codec</b> <b>2</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: TSC2

       <b>Theora</b>                  <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab encoding supported through external library libtheora

       <b>Tiertex</b> <b>Limited</b> <b>SEQ</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Codec used in DOS CD-ROM FlashBack game.

       <b>Ut</b> <b>Video</b>                <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>v210</b> <b>QuickTime</b> <b>uncompressed</b> <b>4:2:2</b> <b>10-bit</b>      <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>v308</b> <b>QuickTime</b> <b>uncompressed</b> <b>4:4:4</b>             <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>v408</b> <b>QuickTime</b> <b>uncompressed</b> <b>4:4:4:4</b>           <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>v410</b> <b>QuickTime</b> <b>uncompressed</b> <b>4:4:4</b> <b>10-bit</b>      <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>VBLE</b> <b>Lossless</b> <b>Codec</b>     <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>vMix</b> <b>Video</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab fourcc: 'VMX1'

       <b>VMware</b> <b>Screen</b> <b>Codec</b> <b>/</b> <b>VMware</b> <b>Video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Codec used in videos captured by VMware.

       <b>Westwood</b> <b>Studios</b> <b>VQA</b> <b>(Vector</b> <b>Quantized</b> <b>Animation)</b> <b>video</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Windows</b> <b>Media</b> <b>Image</b>     <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Windows</b> <b>Media</b> <b>Video</b> <b>7</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Windows</b> <b>Media</b> <b>Video</b> <b>8</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Windows</b> <b>Media</b> <b>Video</b> <b>9</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab not completely working

       <b>Wing</b> <b>Commander</b> <b>III</b> <b>/</b> <b>Xan</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in Wing Commander III .MVE files.

       <b>Wing</b> <b>Commander</b> <b>IV</b> <b>/</b> <b>Xan</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in Wing Commander IV.

       <b>Winnov</b> <b>WNV1</b>             <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>WMV7</b>                    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>YAMAHA</b> <b>SMAF</b>             <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Psygnosis</b> <b>YOP</b> <b>Video</b>     <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>yuv4</b>                    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab libquicktime uncompressed packed 4:2:0

       <b>ZeroCodec</b> <b>Lossless</b> <b>Video</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ZLIB</b>                    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab part of LCL, encoder experimental

       <b>Zip</b> <b>Motion</b> <b>Blocks</b> <b>Video</b>   <b>:</b>    <b>X</b> <b>@tab</b>  <b>X</b>
               @tab Encoder works only in PAL8.

       "X" means that the feature in that column (encoding / decoding) is supported.

       "E" means that support is provided through an external library.

   <b>Audio</b> <b>Codecs</b>
       <b>Name</b>  <b>:</b>  <b>Encoding</b> <b>@tab</b> <b>Decoding</b> <b>@tab</b> <b>Comments</b>
       <b>8SVX</b> <b>exponential</b>        <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>8SVX</b> <b>fibonacci</b>          <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>AAC</b>                     <b>:</b>  <b>EX</b>  <b>@tab</b>  <b>X</b>
               @tab encoding supported through internal encoder and external library libfdk-aac

       <b>AAC+</b>                    <b>:</b>   <b>E</b>  <b>@tab</b>  <b>IX</b>
               @tab encoding supported through external library libfdk-aac

       <b>AC-3</b>                    <b>:</b>  <b>IX</b>  <b>@tab</b>  <b>IX</b>
       <b>ACELP.KELVIN</b>            <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>4X</b> <b>Movie</b>          <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Yamaha</b> <b>AICA</b>       <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>AmuseGraphics</b> <b>Movie</b>  <b>:</b>     <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Argonaut</b> <b>Games</b>    <b>:</b>  <b>X</b>   <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>CDROM</b> <b>XA</b>          <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Creative</b> <b>Technology</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab 16 -E&lt;gt&gt; 4, 8 -E&lt;gt&gt; 4, 8 -E&lt;gt&gt; 3, 8 -E&lt;gt&gt; 2

       <b>ADPCM</b> <b>Electronic</b> <b>Arts</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in various EA titles.

       <b>ADPCM</b> <b>Electronic</b> <b>Arts</b> <b>Maxis</b> <b>CDROM</b> <b>XS</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in Sim City 3000.

       <b>ADPCM</b> <b>Electronic</b> <b>Arts</b> <b>R1</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Electronic</b> <b>Arts</b> <b>R2</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Electronic</b> <b>Arts</b> <b>R3</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Electronic</b> <b>Arts</b> <b>XAS</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>G.722</b>             <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>G.726</b>             <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>Acorn</b> <b>Replay</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>AMV</b>           <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Used in AMV files

       <b>ADPCM</b> <b>IMA</b> <b>Cunning</b> <b>Developments</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>Electronic</b> <b>Arts</b> <b>EACS</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>Electronic</b> <b>Arts</b> <b>SEAD</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>Funcom</b>        <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>High</b> <b>Voltage</b> <b>Software</b> <b>ALP</b>       <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>Mobiclip</b> <b>MOFLEX</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>QuickTime</b>     <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>Simon</b> <b>&amp;</b> <b>Schuster</b> <b>Interactive</b>    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>Ubisoft</b> <b>APM</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>Loki</b> <b>SDL</b> <b>MJPEG</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>WAV</b>           <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>Westwood</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>ISS</b> <b>IMA</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in FunCom games.

       <b>ADPCM</b> <b>IMA</b> <b>Dialogic</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>IMA</b> <b>Duck</b> <b>DK3</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in some Sega Saturn console games.

       <b>ADPCM</b> <b>IMA</b> <b>Duck</b> <b>DK4</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in some Sega Saturn console games.

       <b>ADPCM</b> <b>IMA</b> <b>Radical</b>       <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Microsoft</b>         <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>MS</b> <b>IMA</b>            <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Nintendo</b> <b>Gamecube</b> <b>AFC</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Nintendo</b> <b>Gamecube</b> <b>DTK</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Nintendo</b> <b>THP</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Playstation</b>       <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>QT</b> <b>IMA</b>            <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>SEGA</b> <b>CRI</b> <b>ADX</b>      <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Used in Sega Dreamcast games.

       <b>ADPCM</b> <b>Shockwave</b> <b>Flash</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Sound</b> <b>Blaster</b> <b>Pro</b> <b>2-bit</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Sound</b> <b>Blaster</b> <b>Pro</b> <b>2.6-bit</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Sound</b> <b>Blaster</b> <b>Pro</b> <b>4-bit</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>VIMA</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in LucasArts SMUSH animations.

       <b>ADPCM</b> <b>Konami</b> <b>XMD</b>        <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Westwood</b> <b>Studios</b> <b>IMA</b>       <b>:</b>   <b>X</b> <b>@tab</b>  <b>X</b>
               @tab Used in Westwood Studios games like Command and Conquer.

       <b>ADPCM</b> <b>Yamaha</b>            <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>ADPCM</b> <b>Zork</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>AMR-NB</b>                  <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab encoding supported through external library libopencore-amrnb

       <b>AMR-WB</b>                  <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab encoding supported through external library libvo-amrwbenc

       <b>Amazing</b> <b>Studio</b> <b>PAF</b> <b>Audio</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Apple</b> <b>lossless</b> <b>audio</b>    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab QuickTime fourcc 'alac'

       <b>aptX</b>                    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Used in Bluetooth A2DP

       <b>aptX</b> <b>HD</b>                 <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Used in Bluetooth A2DP

       <b>ATRAC1</b>                  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ATRAC3</b>                  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ATRAC3+</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>ATRAC9</b>                  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Bink</b> <b>Audio</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in Bink and Smacker files in many games.

       <b>Bonk</b> <b>audio</b>              <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>CELT</b>                    <b>:</b>      <b>@tab</b>  <b>E</b>
               @tab decoding supported through external library libcelt

       <b>codec2</b>                  <b>:</b>   <b>E</b>  <b>@tab</b>  <b>E</b>
               @tab en/decoding supported through external library libcodec2

       <b>CRI</b> <b>HCA</b>                 <b>:</b>      <b>@tab</b> <b>X</b>
       <b>Delphine</b> <b>Software</b> <b>International</b> <b>CIN</b> <b>audio</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Codec used in Delphine Software International games.

       <b>DFPWM</b>                   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Digital</b> <b>Speech</b> <b>Standard</b> <b>-</b> <b>Standard</b> <b>Play</b> <b>mode</b> <b>(DSS</b> <b>SP)</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Discworld</b> <b>II</b> <b>BMV</b> <b>Audio</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>COOK</b>                    <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab All versions except 5.1 are supported.

       <b>DCA</b> <b>(DTS</b> <b>Coherent</b> <b>Acoustics)</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab supported extensions: XCh, XXCH, X96, XBR, XLL, LBR (partially)

       <b>Dolby</b> <b>E</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>DPCM</b> <b>Cuberoot-Delta-Exact</b>  <b>:</b>   <b>@tab</b>  <b>X</b>
               @tab Used in few games.

       <b>DPCM</b> <b>Gremlin</b>            <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>DPCM</b> <b>id</b> <b>RoQ</b>             <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Used in Quake III, Jedi Knight 2 and other computer games.

       <b>DPCM</b> <b>Marble</b> <b>WADY</b>        <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>DPCM</b> <b>Interplay</b>          <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in various Interplay computer games.

       <b>DPCM</b> <b>Squareroot-Delta-Exact</b>   <b>:</b>   <b>@tab</b>  <b>X</b>
               @tab Used in various games.

       <b>DPCM</b> <b>Sierra</b> <b>Online</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in Sierra Online game audio files.

       <b>DPCM</b> <b>Sol</b>                <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>DPCM</b> <b>Xan</b>                <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in Origin's Wing Commander IV AVI files.

       <b>DPCM</b> <b>Xilam</b> <b>DERF</b>         <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>DSD</b> <b>(Direct</b> <b>Stream</b> <b>Digital),</b> <b>least</b> <b>significant</b> <b>bit</b> <b>first</b>   <b>:</b>   <b>@tab</b>  <b>X</b>
       <b>DSD</b> <b>(Direct</b> <b>Stream</b> <b>Digital),</b> <b>most</b> <b>significant</b> <b>bit</b> <b>first</b>    <b>:</b>   <b>@tab</b>  <b>X</b>
       <b>DSD</b> <b>(Direct</b> <b>Stream</b> <b>Digital),</b> <b>least</b> <b>significant</b> <b>bit</b> <b>first,</b> <b>planar</b>   <b>:</b>   <b>@tab</b>  <b>X</b>
       <b>DSD</b> <b>(Direct</b> <b>Stream</b> <b>Digital),</b> <b>most</b> <b>significant</b> <b>bit</b> <b>first,</b> <b>planar</b>    <b>:</b>   <b>@tab</b>  <b>X</b>
       <b>DSP</b> <b>Group</b> <b>TrueSpeech</b>    <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>DST</b> <b>(Direct</b> <b>Stream</b> <b>Transfer)</b>  <b>:</b>   <b>@tab</b>  <b>X</b>
       <b>DV</b> <b>audio</b>                <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Enhanced</b> <b>AC-3</b>           <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>EVRC</b> <b>(Enhanced</b> <b>Variable</b> <b>Rate</b> <b>Codec)</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>FLAC</b> <b>(Free</b> <b>Lossless</b> <b>Audio</b> <b>Codec)</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>IX</b>
       <b>FTR</b> <b>Voice</b>               <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>G.723.1</b>                 <b>:</b>  <b>X</b>   <b>@tab</b>  <b>X</b>
       <b>G.729</b>                   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>GSM</b>                     <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab encoding supported through external library libgsm

       <b>GSM</b> <b>Microsoft</b> <b>variant</b>   <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab encoding supported through external library libgsm

       <b>IAC</b> <b>(Indeo</b> <b>Audio</b> <b>Coder)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>iLBC</b> <b>(Internet</b> <b>Low</b> <b>Bitrate</b> <b>Codec)</b>  <b>:</b>   <b>E</b>  <b>@tab</b>  <b>EX</b>
               @tab encoding and decoding supported through external library libilbc

       <b>IMC</b> <b>(Intel</b> <b>Music</b> <b>Coder)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Interplay</b> <b>ACM</b>             <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>LC3</b>                     <b>:</b>  <b>E</b>  <b>@tab</b>  <b>E</b>
               @tab supported through external library liblc3

       <b>MACE</b> <b>(Macintosh</b> <b>Audio</b> <b>Compression/Expansion)</b> <b>6:1</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Marian's</b> <b>A-pac</b> <b>audio</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>MI-SC4</b> <b>(Micronas</b> <b>SC-4</b> <b>Audio)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>MLP</b> <b>(Meridian</b> <b>Lossless</b> <b>Packing)</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Used in DVD-Audio discs.

       <b>Monkey's</b> <b>Audio</b>          <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>MP1</b> <b>(MPEG</b> <b>audio</b> <b>layer</b> <b>1)</b>   <b>:</b>      <b>@tab</b> <b>IX</b>
       <b>MP2</b> <b>(MPEG</b> <b>audio</b> <b>layer</b> <b>2)</b>   <b>:</b>  <b>IX</b>  <b>@tab</b> <b>IX</b>
               @tab encoding supported also through external library TwoLAME

       <b>MP3</b> <b>(MPEG</b> <b>audio</b> <b>layer</b> <b>3)</b>   <b>:</b>   <b>E</b>  <b>@tab</b> <b>IX</b>
               @tab encoding supported through external library LAME, ADU MP3 and MP3onMP4 also supported

       <b>MPEG-4</b> <b>Audio</b> <b>Lossless</b> <b>Coding</b> <b>(ALS)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>MobiClip</b> <b>FastAudio</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Musepack</b> <b>SV7</b>            <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Musepack</b> <b>SV8</b>            <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Nellymoser</b> <b>Asao</b>         <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>On2</b> <b>AVC</b> <b>(Audio</b> <b>for</b> <b>Video</b> <b>Codec)</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Opus</b>                    <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab encoding supported through external library libopus

       <b>OSQ</b> <b>(Original</b> <b>Sound</b> <b>Quality)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>A-law</b>               <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>mu-law</b>              <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>Archimedes</b> <b>VIDC</b>     <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>8-bit</b> <b>planar</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>16-bit</b> <b>big-endian</b> <b>planar</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>16-bit</b> <b>little-endian</b> <b>planar</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>24-bit</b> <b>little-endian</b> <b>planar</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>32-bit</b> <b>little-endian</b> <b>planar</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>32-bit</b> <b>floating</b> <b>point</b> <b>big-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>32-bit</b> <b>floating</b> <b>point</b> <b>little-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>64-bit</b> <b>floating</b> <b>point</b> <b>big-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>64-bit</b> <b>floating</b> <b>point</b> <b>little-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>D-Cinema</b> <b>audio</b> <b>signed</b> <b>24-bit</b>    <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>8-bit</b>        <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>16-bit</b> <b>big-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>16-bit</b> <b>little-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>24-bit</b> <b>big-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>24-bit</b> <b>little-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>32-bit</b> <b>big-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>32-bit</b> <b>little-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>signed</b> <b>16/20/24-bit</b> <b>big-endian</b> <b>in</b> <b>MPEG-TS</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>unsigned</b> <b>8-bit</b>      <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>unsigned</b> <b>16-bit</b> <b>big-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>unsigned</b> <b>16-bit</b> <b>little-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>unsigned</b> <b>24-bit</b> <b>big-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>unsigned</b> <b>24-bit</b> <b>little-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>unsigned</b> <b>32-bit</b> <b>big-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>unsigned</b> <b>32-bit</b> <b>little-endian</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>PCM</b> <b>SGA</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>QCELP</b> <b>/</b> <b>PureVoice</b>       <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>QDesign</b> <b>Music</b> <b>Codec</b> <b>1</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>QDesign</b> <b>Music</b> <b>Codec</b> <b>2</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab There are still some distortions.

       <b>RealAudio</b> <b>1.0</b> <b>(14.4K)</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Real 14400 bit/s codec

       <b>RealAudio</b> <b>2.0</b> <b>(28.8K)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Real 28800 bit/s codec

       <b>RealAudio</b> <b>3.0</b> <b>(dnet)</b>    <b>:</b>  <b>IX</b>  <b>@tab</b>  <b>X</b>
               @tab Real low bitrate AC-3 codec

       <b>RealAudio</b> <b>Lossless</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>RealAudio</b> <b>SIPR</b> <b>/</b> <b>ACELP.NET</b>  <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>RK</b> <b>Audio</b> <b>(RKA)</b>          <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>SBC</b> <b>(low-complexity</b> <b>subband</b> <b>codec)</b>  <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Used in Bluetooth A2DP

       <b>Shorten</b>                 <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Sierra</b> <b>VMD</b> <b>audio</b>        <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in Sierra VMD files.

       <b>Smacker</b> <b>audio</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>SMPTE</b> <b>302M</b> <b>AES3</b> <b>audio</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Sonic</b>                   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab experimental codec

       <b>Sonic</b> <b>lossless</b>          <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab experimental codec

       <b>Speex</b>                   <b>:</b>   <b>E</b>  <b>@tab</b>  <b>EX</b>
               @tab supported through external library libspeex

       <b>TAK</b> <b>(Tom's</b> <b>lossless</b> <b>Audio</b> <b>Kompressor)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>True</b> <b>Audio</b> <b>(TTA)</b>        <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>TrueHD</b>                  <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
               @tab Used in HD-DVD and Blu-Ray discs.

       <b>TwinVQ</b> <b>(VQF</b> <b>flavor)</b>     <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>VIMA</b>                    <b>:</b>      <b>@tab</b>  <b>X</b>
               @tab Used in LucasArts SMUSH animations.

       <b>ViewQuest</b> <b>VQC</b>           <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Vorbis</b>                  <b>:</b>   <b>E</b>  <b>@tab</b>  <b>X</b>
               @tab A native but very primitive encoder exists.

       <b>Voxware</b> <b>MetaSound</b>       <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Waveform</b> <b>Archiver</b>       <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>WavPack</b>                 <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Westwood</b> <b>Audio</b> <b>(SND1)</b>   <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Windows</b> <b>Media</b> <b>Audio</b> <b>1</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Windows</b> <b>Media</b> <b>Audio</b> <b>2</b>   <b>:</b>   <b>X</b>  <b>@tab</b>  <b>X</b>
       <b>Windows</b> <b>Media</b> <b>Audio</b> <b>Lossless</b>  <b>:</b>   <b>@tab</b>  <b>X</b>
       <b>Windows</b> <b>Media</b> <b>Audio</b> <b>Pro</b>  <b>:</b>     <b>@tab</b>  <b>X</b>
       <b>Windows</b> <b>Media</b> <b>Audio</b> <b>Voice</b>  <b>:</b>   <b>@tab</b>  <b>X</b>
       <b>Xbox</b> <b>Media</b> <b>Audio</b> <b>1</b>      <b>:</b>      <b>@tab</b>  <b>X</b>
       <b>Xbox</b> <b>Media</b> <b>Audio</b> <b>2</b>      <b>:</b>      <b>@tab</b>  <b>X</b>

       "X" means that the feature in that column (encoding / decoding) is supported.

       "E" means that support is provided through an external library.

       "I"  means  that  an  integer-only version is available, too (ensures high performance on systems without
       hardware floating point support).

   <b>Subtitle</b> <b>Formats</b>
       <b>Name</b>  <b>:</b>  <b>Muxing</b> <b>@tab</b> <b>Demuxing</b> <b>@tab</b> <b>Encoding</b> <b>@tab</b> <b>Decoding</b>
       <b>3GPP</b> <b>Timed</b> <b>Text</b>   <b>:</b>    <b>@tab</b>   <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b>
       <b>AQTitle</b>           <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>DVB</b>               <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b>
       <b>DVB</b> <b>teletext</b>      <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>E</b>
       <b>DVD</b>               <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b>
       <b>JACOsub</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>MicroDVD</b>          <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>MPL2</b>              <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>MPsub</b> <b>(MPlayer)</b>   <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>PGS</b>               <b>:</b>    <b>@tab</b>   <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>PJS</b> <b>(Phoenix)</b>     <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>RealText</b>          <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>SAMI</b>              <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>Spruce</b> <b>format</b> <b>(STL)</b>  <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>SSA/ASS</b>           <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b>
       <b>SubRip</b> <b>(SRT)</b>      <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b>
       <b>SubViewer</b> <b>v1</b>      <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>SubViewer</b>         <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>TED</b> <b>Talks</b> <b>captions</b>  <b>:</b>  <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>TTML</b>              <b>:</b>  <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b> <b>@tab</b>
       <b>VobSub</b> <b>(IDX+SUB)</b>  <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>VPlayer</b>           <b>:</b>    <b>@tab</b> <b>X</b> <b>@tab</b>   <b>@tab</b> <b>X</b>
       <b>WebVTT</b>            <b>:</b>  <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b>
       <b>XSUB</b>              <b>:</b>    <b>@tab</b>   <b>@tab</b> <b>X</b> <b>@tab</b> <b>X</b>

       "X" means that the feature is supported.

       "E" means that support is provided through an external library.

   <b>Network</b> <b>Protocols</b>
       <b>Name</b>          <b>:</b>  <b>Support</b>
       <b>AMQP</b>          <b>:</b>  <b>E</b>
       <b>file</b>          <b>:</b>  <b>X</b>
       <b>FTP</b>           <b>:</b>  <b>X</b>
       <b>Gopher</b>        <b>:</b>  <b>X</b>
       <b>Gophers</b>       <b>:</b>  <b>X</b>
       <b>HLS</b>           <b>:</b>  <b>X</b>
       <b>HTTP</b>          <b>:</b>  <b>X</b>
       <b>HTTPS</b>         <b>:</b>  <b>X</b>
       <b>Icecast</b>       <b>:</b>  <b>X</b>
       <b>MMSH</b>          <b>:</b>  <b>X</b>
       <b>MMST</b>          <b>:</b>  <b>X</b>
       <b>pipe</b>          <b>:</b>  <b>X</b>
       <b>Pro-MPEG</b> <b>FEC</b>  <b>:</b>  <b>X</b>
       <b>RTMP</b>          <b>:</b>  <b>X</b>
       <b>RTMPE</b>         <b>:</b>  <b>X</b>
       <b>RTMPS</b>         <b>:</b>  <b>X</b>
       <b>RTMPT</b>         <b>:</b>  <b>X</b>
       <b>RTMPTE</b>        <b>:</b>  <b>X</b>
       <b>RTMPTS</b>        <b>:</b>  <b>X</b>
       <b>RTP</b>           <b>:</b>  <b>X</b>
       <b>SAMBA</b>         <b>:</b>  <b>E</b>
       <b>SCTP</b>          <b>:</b>  <b>X</b>
       <b>SFTP</b>          <b>:</b>  <b>E</b>
       <b>TCP</b>           <b>:</b>  <b>X</b>
       <b>TLS</b>           <b>:</b>  <b>X</b>
       <b>UDP</b>           <b>:</b>  <b>X</b>
       <b>ZMQ</b>           <b>:</b>  <b>E</b>

       "X" means that the protocol is supported.

       "E" means that support is provided through an external library.

   <b>Input/Output</b> <b>Devices</b>
       <b>Name</b>               <b>:</b>  <b>Input</b>  <b>@tab</b> <b>Output</b>
       <b>ALSA</b>               <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>
       <b>BKTR</b>               <b>:</b>  <b>X</b>      <b>@tab</b>
       <b>caca</b>               <b>:</b>         <b>@tab</b> <b>X</b>
       <b>DV1394</b>             <b>:</b>  <b>X</b>      <b>@tab</b>
       <b>Lavfi</b> <b>virtual</b> <b>device</b>  <b>:</b>  <b>X</b>   <b>@tab</b>
       <b>Linux</b> <b>framebuffer</b>  <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>
       <b>JACK</b>               <b>:</b>  <b>X</b>      <b>@tab</b>
       <b>LIBCDIO</b>            <b>:</b>  <b>X</b>
       <b>LIBDC1394</b>          <b>:</b>  <b>X</b>      <b>@tab</b>
       <b>OpenAL</b>             <b>:</b>  <b>X</b>
       <b>OpenGL</b>             <b>:</b>         <b>@tab</b> <b>X</b>
       <b>OSS</b>                <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>
       <b>PulseAudio</b>         <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>
       <b>SDL</b>                <b>:</b>         <b>@tab</b> <b>X</b>
       <b>Video4Linux2</b>       <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>
       <b>VfW</b> <b>capture</b>        <b>:</b>  <b>X</b>      <b>@tab</b>
       <b>X11</b> <b>grabbing</b>       <b>:</b>  <b>X</b>      <b>@tab</b>
       <b>Win32</b> <b>grabbing</b>     <b>:</b>  <b>X</b>      <b>@tab</b>

       "X" means that input/output is supported.

   <b>Timecode</b>
       <b>Codec/format</b>       <b>:</b>  <b>Read</b>   <b>@tab</b> <b>Write</b>
       <b>AVI</b>                <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>
       <b>DV</b>                 <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>
       <b>GXF</b>                <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>
       <b>MOV</b>                <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>
       <b>MPEG1/2</b>            <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>
       <b>MXF</b>                <b>:</b>  <b>X</b>      <b>@tab</b> <b>X</b>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/ffmpeg.1.html">ffmpeg</a></b>(1),    <b><a href="../man1/ffplay.1.html">ffplay</a></b>(1),    <b><a href="../man1/ffprobe.1.html">ffprobe</a></b>(1),    <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a></b>(1),    <b><a href="../man1/ffmpeg-scaler.1.html">ffmpeg-scaler</a></b>(1),     <b><a href="../man1/ffmpeg-resampler.1.html">ffmpeg-resampler</a></b>(1),
       <b><a href="../man1/ffmpeg-codecs.1.html">ffmpeg-codecs</a></b>(1), <b><a href="../man1/ffmpeg-bitstream-filters.1.html">ffmpeg-bitstream-filters</a></b>(1), <b><a href="../man1/ffmpeg-formats.1.html">ffmpeg-formats</a></b>(1), <b><a href="../man1/ffmpeg-devices.1.html">ffmpeg-devices</a></b>(1), <b><a href="../man1/ffmpeg-protocols.1.html">ffmpeg-protocols</a></b>(1),
       <b><a href="../man1/ffmpeg-filters.1.html">ffmpeg-filters</a></b>(1)

</pre><h4><b>AUTHORS</b></h4><pre>
       The FFmpeg developers.

       For  details  about  the  authorship, see the Git history of the project (https://git.ffmpeg.org/ffmpeg),
       e.g. by typing the command <b>git</b> <b>log</b> in the FFmpeg source directory, or browsing the online  repository  at
       &lt;<b>https://git.ffmpeg.org/ffmpeg</b>&gt;.

       Maintainers for the specific components are listed in the file <u>MAINTAINERS</u> in the source code tree.

                                                                                                   <u><a href="../man1/FFMPEG-ALL.1.html">FFMPEG-ALL</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>