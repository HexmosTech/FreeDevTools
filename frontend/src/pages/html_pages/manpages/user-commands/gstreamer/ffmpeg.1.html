<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ffmpeg - ffmpeg media converter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/ffmpeg">ffmpeg_7.1.1-1ubuntu1.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ffmpeg - ffmpeg media converter

</pre><h4><b>SYNOPSIS</b></h4><pre>
       ffmpeg [<u>global_options</u>] {[<u>input_file_options</u>] -i <u>input_url</u>} ... {[<u>output_file_options</u>] <u>output_url</u>} ...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>ffmpeg</b> is a universal media converter. It can read a wide variety of inputs - including live
       grabbing/recording devices - filter, and transcode them into a plethora of output formats.

       <b>ffmpeg</b> reads from an arbitrary number of input "files" (which can be regular files, pipes, network
       streams, grabbing devices, etc.), specified by the "-i" option, and writes to an arbitrary number of
       output "files", which are specified by a plain output url. Anything found on the command line which
       cannot be interpreted as an option is considered to be an output url.

       Each input or output url can, in principle, contain any number of streams of different types
       (video/audio/subtitle/attachment/data). The allowed number and/or types of streams may be limited by the
       container format. Selecting which streams from which inputs will go into which output is either done
       automatically or with the "-map" option (see the Stream selection chapter).

       To refer to input files in options, you must use their indices (0-based). E.g.  the first input file is
       0, the second is 1, etc. Similarly, streams within a file are referred to by their indices. E.g. "2:3"
       refers to the fourth stream in the third input file. Also see the Stream specifiers chapter.

       As a general rule, options are applied to the next specified file. Therefore, order is important, and you
       can have the same option on the command line multiple times. Each occurrence is then applied to the next
       input or output file.  Exceptions from this rule are the global options (e.g. verbosity level), which
       should be specified first.

       Do not mix input and output files -- first specify all input files, then all output files. Also do not
       mix options which belong to different files. All options apply ONLY to the next input or output file and
       are reset between files.

       Some simple examples follow.

       •   Convert an input media file to a different format, by re-encoding media streams:

                   ffmpeg -i input.avi output.mp4

       •   Set the video bitrate of the output file to 64 kbit/s:

                   ffmpeg -i input.avi -b:v 64k -bufsize 64k output.mp4

       •   Force the frame rate of the output file to 24 fps:

                   ffmpeg -i input.avi -r 24 output.mp4

       •   Force  the  frame  rate of the input file (valid for raw formats only) to 1 fps and the frame rate of
           the output file to 24 fps:

                   ffmpeg -r 1 -i input.m2v -r 24 output.mp4

       The format option may be needed for raw input files.

</pre><h4><b>DETAILED</b> <b>DESCRIPTION</b></h4><pre>
       The transcoding process in <b>ffmpeg</b> for each output can be described by the following diagram:

                _______              ______________
               |       |            |              |
               | input |  demuxer   | encoded data |   decoder
               | file  | ---------&gt; | packets      | -----+
               |_______|            |______________|      |
                                                          v
                                                      _________
                                                     |         |
                                                     | decoded |
                                                     | frames  |
                                                     |_________|
                ________             ______________       |
               |        |           |              |      |
               | output | &lt;-------- | encoded data | &lt;----+
               | file   |   muxer   | packets      |   encoder
               |________|           |______________|

       <b>ffmpeg</b> calls the libavformat library (containing demuxers) to read input files and get packets containing
       encoded data from them. When there are multiple input files, <b>ffmpeg</b> tries to keep  them  synchronized  by
       tracking lowest timestamp on any active input stream.

       Encoded packets are then passed to the decoder (unless streamcopy is selected for the stream, see further
       for  a  description).  The  decoder  produces  uncompressed frames (raw video/PCM audio/...) which can be
       processed further by filtering (see next section). After filtering, the frames are passed to the encoder,
       which encodes them and outputs encoded packets. Finally, those are passed to the muxer, which writes  the
       encoded packets to the output file.

   <b>Filtering</b>
       Before  encoding,  <b>ffmpeg</b>  can  process  raw  audio  and  video frames using filters from the libavfilter
       library. Several chained filters  form  a  filter  graph.  <b>ffmpeg</b>  distinguishes  between  two  types  of
       filtergraphs: simple and complex.

       <u>Simple</u> <u>filtergraphs</u>

       Simple filtergraphs are those that have exactly one input and output, both of the same type. In the above
       diagram they can be represented by simply inserting an additional step between decoding and encoding:

                _________                        ______________
               |         |                      |              |
               | decoded |                      | encoded data |
               | frames  |\                   _ | packets      |
               |_________| \                  /||______________|
                            \   __________   /
                 simple     _\||          | /  encoder
                 filtergraph   | filtered |/
                               | frames   |
                               |__________|

       Simple filtergraphs are configured with the per-stream <b>-filter</b> option (with <b>-vf</b> and <b>-af</b> aliases for video
       and audio respectively).  A simple filtergraph for video can look for example like this:

                _______        _____________        _______        ________
               |       |      |             |      |       |      |        |
               | input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |
               |_______|      |_____________|      |_______|      |________|

       Note  that  some  filters  change  frame  properties but not frame contents. E.g. the "fps" filter in the
       example above changes number of frames, but does not touch the frame contents.  Another  example  is  the
       "setpts" filter, which only sets timestamps and otherwise passes the frames unchanged.

       <u>Complex</u> <u>filtergraphs</u>

       Complex  filtergraphs  are those which cannot be described as simply a linear processing chain applied to
       one stream. This is the case, for example, when the graph has more than one input and/or output, or  when
       output stream type is different from input. They can be represented with the following diagram:

                _________
               |         |
               | input 0 |\                    __________
               |_________| \                  |          |
                            \   _________    /| output 0 |
                             \ |         |  / |__________|
                _________     \| complex | /
               |         |     |         |/
               | input 1 |----&gt;| filter  |\
               |_________|     |         | \   __________
                              /| graph   |  \ |          |
                             / |         |   \| output 1 |
                _________   /  |_________|    |__________|
               |         | /
               | input 2 |/
               |_________|

       Complex  filtergraphs  are  configured with the <b>-filter_complex</b> option.  Note that this option is global,
       since a complex filtergraph, by its nature, cannot be unambiguously associated with a  single  stream  or
       file.

       The <b>-lavfi</b> option is equivalent to <b>-filter_complex</b>.

       A  trivial  example  of a complex filtergraph is the "overlay" filter, which has two video inputs and one
       video output, containing one video overlaid on top of the other. Its  audio  counterpart  is  the  "amix"
       filter.

   <b>Stream</b> <b>copy</b>
       Stream  copy  is  a mode selected by supplying the "copy" parameter to the <b>-codec</b> option. It makes <b>ffmpeg</b>
       omit the decoding and encoding step for the specified stream, so it does only demuxing and muxing. It  is
       useful  for  changing the container format or modifying container-level metadata. The diagram above will,
       in this case, simplify to this:

                _______              ______________            ________
               |       |            |              |          |        |
               | input |  demuxer   | encoded data |  muxer   | output |
               | file  | ---------&gt; | packets      | -------&gt; | file   |
               |_______|            |______________|          |________|

       Since there is no decoding or encoding, it is very fast and there is no quality loss. However,  it  might
       not  work  in  some  cases  because of many factors. Applying filters is obviously also impossible, since
       filters work on uncompressed data.

   <b>Loopback</b> <b>decoders</b>
       While decoders are normally associated with demuxer streams, it is also  possible  to  create  "loopback"
       decoders  that  decode  the output from some encoder and allow it to be fed back to complex filtergraphs.
       This is done with the "-dec" directive, which takes as a parameter the index of the  output  stream  that
       should  be decoded. Every such directive creates a new loopback decoder, indexed with successive integers
       starting at zero. These indices should then be used to refer to loopback decoders in complex  filtergraph
       link labels, as described in the documentation for <b>-filter_complex</b>.

       Decoding  AVOptions  can  be  passed  to  loopback decoders by placing them before "-dec", analogously to
       input/output options.

       E.g. the following example:

               ffmpeg -i INPUT                                        \
                 -map 0:v:0 -c:v libx264 -crf 45 -f null -            \
                 -threads 3 -dec 0:0                                  \
                 -filter_complex '[0:v][dec:0]hstack[stack]'          \
                 -map '[stack]' -c:v ffv1 OUTPUT

       reads an input video and

       •   (line 2) encodes it with "libx264" at low quality;

       •   (line 3) decodes this encoded stream using 3 threads;

       •   (line 4) places decoded video side by side with the original input video;

       •   (line 5) combined video is then losslessly encoded and written into <u>OUTPUT</u>.

</pre><h4><b>STREAM</b> <b>SELECTION</b></h4><pre>
       <b>ffmpeg</b> provides the "-map" option for manual control of stream selection in each output file.  Users  can
       skip  "-map" and let ffmpeg perform automatic stream selection as described below. The "-vn / -an / -sn /
       -dn" options can be used to skip inclusion of video,  audio,  subtitle  and  data  streams  respectively,
       whether  manually mapped or automatically selected, except for those streams which are outputs of complex
       filtergraphs.

   <b>Description</b>
       The sub-sections that follow describe the various rules that  are  involved  in  stream  selection.   The
       examples that follow next show how these rules are applied in practice.

       While  every effort is made to accurately reflect the behavior of the program, FFmpeg is under continuous
       development and the code may have changed since the time of this writing.

       <u>Automatic</u> <u>stream</u> <u>selection</u>

       In the absence of any map options for a particular output file, ffmpeg  inspects  the  output  format  to
       check  which  type  of  streams  can  be  included  in  it,  viz. video, audio and/or subtitles. For each
       acceptable stream type, ffmpeg will pick one stream, when available, from among all the inputs.

       It will select that stream based upon the following criteria:

       •   for video, it is the stream with the highest resolution,

       •   for audio, it is the stream with the most channels,

       •   for subtitles, it is the first subtitle stream found but  there's  a  caveat.   The  output  format's
           default  subtitle  encoder can be either text-based or image-based, and only a subtitle stream of the
           same type will be chosen.

       In the case where several streams of the same type rate equally, the stream  with  the  lowest  index  is
       chosen.

       Data or attachment streams are not automatically selected and can only be included using "-map".

       <u>Manual</u> <u>stream</u> <u>selection</u>

       When  "-map"  is  used,  only  user-mapped  streams  are  included in that output file, with one possible
       exception for filtergraph outputs described below.

       <u>Complex</u> <u>filtergraphs</u>

       If there are any complex filtergraph output streams with unlabeled pads, they will be added to the  first
       output file. This will lead to a fatal error if the stream type is not supported by the output format. In
       the  absence of the map option, the inclusion of these streams leads to the automatic stream selection of
       their types being skipped. If map options are present, these filtergraph streams are included in addition
       to the mapped streams.

       Complex filtergraph output streams with labeled pads must be mapped once and exactly once.

       <u>Stream</u> <u>handling</u>

       Stream handling is independent of stream selection, with an  exception  for  subtitles  described  below.
       Stream  handling  is  set  via the "-codec" option addressed to streams within a specific <u>output</u> file. In
       particular, codec options are applied by ffmpeg after the  stream  selection  process  and  thus  do  not
       influence  the  latter.  If  no  "-codec"  option  is specified for a stream type, ffmpeg will select the
       default encoder registered by the output file muxer.

       An exception exists for subtitles. If a subtitle encoder is specified  for  an  output  file,  the  first
       subtitle  stream  found  of  any  type,  text or image, will be included. ffmpeg does not validate if the
       specified encoder can convert the selected stream or if the converted stream  is  acceptable  within  the
       output  format.  This  applies  generally  as  well:  when  the user sets an encoder manually, the stream
       selection process cannot check if the encoded stream can be muxed into the output file.   If  it  cannot,
       ffmpeg will abort and <u>all</u> output files will fail to be processed.

   <b>Examples</b>
       The  following  examples  illustrate  the  behavior,  quirks and limitations of ffmpeg's stream selection
       methods.

       They assume the following three input files.

               input file 'A.avi'
                     stream 0: video 640x360
                     stream 1: audio 2 channels

               input file 'B.mp4'
                     stream 0: video 1920x1080
                     stream 1: audio 2 channels
                     stream 2: subtitles (text)
                     stream 3: audio 5.1 channels
                     stream 4: subtitles (text)

               input file 'C.mkv'
                     stream 0: video 1280x720
                     stream 1: audio 2 channels
                     stream 2: subtitles (image)

       Example: automatic stream selection

               ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov

       There are three output files specified, and for the first two, no "-map" options are set, so ffmpeg  will
       select streams for these two files automatically.

       <u>out1.mkv</u>  is  a Matroska container file and accepts video, audio and subtitle streams, so ffmpeg will try
       to select one of each type.For video, it will select  "stream  0"  from  <u>B.mp4</u>,  which  has  the  highest
       resolution  among  all  the input video streams.For audio, it will select "stream 3" from <u>B.mp4</u>, since it
       has the greatest number of channels.For subtitles, it will select "stream 2" from  <u>B.mp4</u>,  which  is  the
       first subtitle stream from among <u>A.avi</u> and <u>B.mp4</u>.

       <u>out2.wav</u> accepts only audio streams, so only "stream 3" from <u>B.mp4</u> is selected.

       For  <u>out3.mov</u>,  since  a  "-map"  option is set, no automatic stream selection will occur. The "-map 1:a"
       option will select all audio streams from the second input <u>B.mp4</u>. No other streams will  be  included  in
       this output file.

       For  the  first  two  outputs,  all  included streams will be transcoded. The encoders chosen will be the
       default ones registered by each output format, which may not  match  the  codec  of  the  selected  input
       streams.

       For  the  third  output, codec option for audio streams has been set to "copy", so no decoding-filtering-
       encoding operations will occur, or <u>can</u> occur.  Packets of selected streams shall  be  conveyed  from  the
       input file and muxed within the output file.

       Example: automatic subtitles selection

               ffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv

       Although  <u>out1.mkv</u>  is  a  Matroska container file which accepts subtitle streams, only a video and audio
       stream shall be selected. The subtitle stream of <u>C.mkv</u> is image-based and the default subtitle encoder of
       the Matroska muxer is text-based, so a transcode operation for the subtitles  is  expected  to  fail  and
       hence the stream isn't selected. However, in <u>out2.mkv</u>, a subtitle encoder is specified in the command and
       so,  the  subtitle  stream  is  selected, in addition to the video stream. The presence of "-an" disables
       audio stream selection for <u>out2.mkv</u>.

       Example: unlabeled filtergraph outputs

               ffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex "overlay" out1.mp4 out2.srt

       A filtergraph is setup here using the "-filter_complex" option and consists of a single video filter. The
       "overlay" filter requires exactly two video inputs, but none are specified, so the  first  two  available
       video  streams  are  used,  those of <u>A.avi</u> and <u>C.mkv</u>. The output pad of the filter has no label and so is
       sent to the first output file <u>out1.mp4</u>. Due to this, automatic selection of the video stream is  skipped,
       which  would  have  selected  the stream in <u>B.mp4</u>. The audio stream with most channels viz. "stream 3" in
       <u>B.mp4</u>, is chosen automatically. No subtitle stream is chosen however, since the MP4 format has no default
       subtitle encoder registered, and the user hasn't specified a subtitle encoder.

       The 2nd output file, <u>out2.srt</u>, only accepts text-based  subtitle  streams.  So,  even  though  the  first
       subtitle  stream  available  belongs to <u>C.mkv</u>, it is image-based and hence skipped.  The selected stream,
       "stream 2" in <u>B.mp4</u>, is the first text-based subtitle stream.

       Example: labeled filtergraph outputs

               ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex "[1:v]hue=s=0[outv];overlay;aresample" \
                      -map '[outv]' -an        out1.mp4 \
                                               out2.mkv \
                      -map '[outv]' -map 1:a:0 out3.mkv

       The above command will fail, as the output pad labelled "[outv]" has been  mapped  twice.   None  of  the
       output files shall be processed.

               ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex "[1:v]hue=s=0[outv];overlay;aresample" \
                      -an        out1.mp4 \
                                 out2.mkv \
                      -map 1:a:0 out3.mkv

       This  command above will also fail as the hue filter output has a label, "[outv]", and hasn't been mapped
       anywhere.

       The command should be modified as follows,

               ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex "[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample" \
                       -map '[outv1]' -an        out1.mp4 \
                                                 out2.mkv \
                       -map '[outv2]' -map 1:a:0 out3.mkv

       The video stream from <u>B.mp4</u> is sent to the hue filter, whose  output  is  cloned  once  using  the  split
       filter, and both outputs labelled. Then a copy each is mapped to the first and third output files.

       The  overlay  filter,  requiring two video inputs, uses the first two unused video streams. Those are the
       streams from <u>A.avi</u> and <u>C.mkv</u>. The overlay output isn't labelled, so it is sent to the first  output  file
       <u>out1.mp4</u>, regardless of the presence of the "-map" option.

       The  aresample  filter  is sent the first unused audio stream, that of <u>A.avi</u>. Since this filter output is
       also unlabelled, it too is mapped to the first  output  file.  The  presence  of  "-an"  only  suppresses
       automatic  or  manual  stream  selection of audio streams, not outputs sent from filtergraphs. Both these
       mapped streams shall be ordered before the mapped stream in <u>out1.mp4</u>.

       The video, audio and subtitle streams mapped to "out2.mkv" are entirely determined  by  automatic  stream
       selection.

       <u>out3.mkv</u> consists of the cloned video output from the hue filter and the first audio stream from <u>B.mp4</u>.

</pre><h4><b>OPTIONS</b></h4><pre>
       All  the  numerical  options, if not specified otherwise, accept a string representing a number as input,
       which may be followed by one of the SI unit prefixes, for example: 'K', 'M', or 'G'.

       If 'i' is appended to the SI unit prefix, the complete prefix will be interpreted as a  unit  prefix  for
       binary  multiples,  which  are based on powers of 1024 instead of powers of 1000. Appending 'B' to the SI
       unit prefix multiplies the value by 8. This allows using, for example: 'KB', 'MiB', 'G' and 'B' as number
       suffixes.

       Options which do not take arguments are boolean options, and set the corresponding value  to  true.  They
       can  be  set  to  false  by  prefixing the option name with "no". For example using "-nofoo" will set the
       boolean option with name "foo" to false.

       Options that take arguments support a special syntax where the argument given  on  the  command  line  is
       interpreted  as  a  path to the file from which the actual argument value is loaded. To use this feature,
       add a forward slash '/' immediately before the option name (after the leading dash). E.g.

               ffmpeg -i INPUT -/filter:v filter.script OUTPUT

       will load a filtergraph description from the file named <u>filter.script</u>.

   <b>Stream</b> <b>specifiers</b>
       Some options are applied per-stream, e.g. bitrate or codec.  Stream  specifiers  are  used  to  precisely
       specify which stream(s) a given option belongs to.

       A  stream  specifier  is a string generally appended to the option name and separated from it by a colon.
       E.g. "-codec:a:1 ac3" contains the "a:1"  stream  specifier,  which  matches  the  second  audio  stream.
       Therefore, it would select the ac3 codec for the second audio stream.

       A  stream  specifier  can  match  several streams, so that the option is applied to all of them. E.g. the
       stream specifier in "-b:a 128k" matches all audio streams.

       An empty stream specifier matches all streams. For example, "-codec copy" or "-codec:  copy"  would  copy
       all the streams without reencoding.

       Possible forms of stream specifiers are:

       <u>stream_index</u>
           Matches  the  stream  with  this index. E.g. "-threads:1 4" would set the thread count for the second
           stream to 4. If <u>stream_index</u> is used as an additional stream specifier (see below), then  it  selects
           stream  number  <u>stream_index</u> from the matching streams. Stream numbering is based on the order of the
           streams as detected by libavformat except when a  stream  group  specifier  or  program  ID  is  also
           specified. In this case it is based on the ordering of the streams in the group or program.

       <u>stream_type</u><b>[:</b><u>additional_stream_specifier</u><b>]</b>
           <u>stream_type</u> is one of following: 'v' or 'V' for video, 'a' for audio, 's' for subtitle, 'd' for data,
           and  't' for attachments. 'v' matches all video streams, 'V' only matches video streams which are not
           attached pictures, video thumbnails or cover arts. If <u>additional_stream_specifier</u> is  used,  then  it
           matches  streams  which  both have this type and match the <u>additional_stream_specifier</u>. Otherwise, it
           matches all streams of the specified type.

       <b>g:</b><u>group_specifier</u><b>[:</b><u>additional_stream_specifier</u><b>]</b>
           Matches   streams   which   are   in   the   group   with   the   specifier   <u>group_specifier</u>.     if
           <u>additional_stream_specifier</u>  is  used,  then  it matches streams which both are part of the group and
           match the <u>additional_stream_specifier</u>.  <u>group_specifier</u> may be one of the following:

           <u>group_index</u>
               Match the stream with this group index.

           <b>#</b><u>group_id</u> <b>or</b> <b>i:</b><u>group_id</u>
               Match the stream with this group id.

       <b>p:</b><u>program_id</u><b>[:</b><u>additional_stream_specifier</u><b>]</b>
           Matches streams which are in the program with the id <u>program_id</u>.  If  <u>additional_stream_specifier</u>  is
           used,   then   it   matches   streams   which   both   are   part   of  the  program  and  match  the
           <u>additional_stream_specifier</u>.

       <b>#</b><u>stream_id</u> <b>or</b> <b>i:</b><u>stream_id</u>
           Match the stream by stream id (e.g. PID in MPEG-TS container).

       <b>m:</b><u>key</u><b>[:</b><u>value</u><b>]</b>
           Matches streams with the metadata tag <u>key</u> having the specified value. If <u>value</u> is not given,  matches
           streams  that  contain the given tag with any value. The colon character ':' in <u>key</u> or <u>value</u> needs to
           be backslash-escaped.

       <b>disp:</b><u>dispositions</u><b>[:</b><u>additional_stream_specifier</u><b>]</b>
           Matches streams with the given disposition(s). <u>dispositions</u> is a list of one or more dispositions (as
           printed by the <b>-dispositions</b> option) joined with '+'.

       <b>u</b>   Matches streams with usable configuration, the codec must be defined and  the  essential  information
           such as video dimension or audio sample rate must be present.

           Note that in <b>ffmpeg</b>, matching by metadata will only work properly for input files.

   <b>Generic</b> <b>options</b>
       These options are shared amongst the ff* tools.

       <b>-L</b>  Show license.

       <b>-h,</b> <b>-?,</b> <b>-help,</b> <b>--help</b> <b>[</b><u>arg</u><b>]</b>
           Show help. An optional parameter may be specified to print help about a specific item. If no argument
           is specified, only basic (non advanced) tool options are shown.

           Possible values of <u>arg</u> are:

           <b>long</b>
               Print advanced tool options in addition to the basic tool options.

           <b>full</b>
               Print  complete  list  of  options,  including shared and private options for encoders, decoders,
               demuxers, muxers, filters, etc.

           <b>decoder=</b><u>decoder_name</u>
               Print detailed information about the decoder named <u>decoder_name</u>. Use the <b>-decoders</b> option to  get
               a list of all decoders.

           <b>encoder=</b><u>encoder_name</u>
               Print  detailed information about the encoder named <u>encoder_name</u>. Use the <b>-encoders</b> option to get
               a list of all encoders.

           <b>demuxer=</b><u>demuxer_name</u>
               Print detailed information about the demuxer named <u>demuxer_name</u>. Use the <b>-formats</b> option to get a
               list of all demuxers and muxers.

           <b>muxer=</b><u>muxer_name</u>
               Print detailed information about the muxer named <u>muxer_name</u>. Use the <b>-formats</b>  option  to  get  a
               list of all muxers and demuxers.

           <b>filter=</b><u>filter_name</u>
               Print  detailed  information about the filter named <u>filter_name</u>. Use the <b>-filters</b> option to get a
               list of all filters.

           <b>bsf=</b><u>bitstream_filter_name</u>
               Print detailed information about the bitstream filter named <u>bitstream_filter_name</u>.  Use the <b>-bsfs</b>
               option to get a list of all bitstream filters.

           <b>protocol=</b><u>protocol_name</u>
               Print detailed information about the protocol named <u>protocol_name</u>.  Use the <b>-protocols</b> option  to
               get a list of all protocols.

       <b>-version</b>
           Show version.

       <b>-buildconf</b>
           Show the build configuration, one option per line.

       <b>-formats</b>
           Show available formats (including devices).

       <b>-demuxers</b>
           Show available demuxers.

       <b>-muxers</b>
           Show available muxers.

       <b>-devices</b>
           Show available devices.

       <b>-codecs</b>
           Show all codecs known to libavcodec.

           Note  that  the  term  'codec'  is  used throughout this documentation as a shortcut for what is more
           correctly called a media bitstream format.

       <b>-decoders</b>
           Show available decoders.

       <b>-encoders</b>
           Show all available encoders.

       <b>-bsfs</b>
           Show available bitstream filters.

       <b>-protocols</b>
           Show available protocols.

       <b>-filters</b>
           Show available libavfilter filters.

       <b>-pix_fmts</b>
           Show available pixel formats.

       <b>-sample_fmts</b>
           Show available sample formats.

       <b>-layouts</b>
           Show channel names and standard channel layouts.

       <b>-dispositions</b>
           Show stream dispositions.

       <b>-colors</b>
           Show recognized color names.

       <b>-sources</b> <u>device</u><b>[,</b><u>opt1</u><b>=</b><u>val1</u><b>[,</b><u>opt2</u><b>=</b><u>val2</u><b>]...]</b>
           Show autodetected sources of the input device.  Some  devices  may  provide  system-dependent  source
           names that cannot be autodetected.  The returned list cannot be assumed to be always complete.

                   ffmpeg -sources pulse,server=192.168.0.4

       <b>-sinks</b> <u>device</u><b>[,</b><u>opt1</u><b>=</b><u>val1</u><b>[,</b><u>opt2</u><b>=</b><u>val2</u><b>]...]</b>
           Show  autodetected  sinks of the output device.  Some devices may provide system-dependent sink names
           that cannot be autodetected.  The returned list cannot be assumed to be always complete.

                   ffmpeg -sinks pulse,server=192.168.0.4

       <b>-loglevel</b> <b>[</b><u>flags</u><b>+]</b><u>loglevel</u> <b>|</b> <b>-v</b> <b>[</b><u>flags</u><b>+]</b><u>loglevel</u>
           Set logging level and flags used by the library.

           The optional <u>flags</u> prefix can consist of the following values:

           <b>repeat</b>
               Indicates that repeated log output should not be compressed to  the  first  line  and  the  "Last
               message repeated n times" line will be omitted.

           <b>level</b>
               Indicates that log output should add a "[level]" prefix to each message line. This can be used as
               an alternative to log coloring, e.g. when dumping the log to file.

           Flags  can also be used alone by adding a '+'/'-' prefix to set/reset a single flag without affecting
           other <u>flags</u> or changing <u>loglevel</u>. When setting both <u>flags</u> and <u>loglevel</u>, a '+' separator  is  expected
           between the last <u>flags</u> value and before <u>loglevel</u>.

           <u>loglevel</u> is a string or a number containing one of the following values:

           <b>quiet,</b> <b>-8</b>
               Show nothing at all; be silent.

           <b>panic,</b> <b>0</b>
               Only  show fatal errors which could lead the process to crash, such as an assertion failure. This
               is not currently used for anything.

           <b>fatal,</b> <b>8</b>
               Only show fatal errors. These are errors after which the process absolutely cannot continue.

           <b>error,</b> <b>16</b>
               Show all errors, including ones which can be recovered from.

           <b>warning,</b> <b>24</b>
               Show all warnings and errors. Any message related to possibly incorrect or unexpected events will
               be shown.

           <b>info,</b> <b>32</b>
               Show informative messages during processing. This is in addition to warnings and errors. This  is
               the default value.

           <b>verbose,</b> <b>40</b>
               Same as "info", except more verbose.

           <b>debug,</b> <b>48</b>
               Show everything, including debugging information.

           <b>trace,</b> <b>56</b>

           For example to enable repeated log output, add the "level" prefix, and set <u>loglevel</u> to "verbose":

                   ffmpeg -loglevel repeat+level+verbose -i input output

           Another  example  that  enables repeated log output without affecting current state of "level" prefix
           flag or <u>loglevel</u>:

                   ffmpeg [...] -loglevel +repeat

           By default the program logs to stderr. If coloring is supported by the terminal, colors are  used  to
           mark   errors   and  warnings.  Log  coloring  can  be  disabled  setting  the  environment  variable
           <b>AV_LOG_FORCE_NOCOLOR</b>, or can be forced setting the environment variable <b>AV_LOG_FORCE_COLOR</b>.

       <b>-report</b>
           Dump full command line and log output to a file named "<u>program</u>-<u>YYYYMMDD</u>-<u>HHMMSS</u>.log"  in  the  current
           directory.  This file can be useful for bug reports.  It also implies "-loglevel debug".

           Setting  the  environment  variable  <b>FFREPORT</b>  to  any  value  has the same effect. If the value is a
           ':'-separated key=value sequence, these options will affect the report; option values must be escaped
           if they contain special characters or the options delimiter ':' (see  the  ``Quoting  and  escaping''
           section in the ffmpeg-utils manual).

           The following options are recognized:

           <b>file</b>
               set  the  file  name  to  use  for  the  report; %p is expanded to the name of the program, %t is
               expanded to a timestamp, "%%" is expanded to a plain "%"

           <b>level</b>
               set the log verbosity level using a numerical value (see "-loglevel").

           For example, to output a report to a file named <u>ffreport.log</u> using a log level of 32 (alias  for  log
           level "info"):

                   FFREPORT=file=ffreport.log:level=32 ffmpeg -i input output

           Errors in parsing the environment variable are not fatal, and will not appear in the report.

       <b>-hide_banner</b>
           Suppress printing banner.

           All  FFmpeg  tools  will  normally  show a copyright notice, build options and library versions. This
           option can be used to suppress printing this information.

       <b>-cpuflags</b> <b>flags</b> <b>(</b><u>global</u><b>)</b>
           Allows setting and clearing cpu flags. This option is intended for testing. Do not use it unless  you
           know what you're doing.

                   ffmpeg -cpuflags -sse+mmx ...
                   ffmpeg -cpuflags mmx ...
                   ffmpeg -cpuflags 0 ...

           Possible flags for this option are:

           <b>x86</b>
               <b>mmx</b>
               <b>mmxext</b>
               <b>sse</b>
               <b>sse2</b>
               <b>sse2slow</b>
               <b>sse3</b>
               <b>sse3slow</b>
               <b>ssse3</b>
               <b>atom</b>
               <b>sse4.1</b>
               <b>sse4.2</b>
               <b>avx</b>
               <b>avx2</b>
               <b>xop</b>
               <b>fma3</b>
               <b>fma4</b>
               <b>3dnow</b>
               <b>3dnowext</b>
               <b>bmi1</b>
               <b>bmi2</b>
               <b>cmov</b>
           <b>ARM</b>
               <b>armv5te</b>
               <b>armv6</b>
               <b>armv6t2</b>
               <b>vfp</b>
               <b>vfpv3</b>
               <b>neon</b>
               <b>setend</b>
           <b>AArch64</b>
               <b>armv8</b>
               <b>vfp</b>
               <b>neon</b>
           <b>PowerPC</b>
               <b>altivec</b>
           <b>Specific</b> <b>Processors</b>
               <b>pentium2</b>
               <b>pentium3</b>
               <b>pentium4</b>
               <b>k6</b>
               <b>k62</b>
               <b>athlon</b>
               <b>athlonxp</b>
               <b>k8</b>
       <b>-cpucount</b> <u>count</u> <b>(</b><u>global</u><b>)</b>
           Override  detection  of CPU count. This option is intended for testing. Do not use it unless you know
           what you're doing.

                   ffmpeg -cpucount 2

       <b>-max_alloc</b> <u>bytes</u>
           Set the maximum size limit for allocating a block on the heap by ffmpeg's family of malloc functions.
           Exercise <b>extreme</b> <b>caution</b> when using this option.  Don't  use  if  you  do  not  understand  the  full
           consequence of doing so.  Default is INT_MAX.

   <b>AVOptions</b>
       These  options are provided directly by the libavformat, libavdevice and libavcodec libraries. To see the
       list of available AVOptions, use the <b>-help</b> option. They are separated into two categories:

       <b>generic</b>
           These options can be set for any container,  codec  or  device.  Generic  options  are  listed  under
           AVFormatContext options for containers/devices and under AVCodecContext options for codecs.

       <b>private</b>
           These  options are specific to the given container, device or codec. Private options are listed under
           their corresponding containers/devices/codecs.

       For example to write an ID3v2.3 header instead of a default ID3v2.4 to an MP3 file, use the <b>id3v2_version</b>
       private option of the MP3 muxer:

               ffmpeg -i input.flac -id3v2_version 3 out.mp3

       All codec AVOptions are per-stream, and thus a stream specifier should be attached to them:

               ffmpeg -i multichannel.mxf -map 0:v:0 -map 0:a:0 -map 0:a:0 -c:a:0 ac3 -b:a:0 640k -ac:a:1 2 -c:a:1 aac -b:2 128k out.mp4

       In the above example, a multichannel audio stream is mapped twice for  output.   The  first  instance  is
       encoded with codec ac3 and bitrate 640k.  The second instance is downmixed to 2 channels and encoded with
       codec aac. A bitrate of 128k is specified for it using absolute index of the output stream.

       Note: the <b>-nooption</b> syntax cannot be used for boolean AVOptions, use <b>-option</b> <b>0</b>/<b>-option</b> <b>1</b>.

       Note: the old undocumented way of specifying per-stream AVOptions by prepending v/a/s to the options name
       is now obsolete and will be removed soon.

   <b>Main</b> <b>options</b>
       <b>-f</b> <u>fmt</u> <b>(</b><u>input/output</u><b>)</b>
           Force  input  or output file format. The format is normally auto detected for input files and guessed
           from the file extension for output files, so this option is not needed in most cases.

       <b>-i</b> <u>url</u> <b>(</b><u>input</u><b>)</b>
           input file url

       <b>-y</b> <b>(</b><u>global</u><b>)</b>
           Overwrite output files without asking.

       <b>-n</b> <b>(</b><u>global</u><b>)</b>
           Do not overwrite output files, and exit immediately if a specified output file already exists.

       <b>-stream_loop</b> <u>number</u> <b>(</b><u>input</u><b>)</b>
           Set number of times input stream shall be looped. Loop 0 means no loop, loop -1 means infinite loop.

       <b>-recast_media</b> <b>(</b><u>global</u><b>)</b>
           Allow forcing a decoder of a different media type than the one detected or designated by the demuxer.
           Useful for decoding media data muxed as data streams.

       <b>-c[:</b><u>stream_specifier</u><b>]</b> <u>codec</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
       <b>-codec[:</b><u>stream_specifier</u><b>]</b> <u>codec</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Select an encoder (when used before an output file) or a decoder (when used before an input file) for
           one or more streams. <u>codec</u> is the name of a decoder/encoder or a special value "copy"  (output  only)
           to indicate that the stream is not to be re-encoded.

           For example

                   ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT

           encodes all video streams with libx264 and copies all audio streams.

           For each stream, the last matching "c" option is applied, so

                   ffmpeg -i INPUT -map 0 -c copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT

           will  copy all the streams except the second video, which will be encoded with libx264, and the 138th
           audio, which will be encoded with libvorbis.

       <b>-t</b> <u>duration</u> <b>(</b><u>input/output</u><b>)</b>
           When used as an input option (before "-i"), limit the <u>duration</u> of data read from the input file.

           When used as an output option (before an output url), stop writing  the  output  after  its  duration
           reaches <u>duration</u>.

           <u>duration</u>  must be a time duration specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>.

           -to and -t are mutually exclusive and -t has priority.

       <b>-to</b> <u>position</u> <b>(</b><u>input/output</u><b>)</b>
           Stop writing the output or reading  the  input  at  <u>position</u>.   <u>position</u>  must  be  a  time  duration
           specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>.

           -to and -t are mutually exclusive and -t has priority.

       <b>-fs</b> <u>limit_size</u> <b>(</b><u>output</u><b>)</b>
           Set  the file size limit, expressed in bytes. No further chunk of bytes is written after the limit is
           exceeded. The size of the output file is slightly more than the requested file size.

       <b>-ss</b> <u>position</u> <b>(</b><u>input/output</u><b>)</b>
           When used as an input option (before "-i"), seeks in this input file to <u>position</u>. Note that  in  most
           formats  it  is  not  possible  to seek exactly, so <b>ffmpeg</b> will seek to the closest seek point before
           <u>position</u>.  When transcoding and <b>-accurate_seek</b> is enabled (the default), this extra  segment  between
           the  seek  point  and  <u>position</u>  will  be  decoded  and  discarded.  When  doing  stream copy or when
           <b>-noaccurate_seek</b> is used, it will be preserved.

           When used as an output option (before an output url), decodes but discards input until the timestamps
           reach <u>position</u>.

           <u>position</u> must be a time duration specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b>  <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>.

       <b>-sseof</b> <u>position</u> <b>(</b><u>input</u><b>)</b>
           Like  the  "-ss" option but relative to the "end of file". That is negative values are earlier in the
           file, 0 is at EOF.

       <b>-isync</b> <u>input_index</u> <b>(</b><u>input</u><b>)</b>
           Assign an input as a sync source.

           This will take the difference between the start times of the target and reference inputs  and  offset
           the  timestamps of the target file by that difference. The source timestamps of the two inputs should
           derive from the same clock source for expected results. If "copyts" is set then "start_at_zero"  must
           also be set. If either of the inputs has no starting timestamp then no sync adjustment is made.

           Acceptable  values  are  those that refer to a valid ffmpeg input index. If the sync reference is the
           target index itself or <u>-1</u>, then no adjustment is made to target timestamps. A sync reference may  not
           itself be synced to any other input.

           Default value is <u>-1</u>.

       <b>-itsoffset</b> <u>offset</u> <b>(</b><u>input</u><b>)</b>
           Set the input time offset.

           <u>offset</u>  must  be  a time duration specification, see <b>the</b> <b>Time</b> <b>duration</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b>
           <b>manual</b>.

           The offset is added to the timestamps of the input files. Specifying a positive offset means that the
           corresponding streams are delayed by the time duration specified in <u>offset</u>.

       <b>-itsscale</b> <u>scale</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Rescale input timestamps. <u>scale</u> should be a floating point number.

       <b>-timestamp</b> <u>date</u> <b>(</b><u>output</u><b>)</b>
           Set the recording timestamp in the container.

           <u>date</u> must be a date specification, see <b>the</b> <b>Date</b> <b>section</b> <b>in</b> <b>the</b> <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a>(1)</b> <b>manual</b>.

       <b>-metadata[:metadata_specifier]</b> <u>key</u><b>=</b><u>value</u> <b>(</b><u>output,per-metadata</u><b>)</b>
           Set a metadata key/value pair.

           An optional <u>metadata_specifier</u> may be given to set metadata on streams,  chapters  or  programs.  See
           "-map_metadata" documentation for details.

           This  option  overrides  metadata set with "-map_metadata". It is also possible to delete metadata by
           using an empty value.

           For example, for setting the title in the output file:

                   ffmpeg -i in.avi -metadata title="my title" out.flv

           To set the language of the first audio stream:

                   ffmpeg -i INPUT -metadata:s:a:0 language=eng OUTPUT

       <b>-disposition[:stream_specifier]</b> <u>value</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Sets the disposition for a stream.

           By default, the disposition is copied from the input stream, unless the  output  stream  this  option
           applies to is fed by a complex filtergraph - in that case the disposition is unset by default.

           <u>value</u> is a sequence of items separated by '+' or '-'. The first item may also be prefixed with '+' or
           '-', in which case this option modifies the default value. Otherwise (the first item is not prefixed)
           this options overrides the default value. A '+' prefix adds the given disposition, '-' removes it. It
           is also possible to clear the disposition by setting it to 0.

           If  no  "-disposition"  options  were specified for an output file, ffmpeg will automatically set the
           'default' disposition on the first stream of each type, when there are multiple streams of this  type
           in the output file and no stream of that type is already marked as default.

           The "-dispositions" option lists the known dispositions.

           For example, to make the second audio stream the default stream:

                   ffmpeg -i in.mkv -c copy -disposition:a:1 default out.mkv

           To  make  the  second  subtitle stream the default stream and remove the default disposition from the
           first subtitle stream:

                   ffmpeg -i in.mkv -c copy -disposition:s:0 0 -disposition:s:1 default out.mkv

           To add an embedded cover/thumbnail:

                   ffmpeg -i in.mp4 -i IMAGE -map 0 -map 1 -c copy -c:v:1 png -disposition:v:1 attached_pic out.mp4

           Not all muxers support embedded thumbnails, and those who do, only support a few formats,  like  JPEG
           or PNG.

       <b>-program</b> <b>[title=</b><u>title</u><b>:][program_num=</b><u>program_num</u><b>:]st=</b><u>stream</u><b>[:st=</b><u>stream</u><b>...]</b> <b>(</b><u>output</u><b>)</b>
           Creates a program with the specified <u>title</u>, <u>program_num</u> and adds the specified <u>stream</u>(s) to it.

       <b>-stream_group</b>
       <b>[map=</b><u>input_file_id</u><b>=</b><u>stream_group</u><b>][type=</b><u>type</u><b>:]st=</b><u>stream</u><b>[:st=</b><u>stream</u><b>][:stg=</b><u>stream_group</u><b>][:id=</b><u>stream_group_id</u><b>...]</b>
       <b>(</b><u>output</u><b>)</b>
           Creates  a  stream  group  of  the  specified <u>type</u> and <u>stream_group_id</u>, or by <u>map</u>ping an input group,
           adding the specified <u>stream</u>(s) and/or previously defined <u>stream_group</u>(s) to it.

           <u>type</u> can be one of the following:

           <b>iamf_audio_element</b>
               Groups <u>stream</u>s that belong to the same IAMF Audio Element

               For this group <u>type</u>, the following options are available

               <b>audio_element_type</b>
                   The Audio Element type. The following values are supported:

                   <b>channel</b>
                       Scalable channel audio representation

                   <b>scene</b>
                       Ambisonics representation

               <b>demixing</b>
                   Demixing information used to reconstruct  a  scalable  channel  audio  representation.   This
                   option must be separated from the rest with a ',', and takes the following key=value options

                   <b>parameter_id</b>
                       An identifier parameters blocks in frames may refer to

                   <b>dmixp_mode</b>
                       A pre-defined combination of demixing parameters

               <b>recon_gain</b>
                   Recon  gain  information  used  to reconstruct a scalable channel audio representation.  This
                   option must be separated from the rest with a ',', and takes the following key=value options

                   <b>parameter_id</b>
                       An identifier parameters blocks in frames may refer to

               <b>layer</b>
                   A layer defining a Channel Layout in the Audio Element.  This option must be  separated  from
                   the  rest  with a ','. Several ',' separated entries can be defined, and at least one must be
                   set.

                   It takes the following ":"-separated key=value options

                   <b>ch_layout</b>
                       The layer's channel layout

                   <b>flags</b>
                       The following flags are available:

                       <b>recon_gain</b>
                           Wether to signal if recon_gain is present as  metadata  in  parameter  blocks  within
                           frames

                   <b>output_gain</b>
                   <b>output_gain_flags</b>
                       Which channels output_gain applies to. The following flags are available:

                       <b>FL</b>
                       <b>FR</b>
                       <b>BL</b>
                       <b>BR</b>
                       <b>TFL</b>
                       <b>TFR</b>
                   <b>ambisonics_mode</b>
                       The ambisonics mode. This has no effect if audio_element_type is set to channel.

                       The following values are supported:

                       <b>mono</b>
                           Each ambisonics channel is coded as an individual mono stream in the group

               <b>default_w</b>
                   Default weight value

           <b>iamf_mix_presentation</b>
               Groups <u>stream</u>s that belong to all IAMF Audio Element the same IAMF Mix Presentation references

               For this group <u>type</u>, the following options are available

               <b>submix</b>
                   A  sub-mix  within  the Mix Presentation.  This option must be separated from the rest with a
                   ','. Several ',' separated entries can be defined, and at least one must be set.

                   It takes the following ":"-separated key=value options

                   <b>parameter_id</b>
                       An identifier parameters blocks in frames may refer to,  for  post-processing  the  mixed
                       audio signal to generate the audio signal for playback

                   <b>parameter_rate</b>
                       The  sample  rate  duration  fields  in  parameters  blocks  in frames that refer to this
                       <u>parameter_id</u> are expressed as

                   <b>default_mix_gain</b>
                       Default mix gain value to apply when there are  no  parameter  blocks  sharing  the  same
                       <u>parameter_id</u> for a given frame

                   <b>element</b>
                       References  an  Audio  Element used in this Mix Presentation to generate the final output
                       audio signal for playback.  This option must be separated  from  the  rest  with  a  '|'.
                       Several '|' separated entries can be defined, and at least one must be set.

                       It takes the following ":"-separated key=value options:

                       <b>stg</b> The <u>stream_group_id</u> for an Audio Element which this sub-mix refers to

                       <b>parameter_id</b>
                           An  identifier  parameters blocks in frames may refer to, for applying any processing
                           to the referenced and rendered Audio Element before being summed with other processed
                           Audio Elements

                       <b>parameter_rate</b>
                           The sample rate duration fields in parameters blocks in frames  that  refer  to  this
                           <u>parameter_id</u> are expressed as

                       <b>default_mix_gain</b>
                           Default  mix  gain value to apply when there are no parameter blocks sharing the same
                           <u>parameter_id</u> for a given frame

                       <b>annotations</b>
                           A key=value string describing the sub-mix element where "key" is a string  conforming
                           to  BCP-47 that specifies the language for the "value" string. "key" must be the same
                           as the one in the mix's <u>annotations</u>

                       <b>headphones_rendering_mode</b>
                           Indicates whether the  input  channel-based  Audio  Element  is  rendered  to  stereo
                           loudspeakers  or spatialized with a binaural renderer when played back on headphones.
                           This has no effect if the referenced Audio Element's  <u>audio_element_type</u>  is  set  to
                           channel.

                           The following values are supported:

                           <b>stereo</b>
                           <b>binaural</b>
                   <b>layout</b>
                       Specifies  the  layouts  for this sub-mix on which the loudness information was measured.
                       This option must be separated from the rest with a '|'. Several '|' separated entries can
                       be defined, and at least one must be set.

                       It takes the following ":"-separated key=value options:

                       <b>layout_type</b>
                           <b>loudspeakers</b>
                               The layout follows the loudspeaker sound system convention of ITU-2051-3.

                           <b>binaural</b>
                               The layout is binaural.

                       <b>sound_system</b>
                           Channel layout matching one of Sound Systems A to J of  ITU-2051-3,  plus  7.1.2  and
                           3.1.2 This has no effect if <u>layout_type</u> is set to binaural.

                       <b>integrated_loudness</b>
                           The program integrated loudness information, as defined in ITU-1770-4.

                       <b>digital_peak</b>
                           The digital (sampled) peak value of the audio signal, as defined in ITU-1770-4.

                       <b>true_peak</b>
                           The true peak of the audio signal, as defined in ITU-1770-4.

                       <b>dialog_anchored_loudness</b>
                           The Dialogue loudness information, as defined in ITU-1770-4.

                       <b>album_anchored_loudness</b>
                           The Album loudness information, as defined in ITU-1770-4.

               <b>annotations</b>
                   A  key=value  string  string  describing the mix where "key" is a string conforming to BCP-47
                   that specifies the language for the "value" string. "key" must be the same as the ones in all
                   sub-mix element's <u>annotations</u>s

           E.g. to create an scalable 5.1 IAMF file from several WAV input files

                   ffmpeg -i front.wav -i back.wav -i center.wav -i lfe.wav
                   -map 0:0 -map 1:0 -map 2:0 -map 3:0 -c:a opus
                   -stream_group type=iamf_audio_element:id=1:st=0:st=1:st=2:st=3,
                   demixing=parameter_id=998,
                   recon_gain=parameter_id=101,
                   layer=ch_layout=stereo,
                   layer=ch_layout=5.1,
                   -stream_group type=iamf_mix_presentation:id=2:stg=0:annotations=en-us=Mix_Presentation,
                   submix=parameter_id=100:parameter_rate=48000|element=stg=0:parameter_id=100:annotations=en-us=Scalable_Submix|layout=sound_system=stereo|layout=sound_system=5.1
                   -streamid 0:0 -streamid 1:1 -streamid 2:2 -streamid 3:3 output.iamf

           To copy the two stream groups (Audio Element and Mix Presentation) from an input IAMF file with  four
           streams into an mp4 output

                   ffmpeg -i input.iamf -c:a copy -stream_group map=0=0:st=0:st=1:st=2:st=3 -stream_group map=0=1:stg=0
                   -streamid 0:0 -streamid 1:1 -streamid 2:2 -streamid 3:3 output.mp4

       <b>-target</b> <u>type</u> <b>(</b><u>output</u><b>)</b>
           Specify  target  file  type  ("vcd",  "svcd", "dvd", "dv", "dv50"). <u>type</u> may be prefixed with "pal-",
           "ntsc-" or "film-" to use the corresponding standard. All the format options (bitrate, codecs, buffer
           sizes) are then set automatically. You can just type:

                   ffmpeg -i myfile.avi -target vcd /tmp/vcd.mpg

           Nevertheless you can specify additional options as long as you know they do  not  conflict  with  the
           standard, as in:

                   ffmpeg -i myfile.avi -target vcd -bf 2 /tmp/vcd.mpg

           The parameters set for each target are as follows.

           <b>VCD</b>

                   &lt;pal&gt;:
                   -f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324
                   -s 352x288 -r 25
                   -codec:v mpeg1video -g 15 -b:v 1150k -maxrate:v 1150k -minrate:v 1150k -bufsize:v 327680
                   -ar 44100 -ac 2
                   -codec:a mp2 -b:a 224k

                   &lt;ntsc&gt;:
                   -f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324
                   -s 352x240 -r 30000/1001
                   -codec:v mpeg1video -g 18 -b:v 1150k -maxrate:v 1150k -minrate:v 1150k -bufsize:v 327680
                   -ar 44100 -ac 2
                   -codec:a mp2 -b:a 224k

                   &lt;film&gt;:
                   -f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324
                   -s 352x240 -r 24000/1001
                   -codec:v mpeg1video -g 18 -b:v 1150k -maxrate:v 1150k -minrate:v 1150k -bufsize:v 327680
                   -ar 44100 -ac 2
                   -codec:a mp2 -b:a 224k

           <b>SVCD</b>

                   &lt;pal&gt;:
                   -f svcd -packetsize 2324
                   -s 480x576 -pix_fmt yuv420p -r 25
                   -codec:v mpeg2video -g 15 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1
                   -ar 44100
                   -codec:a mp2 -b:a 224k

                   &lt;ntsc&gt;:
                   -f svcd -packetsize 2324
                   -s 480x480 -pix_fmt yuv420p -r 30000/1001
                   -codec:v mpeg2video -g 18 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1
                   -ar 44100
                   -codec:a mp2 -b:a 224k

                   &lt;film&gt;:
                   -f svcd -packetsize 2324
                   -s 480x480 -pix_fmt yuv420p -r 24000/1001
                   -codec:v mpeg2video -g 18 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1
                   -ar 44100
                   -codec:a mp2 -b:a 224k

           <b>DVD</b>

                   &lt;pal&gt;:
                   -f dvd -muxrate 10080k -packetsize 2048
                   -s 720x576 -pix_fmt yuv420p -r 25
                   -codec:v mpeg2video -g 15 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008
                   -ar 48000
                   -codec:a ac3 -b:a 448k

                   &lt;ntsc&gt;:
                   -f dvd -muxrate 10080k -packetsize 2048
                   -s 720x480 -pix_fmt yuv420p -r 30000/1001
                   -codec:v mpeg2video -g 18 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008
                   -ar 48000
                   -codec:a ac3 -b:a 448k

                   &lt;film&gt;:
                   -f dvd -muxrate 10080k -packetsize 2048
                   -s 720x480 -pix_fmt yuv420p -r 24000/1001
                   -codec:v mpeg2video -g 18 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008
                   -ar 48000
                   -codec:a ac3 -b:a 448k

           <b>DV</b>

                   &lt;pal&gt;:
                   -f dv
                   -s 720x576 -pix_fmt yuv420p -r 25
                   -ar 48000 -ac 2

                   &lt;ntsc&gt;:
                   -f dv
                   -s 720x480 -pix_fmt yuv411p -r 30000/1001
                   -ar 48000 -ac 2

                   &lt;film&gt;:
                   -f dv
                   -s 720x480 -pix_fmt yuv411p -r 24000/1001
                   -ar 48000 -ac 2

           The  "dv50"  target is identical to the "dv" target except that the pixel format set is "yuv422p" for
           all three standards.

           Any user-set value for a parameter above will override the target preset value.  In  that  case,  the
           output may not comply with the target standard.

       <b>-dn</b> <b>(</b><u>input/output</u><b>)</b>
           As  an  input  option,  blocks  all data streams of a file from being filtered or being automatically
           selected or mapped for any output. See "-discard" option to disable streams individually.

           As an output option, disables data recording i.e. automatic selection or mapping of any data  stream.
           For full manual control see the "-map" option.

       <b>-dframes</b> <u>number</u> <b>(</b><u>output</u><b>)</b>
           Set  the number of data frames to output. This is an obsolete alias for "-frames:d", which you should
           use instead.

       <b>-frames[:</b><u>stream_specifier</u><b>]</b> <u>framecount</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Stop writing to the stream after <u>framecount</u> frames.

       <b>-q[:</b><u>stream_specifier</u><b>]</b> <u>q</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-qscale[:</b><u>stream_specifier</u><b>]</b> <u>q</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Use fixed quality scale (VBR). The meaning of <u>q</u>/<u>qscale</u> is codec-dependent.  If <u>qscale</u> is used without
           a <u>stream_specifier</u> then it applies only to the video stream, this is to maintain  compatibility  with
           previous behavior and as specifying the same codec specific value to 2 different codecs that is audio
           and video generally is not what is intended when no stream_specifier is used.

       <b>-filter[:</b><u>stream_specifier</u><b>]</b> <u>filtergraph</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Create the filtergraph specified by <u>filtergraph</u> and use it to filter the stream.

           <u>filtergraph</u>  is a description of the filtergraph to apply to the stream, and must have a single input
           and a single output of the same type of the stream. In the filtergraph, the input  is  associated  to
           the label "in", and the output to the label "out". See the ffmpeg-filters manual for more information
           about the filtergraph syntax.

           See  the  <b>-filter_complex</b>  <b>option</b>  if  you  want  to  create filtergraphs with multiple inputs and/or
           outputs.

       <b>-reinit_filter[:</b><u>stream_specifier</u><b>]</b> <u>integer</u> <b>(</b><u>input,per-stream</u><b>)</b>
           This boolean option determines if the filtergraph(s) to which this stream is fed  gets  reinitialized
           when  input  frame  parameters change mid-stream. This option is enabled by default as most video and
           all audio filters cannot handle deviation in input frame properties.  Upon reinitialization, existing
           filter state is lost, like e.g. the frame count "n" reference available in some filters.  Any  frames
           buffered   at   time   of  reinitialization  are  lost.   The  properties  where  a  change  triggers
           reinitialization are, for video, frame resolution or pixel format; for audio, sample  format,  sample
           rate, channel count or channel layout.

       <b>-filter_threads</b> <u>nb_threads</u> <b>(</b><u>global</u><b>)</b>
           Defines  how  many threads are used to process a filter pipeline. Each pipeline will produce a thread
           pool with this many threads available  for  parallel  processing.   The  default  is  the  number  of
           available CPUs.

       <b>-pre[:</b><u>stream_specifier</u><b>]</b> <u>preset_name</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Specify the preset for matching stream(s).

       <b>-stats</b> <b>(</b><u>global</u><b>)</b>
           Print encoding progress/statistics. It is on by default, to explicitly disable it you need to specify
           "-nostats".

       <b>-stats_period</b> <u>time</u> <b>(</b><u>global</u><b>)</b>
           Set period at which encoding progress/statistics are updated. Default is 0.5 seconds.

       <b>-progress</b> <u>url</u> <b>(</b><u>global</u><b>)</b>
           Send program-friendly progress information to <u>url</u>.

           Progress  information  is  written periodically and at the end of the encoding process. It is made of
           "<u>key</u>=<u>value</u>" lines. <u>key</u> consists of only alphanumeric characters.  The  last  key  of  a  sequence  of
           progress information is always "progress".

           The update period is set using "-stats_period".

       <b>-stdin</b>
           Enable  interaction  on  standard  input. On by default unless standard input is used as an input. To
           explicitly disable interaction you need to specify "-nostdin".

           Disabling interaction on standard input is useful, for  example,  if  ffmpeg  is  in  the  background
           process  group. Roughly the same result can be achieved with "ffmpeg ... &lt; /dev/null" but it requires
           a shell.

       <b>-debug_ts</b> <b>(</b><u>global</u><b>)</b>
           Print timestamp/latency information. It is off by default. This option is mostly useful  for  testing
           and  debugging  purposes,  and the output format may change from one version to another, so it should
           not be employed by portable scripts.

           See also the option "-fdebug ts".

       <b>-attach</b> <u>filename</u> <b>(</b><u>output</u><b>)</b>
           Add an attachment to the output file. This is supported by a few formats like Matroska for e.g. fonts
           used in rendering subtitles. Attachments are implemented as a specific type of stream, so this option
           will add a new stream to the file. It is then possible to use per-stream options on  this  stream  in
           the  usual  way.  Attachment  streams  created  with  this option will be created after all the other
           streams (i.e. those created with "-map" or automatic mappings).

           Note that for Matroska you also have to set the mimetype metadata tag:

                   ffmpeg -i INPUT -attach DejaVuSans.ttf -metadata:s:2 mimetype=application/x-truetype-font out.mkv

           (assuming that the attachment stream will be third in the output file).

       <b>-dump_attachment[:</b><u>stream_specifier</u><b>]</b> <u>filename</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Extract the matching attachment stream into a file named <u>filename</u>. If <u>filename</u>  is  empty,  then  the
           value of the "filename" metadata tag will be used.

           E.g. to extract the first attachment to a file named 'out.ttf':

                   ffmpeg -dump_attachment:t:0 out.ttf -i INPUT

           To extract all attachments to files determined by the "filename" tag:

                   ffmpeg -dump_attachment:t "" -i INPUT

           Technical note -- attachments are implemented as codec extradata, so this option can actually be used
           to extract extradata from any stream, not just attachments.

   <b>Video</b> <b>Options</b>
       <b>-vframes</b> <u>number</u> <b>(</b><u>output</u><b>)</b>
           Set the number of video frames to output. This is an obsolete alias for "-frames:v", which you should
           use instead.

       <b>-r[:</b><u>stream_specifier</u><b>]</b> <u>fps</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set frame rate (Hz value, fraction or abbreviation).

           As an input option, ignore any timestamps stored in the file and instead generate timestamps assuming
           constant  frame  rate <u>fps</u>.  This is not the same as the <b>-framerate</b> option used for some input formats
           like image2 or v4l2 (it used to be the same in older versions of FFmpeg).  If in doubt use <b>-framerate</b>
           instead of the input option <b>-r</b>.

           As an output option:

           <b>video</b> <b>encoding</b>
               Duplicate or drop frames right before encoding them to achieve constant output frame rate <u>fps</u>.

           <b>video</b> <b>streamcopy</b>
               Indicate to the muxer that <u>fps</u> is the stream frame rate. No data is dropped or duplicated in this
               case. This may produce invalid files if <u>fps</u> does not  match  the  actual  stream  frame  rate  as
               determined by packet timestamps.  See also the "setts" bitstream filter.

       <b>-fpsmax[:</b><u>stream_specifier</u><b>]</b> <u>fps</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set maximum frame rate (Hz value, fraction or abbreviation).

           Clamps  output frame rate when output framerate is auto-set and is higher than this value.  Useful in
           batch processing or when input framerate is wrongly detected as very high.  It cannot be set together
           with "-r". It is ignored during streamcopy.

       <b>-s[:</b><u>stream_specifier</u><b>]</b> <u>size</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set frame size.

           As an input option, this is a shortcut for the <b>video_size</b> private option, recognized by some demuxers
           for which the frame size is either not stored in the file or is configurable --  e.g.  raw  video  or
           video grabbers.

           As  an  output  option,  this  inserts  the  "scale"  video  filter  to  the <u>end</u> of the corresponding
           filtergraph. Please use the "scale" filter directly to insert it  at  the  beginning  or  some  other
           place.

           The format is <b>wxh</b> (default - same as source).

       <b>-aspect[:</b><u>stream_specifier</u><b>]</b> <u>aspect</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set the video display aspect ratio specified by <u>aspect</u>.

           <u>aspect</u>  can be a floating point number string, or a string of the form <u>num</u>:<u>den</u>, where <u>num</u> and <u>den</u> are
           the numerator and denominator of the aspect ratio. For example "4:3", "16:9", "1.3333", and  "1.7777"
           are valid argument values.

           If  used  together  with <b>-vcodec</b> <b>copy</b>, it will affect the aspect ratio stored at container level, but
           not the aspect ratio stored in encoded frames, if it exists.

       <b>-display_rotation[:</b><u>stream_specifier</u><b>]</b> <u>rotation</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Set video rotation metadata.

           <u>rotation</u> is a decimal number specifying the amount in degree by which the  video  should  be  rotated
           counter-clockwise before being displayed.

           This  option  overrides  the rotation/display transform metadata stored in the file, if any. When the
           video is being transcoded (rather than copied) and  "-autorotate"  is  enabled,  the  video  will  be
           rotated  at  the filtering stage. Otherwise, the metadata will be written into the output file if the
           muxer supports it.

           If the "-display_hflip" and/or "-display_vflip"  options  are  given,  they  are  applied  after  the
           rotation specified by this option.

       <b>-display_hflip[:</b><u>stream_specifier</u><b>]</b> <b>(</b><u>input,per-stream</u><b>)</b>
           Set whether on display the image should be horizontally flipped.

           See the "-display_rotation" option for more details.

       <b>-display_vflip[:</b><u>stream_specifier</u><b>]</b> <b>(</b><u>input,per-stream</u><b>)</b>
           Set whether on display the image should be vertically flipped.

           See the "-display_rotation" option for more details.

       <b>-vn</b> <b>(</b><u>input/output</u><b>)</b>
           As  an  input  option,  blocks all video streams of a file from being filtered or being automatically
           selected or mapped for any output. See "-discard" option to disable streams individually.

           As an output option, disables video recording i.e.  automatic  selection  or  mapping  of  any  video
           stream. For full manual control see the "-map" option.

       <b>-vcodec</b> <u>codec</u> <b>(</b><u>output</u><b>)</b>
           Set the video codec. This is an alias for "-codec:v".

       <b>-pass[:</b><u>stream_specifier</u><b>]</b> <u>n</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Select  the  pass  number  (1  or 2). It is used to do two-pass video encoding. The statistics of the
           video are recorded in the first pass into a log file (see also the option -passlogfile), and  in  the
           second  pass  that log file is used to generate the video at the exact requested bitrate.  On pass 1,
           you may just deactivate audio and set output to null, examples for Windows and Unix:

                   ffmpeg -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y NUL
                   ffmpeg -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y /dev/null

       <b>-passlogfile[:</b><u>stream_specifier</u><b>]</b> <u>prefix</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set two-pass log file name prefix to <u>prefix</u>, the default file name  prefix  is  ``ffmpeg2pass''.  The
           complete file name will be <u>PREFIX-N.log</u>, where N is a number specific to the output stream

       <b>-vf</b> <u>filtergraph</u> <b>(</b><u>output</u><b>)</b>
           Create the filtergraph specified by <u>filtergraph</u> and use it to filter the stream.

           This is an alias for "-filter:v", see the <b>-filter</b> <b>option</b>.

       <b>-autorotate</b>
           Automatically  rotate  the video according to file metadata. Enabled by default, use <b>-noautorotate</b> to
           disable it.

       <b>-autoscale</b>
           Automatically scale the video according to the resolution of first frame.  Enabled  by  default,  use
           <b>-noautoscale</b>  to  disable it. When autoscale is disabled, all output frames of filter graph might not
           be in the same resolution and may  be  inadequate  for  some  encoder/muxer.  Therefore,  it  is  not
           recommended  to  disable it unless you really know what you are doing.  Disable autoscale at your own
           risk.

   <b>Advanced</b> <b>Video</b> <b>options</b>
       <b>-pix_fmt[:</b><u>stream_specifier</u><b>]</b> <u>format</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set pixel format. Use "-pix_fmts" to show all the supported pixel formats.   If  the  selected  pixel
           format can not be selected, ffmpeg will print a warning and select the best pixel format supported by
           the  encoder.  If <u>pix_fmt</u> is prefixed by a "+", ffmpeg will exit with an error if the requested pixel
           format can not be selected, and automatic conversions inside filtergraphs are disabled.   If  <u>pix_fmt</u>
           is  a  single  "+", ffmpeg selects the same pixel format as the input (or graph output) and automatic
           conversions are disabled.

       <b>-sws_flags</b> <u>flags</u> <b>(</b><u>input/output</u><b>)</b>
           Set default flags for the libswscale library. These flags are used by automatically inserted  "scale"
           filters and those within simple filtergraphs, if not overridden within the filtergraph definition.

           See the <b>ffmpeg-scaler</b> <b>manual</b> for a list of scaler options.

       <b>-rc_override[:</b><u>stream_specifier</u><b>]</b> <u>override</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Rate control override for specific intervals, formatted as "int,int,int" list separated with slashes.
           Two  first  values are the beginning and end frame numbers, last one is quantizer to use if positive,
           or quality factor if negative.

       <b>-vstats</b>
           Dump video coding statistics to <u>vstats_HHMMSS.log</u>. See the <b>vstats</b> <b>file</b> <b>format</b> section for the  format
           description.

       <b>-vstats_file</b> <u>file</u>
           Dump video coding statistics to <u>file</u>. See the <b>vstats</b> <b>file</b> <b>format</b> section for the format description.

       <b>-vstats_version</b> <u>file</u>
           Specify  which  version of the vstats format to use. Default is 2. See the <b>vstats</b> <b>file</b> <b>format</b> section
           for the format description.

       <b>-vtag</b> <u>fourcc/tag</u> <b>(</b><u>output</u><b>)</b>
           Force video tag/fourcc. This is an alias for "-tag:v".

       <b>-force_key_frames[:</b><u>stream_specifier</u><b>]</b> <u>time</u><b>[,</b><u>time</u><b>...]</b> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-force_key_frames[:</b><u>stream_specifier</u><b>]</b> <b>expr:</b><u>expr</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-force_key_frames[:</b><u>stream_specifier</u><b>]</b> <b>source</b> <b>(</b><u>output,per-stream</u><b>)</b>
           <u>force_key_frames</u> can take arguments of the following form:

           <u>time</u><b>[,</b><u>time</u><b>...]</b>
               If the argument consists of timestamps, ffmpeg will round the  specified  times  to  the  nearest
               output  timestamp  as  per  the  encoder time base and force a keyframe at the first frame having
               timestamp equal or greater than the computed timestamp. Note that if the encoder time base is too
               coarse, then the keyframes may be forced on frames with timestamps lower than the specified time.
               The default encoder time base is the inverse of the output framerate but may be set otherwise via
               "-enc_time_base".

               If one of the times is ""chapters"[<u>delta</u>]", it is expanded into the time of the beginning of  all
               chapters  in  the  file,  shifted  by  <u>delta</u>, expressed as a time in seconds.  This option can be
               useful to ensure that a seek point is present at a chapter mark or any other designated place  in
               the output file.

               For  example, to insert a key frame at 5 minutes, plus key frames 0.1 second before the beginning
               of every chapter:

                       -force_key_frames 0:05:00,chapters-0.1

           <b>expr:</b><u>expr</u>
               If the argument is prefixed with "expr:", the string <u>expr</u> is interpreted like an  expression  and
               is evaluated for each frame. A key frame is forced in case the evaluation is non-zero.

               The expression in <u>expr</u> can contain the following constants:

               <b>n</b>   the number of current processed frame, starting from 0

               <b>n_forced</b>
                   the number of forced frames

               <b>prev_forced_n</b>
                   the number of the previous forced frame, it is "NAN" when no keyframe was forced yet

               <b>prev_forced_t</b>
                   the time of the previous forced frame, it is "NAN" when no keyframe was forced yet

               <b>t</b>   the time of the current processed frame

               For example to force a key frame every 5 seconds, you can specify:

                       -force_key_frames expr:gte(t,n_forced*5)

               To force a key frame 5 seconds after the time of the last forced one, starting from second 13:

                       -force_key_frames expr:if(isnan(prev_forced_t),gte(t,13),gte(t,prev_forced_t+5))

           <b>source</b>
               If  the argument is "source", ffmpeg will force a key frame if the current frame being encoded is
               marked as a key frame in its source.  In cases where this  particular  source  frame  has  to  be
               dropped, enforce the next available frame to become a key frame instead.

           Note  that  forcing  too  many  keyframes  is  very  harmful  for the lookahead algorithms of certain
           encoders: using fixed-GOP options or similar would be more efficient.

       <b>-apply_cropping[:</b><u>stream_specifier</u><b>]</b> <u>source</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Automatically crop the video after decoding according to file metadata.  Default is <u>all</u>.

           <b>none</b> <b>(0)</b>
               Don't apply any cropping metadata.

           <b>all</b> <b>(1)</b>
               Apply both codec and container level croppping. This is the default mode.

           <b>codec</b> <b>(2)</b>
               Apply codec level croppping.

           <b>container</b> <b>(3)</b>
               Apply container level croppping.

       <b>-copyinkf[:</b><u>stream_specifier</u><b>]</b> <b>(</b><u>output,per-stream</u><b>)</b>
           When doing stream copy, copy also non-key frames found at the beginning.

       <b>-init_hw_device</b> <u>type</u><b>[=</b><u>name</u><b>][:</b><u>device</u><b>[,</b><u>key=value</u><b>...]]</b>
           Initialise a new hardware device of type <u>type</u> called <u>name</u>, using the given device parameters.  If  no
           name is specified it will receive a default name of the form "<u>type</u>%d".

           The meaning of <u>device</u> and the following arguments depends on the device type:

           <b>cuda</b>
               <u>device</u> is the number of the CUDA device.

               The following options are recognized:

               <b>primary_ctx</b>
                   If set to 1, uses the primary device context instead of creating a new one.

               Examples:

               <u>-init_hw_device</u> <u>cuda:1</u>
                   Choose the second device on the system.

               <u>-init_hw_device</u> <u>cuda:0,primary_ctx=1</u>
                   Choose the first device and use the primary device context.

           <b>dxva2</b>
               <u>device</u> is the number of the Direct3D 9 display adapter.

           <b>d3d11va</b>
               <u>device</u>  is  the  number of the Direct3D 11 display adapter.  If not specified, it will attempt to
               use the default Direct3D 11 display adapter or  the  first  Direct3D  11  display  adapter  whose
               hardware VendorId is specified by <b>vendor_id</b>.

               Examples:

               <u>-init_hw_device</u> <u>d3d11va</u>
                   Create a d3d11va device on the default Direct3D 11 display adapter.

               <u>-init_hw_device</u> <u>d3d11va:1</u>
                   Create a d3d11va device on the Direct3D 11 display adapter specified by index 1.

               <u>-init_hw_device</u> <u>d3d11va:,vendor_id=0x8086</u>
                   Create  a  d3d11va device on the first Direct3D 11 display adapter whose hardware VendorId is
                   0x8086.

           <b>vaapi</b>
               <u>device</u> is either an X11 display name, a DRM render node or  a  DirectX  adapter  index.   If  not
               specified,  it  will  attempt  to  open the default X11 display (<u>$DISPLAY</u>) and then the first DRM
               render node (<u>/dev/dri/renderD128</u>), or the default DirectX adapter on Windows.

               The following options are recognized:

               <b>kernel_driver</b>
                   When <u>device</u> is not specified, use this option to  specify  the  name  of  the  kernel  driver
                   associated  with  the  desired  device.  This  option  is  available  only  when the hardware
                   acceleration method <u>drm</u> and <u>vaapi</u> are enabled.

               <b>vendor_id</b>
                   When <u>device</u> and <u>kernel_driver</u> are not specified, use this option to  specify  the  vendor  id
                   associated  with  the  desired  device.  This  option  is  available  only  when the hardware
                   acceleration method <u>drm</u> and <u>vaapi</u> are enabled and <u>kernel_driver</u> is not specified.

               Examples:

               <u>-init_hw_device</u> <u>vaapi</u>
                   Create a vaapi device on the default device.

               <u>-init_hw_device</u> <u>vaapi:/dev/dri/renderD129</u>
                   Create a vaapi device on DRM render node <u>/dev/dri/renderD129</u>.

               <u>-init_hw_device</u> <u>vaapi:1</u>
                   Create a vaapi device on DirectX adapter 1.

               <u>-init_hw_device</u> <u>vaapi:,kernel_driver=i915</u>
                   Create a vaapi device on a device associated with kernel driver <b>i915</b>.

               <u>-init_hw_device</u> <u>vaapi:,vendor_id=0x8086</u>
                   Create a vaapi device on a device associated with vendor id <b>0x8086</b>.

           <b>vdpau</b>
               <u>device</u> is an X11 display name.  If not specified, it will attempt to open the default X11 display
               (<u>$DISPLAY</u>).

           <b>qsv</b> <u>device</u> selects a value in <b>MFX_IMPL_*</b>. Allowed values are:

               <b>auto</b>
               <b>sw</b>
               <b>hw</b>
               <b>auto_any</b>
               <b>hw_any</b>
               <b>hw2</b>
               <b>hw3</b>
               <b>hw4</b>

               If not specified, <b>auto_any</b> is used.  (Note that it may be easier to achieve  the  desired  result
               for  QSV  by  creating  the  platform-appropriate  subdevice (<b>dxva2</b> or <b>d3d11va</b> or <b>vaapi</b>) and then
               deriving a QSV device from that.)

               The following options are recognized:

               <b>child_device</b>
                   Specify a DRM render node on Linux or DirectX adapter on Windows.

               <b>child_device_type</b>
                   Choose platform-appropriate subdevice type. On Windows <b>d3d11va</b> is used as  default  subdevice
                   type  when  "--enable-libvpl"  is  specified  at configuration time, <b>dxva2</b> is used as default
                   subdevice type when "--enable-libmfx" is specified at configuration time. On Linux  user  can
                   use <b>vaapi</b> only as subdevice type.

               Examples:

               <u>-init_hw_device</u> <u>qsv:hw,child_device=/dev/dri/renderD129</u>
                   Create a QSV device with <b>MFX_IMPL_HARDWARE</b> on DRM render node <u>/dev/dri/renderD129</u>.

               <u>-init_hw_device</u> <u>qsv:hw,child_device=1</u>
                   Create a QSV device with <b>MFX_IMPL_HARDWARE</b> on DirectX adapter 1.

               <u>-init_hw_device</u> <u>qsv:hw,child_device_type=d3d11va</u>
                   Choose the GPU subdevice with type <b>d3d11va</b> and create QSV device with <b>MFX_IMPL_HARDWARE</b>.

               <u>-init_hw_device</u> <u>qsv:hw,child_device_type=dxva2</u>
                   Choose the GPU subdevice with type <b>dxva2</b> and create QSV device with <b>MFX_IMPL_HARDWARE</b>.

               <u>-init_hw_device</u> <u>qsv:hw,child_device=1,child_device_type=d3d11va</u>
                   Create a QSV device with <b>MFX_IMPL_HARDWARE</b> on DirectX adapter 1 with subdevice type <b>d3d11va</b>.

               <u>-init_hw_device</u> <u>vaapi=va:/dev/dri/renderD129</u> <u>-init_hw_device</u> <u>qsv=hw1@va</u>
                   Create  a  VAAPI device called <b>va</b> on <u>/dev/dri/renderD129</u>, then derive a QSV device called <b>hw1</b>
                   from device <b>va</b>.

           <b>opencl</b>
               <u>device</u> selects the platform and device as <u>platform_index.device_index</u>.

               The set of devices can also be filtered using the key-value pairs to find only  devices  matching
               particular platform or device strings.

               The strings usable as filters are:

               <b>platform_profile</b>
               <b>platform_version</b>
               <b>platform_name</b>
               <b>platform_vendor</b>
               <b>platform_extensions</b>
               <b>device_name</b>
               <b>device_vendor</b>
               <b>driver_version</b>
               <b>device_version</b>
               <b>device_profile</b>
               <b>device_extensions</b>
               <b>device_type</b>

               The indices and filters must together uniquely select a device.

               Examples:

               <u>-init_hw_device</u> <u>opencl:0.1</u>
                   Choose the second device on the first platform.

               <u>-init_hw_device</u> <u>opencl:,device_name=Foo9000</u>
                   Choose the device with a name containing the string <u>Foo9000</u>.

               <u>-init_hw_device</u> <u>opencl:1,device_type=gpu,device_extensions=cl_khr_fp16</u>
                   Choose the GPU device on the second platform supporting the <u>cl_khr_fp16</u> extension.

           <b>vulkan</b>
               If  <u>device</u>  is  an  integer,  it  selects  the  device by its index in a system-dependent list of
               devices.  If <u>device</u> is any other string, it selects the first device with a name containing  that
               string as a substring.

               The following options are recognized:

               <b>debug</b>
                   If set to 1, enables the validation layer, if installed.

               <b>linear_images</b>
                   If set to 1, images allocated by the hwcontext will be linear and locally mappable.

               <b>instance_extensions</b>
                   A plus separated list of additional instance extensions to enable.

               <b>device_extensions</b>
                   A plus separated list of additional device extensions to enable.

               Examples:

               <u>-init_hw_device</u> <u>vulkan:1</u>
                   Choose the second device on the system.

               <u>-init_hw_device</u> <u>vulkan:RADV</u>
                   Choose the first device with a name containing the string <u>RADV</u>.

               <u>-init_hw_device</u> <u>vulkan:0,instance_extensions=VK_KHR_wayland_surface+VK_KHR_xcb_surface</u>
                   Choose the first device and enable the Wayland and XCB instance extensions.

       <b>-init_hw_device</b> <u>type</u><b>[=</b><u>name</u><b>]@</b><u>source</u>
           Initialise  a new hardware device of type <u>type</u> called <u>name</u>, deriving it from the existing device with
           the name <u>source</u>.

       <b>-init_hw_device</b> <b>list</b>
           List all hardware device types supported in this build of ffmpeg.

       <b>-filter_hw_device</b> <u>name</u>
           Pass the hardware device called <u>name</u> to all filters in any filter graph.  This can be used to set the
           device to upload to with the "hwupload" filter, or the device to map  to  with  the  "hwmap"  filter.
           Other  filters  may  also  make use of this parameter when they require a hardware device.  Note that
           this is typically only required when the input is not already  in  hardware  frames  -  when  it  is,
           filters will derive the device they require from the context of the frames they receive as input.

           This is a global setting, so all filters will receive the same device.

       <b>-hwaccel[:</b><u>stream_specifier</u><b>]</b> <u>hwaccel</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Use hardware acceleration to decode the matching stream(s). The allowed values of <u>hwaccel</u> are:

           <b>none</b>
               Do not use any hardware acceleration (the default).

           <b>auto</b>
               Automatically select the hardware acceleration method.

           <b>vdpau</b>
               Use VDPAU (Video Decode and Presentation API for Unix) hardware acceleration.

           <b>dxva2</b>
               Use DXVA2 (DirectX Video Acceleration) hardware acceleration.

           <b>d3d11va</b>
               Use D3D11VA (DirectX Video Acceleration) hardware acceleration.

           <b>vaapi</b>
               Use VAAPI (Video Acceleration API) hardware acceleration.

           <b>qsv</b> Use the Intel QuickSync Video acceleration for video transcoding.

               Unlike  most  other  values,  this  option  does  not  enable  accelerated decoding (that is used
               automatically whenever a qsv decoder is selected), but accelerated transcoding,  without  copying
               the frames into the system memory.

               For  it  to  work,  both the decoder and the encoder must support QSV acceleration and no filters
               must be used.

           This option has no effect if the selected hwaccel is not available or not  supported  by  the  chosen
           decoder.

           Note  that  most  acceleration methods are intended for playback and will not be faster than software
           decoding on modern CPUs. Additionally, <b>ffmpeg</b> will usually need to copy the decoded frames  from  the
           GPU  memory into the system memory, resulting in further performance loss. This option is thus mainly
           useful for testing.

       <b>-hwaccel_device[:</b><u>stream_specifier</u><b>]</b> <u>hwaccel_device</u> <b>(</b><u>input,per-stream</u><b>)</b>
           Select a device to use for hardware acceleration.

           This option only makes sense when the <b>-hwaccel</b> option is also specified.  It can either refer  to  an
           existing  device  created  with  <b>-init_hw_device</b>  by  name,  or  it  can  create  a  new device as if
           <b>-init_hw_device</b> <u>type</u>:<u>hwaccel_device</u> were called immediately before.

       <b>-hwaccels</b>
           List all  hardware  acceleration  components  enabled  in  this  build  of  ffmpeg.   Actual  runtime
           availability depends on the hardware and its suitable driver being installed.

       <b>-fix_sub_duration_heartbeat[:</b><u>stream_specifier</u><b>]</b>
           Set  a  specific  output  video  stream  as the heartbeat stream according to which to split and push
           through currently in-progress subtitle upon receipt of a random access packet.

           This lowers the latency of subtitles for which the end packet or the following subtitle has  not  yet
           been  received.  As a drawback, this will most likely lead to duplication of subtitle events in order
           to cover the full duration, so when dealing with use cases where latency of when the  subtitle  event
           is passed on to output is not relevant this option should not be utilized.

           Requires  <b>-fix_sub_duration</b>  to  be  set  for the relevant input subtitle stream for this to have any
           effect, as well as for the input subtitle stream having to be directly mapped to the same  output  in
           which the heartbeat stream resides.

   <b>Audio</b> <b>Options</b>
       <b>-aframes</b> <u>number</u> <b>(</b><u>output</u><b>)</b>
           Set the number of audio frames to output. This is an obsolete alias for "-frames:a", which you should
           use instead.

       <b>-ar[:</b><u>stream_specifier</u><b>]</b> <u>freq</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set  the  audio  sampling  frequency. For output streams it is set by default to the frequency of the
           corresponding input stream. For input streams this option only makes sense for audio grabbing devices
           and raw demuxers and is mapped to the corresponding demuxer options.

       <b>-aq</b> <u>q</u> <b>(</b><u>output</u><b>)</b>
           Set the audio quality (codec-specific, VBR). This is an alias for -q:a.

       <b>-ac[:</b><u>stream_specifier</u><b>]</b> <u>channels</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set the number of audio channels. For output streams it is set by default  to  the  number  of  input
           audio  channels.  For  input  streams this option only makes sense for audio grabbing devices and raw
           demuxers and is mapped to the corresponding demuxer options.

       <b>-an</b> <b>(</b><u>input/output</u><b>)</b>
           As an input option, blocks all audio streams of a file from being  filtered  or  being  automatically
           selected or mapped for any output. See "-discard" option to disable streams individually.

           As  an  output  option,  disables  audio  recording  i.e. automatic selection or mapping of any audio
           stream. For full manual control see the "-map" option.

       <b>-acodec</b> <u>codec</u> <b>(</b><u>input/output</u><b>)</b>
           Set the audio codec. This is an alias for "-codec:a".

       <b>-sample_fmt[:</b><u>stream_specifier</u><b>]</b> <u>sample_fmt</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set the audio sample format. Use "-sample_fmts" to get a list of supported sample formats.

       <b>-af</b> <u>filtergraph</u> <b>(</b><u>output</u><b>)</b>
           Create the filtergraph specified by <u>filtergraph</u> and use it to filter the stream.

           This is an alias for "-filter:a", see the <b>-filter</b> <b>option</b>.

   <b>Advanced</b> <b>Audio</b> <b>options</b>
       <b>-atag</b> <u>fourcc/tag</u> <b>(</b><u>output</u><b>)</b>
           Force audio tag/fourcc. This is an alias for "-tag:a".

       <b>-ch_layout[:</b><u>stream_specifier</u><b>]</b> <u>layout</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Alias for "-channel_layout".

       <b>-channel_layout[:</b><u>stream_specifier</u><b>]</b> <u>layout</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Set the audio channel layout. For output streams it is set by default to the  input  channel  layout.
           For  input  streams  it  overrides  the  channel  layout  of  the input. Not all decoders respect the
           overridden channel layout. This option also sets the channel layout for audio  grabbing  devices  and
           raw demuxers and is mapped to the corresponding demuxer option.

       <b>-guess_layout_max</b> <u>channels</u> <b>(</b><u>input,per-stream</u><b>)</b>
           If  some  input  channel  layout  is  not  known,  try to guess only if it corresponds to at most the
           specified number of channels. For example, 2 tells to <b>ffmpeg</b> to recognize 1 channel  as  mono  and  2
           channels as stereo but not 6 channels as 5.1. The default is to always try to guess. Use 0 to disable
           all  guessing. Using the "-channel_layout" option to explicitly specify an input layout also disables
           guessing.

   <b>Subtitle</b> <b>options</b>
       <b>-scodec</b> <u>codec</u> <b>(</b><u>input/output</u><b>)</b>
           Set the subtitle codec. This is an alias for "-codec:s".

       <b>-sn</b> <b>(</b><u>input/output</u><b>)</b>
           As an input option, blocks all subtitle streams of a file from being filtered or being  automatically
           selected or mapped for any output. See "-discard" option to disable streams individually.

           As  an output option, disables subtitle recording i.e. automatic selection or mapping of any subtitle
           stream. For full manual control see the "-map" option.

   <b>Advanced</b> <b>Subtitle</b> <b>options</b>
       <b>-fix_sub_duration</b>
           Fix subtitles durations. For each subtitle, wait for the next packet in the same  stream  and  adjust
           the  duration of the first to avoid overlap. This is necessary with some subtitles codecs, especially
           DVB subtitles, because the duration in the original packet is only a rough estimate and  the  end  is
           actually  marked  by an empty subtitle frame. Failing to use this option when necessary can result in
           exaggerated durations or muxing failures due to non-monotonic timestamps.

           Note that this option will delay the output of all data until the next subtitle packet is decoded: it
           may increase memory consumption and latency a lot.

       <b>-canvas_size</b> <u>size</u>
           Set the size of the canvas used to render subtitles.

   <b>Advanced</b> <b>options</b>
       <b>-map</b> <b>[-]</b><u>input_file_id</u><b>[:</b><u>stream_specifier</u><b>][:</b><u>view_specifier</u><b>][:?]</b> <b>|</b> <u>[linklabel]</u> <b>(</b><u>output</u><b>)</b>
           Create one or more streams in the output file. This option has two  forms  for  specifying  the  data
           source(s):  the  first  selects  one  or more streams from some input file (specified with "-i"), the
           second takes an output from some complex filtergraph (specified with "-filter_complex").

           In the first form, an output stream is created for every stream from the input file  with  the  index
           <u>input_file_id</u>.  If  <u>stream_specifier</u>  is  given, only those streams that match the specifier are used
           (see the <b>Stream</b> <b>specifiers</b> section for the <u>stream_specifier</u> syntax).

           A "-" character before the stream identifier creates a  "negative"  mapping.   It  disables  matching
           streams from already created mappings.

           An  optional  <u>view_specifier</u>  may  be  given  after  the  stream specifier, which for multiview video
           specifies the view to be used. The view specifier may have one of the following formats:

           <b>view:</b><u>view_id</u>
               select a view by its ID; <u>view_id</u> may be set to 'all' to use all the views  interleaved  into  one
               stream;

           <b>vidx:</b><u>view_idx</u>
               select a view by its index; i.e. 0 is the base view, 1 is the first non-base view, etc.

           <b>vpos:</b><u>position</u>
               select a view by its display position; <u>position</u> may be "left" or "right"

           The  default  for  transcoding  is  to  only  use the base view, i.e. the equivalent of "vidx:0". For
           streamcopy, view specifiers are not supported and all views are always copied.

           A trailing "?" after the stream index will allow the map to  be  optional:  if  the  map  matches  no
           streams  the map will be ignored instead of failing. Note the map will still fail if an invalid input
           file index is used; such as if the map refers to a non-existent input.

           An alternative <u>[linklabel]</u> form will map outputs from complex filter graphs (see the  <b>-filter_complex</b>
           option) to the output file.  <u>linklabel</u> must correspond to a defined output link label in the graph.

           This  option  may be specified multiple times, each adding more streams to the output file. Any given
           input stream may also be mapped any number of times as a source for different output streams, e.g. in
           order to use different encoding options and/or filters. The streams are created in the output in  the
           same order in which the "-map" options are given on the commandline.

           Using this option disables the default mappings for this output file.

           Examples:

           <u>map</u> <u>everything</u>
               To map ALL streams from the first input file to output

                       ffmpeg -i INPUT -map 0 output

           <u>select</u> <u>specific</u> <u>stream</u>
               If  you  have  two audio streams in the first input file, these streams are identified by <u>0:0</u> and
               <u>0:1</u>. You can use "-map" to select which streams to place in an output file. For example:

                       ffmpeg -i INPUT -map 0:1 out.wav

               will map the second input stream in <u>INPUT</u> to the (single) output stream in <u>out.wav</u>.

           <u>create</u> <u>multiple</u> <u>streams</u>
               To select the stream with index 2 from input file <u>a.mov</u> (specified by the  identifier  <u>0:2</u>),  and
               stream  with  index  6  from  input <u>b.mov</u> (specified by the identifier <u>1:6</u>), and copy them to the
               output file <u>out.mov</u>:

                       ffmpeg -i a.mov -i b.mov -c copy -map 0:2 -map 1:6 out.mov

           <u>create</u> <u>multiple</u> <u>streams</u> <u>2</u>
               To select all video and the third audio stream from an input file:

                       ffmpeg -i INPUT -map 0:v -map 0:a:2 OUTPUT

           <u>negative</u> <u>map</u>
               To map all the streams except the second audio, use negative mappings

                       ffmpeg -i INPUT -map 0 -map -0:a:1 OUTPUT

           <u>optional</u> <u>map</u>
               To map the video and audio streams from the first input, and using the trailing "?",  ignore  the
               audio mapping if no audio streams exist in the first input:

                       ffmpeg -i INPUT -map 0:v -map 0:a? OUTPUT

           <u>map</u> <u>by</u> <u>language</u>
               To pick the English audio stream:

                       ffmpeg -i INPUT -map 0:m:language:eng OUTPUT

       <b>-ignore_unknown</b>
           Ignore input streams with unknown type instead of failing if copying such streams is attempted.

       <b>-copy_unknown</b>
           Allow  input  streams  with  unknown  type to be copied instead of failing if copying such streams is
           attempted.

       <b>-map_metadata[:</b><u>metadata_spec_out</u><b>]</b> <u>infile</u><b>[:</b><u>metadata_spec_in</u><b>]</b> <b>(</b><u>output,per-metadata</u><b>)</b>
           Set metadata information of the next output file from <u>infile</u>. Note that those are file indices (zero-
           based), not filenames.  Optional <u>metadata_spec_in/out</u> parameters specify, which metadata to copy.   A
           metadata specifier can have the following forms:

           <u>g</u>   global metadata, i.e. metadata that applies to the whole file

           <u>s</u><b>[:</b><u>stream_spec</u><b>]</b>
               per-stream  metadata.  <u>stream_spec</u>  is  a  stream specifier as described in the <b>Stream</b> <b>specifiers</b>
               chapter. In an input metadata specifier, the first matching stream is copied from. In  an  output
               metadata specifier, all matching streams are copied to.

           <u>c</u><b>:</b><u>chapter_index</u>
               per-chapter metadata. <u>chapter_index</u> is the zero-based chapter index.

           <u>p</u><b>:</b><u>program_index</u>
               per-program metadata. <u>program_index</u> is the zero-based program index.

           If metadata specifier is omitted, it defaults to global.

           By  default, global metadata is copied from the first input file, per-stream and per-chapter metadata
           is copied along with streams/chapters. These default mappings are disabled by creating any mapping of
           the relevant type. A negative file index can be used to create a dummy  mapping  that  just  disables
           automatic copying.

           For example to copy metadata from the first stream of the input file to global metadata of the output
           file:

                   ffmpeg -i in.ogg -map_metadata 0:s:0 out.mp3

           To do the reverse, i.e. copy global metadata to all audio streams:

                   ffmpeg -i in.mkv -map_metadata:s:a 0:g out.mkv

           Note that simple 0 would work as well in this example, since global metadata is assumed by default.

       <b>-map_chapters</b> <u>input_file_index</u> <b>(</b><u>output</u><b>)</b>
           Copy  chapters  from  input  file  with index <u>input_file_index</u> to the next output file. If no chapter
           mapping is specified, then chapters are copied from the first input file with at least  one  chapter.
           Use a negative file index to disable any chapter copying.

       <b>-benchmark</b> <b>(</b><u>global</u><b>)</b>
           Show  benchmarking  information  at  the end of an encode.  Shows real, system and user time used and
           maximum memory consumption.  Maximum memory consumption is not supported  on  all  systems,  it  will
           usually display as 0 if not supported.

       <b>-benchmark_all</b> <b>(</b><u>global</u><b>)</b>
           Show  benchmarking  information  during the encode.  Shows real, system and user time used in various
           steps (audio/video encode/decode).

       <b>-timelimit</b> <u>duration</u> <b>(</b><u>global</u><b>)</b>
           Exit after ffmpeg has been running for <u>duration</u> seconds in CPU user time.

       <b>-dump</b> <b>(</b><u>global</u><b>)</b>
           Dump each input packet to stderr.

       <b>-hex</b> <b>(</b><u>global</u><b>)</b>
           When dumping packets, also dump the payload.

       <b>-readrate</b> <u>speed</u> <b>(</b><u>input</u><b>)</b>
           Limit input read speed.

           Its value is a floating-point positive number which represents the  maximum  duration  of  media,  in
           seconds,  that  should  be  ingested  in  one  second  of  wallclock time.  Default value is zero and
           represents no imposed limitation on speed of ingestion.  Value 1 represents real-time  speed  and  is
           equivalent to "-re".

           Mainly  used  to  simulate  a  capture  device  or live input stream (e.g. when reading from a file).
           Should not be used with a low value when input is an actual capture device or live stream as  it  may
           cause packet loss.

           It is useful for when flow speed of output packets is important, such as live streaming.

       <b>-re</b> <b>(</b><u>input</u><b>)</b>
           Read input at native frame rate. This is equivalent to setting "-readrate 1".

       <b>-readrate_initial_burst</b> <u>seconds</u>
           Set an initial read burst time, in seconds, after which <b>-re/-readrate</b> will be enforced.

       <b>-vsync</b> <u>parameter</u> <b>(</b><u>global</u><b>)</b>
       <b>-fps_mode[:</b><u>stream_specifier</u><b>]</b> <u>parameter</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set  video  sync  method  /  framerate  mode. vsync is applied to all output video streams but can be
           overridden for a stream by setting fps_mode. vsync is deprecated and will be removed in the future.

           For compatibility reasons some of the values  for  vsync  can  be  specified  as  numbers  (shown  in
           parentheses in the following table).

           <b>passthrough</b> <b>(0)</b>
               Each frame is passed with its timestamp from the demuxer to the muxer.

           <b>cfr</b> <b>(1)</b>
               Frames will be duplicated and dropped to achieve exactly the requested constant frame rate.

           <b>vfr</b> <b>(2)</b>
               Frames  are  passed through with their timestamp or dropped so as to prevent 2 frames from having
               the same timestamp.

           <b>auto</b> <b>(-1)</b>
               Chooses between cfr and vfr depending on muxer capabilities. This is the default method.

           Note that the timestamps may be further modified by the muxer, after this.  For example, in the  case
           that the format option <b>avoid_negative_ts</b> is enabled.

           With -map you can select from which stream the timestamps should be taken. You can leave either video
           or audio unchanged and sync the remaining stream(s) to the unchanged one.

       <b>-frame_drop_threshold</b> <u>parameter</u>
           Frame drop threshold, which specifies how much behind video frames can be before they are dropped. In
           frame  rate  units,  so  1.0  is  one  frame.   The default is -1.1. One possible usecase is to avoid
           framedrops in case of noisy timestamps  or  to  increase  frame  drop  precision  in  case  of  exact
           timestamps.

       <b>-apad</b> <u>parameters</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Pad  the  output  audio  stream(s). This is the same as applying "-af apad".  Argument is a string of
           filter parameters composed the same as with the "apad" filter.  "-shortest"  must  be  set  for  this
           output for the option to take effect.

       <b>-copyts</b>
           Do  not  process  input  timestamps,  but  keep  their  values  without  trying  to sanitize them. In
           particular, do not remove the initial start time offset value.

           Note that, depending on the <b>vsync</b> option or on specific muxer processing (e.g.  in  case  the  format
           option  <b>avoid_negative_ts</b>  is  enabled)  the output timestamps may mismatch with the input timestamps
           even when this option is selected.

       <b>-start_at_zero</b>
           When used with <b>copyts</b>, shift input timestamps so they start at zero.

           This means that using e.g. "-ss 50" will make output timestamps start at 50  seconds,  regardless  of
           what timestamp the input file started at.

       <b>-copytb</b> <u>mode</u>
           Specify  how  to set the encoder timebase when stream copying.  <u>mode</u> is an integer numeric value, and
           can assume one of the following values:

           <b>1</b>   Use the demuxer timebase.

               The time base is copied to the output encoder from  the  corresponding  input  demuxer.  This  is
               sometimes  required  to  avoid non monotonically increasing timestamps when copying video streams
               with variable frame rate.

           <b>0</b>   Use the decoder timebase.

               The time base is copied to the output encoder from the corresponding input decoder.

           <b>-1</b>  Try to make the choice automatically, in order to generate a sane output.

           Default value is -1.

       <b>-enc_time_base[:</b><u>stream_specifier</u><b>]</b> <u>timebase</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Set the encoder timebase. <u>timebase</u> can assume one of the following values:

           <b>0</b>   Assign a default value according to the media type.

               For video - use 1/framerate, for audio - use 1/samplerate.

           <b>demux</b>
               Use the timebase from the demuxer.

           <b>filter</b>
               Use the timebase from the filtergraph.

           <b>a</b> <b>positive</b> <b>number</b>
               Use the provided number as the timebase.

               This field can be provided as a ratio of two integers (e.g. 1:24, 1:48000) or as a decimal number
               (e.g. 0.04166, 2.0833e-5)

           Default value is 0.

       <b>-bitexact</b> <b>(</b><u>input/output</u><b>)</b>
           Enable bitexact mode for (de)muxer and (de/en)coder

       <b>-shortest</b> <b>(</b><u>output</u><b>)</b>
           Finish encoding when the shortest output stream ends.

           Note that this option may require buffering frames,  which  introduces  extra  latency.  The  maximum
           amount of this latency may be controlled with the "-shortest_buf_duration" option.

       <b>-shortest_buf_duration</b> <u>duration</u> <b>(</b><u>output</u><b>)</b>
           The  "-shortest"  option may require buffering potentially large amounts of data when at least one of
           the streams is "sparse" (i.e. has large gaps  between  frames  –  this  is  typically  the  case  for
           subtitles).

           This option controls the maximum duration of buffered frames in seconds.  Larger values may allow the
           "-shortest" option to produce more accurate results, but increase memory use and latency.

           The default value is 10 seconds.

       <b>-dts_delta_threshold</b> <u>threshold</u>
           Timestamp discontinuity delta threshold, expressed as a decimal number of seconds.

           The  timestamp  discontinuity  correction  enabled  by  this  option is only applied to input formats
           accepting timestamp discontinuity (for which the "AVFMT_TS_DISCONT" flag is  enabled),  e.g.  MPEG-TS
           and  HLS,  and  is  automatically  disabled  when  employing the "-copyts" option (unless wrapping is
           detected).

           If a timestamp discontinuity is detected whose absolute value is greater than <u>threshold</u>, ffmpeg  will
           remove  the discontinuity by decreasing/increasing the current DTS and PTS by the corresponding delta
           value.

           The default value is 10.

       <b>-dts_error_threshold</b> <u>threshold</u>
           Timestamp error delta threshold, expressed as a decimal number of seconds.

           The timestamp correction enabled by this option is  only  applied  to  input  formats  not  accepting
           timestamp discontinuity (for which the "AVFMT_TS_DISCONT" flag is not enabled).

           If  a timestamp discontinuity is detected whose absolute value is greater than <u>threshold</u>, ffmpeg will
           drop the PTS/DTS timestamp value.

           The default value is "3600*30" (30 hours), which is arbitrarily picked and quite conservative.

       <b>-muxdelay</b> <u>seconds</u> <b>(</b><u>output</u><b>)</b>
           Set the maximum demux-decode delay.

       <b>-muxpreload</b> <u>seconds</u> <b>(</b><u>output</u><b>)</b>
           Set the initial demux-decode delay.

       <b>-streamid</b> <u>output-stream-index</u><b>:</b><u>new-value</u> <b>(</b><u>output</u><b>)</b>
           Assign a new stream-id value to an output stream. This option should be specified prior to the output
           filename to which it applies.  For the situation where multiple output files exist, a streamid may be
           reassigned to a different value.

           For example, to set the stream 0 PID to 33 and the stream 1 PID to 36 for an output mpegts file:

                   ffmpeg -i inurl -streamid 0:33 -streamid 1:36 out.ts

       <b>-bsf[:</b><u>stream_specifier</u><b>]</b> <u>bitstream_filters</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Apply bitstream filters to matching streams. The filters are applied to each packet as it is received
           from the demuxer (when used as an input option) or before it is sent to the muxer (when  used  as  an
           output option).

           <u>bitstream_filters</u> is a comma-separated list of bitstream filter specifications, each of the form

                   &lt;filter&gt;[=&lt;optname0&gt;=&lt;optval0&gt;:&lt;optname1&gt;=&lt;optval1&gt;:...]

           Any  of  the  ',=:'  characters  that  are  to be a part of an option value need to be escaped with a
           backslash.

           Use the "-bsfs" option to get the list of bitstream filters.

           E.g.

                   ffmpeg -bsf:v h264_mp4toannexb -i h264.mp4 -c:v copy -an out.h264

           applies the "h264_mp4toannexb" bitstream filter (which  converts  MP4-encapsulated  H.264  stream  to
           Annex B) to the <u>input</u> video stream.

           On the other hand,

                   ffmpeg -i file.mov -an -vn -bsf:s mov2textsub -c:s copy -f rawvideo sub.txt

           applies  the  "mov2textsub"  bitstream  filter (which extracts text from MOV subtitles) to the <u>output</u>
           subtitle stream. Note, however, that since both examples use "-c copy", it matters little whether the
           filters are applied on input or output - that would change if transcoding was happening.

       <b>-tag[:</b><u>stream_specifier</u><b>]</b> <u>codec_tag</u> <b>(</b><u>input/output,per-stream</u><b>)</b>
           Force a tag/fourcc for matching streams.

       <b>-timecode</b> <u>hh</u><b>:</b><u>mm</u><b>:</b><u>ss</u><b>SEP</b><u>ff</u>
           Specify Timecode for writing. <u>SEP</u> is ':' for non drop timecode and ';' (or '.') for drop.

                   ffmpeg -i input.mpg -timecode 01:02:03.04 -r 30000/1001 -s ntsc output.mpg

       <b>-filter_complex</b> <u>filtergraph</u> <b>(</b><u>global</u><b>)</b>
           Define a complex filtergraph, i.e. one with arbitrary number of inputs  and/or  outputs.  For  simple
           graphs  --  those  with  one  input  and  one  output  of  the  same type -- see the <b>-filter</b> options.
           <u>filtergraph</u> is a description of the filtergraph, as described in the ``Filtergraph  syntax''  section
           of  the  ffmpeg-filters  manual. This option may be specified multiple times - each use creates a new
           complex filtergraph.

           Inputs to a complex filtergraph may come from different source types, distinguished by the format  of
           the corresponding link label:

           •   To  connect  an input stream, use "[file_index:stream_specifier]" (i.e. the same syntax as <b>-map</b>).
               If <u>stream_specifier</u> matches multiple streams, the first one will be used.  For  multiview  video,
               the stream specifier may be followed by the view specifier, see documentation for the <b>-map</b> option
               for its syntax.

           •   To  connect  a  loopback  decoder  use  [dec:<u>dec_idx</u>], where <u>dec_idx</u> is the index of the loopback
               decoder to be connected to given input. For multiview video, the decoder index may be followed by
               the view specifier, see documentation for the <b>-map</b> option for its syntax.

           •   To connect an output from another complex filtergraph, use its  link  label.  E.g  the  following
               example:

                       ffmpeg -i input.mkv \
                         -filter_complex '[0:v]scale=size=hd1080,split=outputs=2[for_enc][orig_scaled]' \
                         -c:v libx264 -map '[for_enc]' output.mkv \
                         -dec 0:0 \
                         -filter_complex '[dec:0][orig_scaled]hstack[stacked]' \
                         -map '[stacked]' -c:v ffv1 comparison.mkv

               reads an input video and

               •   (line  2)  uses  a  complex  filtergraph with one input and two outputs to scale the video to
                   1920x1080 and duplicate the result to both outputs;

               •   (line 3) encodes one scaled output with "libx264" and writes the result to <u>output.mkv</u>;

               •   (line 4) decodes this encoded stream with a loopback decoder;

               •   (line 5) places the output of the loopback decoder (i.e. the "libx264"-encoded video) side by
                   side with the scaled original input;

               •   (line 6) combined video is then losslessly encoded and written into <u>comparison.mkv</u>.

               Note that the two filtergraphs cannot be combined into one, because then there would be  a  cycle
               in  the  transcoding  pipeline (filtergraph output goes to encoding, from there to decoding, then
               back to the same graph), and such cycles are not allowed.

           An unlabeled input will be connected to the first unused input stream of the matching type.

           Output link labels are referred to with <b>-map</b>. Unlabeled outputs are added to the first output file.

           Note that with this option it is possible to use only lavfi sources without normal input files.

           For example, to overlay an image over video

                   ffmpeg -i video.mkv -i image.png -filter_complex '[0:v][1:v]overlay[out]' -map
                   '[out]' out.mkv

           Here "[0:v]" refers to the first video stream in the first input file, which is linked to  the  first
           (main) input of the overlay filter. Similarly the first video stream in the second input is linked to
           the second (overlay) input of overlay.

           Assuming there is only one video stream in each input file, we can omit input labels, so the above is
           equivalent to

                   ffmpeg -i video.mkv -i image.png -filter_complex 'overlay[out]' -map
                   '[out]' out.mkv

           Furthermore we can omit the output label and the single output from the filter graph will be added to
           the output file automatically, so we can simply write

                   ffmpeg -i video.mkv -i image.png -filter_complex 'overlay' out.mkv

           As  a  special  exception, you can use a bitmap subtitle stream as input: it will be converted into a
           video with the same size as the largest video in the file, or 720x576 if no video  is  present.  Note
           that  this  is an experimental and temporary solution. It will be removed once libavfilter has proper
           support for subtitles.

           For example, to hardcode subtitles on top of a DVB-T recording stored in MPEG-TS format, delaying the
           subtitles by 1 second:

                   ffmpeg -i input.ts -filter_complex \
                     '[#0x2ef] setpts=PTS+1/TB [sub] ; [#0x2d0] [sub] overlay' \
                     -sn -map '#0x2dc' output.mkv

           (0x2d0, 0x2dc and 0x2ef are the MPEG-TS PIDs of respectively the video, audio and subtitles  streams;
           0:0, 0:3 and 0:7 would have worked too)

           To generate 5 seconds of pure red video using lavfi "color" source:

                   ffmpeg -filter_complex 'color=c=red' -t 5 out.mkv

       <b>-filter_complex_threads</b> <u>nb_threads</u> <b>(</b><u>global</u><b>)</b>
           Defines  how  many threads are used to process a filter_complex graph.  Similar to filter_threads but
           used for "-filter_complex" graphs only.  The default is the number of available CPUs.

       <b>-lavfi</b> <u>filtergraph</u> <b>(</b><u>global</u><b>)</b>
           Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. Equivalent  to
           <b>-filter_complex</b>.

       <b>-accurate_seek</b> <b>(</b><u>input</u><b>)</b>
           This option enables or disables accurate seeking in input files with the <b>-ss</b> option. It is enabled by
           default,  so  seeking  is accurate when transcoding. Use <b>-noaccurate_seek</b> to disable it, which may be
           useful e.g. when copying some streams and transcoding the others.

       <b>-seek_timestamp</b> <b>(</b><u>input</u><b>)</b>
           This option enables or disables seeking by timestamp in input  files  with  the  <b>-ss</b>  option.  It  is
           disabled  by  default.  If enabled, the argument to the <b>-ss</b> option is considered an actual timestamp,
           and is not offset by the start time of the file. This matters only for files which do not start  from
           timestamp 0, such as transport streams.

       <b>-thread_queue_size</b> <u>size</u> <b>(</b><u>input/output</u><b>)</b>
           For  input,  this  option  sets  the  maximum  number of queued packets when reading from the file or
           device. With low latency / high rate live streams, packets may be discarded if they are not read in a
           timely manner; setting this value can force ffmpeg to use a separate input thread and read packets as
           soon as they arrive. By default ffmpeg only does this if multiple inputs are specified.

           For output, this option specified the maximum number of packets that may be  queued  to  each  muxing
           thread.

       <b>-sdp_file</b> <u>file</u> <b>(</b><u>global</u><b>)</b>
           Print  sdp  information  for  an  output stream to <u>file</u>.  This allows dumping sdp information when at
           least one output isn't an rtp stream. (Requires at least one of the output formats to be rtp).

       <b>-discard</b> <b>(</b><u>input</u><b>)</b>
           Allows discarding specific streams or frames from streams.  Any input stream can be fully  discarded,
           using  value  "all" whereas selective discarding of frames from a stream occurs at the demuxer and is
           not supported by all demuxers.

           <b>none</b>
               Discard no frame.

           <b>default</b>
               Default, which discards no frames.

           <b>noref</b>
               Discard all non-reference frames.

           <b>bidir</b>
               Discard all bidirectional frames.

           <b>nokey</b>
               Discard all frames excepts keyframes.

           <b>all</b> Discard all frames.

       <b>-abort_on</b> <u>flags</u> <b>(</b><u>global</u><b>)</b>
           Stop and abort on various conditions. The following flags are available:

           <b>empty_output</b>
               No packets were passed to the muxer, the output is empty.

           <b>empty_output_stream</b>
               No packets were passed to the muxer in some of the output streams.

       <b>-max_error_rate</b> <b>(</b><u>global</u><b>)</b>
           Set fraction of decoding frame failures across all inputs which when crossed ffmpeg will return  exit
           code  69.  Crossing  this  threshold  does not terminate processing. Range is a floating-point number
           between 0 to 1. Default is 2/3.

       <b>-xerror</b> <b>(</b><u>global</u><b>)</b>
           Stop and exit on error

       <b>-max_muxing_queue_size</b> <u>packets</u> <b>(</b><u>output,per-stream</u><b>)</b>
           When transcoding audio and/or video streams, ffmpeg will not begin writing into the output  until  it
           has  one packet for each such stream. While waiting for that to happen, packets for other streams are
           buffered. This option sets the size of this buffer, in packets, for the matching output stream.

           The default value of this option should be high enough for most uses, so only touch  this  option  if
           you are sure that you need it.

       <b>-muxing_queue_data_threshold</b> <u>bytes</u> <b>(</b><u>output,per-stream</u><b>)</b>
           This  is a minimum threshold until which the muxing queue size is not taken into account. Defaults to
           50 megabytes per stream, and is based on the overall size of packets passed to the muxer.

       <b>-auto_conversion_filters</b> <b>(</b><u>global</u><b>)</b>
           Enable automatically inserting format conversion  filters  in  all  filter  graphs,  including  those
           defined  by <b>-vf</b>, <b>-af</b>, <b>-filter_complex</b> and <b>-lavfi</b>. If filter format negotiation requires a conversion,
           the initialization of the filters will fail.  Conversions can still be  performed  by  inserting  the
           relevant  conversion filter (scale, aresample) in the graph.  On by default, to explicitly disable it
           you need to specify "-noauto_conversion_filters".

       <b>-bits_per_raw_sample[:</b><u>stream_specifier</u><b>]</b> <u>value</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Declare the number of bits per raw sample in the given output stream to  be  <u>value</u>.  Note  that  this
           option  sets  the information provided to the encoder/muxer, it does not change the stream to conform
           to this value. Setting values that do not match the stream properties may result in encoding failures
           or invalid output files.

       <b>-stats_enc_pre[:</b><u>stream_specifier</u><b>]</b> <u>path</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-stats_enc_post[:</b><u>stream_specifier</u><b>]</b> <u>path</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-stats_mux_pre[:</b><u>stream_specifier</u><b>]</b> <u>path</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Write per-frame encoding information about the matching streams into the file given by <u>path</u>.

           <b>-stats_enc_pre</b> writes information about raw video or audio frames right  before  they  are  sent  for
           encoding,  while  <b>-stats_enc_post</b>  writes information about encoded packets as they are received from
           the encoder.  <b>-stats_mux_pre</b> writes information about packets just as they are about to  be  sent  to
           the  muxer. Every frame or packet produces one line in the specified file. The format of this line is
           controlled by <b>-stats_enc_pre_fmt</b> / <b>-stats_enc_post_fmt</b> / <b>-stats_mux_pre_fmt</b>.

           When stats for multiple streams are written into a single file, the lines corresponding to  different
           streams  will  be  interleaved.  The  precise  order  of  this  interleaving is not specified and not
           guaranteed to remain stable between different invocations of the program, even with the same options.

       <b>-stats_enc_pre_fmt[:</b><u>stream_specifier</u><b>]</b> <u>format_spec</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-stats_enc_post_fmt[:</b><u>stream_specifier</u><b>]</b> <u>format_spec</u> <b>(</b><u>output,per-stream</u><b>)</b>
       <b>-stats_mux_pre_fmt[:</b><u>stream_specifier</u><b>]</b> <u>format_spec</u> <b>(</b><u>output,per-stream</u><b>)</b>
           Specify the format for the lines written with <b>-stats_enc_pre</b> / <b>-stats_enc_post</b> / <b>-stats_mux_pre</b>.

           <u>format_spec</u> is a string that may contain directives of the  form  <u>{fmt}</u>.  <u>format_spec</u>  is  backslash-
           escaped --- use \{, \}, and \\ to write a literal {, }, or \, respectively, into the output.

           The directives given with <u>fmt</u> may be one of the following:

           <b>fidx</b>
               Index of the output file.

           <b>sidx</b>
               Index of the output stream in the file.

           <b>n</b>   Frame  number.  Pre-encoding: number of frames sent to the encoder so far.  Post-encoding: number
               of packets received from the encoder so far.  Muxing: number of packets submitted  to  the  muxer
               for this stream so far.

           <b>ni</b>  Input  frame number. Index of the input frame (i.e. output by a decoder) that corresponds to this
               output frame or packet. -1 if unavailable.

           <b>tb</b>  Timebase in which this frame/packet's timestamps are expressed, as  a  rational  number  <u>num/den</u>.
               Note that encoder and muxer may use different timebases.

           <b>tbi</b> Timebase for <u>ptsi</u>, as a rational number <u>num/den</u>. Available when <u>ptsi</u> is available, <u>0/1</u> otherwise.

           <b>pts</b> Presentation  timestamp  of  the  frame  or  packet,  as  an integer. Should be multiplied by the
               timebase to compute presentation time.

           <b>ptsi</b>
               Presentation timestamp of the input frame (see <u>ni</u>), as an integer. Should be multiplied by <u>tbi</u> to
               compute presentation time. Printed as (2^63 - 1 = 9223372036854775807) when not available.

           <b>t</b>   Presentation time of the frame or packet, as a decimal number. Equal to <u>pts</u> multiplied by <u>tb</u>.

           <b>ti</b>  Presentation time of the input frame (see <u>ni</u>), as a decimal number. Equal to <u>ptsi</u>  multiplied  by
               <u>tbi</u>. Printed as inf when not available.

           <b>dts</b> <b>(</b><u>packet</u><b>)</b>
               Decoding  timestamp of the packet, as an integer. Should be multiplied by the timebase to compute
               presentation time.

           <b>dt</b> <b>(</b><u>packet</u><b>)</b>
               Decoding time of the frame or packet, as a decimal number. Equal to <u>dts</u> multiplied by <u>tb</u>.

           <b>sn</b> <b>(</b><u>frame,audio</u><b>)</b>
               Number of audio samples sent to the encoder so far.

           <b>samp</b> <b>(</b><u>frame,audio</u><b>)</b>
               Number of audio samples in the frame.

           <b>size</b> <b>(</b><u>packet</u><b>)</b>
               Size of the encoded packet in bytes.

           <b>br</b> <b>(</b><u>packet</u><b>)</b>
               Current bitrate in bits per second.

           <b>abr</b> <b>(</b><u>packet</u><b>)</b>
               Average bitrate for the whole stream so far, in bits per second, -1 if it cannot be determined at
               this point.

           <b>key</b> <b>(</b><u>packet</u><b>)</b>
               Character 'K' if the packet contains a keyframe, character 'N' otherwise.

           Directives tagged with <u>packet</u> may only be used with <b>-stats_enc_post_fmt</b> and <b>-stats_mux_pre_fmt</b>.

           Directives tagged with <u>frame</u> may only be used with <b>-stats_enc_pre_fmt</b>.

           Directives tagged with <u>audio</u> may only be used with audio streams.

           The default format strings are:

           <b>pre-encoding</b>
               {fidx} {sidx} {n} {t}

           <b>post-encoding</b>
               {fidx} {sidx} {n} {t}

           In the future, new items may be added to the end of the default formatting strings. Users who  depend
           on the format staying exactly the same, should prescribe it manually.

           Note that stats for different streams written into the same file may have different formats.

   <b>Preset</b> <b>files</b>
       A  preset  file  contains  a  sequence of <u>option</u>=<u>value</u> pairs, one for each line, specifying a sequence of
       options which would be awkward to specify on the  command  line.  Lines  starting  with  the  hash  ('#')
       character  are ignored and are used to provide comments. Check the <u>presets</u> directory in the FFmpeg source
       tree for examples.

       There are two types of preset files: ffpreset and avpreset files.

       <u>ffpreset</u> <u>files</u>

       ffpreset files are specified with the "vpre", "apre", "spre", and "fpre" options. The "fpre" option takes
       the filename of the preset instead of a preset name as input and can be used for any kind of  codec.  For
       the  "vpre",  "apre",  and  "spre"  options,  the  options  specified in a preset file are applied to the
       currently selected codec of the same type as the preset option.

       The argument passed to the "vpre", "apre", and "spre" preset options identifies the preset  file  to  use
       according to the following rules:

       First  ffmpeg  searches  for  a  file named <u>arg</u>.ffpreset in the directories <u>$FFMPEG_DATADIR</u> (if set), and
       <u>$HOME/.ffmpeg</u>, and in the datadir defined at configuration time (usually  <u>PREFIX/share/ffmpeg</u>)  or  in  a
       <u>ffpresets</u>  folder  along  the  executable  on  win32,  in  that  order.  For  example, if the argument is
       "libvpx-1080p", it will search for the file <u>libvpx-1080p.ffpreset</u>.

       If no such file is found, then ffmpeg will search for a file named <u>codec_name</u>-<u>arg</u>.ffpreset in the  above-
       mentioned directories, where <u>codec_name</u> is the name of the codec to which the preset file options will be
       applied.  For example, if you select the video codec with "-vcodec libvpx" and use "-vpre 1080p", then it
       will search for the file <u>libvpx-1080p.ffpreset</u>.

       <u>avpreset</u> <u>files</u>

       avpreset files are specified with the "pre" option. They work similar to ffpreset files,  but  they  only
       allow encoder- specific options. Therefore, an <u>option</u>=<u>value</u> pair specifying an encoder cannot be used.

       When  the  "pre"  option  is  specified,  ffmpeg  will  look  for  files with the suffix .avpreset in the
       directories <u>$AVCONV_DATADIR</u> (if set), and <u>$HOME/.avconv</u>, and in the datadir defined at configuration time
       (usually <u>PREFIX/share/ffmpeg</u>), in that order.

       First ffmpeg searches for a file named <u>codec_name</u>-<u>arg</u>.avpreset in the above-mentioned directories,  where
       <u>codec_name</u> is the name of the codec to which the preset file options will be applied. For example, if you
       select  the  video  codec  with  "-vcodec  libvpx" and use "-pre 1080p", then it will search for the file
       <u>libvpx-1080p.avpreset</u>.

       If no such file is found, then ffmpeg will search for a file named <u>arg</u>.avpreset in the same directories.

   <b>vstats</b> <b>file</b> <b>format</b>
       The "-vstats" and "-vstats_file" options enable generation of a  file  containing  statistics  about  the
       generated video outputs.

       The "-vstats_version" option controls the format version of the generated file.

       With version 1 the format is:

               frame= &lt;FRAME&gt; q= &lt;FRAME_QUALITY&gt; PSNR= &lt;PSNR&gt; f_size= &lt;FRAME_SIZE&gt; s_size= &lt;STREAM_SIZE&gt;kB time= &lt;TIMESTAMP&gt; br= &lt;BITRATE&gt;kbits/s avg_br= &lt;AVERAGE_BITRATE&gt;kbits/s

       With version 2 the format is:

               out= &lt;OUT_FILE_INDEX&gt; st= &lt;OUT_FILE_STREAM_INDEX&gt; frame= &lt;FRAME_NUMBER&gt; q= &lt;FRAME_QUALITY&gt;f PSNR= &lt;PSNR&gt; f_size= &lt;FRAME_SIZE&gt; s_size= &lt;STREAM_SIZE&gt;kB time= &lt;TIMESTAMP&gt; br= &lt;BITRATE&gt;kbits/s avg_br= &lt;AVERAGE_BITRATE&gt;kbits/s

       The value corresponding to each key is described below:

       <b>avg_br</b>
           average bitrate expressed in Kbits/s

       <b>br</b>  bitrate expressed in Kbits/s

       <b>frame</b>
           number of encoded frame

       <b>out</b> out file index

       <b>PSNR</b>
           Peak Signal to Noise Ratio

       <b>q</b>   quality of the frame

       <b>f_size</b>
           encoded packet size expressed as number of bytes

       <b>s_size</b>
           stream size expressed in KiB

       <b>st</b>  out file stream index

       <b>time</b>
           time of the packet

       <b>type</b>
           picture type

       See also the <b>-stats_enc</b> <b>options</b> for an alternative way to show encoding statistics.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Video</b> <b>and</b> <b>Audio</b> <b>grabbing</b>
       If you specify the input format and device then ffmpeg can grab video and audio directly.

               ffmpeg -f oss -i /dev/dsp -f video4linux2 -i /dev/video0 /tmp/out.mpg

       Or with an ALSA audio source (mono input, card id 1) instead of OSS:

               ffmpeg -f alsa -ac 1 -i hw:1 -f video4linux2 -i /dev/video0 /tmp/out.mpg

       Note that you must activate the right video source and channel before launching ffmpeg with any TV viewer
       such  as &lt;<b><a href="http://linux.bytesex.org/xawtv/">http://linux.bytesex.org/xawtv/</a></b>&gt; by Gerd Knorr. You also have to set the audio recording levels
       correctly with a standard mixer.

   <b>X11</b> <b>grabbing</b>
       Grab the X11 display with ffmpeg via

               ffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0 /tmp/out.mpg

       0.0 is display.screen number of your X11 server, same as the DISPLAY environment variable.

               ffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0+10,20 /tmp/out.mpg

       0.0 is display.screen number of your X11 server, same as the DISPLAY  environment  variable.  10  is  the
       x-offset and 20 the y-offset for the grabbing.

   <b>Video</b> <b>and</b> <b>Audio</b> <b>file</b> <b>format</b> <b>conversion</b>
       Any supported file format and protocol can serve as input to ffmpeg:

       Examples:

       •   You can use YUV files as input:

                   ffmpeg -i /tmp/test%d.Y /tmp/out.mpg

           It will use the files:

                   /tmp/test0.Y, /tmp/test0.U, /tmp/test0.V,
                   /tmp/test1.Y, /tmp/test1.U, /tmp/test1.V, etc...

           The  Y  files use twice the resolution of the U and V files. They are raw files, without header. They
           can be generated by all decent video decoders. You must specify the size of the  image  with  the  <b>-s</b>
           option if ffmpeg cannot guess it.

       •   You can input from a raw YUV420P file:

                   ffmpeg -i /tmp/test.yuv /tmp/out.avi

           test.yuv  is a file containing raw YUV planar data. Each frame is composed of the Y plane followed by
           the U and V planes at half vertical and horizontal resolution.

       •   You can output to a raw YUV420P file:

                   ffmpeg -i mydivx.avi hugefile.yuv

       •   You can set several input files and output files:

                   ffmpeg -i /tmp/a.wav -s 640x480 -i /tmp/a.yuv /tmp/a.mpg

           Converts the audio file a.wav and the raw YUV video file a.yuv to MPEG file a.mpg.

       •   You can also do audio and video conversions at the same time:

                   ffmpeg -i /tmp/a.wav -ar 22050 /tmp/a.mp2

           Converts a.wav to MPEG audio at 22050 Hz sample rate.

       •   You can encode to several formats at the same time and define a mapping from input stream  to  output
           streams:

                   ffmpeg -i /tmp/a.wav -map 0:a -b:a 64k /tmp/a.mp2 -map 0:a -b:a 128k /tmp/b.mp2

           Converts  a.wav  to  a.mp2  at  64 kbits and to b.mp2 at 128 kbits. '-map file:index' specifies which
           input stream is used for each output stream, in the order of the definition of output streams.

       •   You can transcode decrypted VOBs:

                   ffmpeg -i snatch_1.vob -f avi -c:v mpeg4 -b:v 800k -g 300 -bf 2 -c:a libmp3lame -b:a 128k snatch.avi

           This is a typical DVD ripping example; the input is a VOB file, the output an AVI  file  with  MPEG-4
           video  and  MP3  audio.  Note  that  in  this  command  we use B-frames so the MPEG-4 stream is DivX5
           compatible, and GOP size is 300 which means one intra frame  every  10  seconds  for  29.97fps  input
           video.  Furthermore,  the  audio  stream is MP3-encoded so you need to enable LAME support by passing
           "--enable-libmp3lame" to configure.  The mapping is particularly useful for DVD  transcoding  to  get
           the desired audio language.

           NOTE: To see the supported input formats, use "ffmpeg -demuxers".

       •   You can extract images from a video, or create a video from many images:

           For extracting images from a video:

                   ffmpeg -i foo.avi -r 1 -s WxH -f image2 foo-%03d.jpeg

           This  will  extract  one  video  frame  per second from the video and will output them in files named
           <u>foo-001.jpeg</u>, <u>foo-002.jpeg</u>, etc. Images will be rescaled to fit the new WxH values.

           If you want to extract just a limited number of frames, you can use the above command in  combination
           with  the  "-frames:v"  or "-t" option, or in combination with -ss to start extracting from a certain
           point in time.

           For creating a video from many images:

                   ffmpeg -f image2 -framerate 12 -i foo-%03d.jpeg -s WxH foo.avi

           The syntax "foo-%03d.jpeg" specifies to use a decimal number composed of  three  digits  padded  with
           zeroes  to express the sequence number. It is the same syntax supported by the C printf function, but
           only formats accepting a normal integer are suitable.

           When importing an image sequence, -i also supports expanding shell-like wildcard patterns  (globbing)
           internally, by selecting the image2-specific "-pattern_type glob" option.

           For example, for creating a video from filenames matching the glob pattern "foo-*.jpeg":

                   ffmpeg -f image2 -pattern_type glob -framerate 12 -i 'foo-*.jpeg' -s WxH foo.avi

       •   You can put many streams of the same type in the output:

                   ffmpeg -i test1.avi -i test2.avi -map 1:1 -map 1:0 -map 0:1 -map 0:0 -c copy -y test12.nut

           The  resulting  output  file  <u>test12.nut</u>  will contain the first four streams from the input files in
           reverse order.

       •   To force CBR video output:

                   ffmpeg -i myfile.avi -b 4000k -minrate 4000k -maxrate 4000k -bufsize 1835k out.m2v

       •   The four options lmin, lmax, mblmin and mblmax use 'lambda' units, but  you  may  use  the  QP2LAMBDA
           constant to easily convert from 'q' units:

                   ffmpeg -i src.ext -lmax 21*QP2LAMBDA dst.ext

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/ffmpeg-all.1.html">ffmpeg-all</a></b>(1),    <b><a href="../man1/ffplay.1.html">ffplay</a></b>(1),    <b><a href="../man1/ffprobe.1.html">ffprobe</a></b>(1),   <b><a href="../man1/ffmpeg-utils.1.html">ffmpeg-utils</a></b>(1),   <b><a href="../man1/ffmpeg-scaler.1.html">ffmpeg-scaler</a></b>(1),   <b><a href="../man1/ffmpeg-resampler.1.html">ffmpeg-resampler</a></b>(1),
       <b><a href="../man1/ffmpeg-codecs.1.html">ffmpeg-codecs</a></b>(1), <b><a href="../man1/ffmpeg-bitstream-filters.1.html">ffmpeg-bitstream-filters</a></b>(1), <b><a href="../man1/ffmpeg-formats.1.html">ffmpeg-formats</a></b>(1), <b><a href="../man1/ffmpeg-devices.1.html">ffmpeg-devices</a></b>(1), <b><a href="../man1/ffmpeg-protocols.1.html">ffmpeg-protocols</a></b>(1),
       <b><a href="../man1/ffmpeg-filters.1.html">ffmpeg-filters</a></b>(1)

</pre><h4><b>AUTHORS</b></h4><pre>
       The FFmpeg developers.

       For details about the authorship, see the Git history  of  the  project  (https://git.ffmpeg.org/ffmpeg),
       e.g.  by  typing the command <b>git</b> <b>log</b> in the FFmpeg source directory, or browsing the online repository at
       &lt;<b>https://git.ffmpeg.org/ffmpeg</b>&gt;.

       Maintainers for the specific components are listed in the file <u>MAINTAINERS</u> in the source code tree.

                                                                                                       <u><a href="../man1/FFMPEG.1.html">FFMPEG</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>