<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>parallel - build and execute shell command lines from standard input in parallel</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/parallel">parallel_20240222+ds-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       parallel - build and execute shell command lines from standard input in parallel

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>parallel</b> [options] [<u>command</u> [arguments]] &lt; list_of_arguments

       <b>parallel</b> [options] [<u>command</u> [arguments]] ( <b>:::</b> arguments | <b>:::+</b> arguments | <b>::::</b> argfile(s) | <b>::::+</b>
       argfile(s) ) ...

       <b>parallel</b> --semaphore [options] <u>command</u>

       <b>#!/usr/bin/parallel</b> --shebang [options] [<u>command</u> [arguments]]

       <b>#!/usr/bin/parallel</b> --shebang-wrap [options] [<u>command</u> [arguments]]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       STOP!

       Read the <b>Reader's</b> <b>guide</b> below if you are new to GNU <b>parallel</b>.

       GNU <b>parallel</b> is a shell tool for executing jobs in parallel using one or more computers. A job can be a
       single command or a small script that has to be run for each of the lines in the input. The typical input
       is a list of files, a list of hosts, a list of users, a list of URLs, or a list of tables. A job can also
       be a command that reads from a pipe. GNU <b>parallel</b> can then split the input into blocks and pipe a block
       into each command in parallel.

       If you use xargs and tee today you will find GNU <b>parallel</b> very easy to use as GNU <b>parallel</b> is written to
       have the same options as xargs. If you write loops in shell, you will find GNU <b>parallel</b> may be able to
       replace most of the loops and make them run faster by running several jobs in parallel.

       GNU <b>parallel</b> makes sure output from the commands is the same output as you would get had you run the
       commands sequentially. This makes it possible to use output from GNU <b>parallel</b> as input for other
       programs.

       For each line of input GNU <b>parallel</b> will execute <u>command</u> with the line as arguments. If no <u>command</u> is
       given, the line of input is executed. Several lines will be run in parallel. GNU <b>parallel</b> can often be
       used as a substitute for <b>xargs</b> or <b>cat</b> <b>|</b> <b>bash</b>.

   <b>Reader's</b> <b>guide</b>
       GNU <b>parallel</b> includes the 4 types of documentation: Tutorial, how-to, reference and explanation/design.

       <u>Tutorial</u>

       If you prefer reading a book buy <b>GNU</b> <b>Parallel</b> <b>2018</b> at
       https://www.lulu.com/shop/ole-tange/gnu-parallel-2018/paperback/product-23558902.html or download it at:
       https://doi.org/10.5281/zenodo.1146014 Read at least chapter 1+2. It should take you less than 20
       minutes.

       Otherwise start by watching the intro videos for a quick introduction:
       https://youtube.com/playlist?list=PL284C9FF2488BC6D1

       If you want to dive deeper: spend a couple of hours walking through the tutorial (<b>man</b> <b>parallel_tutorial</b>).
       Your command line will love you for it.

       <u>How-to</u>

       You can find a lot of examples of use in <b>man</b> <b>parallel_examples</b>. They will give you an idea of what GNU
       <b>parallel</b> is capable of, and you may find a solution you can simply adapt to your situation.

       If the example do not cover your exact needs, the options map
       (https://www.gnu.org/software/parallel/parallel_options_map.pdf) can help you identify options that are
       related, so you can look these up in the man page.

       <u>Reference</u>

       If you need a one page printable cheat sheet you can find it on:
       https://www.gnu.org/software/parallel/parallel_cheat.pdf

       The man page is the reference for all options, and reading the man page from cover to cover is probably
       not what you need.

       <u>Design</u> <u>discussion</u>

       If you want to know the design decisions behind GNU <b>parallel</b>, try: <b>man</b> <b>parallel_design</b>. This is also a
       good intro if you intend to change GNU <b>parallel</b>.

</pre><h4><b>OPTIONS</b></h4><pre>
       <u>command</u>
           Command to execute.

           If <u>command</u> or the following arguments contain replacement strings (such as <b>{}</b>) every instance will be
           substituted with the input.

           If <u>command</u> is given, GNU <b>parallel</b> solve the same tasks as <b>xargs</b>. If <u>command</u> is not given GNU <b>parallel</b>
           will behave similar to <b>cat</b> <b>|</b> <b>sh</b>.

           The <u>command</u> must be an executable, a script, a composed command, an alias, or a function.

           <b>Bash</b> <b>functions</b>: <b>export</b> <b>-f</b> the function first or use <b>env_parallel</b>.

           <b>Bash,</b> <b>Csh,</b> <b>or</b> <b>Tcsh</b> <b>aliases</b>: Use <b>env_parallel</b>.

           <b>Zsh,</b> <b>Fish,</b> <b>Ksh,</b> <b>and</b> <b>Pdksh</b> <b>functions</b> <b>and</b> <b>aliases</b>: Use <b>env_parallel</b>.

       <b>{}</b>  Input line.

           This  replacement string will be replaced by a full line read from the input source. The input source
           is normally stdin (standard input), but can also be given with <b>--arg-file</b>, <b>:::</b>, or <b>::::</b>.

           The replacement string <b>{}</b> can be changed with <b>-I</b>.

           If the command line contains no replacement strings then <b>{}</b> will be appended to the command line.

           Replacement strings are normally quoted, so special characters are  not  parsed  by  the  shell.  The
           exception is if the command starts with a replacement string; then the string is not quoted.

           See also: <b>--plus</b> <b>{.}</b> <b>{/}</b> <b>{//}</b> <b>{<a href="file:/.">/.</a>}</b> <b>{#}</b> <b>{%}</b> <b>{</b><u>n</u><b>}</b> <b>{=</b><u>perl</u> <u>expression</u><b>=}</b>

       <b>{.}</b> Input line without extension.

           This  replacement  string will be replaced by the input with the extension removed. If the input line
           contains <b>.</b> after the last <b>/</b>, the last <b>.</b> until the end of the string will be removed and <b>{.}</b>  will  be
           replaced   with   the  remaining.  E.g.  <u>foo.jpg</u>  becomes  <u>foo</u>,  <u>subdir/foo.jpg</u>  becomes  <u>subdir/foo</u>,
           <u>sub.dir/foo.jpg</u> becomes <u>sub.dir/foo</u>, <u>sub.dir/bar</u> remains <u>sub.dir/bar</u>. If  the  input  line  does  not
           contain <b>.</b> it will remain unchanged.

           The replacement string <b>{.}</b> can be changed with <b>--extensionreplace</b>

           See also: <b>{}</b> <b>--extensionreplace</b>

       <b>{/}</b> Basename of input line.

           This replacement string will be replaced by the input with the directory part removed.

           See also: <b>{}</b> <b>--basenamereplace</b>

       <b>{//}</b>
           Dirname of input line.

           This replacement string will be replaced by the dir of the input line. See <b><a href="../man1/dirname.1.html">dirname</a></b>(1).

           See also: <b>{}</b> <b>--dirnamereplace</b>

       <b>{<a href="file:/.">/.</a>}</b>
           Basename of input line without extension.

           This  replacement string will be replaced by the input with the directory and extension part removed.
           <b>{<a href="file:/.">/.</a>}</b> is a combination of <b>{/}</b> and <b>{.}</b>.

           See also: <b>{}</b> <b>--basenameextensionreplace</b>

       <b>{#}</b> Sequence number of the job to run.

           This replacement string will be replaced by the sequence number of the job being run. It contains the
           same number as $PARALLEL_SEQ.

           See also: <b>{}</b> <b>--seqreplace</b>

       <b>{%}</b> Job slot number.

           This replacement string will be replaced by the job's slot number between 1 and number of jobs to run
           in parallel. There will never be 2 jobs running at the same time with the same job slot number.

           If the job needs to be  retried  (e.g  using  <b>--retries</b>  or  <b>--retry-failed</b>)  the  job  slot  is  not
           automatically updated. You should then instead use <b>$PARALLEL_JOBSLOT</b>:

             $ do_test() {
                 id="$3 {%}=$1 PARALLEL_JOBSLOT=$2"
                 echo run "$id";
                 sleep 1
                 # fail if {%} is odd
                 return `echo $1%2 | bc`
               }
             $ export -f do_test
             $ parallel -j3 --jl mylog do_test {%} \$PARALLEL_JOBSLOT {} ::: A B C D
             run A {%}=1 PARALLEL_JOBSLOT=1
             run B {%}=2 PARALLEL_JOBSLOT=2
             run C {%}=3 PARALLEL_JOBSLOT=3
             run D {%}=1 PARALLEL_JOBSLOT=1
             $ parallel --retry-failed -j3 --jl mylog do_test {%} \$PARALLEL_JOBSLOT {} ::: A B C D
             run A {%}=1 PARALLEL_JOBSLOT=1
             run C {%}=3 PARALLEL_JOBSLOT=2
             run D {%}=1 PARALLEL_JOBSLOT=3

           Notice how {%} and $PARALLEL_JOBSLOT differ in the retry run of C and D.

           See also: <b>{}</b> <b>--jobs</b> <b>--slotreplace</b>

       <b>{</b><u>n</u><b>}</b> Argument from input source <u>n</u> or the <u>n</u>'th argument.

           This  positional replacement string will be replaced by the input from input source <u>n</u> (when used with
           <b>--arg-file</b> or <b>::::</b>) or with the <u>n</u>'th argument (when used with <b>-N</b>). If <u>n</u> is negative it refers to  the
           <u>n</u>'th last argument.

           See also: <b>{}</b> <b>{</b><u>n</u>.<b>}</b> <b>{</b><u>n</u>/<b>}</b> <b>{</b><u>n</u>//<b>}</b> <b>{</b><u>n</u><a href="file:/.">/.</a><b>}</b>

       <b>{</b><u>n</u>.<b>}</b>
           Argument from input source <u>n</u> or the <u>n</u>'th argument without extension.

           <b>{</b><u>n</u>.<b>}</b> is a combination of <b>{</b><u>n</u><b>}</b> and <b>{.}</b>.

           This  positional replacement string will be replaced by the input from input source <u>n</u> (when used with
           <b>--arg-file</b> or <b>::::</b>) or with the <u>n</u>'th argument (when used with <b>-N</b>). The input will have the  extension
           removed.

           See also: <b>{</b><u>n</u><b>}</b> <b>{.}</b>

       <b>{</b><u>n</u>/<b>}</b>
           Basename of argument from input source <u>n</u> or the <u>n</u>'th argument.

           <b>{</b><u>n</u>/<b>}</b> is a combination of <b>{</b><u>n</u><b>}</b> and <b>{/}</b>.

           This  positional replacement string will be replaced by the input from input source <u>n</u> (when used with
           <b>--arg-file</b> or <b>::::</b>) or with the <u>n</u>'th argument (when used with <b>-N</b>). The input will have the  directory
           (if any) removed.

           See also: <b>{</b><u>n</u><b>}</b> <b>{/}</b>

       <b>{</b><u>n</u>//<b>}</b>
           Dirname of argument from input source <u>n</u> or the <u>n</u>'th argument.

           <b>{</b><u>n</u>//<b>}</b> is a combination of <b>{</b><u>n</u><b>}</b> and <b>{//}</b>.

           This positional replacement string will be replaced by the dir of the input from input source <u>n</u> (when
           used with <b>--arg-file</b> or <b>::::</b>) or with the <u>n</u>'th argument (when used with <b>-N</b>). See <b><a href="../man1/dirname.1.html">dirname</a></b>(1).

           See also: <b>{</b><u>n</u><b>}</b> <b>{//}</b>

       <b>{</b><u>n</u><a href="file:/.">/.</a><b>}</b>
           Basename of argument from input source <u>n</u> or the <u>n</u>'th argument without extension.

           <b>{</b><u>n</u><a href="file:/.">/.</a><b>}</b> is a combination of <b>{</b><u>n</u><b>}</b>, <b>{/}</b>, and <b>{.}</b>.

           This  positional replacement string will be replaced by the input from input source <u>n</u> (when used with
           <b>--arg-file</b> or <b>::::</b>) or with the <u>n</u>'th argument (when used with <b>-N</b>). The input will have the  directory
           (if any) and extension removed.

           See also: <b>{</b><u>n</u><b>}</b> <b>{<a href="file:/.">/.</a>}</b>

       <b>{=</b><u>perl</u> <u>expression</u><b>=}</b>
           Replace with calculated <u>perl</u> <u>expression</u>.

           <b>$_</b>  will contain the same as <b>{}</b>. After evaluating <u>perl</u> <u>expression</u> <b>$_</b> will be used as the value. It is
           recommended to only change $_ but you have full access to all of GNU  <b>parallel</b>'s  internal  functions
           and data structures.

           The  expression  must give the same result if evaluated twice - otherwise the behaviour is undefined.
           E.g. in some versions of GNU <b>parallel</b> this will not work as expected:

               parallel echo '{= $_= ++$wrong_counter =}' ::: a b c

           A few convenience functions and data structures have been made:

            <b>Q(</b><u>string</u><b>)</b>
             Shell quote a string. Example:

               parallel echo {} is quoted as '{= $_=Q($_) =}' ::: \$PWD

            <b>pQ(</b><u>string</u><b>)</b>
             Perl quote a string. Example:

               parallel echo {} is quoted as '{= $_=pQ($_) =}' ::: \$PWD

            <b>uq()</b> (or <b>uq</b>)
             Do not quote current replacement string. Example:

               parallel echo {} has the value '{= uq =}' ::: \$PWD

            <b>hash(val)</b>
             Compute B::hash(val). Example:

               parallel echo Hash of {} is '{= $_=hash($_) =}' ::: a b c

            <b>total_jobs()</b>
             Number of jobs in total. Example:

               parallel echo Number of jobs: '{= $_=total_jobs() =}' ::: a b c

            <b>slot()</b>
             Slot number of job. Example:

               parallel echo Job slot of {} is '{= $_=slot() =}' ::: a b c

            <b>seq()</b>
             Sequence number of job. Example:

               parallel echo Seq number of {} is '{= $_=seq() =}' ::: a b c

            <b>@arg</b>
             The arguments counting from 1 ($arg[1] = {1} = first argument). Example:

               parallel echo {1}+{2}='{=1 $_=$arg[1]+$arg[2] =}' \
                 ::: 1 2 3 ::: 2 3 4

             ('{=1' forces this to be a positional replacement string, and therefore will not repeat  the  value
             for each arg.)

            <b>skip()</b>
             Skip this job (see also <b>--filter</b>). Example:

               parallel echo '{= $arg[1] &gt;= $arg[2] and skip =}' \
                 ::: 1 2 3 ::: 2 3 4

            <b>yyyy_mm_dd_hh_mm_ss(sec)</b>
            <b>yyyy_mm_dd_hh_mm(sec)</b>
            <b>yyyy_mm_dd(sec)</b>
            <b>hh_mm_ss(sec)</b>
            <b>hh_mm(sec)</b>
            <b>yyyymmddhhmmss(sec)</b>
            <b>yyyymmddhhmm(sec)</b>
            <b>yyyymmdd(sec)</b>
            <b>hhmmss(sec)</b>
            <b>hhmm(sec)</b>
             Time  functions.  <u>sec</u> is number of seconds since epoch. If left out it will use current local time.
             Example:

               parallel echo 'Now: {= $_=yyyy_mm_dd_hh_mm_ss() =}' ::: Dummy
               parallel echo 'The end: {= $_=yyyy_mm_dd_hh_mm_ss($_) =}' \
                 ::: 2147483648

           Example:

             seq 10 | parallel echo {} + 1 is {= '$_++' =}
             parallel csh -c {= '$_="mkdir ".Q($_)' =} ::: '12" dir'
             seq 50 | parallel echo job {#} of {= '$_=total_jobs()' =}

           See also: <b>--rpl</b> <b>--parens</b> <b>{}</b> <b>{=</b><u>n</u> <u>perl</u> <u>expression</u><b>=}</b> <b>--filter</b>

       <b>{=</b><u>n</u> <u>perl</u> <u>expression</u><b>=}</b>
           Positional equivalent to <b>{=</b><u>perl</u> <u>expression</u><b>=}</b>.

           To understand positional replacement strings see <b>{</b><u>n</u><b>}</b>.

           See also: <b>{=</b><u>perl</u> <u>expression</u><b>=}</b> <b>{</b><u>n</u><b>}</b>

       <b>:::</b> <u>arguments</u>
           Use arguments on the command line as input source.

           Unlike other options for GNU <b>parallel</b> <b>:::</b> is placed after the <u>command</u> and before the arguments.

           The following are equivalent:

             (echo file1; echo file2) | parallel gzip
             parallel gzip ::: file1 file2
             parallel gzip {} ::: file1 file2
             parallel --arg-sep ,, gzip {} ,, file1 file2
             parallel --arg-sep ,, gzip ,, file1 file2
             parallel ::: "gzip file1" "gzip file2"

           To avoid treating <b>:::</b> as special use <b>--arg-sep</b> to set the argument separator to something else.

           If multiple <b>:::</b> are given, each group will be treated as an input source,  and  all  combinations  of
           input  sources  will be generated. E.g. ::: 1 2 ::: a b c will result in the combinations (1,a) (1,b)
           (1,c) (2,a) (2,b) (2,c). This is useful for replacing nested for-loops.

           <b>:::</b>, <b>::::</b>, and <b>--arg-file</b> can be mixed. So these are equivalent:

             parallel echo {1} {2} {3} ::: 6 7 ::: 4 5 ::: 1 2 3
             parallel echo {1} {2} {3} :::: &lt;(seq 6 7) &lt;(seq 4 5) \
               :::: &lt;(seq 1 3)
             parallel -a &lt;(seq 6 7) echo {1} {2} {3} :::: &lt;(seq 4 5) \
               :::: &lt;(seq 1 3)
             parallel -a &lt;(seq 6 7) -a &lt;(seq 4 5) echo {1} {2} {3} \
               ::: 1 2 3
             seq 6 7 | parallel -a - -a &lt;(seq 4 5) echo {1} {2} {3} \
               ::: 1 2 3
             seq 4 5 | parallel echo {1} {2} {3} :::: &lt;(seq 6 7) - \
               ::: 1 2 3

           See also: <b>--arg-sep</b> <b>--arg-file</b> <b>::::</b> <b>:::+</b> <b>::::+</b> <b>--link</b>

       <b>:::+</b> <u>arguments</u>
           Like <b>:::</b> but linked like <b>--link</b> to the previous input source.

           Contrary to <b>--link</b>, values do not wrap: The shortest input source determines the length.

           Example:

             parallel echo ::: a b c :::+ 1 2 3 ::: X Y :::+ 11 22

           See also: <b>::::+</b> <b>--link</b>

       <b>::::</b> <u>argfiles</u>
           Another way to write <b>--arg-file</b> <u>argfile1</u> <b>--arg-file</b> <u>argfile2</u> ...

           <b>:::</b> and <b>::::</b> can be mixed.

           See also: <b>--arg-file</b> <b>:::</b> <b>::::+</b> <b>--link</b>

       <b>::::+</b> <u>argfiles</u>
           Like <b>::::</b> but linked like <b>--link</b> to the previous input source.

           Contrary to <b>--link</b>, values do not wrap: The shortest input source determines the length.

           See also: <b>--arg-file</b> <b>:::+</b> <b>--link</b>

       <b>--null</b>
       <b>-0</b>  Use NUL as delimiter.

           Normally input lines will end in \n (newline). If they end in \0 (NUL), then use this option.  It  is
           useful for processing arguments that may contain \n (newline).

           Shorthand for <b>--delimiter</b> <b>'\0'</b>.

           See also: <b>--delimiter</b>

       <b>--arg-file</b> <u>input-file</u>
       <b>-a</b> <u>input-file</u>
           Use <u>input-file</u> as input source.

           If  multiple  <b>--arg-file</b>  are  given,  each  <u>input-file</u>  will  be treated as an input source, and all
           combinations of input sources will be generated. E.g. The  file  <b>foo</b>  contains  <b>1</b>  <b>2</b>,  the  file  <b>bar</b>
           contains  <b>a</b>  <b>b</b> <b>c</b>.  <b>-a</b> <b>foo</b> <b>-a</b> <b>bar</b> will result in the combinations (1,a) (1,b) (1,c) (2,a) (2,b) (2,c).
           This is useful for replacing nested for-loops.

           If <u>input-file</u> starts with <b>+</b> the file will be linked to the previous  <b>--arg-file</b>  E.g.  The  file  <b>foo</b>
           contains  <b>1</b> <b>2</b>, the file <b>bar</b> contains <b>a</b> <b>b</b>.  <b>-a</b> <b>foo</b> <b>-a</b> <b>+bar</b> will result in the combinations (1,a) (2,b)
           like <b>--link</b> instead of generating all combinations.

           See also: <b>--link</b> <b>{</b><u>n</u><b>}</b> <b>::::</b> <b>::::+</b> <b>:::</b>

       <b>--arg-file-sep</b> <u>sep-str</u>
           Use <u>sep-str</u> instead of <b>::::</b> as separator string between command and argument files.

           Useful if <b>::::</b> is used for something else by the command.

           See also: <b>::::</b>

       <b>--arg-sep</b> <u>sep-str</u>
           Use <u>sep-str</u> instead of <b>:::</b> as separator string.

           Useful if <b>:::</b> is used for something else by the command.

           Also useful if you command uses <b>:::</b> but you still want to read arguments from stdin (standard input):
           Simply change <b>--arg-sep</b> to a string that is not in the command line.

           See also: <b>:::</b>

       <b>--bar</b>
           Show progress as a progress bar.

           In the bar is shown: % of jobs completed, estimated seconds left, and number of jobs started.

           It is compatible with <b>zenity</b>:

             seq 1000 | parallel -j30 --bar '(echo {};sleep 0.1)' \
               2&gt; &gt;(perl -pe 'BEGIN{$/="\r";$|=1};s/\r/\n/g' |
                    zenity --progress --auto-kill) | wc

           See also: <b>--eta</b> <b>--progress</b> <b>--total-jobs</b>

       <b>--basefile</b> <u>file</u>
       <b>--bf</b> <u>file</u>
           <u>file</u> will be transferred to each sshlogin before first job is started.

           It will be removed if <b>--cleanup</b> is active. The file may be a script to run or some common  base  data
           needed  for  the  job.   Multiple  <b>--bf</b> can be specified to transfer more basefiles. The <u>file</u> will be
           transferred the same way as <b>--transferfile</b>.

           See also: <b>--sshlogin</b> <b>--transfer</b> <b>--return</b> <b>--cleanup</b> <b>--workdir</b>

       <b>--basenamereplace</b> <u>replace-str</u>
       <b>--bnr</b> <u>replace-str</u>
           Use the replacement string <u>replace-str</u> instead of <b>{/}</b> for basename of input line.

           See also: <b>{/}</b>

       <b>--basenameextensionreplace</b> <u>replace-str</u>
       <b>--bner</b> <u>replace-str</u>
           Use the replacement string <u>replace-str</u> instead of <b>{<a href="file:/.">/.</a>}</b> for basename of input line without extension.

           See also: <b>{<a href="file:/.">/.</a>}</b>

       <b>--bin</b> <u>binexpr</u>
           Use <u>binexpr</u> as binning key and bin input to the jobs.

           <u>binexpr</u> is [column number|column name] [perlexpression] e.g.:

             3
             Address
             3 $_%=100
             Address s/\D//g

           Each input line is split using <b>--colsep</b>. The value of the column is put into $_, the perl  expression
           is  executed,  the  resulting  value  is is the job slot that will be given the line. If the value is
           bigger than the number of jobslots the value will be modulo number of jobslots.

           This is similar to <b>--shard</b> but the hashing algorithm is a simple modulo, which makes  it  predictible
           which jobslot will receive which value.

           The  performance is in the order of 100K rows per second. Faster if the <u>bincol</u> is small (&lt;10), slower
           if it is big (&gt;100).

           <b>--bin</b> requires <b>--pipe</b> and a fixed numeric value for <b>--jobs</b>.

           See also: SPREADING BLOCKS OF DATA <b>--group-by</b> <b>--round-robin</b> <b>--shard</b>

       <b>--bg</b>
           Run command in background.

           GNU <b>parallel</b> will normally wait for the completion of a job. With <b>--bg</b> GNU <b>parallel</b> will not wait for
           completion of the command before exiting.

           This is the default if <b>--semaphore</b> is set.

           Implies <b>--semaphore</b>.

           See also: <b>--fg</b> <b>man</b> <b>sem</b>

       <b>--block</b> <u>size</u>
       <b>--block-size</b> <u>size</u>
           Size of block in bytes to read at a time.

           The <u>size</u> can be postfixed with K, M, G, T, P, k, m, g, t, or p.

           GNU <b>parallel</b> tries to meet the block size but can be off by the length of one record. For performance
           reasons <u>size</u> should be bigger than a two records.  GNU  <b>parallel</b>  will  warn  you  and  automatically
           increase the size if you choose a <u>size</u> that is too small.

           If you use <b>-N</b>, <b>--block</b> should be bigger than N+1 records.

           <u>size</u> defaults to 1M.

           When  using  <b>--pipe-part</b> a negative block size is not interpreted as a blocksize but as the number of
           blocks each jobslot should have. So this will run 10*5 = 50 jobs in total:

             parallel --pipe-part -a myfile --block -10 -j5 wc

           This is an efficient alternative to <b>--round-robin</b> because data is never read by GNU <b>parallel</b>, but you
           can still have very few jobslots process large amounts of data.

           See also: UNIT PREFIX <b>-N</b> <b>--pipe</b> <b>--pipe-part</b> <b>--round-robin</b> <b>--block-timeout</b>

       <b>--block-timeout</b> <u>duration</u>
       <b>--bt</b> <u>duration</u>
           Timeout for reading block when using <b>--pipe</b>.

           If it takes longer than <u>duration</u> to read a full block, use the partial block read so far.

           <u>duration</u> is in seconds, but can be postfixed with s, m, h, or d.

           See also: TIME POSTFIXES <b>--pipe</b> <b>--block</b>

       <b>--cat</b>
           Create a temporary file with content.

           Normally <b>--pipe</b>/<b>--pipe-part</b> will give data to the program on stdin (standard input). With  <b>--cat</b>  GNU
           <b>parallel</b>  will  create  a temporary file with the name in <b>{}</b>, so you can do: <b>parallel</b> <b>--pipe</b> <b>--cat</b> <b>wc</b>
           <b>{}</b>.

           Implies <b>--pipe</b> unless <b>--pipe-part</b> is used.

           See also: <b>--pipe</b> <b>--pipe-part</b> <b>--fifo</b>

       <b>--cleanup</b>
           Remove transferred files.

           <b>--cleanup</b> will remove the transferred files on the remote computer after processing is done.

             find log -name '*gz' | parallel \
               --sshlogin server.example.com --transferfile {} \
               --return {.}.bz2 --cleanup "zcat {} | bzip -9 &gt;{.}.bz2"

           With <b>--transferfile</b> <b>{}</b> the file transferred to the remote computer will  be  removed  on  the  remote
           computer. Directories on the remote computer containing the file will be removed if they are empty.

           With  <b>--return</b>  the file transferred from the remote computer will be removed on the remote computer.
           Directories on the remote computer containing the file will be removed if they are empty.

           <b>--cleanup</b> is ignored when not used with <b>--basefile</b>, <b>--transfer</b>, <b>--transferfile</b> or <b>--return</b>.

           See also: <b>--basefile</b> <b>--transfer</b> <b>--transferfile</b> <b>--sshlogin</b> <b>--return</b>

       <b>--color</b>
           Colour output.

           Colour the output. Each job gets its own colour combination (background+foreground).

           <b>--color</b> is ignored when using <b>-u</b>.

           See also: <b>--color-failed</b>

       <b>--color-failed</b>
       <b>--cf</b>
           Colour the output from failing jobs white on red.

           Useful if you have a lot of jobs and want to focus on the failing jobs.

           <b>--color-failed</b> is ignored when using <b>-u</b>, <b>--line-buffer</b> and unreliable when using <b>--latest-line</b>.

           See also: <b>--color</b>

       <b>--colsep</b> <u>regexp</u>
       <b>-C</b> <u>regexp</u>
           Column separator.

           The input will be treated as a table with <u>regexp</u> separating the  columns.  The  n'th  column  can  be
           accessed using <b>{</b><u>n</u><b>}</b> or <b>{</b><u>n</u>.<b>}</b>. E.g. <b>{3}</b> is the 3rd column.

           If there are more input sources, each input source will be separated, but the columns from each input
           source will be linked.

             parallel --colsep '-' echo {4} {3} {2} {1} \
               ::: A-B C-D ::: e-f g-h

           <b>--colsep</b> implies <b>--trim</b> <b>rl</b>, which can be overridden with <b>--trim</b> <b>n</b>.

           <u>regexp</u> is a Perl Regular Expression: https://perldoc.perl.org/perlre.html

           See also: <b>--csv</b> <b>{</b><u>n</u><b>}</b> <b>--trim</b> <b>--link</b>

       <b>--combineexec</b> <u>name</u> (beta testing)
       <b>--combine-executable</b> <u>name</u> (beta testing)
           Combine GNU <b>parallel</b> with another program into a single executable.

           Let  us say you have developed <u>myprg</u> which takes a single argument. You do not want to parallelize it
           yourself.

           You could write a wrapper that uses GNU <b>parallel</b> called <b>myparprg</b>:

              #!<a href="file:/bin/sh">/bin/sh</a>

              parallel myprg ::: "$@"

           But for others to use this, they need to install: GNU <b>parallel</b>, <b>myprg</b>, and <b>myparprg</b>.

           It would be easier to install if all could be packed into a single executable.

           If <b>myprg</b> is written in shell, you can use <b>--embed</b>.

           If <b>myprg</b> is a binary you can use <b>--combineexec</b>.

           Here we use <b>gzip</b> as example:

              parallel --combineexec pargzip gzip -9 :::

           You can now do:

              ./pargzip foo bar baz

           If you want to pass options to <b>gzip</b> you can do:

              parallel --combineexec pargzip gzip

           Followed by:

              ./pargzip -1 ::: foo bar baz

           See also: <b>--embed</b> <b>--shebang</b> <b>--shebang-wrap</b>

       <b>--compress</b>
           Compress temporary files.

           If the output is big and very compressible this will take up less disk space in $TMPDIR and  possibly
           be faster due to less disk I/O.

           GNU  <b>parallel</b>  will  try  <b>pzstd</b>,  <b>lbzip2</b>, <b>pbzip2</b>, <b>zstd</b>, <b>pigz</b>, <b>lz4</b>, <b>lzop</b>, <b>plzip</b>, <b>lzip</b>, <b>lrz</b>, <b>gzip</b>, <b>pxz</b>,
           <b>lzma</b>, <b>bzip2</b>, <b>xz</b>, <b>clzip</b>, in that order, and use the first available.

           GNU <b>parallel</b> will use up to 8 processes per job waiting to be printed. See  <b>man</b>  <b>parallel_design</b>  for
           details.

           See also: <b>--compress-program</b>

       <b>--compress-program</b> <u>prg</u>
       <b>--decompress-program</b> <u>prg</u>
           Use <u>prg</u> for (de)compressing temporary files.

           It  is assumed that <u>prg</u> <u>-dc</u> will decompress stdin (standard input) to stdout (standard output) unless
           <b>--decompress-program</b> is given.

           See also: <b>--compress</b>

       <b>--csv</b>
           Treat input as CSV-format.

           <b>--colsep</b> sets the field delimiter. It works very much like <b>--colsep</b> except it  deals  correctly  with
           quoting. Compare:

              echo '"1 big, 2 small","2""x4"" plank",12.34' |
                parallel --csv echo {1} of {2} at {3}

              echo '"1 big, 2 small","2""x4"" plank",12.34' |
                parallel --colsep ',' echo {1} of {2} at {3}

           Even quoted newlines are parsed correctly:

              (echo '"Start of field 1 with newline'
               echo 'Line 2 in field 1";value 2') |
                parallel --csv --colsep ';' echo Field 1: {1} Field 2: {2}

           When used with <b>--pipe</b> only pass full CSV-records.

           See also: <b>--pipe</b> <b>--link</b> <b>{</b><u>n</u><b>}</b> <b>--colsep</b> <b>--header</b>

       <b>--ctag</b> (obsolete: use <b>--color</b> <b>--tag</b>)
           Color tag.

           If  the  values  look  very  similar looking at the output it can be hard to tell when a new value is
           used. <b>--ctag</b> gives each value a random color.

           See also: <b>--color</b> <b>--tag</b>

       <b>--ctagstring</b> <u>str</u> (obsolete: use <b>--color</b> <b>--tagstring</b>)
           Color tagstring.

           See also: <b>--color</b> <b>--ctag</b> <b>--tagstring</b>

       <b>--delay</b> <u>duration</u>
           Delay starting next job by <u>duration</u>.

           GNU <b>parallel</b> will not start another job for the next <u>duration</u>.

           <u>duration</u> is in seconds, but can be postfixed with s, m, h, or d.

           If you append 'auto' to <u>duration</u> (e.g. 13m3sauto) GNU <b>parallel</b> will automatically  try  to  find  the
           optimal value: If a job fails, <u>duration</u> is increased by 30%. If a job succeeds, <u>duration</u> is decreased
           by 10%.

           See also: TIME POSTFIXES <b>--retries</b> <b>--ssh-delay</b>

       <b>--delimiter</b> <u>delim</u>
       <b>-d</b> <u>delim</u>
           Input items are terminated by <u>delim</u>.

           The  specified  delimiter  may  be  characters,  C-style  character  escapes  such as \n, or octal or
           hexadecimal escape codes.  Octal and hexadecimal escape  codes  are  understood  as  for  the  printf
           command.

           See also: <b>--colsep</b>

       <b>--dirnamereplace</b> <u>replace-str</u>
       <b>--dnr</b> <u>replace-str</u>
           Use the replacement string <u>replace-str</u> instead of <b>{//}</b> for dirname of input line.

           See also: <b>{//}</b>

       <b>--dry-run</b>
           Print the job to run on stdout (standard output), but do not run the job.

           Use  <b>-v</b>  <b>-v</b>  to  include  the  wrapping that GNU <b>parallel</b> generates (for remote jobs, <b>--tmux</b>, <b>--nice</b>,
           <b>--pipe</b>, <b>--pipe-part</b>, <b>--fifo</b> and <b>--cat</b>). Do not count on this literally, though, as  the  job  may  be
           scheduled on another computer or the local computer if : is in the list.

           See also: <b>-v</b>

       <b>-E</b> <u>eof-str</u>
           Set the end of file string to <u>eof-str</u>.

           If  the  end of file string occurs as a line of input, the rest of the input is not read.  If neither
           <b>-E</b> nor <b>-e</b> is used, no end of file string is used.

       <b>--eof</b>[=<u>eof-str</u>]
       <b>-e</b>[<u>eof-str</u>]
           This option is a synonym for the <b>-E</b> option.

           Use <b>-E</b> instead, because it is POSIX compliant for <b>xargs</b> while this option  is  not.   If  <u>eof-str</u>  is
           omitted,  there  is  no  end  of file string.  If neither <b>-E</b> nor <b>-e</b> is used, no end of file string is
           used.

       <b>--embed</b>
           Embed GNU <b>parallel</b> in a shell script.

           If you need to distribute your script to someone who does not want to install GNU  <b>parallel</b>  you  can
           embed GNU <b>parallel</b> in your own shell script:

             parallel --embed &gt; new_script

           After  which  you add your code at the end of <b>new_script</b>. This is tested on <b>ash</b>, <b>bash</b>, <b>dash</b>, <b>ksh</b>, <b>sh</b>,
           and <b>zsh</b>.

       <b>--env</b> <u>var</u>
           Copy exported environment variable <u>var</u>.

           This will copy <u>var</u> to the environment that the command is run  in.  This  is  especially  useful  for
           remote execution.

           In Bash <u>var</u> can also be a Bash function - just remember to <b>export</b> <b>-f</b> the function.

           The  variable  '_'  is  special.  It will copy all exported environment variables except for the ones
           mentioned in <a href="file:~/.parallel/ignored_vars.">~/.parallel/ignored_vars.</a>

           To copy the full environment (both exported and not exported variables, arrays,  and  functions)  use
           <b>env_parallel</b>.

           See also: <b>--record-env</b> <b>--session</b> <b>--sshlogin</b> <u>command</u> <b>env_parallel</b>

       <b>--eta</b>
           Show the estimated number of seconds before finishing.

           This  forces GNU <b>parallel</b> to read all jobs before starting to find the number of jobs (unless you use
           <b>--total-jobs</b>). GNU <b>parallel</b> normally only reads the next job to run.

           The estimate is based on the runtime of finished jobs, so the first estimate will only be shown  when
           the first job has finished.

           Implies <b>--progress</b>.

           See also: <b>--bar</b> <b>--progress</b> <b>--total-jobs</b>

       <b>--fg</b>
           Run command in foreground.

           With <b>--tmux</b> and <b>--tmuxpane</b> GNU <b>parallel</b> will start <b>tmux</b> in the foreground.

           With  <b>--semaphore</b>  GNU  <b>parallel</b> will run the command in the foreground (opposite <b>--bg</b>), and wait for
           completion of the command before exiting. Exit code will be that of the command.

           See also: <b>--bg</b> <b>man</b> <b>sem</b>

       <b>--fifo</b>
           Create a temporary fifo with content.

           Normally <b>--pipe</b> and <b>--pipe-part</b> will give data to the program on stdin (standard input). With  <b>--fifo</b>
           GNU <b>parallel</b> will create a temporary fifo with the name in <b>{}</b>, so you can do:

             parallel --pipe --fifo wc {}

           Beware: If the fifo is never opened for reading, the job will block forever:

             seq 1000000 | parallel --fifo echo This will block forever
             seq 1000000 | parallel --fifo 'echo This will not block &lt; {}'

           By  using  <b>--fifo</b>  instead of <b>--cat</b> you may save I/O as <b>--cat</b> will write to a temporary file, whereas
           <b>--fifo</b> will not.

           Implies <b>--pipe</b> unless <b>--pipe-part</b> is used.

           See also: <b>--cat</b> <b>--pipe</b> <b>--pipe-part</b>

       <b>--filter</b> <u>filter</u>
           Only run jobs where <u>filter</u> is true.

           <u>filter</u> can contain replacement strings and Perl code. Example:

             parallel --filter '{1}+{2}+{3} &lt; 10' echo {1},{2},{3} \
               ::: {1..10} ::: {3..8} ::: {3..10}

           Outputs: 1,3,3 1,3,4 1,3,5 1,4,3 1,4,4 1,5,3 2,3,3 2,3,4 2,4,3 3,3,3

             parallel --filter '{1} &lt; {2}*{2}' echo {1},{2} \
               ::: {1..10} ::: {1..3}

           Outputs: 1,2 1,3 2,2 2,3 3,2 3,3 4,3 5,3 6,3 7,3 8,3

             parallel --filter '{choose_k}' --plus echo {1},{2},{3} \
               ::: {1..5} ::: {1..5} ::: {1..5}

           Outputs: 1,2,3 1,2,4 1,2,5 1,3,4 1,3,5 1,4,5 2,3,4 2,3,5 2,4,5 3,4,5

           See also: <b>skip()</b> <b>--no-run-if-empty</b> <b>{choose_k}</b>

       <b>--filter-hosts</b>
           Remove down hosts.

           For each remote host: check that login through ssh works. If not: do not use this host.

           For performance reasons, this check is performed only at the start and every time  <b>--sshloginfile</b>  is
           changed.  If  an  host goes down after the first check, it will go undetected until <b>--sshloginfile</b> is
           changed; <b>--retries</b> can be used to mitigate this.

           Currently you can <u>not</u> put <b>--filter-hosts</b> in a profile, $PARALLEL,  /etc/parallel/config  or  similar.
           This  is  because  GNU  <b>parallel</b> uses GNU <b>parallel</b> to compute this, so you will get an infinite loop.
           This will likely be fixed in a later release.

           See also: <b>--sshloginfile</b> <b>--sshlogin</b> <b>--retries</b>

       <b>--gnu</b>
           Behave like GNU <b>parallel</b>.

           This option historically took precedence over <b>--tollef</b>. The  <b>--tollef</b>  option  is  now  retired,  and
           therefore may not be used. <b>--gnu</b> is kept for compatibility, but does nothing.

       <b>--group</b>
           Group output.

           Output  from  each  job  is grouped together and is only printed when the command is finished. Stdout
           (standard output) first followed by stderr (standard error).

           This takes in the order of 0.5ms CPU time per job and depends on the speed of your  disk  for  larger
           output.

           <b>--group</b> is the default.

           See also: <b>--line-buffer</b> <b>--ungroup</b> <b>--tag</b>

       <b>--group-by</b> <u>val</u>
           Group input by value.

           Combined with <b>--pipe</b>/<b>--pipe-part</b> <b>--group-by</b> groups lines with the same value into a record.

           The value can be computed from the full line or from a single column.

           <u>val</u> can be:

            column number Use the value in the column numbered.

            column name   Treat the first line as a header and use the value in the column named.

                          (Not supported with <b>--pipe-part</b>).

            perl expression
                          Run the perl expression and use $_ as the value.

            column number perl expression
                          Put  the  value  of  the  column put in $_, run the perl expression, and use $_ as the
                          value.

            column name perl expression
                          Put the value of the column put in $_, run the perl expression,  and  use  $_  as  the
                          value.

                          (Not supported with <b>--pipe-part</b>).

           Example:

             UserID, Consumption
             123,    1
             123,    2
             12-3,   1
             221,    3
             221,    1
             2/21,   5

           If you want to group 123, 12-3, 221, and 2/21 into 4 records and pass one record at a time to <b>wc</b>:

             tail -n +2 table.csv | \
               parallel --pipe --colsep , --group-by 1 -kN1 wc

           Make GNU <b>parallel</b> treat the first line as a header:

             cat table.csv | \
               parallel --pipe --colsep , --header : --group-by 1 -kN1 wc

           Address column by column name:

             cat table.csv | \
               parallel --pipe --colsep , --header : --group-by UserID -kN1 wc

           If 12-3 and 123 are really the same UserID, remove non-digits in UserID when grouping:

             cat table.csv | parallel --pipe --colsep , --header : \
               --group-by 'UserID s/\D//g' -kN1 wc

           See also: SPREADING BLOCKS OF DATA <b>--pipe</b> <b>--pipe-part</b> <b>--bin</b> <b>--shard</b> <b>--round-robin</b>

       <b>--help</b>
       <b>-h</b>  Print a summary of the options to GNU <b>parallel</b> and exit.

       <b>--halt-on-error</b> <u>val</u>
       <b>--halt</b> <u>val</u>
           When should GNU <b>parallel</b> terminate?

           In  some  situations  it makes no sense to run all jobs. GNU <b>parallel</b> should simply stop as soon as a
           condition is met.

           <u>val</u> defaults to <b>never</b>, which runs all jobs no matter what.

           <u>val</u> can also take on the form of <u>when</u>,<u>why</u>.

           <u>when</u> can be 'now' which means kill all running jobs and halt immediately, or it can be  'soon'  which
           means wait for all running jobs to complete, but start no new jobs.

           <u>why</u>  can  be  'fail=X',  'fail=Y%',  'success=X', 'success=Y%', 'done=X', or 'done=Y%' where X is the
           number of jobs that has to fail, succeed, or be done before halting, and Y is the percentage of  jobs
           that has to fail, succeed, or be done before halting.

           Example:

            --halt now,fail=1     exit when a job has failed. Kill running jobs.

            --halt soon,fail=3    exit when 3 jobs have failed, but wait for running jobs to complete.

            --halt soon,fail=3%   exit when 3% of the jobs have failed, but wait for running jobs to complete.

            --halt now,success=1  exit when a job has succeeded. Kill running jobs.

            --halt soon,success=3 exit when 3 jobs have succeeded, but wait for running jobs to complete.

            --halt now,success=3% exit when 3% of the jobs have succeeded. Kill running jobs.

            --halt now,done=1     exit when a job has finished. Kill running jobs.

            --halt soon,done=3    exit when 3 jobs have finished, but wait for running jobs to complete.

            --halt now,done=3%    exit when 3% of the jobs have finished. Kill running jobs.

           For backwards compatibility these also work:

           0           never

           1           soon,fail=1

           2           now,fail=1

           -1          soon,success=1

           -2          now,success=1

           1-99%       soon,fail=1-99%

       <b>--header</b> <u>regexp</u>
           Use regexp as header.

           For  normal  usage the matched header (typically the first line: <b>--header</b> <b>'.*\n'</b>) will be split using
           <b>--colsep</b> (which will default to '\t') and column names can be used as replacement variables:  <b>{column</b>
           <b>name}</b>,  <b>{column</b>  <b>name/}</b>,  <b>{column</b>  <b>name//}</b>,  <b>{column</b>  <b>name/.}</b>,  <b>{column</b>  <b>name.}</b>,  <b>{=column</b>  <b>name</b> <b>perl</b>
           <b>expression</b> <b>=}</b>, ..

           For <b>--pipe</b> the matched header will be prepended to each output.

           <b>--header</b> <b>:</b> is an alias for <b>--header</b> <b>'.*\n'</b>.

           If <u>regexp</u> is a number, it is a fixed number of lines.

           <b>--header</b> <b>0</b> is special: It will make replacement strings for files given with <b>--arg-file</b> or  <b>::::</b>.  It
           will make <b>{foo/bar}</b> for the file <b>foo/bar</b>.

           See also: <b>--colsep</b> <b>--pipe</b> <b>--pipe-part</b> <b>--arg-file</b>

       <b>--hostgroups</b>
       <b>--hgrp</b>
           Enable hostgroups on arguments.

           If  an argument contains '@' the string after '@' will be removed and treated as a list of hostgroups
           on which this job is allowed to run. If there is no <b>--sshlogin</b> with a corresponding  group,  the  job
           will run on any hostgroup.

           Example:

             parallel --hostgroups \
               --sshlogin @grp1/myserver1 -S @grp1+grp2/myserver2 \
               --sshlogin @grp3/myserver3 \
               echo ::: my_grp1_arg@grp1 arg_for_grp2@grp2 third@grp1+grp3

           <b>my_grp1_arg</b>  may  be  run  on  either <b>myserver1</b> or <b>myserver2</b>, <b>third</b> may be run on either <b>myserver1</b> or
           <b>myserver3</b>, but <b>arg_for_grp2</b> will only be run on <b>myserver2</b>.

           See also: <b>--sshlogin</b> <b>$PARALLEL_HOSTGROUPS</b> <b>$PARALLEL_ARGHOSTGROUPS</b>

       <b>-I</b> <u>replace-str</u>
           Use the replacement string <u>replace-str</u> instead of <b>{}</b>.

           See also: <b>{}</b>

       <b>--replace</b> [<u>replace-str</u>]
       <b>-i</b> [<u>replace-str</u>]
           This option is deprecated; use <b>-I</b> instead.

           This option is a synonym for <b>-I</b><u>replace-str</u> if <u>replace-str</u> is specified, and for <b>-I</b> <b>{}</b> otherwise.

           See also: <b>{}</b>

       <b>--joblog</b> <u>logfile</u>
       <b>--jl</b> <u>logfile</u>
           Logfile for executed jobs.

           Save a list of the executed jobs to <u>logfile</u> in the following TAB separated format:  sequence  number,
           sshlogin,  start  time as seconds since epoch, run time in seconds, bytes in files transferred, bytes
           in files returned, exit status, signal, and command run.

           For <b>--pipe</b> bytes transferred and bytes returned are number of input and output of bytes.

           If <b>logfile</b> is prepended with '+' log lines will be appended to the logfile.

           To convert the times into ISO-8601 strict do:

             cat logfile | perl -a -F"\t" -ne \
               'chomp($F[2]=`date -d \@$F[2] +%FT%T`); print join("\t",@F)'

           If the host is long, you can use <b>column</b> <b>-t</b> to pretty print it:

             cat joblog | column -t

           See also: <b>--resume</b> <b>--resume-failed</b>

       <b>--jobs</b> <u>num</u>
       <b>-j</b> <u>num</u>
       <b>--max-procs</b> <u>num</u>
       <b>-P</b> <u>num</u>
           Number of jobslots on each machine.

           Run up to <u>num</u> jobs in parallel. Default is 100%.

           <u>num</u>    Run up to <u>num</u> jobs in parallel.

           0      Run as many as possible (this can take a while to determine).

                  Due to a bug <b>-j</b> <b>0</b> will also evaluate replacement strings twice up to the number of joblots:

                    # This will not count from 1 but from number-of-jobslots
                    seq 10000 | parallel -j0   echo '{= $_ = $foo++; =}' | head
                    # This will count from 1
                    seq 10000 | parallel -j100 echo '{= $_ = $foo++; =}' | head

           <u>num</u>%   Multiply the number of CPU threads by <u>num</u> percent. E.g. 100% means one job per CPU  thread  on
                  each machine.

           +<u>num</u>   Add <u>num</u> to the number of CPU threads.

           -<u>num</u>   Subtract <u>num</u> from the number of CPU threads.

           <u>expr</u>   Evaluate  <u>expr</u>.  E.g. '12/2' to get 6, '+25%' gives the same as '125%', or complex expressions
                  like '+3*<a href="../man55/log.55.html">log</a>(55)%' which means: multiply 3 by <a href="../man55/log.55.html">log</a>(55), multiply that  by  the  number  of  CPU
                  threads and divide by 100, add this to the number of CPU threads.

                  An expression that evalutates to less that 1 is replaced with 1.

           <u>procfile</u>
                  Read parameter from file.

                  Use  the  content of <u>procfile</u> as parameter for <u>-j</u>. E.g. <u>procfile</u> could contain the string 100%
                  or +2 or 10.

                  If <u>procfile</u> is changed when a job completes, <u>procfile</u> is read again and the new number of jobs
                  is computed. If the number is lower than before, running jobs will be allowed  to  finish  but
                  new  jobs will not be started until the wanted number of jobs has been reached.  This makes it
                  possible to change the number of simultaneous running jobs while GNU <b>parallel</b> is running.

           If the evaluated number is less than 1 then 1 will be used.

           If <b>--semaphore</b> is set, the default is 1 thus making a mutex.

           See also: <b>--use-cores-instead-of-threads</b> <b>--use-sockets-instead-of-threads</b>

       <b>--keep-order</b>
       <b>-k</b>  Keep sequence of output same as the order of input.

           Normally the output of a job will be printed as soon as the  job  completes.  Try  this  to  see  the
           difference:

             parallel -j4 sleep {}\; echo {} ::: 2 1 4 3
             parallel -j4 -k sleep {}\; echo {} ::: 2 1 4 3

           If used with <b>--onall</b> or <b>--nonall</b> the output will grouped by sshlogin in sorted order.

           <b>--keep-order</b> cannot keep the output order when used with <b>--pipe</b> <b>--round-robin</b>. Here it instead means,
           that  the  jobslots  will get the same blocks as input in the same order in every run if the input is
           kept the same. Run each of these twice and compare:

             seq 10000000 | parallel --pipe --round-robin 'sleep 0.$RANDOM; wc'
             seq 10000000 | parallel --pipe -k --round-robin 'sleep 0.$RANDOM; wc'

           <b>-k</b> only affects the order in which the output is printed - not the order in which jobs are run.

           See also: <b>--group</b> <b>--line-buffer</b>

       <b>-L</b> <u>recsize</u>
           When used with <b>--pipe</b>: Read records of <u>recsize</u>.

           When used otherwise: Use at most <u>recsize</u> nonblank input lines  per  command  line.   Trailing  blanks
           cause an input line to be logically continued on the next input line.

           <b>-L</b> <b>0</b> means read one line, but insert 0 arguments on the command line.

           <u>recsize</u> can be postfixed with K, M, G, T, P, k, m, g, t, or p.

           Implies <b>-X</b> unless <b>-m</b>, <b>--xargs</b>, or <b>--pipe</b> is set.

           See also: UNIT PREFIX <b>-N</b> <b>--max-lines</b> <b>--block</b> <b>-X</b> <b>-m</b> <b>--xargs</b> <b>--pipe</b>

       <b>--max-lines</b> [<u>recsize</u>]
       <b>-l</b>[<u>recsize</u>]
           When used with <b>--pipe</b>: Read records of <u>recsize</u> lines.

           When  used  otherwise:  Synonym  for the <b>-L</b> option.  Unlike <b>-L</b>, the <u>recsize</u> argument is optional.  If
           <u>recsize</u> is not specified, it defaults to one.  The <b>-l</b> option is deprecated since the  POSIX  standard
           specifies <b>-L</b> instead.

           <b>-l</b> <b>0</b> is an alias for <b>-l</b> <b>1</b>.

           Implies <b>-X</b> unless <b>-m</b>, <b>--xargs</b>, or <b>--pipe</b> is set.

           See also: UNIT PREFIX <b>-N</b> <b>--block</b> <b>-X</b> <b>-m</b> <b>--xargs</b> <b>--pipe</b>

       <b>--limit</b> "<u>command</u> <u>args</u>"
           Dynamic job limit.

           Before  starting  a  new  job  run  <u>command</u>  with <u>args</u>. The exit value of <u>command</u> determines what GNU
           <b>parallel</b> will do:

           0   Below limit. Start another job.

           1   Over limit. Start no jobs.

           2   Way over limit. Kill the youngest job.

           You can use any shell command. There are 3 predefined commands:

           "io <u>n</u>"    Limit for I/O. The amount of disk I/O will be computed as a value 0-100, where 0 is no  I/O
                     and 100 is at least one disk is 100% saturated.

           "load <u>n</u>"  Similar to <b>--load</b>.

           "mem <u>n</u>"   Similar to <b>--memfree</b>.

           See also: <b>--memfree</b> <b>--load</b>

       <b>--latest-line</b>
       <b>--ll</b>
           Print  the lastest line. Each job gets a single line that is updated with the lastest output from the
           job.

           Example:

             slow_seq() {
               seq "$@" |
                 perl -ne '$|=1; for(split//){ print; select($a,$a,$a,0.03);}'
             }
             export -f slow_seq
             parallel --shuf -j99 --ll --tag --bar --color slow_seq {} ::: {1..300}

           See also: <b>--line-buffer</b>

       <b>--line-buffer</b>
       <b>--lb</b>
           Buffer output on line basis.

           <b>--group</b> will keep the output together for a whole job. <b>--ungroup</b> allows output to mixup with  half  a
           line  coming  from  one job and half a line coming from another job. <b>--line-buffer</b> fits between these
           two: GNU <b>parallel</b> will print a full line, but will allow for mixing lines of different jobs.

           <b>--line-buffer</b> takes more CPU power than both <b>--group</b> and <b>--ungroup</b>,  but  can  be  much  faster  than
           <b>--group</b> if the CPU is not the limiting factor.

           Normally  <b>--line-buffer</b> does not buffer on disk, and can thus process an infinite amount of data, but
           it will buffer on disk when combined with: <b>--keep-order</b>, <b>--results</b>,  <b>--compress</b>,  and  <b>--files</b>.  This
           will make it as slow as <b>--group</b> and will limit output to the available disk space.

           With  <b>--keep-order</b>  <b>--line-buffer</b>  will  output  lines  from  the  first job continuously while it is
           running, then lines from the second job while that is running. It will buffer full  lines,  but  jobs
           will not mix. Compare:

             parallel -j0 'echo [{};sleep {};echo {}]' ::: 1 3 2 4
             parallel -j0 --lb 'echo [{};sleep {};echo {}]' ::: 1 3 2 4
             parallel -j0 -k --lb 'echo [{};sleep {};echo {}]' ::: 1 3 2 4

           See also: <b>--group</b> <b>--ungroup</b> <b>--keep-order</b> <b>--tag</b>

       <b>--link</b>
       <b>--xapply</b>
           Link input sources.

           Read  multiple  input  sources  like  the  command  <b>xapply</b>.  If multiple input sources are given, one
           argument will be read from each of the input sources. The arguments can be accessed in the command as
           <b>{1}</b> .. <b>{</b><u>n</u><b>}</b>, so <b>{1}</b> will be a line from the first input source, and <b>{6}</b> will refer to  the  line  with
           the same line number from the 6th input source.

           Compare these two:

             parallel echo {1} {2} ::: 1 2 3 ::: a b c
             parallel --link echo {1} {2} ::: 1 2 3 ::: a b c

           Arguments will be recycled if one input source has more arguments than the others:

             parallel --link echo {1} {2} {3} \
               ::: 1 2 ::: I II III ::: a b c d e f g

           See also: <b>--header</b> <b>:::+</b> <b>::::+</b>

       <b>--load</b> <u>max-load</u>
           Only start jobs if load is less than max-load.

           Do  not  start new jobs on a given computer unless the number of running processes on the computer is
           less than <u>max-load</u>. <u>max-load</u> uses the same syntax as <b>--jobs</b>, so <u>100%</u> for  one  per  CPU  is  a  valid
           setting. Only difference is 0 which is interpreted as 0.01.

           See also: <b>--limit</b> <b>--jobs</b>

       <b>--controlmaster</b>
       <b>-M</b>  Use ssh's ControlMaster to make ssh connections faster.

           Useful if jobs run remote and are very fast to run. This is disabled for sshlogins that specify their
           own ssh command.

           See also: <b>--ssh</b> <b>--sshlogin</b>

       <b>-m</b>  Multiple arguments.

           Insert  as  many  arguments  as  the  command  line length permits. If multiple jobs are being run in
           parallel: distribute the arguments evenly among the jobs. Use <b>-j1</b> or <b>--xargs</b> to avoid this.

           If <b>{}</b> is not used the arguments will be appended to the line.  If <b>{}</b> is used multiple times  each  <b>{}</b>
           will be replaced with all the arguments.

           Support for <b>-m</b> with <b>--sshlogin</b> is limited and may fail.

           If in doubt use <b>-X</b> as that will most likely do what is needed.

           See also: <b>-X</b> <b>--xargs</b>

       <b>--memfree</b> <u>size</u>
           Minimum memory free when starting another job.

           The <u>size</u> can be postfixed with K, M, G, T, P, k, m, g, t, or p.

           If  the  jobs  take up very different amount of RAM, GNU <b>parallel</b> will only start as many as there is
           memory for. If less than <u>size</u> bytes are free, no more jobs will be started. If  less  than  50%  <u>size</u>
           bytes  are free, the youngest job will be killed (as per <b>--term-seq</b>), and put back on the queue to be
           run later.

           <b>--retries</b> must be set to determine how many times GNU <b>parallel</b> should retry a given job.

           See also: UNIT PREFIX <b>--term-seq</b> <b>--retries</b> <b>--memsuspend</b>

       <b>--memsuspend</b> <u>size</u>
           Suspend jobs when there is less memory available.

           If the available memory falls below 2 * <u>size</u>, GNU <b>parallel</b> will suspend some of the running jobs.  If
           the available memory falls below <u>size</u>, only one job will be running.

           If  a single job fits in the given size, all jobs will complete without running out of memory. If you
           have swap available, you can usually lower <u>size</u> to around half the size of a single job  -  with  the
           slight risk of swapping a little.

           Jobs will be resumed when more RAM is available - typically when the oldest job completes.

           <b>--memsuspend</b> only works on local jobs because there is no obvious way to suspend remote jobs.

           <u>size</u> can be postfixed with K, M, G, T, P, k, m, g, t, or p.

           See also: UNIT PREFIX <b>--memfree</b>

       <b>--minversion</b> <u>version</u>
           Print the version GNU <b>parallel</b> and exit.

           If the current version of GNU <b>parallel</b> is less than <u>version</u> the exit code is 255. Otherwise it is 0.

           This  is  useful  for  scripts  that  depend on features only available from a certain version of GNU
           <b>parallel</b>:

              parallel --minversion 20170422 &amp;&amp;
                echo halt done=50% supported from version 20170422 &amp;&amp;
                parallel --halt now,done=50% echo ::: {1..100}

           See also: <b>--version</b>

       <b>--max-args</b> <u>max-args</u>
       <b>-n</b> <u>max-args</u>
           Use at most <u>max-args</u> arguments per command line.

           Fewer than <u>max-args</u> arguments will be used if the size (see the <b>-s</b> option) is exceeded, unless the <b>-x</b>
           option is given, in which case GNU <b>parallel</b> will exit.

           <b>-n</b> <b>0</b> means read one argument, but insert 0 arguments on the command line.

           <u>max-args</u> can be postfixed with K, M, G, T, P, k, m, g, t, or p (see UNIT PREFIX).

           Implies <b>-X</b> unless <b>-m</b> is set.

           See also: <b>-X</b> <b>-m</b> <b>--xargs</b> <b>--max-replace-args</b>

       <b>--max-replace-args</b> <u>max-args</u>
       <b>-N</b> <u>max-args</u>
           Use at most <u>max-args</u> arguments per command line.

           Like <b>-n</b> but also makes replacement strings <b>{1}</b> .. <b>{</b><u>max-args</u><b>}</b> that represents argument 1 ..  <u>max-args</u>.
           If too few args the <b>{</b><u>n</u><b>}</b> will be empty.

           <b>-N</b> <b>0</b> means read one argument, but insert 0 arguments on the command line.

           This will set the owner of the homedir to the user:

             tr ':' '\n' &lt; <a href="file:/etc/passwd">/etc/passwd</a> | parallel -N7 chown {1} {6}

           Implies <b>-X</b> unless <b>-m</b> or <b>--pipe</b> is set.

           <u>max-args</u> can be postfixed with K, M, G, T, P, k, m, g, t, or p.

           When used with <b>--pipe</b> <b>-N</b> is the number of records to read. This is somewhat slower than <b>--block</b>.

           See also: UNIT PREFIX <b>--pipe</b> <b>--block</b> <b>-m</b> <b>-X</b> <b>--max-args</b>

       <b>--nonall</b>
           <b>--onall</b> with no arguments.

           Run  the  command on all computers given with <b>--sshlogin</b> but take no arguments. GNU <b>parallel</b> will log
           into <b>--jobs</b> number of computers in parallel and run the job on the  computer.  <b>-j</b>  adjusts  how  many
           computers to log into in parallel.

           This is useful for running the same command (e.g. uptime) on a list of servers.

           See also: <b>--onall</b> <b>--sshlogin</b>

       <b>--onall</b>
           Run all the jobs on all computers given with <b>--sshlogin</b>.

           GNU  <b>parallel</b>  will  log into <b>--jobs</b> number of computers in parallel and run one job at a time on the
           computer. The order of the jobs will not be changed, but some computers may finish before others.

           When using <b>--group</b> the output will be grouped by each server, so all the output from one server  will
           be grouped together.

           <b>--joblog</b> will contain an entry for each job on each server, so there will be several job sequence 1.

           See also: <b>--nonall</b> <b>--sshlogin</b>

       <b>--open-tty</b>
       <b>-o</b>  Open terminal tty.

           Similar to <b>--tty</b> but does not set <b>--jobs</b> or <b>--ungroup</b>.

           See also: <b>--tty</b>

       <b>--output-as-files</b>
       <b>--outputasfiles</b>
       <b>--files</b>
       <b>--files0</b>
           Save output to files.

           Instead  of printing the output to stdout (standard output) the output of each job is saved in a file
           and the filename is then printed.

           <b>--files0</b> uses NUL (\0) instead of newline (\n) as separator.

           See also: <b>--results</b>

       <b>--pipe</b>
       <b>--spreadstdin</b>
           Spread input to jobs on stdin (standard input).

           Read a block of data from stdin (standard input) and give one block of data as input to one job.

           The block size is determined by <b>--block</b> (default: 1M).

           Except for the first and last record GNU <b>parallel</b> only passes full records to the  job.  The  strings
           <b>--recstart</b>  and  <b>--recend</b> determine where a record starts and ends: The border between two records is
           defined as <b>--recend</b> immediately followed by <b>--recstart</b>. GNU <b>parallel</b> splits  exactly  after  <b>--recend</b>
           and before <b>--recstart</b>. The block will have the last partial record removed before the block is passed
           on to the job. The partial record will be prepended to next block.

           You can limit the number of records to be passed with <b>-N</b>, and set the record size with <b>-L</b>.

           <b>--pipe</b>  maxes  out  at  around  1  GB/s  input,  and 100 MB/s output. If performance is important use
           <b>--pipe-part</b>.

           <b>--fifo</b> and <b>--cat</b> will give stdin (standard input) on a fifo or a temporary file.

           If data is arriving slowly, you can use <b>--block-timeout</b> to finish reading a block early.

           The data can be spread between the  jobs  in  specific  ways  using  <b>--round-robin</b>,  <b>--bin</b>,  <b>--shard</b>,
           <b>--group-by</b>. See the section: SPREADING BLOCKS OF DATA

           See also: <b>--block</b> <b>--block-timeout</b> <b>--recstart</b> <b>--recend</b> <b>--fifo</b> <b>--cat</b> <b>--pipe-part</b> <b>-N</b> <b>-L</b> <b>--round-robin</b>

       <b>--pipe-part</b>
           Pipe parts of a physical file.

           <b>--pipe-part</b> works similar to <b>--pipe</b>, but is much faster. 5 GB/s can easily be delivered.

           <b>--pipe-part</b> has a few limitations:

             The  file  must  be  a normal file or a block device (technically it must be seekable) and must be
              given using <b>--arg-file</b> or <b>::::</b>. The file cannot be a pipe, a fifo, or a stream  as  they  are  not
              seekable.

              If using a block device with lot of NUL bytes, remember to set <b>--recend</b> <b>''</b>.

             Record counting (<b>-N</b>) and line counting (<b>-L</b>/<b>-l</b>) do not work. Instead use <b>--recstart</b> and <b>--recend</b> to
              determine where records end.

           See also: <b>--pipe</b> <b>--recstart</b> <b>--recend</b> <b>--arg-file</b> <b>::::</b>

       <b>--plain</b>
           Ignore <b>--profile</b>, $PARALLEL, and <a href="file:~/.parallel/config.">~/.parallel/config.</a>

           Ignore any <b>--profile</b>, $PARALLEL, and <a href="file:~/.parallel/config">~/.parallel/config</a> to get full control on the command line (used
           by GNU <b>parallel</b> internally when called with <b>--sshlogin</b>).

           See also: <b>--profile</b>

       <b>--plus</b>
           Add more replacement strings.

           Activate  additional  replacement  strings:  {+/} {+.} {+..} {+...} {..} {...} {<a href="file:/..">/..</a>} {/...} {##}. The
           idea being that '{+foo}' matches the opposite of '{foo}' so that:

           {} = {+/}/{/} =  {.}.{+.}  =  {+/}/{<a href="file:/.">/.</a>}.{+.}   =  {..}.{+..}  =  {+/}/{<a href="file:/..">/..</a>}.{+..}  =  {...}.{+...}  =
           {+/}/{/...}.{+...}

           <b>{##}</b> is the total number of jobs to be run. It is incompatible with <b>-X</b>/<b>-m</b>/<b>--xargs</b>.

           <b>{0%}</b> zero-padded jobslot.

           <b>{0#}</b> zero-padded sequence number.

           <b>{slot-1}</b>  jobslot  -  1  (i.e.  counting  from  0).  -1  can  be  any  perl expression: {slot**2-1} =
           slot*slot-1.

           <b>{seq-1}</b> sequence number - 1 (i.e. counting from 0). -1 can be any perl expression.

           <b>{choose_k}</b> is inspired by n choose k: Given a list of n elements, choose k. k is the number of  input
           sources  and  n is the number of arguments in an input source.  The content of the input sources must
           be the same and the arguments must be unique.

           <b>{uniq}</b> skips jobs where values from two input sources are the same.

           Shorthands for variables:

             {slot}         $PARALLEL_JOBSLOT (see {%})
             {sshlogin}     $PARALLEL_SSHLOGIN
             {host}         $PARALLEL_SSHHOST
             {agrp}         $PARALLEL_ARGHOSTGROUPS
             {hgrp}         $PARALLEL_HOSTGROUPS

           The following dynamic replacement strings are also activated. They are inspired by  bash's  parameter
           expansion:

             {:-str}        str if the value is empty
             {:num}         remove the first num characters
             {:pos:len}     substring from position pos length len
             {#regexp}      remove prefix regexp (non-greedy)
             {##regexp}     remove prefix regexp (greedy)
             {%regexp}      remove postfix regexp (non-greedy)
             {%%regexp}     remove postfix regexp (greedy)
             {/regexp/str}  replace one regexp with str
             {//regexp/str} replace every regexp with str
             {^str}         uppercase str if found at the start
             {^^str}        uppercase str
             {,str}         lowercase str if found at the start
             {,,str}        lowercase str

           See also: <b>--rpl</b> <b>{}</b>

       <b>--process-slot-var</b> <u>varname</u>
           Set the environment variable <u>varname</u> to the jobslot number-1.

             seq 10 | parallel --process-slot-var=name echo '$name' {}

       <b>--progress</b>
           Show progress of computations.

           List  the  computers  involved in the task with number of CPUs detected and the max number of jobs to
           run. After that show progress for each computer: number of running jobs, number  of  completed  jobs,
           and  percentage  of  all  jobs done by this computer. The percentage will only be available after all
           jobs have been scheduled as GNU <b>parallel</b> only read the next job when ready to schedule it -  this  is
           to avoid wasting time and memory by reading everything at startup.

           By  sending  GNU  <b>parallel</b> SIGUSR2 you can toggle turning on/off <b>--progress</b> on a running GNU <b>parallel</b>
           process.

           See also: <b>--eta</b> <b>--bar</b>

       <b>--max-line-length-allowed</b>
           Print maximal command line length.

           Print the maximal number of characters allowed on the command line and exit  (used  by  GNU  <b>parallel</b>
           itself to determine the line length on remote computers).

           See also: <b>--show-limits</b>

       <b>--number-of-cpus</b> (obsolete)
           Print the number of physical CPU cores and exit.

       <b>--number-of-cores</b>
           Print  the number of physical CPU cores and exit (used by GNU <b>parallel</b> itself to determine the number
           of physical CPU cores on remote computers).

           See also: <b>--number-of-sockets</b> <b>--number-of-threads</b> <b>--use-cores-instead-of-threads</b> <b>--jobs</b>

       <b>--number-of-sockets</b>
           Print the number of filled CPU sockets and exit (used by GNU <b>parallel</b> itself to determine the  number
           of filled CPU sockets on remote computers).

           See also: <b>--number-of-cores</b> <b>--number-of-threads</b> <b>--use-sockets-instead-of-threads</b> <b>--jobs</b>

       <b>--number-of-threads</b>
           Print  the  number  of hyperthreaded CPU cores and exit (used by GNU <b>parallel</b> itself to determine the
           number of hyperthreaded CPU cores on remote computers).

           See also: <b>--number-of-cores</b> <b>--number-of-sockets</b> <b>--jobs</b>

       <b>--no-keep-order</b>
           Overrides an earlier <b>--keep-order</b> (e.g. if set in <b><a href="file:~/.parallel/config">~/.parallel/config</a></b>).

       <b>--nice</b> <u>niceness</u>
           Run the command at this niceness.

           By default GNU <b>parallel</b> will run jobs at the same nice level as GNU <b>parallel</b> is started - both on the
           local machine and remote servers, so you are unlikely to ever use this option.

           Setting <b>--nice</b> will override this nice level. If the nice level is  smaller  than  the  current  nice
           level,  it  will  only affect remote jobs (e.g. if current level is 10 then <b>--nice</b> <b>5</b> will cause local
           jobs to be run at level 10, but remote jobs run at nice level 5).

       <b>--interactive</b>
       <b>-p</b>  Ask user before running a job.

           Prompt the user about whether to run each command line and read a line from the terminal.   Only  run
           the command line if the response starts with 'y' or 'Y'.  Implies <b>-t</b>.

       <b>--_parset</b> <u>type</u>,<u>varname</u>
           Used internally by <b>parset</b>.

           Generate  shell  code  to  be eval'ed which will set the variable(s) <u>varname</u>. <u>type</u> can be 'assoc' for
           associative array or 'var' for normal variables.

           The only supported use is as part of <b>parset</b>.

       <b>--parens</b> <u>parensstring</u>
           Use <u>parensstring</u> instead of <b>{==}</b>.

           Define start and end parenthesis for <b>{=perl</b> <b>expression=}</b>. The left and the right parenthesis  can  be
           multiple characters and are assumed to be the same length. The default is <b>{==}</b> giving <b>{=</b> as the start
           parenthesis and <b>=}</b> as the end parenthesis.

           Another useful setting is <b>,,,,</b> which would make both parenthesis <b>,,</b>:

             parallel --parens ,,,, echo foo is ,,s/I/O/g,, ::: FII

           See also: <b>--rpl</b> <b>{=</b><u>perl</u> <u>expression</u><b>=}</b>

       <b>--profile</b> <u>profilename</u>
       <b>-J</b> <u>profilename</u>
           Use profile <u>profilename</u> for options.

           This  is useful if you want to have multiple profiles. You could have one profile for running jobs in
           parallel on the local computer and a different profile for running jobs on remote computers.

           <u>profilename</u> corresponds to the file <a href="file:~/.parallel/">~/.parallel/</a><u>profilename</u>.

           You can give multiple profiles by repeating <b>--profile</b>. If parts of the profiles conflict,  the  later
           ones will be used.

           Default: <a href="file:~/.parallel/config">~/.parallel/config</a>

           See also: PROFILE FILES

       <b>--quote</b>
       <b>-q</b>  Quote <u>command</u>.

           If  your  command contains special characters that should not be interpreted by the shell (e.g. ; \ |
           *), use <b>--quote</b> to escape these. The command  must  be  a  simple  command  (see  <b>man</b>  <b>bash</b>)  without
           redirections and without variable assignments.

           Most people will not need this. Quoting is disabled by default.

           See also: QUOTING <u>command</u> <b>--shell-quote</b> <b>uq()</b> <b>Q()</b>

       <b>--no-run-if-empty</b>
       <b>-r</b>  Do not run empty input.

           If the stdin (standard input) only contains whitespace, do not run the command.

           If used with <b>--pipe</b> this is slow.

           See also: <u>command</u> <b>--pipe</b> <b>--interactive</b>

       <b>--noswap</b>
           Do not start job is computer is swapping.

           Do not start new jobs on a given computer if there is both swap-in and swap-out activity.

           The swap activity is only sampled every 10 seconds as the sampling takes 1 second to do.

           Swap  activity is computed as (swap-in)*(swap-out) which in practice is a good value: swapping out is
           not a problem, swapping in is not a problem, but  both  swapping  in  and  out  usually  indicates  a
           problem.

           <b>--memfree</b> and <b>--memsuspend</b> may give better results, so try using those first.

           See also: <b>--memfree</b> <b>--memsuspend</b>

       <b>--record-env</b>
           Record exported environment.

           Record  current  exported  environment  variables  in  <b><a href="file:~/.parallel/ignored_vars">~/.parallel/ignored_vars</a></b>.   This  will  ignore
           variables currently set when using <b>--env</b> <b>_</b>. So you should set the variables/fuctions, you want to use
           <u>after</u> running <b>--record-env</b>.

           See also: <b>--env</b> <b>--session</b> <b>env_parallel</b>

       <b>--recstart</b> <u>startstring</u>
       <b>--recend</b> <u>endstring</u>
           Split record between <u>endstring</u> and <u>startstring</u>.

           If <b>--recstart</b> is given <u>startstring</u> will be used to split at record start.

           If <b>--recend</b> is given <u>endstring</u> will be used to split at record end.

           If both <b>--recstart</b> and <b>--recend</b> are given the combined string <u>endstringstartstring</u> will have to match
           to find a split position. This is useful if either <u>startstring</u> or <u>endstring</u> match in the middle of  a
           record.

           If  neither  <b>--recstart</b>  nor  <b>--recend</b>  are  given, then <b>--recend</b> defaults to '\n'. To have no record
           separator (e.g. for binary files) use <b>--recend</b> <b>""</b>.

           <b>--recstart</b> and <b>--recend</b> are used with <b>--pipe</b>.

           Use <b>--regexp</b> to interpret <b>--recstart</b> and <b>--recend</b> as regular expressions. This is slow, however.

           Use <b>--remove-rec-sep</b> to remove <b>--recstart</b> and <b>--recend</b> before passing the block to the job.

           See also: <b>--pipe</b> <b>--regexp</b> <b>--remove-rec-sep</b>

       <b>--regexp</b>
           Use <b>--regexp</b> to interpret <b>--recstart</b> and <b>--recend</b> as regular expressions. This is slow, however.

           See also: <b>--pipe</b> <b>--regexp</b> <b>--remove-rec-sep</b> <b>--recstart</b> <b>--recend</b>

       <b>--remove-rec-sep</b>
       <b>--removerecsep</b>
       <b>--rrs</b>
           Remove record separator.

           Remove the text matched by <b>--recstart</b> and <b>--recend</b> before piping it to the command.

           Only used with <b>--pipe</b>/<b>--pipe-part</b>.

           See also: <b>--pipe</b> <b>--regexp</b> <b>--pipe-part</b> <b>--recstart</b> <b>--recend</b>

       <b>--results</b> <u>name</u>
       <b>--res</b> <u>name</u>
           Save the output into files.

           <b>Simple</b> <b>string</b> <b>output</b> <b>dir</b>

           If <u>name</u> does not contain replacement strings and does not end in <b>.csv/.tsv</b>, the output will be stored
           in a directory tree rooted at <u>name</u>.  Within this directory tree, each command will  result  in  three
           files:  <u>name</u>/&lt;ARGS&gt;/stdout  and  <u>name</u>/&lt;ARGS&gt;/stderr,  <u>name</u>/&lt;ARGS&gt;/seq,  where &lt;ARGS&gt; is a sequence of
           directories representing the header of the input source (if using <b>--header</b> <b>:</b>) or the  number  of  the
           input source and corresponding values.

           E.g:

             parallel --header : --results foo echo {a} {b} \
               ::: a I II ::: b III IIII

           will generate the files:

             foo/a/II/b/III/seq
             foo/a/II/b/III/stderr
             foo/a/II/b/III/stdout
             foo/a/II/b/IIII/seq
             foo/a/II/b/IIII/stderr
             foo/a/II/b/IIII/stdout
             foo/a/I/b/III/seq
             foo/a/I/b/III/stderr
             foo/a/I/b/III/stdout
             foo/a/I/b/IIII/seq
             foo/a/I/b/IIII/stderr
             foo/a/I/b/IIII/stdout

           and

             parallel --results foo echo {1} {2} ::: I II ::: III IIII

           will generate the files:

             foo/1/II/2/III/seq
             foo/1/II/2/III/stderr
             foo/1/II/2/III/stdout
             foo/1/II/2/IIII/seq
             foo/1/II/2/IIII/stderr
             foo/1/II/2/IIII/stdout
             foo/1/I/2/III/seq
             foo/1/I/2/III/stderr
             foo/1/I/2/III/stdout
             foo/1/I/2/IIII/seq
             foo/1/I/2/IIII/stderr
             foo/1/I/2/IIII/stdout

           <b>CSV</b> <b>file</b> <b>output</b>

           If <u>name</u> ends in <b>.csv</b>/<b>.tsv</b> the output will be a CSV-file named <u>name</u>.

           <b>.csv</b> gives a comma separated value file. <b>.tsv</b> gives a TAB separated value file.

           <b>-.csv</b>/<b>-.tsv</b> are special: It will give the file on stdout (standard output).

           <b>JSON</b> <b>file</b> <b>output</b>

           If <u>name</u> ends in <b>.json</b> the output will be a JSON-file named <u>name</u>.

           <b>-.json</b> is special: It will give the file on stdout (standard output).

           <b>Replacement</b> <b>string</b> <b>output</b> <b>file</b>

           If  <u>name</u>  contains  a replacement string and the replaced result does not end in /, then the standard
           output will be stored in a file named by this result. Standard error will be stored in the same  file
           name  with  '.err'  added,  and  the sequence number will be stored in the same file name with '.seq'
           added.

           E.g.

             parallel --results my_{} echo ::: foo bar baz

           will generate the files:

             my_bar
             my_bar.err
             my_bar.seq
             my_baz
             my_baz.err
             my_baz.seq
             my_foo
             my_foo.err
             my_foo.seq

           <b>Replacement</b> <b>string</b> <b>output</b> <b>dir</b>

           If <u>name</u> contains a replacement string and the replaced result ends in /, then output  files  will  be
           stored in the resulting dir.

           E.g.

             parallel --results my_{}/ echo ::: foo bar baz

           will generate the files:

             my_bar/seq
             my_bar/stderr
             my_bar/stdout
             my_baz/seq
             my_baz/stderr
             my_baz/stdout
             my_foo/seq
             my_foo/stderr
             my_foo/stdout

           See also: <b>--output-as-files</b> <b>--tag</b> <b>--header</b> <b>--joblog</b>

       <b>--resume</b>
           Resumes from the last unfinished job.

           By  reading  <b>--joblog</b>  or  the <b>--results</b> dir GNU <b>parallel</b> will figure out the last unfinished job and
           continue from there. As GNU <b>parallel</b> only looks at the sequence numbers in <b>--joblog</b> then  the  input,
           the  command,  and  <b>--joblog</b>  all  have  to  remain  unchanged;  otherwise GNU <b>parallel</b> may run wrong
           commands.

           See also: <b>--joblog</b> <b>--results</b> <b>--resume-failed</b> <b>--retries</b>

       <b>--resume-failed</b>
           Retry all failed and resume from the last unfinished job.

           By reading <b>--joblog</b> GNU <b>parallel</b> will figure out the failed jobs and run those again. After  that  it
           will  resume  last unfinished job and continue from there. As GNU <b>parallel</b> only looks at the sequence
           numbers in <b>--joblog</b> then the input, the command, and <b>--joblog</b> all have to remain unchanged; otherwise
           GNU <b>parallel</b> may run wrong commands.

           See also: <b>--joblog</b> <b>--resume</b> <b>--retry-failed</b> <b>--retries</b>

       <b>--retry-failed</b>
           Retry all failed jobs in joblog.

           By reading <b>--joblog</b> GNU <b>parallel</b> will figure out the failed jobs and run those again.

           <b>--retry-failed</b> ignores the command and arguments on the command line: It only looks at the joblog.

           <b>Differences</b> <b>between</b> <b>--resume,</b> <b>--resume-failed,</b> <b>--retry-failed</b>

           In this example <b>exit</b> <b>{=</b> <b>$_%=2</b> <b>=}</b> will cause every other job to fail.

             timeout -k 1 4 parallel --joblog log -j10 \
               'sleep {}; exit {= $_%=2 =}' ::: {10..1}

           4 jobs completed. 2 failed:

             Seq   [...]   Exitval Signal  Command
             10    [...]   1       0       sleep 1; exit 1
             9     [...]   0       0       sleep 2; exit 0
             8     [...]   1       0       sleep 3; exit 1
             7     [...]   0       0       sleep 4; exit 0

           <b>--resume</b> does not care about the Exitval, but only looks at Seq. If the Seq is run, it  will  not  be
           run again. So if needed, you can change the command for the seqs not run yet:

             parallel --resume --joblog log -j10 \
               'sleep .{}; exit {= $_%=2 =}' ::: {10..1}

             Seq   [...]   Exitval Signal  Command
             [... as above ...]
             1     [...]   0       0       sleep .10; exit 0
             6     [...]   1       0       sleep .5; exit 1
             5     [...]   0       0       sleep .6; exit 0
             4     [...]   1       0       sleep .7; exit 1
             3     [...]   0       0       sleep .8; exit 0
             2     [...]   1       0       sleep .9; exit 1

           <b>--resume-failed</b>  cares  about the Exitval, but also only looks at Seq to figure out which commands to
           run. Again this means you can change the command, but not the arguments. It will run the failed  seqs
           and the seqs not yet run:

             parallel --resume-failed --joblog log -j10 \
               'echo {};sleep .{}; exit {= $_%=3 =}' ::: {10..1}

             Seq   [...]   Exitval Signal  Command
             [... as above ...]
             10    [...]   1       0       echo 1;sleep .1; exit 1
             8     [...]   0       0       echo 3;sleep .3; exit 0
             6     [...]   2       0       echo 5;sleep .5; exit 2
             4     [...]   1       0       echo 7;sleep .7; exit 1
             2     [...]   0       0       echo 9;sleep .9; exit 0

           <b>--retry-failed</b>  cares  about  the  Exitval,  but  takes  the  command from the joblog. It ignores any
           arguments or commands given on the command line:

             parallel --retry-failed --joblog log -j10 this part is ignored

             Seq   [...]   Exitval Signal  Command
             [... as above ...]
             10    [...]   1       0       echo 1;sleep .1; exit 1
             6     [...]   2       0       echo 5;sleep .5; exit 2
             4     [...]   1       0       echo 7;sleep .7; exit 1

           See also: <b>--joblog</b> <b>--resume</b> <b>--resume-failed</b> <b>--retries</b>

       <b>--retries</b> <u>n</u>
           Try failing jobs <u>n</u> times.

           If a job fails, retry it on another computer on which it has not failed. Do this <u>n</u>  times.  If  there
           are  fewer  than <u>n</u> computers in <b>--sshlogin</b> GNU <b>parallel</b> will re-use all the computers. This is useful
           if some jobs fail for no apparent reason (such as network failure).

           <u>n</u>=0 means infinite.

           See also: <b>--term-seq</b> <b>--sshlogin</b>

       <b>--return</b> <u>filename</u>
           Transfer files from remote computers.

           <b>--return</b> is used with <b>--sshlogin</b>  when  the  arguments  are  files  on  the  remote  computers.  When
           processing  is  done  the  file <u>filename</u> will be transferred from the remote computer using <b>rsync</b> and
           will be put relative to the default login dir. E.g.

             echo foo/bar.txt | parallel --return {.}.out \
               --sshlogin server.example.com touch {.}.out

           This will transfer the file <u>$HOME/foo/bar.out</u>  from  the  computer  <u>server.example.com</u>  to  the  file
           <u>foo/bar.out</u> after running <b>touch</b> <b>foo/bar.out</b> on <u>server.example.com</u>.

             parallel -S server --trc out/./{}.out touch {}.out ::: in/file

           This  will  transfer  the  file  <u>in/file.out</u>  from  the  computer  <u>server.example.com</u>  to  the  files
           <u>out/in/file.out</u> after running <b>touch</b> <b>in/file.out</b> on <u>server</u>.

             echo /tmp/foo/bar.txt | parallel --return {.}.out \
               --sshlogin server.example.com touch {.}.out

           This will transfer the file  <u>/tmp/foo/bar.out</u>  from  the  computer  <u>server.example.com</u>  to  the  file
           <u>/tmp/foo/bar.out</u> after running <b>touch</b> <b>/tmp/foo/bar.out</b> on <u>server.example.com</u>.

           Multiple files can be transferred by repeating the option multiple times:

             echo /tmp/foo/bar.txt | parallel \
               --sshlogin server.example.com \
               --return {.}.out --return {.}.out2 touch {.}.out {.}.out2

           <b>--return</b> is ignored when used with <b>--sshlogin</b> <b>:</b> or when not used with <b>--sshlogin</b>.

           For details on transferring see <b>--transferfile</b>.

           See also: <b>--transfer</b> <b>--transferfile</b> <b>--sshlogin</b> <b>--cleanup</b> <b>--workdir</b>

       <b>--round-robin</b>
       <b>--round</b>
           Distribute chunks of standard input in a round robin fashion.

           Normally  <b>--pipe</b>  will  give  a  single block to each instance of the command. With <b>--round-robin</b> all
           blocks will at random be written to commands already running. This is useful if the command  takes  a
           long time to initialize.

           With  <b>--keep-order</b> and <b>--round-robin</b> the jobslots will get the same blocks as input in the same order
           in every run if the input is kept the same. See details under <b>--keep-order</b>.

           <b>--round-robin</b> implies <b>--pipe</b>, except if <b>--pipe-part</b> is given.

           See the section: SPREADING BLOCKS OF DATA.

           See also: <b>--bin</b> <b>--group-by</b> <b>--shard</b>

       <b>--rpl</b> '<u>tag</u> <u>perl</u> <u>expression</u>'
           Define replacement string.

           Use <u>tag</u> as a replacement string for <u>perl</u> <u>expression</u>. This  makes  it  possible  to  define  your  own
           replacement strings. GNU <b>parallel</b>'s 7 replacement strings are implemented as:

             --rpl '{} '
             --rpl '{#} 1 $_=$job-&gt;seq()'
             --rpl '{%} 1 $_=$job-&gt;slot()'
             --rpl '{/} s:.*/::'
             --rpl '{//} $Global::use{"File::Basename"} ||=
                         eval "use File::Basename; 1;"; $_ = dirname($_);'
             --rpl '{<a href="file:/.">/.</a>} s:.*/::; s:\.[^<a href="file:/.">/.</a>]+$::;'
             --rpl '{.} s:\.[^<a href="file:/.">/.</a>]+$::'

           The <b>--plus</b> replacement strings are implemented as:

             --rpl '{+/} s:/[^/]*$:: || s:.*$::'
             --rpl '{+.} s:.*\.:: || s:.*$::'
             --rpl '{+..} s:.*\.([^<a href="file:/.">/.</a>]+\.[^<a href="file:/.">/.</a>]+)$:$1: || s:.*$::'
             --rpl '{+...} s:.*\.([^<a href="file:/.">/.</a>]+\.[^<a href="file:/.">/.</a>]+\.[^<a href="file:/.">/.</a>]+)$:$1: || s:.*$::'
             --rpl '{..} s:\.[^<a href="file:/.">/.</a>]+\.[^<a href="file:/.">/.</a>]+$::'
             --rpl '{...} s:\.[^<a href="file:/.">/.</a>]+\.[^<a href="file:/.">/.</a>]+\.[^<a href="file:/.">/.</a>]+$::'
             --rpl '{<a href="file:/..">/..</a>} s:.*/::; s:\.[^<a href="file:/.">/.</a>]+\.[^<a href="file:/.">/.</a>]+$::'
             --rpl '{/...} s:.*/::; s:\.[^<a href="file:/.">/.</a>]+\.[^<a href="file:/.">/.</a>]+\.[^<a href="file:/.">/.</a>]+$::'
             --rpl '{choose_k}
                    for $t (2..$#arg){ if($arg[$t-1] ge $arg[$t]) { skip() } }'
             --rpl '{##} 1 $_=total_jobs()'
             --rpl '{0%} 1 $f=1+int((log($Global::max_jobs_running||1)/
                                     <a href="../man10/log.10.html">log</a>(10))); $_=sprintf("%0${f}d",slot())'
             --rpl '{0#} 1 $f=1+int((log(total_jobs())/<a href="../man10/log.10.html">log</a>(10)));
                         $_=sprintf("%0${f}d",seq())'
             --rpl '{seq(.*?)} $_=eval q{$job-&gt;seq()}.qq{$$1}'
             --rpl '{slot(.*?)} $_=eval q{$job-&gt;slot()}.qq{$$1}'

             --rpl '{:-([^}]+?)} $_ ||= $$1'
             --rpl '{:(\d+?)} substr($_,0,$$1) = ""'
             --rpl '{:(\d+?):(\d+?)} $_ = substr($_,$$1,$$2);'
             --rpl '{#([^#}][^}]*?)} $nongreedy=::make_regexp_ungreedy($$1);
                                     s/^$nongreedy(.*)/$1/;'
             --rpl '{##([^#}][^}]*?)} s/^$$1//;'
             --rpl '{%([^}]+?)} $nongreedy=::make_regexp_ungreedy($$1);
                                s/(.*)$nongreedy$/$1/;'
             --rpl '{%%([^}]+?)} s/$$1$//;'
             --rpl '{/([^}]+?)/([^}]*?)} s/$$1/$$2/;'
             --rpl '{^([^}]+?)} s/^($$1)/uc($1)/e;'
             --rpl '{^^([^}]+?)} s/($$1)/uc($1)/eg;'
             --rpl '{,([^}]+?)} s/^($$1)/lc($1)/e;'
             --rpl '{,,([^}]+?)} s/($$1)/lc($1)/eg;'

             --rpl '{slot} 1 $_="\${PARALLEL_JOBSLOT}";uq()'
             --rpl '{host} 1 $_="\${PARALLEL_SSHHOST}";uq()'
             --rpl '{sshlogin} 1 $_="\${PARALLEL_SSHLOGIN}";uq()'
             --rpl '{hgrp} 1 $_="\${PARALLEL_HOSTGROUPS}";uq()'
             --rpl '{agrp} 1 $_="\${PARALLEL_ARGHOSTGROUPS}";uq()'

           If  the  user  defined  replacement  string  starts  with  '{'  it  can  also be used as a positional
           replacement string (like <b>{2.}</b>).

           It is recommended to only change $_ but you have full  access  to  all  of  GNU  <b>parallel</b>'s  internal
           functions and data structures.

           Here are a few examples:

             Is the job sequence even or odd?
             --rpl '{odd} $_ = seq() % 2 ? "odd" : "even"'
             Pad job sequence with leading zeros to get equal width
             --rpl '{0#} $f=1+int("".(log(total_jobs())/<a href="../man10/log.10.html">log</a>(10)));
               $_=sprintf("%0${f}d",seq())'
             Job sequence counting from 0
             --rpl '{#0} $_ = seq() - 1'
             Job slot counting from 2
             --rpl '{%1} $_ = slot() + 1'
             Remove all extensions
             --rpl '{:} s:(\.[^/]+)*$::'

           You  can  have  dynamic  replacement  strings  by including parenthesis in the replacement string and
           adding a regular expression between the parenthesis. The matching string will be inserted as $$1:

             parallel --rpl '{%(.*?)} s/$$1//' echo {%.tar.gz} ::: my.tar.gz
             parallel --rpl '{:%(.+?)} s:$$1(\.[^/]+)*$::' \
               echo {:%_file} ::: my_file.tar.gz
             parallel -n3 --rpl '{/:%(.*?)} s:.*/(.*)$$1(\.[^/]+)*$:$1:' \
               echo job {#}: {2} {2.} {3/:%_1} ::: a/b.c c/d.e f/g_1.h.i

           You can even use multiple matches:

             parallel --rpl '{/(.+?)/(.*?)} s/$$1/$$2/;'
               echo {/replacethis/withthis} {/b/C} ::: a_replacethis_b

             parallel --rpl '{(.*?)/(.*?)} $_="$$2$_$$1"' \

               echo {swap/these} ::: -middle-
           See also: <b>{=</b><u>perl</u> <u>expression</u><b>=}</b> <b>--parens</b>

       <b>--rsync-opts</b> <u>options</u>
           Options to pass on to <b>rsync</b>.

           Setting <b>--rsync-opts</b> takes precedence over setting the environment variable $PARALLEL_RSYNC_OPTS.

       <b>--max-chars</b> <u>max-chars</u>
       <b>-s</b> <u>max-chars</u>
           Limit length of command.

           Use at most <u>max-chars</u> characters per command line, including the command  and  initial-arguments  and
           the  terminating  nulls  at  the  ends of the argument strings.  The largest allowed value is system-
           dependent, and is calculated  as  the  argument  length  limit  for  exec,  less  the  size  of  your
           environment.  The default value is the maximum.

           <u>max-chars</u> can be postfixed with K, M, G, T, P, k, m, g, t, or p (see UNIT PREFIX).

           Implies <b>-X</b> unless <b>-m</b> or <b>--xargs</b> is set.

           See also: <b>-X</b> <b>-m</b> <b>--xargs</b> <b>--max-line-length-allowed</b> <b>--show-limits</b>

       <b>--show-limits</b>
           Display limits given by the operating system.

           Display  the  limits  on the command-line length which are imposed by the operating system and the <b>-s</b>
           option.  Pipe the input from /dev/null (and perhaps specify --no-run-if-empty) if you don't want  GNU
           <b>parallel</b> to do anything.

           See also: <b>--max-chars</b> <b>--max-line-length-allowed</b> <b>--version</b>

       <b>--semaphore</b>
           Work as a counting semaphore.

           <b>--semaphore</b> will cause GNU <b>parallel</b> to start <u>command</u> in the background. When the number of jobs given
           by  <b>--jobs</b>  is  reached,  GNU <b>parallel</b> will wait for one of these to complete before starting another
           command.

           <b>--semaphore</b> implies <b>--bg</b> unless <b>--fg</b> is specified.

           The command <b>sem</b> is an alias for <b>parallel</b> <b>--semaphore</b>.

           See also: <b>man</b> <b>sem</b> <b>--bg</b> <b>--fg</b> <b>--semaphore-name</b> <b>--semaphore-timeout</b> <b>--wait</b>

       <b>--semaphore-name</b> <u>name</u>
       <b>--id</b> <u>name</u>
           Use <b>name</b> as the name of the semaphore.

           The default is the name of the controlling tty (output from <b>tty</b>).

           The default normally works as expected when used interactively, but when used in a script <u>name</u> should
           be set. <u>$$</u> or <u>my_task_name</u> are often a good value.

           The semaphore is stored in <a href="file:~/.parallel/semaphores/">~/.parallel/semaphores/</a>

           Implies <b>--semaphore</b>.

           See also: <b>man</b> <b>sem</b> <b>--semaphore</b>

       <b>--semaphore-timeout</b> <u>secs</u>
       <b>--st</b> <u>secs</u>
           If <u>secs</u> &gt; 0: If the semaphore is not released within <u>secs</u> seconds, take it anyway.

           If <u>secs</u> &lt; 0: If the semaphore is not released within <u>secs</u> seconds, exit.

           <u>secs</u> is in seconds, but can be postfixed with s, m, h, or d (see the section TIME POSTFIXES).

           Implies <b>--semaphore</b>.

           See also: <b>man</b> <b>sem</b>

       <b>--seqreplace</b> <u>replace-str</u>
           Use the replacement string <u>replace-str</u> instead of <b>{#}</b> for job sequence number.

           See also: <b>{#}</b>

       <b>--session</b>
           Record names in current environment in <b>$PARALLEL_IGNORED_NAMES</b> and exit.

           Only used with <b>env_parallel</b>. Aliases, functions, and variables with names in  <b>$PARALLEL_IGNORED_NAMES</b>
           will not be copied.  So you should set variables/function you want copied <u>after</u> running <b>--session</b>.

           It is similar to <b>--record-env</b>, but only for this session.

           Only supported in <b>Ash,</b> <b>Bash,</b> <b>Dash,</b> <b>Ksh,</b> <b>Sh,</b> <b>and</b> <b>Zsh</b>.

           See also: <b>--env</b> <b>--record-env</b> <b>env_parallel</b>

       <b>--shard</b> <u>shardexpr</u>
           Use <u>shardexpr</u> as shard key and shard input to the jobs.

           <u>shardexpr</u> is [column number|column name] [perlexpression] e.g.:

             3
             Address
             3 $_%=100
             Address s/\d//g

           Each input line is split using <b>--colsep</b>. The string of the column is put into $_, the perl expression
           is  executed,  the resulting string is hashed so that all lines of a given value is given to the same
           job slot.

           This is similar to sharding in databases.

           The performance is in the order of 100K rows per second. Faster  if  the  <u>shardcol</u>  is  small  (&lt;10),
           slower if it is big (&gt;100).

           <b>--shard</b> requires <b>--pipe</b> and a fixed numeric value for <b>--jobs</b>.

           See the section: SPREADING BLOCKS OF DATA.

           See also: <b>--bin</b> <b>--group-by</b> <b>--round-robin</b>

       <b>--shebang</b>
       <b>--hashbang</b>
           GNU  <b>parallel</b>  can  be called as a shebang (#!) command as the first line of a script. The content of
           the file will be treated as inputsource.

           Like this:

             #!/usr/bin/parallel --shebang -r wget

             https://ftpmirror.gnu.org/parallel/parallel-20120822.tar.bz2
             https://ftpmirror.gnu.org/parallel/parallel-20130822.tar.bz2
             https://ftpmirror.gnu.org/parallel/parallel-20140822.tar.bz2

           <b>--shebang</b> must be set as the first option.

           On FreeBSD <b>env</b> is needed:

             #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?env">/usr/bin/env</a> -S parallel --shebang -r wget

             https://ftpmirror.gnu.org/parallel/parallel-20120822.tar.bz2
             https://ftpmirror.gnu.org/parallel/parallel-20130822.tar.bz2
             https://ftpmirror.gnu.org/parallel/parallel-20140822.tar.bz2

           There are many limitations of shebang (#!)  depending  on  your  operating  system.  See  details  on
           https://www.in-ulm.de/~mascheck/various/shebang/

           See also: <b>--shebang-wrap</b>

       <b>--shebang-wrap</b>
           GNU  <b>parallel</b>  can  parallelize  scripts by wrapping the shebang line. If the program can be run like
           this:

             cat arguments | parallel the_program

           then the script can be changed to:

             #!/usr/bin/parallel --shebang-wrap /original/parser --options

           E.g.

             #!/usr/bin/parallel --shebang-wrap /usr/bin/python

           If the program can be run like this:

             cat data | parallel --pipe the_program

           then the script can be changed to:

             #!/usr/bin/parallel --shebang-wrap --pipe /orig/parser --opts

           E.g.

             #!/usr/bin/parallel --shebang-wrap --pipe <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           <b>--shebang-wrap</b> must be set as the first option.

           See also: <b>--shebang</b>

       <b>--shell-completion</b> <u>shell</u>
           Generate shell completion code for interactive shells.

           Supported shells: bash zsh.

           Use <u>auto</u> as <u>shell</u> to automatically detect running shell.

           Activate the completion code with:

             zsh% eval "$(parallel --shell-completion auto)"
             bash$ eval "$(parallel --shell-completion auto)"

           Or put this `/usr/share/zsh/site-functions/_parallel`, then `compinit` to generate `<a href="file:~/.zcompdump">~/.zcompdump</a>`:

             #compdef parallel

             (( $+functions[_comp_parallel] )) ||
               eval "$(parallel --shell-completion auto)" &amp;&amp;
               _comp_parallel

       <b>--shell-quote</b>
           Does not run the command but quotes it. Useful for making quoted composed commands for GNU <b>parallel</b>.

           Multiple <b>--shell-quote</b> with quote the string multiple times, so  <b>parallel</b>  <b>--shell-quote</b>  <b>|</b>  <b>parallel</b>
           <b>--shell-quote</b> can be written as <b>parallel</b> <b>--shell-quote</b> <b>--shell-quote</b>.

           See also: <b>--quote</b>

       <b>--shuf</b>
           Shuffle jobs.

           When  having  multiple input sources it is hard to randomize jobs. <b>--shuf</b> will generate all jobs, and
           shuffle them before running them. This is useful to get a quick preview of the results before running
           the full batch.

           Combined with <b>--halt</b> <b>soon,done=1%</b> you can run a random 1% sample of all jobs:

             parallel --shuf --halt soon,done=1% echo ::: {1..100} ::: {1..100}

           See also: <b>--halt</b>

       <b>--skip-first-line</b>
           Do not use the first line of input (used by GNU <b>parallel</b> itself when called with <b>--shebang</b>).

       <b>--sql</b> <u>DBURL</u> (obsolete)
           Use <b>--sql-master</b> instead.

       <b>--sql-master</b> <u>DBURL</u>
           Submit jobs via SQL server. <u>DBURL</u> must point to a table, which will contain the same  information  as
           <b>--joblog</b>,  the  values from the input sources (stored in columns V1 .. Vn), and the output (stored in
           columns Stdout and Stderr).

           If <u>DBURL</u> is prepended with '+' GNU <b>parallel</b> assumes the  table  is  already  made  with  the  correct
           columns and appends the jobs to it.

           If  <u>DBURL</u>  is not prepended with '+' the table will be dropped and created with the correct amount of
           V-columns unless

           <b>--sqlmaster</b> does not run any jobs, but it creates the values for the jobs to  be  run.  One  or  more
           <b>--sqlworker</b> must be run to actually execute the jobs.

           If <b>--wait</b> is set, GNU <b>parallel</b> will wait for the jobs to complete.

           The format of a DBURL is:

             [sql:]vendor://[[user][:pwd]@][host][:port]/[db]/table

           E.g.

             sql:mysql://hr:hr@localhost:3306/hrdb/jobs
             mysql://scott:<a href="mailto:tiger@my.example.com">tiger@my.example.com</a>/pardb/paralleljobs
             sql:oracle://scott:<a href="mailto:tiger@ora.example.com">tiger@ora.example.com</a>/xe/parjob
             postgresql://scott:<a href="mailto:tiger@pg.example.com">tiger@pg.example.com</a>/pgdb/parjob
             pg:///parjob
             sqlite3:///%2Ftmp%2Fpardb.sqlite/parjob
             csv:///%2Ftmp%2Fpardb/parjob

           Notice  how  /  in  the path of sqlite and CVS must be encoded as %2F. Except the last / in CSV which
           must be a <a href="file:/.">/.</a>

           It can also be an alias from <a href="file:~/.sql/aliases">~/.sql/aliases</a>:

             :myalias mysql:///mydb/paralleljobs

           See also: <b>--sql-and-worker</b> <b>--sql-worker</b> <b>--joblog</b>

       <b>--sql-and-worker</b> <u>DBURL</u>
           Shorthand for: <b>--sql-master</b> <u>DBURL</u> <b>--sql-worker</b> <u>DBURL</u>.

           See also: <b>--sql-master</b> <b>--sql-worker</b>

       <b>--sql-worker</b> <u>DBURL</u>
           Execute jobs via SQL server. Read the input sources variables from the table pointed to by <u>DBURL</u>. The
           <u>command</u> on the command line should be the same as given by <b>--sqlmaster</b>.

           If you have more than one <b>--sqlworker</b> jobs may be run more than once.

           If <b>--sqlworker</b> runs on the local machine, the hostname in the SQL table will not be ':'  but  instead
           the hostname of the machine.

           See also: <b>--sql-master</b> <b>--sql-and-worker</b>

       <b>--ssh</b> <u>sshcommand</u>
           GNU  <b>parallel</b> defaults to using <b>ssh</b> for remote access. This can be overridden with <b>--ssh</b>. It can also
           be set on a per server basis with <b>--sshlogin</b>.

           See also: <b>--sshlogin</b>

       <b>--ssh-delay</b> <u>duration</u>
           Delay starting next ssh by <u>duration</u>.

           GNU <b>parallel</b> will not start another ssh for the next <u>duration</u>.

           <u>duration</u> is in seconds, but can be postfixed with s, m, h, or d.

           See also: TIME POSTFIXES <b>--sshlogin</b> <b>--delay</b>

       <b>--sshlogin</b> <u>[@hostgroups/][ncpus/]sshlogin[,[@hostgroups/][ncpus/]sshlogin[,...]]</u>
       <b>--sshlogin</b> <u>@hostgroup</u>
       <b>-S</b> <u>[@hostgroups/][ncpus/]sshlogin[,[@hostgroups/][ncpus/]sshlogin[,...]]</u>
       <b>-S</b> <u>@hostgroup</u>
           Distribute jobs to remote computers.

           The jobs will be run on a list of remote computers.

           If <u>hostgroups</u> is given, the <u>sshlogin</u> will  be  added  to  that  hostgroup.  Multiple  hostgroups  are
           separated by '+'. The <u>sshlogin</u> will always be added to a hostgroup named the same as <u>sshlogin</u>.

           If  only  the  <u>@hostgroup</u>  is  given,  only  the  sshlogins  in that hostgroup will be used. Multiple
           <u>@hostgroup</u> can be given.

           GNU <b>parallel</b> will determine the number of CPUs on the remote computers and run the number of jobs  as
           specified  by  <b>-j</b>.  If the number <u>ncpus</u> is given GNU <b>parallel</b> will use this number for number of CPUs
           on the host. Normally <u>ncpus</u> will not be needed.

           An <u>sshlogin</u> is of the form:

             [sshcommand [options]] [username[:password]@]hostname

           If <u>password</u> is given, <b>sshpass</b> will be used. Otherwise the sshlogin must not require a password  (<b>ssh-</b>
           <b>agent</b> and <b>ssh-copy-id</b> may help with that).

           If  the  hostname  is an IPv6 address, the port can be given separated with p or #. If the address is
           enclosed in [] you can also use :.  E.g. ::1p2222 ::1#2222 [::1]:2222

           Ranges of hostnames can be given in [] like this: server[1,3,8-10] (for  server1,  server3,  server8,
           server9,  server10)  or  server[001,003,008-010]  (for  server001,  server003,  server008, server009,
           server010). With Bash's brace expansion you  can  do:  -S{dev,prod}[001-100]  to  get  -Sdev[001-100]
           -Sprod[001-100] More [] are allowed: server[1-10].cluster[1-5].example.net

           The sshlogin ':' is special, it means 'no ssh' and will therefore run on the local computer.

           The    sshlogin   '..'   is   special,   it   read   sshlogins   from   <a href="file:~/.parallel/sshloginfile">~/.parallel/sshloginfile</a>   or
           $XDG_CONFIG_HOME/parallel/sshloginfile

           The sshlogin '-' is special, too, it read sshlogins from stdin (standard input).

           To specify more sshlogins separate the sshlogins by comma, newline (in the same  string),  or  repeat
           the options multiple times.

           GNU  <b>parallel</b>  splits on , (comma) so if your sshlogin contains , (comma) you need to replace it with
           \, or ,,

           For examples: see <b>--sshloginfile</b>.

           The remote host must have GNU <b>parallel</b> installed.

           <b>--sshlogin</b> is known to cause problems with <b>-m</b> and <b>-X</b>.

           See also: <b>--basefile</b> <b>--transferfile</b> <b>--return</b> <b>--cleanup</b> <b>--trc</b> <b>--sshloginfile</b> <b>--workdir</b>  <b>--filter-hosts</b>
           <b>--ssh</b>

       <b>--sshloginfile</b> <u>filename</u>
       <b>--slf</b> <u>filename</u>
           File with sshlogins. The file consists of sshlogins on separate lines. Empty lines and lines starting
           with '#' are ignored. Example:

             server.example.com
             <a href="mailto:username@server2.example.com">username@server2.example.com</a>
             8/my-8-cpu-server.example.com
             2/<a href="mailto:my_other_username@my-dualcore.example.net">my_other_username@my-dualcore.example.net</a>
             # This server has SSH running on port 2222
             ssh -p 2222 server.example.net
             4/ssh -p 2222 quadserver.example.net
             # Use a different ssh program
             myssh -p 2222 -l myusername hexacpu.example.net
             # Use a different ssh program with default number of CPUs
             //usr/local/bin/myssh -p 2222 -l myusername hexacpu
             # Use a different ssh program with 6 CPUs
             6//usr/local/bin/myssh -p 2222 -l myusername hexacpu
             # Assume 16 CPUs on the local computer
             16/:
             # Put server1 in hostgroup1
             @hostgroup1/server1
             # Put myusername@server2 in hostgroup1+hostgroup2
             @hostgroup1+hostgroup2/myusername@server2
             # Force 4 CPUs and put 'ssh -p 2222 server3' in hostgroup1
             @hostgroup1/4/ssh -p 2222 server3

           When using a different ssh program the last argument must be the hostname.

           Multiple <b>--sshloginfile</b> are allowed.

           GNU  <b>parallel</b>  will  first  look  for  the file in current dir; if that fails it look for the file in
           <a href="file:~/.parallel.">~/.parallel.</a>

           The sshloginfile '..' is special, it read sshlogins from <a href="file:~/.parallel/sshloginfile">~/.parallel/sshloginfile</a>

           The sshloginfile '.' is special, it read sshlogins from /etc/parallel/sshloginfile

           The sshloginfile '-' is special, too, it read sshlogins from stdin (standard input).

           If the sshloginfile is changed it will be re-read when a job finishes though at most once per second.
           This makes it possible to add and remove hosts while running.

           This can be used to have a daemon that updates the sshloginfile to only contain servers that are up:

               cp original.slf tmp2.slf
               while [ 1 ] ; do
                 nice parallel --nonall -j0 -k --slf original.slf \
                   --tag echo | perl 's/\t$//' &gt; tmp.slf
                 if diff tmp.slf tmp2.slf; then
                   mv tmp.slf tmp2.slf
                 fi
                 sleep 10
               done &amp;
               parallel --slf tmp2.slf ...

           See also: <b>--filter-hosts</b>

       <b>--slotreplace</b> <u>replace-str</u>
           Use the replacement string <u>replace-str</u> instead of <b>{%}</b> for job slot number.

           See also: <b>{%}</b>

       <b>--silent</b>
           Silent.

           The job to be run will not be printed. This is the default.  Can be reversed with <b>-v</b>.

           See also: <b>-v</b>

       <b>--template</b> <u>file</u>=<u>repl</u>
       <b>--tmpl</b> <u>file</u>=<u>repl</u>
           Replace replacement strings in <u>file</u> and save it in <u>repl</u>.

           All replacement strings in the contents of <u>file</u> will be replaced. All replacement strings in the name
           <u>repl</u> will be replaced.

           With <b>--cleanup</b> the new file will be removed when the job is done.

           If <u>my.tmpl</u> contains this:

             Xval: {x}
             Yval: {y}
             FixedValue: 9
             # x with 2 decimals
             DecimalX: {=x $_=sprintf("%.2f",$_) =}
             TenX: {=x $_=$_*10 =}
             RandomVal: {=1 $_=rand() =}

           it can be used like this:

             myprog() { echo Using "$@"; cat "$@"; }
             export -f myprog
             parallel --cleanup --header : --tmpl my.tmpl={#}.t myprog {#}.t \
               ::: x 1.234 2.345 3.45678 ::: y 1 2 3

           See also: <b>{}</b> <b>--cleanup</b>

       <b>--tty</b>
           Open terminal tty.

           If GNU <b>parallel</b> is used for starting a program that accesses the tty (such as an interactive program)
           then this option may be needed. It will default to starting only one job at a time  (i.e.  <b>-j1</b>),  not
           buffer the output (i.e. <b>-u</b>), and it will open a tty for the job.

           You can of course override <b>-j1</b> and <b>-u</b>.

           Using <b>--tty</b> unfortunately means that GNU <b>parallel</b> cannot kill the jobs (with <b>--timeout</b>, <b>--memfree</b>, or
           <b>--halt</b>).  This  is due to GNU <b>parallel</b> giving each child its own process group, which is then killed.
           Process groups are dependant on the tty.

           See also: <b>--ungroup</b> <b>--open-tty</b>

       <b>--tag</b>
           Tag lines with arguments.

           Each output line will be prepended with the arguments and TAB (\t). When  combined  with  <b>--onall</b>  or
           <b>--nonall</b> the lines will be prepended with the sshlogin instead.

           <b>--tag</b> is ignored when using <b>-u</b>.

           See also: <b>--tagstring</b> <b>--ctag</b>

       <b>--tagstring</b> <u>str</u>
           Tag lines with a string.

           Each output line will be prepended with <u>str</u> and TAB (\t). <u>str</u> can contain replacement strings such as
           <b>{}</b>.

           <b>--tagstring</b> is ignored when using <b>-u</b>, <b>--onall</b>, and <b>--nonall</b>.

           See also: <b>--tag</b> <b>--ctagstring</b>

       <b>--tee</b>
           Pipe all data to all jobs.

           Used with <b>--pipe</b>/<b>--pipe-part</b> and <b>:::</b>.

             seq 1000 | parallel --pipe --tee -v wc {} ::: -w -l -c

           How many numbers in 1..1000 contain 0..9, and how many bytes do they fill:

             seq 1000 | parallel --pipe --tee --tag \
               'grep {1} | wc {2}' ::: {0..9} ::: -l -c

           How many words contain a..z and how many bytes do they fill?

             parallel -a /usr/share/dict/words --pipe-part --tee --tag \
               'grep {1} | wc {2}' ::: {a..z} ::: -l -c

           See also: <b>:::</b> <b>--pipe</b> <b>--pipe-part</b>

       <b>--term-seq</b> <u>sequence</u>
           Termination sequence.

           When  a  job  is killed due to <b>--timeout</b>, <b>--memfree</b>, <b>--halt</b>, or abnormal termination of GNU <b>parallel</b>,
           <u>sequence</u> determines how the job is killed. The default is:

               TERM,200,TERM,100,TERM,50,KILL,25

           which sends a TERM signal, waits 200 ms, sends another TERM signal, waits 100 ms, sends another  TERM
           signal,  waits  50 ms, sends a KILL signal, waits 25 ms, and exits. GNU <b>parallel</b> detects if a process
           dies before the waiting time is up.

           See also: <b>--halt</b> <b>--timeout</b> <b>--memfree</b>

       <b>--total-jobs</b> <u>jobs</u>
       <b>--total</b> <u>jobs</u>
           Provide the total number of jobs for computing ETA which is also used for <b>--bar</b>.

           Without <b>--total-jobs</b> GNU Parallel will read all jobs before starting a job. <b>--total-jobs</b> is useful if
           the input is generated slowly.

           See also: <b>--bar</b> <b>--eta</b>

       <b>--tmpdir</b> <u>dirname</u>
           Directory for temporary files.

           GNU <b>parallel</b> normally buffers output into temporary files in /tmp. By setting <b>--tmpdir</b> you can use  a
           different dir for the files. Setting <b>--tmpdir</b> is equivalent to setting $TMPDIR.

           See also: <b>--compress</b> <b>$TMPDIR</b> <b>$PARALLEL_REMOTE_TMPDIR</b>

       <b>--tmux</b> (Long beta testing)
           Use  <b>tmux</b>  for  output.  Start  a <b>tmux</b> session and run each job in a window in that session. No other
           output will be produced.

           See also: <b>--tmuxpane</b>

       <b>--tmuxpane</b> (Long beta testing)
           Use <b>tmux</b> for output but put output into panes in the first window.  Useful if you want to monitor the
           progress of less than 100 concurrent jobs.

           See also: <b>--tmux</b>

       <b>--timeout</b> <u>duration</u>
           Time out for command. If the command runs for longer than <u>duration</u> seconds it will get killed as  per
           <b>--term-seq</b>.

           If  <u>duration</u>  is followed by a % then the timeout will dynamically be computed as a percentage of the
           median average runtime of successful jobs. Only values &gt; 100% will make sense.

           <u>duration</u> is in seconds, but can be postfixed with s, m, h, or d.

           See also: TIME POSTFIXES <b>--term-seq</b> <b>--retries</b>

       <b>--verbose</b>
       <b>-t</b>  Print the job to be run on stderr (standard error).

           See also: <b>-v</b> <b>--interactive</b>

       <b>--transfer</b>
           Transfer files to remote computers.

           Shorthand for: <b>--transferfile</b> <b>{}</b>.

           See also: <b>--transferfile</b>.

       <b>--transferfile</b> <u>filename</u>
       <b>--tf</b> <u>filename</u>
           Transfer <u>filename</u> to remote computers.

           <b>--transferfile</b> is used with <b>--sshlogin</b> to transfer files to the remote computers. The files  will  be
           transferred using <b>rsync</b> and will be put relative to the work dir.

           The <u>filename</u> will normally contain a replacement string.

           If  the  path  contains  <a href="file:/./">/./</a>  the  remaining  path will be relative to the work dir (for details: see
           <b>rsync</b>). If the work dir is <b>/home/user</b>, the transferring will be as follows:

             /tmp/foo/bar   =&gt; /tmp/foo/bar
             tmp/foo/bar    =&gt; /home/user/tmp/foo/bar
             /tmp/./foo/bar =&gt; /home/user/foo/bar
             tmp/./foo/bar  =&gt; /home/user/foo/bar

           <u>Examples</u>

           This  will  transfer  the  file  <u>foo/bar.txt</u>  to  the  computer  <u>server.example.com</u>   to   the   file
           <u>$HOME/foo/bar.txt</u> before running <b>wc</b> <b>foo/bar.txt</b> on <u>server.example.com</u>:

             echo foo/bar.txt | parallel --transferfile {} \
               --sshlogin server.example.com wc

           This  will  transfer  the  file  <u>/tmp/foo/bar.txt</u>  to  the  computer  <u>server.example.com</u>  to the file
           <u>/tmp/foo/bar.txt</u> before running <b>wc</b> <b>/tmp/foo/bar.txt</b> on <u>server.example.com</u>:

             echo /tmp/foo/bar.txt | parallel --transferfile {} \
               --sshlogin server.example.com wc

           This will transfer  the  file  <u>/tmp/foo/bar.txt</u>  to  the  computer  <u>server.example.com</u>  to  the  file
           <u>foo/bar.txt</u> before running <b>wc</b> <b>./foo/bar.txt</b> on <u>server.example.com</u>:

             echo /tmp/./foo/bar.txt | parallel --transferfile {} \
               --sshlogin server.example.com wc {= s:.*/\./:./: =}

           <b>--transferfile</b>  is  often  used  with  <b>--return</b>  and  <b>--cleanup</b>. A shorthand for <b>--transferfile</b> <b>{}</b> is
           <b>--transfer</b>.

           <b>--transferfile</b> is ignored when used with <b>--sshlogin</b> <b>:</b> or when not used with <b>--sshlogin</b>.

           See also: <b>--workdir</b> <b>--sshlogin</b> <b>--basefile</b> <b>--return</b> <b>--cleanup</b>

       <b>--trc</b> <u>filename</u>
           Transfer, Return, Cleanup. Shorthand for: <b>--transfer</b> <b>--return</b> <u>filename</u> <b>--cleanup</b>

           See also: <b>--transfer</b> <b>--return</b> <b>--cleanup</b>

       <b>--trim</b> &lt;n|l|r|lr|rl&gt;
           Trim white space in input.

           n   No trim. Input is not modified. This is the default.

           l   Left trim. Remove white space from start of input. E.g. " a bc " -&gt; "a bc ".

           r   Right trim. Remove white space from end of input. E.g. " a bc " -&gt; " a bc".

           lr
           rl  Both trim. Remove white space from both start and end of input. E.g. " a bc " -&gt; "a bc". This  is
               the default if <b>--colsep</b> is used.

           See also: <b>--no-run-if-empty</b> <b>{}</b> <b>--colsep</b>

       <b>--ungroup</b>
       <b>-u</b>  Ungroup output.

           Output  is  printed as soon as possible and bypasses GNU <b>parallel</b> internal processing. This may cause
           output from different commands to be mixed thus should only be used if you  do  not  care  about  the
           output. Compare these:

             seq 4 | parallel -j0 \
               'sleep {};echo -n start{};sleep {};echo {}end'
             seq 4 | parallel -u -j0 \
               'sleep {};echo -n start{};sleep {};echo {}end'

           It also disables <b>--tag</b>. GNU <b>parallel</b> outputs faster with <b>-u</b>. Compare the speeds of these:

             parallel seq ::: 300000000 &gt;/dev/null
             parallel -u seq ::: 300000000 &gt;/dev/null
             parallel --line-buffer seq ::: 300000000 &gt;/dev/null

           Can be reversed with <b>--group</b>.

           See also: <b>--line-buffer</b> <b>--group</b>

       <b>--extensionreplace</b> <u>replace-str</u>
       <b>--er</b> <u>replace-str</u>
           Use the replacement string <u>replace-str</u> instead of <b>{.}</b> for input line without extension.

           See also: <b>{.}</b>

       <b>--use-sockets-instead-of-threads</b>
           See also: <b>--use-cores-instead-of-threads</b>

       <b>--use-cores-instead-of-threads</b>
       <b>--use-cpus-instead-of-cores</b> (obsolete)
           Determine how GNU <b>parallel</b> counts the number of CPUs.

           GNU <b>parallel</b> uses this number when the number of jobslots (<b>--jobs</b>) is computed relative to the number
           of CPUs (e.g. 100% or +1).

           CPUs can be counted in three different ways:

           sockets The number of filled CPU sockets (i.e. the number of physical chips).

           cores   The number of physical cores (i.e. the number of physical compute cores).

           threads The  number  of  hyperthreaded  cores  (i.e.  the number of virtual cores - with some of them
                   possibly being hyperthreaded)

           Normally   the   number   of   CPUs   is   computed   as   the   number   of   CPU   threads.    With
           <b>--use-sockets-instead-of-threads</b> or <b>--use-cores-instead-of-threads</b> you can force it to be computed as
           the number of filled sockets or number of cores instead.

           Most users will not need these options.

           <b>--use-cpus-instead-of-cores</b>  is a (misleading) alias for <b>--use-sockets-instead-of-threads</b> and is kept
           for backwards compatibility.

           See also: <b>--number-of-threads</b> <b>--number-of-cores</b> <b>--number-of-sockets</b>

       <b>-v</b>  Verbose.

           Print the job to be run on stdout (standard output). Can be reversed with <b>--silent</b>.

           Use <b>-v</b> <b>-v</b> to print the wrapping ssh command when running remotely.

           See also: <b>-t</b>

       <b>--version</b>
       <b>-V</b>  Print the version GNU <b>parallel</b> and exit.

       <b>--workdir</b> <u>mydir</u>
       <b>--wd</b> <u>mydir</u>
           Jobs will be run in the dir <u>mydir</u>. The default is the current dir for  the  local  machine,  and  the
           login dir for remote computers.

           Files transferred using <b>--transferfile</b> and <b>--return</b> will be relative to <u>mydir</u> on remote computers.

           The  special  <u>mydir</u>  value <b>...</b> will create working dirs under <b><a href="file:~/.parallel/tmp/">~/.parallel/tmp/</a></b>. If <b>--cleanup</b> is given
           these dirs will be removed.

           The special <u>mydir</u> value <b>.</b> uses the current working dir.  If the current working dir is  beneath  your
           home  dir, the value <b>.</b> is treated as the relative path to your home dir. This means that if your home
           dir is different on remote computers (e.g. if your login is different) the relative path  will  still
           be relative to your home dir.

           To see the difference try:

             parallel -S server pwd ::: ""
             parallel --wd . -S server pwd ::: ""
             parallel --wd ... -S server pwd ::: ""

           <u>mydir</u> can contain GNU <b>parallel</b>'s replacement strings.

       <b>--wait</b>
           Wait for all commands to complete.

           Used with <b>--semaphore</b> or <b>--sqlmaster</b>.

           See also: <b>man</b> <b>sem</b>

       <b>-X</b>  Multiple arguments with context replace. Insert as many arguments as the command line length permits.
           If  multiple  jobs are being run in parallel: distribute the arguments evenly among the jobs. Use <b>-j1</b>
           to avoid this.

           If <b>{}</b> is not used the arguments will be appended to the line.  If <b>{}</b> is used as part of a word  (like
           <u>pic{}.jpg</u>)  then  the  whole  word  will  be  repeated.  If <b>{}</b> is used multiple times each <b>{}</b> will be
           replaced with the arguments.

           Normally <b>-X</b> will do the right thing, whereas <b>-m</b> can give unexpected results if <b>{}</b> is used as part  of
           a word.

           Support for <b>-X</b> with <b>--sshlogin</b> is limited and may fail.

           See also: <b>-m</b>

       <b>--exit</b>
       <b>-x</b>  Exit if the size (see the <b>-s</b> option) is exceeded.

       <b>--xargs</b>
           Multiple arguments. Insert as many arguments as the command line length permits.

           If  <b>{}</b>  is not used the arguments will be appended to the line.  If <b>{}</b> is used multiple times each <b>{}</b>
           will be replaced with all the arguments.

           Support for <b>--xargs</b> with <b>--sshlogin</b> is limited and may fail.

           See also: <b>-X</b>

</pre><h4><b>EXAMPLES</b></h4><pre>
       See: <b>man</b> <b>parallel_examples</b>

</pre><h4><b>SPREADING</b> <b>BLOCKS</b> <b>OF</b> <b>DATA</b></h4><pre>
       <b>--round-robin</b>, <b>--pipe-part</b>, <b>--shard</b>, <b>--bin</b> and <b>--group-by</b> are all specialized versions of <b>--pipe</b>.

       In the following <u>n</u> is the number of jobslots given by <b>--jobs</b>. A record starts with  <b>--recstart</b>  and  ends
       with <b>--recend</b>. It is typically a full line. A chunk is a number of full records that is approximately the
       size of a block. A block can contain half records, a chunk cannot.

       <b>--pipe</b>  starts one job per chunk. It reads blocks from stdin (standard input). It finds a record end near
       a block border and passes a chunk to the program.

       <b>--pipe-part</b> starts one job per chunk - just like normal <b>--pipe</b>. It first finds record  endings  near  all
       block  borders  in  the  file and then starts the jobs. By using <b>--block</b> <b>-1</b> it will set the block size to
       size-of-file/<u>n</u>. Used this way it will start <u>n</u> jobs in total.

       <b>--round-robin</b> starts <u>n</u> jobs in total. It reads a block and passes a chunk to whichever job  is  ready  to
       read.  It  does  not  parse  the  content except for identifying where a record ends to make sure it only
       passes full records.

       <b>--shard</b> starts <u>n</u> jobs in total. It parses each line to read the string in the given column. Based on this
       string the line is passed to one of the <u>n</u> jobs. All lines having this string will be given  to  the  same
       jobslot.

       <b>--bin</b> works like <b>--shard</b> but the value of the column must be numeric and is the jobslot number it will be
       passed  to.  If  the  value is bigger than <u>n</u>, then <u>n</u> will be subtracted from the value until the value is
       smaller than or equal to <u>n</u>.

       <b>--group-by</b> starts one job per chunk. Record borders are  not  given  by  <b>--recend</b>/<b>--recstart</b>.  Instead  a
       record  is defined by a group of lines having the same string in a given column. So the string of a given
       column changes at a chunk border. With <b>--pipe</b> every line is parsed, with <b>--pipe-part</b> only a few lines are
       parsed to find the chunk border.

       <b>--group-by</b> can be combined with <b>--round-robin</b> or <b>--pipe-part</b>.

</pre><h4><b>TIME</b> <b>POSTFIXES</b></h4><pre>
       Arguments that give a duration are given in seconds, but can be expressed as floats postfixed with <b>s</b>,  <b>m</b>,
       <b>h</b>,  or  <b>d</b>  which would multiply the float by 1, 60, 60*60, or 60*60*24. Thus these are equivalent: 100000
       and 1d3.5h16.6m4s.

</pre><h4><b>UNIT</b> <b>PREFIX</b></h4><pre>
       Many numerical arguments in GNU <b>parallel</b> can be postfixed with K, M, G, T, P, k, m,  g,  t,  or  p  which
       would multiply the number with 1024, 1048576, 1073741824, 1099511627776, 1125899906842624, 1000, 1000000,
       1000000000, 1000000000000, or 1000000000000000, respectively.

       You can even give it as a math expression. E.g. 1000000 can be written as 1M-12*2.024*2k.

</pre><h4><b>QUOTING</b></h4><pre>
       GNU  <b>parallel</b>  is very liberal in quoting. You only need to quote characters that have special meaning in
       shell:

         ( ) $ ` ' " &lt; &gt; ; | \

       and depending on context these needs to be quoted, too:

         ~ &amp; # ! ? space * {

       Therefore most people will never need more quoting than putting '\' in front of the special characters.

       Often you can simply put \' around every ':

         perl -ne '/^\S+\s+\S+$/ and print $ARGV,"\n"' file

       can be quoted:

         parallel perl -ne \''/^\S+\s+\S+$/ and print $ARGV,"\n"'\' ::: file

       However, when you want to use a shell variable you need to quote the $-sign. Here  is  an  example  using
       $PARALLEL_SEQ.  This  variable  is set by GNU <b>parallel</b> itself, so the evaluation of the $ must be done by
       the sub shell started by GNU <b>parallel</b>:

         seq 10 | parallel -N2 echo seq:\$PARALLEL_SEQ arg1:{1} arg2:{2}

       If the variable is set before GNU <b>parallel</b> starts you can do this:

         VAR=this_is_set_before_starting
         echo test | parallel echo {} $VAR

       Prints: <b>test</b> <b>this_is_set_before_starting</b>

       It is a little more tricky if the variable contains more than one space in a row:

         VAR="two  spaces  between  each  word"
         echo test | parallel echo {} \'"$VAR"\'

       Prints: <b>test</b> <b>two</b>  <b>spaces</b>  <b>between</b>  <b>each</b>  <b>word</b>

       If the variable should not be evaluated by the shell starting GNU <b>parallel</b> but be evaluated  by  the  sub
       shell started by GNU <b>parallel</b>, then you need to quote it:

         echo test | parallel VAR=this_is_set_after_starting \; echo {} \$VAR

       Prints: <b>test</b> <b>this_is_set_after_starting</b>

       It is a little more tricky if the variable contains space:

         echo test |\
           parallel VAR='"two  spaces  between  each  word"' echo {} \'"$VAR"\'

       Prints: <b>test</b> <b>two</b>  <b>spaces</b>  <b>between</b>  <b>each</b>  <b>word</b>

       $$  is  the  shell variable containing the process id of the shell. This will print the process id of the
       shell running GNU <b>parallel</b>:

         seq 10 | parallel echo $$

       And this will print the process ids of the sub shells started by GNU <b>parallel</b>.

         seq 10 | parallel echo \$\$

       If the special characters should not be evaluated by the sub shell then you need to  protect  it  against
       evaluation from both the shell starting GNU <b>parallel</b> and the sub shell:

         echo test | parallel echo {} \\\$VAR

       Prints: <b>test</b> <b>$VAR</b>

       GNU <b>parallel</b> can protect against evaluation by the sub shell by using -q:

         echo test | parallel -q echo {} \$VAR

       Prints: <b>test</b> <b>$VAR</b>

       This is particularly useful if you have lots of quoting. If you want to run a perl script like this:

         perl -ne '/^\S+\s+\S+$/ and print $ARGV,"\n"' file

       It needs to be quoted like one of these:

         ls | parallel perl -ne '/^\\S+\\s+\\S+\$/\ and\ print\ \$ARGV,\"\\n\"'
         ls | parallel perl -ne \''/^\S+\s+\S+$/ and print $ARGV,"\n"'\'

       Notice  how  spaces, \'s, "'s, and $'s need to be quoted. GNU <b>parallel</b> can do the quoting by using option
       -q:

         ls | parallel -q  perl -ne '/^\S+\s+\S+$/ and print $ARGV,"\n"'

       However, this means you cannot make the sub shell interpret special characters. For example because of <b>-q</b>
       this WILL NOT WORK:

         ls *.gz | parallel -q "zcat {} &gt;{.}"
         ls *.gz | parallel -q "zcat {} | bzip2 &gt;{.}.bz2"

       because &gt; and | need to be interpreted by the sub shell.

       If you get errors like:

         sh: -c: line 0: syntax error near unexpected token
         sh: Syntax error: Unterminated quoted string
         sh: -c: line 0: unexpected EOF while looking for matching `''
         sh: -c: line 1: syntax error: unexpected end of file
         zsh:1: no matches found:

       then you might try using <b>-q</b>.

       If you are using <b>bash</b> process substitution like <b>&lt;(cat</b> <b>foo)</b> then you may try  <b>-q</b>  and  prepending  <u>command</u>
       with <b>bash</b> <b>-c</b>:

         ls | parallel -q bash -c 'wc -c &lt;(echo {})'

       Or for substituting output:

         ls | parallel -q bash -c \
           'tar c {} | tee &gt;(gzip &gt;{}.tar.gz) | bzip2 &gt;{}.tar.bz2'

       <b>Conclusion</b>:  If this is confusing consider avoiding having to deal with quoting by writing a small script
       or a function (remember to <b>export</b> <b>-f</b> the function) and have GNU <b>parallel</b> call that.

</pre><h4><b>LIST</b> <b>RUNNING</b> <b>JOBS</b></h4><pre>
       If you want a list of the jobs currently running you can run:

         killall -USR1 parallel

       GNU <b>parallel</b> will then print the currently running jobs on stderr (standard error).

</pre><h4><b>COMPLETE</b> <b>RUNNING</b> <b>JOBS</b> <b>BUT</b> <b>DO</b> <b>NOT</b> <b>START</b> <b>NEW</b> <b>JOBS</b></h4><pre>
       If you regret starting a lot of jobs you can simply break GNU <b>parallel</b>, but if you want to make sure  you
       do not have half-completed jobs you should send the signal <b>SIGHUP</b> to GNU <b>parallel</b>:

         killall -HUP parallel

       This  will  tell  GNU  <b>parallel</b>  to not start any new jobs, but wait until the currently running jobs are
       finished before exiting.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       $PARALLEL_HOME
                Dir where  GNU  <b>parallel</b>  stores  config  files,  semaphores,  and  caches  information  between
                invocations. If set to a non-existent dir, the dir will be created.

                Default: $HOME/.parallel.

       $PARALLEL_ARGHOSTGROUPS
                When using <b>--hostgroups</b> GNU <b>parallel</b> sets this to the hostgroups of the job.

                Remember to quote the $, so it gets evaluated by the correct shell. Or use <b>--plus</b> and {agrp}.

       $PARALLEL_HOSTGROUPS
                When using <b>--hostgroups</b> GNU <b>parallel</b> sets this to the hostgroups of the sshlogin that the job is
                run on.

                Remember to quote the $, so it gets evaluated by the correct shell. Or use <b>--plus</b> and {hgrp}.

       $PARALLEL_JOBSLOT
                Set by GNU <b>parallel</b> and can be used in jobs run by GNU <b>parallel</b>.  Remember to quote the $, so it
                gets evaluated by the correct shell. Or use <b>--plus</b> and {slot}.

                $PARALLEL_JOBSLOT is the jobslot of the job. It is equal to {%} unless the job is being retried.
                See {%} for details.

       $PARALLEL_PID
                Set by GNU <b>parallel</b> and can be used in jobs run by GNU <b>parallel</b>.  Remember to quote the $, so it
                gets evaluated by the correct shell.

                This makes it possible for the jobs to communicate directly to GNU <b>parallel</b>.

                <b>Example:</b>  If  each  of  the jobs tests a solution and one of jobs finds the solution the job can
                tell GNU <b>parallel</b> not to start more jobs by: <b>kill</b> <b>-HUP</b> <b>$PARALLEL_PID</b>. This  only  works  on  the
                local computer.

       $PARALLEL_RSYNC_OPTS
                Options to pass on to <b>rsync</b>. Defaults to: -rlDzR.

       $PARALLEL_SHELL
                Use this shell for the commands run by GNU <b>parallel</b>:

                 $PARALLEL_SHELL. If undefined use:

                 The shell that started GNU <b>parallel</b>. If that cannot be determined:

                 $SHELL. If undefined use:

                 <a href="file:/bin/sh">/bin/sh</a>

       $PARALLEL_SSH
                GNU  <b>parallel</b>  defaults  to using the <b>ssh</b> command for remote access. This can be overridden with
                $PARALLEL_SSH, which again can be overridden with <b>--ssh</b>. It can also be  set  on  a  per  server
                basis (see <b>--sshlogin</b>).

       $PARALLEL_SSHHOST
                Set by GNU <b>parallel</b> and can be used in jobs run by GNU <b>parallel</b>.  Remember to quote the $, so it
                gets evaluated by the correct shell. Or use <b>--plus</b> and {host}.

                $PARALLEL_SSHHOST is the host part of an sshlogin line. E.g.

                  4//usr/bin/specialssh user@host

                becomes:

                  host

       $PARALLEL_SSHLOGIN
                Set by GNU <b>parallel</b> and can be used in jobs run by GNU <b>parallel</b>.  Remember to quote the $, so it
                gets evaluated by the correct shell. Or use <b>--plus</b> and {sshlogin}.

                The value is the sshlogin line with number of threads removed. E.g.

                  4//usr/bin/specialssh user@host

                becomes:

                  /usr/bin/specialssh user@host

       $PARALLEL_SEQ
                Set by GNU <b>parallel</b> and can be used in jobs run by GNU <b>parallel</b>.  Remember to quote the $, so it
                gets evaluated by the correct shell.

                $PARALLEL_SEQ is the sequence number of the job running.

                <b>Example:</b>

                  seq 10 | parallel -N2 \
                    echo seq:'$'PARALLEL_SEQ arg1:{1} arg2:{2}

                {#} is a shorthand for $PARALLEL_SEQ.

       $PARALLEL_TMUX
                Path to <b>tmux</b>. If unset the <b>tmux</b> in $PATH is used.

       $TMPDIR  Directory for temporary files.

                See also: <b>--tmpdir</b>

       $PARALLEL_REMOTE_TMPDIR
                Directory for temporary files on remote servers.

                See also: <b>--tmpdir</b>

       $PARALLEL
                The  environment  variable  $PARALLEL  will  be used as default options for GNU <b>parallel</b>. If the
                variable contains special shell characters (e.g. $, *, or space) then these need  to  be  to  be
                escaped with \.

                <b>Example:</b>

                  cat list | parallel -j1 -k -v ls
                  cat list | parallel -j1 -k -v -S"myssh user@server" ls

                can be written as:

                  cat list | PARALLEL="-kvj1" parallel ls
                  cat list | PARALLEL='-kvj1 -S myssh\ user@server' \
                    parallel echo

                Notice the \ after 'myssh' is needed because 'myssh' and 'user@server' must be one argument.

                See also: <b>--profile</b>

</pre><h4><b>DEFAULT</b> <b>PROFILE</b> <b>(CONFIG</b> <b>FILE)</b></h4><pre>
       The   global   configuration   file   /etc/parallel/config,   followed   by   user   configuration   file
       <a href="file:~/.parallel/config">~/.parallel/config</a> (formerly known as .parallelrc) will be read in turn if they  exist.   Lines  starting
       with  '#'  will  be  ignored. The format can follow that of the environment variable $PARALLEL, but it is
       often easier to simply put each option on its own line.

       Options on the command line take  precedence,  followed  by  the  environment  variable  $PARALLEL,  user
       configuration file <a href="file:~/.parallel/config">~/.parallel/config</a>, and finally the global configuration file /etc/parallel/config.

       Note  that  no file that is read for options, nor the environment variable $PARALLEL, may contain retired
       options such as <b>--tollef</b>.

</pre><h4><b>PROFILE</b> <b>FILES</b></h4><pre>
       If <b>--profile</b> set, GNU <b>parallel</b> will read the profile from that  file  rather  than  the  global  or  user
       configuration files. You can have multiple <b>--profiles</b>.

       Profiles  are  searched  for in <b><a href="file:~/.parallel">~/.parallel</a></b>. If the name starts with <b>/</b> it is seen as an absolute path. If
       the name starts with <b>./</b> it is seen as a relative path from current dir.

       Example: Profile for running a command on every sshlogin in <a href="file:~/.ssh/sshlogins">~/.ssh/sshlogins</a> and prepend the output  with
       the sshlogin:

         echo --tag -S .. --nonall &gt; <a href="file:~/.parallel/nonall_profile">~/.parallel/nonall_profile</a>
         parallel -J nonall_profile uptime

       Example: Profile for running every command with <b>-j-1</b> and <b>nice</b>

         echo -j-1 nice &gt; <a href="file:~/.parallel/nice_profile">~/.parallel/nice_profile</a>
         parallel -J nice_profile bzip2 -9 ::: *

       Example: Profile for running a perl script before every command:

         echo "perl -e '\$a=\$\$; print \$a,\" \",'\$PARALLEL_SEQ',\" \";';" \
           &gt; <a href="file:~/.parallel/pre_perl">~/.parallel/pre_perl</a>
         parallel -J pre_perl echo ::: *

       Note how the $ and " need to be quoted using \.

       Example: Profile for running distributed jobs with <b>nice</b> on the remote computers:

         echo -S .. nice &gt; <a href="file:~/.parallel/dist">~/.parallel/dist</a>
         parallel -J dist --trc {.}.bz2 bzip2 -9 ::: *

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       Exit status depends on <b>--halt-on-error</b> if one of these is used: success=X, success=Y%, fail=Y%.

       0     All  jobs ran without error. If success=X is used: X jobs ran without error. If success=Y% is used:
             Y% of the jobs ran without error.

       1-100 Some of the jobs failed. The exit status gives the number of failed jobs. If Y% is  used  the  exit
             status is the percentage of jobs that failed.

       101   More than 100 jobs failed.

       255   Other error.

       -1 (In joblog and SQL table)
             Killed by Ctrl-C, timeout, not enough memory or similar.

       -2 (In joblog and SQL table)
             <b>skip()</b> was called in <b>{=</b> <b>=}</b>.

       -1000 (In SQL table)
             Job is ready to run (set by --sqlmaster).

       -1220 (In SQL table)
             Job is taken by worker (set by --sqlworker).

       If fail=1 is used, the exit status will be the exit status of the failing job.

</pre><h4><b>DIFFERENCES</b> <b>BETWEEN</b> <b>GNU</b> <b>Parallel</b> <b>AND</b> <b>ALTERNATIVES</b></h4><pre>
       See: <b>man</b> <b>parallel_alternatives</b>

</pre><h4><b>BUGS</b></h4><pre>
   <b>Quoting</b> <b>of</b> <b>newline</b>
       Because of the way newline is quoted this will not work:

         echo 1,2,3 | parallel -vkd, "echo 'a{}b'"

       However, these will all work:

         echo 1,2,3 | parallel -vkd, echo a{}b
         echo 1,2,3 | parallel -vkd, "echo 'a'{}'b'"
         echo 1,2,3 | parallel -vkd, "echo 'a'"{}"'b'"

   <b>Speed</b>
       <u>Startup</u>

       GNU <b>parallel</b> is slow at starting up - around 250 ms the first time and 150 ms after that.

       <u>Job</u> <u>startup</u>

       Starting  a  job  on  the local machine takes around 3-10 ms. This can be a big overhead if the job takes
       very few ms to run. Often you can group small jobs together using <b>-X</b> which will make  the  overhead  less
       significant. Or you can run multiple GNU <b>parallel</b>s as described in <b>EXAMPLE:</b> <b>Speeding</b> <b>up</b> <b>fast</b> <b>jobs</b>.

       <u>SSH</u>

       When  using  multiple  computers  GNU  <b>parallel</b>  opens  <b>ssh</b>  connections  to  them to figure out how many
       connections can be used reliably simultaneously (Namely SSHD's MaxStartups). This test is done  for  each
       host in serial, so if your <b>--sshloginfile</b> contains many hosts it may be slow.

       If your jobs are short you may see that there are fewer jobs running on the remote systems than expected.
       This is due to time spent logging in and out. <b>-M</b> may help here.

       <u>Disk</u> <u>access</u>

       A  single  disk  can normally read data faster if it reads one file at a time instead of reading a lot of
       files in parallel, as this will avoid disk seeks. However, newer disk systems with  multiple  drives  can
       read faster if reading from multiple files in parallel.

       If  the  jobs  are  of  the form read-all-compute-all-write-all, so everything is read before anything is
       written, it may be faster to force only one disk access at the time:

         sem --id diskio cat file | compute | sem --id diskio cat &gt; file

       If the jobs are of the form read-compute-write, so writing starts before all reading is done, it  may  be
       faster to force only one reader and writer at the time:

         sem --id read cat file | compute | sem --id write cat &gt; file

       If the jobs are of the form read-compute-read-compute, it may be faster to run more jobs in parallel than
       the system has CPUs, as some of the jobs will be stuck waiting for disk access.

   <b>--nice</b> <b>limits</b> <b>command</b> <b>length</b>
       The current implementation of <b>--nice</b> is too pessimistic in the max allowed command length. It only uses a
       little  more  than half of what it could. This affects <b>-X</b> and <b>-m</b>. If this becomes a real problem for you,
       file a bug-report.

   <b>Aliases</b> <b>and</b> <b>functions</b> <b>do</b> <b>not</b> <b>work</b>
       If you get:

         Can't exec "command": No such file or directory

       or:

         open3: exec of by command failed

       or:

         <a href="file:/bin/bash">/bin/bash</a>: command: command not found

       it may be because <u>command</u> is not known, but it could also be because <u>command</u> is an alias or  a  function.
       If it is a function you need to <b>export</b> <b>-f</b> the function first or use <b>env_parallel</b>. An alias will only work
       if you use <b>env_parallel</b>.

   <b>Database</b> <b>with</b> <b>MySQL</b> <b>fails</b> <b>randomly</b>
       The <b>--sql*</b> options may fail randomly with MySQL. This problem does not exist with PostgreSQL.

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<a href="mailto:parallel@gnu.org">parallel@gnu.org</a>&gt; or https://savannah.gnu.org/bugs/?func=additem&amp;group=parallel

       When  you  write your report, please keep in mind, that you must give the reader enough information to be
       able to run exactly what you run. So you need to include all data and programs that you use to  show  the
       problem.

       See a perfect bug report on https://lists.gnu.org/archive/html/bug-parallel/2015-01/msg00000.html

       Your bug report should always include:

        The  error message you get (if any). If the error message is not from GNU <b>parallel</b> you need to show why
         you think GNU <b>parallel</b> caused this.

        The complete output of <b>parallel</b> <b>--version</b>. If you are not running  the  latest  released  version  (see
         https://ftp.gnu.org/gnu/parallel/)  you should specify why you believe the problem is not fixed in that
         version.

        A minimal, complete, and verifiable example (See description on https://stackoverflow.com/help/mcve).

         It should be a complete example that others can run which shows the problem including all files  needed
         to  run  the  example.  This should preferably be small and simple, so try to remove as many options as
         possible.

         A combination of <b>yes</b>, <b>seq</b>, <b>cat</b>, <b>echo</b>, <b>wc</b>, and <b>sleep</b> can reproduce most errors.

         If your example requires large files, see if you can make them with  something  like  <b>seq</b>  <b>100000000</b>  &gt;
         <b>bigfile</b>  or <b>yes</b> <b>|</b> <b>head</b> <b>-n</b> <b>1000000000</b> &gt; <b>file</b>. If you need multiple columns: <b>paste</b> <b>&lt;(seq</b> <b>1000)</b> <b>&lt;(seq</b> <b>1000</b>
         <b>1999)</b>

         If your example requires remote execution, see if you can use <b>localhost</b> - maybe using another login.

         If you have access to a different system (maybe a VirtualBox on your own machine), test  if  your  MCVE
         shows the problem on that system. If it does not, read below.

        The  output  of your example. If your problem is not easily reproduced by others, the output might help
         them figure out the problem.

        Whether you have watched the intro  videos  (https://www.youtube.com/playlist?list=PL284C9FF2488BC6D1),
         walked through the tutorial (man parallel_tutorial), and read the examples (man parallel_examples).

   <b>Bug</b> <b>dependent</b> <b>on</b> <b>environment</b>
       If  you  suspect  the  error  is  dependent  on  your  environment or distribution, please see if you can
       reproduce       the       error       on       one       of        these        VirtualBox        images:
       https://sourceforge.net/projects/virtualboximage/files/ https://www.osboxes.org/virtualbox-images/

       Specifying  the name of your distribution is not enough as you may have installed software that is not in
       the VirtualBox images.

       If you cannot reproduce the error on any of  the  VirtualBox  images  above,  see  if  you  can  build  a
       VirtualBox  image  on  which  you can reproduce the error. If not you should assume the debugging will be
       done through you. That will put a lot more burden  on  you  and  it  is  extra  important  you  give  any
       information that help. In general the problem will be fixed faster and with much less work for you if you
       can reproduce the error on a VirtualBox - even if you have to build a VirtualBox image.

   <b>In</b> <b>summary</b>
       Your report must include:

        <b>parallel</b> <b>--version</b>

        output + error message

        full example including all files

        VirtualBox image, if you cannot reproduce it on other systems

</pre><h4><b>AUTHOR</b></h4><pre>
       When using GNU <b>parallel</b> for a publication please cite:

       O.  Tange  (2011):  GNU  Parallel  -  The  Command-Line Power Tool, ;login: The USENIX Magazine, February
       2011:42-47.

       Copyright (C) 2007-10-18 Ole Tange, <a href="http://ole.tange.dk">http://ole.tange.dk</a>

       Copyright (C) 2008-2010 Ole Tange, <a href="http://ole.tange.dk">http://ole.tange.dk</a>

       Copyright (C) 2010-2024 Ole Tange, <a href="http://ole.tange.dk">http://ole.tange.dk</a> and Free Software Foundation, Inc.

       Parts of the manual concerning <b>xargs</b> compatibility is inspired by the manual of <b>xargs</b> from GNU  findutils
       4.4.2.

</pre><h4><b>LICENSE</b></h4><pre>
       This  program  is  free  software;  you  can  redistribute it and/or modify it under the terms of the GNU
       General Public License as published by the Free Software Foundation; either version 3 of the License,  or
       at your option any later version.

       This  program  is  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General  Public
       License for more details.

       You  should  have received a copy of the GNU General Public License along with this program.  If not, see
       &lt;https://www.gnu.org/licenses/&gt;.

   <b>Documentation</b> <b>license</b> <b>I</b>
       Permission is granted to copy, distribute and/or modify this documentation under the  terms  of  the  GNU
       Free  Documentation  License, Version 1.3 or any later version published by the Free Software Foundation;
       with no Invariant Sections, with no Front-Cover Texts, and with no  Back-Cover  Texts.   A  copy  of  the
       license is included in the file LICENSES/GFDL-1.3-or-later.txt.

   <b>Documentation</b> <b>license</b> <b>II</b>
       You are free:

       <b>to</b> <b>Share</b> to copy, distribute and transmit the work

       <b>to</b> <b>Remix</b> to adapt the work

       Under the following conditions:

       <b>Attribution</b>
                You  must  attribute  the work in the manner specified by the author or licensor (but not in any
                way that suggests that they endorse you or your use of the work).

       <b>Share</b> <b>Alike</b>
                If you alter, transform, or build upon this work, you may distribute  the  resulting  work  only
                under the same, similar or a compatible license.

       With the understanding that:

       <b>Waiver</b>   Any of the above conditions can be waived if you get permission from the copyright holder.

       <b>Public</b> <b>Domain</b>
                Where  the work or any of its elements is in the public domain under applicable law, that status
                is in no way affected by the license.

       <b>Other</b> <b>Rights</b>
                In no way are any of the following rights affected by the license:

                 Your  fair  dealing  or  fair  use  rights,  or  other  applicable  copyright  exceptions  and
                  limitations;

                 The author's moral rights;

                 Rights  other  persons  may have either in the work itself or in how the work is used, such as
                  publicity or privacy rights.

       <b>Notice</b>   For any reuse or distribution, you must make clear to others the license terms of this work.

       A copy of the full license is included in the file as LICENCES/CC-BY-SA-4.0.txt

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       GNU <b>parallel</b> uses Perl, and the Perl modules  Getopt::Long,  IPC::Open3,  Symbol,  IO::File,  POSIX,  and
       File::Temp.

       For <b>--csv</b> it uses the Perl module Text::CSV.

       For remote usage it uses <b>rsync</b> with <b>ssh</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/parallel_tutorial.1.html">parallel_tutorial</a></b>(1),      <b><a href="../man1/env_parallel.1.html">env_parallel</a></b>(1),      <b><a href="../man1/parset.1.html">parset</a></b>(1),     <b><a href="../man1/parsort.1.html">parsort</a></b>(1),     <b><a href="../man1/parallel_alternatives.1.html">parallel_alternatives</a></b>(1),
       <b><a href="../man7/parallel_design.7.html">parallel_design</a></b>(7), <b><a href="../man1/niceload.1.html">niceload</a></b>(1), <b><a href="../man1/sql.1.html">sql</a></b>(1), <b><a href="../man1/ssh.1.html">ssh</a></b>(1), <b><a href="../man1/ssh-agent.1.html">ssh-agent</a></b>(1), <b><a href="../man1/sshpass.1.html">sshpass</a></b>(1), <b><a href="../man1/ssh-copy-id.1.html">ssh-copy-id</a></b>(1), <b><a href="../man1/rsync.1.html">rsync</a></b>(1)

20240222                                           2024-03-22                                        <u><a href="../man1/PARALLEL.1.html">PARALLEL</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>