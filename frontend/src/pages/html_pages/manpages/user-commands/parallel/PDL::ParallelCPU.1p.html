<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::ParallelCPU - Parallel processor multi-threading support in PDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/noble/+package/pdl">pdl_2.085-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::ParallelCPU - Parallel processor multi-threading support in PDL

</pre><h4><b>DESCRIPTION</b></h4><pre>
       PDL has support for splitting up numerical processing between multiple parallel processor threads (or
       pthreads) using the <u>set_autopthread_targ</u> and <u>set_autopthread_size</u> functions.  This can improve processing
       performance (by greater than 2-4X in most cases) by taking advantage of multi-core and/or multi-processor
       machines.

       As of 2.059, "online_cpus" in PDL::Core is used to set the number of threads used if
       "PDL_AUTOPTHREAD_TARG" is not set.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use PDL;

         # Set target of 4 parallel pthreads to create, with a lower limit of
         #  5Meg elements for splitting processing into parallel pthreads.
         <a href="../man4/set_autopthread_targ.4.html">set_autopthread_targ</a>(4);
         <a href="../man5/set_autopthread_size.5.html">set_autopthread_size</a>(5);

         $x = zeroes(5000,5000); # Create 25Meg element array

         $y = $x + 5; # Processing will be split up into multiple pthreads

         # Get the actual number of pthreads for the last
         #  processing operation.
         $actualPthreads = get_autopthread_actual();

         # Or compare these to see CPU usage (first one only 1 pthread, second one 10)
         # in the PDL shell:
         $x = ones(10,1000,10000); <a href="../man1/set_autopthread_targ.1.html">set_autopthread_targ</a>(1); $y = sin($x)*cos($x); p get_autopthread_actual;
         $x = ones(10,1000,10000); <a href="../man10/set_autopthread_targ.10.html">set_autopthread_targ</a>(10); $y = sin($x)*cos($x); p get_autopthread_actual;

</pre><h4><b>Terminology</b></h4><pre>
       To reduce the confusion that existed in PDL before 2.075, this document uses <b>pthreading</b> to refer to
       <u>processor</u> <u>multi-threading</u>, which is the use of multiple processor threads to split up numerical
       processing into parallel operations.

</pre><h4><b>Functions</b> <b>that</b> <b>control</b> <b>PDL</b> <b>pthreads</b></h4><pre>
       This is a brief listing and description of the PDL pthreading functions, see the PDL::Core docs for
       detailed information.

       set_autopthread_targ
            Set  the  target  number  of  processor-threads  (pthreads)  for  multi-threaded processing. Setting
            auto_pthread_targ to 0 means that no pthreading will occur.

            See PDL::Core for details.

       set_autopthread_size
            Set the minimum size (in Meg-elements or 2**20 elements) of the largest PDL involved in  a  function
            where  auto-pthreading  will be performed. For small PDLs, it probably isn't worth starting multiple
            pthreads, so this function is used to define a minimum  threshold  where  auto-pthreading  won't  be
            attempted.

            See PDL::Core for details.

       get_autopthread_actual
            Get the actual number of pthreads executed for the last pdl processing function.

            See PDL::get_autopthread_actual for details.

</pre><h4><b>Global</b> <b>Control</b> <b>of</b> <b>PDL</b> <b>pthreading</b> <b>using</b> <b>Environment</b> <b>Variables</b></h4><pre>
       PDL  pthreading  can  be  globally  turned  on,  without  modifying  existing code by setting environment
       variables <b>PDL_AUTOPTHREAD_TARG</b> and <b>PDL_AUTOPTHREAD_SIZE</b> before running a PDL script.   These  environment
       variables  are  checked  when  PDL  starts  up and calls to <u>set_autopthread_targ</u> and <u>set_autopthread_size</u>
       functions made with the environment variable's values.

       For example, if the environment var <b>PDL_AUTOPTHREAD_TARG</b> is set to 3, and <b>PDL_AUTOPTHREAD_SIZE</b> is set  to
       10, then any pdl script will run as if the following lines were at the top of the file:

        <a href="../man3/set_autopthread_targ.3.html">set_autopthread_targ</a>(3);
        <a href="../man10/set_autopthread_size.10.html">set_autopthread_size</a>(10);

</pre><h4><b>How</b> <b>It</b> <b>Works</b></h4><pre>
       The  auto-pthreading process works by analyzing broadcast array dimensions in PDL operations (those above
       the operation's "signature" dimensions) and splitting up processing according to those  and  the  desired
       number  of  pthreads  (i.e.  the pthread target or pthread_targ). The offsets, increments, and dimension-
       sizes (in case the whole dimension does not divide neatly by the number of pthreads)  that  PDL  uses  to
       step  thru the data in memory are modified for each pthread so each one sees a different set of data when
       performing processing.

       <b>Example</b>

        $x = sequence(20,4,3); # Small 3-D Array, size 20,4,3

        # Setup auto-pthreading:
        <a href="../man2/set_autopthread_targ.2.html">set_autopthread_targ</a>(2); # Target of 2 pthreads
        <a href="../man0/set_autopthread_size.0.html">set_autopthread_size</a>(0); # Zero so that the small PDLs in this example will be pthreaded

        # This will be split up into 2 pthreads
        $c = maximum($x);

       For the above example, the <u>maximum</u> function has a signature of "(a(n); [o]c())",  which  means  that  the
       first  dimension  of $x (size 20) is a <u>Core</u> dimension of the <u>maximum</u> function. The other dimensions of $x
       (size 4,3) are <u>broadcast</u> dimensions (i.e. will be broadcasted-over in the <u>maximum</u> function.

       The auto-pthreading algorithm examines the broadcasted dims of size (4,3)  and  picks  the  4  dimension,
       since it is evenly divisible by the autopthread_targ of 2. The processing of the maximum function is then
       split into two pthreads on the size-4 dimension, with dim indexes 0,2 processed by one pthread
        and dim indexes 1,3 processed by the other pthread.

</pre><h4><b>Limitations</b></h4><pre>
   <b>Must</b> <b>have</b> <b>POSIX</b> <b>Threads</b> <b>Enabled</b>
       Auto-pthreading  only  works  if  your  PDL installation was compiled with POSIX threads enabled. This is
       normally the case if you are running on Windows, Linux, MacOS X, or other unix variants.

   <b>Non-Threadsafe</b> <b>Code</b>
       Not all the libraries that PDL intefaces to are thread-safe, i.e. they aren't written  to  operate  in  a
       multi-threaded environment without crashing or causing side-effects. Some examples in the PDL core is the
       <u>fft</u> function and the <u>pnmout</u> functions.

       To  operate  properly  with  these  types  of functions, the PPCode flag <b>NoPthread</b> has been introduced to
       indicate a function as <u>not</u> being pthread-safe. See PDL::PP docs for details.

   <b>Size</b> <b>of</b> <b>PDL</b> <b>Dimensions</b> <b>and</b> <b>pthread</b> <b>Target</b>
       As of PDL 2.058, the broadcasted dimension sizes do not need to divide exactly  by  the  pthread  target,
       although if one does, it will be used.

       If no dimension is as large as the pthread target, the number of pthreads will be the size of the largest
       broadcasted dimension.

       In  order  to  minimise  idle  CPUs  on  the  last iteration at the end of the broadcasted dimension, the
       algorithm that picks the dimension to pthread on aims for the largest remainder in dividing  the  pthread
       target  into  the  sizes  of  the broadcasted dimensions. For example, if a PDL has broadcasted dimension
       sizes of (9,6,2) and the <u>auto_pthread_targ</u> is 4, the algorithm will pick the 1-th (size 6), as that  will
       leave  a remainder of 2 (leaving 2 idle at the end) in preference to one with size 9, which would leave 3
       idle.

   <b>Speed</b> <b>improvement</b> <b>might</b> <b>be</b> <b>less</b> <b>than</b> <b>you</b> <b>expect.</b>
       If you have an 8-core machine and call <u>auto_pthread_targ</u> with 8 to  generate  8  parallel  pthreads,  you
       probably  won't  get  a  8X  improvement in speed, due to memory bandwidth issues. Even though you have 8
       separate CPUs crunching away on data, you will have (for most common machine  architectures)  common  RAM
       that  now  becomes  your  bottleneck.  For  simple calculations (e.g simple additions) you can run into a
       performance limit at about 4 pthreads. For more CPU-bound calculations the limit will be higher.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2011 John Cerney. You can distribute and/or modify this document under the same  terms  as  the
       current Perl license.

       See: <a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a>

perl v5.38.2                                       2024-04-10                                    <u><a href="../man1p/PARALLELCPU.1p.html">PARALLELCPU</a></u>(1p)
</pre>
 </div>
</div></section>
</div>
</body>
</html>