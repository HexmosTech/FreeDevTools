<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>stalin - A global optimizing compiler for Scheme</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/stalin">stalin_0.11-8_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       stalin - A global optimizing compiler for Scheme

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>stalin</b> [<b>-version</b>]

              [<b>-I</b> <u>include-directory</u>]*
              [[<b>-s</b>|<b>-x</b>|<b>-q</b>|<b>-t</b>]]

              [[<b>-treat-all-symbols-as-external</b>|
                <b>-do-not-treat-all-symbols-as-external</b>]]
              [[<b>-index-allocated-string-types-by-expression</b>|
                <b>-do-not-index-allocated-string-types-by-expression</b>]]

              [[<b>-index-constant-structure-types-by-slot-types</b>|
                <b>-do-not-index-constant-structure-types-by-slot-types</b>]]
              [[<b>-index-constant-structure-types-by-expression</b>|
                <b>-do-not-index-constant-structure-types-by-expression</b>]]
              [[<b>-index-allocated-structure-types-by-slot-types</b>|
                <b>-do-not-index-allocated-structure-types-by-slot-types</b>]]
              [[<b>-index-allocated-structure-types-by-expression</b>|
                <b>-do-not-index-allocated-structure-types-by-expression</b>]]

              [[<b>-index-constant-headed-vector-types-by-element-type</b>|
                <b>-do-not-index-constant-headed-vector-types-by-element-type</b>]]
              [[<b>-index-constant-headed-vector-types-by-expression</b>|
                <b>-do-not-index-constant-headed-vector-types-by-expression</b>]]
              [[<b>-index-allocated-headed-vector-types-by-element-type</b>|
                <b>-do-not-index-allocated-headed-vector-types-by-element-type</b>]]
              [[<b>-index-allocated-headed-vector-types-by-expression</b>|
                <b>-do-not-index-allocated-headed-vector-types-by-expression</b>]]
              [[<b>-index-constant-nonheaded-vector-types-by-element-type</b>|
                <b>-do-not-index-constant-nonheaded-vector-types-by-element-type</b>]]
              [[<b>-index-constant-nonheaded-vector-types-by-expression</b>|
                <b>-do-not-index-constant-nonheaded-vector-types-by-expression</b>]]
              [[<b>-index-allocated-nonheaded-vector-types-by-element-type</b>|
                <b>-do-not-index-allocated-nonheaded-vector-types-by-element-type</b>]]
              [[<b>-index-allocated-nonheaded-vector-types-by-expression</b>|
                <b>-do-not-index-allocated-nonheaded-vector-types-by-expression</b>]]

              [[<b>-no-clone-size-limit</b>|
                <b>-clone-size-limit</b> <u>number-of-expressions</u>]]
              [<b>-split-even-if-no-widening</b>]
              [[<b>-fully-convert-to-CPS</b>|
                <b>-no-escaping-continuations</b>]]
              [<b>-du</b>]

              [<b>-Ob</b>] [<b>-Om</b>] [<b>-On</b>] [<b>-Or</b>] [<b>-Ot</b>]

              [<b>-d0</b>] [<b>-d1</b>] [<b>-d2</b>] [<b>-d3</b>] [<b>-d4</b>] [<b>-d5</b>] [<b>-d6</b>] [<b>-d7</b>]
              [<b>-closure-conversion-statistics</b>]

              [<b>-dc</b>] [<b>-dC</b>] [<b>-dH</b>] [<b>-dg</b>] [<b>-dh</b>]

              [<b>-d</b>]
              [<b>-architecture</b> <u>name</u>]
              [[<b>-baseline</b>|
                <b>-conventional</b>|
                <b>-lightweight</b>]]
              [[<b>-immediate-flat</b>|
                <b>-indirect-flat</b>|
                <b>-immediate-display</b>|
                <b>-indirect-display</b>|
                <b>-linked</b>]]
              [[<b>-align-strings</b>|<b>-do-not-align-strings</b>]]
              [<b>-de</b>] [<b>-df</b>] [<b>-dG</b>] [<b>-di</b>] [<b>-dI</b>] [<b>-dp</b>] [<b>-dP</b>]
              [<b>-ds</b>] [<b>-dS</b>] [<b>-Tmk</b>]
              [<b>-no-tail-call-optimization</b>]

              [<b>-db</b>] [<b>-c</b>] [<b>-k</b>]
              [<b>-cc</b> <u>C-compiler</u>]
              [<b>-copt</b> <u>C-compiler-option</u>]*

              [<u>pathname</u>]

       Compiles  the  Scheme  source file <u>pathname</u>.sc first into a C file <u>pathname</u>.c and then into an executable
       image <u>pathname</u>.  Also produces a database file <u>pathname</u>.db.  The <u>pathname</u>  argument  is  required  unless
       <b>-version</b> is specified.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Stalin  is  an  extremely  efficient compiler for Scheme.  It is designed to be used not as a development
       tool but rather as a means to generate efficient executable images either for application delivery or for
       production research runs.  In contrast to traditional Scheme  implementations,  Stalin  is  a  batch-mode
       compiler.   There  is  no  interactive READ-EVAL-PRINT loop.  Stalin compiles a single Scheme source file
       into an executable image (indirectly via C).  Running that image has equivalent semantics to loading  the
       Scheme  source  file  into  a  virgin  Scheme  interpreter and then terminating its execution.  The chief
       limitation is that it is not possible to LOAD or EVAL new expressions or  procedure  definitions  into  a
       running  program  after  compilation.   In  return  for  this  limitation, Stalin does substantial global
       compile-time analysis of the source program under this closed-world assumption  and  produces  executable
       images that are small, stand-alone, and fast.

       Stalin  incorporates  numerous  strategies for generating efficient code.  Among them, Stalin does global
       static type analysis using a soft type system that supports recursive union types.  Stalin can  determine
       a  narrow  or  even monomorphic type for each source code expression in arbitrary Scheme programs with no
       type declarations.  This allows Stalin  to  reduce,  or  often  eliminate,  run-time  type  checking  and
       dispatching.  Stalin also does low-level representation selection on a per-expression basis.  This allows
       the  use  of  unboxed  base machine data representations for all monomorphic types resulting in extremely
       high-performance numeric code.  Stalin also does global static life-time analysis for all allocated data.
       This allows much temporary allocated storage to be reclaimed without garbage collection.  Finally, Stalin
       has  very  efficient  strategies  for  compiling  closures.   Together,  these   compilation   techniques
       synergistically yield efficient object code.  Furthermore, the executable images created by Stalin do not
       contain  (user-defined  or  library)  procedures that aren't called, variables and parameters that aren't
       used, and expressions that cannot be reached.  This encourages a programming style  whereby  one  creates
       and uses very general library procedures without fear that executable images will suffer from code bloat.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-version</b>
              Prints the version of Stalin and exits immediately.

       The following options control preprocessing:

       <b>-I</b>     Specifies  the  directories  to  search  for Scheme include files.  This option can be repeated to
              specify multiple directories.  Stalin first searches for include files in the  current  directory,
              then  each  of  the  directories  specified  in  the  command  line,  and  finally  in the default
              installation include directory.

       <b>-s</b>     Includes the macros from the Scheme-&gt;C compatibility library.  Currently, this  defines  the  WHEN
              and UNLESS syntax.

       <b>-x</b>     Includes  the  macros  from the Xlib and GL library.  Currently, this defines the FOREIGN-FUNCTION
              and FOREIGN-DEFINE syntax.  This implies <b>-s</b>.

       <b>-q</b>     Includes the macros from the QobiScheme library.  Currently,  this  defines  the  DEFINE-STRUCTURE
              syntax, among other things.  This implies <b>-x</b>.

       <b>-t</b>     Includes the macros needed to compile Stalin with itself.  This implies <b>-q</b>.

       The following options control the precision of flow analysis:

       <b>-treat-all-symbols-as-external</b>
              During flow analysis, generate a single abstract external symbol that is shared among all symbols.

       <b>-do-not-treat-all-symbols-as-external</b>
              During  flow  analysis,  when processing constant expressions that contain symbols, generate a new
              abstract internal symbol for each distinct symbol constant in the program.  This is the default.

       <b>-index-allocated-string-types-by-expression</b>
              During flow analysis, when  processing  procedure-call  expressions  that  can  allocate  strings,
              generate a new abstract string for each such expression.  This is the default.

       <b>-do-not-index-allocated-string-types-by-expression</b>
              During  flow  analysis,  when  processing  procedure-call  expressions  that can allocate strings,
              generate a single abstract string that is shared among all such expressions.

       Note that there are no versions of the above options for element type  because  the  element  type  of  a
       string  is always char.  Furthermore, there are no versions of the above options for constant expressions
       because there is always only a single abstract constant string.

       <b>-index-constant-structure-types-by-slot-types</b>
              During flow analysis, when processing constant expressions that contain structures, generate a new
              abstract structure for each set of potential slot types for that structure.

       <b>-do-not-index-constant-structure-types-by-slot-types</b>
              During flow analysis, when processing constant expressions that  contain  structures,  generate  a
              single  abstract  structure  that  is  shared  among  all  sets  of  potential slot types for that
              structure.  This is the default.

       <b>-index-constant-structure-types-by-expression</b>
              During flow analysis, when processing constant expression that contain structures, generate a  new
              abstract structure for each such expression.  This is the default.

       <b>-do-not-index-constant-structure-types-by-expression</b>
              During  flow  analysis,  when  processing constant expressions that contain structures, generate a
              single abstract structure that is shared among all such expressions.

       <b>-index-allocated-structure-types-by-slot-types</b>
              During flow analysis, when processing procedure-call expressions  that  can  allocate  structures,
              generate a new abstract structure for each set of potential slot types for that structure.

       <b>-do-not-index-allocated-structure-types-by-slot-types</b>
              During  flow  analysis,  when  processing procedure-call expressions that can allocate structures,
              generate a single abstract structure that is shared among all sets of  potential  slot  types  for
              that structure.  This is the default.

       <b>-index-allocated-structure-types-by-expression</b>
              During  flow  analysis,  when  processing procedure-call expressions that can allocate structures,
              generate a new abstract structure for each such expression.  This is the default.

       <b>-do-not-index-allocated-structure-types-by-expression</b>
              During flow analysis, when processing procedure-call expressions  that  can  allocate  structures,
              generate a single abstract structure that is shared among all such expressions.

       Note that, currently, pairs are the only kind of structure that can appear in constant expressions.  This
       may change in the future, if the reader is extended to support other kinds of structures.

       <b>-index-constant-headed-vector-types-by-element-type</b>
              During flow analysis, when processing constant expressions that contain headed vectors, generate a
              new abstract headed vector for each potential element type for that headed vector.

       <b>-do-not-index-constant-headed-vector-types-by-element-type</b>
              During flow analysis, when processing constant expressions that contain headed vectors, generate a
              single  abstract  headed  vector  that is shared among all potential element types for that headed
              vector.  This is the default.

       <b>-index-constant-headed-vector-types-by-expression</b>
              During flow analysis, when processing constant expressions that contain headed vectors, generate a
              new abstract headed vector for each such expression.  This is the default.

       <b>-do-not-index-constant-headed-vector-types-by-expression</b>
              During flow analysis, when processing constant expressions that contain headed vectors, generate a
              single abstract headed vector that is shared among all such expressions.

       <b>-index-allocated-headed-vector-types-by-element-type</b>
              During flow analysis, when processing procedure-call expressions that can allocate headed vectors,
              generate a new abstract headed vector for each potential element type for that headed vector.

       <b>-do-not-index-allocated-headed-vector-types-by-element-type</b>
              During flow analysis, when processing procedure-call expressions that can allocate headed vectors,
              generate a single abstract headed vector that is shared among all potential element types for that
              headed vector.  This is the default.

       <b>-index-allocated-headed-vector-types-by-expression</b>
              During flow analysis, when processing procedure-call expressions that can allocate headed vectors,
              generate a new abstract headed vector for each such expression.  This is the default.

       <b>-do-not-index-allocated-headed-vector-types-by-expression</b>
              During flow analysis, when processing procedure-call expressions that can allocate headed vectors,
              generate a single abstract headed vector that is shared among all such expressions.

       <b>-index-constant-nonheaded-vector-types-by-element-type</b>
              During flow analysis,  when  processing  constant  expressions  that  contain  nonheaded  vectors,
              generate  a  new  abstract  nonheaded  vector  for  each potential element type for that nonheaded
              vector.

       <b>-do-not-index-constant-nonheaded-vector-types-by-element-type</b>
              During flow analysis,  when  processing  constant  expressions  that  contain  nonheaded  vectors,
              generate  a  single abstract nonheaded vector that is shared among all potential element types for
              that nonheaded vector.  This is the default.

       <b>-index-constant-nonheaded-vector-types-by-expression</b>
              During flow analysis,  when  processing  constant  expressions  that  contain  nonheaded  vectors,
              generate a new abstract nonheaded vector for each such expression.  This is the default.

       <b>-do-not-index-constant-nonheaded-vector-types-by-expression</b>
              During  flow  analysis,  when  processing  constant  expressions  that  contain nonheaded vectors,
              generate a single abstract nonheaded vector that is shared among all such expressions.

       <b>-index-allocated-nonheaded-vector-types-by-element-type</b>
              During flow analysis, when processing  procedure-call  expressions  that  can  allocate  nonheaded
              vectors,  generate  a  new  abstract  nonheaded  vector  for  each potential element type for that
              nonheaded vector.

       <b>-do-not-index-allocated-nonheaded-vector-types-by-element-type</b>
              During flow analysis, when processing  procedure-call  expressions  that  can  allocate  nonheaded
              vectors,  generate  a  single abstract nonheaded vector that is shared among all potential element
              types for that nonheaded vector.  This is the default.

       <b>-index-allocated-nonheaded-vector-types-by-expression</b>
              During flow analysis, when processing  procedure-call  expressions  that  can  allocate  nonheaded
              vectors, generate a new abstract nonheaded vector for each such expression.  This is the default.

       <b>-do-not-index-allocated-nonheaded-vector-types-by-expression</b>
              During  flow  analysis,  when  processing  procedure-call  expressions that can allocate nonheaded
              vectors, generate a single abstract nonheaded vector that is shared among all such expressions.

       Note that, currently, constant expressions cannot contain nonheaded vectors  and  nonheaded  vectors  are
       never  allocated by any procedure-call expression.  ARGV is the only nonheaded vector.  These options are
       included only for completeness and in case future extensions  to  the  language  allow  nonheaded  vector
       constants and procedures that allocate nonheaded vectors.

       <b>-no-clone-size-limit</b>
              Allow unlimited polyvariance, i.e. make copies of procedures of any size.

       <b>-clone-size-limit</b>
              Specify  the  polyvariance  limit,  i.e.  make copies of procedures that have fewer than this many
              expressions.  Must be a nonnegative integer.  Defaults to 80.  Specify 0 to disable polyvariance.

       <b>-split-even-if-no-widening</b>
              Normally, polyvariance will make a copy of a procedure only if it  is  called  with  arguments  of
              different  types.  Specify this option to make copies of procedures even when they are called with
              arguments of the same type.  This will allow them to be in-lined.

       <b>-fully-convert-to-CPS</b>
              Normally, lightweight CPS conversion is applied, converting only those expressions and  procedures
              needed  to  support  escaping  continuations.  When this option is specified, the program is fully
              converted to CPS.

       <b>-no-escaping-continuations</b>
              Normally, full continuations are supported.  When this option is specified, the only continuations
              that are supported are  those  that  cannot  be  called  after  the  procedure  that  created  the
              continuation has returned.

       <b>-du</b>    Normally,  after  flow  analysis,  Stalin  forces each type set to have at most one structure-type
              member of a given name, at most one headed-vector-type member, and at most  one  nonheaded-vector-
              type  member.   This  option  disables  this,  allowing  type sets to have multiple structure-type
              members of a given name, multiple headed-vector-type members, and  multiple  nonheaded-vector-type
              members.  Sometimes yields more efficient code and sometimes yields less efficient code.

       The  following  options  control  the  amount  of  run-time  error-checking  code  generated.  Note that,
       independent of the settings of these options, Stalin will always generate code that obeys  the  semantics
       of the Scheme language for correct programs.  These options only control the level of safety, that is the
       degree of run-time error checking for incorrect programs.

       <b>-Ob</b>    Specifies that code to check for out-of-bound vector or string subscripts is to be suppressed.  If
              not  specified,  a run-time error will be issued if a vector or string subscript is out of bounds.
              If specified, the behavior of programs that have an out-of-bound vector  or  string  subscript  is
              undefined.

       <b>-Om</b>    Specifies  that  code  to check for out-of-memory errors is to be suppressed.  If not specified, a
              run-time error will be issued if  sufficient  memory  cannot  be  allocated.   If  specified,  the
              behavior of programs that run out of memory is undefined.

       <b>-On</b>    Specifies  that code to check for exact integer overflow is to be suppressed.  If not specified, a
              run-time error will be issued on exact integer overflow.  If specified, the behavior  of  programs
              that  cause  exact integer overflow is undefined.  Currently, Stalin does not know how to generate
              overflow checking code so this option must be specified.

       <b>-Or</b>    Specifies that code to check for various run-time file-system errors is to be suppressed.  If  not
              specified, a run-time error will be issued when an unsuccessful attempt is made to open or close a
              file.   If specified, the behavior of programs that make such unsuccessful file-access attempts is
              undefined.

       <b>-Ot</b>    Specifies that code to check that primitive procedures are passed arguments of the correct type is
              suppressed.  If not specified, a run-time error will be issued if a primitive procedure is  called
              with  arguments  of  the wrong type.  If specified, the behavior of programs that call a primitive
              procedure with data of the wrong type is undefined.

       The following options control the verbosity of the compiler:

       <b>-d0</b>    Produces a compile-time backtrace upon a compiler error.

       <b>-d1</b>    Produces commentary during compilation describing what the compiler is doing.

       <b>-d2</b>    Produces a decorated listing of the source program after flow analysis.

       <b>-d3</b>    Produces a decorated listing of the source program after equivalent types have been merged.

       <b>-d4</b>    Produces a call graph of the source program.

       <b>-d5</b>    Produces a description of all nontrivial native procedures generated.

       <b>-d6</b>    Produces a list of all expressions and closures that allocate storage along with a description  of
              where that storage is allocated.

       <b>-d7</b>    Produces a trace of the lightweight closure-conversion process.

       <b>-closure-conversion-statistics</b>
              Produces a summary of the closure-conversion statistics.  These are automatically processed by the
              program   <u>bcl-to-latex.sc</u>   which   is   run   by   the   <u>bcl-benchmark</u>   script   (both   in  the
              <u>/usr/local/stalin/benchmarks</u> directory) to produce tables II, III, and  IV,  of  the  paper  <u>Flow-</u>
              <u>Directed</u> <u>Lightweight</u> <u>Closure</u> <u>Conversion</u>.

       The following options control the storage management strategy used by compiled code:

       <b>-dc</b>    Disables  the use of <u><a href="../man3/alloca.3.html">alloca</a>(3)</u>.  Normally, the compiler will use <u><a href="../man3/alloca.3.html">alloca</a>(3)</u> to allocate on the call
              stack when possible.

       <b>-dC</b>    Disables the use of the Boehm conservative garbage collector.  Normally, the compiler will use the
              Boehm collector to allocate data whose lifetime is not known to be short.  Note that the  compiler
              will  still  use the Boehm collector for some data if it cannot allocate that data on the stack or
              on a region.

       <b>-dH</b>    Disables the use of regions for allocating data.

       <b>-dg</b>    Generate code to produce diagnostic messages when region segments are allocated and freed.

       <b>-dh</b>    Disables the use of expandable regions and uses fixed-size regions instead.

       The following options control code generation:

       <b>-d</b>     Specifies that  inexact  reals  are  represented  as  C  doubles.   Normally,  inexact  reals  are
              represented as C floats.

       <b>-architecture</b>
              Specify the architecture for which to generate code.  The default is to generate code for whatever
              architecture  the  compiler  is  run on.  Currently, the known architectures are IA32, IA32-align-
              double, SPARC, SPARCv9, SPARC64, MIPS, Alpha, ARM, M68K, PowerPC, and S390.

       <b>-baseline</b>
              Do not perform lightweight closure conversion.  Closures are created for all procedures.  The user
              would not normally specify this option.  It is only  intended  to  measure  the  effectiveness  of
              lightweight   closure   conversion.    It   is   used   by   the   <u>bcl-benchmark</u>  script  (in  the
              <u>/usr/local/stalin/benchmarks</u> directory) to produce tables II, III, and  IV,  of  the  paper  <u>Flow-</u>
              <u>Directed</u> <u>Lightweight</u> <u>Closure</u> <u>Conversion</u>.

       <b>-conventional</b>
              Perform   a   simplified  version  of  lightweight  closure  conversion  that  does  not  rely  on
              interprocedural analysis.  Attempts to mimic what `conventional' compilers do (whatever that  is).
              The user would not normally specify this option.  It is only intended to measure the effectiveness
              of   lightweight   closure   conversion.    It  is  used  by  the  <u>bcl-benchmark</u>  script  (in  the
              <u>/usr/local/stalin/benchmarks</u> directory) to produce tables II, III,  and  IV  of  the  paper  <u>Flow-</u>
              <u>Directed</u> <u>Lightweight</u> <u>Closure</u> <u>Conversion</u>.

       <b>-lightweight</b>
              Perform lightweight closure conversion.  This is the default.

       <b>-immediate-flat</b>
              Generate code using immediate flat closures.  This is not (yet) implemented.

       <b>-indirect-flat</b>
              Generate code using indirect flat closures.  This is not (yet) implemented.

       <b>-immediate-display</b>
              Generate code using immediate display closures.

       <b>-indirect-display</b>
              Generate code using indirect display closures.  This is not (yet) implemented.

       <b>-linked</b>
              Generate code using linked closures.  This is the default.

       <b>-align-strings</b>
              Align  all  strings  to fixnum alignment.  This will not work when strings are returned by foreign
              procedures that are not aligned to fixnum alignment.  It will also not work  when  ARGV  is  used,
              since those strings are also not aligned to fixnum alignment.  This is the default.

       <b>-do-not-align-strings</b>
              Do not align strings to fixnum alignment.  This must be specified when strings returned by foreign
              procedures are not aligned to fixnum alignment.

       <b>-de</b>    Enables  the compiler optimization known as EQ? forgery.  Sometimes yields more efficient code and
              sometimes yields less efficient code.

       <b>-df</b>    Disables the compiler optimization known as forgery.

       <b>-dG</b>    Pass arguments using global variables instead of parameters whenever possible.

       <b>-di</b>    Generate if statements instead of switch statements for dispatching.

       <b>-dI</b>    Enables the use of immediate structures.

       <b>-dp</b>    Enables representation promotion.  Promotes some type sets from squeezed to squished  or  squished
              to  general  if  this will decrease the amount of run-time branching or dispatching representation
              coercions.  Sometimes yields more efficient code and sometimes yields less efficient code.

       <b>-dP</b>    Enables copy propagation.   Sometimes  yields  more  efficient  code  and  sometimes  yields  less
              efficient code.

       <b>-ds</b>    Disables the compiler optimization known as squeezing.

       <b>-dS</b>    Disables the compiler optimization known as squishing.

       <b>-Tmk</b>   Enables  generation  of  code  that  works  with the Treadmarks distributed-shared-memory package.
              Currently this option is not fully implemented and is not known to work.

       <b>-no-tail-call-optimization</b>
              Stalin now generates code that is properly tail recursive, by default, in all but  the  rarest  of
              circumstances.   And  it  can  be  coerced  into  generating  properly  tail-recursive code in all
              circumstances by appropriate options.  Some tail-recursive calls, those where the call site is in-
              lined in the target, are translated as C goto statements  and  always  result  in  properly  tail-
              recursive code.  The rest are translated as C function calls in tail position.  This relies on the
              C  compiler  to perform tail-call optimization.  <u><a href="../man1/gcc.1.html">gcc</a>(1)</u> versions 2.96 and 3.0.2 (and perhaps other
              versions)  perform  tail-call  optimization  on  IA32  (and  perhaps  other  architectures)   when
              <b>-foptimize-sibling-calls</b>  is  specified.   (<b>-O2</b>  implies  <b>-foptimize-sibling-calls</b>.)   <u><a href="../man1/gcc.1.html">gcc</a>(1)</u> only
              performs tail-call optimization on IA32 in certain circumstances.  First, the target and the  call
              site  must  have  compatible  signatures.   To  guarantee  compatible  signatures,  Stalin  passes
              parameters to C functions that are part of tail-recursive loops in global variables.  Second,  the
              target  must  not  be  declared  <b>__</b><u>attribute</u><b>__</b>  <u>((noreturn))</u>.   Thus  Stalin  will  not generate a
              <b>__</b><u>attribute</u><b>__</b> <u>((noreturn))</u> declaration for a function that is part of a tail-recursive  loop  even
              if  Stalin  knows that it never returns.  Third, the function containing the call site cannot call
              <u><a href="../man3/alloca.3.html">alloca</a>(3)</u>.  <u><a href="../man1/gcc.1.html">gcc</a>(1)</u> does no flow analysis.  Any call to <u><a href="../man3/alloca.3.html">alloca</a>(3)</u> in the  function  containing  the
              call  site,  no  matter  whether  the allocated data escapes, will disable tail-call optimization.
              Thus Stalin disables stack allocation of data in any procedure in-lined in  a  procedure  that  is
              part  of  a tail-recursive loop.  Finally, the call site cannot contain a reentrant region because
              reentrant regions are freed upon procedure exit and a  tail  call  would  require  an  intervening
              region  reclamation.   Thus  Stalin  disables  allocation  of  data  on  a reentrant region in any
              procedure that is part of a tail-recursive loop.  Disabling these optimizations incurs a cost  for
              the  benefit  of  achieving tail-call optimization.  If your C compiler does not perform tail-call
              optimization then you may wish not to pay the cost.  The <b>-no-tail-call-optimization</b> option  causes
              Stalin  not to take these above four measures to generate code on which <u><a href="../man1/gcc.1.html">gcc</a>(1)</u> would perform tail-
              call optimization.  Even when specifying this option, Stalin still  translates  calls,  where  the
              call  site  is  in-lined in the target, as C goto statements.  There are three rare occasions that
              can still foil proper tail recursion.  First, if you specify <b>-dC</b> you may force Stalin to use stack
              or region allocation even in a tail-call cycle.   You  can  avoid  this  by  not  specifying  <b>-dC</b>.
              Second,  <u><a href="../man1/gcc.1.html">gcc</a>(1)</u> will not perform tail-call optimization when the function containing the call site
              applies unary &amp; to a local variable.  <u><a href="../man1/gcc.1.html">gcc</a>(1)</u> does no flow analysis.  Any application of unary &amp; to
              a local variable in the function containing the call site, no matter whether the pointer  escapes,
              will  disable  tail-call  optimization.  Stalin can generate such uses of unary &amp; when you specify
              <b>-de</b> or don't specify <b>-df</b>.  You can avoid such cases by specifying  <b>-df</b>  and  not  specifying  <b>-de</b>.
              Finally, <u><a href="../man1/gcc.1.html">gcc</a>(1)</u> will not perform tail-call optimization when the function containing the call site
              calls  <u><a href="../man3/setjmp.3.html">setjmp</a>(3)</u>.  <u><a href="../man1/gcc.1.html">gcc</a>(1)</u> does no flow analysis.  Any call to <u><a href="../man3/setjmp.3.html">setjmp</a>(3)</u> in the function containing
              the call site, no matter whether  the  <u>jmp_buf</u>   escapes,  will  disable  tail-call  optimization.
              Stalin  translates certain calls to <u>call-with-current-continuation</u> as calls to <u><a href="../man3/setjmp.3.html">setjmp</a>(3)</u>.  You can
              force Stalin not to do so by specifying <b>-fully-convert-to-CPS</b>.  Stalin will generate a warning  in
              the  first  and  third  cases,  namely,  when tail-call optimization is foiled by reentrant-region
              allocation or calls to <u><a href="../man3/alloca.3.html">alloca</a>(3)</u> or <u><a href="../man3/setjmp.3.html">setjmp</a>(3)</u>.  So you can hold off specifying  <b>-fully-convert-to-</b>
              <b>CPS</b>  or refraining from specifying <b>-dC</b> until you see such warnings.  No such warning is generated,
              however, when uses of unary &amp; foil tail-call optimization.  So you might want  to  always  specify
              <b>-df</b> and refrain from specifying <b>-de</b> if you desire your programs to be properly tail recursive.

       The following options control the C-compilation phase:

       <b>-db</b>    Disables the production of a database file.

       <b>-c</b>     Specifies  that  the  C compiler is not to be called after generating the C code.  Normally, the C
              compiler is called after generating the C code to produce an executable image.  This implies <b>-k</b>.

       <b>-k</b>     Specifies that the generated C file is not to be deleted.   Normally,  the  generated  C  file  is
              deleted after it is compiled.

       <b>-cc</b>    Specifies the C compiler to use.  Defaults to <u><a href="../man1/gcc.1.html">gcc</a>(1)</u>.

       <b>-copt</b>  Specifies the options that the C compiler is to be called with.  Normally the C compiler is called
              without  any  options.   This  option  can  be repeated to allow passing multiple options to the C
              compiler.

</pre><h4><b>FILES</b></h4><pre>
       <u>/usr/local/stalin/include/</u> default directory for Scheme include files and library archive files
       <u>/usr/local/stalin/include/Scheme-to-C-compatibility.sc</u> include file for Scheme-&gt;C compatibility
       <u>/usr/local/stalin/include/QobiScheme.sc</u> include file for QobiScheme
       <u>/usr/local/stalin/include/xlib.sc</u> include file for Xlib FPI
       <u>/usr/local/stalin/include/xlib-original.sc</u> include file for Xlib FPI
       <u>/usr/local/stalin/include/libstalin.a</u> library archive for Xlib FPI
       <u>/usr/local/stalin/include/gc.h</u> include file for the Boehm conservative garbage collector
       <u>/usr/local/stalin/include/libgc.a</u> library archive for the Boehm conservative garbage collector
       <u>/usr/local/stalin/include/stalin.architectures</u>  the  known  architectures   and   their   code-generation
       parameters
       <u>/usr/local/stalin/include/stalin-architecture-name</u> shell script that determines the architecture on which
       Stalin is running
       <u>/usr/local/stalin/stalin-architecture.c</u>  program  to  construct a new entry for <u>stalin.architectures</u> with
       the code-generation parameters for the machine on which it is run
       <u>/usr/local/stalin/benchmarks</u> directory containing benchmarks from  the  paper  <u>Flow-Directed</u>  <u>Lightweight</u>
       <u>Closure</u> <u>Conversion</u>
       <u>/usr/local/stalin/benchmarks/bcl-benchmark</u>  script  for  producing  tables II, III, and IV from the paper
       <u>Flow-Directed</u> <u>Lightweight</u> <u>Closure</u> <u>Conversion</u>
       <u>/usr/local/stalin/benchmarks/bcl-to-latex.sc</u> Scheme program for producing tables II, III, and IV from the
       paper <u>Flow-Directed</u> <u>Lightweight</u> <u>Closure</u> <u>Conversion</u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/sci.2.html">sci</a></b>(2), <b><a href="../man2/scc.2.html">scc</a></b>(2), <b><a href="../man1/gcc.1.html">gcc</a></b>(1), <b><a href="../man1/ld.1.html">ld</a></b>(1), <b><a href="../man3/alloca.3.html">alloca</a></b>(3), <b><a href="../man3/setjmp.3.html">setjmp</a></b>(3), <b><a href="../man8/gc.8.html">gc</a></b>(8)

</pre><h4><b>BUGS</b></h4><pre>
       Version 0.11 is an alpha release and contains many known bugs.  Not everything is fully implemented.  Bug
       mail should be addressed to <u><a href="mailto:Bug-Stalin@AI.MIT.EDU">Bug-Stalin@AI.MIT.EDU</a></u> and not to the  author.   Please  include  the  version
       number  (0.11)  in the message.  Periodic announcements of bug fixes, enhancements, and new releases will
       be made to <u><a href="mailto:Info-Stalin@AI.MIT.EDU">Info-Stalin@AI.MIT.EDU</a></u>.  Send mail to <u><a href="mailto:Info-Stalin-Request@AI.MIT.EDU">Info-Stalin-Request@AI.MIT.EDU</a></u> to be added to the  <u>Info-</u>
       <u><a href="mailto:Stalin@AI.MIT.EDU">Stalin@AI.MIT.EDU</a></u> mailing list.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jeffrey Mark Siskind

</pre><h4><b>THANKS</b></h4><pre>
       Rob Browning packaged version 0.11 for Debian Linux.

0.11                                               August 2006                                         <u><a href="../man1/STALIN.1.html">STALIN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>