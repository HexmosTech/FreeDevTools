<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nescc-mig - message interface generator for nesC</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/nescc">nescc_1.3.5-1.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       nescc-mig - message interface generator for nesC

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>nescc-mig</b> [any nescc option] [tool-specific options]
                 [<b>-o</b> <u>output-file</u>] [<b>-nescc=</b><u>driver</u>]
                 <u>tool</u> <u>msg-format-file</u> <u>message-type</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>nescc-mig</b>  is a tool to generate code to process nesC messages (which are specified by C types). The <u>tool</u>
       argument specifies what tool should be generated, the <u>message-type</u> specifies the C type  of  the  message
       you wish to process and <u>msg-format-file</u> specifies a nesC file which uses that type. The message type must
       be defined with <b>struct</b> <u>message-type</u>, <b>nx_struct</b> <u>message-type</u>, <b>union</b> <u>message-type</u>, <b>nx_union</b> <u>message-type</u>.

       When  used  with types whose layout is platform-dependent (i.e., not defined with <b>nx_struct</b> or <b>nx_union</b>),
       it is important to specify the correct <b>nescc</b> target architecture option (<b>-fnesc-target=</b><u>...</u>). If  you  are
       invoking <b>nescc-mig</b> indirectly via <b>mig</b>, you can use the <b>ncc</b> <b>-target=</b><u>...</u>  option instead.

       If  an  enum  constant  named <b>AM_</b><u>message_type</u> (with <u>message_type</u> capitalized) is found, then the value of
       that constant is assumed to be the active message type for <u>message-type</u>. If  you  need  access  to  other
       constants from your nesC application, please consult the <b>nescc-ncg</b> man page.

       The  current  tools  are <b>java</b>, <b>csharp</b>, <b>python</b> and <b>C</b>, which generate java, C#, python and C code to encode
       and decode messages.

</pre><h4><b>OPTIONS</b></h4><pre>
       You can pass any <b>nescc</b> option, as well as

       <b>-o</b> <u>output-file</u>
              Specify the file in which to output the generated code.

       <b>-nescc=</b><u>driver</u>
              Use <u>driver</u> instead of <b>nescc</b> to extract type layout  information.   For  example,  if  you  specify
              <b>-nescc=ncc</b>,  you can use <b>nescc-mig</b> to extract type information from TinyOS applications (which are
              normally compiled with <b>ncc</b>).

       tool-specific options
              See below.

</pre><h4><b>JAVA</b> <b>TOOL</b></h4><pre>
       This  tool  generates  a  java  class  to  encode  or  decode  a  nesC  message,  basing  itself  on  the
       net.tinyos.message infrastructure. It accepts the following options:

       <b>-java-classname=</b><u>full-class-name</u>
              This  option  is  required and specifies the package and name of the generated class. If the <u>full-</u>
              <u>class-name</u> has no '.', then no package directive is included in the output.

       <b>-java-extends=</b><u>class-name</u>
              Specify the class the generated class will extend. The default is <b>net.tinyos.message.Message</b>.

       For each field <u>fname</u> of structure <u>message-type</u>, there are the following methods (the bit offset and  size
       methods are useful for structures containing bitfields):

       *      <b>get_</b><u>fname</u>: get field's value

       *      <b>set_</b><u>fname</u>: set field's value

       *      <b>offsetBits_</b><u>fname</u>: return bit offset of field in <u>message-type</u>

       *      <b>offset_</b><u>fname</u>: return byte offset of field in <u>message-type</u>

       *      <b>sizeBits_</b><u>fname</u>: return size in bits of field (not for arrays)

       *      <b>size_</b><u>fname</u>: return size in bytes of field (not for arrays) (absent if <u>fname</u> is a bitfield)

       *      <b>isSigned_</b><u>fname</u>: return true if <u>fname</u> is of a signed type

       *      <b>isArray_</b><u>fname</u>: return true if <u>fname</u> is an array

       Embedded structures in <u>message-type</u> are expanded, using _ to separate the structure name and its fields.

       A number of extra methods are present for fields that are arrays:

       *      <b>getElement_</b><u>fname</u>: get an element of the array

       *      <b>setElement_</b><u>fname</u>: set an element of the array

       *      <b>elementSize_</b><u>fname</u>: return size in bytes of array elements

       *      <b>elementSizeBits_</b><u>fname</u>: return size in bits of array elements

       *      <b>numDimensions_</b><u>fname</u>: return number of dimensions of the array

       *      <b>numElements_</b><u>fname</u>:  return  number  of  elements  of  the  array  for a given dimension (left-most
              dimension is numbered 0) - the dimension is optional for 1-dimensional arrays

       *      <b>totalSize_</b><u>fname</u>: return size in bytes of the array (absent if the array is variable-size)

       *      <b>totalSizeBits_</b><u>fname</u>: return size in bits of the array (absent if the array is variable-size)

       If the array is 1-dimensional and the elements are one byte, then the following methods exist:

       *      <b>getString_</b><u>fname</u>: build a Java string from the array assuming it contains a C-style null-terminated
              string

       *      <b>setString_</b><u>fname</u>: set the array to a C-style null-terminated string given a java string

       The <b>getElement_...</b>, <b>setElement_...</b>, <b>offset_...</b> and <b>offsetBits_...</b> methods take  one  argument  per  array
       dimension.  These  methods  report  errors if the array index is out of bounds. If an array has a maximum
       size of 0, mig assumes it represents a variable-size array and does not  check  the  corresponding  array
       index.

       The data for a message is stored in an array, with explicit base and length information. The constructors
       can  either  allocate  this array, receive it as an explicit argument or extract if from another message.
       The base and length can also be optionally passed to these constructors.

       The optional length argument overrides the default size  of  sizeof(message-type);  this  is  useful  for
       variable-size messages. The use of an explicit base is helpful for messages embedded in other messages.

       The generated class also has an amType() method which returns the message's active message type, or -1 if
       no AM_<u>message_type</u> constant was found.

</pre><h4><b>C#</b> <b>TOOL</b></h4><pre>
       This tool generates a C# class to encode or decode a nesC message. It accepts the following options:

       <b>-csharp-classname=</b><u>full-class-name</u>
              This  option is required and specifies the namespace and name of the generated class. If the <u>full-</u>
              <u>class-name</u> has no '.', then no namespace directive is included in the output.

       <b>-csharp-extends=</b><u>class-name</u>
              Specify the class the generated class will extend. The default is <b>tinyos.message.Message</b>.

              The methods in the generated class are the same as for the Java tool.

</pre><h4><b>PYTHON</b> <b>TOOL</b></h4><pre>
       This tool generates a Python class to encode or decode a nesC message.  It accepts the following options:

       <b>-python-classname=</b><u>full-class-name</u>
              This option is required and specifies the name of the generated class.

       <b>-python-extends=</b><u>class-name</u>
              Specify the class the generated class will extend. The default is <b>tinyos.message.Message.Message</b>.

              The methods in the generated class are the same as for the Java tool.

</pre><h4><b>C</b> <b>TOOL</b></h4><pre>
       This tool generates a C header file (<b>.h</b>) with constants describing the type's layout, and a C module (<b>.c</b>)
       with functions to get and set each field. You must pass the <b>.h</b> file's name to <b>nescc-mig</b> using <b>-o</b>.

       The C tool accepts the following option:

       <b>-c-prefix=</b><u>prefix</u>
              This option specifies the <u>prefix</u> to attach to the generated constants and functions.  If  omitted,
              <u>message-type</u> is used.

       For  each  non-array  field  <u>fname</u>  of  structure <u>message-type</u>, the following functions and constants are
       generated:

       *      <u>prefix_fname</u><b>_get</b>(): get field's value

       *      <u>prefix_fname</u><b>_set</b>(): get field's value

       *      <u>prefix_fname</u><b>_OFFSETBITS</b>: bit offset of field

       *      <u>prefix_fname</u><b>_OFFSET</b>: byte offset of field

       *      <u>prefix_fname</u><b>_SIZEBITS</b>: size in bits of field

       *      <u>prefix_fname</u><b>_SIZE</b>: size in bytes of field

       For each array field  <u>fname</u>  of  structure  <u>message-type</u>,  the  following  functions  and  constants  are
       generated:

       *      <u>prefix_fname</u><b>_get()</b>: get field's value

       *      <u>prefix_fname</u><b>_set()</b>: get field's value

       *      <u>prefix_fname</u><b>_offsetbits()</b>: bit offset of array element

       *      <u>prefix_fname</u><b>_offset()</b>: byte offset of array element

       *      <u>prefix_fname</u><b>_ELEMENTSIZEBITS</b>: size in bits of array element

       *      <u>prefix_fname</u><b>_ELEMENTSIZE</b>: size in bytes of array element

       *      <u>prefix_fname</u><b>_NUMELEMENTS</b>: number of elements in array (absent for variable-sized arrays)

       *      <u>prefix_fname</u><b>_NUMELEMENTS_</b><u>i</u>: size of <u>i</u>th array dimension

       Embedded  structures in <u>message-type</u> are expanded, using _ to separate the structure name and its fields.
       A field of an array of embedded structures is considered to be an array.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>nescc-mig</b> reports an error if <b>nescc</b> cannot compile <u>msg-format-file</u>, if <u>message-type</u> isn't found or if  it
       contains pointers.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The  generated  code  for  the  various  tools  refer  to  libraries that are distributed with the TinyOS
       operating system. Please refer to that project's documentation for more information.

       <u><a href="../man1/mig.1.html">mig</a></u>(1), <u><a href="../man1/nescc.1.html">nescc</a></u>(1), <u><a href="../man1/nescc-ncg.1.html">nescc-ncg</a></u>(1)

                                                 April 27, 2004                                     <u><a href="../man1/nescc-mig.1.html">nescc-mig</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>