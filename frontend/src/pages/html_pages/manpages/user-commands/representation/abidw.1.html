<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>abidw - serialize the ABI of an ELF file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/abigail-tools">abigail-tools_2.6-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       abidw - serialize the ABI of an ELF file

       abidw reads a shared library in <u>ELF</u> format and emits an XML representation of its ABI to standard output.
       The  emitted  representation  format,  named  <b>ABIXML</b>,  includes  all  the  globally defined functions and
       variables, along with a complete representation of their types.  It also includes a representation of the
       globally defined ELF symbols of the file.

       When given the <b>--linux-tree</b> option, this program can also  handle  a  <u>Linux</u>  <u>kernel</u>  tree.   That  is,  a
       directory  tree  that contains both the vmlinux binary and <u>Linux</u> <u>Kernel</u> modules.  It analyses those <u>Linux</u>
       <u>Kernel</u> binaries and emits an XML representation of the interface between the kernel and  its  module,  to
       standard  output.   In  this  case,  we  don’t  call it an ABI, but a KMI (Kernel Module Interface).  The
       emitted  KMI  includes  all  the  globally  defined  functions  and  variables,  along  with  a  complete
       representation of their types.

       To  generate  either  ABI  or  KMI  representation,  by default <b>abidw</b> uses debug information in the <u>DWARF</u>
       format, if present, otherwise it looks for debug information in <u>CTF</u> or <u>BTF</u> formats, if present.  Finally,
       if no debug info in these formats is found, it only considers <u>ELF</u> symbols and report about their addition
       or removal.

       This tool uses the libabigail library to analyze the binary as well as its associated debug  information.
       Here is its general mode of operation.

       When  instructed  to  do so, a binary and its associated debug information is read and analyzed.  To that
       effect, libabigail analyzes by default  the  descriptions  of  the  types  reachable  by  the  interfaces
       (functions  and  variables)  that  are  visible outside of their translation unit.  Once that analysis is
       done, an Application Binary Interface Corpus is constructed by  only  considering  the  subset  of  types
       reachable  from  interfaces  associated to <u>ELF</u> symbols that are defined and exported by the binary.  It’s
       that final ABI corpus which libabigail considers as representing the ABI of the analyzed binary.

       Libabigail then has capabilities to generate  textual  representations  of  ABI  Corpora,  compare  them,
       analyze their changes and report about them.

</pre><h4><b>INVOCATION</b></h4><pre>
          abidw [options] [&lt;path-to-elf-file&gt;]

</pre><h4><b>OPTIONS</b></h4><pre>
          • <b>--help</b> <b>|</b> <b>-h</b>

            Display a short help about the command and exit.

          • <b>--version</b> <b>|</b> <b>-v</b>

            Display the version of the program and exit.

          • <b>--abixml-version</b>

            Display the version of the ABIXML format emitted by this program and exit.

          • <b>--add-binaries</b> &lt;<u>bin1,bin2,…</u>&gt;

            For each of the comma-separated binaries given in argument to this option, if the binary is found in
            the  directory  specified  by the <u>–added-binaries-dir</u> option, then load the ABI corpus of the binary
            and add it to a set of ABI corpora (called a ABI Corpus Group) made of the  binary  denoted  by  the
            Argument of <b>abidw</b>.  That corpus group is then serialized out.

          • <b>--follow-dependencies</b>

            For  each  dependency of the input binary of <b>abidw</b>, if it is found in the directory specified by the
            <b>--added-binaries-dir</b> option, then construct an ABI corpus out of the dependency and add it to a  set
            of  ABI  corpora  (called  an ABI Corpus Group) along with the ABI corpus of the input binary of the
            program.  The ABI Corpus Group is then serialized out.

          • <b>--list-dependencies</b>

            For each dependency of the input binary of``abidw``, if it’s found in the directory specified by the
            <b>--added-binaries-dir</b> option, then the name of the dependency is printed out.

          • <b>--added-binaries-dir</b> <b>|</b> <b>--abd</b> &lt;<u>dir-path</u>&gt;

            This option is to be used in conjunction with the <b>--add-binaries</b>, the <b>--follow-dependencies</b>  or  the
            <b>--list-dependencies</b>  option.   Binaries  listed  as  arguments of the <b>--add-binaries</b> option or being
            dependencies of the input binary in the case of the <b>--follow-dependencies</b> option and  found  in  the
            directory  &lt;<u>dir-path</u>&gt;  are  going  to  be  loaded  as ABI corpus and added to the set of ABI corpora
            (called an ABI corpus group) built and serialized.

          • <b>--debug-info-dir</b> <b>|</b> <b>-d</b> &lt;<u>dir-path</u>&gt;

            In cases where the debug info for <u>path-to-elf-file</u> is in a  separate  file  that  is  located  in  a
            non-standard place, this tells <b>abidw</b> where to look for that debug info file.

            Note that <u>dir-path</u> must point to the root directory under which the debug information is arranged in
            a tree-like manner.  Under Red Hat based systems, that directory is usually <b>&lt;root&gt;/usr/lib/debug</b>.

            This option can be provided several times with different root directories.  In that case, <b>abidw</b> will
            potentially look into all those root directories to find the split debug info for the elf file.

            Note  that  this  option  is  not  mandatory  for split debug information installed by your system’s
            package manager because then <b>abidw</b> knows where to find it.

          • <b>--out-file</b> <b>|</b> <b>-o</b> &lt;<u>file-path</u>&gt;

            This option instructs <b>abidw</b> to emit  the  XML  representation  of  <u>path-to-elf-file</u>  into  the  file
            <u>file-path</u>, rather than emitting it to its standard output.

          • <b>--noout</b>

            This option instructs <b>abidw</b> to not emit the XML representation of the ABI.  So it only reads the ELF
            and  debug  information,  builds  the  internal representation of the ABI and exits.  This option is
            usually useful for debugging purposes.

          • <b>--no-corpus-path</b>

            Do not emit the path attribute for the ABI corpus.

          • <b>--suppressions</b> <b>|</b> <b>suppr</b> &lt;<u>path-to-suppression-specifications-file</u>&gt;

            Use a <u>suppression</u> <u>specification</u> file located at <u>path-to-suppression-specifications-file</u>.  Note  that
            this  option  can  appear  multiple  times  on  the command line.  In that case, all of the provided
            suppression specification files are taken into account.  ABI artifacts matched  by  the  suppression
            specifications are suppressed from the output of this tool.

          • <b>--kmi-whitelist</b> <b>|</b> <b>--kmi-stablelist</b> <b>|-w</b> &lt;<u>path-to-stablelist</u>&gt;

            When  analyzing  a  <u>Linux</u>  <u>Kernel</u>  binary, this option points to the list of names of ELF symbols of
            functions and variables which ABI must be written out.  Any function or variable with a name that is
            not included in that list will not ignored.  That list is called a “ Kernel Module Interface  stable
            list”.   This  is  because  for  the  Kernel,  we don’t talk about the ABI; we rather talk about the
            interface between the Kernel and its module. Hence the term <b>KMI</b> rather than <b>KABI</b>.

            Any other function or variable which ELF symbol are not present in that  stable  list  will  not  be
            considered by the KMI writing process.

            If  this option is not provided – thus if no stable list is provided – then the entire KMI, that is,
            all publicly defined and exported functions and global variables by the  <u>Linux</u>  <u>Kernel</u>  binaries  is
            emitted.

          • <b>--linux-tree</b> <b>|</b> <b>--lt</b>

            Make  <b>abidw</b>  to  consider  the  input path as a path to a directory containing the vmlinux binary as
            several kernel modules binaries.  In that case, this program emits the representation of the  Kernel
            Module Interface (KMI) on the standard output.

            Below is an example of usage of <b>abidw</b> on a <u>Linux</u> <u>Kernel</u> tree.

            First,  checkout  a  <u>Linux</u>  <u>Kernel</u>  source  tree and build it.  Then install the kernel modules in a
            directory somewhere.  Copy the vmlinux binary into that directory too.  And then serialize  the  KMI
            of that kernel to disk, using <b>abidw</b>:

                $ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
                $ cd linux &amp;&amp; git checkout v4.5
                $ make allyesconfig all
                $ mkdir build-output
                $ make INSTALL_MOD_PATH=./build-output modules_install
                $ cp vmlinux build-output/modules/4.5.0
                $ abidw --linux-tree build-output/modules/4.5.0 &gt; build-output/linux-4.5.0.kmi

          • <b>--headers-dir</b> <b>|</b> <b>--hd</b> &lt;headers-directory-path-1&gt;

            Specifies  where  to  find the public headers of the binary that the tool has to consider.  The tool
            will thus filter out types that are not defined in public headers.

            Note that several public header directories can be specified for the binary to  consider.   In  that
            case  the  <b>--header-dir</b>  option  should  be  present  several times on the command line, like in the
            following example:

                $ abidw --header-dir /some/path       \
                        --header-dir /some/other/path \
                        binary &gt; binary.abi

          • <b>--header-file</b> <b>|</b> <b>--hf</b> &lt;header-file-path&gt;

            Specifies where to find one of the public headers of the abi file that the  tool  has  to  consider.
            The tool will thus filter out types that are not defined in public headers.

          • <b>--drop-private-types</b>

            This  option  is  to  be  used with the <b>--headers-dir</b> and/or <b>header-file</b> options.  With this option,
            types that are <u>NOT</u> defined in the headers are entirely  dropped  from  the  internal  representation
            build by Libabigail to represent the ABI and will not end up in the abi XML file.

          • <b>--no-elf-needed</b>

            Do not include the list of DT_NEEDED dependency names in the corpus.

          • <b>--drop-undefined-syms</b>

            With this option functions or variables for which the (exported) ELF symbol is undefined are dropped
            from the internal representation build by Libabigail to represent the ABI and will not end up in the
            abi XML file.

          • <b>--exported-interfaces-only</b>

            By  default,  when  looking  at  the debug information accompanying a binary, this tool analyzes the
            descriptions of the types reachable by the interfaces (functions and  variables)  that  are  visible
            outside of their translation unit.  Once that analysis is done, an ABI corpus is constructed by only
            considering the subset of types reachable from interfaces associated to <u>ELF</u> symbols that are defined
            and  exported  by  the  binary.  It’s that final ABI corpus which textual representation is saved as
            <b>ABIXML</b>.

            The problem with that approach however is that analyzing all the interfaces that  are  visible  from
            outside  their  translation  unit  can  amount  to a lot of data, especially when those binaries are
            applications, as opposed to shared libraries.  One example of such applications is the <u>Linux</u> <u>Kernel</u>.
            Analyzing massive ABI corpora like these can be extremely slow.

            To mitigate that performance issue, this option allows libabigail to only  analyze  types  that  are
            reachable from interfaces associated with defined and exported <u>ELF</u> symbols.

            Note  that  this  option  is  turned on by default when analyzing the <u>Linux</u> <u>Kernel</u>.  Otherwise, it’s
            turned off by default.

          • <b>--allow-non-exported-interfaces</b>

            When looking at the debug information accompanying a binary, this tool analyzes the descriptions  of
            the  types  reachable  by the interfaces (functions and variables) that are visible outside of their
            translation unit.  Once that analysis is done, an ABI corpus is constructed by only considering  the
            subset of types reachable from interfaces associated to <u>ELF</u> symbols that are defined and exported by
            the binary.  It’s that final ABI corpus which textual representation is saved as <b>ABIXML</b>.

            The  problem  with  that approach however is that analyzing all the interfaces that are visible from
            outside their translation unit can amount to a lot of  data,  especially  when  those  binaries  are
            applications, as opposed to shared libraries.  One example of such applications is the <u>Linux</u> <u>Kernel</u>.
            Analyzing massive ABI corpora like these can be extremely slow.

            In  the  presence  of an “average sized” binary however one can afford having libabigail analyze all
            interfaces that are visible outside of their translation unit, using this option.

            Note that this option is turned on by default, unless we are in the presence of the <u>Linux</u> <u>Kernel</u>.

          • <b>--no-linux-kernel-mode</b>

            Without this option, if abipkgiff detects that the binaries  it  is  looking  at  are  Linux  Kernel
            binaries  (either  vmlinux  or  modules)  then  it  only considers functions and variables which ELF
            symbols are listed in the __ksymtab and __ksymtab_gpl sections.

            With this option, abipkgdiff considers the binary as a non-special ELF binary.   It  thus  considers
            functions and variables which are defined and exported in the ELF sense.

          • <b>--check-alternate-debug-info</b> &lt;<u>elf-path</u>&gt;

            If  the debug info for the file <u>elf-path</u> contains a reference to an <u>alternate</u> <u>debug</u> <u>info</u> file, <b>abidw</b>
            checks that it can find that alternate debug info file.  In that case, it emits a meaningful success
            message mentioning the full path to the alternate debug info file found.   Otherwise,  it  emits  an
            error code.

          • <b>--no-show-locs</b>
              In  the  emitted  ABI  representation,  do  not  show file, line or column where ABI artifacts are
              defined.

          • <b>--no-parameter-names</b>

            In the emitted ABI representation, do not show names of function parameters, just the types.

          • <b>--no-write-default-sizes</b>

            In the XML ABI representation, do not write the size-in-bits for pointer type definitions, reference
            type definitions, function declarations and function types  when  they  are  equal  to  the  default
            address size of the translation unit.  Note that libabigail before 1.8 will not set the default size
            and will interpret types without a size-in-bits attribute as zero sized.

          • <b>--type-id-style</b> &lt;<b>sequence``|``hash</b>&gt;

            This  option controls how types are idenfied in the generated XML files.  The default <b>sequence</b> style
            just numbers (with <b>type-id-</b> as prefix) the types in the order they are encountered.  The <b>hash</b>  style
            uses  a  (stable, portable) hash of libabigail’s internal type names and is intended to make the XML
            files easier to diff.

          • <b>--check-alternate-debug-info-base-name</b> &lt;<u>elf-path</u>&gt;

            Like <b>--check-alternate-debug-info</b>, but in the success message, only mention the  base  name  of  the
            debug info file; not its full path.

          • <b>--load-all-types</b>

            By  default,  <b>libabigail</b>  (and  thus  <b>abidw</b>)  only loads types that are reachable from functions and
            variables declarations that are publicly defined and exported by the binary.  So  only  those  types
            are  present  in the output of <b>abidw</b>.  This option however makes <b>abidw</b> load <u>all</u> the types defined in
            the binaries, even those that are not reachable from public declarations.

            • <b>--no-load-undefined-interfaces</b>

            By default, <b>libabigail</b> (and thus <b>abidw</b>) loads information  about  undefined  function  and  variable
            symbols  as well as functions and variables that are associated with those undefined symbols.  Those
            are called undefined interfaces.  This option however makes makes <b>abidw</b>  avoid  loading  information
            about  undefined  interfaces.   The  resulting XML file thus doesn’t contain information about those
            undefined interfaces.

          • <b>--abidiff</b>
              Load the ABI of the ELF binary given in  argument,  save  it  in  libabigail’s  XML  format  in  a
              temporary  file;  read  the ABI from the temporary XML file and compare the ABI that has been read
              back against the ABI of the ELF binary given in argument.  The ABIs should compare equal.  If they
              don’t, the program emits a diagnostic and exits with a non-zero code.

              This is a debugging and sanity check option.

              • <b>--debug-abidiff</b>

              Same as <b>--abidiff</b> but in debug mode.  In this mode, error messages are  emitted  for  types  which
              fail type canonicalization.

              This  is an optional debugging and sanity check option.  To enable it the libabigail package needs
              to be configured with the –enable-debug-self-comparison option.

              • <b>--debug-type-canonicalization</b> <b>|</b> <b>--debug-tc</b>

              Debug the type canonicalization process.  This is done by using structural and canonical  equality
              when  canonicalizing  every  single type.  Structural and canonical equality should yield the same
              result.  If they don’t  yield  the  same  result  for  a  given  type,  then  it  means  that  the
              canonicalization  of  that  type  went  wrong.   In that case, an error message is emitted and the
              execution of the program is aborted.

              This   option   is   available    only    if    the    package    was    configured    with    the
              –enable-debug-type-canonicalization option.

          • <b>--no-assume-odr-for-cplusplus</b>

            When  analysing a binary originating from C++ code using <u>DWARF</u> debug information, libabigail assumes
            the <u>One</u> <u>Definition</u> <u>Rule</u> to speed-up the analysis.  In that case, when several types  have  the  same
            name in the binary, they are assumed to all be equal.

            This option disables that assumption and instructs libabigail to actually actually compare the types
            to determine if they are equal.

          • <b>--no-leverage-dwarf-factorization</b>

            When  analysing  a  binary  which  <u>DWARF</u> debug information was processed with the <u>DWZ</u> tool, the type
            information is supposed to be already factorized.  That context is used  by  libabigail  to  perform
            some speed optimizations.

            This option disables those optimizations.

          • <b>--ctf</b>

            Extract ABI information from <u>CTF</u> debug information, if present in the given object.

          • <b>--annotate</b>
              Annotate  the  ABIXML  output  with  comments  above  most elements.  The comments are made of the
              pretty-printed form types, declaration or even ELF symbols.  The purpose is  to  make  the  ABIXML
              output more human-readable for debugging or documenting purposes.

          • <b>--stats</b>

            Emit statistics about various internal things.

          • <b>--verbose</b>

            Emit verbose logs about the progress of miscellaneous internal things.

</pre><h4><b>USAGE</b> <b>EXAMPLES</b></h4><pre>
          1. Emitting an <b>ABIXML</b> representation of a binary:

                 $ abidw binary &gt; binary.abi

          2. Emitting an <b>ABIXML</b> representation of a set of binaries specified on the command line:

                 $ abidw --added-binaries=bin1,bin2,bin3  \
                         --added-binaries-dir /some/where \
                         binary &gt; binaries.abi

             Note  that  the  binaries  bin1,  bin2  and  bin3  are to be found in the directory <b>/some/where</b>.  A
             representation of the ABI of the set of binaries <b>binary,</b> <b>bin1,</b> <b>bin2</b> and <b>bin3</b> called an  <b>ABI</b>  <b>corpus</b>
             <b>group</b> is serialized in the file binaries.abi.

          3. Emitting an <b>ABIXML</b> representation of a binary and its dependencies:

                 $ abidw --follow-dependencies              \
                         --added-binaries-dir /some/where   \
                         binary &gt; binary.abi

             Note  that  only  the dependencies that are found in the directory <b>/some/where</b> are analysed.  Their
             ABIs, along with the ABI the binary named <b>binary</b>  are  represented  as  an  ABI  corpus  group  and
             serialized in the file <b>binary.abi</b>, in the ABIXML format.

</pre><h4><b>NOTES</b></h4><pre>
   <b>Alternate</b> <b>debug</b> <b>info</b> <b>files</b>
       As  of  the  version  4 of the DWARF specification, <u>Alternate</u> <u>debug</u> <u>information</u> is a <u>GNU</u> extension to the
       DWARF specification.  It has however been proposed for inclusion into the upcoming version 5 of the DWARF
       standard.  You can read more about the GNU extensions to the DWARF standard <u>here</u>.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dodji Seketeli

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2014-2024, Red Hat, Inc.

                                                  Nov 13, 2024                                          <u><a href="../man1/ABIDW.1.html">ABIDW</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>