<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>audio_rename - rename an audio file via information got via MP3::Tag.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libmp3-tag-perl">libmp3-tag-perl_1.16-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       audio_rename - rename an audio file via information got via MP3::Tag.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         audio_rename -csR -@p "@a/@l/@02n_@t" .

       renames all the audio files in this directory and its subdirectories into a 3-level directory structure
       given by <u>Artist_Name/Album/Filename</u>, with the basename of <u>Filename</u> being the 2-digit track number
       separated from the title by underscore; it also transliterates cyrillic, and shortens long names.

       (Due to use of "-@" and double quotes, this command line should work both with UNIXish and DOSish shells;
       the other examples can be massaged likewise.)

       (Replacing @02n by "@{mA}@{n0}" (as in the default value of "-p") may provide more intelligent semantic.
       See the description of "-p".

         audio_rename -KD *.wav

       Reports how it would rename the <u>*.wav</u> files in this directory according to the default <b>-p</b> rule, but
       without protectiing "funny" characters.  Will not do actual renaming.

         audio_rename -sc *.mp3

       Rename the <u>*.mp3</u> files in this directory according to the default <b>-p</b> rule, translating cyrillic
       characters into Latin "equivalents", shortening the names of long components, and protecting "funny"
       characters.

         audio_rename -p '%a/%{d0}/%B' -G '*/*.mp3'

       Assuming one-level subdirectory structure <u>dir/filename.ext</u>, finds files with extension <u>.mp3</u>, and "sorts"
       them into a two-level subdirectory structure; toplevel directory is based on the "artist" field, the
       remaing level is preserved.

         audio_rename -p '%a/%{d0}/%B' -R .

       Likewise, but does not suppose any particular depth of the current directory structure; only the filename
       and the most internal directory name are preserved.

         audio_rename -p '%a/%N' -R .

       Likewise, but all directory names (inside the current directory) are preserved.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The script takes a list of files (or, with <b>-R</b> option, directories) and renames the given files (or audio
       files in the directories) according to the rules specified through the command line options.  File
       extensions are preserved (by default).

       Some "companion" files (i.e., files with the same basename, and with an extension from a certain list)
       may be renamed together with audio files.  A lot of care is taken to make the resulting file names as
       portable as possible: e.g., "funny" characters in file names are dumbed down (unless requested
       otherwise), long filename components may be shortened to certain limits.

       A care is taken so that renaming will not overwrite existing files; however, on OSes which allow <b>rename()</b>
       to overwrite files, race conditions can ruin the best intentions.  E.g., do not run several "overlapping"
       rename procedures simultaneously!

</pre><h4><b>Recognized</b> <b>options</b></h4><pre>
       General use options:

       <b>-p</b> "TARGET_FILENAME_PATTERN"
           Target file name/basename pattern; is subject to interpolation via "MP3::Tag" method "interpolate()".
           Default is "%{mA}%{n0}_%t"; in simplest cases this uses 2-digit track number separated from the title
           by underscore.  See "interpolate" in MP3::Tag for more details.

           Here  is  the  explanation  of  the default value: due to semantic of escapes "%{mA}" and "%{n0}", if
           "TPOS" frame (disk number) is present, it is encoded as a letter, and put before  the  track  number.
           If the track number has a form "N1/N2" (meaning track N1 of N2), then N1 is used, and padded by 0s to
           the width of N2.  If "N2" is not present, padding to width=2 is used.

           For  example,  if  "TPOS"  is  3/12,  and  track  is "14/173", then what is prepended to the title is
           "c014_"; if there is no "TPOS" frame, and track is "4/8", "4_" is prepended without any leading 0.

           (If  you  want  to  modify   the   semantic   of   "%{n0}",   note   that   it   is   equivalent   to
           "%{n2:%{n0}}%{!n2:%02n}".   So  while  %02{n0}  will  ALWAYS  0-pad  to at least width=2, the pattern
           "%{n2:%{n0}}%{!n2:%03n}" will 0-pad to width=3 in the case N2 is absent.

       <b>-e</b> ".ext1|.ext2|..."
           "|"-separated list of associated extensions; when renaming  <u>source.mp3</u>  to  <u>target.mp3</u>,  the  similar
           rename  will  be done to files with the same basename, and extensions <u>.ext1</u>, <u>.ext2</u>, etc.  Defaults to
           ".inf|.tag|.id3".

       <b>-x</b>  If not present, the pattern of <b>-p</b> is the basename; the extension of the initial file is appended  (as
           interpolated  by  %E).  If present, the pattern of <b>-p</b> is the complete file name.  Behaviour with non-
           empty list of associated extensions is not defined.

       The following options have the same meaning as for script "mp3info2"

       <b>-D</b>  "Dry run": do not rename, just report the calculated renames.

       <b>-G</b>  Arguments are glob patterns; expand them.

       <b>-R</b>  Arguments are directory names, recurse inside using option <b>-E</b> for  choosing  audio  files  via  their
           extension.

       <b>-r</b>  Regular  expression  to  use  when looking for audio files per option <b>-R</b>.  Defaults to "(?i:\.mp3$)":
           will find files ending in <u>.mp3</u> (ignoring the case).  Note that this expression is put  into  a  case-
           ignoring   regular   expression,  so  if  you  want  it  to  be  case-sensitive,  protect  it  as  in
           "(?-i:REGEXPR)".

       <b>-E</b>  "option_letters"
           Controls expansion of escape characters.  It should contain the letters of the  command-line  options
           where "\\, \n, \t" are interpolated.  Default is none.

       <b>-@</b>  Replace  "@"  by  "%"  in  option  values.  (May be useful since <b>-p</b> and <b>-P</b> may have a lot of embedded
           characters "%", which may be hard to deal with on some shells, e.g., DOSISH  shells.   DOSish  shells
           recognize  double  quotes,  so  if  one wants shell-transparent examples of command lines, use -@ and
           double quotes.)

       <b>-P</b> "patterns"
           Patterns to parse before application of the rule <b>-p</b>.  See mp3info2 for details.

       <b>-C</b> "config_options"
           Configuration options for MP3::Tag.  See mp3info2 for details.

       File name portability options:

       <b>-s</b>  Make the components of file names short enough to fit on a CD file system.  Currently this means  the
           restriction  to  110  chars  (as  with "mkisofs -J --joliet-long", at least of version 2.01a32).  The
           limit may be modified per "AUDIO_MAX_FILENAME_LEN" environment variable.

           Note that "components" are parts separated by a literal character  "/"  in  the  given  pattern  (not
           slashes coming from interpolated strings).

       <b>-c</b>  Latinize  file names (for portability) assuming they are in Unicode (or WinCyrillic) encoding.  Needs
           <u>transliterate_win1251.pm</u> (in <u>examples/mod/Encode</u>  directory  of  the  distribution;  put  it  in  the
           subdirectory <u>Encode</u> of the script directory).

       <b>-K</b>  Do  not  convert  "exotic"  characters  to underscores (those characters which have a low portability
           score, so the files will have problem being moved between systems).

       <b>-L</b>  The value of option "-L" is the encoding used for the output; if  the  value  is  a  number,  system-
           specific  encoding is guessed (and used for the output if the bit 0x1 is set); if the bit 0x2 is set,
           then command line options are assumed to be in the guessed encoding; if the  bit  0x4  is  set,  then
           command  line  arguments  are  assumed  to  be  in  the guessed encoding.  If the bit 0x8 is set, the
           encoding/decoding configuration of file input/output of "MP3::Tag" is redone with  the  the  detected
           encoding.

       <b>-U</b>  In  presence  of "-U" option the default for "-L" is 15, and the decoding/encoding processing happens
           as if LANG is set for "UTF-8" encoding.  (For example, for "-Uee 1" the "STDOUT" the  output  message
           of  this  script  happens  in UTF-8 mode, which makes it easier to detect decoding/encoding errors in
           tags.)

       Note that this utility performes very similarly to mp3info2 utility when the latter one is used  with  <b>-p</b>
       option; only instead of printing the result of interpolation of <b>-p</b>, it uses the result as the target file
       name  for  renaming  (after  some  "sanitizing"  of the result).  (However, the defaults for "-E" options
       differ!)

       Please take into account that the option <b>-P</b> is provided for  completeness  only.   If  one  needs  really
       complicated  parsing rules to deduce the resulting file name, it is much safer to use mp3info2 utility to
       set the wanted file name into some ID3v2 frame (such  as  "TXXX[wanted-target-name]"),  and  then,  after
       checking for errors, use this result similarly to

         audio_rename -p "%{TXXX[wanted-target-name]}" -R .

       After rename, one can delete this frame from the resulting files.

       If  you  want  to  be  absolutely  error-prone,  preserve the initial file name inside the files by doing
       something similar to

         mp3info2 -@F "TXXX[orig-fname]=@A" -R .

       before the rename.  If worst  comes  to  worst  (but  no  race  conditions  happend,  so  files  are  not
       overwritten), one should be able to restore the status quo by running

         audio_rename -@p "@A" files_or_directories_list

       (giving <b>-R</b> option if needed).

</pre><h4><b>POSSIBLE</b> <b>PROBLEMS</b></h4><pre>
       With  <b>-R</b>  option,  there might be situations when the scan of subdirectories first finds a source file in
       some directory, renames it, then continues the scan of other subdirectories, and  will  find  the  target
       file, so will try to rename it again.

       In  practice,  I  do not recall ever encountering this situation; if the target file name depends only on
       the contents of the file, and not its name, then the second rename will be tautological, so not visible.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ilya Zakharevich &lt;<a href="mailto:cpan@ilyaz.org">cpan@ilyaz.org</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       MP3::Tag, MP3::Tag::ParseData, mp3info2

perl v5.36.0                                       2022-12-30                                   <u><a href="../man1p/AUDIO_RENAME.1p.html">AUDIO_RENAME</a></u>(1p)
</pre>
 </div>
</div></section>
</div>
</body>
</html>