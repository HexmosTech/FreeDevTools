<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>srec_examples - examples of how to use SRecord</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/srecord">srecord_1.64-4.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       srec_examples - examples of how to use SRecord

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>srec_cat</u>  command  is  very  powerful, due to the ability to combine the the input filters in almost
       unlimited ways.  This manual page describes a few of them.

       This manual page describes how to use the various input files, input filters and input  generators.   But
       these are only examples, for more complete details, see the <u><a href="../man1/srec_input.1.html">srec_input</a></u>(1) manual page.

   <b>The</b> <b>Commands</b> <b>Lines</b> <b>Are</b> <b>Too</b> <b>Long</b>
       If  you  are  marooned on an operating system with absurdly short command line length limits, some of the
       commands which follow may be too long.  You can get around this handicap by placing your command line  in
       a  file, say <u>fred.txt</u>, and then tell <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) to read this file for the rest of its command line, like
       this

              srec_cat @fred.txt

       This also has the advantage of allowing comments, allowing you to write your command  line  options  over
       several  lines, and even indenting to make the command more clear.  Comments start at a “<b>#</b>” and extend to
       the end of the line.  Blank lines are ignored.

       Of course, you could always upgrade to Linux, which has been sucking less for over 33 years now.

   <b>Your</b> <b>Examples</b> <b>Wanted</b>
       If you have a clever way of using SRecord, or have solved a difficult problem  with  SRecord,  you  could
       contribute to this manual page, making it more useful for everyone.  Send your example in an email to the
       email address at the end of this manual page.

</pre><h4><b>CONVERTING</b> <b>FILE</b> <b>FORMATS</b></h4><pre>
       The  simplest  of the things <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) can do is convert from one EPROM file format to another.  Please
       keep in mind, as you read this section, that you can do  many  of  these  things  simultaneously  in  one
       command.  They are only broken out separately to make them easier to understand.

   <b>Intel</b> <b>to</b> <b>Motorola</b>
       One of the simplest examples is converting files from Intel hex format to Motorola S‐Record format:

              srec_cat <u>intel‐file</u> -intel -o <u>srec‐file</u>

       Note  that  the format specifier immediately follows the name of the file it is describing.  Pick any two
       formats that SRecord understands, and it can convert between all of them.  (Except the assembler,  BASIC,
       C and FPGA outputs which are write only.)

   <b>Motorola</b> <b>to</b> <b>Intel</b>
       Converting the other way is just as simple:

              srec_cat <u>srec‐file</u> -o <u>intel‐file</u> -intel

       The default format is Motorola S‐Record format, so it does not need to be specified after the file name.

   <b>Different</b> <b>Shapes</b> <b>of</b> <b>the</b> <b>Same</b> <b>Format</b>
       It  is  regrettably  common  that  some  addle‐pated  EPROM  programmers  only implement a portion of the
       specification used to represent their hex files.  For example, some compilers produce “s19” Motorola data
       (that is, S1 data records with S9 start records, 16 bit address fields) which would  be  OK  except  that
       some  blockhead  EPROM  programmers insist on “s37” Motorola data (that is, S3 data records with S7 start
       records, 32 bit address fields).

       It is possible to convert from one Motorola shape to another using the <b>-Address‐Length</b> option:

              srec_cat short.srec -o long.srec -address‐length=4

       This command says to use four byte (32‐bit) addresses on output.

       This section also applies to Intel hex files, as they, too, have the ability to select from a variety  of
       address widths.  To convert from one Intel shape to another using the same <b>-Address‐Length</b> option:

              srec_cat i32.hex -o i16.hex -address‐length=3

       This  command  says  to use “i16hex” 20‐bit segmented addresses on output.  An address length of 4 is the
       default (“i32hex” 32‐bit linear addressing), and an address length of  2  would  request  “i8hex”  16‐bit
       addressing.

   <b>Line</b> <b>Lengths</b>
       From  time  to  time you will come across a feeble‐minded EPROM programmer that can't cope with long text
       lines, they assume that there will only ever be 46 characters per line and barf when they see the default
       line lengths that <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) writes (or worse, get a stack scribble and crash).

       The Motorola S‐record format definition permits up to 255 bytes of payload, or lines of  <u>514</u>  characters,
       plus  the  line  termination.   All EPROM programmers <u>should</u> have sufficiently large line buffers to cope
       with records this big.  Few do.

       The -line‐length option may be used to specify the maximum line length (not including the newline) to  be
       used on output.  For example, 16 byte payloads for Motorola hex

              srec_cat long.srec -o short.s19 -line‐length=46

       The  line  length option interacts with the address length option, so some tinkering to optimize for your
       particular situation many be necessary.

   <b>Output</b> <b>Block</b> <b>Size</b>
       Every once in a while you will come across an ancient daft EPROM programmer that  can't  cope  with  long
       data records, they assume that there will only ever be at most 16 bytes of data per record, and barf when
       they  see  the  default  32 byte payloads that <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) writes (or worse, the buffer over‐run causes a
       tall grass walk that scribbles on your EPROM).

       The Intel hex format definition permits  up  to  255  bytes  of  payload  data  per  record.   All  EPROM
       programmers  <u>should</u>  have  sufficiently large data buffers to cope with records this big.  Good luck with
       that.

       The -Output‐Block‐Size option may be used to specify the record data size to  be  used  on  output.   For
       example, Intel hex with 16 byte payloads:

              srec_cat long.srec -o short.hex -intel -obs=16

       Be careful not to put the <b>-obs</b> option between the output file name and the format specifier.

   <b>Just</b> <b>the</b> <b>Data,</b> <b>Please</b>
       There  are  some bonehead EPROM programmers which can only cope with data records, and are unable to cope
       with header records or execution start address records.  If you have this problem, the <b>-data‐only</b>  option
       can  be used to suppress just about everything except the data.  The actual effect depends on the format,
       of course, because some don't have these features anyway.

       The <b>-data‐only</b> option is short hand.  There are four  properties  which  may  be  <b>-disabled</b>  or  <b>-enabled</b>
       separately.  See the <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) man page for a description of the <b>-disabled</b> and <b>-enabled</b> options.

       For  example,  your  neanderthal  EPROM  programmer  requires  Motorola hex with header records (S0), but
       without data count (S5) records.  Not using the <b>-data‐only</b> option has it barf on the data  count  record,
       but  using the <b>-data‐only</b> option has it barf on the missing header record.  Using the <b>-disable=data‐count</b>
       option would leave the header record intact while suppressing the data count record.

   <b>Data</b> <b>Headers</b>
       The <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) command always tries to pass through header records unchanged, whenever they are present.
       It even tries preserve them across file format changes, to the limit the file formats are capable of.

       If there is no file header record and you would like to add one, or you wish to override an existing file
       header record, use the <b>-header</b>=<u>string</u> option.  You will need to quote the string (to insulate it from the
       shell) if it contains spaces or shell meta‐characters.

   <b>Execution</b> <b>Start</b> <b>Addresses</b>
       The <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) command always tries to pass through execution start addresses  (typically  occurring  at
       the  end  of  the file), whenever they are present.  They are adjusted along with the data records by the
       <b>-offset</b> filter.  It even tries preserve them across file format changes, to the limit  the  file  formats
       are capable of.

       If  there  is no execution start address record and you would like to add one, or you wish to override an
       existing execution start address record, use the <b>-execution‐start‐address</b>=<u>number</u> option.

       Please note: the execution start address is a different concept than the first address in memory of  your
       data.   Think of it as a “goto” address to be jumped to by the monitor when the hex load is complete.  If
       you want to change where your data starts in memory, use the <b>-offset</b> filter.

   <b>Fixing</b> <b>Checksums</b>
       Some embedded  firmware  developers  are  saddled  with  featherbrained  tools  which  produce  incorrect
       checksums, which the more vigilant models of EPROM programmer will not accept.

       To fix the checksums on a file, use the <b>-ignore‐checksums</b> option.  For example:

              srec_cat broken.srec -ignore‐checksums -o fixed.srec

       The  checksums  in <u>broken.srec</u> are parsed (it is still and error if they are absent) but are not checked.
       The resulting <u>fixed.srec</u> file has correct checksums.  The <b>-ignore‐checksums</b> option only applies to input.

       This option may be used on any file format which has checksums, including Intel hex.

   <b>Discovering</b> <b>Mystery</b> <b>Formats</b>
       See the <b>What</b> <b>Format</b> <b>Is</b> <b>This?</b> section, below, for how to discover and  convert  mystery  EPROM  load  file
       formats.

</pre><h4><b>BINARY</b> <b>FILES</b></h4><pre>
       It  is  possible  to  convert  to and from binary files.  You can even mix binary files and other formats
       together in the same <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) command.

   <b>Writing</b> <b>Binary</b> <b>Files</b>
       The simplest way of reading a hex file and converting it to a binary file looks like this:

              srec_cat fred.hex -o fred.bin -binary

       This reads the Motorola hex file <u>fred.srec</u> and writes it out to the <u>fred.bin</u> as raw binary.

       Note that the data is placed into the binary file at the byte offset specified by the  addresses  in  the
       hex  file.   If  there  are holes in the data they are filled with zero.  This is, of course, common with
       linker output where the code is placed starting at a particular place in memory.  For example,  when  you
       have an image that starts at 0x100000, the first 1MB of the output binary file will be zero.

       You can automatically cancel this offset using a command like

              srec_cat fred.hex -offset − -minimum‐addr fred.hex -o fred.bin

       The  above  command  works  by  offsetting  the <u>fred.hex</u> file lower in memory by the least address in the
       <u>fred.hex</u> file's data.

       See also the <u><a href="../man5/srec_binary.5.html">srec_binary</a></u>(5) man page for additional detail.

   <b>Reading</b> <b>Binary</b> <b>Files</b>
       The simplest way of reading a binary file and converting it looks like this

              srec_cat fred.bin -binary -o fred.srec

       This reads the binary file <u>fred.bin</u> and writes all of its data back out  again  as  a  Motorola  S‐Record
       file.

       Often,  this binary isn't exactly where you want it in the address space, because it is assumed to reside
       at address zero.  If you need to move it around use the <b>-offset</b> filter.

              srec_cat fred.bin -binary -offset 0x10000 -o fred.srec

       You also need to avoid file “holes” which are filled with zero.  You can use the  <b>-crop</b>  filter,  of  you
       could use the <b>-unfill</b> filter if you don't know exactly where the data is.

              srec_cat fred.bin -binary -unfill 0x00 512 -o fred.srec

       The  above  command  removes runs of zero bytes that are 512 bytes long or longer.  If your file contains
       1GB of leading zero bytes, this is going to be slow, it may be better to use the <u><a href="../man1/dd.1.html">dd</a></u>(1) command  to  slice
       and dice first.

</pre><h4><b>JOINING</b> <b>FILES</b> <b>TOGETHER</b></h4><pre>
       The  <u>srec_cat</u>  command  takes its name from the UNIX <u><a href="../man1/cat.1.html">cat</a></u>(1) command, which is short for “catenate” or “to
       join”.  The <u>srec_cat</u> command joins EPROM load files together.

   <b>All</b> <b>In</b> <b>One</b>
       Joining EPROM load files together into a single file is simple, just name as many files  on  the  command
       line as you need:

              srec_cat <u>infile1</u> <u>infile2</u> -o <u>outfile</u>

       This  example  is  all Motorola S‐Record files, because that's the default format.  You can have multiple
       formats in the one command, and <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) will still work.  You don't even  have  to  output  the  same
       format:

              srec_cat <u>infile1</u> -spectrum <u>infile2</u> -needham \
                  -o <u>outfile</u> -signetics

       These  are  all  ancient  formats,  however it isn't uncommon to have to mix and match Intel and Motorola
       formats in the one project.

   <b>Overlaying</b> <b>two</b> <b>data</b> <b>files</b>
       It is common to want to “join” two hex files together, without any changes of address. on the  assumption
       neither  file  intersects  with  the other.  This is a simple “layers”, it is quite common for linkers to
       output the main code, and then a whole bunch of relocation and jump destination, by writing a two layered
       files.
              srec_cat one.he two.hex -o three.hex
       Almost always you see an error
              srec_cat: two.srec: 49282: contradictory 0x00000000 value (previous = 0x00, this one = 0x80)

       This means that the files actually intersect, they try to set the same location.  You can turn the  error
       into  a  warning,  using  the  <b>-contradictory‐bytes=warning</b>  command line option.  But this will probably
       generate a bazillion warnings.

       The necessary step is to crop the first file, to avoid  the  regions  the  second  file  is  going  o  be
       overwriting.
              srec_cat                               \
                  one.srec -exclude -within two.srec \
                  two.srec -exclude -within one.srec \
                  -o three.hex

       Depending  on your linker this will have no errors (but if it wants another layer, more jiggery‐pokery is
       required).

   <b>Filtering</b> <b>After</b> <b>Joining</b>
       There are times when you want to join two sets of data together, and then apply a filter  to  the  joined
       result.  To do this you use parentheses.
              srec_cat                                                  \
                  '('                                                   \
                      <u>infile</u> -exclude 0xFFF0 0x10000                      \
                      -generate 0xFFF0 0xFFF8 -repeat‐string 'Bananas ' \
                  ')'                                                   \
                  -length‐b‐e 0xFFF8 4                                  \
                  -checksum‐neg‐b‐e 0xFFFC 4 4                          \
                  -o <u>outfile</u>

       The  above example command catenate an input file (with the generated data area excluded) with a constant
       string.  This catenated input is then filtered to add a 4‐byte length, and a 4‐byte checksum.

   <b>Joining</b> <b>End‐to‐End</b>
       All too often the address ranges in the EPROM load files will overlap.  You will get an error if they do.
       If both files start from address zero, because each goes into a separate EPROM, you may need to  use  the
       offset filter:

              srec_cat <u>infile1</u> \
                  <u>infile2</u> -offset 0x80000 \
                  -o <u>outfile</u>

       Sometimes you want the two files to follow each other exactly, but you don't know the offset in advance:

              srec_cat <u>infile1</u> \
                  <u>infile2</u> -offset -maximum‐addr <u>infile1</u> \
                  -o <u>outfile</u>

       Notice  that where the was a number (0x80000) before, there is now a calculation (-maximum‐addr <u>infile1</u>).
       This is possible most places a number may be used (also -minimum‐addr and -range).

</pre><h4><b>CROPPING</b> <b>THE</b> <b>DATA</b></h4><pre>
       It is possible to copy an EPROM load file, selecting addresses to keep and addresses to discard.

   <b>What</b> <b>To</b> <b>Keep</b>
       A common activity is to crop your data to match your EPROM location.  Your linker may add other junk that
       you are not interested in, <u>e.g.</u>  at the RAM location.  In this example, there is a 1MB EPROM at  the  2MB
       boundary:

              srec_cat <u>infile</u> -crop 0x200000 0x300000 \
                  -o <u>outfile</u>

       The lower bound for all address ranges is inclusive, the upper bound is exclusive.  If you subtract them,
       you get the number of bytes.

   <b>Address</b> <b>Offset</b>
       Just  possibly,  you  have  a  moronic EPROM programmer, and it barfs if the EPROM image doesn't start at
       zero.  To find out just where is <u>does</u> start in memory, use the <u><a href="../man1/srec_info.1.html">srec_info</a></u>(1) command:

              $ <b>srec_info</b> <b>example.srec</b>
              Format: Motorola S‐Record
              Header: extra‐whizz tool chain linker
              Execution Start Address: 0x00200000
              Data:   0x200000 - 0x32AAEF
              $

       Rather than butcher the linker command file, just offset the addresses:

              srec_cat <u>infile</u> -crop 0x200000 0x300000 -offset −0x200000 \
                  -o <u>outfile</u>

       Note that the offset given is <u>negative</u>, it has the effect of subtracting that value from all addresses in
       the input records, to form the output record addresses.  In this case, shifting the image back to zero.

       This example also demonstrates how the input filters may be chained together: first the crop and then the
       offset, all in one command, without the need for temporary files.

       If all you want to do is offset the data to start from address zero, this can be automated, so you  don't
       have  to know the minimum address in advance, by using <u>srec_cat</u>'s ability to calculate some things on the
       command line:

              srec_cat <u>infile</u> -offset − -minimum‐addr <u>infile</u> \
                  -o <u>outfile</u>

       Note the spaces either side of the minus sign, they are mandatory.

   <b>What</b> <b>To</b> <b>Throw</b> <b>Away</b>
       There are times when you need to exclude an small address range from an  EPROM  load  file,  rather  than
       wanting to keep a small address range.  The <b>-exclude</b> filter may be used for this purpose.

       For  example,  if  you wish to exclude the address range where the serial number of an embedded device is
       kept, say 0x20 bytes at 0x100, you would use a command like this:

              srec_cat input.srec -exclude 0x100 0x120 -o output.srec

       The <u>output.srec</u> file will have a hole in the data at the necessary locations.

       Note that you can have both <b>-crop</b> and <b>-exclude</b> on the same command line, whichever works  more  naturally
       for your situation.

   <b>Discontinuous</b> <b>Address</b> <b>Ranges</b>
       Address  ranges  don't  have  to  be  a single range, you can build up an address range using more than a
       single pair.

              srec_cat <u>infile</u> -crop 0x100 0x200 0x1000 0x1200 \
                  -o <u>outfile</u>

       This filter results in data from 0x100..0x1FF and data from 0x1000..0x1200 to pass through, the  rest  is
       dropped.  This is is more efficient than chaining a <b>-crop</b> and an <b>-exclude</b> filter together.

</pre><h4><b>MOVING</b> <b>THINGS</b> <b>AROUND</b></h4><pre>
       It  is  also  possible  to  change  the address of data records, both forwards and backwards.  It is also
       possible rearrange where data records are placed in memory.

   <b>Offset</b> <b>Filter</b>
       The <b>-offset=</b><u>number</u> filter operates on the addresses of records.  If the number is positive the  addresses
       move that many bytes higher in memory, negative values move lower.

              srec_cat <u>infile</u> -crop 0x200000 0x300000 -offset −0x200000 \
                  -o <u>outfile</u>

       The  above  example  moves  the  1MB  block of data at 0x200000 down to zero (the offset is <u>negative</u>) and
       discards the rest of the data.

   <b>Byte</b> <b>Swapping</b>
       There are times when the bytes in the data need to be swapped, converting between big‐endian and  little‐
       endian data usually.

              srec_cat <u>infile</u> -byte‐swap 4 -o <u>outfile</u>

       This  reverses bytes in 32 bit values (4 bytes).  The default, if you don't supply a width, is to reverse
       bytes in 16 bit values (2 bytes).  You can actually use any weird value you like, it doesn't even have to
       be a power of 2.  Perhaps 64 bits (8 bytes) may be useful one day.

   <b>Binary</b> <b>Output</b>
       You need to watch out for binary files on output, because the holes are filled with  zeros.   Your  100kB
       program  at  the  top  of  32‐bit  addressed  memory  will  make  a 4GB file.  See <u><a href="../man5/srec_binary.5.html">srec_binary</a></u>(5) for how
       understand and avoid this problem, usually with the <b>-offset</b> filter.

   <b>Splitting</b> <b>an</b> <b>Image</b>
       If you have a 16‐bit data bus, but you are using two 8‐bit EPROMs to hold your firmware, you can generate
       the even and odd images by using the <b>-SPlit</b> filter.  Assuming your firmware is in the <u>firmware.hex</u>  file,
       use the following:

              srec_cat firmware.hex -split 2 0 -o firmware.even.hex
              srec_cat firmware.hex -split 2 1 -o firmware.odd.hex

       This  will  result  in the two necessary EPROM images.  Note that the output addresses are divided by the
       split multiple, so if your EPROM images are at  a  particular  offset  (say  0x10000,  in  the  following
       example), you need to remove the offset, and then replace it...

              srec_cat firmware.hex \
                  -offset −0x10000 -split 2 0 \
                  -offset 0x10000 -o firmware.even.hex
              srec_cat firmware.hex \
                  -offset −0x10000 -split 2 1 \
                  -offset 0x10000 -o firmware.odd.hex

       Note how the ability to apply multiple filters simplifies what would otherwise be a much longer script.

   <b>Striping</b>
       A second use for the <b>-SPlit</b> filter is memory striping.

       You  don't  have  to  split  into  byte‐wide  parts, you can choose other sizes.  It is common to want to
       convert 32‐bit wide data into two set of 16‐bit wide data.

              srec_cat firmware.hex -split 4 0 2 -o firmware.01.hex
              srec_cat firmware.hex -split 4 2 2 -o firmware.23.hex

       This is relatively simple to understand, but you can use even wider stripes.

       In this next example, the hardware requires that 512‐byte blocks alternate between 4 EPROMs.   Generating
       the 4 images would be done as follows:

              srec_cat firmware.hex -split 0x800 0x000 0x200 -o firmware.0.hex
              srec_cat firmware.hex -split 0x800 0x200 0x200 -o firmware.1.hex
              srec_cat firmware.hex -split 0x800 0x400 0x200 -o firmware.2.hex
              srec_cat firmware.hex -split 0x800 0x600 0x200 -o firmware.3.hex

   <b>Asymmetric</b> <b>Striping</b>
       A  more  peculiar  example of striping is the Microchip dsPIC33F microcontroller, that has a weird memory
       storage pattern and they are able to store 3 bytes in an address that should only contain 2  bytes.   The
       result  is  a  hex  file that has zero‐filled the top byte (little‐endian), and all addresses are doubled
       from what they are in the chip.  Here is an example:

              S1130000000102000405060008090A000C0D0E0098
              S1130010101112001415160018191A001C1D1E00C8
              S1130020202122002425260028292A002C2D2E00F8
              S1130030303132003435360038393A003C3D3E0028

       To get rid of the 00 padding bytes, leaving only the 3/4  significant  bytes,  you  also  use  the  split
       filter, with its additional <u>width</u> argument, like this:

              srec_cat example.srec -split 4 0 3 -o no_dross.srec

       This results in a file with the 00 padding bytes removed.  It looks like this:

              S113000000010204050608090A0C0D0E1011121451
              S1130010151618191A1C1D1E2021222425262829EC
              S11300202A2C2D2E30313234353638393A3C3D3E87

       Notice  how the addresses are 3/4 the size, as well.  You can reverse this using the <b>-unsplit</b> and <b>-fill=0</b>
       filters.

   <b>Unsplit</b> <b>ING</b> <b>Images</b>
       The unsplit filter may be used to reverse the effects of the split filter.  Note that the  address  range
       is  expanded  leaving  holes  between  the  stripes.   By  using  all  the stripes, the complete input is
       reassembled, without any holes.

              srec_cat -o firmware.hex \
                  firmware.even.hex -unsplit 2 0 \
                  firmware.odd.hex  -unsplit 2 1

       The above example reverses the previous 16‐bit data bus example.  In general, you unsplit with  the  same
       parameters that you split with.

</pre><h4><b>FILLING</b> <b>THE</b> <b>BLANKS</b></h4><pre>
       Often  EPROM  load  files  will  have  “holes”  in them, places where the compiler and linker did not put
       anything.  For some purposes this is OK, and for other purposes something has to be done about the holes.

   <b>The</b> <b>Fill</b> <b>Filter</b>
       It is possible to fill the blanks where your data does not lie.  The simplest example of this  fills  the
       entire EPROM:

              srec_cat <u>infile</u> -fill 0x00 0x200000 0x300000 -o <u>outfile</u>

       This  example  fills  the  holes,  if  any, with zeros.  You must specify a range - with a 32‐bit address
       space, filling everything generates <u>huge</u> load files.

       If you only want to fill the gaps in your data, and don't want to fill the entire EPROM, try:

              srec_cat <u>infile</u> -fill 0x00 -over <u>infile</u> -o <u>outfile</u>

       This example demonstrates the fact that wherever an address range may be specified, the <b>-over</b> and <b>-within</b>
       options may be used.

   <b>Unfilling</b> <b>the</b> <b>Blanks</b>
       It is common to need to “unfill” an EPROM image after you read it out of a chip.  Usually, it  will  have
       had  all the holes filled with 0xFF (areas of the EPROM you don't program show as 0xFF when you read them
       back).

       To get rid of all the 0xFF bytes in the data, use this filter:

              srec_cat <u>infile</u> -unfill 0xFF -o <u>outfile</u>

       This will get rid of <u>all</u> the 0xFF bytes, including the ones you actually wanted in there.  There are  two
       ways to deal with this.  First, you can specify a minimum run length to the un‐fill:

              srec_cat <u>infile</u> -unfill 0xFF 5 -o <u>outfile</u>

       This  says that runs of 1 to 4 bytes of 0xFF are OK, and that a hole should only be created for runs of 5
       or more 0xFF bytes in a row.  The second method is to re‐fill over the intermediate gaps:

              srec_cat <u>outfile</u> -fill 0xFF -over <u>outfile</u> \
                  -o <u>outfile2</u>

       Which method you choose depends on your needs, and the shape of the data in your EPROM.  You may need  to
       combine both techniques.

   <b>Address</b> <b>Range</b> <b>Padding</b>
       Some data formats are 16 bits wide, and automatically fill with 0xFF bytes if it is necessary to fill out
       the  other  half of a word which is not in the data.  If you need to fill with a different value, you can
       use a command like this:

              srec_cat <u>infile</u> -fill 0x0A \
                  -within <u>infile</u> -range‐padding 2 \
                  -o <u>outfile</u>

       This gives the fill filter an address range calculated from details of the input file.  The address range
       is all the address ranges covered by data in the <u>infile</u>, extended downwards (if necessary) at  the  start
       of  each  sub‐range to a 2 byte multiple and extended upwards (if necessary) at the end of each sub‐range
       to a 2 byte multiple.  This also works for larger multiples, like 1kB page  boundaries  of  flash  chips.
       This address range padding works anywhere an address range is required.

   <b>Fill</b> <b>with</b> <b>Copyright</b>
       It  is  possible to fill unused portions of your EPROM with a repeating copyright message.  Anyone trying
       to reverse engineer your EPROMs is going to see the copyright notice in their hex editor.

       This is accomplished with two input sources, one from a data file, and one which is generated on‐the‐fly.

              srec_cat <u>infile</u> \
                  -generate '(' 0 0x100000 -minus -within <u>infile</u> ')' \
                      -repeat‐string 'Copyright (C) 1812 Tchaikovsky.  ' \
                  -o <u>outfile</u>

       Notice the address range for the data generation: it takes the address range of your EPROM, in this  case
       1MB starting from 0, and subtracts from it the address ranges used by the input file.

       If  you  want  to  script  this with the current year (because 1812 is a bit out of date) use the shell's
       output substitution (back ticks) ability:

              srec_cat <u>infile</u> \
                  -generate '(' 0 0x100000 -minus -within <u>infile</u> ')' \
                      -repeat‐string "Copyright (C) `date +%Y` Tchaikovsky.  " \
                  -o <u>outfile</u>

       The string specified is repeated over and over again, until it has filled all the holes.

   <b>Obfuscating</b> <b>with</b> <b>Noise</b>
       Sometimes you want to fill your EPROM images with noise, to conceal where the real data stops and starts.
       You can do this with the <b>-random‐fill</b> filter.

              srec_cat <u>infile</u> -random‐fill 0x200000 0x300000 \
                  -o <u>outfile</u>

       It works just like the <b>-fill</b> filter, but uses random numbers instead of a constant byte value.

   <b>Fill</b> <b>With</b> <b>16‐bit</b> <b>Words</b>
       When filling the image with a constant byte value doesn't work, and you need a constant 16‐bit word value
       instead, use the <b>-repeat‐data</b> generator, which takes an arbitrarily long sequence of bytes to use as  the
       fill pattern:

              srec_cat <u>infile</u> \
                  -generator '(' 0x200000 0x300000 -minus -within <u>infile</u> ')' \
                      -repeat‐data 0x1B 0x08 \
                  -o <u>outfile</u>

       Notice  how  the  generator's address range once again avoids the address ranges occupied by the <u>infile</u>'s
       data.  You have to get the endian‐ness right yourself.

</pre><h4><b>INSERTING</b> <b>CONSTANT</b> <b>DATA</b></h4><pre>
       From time to time you will want to insert constant data,  or  data  not  produced  by  your  compiler  or
       assembler, into your EPROM load images.

   <b>Binary</b> <b>Means</b> <b>Literal</b>
       One  simple  way  is to have the desired information in a file.  To insert the file's contents literally,
       with no format interpretation, use the <u>binary</u> input format:

              srec_cat <u>infile</u> -binary -o <u>outfile</u>

       It will probably be necessary to use an <u>offset</u> filter to move the data to  where  you  actually  want  it
       within the image:

              srec_cat <u>infile</u> -binary -offset 0x1234 -o <u>outfile</u>

       It  is  also  possible  to use the standard input as a data source, which lends itself to being scripted.
       For example, to insert the current date and time into an EPROM load file, you could use a pipe:

              date | srec_cat - -bin -offset 0xFFE3 -o <u>outfile</u>

       The special file name “-” means to read from the standard input.  The  output  of  the  <u>date</u>  command  is
       always 29 characters long, and the offset shown will place it at the top of a 64KB EPROM image.

   <b>Repeating</b> <b>Once</b>
       The  <b>Fill</b> <b>with</b> <b>Copyright</b> section, above, shows how to repeat a string over and over.  We can use a single
       repeat to insert a string just once.

              srec_cat -generate 0xFFE3 0x10000 -repeat‐string "`date`" \
                  -o <u>outfile</u>

       Notice how the address range for the data generation exactly matches the length  of  the  <u><a href="../man1/date.1.html">date</a></u>(1)  output
       size.   You  can,  of course, add your input file to the above <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) command to catenate your EPROM
       image together with the date and time.

   <b>Inserting</b> <b>A</b> <b>Long</b>
       Another possibility is to add the Subversion commit number to your EPROM image.  In this example, we  are
       inserting  it  a  a 4‐byte little‐endian value at address 0x0008.  The Subversion commit number is in the
       <u>$version</u> shell variable in this example:

              srec_cat -generate 0x0008 0x000C -constant‐l‐e $version 4 \
                  <u>infile</u> -exclude 0x0008 0x000C \
                  -o <u>outfile</u>

       Note that we use a filter to ensure there is a hole in the input where the version number goes,  just  in
       case the linker put something there.

</pre><h4><b>DATA</b> <b>ABOUT</b> <b>THE</b> <b>DATA</b></h4><pre>
       It is possible to add a variety of data about the data to the output.

   <b>Checksums</b>
       The <b>-checksum‐negative‐big‐endian</b> filter may be used to sum the data, and then insert the negative of the
       sum  into  the  data.   This has the effect of summing to zero when the checksum itself is summed across,
       provided the sum width matches the inserted value width.

              srec_cat <u>infile</u> \
                      -crop 0 0xFFFFFC \
                      -random‐fill 0 0xFFFFFC \
                      -checksum‐neg‐b‐e 0xFFFFFC 4 4 \
                  -o <u>outfile</u>

       In this example, we have an EPROM in the lowest megabyte of memory.  The -crop filter ensures we are only
       summing the data within the EPROM, and not anywhere else.  The -random‐fill filter fills any  holes  left
       in the data with random values.  Finally, the -checksum‐neg‐b‐e filter inserts a 32 bit (4 byte) checksum
       in big‐endian format in the last 4 bytes of the EPROM image.  Naturally, there is a little‐endian version
       of this filter as well.

       Your embedded code can check the EPROM using C code similar to the following:

              unsigned long *begin = (unsigned long *)0;
              unsigned long *end = (unsigned long *)0x100000;
              unsigned long sum = 0;
              while (begin &lt; end)
                  sum += *begin++;
              if (sum != 0)
              {
                  <u>Oops</u>
              }

       The  <b>-checksum‐bitnot‐big‐endian</b>  filter is similar, except that summing over the checksum should yield a
       value of all‐one‐bits (−1).  For example, using shorts rather than longs:

              srec_cat <u>infile</u> \
                      -crop 0 0xFFFFFE \
                      -fill 0xCC 0x00000 0xFFFFFE \
                      -checksum‐neg‐b‐e 0xFFFFFE 2 2 \
                  -o <u>outfile</u>

       Assuming you chose the correct endian‐ness filter, your embedded code can check the EPROM  using  C  code
       similar to the following:

              unsigned short *begin = (unsigned short *)0;
              unsigned short *end = (unsigned short *)0x100000;
              unsigned short sum = 0;
              while (begin &lt; end)
                  sum += *begin++;
              if (sum != 0xFFFF)
              {
                  <u>Oops</u>
              }

       There  is  also  a  <b>-checksum‐positive‐b‐e</b> filter, and a matching little‐endian filter, which inserts the
       simple sum, and which would be checked in C using an equality test.

              srec_cat <u>infile</u> \
                      -crop 0 0xFFFFFF \
                      -fill 0x00 0x00000 0xFFFFFF \
                      -checksum‐neg‐b‐e 0xFFFFFF 1 1 \
                  -o <u>outfile</u>

       Assuming you chose the correct endian‐ness filter, your embedded code can check the EPROM  using  C  code
       similar to the following:

              unsigned char *begin = (unsigned char *)0;
              unsigned char *end = (unsigned char *)0xFFFFF;
              unsigned char sum = 0;
              while (begin &lt; end)
                  sum += *begin++;
              if (sum != *end)
              {
                  <u>Oops</u>
              }

       In the 8‐bit case, it doesn't matter whether you use the big‐endian or little‐endian filter.

   <b>Quick</b> <b>Hex‐Dump</b>
       You  can  look  at  the checksum of your data, by using the “hex‐dump” output format.  This is useful for
       looking at calculated values, or for debugging an  <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1)  command  before  immortalizing  it  in  a
       script.

              srec_cat <u>infile</u>                        \
                      -crop 0 0x10000             \
                      -fill 0xFF 0x0000 0x10000   \
                      -checksum‐neg‐b‐e 0x10000 4 \
                      -crop 0x10000 0x10004       \
                  -o - -hex‐dump

       This  command  reads in the file, checksums the data and places the checksum at 0x10000, crops the result
       to contain only the checksum, and then prints  the  checksum  on  the  standard  output  in  a  classical
       hexadecimal dump format.  The special file name “-” means “the standard output” in this context.

   <b>Cyclic</b> <b>Redundancy</b> <b>Checks</b>
       The  simple  additive  checksums have a number of theoretical limitations, to do with errors they can and
       can't detect.  The CRC methods have fewer problems.

              srec_cat <u>infile</u>                        \
                      -crop 0 0xFFFFFC            \
                      -fill 0x00 0x00000 0xFFFFFC \
                      -crc32‐b‐e 0xFFFFFC         \
                  -o <u>outfile</u>

       In the above example, we have an EPROM in the lowest megabyte of memory.  The <b>-crop</b> filter ensures we are
       only summing the data within the EPROM, and not anywhere else.  The <b>-fill</b> filter fills any holes left  in
       the  data.  Finally, the <b>-checksum‐neg‐b‐e</b> filter inserts a 32 bit (4 byte) checksum in big‐endian format
       in the last 4 bytes of the EPROM image.  Naturally, there is a little‐endian version of  this  filter  as
       well.

       The  checksum  is calculated using the industry standard 32‐bit CRC.  Because SRecord is open source, you
       can always read the source code to see how it works.  There  are  many  non‐GPL  versions  of  this  code
       available on the Internet, and suitable for embedding in proprietary firmware.

       There is also a 16‐bit CRC available.

              srec_cat <u>infile</u>                        \
                      -crop 0 0xFFFFFE            \
                      -fill 0x00 0x00000 0xFFFFFE \
                      -crc16‐b‐e 0xFFFFFE         \
                  -o <u>outfile</u>

       The  checksum is calculated using the CCITT formula.  Because SRecord is open source, you can always read
       the source code to see how it works.  There are many non‐GPL  version  of  this  code  available  on  the
       Internet, and suitable for embedding in proprietary firmware.

       You can look at the CRC of your data, by using the “hex‐dump” output format.

              srec_cat <u>infile</u>                      \
                      -crop 0 0x10000           \
                      -fill 0xFF 0x0000 0x10000 \
                      -crc16‐b‐e 0x10000        \
                      -crop 0x10000 0x10002     \
                  -o - -hex‐dump

       This  command  reads in the file, calculates the CRC of the data and places the CRC at 0x10000, crops the
       result to contain only the CRC, and then prints the checksum  on  the  standard  output  in  a  classical
       hexadecimal dump format.

   <b>Where</b> <b>Is</b> <b>My</b> <b>Data?</b>
       There are several properties of your EPROM image that you may wish to insert into the data.

              srec_cat <u>infile</u> -minimum‐b‐e 0xFFFE 2 -o <u>outfile</u>

       The above example inserts the minimum address of the data (<u>low</u> <u>water</u>) into the data, as two bytes in big‐
       endian order at address 0xFFFE.  This includes the minimum itself.  If the data already contains bytes at
       the given address, you need to use an exclude filter.  The number of bytes defaults to 4.

       There  is  also  a  <b>-minimum‐l‐e</b>  filter  for inserting little‐endian values, and two more filters called
       <b>-exclusive‐minimum‐b‐e</b> and  <b>-exclusive‐minimum‐l‐e</b>  that  do  not  include  the  minimum  itself  in  the
       calculation of the minimum data address.

              srec_cat <u>infile</u> -maximum‐b‐e 0xFFFFFC 4 -o <u>outfile</u>

       The above example inserts the maximum address of the data (<u>high</u> <u>water</u> <u>+</u> <u>1</u>, just like address ranges) into
       the  data,  as four bytes in big‐endian order at address 0xFFFFFC.  This includes the maximum itself.  If
       the data already contains bytes at the given address, you need to use an <b>-exclude</b> filter.  The number  of
       bytes defaults to 4.

       There  is  also  a  <b>-maximum‐l‐e</b>  filter  for inserting little‐endian values, and two more filters called
       <b>-exclusive‐maximum‐b‐e</b> and  <b>-exclusive‐maximum‐l‐e</b>  that  do  not  include  the  maximum  itself  in  the
       calculation of the maximum data address.

              srec_cat <u>infile</u> -length‐b‐e 0xFFFFFC 4 -o <u>outfile</u>

       The  above  example  inserts  the  length of the data (<u>high</u> <u>water</u> + 1 − <u>low</u> <u>water</u>) into the data, as four
       bytes in big‐endian order at address 0xFFFFFC.  This includes the length itself.   If  the  data  already
       contains  bytes at the length location, you need to use an <b>-exclude</b> filter.  The number of bytes defaults
       to 4.

       There is also a <b>-length‐l‐e</b> filter for inserting a little‐endian length,  and  the  <b>-exclusive‐length‐b‐e</b>
       and <b>-exclusive‐length‐l‐e</b> filters that do not include the length itself in the calculation.

   <b>What</b> <b>Format</b> <b>Is</b> <b>This?</b>
       You  can obtain a variety of information about an EPROM load file by using the <u><a href="../man1/srec_info.1.html">srec_info</a></u>(1) command.  For
       example:

              $ <b>srec_info</b> <b>example.srec</b>
              Format: Motorola S‐Record
              Header: "<a href="http://srecord.sourceforge.net/">http://srecord.sourceforge.net/</a>"
              Execution Start Address: 00000000
              Data:   0000 - 0122
                      0456 - 0FFF
              $

       This example shows that the file is a Motorola S‐Record.  The text in the file header is  printed,  along
       with  the execution start address.  The final section shows the address ranges containing data (the upper
       bound of each subrange is <u>in</u>clusive, rather than the <u>ex</u>clusive form used on the command line.

              $ <b>srec_info</b> <b>some‐weird‐file.hex</b> <b>-guess</b>
              Format: Signetics
              Data:   0000 - 0122
                      0456 - 0FFF
              $

       The above example guesses the EPROM load file format.  It isn't infallible but it usually gets it  right.
       You  can  use  <b>-guess</b>  anywhere you would give an explicit format, but it tends to be slower and for that
       reason is not recommended.  Also, for automated build systems, you want hard errors as early as possible;
       if a file isn't in the expected format, you want it to barf.

</pre><h4><b>MANGLING</b> <b>THE</b> <b>DATA</b></h4><pre>
       It is possible to change the values of the data bytes in several ways.

              srec_cat <u>infile</u> -and 0xF0 -o <u>outfile</u>

       The above example performs a bit‐wise AND of the data bytes with the 0xF0 mask.  The addresses of records
       are unchanged.  I can't actually think of a use for this filter.

              srec_cat <u>infile</u> -or 0x0F -o <u>outfile</u>

       The above example performs a bit‐wise OR of the data bytes with the 0x0F bits.  The addresses of  records
       are unchanged.  I can't actually think of a use for this filter.

              srec_cat <u>infile</u> -xor 0xA5 -o <u>outfile</u>

       The  above  example performs a bit‐wise exclusive OR of the data bytes with the 0xA5 bits.  The addresses
       of records are unchanged.  You could use this to obfuscate the contents of your EPROM.

              srec_cat <u>infile</u> -not -o <u>outfile</u>

       The above example performs a bit‐wise NOT of the data bytes.  The addresses  of  records  are  unchanged.
       Security by obscurity?

</pre><h4><b>COPYRIGHT</b></h4><pre>
       <u>srec_cat</u> version 1.64
       Copyright  (C)  1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
       2013, 2014 Peter Miller

       The <u>srec_cat</u> program comes with ABSOLUTELY NO WARRANTY; for details use the '<u>srec_cat</u>  <u>-VERSion</u>  <u>License</u>'
       command.   This  is  free  software  and you are welcome to redistribute it under certain conditions; for
       details use the '<u>srec_cat</u> <u>-VERSion</u> <u>License</u>' command.

</pre><h4><b>MAINTAINER</b></h4><pre>
       Scott Finneran   E‐Mail:   <a href="mailto:scottfinneran@yahoo.com.au">scottfinneran@yahoo.com.au</a>
       Peter Miller     E‐Mail:   <a href="mailto:pmiller@opensource.org.au">pmiller@opensource.org.au</a>

Reference Manual                                     SRecord                                    <u><a href="../man1/srec_examples.1.html">srec_examples</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>