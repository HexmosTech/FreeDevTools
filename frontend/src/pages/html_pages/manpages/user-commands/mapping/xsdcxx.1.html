<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xsdcxx - W3C XML Schema to C++ Compiler</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/xsdcxx">xsdcxx_4.0.0-10_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       xsdcxx - W3C XML Schema to C++ Compiler

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>xsdcxx</b> <u>command</u> <b>[</b> <u>options</u> <b>]</b> <u>file</u> <b>[</b> <u>file</u> <b>...]</b>
       <b>xsdcxx</b> <b>help</b> <b>[</b> <u>command</u> <b>]</b>
       <b>xsdcxx</b> <b>version</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>xsdcxx</b>  generates  vocabulary-specific,  statically-typed  C++  mapping  from W3C XML Schema definitions.
       Particular mapping to produce is selected by a <u>command</u>.  Each mapping has a  number  of  mapping-specific
       <u>options</u> that should appear, if any, after the <u>command</u>.  Input files should be W3C XML Schema definitions.
       The exact set of the generated files depends on the selected mapping and options.

</pre><h4><b>COMMANDS</b></h4><pre>
       <b>cxx-tree</b>
              Generate  the  C++/Tree  mapping. For each input file in the form <b>name.xsd</b> the following C++ files
              are generated: <b>name.hxx</b> (header file), <b>name.ixx</b> (inline file, generated only  if  the  <b>--generate-</b>
              <b>inline</b>  option  is specified), <b>name.cxx</b> (source file), and <b>name-fwd.hxx</b> (forward declaration file,
              generated only if the <b>--generate-forward</b> option is specified).

       <b>cxx-parser</b>
              Generate the C++/Parser mapping. For each input file in the form <b>name.xsd</b> the following C++  files
              are  generated:  <b>name-pskel.hxx</b>  (parser  skeleton  header  file), <b>name-pskel.ixx</b> (parser skeleton
              inline file, generated only if the <b>--generate-inline</b>  option  is  specified),  and  <b>name-pskel.cxx</b>
              (parser  skeleton  source  file).  If  the <b>--generate-noop-impl</b> or <b>--generate-print-impl</b> option is
              specified, the following additional sample  implementation  files  are  generated:  <b>name-pimpl.hxx</b>
              (parser implementation header file) and <b>name-pimpl.cxx</b> (parser implementation source file). If the
              <b>--generate-test-driver</b>  option  is  specified,  the additional <b>name-driver.cxx</b> test driver file is
              generated.

       <b>help</b>   Print usage information and exit. Use

                 <b>xsdcxx</b> <b>help</b> <u>command</u>

              for command-specific help.

       <b>version</b>
              Print version and exit.

</pre><h4><b>OPTIONS</b></h4><pre>
       Command-specific <u>options</u>, if any, should appear after the corresponding <u>command</u>.

   <b>common</b> <b>options</b>
       <b>--std</b> <u>version</u>
              Specify the C++ standard that the generated  code  should  conform  to.  Valid  values  are  <b>c++98</b>
              (default) and <b>c++11</b>.

              The  C++  standard affects various aspects of the generated code that are discussed in more detail
              in various mapping-specific documentation.  Overall, when C++11 is selected,  the  generated  code
              relies on the move semantics and uses <b>std::unique_ptr</b> instead of deprecated <b>std::auto_ptr</b>.

              When  the  C++11  mode  is selected, you normally don't need to perform any extra steps other than
              enable C++11 in your C++ compiler, if required. The XSDCXX compiler  will  automatically  add  the
              necessary  macro  defines  to  the  generated header files that will switch the header-only XSDCXX
              runtime library (<b>libxsd</b>) to the C++11 mode. However, if you include  any  of  the  XSDCXX  runtime
              headers  directly  in your application (normally you just include the generated headers), then you
              will need to define the <b>XSD_CXX11</b> macro for your entire project.

       <b>--char-type</b> <u>type</u>
              Generate code using the provided character <u>type</u> instead of the default <b>char</b>. Valid values are <b>char</b>
              and <b>wchar_t</b>.

       <b>--char-encoding</b> <u>enc</u>
              Specify the character encoding that should be used in the generated code.  Valid  values  for  the
              <b>char</b>  character  type are <b>utf8</b> (default), <b>iso8859-1</b>, <b>lcp</b> (Xerces-C++ local code page), and <b>custom</b>.
              If you pass <b>custom</b> as the value then you will need to include the transcoder implementation header
              for your encoding at the beginning of the generated header files (see the <b>--hxx-prologue</b> option).

              For the <b>wchar_t</b> character type the only valid value is <b>auto</b>  and  the  encoding  is  automatically
              selected between UTF-16 and UTF-32/UCS-4, depending on the <b>wchar_t</b> type size.

       <b>--output-dir</b> <u>dir</u>
              Write generated files to <u>dir</u> instead of the current directory.

       <b>--generate-inline</b>
              Generate simple functions inline. This option triggers creation of the inline file.

       <b>--generate-xml-schema</b>
              Generate  a  C++ header file as if the schema being compiled defines the XML Schema namespace. For
              the C++/Tree mapping, the resulting file will contain definitions  for  all  XML  Schema  built-in
              types.  For the C++/Parser mapping, the resulting file will contain definitions for all the parser
              skeletons and implementations corresponding to the XML Schema built-in types.

              The schema file provided to the compiler need not exist and is only used to derive the name of the
              resulting header file. Use the <b>--extern-xml-schema</b> option to include this file  in  the  generated
              files for other schemas.

       <b>--extern-xml-schema</b> <u>file</u>
              Include  a  header  file  derived from <u>file</u> instead of generating the XML Schema namespace mapping
              inline. The provided file need not exist and is only used to  derive  the  name  of  the  included
              header file. Use the <b>--generate-xml-schema</b> option to generate this header file.

       <b>--namespace-map</b> <u>xns</u>=<u>cns</u>
              Map  XML Schema namespace <u>xns</u> to C++ namespace <u>cns</u>. Repeat this option to specify mapping for more
              than one XML Schema namespace. For example, the following option:

              <b>--namespace-map</b> <b><a href="http://example.com/foo/bar">http://example.com/foo/bar</a>=foo::bar</b>

              Will map the <b><a href="http://example.com/foo/bar">http://example.com/foo/bar</a></b> XML Schema namespace to the <b>foo::bar</b> C++ namespace.

       <b>--namespace-regex</b> <u>regex</u>
              Add <u>regex</u> to the list of regular expressions used to translate XML Schema namespace names  to  C++
              namespace  names.  <u>regex</u>  is a Perl-like regular expression in the form <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>. Any
              character can be used as a delimiter instead of <b>/</b>. Escaping of the delimiter character in  <u>pattern</u>
              or <u>replacement</u> is not supported.

              All  the regular expressions are pushed into a stack with the last specified expression considered
              first. The first match that succeeds is used.  Regular expressions are applied to a string in  the
              form

              <u>filename</u> <u>namespace</u>

              For example, if you have file <b>hello.xsd</b> with namespace <b><a href="http://example.com/hello">http://example.com/hello</a></b> and you run <b>xsd</b> on
              this file, then the string in question will be:

              <b>hello.xsd.</b> <b><a href="http://example.com/hello">http://example.com/hello</a></b>

              For the built-in XML Schema namespace the string is:

              <b>XMLSchema.xsd</b> <b><a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a></b>

              The following three steps are performed for each regular expression until the match is found:

              1. The expression is applied and if the result is empty the next expression is considered.

              2. All <b>/</b> are replaced with <b>::</b>.

              3.  The  result  is verified to be a valid C++ scope name (e.g., <b>foo::bar</b>). If this test succeeds,
              the result is used as a C++ namespace name.

              As  an  example,  the  following  expression   maps   XML    Schema   namespaces   in   the   form
              <b><a href="http://example.com/foo/bar">http://example.com/foo/bar</a></b> to C++ namespaces in the form <b>foo::bar</b>:

              <b>%.*</b> <b><a href="http://example.com/">http://example.com/</a>(.+)%$1%</b>

              See also the REGEX AND SHELL QUOTING section below.

       <b>--namespace-regex-trace</b>
              Trace the process of applying regular expressions specified with the <b>--namespace-regex</b> option. Use
              this option to find out why your regular expressions don't do what you expected them to do.

       <b>--reserved-name</b> <u>n</u>[=<u>r</u>]
              Add name <u>n</u> to the list of names that should not be used as identifiers. The name can optionally be
              followed  by  <b>=</b>  and  the replacement name <u>r</u> that should be used instead. All the C++ keywords are
              already in this list.

       <b>--include-with-brackets</b>
              Use angle brackets (&lt;&gt;) instead of quotes ("") in generated <b>#include</b> directives.

       <b>--include-prefix</b> <u>prefix</u>
              Add <u>prefix</u> to generated <b>#include</b> directive paths.

              For example, if you had the following import element in your schema

              <b>&lt;import</b> <b>namespace="..."</b> <b>schemaLocation="base.xsd"/&gt;</b>

              and compiled this fragment with <b>--include-prefix</b> <b>schemas/</b>,  then  the  include  directive  in  the
              generated code would be:

              <b>#include</b> <b>"schemas/base.hxx"</b>

       <b>--include-regex</b> <u>regex</u>
              Add  <u>regex</u> to the list of regular expressions used to transform <b>#include</b> directive paths. <u>regex</u> is
              a Perl-like regular expression in the form <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>.  Any character can be used as  a
              delimiter  instead  of  <b>/</b>.  Escaping  of  the delimiter character in <u>pattern</u> or <u>replacement</u> is not
              supported.

              All the regular expressions are pushed into a stack with the last specified expression  considered
              first. The first match that succeeds is used.

              As  an  example, the following expression transforms paths in the form <b>schemas/foo/bar</b> to paths in
              the form <b>generated/foo/bar</b>:

              <b>%schemas/(.+)%generated/$1%</b>

              See also the REGEX AND SHELL QUOTING section below.

       <b>--include-regex-trace</b>
              Trace the process of applying regular expressions specified with the <b>--include-regex</b>  option.  Use
              this option to find out why your regular expressions don't do what you expected them to do.

       <b>--guard-prefix</b> <u>prefix</u>
              Add  <u>prefix</u>  to  generated  header  inclusion  guards. The prefix is transformed to upper case and
              characters that are illegal in a preprocessor macro name are replaced with  underscores.  If  this
              option is not specified then the directory part of the input schema file is used as a prefix.

       <b>--hxx-suffix</b> <u>suffix</u>
              Use the provided <u>suffix</u> instead of the default <b>.hxx</b> to construct the name of the header file. Note
              that   this   suffix   is   also  used  to  construct  names  of  header  files  corresponding  to
              included/imported schemas.

       <b>--ixx-suffix</b> <u>suffix</u>
              Use the provided <u>suffix</u> instead of the default <b>.ixx</b> to construct the name of the inline file.

       <b>--cxx-suffix</b> <u>suffix</u>
              Use the provided <u>suffix</u> instead of the default <b>.cxx</b> to construct the name of the source file.

       <b>--fwd-suffix</b> <u>suffix</u>
              Use the provided <u>suffix</u> instead of the default <b>-fwd.hxx</b> to  construct  the  name  of  the  forward
              declaration file.

       <b>--hxx-regex</b> <u>regex</u>
              Use  the  provided  expression  to  construct  the  name of the header file.  <u>regex</u> is a Perl-like
              regular expression in the form <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>. Note that this expression is  also  used  to
              construct names of header files corresponding to included/imported schemas. See also the REGEX AND
              SHELL QUOTING section below.

       <b>--ixx-regex</b> <u>regex</u>
              Use  the  provided  expression  to  construct  the  name of the inline file.  <u>regex</u> is a Perl-like
              regular expression in the form <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>. See also the REGEX AND SHELL QUOTING section
              below.

       <b>--cxx-regex</b> <u>regex</u>
              Use the provided expression to construct the name of  the  source  file.   <u>regex</u>  is  a  Perl-like
              regular expression in the form <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>. See also the REGEX AND SHELL QUOTING section
              below.

       <b>--fwd-regex</b> <u>regex</u>
              Use  the  provided  expression  to  construct the name of the forward declaration file. <u>regex</u> is a
              Perl-like regular expression in the form <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>.  See  also  the  REGEX  AND  SHELL
              QUOTING section below.

       <b>--hxx-prologue</b> <u>text</u>
              Insert <u>text</u> at the beginning of the header file.

       <b>--ixx-prologue</b> <u>text</u>
              Insert <u>text</u> at the beginning of the inline file.

       <b>--cxx-prologue</b> <u>text</u>
              Insert <u>text</u> at the beginning of the source file.

       <b>--fwd-prologue</b> <u>text</u>
              Insert <u>text</u> at the beginning of the forward declaration file.

       <b>--prologue</b> <u>text</u>
              Insert <u>text</u> at the beginning of each generated file for which there is no file-specific prologue.

       <b>--hxx-epilogue</b> <u>text</u>
              Insert <u>text</u> at the end of the header file.

       <b>--ixx-epilogue</b> <u>text</u>
              Insert <u>text</u> at the end of the inline file.

       <b>--cxx-epilogue</b> <u>text</u>
              Insert <u>text</u> at the end of the source file.

       <b>--fwd-epilogue</b> <u>text</u>
              Insert <u>text</u> at the end of the forward declaration file.

       <b>--epilogue</b> <u>text</u>
              Insert <u>text</u> at the end of each generated file for which there is no file-specific epilogue.

       <b>--hxx-prologue-file</b> <u>file</u>
              Insert the content of the <u>file</u> at the beginning of the header file.

       <b>--ixx-prologue-file</b> <u>file</u>
              Insert the content of the <u>file</u> at the beginning of the inline file.

       <b>--cxx-prologue-file</b> <u>file</u>
              Insert the content of the <u>file</u> at the beginning of the source file.

       <b>--fwd-prologue-file</b> <u>file</u>
              Insert the content of the <u>file</u> at the beginning of the forward declaration file.

       <b>--prologue-file</b> <u>file</u>
              Insert the content of the <u>file</u> at the beginning of each generated file for which there is no file-
              specific prologue file.

       <b>--hxx-epilogue-file</b> <u>file</u>
              Insert the content of the <u>file</u> at the end of the header file.

       <b>--ixx-epilogue-file</b> <u>file</u>
              Insert the content of the <u>file</u> at the end of the inline file.

       <b>--cxx-epilogue-file</b> <u>file</u>
              Insert the content of the <u>file</u> at the end of the source file.

       <b>--fwd-epilogue-file</b> <u>file</u>
              Insert the content of the <u>file</u> at the end of the forward declaration file.

       <b>--epilogue-file</b> <u>file</u>
              Insert  the  content  of  the  <u>file</u>  at the end of each generated file for which there is no file-
              specific epilogue file.

       <b>--export-symbol</b> <u>symbol</u>
              Insert     <u>symbol</u>     in     places     where     DLL     export/import     control     statements
              (<b>__declspec(dllexport/dllimport)</b>) are necessary.

       <b>--export-xml-schema</b>
              Export/import  types  in  the  XML  Schema  namespace  using  the  export symbol provided with the
              <b>--export-symbol</b> option. The <b>XSD_NO_EXPORT</b>  macro  can  be  used  to  omit  this  code  during  C++
              compilation,  which may be useful if you would like to use the same generated code across multiple
              platforms.

       <b>--export-maps</b>
              Export polymorphism support maps from a Win32 DLL into which this generated code is  placed.  This
              is  necessary  when your type hierarchy is split across several DLLs since otherwise each DLL will
              have its own set of maps. In this situation the generated code for the  DLL  which  contains  base
              types  and/or  substitution group heads should be compiled with this option and the generated code
              for all other DLLs should be compiled with <b>--import-maps</b>. This option is only valid together  with
              <b>--generate-polymorphic</b>.  The  <b>XSD_NO_EXPORT</b>  macro  can  be  used  to  omit  this  code during C++
              compilation, which may be useful if you would like to use the same generated code across  multiple
              platforms.

       <b>--import-maps</b>
              Import  polymorphism  support  maps to a Win32 DLL or executable into which this generated code is
              linked. See the <b>--export-maps</b> option  documentation  for  details.  This  options  is  only  valid
              together with <b>--generate-polymorphic</b>. The <b>XSD_NO_EXPORT</b> macro can be used to omit this code during
              C++  compilation,  which  may  be  useful  if you would like to use the same generated code across
              multiple platforms.

       <b>--generate-dep</b>
              Generate <b>make</b> dependency information. This option triggers the creation of the <b>.d</b> file  containing
              the  dependencies  of  the generated files on the main schema file as well as all the schema files
              that it includes/imports, transitively. This dependency file is then normally  included  into  the
              main <b>makefile</b> to implement automatic dependency tracking.

              Note also that automatic dependency generation is not supported in the file-per-type mode (<b>--file-</b>
              <b>per-type</b>).  In  this  case, all the generated files are produced with a single compiler invocation
              and depend on all the schemas. As a result, it is easier to establish such a dependency  manually,
              perhaps with the help of the <b>--file-list*</b> options.

       <b>--generate-dep-only</b>
              Generate <b>make</b> dependency information only.

       <b>--dep-phony</b>
              Generate phony targets for included/imported schema files, causing each to depend on nothing. Such
              dummy  rules  work  around <b>make</b> errors caused by the removal of schema files without also updating
              the dependency file to match.

       <b>--dep-target</b> <u>target</u>
              Change the target of the dependency rule. By default it contains all the generated  C++  files  as
              well  as  the  dependency  file  itself,  without  any directory prefixes. If you require multiple
              targets, then you can specify them as a single, space-separated argument or you  can  repeat  this
              option multiple times.

       <b>--dep-suffix</b> <u>suffix</u>
              Use the provided <u>suffix</u> instead of the default <b>.d</b> to construct the name of the dependency file.

       <b>--dep-regex</b> <u>regex</u>
              Use  the  provided  expression to construct the name of the dependency file.  <u>regex</u> is a Perl-like
              regular expression in the form <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>. See also the REGEX AND SHELL QUOTING section
              below.

       <b>--disable-warning</b> <u>warn</u>
              Disable printing warning with id <u>warn</u>. If <b>all</b> is specified for the warning id  then  all  warnings
              are disabled.

       <b>--options-file</b> <u>file</u>
              Read  additional  options  from  <u>file</u>.  Each option should appearing on a separate line optionally
              followed by space and an option value. Empty lines and lines starting with <b>#</b> are  ignored.  Option
              values  can  be  enclosed  in  double  (<b>"</b>)  or single (<b>'</b>) quotes  to preserve leading and trailing
              whitespaces as well as to specify empty values. If the value itself contains trailing  or  leading
              quotes,  enclose  it with an extra pair of quotes, for example <b>'"x"'</b>. Non-leading and non-trailing
              quotes are interpreted as being part of the option value.

              The semantics of providing options in a file is equivalent to providing the same set of options in
              the same order on the command line at the point  where  the  <b>--options-file</b>  option  is  specified
              except  that the shell escaping and quoting is not required. You can repeat this option to specify
              more than one options file.

       <b>--show-sloc</b>
              Show the number of generated physical source lines of code (SLOC).

       <b>--sloc-limit</b> <u>num</u>
              Check that the number of generated physical source lines of code (SLOC) does not exceed <u>num</u>.

       <b>--proprietary-license</b>
              Indicate that the generated code is licensed under a proprietary license instead of the GPL.

       <b>--custom-literals</b> <u>file</u>
              Load custom XML string to C++ literal mappings from <u>file</u>. This mechanism can be useful if you  are
              using  a  custom  character  encoding  and  some  of  the  strings  in  your  schemas, for example
              element/attribute names or enumeration values, contain non-ASCII characters. In this case you will
              need to provide a custom mapping to C++ literals for such strings. The  format  of  this  file  is
              specified  in  the  <b>custom-literals.xsd</b>  XML  Schema  file  that can be found in the documentation
              directory.

       <b>--preserve-anonymous</b>
              Preserve anonymous types. By default anonymous types are automatically named  with  names  derived
              from  the enclosing elements/attributes. Because mappings implemented by this compiler require all
              types to be named, this option is only useful if you want to make sure  your  schemas  don't  have
              anonymous types.

       <b>--show-anonymous</b>
              Show  elements  and  attributes that are of anonymous types. This option only makes sense together
              with the <b>--preserve-anonymous</b> option.

       <b>--anonymous-regex</b> <u>regex</u>
              Add <u>regex</u> to the list of regular expressions used to derive names for  anonymous  types  from  the
              enclosing   attributes/elements.   <u>regex</u>   is   a   Perl-like   regular  expression  in  the  form
              <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>. Any character can be used as a delimiter instead  of  <b>/</b>.  Escaping  of  the
              delimiter character in <u>pattern</u> or <u>replacement</u> is not supported.

              All  the regular expressions are pushed into a stack with the last specified expression considered
              first. The first match that succeeds is used.  Regular expressions are applied to a string in  the
              form

              <u>filename</u> <u>namespace</u> <u>xpath</u>

              For instance:

              <b>hello.xsd</b> <b><a href="http://example.com/hello">http://example.com/hello</a></b> <b>element</b>

              <b>hello.xsd</b> <b><a href="http://example.com/hello">http://example.com/hello</a></b> <b>type/element</b>

              As  an  example,  the following expression makes all the derived names start with capital letters.
              This could be useful when your naming  convention  requires  type  names  to  start  with  capital
              letters:

              <b>%.*</b> <b>.*</b> <b>(.+/)*(.+)%\u$2%</b>

              See also the REGEX AND SHELL QUOTING section below.

       <b>--anonymous-regex-trace</b>
              Trace the process of applying regular expressions specified with the <b>--anonymous-regex</b> option. Use
              this option to find out why your regular expressions don't do what you expected them to do.

       <b>--location-map</b> <u>ol</u>=<u>nl</u>
              Map the original schema location <u>ol</u> that is specified in the XML Schema include or import elements
              to  new  schema location <u>nl</u>. Repeat this option to map more than one schema location. For example,
              the following option maps the <b><a href="http://example.com/foo.xsd">http://example.com/foo.xsd</a></b> URL to the <b>foo.xsd</b> local file.

              <b>--location-map</b> <b><a href="http://example.com/foo.xsd">http://example.com/foo.xsd</a>=foo.xsd</b>

       <b>--location-regex</b> <u>regex</u>
              Add <u>regex</u> to the list of regular expressions used to map schema locations that  are  specified  in
              the  XML  Schema  include or import elements.  <u>regex</u> is a Perl-like regular expression in the form
              <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>. Any character can be used as a delimiter instead  of  <b>/</b>.  Escaping  of  the
              delimiter  character  in  <u>pattern</u> or <u>replacement</u> is not supported. All the regular expressions are
              pushed into a stack with the last specified expression considered  first.  The  first  match  that
              succeeds is used.

              For    example,    the    following    expression    maps    URL    locations    in    the    form
              <b><a href="http://example.com/foo/bar.xsd">http://example.com/foo/bar.xsd</a></b> to local files in the form <b>bar.xsd</b>:

              <b>%http:/<a href="file:/.">/.</a>+/(.+)%$1%</b>

              See also the REGEX AND SHELL QUOTING section below.

       <b>--location-regex-trace</b>
              Trace the process of applying regular expressions specified with the <b>--location-regex</b> option.  Use
              this option to find out why your regular expressions don't do what you expected them to do.

       <b>--file-per-type</b>
              Generate  a separate set of C++ files for each type defined in XML Schema.  Note that in this mode
              you only need to compile the root schema(s) and the code will be generated for  all  included  and
              imported  schemas.  This  compilation mode is primarily useful when some of your schemas cannot be
              compiled separately or have cyclic dependencies which  involve  type  inheritance.  Other  options
              related  to  this  mode  are: <b>--type-file-regex</b>, <b>--schema-file-regex</b>, <b>--fat-type-file</b>, and <b>--file-</b>
              <b>list</b>.

       <b>--type-file-regex</b> <u>regex</u>
              Add <u>regex</u> to the list of regular expressions used to translate type names to file names  when  the
              <b>--file-per-type</b>  option  is  specified.   <u>regex</u>  is  a  Perl-like  regular  expression in the form
              <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>. Any character can be used as a delimiter instead  of  <b>/</b>.  Escaping  of  the
              delimiter  character  in  <u>pattern</u> or <u>replacement</u> is not supported. All the regular expressions are
              pushed into a stack with the last specified expression considered  first.  The  first  match  that
              succeeds is used. Regular expressions are applied to a string in the form

              <u>namespace</u> <u>type-name</u>

              For  example, the following expression maps type <b>foo</b> that is defined in the <b><a href="http://example.com/bar">http://example.com/bar</a></b>
              namespace to file name <b>bar-foo</b>:

              <b>%<a href="http://example.com/">http://example.com/</a>(.+)</b> <b>(.+)%$1-$2%</b>

              See also the REGEX AND SHELL QUOTING section below.

       <b>--type-file-regex-trace</b>
              Trace the process of applying regular expressions specified with the <b>--type-file-regex</b> option. Use
              this option to find out why your regular expressions don't do what you expected them to do.

       <b>--schema-file-regex</b> <u>regex</u>
              Add <u>regex</u> to the list of regular expressions used to translate schema file names when the  <b>--file-</b>
              <b>per-type</b>   option   is   specified.   <u>regex</u>   is  a  Perl-like  regular  expression  in  the  form
              <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>. Any character can be used as a delimiter instead  of  <b>/</b>.  Escaping  of  the
              delimiter  character  in  <u>pattern</u> or <u>replacement</u> is not supported. All the regular expressions are
              pushed into a stack with the last specified expression considered  first.  The  first  match  that
              succeeds is used. Regular Expressions are applied to the absolute filesystem path of a schema file
              and  the  result,  including  the directory part, if any, is used to derive the <b>#include</b> directive
              paths as well as the generated C++ file paths.  This  option,  along  with  <b>--type-file-regex</b>  are
              primarily  useful  to  place  the  generated  files  into  subdirectories  or to resolve file name
              conflicts.

              For example, the following expression maps schema files in  the  <b>foo/1.0.0/</b>  subdirectory  to  the
              files in the <b>foo/</b> subdirectory. As a result, the <b>#include</b> directive paths for such schemas will be
              in the <b>foo/schema.hxx</b> form and the generated C++ files will be placed into the <b>foo/</b> subdirectory:

              <b>%.*/foo/1.0.0/(.+)%foo/$1%</b>

              See also the REGEX AND SHELL QUOTING section below.

       <b>--schema-file-regex-trace</b>
              Trace  the  process of applying regular expressions specified with the <b>--schema-file-regex</b> option.
              Use this option to find out why your regular expressions don't do what you expected them to do.

       <b>--fat-type-file</b>
              Generate code corresponding to global elements into type files instead of schema  files  when  the
              <b>--type-file-regex</b> option is specified. This option is primarily useful when trying to minimize the
              amount  of object code that is linked to an executable by packaging compiled generated code into a
              static (archive) library.

       <b>--file-list</b> <u>file</u>
              Write a list of generated C++ files to <u>file</u>. This option is primarily useful in the  file-per-type
              compilation  mode  (<b>--file-per-type</b>)  to  create  a list of generated C++ files, for example, as a
              makefile fragment.

       <b>--file-list-prologue</b> <u>text</u>
              Insert <u>text</u> at the beginning of the file list.  As  a  convenience,  all  occurrences  of  the  <b>\n</b>
              character  sequence  in <u>text</u> are replaced with new lines. This option can, for example, be used to
              assign the generated file list to a makefile variable.

       <b>--file-list-epilogue</b> <u>text</u>
              Insert <u>text</u> at the end of the file list. As a convenience, all occurrences  of  the  <b>\n</b>  character
              sequence in <u>text</u> are replaced with new lines.

       <b>--file-list-delim</b> <u>text</u>
              Delimit  file names written to the file list with <u>text</u> instead of new lines. As a convenience, all
              occurrences of the <b>\n</b> character sequence in <u>text</u> are replaced with new lines.

   <b>cxx-tree</b> <b>command</b> <b>options</b>
       <b>--generate-polymorphic</b>
              Generate polymorphism-aware code. Specify this option if you use substitution groups or  <b>xsi:type</b>.
              Use  the <b>--polymorphic-type</b> or <b>--polymorphic-type-all</b> option to specify which type hierarchies are
              polymorphic.

       <b>--polymorphic-type</b> <u>type</u>
              Indicate that <u>type</u> is a root of a polymorphic type hierarchy. The compiler can often automatically
              determine which types are polymorphic based on the substitution group declarations.  However,  you
              may need to use this option if you are not using substitution groups or if substitution groups are
              defined  in  another schema. You need to specify this option when compiling every schema file that
              references <u>type</u>. The <u>type</u> argument is an XML Schema type name that  can  be  optionally  qualified
              with a namespace in the <u>namespace</u><b>#</b><u>name</u> form.

       <b>--polymorphic-type-all</b>
              Indicate that all types should be treated as polymorphic.

       <b>--polymorphic-plate</b> <u>num</u>
              Specify  the  polymorphic  map plate the generated code should register on.  This functionality is
              primarily useful to segregate multiple schemas that define the same polymorphic types.

       <b>--ordered-type</b> <u>type</u>
              Indicate that element order in <u>type</u> is significant. An  example  would  be  a  complex  type  with
              unbounded  choice  as  a  content  model  where  the element order in XML has application-specific
              semantics. For ordered types the  compiler  generates  a  special  container  data  member  and  a
              corresponding  set  of accessors and modifiers that are used to capture the order of elements and,
              for mixed content, of text.

              The <u>type</u> argument is an XML Schema type name that can be optionally qualified with a namespace  in
              the <u>namespace</u><b>#</b><u>name</u> form.  Note also that you will need to specify this option when compiling every
              schema file that has other ordered types derived from this type.

       <b>--ordered-type-derived</b>
              Automatically  treat types derived from ordered bases as also ordered. This is primarily useful if
              you would like to be able to iterate over the complete content using the content order container.

       <b>--ordered-type-mixed</b>
              Automatically treat complex types with mixed content as ordered.

       <b>--ordered-type-all</b>
              Indicate that element order in all types is significant.

       <b>--order-container</b> <u>type</u>
              Specify a custom class template that should be used as  a  container  for  the  content  order  in
              ordered  types  instead  of  the  default <b>std::vector</b>.  See <b>--ordered-type</b> for more information on
              ordered type. This option is primarily useful if you need to perform more complex lookups  in  the
              content  order  container,  for example by element id. In this case, a container like Boost multi-
              index may be more convenient. Note that if using a custom container, you  will  also  most  likely
              need to include the relevant headers using the <b>--hxx-prologue*</b> options.

       <b>--generate-serialization</b>
              Generate serialization functions. Serialization functions convert the object model back to XML.

       <b>--generate-ostream</b>
              Generate  ostream  insertion operators (<b>operator&lt;&lt;</b>) for generated types. This allows one to easily
              print a fragment or the whole object model for debugging or logging.

       <b>--generate-doxygen</b>
              Generate documentation comments suitable for  extraction  by  the  Doxygen  documentation  system.
              Documentation from annotations is added to the comments if present in the schema.

       <b>--generate-comparison</b>
              Generate  comparison  operators  (<b>operator==</b>  and  <b>operator!=</b>)  for  complex  types. Comparison is
              performed member-wise.

       <b>--generate-default-ctor</b>
              Generate default constructors even for types that have required members.  Required members  of  an
              instance  constructed  using  such a constructor are not initialized and accessing them results in
              undefined behavior.

       <b>--generate-from-base-ctor</b>
              Generate constructors that expect an instance of a base type followed by all required members.

       <b>--suppress-assignment</b>
              Suppress the generation of copy  assignment  operators  for  complex  types.  If  this  option  is
              specified,   the  copy  assignment  operators  for  such  types  are  declared  private  and  left
              unimplemented.

       <b>--generate-detach</b>
              Generate detach functions for required elements and attributes. Detach functions for optional  and
              sequence  cardinalities  are  provided by the respective containers. These functions, for example,
              allow you to move sub-trees in the object model either within the same tree or  between  different
              trees.

       <b>--generate-wildcard</b>
              Generate  accessors  and  modifiers  as  well  as  parsing  and  serialization code for XML Schema
              wildcards (<b>any</b> and <b>anyAttribute</b>). XML content matched by wildcards is presented as DOM  fragments.
              Note that you need to initialize the Xerces-C++ runtime if you are using this option.

       <b>--generate-any-type</b>
              Extract  and store content of the XML Schema <b>anyType</b> type as a DOM fragment. Note that you need to
              initialize the Xerces-C++ runtime if you are using this option.

       <b>--generate-insertion</b> <u>os</u>
              Generate data representation stream insertion operators for the <u>os</u> output stream type. Repeat this
              option to specify more than one stream type. The ACE CDR stream (<b>ACE_OutputCDR</b>) and  RPC  XDR  are
              recognized  by the compiler and the necessary <b>#include</b> directives are automatically generated. For
              custom stream types use the <b>--hxx-prologue*</b> options to provide the necessary declarations.

       <b>--generate-extraction</b> <u>is</u>
              Generate data representation stream extraction constructors for the <u>is</u> input stream  type.  Repeat
              this  option  to  specify more than one stream type. The ACE CDR stream (<b>ACE_InputCDR</b>) and RPC XDR
              are recognized by the compiler and the necessary <b>#include</b> directives are automatically  generated.
              For custom stream types use the <b>--hxx-prologue*</b> options to provide the necessary declarations.

       <b>--generate-forward</b>
              Generate a separate header file with forward declarations for the types being generated.

       <b>--suppress-parsing</b>
              Suppress  the  generation of the parsing functions and constructors. Use this option to reduce the
              generated code size when parsing from XML is not needed.

       <b>--generate-element-type</b>
              Generate types instead of parsing and serialization functions for root elements. This is primarily
              useful to distinguish object models with the same root type but with different root elements.

       <b>--generate-element-map</b>
              Generate a root element map that  allows  uniform  parsing  and  serialization  of  multiple  root
              elements. This option is only valid together with <b>--generate-element-type</b>.

       <b>--generate-intellisense</b>
              Generate workarounds for IntelliSense bugs in Visual Studio 2005 (8.0).  When this option is used,
              the  resulting  code is slightly more verbose.  IntelliSense in Visual Studio 2008 (9.0) and later
              does not require these workarounds. Support for  IntelliSense  in  Visual  Studio  2003  (7.1)  is
              improved with this option but is still incomplete.

       <b>--omit-default-attributes</b>
              Omit attributes with default and fixed values from serialized XML documents.

       <b>--type-naming</b> <u>style</u>
              Specify the type naming convention that should be used in the generated code. Valid styles are <b>knr</b>
              (default), <b>ucc</b>, and <b>java</b>. See the NAMING CONVENTION section below for more information.

       <b>--function-naming</b> <u>style</u>
              Specify the function naming convention that should be used in the generated code. Valid styles are
              <b>knr</b> (default), <b>lcc</b>, and <b>java</b>. See the NAMING CONVENTION section below for more information.

       <b>--type-regex</b> <u>regex</u>
              Add  <u>regex</u>  to the list of regular expressions used to translate XML Schema type names to C++ type
              names. See the NAMING CONVENTION section below for more information.

       <b>--accessor-regex</b> <u>regex</u>
              Add  <u>regex</u>  to  the  list  of  regular  expressions  used  to  translate  XML  Schema   names   of
              elements/attributes  to  C++  accessor function names. See the NAMING CONVENTION section below for
              more information.

       <b>--one-accessor-regex</b> <u>regex</u>
              Add  <u>regex</u>  to  the  list  of  regular  expressions  used  to  translate  XML  Schema   names   of
              elements/attributes with cardinality one to C++ accessor function names. See the NAMING CONVENTION
              section below for more information.

       <b>--opt-accessor-regex</b> <u>regex</u>
              Add   <u>regex</u>   to  the  list  of  regular  expressions  used  to  translate  XML  Schema  names  of
              elements/attributes with cardinality optional to C++  accessor  function  names.  See  the  NAMING
              CONVENTION section below for more information.

       <b>--seq-accessor-regex</b> <u>regex</u>
              Add   <u>regex</u>   to  the  list  of  regular  expressions  used  to  translate  XML  Schema  names  of
              elements/attributes with cardinality sequence to C++  accessor  function  names.  See  the  NAMING
              CONVENTION section below for more information.

       <b>--modifier-regex</b> <u>regex</u>
              Add   <u>regex</u>   to  the  list  of  regular  expressions  used  to  translate  XML  Schema  names  of
              elements/attributes to C++ modifier function names. See the NAMING CONVENTION  section  below  for
              more information.

       <b>--one-modifier-regex</b> <u>regex</u>
              Add   <u>regex</u>   to  the  list  of  regular  expressions  used  to  translate  XML  Schema  names  of
              elements/attributes with cardinality one to C++ modifier function names. See the NAMING CONVENTION
              section below for more information.

       <b>--opt-modifier-regex</b> <u>regex</u>
              Add  <u>regex</u>  to  the  list  of  regular  expressions  used  to  translate  XML  Schema   names   of
              elements/attributes  with  cardinality  optional  to  C++  modifier function names. See the NAMING
              CONVENTION section below for more information.

       <b>--seq-modifier-regex</b> <u>regex</u>
              Add  <u>regex</u>  to  the  list  of  regular  expressions  used  to  translate  XML  Schema   names   of
              elements/attributes  with  cardinality  sequence  to  C++  modifier function names. See the NAMING
              CONVENTION section below for more information.

       <b>--parser-regex</b> <u>regex</u>
              Add <u>regex</u> to the list of regular expressions used to translate XML Schema  element  names  to  C++
              parsing function names. See the NAMING CONVENTION section below for more information.

       <b>--serializer-regex</b> <u>regex</u>
              Add  <u>regex</u>  to  the  list of regular expressions used to translate XML Schema element names to C++
              serialization function names. See the NAMING CONVENTION section below for more information.

       <b>--const-regex</b> <u>regex</u>
              Add <u>regex</u> to the list of regular expressions used to translate XML  Schema-derived  names  to  C++
              constant names. See the NAMING CONVENTION section below for more information.

       <b>--enumerator-regex</b> <u>regex</u>
              Add  <u>regex</u>  to  the list of regular expressions used to translate XML Schema enumeration values to
              C++ enumerator names. See the NAMING CONVENTION section below for more information.

       <b>--element-type-regex</b> <u>regex</u>
              Add <u>regex</u> to the list of regular expressions used to translate XML Schema  element  names  to  C++
              element type names. See the NAMING CONVENTION section below for more information.

       <b>--name-regex-trace</b>
              Trace  the process of applying regular expressions specified with the name transformation options.
              Use this option to find out why your regular expressions don't do what you expected them to do.

       <b>--root-element-first</b>
              Treat only the first global element as a  document  root.  By  default  all  global  elements  are
              considered document roots.

       <b>--root-element-last</b>
              Treat  only  the  last  global  element  as  a  document  root. By default all global elements are
              considered document roots.

       <b>--root-element-all</b>
              Treat all global elements as  document  roots.  This  is  the  default  behavior.   By  explicitly
              specifying this option you can suppress the warning that is issued if more than one global element
              is defined.

       <b>--root-element-none</b>
              Do  not treat any global elements as document roots. By default all global elements are considered
              document roots.

       <b>--root-element</b> <u>element</u>
              Treat only <u>element</u> as a document root. Repeat this option to specify more than one root element.

       <b>--custom-type</b> <u>map</u>
              Use a custom C++  type  instead  of  the  generated  class.  The  <u>map</u>  argument  is  in  the  form
              <u>name</u>[<b>=</b><u>type</u>[<b>/</b><u>base</u>]], where <u>name</u> is a type name as defined in XML Schema and <u>type</u> is a C++ type name
              that  should  be  used instead. If <u>type</u> is not present or empty then the custom type is assumed to
              have the same name and be defined in the same namespace as the generated class would have. If <u>base</u>
              is specified then the generated class is still generated but with that name.

       <b>--custom-type-regex</b> <u>regex</u>
              Use custom C++ types instead of the generated classes. The <u>regex</u> argument is in  the  form  <b>/</b><u>name-</u>
              <u>pat</u><b>/</b>[<u>type-sub</u><b>/</b>[<u>base-sub</u><b>/</b>]],  where  <u>name-pat</u>  is a regex pattern that will be matched against type
              names as defined in XML Schema and <u>type-sub</u> is a C++ type name substitution that  should  be  used
              instead. If <u>type-sub</u> is not present or its substitution results in an empty string then the custom
              type  is assumed to have the same name and be defined in the same namespace as the generated class
              would have. If <u>base-sub</u> is present and its substitution results in a  non-empty  string  then  the
              generated  class  is  still  generated  but  with the result of this substitution as its name. The
              pattern and substitutions are in the Perl regular expression format. See also the REGEX AND  SHELL
              QUOTING section below.

       <b>--parts</b> <u>num</u>
              Split  generated  source  code  into  <u>num</u> parts. This is useful when translating large, monolithic
              schemas and a C++ compiler is not able to compile the resulting source code at once  (usually  due
              to insufficient memory).

       <b>--parts-suffix</b> <u>suffix</u>
              Use <u>suffix</u> instead of the default '<b>-</b>' to separate the file name from the part number.

   <b>cxx-parser</b> <b>command</b> <b>options</b>
       <b>--type-map</b> <u>mapfile</u>
              Read  XML  Schema  to  C++  type  mapping  information from <u>mapfile</u>. Repeat this option to specify
              several type maps. Type maps are considered in order of appearance and the first match is used. By
              default all user-defined types are mapped to <b>void</b>.  See  the  TYPE  MAP  section  below  for  more
              information.

       <b>--xml-parser</b> <u>parser</u>
              Use  <u>parser</u>  as  the  underlying  XML parser. Valid values are <b>xerces</b> for Xerces-C++ (default) and
              <b>expat</b> for Expat.

       <b>--generate-validation</b>
              Generate validation code. The validation code ("perfect parser") ensures that  instance  documents
              conform  to  the  schema. Validation code is generated by default when the selected underlying XML
              parser is non-validating (<b>expat</b>).

       <b>--suppress-validation</b>
              Suppress the generation of validation code. Validation is suppressed by default when the  selected
              underlying XML parser is validating (<b>xerces</b>).

       <b>--generate-polymorphic</b>
              Generate polymorphism-aware code. Specify this option if you use substitution groups or <b>xsi:type</b>.

       <b>--generate-noop-impl</b>
              Generate   a   sample  parser  implementation  that  does  nothing  (no  operation).   The  sample
              implementation can then be filled with the application-specific code. For an  input  file  in  the
              form  <b>name.xsd</b>  this option triggers the generation of two additional C++ files in the form: <b>name-</b>
              <b>pimpl.hxx</b> (parser implementation header file) and  <b>name-pimpl.cxx</b>  (parser  implementation  source
              file).

       <b>--generate-print-impl</b>
              Generate  a sample parser implementation that prints the XML data to STDOUT.  For an input file in
              the form <b>name.xsd</b> this option triggers the generation of two additional C++  files  in  the  form:
              <b>name-pimpl.hxx</b>  (parser  implementation  header  file)  and  <b>name-pimpl.cxx</b> (parser implementation
              source file).

       <b>--generate-test-driver</b>
              Generate a test driver for the sample parser  implementation.  For  an  input  file  in  the  form
              <b>name.xsd</b>  this  option  triggers  the  generation  of  an  additional  C++  file in the form <b>name-</b>
              <b>driver.cxx</b>.

       <b>--force-overwrite</b>
              Force overwriting of the existing implementation and test driver files. Use this  option  only  if
              you  do  not  mind  loosing  the changes you have made in the sample implementation or test driver
              files.

       <b>--root-element-first</b>
              Indicate that the first global element is the document root. This information is used to  generate
              the test driver for the sample implementation.

       <b>--root-element-last</b>
              Indicate  that  the last global element is the document root. This information is used to generate
              the test driver for the sample implementation.

       <b>--root-element</b> <u>element</u>
              Indicate that <u>element</u> is the document root. This information is used to generate the  test  driver
              for the sample implementation.

       <b>--skel-type-suffix</b> <u>suffix</u>
              Use  the  provided  <u>suffix</u>  instead  of the default <b>_pskel</b> to construct the names of the generated
              parser skeletons.

       <b>--skel-file-suffix</b> <u>suffix</u>
              Use the provided <u>suffix</u> instead of the default <b>-pskel</b> to construct  the  names  of  the  generated
              parser skeleton files.

       <b>--impl-type-suffix</b> <u>suffix</u>
              Use  the  provided  <u>suffix</u>  instead  of  the  default  <b>_pimpl</b> to construct the names of the parser
              implementations for the built-in XML Schema types as well as sample parser implementations.

       <b>--impl-file-suffix</b> <u>suffix</u>
              Use the provided <u>suffix</u> instead of the default <b>-pimpl</b> to construct  the  names  of  the  generated
              sample parser implementation files.

</pre><h4><b>NAMING</b> <b>CONVENTION</b></h4><pre>
       The  compiler  can be instructed to use a particular naming convention in the generated code. A number of
       widely-used conventions can be selected using the <b>--type-naming</b> and <b>--function-naming</b> options.  A  custom
       naming  convention can be achieved using the <b>--type-regex</b>, <b>--accessor-regex</b>, <b>--one-accessor-regex</b>, <b>--opt-</b>
       <b>accessor-regex</b>,  <b>--seq-accessor-regex</b>,  <b>--modifier-regex</b>,   <b>--one-modifier-regex</b>,   <b>--opt-modifier-regex</b>,
       <b>--seq-modifier-regex</b>,   <b>--parser-regex</b>,   <b>--serializer-regex</b>,   <b>--const-regex</b>,   <b>--enumerator-regex</b>,  and
       <b>--element-type-regex</b> options.

       The <b>--type-naming</b> option specifies the convention that should be used for  naming  C++  types.   Possible
       values  for  this  option are <b>knr</b> (default), <b>ucc</b>, and <b>java</b>.  The <b>knr</b> value (stands for K&amp;R) signifies the
       standard, lower-case naming convention with the underscore used as a word delimiter,  for  example:  foo,
       foo_bar.  The <b>ucc</b> (stands for upper-camel-case) and <b>java</b> values a synonyms for the same naming convention
       where the first letter of each word in the name is capitalized, for example: Foo, FooBar.

       Similarly,  the  <b>--function-naming</b>  option  specifies  the  convention that should be used for naming C++
       functions.  Possible values for this option are <b>knr</b> (default), <b>lcc</b>, and <b>java</b>.  The <b>knr</b> value (stands  for
       K&amp;R)  signifies  the standard, lower-case naming convention with the underscore used as a word delimiter,
       for example: foo(), foo_bar().  The <b>lcc</b> value (stands for lower-camel-case) signifies a naming convention
       where the first letter of each word except the first is capitalized, for example:  foo(),  fooBar().  The
       <b>java</b> naming convention is similar to the lower-camel-case one except that accessor functions are prefixed
       with  get,  modifier  functions  are  prefixed  with  set, parsing functions are prefixed with parse, and
       serialization functions are prefixed with serialize, for  example:  getFoo(),  setFooBar(),  parseRoot(),
       serializeRoot().

       Note  that  the naming conventions specified with the <b>--type-naming</b> and <b>--function-naming</b> options perform
       only limited transformations on the names that come from the schema in the form of type,  attribute,  and
       element  names.  In  other  words, to get consistent results, your schemas should follow a similar naming
       convention as the one you would like to have in the  generated  code.  Alternatively,  you  can  use  the
       <b>--*-regex</b>  options  (discussed  below) to perform further transformations on the names that come from the
       schema.

       The <b>--type-regex</b>,  <b>--accessor-regex</b>,  <b>--one-accessor-regex</b>,  <b>--opt-accessor-regex</b>,  <b>--seq-accessor-regex</b>,
       <b>--modifier-regex</b>,   <b>--one-modifier-regex</b>,   <b>--opt-modifier-regex</b>,  <b>--seq-modifier-regex</b>,  <b>--parser-regex</b>,
       <b>--serializer-regex</b>, <b>--const-regex</b>, <b>--enumerator-regex</b>, and  <b>--element-type-regex</b>  options  allow  you  to
       specify  extra regular expressions for each name category in addition to the predefined set that is added
       depending on the <b>--type-naming</b> and <b>--function-naming</b> options. Expressions  that  are  provided  with  the
       <b>--*-regex</b>  options  are  evaluated  prior  to  any predefined expressions. This allows you to selectively
       override some or all of the predefined transformations.  When debugging your own expressions, it is often
       useful to see which expressions match which names. The <b>--name-regex-trace</b> option allows you to trace  the
       process of applying regular expressions to names.

       The   value   for   the  <b>--*-regex</b>  options  should  be  a  perl-like  regular  expression  in  the  form
       <b>/</b><u>pattern</u><b>/</b><u>replacement</u><b>/</b>.  Any character can be used as a delimiter instead of <b>/</b>.  Escaping of the delimiter
       character in <u>pattern</u> or <u>replacement</u> is not supported. All the regular expressions for each  category  are
       pushed  into  a  category-specific  stack  with the last specified expression considered first. The first
       match that succeeds is used. For  the  <b>--one-accessor-regex</b>  (accessors  with  cardinality  one),  <b>--opt-</b>
       <b>accessor-regex</b>   (accessors   with   cardinality  optional),  and  <b>--seq-accessor-regex</b>  (accessors  with
       cardinality sequence) categories the <b>--accessor-regex</b> expressions are used as a fallback. For the  <b>--one-</b>
       <b>modifier-regex</b>,   <b>--opt-modifier-regex</b>,   and   <b>--seq-modifier-regex</b>   categories   the  <b>--modifier-regex</b>
       expressions are used as a fallback. For the <b>--element-type-regex</b> category  the  <b>--type-regex</b>  expressions
       are used as a fallback.

       The type name expressions (<b>--type-regex</b>) are evaluated on the name string that has the following format:

       [<u>namespace</u>  ]<u>name</u>[<b>,</b><u>name</u>][<b>,</b><u>name</u>][<b>,</b><u>name</u>]

       The element type name expressions (<b>--element-type-regex</b>), effective only when the <b>--generate-element-type</b>
       option is specified, are evaluated on the name string that has the following format:

       <u>namespace</u> <u>name</u>

       In the type name format the <u>namespace</u> part followed by a space is only present for global type names. For
       global  types and elements defined in schemas without a target namespace, the <u>namespace</u> part is empty but
       the space is still present. In the type name format  after  the  initial  <u>name</u>  component,  up  to  three
       additional <u>name</u> components can be present, separated by commas. For example:

       <b><a href="http://example.com/hello">http://example.com/hello</a></b> <b>type</b>

       <b>foo</b>

       <b>foo,iterator</b>

       <b>foo,const,iterator</b>

       The following set of predefined regular expressions is used to transform type names when the upper-camel-
       case naming convention is selected:

       <b>/(?:[^</b> <b>]*</b> <b>)?([^,]+)/\u$1/</b>

       <b>/(?:[^</b> <b>]*</b> <b>)?([^,]+),([^,]+)/\u$1\u$2/</b>

       <b>/(?:[^</b> <b>]*</b> <b>)?([^,]+),([^,]+),([^,]+)/\u$1\u$2\u$3/</b>

       <b>/(?:[^</b> <b>]*</b> <b>)?([^,]+),([^,]+),([^,]+),([^,]+)/\u$1\u$2\u$3\u$4/</b>

       The accessor and modifier expressions (<b>--*accessor-regex</b> and <b>--*modifier-regex</b>) are evaluated on the name
       string that has the following format:

       <u>name</u>[<b>,</b><u>name</u>][<b>,</b><u>name</u>]

       After  the  initial  <u>name</u>  component,  up  to two additional <u>name</u> components can be present, separated by
       commas. For example:

       <b>foo</b>

       <b>dom,document</b>

       <b>foo,default,value</b>

       The following set of predefined regular expressions is used to transform accessor  names  when  the  <b>java</b>
       naming convention is selected:

       <b>/([^,]+)/get\u$1/</b>

       <b>/([^,]+),([^,]+)/get\u$1\u$2/</b>

       <b>/([^,]+),([^,]+),([^,]+)/get\u$1\u$2\u$3/</b>

       For  the  parser,  serializer,  and  enumerator  categories,  the  corresponding  regular expressions are
       evaluated on local names of elements and on enumeration values, respectively. For example, the  following
       predefined regular expression is used to transform parsing function names when the <b>java</b> naming convention
       is selected:

       <b>/(.+)/parse\u$1/</b>

       The  const  category  is  used  to create C++ constant names for the element/wildcard/text content ids in
       ordered types.

       See also the REGEX AND SHELL QUOTING section below.

</pre><h4><b>TYPE</b> <b>MAP</b></h4><pre>
       Type map files are used in C++/Parser to define a mapping between XML Schema and C++ types. The  compiler
       uses this information to determine the return types of <b>post_*</b> functions in parser skeletons corresponding
       to  XML  Schema types as well as argument types for callbacks corresponding to elements and attributes of
       these types.

       The compiler has a set of predefined mapping rules that map built-in XML Schema  types  to  suitable  C++
       types  (discussed  below)  and all other types to <b>void</b>.  By providing your own type maps you can override
       these predefined rules.  The format of the type map file is presented below:

              <b>namespace</b> <u>schema-namespace</u> [ <u>cxx-namespace</u> ]
              <b>{</b>
                ( <b>include</b> <u>file-name</u><b>;</b> )*
                ([ <b>type</b> ] <u>schema-type</u> <u>cxx-ret-type</u> [ <u>cxx-arg-type</u> ]<b>;</b> )*
              <b>}</b>

       Both <u>schema-namespace</u> and <u>schema-type</u> are regex patterns while <u>cxx-namespace</u>, <u>cxx-ret-type</u>, and  <u>cxx-arg-</u>
       <u>type</u>  are  regex  pattern  substitutions.  All  names  can be optionally enclosed in " ", for example, to
       include white-spaces.

       <u>schema-namespace</u> determines XML Schema namespace. Optional <u>cxx-namespace</u> is prefixed to  every  C++  type
       name  in  this  namespace declaration.  <u>cxx-ret-type</u> is a C++ type name that is used as a return type for
       the <b>post_*</b> functions. Optional <u>cxx-arg-type</u> is an argument type for callback functions  corresponding  to
       elements  and  attributes  of this type. If <u>cxx-arg-type</u> is not specified, it defaults to <u>cxx-ret-type</u> if
       <u>cxx-ret-type</u> ends with <b>*</b> or <b>&amp;</b> (that is,  it  is  a  pointer  or  a  reference)  and  <b>const</b>  <u>cxx-ret-type</u><b>&amp;</b>
       otherwise.   <u>file-name</u>  is  a  file  name  either in the " " or &lt; &gt; format and is added with the <b>#include</b>
       directive to the generated code.

       The <b>#</b> character starts a comment that ends with a new line or  end  of  file.  To  specify  a  name  that
       contains <b>#</b> enclose it in " ". For example:

              namespace <a href="http://www.example.com/xmlns/my">http://www.example.com/xmlns/my</a> my
              {
                include "my.hxx";

                # Pass apples by value.
                #
                apple apple;

                # Pass oranges as pointers.
                #
                orange orange_t*;
              }

       In  the  example above, for the <b><a href="http://www.example.com/xmlns/my">http://www.example.com/xmlns/my</a>#orange</b> XML Schema type, the <b>my::orange_t*</b>
       C++ type will be used as both return and argument types.

       Several namespace declarations can be specified in a single file.  The namespace declaration can also  be
       completely omitted to map types in a schema without a namespace. For instance:

              include "my.hxx";
              apple apple;

              namespace <a href="http://www.example.com/xmlns/my">http://www.example.com/xmlns/my</a>
              {
                orange "const orange_t*";
              }

       The  compiler  has a number of predefined mapping rules that can be presented as the following map files.
       The string-based XML Schema built-in types are mapped to either <b>std::string</b> or <b>std::wstring</b> depending  on
       the character type selected with the <b>--char-type</b> option (<b>char</b> by default).

              namespace <a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>
              {
                boolean bool bool;

                byte "signed char" "signed char";
                unsignedByte "unsigned char" "unsigned char";

                short short short;
                unsignedShort "unsigned short" "unsigned short";

                int int int;
                unsignedInt "unsigned int" "unsigned int";

                long "long long" "long long";
                unsignedLong "unsigned long long" "unsigned long long";

                integer "long long" "long long";

                negativeInteger "long long" "long long";
                nonPositiveInteger "long long" "long long";

                positiveInteger "unsigned long long" "unsigned long long";
                nonNegativeInteger "unsigned long long" "unsigned long long";

                float float float;
                double double double;
                decimal double double;

                string std::string;
                normalizedString std::string;
                token std::string;
                Name std::string;
                NMTOKEN std::string;
                NCName std::string;
                ID std::string;
                IDREF std::string;
                language std::string;
                anyURI std::string;

                NMTOKENS xml_schema::string_sequence;
                IDREFS xml_schema::string_sequence;

                QName xml_schema::qname;

                base64Binary std::auto_ptr&lt;xml_schema::buffer&gt;
                             std::auto_ptr&lt;xml_schema::buffer&gt;;
                hexBinary std::auto_ptr&lt;xml_schema::buffer&gt;
                          std::auto_ptr&lt;xml_schema::buffer&gt;;

                date xml_schema::date;
                dateTime xml_schema::date_time;
                duration xml_schema::duration;
                gDay xml_schema::gday;
                gMonth xml_schema::gmonth;
                gMonthDay xml_schema::gmonth_day;
                gYear xml_schema::gyear;
                gYearMonth xml_schema::gyear_month;
                time xml_schema::time;
              }

       The last predefined rule maps anything that wasn't mapped by previous rules to <b>void</b>:

              namespace .*
              {
                .* void void;
              }

       When you provide your own type maps with the <b>--type-map</b> option, they are evaluated first. This allows you
       to selectively override predefined rules.

</pre><h4><b>REGEX</b> <b>AND</b> <b>SHELL</b> <b>QUOTING</b></h4><pre>
       When  entering  a  regular  expression  argument  in  the shell command line it is often necessary to use
       quoting (enclosing the argument in " " or ' ') in order to prevent the shell  from  interpreting  certain
       characters, for example, spaces as argument separators and $ as variable expansions.

       Unfortunately  it is hard to achieve this in a manner that is portable across POSIX shells, such as those
       found on GNU/Linux and UNIX, and Windows shell. For example, if you use " " for quoting you  will  get  a
       wrong  result  with  POSIX shells if your expression contains $. The standard way of dealing with this on
       POSIX systems is to use ' ' instead. Unfortunately, Windows shell does not remove  '  '   from  arguments
       when  they  are passed to applications. As a result you may have to use ' ' for POSIX and " " for Windows
       ($ is not treated as a special character on Windows).

       Alternatively, you can save regular expression options into a file, one option per  line,  and  use  this
       file with the <b>--options-file</b> option. With this approach you don't need to worry about shell quoting.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       If  the  input  file  is  not a valid W3C XML Schema definition, <b>xsdcxx</b> will issue diagnostic messages to
       <b>STDERR</b> and exit with non-zero exit code.

</pre><h4><b>BUGS</b></h4><pre>
       Send bug reports to the <a href="mailto:xsd-users@codesynthesis.com">xsd-users@codesynthesis.com</a> mailing list.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005-2014 Code Synthesis Tools CC.

       Permission is granted to copy, distribute and/or modify this document under the terms  of  the  GNU  Free
       Documentation  License,  version  1.2; with no Invariant Sections, no Front-Cover Texts and no Back-Cover
       Texts. Copy of the license can be obtained from <a href="http://codesynthesis.com/licenses/fdl-1.2.txt">http://codesynthesis.com/licenses/fdl-1.2.txt</a>

XSDCXX 4.0.0                                        July 2014                                          <u><a href="../man1/XSDCXX.1.html">XSDCXX</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>