<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pipexec - create a directed graph of processes and pipes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/pipexec">pipexec_2.6.2-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pipexec - create a directed graph of processes and pipes

</pre><h4><b>SYNOPSIS</b></h4><pre>
       pipexec [OPTION]... [PROCESS DESCRIPTION]... [PIPE DESCRIPTION]...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>pipexec</b> creates an arbitrary network (directed graph) of processes and pipes in between - even cycles are
       possible.   It  overcomes  the  shortcomings  of shells that are typically only able to create non cyclic
       trees.

       <b>pipexec</b> also monitors all it's child processes and is able to restart the whole network of processes  and
       pipes  if  one  crashes.   Therefore  <b>pipexec</b>  can be used in SYSV-init or systemd configuration to run a
       network of processes.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-h</b>     print help and version information

       <b>-l</b> <b>logfd</b>
              use the given file descriptor for text logging.  If a 's' is specified, syslog is used.   Example:
              Specifying '2' means log to stderr.

       <b>-j</b> <b>logfd</b>
              use  the given file descriptor for json logging.  If a 's' is specified, syslog is used.  Example:
              Specifying '2' means log to stderr.  As this is meant to be parsed by other programs, this  is  an
              official and supported interface which is described in the JSON LOGGING chapter.

       <b>-p</b> <b>pidfile</b>
              with  <b>pipexec</b> it is possible to handle pipes within SYSV-init scripts.  In some environments (e.g.
              RHEL6, Debian7) the start and stop routines need a pid file.  If this  option  is  given,  pipexec
              writes its own pid into the file shortly after start of pipexec.

       <b>-k</b>     if one sub-process (child) gets killed and this options is given, all other sub-processes are also
              killed.  Afterwards all processes are restarted.

       <b>-s</b> <b>sleep_time</b>
              the  time  interval  in seconds before a restart.  This option makes only sense when also the '-k'
              option is specified.

</pre><h4><b>BACKGROUND</b></h4><pre>
       Inside a shell it is possible to start processes and redirect the output to other processes.

       Example:
           cat Chap1.txt Chap2.txt | grep bird | wc -l

       Three processes are created: the standard output (file  descriptor  (fd)  1)  of  the  'cat'  process  is
       connected  to  the  standard  input  (fd  0) of the 'grep' command, and the standard output of the 'grep'
       command is connected to the standard input (fd 0) of the 'wc' process.

       Please note that the assignment between names and file descriptor number is pure historical  and  has  no
       technical background.

       Example:
           find / 1&gt; &gt;(grep .txt) 2&gt; &gt;(wc &gt;/tmp/w.log)

       In  this  more complex example, the fd 1 of the 'find' process is connected to fd 0 of 'grep' and fd 2 is
       connected to fd 0 of 'wc'.

       The limitation using this way of specifying processes and pipes is, that it is not possible to  have  any
       cycles.  It is impossible to e.g. pass a fd of 'wc' either to 'grep' or to 'find'.

       <b>pipexec</b>  overcomes these limitations.  It makes it possible to link any two arbitrary file descriptors in
       a set of processes.

</pre><h4><b>USAGE</b></h4><pre>
       When building up a network of processes and pipes, there is the need to specify each element separately.

       The processes will be the nodes in the network (directed graph), the connections of the file  descriptors
       between to processes are the edges.  Each node (process) has a unique name assigned to it.  This makes it
       possible to differentiate between using the same command more than once.

       The format of specifying a process is
           [ NAME /path/to/command arg1 arg2 ... argN ]

       The  first  parameter  'NAME'  must  be a unique name.  The second parameter must be the full path of the
       command to execute.  Please note that  always  the  full  path  must  be  specified,  there  is  no  PATH
       environment  variable  handling  (<a href="../man2/execv.2.html">execv</a>(2)  is  used  internally  to  span new processes).  The following
       parameters are the parameters passed to the command.

       The whole definition must be enclosed in square brackets.  The square brackets must be given separately -
       before and after them must be a space.

       The format of specifying a pipe between processes is
           {NAME_1:FD1&gt;NAME_2:FD2}

       Example
           {LS:1&gt;GREP:0}

       The names are the names of the processes, the numbers are the number of the file descriptor  that  should
       be  used  to build the pipe in between.  When using pipexec from a shell (like bash) there is the need to
       escape the brackets or use quotation marks.

</pre><h4><b>JSON</b> <b>LOGGING</b></h4><pre>
       <b>pipexec</b> can log in JSON format. This is an official supported interface which is defined in this chapter.
       This can be seen as stable as no changes will be made during small version upgrades. Of course  additions
       will be made also within minor upgrades, but this should be fine because of the underlaying JSON format.

       Each JSON log object (e.g. line) will be in a separate line.

       The following keys are always present:

       <b>timestamp</b>
              The timestamp is the <a href="../man0/time.0.html">time</a>(0) (seconds since epoch) when the log in generated.

       <b>pipexec_pid</b>
              The pid of the pipexec process.

       <b>id</b>     An id that specifies defined log objects.

       <b>type</b>   An indicator in which internal module this log was generated.

       <b>serverity</b>
              One of debug, info, warning, error.

       <b>message</b>
              A short message describing the event.

       Depending on the id there might be additional fields which are described in the next section.

       <b>id</b> <b>=</b> <b>0</b> id  of  0  is a special case: this is used for internal logs only. The logs are not documented and
              may change at any time. The information can be used to get  an  idea  what  currently  happens  in
              pipexec.

       <b>id</b> <b>=</b> <b>1</b> This  gives  information about the process ids (pids) of the commands.  The field <b>command</b> contains
              the command (i.e. the part in the command before the colon. The field <b>command_pid</b> contains the pid
              of the command.

       <b>id</b> <b>=</b> <b>2</b> This log message is emitted when a child (command) exits. It contains some information  about  the
              exit  status and termination reason of the command.  The field <b>command_pid</b> contains the pid of the
              command which just terminated. The  field  <b>status</b>  is  the  value  which  is  set  by  <b><a href="../man2/waitpid.2.html">waitpid</a>(2)</b>.
              <b>normal_exit</b>,  <b>child_status</b>  and  <b>child_signaled</b>  are <b>WIFEXITED</b>, <b>WEXITSTATUS</b> and <b>WIFSIGNALED</b> of the
              status respectively.

</pre><h4><b>RETURN</b></h4><pre>
       pipexec returns 1 if any of the child processes fails else 0 is returned.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The shell command
           cat Chap1.txt Chap2.txt | grep bird | wc -l

       is equivalent to
           pipexec [ CAT <a href="file:/bin/cat">/bin/cat</a> Chap1.txt Chap2.txt ] \
             [ GREP <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?grep">/usr/bin/grep</a> bird ] [ WC <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?wc">/usr/bin/wc</a> -l ] \
             "{CAT:1&gt;GREP:0}" "{GREP:1&gt;WC:0}"

       The pipexec equivalent is longer and more complex in this example.  But pipexec can build cycles that are
       impossible within a shell:
           pipexec [ A /bin/cmd1 ] [ B /bin/cmd2 ] "{A:1&gt;B:0}" "{B:1&gt;A:0}"

       When using json log, you get output like:
       {"timestamp":1655706460,"pipexec_pid":42850,"id":1,"type":"exec","serverity":"info","message":"New child forked","command":"A","command_pid":"42851"}
       {"timestamp":1655706886,"pipexec_pid":42869,"id":2,"type":"tracing","serverity":"info","message":"child exit","command_pid":"42870","status":"1","normal_exit":"1","child_status":"1","child_signaled":"0"}

       For more examples see the <a href="../man1/ptee.1.html">ptee</a>(1) and <a href="../man1/peet.1.html">peet</a>(1) man pages.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/bash.1.html">bash</a>(1),</b> <b><a href="../man1/ptee.1.html">ptee</a>(1),</b> <b><a href="../man1/peet.1.html">peet</a>(1),</b> <b><a href="../man2/execv.2.html">execv</a>(2)</b>

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Andreas Florath (<a href="mailto:andreas@florath.net">andreas@florath.net</a>)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright Â© 2015,2022 by Andreas Florath (<a href="mailto:andreas@florath.net">andreas@florath.net</a>).  License GPLv2+: GNU  GPL  version  2  or
       later &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.

User Commands                                      2022-07-18                                         <u><a href="../man1/pipexec.1.html">pipexec</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>