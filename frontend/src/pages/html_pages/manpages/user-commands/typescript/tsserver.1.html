<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tsserver - TypeScript standalone server</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/node-typescript">node-typescript_4.9.5+ds1-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>tsserver</b> <b>-</b> <b>TypeScript</b> <b>standalone</b> <b>server</b>

       The  TypeScript  standalone  server  (aka <b>tsserver</b>) is a node executable that encapsulates the TypeScript
       compiler and language services, and exposes them through a JSON protocol. <b>tsserver</b>  is  well  suited  for
       editors and IDE support.

                                                  October 2023                                       <u><a href="../man1/TSSERVER.1.html">TSSERVER</a></u>(1)
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
</pre><h4><b>NAME</b></h4><pre>
       <b>Protocol</b>

</pre><h4><b>Definition</b></h4><pre>
       The   server  communication  protocol  is  defined  in  the  <b>ts.server.protocol</b>  namespace,  declared  in
       <u>`tsserverlibrary.d.ts`</u>.

       The executable can be found in lib folder under the typescript package.
         npm install --save typescript
         ls node_modules\typescript\lib\tsserver.js

</pre><h4><b>Message</b> <b>format</b></h4><pre>
       <b>tsserver</b> listens on <b>stdin</b> and writes messages back to <b>stdout</b>.

       Requests are JSON following the  protocol  definition.  Here  is  an  example  request  to  open  a  file
       <b>c:/DefinitelyTyped/gregorian-calendar/index.d.ts</b>:
         {"seq":1,"type":"request","command":"open","arguments":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts"}}

       Responses are augmented JSON format. The Message starts with a header with the content length followed by
       a line separator (<b>\r\n</b>) followed by the response body as a JSON string:

       Here is an example of a response for a <b>quickinfo</b> command:
         Content-Length: 116

         {"seq":0,"type":"response","command":"quickinfo","request_seq":2,"success":false,"message":"No content available."}

       Similarly events have the same format as a response.

       Here is an example event for error message:
         Content-Length: 261

         {"seq":0,"type":"event","event":"semanticDiag","body":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts","diagnostics":[{"start":{"line":264,"offset":44},"end":{"line":264,"offset":50},"text":"Binding element 'Object'
         implicitly has an 'any' type."}]}}

</pre><h4><b>Commands</b></h4><pre>
       <b>tsserver</b> supports a set of commands. The full list of commands supported by the server can be found under
       <u>ts.server.protocol.CommandTypes</u>.

       Each  command  is  associated with a request and a response interface. For instance command <b>"completions"</b>
       corresponds   to   request   interface   <b>CompletionsRequest</b>,   and   response   interface   defined    in
       <b>CompletionsResponse</b>.

                                                  October 2023                                       <u><a href="../man1/TSSERVER.1.html">TSSERVER</a></u>(1)
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
</pre><h4><b>NAME</b></h4><pre>
       Sample implementations

</pre><h4><b>Sublime</b> <b>text</b> <b>plugin</b></h4><pre>
       <u>TypeScript-Sublime-Plugin</u> is a Sublime text plugin written in Python that uses <b>tsserver</b>.

</pre><h4><b>Visual</b> <b>Studio</b> <b>Code</b></h4><pre>
       <u>VS</u> <u>Code</u>' s <u>TypeScript</u> <u>support</u> is implemented in TypeScript using <b>tsserver</b>.

</pre><h4><b>Tide</b></h4><pre>
       <u>Tide</u> is an elisp implementation for emacs plugin using <b>tsserver</b>

</pre><h4><b>Neovim</b></h4><pre>
       <u>nvim-typescript</u> is a neovim plugin using <b>tsserver</b>

                                                  October 2023                                       <u><a href="../man1/TSSERVER.1.html">TSSERVER</a></u>(1)
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
</pre><h4><b>NAME</b></h4><pre>
       Advanced topics

</pre><h4><b>Logging</b></h4><pre>
       <b>tsserver</b> logging is configured through the <b>TSS_LOG</b> environment variable.

       <b>TSS_LOG</b> can have the following format:
         [-level &lt;terse | normal | requestTime | verbose&gt;]
         [-traceToConsole &lt;true | false&gt;]
         [-logToFile &lt;true | false&gt;]
         [-file &lt;log file path&gt;]

       Note: <b>file</b> defaults to <b>__dirname\.log&lt;PID&gt;</b> if not specified

       <b>Example</b>: <b>set</b> <b>TSS_LOG=-level</b> <b>verbose</b> <b>-file</b> <b>c:\tmp\tsserver.log</b>

</pre><h4><b>Cancellation</b></h4><pre>
       <b>tsserver</b>  on  startup  will  try  to  load module <b>./cancellationToken</b> from the containing directory. This
       module should export a factory function that accepts  a  list  of  command  line  arguments  and  returns
       <u>HostCancellationToken</u>.  <b>tsserver</b> will use this token to check if in-flight operation should be cancelled.

       NOTE:  This  token  will be used for all operations so if one operation is cancelled and cancellation was
       reported through the token then when another operation is started  -  token  should  be  reset  into  the
       non-cancelled state.

       Default  implementation  of  the  cancellation  token uses the presence of named pipes as a way to signal
       cancellation.

        • Before spawning the server, the client generates a unique name. This name is passed to the server as a
          <b>cancellationPipeName</b> command line argument.

        • If some operation on the client side should be cancelled - client opens  a  named  pipe  with  a  name
          generated  on  step  1.  Nothing  needs  to  be  written in the pipe - default cancellation token will
          interpret the presence of named pipe as a cancellation request.

        • After receiving acknowledgment from the server, the client closes the pipe so it can use the same pipe
          name for the next operation.

       Server can split execution of some commands (like <b>geterr</b>) in a few steps that will  be  executed  with  a
       delay.  This  allows  it  to  react on user actions more promptly and not run heavy computations if their
       results will not be used. However, it introduces a tricky moment in support of cancellations. By allowing
       request to be suspended and resumed later we break the invariant that was  the  cornerstone  for  default
       implementation  of  cancellation.  Namely now requests can overlap so one pipe name can no longer be used
       because client have no reason what request is currently executing and will be  cancelled.  To  deal  with
       this  issue  <b>tsserver</b>  allows pipe name to be computed dynamically based on current request id. To enable
       this the client need to provide a value that ends with  <b>*</b>  as  the  <b>--cancellationPipeName</b>  argument.  If
       provided  cancellation pipe name ends with <b>*</b> then default implementation of cancellation token will build
       expected pipe name as <b>&lt;cancellationPipeName</b> <b>argument</b> <b>without</b> <b>*&gt;&lt;currentRequestId&gt;</b>. This will allow client
       to signal any request it thinks is in flight by creating a named pipe  with  a  proper  name.  Note  that
       server  will  always  send  <b>requestCompleted</b>  message  to  denote that asynchronous request was completed
       (either by running to completion or via cancellation) so the  client  can  close  named  pipe  once  this
       message is received.

</pre><h4><b>Commandline</b> <b>options</b></h4><pre>
       <b>--cancellationPipeName</b>
              Name of the pipe used as a request cancellation semaphore. See <u>Cancellation</u> for more information.

       <b>--syntaxOnly</b>
              A streamlined mode for when the server will only be answering syntactic queries.

       <b>--suppressDiagnosticEvents</b>
              Opt out of receiving events when new diagnostics are discovered (i.e. must request them explicitly).

       <b>--eventPort</b>
              Port used for receiving events. If non is specified events are sent to stdout.

       <b>--useSingleInferredProject</b>
              Put all open .ts and .js files that do not have a .tsconfig file in a common project

       <b>--noGetErrOnBackgroundUpdate</b>
              Opt out of starting <b>getErr</b> on <b>projectsUpdatedInBackground</b> event

       <b>--locale</b>
              The locale to use to show error messages, e.g. en-us.
              Possible values are: English (US): <b>en</b>, Czech: <b>cs</b>, German: <b>de</b>, Spanish: <b>es</b>, French: <b>fr</b>, Italian: <b>it</b>, Japanese: <b>ja</b>, Korean: <b>ko</b>, Polish: <b>pl</b>,
              Portuguese(Brazil): <b>pt-BR</b>, Russian: <b>ru</b>, Turkish: <b>tr</b>, Simplified Chinese: <b>zh-CN</b>, Traditional Chinese: <b>zh-TW</b>

                                                  October 2023                                       <u><a href="../man1/TSSERVER.1.html">TSSERVER</a></u>(1)
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
</pre><h4><b>NAME</b></h4><pre>
       Project System
       There are three kinds of projects:
</pre><h4><b>Configured</b> <b>Project</b></h4><pre>
       Configured  projects  are  defined  by  a configuration file, which can be either <b>tsconfig.json</b> file or a
       <b>jTshconfig.jsonie</b>ccompileraoptionsdtoib<b>e</b>susedtforlthisoproject..
       <u>tsconfig.json</u>m<u>documentation</u>.n in the

</pre><h4><b>External</b> <b>Project</b></h4><pre>
       Theehostnis responsiblerfornsupplyingptheflistr<b>o</b>fefilesrintthisaproject and compiler.options to use.
       Currently VS is the only consumer of this type of project, to model the TS/JS files in a .csproj project.
</pre><h4><b>Inferred</b> <b>Project</b></h4><pre>
       <b>I</b>ffarfilepd<b>o</b>escnotahaveh<b>a</b>tconfigura<b>t</b>ionefilee(<b>tsconfig.json</b>Jorf<b>jsconfig.json</b>) <b>in</b> <b>the</b> <b>current</b> <b>directory</b> <b>or</b>
       <b>any</b> <b>parent</b> <b>directories</b>, the server will create an inferred project for it.
       The server will include the loose file, then includes all other files included by triple slash references
       and module imports from the original file transitively.
       Thephos<b>t</b>icanosetothewdefa<b>u</b>ltstof anfinferrediproject.inferred projects.
</pre><h4><b>Relationship</b> <b>Among</b> <b>These</b> <b>Projects</b></h4><pre>
       In general, the relationship can be summarized as <b>configured</b> <b>projects</b>  <b>&gt;</b>  <b>external</b>  <b>projects</b>  <b>&gt;</b>  <b>inferred</b>
       <b>projects</b>.
       For example, if <b>file1.ts</b> belongs to an inferred project, but later a new <b>tsconfig.json</b> also includes this
       Then. after  the  <b>tsconfig.json</b>  file  is  found, <b>file1.ts</b> will no longer belong to the previous inferred
       Ifo<b>file1.ts</b> us<b>e</b>dntolbecthetrootofileurof ptheecinferr<b>e</b>dd.project,  that  inferred  project  will  now  be
       destroyed; otherwise it will remain with one fewer file.

       For  another  example,  if  a  <b>tsconfig.json</b>  file  is created to include some files used to belong to an
       external project (let's call it EP1), then in the current implementation EP1 will be destroyed,  all  its
       files  either  go to the new configured project or will belong to a new inferred project the next time it
       is opened.
       One thing to notice is that one file can belong to multiple projects of the same kind at the  same  time.
       E.g., a file can be included by multiple configured projects / inferred projects / external projects.
                                                  October 2023                                       <u><a href="../man1/TSSERVER.1.html">TSSERVER</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>