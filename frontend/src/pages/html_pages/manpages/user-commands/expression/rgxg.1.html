<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rgxg - ReGular eXpression Generator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/rgxg">rgxg_0.1.2-6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rgxg - ReGular eXpression Generator

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>rgxg</b> COMMAND [ARGS]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>rgxg</b> is a generator for (extended) regular expressions.

       For  instance  it  is  useful  to  generate  a regular expression to exactly match a numeric range or all
       addresses of a given CIDR block.

</pre><h4><b>COMMANDS</b></h4><pre>
       <b>alternation</b> [options] [PATTERN...]

           Generate a regular expression that matches any of the given patterns.

           <b>Options</b>

              -N     Omit the outer parentheses, if any, of the regular expression. This option can be useful if
                     the generated regular expression is used within another alternation.

              -h     Display help and exit.

           <b>Examples</b>

              Match either lion, elephant, rhino, buffalo or leopard:
                 $ rgxg alternation lion elephant rhino buffalo leopard
                 (lion|elephant|rhino|buffalo|leopard)

       <b>cidr</b> [options] CIDR

           Generate a regular expression that matches all addresses of the given CIDR block. Both IPv4 and  IPv6
           CIDR blocks are supported.

           <b>Options</b>

              -N     Omit the outer parentheses, if any, of the regular expression. This option can be useful if
                     the generated regular expression is used within another alternation.

              -l     Match  only  IPv6  addresses  with lower case letters. By default both lower and upper case
                     letters are matched.

              -U     Match only IPv6 addresses with upper case letters. By default both  lower  and  upper  case
                     letters are matched.

              -u     Do  not  match  IPv6 addresses with zero compression (second form of text representation of
                     IPv6 addresses mentioned in section 2.2 of <b>RFC</b> <b>4291</b>).

              -s     Do not match IPv6 addresses in mixed notation (third form of text  representation  of  IPv6
                     addresses mentioned in section 2.2 of <b>RFC</b> <b>4291</b>).

              -h     Display help and exit.

           <b>Examples</b>

              Match 192.168.0.0/24:
                 $ rgxg cidr 192.168.0.0/24
                 192.168.0.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])

              Match 2001:db8:aaaa:bbbb:cccc:dddd::/96 limited to lower case letters:
                 $ rgxg cidr -l 2001:db8:aaaa:bbbb:cccc:dddd::/112
                 2001:0?db8:aaaa:bbbb:cccc:dddd((::[0-9a-f]{1,4}|::|:0?0?0?0(::|:[0-9a-f]{1,4}))|:0.0(.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){2})

              Match 2001:db8:1234::/48 restricted to uncompressed standard notation:
                 $ rgxg cidr -u -s 2001:db8:1234::/48
                 2001:0?[Dd][Bb]8:1234(:[0-9A-Fa-f]{1,4}){5}

       <b>escape</b> [options] STRING

           Generate the regular expression which matches the given string by escaping the escape characters.

           <b>Options</b>

              -h     Display help and exit.

           <b>Examples</b>

              Match '1+(2*(3-4))':
                 $ rgxg escape 1+(2*(3-4))
                 1\+\(2\*\(3-4\)\)

       <b>help</b> [COMMAND]

           Describe the usage of rgxg or the given COMMAND.

       <b>range</b> [options] FIRST [LAST]

           Generate  a  regular  expression  that  matches  the  number range between FIRST and LAST. If LAST is
           omitted the regular expression matches all numbers which are greater than or equal FIRST. The numbers
           must be positive and given in base-10 notation.

           <b>Options</b>

              -b <u>BASE</u>
                     Generate the regular expression for the number range with base BASE. The BASE  must  be  in
                     the range between 2 and 32. The default base is 10.

              -N     Omit the outer parentheses, if any, of the regular expression. This option can be useful if
                     the generated regular expression is used within another alternation.

              -l     For  bases  greater  than 10 only match lower case letters. By default both lower and upper
                     case letters are matched.

              -U     For bases greater than 10 only match upper case letters. By default both  lower  and  upper
                     case letters are matched.

              -h     Display help and exit.

              -z     Only  match  numbers  with leading zeros. By default the number of leading zeros depends on
                     the length (i.e. the number of digits) of LAST (see also <b>-m</b>). The default is to  not  match
                     numbers with leading zeros.

              -Z     Match  numbers  with  a  variable number of leading zeros. By default the maximum number of
                     leading zeros depends on the length (i.e. the number of digits) of LAST (see also <b>-m</b>).  The
                     default is to not match numbers with leading zeros.

              -m <u>LENGTH</u>
                     with <b>-z</b> or <b>-Z</b>, the minimum LENGTH of matched numbers. For instance the number 5 with LENGTH
                     set  to  3  and <b>-z</b> option set is matched as '005'. If LENGTH is lesser than or equal to the
                     number of digits of LAST, this option has no effect.

           <b>Examples</b>

              Match the numbers from 0 to 31:
                 $ rgxg range 0 31
                 (3[01]|[12]?[0-9])

              Match numbers from 0 to 31 with base 2:
                 $ rgxg range -b 2 0 31
                 (1[01]{0,4}|0)

              Match 0 to 31 with base 16:
                 $ rgxg range -b 16 0 31
                 1?[0-9A-Fa-f]

              Match 0 to 31 with base 16 limited to upper case letters:
                 $ rgxg range -b 16 -U 0 31
                 1?[0-9A-F]

              Match 0 to 31 with base 16 limited to lower case letters:
                 $ rgxg range -b 16 -l 0 31
                 1?[0-9a-f]

              Match 00 to 31:
                 $ rgxg range -z 0 31
                 (3[01]|[0-2][0-9])

              Match 0000 to 0031:
                 $ rgxg range -z -m 4 0 31
                 (003[01]|00[0-2][0-9])

              Match 0 to 31 and 00 to 31 and 000 to 031:
                 $ rgxg range -Z -m 3 0 31
                 (0?3[01]|0?[0-2]?[0-9])

              Match 0 to 31 and omit outer parentheses:
                 $ rgxg range -N 0 31
                 3[01]|[12]?[0-9]

              Match all numbers greater than or equal to 4096:
                 $ rgxg range 4096
                 ([1-9][0-9]{4,}|[5-9][0-9]{3}|4[1-9][0-9]{2}|409[6-9])

       <b>version</b>
           Prints the version of the rgxg command.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       The exit status is 0 if the regular expression has been successfully generated. If an error occurred  the
       exit status is 1.

</pre><h4><b>NOTES</b></h4><pre>
       The  regular  expressions generated by rgxg are supposed to be used in any context. This may lead to some
       side effects.

       For instance consider the following:

          $ echo '192.168.0.999' | grep -E "$(rgxg cidr 192.168.0.0/24)"
          192.168.0.999
          $

       This is correct because the regular expression for '192.168.0.0/24' matches '192.168.0.99'.

       One can verify this by adding '-o' to grep:

          echo '192.168.0.999' | grep -oE "$(rgxg cidr 192.168.0.0/24)"
          192.168.0.99
          $

       As rgxg cannot know in which context the generated regular expression is used, it is up to  the  user  to
       ensure that the regular expression works as expected (e.g. by adding anchors like '^' and '$').

       In the example above adding line anchors leads to the expected behaviour:

          $ echo '192.168.0.999' | grep -E "^$(rgxg cidr 192.168.0.0/24)$"
          $

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/regex.7.html">regex</a></b>(7)

</pre><h4><b>AUTHOR</b></h4><pre>
       Hannes von Haugwitz &lt;<a href="mailto:hannes@vonhaugwitz.com">hannes@vonhaugwitz.com</a>&gt;

rgxg 0.1.2                                        Apr 12, 2020                                           <u><a href="../man1/RGXG.1.html">RGXG</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>