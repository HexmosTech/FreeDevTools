<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fish  is  a  fully-equipped  command  line shell (like bash or zsh) that is smart and user-friendly. Fish</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/fish-common">fish-common_4.0.1-1_all</a> <br><br><pre>
</pre><h4><b>WHY</b> <b>FISH?</b></h4><pre>
       Fish  is  a  fully-equipped  command  line shell (like bash or zsh) that is smart and user-friendly. Fish
       supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work,
       with nothing to learn or configure.

       If you want to make your command line more productive, more useful, and  more  fun,  without  learning  a
       bunch of arcane syntax and configuration options, then fish might be just what you're looking for!

</pre><h4><b>GETTING</b> <b>STARTED</b></h4><pre>
       Once installed, just type in <b>fish</b> into your current shell to try it out!

       You will be greeted by the standard fish prompt, which means you are all set up and can start using fish:

          &gt; fish
          Welcome to fish, the friendly interactive shell
          Type help for instructions on how to use fish
          you@hostname ~&gt;

       This  prompt that you see above is the fish default prompt: it shows your username, hostname, and working
       directory. You can customize it, see <u>how</u> <u>to</u> <u>change</u> <u>your</u> <u>prompt</u>.

       From now on, we'll pretend your prompt is just a <b>&gt;</b> to save space.

</pre><h4><b>LEARNING</b> <b>FISH</b></h4><pre>
       This tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a
       working copy of fish.

       If you have a strong understanding of other shells, and want to know what fish does  differently,  search
       for the magic phrase <u>unlike</u> <u>other</u> <u>shells</u>, which is used to call out important differences.

       Or, if you want a quick overview over the differences to other shells like Bash, see <u>Fish</u> <u>For</u> <u>Bash</u> <u>Users</u>.

       For the full, detailed description of how to use fish interactively, see <u>Interactive</u> <u>Use</u>.

       For a comprehensive description of fish's scripting language, see <u>The</u> <u>Fish</u> <u>Language</u>.

</pre><h4><b>RUNNING</b> <b>COMMANDS</b></h4><pre>
       Fish  runs  commands  like  other  shells:  you  type  a  command,  followed by its arguments. Spaces are
       separators:

          &gt; echo hello world
          hello world

       This runs the command <b>echo</b> with the arguments <b>hello</b> and <b>world</b>. In  this  case  that's  the  same  as  one
       argument  <b>hello</b> <b>world</b>, but in many cases it's not. If you need to pass an argument that includes a space,
       you can <u>escape</u> with a backslash, or <u>quote</u> it using single or double quotes:

          &gt; mkdir My\ Files
          # Makes a directory called "My Files", with a space in the name
          &gt; cp <a href="file:~/Some">~/Some</a>\ File 'My Files'
          # Copies a file called "Some File" in the home directory to "My Files"
          &gt; ls "My Files"
          Some File

</pre><h4><b>GETTING</b> <b>HELP</b></h4><pre>
       Run <b>help</b> to open fish's help in a web browser, and <b>man</b> with the page (like <b>fish-language</b>) to open it in a
       man page. You can also ask for help with a specific command, for example, <b>help</b>  <b>set</b>  to  open  in  a  web
       browser, or <b>man</b> <b>set</b> to see it in the terminal.

          &gt; man set
          set - handle shell variables
            Synopsis...

       To open this section, use <b>help</b> <b>getting-help</b>.

       This  only  works for fish's own documentation for itself and its built-in commands (the "builtins"). For
       any other commands on your system, they should provide their own documentation, often in the man  system.
       For example <b>man</b> <b>ls</b> should tell you about your computer's <b>ls</b> command.

</pre><h4><b>SYNTAX</b> <b>HIGHLIGHTING</b></h4><pre>
       You'll  quickly  notice  that fish performs syntax highlighting as you type. Invalid commands are colored
       red by default:

          &gt; /bin/mkd

       A command may be invalid because it does not exist, or refers to a file that you cannot execute. When the
       command becomes valid, it is shown in a different color:

          &gt; <a href="file:/bin/mkdir">/bin/mkdir</a>

       Valid file paths are underlined as you type them:

          &gt; cat <a href="file:~/somefi">~/somefi</a>

       This tells you that there exists a file that starts with <b>somefi</b>, which is useful feedback as you type.

       These colors, and many more, can be changed by running  <b>fish_config</b>,  or  by  modifying  <u>color</u>  <u>variables</u>
       directly.

       For example, if you want to disable (almost) all coloring:

          fish_config theme choose none

       This picks the "none" theme. To see all themes:

          fish_config theme show

       Just  running  <b>fish_config</b>  will  open  up a browser interface that allows you to pick from the available
       themes.

</pre><h4><b>AUTOSUGGESTIONS</b></h4><pre>
       As you type fish will suggest commands to the right of the cursor, in gray. For example:

          &gt; <a href="file:/bin/hostname">/bin/hostname</a>

       It knows about paths and options:

          &gt; grep --ignore-case

       And history too. Type a command once, and you can re-summon it by just typing a few letters:

          &gt; rsync -avze ssh . <a href="mailto:myname@somelonghost.com">myname@somelonghost.com</a>:/some/long/path/doo/dee/doo/dee/doo

       To accept the autosuggestion, hit <b>right</b> (<b>→</b>) or <b>ctrl-f</b>. To accept a single  word  of  the  autosuggestion,
       <b>alt-right</b> (<b>→</b>). If the autosuggestion is not what you want, just ignore it.

       If you don't like autosuggestions, you can disable them by setting <b>$fish_autosuggestion_enabled</b> to 0:

          set -g fish_autosuggestion_enabled 0

</pre><h4><b>TAB</b> <b>COMPLETIONS</b></h4><pre>
       A rich set of tab completions work "out of the box".

       Press <b>tab</b> and fish will attempt to complete the command, argument, or path:

          &gt; /pri<b>tab</b> =&gt; /private/

       If there's more than one possibility, it will list them:

          &gt; <a href="file:~/stuff/s">~/stuff/s</a><b>tab</b>
          <a href="file:~/stuff/script.sh">~/stuff/script.sh</a>  (command)  <a href="file:~/stuff/sources/">~/stuff/sources/</a>  (directory)

       Hit  tab  again  to  cycle  through  the possibilities. The part in parentheses there (that "command" and
       "directory") is the completion description. It's just a short hint to explain what kind  of  argument  it
       is.

       fish can also complete many commands, like git branches:

          &gt; git merge pr<b>tab</b> =&gt; git merge prompt_designer
          &gt; git checkout b<b>tab</b>
          builtin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)

       Try hitting tab and see what fish can do!

</pre><h4><b>VARIABLES</b></h4><pre>
       Like other shells, a dollar sign followed by a variable name is replaced with the value of that variable:

          &gt; echo My home directory is $HOME
          My home directory is /home/tutorial

       This is known as variable substitution, and it also happens in double quotes, but not single quotes:

          &gt; echo "My current directory is $PWD"
          My current directory is /home/tutorial
          &gt; echo 'My current directory is $PWD'
          My current directory is $PWD

       Unlike other shells, fish has an ordinary command to set variables: <b>set</b>, which takes a variable name, and
       then its value.

          &gt; set name 'Mister Noodle'
          &gt; echo $name
          Mister Noodle

       (Notice  the  quotes: without them, <b>Mister</b> and <b>Noodle</b> would have been separate arguments, and <b>$name</b> would
       have been made into a list of two elements.)

       Unlike other shells, variables are not further split after substitution:

          &gt; mkdir $name
          &gt; ls
          Mister Noodle

       In bash, this would have created two directories "Mister" and "Noodle". In fish, it created only one: the
       variable had the value "Mister Noodle", so that is the argument that was passed to <b>mkdir</b>, spaces and all.

       You can erase (or "delete") a variable with <b>-e</b> or <b>--erase</b>

          &gt; set -e MyVariable
          &gt; env | grep MyVariable
          (no output)

       For more, see <u>Variable</u> <u>expansion</u>.

</pre><h4><b>EXPORTS</b> <b>(SHELL</b> <b>VARIABLES)</b></h4><pre>
       Sometimes you need to have a variable available to an external command, often as a setting.  For  example
       many  programs  like  <b>git</b> or <b>man</b> read the <b>$PAGER</b> variable to figure out your preferred pager (the program
       that lets you scroll text). Other variables used like this include <b>$BROWSER</b>,  <b>$LANG</b>  (to  configure  your
       language) and <b>$PATH</b>. You'll note these are written in ALLCAPS, but that's just a convention.

       To  give  a  variable to an external command, it needs to be "exported". This is done with a flag to <b>set</b>,
       either <b>--export</b> or just <b>-x</b>.

          &gt; set -x MyVariable SomeValue
          &gt; env | grep MyVariable
          MyVariable=SomeValue

       It can also be unexported with <b>--unexport</b> or <b>-u</b>.

       This works the other way around as well! If fish is started by something else, it inherits  that  parents
       exported  variables.  So  if your terminal emulator starts fish, and it exports <b>$LANG</b> set to <b>en_US.UTF-8</b>,
       fish will receive that setting. And whatever started your terminal emulator also gave <u>it</u>  some  variables
       that  it  will  then pass on unless it specifically decides not to. This is how fish usually receives the
       values for things like <b>$LANG</b>, <b>$PATH</b> and <b>$TERM</b>, without you having to specify them again.

       Exported variables can be local or global or universal - "exported" is not a <u>scope</u>!  Usually  you'd  make
       them global via <b>set</b> <b>-gx</b> <b>MyVariable</b> <b>SomeValue</b>.

       For more, see <u>Exporting</u> <u>variables</u>.

</pre><h4><b>LISTS</b></h4><pre>
       The  <b>set</b>  command  above  used  quotes  to ensure that <b>Mister</b> <b>Noodle</b> was one argument. If it had been two
       arguments, then <b>name</b> would have been a list of length 2.  In fact,  all  variables  in  fish  are  really
       lists, that can contain any number of values, or none at all.

       Some  variables,  like <b>$PWD</b>, only have one value. By convention, we talk about that variable's value, but
       we really mean its first (and only) value.

       Other variables, like <b>$PATH</b>, really do have multiple values.  During  variable  expansion,  the  variable
       expands to become multiple arguments:

          &gt; echo $PATH
          <a href="file:/usr/bin">/usr/bin</a> <a href="file:/bin">/bin</a> <a href="file:/usr/sbin">/usr/sbin</a> <a href="file:/sbin">/sbin</a> <a href="file:/usr/local/bin">/usr/local/bin</a>

       Variables  whose  name  ends in "PATH" are automatically split on colons to become lists. They are joined
       using colons when exported to subcommands. This is for compatibility with other tools, which expect $PATH
       to use colons. You can also explicitly add this quirk to a variable with <b>set</b> <b>--path</b>, or  remove  it  with
       <b>set</b> <b>--unpath</b>.

       Lists cannot contain other lists: there is no recursion.  A variable is a list of strings, full stop.

       Get the length of a list with <b>count</b>:

          &gt; count $PATH
          5

       You can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here
       we append <a href="file:/usr/local/bin">/usr/local/bin</a> to $PATH:

          &gt; set PATH $PATH <a href="file:/usr/local/bin">/usr/local/bin</a>

       You  can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1
       from the end:

          &gt; echo $PATH
          <a href="file:/usr/bin">/usr/bin</a> <a href="file:/bin">/bin</a> <a href="file:/usr/sbin">/usr/sbin</a> <a href="file:/sbin">/sbin</a> <a href="file:/usr/local/bin">/usr/local/bin</a>
          &gt; echo $PATH[1]
          <a href="file:/usr/bin">/usr/bin</a>
          &gt; echo $PATH[-1]
          <a href="file:/usr/local/bin">/usr/local/bin</a>

       You can also access ranges of elements, known as "slices":

          &gt; echo $PATH[1..2]
          <a href="file:/usr/bin">/usr/bin</a> <a href="file:/bin">/bin</a>
          &gt; echo $PATH[-1..2]
          <a href="file:/usr/local/bin">/usr/local/bin</a> <a href="file:/sbin">/sbin</a> <a href="file:/usr/sbin">/usr/sbin</a> <a href="file:/bin">/bin</a>

       You can iterate over a list (or a slice) with a for loop:

          for val in $PATH
            echo "entry: $val"
          end
          # Will print:
          # entry: <a href="file:/usr/bin/">/usr/bin/</a>
          # entry: <a href="file:/bin">/bin</a>
          # entry: <a href="file:/usr/sbin">/usr/sbin</a>
          # entry: <a href="file:/sbin">/sbin</a>
          # entry: <a href="file:/usr/local/bin">/usr/local/bin</a>

       One particular bit is that you can use lists like <u>Brace</u> <u>expansion</u>. If you  attach  another  string  to  a
       list, it'll combine every element of the list with the string:

          &gt; set mydirs <a href="file:/usr/bin">/usr/bin</a> <a href="file:/bin">/bin</a>
          &gt; echo $mydirs/fish # this is just like {<a href="file:/usr/bin">/usr/bin</a>,<a href="file:/bin">/bin</a>}/fish
          /usr/bin/fish /bin/fish

       This also means that, if the list is empty, there will be no argument:

          &gt; set empty # no argument
          &gt; echo $empty/this_is_gone # prints an empty line

       If you quote the list, it will be used as one string and so you'll get one argument even if it is empty.

       For  more,  see  <u>Lists</u>.   For  more  on combining lists with strings (or even other lists), see <u>cartesian</u>
       <u>products</u> and <u>Variable</u> <u>expansion</u>.

</pre><h4><b>WILDCARDS</b></h4><pre>
       Fish supports the familiar wildcard <b>*</b>. To list all JPEG files:

          &gt; ls *.jpg
          lena.jpg
          meena.jpg
          santa maria.jpg

       You can include multiple wildcards:

          &gt; ls l*.p*
          lena.png
          lesson.pdf

       The recursive wildcard <b>**</b> searches directories recursively:

          &gt; ls <a href="file:/var/">/var/</a>**.log
          /var/log/system.log
          /var/run/sntp.log

       If that directory traversal is taking a long time, you can <b>ctrl-c</b> out of it.

       For more, see <u>Wildcards</u>.

</pre><h4><b>PIPES</b> <b>AND</b> <b>REDIRECTIONS</b></h4><pre>
       You can pipe between commands with the usual vertical bar:

          &gt; echo hello world | wc
                1       2      12

       stdin and stdout can be redirected via the familiar <b>&lt;</b> and <b>&gt;</b>. stderr is redirected with a <b>2&gt;</b>.

          &gt; grep fish &lt; <a href="file:/etc/shells">/etc/shells</a> &gt; <a href="file:~/output.txt">~/output.txt</a> 2&gt; <a href="file:~/errors.txt">~/errors.txt</a>

       To redirect stdout and stderr into one file, you can use <b>&amp;&gt;</b>:

          &gt; make &amp;&gt; make_output.txt

       For more, see <u>Input</u> <u>and</u> <u>output</u> <u>redirections</u> and <u>Pipes</u>.

</pre><h4><b>COMMAND</b> <b>SUBSTITUTIONS</b></h4><pre>
       Command substitutions use the output of one command as an argument to another. Unlike other shells,  fish
       does  not  use  backticks  ``  for  command substitutions. Instead, it uses parentheses with or without a
       dollar:

          &gt; echo In (pwd), running $(uname)
          In /home/tutorial, running FreeBSD

       A common idiom is to capture the output of a command in a variable:

          &gt; set os (uname)
          &gt; echo $os
          Linux

       Command substitutions without a dollar are not expanded within quotes, so the version with  a  dollar  is
       simpler:

          &gt; touch "testing_$(date +%s).txt"
          &gt; ls *.txt
          testing_1360099791.txt

       Unlike  other  shells, fish does not split command substitutions on any whitespace (like spaces or tabs),
       only newlines. Usually this is a big  help  because  unix  commands  operate  on  a  line-by-line  basis.
       Sometimes  it  can  be  an  issue  with  commands like <b>pkg-config</b> that print what is meant to be multiple
       arguments on a single line. To split it on spaces too, use <b>string</b> <b>split</b>.

          &gt; printf '%s\n' (pkg-config --libs gio-2.0)
          -lgio-2.0 -lgobject-2.0 -lglib-2.0
          &gt; printf '%s\n' (pkg-config --libs gio-2.0 | string split -n " ")
          -lgio-2.0
          -lgobject-2.0
          -lglib-2.0

       If you need a command substitutions output as one  argument,  without  any  splits,  use  quoted  command
       substitution:

          &gt; echo "first line
          second line" &gt; myfile
          &gt; set myfile "$(cat myfile)"
          &gt; printf '|%s|' $myfile
          |first line
          second line|

       For more, see <u>Command</u> <u>substitution</u>.

</pre><h4><b>SEPARATING</b> <b>COMMANDS</b> <b>(SEMICOLON)</b></h4><pre>
       Like other shells, fish allows multiple commands either on separate lines or the same line.

       To  write  them  on  the  same  line,  use the semicolon (";"). That means the following two examples are
       equivalent:

          echo fish; echo chips

          # or
          echo fish
          echo chips

       This is useful interactively to enter multiple commands. In a script it's easier to read if the  commands
       are on separate lines.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       When a command exits, it returns a status code as a non-negative integer (that's a whole number &gt;= 0).

       Unlike other shells, fish stores the exit status of the last command in <b>$status</b> instead of <b>$?</b>.

          &gt; false
          &gt; echo $status
          1

       This  indicates  how  the  command  fared  -  0  usually means success, while the others signify kinds of
       failure. For instance fish's <b>set</b> <b>--query</b> returns the number of variables it queried that  weren't  set  -
       <b>set</b> <b>--query</b> <b>PATH</b> usually returns 0, <b>set</b> <b>--query</b> <b>arglbargl</b> <b>boogagoogoo</b> usually returns 2.

       There is also a <b>$pipestatus</b> list variable for the exit statuses [1] of processes in a pipe.

       For more, see <u>The</u> <u>status</u> <u>variable</u>.

       [1]  or  "stati" if you prefer, or "statūs" if you've time-travelled from ancient Rome or work as a latin
            teacher

</pre><h4><b>COMBINERS</b> <b>(AND,</b> <b>OR,</b> <b>NOT)</b></h4><pre>
       fish supports the familiar <b>&amp;&amp;</b> and <b>||</b> to combine commands, and <b>!</b> to negate them:

          &gt; ./configure &amp;&amp; make &amp;&amp; sudo make install

       Here, <b>make</b> is only executed if <b>./configure</b> succeeds (returns 0), and <b>sudo</b> <b>make</b> <b>install</b> is  only  executed
       if both <b>./configure</b> and <b>make</b> succeed.

       fish  also  supports <u>and</u>, <u>or</u>, and <u>not</u>. The first two are job modifiers and have lower precedence. Example
       usage:

          &gt; cp file1 file1_bak &amp;&amp; cp file2 file2_bak; and echo "Backup successful"; or echo "Backup failed"
          Backup failed

       As mentioned in <u>the</u> <u>section</u> <u>on</u> <u>the</u> <u>semicolon</u>, this can also be written in multiple lines, like so:

          cp file1 file1_bak &amp;&amp; cp file2 file2_bak
          and echo "Backup successful"
          or echo "Backup failed"

</pre><h4><b>CONDITIONALS</b> <b>(IF,</b> <b>ELSE,</b> <b>SWITCH)</b></h4><pre>
       Use <u>if</u> and <u>else</u> to conditionally execute code, based on the exit status of a command.

          if grep fish <a href="file:/etc/shells">/etc/shells</a>
              echo Found fish
          else if grep bash <a href="file:/etc/shells">/etc/shells</a>
              echo Found bash
          else
              echo Got nothing
          end

       To compare strings or numbers or check file properties (whether a file exists or is writeable and  such),
       use <u>test</u>, like

          if test "$fish" = "flounder"
              echo FLOUNDER
          end

          # or

          if test "$number" -gt 5
              echo $number is greater than five
          else
              echo $number is five or less
          end

          # or

          # This test is true if the path <a href="file:/etc/hosts">/etc/hosts</a> exists
          # - it could be a file or directory or symlink (or possibly something else).
          if test -e <a href="file:/etc/hosts">/etc/hosts</a>
              echo We most likely have a hosts file
          else
              echo We do not have a hosts file
          end

       <u>Combiners</u> can also be used to make more complex conditions, like

          if command -sq fish; and grep fish <a href="file:/etc/shells">/etc/shells</a>
              echo fish is installed and configured
          end

       For even more complex conditions, use <u>begin</u> and <u>end</u> to group parts of them.

       There is also a <u>switch</u> command:

          switch (uname)
          case Linux
              echo Hi Tux!
          case Darwin
              echo Hi Hexley!
          case FreeBSD NetBSD DragonFly
              echo Hi Beastie!
          case '*'
              echo Hi, stranger!
          end

       As you see, <u>case</u> does not fall through, and can accept multiple arguments or (quoted) wildcards.

       For more, see <u>Conditions</u>.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       A  fish  function  is  a  list  of  commands,  which  may optionally take arguments. Unlike other shells,
       arguments are not passed in "numbered variables" like <b>$1</b>, but instead in a single list <b>$argv</b>. To create a
       function, use the <u>function</u> builtin:

          function say_hello
              echo Hello $argv
          end
          say_hello
          # prints: Hello
          say_hello everybody!
          # prints: Hello everybody!

       Unlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [2]

       You can list the names of all functions with the <u>functions</u> builtin (note the plural!).  fish  starts  out
       with a number of functions:

          &gt; functions
          N_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait

       You can see the source for any function by passing its name to <b>functions</b>:

          &gt; functions ls
          function ls --description 'List contents of directory'
              command ls -G $argv
          end

       For more, see <u>Functions</u>.

       [2]  There  is  a  function  called <u>alias</u>, but it's just a shortcut to make functions. fish also provides
            <u>abbreviations</u>, through the <u>abbr</u> command.

</pre><h4><b>LOOPS</b></h4><pre>
       While loops:

          while true
              echo "Loop forever"
          end
          # Prints:
          # Loop forever
          # Loop forever
          # Loop forever
          # yes, this really will loop forever. Unless you abort it with ctrl-c.

       For loops can be used to iterate over a list. For example, a list of files:

          for file in *.txt
              cp $file $file.bak
          end

       Iterating over a list of numbers can be done with <b>seq</b>:

          for x in (seq 5)
              touch file_$x.txt
          end

       For more, see <u>Loops</u> <u>and</u> <u>blocks</u>.

</pre><h4><b>PROMPT</b></h4><pre>
       Unlike other shells, there is no prompt variable like <b>PS1</b>. To display  your  prompt,  fish  executes  the
       <u>fish_prompt</u>  function  and  uses  its  output  as  the  prompt.  And if it exists, fish also executes the
       <u>fish_right_prompt</u> function and uses its output as the right prompt.

       You can define your own prompt from the command line:

          &gt; function fish_prompt; echo "New Prompt % "; end
          New Prompt % _

       Then, if you are happy with it, you can save it to disk by typing <b>funcsave</b> <b>fish_prompt</b>.  This  saves  the
       prompt  in <b><a href="file:~/.config/fish/functions/fish_prompt.fish">~/.config/fish/functions/fish_prompt.fish</a></b>. (Or, if you want, you can create that file manually
       from the start.)

       Multiple lines are OK. Colors can be set via <u>set_color</u>, passing it named ANSI colors, or hex RGB values:

          function fish_prompt
              set_color purple
              date "+%m/%d/%y"
              set_color F00
              echo (pwd) '&gt;' (set_color normal)
          end

       This prompt would look like:

          02/06/13
          /home/tutorial &gt; _

       You can choose among some sample prompts by running <b>fish_config</b> for a web UI or <b>fish_config</b> <b>prompt</b> for  a
       simpler version inside your terminal.

</pre><h4><b>$PATH</b></h4><pre>
       <b>$PATH</b> is an environment variable containing the directories that fish searches for commands. Unlike other
       shells, $PATH is a <u>list</u>, not a colon-delimited string.

       Fish  takes care to set <b>$PATH</b> to a default, but typically it is just inherited from fish's parent process
       and is set to a value that makes sense for the system - see <u>Exports</u>.

       To prepend <a href="file:/usr/local/bin">/usr/local/bin</a> and <a href="file:/usr/sbin">/usr/sbin</a> to <b>$PATH</b>, you can write:

          &gt; set PATH <a href="file:/usr/local/bin">/usr/local/bin</a> <a href="file:/usr/sbin">/usr/sbin</a> $PATH

       To remove <a href="file:/usr/local/bin">/usr/local/bin</a> from <b>$PATH</b>, you can write:

          &gt; set PATH (string match -v <a href="file:/usr/local/bin">/usr/local/bin</a> $PATH)

       For compatibility with other shells and external commands, $PATH is a  <u>path</u>  <u>variable</u>,  and  so  will  be
       joined with colons (not spaces) when you quote it:

          &gt; echo "$PATH"
          <a href="file:/usr/local/sbin">/usr/local/sbin</a>:<a href="file:/usr/local/bin">/usr/local/bin</a>:<a href="file:/usr/bin">/usr/bin</a>

       and  it  will  be exported like that, and when fish starts it splits the $PATH it receives into a list on
       colon.

       You can do so directly in <b>config.fish</b>, like you might do in other shells with <b>.profile</b>. See <u>this</u> <u>example</u>.

       A faster way is to use the <u>fish_add_path</u> function, which adds given  directories  to  the  path  if  they
       aren't  already  included.  It  does  this by modifying the <b>$fish_user_paths</b> <u>universal</u> <u>variable</u>, which is
       automatically prepended to <b>$PATH</b>. For example, to permanently add <b><a href="file:/usr/local/bin">/usr/local/bin</a></b> to your <b>$PATH</b>, you could
       write:

          &gt; fish_add_path <a href="file:/usr/local/bin">/usr/local/bin</a>

       The advantage is that you don't have to go mucking around in files: just run this  once  at  the  command
       line,  and it will affect the current session and all future instances too. You can also add this line to
       <u>config.fish</u>, as it only adds the component if necessary.

       Or  you  can  modify  $fish_user_paths  yourself,  but  you  should  be  careful  <u>not</u>  to  append  to  it
       unconditionally in config.fish, or it will grow longer and longer.

</pre><h4><b>STARTUP</b> <b>(WHERE'S</b> <b>.BASHRC?)</b></h4><pre>
       Fish starts by executing commands in <b><a href="file:~/.config/fish/config.fish">~/.config/fish/config.fish</a></b>. You can create it if it does not exist.

       It  is  possible to directly create functions and variables in <b>config.fish</b> file, using the commands shown
       above. For example:

          &gt; cat <a href="file:~/.config/fish/config.fish">~/.config/fish/config.fish</a>

          set -x PATH $PATH <a href="file:/sbin/">/sbin/</a>

          function ll
              ls -lh $argv
          end

       However, it is more common and efficient to use  autoloading functions and universal variables.

       If  you  want  to  organize  your  configuration,  fish  also  reads   commands   in   .fish   files   in
       <b><a href="file:~/.config/fish/conf.d/">~/.config/fish/conf.d/</a></b>. See <u>Configuration</u> <u>Files</u> for the details.

</pre><h4><b>AUTOLOADING</b> <b>FUNCTIONS</b></h4><pre>
       When  fish  encounters  a  command, it attempts to autoload a function for that command, by looking for a
       file with the name of that command in <b><a href="file:~/.config/fish/functions/">~/.config/fish/functions/</a></b>.

       For  example,  if  you  wanted  to  have  a  function  <b>ll</b>,  you  would  add  a  text  file   <b>ll.fish</b>   to
       <b><a href="file:~/.config/fish/functions">~/.config/fish/functions</a></b>:

          &gt; cat <a href="file:~/.config/fish/functions/ll.fish">~/.config/fish/functions/ll.fish</a>
          function ll
              ls -lh $argv
          end

       This is the preferred way to define your prompt as well:

          &gt; cat <a href="file:~/.config/fish/functions/fish_prompt.fish">~/.config/fish/functions/fish_prompt.fish</a>
          function fish_prompt
              echo (pwd) "&gt; "
          end

       See  the  documentation  for  <u>funced</u>  and  <u>funcsave</u>  for  ways  to  create these files automatically, and
       <u>$fish_function_path</u> to control their location.

</pre><h4><b>UNIVERSAL</b> <b>VARIABLES</b></h4><pre>
       A universal variable is a variable whose value is shared across all instances of fish,  now  and  in  the
       future – even after a reboot. You can make a variable universal with <b>set</b> <b>-U</b>:

          &gt; set -U EDITOR vim

       Now in another shell:

          &gt; echo $EDITOR
          vim

       You  only need to set universal variables once interactively. There is no need to add them to your <u>config</u>
       <u>files</u>. For more details, see <u>Universal</u> <u>Variables</u>.

</pre><h4><b>READY</b> <b>FOR</b> <b>MORE?</b></h4><pre>
       If you want to learn more about fish, there is  <u>lots</u>  <u>of</u>  <u>detailed</u>  <u>documentation</u>,  the  <u>official</u>  <u>gitter</u>
       <u>channel</u>       &lt;<b>https://gitter.im/fish-shell/fish-shell</b>&gt;,       an       <u>official</u>       <u>mailing</u>       <u>list</u>
       &lt;<b>https://lists.sourceforge.net/lists/listinfo/fish-users</b>&gt;, and the <u>github</u> <u>page</u>  &lt;<b>https://github.com/fish-</b>
       <b>shell/fish-shell/</b>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       fish-shell developers

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2024, fish-shell developers

4.0                                               Mar 13, 2025                                  <u><a href="../man1/FISH-TUTORIAL.1.html">FISH-TUTORIAL</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>