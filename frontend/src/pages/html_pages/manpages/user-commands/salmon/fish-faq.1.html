<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>See Fish for bash users</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/fish-common">fish-common_4.0.1-1_all</a> <br><br><pre>
</pre><h4><b>WHAT</b> <b>IS</b> <b>THE</b> <b>EQUIVALENT</b> <b>TO</b> <b>THIS</b> <b>THING</b> <b>FROM</b> <b>BASH</b> <b>(OR</b> <b>OTHER</b> <b>SHELLS)?</b></h4><pre>
       See <u>Fish</u> <u>for</u> <u>bash</u> <u>users</u>

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>SET</b> <b>OR</b> <b>CLEAR</b> <b>AN</b> <b>ENVIRONMENT</b> <b>VARIABLE?</b></h4><pre>
       Use the <u>set</u> command:

          set -x key value # typically set -gx key value
          set -e key

       Since  fish 3.1 you can set an environment variable for just one command using the <b>key=value</b> <b>some</b> <b>command</b>
       syntax, like in other shells.  The two lines below behave identically - unlike other  shells,  fish  will
       output <b>value</b> both times:

          key=value echo $key
          begin; set -lx key value; echo $key; end

       Note  that  "exported"  is  not  a  <u>scope</u>,  but  an additional bit of state. A variable can be global and
       exported or local and exported or even universal and exported.  Typically  it  makes  sense  to  make  an
       exported variable global.

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>CHECK</b> <b>WHETHER</b> <b>A</b> <b>VARIABLE</b> <b>IS</b> <b>DEFINED?</b></h4><pre>
       Use <b>set</b> <b>-q</b> <b>var</b>.  For example, <b>if</b> <b>set</b> <b>-q</b> <b>var;</b> <b>echo</b> <b>variable</b> <b>defined;</b> <b>end</b>.  To check multiple variables you
       can combine with <b>and</b> and <b>or</b> like so:

          if set -q var1; or set -q var2
              echo either variable defined
          end

       Keep  in  mind that a defined variable could also be empty, either by having no elements (if set like <b>set</b>
       <b>var</b>) or only empty elements (if set like <b>set</b> <b>var</b> <b>""</b>). Read on for how to deal with those.

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>CHECK</b> <b>WHETHER</b> <b>A</b> <b>VARIABLE</b> <b>IS</b> <b>NOT</b> <b>EMPTY?</b></h4><pre>
       Use <b>string</b> <b>length</b> <b>-q</b> <b>--</b> <b>$var</b>.  For example, <b>if</b> <b>string</b> <b>length</b> <b>-q</b> <b>--</b> <b>$var;</b> <b>echo</b> <b>not</b> <b>empty;</b> <b>end</b>.  Note  that
       <b>string</b> <b>length</b> will interpret a list of multiple variables as a disjunction (meaning any/or):

          if string length -q -- $var1 $var2 $var3
              echo at least one of these variables is not empty
          end

       Alternatively, use <b>test</b> <b>-n</b> <b>"$var"</b>, but remember that <b>the</b> <b>variable</b> <b>must</b> <b>be</b> <b>double-quoted</b>.  For example, <b>if</b>
       <b>test</b> <b>-n</b> <b>"$var";</b> <b>echo</b> <b>not</b> <b>empty;</b> <b>end</b>. The <b>test</b> command provides its own and (-a) and or (-o):

          if test -n "$var1" -o -n "$var2" -o -n "$var3"
              echo at least one of these variables is not empty
          end

       If you want to know if a variable has <u>no</u> <u>elements</u>, use <b>set</b> <b>-q</b> <b>var[1]</b>.

</pre><h4><b>WHY</b> <b>DOESN'T</b> <b>SET</b> <b>-UX</b> <b>(EXPORTED</b> <b>UNIVERSAL</b> <b>VARIABLES)</b> <b>SEEM</b> <b>TO</b> <b>WORK?</b></h4><pre>
       A global variable of the same name already exists.

       Environment variables such as <b>EDITOR</b> or <b>TZ</b> can be set universally using <b>set</b> <b>-Ux</b>.  However, if there is an
       environment  variable already set before fish starts (such as by login scripts or system administrators),
       it is imported into fish as a global variable. The <u>variable</u> <u>scopes</u> are searched from  the  "inside  out",
       which  means  that local variables are checked first, followed by global variables, and finally universal
       variables.

       This means that the global value takes precedence over the universal value.

       To avoid this problem, consider changing the setting which fish inherits. If this is not possible, add  a
       statement to your <u>configuration</u> <u>file</u> (usually <b><a href="file:~/.config/fish/config.fish">~/.config/fish/config.fish</a></b>):

          set -gx EDITOR vim

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>RUN</b> <b>A</b> <b>COMMAND</b> <b>EVERY</b> <b>LOGIN?</b> <b>WHAT'S</b> <b>FISH'S</b> <b>EQUIVALENT</b> <b>TO</b> <b>.BASHRC</b> <b>OR</b> <b>.PROFILE?</b></h4><pre>
       Edit the file <b><a href="file:~/.config/fish/config.fish">~/.config/fish/config.fish</a></b> [1], creating it if it does not exist (Note the leading period).

       Unlike .bashrc and .profile, this file is always read, even in non-interactive or login shells.

       To do something only in interactive shells, check <b>status</b> <b>is-interactive</b> like:

          if status is-interactive
              # use the coolbeans theme
              fish_config theme choose coolbeans
          end

       [1]  The "<a href="file:~/.config">~/.config</a>" part of this can be set via $XDG_CONFIG_HOME, that's just the default.

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>SET</b> <b>MY</b> <b>PROMPT?</b></h4><pre>
       The     prompt     is     the     output     of     the     <b>fish_prompt</b>     function.     Put    it    in
       <b><a href="file:~/.config/fish/functions/fish_prompt.fish">~/.config/fish/functions/fish_prompt.fish</a></b>. For example, a simple prompt is:

          function fish_prompt
              set_color $fish_color_cwd
              echo -n (prompt_pwd)
              set_color normal
              echo -n ' &gt; '
          end

       You can also use the Web configuration tool, <u>fish_config</u>, to preview and choose from a gallery of  sample
       prompts.

       Or you can use fish_config from the commandline:

          &gt; fish_config prompt show
          # displays all the prompts fish ships with
          &gt; fish_config prompt choose disco
          # loads the disco prompt in the current shell
          &gt; fish_config prompt save
          # makes the change permanent

       If you want to modify your existing prompt, you can use <u>funced</u> and <u>funcsave</u> like:

          &gt;_ funced fish_prompt
          # This opens up your editor (set in $EDITOR).
          # Modify the function,
          # save the file and repeat to your liking.
          # Once you are happy with it:
          &gt;_ funcsave fish_prompt

       This also applies to <u>fish_right_prompt</u> and <u>fish_mode_prompt</u>.

</pre><h4><b>WHY</b> <b>DOES</b> <b>MY</b> <b>PROMPT</b> <b>SHOW</b> <b>A</b> <b>[I]?</b></h4><pre>
       That's   the  <u>fish_mode_prompt</u>.  It  is  displayed  by  default  when  you've  activated  vi  mode  using
       <b>fish_vi_key_bindings</b>.

       If you haven't activated vi mode on purpose, you might have installed a third-party theme or plugin  that
       does it.

       If  you  want  to  change or disable this display, modify the <b>fish_mode_prompt</b> function, for instance via
       <u>funced</u>.

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>CUSTOMIZE</b> <b>MY</b> <b>SYNTAX</b> <b>HIGHLIGHTING</b> <b>COLORS?</b></h4><pre>
       Use the web configuration tool, <u>fish_config</u>, or alter the <u>fish_color</u> <u>family</u> <u>of</u> <u>environment</u> <u>variables</u>.

       You can also use <b>fish_config</b> on the commandline, like:

          &gt; fish_config theme show
          # to demonstrate all the colorschemes
          &gt; fish_config theme choose coolbeans
          # to load the "coolbeans" theme
          &gt; fish_config theme save
          # to make the change permanent

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>CHANGE</b> <b>THE</b> <b>GREETING</b> <b>MESSAGE?</b></h4><pre>
       Change the value of the variable <b>fish_greeting</b> or create a <u>fish_greeting</u> function. For example, to remove
       the greeting use:

          set -U fish_greeting

       Or if you prefer not to use a universal variable, use:

          set -g fish_greeting

       in <u>config.fish</u>.

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>RUN</b> <b>A</b> <b>COMMAND</b> <b>FROM</b> <b>HISTORY?</b></h4><pre>
       Type some part of the command, and then hit the <b>up</b> (<b>↑</b>) or <b>down</b> (<b>↓</b>) arrow keys to navigate through history
       matches, or press <b>ctrl-r</b> to open the history in a searchable pager. In this pager you can press <b>ctrl-r</b> or
       <b>ctrl-s</b> to move to older or younger history respectively.

       Additional default key bindings include <b>ctrl-p</b> (up) and <b>ctrl-n</b> (down). See <u>Searchable</u> <u>command</u> <u>history</u> for
       more information.

</pre><h4><b>WHY</b> <b>DOESN'T</b> <b>HISTORY</b> <b>SUBSTITUTION</b> <b>("!$"</b> <b>ETC.)</b> <b>WORK?</b></h4><pre>
       Because history substitution is an awkward interface that was invented before  interactive  line  editing
       was  even possible. Instead of adding this pseudo-syntax, fish opts for nice history searching and recall
       features.  Switching requires a small change of habits: if you want to modify  an  old  line/word,  first
       recall it, then edit.

       As  a  special  case,  most  of the time history substitution is used as <b>sudo</b> <b>!!</b>. In that case just press
       <b>alt-s</b>, and it will recall your last commandline with <b>sudo</b> prefixed  (or  toggle  a  <b>sudo</b>  prefix  on  the
       current commandline if there is anything).

       In general, fish's history recall works like this:

       • Like  other  shells,  the  Up  arrow,  <b>up</b> recalls whole lines, starting from the last executed line. So
         instead of typing <b>!!</b>, you would just hit the up-arrow.

       • If the line you want is far back in the history, type any part of the line and then  press  Up  one  or
         more  times.   This  will filter the recalled lines to ones that include this text, and you will get to
         the line you want much faster.  This replaces "!vi", "!?bar.c" and the like. If you want  to  see  more
         context, you can press <b>ctrl-r</b> to open the history in the pager.

       • <b>alt-up</b>  recalls  individual  arguments, starting from the last argument in the last executed line. This
         can be used instead of "!$".

       See <u>documentation</u> for more details about line editing in fish.

       That being said, you can use <u>Abbreviations</u> to implement history substitution. Here's just <b>!!</b>:

          function last_history_item; echo $history[1]; end
          abbr -a !! --position anywhere --function last_history_item

       Run this and <b>!!</b> will be replaced with the last history entry, anywhere on the commandline.  Put  it  into
       <u>config.fish</u> to keep it.

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>RUN</b> <b>A</b> <b>SUBCOMMAND?</b> <b>THE</b> <b>BACKTICK</b> <b>DOESN'T</b> <b>WORK!</b></h4><pre>
       <b>fish</b> uses parentheses for subcommands. For example:

          for i in (ls)
              echo $i
          end

       It  also  supports  the familiar <b>$()</b> syntax, even in quotes. Backticks are not supported because they are
       discouraged even in POSIX shells. They nest poorly and are hard to tell from single quotes (<b>''</b>).

</pre><h4><b>MY</b> <b>COMMAND</b> <b>(PKG-CONFIG)</b> <b>GIVES</b> <b>ITS</b> <b>OUTPUT</b> <b>AS</b> <b>A</b> <b>SINGLE</b> <b>LONG</b> <b>STRING?</b></h4><pre>
       Unlike other shells, fish splits command substitutions only on  newlines,  not  spaces  or  tabs  or  the
       characters in $IFS.

       That means if you run

          count (printf '%s ' a b c)

       It will print <b>1</b>, because the "a b c " is used in one piece. But if you do

          count (printf '%s\n' a b c)

       it will print <b>3</b>, because it gave <b>count</b> the arguments "a", "b" and "c" separately.

       In  the  overwhelming majority of cases, splitting on spaces is unwanted, so this is an improvement. This
       is why you hear about problems with filenames with spaces, after all.

       However sometimes, especially with <b>pkg-config</b> and related tools, splitting on spaces is needed.

       In these cases use <b>string</b> <b>split</b> <b>-n</b> <b>"</b> <b>"</b> like:

          g++ example_01.cpp (pkg-config --cflags --libs gtk+-2.0 | string split -n " ")

       The <b>-n</b> is so empty elements are removed like POSIX shells would do.

</pre><h4><b>HOW</b> <b>DO</b> <b>I</b> <b>GET</b> <b>THE</b> <b>EXIT</b> <b>STATUS</b> <b>OF</b> <b>A</b> <b>COMMAND?</b></h4><pre>
       Use the <b>$status</b> variable. This replaces the <b>$?</b> variable used in other shells.

          somecommand
          if test $status -eq 7
              echo "That's my lucky number!"
          end

       If you are just interested in success or failure, you can run the command directly as the if-condition:

          if somecommand
              echo "Command succeeded"
          else
              echo "Command failed"
          end

       Or if you just want to do one command in case the first succeeded or failed, use <b>and</b> or <b>or</b>:

          somecommand
          or someothercommand

       See the <u>Conditions</u> and the documentation for <u>test</u> and <u>if</u> for more information.

</pre><h4><b>MY</b> <b>COMMAND</b> <b>PRINTS</b> <b>NO</b> <b>MATCHES</b> <b>FOR</b> <b>WILDCARD</b> <b>BUT</b> <b>WORKS</b> <b>IN</b> <b>BASH</b></h4><pre>
       In short: <u>quote</u> or <u>escape</u> the wildcard:

          scp user@ip:/dir/"string-*"

       When fish sees an unquoted <b>*</b>, it performs <u>wildcard</u> <u>expansion</u>. That means it tries to match  filenames  to
       the given string.

       If the wildcard doesn't match any files, fish prints an error instead of running the command:

          &gt; echo *this*does*not*exist
          fish: No matches for wildcard '*this*does*not*exist'. See `help expand`.
          echo *this*does*not*exist
               ^

       Now,  bash  also tries to match files in this case, but when it doesn't find a match, it passes along the
       literal wildcard string instead.

       That means that commands like the above

          scp user@ip:/dir/string-*

       or

          apt install postgres-*

       appear to work, because most of the time the string doesn't match and so it passes  along  the  <b>string-*</b>,
       which is then interpreted by the receiving program.

       But  it also means that these commands can stop working at any moment once a matching file is encountered
       (because it has been created or the command is executed in a different working directory),  and  to  deal
       with that bash needs workarounds like

          for f in ./*.mpg; do
                # We need to test if the file really exists because
                # the wildcard might have failed to match.
                test -f "$f" || continue
                mympgviewer "$f"
          done

       (from <u><a href="http://mywiki.wooledge.org/BashFAQ/004">http://mywiki.wooledge.org/BashFAQ/004</a></u>)

       For  these  reasons, fish does not do this, and instead expects asterisks to be quoted or escaped if they
       aren't supposed to be expanded.

       This is similar to bash's "failglob" option.

</pre><h4><b>WHY</b> <b>WON'T</b> <b>SSH/SCP/RSYNC</b> <b>CONNECT</b> <b>PROPERLY</b> <b>WHEN</b> <b>FISH</b> <b>IS</b> <b>MY</b> <b>LOGIN</b> <b>SHELL?</b></h4><pre>
       This problem may show up as messages like "<b>Received</b> <b>message</b> <b>too</b>  <b>long</b>",  "<b>open</b>  <b>terminal</b>  <b>failed:</b>  <b>not</b>  <b>a</b>
       <b>terminal</b>",    "<b>Bad</b>    <b>packet</b>    <b>length</b>",    or    "<b>Connection</b>    <b>refused</b>"    with   strange   output   in
       <b>ssh_exchange_identification</b> messages in the debug log.

       This usually happens because fish reads the <u>user</u> <u>configuration</u> <u>file</u> (<b><a href="file:~/.config/fish/config.fish">~/.config/fish/config.fish</a></b>)  <u>always</u>,
       whether it's in an interactive or login or non-interactive or non-login shell.

       This  simplifies  matters,  but  it also means when config.fish generates output, it will do that even in
       non-interactive shells like the one ssh/scp/rsync start when they connect.

       Anything in config.fish that produces output should be guarded  with  <b>status</b>  <b>is-interactive</b>  (or  <b>status</b>
       <b>is-login</b> if you prefer):

          if status is-interactive
            ...
          end

       The  same  applies  for  example  when  you  start <b>tmux</b> in config.fish without guards, which will cause a
       message like <b>sessions</b> <b>should</b> <b>be</b> <b>nested</b> <b>with</b> <b>care,</b> <b>unset</b> <b>$TMUX</b> <b>to</b> <b>force</b>.

</pre><h4><b>I'M</b> <b>GETTING</b> <b>WEIRD</b> <b>GRAPHICAL</b> <b>GLITCHES</b> <b>(A</b> <b>STAIRCASE</b> <b>EFFECT,</b> <b>GHOST</b> <b>CHARACTERS,</b> <b>CURSOR</b> <b>IN</b> <b>THE</b> <b>WRONG</b> <b>POSITION,...)?</b></h4><pre>
       In a terminal, the application running inside it and the terminal itself need to agree on  the  width  of
       characters in order to handle cursor movement.

       This  is  more  important  to  fish  than  other  shells  because  features  like syntax highlighting and
       autosuggestions are implemented by moving the cursor.

       Sometimes, there is disagreement on the width. There are numerous causes and fixes for this:

       • It is possible the character is simply too new for your system to know -  in  this  case  you  need  to
         refrain from using it.

       • Fish or your terminal might not know about the character or handle it wrong - in this case fish or your
         terminal needs to be fixed, or you need to update to a fixed version.

       • The  character  has  an  "ambiguous"  width and fish thinks that means a width of X while your terminal
         thinks it's Y.  In  this  case  you  either  need  to  change  your  terminal's  configuration  or  set
         $fish_ambiguous_width to the correct value.

       • The  character  is  an  emoji  and  the  host system only supports Unicode 8, while you are running the
         terminal on a system that uses Unicode &gt;= 9. In this case set $fish_emoji_width to 2.

       This also means that a few things are unsupportable:

       • Non-monospace fonts - there is <u>no</u> <u>way</u> for fish to figure out what width a specific character has as  it
         has no influence on the terminal's font rendering.

       • Different widths for multiple ambiguous width characters - there is no way for fish to know which width
         you assign to each character.

</pre><h4><b>UNINSTALLING</b> <b>FISH</b></h4><pre>
       If  you  want  to uninstall fish, first make sure fish is not set as your shell. Run <b>chsh</b> <b>-s</b> <b><a href="file:/bin/bash">/bin/bash</a></b> if
       you are not sure.

       If you installed it with a package manager, just use that package manager's uninstall  function.  If  you
       built fish yourself, assuming you installed it to <a href="file:/usr/local">/usr/local</a>, do this:

          rm -Rf /usr/local/etc/fish /usr/local/share/fish <a href="file:~/.config/fish">~/.config/fish</a>
          rm /usr/local/share/man/man1/fish*.1
          cd <a href="file:/usr/local/bin">/usr/local/bin</a>
          rm -f fish fish_indent

</pre><h4><b>AUTHOR</b></h4><pre>
       fish-shell developers

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2024, fish-shell developers

4.0                                               Mar 13, 2025                                       <u><a href="../man1/FISH-FAQ.1.html">FISH-FAQ</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>