<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pairtools - pairtools Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/python3-pairtools">python3-pairtools_0.3.0-3.2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pairtools - pairtools Documentation

       <u>pairtools</u>  is a simple and fast command-line framework to process sequencing data from a Hi-C experiment.
       <u>pairtools</u> perform various operations on Hi-C pairs and occupy the middle position in a typical Hi-C  data
       processing pipeline:
         [image: The diagram of a typical processing pipeline for Hi-C data] [image] In a typical Hi-C pipeline,
         DNA  sequences  (reads)  are  aligned  to  the  reference genome, converted into ligation junctions and
         binned, thus producing a Hi-C contact map..UNINDENT

         <u>pairtools</u> aim to be an all-in-one tool for processing Hi-C pairs, and can perform following operations:

       • detect ligation junctions (a.k.a. Hi-C pairs) in aligned paired-end sequences of Hi-C DNA molecules

       • sort .pairs files for downstream analyses

       • detect, tag and remove PCR/optical duplicates

       • generate extensive statistics of Hi-C datasets

       • select Hi-C pairs given flexibly defined criteria

       • restore .sam alignments from Hi-C pairs

       <u>pairtools</u> produce .pairs files compliant with the <u>4DN</u> <u>standard</u>.

       The full list of available pairtools:
                               ┌─────────────┬───────────────────────────────────────┐
                               │ Pairtool    │ Description                           │
                               ├─────────────┼───────────────────────────────────────┤
                               │ dedup       │ Find    and    remove     PCR/optical │
                               │             │ duplicates.                           │
                               ├─────────────┼───────────────────────────────────────┤
                               │ filterbycov │ Remove  pairs  from  regions  of high │
                               │             │ coverage.                             │
                               ├─────────────┼───────────────────────────────────────┤
                               │ flip        │ Flip pairs to get an upper-triangular │
                               │             │ matrix.                               │
                               ├─────────────┼───────────────────────────────────────┤
                               │ markasdup   │ Tag pairs as duplicates.              │
                               ├─────────────┼───────────────────────────────────────┤
                               │ merge       │ Merge sorted .pairs/.pairsam files.   │
                               ├─────────────┼───────────────────────────────────────┤
                               │ parse       │ Find ligation junctions in .sam, make │
                               │             │ .pairs.                               │
                               ├─────────────┼───────────────────────────────────────┤
                               │ phase       │ Phase  pairs  mapped  to  a   diploid │
                               │             │ genome.                               │
                               ├─────────────┼───────────────────────────────────────┤
                               │ restrict    │ Assign   restriction   fragments   to │
                               │             │ pairs.                                │
                               ├─────────────┼───────────────────────────────────────┤
                               │ select      │ Select  pairs   according   to   some │
                               │             │ condition.                            │
                               ├─────────────┼───────────────────────────────────────┤
                               │ sort        │ Sort a .pairs/.pairsam file.          │
                               ├─────────────┼───────────────────────────────────────┤
                               │ split       │ Split a .pairsam file into .pairs and │
                               │             │ .sam.                                 │
                               ├─────────────┼───────────────────────────────────────┤
                               │ stats       │ Calculate pairs statistics.           │
                               └─────────────┴───────────────────────────────────────┘

       Contents:

</pre><h4><b>QUICKSTART</b></h4><pre>
       Install  <u>pairtools</u>  and  all of its dependencies using the <u>conda</u> package manager and the <u>bioconda</u> channel
       for bioinformatics software.

          $ conda install -c conda-forge -c bioconda pairtools

       Setup a new test folder and download a small Hi-C dataset mapped to sacCer3 genome:

          $ mkdir /tmp/test-pairtools
          $ cd /tmp/test-pairtools
          $ wget https://github.com/mirnylab/distiller-test-data/raw/master/bam/MATalpha_R1.bam

       Additionally, we will need a .chromsizes file, a TAB-separated plain text  table  describing  the  names,
       sizes and the order of chromosomes in the genome assembly used during mapping:

          $ wget https://raw.githubusercontent.com/mirnylab/distiller-test-data/master/genome/sacCer3.reduced.chrom.sizes

       With  <u>pairtools</u>  <u>parse</u>,  we  can  convert  paired-end sequence alignments stored in .sam/.bam format into
       .pairs, a TAB-separated table of Hi-C ligation junctions:

          $ pairtools parse -c sacCer3.reduced.chrom.sizes -o MATalpha_R1.pairs.gz --drop-sam MATalpha_R1.bam

       Inspect the resulting table:

          $ less MATalpha_R1.pairs.gz

</pre><h4><b>INSTALLATION</b></h4><pre>
   <b>Requirements</b>
       • Python 3.x

       • Python packages <u>numpy</u> and <u>click</u>

       • Command-line utilities <u>sort</u> (the Unix version), <u>bgzip</u> (shipped with <u>tabix</u>) and <u>samtools</u>. If  available,
         <u>pairtools</u> can compress outputs with <u>pbgzip</u> and <u>lz4</u>.

   <b>Install</b> <b>using</b> <b>conda</b>
       We  highly  recommend using the <u>conda</u> package manager to install pre-compiled <u>pairtools</u> together with all
       its dependencies. To get it, you can either install the full <u>Anaconda</u> Python  distribution  or  just  the
       standalone <u>conda</u> package manager.

       With <u>conda</u>, you can install pre-compiled <u>pairtools</u> and all of its dependencies from the <u>bioconda</u> channel:

          $ conda install -c conda-forge -c bioconda pairtools

   <b>Install</b> <b>using</b> <b>pip</b>
       Alternatively, compile and install <u>pairtools</u> and its Python dependencies from PyPI using pip:

          $ pip install pairtools

   <b>Install</b> <b>the</b> <b>development</b> <b>version</b>
       Finally,  you  can  install  the latest development version of <u>pairtools</u> from github. First, make a local
       clone of the github repository:

          $ git clone https://github.com/mirnylab/pairtools

       Then, you can compile and install <u>pairtools</u> in <u>the</u> <u>development</u> <u>mode</u>, which installs the  package  without
       moving  it  to  a  system  folder  and thus allows immediate live-testing any changes in the python code.
       Please, make sure that you have <u>cython</u> installed!

          $ cd pairtools
          $ pip install -e ./

</pre><h4><b>PARSING</b> <b>SEQUENCE</b> <b>ALIGNMENTS</b> <b>INTO</b> <b>HI-C</b> <b>PAIRS</b></h4><pre>
   <b>Overview</b>
       Hi-C experiments aim to measure the frequencies of contacts between all pairs of loci in the  genome.  In
       these  experiments,  the  spacial  structure  of chromosomes if first fixed with formaldehyde crosslinks,
       after which DNA is partially digested with restriction enzymes and then re-ligated  back.  Then,  DNA  is
       shredded  into  smaller pieces, released from nucleus, sequenced and aligned to the reference genome. The
       resulting sequence alignments reveal if DNA molecules were formed  through  ligations  between  DNA  from
       different  locations  in  the  genome.   These ligation events imply that ligated loci were close to each
       other when the ligation enzyme was active, i.e. they formed "a contact".

       <b>pairtools</b> <b>parse</b> detects ligation events in  the  aligned  sequences  of  DNA  molecules  formed  in  Hi-C
       experiments and reports them in the .pairs/.pairsam format.

   <b>Terminology</b>
       Throughout  this document we will be using the same visual language to describe how DNA sequences (in the
       .fastq format) are transformed into sequence alignments (.sam/.bam) and into ligation events (.pairs).
         [image: The visual language to describe transformation of Hi-C data] [image] DNA sequences (reads)  are
         aligned to the reference genome and converted into ligation events.UNINDENT

         Short-read sequencing determines the sequences of the both ends (or, <b>sides</b>) of DNA molecules (typically
         50-300  bp),  producing  <b>read</b>  <b>pairs</b> in .fastq format (shown in the first row on the figure above).  In
         such reads, base pairs are reported from the  tips  inwards,  which  is  also  defined  as  the  <b>5'-&gt;3'</b>
         direction  (in  accordance of the 5'-&gt;3' direction of the DNA strand that sequence of the corresponding
         side of the read).

         Alignment software maps both reads of a pair  to  the  reference  genome,  producing  <b>alignments</b>,  i.e.
         segments of the reference genome with matching sequences.  Typically, there will be only two alignments
         per  read  pair, one on each side.  But, sometimes, the parts of one or both sides may map to different
         locations on the genome, producing more than two alignments per DNA molecule  (see  <u>Multiple</u>  <u>ligations</u>
         <u>(walks)</u>).

         <b>pairtools</b>  <b>parse</b>  converts  alignments into <b>ligation</b> <b>events</b> (aka <b>Hi-C</b> <b>pairs</b> aka <b>pairs</b>). In the simplest
         case, when each side has only one unique alignment (i.e. the whole side maps to a single unique segment
         of the genome), for each side, we report the chromosome, the genomic position of  the  outer-most  (5')
         aligned  base  pair  and  the  strand of the reference genome that the read aligns to.  <b>pairtools</b> <b>parse</b>
         assigns to such pairs the type <b>UU</b> (unique-unique).

   <b>Unmapped/multimapped</b> <b>reads</b>
       Sometimes, one side or both sides of a read pair may not align to the reference genome:
         [image: Read pairs missing an alignment on one or both sides] [image] Read pairs missing  an  alignment
         on one or both sides.UNINDENT

         In  this  case,  <b>pairtools</b> <b>parse</b> fills in the chromosome of the corresponding side of Hi-C pair with <b>!</b>,
         the position with <b>0</b> and the strand with <b>-</b>.  Such pairs are reported as type <b>NU</b> (null-unique,  when  the
         other side has a unique alignment) or <b>NN</b> (null-null, when both sides lack any alignment).

         Similarly, when one or both sides map to many genome locations equally well (i.e.  have non-unique, or,
         multi-mapping alignments), <b>pairtools</b> <b>parse</b> reports the corresponding sides as (chromosome= <b>!</b>, position=
         <b>0</b>,  strand= <b>-</b>) and type <b>MU</b> (multi-unique) or <b>MM</b> (multi-multi) or <b>NM</b> (null-multi), depending on the type
         of the alignment on the other side.
         [image: Read pairs with a non-unique alignment on  one  or  both  sides]  [image]  Read  pairs  with  a
         non-unique (multi-) alignment on one side.UNINDENT

         <b>pairtools</b>  <b>parse</b>  calls  an  alignment  to  be  multi-mapping when its <u>MAPQ</u> <u>score</u> (which depends on the
         scoring gap between the two best candidate alignments for a segment) is equal or greater than the value
         specified with the <b>--min-mapq</b> flag (by default, 1).

   <b>Multiple</b> <b>ligations</b> <b>(walks)</b>
       Finally, a read pair may contain more than two alignments:
         [image: A sequenced Hi-C molecule that was formed via multiple  ligations]  [image]  A  sequenced  Hi-C
         molecule that was formed via multiple ligations.UNINDENT

         Molecules like these typically form via multiple ligation events and we call them walks [1]. Currently,
         <b>pairtools</b> <b>parse</b> does not process such molecules and tags them as type <b>WW</b>.

   <b>Interpreting</b> <b>gaps</b> <b>between</b> <b>alignments</b>
       Reads  that  are  only  partially  aligned  to  the  genome can be interpreted in two different ways. One
       possibility is to assume that this molecule was formed via at least two ligations (i.e. it's a <u>walk</u>)  but
       the  non-aligned  part  (a <b>gap</b>) was missing from the reference genome for one reason or another.  Another
       possibility is to simply ignore this gap (for example, because it could be an insertion  or  a  technical
       artifact), thus assuming that our molecule was formed via a single ligation and has to be reported:
         [image:  A  gap  between  alignments can be ignored or interpreted as a "null" alignment] [image] A gap
         between  alignments  can  interpreted  as  a  legitimate  segment  without  an  alignment   or   simply
         ignored.UNINDENT

         Both options have their merits, depending on a dataset, quality of the reference genome and sequencing.
         <b>pairtools</b>  <b>parse</b>  ignores  shorter <u>gaps</u> and keeps longer ones as "null" alignments. The maximal size of
         ignored <u>gaps</u> is set by the <b>--max-inter-align-gap</b> flag (by default, 20bp).

   <b>Rescuing</b> <b>single</b> <b>ligations</b>
       Importantly, some of DNA molecules containing only one ligation junction may  still  end  up  with  three
       alignments:
         [image:  Not  all  read  pairs with three alignments come from "walks"] [image] Not all read pairs with
         three alignments come from "walks".UNINDENT

         A molecule formed via a single ligation gets three alignments when one of the two ligated DNA pieces is
         shorter than the read length, such that that read on  the  corresponding  side  sequences  through  the
         ligation junction and into the other piece [2]. The amount of such molecules depends on the type of the
         restriction  enzyme,  the  typical  size  of DNA molecules in the Hi-C library and the read length, and
         sometimes can be considerable.

         <b>pairtools</b> <b>parse</b> detects such molecules and <b>rescues</b> them (i.e.  changes their type  from  a  <u>walk</u>  to  a
         single-ligation molecule). It tests walks with three aligments using three criteria:
         [image:   The  three  criteria  used  for  "rescue"]  [image]  The  three  criteria  used  to  "rescue"
         three-alignment walks: cis, point towards each other, short distance.UNINDENT

       1. On the side with two alignments (the <b>chimeric</b> side), the "inner" (or, 3') alignment  must  be  on  the
          same chromosome as the alignment on the non-chimeric side.

       2. The  "inner"  alignment  on  the  chimeric  side and the alignment on the non-chimeric side must point
          toward each other.

       3. These two alignments must be within the distance  specified  with  the  <b>--max-molecule-size</b>  flag  (by
          default, 2000bp).

       Sometimes, the "inner" alignment on the chimeric side can be non-unique or "null" (i.e. when the unmapped
       segment  is  longer  than  <b>--max-inter-align-gap</b>,  as described in <u>Interpreting</u> <u>gaps</u> <u>between</u> <u>alignments</u>).
       <b>pairtools</b> <b>parse</b> ignores such alignments altogether and thus rescues such <u>walks</u> as well.
         [image: A walk with three alignments get rescued, when the middle alignment is multi- or null]  [image]
         A walk with three alignments get rescued, when the middle alignment is multi- or null..UNINDENT

       [1]  Following the lead of <u>C-walks</u>

       [2]  This procedure was first introduced in <u>HiC-Pro</u> and the in <u>Juicer</u> .

</pre><h4><b>SORTING</b> <b>PAIRS</b></h4><pre>
       In  order  to  enable  efficient  random  access  to  Hi-C pairs, we <b>flip</b> and <b>sort</b> pairs.  After sorting,
       interactions become arranged in the order of their genomic position, such that, for  any  given  pair  of
       regions,  we  easily  find  and extract all of their interactions.  And, after flipping, all artificially
       duplicated molecules (either during PCR or in optical sequencing) end up in adjacent rows in sorted lists
       of interactions, such that we can easily identify and remove them.

   <b>Sorting</b>
       <b>pairtools</b> <b>sort</b> arrange pairs in the order of (chrom1, chrom2, pos1, pos2).  This order is also  known  as
       <u>block</u> <u>sorting</u>, because all pairs between any given pair of chromosomes become grouped into one continuous
       block.   Additionally,  <b>pairtools</b>  <b>sort</b> also sorts pairs with identical positions by <u>pair_type</u>. This does
       not really do much for mapped reads, but it nicely splits unmapped reads into blocks of  null-mapped  and
       multi-mapped reads.

       We  note  that  there  is  an alternative to block sorting, called <u>row</u> <u>sorting</u>, where pairs are sorted by
       (chrom1, pos1, chrom2, pos2).  In <u>pairtools</u> <u>sort</u>, we prefer block-sorting since it cleanly separates  cis
       interactions from trans ones and thus is a more optimal solution for typical use cases.

   <b>Flipping</b>
       In  a  typical paired-end experiment, <u>side1</u> and <u>side2</u> of a DNA molecule are defined by the order in which
       they got sequenced.  Since this order is essentially random, any given Hi-C  pair,  e.g.   (chr1,  1.1Mb;
       chr2,  2.1Mb),  may  appear  in  a  reversed orientation, i.e.  (chr2, 2.1Mb; chr1, 1.1Mb). If we were to
       preserve this order of sides, interactions between same loci would appear in two different  locations  of
       the sorted pair list, which would complicate finding PCR/optical duplicates.

       To  ensure  that  Hi-C  pairs with similar coordinates end up in the same location of the sorted list, we
       <b>flip</b> pairs, i.e. we choose <u>side1</u> as the side with the lowest genomic coordinate.  Thus,  after  flipping,
       for  <u>trans</u>  pairs  (chrom1!=chrom2),  order(chrom1)&lt;order(chrom2);  and  for  <u>cis</u> pairs (chrom1==chrom2),
       pos1&lt;=pos2.  In a matrix representation, flipping is equal to reflecting the lower triangle of  the  Hi-C
       matrix onto its upper triangle, such that the resulting matrix is upper-triangular.

       In  <u>pairtools</u>,  flipping  is done during parsing - that's why <b>pairtools</b> <b>parse</b> requires a .chromsizes file
       that specifies the order of chromosomes for flipping.  Importantly, <b>pairtools</b> <b>parse</b> also flips  one-sided
       pairs  such  that  side1  is  always  unmapped;  and unmapped pairs such that side1 always has a "poorer"
       mapping type (i.e. null-mapping&lt;multi-mapping).

   <b>Chromosomal</b> <b>order</b> <b>for</b> <b>sorting</b> <b>and</b> <b>flipping</b>
       Importantly, the order of chromosomes for sorting and flipping can be different.  Specifically, <b>pairtools</b>
       <b>sort</b> uses the lexicographic order for chromosomes (chr1, chr10, chr11, ..., chr2, chr21,...)  instead  of
       the  "natural"  order  (chr1,  chr2, chr3, ...); at the same time, flipping is done in <b>pairsamtools</b> <b>parse</b>
       using the chromosomal order specified by the user.

       <b>pairtools</b> <b>sort</b> uses the lexicographic order for sorting chromosomes.  This order is used  universally  to
       sorting  strings  in  all  languages  and tools [1], which makes it easy to design tools for indexing and
       searching in sorted pair lists.

       At the same time, <b>pairtools</b> <b>parse</b> uses a custom  user-provided  chromosomal  order  to  flip  pairs.  For
       performance considerations, for flipping, we recommend ordering chromosomes in a way that will be used in
       plotting contact maps.

       [1]  Unfortunately,  many  existing  genomes  use  rather  unconventional  choices  in chromosomal naming
            schemes. For example, in sacCer3, chromosomes are  enumerated  with  Roman  numerals;  in  dm3,  big
            autosomes are split 4 different contigs each. Thus, it is impossible to design a universal algorithm
            that would order chromosomes in a "meaningful" way for all existing genomes.

</pre><h4><b>FORMATS</b> <b>FOR</b> <b>STORING</b> <b>HI-C</b> <b>PAIRS</b></h4><pre>
   <b>.pairs</b>
       <u>.pairs</u>  is  a simple tabular format for storing DNA contacts detected in a Hi-C experiment.  The detailed
       <u>.pairs</u> <u>specification</u> is defined by the 4DN Consortium.

       The body of a .pairs contains a table with a variable number of fields separated by a "\t"  character  (a
       horizontal tab). The .pairs specification fixes the content and the order of the first seven columns:
                                  ┌───────┬─────────┬──────────────────────────────┐
                                  │ index │ name    │ description                  │
                                  ├───────┼─────────┼──────────────────────────────┤
                                  │ 1     │ read_id │ the   ID   of  the  read  as │
                                  │       │         │ defined in fastq files       │
                                  ├───────┼─────────┼──────────────────────────────┤
                                  │ 2     │ chrom1  │ the   chromosome   of    the │
                                  │       │         │ alignment on side 1          │
                                  ├───────┼─────────┼──────────────────────────────┤
                                  │ 3     │ pos1    │ the 1-based genomic position │
                                  │       │         │ of   the   outer-most   (5') │
                                  │       │         │ mapped bp on side 1          │
                                  ├───────┼─────────┼──────────────────────────────┤
                                  │ 4     │ chrom2  │ the   chromosome   of    the │
                                  │       │         │ alignment on side 2          │
                                  ├───────┼─────────┼──────────────────────────────┤
                                  │ 5     │ pos2    │ the 1-based genomic position │
                                  │       │         │ of   the   outer-most   (5') │
                                  │       │         │ mapped bp on side 2          │
                                  ├───────┼─────────┼──────────────────────────────┤
                                  │ 6     │ strand1 │ the strand of the  alignment │
                                  │       │         │ on side 1                    │
                                  ├───────┼─────────┼──────────────────────────────┤
                                  │ 7     │ strand2 │ the  strand of the alignment │
                                  │       │         │ on side 2                    │
                                  └───────┴─────────┴──────────────────────────────┘

       A .pairs file starts with a header, an arbitrary number of  lines  starting  with  a  "#"  character.  By
       convention,  the  header  lines  have  a  format of "#field_name: field_value".  The <u>.pairs</u> <u>specification</u>
       mandates a few standard header lines (e.g., column names, chromosome order, sorting order, etc),  all  of
       which are automatically filled in by <u>pairtools</u>.

       The  entries  of  a .pairs file can be flipped and sorted. "Flipping" means that <u>the</u> <u>sides</u> <u>1</u> <u>and</u> <u>2</u> <u>do</u> <u>not</u>
       <u>correspond</u> <u>to</u> <u>side1</u> <u>and</u> <u>side2</u> <u>in</u> <u>sequencing</u> <u>data.</u>  Instead,  side1  is  defined  as  the  side  with  the
       alignment  with  a lower sorting index (using the lexographic order for chromosome names, followed by the
       numeric order for positions and the lexicographic  order  for  pair  types).  This  particular  order  of
       "flipping"  is  defined  as "upper-triangular flipping", or "triu-flipping". Finally, pairs are <u>typically</u>
       block-sorted: i.e. first lexicographically by chrom1 and chrom2, then numerically by pos1 and pos2.

   <b>Pairtools'</b> <b>flavor</b> <b>of</b> <b>.pairs</b>
       .pairs files produced by <u>pairtools</u> extend .pairs format in a few ways.

       1. <u>pairtools</u> store null/ambiguous/chimeric alignments as chrom='!', pos=0, strand='-'.

       2. <u>pairtools</u> store the header of the source .sam files in the '#samheader:' fields of the  pairs  header.
          When multiple .pairs files are merged, the respective '#samheader:' fields are checked for consistency
          and merged.

       3. Each pairtool applied to .pairs leaves a record in the '#samheader' fields (using a @PG sam tag), thus
          preserving the full history of data processing.

       4. <u>pairtools</u> append an extra column describing the type of a Hi-C pair:
                                   ┌───────┬───────────┬─────────────────────────┐
                                   │ index │ name      │ description             │
                                   ├───────┼───────────┼─────────────────────────┤
                                   │ 8     │ pair_type │ the type of a Hi-C pair │
                                   └───────┴───────────┴─────────────────────────┘

   <b>Pair</b> <b>types</b>
       <u>pairtools</u> use a simple two-character notation to define all possible pair types, according to the quality
       of  alignment of the two sides. The type of a pair can be defined unambiguously using the table below. To
       use this table, identify which side has an alignment of a "poorer"  quality  (unmapped  &lt;  multimapped  &lt;
       unique alignment) and which side has a "better" alignment and find the corresponding row in the table.
           ┌────────────┬─────────────┬─────────────┬────────┬────────┬────────────────┬──────┬───────────┐
           │ .          │ Less        │ More        │ .      │ .      │ .              │      │           │
           │            │ informative │ informative │        │        │                │      │           │
           │            │ alignment   │ alignment   │        │        │                │      │           │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ &gt;2         │ Mapped      │ Unique      │ Mapped │ Unique │ Pair type      │ Code │ Sidedness │
           │ alignments │             │             │        │        │                │      │           │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ✔          │ ❌          │ ❌          │ ❌     │ ❌     │ walk-walk      │ WW   │ 0 [1]     │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ❌         │ ❌          │             │ ❌     │        │ null           │ NN   │ 0         │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ❌         │ ❌          │             │ ❌     │        │ corrupt        │ XX   │ 0         │
           │            │             │             │        │        │                │      │ [2]_      │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ❌         │ ❌          │             │ ✔      │ ❌     │ null-multi     │ NM   │ 0         │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ✔          │ ❌          │             │ ✔      │ ✔      │ null-rescued   │ NR   │ 1 [3]     │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ❌         │ ❌          │             │ ✔      │ ✔      │ null-unique    │ NU   │ 1         │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ❌         │ ✔           │ ❌          │ ✔      │ ❌     │ multi-multi    │ MM   │ 0         │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ✔          │ ✔           │ ❌          │ ✔      │ ✔      │ multi-rescued  │ MR   │ 1 [3]     │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ❌         │ ✔           │ ❌          │ ✔      │ ✔      │ multi-unique   │ MU   │ 1         │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ✔          │ ✔           │ ✔           │ ✔      │ ✔      │ rescued-unique │ RU   │ 2 [3]     │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ✔          │ ✔           │ ✔           │ ✔      │ ✔      │ unique-rescued │ UR   │ 2 [3]     │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ❌         │ ✔           │ ✔           │ ✔      │ ✔      │ unique-unique  │ UU   │ 2         │
           ├────────────┼─────────────┼─────────────┼────────┼────────┼────────────────┼──────┼───────────┤
           │ ❌         │ ✔           │ ✔           │ ✔      │ ✔      │ duplicate      │ DD   │ 2         │
           │            │             │             │        │        │                │      │ [4]_      │
           └────────────┴─────────────┴─────────────┴────────┴────────┴────────────────┴──────┴───────────┘

       [1]  "walks", or, <u>C-walks</u> are Hi-C molecules formed via multiple ligation events which cannot be reported
            as a single pair.

       [2]  "corrupt"  pairs  are those with technical issues - e.g. missing a FASTQ sequence/SAM entry from one
            side of the molecule.

       [2]  "rescued" pairs have two non-overlapping alignments on one of  the  sides  (referred  below  as  the
            chimeric  side/read), but the inner (3'-) one extends the only alignment on the other side (referred
            as the non-chimeric side/read).  Such pairs form when one  of  the  two  ligated  DNA  fragments  is
            shorter  than the read length. In this case, one of the reads contains this short fragment entirely,
            together with the ligation junction and a chunk of the other DNA fragment (thus, this read  ends  up
            having  two  non-overlapping alignments).  Following the procedure introduced in <u>HiC-Pro</u> and <u>Juicer</u>,
            <u>pairtools</u> <u>parse</u> rescues such Hi-C molecules, reports  the  position  of  the  5'  alignment  on  the
            chimeric  side, and tags them as "NU", "MU", "UR" or "RU" pair type, depending on the type of the 5'
            alignment on the chimeric side. Such molecules can and should be used in downstream analysis.   Read
            more on the rescue procedure in the section on parsing.

       [3]  <u>pairtools</u>  <u>dedup</u>  detects  molecules  that could be formed via PCR duplication and tags them as "DD"
            pair type. These pairs should be excluded from downstream analyses.

   <b>.pairsam</b>
       <u>pairtools</u> also define .pairsam, a valid extension of the .pairs format.  On top of the pairtools'  flavor
       of  .pairs, .pairsam format adds two extra columns containing the alignments from which the Hi-C pair was
       extracted:
                                   ───────────────────────────────────────────────
                                   │ index │ name │ description                  │
                                   ├───────┼──────┼──────────────────────────────┤
                                   │ 9     │ sam1 │ the sam alignment(s) on side │
                                   │       │      │ 1;   separate   supplemental │
                                   │       │      │ alignments by NEXT_SAM       │
                                   ├───────┼──────┼──────────────────────────────┤
                                   │ 10    │ sam2 │ the sam alignment(s) on side │
                                   │       │      │ 2;   separate   supplemental │
                                   │       │      │ alignments by NEXT_SAM       │
                                   └───────┴──────┴──────────────────────────────┘

       Note that, normally, the fields of a sam alignment are separated by  a  horizontal  tab  character  (\t),
       which  we already use to separate .pairs columns. To avoid confusion, we replace the tab character in sam
       entries stored in sam1 and sam2 columns with a UNIT SEPARATOR character (\031).

       Finally, sam1 and sam2 can store multiple .sam alignments, separated by a string '\031NEXT_SAM\031'

</pre><h4><b>TECHNICAL</b> <b>NOTES</b></h4><pre>
       Designing scientific software and formats requires making a multitude of tantalizing technical  decisions
       and  compromises.  Often, the reasons behind a certain decision are non-trivial and convoluted, involving
       many factors.  Here, we collect the notes and observations made during the desing stage of <u>pairtools</u>  and
       provide  a  justification  for most non-trivial decisions.  We hope that this document will elucidate the
       design of <u>pairtools</u> and may prove useful to developers in their future projects.

   <b>.pairs</b> <b>format</b>
       The motivation behind some of the technical decisions in the pairtools' flavor of .pairs/.pairsam:

       • <u>pairtools</u> can store SAM entries together with the Hi-C pair  information  in  .pairsam  files.  Storing
         pairs  and alignments in the same row enables easy tagging and filtering of paired-end alignments based
         on their Hi-C information.

       • <u>pairtools</u> use the exclamation mark "!" instead of '.' as 'chrom' of unmapped reads because it  has  the
         lowest  lexicographic  sorting  order  among  all  characters.  The use of '0' and '-' in the 'pos' and
         'strand' fields of unmapped reads allows us to keep the types of these fields  as  'unsigned  int'  and
         enum{'+','-'}, respectively.

       • "rescued" pairs have two types "UR" and "RU" instead of just "RU". We chose this design because rescued
         pairs  are  two-sided and thus are flipped based on (chrom, pos), and not based on the side types. With
         two pair types "RU" and "UR", <u>pairtools</u> can keep track of which side of the pair was rescued.

       • in "rescued" pairs, the type "R" is assigned to the non-chimeric side.  This may seem counter-intuitive
         at first, since it is the chimeric side that gets rescued, but this way <u>pairtools</u> can keep track of the
         type of the 5' alignment on the chimeric side (the alignment on the non-chimeric side has to be  unique
         for the pair to be rescued).

       • <u>pairtools</u>  rely  on  a text format, .pairs, instead of hdf5/parquet-based tables or custom binaries. We
         went with a text format for a few reasons:

         • text tables enable easy access to data from any language and any tool.  This is especially  important
           at the level of Hi-C pairs, the "rawest" format of information from a Hi-C experiment.

         • hdf5  and parquet have a few shortcomings that hinder their immediate use in <u>pairtools</u>. Specifically,
           hdf5 cannot compress variable-length strings (which are, in turn, required to  store  sam  alignments
           and  some  optional information on pairs) and parquet cannot append columns to existing files, modify
           datasets in place or store multiple tables in one file (which is required to keep  table  indices  in
           the same file with pairs).

         • text  tables  have  a  set  of  well-developed  and  highly-optimized  tools for sorting (Unix sort),
           compression (bgzip/lz4) and random access (tabix).

         • text formats enable easy streaming between individual command-line tools.

         Having said that, text formats have many downsides - they are bulky when  not  compressed,  compression
         and  parsing requires extra computational resources, they cannot be modified in place and random access
         requires extra tools. In the future, we plan to develop a binary format  based  on  existing  container
         formats, which would mitigate these downsides.

   <b>CLI</b>
       • many  <u>pairtools</u>  perform  multiple  actions at once, which contradicts the "do one thing" philosophy of
         Unix command line. We packed multiple  (albeit,  related)  functions  into  one  tool  to  improve  the
         performance  of  <u>pairtools</u>.  Specifically, given the large size of Hi-C data, a significant fraction of
         time is spent on compression/decompression, parsing, loading data  into  memory  and  sending  it  over
         network  (for  cloud/clusters).  Packing  multiple functions into one tool cuts down the amount of such
         time consuming operations.

       • <b>pairtools</b> <b>parse</b> requires a .chromsizes file to know the order of chromosomes and perform pair flipping.

       • <u>pairtools</u> use <u>bgzip</u> compression by default instead of gzip. Using <u>bgzip</u> allows us to  create  an  index
         with <u>pairix</u> and get random access to data.

       • <u>paritools</u>  have  an  option  to  compress  outputs  with <u>lz4</u>.  <u>Lz4</u> <u>is</u> <u>much</u> <u>faster</u> <u>and</u> <u>only</u> <u>slighly</u> <u>less</u>
         <u>efficient</u> <u>than</u> <u>gzip</u>.  This makes lz4 a better choice for  passing  data  between  individual  pairtools
         before producing final result (which, in turn, requires bgzip compression).

</pre><h4><b>COMMAND-LINE</b> <b>API</b></h4><pre>
       • genindex

</pre><h4><b>AUTHOR</b></h4><pre>
       Mirny Lab

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2017-2022, Mirny Lab

0.3.0                                             Mar 16, 2022                                      <u><a href="../man1/PAIRTOOLS.1.html">PAIRTOOLS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>