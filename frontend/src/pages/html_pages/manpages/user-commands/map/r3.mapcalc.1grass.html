<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>r3.mapcalc  - Raster map calculator.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>r3.mapcalc</b>  - Raster map calculator.

</pre><h4><b>KEYWORDS</b></h4><pre>
       raster, algebra

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>r3.mapcalc</b>
       <b>r3.mapcalc</b> <b>--help</b>
       <b>r3.mapcalc</b>  [-<b>sl</b>]   [<b>expression</b>=<u>string</u>]    [<b>region</b>=<u>string</u>]   [<b>file</b>=<u>name</u>]   [<b>seed</b>=<u>integer</u>]   [--<b>overwrite</b>]
       [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-s</b>
           Generate random seed (result is non-deterministic)

       <b>-l</b>
           List input and output maps

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>expression</b>=<u>string</u>
           Expression to evaluate

       <b>region</b>=<u>string</u>
           The computational region that should be used.
           Options: <u>current,</u> <u>intersect,</u> <u>union</u>
           Default: <u>current</u>
           <b>current</b>: current uses the current region of the mapset
           <b>intersect</b>: intersect computes the intersection region between all input maps and  uses  the  smallest
           resolution
           <b>union</b>: union computes the union extent of all map regions and uses the smallest resolution

       <b>file</b>=<u>name</u>
           File containing expression(s) to evaluate

       <b>seed</b>=<u>integer</u>
           Seed for rand() function

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>r3.mapcalc</u>  performs  arithmetic  on  raster  map layers.  New raster map layers can be created which are
       arithmetic expressions involving existing raster map layers, integer or  floating  point  constants,  and
       functions.

   <b>Program</b> <b>use</b>
       <u>r3.mapcalc</u> expression have the form:

       <b>result</b> <b>=</b> <u>expression</u>

       where <u>result</u> is the name of a raster map layer to contain the result of the calculation and <b>expression</b> is
       any  legal  arithmetic expression involving existing raster map layers (except <u>result</u> itself), integer or
       floating point constants, and functions  known  to  the  calculator.   Parentheses  are  allowed  in  the
       expression and may be nested to any depth.  <u>result</u> will be created in the user’s current mapset.

       As  <b>expression=</b>  is  the  first  option,  it is the default. This means that passing an expression on the
       command line is possible as long as the expression is quoted and a space is included before the  first  <u>=</u>
       sign.  Example (’foo’ is the resulting map):
       r3.mapcalc "foo = 1"
       or:
       r3.mapcalc ’foo = 1’
       An  unquoted  expression  (i.e.  split  over  multiple arguments) won’t work, nor will omitting the space
       before the = sign:
       r3.mapcalc ’foo=1’
       Sorry, &lt;foo&gt; is not a valid parameter
       If no options are given, it manufactures "file=-" (which reads from stdin), so you can  continue  to  use
       e.g.:
       r3.mapcalc &lt; file
       or:
       r3.mapcalc &lt;&lt;EOF
       foo = 1
       EOF
       But unless you need compatibility with previous versions, use file= explicitly, e.g.:
       r3.mapcalc file=file
       or:
       r3.mapcalc file=- &lt;&lt;EOF
       foo = 1
       EOF

       The  formula entered to <u>r3.mapcalc</u> by the user is recorded both in the <u>result</u> map title (which appears in
       the category file for <u>result</u>) and in the history file for <u>result</u>.

       Some characters have special meaning to the command shell. If the user is entering input to <u>r3.mapcalc</u> on
       the command line, expressions should be enclosed within single quotes.  See NOTES, below.

   <b>Operators</b> <b>and</b> <b>order</b> <b>of</b> <b>precedence</b>
       The following operators are supported:
            Operator   Meaning                    Type        Precedence
            --------------------------------------------------------------
            -          negation                   Arithmetic  12
            ~          one’s complement           Bitwise     12
            !          not                        Logical     12
            ^          exponentiation             Arithmetic  11
            %          modulus                    Arithmetic  10
            /          division                   Arithmetic  10
            *          multiplication             Arithmetic  10
            +          addition                   Arithmetic   9
            -          subtraction                Arithmetic   9
            &lt;&lt;         left shift                 Bitwise      8
            &gt;&gt;         right shift                Bitwise      8
            &gt;&gt;&gt;        right shift (unsigned)     Bitwise      8
            &gt;          greater than               Logical      7
            &gt;=         greater than or equal      Logical      7
            &lt;          less than                  Logical      7
            &lt;=         less than or equal         Logical      7
            ==         equal                      Logical      6
            !=         not equal                  Logical      6
            &amp;          bitwise and                Bitwise      5
            |          bitwise or                 Bitwise      4
            &amp;&amp;         logical and                Logical      3
            &amp;&amp;&amp;        logical and[1]             Logical      3
            ||         logical or                 Logical      2
            |||        logical or[1]              Logical      2
            ?:         conditional                Logical      1
       (modulus is the remainder upon division)

       [1] The &amp;&amp;&amp; and ||| operators handle null values differently to other operators. See the section entitled
       <b>NULL</b> <b>support</b> below for more details.

       The operators are applied from left to right, with those of higher precedence applied before  those  with
       lower  precedence.   Division  by  0 and modulus by 0 are acceptable and give a NULL result.  The logical
       operators give a 1 result if the comparison is true, 0 otherwise.

   <b>3D</b> <b>Grid</b> <b>names</b>
       Anything in the expression which is not a number, operator, or function name is taken to  be  a  3D  grid
       name.  Examples:

       volume
       x3
       3d.his

       Most  GRASS raster map layers and 3D grids meet this naming convention.  However, if a 3D grid has a name
       which conflicts with the above rule, it should be quoted. For example, the expression

       x = a-b

       would be interpreted as:  x equals a minus b, whereas

       x = "a-b"

       would be interpreted as:  x equals the 3D grid named <u>a-b</u>

       Also

       x = 3107

       would create <u>x</u> filled with the number 3107, while

       x = "3107"

       would copy the 3D grid <u>3107</u> to the 3D grid <u>x</u>.

       Quotes are not required unless the 3D grid names look like numbers or contain operators,  OR  unless  the
       program is run non-interactively. Examples given here assume the program is run interactively. See NOTES,
       below.

       <u>r3.mapcalc</u>  will look for the 3D grids according to the user’s current mapset search path. It is possible
       to override the search path and specify the mapset from which to select the 3D  grid.  This  is  done  by
       specifying the 3D grid name in the form:

       name@mapset

       For example, the following is a legal expression:

       result = x@PERMANENT / y@SOILS

       The  mapset  specified  does  not  have  to be in the mapset search path.  (This method of overriding the
       mapset search path is common to all GRASS commands, not just <u>r3.mapcalc</u>.)

   <b>The</b> <b>neighborhood</b> <b>modifier</b>
       3D grids are data base files stored in voxel format, i.e.,  three-dimensional  matrices  of  float/double
       values.  In  <u>r3.mapcalc</u>,  3D  grids  may be followed by a <u>neighborhood</u> modifier that specifies a relative
       offset from the current cell being evaluated. The format is <u>map[r,c,d]</u>, where <u>r</u> is the row offset,  <u>c</u>  is
       the  column  offset  and <u>d</u> is the depth offset. For example, <u>map[1,2,3]</u> refers to the cell one row below,
       two columns to the right and 3 levels below of the current cell, <u>map[-3,-2,-1]</u> refers to the  cell  three
       rows above, two columns to the left and one level below of the current cell, and <u>map[0,1,0]</u> refers to the
       cell   one   column  to  the  right  of  the  current  cell.  This  syntax  permits  the  development  of
       neighborhood-type filters within a single 3D grid or across multiple 3D grids.

   <b>Functions</b>
       The functions currently supported are listed in the table below.  The type of the result is indicated  in
       the  last  column.  <u>F</u> means that the functions always results in a floating point value, <u>I</u> means that the
       function gives an integer result, and <u>*</u> indicates that the result is float if any of the arguments to the
       function are floating point values and integer if all arguments are integer.

       function                description                                     type
       ---------------------------------------------------------------------------
       abs(x)                  return absolute value of x                      *
       acos(x)                 inverse cosine of x (result is in degrees)      F
       asin(x)                 inverse sine of x (result is in degrees)        F
       atan(x)                 inverse tangent of x (result is in degrees)     F
       atan(x,y)               inverse tangent of y/x (result is in degrees)   F
       ceil(x)                 the smallest integral value not less than x     *
       cos(x)                  cosine of x (x is in degrees)                   F
       double(x)               convert x to double-precision floating point    F
       eval([x,y,...,]z)       evaluate values of listed expr, pass results to z
       exp(x)                  exponential function of x                       F
       exp(x,y)                x to the power y                                F
       float(x)                convert x to single-precision floating point    F
       floor(x)                the largest integral value not greater than x   *
       graph(x,x1,y1[x2,y2..]) convert the x to a y based on points in a graph F
       graph2(x,x1[,x2,..],y1[,y2..])
                               alternative form of graph()                     F
       if                      decision options:                               *
       if(x)                   1 if x not zero, 0 otherwise
       if(x,a)                 a if x not zero, 0 otherwise
       if(x,a,b)               a if x not zero, b otherwise
       if(x,a,b,c)             a if x &gt; 0, b if x is zero, c if x &lt; 0
       int(x)                  convert x to integer [ truncates ]              I
       isnull(x)               check if x = NULL
       log(x)                  natural log of x                                F
       log(x,b)                log of x base b                                 F
       max(x,y[,z...])         largest value of those listed                   *
       median(x,y[,z...])      median value of those listed                    *
       min(x,y[,z...])         smallest value of those listed                  *
       mod(x,y)                return the modulus (the remainder) of x/y       *
       mode(x,y[,z...])        mode value of those listed                      *
       nmax(x,y[,z...])        largest value of those listed, excluding NULLs  *
       nmedian(x,y[,z...])     median value of those listed, excluding NULLs   *
       nmin(x,y[,z...])        smallest value of those listed, excluding NULLs *
       nmode(x,y[,z...])       mode value of those listed, excluding NULLs     *
       not(x)                  1 if x is zero, 0 otherwise
       pow(x,y)                x to the power y                                *
       rand(a,b)               random value x : a &lt;= x &lt; b                     *
       round(x)                round x to nearest integer                      I
       round(x,y)              round x to nearest multiple of y
       round(x,y,z)            round x to nearest y*i+z for some integer i
       sin(x)                  sine of x (x is in degrees)                     F
       sqrt(x)                 square root of x                                F
       tan(x)                  tangent of x (x is in degrees)                  F
       xor(x,y)                exclusive-or (XOR) of x and y                   I
       Internal variables:
        row()                  current row of moving window                    I
        col()                  current col of moving window                    I
        depth()                return current depth                            I
        nrows()                number of rows in computation region            I
        ncols()                number of columns in computation region         I
        ndepths()              number of depth levels in computation region    I
        x()                    current x-coordinate of moving window           F
        y()                    current y-coordinate of moving window           F
        z()                    return current z value                          F
        ewres()                current east-west resolution                    F
        nsres()                current north-south resolution                  F
        tbres()                current top-bottom resolution                   F
        area()                 area of current cell in square meters           F
        null()                 NULL value
       Note, that the row(), col() and depth() indexing starts with 1.

   <b>Floating</b> <b>point</b> <b>values</b> <b>in</b> <b>the</b> <b>expression</b>
       Floating point numbers are allowed in the expression. A floating point number is a number which  contains
       a decimal point:
           2.3   12.0   12.   .81
       Floating  point  values  in  the  expression  are  handled in a special way.  With arithmetic and logical
       operators, if either operand is float, the other is converted to float and the result of the operation is
       float.  This means, in particular that division of integers  results  in  a  (truncated)  integer,  while
       division  of  floats  results  in  an accurate floating point value.  With functions of type * (see table
       above), the result is float if any argument is float, integer otherwise.

       Note: If you calculate with integer numbers, the resulting map will be integer. If  you  want  to  get  a
       float result, add the decimal point to integer number(s).

       If  you  want  floating  point  division, at least one of the arguments has to be a floating point value.
       Multiplying one of them by 1.0 will produce a floating-point result, as will using float():
             r3.mapcalc "ratio = float(soil.4 - soil.3) / soil.3)"

   <b>NULL</b> <b>support</b>
           •   Division by zero should result in NULL.

           •   Modulus by zero should result in NULL.

           •   NULL-values in any arithmetic or logical operation should result in NULL. (however, &amp;&amp;&amp;  and  |||
               are treated specially, as described below).

           •   The &amp;&amp;&amp; and ||| operators observe the following axioms even when x is NULL:
                   x &amp;&amp;&amp; false == false
                   false &amp;&amp;&amp; x == false
                   x ||| true == true
                   true ||| x == true

           •   NULL-values  in  function arguments should result in NULL (however, if(), eval() and isnull() are
               treated specially, as described below).

           •   The eval() function always returns its last argument

           •   The situation for if() is:
               if(x)
                   NULL if x is NULL; 0 if x is zero; 1 otherwise
               if(x,a)
                   NULL if x is NULL; a if x is non-zero; 0 otherwise
               if(x,a,b)
                   NULL if x is NULL; a if x is non-zero; b otherwise
               if(x,n,z,p)
                   NULL if x is NULL; n if x is negative;
               z if x is zero; p if x is positive

           •   The (new) function isnull(x) returns: 1 if x is NULL; 0  otherwise.  The  (new)  function  null()
               (which has no arguments) returns an integer NULL.

           •   Non-NULL, but invalid, arguments to functions should result in NULL.
               Examples:
               log(-2)
               sqrt(-2)
               pow(a,b) where a is negative and b is not an integer

       NULL  support:  Please  note  that  any math performed with NULL cells always results in a NULL value for
       these cells. If you want to replace a  NULL  cell  on-the-fly,  use  the  isnull()  test  function  in  a
       if-statement.

       Example:  The  users  wants  the NULL-valued cells to be treated like zeros. To add maps A and B (where B
       contains NULLs) to get a map C the user can use a construction like:

       C = A + if(isnull(B),0,B)

       <b>NULL</b> <b>and</b> <b>conditions:</b>

       For the one argument form:
       if(x) = NULL        if x is NULL
       if(x) = 0        if x = 0
       if(x) = 1        otherwise (i.e. x is neither NULL nor 0).

       For the two argument form:
       if(x,a) = NULL        if x is NULL
       if(x,a) = 0        if x = 0
       if(x,a) = a        otherwise (i.e. x is neither NULL nor 0).

       For the three argument form:
       if(x,a,b) = NULL    if x is NULL
       if(x,a,b) = b        if x = 0
       if(x,a,b) = a        otherwise (i.e. x is neither NULL nor 0).

       For the four argument form:
       if(x,a,b,c) = NULL    if x is NULL
       if(x,a,b,c) = a        if x &gt; 0
       if(x,a,b,c) = b        if x = 0
       if(x,a,b,c) = c        if x &lt; 0
       More generally, all operators and most functions return NULL if *any* of their arguments are NULL.
       The functions if(), isnull() and eval() are exceptions.
       The function isnull() returns 1 if its argument is NULL and 0 otherwise.  If the user wants the opposite,
       the ! operator, e.g. "!isnull(x)" must be used.

       All forms of if() return NULL if the first argument is NULL. The 2, 3 and 4 argument forms of if() return
       NULL if the "selected" argument is NULL, e.g.:
       if(0,a,b) = b    regardless of whether a is NULL
       if(1,a,b) = a    regardless of whether b is NULL
       eval() always returns its last argument, so it only returns NULL if the last argument is NULL.

       <b>Note</b>: The user cannot test for NULL using the == operator,  as  that  returns  NULL  if  either  or  both
       arguments are NULL, i.e. if x and y are both NULL, then "x == y" and "x != y" are both NULL rather than 1
       and 0 respectively.
       The behaviour makes sense if the user considers NULL as representing an unknown quantity. E.g. if x and y
       are  both  unknown,  then the values of "x == y" and "x != y" are also unknown; if they both have unknown
       values, the user doesn’t know whether or not they both have the same value.

</pre><h4><b>NOTES</b></h4><pre>
   <b>Usage</b> <b>from</b> <b>command</b> <b>line</b>
       Extra care must be taken if the expression is given on the command line.  Some  characters  have  special
       meaning to the UNIX shell.  These include, among others:
       * ( ) &gt; &amp; |

       It is advisable to put single quotes around the expression; e.g.:
       ’result = volume * 2’
       Without  the  quotes, the *, which has special meaning to the UNIX shell, would be altered and <u>r3.mapcalc</u>
       would see something other than the *.

   <b>Multiple</b> <b>computations</b>
       In general, it’s preferable to do as much as possible in each r3.mapcalc command using multi-line input.

   <b>Backwards</b> <b>compatibility</b>
       For the backwards compatibility with GRASS 6, if no options are  given,  it  manufactures  file=-  (which
       reads from stdin), so you can continue to use e.g.:
       r3.mapcalc &lt; file
       or:
       r3.mapcalc &lt;&lt;EOF
       foo = 1
       EOF
       But  unless  you  need  compatibility  with  previous GRASS GIS versions, use file= explicitly, as stated
       above.

       When the map name contains uppercase letter(s) or a dot which are not allowed  to  be  in  module  option
       names, the <u>r3.mapcalc</u> command will be valid also without quotes:
       r3.mapcalc volume_A=1
       r3.mapcalc volume.1=1
       However,  this  syntax  is  not  recommended  as  quotes as stated above more safe.  Using quotes is both
       backwards compatible and valid in future.

   <b>Interactive</b> <b>input</b> <b>in</b> <b>command</b> <b>line</b>
       For formulas that the user enters from standard input  (rather  than  from  the  command  line),  a  line
       continuation  feature  now  exists.  If the user adds a backslash to the end of an input line, <u>r3.mapcalc</u>
       assumes that the formula being entered by the user continues on to the next  input  line.   There  is  no
       limit to the possible number of input lines or to the length of a formula.

       If  the  <u>r3.mapcalc</u> formula entered by the user is very long, the map title will contain only some of it,
       but most (if not all) of the formula will be placed into the history file for the <u>result</u> map.

       When the user enters input to <u>r3.mapcalc</u> non-interactively on the command line, the program will not warn
       the user not to overwrite existing map layers.  Users  should  therefore  take  care  to  assign  program
       outputs raster map names that do not yet exist in their current mapsets.

   <b>3D</b> <b>GRID</b> <b>MASK</b> <b>handling</b>
       <u>r3.mapcalc</u>  follows  the  common GRASS behavior of raster MASK handling, so the MASK is only applied when
       reading an existing GRASS raster map.  This implies that, for example, the command:
       r3.mapcalc "volume_amplified = volume * 3"
       create a map respecting the masked pixels if MASK is active.

       However, when creating a map which is not based on any map, e.g. a map from a constant:
       r3.mapcalc "volume_const = 200.0"
       the created raster map is limited only by a computation region but it is not affected by an active  MASK.
       This  is  expected  because,  as  mentioned  above, MASK is only applied when reading, not when writing a
       raster map.

       If also in this case the MASK should be applied, an if() statement including the  MASK  should  be  used,
       e.g.:
       r3.mapcalc "volume_const = if(MASK, 200.0, null())"
       When  testing MASK related expressions keep in mind that when MASK is active you don’t see data in masked
       areas even if they are not NULL.  See <u>r.mask</u> for details.

   <b>Random</b> <b>number</b> <b>generator</b> <b>initialization</b>
       The pseudo-random number generator used by the rand() function can be initialised  to  a  specific  value
       using the <b>seed</b> option.  This can be used to replicate a previous calculation.

       Alternatively,  it  can  be  initialised  from the system time and the PID using the <b>-r</b> flag. This should
       result in a different seed being used each time.

       In either case, the seed will be written to the map’s history, and can be seen using <u>r.info</u>.

       If you want other people to be able to verify your results, it’s preferable to use  the  <b>seed</b>  option  to
       supply a seed which is either specified in the script or generated from a deterministic process such as a
       pseudo-random number generator given an explicit seed.

       Note  that the rand() function will generate a fatal error if neither the <b>seed</b> option nor the <b>-s</b> flag are
       given.

</pre><h4><b>EXAMPLES</b></h4><pre>
       To compute the average of two 3D grids <u>a</u> and <u>b</u>:
       ave = (a + b)/2

       To form a weighted average:
       ave = (5*a + 3*b)/8.0

       To produce a binary representation of the 3D grid <u>a</u> so that category 0 remains 0 and all other categories
       become 1:
       mask = a != 0
       This could also be accomplished by:
       mask = if(a)

       To mask 3D grid <u>b</u> by 3D grid <u>a</u>:
       result = if(a,b)

       To change all values below 5 to NULL, keep value otherwise:
       newmap = if(map &lt; 5, null(), map)
       The graph() function allows users to specify a x-y conversion using pairs of x,y  coordinates.   In  some
       situations  a  transformation from one value to another is not easily established mathematically, but can
       be represented by a 2-D  graph  and  then  linearly  interpolated.  The  graph()  function  provides  the
       opportunity  to  accomplish  this.   An  x-axis  value  is  provided to the graph function along with the
       associated graph represented by a series of x,y pairs.  The x values  must  be  monotonically  increasing
       (each  larger  than  or  equal to the previous).  The graph function linearly interpolates between pairs.
       Any x value lower the lowest x value (i.e. first) will have the associated y value returned.  Any x value
       higher than the last will similarly have the associated y value returned.  Consider the request:
       newmap = graph(map, 1,10, 2,25, 3,50)
       X (map) values supplied and y (newmap) values returned:
       0, 10
       1, 10
       1.5, 17.5
       2.9, 47.5
       4, 50
       100, 50

</pre><h4><b>KNOWN</b> <b>ISSUES</b></h4><pre>
       The <u>result</u> variable on the left hand side of the equation should not appear  in  the  <u>expression</u>  on  the
       right hand side.
       mymap = if( mymap &gt; 0, mymap, 0)

       Any  maps  generated  by a <u>r3.mapcalc</u> command only exist after the entire command has completed. All maps
       are generated concurrently, row-by-row (i.e. there is an implicit "for row  in  rows  {...}"  around  the
       entire  expression).   Thus  the  #,  @,  and [ ] operators cannot be used on a map generated within same
       <u>r3.mapcalc</u> command run.
       newmap = oldmap * 3.14
       othermap = newmap[-1, 0] / newmap[1, 0]

       Continuation lines must end with a \ and have <u>no</u> trailing white space (blanks or tabs). If the user  does
       leave  white  space  at  the end of continuation lines, the error messages produced by <u>r3.mapcalc</u> will be
       meaningless and the equation will not work as the user intended.  This is particularly important for  the
       eval() function.

       Currently, there is no comment mechanism in <u>r3.mapcalc</u>.  Perhaps adding a capability that would cause the
       entire  line  to  be ignored when the user inserted a # at the start of a line as if it were not present,
       would do the trick.

       The function should require the user to type "end" or "exit" instead of simply a blank line.  This  would
       make separation of multiple scripts separable by white space.

       <u>r3.mapcalc</u>  does  not  print  a  warning  in  case of operations on NULL cells. It is left to the user to
       utilize the isnull() function.

</pre><h4><b>REFERENCES</b></h4><pre>
       <b>r.mapcalc:</b> <b>An</b> <b>Algebra</b> <b>for</b> <b>GIS</b> <b>and</b> <b>Image</b> <b>Processing</b>, by Michael Shapiro  and  Jim  Westervelt,  U.S.  Army
       Construction Engineering Research Laboratory (March/1991).

       <b>Performing</b>  <b>Map</b>  <b>Calculations</b> <b>on</b> <b>GRASS</b> <b>Data:</b> <b>r.mapcalc</b> <b>Program</b> <b>Tutorial</b>, by Marji Larson, Michael Shapiro
       and Scott Tweddale, U.S. Army Construction Engineering Research Laboratory (December 1991)

       Neteler, M. (2001): Volume modelling of soils using GRASS GIS 3D tools. - in: Brovelli,  M.  (ed.)(2001):
       The Geomatics Workbook N. 2. Politecnico di Milano, Italy (ISSN 1591-092X) (PDF)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>g.region,</u> <u>r3.colors,</u> <u>r.mapcalc</u>

</pre><h4><b>AUTHORS</b></h4><pre>
       Tomas Paudits &amp; Jaro Hofierka, funded by GeoModel s.r.o., Slovakia
       <a href="mailto:tpaudits@mailbox.sk">tpaudits@mailbox.sk</a>, <a href="mailto:hofierka@geomodel.sk">hofierka@geomodel.sk</a>

       Glynn Clements

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: r3.mapcalc source code (history)

       Accessed: Friday Apr 04 01:18:59 2025

       Main index | 3D raster index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                   <u><a href="../man1grass/r3.mapcalc.1grass.html">r3.mapcalc</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>