<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::Objects -- Object-Orientation, what is it and how to exploit it</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/noble/+package/pdl">pdl_2.085-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::Objects -- Object-Orientation, what is it and how to exploit it

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This still needs to be written properly.  [Also, is there a good reason we don't recommend storing extra
       object data in the header hash?]

   <b>Inheritance</b>
       There are basically two reasons for subclassing ndarrays.  The first is simply that you want to be able
       to use your own routines like

               $ndarray-&gt;something()

       but don't want to mess up the PDL namespace (a worthy goal, indeed!).  The other is that you wish to
       provide special handling of some functions or more information about the data the ndarray contains.  In
       the first case, you can do with

               package BAR;
               @ISA=qw/PDL/;
               sub foo {my($this) = @_; fiddle;}

               package main;
               $x = PDL::pdl(BAR,5);
               $x-&gt;foo();

       However, because a PDL object is an opaque reference to a C struct, it is not possible to extend the PDL
       class by e.g. extra data via subclassing.  To circumvent this problem PerlDL has built-in support to
       extent the PDL class via the <u>has-a</u> relation for blessed hashes.  You can get the <u>HAS-A</u> behave like <u>IS-A</u>
       simply in that you assign the "PDL" object to the attribute named PDL and redefine the method
       <b>initialize()</b>.

           package FOO;

           @FOO::ISA = qw(PDL);
           sub initialize {
               my $class = shift;
               my $self = {
                       creation_time =&gt; time(),  # necessary extension :-)
                       PDL =&gt; null,             # used to store PDL object
                       };
               bless $self, $class;
           }

       All PDL constructors will call <b>initialize()</b> to make sure that your extensions are added by <u>all</u> PDL
       constructors automatically.   The "PDL" attribute is used by perlDL to store the PDL object and all PDL
       methods use this attribute automatically if they are called with a blessed hash reference instead of a
       PDL object (a blessed scalar).

       Do remember that if you subclass a class that is subclassed from an ndarray, you need to call
       SUPER::initialize.

       NEED STUFF ABOUT CODE REFs!!

   <b>Examples</b>
       You can find some simple examples of PDL subclassing in the PDL distribution test-case files. Look in
       "t/subclass2.t", "t/subclass3.t", etc.

   <b>Output</b> <b>Auto-Creation</b> <b>and</b> <b>Subclassed</b> <b>Objects</b>
       For PDL Functions where the output is created and returned, PDL will either call the subclassed object's
       "initialize" or "copy" method to create the output object. (See PDL::Indexing for a discussion on Output
       Auto-Creation.) This behavior is summarized as follows:

       •
        For <u>Simple</u> functions, defined as having a signature of

         func( a(), [o]b() )

        PDL will call $a-&gt;copy to create the output object.

        In  the  spirit  of the Perl philosophy of making <u>Easy</u> <u>Things</u> <u>Easy</u>, This behavior enables PDL-subclassed
        objects to be written without having to overload the many simple PDL functions in this category.

        The file t/subclass4.t in the PDL Distribution tests for this behavior.  See that file for an example.

       •
        For other functions, PDL will call $class-&gt;initialize to create the output object.  Where $class is  the
        class name of the first argument supplied to the function.

        For  these  more complex cases, it is difficult to second-guess the subclassed object's designer to know
        if a "copy" or a "initialize" is appropriate. So  for  these  cases,  $class-&gt;initialize  is  called  by
        default.  If  this is not appropriate for you, overload the function in your subclass and do whatever is
        appropriate is the overloaded function's code.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) Karl Glazebrook (<a href="mailto:kgb@aaoepp.aao.gov.au">kgb@aaoepp.aao.gov.au</a>),  Tuomas  J.  Lukka,  (<a href="mailto:lukka@husc.harvard.edu">lukka@husc.harvard.edu</a>)  and
       Christian  Soeller  (<a href="mailto:c.soeller@auckland.ac.nz">c.soeller@auckland.ac.nz</a>)  2000.  All rights reserved. There is no warranty. You are
       allowed to copy this on the same terms as Perl itself.

perl v5.38.2                                       2024-04-10                                        <u><a href="../man1p/OBJECTS.1p.html">OBJECTS</a></u>(1p)
</pre>
 </div>
</div></section>
</div>
</body>
</html>