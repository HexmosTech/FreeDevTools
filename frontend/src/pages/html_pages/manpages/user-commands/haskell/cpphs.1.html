<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cpphs - liberalised cpp-a-like preprocessor for Haskell</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/cpphs">cpphs_1.20.9.1-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cpphs - liberalised cpp-a-like preprocessor for Haskell

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>cpphs</b> [<u>FILENAME</u>|<u>OPTION</u>]...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>cpphs</u> is a liberalised re-implementation of <b>cpp</b> <b>(1),</b> the C pre-processor, in and for Haskell.

       Why re-implement cpp?  Rightly or wrongly, the C pre-processor is widely used in Haskell source code.  It
       enables  conditional  compilation  for  different compilers, different versions of the same compiler, and
       different OS platforms.  It is also occasionally used for its macro language, which  can  enable  certain
       forms  of  platform-specific  detail-filling,  such  as  the  tedious  boilerplate generation of instance
       definitions and FFI declarations.  However, there are two problems  with  cpp,  aside  from  the  obvious
       aesthetic ones:

              For some Haskell systems, notably Hugs on Windows, a true cpp is not available by default.

              Even  for  the  other  Haskell  systems, the common cpp provided by the gcc 3.x series is changing
              subtly in ways that are incompatible with Haskell's syntax.  There have always been problems with,
              for instance, string gaps, and prime characters in identifiers.  These problems are only going  to
              get worse.

       So,  it  seemed right to attempt to provide an alternative to cpp, both more compatible with Haskell, and
       itself written in Haskell so that it can be distributed with compilers.

       <u>cpphs</u> is pretty-much feature-complete, and compatible with the <b>-traditional</b> style of  cpp.   It  has  two
       modes:

              conditional compilation only (<b>--nomacro</b>),

              and full macro-expansion (default).

       In  <b>--nomacro</b>  mode,  <u>cpphs</u>  performs  only conditional compilation actions, i.e.  <b>#include</b>'s, <b>#if</b>'s, and
       <b>#ifdef</b>'s are processed according to text-replacement definitions (both command-line and internal), but no
       parameterised  macro  expansion  is  performed.   In  full  compatibility  mode  (the  default),  textual
       replacements and macro expansions are also processed in the remaining body of non-cpp text.

       Working Features:

       <b>#ifdef</b> simple conditional compilation

       <b>#if</b>    the full boolean language of defined(), &amp;&amp;, ||, ==, etc.

       <b>#elif</b>  chained conditionals

       <b>#define</b>
              in-line definitions (text replacements and macros)

       <b>#undef</b> in-line revocation of definitions

       <b>#include</b>
              file inclusion

       <b>#line</b>  line number directives

       <b>\n</b>     line continuations within all # directives

       <b>/**/</b>   token catenation within a macro definition

       <b>##</b>     ANSI-style token catenation

       <b>#</b>      ANSI-style token stringisation

       <b>__FILE__</b>
              special text replacement for DIY error messages

       <b>__LINE__</b>
              special text replacement for DIY error messages

       <b>__DATE__</b>
              special text replacement

       <b>__TIME__</b>
              special text replacement

       Macro  expansion  is recursive.  Redefinition of a macro name does not generate a warning.  Macros can be
       defined on the command-line with <b>-D</b> just like textual replacements.  Macro  names  are  permitted  to  be
       Haskell  identifiers e.g. with the prime ` and backtick ´ characters, which is slightly looser than in C,
       but they still may not include operator symbols.

       Numbering of lines in the output is preserved so that any  later  processor  can  give  meaningful  error
       messages.   When  a  file  is  <b>#include</b>'d,  <u>cpphs</u> inserts <b>#line</b> directives for the same reason. Numbering
       should be correct even in the presence of line continuations. If you don't want <b>#line</b> directives  in  the
       final output, use the <b>--noline</b> option.

       Any  syntax  errors in cpp directives gives a message to stderr and halts the program.  Failure to find a
       #include'd file produces a warning to stderr, but processing continues.

       You can give any number of filenames on the command-line.  The results are catenated on standard output.

       <b>-D</b><u>sym</u>  define a textual replacement (default value is 1)

       <b>-Dsym=</b><u>val</u>
              define a textual replacement with a specific value

       <b>-I</b><u>path</u> add a directory to the search path for #include's

       <b>-O</b><u>file</u> specify a file for output (default is stdout)

       <b>--nomacro</b>
              only process #ifdef's and #include's,
                                    do not expand macros

       <b>--noline</b>
              remove #line droppings from the output

       <b>--strip</b>
              convert C-style comments to whitespace, even outside
                                    cpp directives

       <b>--hashes</b>
              recognise the ANSI # stringise operator, and ## for
                                    token catenation, within macros

       <b>--text</b> treat the input as plain text, not Haskell code

       <b>--layout</b>
              preserve newlines within macro expansions

       <b>--unlit</b>
              remove literate-style comments

       <b>--version</b>
              report version number of cpphs and stop

       There are NO textual replacements defined by default.  (Normal cpp usually has definitions  for  machine,
       OS, etc.  These could easily be added to the cpphs source code if you wish.)  The search path is searched
       in  order  of  the <b>-I</b> options, except that the directory of the calling file, then the current directory,
       are always searched first.  Again, there is no default search path  (and  again,  this  could  easily  be
       changed).

</pre><h4><b>DIFFERENCES</b> <b>FROM</b> <b>CPP</b></h4><pre>
       In  general,  cpphs  is  based  on  the  <b>-traditional</b>  behaviour,  not ANSI C, and has the following main
       differences from the standard cpp.

       <b>General</b>

       The <b>#</b> that introduces any cpp directive must be in the first column  of  a  line  (whereas  ANSI  permits
       whitespace before the <b>#</b> ).

       Generates the <b>#line</b> <u>n</u> "<u>filename</u>" syntax, not the <b>#</b> <u>n</u> "<u>filename</u>" variant.

       C comments are only removed from within cpp directives.  They are not stripped from other text.  Consider
       for instance that in Haskell, all of the following are valid operator symbols: <b>/*</b> <b>*/</b> <b>*/*</b> However, you can
       turn on C-comment removal with the <b>--strip</b> option.

       <b>Macro</b> <b>language</b>

       Accepts  <b>/**/</b>  for  token-pasting  in  a  macro  definition.   However,  <b>/*</b> <b>*/</b> (with any text between the
       open/close comment) inserts whitespace.

       The ANSI <b>##</b> token-pasting operator is available with the <b>--hashes</b> flag.  This is to avoid misinterpreting
       any valid Haskell operator of the same name.

       Replaces a macro formal parameter with the actual, even inside a string (double or single quoted).   This
       is -traditional behaviour, not supported in ANSI.

       Recognises  the  <b>#</b> stringisation operator in a macro definition only if you use the <b>--hashes</b> option.  (It
       is an ANSI addition, only needed because quoted stringisation (above) is prohibited by ANSI.)

       Preserves whitespace within a textual replacement definition exactly (modulo newlines), but  leading  and
       trailing space is eliminated.

       Preserves  whitespace  within a macro definition (and trailing it) exactly (modulo newlines), but leading
       space is eliminated.

       Preserves whitespace within macro call arguments exactly (including newlines), but leading  and  trailing
       space is eliminated.

       With  the  <b>--layout</b> option, line continuations in a textual replacement or macro definition are preserved
       as line-breaks in the macro call.  (Useful for layout-sensitive code in Haskell.)

</pre><h4><b>BUGS</b></h4><pre>
       Bug reports, and any other feedback, should be sent to Malcolm Wallace &lt;<a href="mailto:Malcolm.Wallace@cs.york.ac.uk">Malcolm.Wallace@cs.york.ac.uk</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2004-2005 Malcolm Wallace, except for ParseLib (Copyright  ©  1995  Graham  Hutton  and  Erik
       Meijer).

       The  library  modules  in cpphs are distributed under the terms of the LGPL. If that's a problem for you,
       contact me to make other arrangements. The application module <b>Main.hs</b> itself is GPL.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/cpp.1.html">cpp</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       This manual page was written, based on <b>index.html</b>, by Ian Lynagh &lt;<a href="mailto:igloo@debian.org">igloo@debian.org</a>&gt; for the Debian system
       (but may be used by others).

cpphs version 0.9                                  2004-10-01                                           <u><a href="../man1/CPPHS.1.html">CPPHS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>