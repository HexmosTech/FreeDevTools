<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fvwm3commands - fvwm built-in commands</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/fvwm3">fvwm3_1.1.2+ds-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fvwm3commands - fvwm built-in commands

</pre><h4><b>LIST</b> <b>OF</b> <b>FVWM</b> <b>COMMANDS</b></h4><pre>
       The command descriptions below are grouped together in the following sections. The sections are hopefully
       sorted in order of usefulness to the newcomer.

       •   <b>Menu</b> <b>commands</b>

       •   <b>Miscellaneous</b> <b>commands</b>

       •   <b>Commands</b> <b>affecting</b> <b>window</b> <b>movement</b> <b>and</b> <b>placement</b>

       •   <b>Commands</b> <b>for</b> <b>focus</b> <b>and</b> <b>mouse</b> <b>movement</b>

       •   <b>Commands</b> <b>controlling</b> <b>window</b> <b>state</b>

       •   <b>Commands</b> <b>for</b> <b>mouse</b> <b>and</b> <b>key</b> <b>bindings</b>

       •   <b>The</b> <b>Style</b> <b>command</b> <b>(controlling</b> <b>window</b> <b>styles)</b>

       •   <b>Other</b> <b>commands</b> <b>controlling</b> <b>window</b> <b>styles</b>

       •   <b>Commands</b> <b>controlling</b> <b>the</b> <b>virtual</b> <b>desktop</b>

       •   <b>Commands</b> <b>for</b> <b>user</b> <b>functions</b> <b>and</b> <b>shell</b> <b>commands</b>

       •   <b>Conditional</b> <b>commands</b>

       •   <b>Module</b> <b>commands</b>

       •   <b>Quit,</b> <b>restart</b> <b>and</b> <b>session</b> <b>management</b> <b>commands</b>

       •   <b>Colorsets</b>

       •   <b>Color</b> <b>gradients</b>

   <b>Miscellaneous</b> <b>Commands</b>
       <b>BugOpts</b> [<u>option</u> [<u>bool</u>]], ...
           This command controls several workarounds for bugs in third party programs. The individual options
           are separated by commas. The optional argument <u>bool</u> is a boolean argument and controls if the bug
           workaround is enabled or not. It can either be "True" or "False" to turn the option on or off, or
           "toggle" to switch is back and forth. If <u>bool</u> is omitted, the default setting is restored.

           <u>DebugRandR</u> activates monitor layout debug messages.

           <u>FlickeringMoveWorkaround</u> disables ConfigureNotify events that are usually sent to an application
           while it is moved. If some windows flicker annoyingly while being moved, this option may help you.
           Note that if this problem occurs it is not an fvwm bug, it is a problem of the application.

           <u>MixedVisualWorkaround</u> makes fvwm install the root colormap before it does some operations using the
           root window visuals. This is only useful when the <b>-visual</b> option is used to start fvwm and then only
           with some configurations of some servers (e.g. Exceed 6.0 with an 8 bit PseudoColor root and fvwm
           using a 24 bit TrueColor visual).

           The <u>ModalityIsEvil</u> option controls whether Motif applications have the ability to have modal dialogs
           (dialogs that force you to close them first before you can do anything else). The default is to not
           allow applications to have modal dialogs. Use this option with care. Once this option is turned on,
           you have to restart fvwm to turn it off.

           <u>RaiseOverNativeWindows</u> makes fvwm try to raise the windows it manages over native windows of the X
           server’s host system. This is needed for some X servers running under Windows, Windows NT or Mac OS
           X. Fvwm tries to detect if it is running under such an X server and initializes the flag accordingly.

           <u>RaiseOverUnmanaged</u> makes fvwm try to raise the windows it manages over override_redirect windows.
           This is used to cope with ill-mannered applications that use long-lived windows of this sort,
           contrary to ICCCM conventions. It is useful with the <u>Unmanaged</u> style option too.

           <u>FlickeringQtDialogsWorkaround</u> suppresses flickering of the focused window in some modules when using
           KDE or QT applications with application modal dialog windows. By default this option is turned on.
           This option may be visually disturbing for other applications using windows not managed by fvwm.
           Since these applications are rare it is most likely safe to leave this option at its default.

           <u>QtDragnDropWorkaround</u> suppresses the forwarding of unknown ClientEvent messages to windows — usually
           this is harmless, but Qt has problems handling unrecognised ClientEvent messages. Enabling this
           option might therefore help for Qt applications using DragnDrop. This option is off by default.

           <u>EWMHIconicStateWorkaround</u> is needed by EWMH compliant pagers or taskbars which represent windows
           which are on a different desktops as iconified. These pagers and taskbars use a version of the EWMH
           specification before version 1.2 (the current KDE 2 &amp; 3 versions). These pagers and taskbars use the
           IconicState WM_STATE state to determine if an application is iconified. This state, according to the
           ICCCM, does not imply that a window is iconified (in the usual sense). Turning on this option forces
           fvwm to establish an equivalence between the IconicState WM_STATE state and the iconified window.
           This violates ICCCM compliance but should not cause big problems. By default this option is off.

           With the <u>DisplayNewWindowNames</u> enabled, fvwm prints the name, icon name (if available), resource and
           class of new windows to the console. This can help in finding the correct strings to use in the <b>Style</b>
           command.

           When the <u>ExplainWindowPlacement</u> option is enabled, fvwm prints a message to the console whenever a
           new window is placed or <b>PlaceAgain</b>, is used. The message explains on which desk, page, screen and
           position it was placed and why. This option can be used to figure out why a specific window does not
           appear where you think it should.

           The <u>DebugCRMotionMethod</u> option enables some debugging code in the ConfigureRequest handling routines
           of fvwm. It is not helpful for the user, but if you report a bug to the fvwm team we may ask you to
           enable this option.

           The <u>TransliterateUtf8</u> option enables transliteration during conversions from utf-8 strings. By
           default fvwm will not transliterate during conversion, but will fall back to alternate strings
           provided by the clients if conversion from utf-8 fails due to characters which have no direct
           correspondence in the target charecter set. Some clients however neglect to set non utf-8 properties
           correctly in which case this option may help.

       <b>BusyCursor</b> [<u>Option</u> <u>bool</u>], ...
           This command controls the cursor during the execution of certain commands. <u>Option</u> can be <u>DynamicMenu</u>,
           <u>ModuleSynchronous</u>, <u>Read</u>, <u>Wait</u> or <u>*</u>. An option must be followed by a boolean argument <u>bool</u>. You can
           use commas to separate individual options. If you set an option to "True", then when the
           corresponding command is run, fvwm displays the cursor of the <u>WAIT</u> context of the <b>CursorStyle</b>
           command. "False" forces to not display the cursor. The default is:

               BusyCursor DynamicMenu False, ModuleSynchronous False, \
               Read False, Wait False

           The <u>*</u> option refers to all available options.

           The <u>Read</u> option controls the <b>PipeRead</b> command.

           The <u>DynamicMenu</u> option affects the <u>DynamicPopupAction</u> and <u>MissingSubmenuFunction</u> options of the
           <b>AddToMenu</b> command. If this option is set to "False", then the busy cursor is not displayed during a
           dynamic menu command even if this command is a <b>Read</b> or <b>PipeRead</b> command and the <u>Read</u> option is set to
           "True".

           The <u>ModuleSynchronous</u> option affects the <b>ModuleSynchronous</b> command. If this option is set to "False",
           then the busy cursor is not displayed while fvwm waits for a module started by <b>ModuleSynchronous</b> to
           complete its startup.

           The <u>Wait</u> option affects only the root cursor. During a wait pause the root cursor is replaced by the
           busy cursor and fvwm is still fully functional (you can escape from the pause, see the <b>EscapeFunc</b>
           command). If you want to use this option and if you do not use the default root cursor, you must set
           your root cursor with the <b>CursorStyle</b> command.

       <b>ClickTime</b> [<u>delay</u>]
           Specifies the maximum delay in milliseconds between a button press and a button release for the
           <b>Function</b> command to consider the action a mouse click. The default delay is 150 milliseconds.
           Omitting the delay value resets the <b>ClickTime</b> to the default.

           ClickTime also specifies the delay between two clicks to be interpreted as a double-click.

       <b>ColormapFocus</b> FollowsMouse | FollowsFocus
           By default, fvwm installs the colormap of the window that the cursor is in. If you use

               ColormapFocus FollowsFocus

           then the installed colormap is the one for the window that currently has the keyboard focus.

       <b>CursorStyle</b> <u>context</u> [<u>num</u> | <u>name</u> | None | Tiny | <u>file</u> [<u>x</u> <u>y</u>] [<u>fg</u> <u>bg</u>]]
           Defines a new cursor for the specified context. Note that this command can not control the shapes an
           applications uses, for example, to indicate that it is busy. The various contexts are:

           <u>POSITION</u> (top_left_corner)
               used when initially placing windows

           <u>TITLE</u> (top_left_arrow)
               used in a window title-bar

           <u>DEFAULT</u> (top_left_arrow)
               used in windows that do not set their cursor

           <u>SYS</u> (hand2)
               used in one of the title-bar buttons

           <u>MOVE</u> (fleur)
               used when moving or resizing windows

           <u>RESIZE</u> (sizing)
               used when moving or resizing windows

           <u>WAIT</u> (watch)
               used during certain fvwm commands (see <b>BusyCursor</b> for details)

           <u>MENU</u> (top_left_arrow)
               used in menus

           <u>SELECT</u> (crosshair)
               used when the user is required to select a window

           <u>DESTROY</u> (pirate)
               used for <b>Destroy</b>, <b>Close</b>, and <b>Delete</b> commands

           <u>TOP</u> (top_side)
               used in the top side-bar of a window

           <u>RIGHT</u> (right_side)
               used in the right side-bar of a window

           <u>BOTTOM</u> (bottom_side)
               used in the bottom side-bar of a window

           <u>LEFT</u> (left_side)
               used in the left side-bar of a window

           <u>TOP_LEFT</u> (top_left_corner)
               used in the top left corner of a window

           <u>TOP_RIGHT</u> (top_right_corner)
               used in the top right corner of a window

           <u>BOTTOM_LEFT</u> (bottom_left_corner)
               used in the bottom left corner of a window

           <u>BOTTOM_RIGHT</u> (bottom_right_corner)
               used in the bottom right corner of a window

           <u>TOP_EDGE</u> (top_side)
               used at the top edge of the screen

           <u>RIGHT_EDGE</u> (right_side)
               used at the right edge of the screen

           <u>BOTTOM_EDGE</u> (bottom_side)
               used at the bottom edge of the screen

           <u>LEFT_EDGE</u> (left_side)
               used at the left edge of the screen

           <u>ROOT</u> (left_ptr)
               used as the root cursor

       The defaults are shown in parentheses above. If you ever want to restore the default cursor for a
       specific context you can omit the second argument.

       The second argument is either the numeric value of the cursor as defined in the include file
       <u>X11/cursorfont.h</u> or its name (without the XC_ prefix). Alternatively, the xpm file name may be specified.
       The name can also be <u>None</u> (no cursor) or <u>Tiny</u> (a single pixel as the cursor).

           # make the kill cursor be XC_gumby (both forms work):
           CursorStyle DESTROY 56
           CursorStyle DESTROY gumby

       Alternatively, the cursor can be loaded from an (XPM, PNG or SVG) image <u>file</u>. If fvwm is compiled with
       Xcursor support, full ARGB is used, and (possibly animated) cursor files made with the <b>xcursorgen</b> program
       can be loaded. Otherwise the cursor is converted to monochrome.

       The optional <u>x</u> and <u>y</u> arguments (following a <u>file</u> argument) specifies the hot-spot coordinate with 0 0 as
       the top left corner of the image. Coordinates within the image boundary are valid and overrides any
       hot-spot defined in the (XPM/Xcursor) image file. An invalid or undefined hot-spot is placed in the
       center of the image.

           CursorStyle ROOT cursor_image.png 0 0

       The optional <u>fg</u> and <u>bg</u> arguments specify the foreground and background colors for the cursor, defaulting
       to black and white (reverse video compared to the actual bitmap). These colors are only used with
       monochrome cursors. Otherwise they are silently ignored.

           CursorStyle ROOT nice_arrow.xpm yellow black

       <b>DefaultFont</b> [<u>fontname</u>]
           <b>DefaultFont</b> sets the default font to font <u>fontname</u>. The default font is used by fvwm whenever no
           other font has been specified. To reset the default font to the built-in default, omit the argument.
           The default font is used for menus, window titles, icon titles as well as the geometry feedback
           windows during a move or resize operation. To override the default font in a specific context, use
           the <b>Style</b> * <u>Font</u>, <b>Style</b> * <u>IconFont</u>, or <b>MenuStyle</b> commands.

       <b>DefaultIcon</b> <u>filename</u>
           Sets the default icon which is used if a window has neither an client-supplied icon nor an icon
           supplied via the <u>Icon</u> option of the <b>Style</b> command.

       <b>DefaultLayers</b> <u>bottom</u> <u>put</u> <u>top</u>
           Changes the layers that are used for the <u>StaysOnBottom</u>, <u>StaysPut</u>, <u>StaysOnTop</u> <b>Style</b> options.
           Initially, the layers 2, 4 and 6 are used.

       <b>Deschedule</b> [<u>command_id</u>]
           Removes all commands that were scheduled with the id <u>command_id</u> with the <b>Schedule</b> command from the
           list of commands to be executed unless they were already executed. If the <u>command_id</u> is omitted, the
           value of the variable $[schedule.last] is used as the id.

       <b>Emulate</b> Fvwm | Mwm | Win
           This command is a catch all for how miscellaneous things are done by fvwm. Right now this command
           affects where the move/resize feedback window appears and how window placement is aborted. To have
           more Mwm- or Win-like behavior you can call <b>Emulate</b> with <u>Mwm</u> or <u>Win</u> as its argument. With Mwm resize
           and move feedback windows are in the center of the screen, instead of the upper left corner. This
           also affects how manual placement is aborted. See the <u>ManualPlacement</u> description.

       <b>EscapeFunc</b>
           By default the key sequence Ctrl-Alt-Escape allows for escaping from a <b>Wait</b> pause and from a locked
           <b>ModuleSynchronous</b> command. The <b>EscapeFunc</b> command used with the <b>Key</b> command allows for configuring
           this key sequence. An example:

               Key Escape A MC -
               Key Escape A  S EscapeFunc

           replaces the Ctrl-Alt-Escape  key sequence with Shift-Escape for aborting a <b>Wait</b> pause and
           <b>ModuleSynchronous</b> command. <b>EscapeFunc</b> used outside the <b>Key</b> command does nothing.

       <b>FakeClick</b> [<u>command</u> <u>value</u>] ...
           This command is mainly intended for debugging fvwm and no guarantees are made that it works for you.
           <u>FakeClick</u> can simulate mouse button press and release events and pass them to fvwm or the
           applications. The parameters are a list of commands which consist of pairs of <u>command</u> tokens and
           integer <u>values</u>, The <u>press</u> and <u>release</u> commands are followed by the appropriate mouse button number
           and generate a button press or release event on the window below the pointer. The <u>wait</u> commands
           pauses fvwm for the given number of milliseconds. The <u>modifiers</u> command simulates pressing or
           releasing modifier keys. The values 1 to 5 are mapped to Mod1 to Mod5 while 6, 7 and 8 are mapped to
           Shift, Lock and Control. The modifier is set for any further button events. To release a modifier
           key, use the corresponding negative number. The <u>depth</u> command determines to which window the button
           events are sent. With a depth of 1, all events go to the root window, regardless of the pointer’s
           position. With 2, the event is passed to the top level window under the pointer which is usually the
           frame window. With 3, events go to the client window. Higher numbers go to successive sub windows.
           Zero (0) goes to the smallest window that contains the pointer. Note that events propagate upward.

               FakeClick depth 2 press 1 wait 250 release 1

           This simulates a click with button 1 in the parent window (depth 2) with a delay of 250 milliseconds
           between the press and the release. Note: all command names can be abbreviated with their first
           letter.

       <b>FakeKeypress</b> [<u>command</u> <u>value</u>] ...
           This command is mainly intended for debugging fvwm and no guarantees are made that it works for you.
           <b>FakeKeypress</b> can simulate key press and release events and pass them to fvwm or applications. The
           parameters are a list of commands which consist of pairs of command tokens and values. The <u>press</u> and
           <u>release</u> commands are followed by a key name. The key name is a standard X11 key name as defined in
           <u>/usr/include/X11/keysymdef.h</u>, (without the <u>XK</u><b>_</b> prefix), or the keysym database
           <u>/usr/X11R6/lib/X11/XKeysymDB</u>. The <u>wait</u>, <u>modifiers</u> and <u>depth</u> commands are the same as those used by
           <b>FakeClick</b>.

           Save all GVim sessions with: "Esc:w\n"

               All (gvim) FakeKeypress press Escape \
                                 press colon \
                                 press w \
                                 press Return

           Save &amp; exit all GVim sessions with: "Esc:wq\n"

               All (gvim) FakeKeypress press Escape \
                                 press colon \
                                 press w \
                                 press q \
                                 press Return

           Send A to a specific window:

               WindowId 0x3800002 FakeKeypress press A

           Note: all command names can be abbreviated with their first letter.

       <b>ImagePath</b> <u>path</u>
           Specifies a colon separated list of directories in which to search for images (both monochrome and
           pixmap). To find an image given by a relative pathname, fvwm looks into each directory listed in
           turn, and uses the first file found.

           If a directory is given in the form "/some/dir;.ext", this means all images in this directory have
           the extension ".ext" that should be forced. The original image name (that may contain another
           extension or no extension at all) is not probed, instead ".ext" is added or replaces the original
           extension. This is useful, for example, if a user has some image directories with ".xpm" images and
           other image directories with the same names, but ".png" images.

           The <u>path</u> may contain environment variables such as <u>$HOME</u> (or <u>${HOME}</u>). Further, a '+' in the <u>path</u> is
           expanded to the previous value of the path, allowing appending or prepending to the path easily.

           For example:

               ImagePath $HOME/icons:+:/usr/include/X11/bitmaps

       <b>LocalePath</b> <u>path</u>
           Specifies a colon separated list of "locale path" in which to search for string translations. A
           locale path is constituted by a directory path and a text domain separated by a semicolon (';'). As
           an example the default locale path is:

               /install_prefix/share/locale;fvwm

           where install_prefix is the fvwm installation directory. With such a locale path translations are
           searched for in

               /install_prefix/share/locale/lang/LC_MESSAGES/fvwm.mo

           where <u>lang</u> depends on the locale. If no directory is given the default directory path is assumed. If
           no text domain is given, <b>fvwm</b> is assumed. Without argument the default locale path is restored.

           As for the <b>ImagePath</b> command, <u>path</u> may contain environment variables and a '+' to append or prepend
           the locale path easily.

           For example, the fvwm-themes package uses

               LocalePath ";fvwm-themes:+"

           to add locale catalogs.

           The default fvwm catalog contains a few strings used by the fvwm executable itself (Desk and
           Geometry) and strings used in some default configuration files and <b>FvwmForm</b> configuration. You can
           take a look at the po/ subdirectory of the fvwm source to get the list of the strings with a possible
           translation in various languages. At present, very few languages are supported.

           The main use of locale catalogs is via the "$[gt.string]" parameter:

               DestroyMenu MenuFvwmWindowOps
               AddToMenu   MenuFvwmWindowOps "$[gt.Window Ops]" Title
               + "$[gt.&amp;Move]"              Move
               + "$[gt.&amp;Resize]"            Resize
               + "$[gt.R&amp;aise]"             Raise
               + "$[gt.&amp;Lower]"             Lower
               + "$[gt.(De)&amp;Iconify]"       Iconify
               + "$[gt.(Un)&amp;Stick]"         Stick
               + "$[gt.(Un)Ma&amp;ximize]"      Maximize
               + "" Nop
               + "$[gt.&amp;Close]"             Close
               + "$[gt.&amp;Destroy]"           Destroy

           gives a menu in the locale languages if translations are available.

           Note that the <b>FvwmScript</b> module has a set of special instructions for string translation. It is out
           of the scope of this discussion to explain how to build locale catalogs. Please refer to the GNU
           gettext documentation.

       <b>PrintInfo</b> <u>subject</u> [<u>verbose</u>]
           Print information on <u>subject</u> to debug log file, which defaults to <u>$HOME/.fvwm/fvwm3-output.log</u> .
           Environment variables <u>$FVWM_USERDIR</u> and <u>$FVWM3_LOGFILE</u> can alter this default. For this logfile to be
           written, either fvwm3 has to be started with <b>-v</b> option or <b>SIGUSR2</b> signal can be used to toggle
           opening/closing debug log file.

           An optional integer argument to debug log file, which defaults to <u>$HOME/.fvwm/fvwm3-output.log</u> .
           Environment variables <u>$FVWM_USERDIR</u> and <u>$FVWM3_LOGFILE</u> can alter this default. For this logfile to be
           written, either fvwm3 has to be started with <b>-v</b> option or <b>SIGUSR2</b> signal can be used to toggle
           opening/closing debug log file.

           An optional integer argument <u>verbose</u> defines the level of information which is given. The current
           valid subjects are:

           <u>Colors</u> which prints information about the colors used by fvwm. This useful on screens which can only
           display 256 (or less) colors at once. If <u>verbose</u> is one or greater the palette used by fvwm is
           printed. If you have a limited color palette, and you run out of colors, this command might be
           helpful.

           <u>ImageCache</u> which prints information about the images loaded by fvwm. If <u>verbose</u> is one or greater all
           images in the cache will be listed together with their respective reuse.

           <u>Locale</u> which prints information on your locale and the fonts that fvwm used. <u>verbose</u> can be 1 or 2.

           <u>nls</u> which prints information on the locale catalogs that fvwm used

           <u>bindings</u> which prints information on all the bindings fvwm has: key and mouse bindings. <u>verbose</u> has
           no effect with this option.

           <u>infostore</u> which prints information on all entries in the infostore, listing the key and its value.
           <u>verbose</u> has no effect with this option.

       <b>Schedule</b> [<u>Periodic</u>] <u>delay_ms</u> [<u>command_id</u>] <u>command</u>
           The <u>command</u> is executed after about <u>delay_ms</u> milliseconds. This may be useful in some tricky setups.
           The <u>command</u> is executed in the same context window as the <b>Schedule</b> command. An optional integer
           argument <u>command_id</u> may be given in decimal, hexadecimal or octal format. This id can be used with
           the <b>Deschedule</b> command to remove the scheduled command before it is executed. If no id is given, fvwm
           uses negative id numbers, starting with -1 and decreasing by one with each use of the <b>Schedule</b>
           command. Note that the <b>Schedule</b> command and its arguments undergo the usual command line expansion,
           and, when <u>command</u> is finally executed, it is expanded again. It may therefore be necessary to quote
           the parts of the command that must not be expanded twice.

           Note: A window’s id as it is returned with $[w.id] can be used as the <u>command_id</u>. Example:

               Current Schedule 1000 $[w.id] WindowShade

           The <b>Schedule</b> command also supports the optional keyword <u>Periodic</u> which indicates that the <u>command</u>
           should be executed every <u>delay_ms</u>. Example:

               Schedule Periodic 10000 PipeRead '[ -N "$MAIL" ] &amp;&amp; echo \
                Echo You have mail'

           Use the <b>Deschedule</b> command to stop periodic commands.

       <b>State</b> <u>state</u> [<u>bool</u>]
           Sets, clears or toggles one of the 32 user defined states which are associated with each window. The
           <u>state</u> is a number ranging from 0 to 31. The states have no meaning in fvwm, but they can be checked
           in conditional commands like <b>Next</b> with the <u>State</u> condition. The optional argument <u>bool</u> is a boolean
           argument. "True" sets the given state, while "False" clears it. Using "toggle" switches to the
           opposite state. If the <u>bool</u> argument is not given, the state is toggled.

       <b>WindowList</b> [(<u>conditions</u>)] [<u>position</u>] [<u>options</u>] [<u>double-click-action</u>]
           Generates a pop-up menu (and pops it up) in which the title and geometry of each of the windows
           currently on the desktop are shown.

           The format of the geometry part is: <u>desk</u>(<u>layer</u>): <u>x-geometry</u> <u>sticky</u>, where <u>desk</u> and <u>layer</u> are the
           corresponding numbers and <u>sticky</u> is empty or a capital S. The geometry of iconified windows is shown
           in parentheses. Selecting an item from the window list pop-up menu causes the interpreted function
           "WindowListFunc" to be run with the window id of that window passed in as $0. The default
           "WindowListFunc" looks like this:

               AddToFunc WindowListFunc
               + I Iconify off
               + I FlipFocus
               + I Raise
               + I WarpToWindow 5p 5p

           You can destroy the built-in "WindowListFunc" and create your own if these defaults do not suit you.

           The window list menu uses the "WindowList" menu style if it is defined (see <b>MenuStyle</b> command).
           Otherwise the default menu style is used. To switch back to the default menu style, issue the command

               DestroyMenuStyle WindowList

           Example:

               MenuStyle WindowList SelectOnRelease Meta_L

           The <u>conditions</u> can be used to exclude certain windows from the window list. Please refer to the
           <b>Current</b> command for details. Only windows that match the given conditions are displayed in the window
           list. The <u>options</u> below work vice versa: windows that would otherwise not be included in the window
           list can be selected with them. The <u>conditions</u> always override the <u>options</u>.

           The <u>position</u> arguments are the same as for <b>Menu</b>. The command <u>double-click-action</u> is invoked if the
           user double-clicks (or hits the key rapidly twice if the menu is bound to a key) when bringing the
           window list. The <u>double-click-action</u> must be quoted if it consists of more than one word.

           The <u>double-click-action</u> is useful to define a default window if you have bound the window list to a
           key (or button) like this:

               # Here we call an existing function, but
               # it may be different.  See the default
               # WindowListFunc definition earlier in this
               # man page.
               AddToFunc SwitchToWindow
               + I WindowListFunc

               Key Tab A M WindowList "Prev SwitchToWindow"

           Hitting Alt-Tab once it brings up the window list, if you hit it twice the focus is flipped between
           the current and the last focused window. With the proper <u>SelectOnRelease</u> menu style (see example
           above) a window is selected as soon as you release the Alt key.

           The <u>options</u> passed to WindowList are separated by commas and can be <u>Geometry</u> / <u>NoGeometry</u> /
           <u>NoGeometryWithInfo</u>, <u>NoDeskNum,</u> <u>NoLayer,</u> <u>NoNumInDeskTitle</u>, <u>NoCurrentDeskTitle</u>, <u>MaxLabelWidth</u> <u>width</u>,
           <u>TitleForAllDesks</u>, <u>Function</u> <u>funcname</u>, <u>Desk</u> <u>desknum</u>, <u>CurrentDesk</u>, <u>NoIcons</u> / <u>Icons</u> / <u>OnlyIcons</u>, <u>NoNormal</u>
           / <u>Normal</u> / <u>OnlyNormal</u>, <u>NoSticky</u> / <u>Sticky</u> / <u>OnlySticky</u>, <u>NoStickyAcrossPages</u> / <u>StickyAcrossPages</u> /
           <u>OnlyStickyAcrossPages</u>, <u>NoStickyAcrossDesks</u> / <u>StickyAcrossDesks</u> / <u>OnlyStickyAcrossDesks</u>, <u>NoOnTop</u> /
           <u>OnTop</u> / <u>OnlyOnTop</u>, <u>NoOnBottom</u> / <u>OnBottom</u> / <u>OnlyOnBottom</u>, <u>Layer</u> <u>m</u> <u>[n]</u>, <u>UseSkipList</u> / <u>OnlySkipList</u>,
           <u>NoDeskSort</u>, <u>ReverseOrder</u>, <u>CurrentAtEnd</u>, <u>IconifiedAtEnd</u>, <u>UseIconName</u>, <u>Alphabetic</u> / <u>NotAlphabetic</u>,
           <u>SortByResource</u>, <u>SortByClass</u>, <u>NoHotkeys</u>, <u>SelectOnRelease</u> ,<u>ShowPage</u>, <u>ShowPageX</u>, <u>ShowPageY</u>, <u>ShowScreen</u>.

           (Note - normal means not iconic, sticky, or on top)

           With the <u>SortByResource</u> option windows are alphabetically sorted first by resource class, then by
           resource name and then by window name (or icon name if <u>UseIconName</u> is specified). <u>ReverseOrder</u> also
           works in the expected manner.

           With the <u>SortByClass</u> option windows are sorted just like with <u>SortByResource</u>, but the resource name
           is not taken into account, only the resource class.

           The <u>SelectOnRelease</u> option works exactly like the <b>MenuStyle</b> option with the same name, but overrides
           the option given in a menu style. By default, this option is set to the left

           key. To switch it off, use <u>SelectOnRelease</u> without a key name.

           If you pass in a function via <b>Function</b> funcname, it is called within a window context of the selected
           window:

               AddToFunc IFunc I Iconify toggle
               WindowList Function IFunc, NoSticky, CurrentDesk, NoIcons

           If you use the <u>Layer</u> <u>m</u> [<u>n</u>] option, only windows in layers between m and n are displayed. n defaults
           to m. With the <u>ReverseOrder</u> option the order of the windows in the list is reversed.

           With the <u>CurrentAtEnd</u> option the currently focused window (if any) is shown at the bottom of the
           list. This is mostly intended for simulating the Alt-Tab behavior in another GUI.

           <u>IconifiedAtEnd</u> makes iconified windows be moved to the end of the list. This is also from another
           GUI.

           The <u>NoGeometry</u> option causes fvwm to not display the geometries as well as the separators which
           indicate the different desktops. <u>NoGeometryWithInfo</u> removes the geometries, but keep the desktop
           information and indicates iconic windows. <u>NoDeskNum</u> causes fvwm to not display the desktop number in
           the geometry or before the window title with the <u>NoGeometryWithInfo</u> option. <u>NoNumInDeskTitle</u> is only
           useful if a desktop name is defined with the <b>DesktopName</b> command. It causes fvwm to not display the
           desktop number before the desktop name. By default, the WindowList menu have a title which indicates
           the current desk or the selected desktop if the <u>Desk</u> condition is used. The <u>NoCurrentDeskTitle</u> option
           removes this title. <u>TitleForAllDesks</u> causes fvwm to add a menu title with the desk name and/or number
           before each group of windows on the same desk. With <u>NoLayer</u>, the layer of the window is not
           displayed. The options <u>ShowPage</u>, <u>ShowPageX</u> and <u>ShowPageY</u> enable displaying the page of the window
           rounded multiples of the display size. With <u>ShowScreen</u>, the window’s screen name is displayed.

           The <u>MaxLabelWidth</u> option takes the number of characters to print as its argument. No more than that
           many characters of the window name are visible.

           If you wanted to use the <b>WindowList</b> as an icon manager, you could invoke the following:

               WindowList OnlyIcons, Sticky, OnTop, Geometry

           (Note - the <u>Only</u> options essentially wipe out all other ones... but the <u>OnlyListSkip</u> option which
           just causes <b>WindowList</b> to only consider the windows with <u>WindowListSkip</u> style.)

       <b>XSync</b>
           When <b>XSync</b> is called, the X function with the same name is used to send all pending X requests to the
           server. This command is intended for debugging only.

       <b>XSynchronize</b> [bool]
           The <b>XSynchronize</b> command controls whether X requests are sent to the X server immediately or not.
           Normally, requests are sent in larger batches to save unnecessary communication. To send requests
           immediately, use "True" as the argument, to disable this use "False" or to toggle between both
           methods use "Toggle" or omit the <b>bool</b> argument. Fvwm defaults to synchronized requests when started
           with the <b>--debug</b> option. This command is intended for debugging only.

       <b>+</b>
           Used to continue adding to the last specified decor, function or menu. See the discussion for
           <b>AddToDecor</b>, <b>AddToFunc</b>, and <b>AddToMenu</b>.

   <b>Window</b> <b>Movement</b> <b>and</b> <b>Placement</b>
       <b>AnimatedMove</b> <u>x</u> <u>y</u> [Warp]
           Move a window in an animated fashion. Similar to <b>Move</b> command. The options are the same, except they
           are required, since it doesn’t make sense to have a user move the window interactively and
           animatedly. If the optional argument <u>Warp</u> is specified the pointer is warped with the window.

       <b>GeometryWindow</b> Hide | Show | Colorset <u>n</u> | Position <u>x</u> <u>y</u> | Screen <u>S</u>
           Configures the position or size window that is usually shown when a window is moved or resized
           interactively. This can be used to hide, show, change the colorset, change the location, or change
           the screen of the geometry window. Multiple options can be set at once separated by spaces. Details
           of each option are described below.

               GeometryWindow Hide [Never | Move | Resize]

           Hides or switches off the geometry window. If the optional parameters <u>Move</u> or <u>Resize</u> are given, it
           will only hide the geometry window during the respective operation. The parameter <u>Never</u> will switch
           the geometry back on again (equivalent to <u>Show</u>).

               GeometryWindow Show [Never | Move | Resize]

           Shows or switches on the geometry window (equivalent to <u>Hide</u> <u>Never</u>). If the optional parameters <u>Move</u>
           or <u>Resize</u> are given, it will only show the geometry window during the respective operation. The
           parameter <u>Never</u> will switch the geometry window off (equivalent to <u>Hide</u>).

               GeometryWindow Colorset _cset_

           Sets colorset of the gometry window to <u>cset</u>. Use the literal option <u>default</u> for <u>cset</u> to use the
           default colorset.

               GeometryWindow Position [+|-]_x_[p] [+|-]_y_[p]

           Configures the position the geometry window appears. <u>x</u> and <u>y</u> are the relative coordinates as a
           percentage of the screen size. If a leading '-' is provided the coordinates are computed from the
           left/bottom of the screen respectively. If the coordinates are appended with a 'p', they are
           interpreted as the number of pixels from the respective screen edge. If no position arguments are
           given, the geometry window’s position will return to its default state of the upper left corner or
           the center if emulating MWM.

               GeometryWindow Screen _RANDRNAME_

           Configure which screen the geometry window is shown on. By default the geometry window is shown on
           the current screen. If a valid <u>RANDRNAME</u> is provided, the geometry window will always be shown on
           that screen. Use <u>current</u> as the <u>RANDRNAME</u> to return the default.

           Examples:

               # Position the geometry window in the center of the screen
               GeometryWindow Position 50 50
               # Position the geometry window next to the RightPanel
               GeometryWindow Position -120p 0
               # Use colorset 2 for the geometry window
               GeometryWindow Colorset 2
               # Only show the geometry window on the primary monitor
               GeometryWindow Screen $[monitor.primary]
               # Hide the geometry window
               GeometryWindow Hide

       <b>Layer</b> [<u>arg1</u> <u>arg2</u>] | [default]
           Puts the current window in a new layer. If <u>arg1</u> is non zero then the next layer is the current layer
           number plus <u>arg1</u>. If <u>arg1</u> is zero then the new layer is <u>arg2</u>.

           As a special case, <u>default</u> puts the window in its default layer, i.e. the layer it was initially in.
           The same happens if no or invalid arguments are specified.

       <b>Lower</b>
           Allows the user to lower a window. Note that this lowers a window only in its layer. To bring a
           window to the absolute bottom, use

               AddToFunc lower-to-bottom
                + I Layer 0 0
                + I Lower

       <b>Move</b> [<u>options</u>]
           Allows the user to move a window. If called from somewhere in a window or its border, then that
           window is moved. If called from the root window, then the user is allowed to select the target
           window.   Move can be called with various options to either start an interactive move, specify the
           position to move, or a direction.

           <b>Move</b> without options starts an interactive move. The window may snap to other windows and screen
           boundaries, configurable with the <b>SnapAttraction</b> style. Moving a window to the edge of the screen can
           be used to drag the window to other pages. (See <b>EdgeScroll</b>, and the <u>EdgeMoveDelay</u> style for more
           information.)

           Holding down <u>Alt</u> disables snapping and allows one to switch pages without any delay. Interactive
           movement can be aborted with the <u>Escape</u> key or any mouse button not set to place the window. By
           default mouse button 2 is set to cancel the move operation. To change this you may use the <b>Mouse</b>
           command with special context 'P' for Placement.

           The window condition <u>PlacedByButton</u> can be used to check if a specific button was pressed to place
           the window (see <b>Current</b> command).

           If the single argument <u>pointer</u> is given, the top left corner of the window is moved to the pointer
           position before starting an interactive move; this is mainly intended for internal use by modules
           like <b>FvwmPager</b>.

               Move pointer

           To move a window in a given direction until it hits another window, icon, or screen boundary use:

               Move shuffle [options] _direction_(s)

           The <u>direction</u> can be <u>North</u>/<u>N</u>/<u>Up</u>/<u>U</u>, <u>East</u>/<u>E</u>/<u>Right</u>/<u>R</u>, <u>South</u>/<u>S</u>/<u>Down</u>/<u>D</u>, or <u>West</u>/<u>W</u>/<u>Left</u>/<u>L</u>. The window will
           move in the given direction until it hits another window or the <b>EwmhBaseStruts</b>/screen boundary. When
           a window is at the <b>EwmhBaseStruts</b>/screen boundary, it will move to the next monitor in the given
           direction, if it exists. If a window is outside of the current working area (partly off screen), it
           will move to the edge of the working area. Windows will honor the EWMH working area and stop at the
           <b>EwmhBaseStruts</b> unless the literal option <u>ewmhiwa</u> is given. If multiple <u>direction</u>(s) are given, the
           window will move the directions in the order of the sequence stated.

           The literal option <u>Warp</u> will warp the mouse pointer to the window. The literal option <u>all_windows</u>
           will consider all windows on the same monitor instead of just the windows in the path the window is
           moving. This allows moving to the boundary of a window it is next too. The literal option <u>both_sides</u>
           will consider both the close side and the far side of the window (by default only the close side is
           considered).

           If the literal option <u>snap</u> followed by a snap <u>type</u> of <u>windows</u>, <u>icons</u>, or <u>same</u> is given, then the
           window will only stop if it hits another window, icon, or the same type. If the literal option <u>layers</u>
           followed by two integers specifying a <u>min</u> layer and <u>max</u> layer is given, then only windows on the
           layers between <u>min</u> and <u>max</u> layers will stop the window. For example:

               # Shuffle the window Right.
               Move shuffle Right
               # Shuffle Up, only consider windows on Layer 3.
               Move shuffle layers 3 3 Up
               # Shuffle Left then Up
               Move shuffle Left Up
               # Shuffle Up then Left (may not be same position as above)
               Move shuffle Up Left

           Move can be used to moved a window to a specified position:

               Move [screen _S_] [desk _N_] [w | m | v]_x_[p | w] \
                    [w | m | v]_y_[p | w] [Warp] [ewmhiwa]

           This will move the window to the <u>x</u> and <u>y</u> position (see below). By default, the EWMH working area of
           each monitor is honoured (the working area for each monitor is set via <b>EwmhBaseStruts</b> and honors any
           strut hints provided by windows on the monitor). This means that if a window is placed outside the
           working area, the position of the window will be adjusted to fit inside the working area of the
           screen the center of the window is on. If the trailing option <u>ewmhiwa</u> is given, then the window
           position will ignore the working area and its position will not be adjusted (this option is needed to
           move windows off the screen and to have full control of where it is placed). If the option <u>Warp</u> is
           given then the pointer is warped to the window.

           If the literal option <u>screen</u> followed by a RandR screen name <u>S</u> is specified, the coordinates are
           interpreted as relative to the given screen. The width and height of the screen are used for the
           calculations instead of the display dimensions. The <u>screen</u> is interpreted as in the <b>MoveToScreen</b>
           command.

           If the literal option <u>desk</u> followed by a desk number <u>N</u> is specified, place the window on the
           specified desk after it has been moved. This can serve two purposes, first you can move a window’s
           position and desk in a single command. Second when a window is moved between monitors, its desk is
           updated to be the same as the new monitor. This option can override that behavior by specifying which
           desk the window should end up on.

           The positional arguments <u>x</u> and <u>y</u> can specify an absolute or relative position from either the
           left/top (positive values) or right/bottom (negative values) of the global screen (the bounding box
           that contains all monitors) or specified <u>screen</u>. By default, the numeric value given is interpreted
           as a percentage of the screen’s width/height, but a trailing '<u>p</u>' changes the interpretation to mean
           pixels, while a trailing '<u>w</u>' means percent of the window width/height. To move the window relative to
           its current position, add the '<u>w</u>' (for "window") prefix before the <u>x</u> and/or <u>y</u> value. To move the
           window to a position relative to the current location of the pointer, add the '<u>m</u>' (for "mouse")
           prefix. To move the window relative to the virtual screen coordinates, add the '<u>v</u>' (for "virtual
           screen") prefix. This is mostly for internal use with FvwmPager, but can be used to give exact
           coordinates on the virtual screen and is best used with the '<u>p</u>' suffix. To leave either coordinate
           unchanged, "<u>keep</u>" can be specified in place of <u>x</u> or <u>y</u>.

           For advanced uses, the arguments <u>x</u> and <u>y</u> can be used multiple times, but without the prefix '<u>m</u>' or
           '<u>w</u>'. (See complex examples below).

           Simple Examples:

               # Interactive move
               Mouse 1 T A Move
               # Move window to top left is at (10%,10%)
               Mouse 2 T A Move 10 10
               # Move top left to (10pixels,10pixels)
               Mouse 3 T A Move 10p 10p

           More complex examples (these can be bound as actions to keystrokes, etc.; only the command is shown,
           though):

               # Move window so bottom right is at bottom
               # right of screen
               Move -0 -0

               # Move window so top left corner is 10 pixels
               # off the top left screen edge
               Move +-10 +-10

               # Move window 5% to the right, and to the
               # middle vertically
               Move w+5 50

               # Move window up 10 pixels, and so left edge
               # is at x=40 pixels
               Move 40p w-10p

               # Move window to the mouse pointer location
               Move m+0 m+0

               # Move window to center of screen (50% of screen
               # position minus 50% of widow size).
               Move 50-50w 50-50w

           See also the <b>AnimatedMove</b> command.

       <b>MoveToDesk</b> [prev | <u>arg1</u> [<u>arg2</u>] [<u>min</u> <u>max</u>]]
           Moves the selected window to another desktop. The arguments are the same as for the <b>GotoDesk</b> command.
           Without any arguments, the window is moved to the current desk.

       <b>MoveThreshold</b> [<u>pixels</u>]
           When the user presses a mouse button upon an object fvwm waits to see if the action is a click or a
           drag. If the mouse moves by more than <u>pixels</u> pixels it is assumed to be a drag.

           Previous versions of fvwm hardwired <u>pixels</u> to 3, which is now the default value. If <u>pixels</u> is
           negative or omitted the default value (which might be increased when 16000x9000 pixel displays become
           affordable) is restored.

       <b>MoveToPage</b> [<u>options</u>] [<u>x</u>[p | w] <u>y</u>[p | w]] | [prev]
           Moves the selected window to another page (<u>x</u>,<u>y</u>). The upper left page is (0,0), the upper right is
           (M,0), where M is one less than the current number of horizontal pages specified in the <b>DesktopSize</b>
           command. Similarly the lower left page is (0,N), and the lower right page is (M,N). Negative page
           numbers refer to pages from the rightmost/lowest page. If <u>x</u> and <u>y</u> are not given, the window is moved
           to the current page (a window that has the focus but is off-screen can be retrieved with this).
           Moving windows to a page relative to the current page can be achieved by adding a trailing '<u>p</u>' after
           any or both numerical arguments. To move the window relative to its current location, add a trailing
           '<u>w</u>'. To move a window to the previous page use <u>prev</u> as the single argument.

           Windows are usually not moved beyond desk boundaries.

           Possible <u>options</u> are <u>wrapx</u> and <u>wrapy</u> to wrap around the x or y coordinate when the window is moved
           beyond the border of the desktop. For example, with <u>wrapx</u>, when the window moves past the right edge
           of the desktop, it reappears on the left edge. The options <u>nodesklimitx</u> and <u>nodesklimity</u> allow moving
           windows beyond the desk boundaries in x and y direction (disabling the <u>wrapx</u> and <u>wrapy</u> options).

           Examples:

               # Move window to page (2,3)
               MoveToPage 2 3

               # Move window to lowest and rightmost page
               MoveToPage -1 -1

               # Move window to last page visited
               MoveToPage prev

               # Move window two pages to the right and one
               # page up, wrap at desk boundaries
               MoveToPage wrapx wrapy +2p -1p

       <b>MoveToScreen</b> [<u>screen</u>]
           Moves the selected window to another screen. The <u>screen</u> argument must be a valid RandR name.

       <b>OpaqueMoveSize</b> [<u>percentage</u>]
           Tells fvwm the maximum size window with which opaque window movement should be used. The percentage
           is percent of the total screen area (may be greater than 100). With

               OpaqueMoveSize 0

           all windows are moved using the traditional rubber-band outline. With

               OpaqueMoveSize unlimited

           or if a negative percentage is given all windows are moved as solid windows. The default is

               OpaqueMoveSize 5

           which allows small windows to be moved in an opaque manner but large windows are moved as
           rubber-bands. If <u>percentage</u> is omitted or invalid the default value is set. To resize windows in an
           opaque manner you can use the <u>ResizeOpaque</u> style. See the <b>Style</b> command.

       <b>PlaceAgain</b> [Anim] [Icon]
           Causes the current window’s position to be re-computed using the initial window placement logic. The
           window is moved to where it would have been if it were a new window that had just appeared. Most
           useful with <u>Smart</u> or <u>Clever</u> (<u>ReallySmart</u>) placement. With the optional argument <u>Anim</u> an animated move
           is used to place the window in its new position. With the additional option <u>Icon</u>, the icon is placed
           again instead.

       <b>Raise</b>
           Allows the user to raise a window. Note that this raises a window only in its layer. To bring a
           window to the absolute top, use

               AddToFunc raise-to-top
                + I Layer 0 ontop
                + I Raise

           where ontop is the highest layer used in your setup.

       <b>RaiseLower</b>
           Alternately raises and lowers a window. The window is raised if it is obscured by any window (except
           for its own transients when <u>RaiseTransient</u> style is used; see the <b>Style</b> command) otherwise it is
           lowered.

       <b>Resize</b> [[frame] [direction <u>dir</u>] [warptoborder <u>automatic</u>] [fixeddirection] <u>width</u>[p | c | wa | da] <u>height</u>[p
       | c]]
           Allows for resizing a window. If called from somewhere in a window or its border, then that window is
           resized. If called from the root window then the user is allowed to select the target window.

           <b>Resize</b> without options starts an interactive resize.

           If the <u>EdgeResizeDelay</u> style is set or the <u>Alt</u> key is held down, the window can be resized across the
           edge of the screen.

           The operation can be aborted with the <u>Escape</u> key or by pressing any mouse button (except button 1
           which confirms it).

           If the optional arguments <u>width</u> and <u>height</u> are provided, then the window is resized so that its
           dimensions are <u>width</u> by <u>height</u>. The units of <u>width</u> and <u>height</u> are percent-of-screen, unless a letter
           '<u>p</u>' is appended to one or both coordinates, in which case the location is specified in pixels. With a
           '<u>c</u>' suffix the unit defined by the client application (hence the c) is used. With the suffix '<u>wa</u>' the
           value is a percentage of the width or height size of the EWMH working area, and with the suffix '<u>da</u>'
           it is a percentage of the width or height of the EWMH dynamic working area. So you can say

               Resize 80c 24c

           to make a terminal window just big enough for 80x24 characters.

           If the <u>width</u> or <u>height</u> is prefixed with the letter '<u>w</u>' the size is not taken as an absolute value but
           added to the current size of the window. Example:

               # Enlarge window by one line
               Resize keep w+1c

           Both, <u>width</u> and <u>height</u> can be negative. In this case the new size is the screen size minus the given
           value. If either value is "<u>keep</u>", the corresponding dimension of the window is left untouched. The
           new size is the size of the client window, thus

               Resize 100 100

           may make the window bigger than the screen. To base the new size on the size of the whole fvwm
           window, add the <u>frame</u> option after the command. The options <u>fixeddirection</u>, <u>direction</u> and
           <u>warptoborder</u> are only used in interactive move operations. With <u>fixeddirection</u> the same border is
           moved even if the pointer moves past the opposite border. The <u>direction</u> option must be followed by a
           direction name such as "NorthWest", "South" or "East" (you get the idea). Resizing is started
           immediately, even if the pointer is not on a border. If the special option <u>automatic</u> is given as a
           direction argument, then the direction to resize is calculated based on the position of the pointer
           in the window. If the pointer is in the middle of the window, then no direction is calculated. The
           <u>warptoborder</u> option can be used to warp the pointer to the direction indicated. As with the <u>automatic</u>
           option for <u>direction</u>, the border to warp to is calculated based on the pointer’s proximity to a given
           border. Also, if resizing is started by clicking on the window border, the pointer is warped to the
           outer edge of the border.

               AddToFunc ResizeSE I Resize Direction SE
               Mouse 3 A M ResizeSE

       <b>Resize</b> [bottomright | br <u>x</u> <u>y</u>]
           An alternate syntax is used if the keyword <u>bottomright</u> or in short <u>br</u> follows the command name. In
           this case, the arguments <u>x</u> and <u>y</u> specify the desired position of the bottom right corner of the
           window. They are interpreted exactly like the <u>x</u> and <u>y</u> arguments of the <b>Move</b> command. Actually, any of
           the options accepted by the <b>Move</b> command can be used.

       <b>ResizeMaximize</b> [<u>resize-arguments</u>]
           Combines the effects of <b>Resize</b> and <b>Maximize</b> in a single command. When used on a maximized window, the
           window is resized and is still in the maximized state afterwards. When used on an unmaximized window,
           the window is resized and put into the maximized state afterwards. This is useful if the user wants
           to resize the window temporarily and then return to the original geometry. The <u>resize-arguments</u> are
           the same as for the <b>Resize</b> command.

       <b>ResizeMove</b> <u>resize-arguments</u> <u>move-arguments</u>
           This command does the same as the <b>Resize</b> and <b>Move</b> commands, but in a single call which is less
           visually disturbing. The <u>resize-arguments</u> are exactly the same arguments as for the <b>Resize</b> command
           and the <u>move-arguments</u> are exactly the same arguments as for the <b>Move</b> command except the <u>pointer</u>
           option which is not supported by the <b>ResizeMove</b> command.

           Examples:

               # Move window to top left corner and cover
               # most of the screen
               ResizeMove -10p -20p 0 0

               # Grow the focused window towards the top of screen
               Current Resize keep w+$[w.y]p keep 0

           Note: Fvwm may not be able to parse the command properly if the option <u>bottomright</u> of the <b>Resize</b>
           command is used.

       <b>ResizeMoveMaximize</b> <u>resize-arguments</u> <u>move-arguments</u>
           Combines the effects of <b>ResizeMove</b> and <b>Maximize</b> in a single command. When used on a maximized window,
           the window is resized and moved and is still in the maximized state afterwards. When used on an
           unmaximized window, the window is resized and put into the maximized state afterwards. This is useful
           if the user wants to resize the window temporarily and then return to the original geometry. The
           <u>resize-arguments</u> and <u>move-arguments</u> are the same as for the <b>ResizeMove</b> command.

       <b>RestackTransients</b>
           This command regroups the transients of a window close to it in the stacking order as if the window
           had just been lowered and then raised. The position of the window itself is not altered. Only windows
           that use either the <u>RaiseTransient</u> or <u>LowerTransient</u> style are affected at all. When
           <b>RestackTransients</b> is used on a transient window with the <u>StackTransientParent</u> style set, it is
           redirected to the parent window.

       <b>SetAnimation</b> <u>milliseconds-delay</u> [<u>fractions-to-move-list</u>]
           Sets the time between frames and the list of fractional offsets to customize the animated moves of
           the <b>AnimatedMove</b> command and the animation of menus (if the menu style is set to animated; see
           <b>MenuStyle</b> command). If the <u>fractions-to-move-list</u> is omitted, only the time between frames is
           altered. The <u>fractions-to-move-list</u> specifies how far the window should be offset at each successive
           frame as a fraction of the difference between the starting location and the ending location. e.g.:

               SetAnimation 10 -.01 0 .01 .03 .08 .18 .3 \
               .45 .6 .75 .85 .90 .94 .97 .99 1.0

           Sets the delay between frames to 10 milliseconds, and sets the positions of the 16 frames of the
           animation motion. Negative values are allowed, and in particular can be used to make the motion
           appear more cartoonish, by briefly moving slightly in the opposite direction of the main motion. The
           above settings are the default.

       <b>XorPixmap</b> [<u>pixmap</u>]
           Selects the pixmap with which bits are xor’ed when doing rubber-band window moving or resizing. This
           has a better chance of making the rubber-band visible if <b>XorValue</b> does not give good results. An
           example pixmap <u>resize.rainbow.xpm</u> is provided with the icon distribution. To turn the <u>XorPixmap</u> off
           again use the <b>XorValue</b> command or omit the <u>pixmap</u> argument.

       <b>XorValue</b> [<u>number</u>]
           Changes the value with which bits are xor’ed when doing rubber-band window moving or resizing. Valid
           values range from zero to the maximum value of an unsigned long integer on your system. Setting this
           value is a trial-and-error process. The default value 0 tries to find a value that gives a good
           contrast to black and white. The default value is used if the given <u>number</u> is omitted or invalid.

   <b>Focus</b> <b>&amp;</b> <b>Mouse</b> <b>Movement</b>
       <b>CursorBarrier</b> [destroy] [options] [<u>left</u> <u>top</u> <u>right</u> <u>bottom</u>]
           A cursor barrier is a box that the cursor cannot be moved outside of (unless warped with <u>CursorMove</u>
           or <u>WarpToWindow</u>). The <u>left</u>, <u>top</u>, <u>right</u>, and <u>bottom</u> values give the percent distance the box is placed
           from each of the corresponding edges of the desktop. If the values end with a <u>p</u>, they are interpreted
           as pixel amounts instead. If the option <u>coords</u> is given, the values are interpreted as the left/top
           and right/bottom coordinates of the box’s corners. If the option <u>screen</u> <u>RandRname</u> is given, the
           positions are computed relative to the specified monitor. Use <u>screen</u> <u>c</u> to place the barrier on the
           current monitor.

           Multiple barriers can be created by calling <u>CursorBarrier</u> multiple times. This allows creating
           multiple regions to confine the cursor to (such as each monitor in a multi-monitor setup), then use
           <u>CursorMove</u> or <u>WarpToWindow</u> to move the cursor between the barriers. If the command <u>destroy</u> is
           included, all barriers are destroyed allowing free movement of the mouse again. If <u>destroy</u> is
           followed by an integer <u>N</u>, only that barrier is destroyed (barriers are numbered in the order they are
           created starting at 0). If the integer is negative, this counts backwards, such as "-1" is the most
           recent created barrier, "-2" is the second most recent, and so on. When a barrier is destroyed, this
           renumbers all barriers after it. In practice this is best used with <u>destroy</u> <u>-1</u> to destroy the most
           recent barrier without affecting any previously created barriers.

           By default the key binding ctrl+shift+D will destroy all cursor barriers by calling <u>CursorBarrier</u>
           <u>destroy</u>.

           Here are some examples:

               # A barrier 15% from left/right and 10% from top/bottom.
               CursorBarrier 15 10 15 10

               # A barrier to confine the mouse to the current monitor.
               CursorBarrier screen c

               # A barrier to confine the mouse to a selected window
               Pick CursorBarrier coords $[w.x]p $[w.y]p \
                   $[math.+.$[w.x],$[w.width]]p $[math.+.$[w.y],$[w.height]]p

               # Destroy all barriers
               CursorBarrier destroy

           Note that if the CURSOR_BARRIER limit is hit, <u>all</u> defined CursorBarriers are undefined. In pratice,
           this is unlikely to happen though. If it does, a message is printed to fvwm3’s debug logs.

           <u>CursorBarrier</u> only works if fvwm is complied with the XFixes extension.

       <b>CursorMove</b> [screen <u>RANDRNAME</u>] <u>horizontal</u>[p] <u>vertical</u>[p]
           Without the <u>screen</u> option, <u>CusorMove</u> moves the mouse cursor a <u>horizontal</u> distance and <u>vertical</u>
           distance from its current position. The values are expressed as either a percent of the virtual
           desktop size, or a pixel distance by appending a '<u>p</u>' to the value. Either or both entries may be
           negative. For example,

               # Move down and right by one full page.
               CursorMove 100 100

               # Move down two full pages.
               CursorMove 0 200

               # Move half page right and quarter page up.
               CursorMove 50 -25

               # Move left 100 pixels and down 50 pixels.
               CursorMove -100p 50p

           If the option <u>screen</u> followed by a valid RandR monitor name is included, <u>CursorMove</u> will move the
           cursor to the absolute position (starting at the top left corner) given by the arguments, as either
           percent values of the monitor’s size, or an absolute location with the '<u>p</u>' suffix. For example,

               # Move cursor to center of monitor DP-1
               CursorMove screen DP-1 50 50

               # Move cursor to the exact location (400, 200) of monitor DP-2
               CursorMove screen DP-2 400p 200p

           When moving to a specified <u>screen</u>, the <u>horizontal</u> and <u>vertical</u> values are always shifted to be inside
           the current page of the specified monitor. For instance '50', '150', and '-150' will all be the
           center of the monitor, and will not change monitor’s page. Use <b>GotoPage</b> to change the page of a
           specified monitor. Negative values can be used to specify distance from the right/bottom corner of
           the monitor.

           <u>CusorMove</u> can only move the cursor relative to its current position, or to an absolute position on a
           given monitor. To move the cursor relative to a window, use <b>WarpToWindow</b>.

       <b>FlipFocus</b> [NoWarp]
           Executes a <b>Focus</b> command as if the user had used the pointer to select the window. This command
           alters the order of the WindowList in the same way as clicking in a window to focus, i.e. the target
           window is removed from the <b>WindowList</b> and placed at the start. This command is recommended for use
           with the <b>Direction</b> command and in the function invoked from <b>WindowList</b>.

       <b>Focus</b> [NoWarp]
           Sets the keyboard focus to the selected window. If the <u>NoWarp</u> argument is given, this is all it does.
           Otherwise it also moves the viewport or window as needed to make the selected window visible. This
           command does not automatically raise the window. Does not warp the pointer into the selected window
           (see <b>WarpToWindow</b> function). Does not de-iconify. This command does not alter the order of the
           <b>WindowList</b>, it rotates the <b>WindowList</b> around so that the target window is at the start.

           When the <u>NoWarp</u> argument is given, Focus cannot transfer the keyboard focus to windows on other
           desks.

           To raise and/or warp a pointer to a window together with <b>Focus</b> or <b>FlipFocus</b>, use a function, like:

               AddToFunc SelectWindow
               + I Focus
               + I Iconify false
               + I Raise
               + I WarpToWindow 50 8p

       <b>WarpToWindow</b> [!raise | raise] <u>x</u>[p] <u>y</u>[p]
           Warps the cursor to the associated window and raises it (unless the option <u>!raise</u> is present). The
           parameters <u>x</u> and <u>y</u> default to percentage of window down and in from the upper left hand corner (or
           number of pixels down and in if '<u>p</u>' is appended to the numbers). If a number is negative the opposite
           edge is used and the direction reversed. This command works also with windows that are not managed by
           fvwm. In this case fvwm does not bring the window onto the screen if it is not visible. For example
           it is possible to warp the pointer to the center of the root window:

               WindowId root WarpToWindow 50 50

   <b>Window</b> <b>State</b>
       <b>Close</b>
           If the window accepts the delete window protocol a message is sent to the window asking it to
           gracefully remove itself. If the window does not understand the delete window protocol then the
           window is destroyed as with the <b>Destroy</b> command. Note: if the window accepts the delete window
           protocol but does not close itself in response, the window is not deleted.

       <b>Delete</b>
           Sends a message to a window asking that it remove itself, frequently causing the application to exit.

       <b>Destroy</b>
           Destroys an application window, which usually causes the application to crash and burn.

       <b>Iconify</b> [<u>bool</u>]
           Iconifies a window if it is not already iconified or de-iconifies it if it is already iconified. The
           optional argument <u>bool</u> is a boolean argument. "<u>True</u>" means only iconification is allowed, while
           "<u>False</u>" forces de-iconification. Using "<u>toggle</u>" switches between iconified and de-iconified states.

           There are a number of <b>Style</b> options which influence the appearance and behavior of icons (e.g.
           <u>StickyIcon</u>, <u>NoIcon</u>).

           For backward compatibility, the optional argument may also be a positive number instead of "True", or
           a negative number instead of "False". Note that this syntax is obsolete, and will be removed in the
           future.

       <b>Maximize</b> [<u>flags</u>] [<u>bool</u> <u>|</u> <u>forget</u>] [<u>horizontal</u>[p]] [<u>vertical</u>[p]]
           Without its optional arguments (or if the <u>bool</u> bit has the value "<u>toggle</u>") <b>Maximize</b> causes the window
           to alternately switch from a full-screen size to its normal size. To force a window into maximized
           (normal) state you can use a "<u>True</u>" or "<u>False</u>" value for the <u>bool</u> argument.

           With just the parameter "forget" a maximized window reverts back into normal state but keeps its
           current maximized size. This can be useful in conjunction with the commands <b>ResizeMaximize</b> and
           <b>ResizeMoveMaximize</b>. If the window is not maximized, nothing happens.

           With the optional arguments <u>horizontal</u> and <u>vertical</u>, which are expressed as percentage of a full
           screen, the user can control the new size of the window. An optional suffix '<u>p</u>' can be used to
           indicate pixels instead of percents of the screen size. If horizontal is greater than 0 then the
           horizontal dimension of the window is set to <u>horizontal</u>*screen_width/100. If the value is smaller
           than 0 the size is subtracted from the screen width, i.e. -25 is the same as 75. If <u>horizontal</u> is
           "<u>grow</u>", it is maximized to current available space until finding any obstacle. The vertical resizing
           is similar. If both horizontal and vertical values are "grow", it expands vertically first, then
           horizontally to find space. Instead of the horizontal "grow" argument, "<u>growleft</u>" or "<u>growright</u>" can
           be used respectively "<u>growup</u>" and "<u>growdown</u>".

           The optional <u>flags</u> argument is a space separated list containing the following key words: <u>fullscreen</u>,
           <u>ewmhiwa</u>, <u>growonwindowlayer</u>, <u>growonlayers</u>, <u>keepgrowing</u>, <u>all_windows</u>, <u>both_sides</u>, and <u>screen</u>.
           <u>fullscreen</u> causes the window to become fullscreened if the appropriate EWMH hint is set. <u>ewmhiwa</u>
           causes fvwm to ignore the EWMH working area. <u>growonwindowlayer</u> causes the various grow methods to
           ignore windows with a layer other than the current layer of the window which is maximized. The
           <u>growonlayers</u> option must have two integer arguments. The first one is the minimum layer and the
           second one the maximum layer to use. Windows that are outside of this range of layers are ignored by
           the grow methods. A negative value as the first or second argument means to assume no minimum or
           maximum layer. The <u>all_windows</u> option will consider all windows on the same monitor in the direction
           the window is growing. This can be used to grow a window to the edge of a window it is next to. The
           option <u>both_sides</u> will consider both sides of other windows when growing (by default only the close
           side is considered). This can be used to grow a window to the boundaries of a window it is currently
           inside of. <u>keepgrowing</u> will allow the window to keep growing beyond any window boundary it is
           currently touching until it grows into the next closest window boundary. <u>screen</u> must have an argument
           which specifies the screen on which to operate.

           Here are some examples. The following adds a title-bar button to switch a window to the full vertical
           size of the screen:

               Mouse 0 4 A Maximize 0 100

           The following causes windows to be stretched to the full width:

               Mouse 0 4 A Maximize 100 0

           This makes a window that is half the screen size in each direction:

               Mouse 0 4 A Maximize 50 50

           To expand a window horizontally until any other window is found:

               Mouse 0 4 A Maximize 0 grow

           To expand a window until any other window on the same or a higher layer is hit.

               Mouse 0 4 A Maximize growonlayers $[w.layer] -1 grow grow

           To expand a window but leave the lower 60 pixels of the screen unoccupied:

               Mouse 0 4 A Maximize 100 -60p

           Values larger than 100 can be used with caution.

       <b>Refresh</b>
           Causes all windows on the screen to redraw themselves. All pending updates of all windows' styles and
           looks are applied immediately. E.g. if <b>Style</b> or <b>TitleStyle</b> commands were issued inside a fvwm
           function.

       <b>RefreshWindow</b>
           Causes the chosen window to redraw itself. All pending updates of the window’s style and look are
           applied immediately. E.g. if <b>Style</b> or <b>TitleStyle</b> commands were issued inside a fvwm function.

       <b>Stick</b> [<u>bool</u>]
           If the <u>bool</u> argument is empty or "<u>toggle</u>", the <b>Stick</b> command makes a window sticky if it is not
           already sticky, or non-sticky if it is already sticky. To make a window sticky regardless of its
           current state the <u>bool</u> argument must be "True". To make it non-sticky use "False".

       <b>StickAcrossPages</b> [<u>bool</u>]
           Works like <b>Stick</b> but only sticks a window across pages, not across desks.

       <b>StickAcrossDesks</b> [<u>bool</u>]
           Works like <b>Stick</b> but only sticks a window across desks, not across pages.

       <b>WindowShade</b> [bool] | [[ShadeAgain] <u>direction</u>]
           Toggles the window shade feature for titled windows. Windows in the shaded state only display a
           title-bar. If <u>bool</u> is not given or "<u>toggle</u>", the window shade state is toggled. If <u>bool</u> is "True",
           the window is forced to the shaded state. If <u>bool</u> is "False", then the window is forced to the
           non-shaded state. To force shading in a certain direction, the <u>direction</u> argument can be used. Any of
           the strings "<u>North</u>", "<u>South</u>", "<u>West</u>", "<u>East</u>", "<u>NorthWest</u>", "<u>NorthEast</u>", "<u>SouthWest</u>", "<u>SouthEast</u>" or
           "<u>Last</u>" can be given. The direction can be abbreviated with the usual one or two letters "<u>N</u>", "<u>NW</u>",
           etc. Using a direction on a window that was already shaded unshades the window. To shade it in a
           different direction, use the <u>ShadeAgain</u> option. The direction <u>Last</u> shades the window in the direction
           it last was shaded. If the window has never been shaded before it is shaded as if no direction had
           been given. Windows without titles can be shaded too. Please refer also to the options
           <u>WindowShadeSteps</u>, <u>WindowShadeShrinks</u>, <u>WindowShadeScrolls</u>, <u>WindowShadeLazy</u>, <u>WindowShadeAlwaysLazy</u> and
           <u>WindowShadeBusy</u> options of the <b>Style</b> command. Examples:

               Style * WindowShadeShrinks, WindowShadeSteps 20, \
                 WindowShadeLazy
               Mouse 1 - S WindowShade North
               Mouse 1 [ S WindowShade West
               Mouse 1 ] S WindowShade E
               Mouse 1 _ S WindowShade S

           Note: When a window that has been shaded with a <u>direction</u> argument changes the direction of the
           window title (see <u>TitleAtTop</u> <b>Style</b> option), the shading direction does not change. This may look very
           strange. Windows that were shaded without a <u>direction</u> argument stay shaded in the direction of the
           title bar.

           For backward compatibility, the optional argument may also be 1 to signify "on", and 2 to signify
           "off". Note that this syntax is obsolete, and will be removed in the future.

   <b>Mouse</b> <b>&amp;</b> <b>Key</b> <b>Bindings</b>
       <b>IgnoreModifiers</b> [<u>Modifiers</u>]
           Tells fvwm which modifiers to ignore when matching Mouse or Key bindings. <b>IgnoreModifiers</b> affects the
           <u>ClickToFocus</u> style too. This command belongs into your <u>config</u>. If you issue it when your fvwm session
           is already up and running the results are unpredictable. The should appear before any applications or
           modules are started in your <u>config</u> file (e.g. with the <b>Exec</b> command).

           <u>Modifiers</u> has the same syntax as in the <b>Mouse</b> or <b>Key</b> bindings, with the addition of 'L' meaning the
           caps lock key. The default is "L". <u>Modifiers</u> can be omitted, meaning no modifiers are ignored. This
           command comes in handy if the num-lock and scroll-lock keys interfere with your shortcuts. With
           XFree86 '2' usually is the num-lock  modifier and '5' refers to the scroll-lock key. To turn all
           these pesky modifiers off you can use this command:

               IgnoreModifiers L25

           If the <u>Modifiers</u> argument is the string "<u>default</u>", fvwm reverts back to the default value "L".

           <b>Important</b> This command creates a lot of extra network traffic, depending on your CPU, network
           connection, the number of <b>Key</b> or <b>Mouse</b> commands in your configuration file and the number of
           modifiers you want to ignore. If you do not have a lightning fast machine or very few bindings you
           should not ignore more than two modifiers. I.e. do not ignore

           if you have no problem with it. In the <u>FAQ</u> you can find a better solution of this problem.

       <b>EdgeCommand</b> [screen <u>RANDRNAME</u>] [<u>direction</u> [<u>Function</u>]]
           Binds a specified fvwm command <u>Function</u> to an edge of the screen. Direction may be one of "<u>North</u>",
           "<u>Top</u>", "<u>West</u>", "<u>Left</u>", "<u>South</u>", "<u>Bottom</u>", "<u>Right</u>" and "<u>East</u>". If <u>Function</u> is omitted the binding for
           this edge is removed. If EdgeCommand is called without any arguments all edge bindings are removed.
           If the literal option <u>screen</u> followed by a RandR screen name <u>RANDRNAME</u> is given, the command is set
           only for the given monitor.

           <u>Function</u> is executed when the mouse pointer enters the invisible pan frames that surround the visible
           screen. The binding works only if <b>EdgeThickness</b> is set to a value greater than 0. If a function is
           bound to an edge, scrolling specified by <b>EdgeScroll</b> is disabled for this edge. It is possible to bind
           a function only to some edges and use the other edges for scrolling. This command is intended to
           raise or lower certain windows when the mouse pointer enters an edge. <b>FvwmAuto</b> can be used get a
           delay when raising or lowering windows. The following example raises <b>FvwmButtons</b> if the mouse pointer
           enters the top edge of the screen.

               # Disable EdgeScrolling but make it possible
               # to move windows over the screen edge
               EdgeResistance -1
               Style * EdgeMoveDelay 250
               Style * EdgeMoveResistance 20

               # Set thickness of the edge of the screen to 1
               EdgeThickness 1

               # Give focus to FvwmButtons if the mouse
               # hits top edge
               EdgeCommand Top Next (FvwmButtons) Focus
               # Make sure the Next command matches the window
               Style FvwmButtons CirculateHit

               Module FvwmButtons
               Module FvwmAuto 100 "Silent AutoRaiseFunction" \
                "Silent AutoLowerFunction"

               # If any window except FvwmButtons has
               # focus when calling this function
               # FvwmButtons are lowered
               DestroyFunc AutoLowerFunction
               AddToFunc AutoLowerFunction
               + I Current (!FvwmButtons) All (FvwmButtons) Lower

               # If FvwmButtons has focus when calling this function raise it
               DestroyFunc AutoRaiseFunction
               AddToFunc AutoRaiseFunction
               + I Current (FvwmButtons) Raise

           Normally, the invisible pan frames are only on the screen edges that border virtual pages. If a
           screen edge has a command bound to it, the pan frame is always created on that edge.

       <b>EdgeLeaveCommand</b> [screen <u>RANDRNAME</u>] [<u>direction</u> [<u>Function</u>]]
           Binds a specified fvwm command <u>Function</u> to an edge of the screen. Direction may be one of "<u>North</u>",
           "<u>Top</u>", "<u>West</u>", "<u>Left</u>", "<u>South</u>", "<u>Bottom</u>", "<u>Right</u>" and "<u>East</u>". If <u>Function</u> is omitted the binding for
           this edge is removed. If EdgeLeaveCommand is called without any arguments all edge bindings are
           removed. If the literal option <u>screen</u> followed by a RandR screen name <u>RANDRNAME</u> is given, the command
           is set only for the given monitor.

           <u>Function</u> is executed when the mouse pointer leaves the invisible pan frames that surround the visible
           screen. The binding works only if <b>EdgeThickness</b> is set to a value greater than 0. If a function is
           bound to an edge, scrolling specified by <b>EdgeScroll</b> is disabled for this edge. It is possible to bind
           a function only to some edges and use the other edges for scrolling. This command is intended to
           raise or lower certain windows when the mouse pointer leaves an edge. <b>FvwmAuto</b> can be used get a
           delay when raising or lowering windows. See example for <b>EdgeCommand</b>

           Normally, the invisible pan frames are only on the screen edges that border virtual pages. If a
           screen edge has a command bound to it, the pan frame is always created on that edge.

       <b>Key</b> [(<u>window</u>)] <u>Keyname</u> <u>Context</u> <u>Modifiers</u> <u>Function</u>
           Binds a keyboard key to a specified fvwm command, or removes the binding if <u>Function</u> is '-'. The
           syntax is the same as for a <b>Mouse</b> binding except that the mouse button number is replaced with a
           <u>Keyname</u>. Normally, the key binding is activated when the key is pressed. <u>Keyname</u> is a standard X11
           key name as defined in <u>/usr/include/X11/keysymdef.h</u>, (without the <u>XK</u><b>_</b> prefix), or the keysym database
           <u>/usr/X11R6/lib/X11/XKeysymDB</u>. Only key names that are generated with no modifier keys or with just
           the

           key held are guaranteed to work. The <u>Context</u> and <u>Modifiers</u> fields are defined as in the <b>Mouse</b>
           binding. However, when you press a key the context window is the window that has the keyboard focus.
           That is not necessarily the same as the window the pointer is over (with <u>SloppyFocus</u> or
           <u>ClickToFocus</u>). Note that key bindings with the '<u>R</u>' (root window) context do not work properly with
           <u>SloppyFocus</u> and <u>ClickToFocus</u>. If you encounter problems, use the <b>PointerKey</b> command instead. If you
           want to bind keys to a window with <u>SloppyFocus</u> or <u>ClickToFocus</u> that are supposed to work when the
           pointer is not over the window, fvwm assumes the pointer is over the client window (i.e. you have to
           use the 'W' context).

           The special context '<u>M</u>' for menus can be used to (re)define the menu controls. It be used alone or
           together with 'T', 'S', 'I', '[', ']', '-' and '_'. See the <b>Menu</b> <b>Bindings</b> section for details.

           The following example binds the built-in window list to pop up when

           is hit, no matter where the mouse pointer is:

               Key F11 A SCM WindowList

           Binding a key to a title-bar button causes that button to appear. Please refer to the <b>Mouse</b> command
           for details.

       <b>Mouse</b> [(<u>window</u>)] <u>Button</u> <u>Context</u> <u>Modifiers</u> <u>Function</u>
           Defines a mouse binding, or removes the binding if <u>Function</u> is '-'. <u>Button</u> is the mouse button
           number. If <u>Button</u> is zero then any button performs the specified function. Note that only mouse
           buttons 1 to 5 are fully supported by X11. Any number above this works only partially. Complex
           functions can not be used with these buttons and neither any operation that requires dragging the
           pointer with the button held. This is due to limitations of X11. By default, the highest allowed
           button number is 9.

           <u>Context</u> describes where the binding applies. Valid contexts are '<u>R</u>' for the root window, '<u>W</u>' for an
           application window, '<u>D</u>' for a desktop application (as kdesktop or Nautilus desktop), '<u>T</u>' for a window
           title-bar, '<u>S</u>' for a window side, top, or bottom bar, '<u>[</u>', '<u>]</u>', '<u>-</u>' and '<b>_</b>' for the left, right, top
           or bottom side only, '<u>F</u>' for a window frame (the corners), '&lt;', '^', '&gt;' and '<u>v</u>' for the top left,
           top right, bottom right or bottom left corner, '<u>I</u>' for an icon window, or '<u>0</u>' through '<u>9</u>' for
           title-bar buttons, or any combination of these letters. '<u>A</u>' is for any context. For instance, a
           context of "FST" applies when the mouse is anywhere in a window’s border except the title-bar
           buttons. Only 'S' and 'W' are valid for an undecorated window.

           The special context '<u>M</u>' for menus can be used to (re)define the menu controls. It can be used alone
           or together with 'T', 'S', 'I', '[', ']', '-' and '_'. See the <b>Menu</b> <b>Bindings</b> section for details.

           The special context '<u>P</u>' controls what buttons that can be used to place a window. When using this
           context no modifiers are allowed (<u>Modifiers</u> must be N), no <u>window</u> is allowed, and the <u>Function</u> must
           be one of <u>PlaceWindow</u>, <u>PlaceWindowDrag</u>, <u>PlaceWindowInteractive</u>, <u>CancelPlacement</u>, <u>CancelPlacementDrag</u>,
           <u>CancelPlacementInteractive</u> or <u>-</u>.

           <u>PlaceWindow</u> makes <u>Button</u> usable for window placement, both for interactive and drag move.
           <u>CancelPlacement</u> does the inverse. That is makes <u>Button</u> to cancel move for both interactive and drag
           move. It may however not override how new windows are resized after being placed. This is controlled
           by the <b>Emulate</b> command. Also a window being dragged can always be placed by releasing the button hold
           while dragging, regardless of if it is set to <u>PlaceWindow</u> or not.

           <u>PlaceWindowDrag</u> and <u>PlaceWindowInteractive</u>/<u>CancelPlacementDrag</u> and <u>CancelPlacementInteractive</u> work as
           <u>PlaceWindow</u>/<u>CancelPlacement</u> with the exception that they only affect either windows dragged / placed
           interactively.

           <u>-</u> is equivalent to <u>CancelPlacement</u>.

           The following example makes all buttons but button 3 usable for interactive placement and makes drag
           moves started by other buttons than one cancel if button 1 is pressed before finishing the move:

               Mouse 0 P N PlaceWindow
               Mouse 3 P N CancelPlacement
               Mouse 1 P N CancelPlacementDrag

           By default, the binding applies to all windows. You can specify that a binding only applies to
           specific windows by specifying the window name in brackets. The window name is a wildcard pattern
           specifying the class, resource or name of the window you want the binding to apply to.

           The following example shows how the same key-binding can be used to perform different functions
           depending on the window that is focused:

               Key (rxvt)  V A C Echo ctrl-V-in-RXVT
               Key (*term) V A C Echo ctrl-V-in-Term
               Key (*vim)  V A C --
               Key         V A C Echo ctrl-V-elsewhere

           A '<u>--</u>' action indicates that the event should be propagated to the specified window to handle. This
           is only a valid action for window-specific bindings.

           This example shows how to display the WindowList when Button 3 is pressed on an rxvt window:

               Mouse (rxvt) 3 A A WindowList

           Note that Fvwm actually intercepts all events for a window-specific binding and (if the focused
           window doesn’t match any of the bindings) sends a synthetic copy of the event to the window. This
           should be transparent to most applications, however (for security reasons) some programs ignore these
           synthetic events by default - xterm is one of them. To enable handling of these events, add the
           following line to your <u><a href="file:~/.Xdefaults">~/.Xdefaults</a></u> file:

               XTerm*allowSendEvents:  true

           <u>Modifiers</u> is any combination of '<u>N</u>' for no modifiers, '<u>C</u>' for control, '<u>S</u>' for shift, '<u>M</u>' for Meta,
           '<u>L</u>' for Caps-Lock or '<u>A</u>' for any modifier. For example, a modifier of "SM" applies when both the

           and

           keys are down. X11 modifiers mod1 through mod5 are represented as the digits '1' through '5'. The
           modifier 'L' is ignored by default. To turn it on, use the <b>IgnoreModifiers</b> command.

           <u>Function</u> is one of fvwm’s commands.

           The title-bar buttons are numbered with odd numbered buttons on the left side of the title-bar and
           even numbers on the right. Smaller-numbered buttons are displayed toward the outside of the window
           while larger-numbered buttons appear toward the middle of the window (0 is short for 10). In summary,
           the buttons are numbered:

               1 3 5 7 9    0 8 6 4 2

           The highest odd numbered button which has an action bound to it determines the number of buttons
           drawn on the left side of the title bar. The highest even number determines the number of right side
           buttons which are drawn. Actions can be bound to either mouse buttons or keyboard keys.

       <b>PointerKey</b> [(<u>window</u>)] <u>Keyname</u> <u>Context</u> <u>Modifiers</u> <u>Function</u>
           This command works exactly like the <b>Key</b> command. The only difference is that the binding operates on
           the window under the pointer. Normal key bindings operate on the focused window instead. The
           <b>PointerKey</b> command can for example be used to bind keys to the root window if you are using
           <u>SloppyFocus</u> or <u>ClickToFocus</u>. However, some applications (xterm is one example) are unable to handle
           this key anymore, even if the pointer is over the xterm window. It is recommended to use the
           <b>PointerKey</b> command only for key combinations that are not needed in any application window.

           Example:

               Style * SloppyFocus
               PointerKey f1 a m Menu MainMenu

   <b>Controlling</b> <b>the</b> <b>Virtual</b> <b>Desktop</b>
       <b>DesktopName</b> <u>desk</u> <u>name</u>
           Defines the name of the desktop number <u>desk</u> to <u>name</u>. This name is used in the <b>WindowList</b> command and
           in the <b>FvwmPager</b> where it override the <u>Label</u> configuration option. Moreover, if consecutive names
           starting from desktop 0 are defined, then these names can be used by any EWMH compliant application
           (as a pager).

       <b>DesktopConfiguration</b> global | per-monitor | shared
           This command controls the behaviour of how desktops should be managed by FVWM. By default, for all
           screens detected by FVWM through RandR support, the option of global means that all windows on the
           same desk across monitors is treated as one — hence, when a change of desktop/page happens, the same
           change occurs across all monitors.

           With per-monitor , each RandR monitor has a separate copy of desktops, and hence function
           independently of one another when switching desks/pages.

           When <u>shared</u> is set, the desktops are shared amongst all monitors. So for example, with the following
           number of desktops defined with two monitors (<u>[]</u> is monitor1, and <u>&lt;&gt;</u> is monitor2):

               [0]     1      2      &lt;3&gt;     4

           Moving between desktops would still honor the monitor the desktop is being requested on. If <u>monitor1</u>
           wanted to switch to desktop 3, then that desktop is exchanged with <u>monitor2</u> such that the following
           showed the active desktop on both monitors:

               &lt;0&gt;     1      2      [3]     4

           This concept is similar to how spectrwm or xmonad handles desktops.

           <b>Note:</b> these each <b>DesktopConfiguration</b> mode can be changed on-the-fly.

       <b>DesktopSize</b> <u>Horizontal</u>x<u>Vertical</u>
           Defines the virtual desktop size in units of the physical screen size.

       <b>EdgeResistance</b> <u>delay</u>, <b>EdgeResistance</b> <u>scrolling</u> <u>moving</u> [<u>screen-scrolling</u>]
           Tells how hard it should be to change the desktop viewport by moving the mouse over the edge of the
           screen. The parameter tells how many milliseconds the pointer must spend on the screen edge before
           fvwm moves the viewport. This is intended for people who use

               EdgeScroll 100 100

           but find themselves accidentally flipping pages when they do not want to. If -1 is given as the
           delay, scrolling is disabled completely.

           The second form of invocation with two or three arguments is obsolete and should be replaced with the
           following three commands as needed:

               EdgeResistance scrolling
               Style * EdgeMoveDelay scrolling
               Style * EdgeMoveResistance moving
               or
               Style * EdgeMoveResistance moving screen-scrolling

           Fvwm does this substitution automatically and prints a warning.

       <b>EdgeScroll</b> [<u>screen</u> <u>RANDRNAME</u>] <u>horizontal</u>[p] <u>vertical</u>[p] [wrap | wrapx | wrapy]
           Specifies the percentage of a page to scroll when the cursor hits the edge of a page. The optional
           '<u>screen</u> <u>RANDRNAME</u>' specifies the RandR monitor which this setting should apply to, ignoring all other
           monitors. Without this option, it applies the value to all monitors. A trailing '<u>p</u>' changes the
           interpretation to mean pixels. If you do not want any paging or scrolling when you hit the edge of a
           page include

               EdgeScroll 0 0

           in your <u>config</u> file, or possibly better, set the <b>EdgeThickness</b> to zero. See the <b>EdgeThickness</b>
           command. If you want whole pages, use

               EdgeScroll 100 100

           Both <u>horizontal</u> and <u>vertical</u> should be positive numbers.

           If the <u>horizontal</u> and <u>vertical</u> percentages are multiplied by 1000 or one of the keywords <u>wrap</u>, <u>wrapx</u>
           and <u>wrapy</u> is given then scrolling wraps around at the edge of the desktop. If

               EdgeScroll 100000 100000

           is used fvwm scrolls by whole pages, wrapping around at the edge of the desktop.

       <b>EdgeThickness</b> [<u>screen</u> <u>RANDRNAME</u>] 0 | 1 | 2
           This is the width or height of the invisible window that fvwm creates on the edges of the screen that
           are used for the edge scrolling feature.

           The optional '<u>screen</u> <u>RANDRNAME</u>' specifies the RandR monitor which this setting should apply to,
           ignoring all other monitors. Without this option, it applies the value to all monitors.

           In order to enable page scrolling via the mouse, four windows called the "pan frames" are placed at
           the very edge of the screen. This is how fvwm detects the mouse’s presence at the window edge.
           Because of the way this works, they need to be at the top of the stack and eat mouse events, so if
           you have any kind of error along the lines of: "mouse clicks at the edge of the screen do the wrong
           thing" you’re having trouble with the pan frames and (assuming you do not use the mouse to flip
           between pages) should set the EdgeThickness to 0.

           A value of 0 completely disables mouse edge scrolling, even while dragging a window. 1 gives the
           smallest pan frames, which seem to work best except on some servers.

           2 is the default.

           Pan frames of 1 or 2 pixels can sometimes be confusing, for example, if you drag a window over the
           edge of the screen, so that it straddles a pan frame, clicks on the window, near the edge of the
           screen are treated as clicks on the root window.

       <b>EwmhBaseStruts</b> <u>screen</u> <u>RANDRNAME</u> <u>left</u> <u>right</u> <u>top</u> <u>bottom</u>
           Where left, right, top and bottom are positive or null integers which define bands at the edge of the
           screen. If <u>screen</u> is given, followed by the RANDRNAME of a given display, then the EwmhBaseStruts are
           defined for just RANDRNAME. <u>left</u> defines a band on the left of your screen of width <u>left</u>, <u>right</u>
           defines a band on the right of your screen of width <u>right</u>, <u>top</u> defines a band on the top of your
           screen of height <u>top</u> and <u>bottom</u> defines a band on the bottom of your screen of height <u>bottom</u>. The
           unit is the pixel and the default is 0 0 0 0. These areas define additional reserved space to the
           reserved space defined by some ewmh compliant applications. This is used to compute the Working Area.
           See the <b>Extended</b> <b>Window</b> <b>Manager</b> <b>Hints</b> section for a definition of the Working Area.

       <b>EwmhNumberOfDesktops</b> <u>num</u> [<u>max</u>]
           This command is useful only for an ewmh compliant pager or taskbar (as kpager or kicker taskbar) and
           not for fvwm modules ( <b>FvwmPager</b> or <b>FvwmIconMan</b>). It causes a compliant application to consider at
           least <u>num</u> desktops (desktop 0 to desktop <u>num</u>-1). The optional argument <u>max</u> causes a compliant
           application to never consider more than <u>max</u> desktops. If <u>max</u> is 0 (the default) there is no
           limitation. The actual number of desktops is determined dynamically. It is at least <u>num</u>, but it can
           be d if there is a window on desktop d-1 (or if the current desktop is desktop d-1) and d is less or
           equal to <u>max</u> or <u>max</u> is null. Moreover, a compliant pager can ask to change <u>num</u> itself. This is
           accepted by fvwm only if this number is less than or equal to <u>max</u> or if <u>max</u> is null. Note that
           negative desktops are not supported by the ewmh specification. The default is 4 0.

       <b>GotoDesk</b> [screen <u>RANDRNAME</u>] [prev | <u>arg1</u> [<u>arg2</u>] [<u>min</u> <u>max</u>]]
           Switches the current viewport to another desktop (workspace, room). The current monitor is used in
           <u>per-monitor</u> and <u>shared</u> <u>DesktopConfiguration</u>, unless the literal <u>screen</u> followed by a valid RandR
           monitor name is included.

           The command takes 1, 2, 3, or 4 arguments. A single argument is interpreted as a relative desk
           number. Two arguments are understood as a relative and an absolute desk number. Three arguments
           specify a relative desk and the minimum and maximum of the allowable range. Four arguments specify
           the relative, absolute, minimum and maximum values. If a literal <u>prev</u> is given as the single
           argument, the last visited desk number is used.

           If <u>arg1</u> is non zero then the next desktop number is the current desktop number plus <u>arg1</u>.

           If <u>arg1</u> is zero then the new desktop number is <u>arg2</u>. (If <u>arg2</u> is not present, then the command has no
           effect.)

           If <u>min</u> and <u>max</u> are given, the new desktop number is no smaller than <u>min</u> and no bigger than <u>max</u>.
           Values out of this range are truncated (if you gave an absolute desk number) or wrapped around (if
           you gave a relative desk number).

           The syntax is the same as for <b>MoveToDesk</b>, which moves a window to a different desktop.

           The number of active desktops is determined dynamically. Only desktops which contain windows or are
           currently being displayed are active. Desktop numbers must be between 0 and 2147483647 (is that
           enough?). Negative desktop numbers are not supported by the EWMH specifications and are no longer
           supported in fvwm.

       <b>GotoDeskAndPage</b> screen | prev | <u>desk</u> <u>xpage</u> <u>ypage</u>
           Switches the current viewport to another desktop and page, similar to the <b>GotoDesk</b> and <b>GotoPage</b>
           commands. The new desk is <u>desk</u> and the new page is (<u>xpage</u>,<u>ypage</u>).

       <b>GotoPage</b> screen | prev | [<u>options</u>] <u>x</u>[p] <u>y</u>[p]
           Moves the desktop viewport to page (x,y). The upper left page is (0,0), the upper right is (M,0),
           where M is one less than the current number of horizontal pages specified in the <b>DesktopSize</b> command.
           The lower left page is (0,N), and the lower right page is (M,N), where N is the desktop’s vertical
           size as specified in the <b>DesktopSize</b> command. To switch to a page relative to the current one add a
           trailing '<u>p</u>' after any or both numerical arguments.

           Possible <u>options</u> are <u>wrapx</u> and <u>wrapy</u> to wrap around the x or y coordinate when the viewport is moved
           beyond the border of the desktop.

           The name of the RandR screen.

           To go to the last visited page use <u>prev</u> as the first argument. The <b>GotoPage</b> function should not be
           used in a pop-up menu.

           Examples:

               # Go to page (2,3)
               GotoPage 2 3

               # Go to lowest and rightmost page
               GotoPage -1 -1

               # Go to last page visited
               GotoPage prev

               # Go two pages to the right and one page up
               GotoPage +2p -1p

       <b>Scroll</b> [screen RANDRNAME] [<u>horizonal</u>[p] <u>vertical</u>[p] | reverse]
           Scrolls the virtual desktop’s viewport by <u>horizontal</u> pages in the x-direction and <u>vertical</u> pages in
           the y-direction or starts interactive scrolling of the viewport. Either or both entries may be
           negative. Both <u>horizontal</u> and <u>vertical</u> values are expressed in percent of pages, so

               Scroll 100 100

           means to scroll down and right by one full page.

               Scroll 50 25

           means to scroll right half a page and down a quarter of a page. The <b>Scroll</b> function should not be
           called from pop-up menus. Normally, scrolling stops at the edge of the desktop.

           If the <u>horizontal</u> and <u>vertical</u> percentages are 100 or more and are multiplied by 1000 then scrolling
           wraps around at the edge of the desktop. If

               Scroll 100000 0

           is executed over and over fvwm moves to the next desktop page on each execution and wraps around at
           the edge of the desktop, so that every page is hit in turn.

           If the letter '<u>p</u>' is appended to each coordinate (<u>horizontal</u> and/or <u>vertical</u>), then the scroll amount
           is measured in pixels.

           Without arguments or if the option <u>reverse</u> is given interactive scrolling takes place. The viewport
           scrolls as the mouse is moved. With the <u>reverse</u> option scrolling is done in opposite direction of the
           mouse movement, and without it scrolling in the same direction as the mouse.

           The binding

               Mouse 1 A CM Scroll reverse

           gives an effect of grabbing and dragging the viewport with button 1 if Control and Meta is pressed.

           If <u>screen</u> is given, followed by the RANDRNAME of a given display, then the specified screen is
           scrolled. This is only useful if using per-monitor or shared <u>DesktopConfiguration</u> and wanting to
           scroll a monitor other than the current monitor. Interactive scrolling always scrolls the current
           monitor.

   <b>User</b> <b>Functions</b> <b>and</b> <b>Shell</b> <b>Commands</b>
       <b>AddToFunc</b> [<u>name</u> [I | J | M | C | H | D <u>action</u>]]
           Begins or adds to a function definition. Here is an example:

               AddToFunc Move-or-Raise I Raise
                + M Move
                + D Lower

           The function name is "Move-or-Raise", and it could be invoked from a menu or a mouse binding or key
           binding:

               Mouse 1 TS A Move-or-Raise

           The <u>name</u> must not contain embedded whitespace. No guarantees are made whether function names with
           embedded whitespace work or not. This behavior may also change in the future without further notice.
           The letter before the <u>action</u> tells what kind of action triggers the command which follows it. '<u>I</u>'
           stands for "Immediate", and is executed as soon as the function is invoked. '<u>J</u>' is similar to
           "Immediate" but is delayed until a button is pressed or released or the pointer is moved, or the
           function completes. It is always executed before the other function actions. '<u>M</u>' stands for "Motion",
           i.e. if the user starts moving the mouse. '<u>C</u>' stands for "Click", i.e., if the user presses and
           releases the mouse button. '<u>H</u>' stands for "Hold", i.e. if the user presses a mouse button and holds
           it down for more than <b>ClickTime</b> milliseconds. '<u>D</u>' stands for "Double-click". The action '<u>I</u>' causes an
           action to be performed on the button-press, if the function is invoked with prior knowledge of which
           window to act on.

           There is a number of predefined symbols that are replaced by certain values if they appear on the
           command line. Please refer to the <b>Command</b> <b>Expansion</b> section for details.

           <b>Warning</b> Please read the comments on executing complex functions in the section <b>Scripting</b> <b>and</b> <b>Complex</b>
           <b>Functions</b>.

           Examples:

           If you call

               Key F10 R A Function MailFunction xmh "-font fixed"

           and "MailFunction" is

               AddToFunc MailFunction
                + I Next ($0) Iconify off
                + I Next (AcceptsFocus, $0) Focus
                + I None ($0) Exec exec $0 $1

           Then the last line of the function becomes

                + I None (xmh) Exec exec xmh -font fixed

           The expansion is performed as the function is executed, so you can use the same function with all
           sorts of different arguments. You could use

               Key F11 R A Function MailFunction zmail "-bg pink"

           in the same <u>config</u>, if you wanted. An example of using "$[w.id]" is:

               AddToFunc PrintFunction
                + I Raise
                + I Exec xdpr -id $[w.id]

           Note that "$$" is expanded to '$'.

           Another example: bind right mouse button within the window button number 6 (this is a minimize button
           for the win95 theme) to iconify all windows of the same resource:

               AddToFunc FuncIconifySameResource "I" All ($0) Iconify on
               Mouse 3 6 A FuncIconifySameResource $[w.resource]

       <b>Beep</b>
           As might be expected, this makes the terminal beep.

       <b>DestroyFunc</b> <u>function</u>
           Deletes a function, so that subsequent references to it are no longer valid. You can use this to
           change the contents of a function during a fvwm session. The function can be rebuilt using <b>AddToFunc</b>.

               DestroyFunc PrintFunction

       <b>Echo</b> <u>string</u>
           Prints a message to the debug log file, which requires logging to be enabled. See the <b>-v</b> option or
           <b>PrintInfo</b> for more information on both enabling debug logging and the log file location. Potentially
           useful for debugging things in your <u>config</u> or getting the value of variables.

               Echo Beginning style definitions...
               Echo Current desk $[desk.n].

       <b>EchoFuncDefinition</b> <u>function</u>
           The <b>EchoFuncDefinition</b> is similar to the <b>Echo</b> command but prints the definition for the given
           <u>function</u> to the debug log file. It is useful to find out how fvwm handles quoting and for debugging
           functions.

       <b>Exec</b> <u>command</u>
           Executes <u>command</u>. You should not use an ampersand '&amp;' at the end of the command. You probably want to
           use an additional "exec" at the beginning of <u>command</u>. Without that, the shell that fvwm invokes to
           run your command stays until the command exits. In effect, you’ll have twice as many processes
           running as you need. Note that some shells are smart enough to avoid this, but it never hurts to
           include the "exec" anyway.

           The following example binds function key

           in the root window, with no modifiers, to the exec function. The program rxvt is started with an
           assortment of options.

               Key F1 R N Exec exec rxvt -fg yellow -bg blue \
               -e /bin/tcsh

           Note that this function doesn’t wait for <u>command</u> to complete, so things like:

               Exec "echo AddToMenu ... &gt; /tmp/file"
               Read /tmp/file

           do not work reliably (see the <b>PipeRead</b> command).

       <b>ExecUseShell</b> [<u>shell</u>]
           Makes the <b>Exec</b> command use the specified shell, or the value of the <u>$SHELL</u> environment variable if no
           shell is specified, instead of the default Bourne shell (<u><a href="file:/bin/sh">/bin/sh</a></u>).

               ExecUseShell
               ExecUseShell /usr/local/bin/tcsh

       <b>Function</b> <u>FunctionName</u>
           Used to bind a previously defined function to a key or mouse button. The following example binds
           mouse button 1 to a function called "Move-or-Raise", whose definition was provided as an example
           earlier in this man page. After performing this binding fvwm executes the "move-or-raise" function
           whenever button 1 is pressed in a window’s title-bar.

               Mouse 1 T A Function Move-or-Raise

           The keyword <b>Function</b> may be omitted if <u>FunctionName</u> does not coincide with an fvwm command.

           Warning: Please read the comments on executing complex functions in the section <b>Scripting</b> <b>and</b> <b>Complex</b>
           <b>Functions</b>.

       <b>InfoStoreAdd</b> <u>key</u> <u>value</u>
           Stores the <u>value</u> at the given <u>key</u>. This is useful to store generic information used in the lifetime
           of an fvwm config file. For example storing program preferences for opening video files.

           The purpose of this command is to store internal information to fvwm which can be used bu fvwm
           functions, or when opening programs of a certain type. Previous to this command the only way to do
           this was via <b>SetEnv</b> but this is discouraged because it places such information in the environment,
           which pollutes it and makes the information global to other processes started by fvwm which may then
           modify them which might not be what’s wanted. Hence the point of <b>InfoStoreAdd</b> is to still allow for
           such information to be stored, but kept internal to fvwm.

           In this way, one can build up as many key/value pairs as needed. Recalling the value of a given key
           happens through fvwm’s usual expansion mechanism. See the <b>Command</b> <b>Expansion</b> section for more details.
           For example:

               InfoStoreAdd teddybearprog xteddy

               # Echo the value of teddybearprog
               Echo $[infostore.teddybearprog]

           Removing an entry from the InfoStore is done with the <b>InfoStoreRemove</b> command.

       <b>InfoStoreRemove</b> <u>key</u>
           Removes an entry at the given <u>key</u> from the InfoStore. Example:

               InfoStoreRemove teddybearprog

       <b>Nop</b>
           Does nothing. This is used to insert a blank line or separator in a menu. If the menu item
           specification is

               AddToMenu MyMenu " " Nop

           then a blank line is inserted. If it looks like

               + "" Nop

           then a separator line is inserted. Can also be used as the double-click action for <b>Menu</b> or <b>Popup</b>.

       <b>PipeRead</b> <u>command</u> [quiet]
           Causes fvwm to read commands from the output of the <u>command</u>. This <u>command</u> is executed by <u><a href="file:/bin/sh">/bin/sh</a></u> as
           if you typed it on the command line. If the command consists of more than one word it must be quoted.
           Useful for building up dynamic menu entries based on a directories contents, for example. If the
           keyword <u>Quiet</u> follows the command no message is produced if the <u>command</u> is not found.

           Example:

               AddToMenu HomeDirMenu
               PipeRead 'for i in $HOME/*; \
               do echo "+ $i Exec xterm -e vi $i"; done'

           Note: The <b>PipeRead</b> changes the pointer to a watch cursor by default during execution. However, some
           commands, for example xwd, need to take control of the pointer themselves and do not work. To disable
           the watch cursor, use the command prior to <b>PipeRead</b>

               BusyCursor Read off

           The <b>PipeRead</b> command executes synchronously. If you want to <b>Exec</b> something, but need the command to
           run synchronously, you might do something like:

               PipeRead 'command 1&gt;&amp;2'

           The redirection causes any output from the program to go to stderr instead of being read as a
           sequence of commands by fvwm. <b>PipeRead</b> returns 1 if the given command could be executed or -1 if not
           (see the section <b>Conditional</b> <b>Commands</b> for the meaning of return codes).

       <b>Read</b> <u>filename</u> [quiet]
           Causes fvwm to read commands from the file named <u>filename</u>. If the keyword <u>Quiet</u> follows the command
           no message is produced if the file is not found. If the file name does not begin with a slash ('/'),
           fvwm looks in the user’s data directory, then the system data directory. The user’s data directory is
           by default <u>$HOME/.fvwm</u>. It can be overridden by exporting <u>FVWM_USERDIR</u> set to any other directory.
           The <b>Read</b> command returns 1 if the given file could be read or -1 if not (see the section <b>Conditional</b>
           <b>Commands</b> for the meaning of return codes).

       <b>SetEnv</b> <u>variable</u> <u>value</u>
           Set an environment variable to a new value, similar to the shell’s export or setenv command. The
           <u>variable</u> and its <u>value</u> are inherited by processes started directly by fvwm. For example:

               SetEnv height HEIGHT

       <b>Silent</b> <u>command</u>
           A number of commands require a window to operate on. If no window was selected when such a function
           is invoked the user is asked to select a window. Sometimes this behavior is unwanted, for example if
           the function was called by a module and the window that was selected at first does not exist anymore.
           You can prevent this by putting <b>Silent</b> in front of the fvwm <u>command</u>. If a function that needs a
           window is called with <b>Silent</b> without a window selected, it simply returns without doing anything. If
           <b>Silent</b> is used on a user defined function it affects all function and sub function calls until the
           original function exits.

           Another usage of <b>Silent</b> is with binding commands <b>Key</b>, <b>PointerKey</b> and <b>Mouse</b>, this disables error
           messages.

           <b>Silent</b> also disables the error message for non-existent commands. Note: This command is treated as a
           prefix to its <u>command</u>. Expansion of the command line is done as if <b>Silent</b> was not there.

           Examples:

               Silent Move 0 0
               Silent User_defined_function
               # do not complain on keyboards without "Help" key
               Silent Key Help R A Popup HelpMenu

       <b>UnsetEnv</b> [<u>variable</u>]
           Unset an environment variable, similar to shell’s export or unsetenv command. The <u>variable</u> then is
           removed from the environment array inherited by processes started directly by fvwm.

       <b>Wait</b> <u>window</u>
           This command is intended to be used in fvwm functions only. It causes execution of a function to
           pause until a new window matching <u>window</u> appears. This can be a window’s name, class, or resource
           string. It may contain the wildcards '*' and '?', which are matched in the usual Unix filename
           manner. This is particularly useful in the "InitFunction" if you are trying to start windows on
           specific desktops:

               AddToFunc InitFunction
                + I Exec exec xterm -geometry 80x64+0+0
                + I Wait xterm
                + I GotoDesk 0 2
                + I Exec exec xmh -font fixed -geometry \
                507x750+0+0
                + I Wait xmh
                + I GotoDesk 0 0

           The above function starts an xterm on the current desk, waits for it to map itself, then switches to
           desk 2 and starts an xmh. After the xmh window appears control moves to desk 0.

           Fvwm remains partially functional during a wait, but any input from the modules is queued up and
           processed only after the window appears or the command is aborted. For example, windows can not be
           focused with <b>FvwmIconMan</b> or <b>FvwmPager</b> during a wait.

           You can escape from a <b>Wait</b> pause by pressing Ctrl-Alt-Escape (where Alt is the first modifier). To
           redefine this key sequence see the <b>EscapeFunc</b> command.

       <b>Status</b> <u>On</u> <u>|</u> <u>Off</u>
           Turns status either On or Off. This sends information in JSON format down a named pipe (set via
           FVWM_STATUS_PIPE env var) about the current desks and number of windows, etc. This is meant to
           provide a fast means of supplying third-party tools information about what’s happening in Fvwm. For
           example, the JSON could be manipulated and sent to tools such as <u>lemonbar</u>, <u>polybar</u>, etc.

           The format of the JSON blob looks like this:

               {
                   "version": 3,
                   "current_screen": "HDMI2",
                   "screens": {
                       "HDMI2": {
                           "randr_order": 0,
                           "current_client": "n6tadam@shuttle: ~",
                           "desktops": {
                               "0": {
                                   "number": 0,
                                   "is_urgent": false,
                                   "is_current": true,
                                   "number_of_clients": 5
                               },
                           },
                       },
                    },
               }

           These sections repeat for all screens/groups/etc, depending on how many there are of each.

   <b>Conditional</b> <b>Commands</b>
       Conditional commands are commands that are only executed if certain conditions are met. Most conditional
       commands work on windows, like <b>Next</b>, <b>ThisWindow</b> or <b>All</b>. There is one conditional command, <b>Test</b>, that
       works on global conditions unrelated to windows. The syntax of the conditions is described below. For
       readability, the list of conditions is located at the end of this section.

       <b>Return</b> <b>Codes</b>
           All commands in this section (unless specifically stated for the command) also have a return code
           that can be 1 (if the condition was met) or 0 (if the condition was not met). Some commands may
           return -1 which means that an error occurred and the return code is useless. The <b>Break</b> command
           returns -2. Additionally, the return codes of commands run in a complex functions are passed to the
           invoking complex function. The return code is used by the <b>TestRc</b> command. Please refer to the
           commands' description for examples. The return code can also be accessed through the variable
           <u>$[cond.rc]</u>. Non conditional commands do not modify the return code of the last conditional command.
           Important note: return codes are only defined inside functions created with the <b>AddToFunc</b> command and
           are not inherited by sub functions. To run a command without altering the return code, the <b>KeepRc</b>
           command can be used.

       <b>The</b> <b>Ring</b> <b>of</b> <b>Windows</b>
           Fvwm stores windows in a ring internally. Think of the focused window as a cursor on the current
           position in the ring. The <b>Next</b> command and many other commands search forwards through the ring for a
           matching window, and <b>Prev</b> searches backwards. The windows in the ring are either ordered by creation
           time (if the <u>!FPSortWindowlistByFocus</u>, <u>NeverFocus</u> or <u>MouseFocus</u> styles are used) or by the last time
           they had the focus.

       <b>List</b> <b>of</b> <b>Conditional</b> <b>Commands</b>

           <b>All</b> [<u>options</u>] [(<u>conditions</u>)] <u>command</u>
               Execute <u>command</u> on all windows meeting the conditions. It returns 1 if any window matches the
               condition and 0 otherwise. The execution starts at the top of the window ring and continues
               towards the bottom. The <u>options</u> can be any combination of <u>Reverse</u> and <u>UseStack</u>. If the option
               <u>Reverse</u> is given the execution order is reversed. The option <u>UseStack</u> makes All use the stacking
               order instead of the window ring when walking through windows. See the <b>Conditions</b> section for a
               list of conditions.

               This command implies the conditions <u>CirculateHit</u>, <u>CirculateHitIcon</u> and <u>CirculateHitShaded</u>. They
               can be turned off by specifying <u>!CirculateHit</u> etc. explicitly.

           <b>Any</b> [(<u>conditions</u>)] <u>command</u>
               Performs <u>command</u> if any window which satisfies all <u>conditions</u> exists. The command is run in the
               context of the root window. See the <b>Conditions</b> section for a list of conditions.

           <b>Break</b> [<u>levels</u>]
               If the break command is used in a function, function execution is terminated immediately. Further
               commands of the function are not processed. Normally, all nested invocations of complex functions
               are left. An optional integer number <u>levels</u> may be given to break out of the given number of
               nested functions and continue execution of a higher level function. The <b>Break</b> command always has
               the return code -2. Example:

                   AddToFunc PickWindowRaiseAndDeiconify
                   + I Pick
                   + I TestRc (Error) Break
                   + I Raise
                   + I Iconify off

           <b>Current</b> [(<u>conditions</u>)] <u>command</u>
               Performs <u>command</u> on the currently focused window if it satisfies all <u>conditions</u>. See the
               <b>Conditions</b> section for a list of conditions.

               This command implies the conditions <u>CirculateHit</u>, <u>CirculateHitIcon</u> and <u>CirculateHitShaded</u>. They
               can be turned off by specifying <u>!CirculateHit</u> etc. explicitly.

           <b>Direction</b> [FromPointer] <u>direction</u> [(<u>conditions</u>)] <u>command</u>
               Performs <u>command</u> (typically <b>Focus</b>) on a window in the given direction which satisfies all
               <u>conditions</u>. Normally, the center of the currently focused window or the context window in which
               the command was invoked is taken as the starting point. Lacking such a window, or when the
               <u>FromPointer</u> option is given, the current position of the pointer is taken as the starting point.
               The <u>direction</u> may be one of "North", "Northeast", "East", "Southeast", "South", "Southwest",
               "West", "Northwest" and "Center". Which window <b>Direction</b> selects depends on angle and distance
               between the center points of the windows. Closer windows are considered a better match than those
               farther away. The <u>Center</u> direction simply selects the window closest to the starting point.
               Returns -1 if an invalid direction was given. See the <b>Conditions</b> section for a list of
               conditions.

           <b>KeepRc</b> <u>command</u>
               Runs the <u>command</u> but does not alter the return code of the previous command. Note: <b>KeepRc</b> is
               treated as a prefix to its <u>command</u>. Expansion of the command line is done as if <b>KeepRc</b> was not
               there.

           <b>Next</b> [(<u>conditions</u>)] <u>command</u>
               Performs <u>command</u> (typically <b>Focus</b>) on the next window which satisfies all <u>conditions</u>. If the
               command is running in a window context, it starts looking for a matching window from there.
               Otherwise it starts at the focused window. See <b>Conditions</b> section for a list of conditions.

           <b>None</b> [(<u>conditions</u>)] <u>command</u>
               Performs <u>command</u> if no window which satisfies all <u>conditions</u> exists. The command is run in the
               context of the root window. Returns 1 if no window matches the conditions and 0 otherwise. See
               <b>Conditions</b> section for a list of conditions.

               This command implies the conditions <u>CirculateHit</u>, <u>CirculateHitIcon</u> and <u>CirculateHitShaded</u>. They
               can be turned off by specifying <u>!CirculateHit</u> etc. explicitly.

           <b>NoWindow</b> <u>command</u>
               Performs <u>command</u>, but removes the window context if any. This is not really a conditional
               command, but a prefix that may be useful in menu items that should operate without a window even
               if such menu is bound to window decorations.

           <b>Pick</b> [(<u>conditions</u>)] <u>command</u>
               <b>Pick</b> works like <b>Function</b> if invoked in the context of a window. If invoked in the root window, it
               first asks the user to pick a window and then executes the <u>command</u> in the context of that window.
               This avoids annoying multiple selections with complex functions. The command is executed only if
               the given <u>conditions</u> are met. Returns -1 if no window was selected. See <b>Conditions</b> section for a
               list of conditions.

               This command implies the conditions <u>CirculateHit</u>, <u>CirculateHitIcon</u> and <u>CirculateHitShaded</u>. They
               can be turned off by specifying <u>!CirculateHit</u> etc. explicitly.

           <b>PointerWindow</b> [(<u>conditions</u>)] <u>command</u>
               Performs <u>command</u> if the window under the pointer satisfies all <u>conditions</u>. Returns -1 if there is
               no window under the pointer. See <b>Conditions</b> section for a list of conditions.

               This command implies the conditions <u>CirculateHit</u>, <u>CirculateHitIcon</u> and <u>CirculateHitShaded</u>. They
               can be turned off by specifying <u>!CirculateHit</u> etc. explicitly.

           <b>Prev</b> [(<u>conditions</u>)] <u>command</u>
               Performs <u>command</u> (typically <b>Focus</b>) on the previous window which satisfies all <u>conditions</u>. If the
               command is running in a window context, it starts looking for a matching window from there.
               Otherwise it starts at the focused window. See <b>Conditions</b> section for a list of conditions.

           <b>ScanForWindow</b> [FromPointer] <u>dir1</u> <u>dir2</u> [(<u>conditions</u>)] <u>command</u>
               Performs <u>command</u> (typically <b>Focus</b>) on a window in the given direction which satisfies all
               <u>conditions</u>. Normally, the center of the currently focused window or the context window in which
               the command was invoked is taken as the starting point. Lacking such a window, or when the
               <u>FromPointer</u> option is given, the current position of the pointer is taken as the starting point.
               The direction <u>dir1</u> may be one of "North", "NorthEast", "East", "SouthEast", "South", "SouthWest",
               "West", and "NorthWest". Which window <b>ScanForWindow</b> selects depends first on the position along
               the primary axis given by <u>dir1</u>. If any windows have the exact same coordinate along the primary
               axis, the secondary direction is used to order the windows. The direction <u>dir2</u> may be one of the
               same set of values as <u>dir1</u>. If <u>dir2</u> is not perfectly perpendicular to <u>dir1</u>, ScanForWindow returns
               a failure. When using ScanForWindow repeatedly with the same arguments, it is guaranteed that all
               windows matching the conditions will eventually be found. If the focus reaches a limit along the
               primary axis, it will wrap around to the opposite side. Returns -1 if an invalid direction was
               given. See <b>Conditions</b> section for a list of conditions.

           <b>Test</b> [(<u>test-conditions</u>)] <u>command</u>
               Performs <u>command</u> if all <u>test-conditions</u> are satisfied. The <u>test-conditions</u> are keywords with
               possible arguments from the list below and are separated by commas or whitespace. They include:
               <u>Version</u> <u>operator</u> <u>x.y.z</u>, <u>EnvIsSet</u> <u>varname</u>, <u>EnvMatch</u> <u>varname</u> <u>pattern</u>, <u>EdgeHasPointer</u> <u>direction</u>,
               <u>EdgeIsActive</u> <u>direction</u>, <u>Start</u>, <u>Init</u>, <u>Restart</u>, <u>Exit</u>, <u>Quit</u>, <u>ToRestart</u>, <u>True</u>, <u>False</u>, <u>F</u>, <u>R</u>, <u>W</u>, <u>X</u> and
               <u>I</u>. A test-condition prefixed with "!" is negated.

               The <u>Version</u> <u>operator</u> <u>x.y.z</u> test-condition is fulfilled if the logical condition of the expression
               is true. Valid <u>operator</u> values are: <u>&gt;=</u>, <u>&gt;</u>, <u>&lt;=</u>, <u>&lt;</u>, <u>==</u> and <u>!=</u>.

               Example:

                   Test (Version &gt;= 2.5.11) Echo 2.5.11 or later.

               The <u>EnvIsSet</u> <u>varname</u> test-condition is true if the given environment variable is set. The
               <u>EnvMatch</u> <u>varname</u> <u>pattern</u> test-condition is true if <u>pattern</u> matches the given environment or
               infostore variable value. (See <b>InfoStoreAdd</b>). The pattern may contain special "*" and "?" chars.
               The "varname" is coded without the leading dollar sign ($).

               The <u>EdgeHasPointer</u> [<u>direction</u>] test-condition is true if the edge in the given direction
               currently contains the pointer. The <u>EdgeIsActive</u> [<u>direction</u>] test-condition is true if the edge
               in the given direction currently is active. An edge is active, and can contain a pointer if
               either a command is bound to it or edge scroll is available in that direction. The direction may
               be one of * Any<u>,</u> North<u>,</u> Top<u>,</u> Up<u>,</u> West<u>,</u> Left<u>,</u> South<u>,</u> Bottom<u>,</u>  Down<u>,</u> Right* and * East<u>.</u> <u>If</u> <u>no</u>
               <u>direction</u> <u>is</u> <u>specified</u> Any* is assumed.

               The <u>Start</u> test-condition is the same as either <u>Init</u> or <u>Restart</u>. It is only true on startup or
               restart prior and during <b>StartFunction</b> execution. The <u>Exit</u> test-condition is the same as either
               <u>Quit</u> or <u>ToRestart</u>. It is only valid on shutdown during <b>ExitFunction</b> function execution.

               The <u>True</u> and <u>False</u> test-conditions are unconditionally true and false.

               Additionally, if a test-condition name is not recognized, the Error return code is set and the
               command is not executed.

               The <u>F</u> <u>file</u>, <u>R</u> <u>file</u>, <u>W</u> <u>file</u>, <u>X</u> <u>file</u> and <u>I</u> <u>file</u> test-conditions test for existence of the given
               [F]ile (possibly with [R]ead/[W]rite permissions), e[X]ecutable (in <u>$PATH</u>), or the [I]mage (in
               ImagePath).

               Example:

                   AddToFunc StartFunction I Test (Init) Exec exec xterm

                   AddToFunc VerifyVersion
                   + I Test (Version 2.5.*) Echo 2.5.x detected
                   + I TestRc (NoMatch) \
                   Test (!Version 2.6.*) Echo Future version
                   + I TestRc (NoMatch) \
                   Echo 2.6.x is detected

                   Test (F $[FVWM_USERDIR]/local-config) Read local-config
                   Test (X xterm-utf16) Exec exec xterm-utf16

           <b>TestRc</b> [([!]<u>returncode</u>)] <u>command</u>
               Performs <u>command</u> if the last conditional command returned the value <u>returncode</u>. Instead of the
               numeric values 0 (no match), 1 (match), -1 (error), and -2 (break) the symbolic names "<u>NoMatch</u>",
               "<u>Match</u>", "<u>Error</u>" and "<u>Break</u>" can be used. If no <u>returncode</u> is given, the default 0 is assumed. If
               the return code is prefixed with '!', the command is executed if <u>returncode</u> does not match the
               value returned by the conditional command. The <b>TestRc</b> command can only be used inside functions.
               If the <u>command</u> is another conditional command, the previous return code is replaced by the new
               one. Example:

                   AddToFunc ToggleXterm
                   + I All (my_xtermwindow) Close
                   + I TestRc (NoMatch) Exec xterm -T my_xtermwindow

           <b>ThisWindow</b> [(<u>conditions</u>)] command
               <b>ThisWindow</b> executes the specified <u>command</u> in the context of the current operand window. If there
               is no operand window (it is invoked in the root window), the command is ignored. <b>ThisWindow</b> is
               never interactive. The command is executed only if the given <u>conditions</u> are met. It returns -1 if
               used outside a window context. See <b>Conditions</b> section for a list of conditions.

               This command implies the conditions <u>CirculateHit</u>, <u>CirculateHitIcon</u> and <u>CirculateHitShaded</u>. They
               can be turned off by specifying "!CirculateHit" etc. explicitly.

           <b>WindowId</b> [<u>id</u>] [(<u>conditions</u>)] | [root] <u>command</u>
               The <b>WindowId</b> command looks for a specific window <u>id</u> and runs the specified <u>command</u> on it. The
               second form of syntax retrieves the window id of the root window. The window indicated by <u>id</u> may
               belong to a window not managed by fvwm. Although most commands can not operate on such windows,
               there are some exceptions, for example the <b>WarpToWindow</b> command. Returns -1 if no window with the
               given id exists. See <b>Conditions</b> section for a list of conditions.

               This command implies the conditions <u>CirculateHit</u>, <u>CirculateHitIcon</u> and <u>CirculateHitShaded</u>. They
               can be turned off by specifying <u>!CirculateHit</u> etc. explicitly.

               Examples:

                   WindowId 0x34567890 Raise
                   WindowId root 1 WarpToWindow 50 50
                   WindowId $0 (Silly_Popup) Delete

               In the past this command was mostly useful for functions used with the <b>WindowList</b> command, or for
               selective processing of <b>FvwmEvent</b> calls (as in the last example), but currently these handler
               functions are called within a window context, so this command is not really needed in these
               cases. Still it may be useful if, for example, the window id should be stored in the environment
               variable for a further proceeding.

               Pick SetEnv BOOKMARKED_WINDOW $[w.id]
               WindowId $[BOOKMARKED_WINDOW] WarpToWindow

       <b>Conditions</b>
           The <u>conditions</u> that may be given as an argument to any conditional command are a list of keywords
           separated by commas, enclosed in parentheses. Unless stated otherwise, conditional commands accept
           all the conditions listed below. Note that earlier versions of fvwm required the conditions to be
           separated by whitespace instead of commas and enclosed in brackets instead of parentheses (this is
           still supported for backward compatibility).

           In addition, the <u>conditions</u> may include one or more window names to match to. If more than one window
           name is given, all of them must match. The window name, icon name, class, and resource are considered
           when attempting to find a match. Each name may include the wildcards '*' and '?', and may consist of
           two or more alternatives, separated by the character '|', which acts as an OR operator. (If OR
           operators are used, they must not be separated by spaces from the names.) Each window name can begin
           with '!', which prevents <u>command</u> if any of the window name, icon name, class or resource match.
           However, '!' must not be applied to individual names in a group separated by OR operators; it may
           only be applied to the beginning of the group, and then it operates on the whole group.

           Examples:

               Next ("Netscape|konqueror|Mozilla*") WarpToWindow 99 90

           This goes to the next web browser window, no matter which of the three named web browsers is being
           used.

               Next ("Mozilla*", "Bookmark*") WarpToWindow 99 90

           This goes to Mozilla’s bookmark manager window, ignoring other Mozilla windows and other browsers'
           bookmark windows.

               All ("XTerm|rxvt", !console) Iconify

           This iconifies all the xterm and rxvt windows on the current page, except that the one named
           "console" (with the -name option to xterm) is excluded.

               Next (!"FvwmPager|FvwmForm*|FvwmButtons") Raise
               Next (!FvwmPager, !FvwmForm*, !FvwmButtons) Raise

           These two commands are equivalent; either one raises the next window which is not one of the named
           fvwm modules.

           Any condition can be negated by using a an exclamation mark ('!') directly in front of its name.

           <u>AcceptsFocus</u>, <u>AnyScreen</u>, <u>CirculateHit</u>, <u>CirculateHitIcon</u>, <u>CirculateHitShaded</u>, <u>Closable</u>, <u>CurrentDesk</u>,
           <u>CurrentGlobalPage</u>, <u>CurrentGlobalPageAnyDesk</u>, <u>CurrentPage</u>, <u>CurrentPageAnyDesk</u>, <u>CurrentScreen</u>, <u>Desk</u>,
           <u>FixedPosition</u>, <u>FixedSize</u>, <u>Focused</u>, <u>HasBorders</u>, <u>HasHandles</u>, <u>HasPointer</u>, <u>HasTitle</u>, <u>TitleAtTop</u>,
           <u>TitleAtBottom</u>, <u>TitleAtLeft</u>, <u>TitleAtRight</u>, <u>Iconic</u>, <u>Iconifiable</u>, <u>Layer</u> <u>[n]</u>, <u>Maximizable</u>, <u>Maximized</u>,
           <u>Overlapped</u>, <u>PlacedByButton</u> <u>n</u>, <u>PlacedByButton3</u>, <u>PlacedByFvwm</u>, <u>Raised</u>, <u>Shaded</u>, <u>State</u> <u>n</u>, <u>Sticky</u>,
           <u>StickyAcrossDesks</u>, <u>StickyAcrossPages</u>, <u>StickyIcon</u>, <u>StickyAcrossDesksIcon</u>, <u>StickyAcrossPagesIcon</u>,
           <u>Transient</u>, <u>Visible</u>.

           The <u>AcceptsFocus</u> condition excludes all windows that do not want the input focus (the application has
           set the "Input hints" for the window to False) and do not use the <u>Lenience</u> option of the <b>Style</b>
           command. Also, all windows using the <u>NeverFocus</u> style are ignored. Note: <u>!Lenience</u> is equivalent to
           the deprecated option <u>NoLenience</u>.

           With the <u>AnyScreen</u> condition used together with any of the <u>Current...</u> conditions, windows that do not
           intersect the screen containing the mouse pointer are considered for a match too. For example:

               # Focus next window on current page,
               # regardless of screen
               Next (CurrentPage, AnyScreen) Focus

           The <u>CirculateHit</u> and <u>CirculateHitIcon</u> options override the <u>CirculateSkip</u> and <u>CirculateSkipIcon</u> <b>Style</b>
           attributes for normal or iconic windows. The <u>CirculateHitShaded</u> option overrides the
           <u>CirculateSkipShaded</u> <b>Style.</b> All three options are turned on by default for the <b>Current</b> command. They
           can be turned off by specifying <u>!CirculateHit</u> etc. explicitly. Note: Do not confuse these conditions
           with the style options of the same name. Specifically,

               Style foo CirculateSkip
               Next (foo, CirculateHit) ...

           is not the same as

               Style foo CirculateHit ...
               Next (foo)

           The prior selects windows with the name foo only in the Next command. In the second example, these
           windows are always matched in all conditional commands.

           The <u>Closable</u> condition matches only windows that are allowed to be closed.

           The <u>CurrentDesk</u> condition matches only windows that are on the current desk.

           The <u>CurrentGlobalPage</u> condition matches only windows that are on the current page of the current
           desk, regardless of which screen the window is on. This condition implicitly activates the
           <u>CurrentDesk</u> condition.

           The <u>CurrentGlobalPageAnyDesk</u> condition matches only windows that are on the current page of any desk,
           regardless of RandR screen .

           The <u>CurrentPage</u> condition matches only windows that are on the current page of the current desk. This
           condition implicitly activates the <u>CurrentDesk</u> condition.

           The <u>CurrentPageAnyDesk</u> and <u>CurrentScreen</u> conditions matches only windows that are on the current page
           of any desk.

           The <u>Screen</u> <u>[name]</u> condition matches only windows which are on the specified screen.

           The <u>Desk</u> <u>[n]</u> condition matches only windows which are on the specified desk.

           The <u>FixedPosition</u> condition excludes all windows that do not have a fixed position, either set
           through WM hints or the <b>Style</b> option <u>FixedPosition</u>. Example:

               DestroyFunc ToggleFixedGeometry
               AddToFunc   ToggleFixedGeometry
               + I Pick (FixedPosition) \
               WindowStyle VariablePosition, VariableSize
               + I TestRc (NoMatch) WindowStyle FixedPosition, FixedSize

           The <u>FixedSize</u> condition excludes all windows that do not have a fixed size, either set through WM
           hints or the <b>Style</b> option <u>FixedSize</u>.

           The <u>Focused</u> matches on the window that currently has the keyboard focus. This is not useful for the
           <b>Current</b> command but can be used with the other conditional commands.

           The <u>HasBorders</u> condition excludes all windows that do not have borders.

           The <u>HasHandles</u> condition excludes all windows that do not have resize handles.

           The <u>HasPointer</u> condition excludes all windows that do not contain the pointer.

           The <u>HasTitle</u> condition excludes all windows that do not have a titlebar.

           The <u>TitleAtTop</u>, <u>TitleAtBottom</u>, <u>TitleAtLeft</u>, <u>TitleAtRight</u> conditions test for the titlebar at that
           window location.

           The <u>Iconic</u> condition matches only iconic windows.

           The <u>Iconifiable</u> condition matches only windows that are allowed to be iconified.

           The <u>Layer</u> <u>[n]</u> condition matches only windows on the specified layer. The optional argument of the
           <u>Layer</u> condition defaults to the layer of the focused window. The negation <u>!Layer</u> switches off the
           <u>Layer</u> condition.

           The <u>Maximizable</u> condition matches only windows that are allowed to be maximized.

           The <u>Maximized</u> condition matches only maximized windows.

           The <u>Overlapped</u> condition matches only windows that are overlapped by other windows on the same layer
           (or unmanaged windows if the option <u>RaiseOverUnmanaged</u> of the <b>BugOpts</b> command is used). Note that
           this condition can be slow if you have many windows or if RaiseOverUnmanaged is used and the
           connection to the X server is slow.

           The <u>PlacedByButton</u> <u>n</u> condition is fulfilled if the last interactive motion of the window (with the
           <b>Move</b> command or as <u>ManualPlacement</u>) was ended by pressing mouse button <u>n</u>. Example:

               Mouse   1 T     A       Function MoveWindow

               DestroyFunc MoveWindow
               AddToFunc MoveWindow
               + C Move
               + C ThisWindow (PlacedByButton 5) WindowShade off
               + C TestRc (Match) Maximize on 0 100
               + C ThisWindow (PlacedByButton 4) WindowShade on

           The <u>PlacedByButton3</u> condition has the same meaning as <u>PlacedByButton</u> 3. It remains only for backward
           compatibility.

           The <u>PlacedByFvwm</u> condition excludes all windows that have been placed manually or by using the user
           or program position hint.

           The <u>Raised</u> conditions matches only windows that are fully visible on the current viewport and not
           overlapped by any other window.

           The <u>Shaded</u> conditions matches only shaded windows (see <b>WindowShade</b> command).

           The <u>State</u> <u>n</u> or <u>!State</u> <u>n</u> conditions match only windows with the specified integer state set (or
           unset). See the <b>State</b> command for details. The argument may range from 0 to 31.

           The <u>Sticky</u>, <u>StickyAcrossDesks</u> and <u>StickyAcrossPages</u> match only windows that are currently sticky,
           sticky across all desks or sticky across all pages. Please refer to the <b>Style</b> options with the same
           name and the commands <b>Stick</b>, <b>StickAcrossDesks</b> and <b>StickAcrossPages</b> for details.

           The <u>StickyIcon</u>, <u>StickyAcrossDesksIcon</u> and <u>StickyAcrossPagesIcon</u> match only windows that become
           sticky, sticky across all desks or sticky across all pages when they are in iconified state.

           The <u>Transient</u> condition matches only windows that have the "transient" property set by the
           application. This it usually the case for application popup menus and dialogs. The <b>FvwmIdent</b> module
           can be used to find out whether a specific window is transient.

           The <u>Visible</u> condition matches only windows that are at least partially visible on the current
           viewport and not completely overlapped by other windows.

   <b>Module</b> <b>Commands</b>
       Fvwm maintains a database of module configuration lines in a form

           *&lt;ModuleName&gt;: &lt;Config-Resource&gt;

       where <u>&lt;ModuleName&gt;</u> is either a real module name or an alias.

       This database is initially filled from config file (or from output of <b>-cmd</b> config command), and can be
       later modified either by user (via <b>FvwmCommand</b>) or by modules.

       When modules are run, they read appropriate portion of database. (The concept of this database is similar
       to one used in X resource database).

       Commands for manipulating module configuration database are described below.

       <b>*</b> <u>module_config_line</u>
           Defines a module configuration. <u>module_config_line</u> consists of a module name (or a module alias) and
           a module resource line. The new syntax allows a delimiter, a colon and optional spaces, between the
           module name and the rest of the line, this is recommended to avoid conflicts.

               *FvwmPager: WindowBorderWidth 1
               *FvwmButtons-TopRight: Geometry 100x100-0+0
               *FvwmButtons-Bottom: Geometry +0-0

       <b>DestroyModuleConfig</b> <u>module_config</u>
           Deletes module configuration entries, so that new configuration lines may be entered instead. This
           also sometimes the only way to turn back some module settings, previously defined. This changes the
           way a module runs during a fvwm session without restarting. Wildcards can be used for portions of the
           name as well.

           The new non-conflicting syntax allows a delimiter, a colon and optional spaces between the module
           name and the rest of the line. In this case a module name (or alias) can’t have wildcards.

               DestroyModuleConfig FvwmButtons*
               DestroyModuleConfig FvwmForm: Fore
               DestroyModuleConfig FvwmIconMan: Tips*

       <b>KillModule</b> <u>modulename</u> [<u>modulealias</u>]
           Causes the module which was invoked with name <u>modulename</u> to be killed. The name may include
           wildcards. If <u>modulealias</u> is given, only modules started with the given alias are killed.

               # kill all pagers
               KillModule FvwmPager

               Module FvwmEvent SoundEvent
               KillModule FvwmEvent SoundEvent

       <b>Module</b> <u>modulename</u> [<u>moduleparams</u>]
           Specifies a module with its optional parameters which should be spawned. Currently several modules,
           including <b>FvwmButtons</b>, <b>FvwmEvent</b>, <b>FvwmForm</b>, <b>FvwmPager</b>, <b>FvwmScript</b> support aliases. Aliases are useful
           if more than one instance of the module should be spawned. Aliases may be configured separately using
           <b>*</b> syntax. To start a module <b>FvwmForm</b> using an alias <u>MyForm</u>, the following syntax may be used:

               Module FvwmForm MyForm

           At the current time the available modules (included with fvwm) are <b>FvwmAnimate</b> (produces animation
           effects when a window is iconified or de-iconified), <b>FvwmAuto</b> (an auto raise module), <b>FvwmBacker</b> (to
           change the background when you change desktops), <b>FvwmBanner</b> (to display a spiffy XBM, XPM, PNG or
           SVG), <b>FvwmButtons</b> (brings up a customizable tool bar), <b>FvwmCommandS</b> (a command server to use with
           shell’s FvwmCommand client), <b>FvwmConsole</b> (to execute fvwm commands directly), <b>FvwmEvent</b> (trigger
           various actions by events), <b>FvwmForm</b> (to bring up dialogs), <b>FvwmIconMan</b> (a flexible icon manager),
           <b>FvwmIdent</b> (to get window info), <b>FvwmPager</b> (a mini version of the desktop), <b>FvwmPerl</b> (a Perl
           manipulator and preprocessor), <b>FvwmProxy</b> (to locate and control obscured windows by using small proxy
           windows), <b>FvwmRearrange</b> (to rearrange windows), <b>FvwmScript</b> (another powerful dialog toolkit), These
           modules have their own man pages. There may be other modules out on there as well.

           Modules can be short lived transient programs or, like <b>FvwmButtons</b> , can remain for the duration of
           the X session. Modules are terminated by the window manager prior to restarts and quits, if possible.
           See the introductory section on modules. The keyword <b>Module</b> may be omitted if <u>modulename</u> is distinct
           from all fvwm commands.

       <b>ModuleListenOnly</b> <u>modulename</u> [<u>moduleparams</u>]
           This command works like the <b>Module</b> command, but fvwm never sends any messages to the module. This may
           be handy to write a module as a shell script that is triggered by external events without the burden
           to answer packets sent by fvwm. For example, a module written as a shell script may change labels of
           the <b>FvwmButtons</b> module to implement a simple clock.

       <b>ModulePath</b> <u>path</u>
           Specifies a colon separated list of directories in which to search for modules. To find a module,
           fvwm searches each directory in turn and uses the first file found. Directory names on the list do
           not need trailing slashes.

           The <b>ModulePath</b> may contain environment variables such as <u>$HOME</u> (or <u>${HOME}</u>). Further, a '+' in the
           <u>path</u> is expanded to the previous value of the <u>path</u>, allowing easy appending or prepending to the
           <u>path</u>.

           For example:

               ModulePath ${HOME}/lib/fvwm/modules:+

           The directory containing the standard modules is available via the environment variable
           <u>$FVWM_MODULEDIR</u>.

       <b>ModuleSynchronous</b> [Expect <u>string</u>] [Timeout <u>secs</u>] <u>modulename</u>
           The <b>ModuleSynchronous</b> command is very similar to <b>Module</b>. Fvwm stops processing any commands and user
           input until the module sends a string beginning with "NOP FINISHED STARTUP" back to fvwm. If the
           optional <u>Timeout</u> is given fvwm gives up if the module sent no input back to fvwm for <u>secs</u> seconds. If
           the <u>Expect</u> option is given, fvwm waits for the given <u>string</u> instead. <b>ModuleSynchronous</b> should only be
           used during fvwm startup to enforce the order in which modules are started. This command is intended
           for use with the (currently hypothetical) module that should be in place before other modules are
           started.

           <b>Warning</b>: It is quite easy to hang fvwm with this command, even if a timeout is given. Be extra
           careful choosing the string to wait for. Although all modules in the fvwm distribution send back the
           "NOP FINISHED STARTUP" string once they have properly started up, this may not be the case for third
           party modules. Moreover, you can try to escape from a locked <b>ModuleSynchronous</b> command by using the
           key sequence

           (see the <b>EscapeFunc</b>).

       <b>ModuleTimeout</b> <u>timeout</u>
           Specifies how many seconds fvwm waits for a module to respond. If the module does not respond within
           the time limit then fvwm kills it. <u>timeout</u> must be greater than zero, or it is reset to the default
           value of 30 seconds.

       <b>SendToModule</b> <u>modulename</u> <u>string</u>
           Sends an arbitrary string (no quotes required) to all modules, whose alias or name matching
           <u>modulename</u>, which may contain wildcards. This only makes sense if the module is set up to understand
           and deal with these strings though. Can be used for module to module communication, or implementation
           of more complex commands in modules.

   <b>Session</b> <b>Management</b> <b>Commands</b>
       <b>Quit</b>
           Exits fvwm, generally causing X to exit too.

       <b>Restart</b> [<u>window_manager</u> [<u>params</u>]]
           Causes fvwm to restart itself if <u>window_manager</u> is left blank, or to switch to an alternate window
           manager (or other fvwm version) if <u>window_manager</u> is specified. If the window manager is not in your
           default search path, then you should use the full path name for <u>window_manager</u>.

           This command should not have a trailing ampersand. The command can have optional parameters with
           simple shell-like syntax. You can use <u>~</u> (is expanded to the user’s home directory) and environmental
           variables <u>$VAR</u> or <u>${VAR}</u>. Here are several examples:

               Key F1 R N Restart
               Key F1 R N Restart fvwm1 -f .fvwmrc
               Key F1 R N Restart xterm -n '"X console"' -T \"X\ console\" -e fvwm

           Note, currently with multi headed displays, restart of fvwms on different screens works
           independently.

       <b>Restart</b> <b>--pass-args</b> <u>window_manager</u>
           The same as <b>Restart</b> without parameters but the name for the current window manager is replaced with
           the specified <u>window_manager</u> and original arguments are preserved.

       <b>Restart</b> <b>--dont-preserve-state</b> [<u>other-params</u>]
           The same as

               Restart [other-params]

           but it does not save any window states over the restart.

           Without this option, <b>Restart</b> preserves most per-window state by writing it to a file named
           <u>.fs-restart-$HOSTDISPLAY</u> in the user’s home directory.

       <b>SaveSession</b>
           Causes a session manager (if any) to save the session. This command does not work for xsm, it seems
           that xsm does not implement this functionality. Use Unix signals to manage xsm remotely.

       <b>SaveQuitSession</b>
           Causes a session manager (if any) to save and then shutdown the session. This command does not work
           for xsm, it seems that xsm does not implement this functionality. Use Unix signals to manage xsm
           remotely.

   <b>Colorsets</b>
       Colorsets are a powerful method to control colors. Colorsets create appearance resources that are shared
       by fvwm and its modules. When a colorset is modified all parts of fvwm react to that change. A colorset
       includes a foreground color, background color, shadow and highlight color (often based on the background
       color), background face (this includes images and all kinds of gradients). There is a way to render
       background face and specify other color operations.

       <b>Colorset</b> <u>num</u> [<u>options</u>]
           Creates or modifies colorset <u>num</u>. Colorsets are identified by this number. The number can start at
           zero and can be a very large number.

           Warning: The highest colorset number used determines memory consumption. Thus, if you define
           'Colorset 100000', the memory for 100001 colorsets is used. Keep your colorset numbers as small as
           possible.

           By convention, colorsets are numbered like this:

               # 0 = Default colors
               # 1 = Inactive windows
               # 2 = Active windows
               # 3 = Inactive menu entry and menu background
               # 4 = Active menu entry
               # 5 = greyed out menu entry (only bg used)
               # 6 = module foreground and background
               # 7 = hilight colors

           If you need to have more colors and do not want to reinvent the wheel, you may use the convention
           used in fvwm-themes, it defines the meaning of the first 40 colorsets for nearly all purposes:

           <a href="http://fvwm-themes.sourceforge.net/doc/colorsets">http://fvwm-themes.sourceforge.net/doc/colorsets</a>

           Each colorset has four colors, an optional pixmap and an optional shape mask. The four colors are
           used by modules as the foreground, background, highlight and shadow colors. When a colorset is
           created it defaults to a foreground of black and background of gray. The background and foreground
           are marked as "average" and "contrast" (see later) so that just specifying a pixmap or gradient gives
           sensible results.

           <u>options</u> is a comma separated list containing some of the keywords: fg, Fore, Foreground, bg, Back,
           Background, hi, Hilite, Hilight, sh, Shade, Shadow, fgsh, Pixmap, TiledPixmap, AspectPixmap,
           Transparent, RootTransparent, Shape, TiledShape, AspectShape, NoShape, ?Gradient, Tint, fgTint,
           bgTint, Alpha, fgAlpha, Dither, NoDither, IconTint, IconAlpha, Plain.

           <u>fg</u>, <u>Fore</u> and <u>Foreground</u> take a color name as an argument and set the foreground color. The special
           name <u>Contrast</u> may be used to select a color that contrasts well with the background color. To reset
           the foreground color to the default value you can simply omit the color name.

           <u>bg</u>, <u>Back</u> and <u>Background</u> take a color name as an argument and set the background color. It also sets
           the highlight and shadow colors to values that give a 3d effect unless these have been explicitly set
           with the options below. The special name <u>Average</u> may be used to select a color that is the average
           color of the pixmap. If the pixmap is tinted with the <u>Tint</u> option, the tint is not taken in account
           in the computation of the average color. You should use the <u>bgTint</u> option to get the "real" average
           color. The background color is reset to the default value if the color name is omitted.

           <u>hi</u>, <u>Hilite</u> and <u>Hilight</u> take a color name as an argument and set the highlight color. If the highlight
           color is not explicitly set, the default is to calculate it from the background color. To switch back
           to the default behavior the color name can be omitted.

           <u>sh</u>, <u>Shade</u> and <u>Shadow</u> take a color name as an argument and set the shadow color. If the shadow color
           is not explicitly set, the default is to calculate it from the background color. To switch back to
           the default behavior the color name can be omitted.

           <u>fgsh</u> takes a color name as an argument and sets the color used by the shadowing font effect. See the
           <b>Font</b> <b>Shadow</b> <b>Effects</b> section of the fvwm man page. By default this color is computed from the
           foreground and background colors. To switch back to the default the color name can be omitted.

           <u>Pixmap</u>, <u>TiledPixmap</u> and <u>AspectPixmap</u> take a file name as an argument, search the <b>ImagePath</b> and use it
           as the background pixmap. Any transparent parts are filled with the background color. Not specifying
           a file name removes any existing image from the colorset. <u>TiledPixmap</u> produces repeated copies of the
           image with no scaling, <u>Pixmap</u> causes the image to be stretched to fit whatever object the colorset is
           applied to and <u>AspectPixmap</u> stretches to fit but retains the image aspect ratio.

           <u>Transparent</u> creates a transparent background pixmap. The pixmap is used as a window background to
           achieve root transparency. For this you should use the <u>ParentalRelativity</u> option to the <b>Style</b>
           command. A subsequent root background change may be detected or not, this depends on the program used
           to set the background. If you use <b>fvwm-root</b>, <b>xsetbg</b> (xli), <b>FvwmBacker</b> with solid or colorset colors
           or a recent version of <b>Esetroot</b> (&gt;= 9.2) a background change is detected. If background changes are
           not detected (e.g., if you use <b>xv</b> or <b>xsetroot</b>) you can force detection by using the <b>-d</b> option of
           fvwm-root:

               xv -root -quit mybg.png; fvwm-root -d

           Due to the way X implements transparency no guarantees can be made that the desired effect can be
           achieved. The application may even crash. If you experience any problems with this option, do not use
           it.

           Using outline move and resize (see the <b>OpaqueMoveSize</b> command and the <u>ResizeOpaque</u> <b>Style</b> option) as
           well as setting the <u>WindowShadeShrinks</u> style may help. The transparency achieved with <u>Transparent</u>
           depends on whether the colorset is applied to the foreground or the background of a window. In the
           second case the transparency is relative to the parent window of the window on which the colorset is
           defined. For example:

               Colorset 12 VGradient 200 grey30 grey60
               Colorset 17 Transparent
               *FvwmIconMan: Colorset 12
               *FvwmIconMan: PlainColorset 17

           gives an IconMan with a vertical grey gradient background and the buttons use the background (by
           transparency). To obtain a (root) transparent IconMan:

               Colorset 12 Transparent
               Colorset 17 Transparent
               Colorset 18 Transparent
               Colorset 19 Transparent

               *FvwmIconMan: Colorset 12
               *FvwmIconMan: PlainColorset 17
               *FvwmIconMan: FocusColorset 18
               *FvwmIconMan: IconColorset  19

           The Colorset IconMan option defines the IconMan window background, but the PlainColorset and the
           FocusColorset are drawn on the foreground. So, the transparency of the IconMan buttons is achieved by
           drawing nothing. Now if this IconMan is swallowed in an FvwmButtons as:

               FvwmButtons:(Colorset 10, Swallow "FvwmIconMan" 'FvwmIconMan')

           then, <b>FvwmIconMan</b> becomes a child of <b>FvwmButtons</b> and it is transparent relative to <b>FvwmButtons</b>. So,
           in this case <b>FvwmIconMan</b> uses Colorset 10 as background. If you want root transparency use the
           <u>RootTransparent</u> option. <b>FvwmButtons</b> <b>FvwmIconMan</b>, and <b>FvwmIdent</b>, are relatively simple. There is one
           main colorset option which defines the background of the window and the other colorsets (if any) are
           drawn on the foreground. The case of <b>FvwmProxy</b> is simpler, the two colorsets refer to the window
           backgrounds. <b>FvwmPager</b> is more complicated as almost everything in the pager are windows with some
           parental relations (the mini windows are the child and the desktops are the parents and all this is
           complicated by the hilighted page). So, the colorsets apply to the background of these windows. You
           should experiment. For <b>FvwmForm</b> and <b>FvwmScript</b> the situation is similar. There is a main window (a
           child of the root window) which corresponds to the main colorset and most of the widgets are windows
           which are children of the main window. <u>Tint</u> may work or not with the <u>Transparent</u> option. When the
           colorset is drawn on the foreground <u>Tint</u> should work. In some cases, tinting may be very slow.
           Tinting may work with fvwm menu (without animation). Tinting may work better if your X server has
           backing store enabled (try xdpyinfo to see if this the case). There is a chance that the backing
           store support of your X server does not work well with the terrible hack used to Tint the
           ParentRelative Pixmap. So, to get tinted root transparency it is more safe to use the <u>RootTransparent</u>
           option.

           <u>RootTransparent</u> [ <u>buffer</u> ] creates a root transparent background. To make this option work, you must
           use an <b>Esetroot</b> compatible program, fvwm-root with the --retain-pixmap option or <b>FvwmBacker</b> with the
           RetainPixmap option (and colorset or solid backgrounds). The <u>buffer</u> keyword is useful only when the
           <u>Tint</u> option is used too. This speeds up creation of windows which use the colorset (useful for fvwm
           menus) at the cost of memory usage. It also speeds up opaque move and resize which can be
           unacceptably slow without <u>buffer</u>. However, this option may add a lot of memory to your X server
           (depending on the size of the image used to set the background). In summary, using outline move and
           resize for modules which use such a colorset may be a good idea.

           <u>Shape</u>, <u>TiledShape</u> and <u>AspectShape</u> take a file name as an argument, search the <b>ImagePath</b> and use it as
           the shape bitmap. <u>TiledShape</u> produces repeated copies of the bitmap with no scaling, <u>Shape</u> causes the
           bitmap to be stretched to fit whatever object the colorset is applied to and <u>AspectShape</u> stretches to
           fit but retains the bitmap aspect ratio. If the file is a pixmap in xpm format the shape mask (all
           opaque pixels) of the pixmap is used. For png and svg images, the shape mask is equivalent to all not
           completely transparent pixels (alpha &gt; 0).

           <b>Warning</b> Due to the way X11 implements shapes you cannot take back making windows shaped. You may have
           to restart fvwm or the shaped application.

           <u>?Gradient</u> <u>...</u> creates a pixmap and stretches it to fit the window. <u>?Gradient</u> may be one of <u>HGradient</u>,
           <u>VGradient</u>, <u>DGradient</u>, <u>BGradient</u>, <u>SGradient</u>, <u>CGradient</u>, <u>RGradient</u> or <u>YGradient</u>. The gradient types are
           as follows: H is horizontal; V is vertical; D is diagonal from top left to bottom right; B is a
           backwards diagonal from bottom left to top right; S is concentric squares; C is concentric circles; R
           is a radar like pattern and Y is a Yin Yang style (but without the dots). Please refer to the <b>Color</b>
           <b>Gradients</b> section for the syntax of gradients.

           <u>Tint</u> takes 2 arguments, a color and a percentage between 0 and 100. It causes the image defined using
           <u>?Pixmap</u> or <u>?Gradient</u> to be tinted with the specified color using the percentage. If the image is
           transparent <u>Tint</u> tints only the image part. Unfortunately, a colorset background specified using the
           <u>Transparent</u> option can give strange results. See the <u>Transparent</u> option for details. With no
           arguments this option removes the tint.

           <u>fgTint</u> takes 2 arguments, a color and a percentage between 0 and 100. It causes the color defined
           using <u>fg</u> to be tinted with the specified color using the percentage. With no arguments this option
           removes the tint.

           <u>bgTint</u> takes 2 arguments, a color and a percentage between 0 and 100. It causes the color defined
           using <u>bg</u> to be tinted with the specified color using the percentage. If the <u>sh</u> and <u>hi</u> colors are not
           specified, they are recomputed from the tinted bg color. With no arguments this option removes the
           tint.

           <u>Alpha</u> takes a percentage between 0 and 100 as an argument. It causes fvwm to merge the image defined
           using <u>?Pixmap</u> or <u>?Gradient</u> with the <u>bg</u> color using the percentage. If the percentage is 0 the image
           is hidden and if it is 100 the image is displayed as usual (no merge). The default is 100 and it is
           restored if no argument is given.

           <u>fgAlpha</u> takes a percentage between 0 and 100 as an argument. It causes fvwm to merge the text and the
           colorset background using the percentage. If the percentage is 0 the text is hidden and if it is 100
           the text is displayed as usual (no merge). This option has an effect only with fonts loaded by Xft,
           see the <b>Font</b> <b>Names</b> <b>and</b> <b>Font</b> <b>Loading</b> section. The default is 100 and it is restored if no argument is
           given.

           <u>Dither</u> causes fvwm to dither the image defined using <u>?Pixmap</u> or <u>?Gradient.</u> This is useful only with
           displays with depth less than or equal to 16 (i.e., on displays which can only display less than
           65537 colors at once). The dithering effect lets you simulate having more colors available that you
           actually have. <u>NoDither</u> causes fvwm to do not dither the images. <u>Dither</u> is the default if the depth
           is less than or equal to 8 (a screen with 256 colors or less). In depth 15 (32768 colors) and 16
           (65536 colors), the default is <u>NoDither</u>, however this effect can be useful with images which contain
           a lot of close colors. For example a fine gradient looks more smooth.

           <u>IconTint</u> takes 2 arguments, a color and a percentage between 0 and 100. It causes fvwm or a module to
           tint the "icons" which are rendered into the colorset background with the specified color using a
           percentage. Here "icons" means, fvwm Icons, fvwm menu icons, MiniIcons which represent applications
           in various modules, images loaded by modules (e.g., images specified by the <u>Icon</u> <b>FvwmButtons</b> button
           option) ...etc. With no arguments this option removes the icon tint.

           <u>IconAlpha</u> takes a percentage between 0 and 100 as an argument. It causes fvwm to merge the "icons"
           which are rendered into the colorset background using this percentage. The default is 100 and it is
           restored if no argument is given.

           <u>Note</u>: It is equivalent to use "Tint a_color rate" and "Alpha a" if a = 100 and the bg color is
           a_color. This equivalence does not hold for IconAlpha and IconTint as the background can be an image
           or a gradient (and not a uniform color background). However, in some cases you can achieve (almost)
           the same effect by using IconTint in the place of IconAlpha. This is preferable as, in general,
           IconAlpha generates more redrawing than IconTint.

           <u>NoShape</u> removes the shape mask from the colorset while <u>Plain</u> removes the background pixmap or
           gradient.

           Examples

               Colorset 3 fg tan, bg navy

           If necessary this creates colorsets 0, 1, 2 and 3 and then changes colorset 3 to have a foreground of
           tan, a background of navy.

               Colorset 3 bg "navy blue"

           changes the background color of colorset 3 to navy blue. The foreground and pixmap are unchanged.

               Colorset 3 AspectPixmap large_murky_dungeon.xpm

           causes depression.

               Colorset 3 bg Average

           Sets the background color and the relief colors to match the background pixmap. This is the default
           setting but it must be used if a background color was specified and is now not required.

               Colorset 3 YGradient 200 3 blue 1000 navy 1 blue 1000 navy

           Adds a Yin Yang gradient background pixmap to colorset 3. If the background is set to average it is
           recomputed along with the foreground if that is set to contrast.

               #!<a href="file:/bin/sh">/bin/sh</a>
               FvwmCommand "Colorset 7 fg navy, bg gray"
               while true
               do
                       FvwmCommand "Colorset 7 fg gray"
                       sleep 1
                       FvwmCommand "Colorset 7 fg navy"
                       sleep 1
               done

           Makes colorset 7 blink.

           The color names used in colorsets are saved as fvwm variables which can be substituted in any fvwm
           command. For example:

               AddToFunc InitFunction
               + I Exec exec xterm -fg $[fg.cs0] -bg $[bg.cs0]

           Where $[fg.cs0] is the foreground color of colorset zero. Please refer to the <b>Command</b> <b>Expansion</b>
           section for more information.

       <b>CleanupColorsets</b>
           Resets a definition of all colorsets.

       <b>Color</b> <b>Gradients</b>
           A color gradient is a background that changes its color gradually from one hue to a different one.
           Color gradients can be used by various commands and modules of fvwm. There are eight types of
           gradients: <b>HGradient</b> is a horizontal gradient, <b>VGradient</b> is vertical, <b>DGradient</b> is diagonal from top
           left to bottom right, <b>BGradient</b> is backwards diagonal from bottom left to top right, <b>SGradient</b> is
           concentric squares, <b>CGradient</b> is concentric circles, <b>RGradient</b> is a radar like pattern and <b>YGradient</b>
           is a Yin Yang style (but without the dots).

           The color gradient syntax has two forms:

           <b>?Gradient</b> <u>colors</u> <u>start-color</u> <u>end-color</u>

           This form specifies a linear gradient. The arguments denote the total number of <u>colors</u> to allocate
           (between 2 and 1000), the initial color and the final color.

           Example:

               TitleStyle VGradient 20 rgb:b8/ce/bc rgb:5b/85/d0

           <b>?Gradient</b> <u>colors</u> <u>segments</u> <u>color</u> <u>length</u> <u>color</u> [<u>length</u> <u>color</u>] ...

           The second form specifies a nonlinear gradient. The arguments are: the total number of <u>colors</u> to
           allocate (between 2 and 1000), then the number of <u>segments</u>. For each segment, specify the starting
           <u>color</u>, a relative <u>length</u>, then the ending color. Each subsequent segment begins with the second color
           of the last segment. The lengths may be any non-negative integers. The length of one segment divided
           by the sum of all segments lengths is the fraction of the colors that are used for the segment.

           Examples:

               Colorset 0 DGradient 128 2 lightgrey 50 blue 50 white

               # 20% gradient from red to blue,
               # 30% from blue to black,
               # 50% from black to grey
               Colorset 0 DGradient 100 3 Red 20 Blue 30 Black 50 Grey

               # 50% from blue to green, then
               # 50% from yellow to red
               Colorset 0 HGradient 128 3 Blue 1000 Green 1 Yellow 1000 Red

           Note: Some gradient styles may be slow and consume huge amounts of memory, so if you encounter
           performance problems with them you may be better off by not using them. To improve performance you
           can try one or all of the following:

           Turn hilighting of the active menu item other than foreground color off:

               MenuStyle &lt;style&gt; Hilight3DOff, !HilightBack

           Make sure sub menus do not overlap the parent menu. This can prevent menus being redrawn every time a
           sub menu pops up or down.

               MenuStyle &lt;style&gt; PopupOffset 1 100

           Run your X server with backing storage. If your X Server is started with the -bs option, turn it off.
           If not try the -wm and +bs options:

               startx -- -wm +bs

           You may have to adapt this example to your system (e.g. if you use xinit to start X).

                                                   2025-02-22                                   <u><a href="../man1/FVWM3COMMANDS.1.html">FVWM3COMMANDS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>