<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>yarn - scenario testing of Unix command line tools</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/cmdtest">cmdtest_0.32.14.gcdfe14e-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       yarn - scenario testing of Unix command line tools

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>yarn</b>  [<b>--allow-missing-steps</b>] [<b>--no-allow-missing-steps</b>] [<b>--cd-datadir</b>] [<b>--no-cd-datadir</b>] [<b>--config</b>=<u>FILE</u>]
       [<b>--dump-config</b>]   [<b>--dump-setting-names</b>]   [<b>--generate-manpage</b>=<u>TEMPLATE</u>]   [<b>-h</b>]   [<b>--help</b>]   [<b>--help-all</b>]
       [<b>--list-config-files</b>]       [<b>--version</b>]       [<b>--no-default-configs</b>]       [<b>--dump-memory-profile</b>=<u>METHOD</u>]
       [<b>--env</b>=<u>NAME=VALUE</u>] [<b>--log</b>=<u>FILE</u>]  [<b>--log-keep</b>=<u>N</u>]  [<b>--log-level</b>=<u>LEVEL</u>]  [<b>--log-max</b>=<u>SIZE</u>]  [<b>--log-mode</b>=<u>MODE</u>]
       [<b>--memory-dump-interval</b>=<u>SECONDS</u>]  [<b>--output</b>=<u>FILE</u>]  [<b>-q</b>]  [<b>--quiet</b>]  [<b>--no-quiet</b>]  [<b>--require-assumptions</b>]
       [<b>--no-require-assumptions</b>]    [<b>-r</b><u>SCENARIO</u>]     [<b>--run</b>=<u>SCENARIO</u>]     [<b>--shell</b>=<u>SHELL</u>]     [<b>--shell-arg</b>=<u>ARG</u>]
       [<b>-s</b><u>SHELL-LIBRARY</u>]  [<b>--shell-library</b>=<u>SHELL-LIBRARY</u>]  [<b>--snapshot</b>]  [<b>--no-snapshot</b>]  [<b>--stop-on-first-fail</b>]
       [<b>--no-stop-on-first-fail</b>] [<b>--tempdir</b>=<u>DIR</u>] [<b>--timings</b>] [<b>--no-timings</b>] [<b>-v</b>] [<b>--verbose</b>] [<b>--no-verbose</b>] [<b>-n</b>]
       [<b>--no-act</b>] [<b>--dry-run</b>] [<b>--pretend</b>] [<b>--no-no-act</b>] [<b>--no-dry-run</b>] [<b>--no-pretend</b>] [<u>FILE</u>]...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>yarn</b> is a scenario testing tool: you write a scenario describing how a user uses your software  and  what
       should  happen,  and  express,  using  very lightweight syntax, the scenario in such a way that it can be
       tested automatically.  The scenario has a simple, but strict structure:

              GIVEN some setup for the test
              WHEN thing that is to be tested happens
              THEN the post-conditions must be true

       As an example, consider a very short test scenario for verifying that a backup program  works,  at  least
       for one simple case.

              SCENARIO backups can be restored
              GIVEN some live data in a directory
              AND an empty backup repository
              WHEN a backup is made
              THEN the data case be restored
              FINALLY cleanup

       Note  the  addition of AND: you can have multiple GIVEN, WHEN, and THEN statements. The AND keyword makes
       the text be more readable.  SCENARIO is also necessary, and gives the title.

       FINALLY is for cleanups.  The FINALLY steps will be run regardless of whether the  scenario  succeeds  or
       not.

       Scenarios  are  meant to be written in somewhat human readable language.  However, they are not free form
       text.  In addition to the GIVEN/WHEN/THEN structure, the text for each of the steps needs a computer-exe‐
       cutable implementation.  This is done by using IMPLEMENTS.  The backup scenario from above might  be  im‐
       plemented as follows:

              IMPLEMENTS GIVEN some live data in a directory
              rm -rf "$DATADIR/data"
              mkdir "$DATADIR/data"
              echo foo &gt; "$DATADIR/data/foo"

              IMPLEMENTS GIVEN an empty backup repository
              rm -rf "$DATADIR/repo"
              mkdir "$DATADIR/repo"

              IMPLEMENTS WHEN a backup is made
              backup-program -r "$DATADIR/repo" "$DATADIR/data"

              IMPLEMENTS THEN the data can be restored
              mkdir "$DATADIR/restored"
              restore-program -r "$DATADIR/repo" "$DATADIR/restored"
              diff -rq "$DATADIR/data" "$DATADIR/restored"

              IMPLEMENTS FINALLY cleanup
              echo nothing to do, actually

       Each  "IMPLEMENTS  GIVEN"  (or WHEN, THEN, FINALLY) is followed by a regular expression on the same line,
       and then a shell script that gets executed to implement any step that  matches  the  regular  expression.
       The implementation can extract data from the match as well: for example, the regular expression might al‐
       low a file size to be specified.

       The  above  example  is a bit silly, of course: why go to the effort to obfuscate the various steps?  The
       answer is that the various steps, implemented using IMPLEMENTS, can be combined in  many  ways,  to  test
       different aspects of the program being tested.

       Moreover, by making the step descriptions be human language text, matched by regular expressions, most of
       the  test  can  hopefully be written, and understood, by non-programmers.  Someone who understands what a
       program should do, could write tests to verify its behaviour.  The implementations of the  various  steps
       need  to  be implemented by a programmer, but given a well-designed set of steps, with enough flexibility
       in their implementation, that quite a good test suite can be written.

       The shell commands in an IMPLEMENTS section are run in the directory in which the user ran <b>yarn</b>.  The en‐
       vironment variable <b>SRCDIR</b> is set to the fully qualified path to that directory.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>--allow-missing-steps</b>
              allow scenarios to reference steps that do not exist, by warning about them, but otherwise  ignor‐
              ing the scenarios

       <b>--no-allow-missing-steps</b>
              opposite of --allow-missing-steps

       <b>--cd-datadir</b>
              change to DATADIR when running commands

       <b>--no-cd-datadir</b>
              opposite of --cd-datadir

       <b>--env</b>=<u>NAME=VALUE</u>
              add NAME=VALUE to the environment when tests are run

       <b>--generate-manpage</b>=<u>TEMPLATE</u>
              fill in manual page TEMPLATE

       <b>-h</b>, <b>--help</b>
              show this help message and exit

       <b>--output</b>=<u>FILE</u>
              write output to FILE, instead of standard output

       <b>-q</b>, <b>--quiet</b>
              be quiet, avoid progress reporting, only show errors

       <b>--no-quiet</b>
              opposite of --quiet

       <b>--require-assumptions</b>
              require ASSUMING to always pass

       <b>--no-require-assumptions</b>
              opposite of --require-assumptions

       <b>-r</b>, <b>--run</b>=<u>SCENARIO</u>
              run only SCENARIO (this option can be repeated)

       <b>--shell</b>=<u>SHELL</u>
              run IMPLEMENTS using SHELL

       <b>--shell-arg</b>=<u>ARG</u>
              use ARG when running shell

       <b>-s</b>, <b>--shell-library</b>=<u>SHELL-LIBRARY</u>
              include a shell library for the IMPLEMENTS sections to use

       <b>--snapshot</b>
              make  snapshots  of test working directory after each scenario step; you probably want to use this
              with --tempdir

       <b>--no-snapshot</b>
              opposite of --snapshot

       <b>--stop-on-first-fail</b>
              stop if any scenario step fails, don't run more scenarios

       <b>--no-stop-on-first-fail</b>
              opposite of --stop-on-first-fail

       <b>--tempdir</b>=<u>DIR</u>
              use DIR as the temporary directory for tests; it should be empty or not exist

       <b>--timings</b>
              report wall clock time for each scenario and step

       <b>--no-timings</b>
              opposite of --timings

       <b>-v</b>, <b>--verbose</b>
              make progress reporting be more verbose ("wall of text"), instead of a one-line status info;  this
              is turned automatically if there is not terminal

       <b>--no-verbose</b>
              opposite of --verbose

       <b>--version</b>
              show program's version number and exit

       <b>-n</b>, <b>--no-act</b>, <b>--dry-run</b>, <b>--pretend</b>
              do not actually run any tests, merely print what would be run

       <b>--no-no-act</b>, <b>--no-dry-run</b>, <b>--no-pretend</b>
              opposite of --no-act

   <b>Configuration</b> <b>files</b> <b>and</b> <b>settings</b>
       <b>--config</b>=<u>FILE</u>
              add FILE to config files

       <b>--dump-config</b>
              write out the entire current configuration

       <b>--dump-setting-names</b>
              write out all names of settings and quit

       <b>--help-all</b>
              show all options

       <b>--list-config-files</b>
              list all possible config files

       <b>--no-default-configs</b>
              clear list of configuration files to read

   <b>Logging</b>
       <b>--log</b>=<u>FILE</u>
              write  log entries to FILE (default is to not write log files at all); use "syslog" to log to sys‐
              tem log, "stderr" to log to the standard error output, or "none" to disable logging

       <b>--log-keep</b>=<u>N</u>
              keep last N logs (10)

       <b>--log-level</b>=<u>LEVEL</u>
              log at LEVEL, one of debug, info, warning, error, critical, fatal (default: debug)

       <b>--log-max</b>=<u>SIZE</u>
              rotate logs larger than SIZE, zero for never (default: 0)

       <b>--log-mode</b>=<u>MODE</u>
              set permissions of new log files to MODE (octal; default 0600)

   <b>Peformance</b>
       <b>--dump-memory-profile</b>=<u>METHOD</u>
              make memory profiling dumps using METHOD, which is one of: none, or simple (no meliae support any‐
              more)(default: simple)

       <b>--memory-dump-interval</b>=<u>SECONDS</u>
              make memory profiling dumps at least SECONDS apart

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>DATADIR</b>
              Fully qualified pathname to a temporary directory, in which the tests can use files.   The  tempo‐
              rary  directory  is  removed at the end of the test execution, unless the user specifies otherwise
              with --snapshot.

       <b>SRCDIR</b> Fully qualitifed pathname to the directory in which the user ran <b>yarn</b>.  This is  useful  when  the
              tests want to change the directory.

</pre><h4><b>EXAMPLE</b></h4><pre>
       To run <b>yarn</b> on all the scenarios in your current directory:

              yarn *.scenario

       All the files will be treated together as if they had been one file.

       To add a shell library to be included when running any IMPLEMENTS section:

              yarn --shell-library mylib.sh *.scenario

       You can repeat <b>--shell-library</b> as many times as necessary.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/cmdtest.1.html">cmdtest</a></b>(1), <b><a href="../man5/cliapp.5.html">cliapp</a></b>(5).

       The README.yarn file has more details on the scenario testing language.

                                                                                                         <u><a href="../man1/YARN.1.html">YARN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>