<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>stag-storenode.pl - script is for storing data in database</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libdbix-dbstag-perl">libdbix-dbstag-perl_0.12-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       stag-storenode.pl - script is for storing data in database

</pre><h4><b>SYNOPSIS</b></h4><pre>
         stag-storenode.pl -d "dbi:Pg:dbname=mydb;host=localhost" myfile.xml

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This script is for storing data (specified in a nested file format such as XML or S-Expressions) in a
       database. It assumes a database schema corresponding to the tags in the input data already exists.

   <b>ARGUMENTS</b>
       <u>-d</u> <u><b>DBNAME</b></u>

       This is either a DBI locator or the logical name of a database in the DBSTAG_DBIMAP_FILE config file

       <u>-user</u> <u><b>USER</b></u>

       db user name

       <u>-password</u> <u><b>PASSWORD</b></u>

       db user password

       <u>-u</u> <u><b>UNIT</b></u>

       This is the node/element name on which to load; a database loading event will be fired every time one of
       these elements is parsed; this also constitutes a whole transaction

       <u>-c</u> <u><b>STAGMAPFILE</b></u>

       This is a stag mapping file, indicating which elements are aliases

       <u>-p</u> <u><b>PARSER</b></u>

       Default is xml; can be any stag compatible parser, OR a perl module which will parse the input file and
       fire stag events (see Data::Stag::BaseGenerator)

       <u>-t</u> <u><b>TRANSFORMER</b></u>

       This is the name of a perl module that will perform a transformation on the stag events/XML. See also
       stag-handle.pl

       <u>-noupdate</u> <u><b>NODELIST</b></u>

       A comma-seperated (no spaces) list of nodes/elements on which no update should be performed if a unique
       key is found to be present in the DB

       <u>-trust_ids</u>

       If this flag is present, the values for primary key values are trusted; otherwise they are assumed to be
       surrogate internal IDs that should not be used. In this case they will be remapped.

       <u>-tracenode</u> <u><b>TABLE/COLUMN</b></u>

       E.g.

         -tracenode person/name

       Writes out a line on STDERR for every new person inserted/updated

       <u>-cache</u> <u><b>TABLE</b>=<b>MODE</b></u>

       Can be specified multiple times

       Example:

         -cache

                          0: off (default)
                          1: memory-caching ON
                          2: memory-caching OFF, bulkload ON
                          3: memory-caching ON, bulkload ON

       IN-MEMORY CACHING

       By default no in-memory caching is used. If this is set to 1, then an in-memory cache is used for any
       particular element. No cache management is used, so you should be sure not to cache elements that will
       cause memory overloads.

       Setting this will not affect the final result, it is purely an efficiency measure for use with
       <b>storenode()</b>.

       The cache is indexed by all unique keys for that particular element/table, wherever those unique keys are
       set

       BULKLOAD

       If bulkload is used without memory-caching (set to 2), then only INSERTs will be performed for this
       element. Note that this could potentially cause a unique key violation, if the same element is present
       twice

       If bulkload is used with memory-caching (set to 3) then only INSERTs will be performed; the unique
       serial/autoincrement identifiers for those inserts will be cached and used. This means you can have the
       same element twice. However, the load must take place in one session, otherwise the contents of memory
       will be lost

</pre><h4><b>XML</b> <b>TO</b> <b>DB</b> <b>MAPPING</b></h4><pre>
       See DBIx::DBStag for details of the actual mapping. Two styles of mapping are allowed: stag-dbxml and
       XORT-style XML. You do not have to specify which, they are sufficiently similar that the loader can
       accept either.

</pre><h4><b>MAKING</b> <b>DATABASE</b> <b>FROM</b> <b>XML</b> <b>FILES</b></h4><pre>
       It is possible to automatically generate a database schema and populate it directly from XML files (or
       from Stag objects or other Stag compatible files). Of course, this is no substitute for proper relational
       design, but often it can be necessary to quickly generate databases from heterogeneous XML data sources,
       for the purposes of data mining.

       There are 3 steps involved:

       1. Prepare the input XML (for instance, modifying db reserved words).  2. Autogenerate the CREATE TABLE
       statements, and make a db from these.  3. Store the XML data in the database.

   <b>Step</b> <b>1:</b> <b>Prepare</b> <b>input</b> <b>file</b>
       You may need to make modifications to your XML before it can be used to make a schema. If your XML
       elements contain any words that are reserved by your DB you should change these.

       Any XML processing tool (eg XSLT) can be used. Alternatively you can use the script 'stag-mogrify'

       e.g. to get rid of '-' characters (this is how Stag treates attributes) and to change the element with
       postgresql reserved word 'date', do this:

         stag-mogrify.pl -xml -r 's/^date$/moddate/' -r 's/\-//g' data.xml &gt; data.mog.xml

       You may also need to explicitly make elements where you will need linking tables. For instance, if the
       relationship between 'movie' and 'star' is many-to-many, and your input data looks like this:

         (movie
          (name "star wars")
          (star
           (name "mark hamill")))

       You will need to *interpose* an element between these two, like this:

         (movie
          (name "star wars")
          (movie2star
           (star
            (name "mark hamill"))))

       you can do this with the -i switch:

         stag-mogrify.pl -xml -i movie,star,movie2star data.xml &gt; data.mog.xml

       or if you simply do:

         stag-mogrify.pl -xml -i star data.xml &gt; data.mog.xml

       the mogrifier will simply interpose an element above every time it sees 'star'; the naming rule is to use
       the two elements with an underscore between (in this case, 'movie_star').

   <b>Step</b> <b>2:</b> <b>Generating</b> <b>CREATE</b> <b>TABLE</b> <b>statements</b>
       Use the stag-autoddl.pl script;

         stag-autoddl.pl data.mog.xml &gt; table.sql

       The default rule is to create foreign keys from the nested element to the outer element; you will want
       linking tables tobe treated differently (a linking table will point to parent and child elements).

         stag-autoddl.pl -l movie2star -l star2character data.mog.xml &gt; table.sql

       Once you have done this, load the statements into your db; eg for postgresql (for other databases, use
       SQL::Translator)

         psql -a mydb &lt; table.sql

       If something goes wrong, go back to step 1 and sort it out!

       Note that certain rules are followed: ever table generated gets a surrogate primary key of type 'serial';
       this is used to generate foreign key relationships. The rule used is primary and foreign key names are
       the name of the table with the '_id' suffix.

       Feel free to modify the autogenerated schema at this stage (eg add uniqueness constraints)

   <b>Step</b> <b>3:</b> <b>Store</b> <b>the</b> <b>data</b> <b>in</b> <b>the</b> <b>db</b>
         stag-storenode.pl -u movie -d 'dbi:Pg:mydb' data.mog.xml

       You generally don't need extra metadata here; everything can be infered by introspecting the database.

       The -u|unit switch controls when transactions are committed

       You can omit the -u switch, and every node directly under the top node will be stored. This will also be
       the transaction unit.

       If this works, you should now be able to retrieve XML from the database, eg

         stag-selectall_xml -d 'dbi:Pg:mydb' 'SELECT * FROM x NATURAL JOIN y'

perl v5.36.0                                       2022-10-14                                 <u><a href="../man1p/STAG-STORENODE.1p.html">STAG-STORENODE</a></u>(1p)
</pre>
 </div>
</div></section>
</div>
</body>
</html>