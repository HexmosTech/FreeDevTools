<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix">manpages-posix_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       make — maintain, update, and regenerate groups of programs (<b>DEVELOPMENT</b>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       make <b>[</b>-einpqrst<b>]</b> <b>[</b>-f <u>makefile</u><b>]</b>... <b>[</b>-k|-S<b>]</b> <b>[</b><u>macro</u>=<u>value</u>...<b>]</b>
           <b>[</b><u>target_name</u>...<b>]</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>make</u> utility shall update files that are derived from other files. A typical case is one where object
       files  are  derived from the corresponding source files. The <u>make</u> utility examines time relationships and
       shall update those derived files (called targets) that have modified  times  earlier  than  the  modified
       times  of  the  files  (called prerequisites) from which they are derived.  A description file (makefile)
       contains a description of the relationships between files, and the commands that need to be  executed  to
       update  the targets to reflect changes in their prerequisites. Each specification, or rule, shall consist
       of a target, optional prerequisites, and optional commands to be executed when a  prerequisite  is  newer
       than the target. There are two types of rule:

        1. <u>Inference</u> <u>rules</u>, which have one target name with at least one &lt;period&gt; (<b>'.'</b>)  and no &lt;slash&gt; (<b>'/'</b>)

        2. <u>Target</u> <u>rules</u>, which can have more than one target name

       In  addition, <u>make</u> shall have a collection of built-in macros and inference rules that infer prerequisite
       relationships to simplify maintenance of programs.

       To receive exactly the behavior described in this section, the user shall ensure that a portable makefile
       shall:

        *  Include the special target <b>.POSIX</b>

        *  Omit any special target reserved for implementations (a leading period followed by uppercase letters)
           that has not been specified by this section

       The behavior of <u>make</u> is unspecified if either or both of these conditions are not met.

</pre><h4><b>OPTIONS</b></h4><pre>
       The <u>make</u> utility shall conform to the Base Definitions volume  of  POSIX.1‐2017,  <u>Section</u>  <u>12.2</u>,  <u>Utility</u>
       <u>Syntax</u> <u>Guidelines</u>, except for Guideline 9.

       The following options shall be supported:

       <b>-e</b>        Cause  environment  variables,  including those with null values, to override macro assignments
                 within makefiles.

       <b>-f</b> <u>makefile</u>
                 Specify a different makefile. The argument <u>makefile</u> is a pathname of a description file,  which
                 is  also referred to as the <u>makefile</u>.  A pathname of <b>'-'</b> shall denote the standard input. There
                 can be multiple instances of this option, and they shall be processed in the  order  specified.
                 The effect of specifying the same option-argument more than once is unspecified.

       <b>-i</b>        Ignore error codes returned by invoked commands. This mode is the same as if the special target
                 <b>.IGNORE</b> were specified without prerequisites.

       <b>-k</b>        Continue  to  update  other  targets  that do not depend on the current target if a non-ignored
                 error occurs while executing the commands to bring a target up-to-date.

       <b>-n</b>        Write commands that would be executed on standard output, but do  not  execute  them.  However,
                 lines  with  a  &lt;plus-sign&gt; (<b>'+'</b>) prefix shall be executed. In this mode, lines with an at-sign
                 (<b>'@'</b>) character prefix shall be written to standard output.

       <b>-p</b>        Write to standard output the complete set of macro definitions  and  target  descriptions.  The
                 output format is unspecified.

       <b>-q</b>        Return  a  zero exit value if the target file is up-to-date; otherwise, return an exit value of
                 1. Targets shall not be updated if this option is specified. However, a makefile  command  line
                 (associated with the targets) with a &lt;plus-sign&gt; (<b>'+'</b>) prefix shall be executed.

       <b>-r</b>        Clear the suffix list and do not use the built-in rules.

       <b>-S</b>        Terminate  <u>make</u>  if  an error occurs while executing the commands to bring a target up-to-date.
                 This shall be the default and the opposite of <b>-k</b>.

       <b>-s</b>        Do not write makefile command lines or touch  messages  (see  <b>-t</b>)  to  standard  output  before
                 executing.  This mode shall be the same as if the special target <b>.SILENT</b> were specified without
                 prerequisites.

       <b>-t</b>        Update the modification time of each target as though a <u>touch</u> <u>target</u> had been executed. Targets
                 that have prerequisites but no commands (see <u>Target</u> <u>Rules</u>), or  that  are  already  up-to-date,
                 shall  not  be  touched in this manner.  Write messages to standard output for each target file
                 indicating the name of the file and that it was touched. Normally, the <u>makefile</u>  command  lines
                 associated  with each target are not executed. However, a command line with a &lt;plus-sign&gt; (<b>'+'</b>)
                 prefix shall be executed.

       Any options specified in the <u>MAKEFLAGS</u>  environment  variable  shall  be  evaluated  before  any  options
       specified  on  the  <u>make</u>  utility  command  line. If the <b>-k</b> and <b>-S</b> options are both specified on the <u>make</u>
       utility command line or by the <u>MAKEFLAGS</u> environment variable,  the  last  option  specified  shall  take
       precedence.   If  the  <b>-f</b>  or  <b>-p</b>  options  appear  in  the <u>MAKEFLAGS</u> environment variable, the result is
       undefined.

</pre><h4><b>OPERANDS</b></h4><pre>
       The following operands shall be supported:

       <u>target_name</u>
                 Target names, as defined in the EXTENDED DESCRIPTION section. If no target is specified,  while
                 <u>make</u>  is  processing the makefiles, the first target that <u>make</u> encounters that is not a special
                 target or an inference rule shall be used.

       <u>macro</u>=<u>value</u>
                 Macro definitions, as defined in <u>Macros</u>.

       If the <u>target_name</u> and <u>macro</u>=<u>value</u> operands are intermixed on the <u>make</u> utility command line, the  results
       are unspecified.

</pre><h4><b>STDIN</b></h4><pre>
       The  standard  input  shall  be  used  only  if the <u>makefile</u> option-argument is <b>'-'</b>.  See the INPUT FILES
       section.

</pre><h4><b>INPUT</b> <b>FILES</b></h4><pre>
       The input file, otherwise known as the makefile, is a text  file  containing  rules,  macro  definitions,
       include lines, and comments.  See the EXTENDED DESCRIPTION section.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       The following environment variables shall affect the execution of <u>make</u>:

       <u>LANG</u>      Provide a default value for the internationalization variables that are unset or null. (See the
                 Base  Definitions  volume  of POSIX.1‐2017, <u>Section</u> <u>8.2</u>, <u>Internationalization</u> <u>Variables</u> for the
                 precedence  of  internationalization  variables  used  to  determine  the  values   of   locale
                 categories.)

       <u>LC_ALL</u>    If  set  to a non-empty string value, override the values of all the other internationalization
                 variables.

       <u>LC_CTYPE</u>  Determine the locale for the interpretation of sequences of bytes of text  data  as  characters
                 (for example, single-byte as opposed to multi-byte characters in arguments and input files).

       <u>LC_MESSAGES</u>
                 Determine  the  locale  that  should  be  used  to affect the format and contents of diagnostic
                 messages written to standard error.

       <u>MAKEFLAGS</u>
                 This variable shall be interpreted as a  character  string  representing  a  series  of  option
                 characters  to  be  used  as  the  default options. The implementation shall accept both of the
                 following formats (but need not accept them when intermixed):

                  *  The characters are option letters without the leading &lt;hyphen-minus&gt; characters or  &lt;blank&gt;
                     separation used on a <u>make</u> utility command line.

                  *  The  characters  are formatted in a manner similar to a portion of the <u>make</u> utility command
                     line: options are preceded by &lt;hyphen-minus&gt; characters and &lt;blank&gt;-separated as  described
                     in  the  Base  Definitions volume of POSIX.1‐2017, <u>Section</u> <u>12.2</u>, <u>Utility</u> <u>Syntax</u> <u>Guidelines</u>.
                     The <u>macro</u>=<u>value</u> macro definition operands can also be included. The difference between  the
                     contents  of  <u>MAKEFLAGS</u>  and  the  <u>make</u>  utility  command  line is that the contents of the
                     variable shall not be subjected to the word expansions (see <u>Section</u> <u>2.6</u>,  <u>Word</u>  <u>Expansions</u>)
                     associated with parsing the command line values.

       <u>NLSPATH</u>   Determine the location of message catalogs for the processing of <u>LC_MESSAGES</u>.

       <u>PROJECTDIR</u>
                 Provide  a directory to be used to search for SCCS files not found in the current directory. In
                 all of the following cases, the search for SCCS files is made in  the  directory  <b>SCCS</b>  in  the
                 identified  directory. If the value of <u>PROJECTDIR</u> begins with a &lt;slash&gt;, it shall be considered
                 an absolute pathname; otherwise, the value of <u>PROJECTDIR</u> is treated as a  user  name  and  that
                 user's initial working directory shall be examined for a subdirectory <b>src</b> or <b>source</b>.  If such a
                 directory is found, it shall be used. Otherwise, the value is used as a relative pathname.

                 If  <u>PROJECTDIR</u>  is  not set or has a null value, the search for SCCS files shall be made in the
                 directory <b>SCCS</b> in the current directory.

                 The setting of <u>PROJECTDIR</u> affects all files listed in the remainder of this utility description
                 for files with a component named <b>SCCS</b>.

       The value of the <u>SHELL</u> environment variable shall not be used as a macro and shall  not  be  modified  by
       defining the <b>SHELL</b> macro in a makefile or on the command line. All other environment variables, including
       those with null values, shall be used as macros, as defined in <u>Macros</u>.

</pre><h4><b>ASYNCHRONOUS</b> <b>EVENTS</b></h4><pre>
       If  not  already  ignored,  <u>make</u>  shall  trap SIGHUP, SIGTERM, SIGINT, and SIGQUIT and remove the current
       target unless the target is a directory or the target is a prerequisite of the special  target  <b>.PRECIOUS</b>
       or  unless  one  of  the <b>-n</b>, <b>-p</b>, or <b>-q</b> options was specified. Any targets removed in this manner shall be
       reported in diagnostic messages of unspecified format, written to  standard  error.  After  this  cleanup
       process, if any, <u>make</u> shall take the standard action for all other signals.

</pre><h4><b>STDOUT</b></h4><pre>
       The  <u>make</u>  utility  shall  write  all commands to be executed to standard output unless the <b>-s</b> option was
       specified, the command is prefixed with an at-sign, or the special target <b>.SILENT</b> has either the  current
       target as a prerequisite or has no prerequisites. If <u>make</u> is invoked without any work needing to be done,
       it  shall  write  a  message  to standard output indicating that no action was taken. If the <b>-t</b> option is
       present and a file is touched, <u>make</u> shall write to  standard  output  a  message  of  unspecified  format
       indicating that the file was touched, including the filename of the file.

</pre><h4><b>STDERR</b></h4><pre>
       The standard error shall be used only for diagnostic messages.

</pre><h4><b>OUTPUT</b> <b>FILES</b></h4><pre>
       Files can be created when the <b>-t</b> option is present. Additional files can also be created by the utilities
       invoked by <u>make</u>.

</pre><h4><b>EXTENDED</b> <b>DESCRIPTION</b></h4><pre>
       The <u>make</u> utility attempts to perform the actions required to ensure that the specified targets are up-to-
       date.  A target shall be considered up-to-date if it exists and is newer than all of its dependencies, or
       if it has already been made up-to-date by the current invocation of  <u>make</u>  (regardless  of  the  target's
       existence  or  age).  A  target may also be considered up-to-date if it exists, is the same age as one or
       more of its prerequisites, and is newer than the remaining prerequisites  (if  any).   The  <u>make</u>  utility
       shall  treat  all  prerequisites  as  targets themselves and recursively ensure that they are up-to-date,
       processing them in the order in  which  they  appear  in  the  rule.  The  <u>make</u>  utility  shall  use  the
       modification times of files to determine whether the corresponding targets are out-of-date.

       To  ensure  that  a target is up-to-date, <u>make</u> shall ensure that all of the prerequisites of a target are
       up-to-date, then check to see if the target itself is up-to-date. If the target is  not  up-to-date,  the
       target  shall  be made up-to-date by executing the rule's commands (if any). If the target does not exist
       after the target has been successfully made up-to-date, the target shall be treated as being  newer  than
       any target for which it is a prerequisite.

       If  a  target  exists and there is neither a target rule nor an inference rule for the target, the target
       shall be considered up-to-date. It shall be an error if <u>make</u> attempts to ensure that a target  is  up-to-
       date  but  the  target  does  not  exist and there is neither a target rule nor an inference rule for the
       target.

   <b>Makefile</b> <b>Syntax</b>
       A makefile can contain rules, macro definitions (see <u>Macros</u>), include lines, and comments. There are  two
       kinds  of  rules:  <u>inference</u>  <u>rules</u>  and  <u>target</u> <u>rules</u>.  The <u>make</u> utility shall contain a set of built-in
       inference rules. If the <b>-r</b> option is present, the built-in rules shall not be used and  the  suffix  list
       shall  be  cleared.  Additional  rules of both types can be specified in a makefile. If a rule is defined
       more than once, the value of the rule shall be that of the last one specified. Macros can also be defined
       more than once, and the value of the macro is specified in <u>Macros</u>.  There are three  kinds  of  comments:
       blank  lines,  empty  lines,  and  a  &lt;number-sign&gt;  (<b>'#'</b>)  and  all following characters up to the first
       unescaped &lt;newline&gt; character. Blank lines, empty lines, and lines with &lt;number-sign&gt; (<b>'#'</b>) as the  first
       character on the line are also known as comment lines.

       By  default,  the  following  files  shall  be  tried in sequence: <b>./makefile</b> and <b>./Makefile</b>.  If neither
       <b>./makefile</b> or <b>./Makefile</b> are found, other implementation-defined  files  may  also  be  tried.   On  XSI-
       conformant systems, the additional files <b>./s.makefile</b>, <b>SCCS/s.makefile</b>, <b>./s.Makefile</b>, and <b>SCCS/s.Makefile</b>
       shall also be tried.

       The  <b>-f</b> option shall direct <u>make</u> to ignore any of these default files and use the specified argument as a
       makefile instead. If the <b>'-'</b> argument is specified, standard input shall be used.

       The term <u>makefile</u> is used to refer to any rules provided by  the  user,  whether  in  <b>./makefile</b>  or  its
       variants, or specified by the <b>-f</b> option.

       The  rules  in  makefiles  shall consist of the following types of lines: target rules, including special
       targets (see <u>Target</u> <u>Rules</u>), inference rules (see <u>Inference</u> <u>Rules</u>), macro definitions  (see  <u>Macros</u>),  and
       comments.

       Target  and  Inference  Rules  may  contain <u>command</u> <u>lines</u>.  Command lines can have a prefix that shall be
       removed before execution (see <u>Makefile</u> <u>Execution</u>).

       When an escaped &lt;newline&gt; (one preceded by a &lt;backslash&gt;) is found anywhere in the makefile except  in  a
       command  line,  an  include  line, or a line immediately preceding an include line, it shall be replaced,
       along with any leading white space on the following  line,  with  a  single  &lt;space&gt;.   When  an  escaped
       &lt;newline&gt;  is  found in a command line in a makefile, the command line shall contain the &lt;backslash&gt;, the
       &lt;newline&gt;, and the next line, except that the first character of the next line shall not be  included  if
       it  is a &lt;tab&gt;.  When an escaped &lt;newline&gt; is found in an include line or in a line immediately preceding
       an include line, the behavior is unspecified.

   <b>Include</b> <b>Lines</b>
       If the word <b>include</b> appears at the beginning of a line and is followed by one or more &lt;blank&gt; characters,
       the string formed by the remainder of the line shall be processed as follows to produce a pathname:

        *  The trailing &lt;newline&gt;, any &lt;blank&gt; characters immediately preceding a comment, and any comment shall
           be discarded. If the resulting string contains any double-quote  characters  (<b>'"'</b>)  the  behavior  is
           unspecified.

        *  The resulting string shall be processed for macro expansion (see <u>Macros</u>).

        *  Any  &lt;blank&gt; characters that appear after the first non-&lt;blank&gt; shall be used as separators to divide
           the macro-expanded string into fields. It is unspecified whether any other white-space characters are
           also used as separators. It is unspecified whether pathname  expansion  (see  <u>Section</u>  <u>2.13</u>,  <u>Pattern</u>
           <u>Matching</u> <u>Notation</u>) is also performed.

        *  If the processing of separators and optional pathname expansion results in either zero or two or more
           non-empty  fields,  the  behavior is unspecified. If it results in one non-empty field, that field is
           taken as the pathname.

       If the pathname does not begin with a <b>'/'</b> it  shall  be  treated  as  relative  to  the  current  working
       directory  of  the  process, not relative to the directory containing the makefile.  If the file does not
       exist in this location, it is unspecified whether additional directories are searched.

       The contents of the file specified by the pathname shall be read and processed as if they appeared in the
       makefile in place of the include line. If the file  ends  with  an  escaped  &lt;newline&gt;  the  behavior  is
       unspecified.

       The file may itself contain further include lines. Implementations shall support nesting of include files
       up to a depth of at least 16.

   <b>Makefile</b> <b>Execution</b>
       Makefile command lines shall be processed one at a time.

       Makefile command lines can have one or more of the following prefixes: a &lt;hyphen-minus&gt; (<b>'-'</b>), an at-sign
       (<b>'@'</b>), or a &lt;plus-sign&gt; (<b>'+'</b>).  These shall modify the way in which <u>make</u> processes the command.

       -     If the command prefix contains a &lt;hyphen-minus&gt;, or the <b>-i</b> option is present, or the special target
             <b>.IGNORE</b>  has  either  the current target as a prerequisite or has no prerequisites, any error found
             while executing the command shall be ignored.

       @     If the command prefix contains an at-sign and the <u>make</u>  utility  command  line  <b>-n</b>  option  is  not
             specified, or the <b>-s</b> option is present, or the special target <b>.SILENT</b> has either the current target
             as  a  prerequisite  or  has  no prerequisites, the command shall not be written to standard output
             before it is executed.

       +     If the command prefix contains a &lt;plus-sign&gt;, this indicates a makefile command line that shall  be
             executed even if <b>-n</b>, <b>-q</b>, or <b>-t</b> is specified.

       An  <u>execution</u>  <u>line</u> is built from the command line by removing any prefix characters. Except as described
       under the at-sign prefix, the execution line shall be written to the standard output, optionally preceded
       by a &lt;tab&gt;.  The execution line shall then be executed by a shell as if it were passed as the argument to
       the <u>system</u>() interface, except that if errors are not being ignored then the shell <b>-e</b> option  shall  also
       be  in  effect.  If errors are being ignored for the command (as a result of the <b>-i</b> option, a <b>'-'</b> command
       prefix, or a <b>.IGNORE</b> special target), the shell <b>-e</b> option shall not be in effect. The environment for the
       command being executed shall contain all of the variables in the environment of <u>make</u>.

       By default, when <u>make</u> receives a non-zero status from the execution of a command, it shall terminate with
       an error message to standard error.

   <b>Target</b> <b>Rules</b>
       Target rules are formatted as follows:

           <u>target</u> <b>[</b><u>target</u>...<b>]</b>: <b>[</b><u>prerequisite</u>...<b>][;</b><u>command</u><b>]</b>
           <b>[</b>&lt;tab&gt;<u>command</u>
           &lt;tab&gt;<u>command</u>
           ...<b>]</b>

           <u>line</u> <u>that</u> <u>does</u> <u>not</u> <u>begin</u> <u>with</u> &lt;tab&gt;

       Target entries are specified by a &lt;blank&gt;-separated, non-null list of targets, then  a  &lt;colon&gt;,  then  a
       &lt;blank&gt;-separated,  possibly  empty  list of prerequisites. Text following a &lt;semicolon&gt;, if any, and all
       following lines that begin with a &lt;tab&gt;, are makefile command lines to be executed to update the  target.
       The  first  non-empty  line  that does not begin with a &lt;tab&gt; or <b>'#'</b> shall begin a new entry. Any comment
       line may begin a new entry.

       Applications shall select target  names  from  the  set  of  characters  consisting  solely  of  periods,
       underscores,  digits, and alphabetics from the portable character set (see the Base Definitions volume of
       POSIX.1‐2017, <u>Section</u> <u>6.1</u>, <u>Portable</u> <u>Character</u> <u>Set</u>).  Implementations may allow other characters in target
       names  as  extensions.  The  interpretation  of  targets  containing  the  characters  <b>'%'</b>  and  <b>'"'</b>   is
       implementation-defined.

       A  target  that has prerequisites, but does not have any commands, can be used to add to the prerequisite
       list for that target. Only one target rule for any given target can contain commands.

       Lines that begin with one of the following are called <u>special</u> <u>targets</u> and control the operation of <u>make</u>:

       <b>.DEFAULT</b>  If the makefile uses this special target, the application shall ensure  that  it  is  specified
                 with  commands,  but  without prerequisites. The commands shall be used by <u>make</u> if there are no
                 other rules available to build a target.

       <b>.IGNORE</b>   Prerequisites of this special target are targets  themselves;  this  shall  cause  errors  from
                 commands  associated  with them to be ignored in the same manner as specified by the <b>-i</b> option.
                 Subsequent occurrences of <b>.IGNORE</b> shall add to the list of targets ignoring command errors.  If
                 no  prerequisites  are  specified, <u>make</u> shall behave as if the <b>-i</b> option had been specified and
                 errors from all commands associated with all targets shall be ignored.

       <b>.POSIX</b>    The application shall ensure that this special target is  specified  without  prerequisites  or
                 commands.  If  it appears as the first non-comment line in the makefile, <u>make</u> shall process the
                 makefile as specified by this section; otherwise, the behavior of <u>make</u> is unspecified.

       <b>.PRECIOUS</b> Prerequisites of this special target  shall  not  be  removed  if  <u>make</u>  receives  one  of  the
                 asynchronous  events  explicitly  described  in  the  ASYNCHRONOUS  EVENTS  section. Subsequent
                 occurrences of <b>.PRECIOUS</b> shall add to the list of  precious  files.  If  no  prerequisites  are
                 specified, all targets in the makefile shall be treated as if specified with <b>.PRECIOUS</b>.

       <b>.SCCS_GET</b> The  application  shall  ensure that this special target is specified without prerequisites. If
                 this special target is included in a makefile, the commands specified with  this  target  shall
                 replace  the  default  commands  associated  with this special target (see <u>Default</u> <u>Rules</u>).  The
                 commands specified with this target are used to get all SCCS files that are not  found  in  the
                 current directory.

                 When  source  files  are  named in a dependency list, <u>make</u> shall treat them just like any other
                 target. Because the source file is presumed to be present in the directory, there is no need to
                 add an entry for it to the makefile. When a target has no dependencies, but is present  in  the
                 directory,  <u>make</u>  shall  assume  that  that file is up-to-date. If, however, an SCCS file named
                 <b>SCCS/s.</b><u>source_file</u> is found for a target <u>source_file</u>, <u>make</u> compares the timestamp of the target
                 file with that of the <b>SCCS/s.source_file</b> to ensure the target is up-to-date. If the  target  is
                 missing,  or  if  the SCCS file is newer, <u>make</u> shall automatically issue the commands specified
                 for the <b>.SCCS_GET</b> special target to retrieve the most recent version. However, if the target is
                 writable by anyone, <u>make</u> shall not retrieve a new version.

       <b>.SILENT</b>   Prerequisites of this  special  target  are  targets  themselves;  this  shall  cause  commands
                 associated  with  them  not  to  be  written  to  the standard output before they are executed.
                 Subsequent occurrences of <b>.SILENT</b> shall add to the list of targets with silent commands. If  no
                 prerequisites  are  specified,  <u>make</u> shall behave as if the <b>-s</b> option had been specified and no
                 commands or touch messages associated with any target shall be written to standard output.

       <b>.SUFFIXES</b> Prerequisites of <b>.SUFFIXES</b> shall be appended to the list of known  suffixes  and  are  used  in
                 conjunction  with  the  inference  rules (see <u>Inference</u> <u>Rules</u>).  If <b>.SUFFIXES</b> does not have any
                 prerequisites, the list of known suffixes shall be cleared.

       The special targets <b>.IGNORE</b>, <b>.POSIX</b>,  <b>.PRECIOUS</b>,  <b>.SILENT</b>,  and  <b>.SUFFIXES</b>  shall  be  specified  without
       commands.

       Targets  with  names  consisting of a leading &lt;period&gt; followed by the uppercase letters <b>"POSIX"</b> and then
       any other characters are reserved for future standardization.  Targets with names consisting of a leading
       &lt;period&gt; followed by one or more uppercase letters are reserved for implementation extensions.

   <b>Macros</b>
       Macro definitions are in the form:

           <u>string1</u> = <b>[</b><u>string2</u><b>]</b>

       The macro named <u>string1</u> is defined as having the value of  <u>string2</u>,  where  <u>string2</u>  is  defined  as  all
       characters,  if  any, after the &lt;equals-sign&gt;, up to a comment character (<b>'#'</b>) or an unescaped &lt;newline&gt;.
       Any &lt;blank&gt; characters immediately before or after the &lt;equals-sign&gt; shall be ignored.

       Applications shall select  macro  names  from  the  set  of  characters  consisting  solely  of  periods,
       underscores,  digits, and alphabetics from the portable character set (see the Base Definitions volume of
       POSIX.1‐2017, <u>Section</u> <u>6.1</u>, <u>Portable</u> <u>Character</u> <u>Set</u>).  A macro name shall  not  contain  an  &lt;equals-sign&gt;.
       Implementations may allow other characters in macro names as extensions.

       Macros  can  appear  anywhere  in the makefile. Macro expansions using the forms $(<u>string1</u>) or ${<u>string1</u>}
       shall be replaced by <u>string2</u>, as follows:

        *  Macros in target lines shall be evaluated when the target line is read.

        *  Macros in makefile command lines shall be evaluated when the command is executed.

        *  Macros in the string before the &lt;equals-sign&gt; in a macro definition shall be evaluated when the macro
           assignment is made.

        *  Macros after the &lt;equals-sign&gt; in a macro definition shall not be evaluated until the  defined  macro
           is used in a rule or command, or before the &lt;equals-sign&gt; in a macro definition.

       The  parentheses  or braces are optional if <u>string1</u> is a single character. The macro $$ shall be replaced
       by the single character <b>'$'</b>.  If <u>string1</u> in a macro expansion contains a macro expansion, the results are
       unspecified.

       Macro expansions using the forms $(<u>string1</u><b>[:</b><u>subst1</u><b>=[</b><u>subst2</u><b>]]</b>) or ${<u>string1</u><b>[:</b><u>subst1</u><b>=[</b><u>subst2</u><b>]]</b>} can be used
       to replace all occurrences of <u>subst1</u> with <u>subst2</u> when the macro substitution is performed. The <u>subst1</u>  to
       be  replaced  shall  be  recognized when it is a suffix at the end of a word in <u>string1</u> (where a <u>word</u>, in
       this context, is defined to be a string delimited  by  the  beginning  of  the  line,  a  &lt;blank&gt;,  or  a
       &lt;newline&gt;).   If <u>string1</u> in a macro expansion contains a macro expansion, the results are unspecified. If
       a &lt;percent-sign&gt; character appears as part of <u>subst1</u> or <u>subst2</u> after any  macros  have  been  recursively
       expanded, the results are unspecified.

       Macro  expansions  in <u>string1</u> of macro definition lines shall be evaluated when read. Macro expansions in
       <u>string2</u> of macro definition lines shall be performed when the macro identified by <u>string1</u> is expanded  in
       a rule or command.

       Macro  definitions  shall be taken from the following sources, in the following logical order, before the
       makefile(s) are read.

        1. Macros specified on the <u>make</u> utility command line, in the order specified on the command line. It  is
           unspecified whether the internal macros defined in <u>Internal</u> <u>Macros</u> are accepted from this source.

        2. Macros  defined  by  the  <u>MAKEFLAGS</u>  environment  variable, in the order specified in the environment
           variable. It is unspecified whether the internal macros defined in <u>Internal</u> <u>Macros</u> are accepted  from
           this source.

        3. The  contents  of  the  environment,  excluding  the  <u>MAKEFLAGS</u> and <u>SHELL</u> variables and including the
           variables with null values.

        4. Macros defined in the inference rules built into <u>make</u>.

       Macro definitions from these sources shall not override macro definitions from a  lower-numbered  source.
       Macro  definitions  from  a  single  source  (for  example,  the <u>make</u> utility command line, the <u>MAKEFLAGS</u>
       environment variable, or the other environment variables) shall override previous macro definitions  from
       the same source.

       Macros  defined  in  the  makefile(s)  shall  override  macro  definitions  that occur before them in the
       makefile(s) and macro definitions from source 4. If the <b>-e</b> option is not specified, macros defined in the
       makefile(s) shall override macro definitions from source 3. Macros defined in the makefile(s)  shall  not
       override macro definitions from source 1 or source 2.

       Before the makefile(s) are read, all of the <u>make</u> utility command line options (except <b>-f</b> and <b>-p</b>) and <u>make</u>
       utility  command line macro definitions (except any for the <u>MAKEFLAGS</u> macro), not already included in the
       <u>MAKEFLAGS</u> macro, shall be added to the <u>MAKEFLAGS</u> macro, quoted in an implementation-defined  manner  such
       that  when  <u>MAKEFLAGS</u>  is  read  by  another  instance of the <u>make</u> command, the original macro's value is
       recovered. Other implementation-defined options and macros may also be added to the <u>MAKEFLAGS</u>  macro.  If
       this  modifies the value of the <u>MAKEFLAGS</u> macro, or, if the <u>MAKEFLAGS</u> macro is modified at any subsequent
       time, the <u>MAKEFLAGS</u> environment variable shall be modified to match the new value of the <u>MAKEFLAGS</u> macro.
       The result of setting <u>MAKEFLAGS</u> in the Makefile is unspecified.

       Before the makefile(s) are read, all of the <u>make</u> utility  command  line  macro  definitions  (except  the
       <u>MAKEFLAGS</u>  macro  or  the  <u>SHELL</u> macro) shall be added to the environment of <u>make</u>.  Other implementation-
       defined variables may also be added to  the  environment  of  <u>make</u>.   Macros  defined  by  the  <u>MAKEFLAGS</u>
       environment  variable and macros defined in the makefile(s) shall not be added to the environment of <u>make</u>
       if they are not already in its environment. With the exception of <u>SHELL</u> (see below),  it  is  unspecified
       whether  macros  defined in these ways update the value of an environment variable that already exists in
       the environment of <u>make</u>.

       The <b>SHELL</b> macro shall be treated specially. It shall be provided by <u>make</u> and set to the pathname  of  the
       shell  command  language interpreter (see <u>sh</u>).  The <u>SHELL</u> environment variable shall not affect the value
       of the <b>SHELL</b> macro. If <b>SHELL</b> is defined in the makefile or is specified on the  command  line,  it  shall
       replace the original value of the <b>SHELL</b> macro, but shall not affect the <u>SHELL</u> environment variable. Other
       effects of defining <b>SHELL</b> in the makefile or on the command line are implementation-defined.

   <b>Inference</b> <b>Rules</b>
       Inference rules are formatted as follows:

           <u>target</u>:
           &lt;tab&gt;<u>command</u>
           <b>[</b>&lt;tab&gt;<u>command</u><b>]</b>
           ...

           <u>line</u> <u>that</u> <u>does</u> <u>not</u> <u>begin</u> <u>with</u> &lt;tab&gt; <u>or</u> #

       The  application  shall  ensure  that the <u>target</u> portion is a valid target name (see <u>Target</u> <u>Rules</u>) of the
       form <b>.s2</b> or <b>.s1.s2</b> (where <b>.s1</b> and <b>.s2</b> are suffixes that have been given as prerequisites of the <b>.SUFFIXES</b>
       special target and <u>s1</u> and <u>s2</u> do not contain any &lt;slash&gt; or &lt;period&gt; characters.) If  there  is  only  one
       &lt;period&gt;  in the target, it is a single-suffix inference rule. Targets with two periods are double-suffix
       inference rules. Inference rules can have only one target before the &lt;colon&gt;.

       The application shall ensure that the makefile does not specify prerequisites  for  inference  rules;  no
       characters  other  than  white space shall follow the &lt;colon&gt; in the first line, except when creating the
       <u>empty</u> <u>rule,</u> described below. Prerequisites are inferred, as described below.

       Inference rules can be redefined. A target that matches an existing inference rule  shall  overwrite  the
       old  inference rule. An empty rule can be created with a command consisting of simply a &lt;semicolon&gt; (that
       is, the rule still exists and is found during inference rule search, but since it is empty, execution has
       no effect). The empty rule can also be formatted as follows:

           <u>rule</u>: ;

       where zero or more &lt;blank&gt; characters separate the &lt;colon&gt; and &lt;semicolon&gt;.

       The <u>make</u> utility uses the suffixes of targets and their prerequisites to infer how a target can  be  made
       up-to-date.  A  list  of inference rules defines the commands to be executed. By default, <u>make</u> contains a
       built-in set of inference rules. Additional rules can be specified in the makefile.

       The special target <b>.SUFFIXES</b> contains as its prerequisites a list of suffixes that shall be used  by  the
       inference  rules.  The order in which the suffixes are specified defines the order in which the inference
       rules for the suffixes are used. New suffixes shall be appended to  the  current  list  by  specifying  a
       <b>.SUFFIXES</b>  special  target in the makefile. A <b>.SUFFIXES</b> target with no prerequisites shall clear the list
       of suffixes. An empty <b>.SUFFIXES</b> target followed by a new <b>.SUFFIXES</b> list is required to change  the  order
       of the suffixes.

       Normally,  the  user  would  provide  an  inference rule for each suffix.  The inference rule to update a
       target with a suffix <b>.s1</b> from a prerequisite with a suffix <b>.s2</b> is specified  as  a  target  <b>.s2.s1</b>.   The
       internal macros provide the means to specify general inference rules (see <u>Internal</u> <u>Macros</u>).

       When  no target rule is found to update a target, the inference rules shall be checked. The suffix of the
       target (<b>.s1</b>) to be built is compared to the list of suffixes specified by the <b>.SUFFIXES</b> special  targets.
       If  the  <b>.s1</b> suffix is found in <b>.SUFFIXES</b>, the inference rules shall be searched in the order defined for
       the first <b>.s2.s1</b> rule whose prerequisite file (<b>$*.s2</b>) exists. If the target is out-of-date  with  respect
       to this prerequisite, the commands for that inference rule shall be executed.

       If  the  target  to  be  built  does not contain a suffix and there is no rule for the target, the single
       suffix inference rules shall be checked. The single-suffix inference rules define how to build  a  target
       if  a  file is found with a name that matches the target name with one of the single suffixes appended. A
       rule with one suffix <b>.s2</b> is the definition of how to build <u>target</u> from <b>target.s2</b>.  The other suffix (<b>.s1</b>)
       is treated as null.

       A &lt;tilde&gt; (<b>'~'</b>) in the above rules refers to an SCCS file in the current directory.  Thus, the rule <b>.c~.o</b>
       would transform an SCCS C-language source file into an object file (<b>.o</b>).  Because the  <b>s.</b>   of  the  SCCS
       files  is  a  prefix,  it  is  incompatible  with <u>make</u>'s suffix point of view. Hence, the <b>'~'</b> is a way of
       changing any file reference into an SCCS file reference.

   <b>Libraries</b>
       If a target or prerequisite contains parentheses, it shall be treated as a member of an archive  library.
       For the <u>lib</u>(<u>member</u><b>.o</b>) expression <u>lib</u> refers to the name of the archive library and <u>member</u><b>.o</b> to the member
       name. The application shall ensure that the member is an object file with the <b>.o</b> suffix. The modification
       time  of  the  expression is the modification time for the member as kept in the archive library; see <u>ar</u>.
       The <b>.a</b> suffix shall refer to an archive library. The <b>.s2.a</b> rule shall be used to update a member  in  the
       library from a file with a suffix <b>.s2</b>.

   <b>Internal</b> <b>Macros</b>
       The  <u>make</u>  utility shall maintain five internal macros that can be used in target and inference rules. In
       order to clearly define the meaning of these  macros,  some  clarification  of  the  terms  <u>target</u>  <u>rule</u>,
       <u>inference</u> <u>rule</u>, <u>target</u>, and <u>prerequisite</u> is necessary.

       Target  rules  are specified by the user in a makefile for a particular target. Inference rules are user-
       specified or <u>make</u>-specified rules for a particular class of target name. Explicit prerequisites are those
       prerequisites specified in a makefile on target lines.  Implicit prerequisites  are  those  prerequisites
       that  are  generated when inference rules are used. Inference rules are applied to implicit prerequisites
       or to explicit prerequisites that do not have target rules defined for them in the makefile. Target rules
       are applied to targets specified in the makefile.

       Before any target in the makefile is updated, each of its  prerequisites  (both  explicit  and  implicit)
       shall be updated. This shall be accomplished by recursively processing each prerequisite. Upon recursion,
       each  prerequisite shall become a target itself. Its prerequisites in turn shall be processed recursively
       until a target is found that has no prerequisites,  or  further  recursion  would  require  applying  two
       inference  rules  one  immediately  after  the  other,  at  which  point  the recursion shall stop. As an
       extension, implementations may continue recursion when two or more successive inference rules need to  be
       applied;  however,  if there are multiple different chains of such rules that could be used to create the
       target, it is unspecified which chain is used. The recursion shall then back up, updating each target  as
       it goes.

       In the definitions that follow, the word <u>target</u> refers to one of:

        *  A target specified in the makefile

        *  An  explicit  prerequisite  specified  in the makefile that becomes the target when <u>make</u> processes it
           during recursion

        *  An implicit prerequisite that becomes a target when <u>make</u> processes it during recursion

       In the definitions that follow, the word <u>prerequisite</u> refers to one of the following:

        *  An explicit prerequisite specified in the makefile for a particular target

        *  An implicit prerequisite generated as  a  result  of  locating  an  appropriate  inference  rule  and
           corresponding file that matches the suffix of the target

       The five internal macros are:

       $@      The $@ shall evaluate to the full target name of the current target, or the archive filename part
               of a library archive target. It shall be evaluated for both target and inference rules.

               For  example,  in  the  <b>.c.a</b>  inference  rule, $@ represents the out-of-date <b>.a</b> file to be built.
               Similarly, in a makefile target rule to build <b>lib.a</b> from <b>file.c</b>, $@  represents  the  out-of-date
               <b>lib.a</b>.

       $%      The  $% macro shall be evaluated only when the current target is an archive library member of the
               form <u>libname</u>(<u>member</u><b>.o</b>).  In these cases, $@ shall evaluate to <u>libname</u> and $%  shall  evaluate  to
               <u>member</u><b>.o</b>.  The $% macro shall be evaluated for both target and inference rules.

               For  example,  in a makefile target rule to build <b>lib.a</b>(<b>file.o</b>), $% represents <b>file.o</b>, as opposed
               to $@, which represents <b>lib.a</b>.

       $?      The $? macro shall evaluate to the list of prerequisites that are newer than the current  target.
               It shall be evaluated for both target and inference rules.

               For  example,  in  a  makefile  target rule to build <u>prog</u> from <b>file1.o</b>, <b>file2.o</b>, and <b>file3.o</b>, and
               where <u>prog</u> is not out-of-date with respect to <b>file1.o</b>, but is out-of-date with respect to <b>file2.o</b>
               and <b>file3.o</b>, $? represents <b>file2.o</b> and <b>file3.o</b>.

       $&lt;      In an inference rule, the $&lt; macro shall evaluate to the filename  whose  existence  allowed  the
               inference rule to be chosen for the target.  In the <b>.DEFAULT</b> rule, the $&lt; macro shall evaluate to
               the current target name. The meaning of the $&lt; macro shall be otherwise unspecified.

               For example, in the <b>.c.a</b> inference rule, $&lt; represents the prerequisite <b>.c</b> file.

       $*      The  $*  macro  shall  evaluate  to  the current target name with its suffix deleted. It shall be
               evaluated at least for inference rules.

               For example, in the <b>.c.a</b> inference rule, $*.o represents the out-of-date <b>.o</b> file that corresponds
               to the prerequisite <b>.c</b> file.

       Each of the internal macros has an alternative form. When an uppercase <b>'D'</b> or <b>'F'</b> is appended to  any  of
       the  macros,  the  meaning shall be changed to the <u>directory</u> <u>part</u> for <b>'D'</b> and <u>filename</u> <u>part</u> for <b>'F'</b>.  The
       directory part is the path prefix of the file without a trailing &lt;slash&gt;; for the current directory,  the
       directory  part  is  <b>'.'</b>.   When the $? macro contains more than one prerequisite filename, the $(?D) and
       $(?F) (or ${?D} and ${?F})  macros  expand  to  a  list  of  directory  name  parts  and  filename  parts
       respectively.

       For the target <u>lib</u>(<u>member</u><b>.o</b>) and the <b>s2.a</b> rule, the internal macros shall be defined as:

       $&lt;      <u>member</u><b>.s2</b>

       $*      <u>member</u>

       $@      <u>lib</u>

       $?      <u>member</u><b>.s2</b>

       $%      <u>member</u><b>.o</b>

   <b>Default</b> <b>Rules</b>
       The  default  rules  for  <u>make</u>  shall  achieve  results  that are the same as if the following were used.
       Implementations that do not support the C-Language Development Utilities  option  may  omit  <b>CC</b>,  <b>CFLAGS</b>,
       <b>YACC</b>,  <b>YFLAGS</b>,  <b>LEX</b>, <b>LFLAGS</b>, <b>LDFLAGS</b>, and the <b>.c</b>, <b>.y</b>, and <b>.l</b> inference rules. Implementations that do not
       support FORTRAN may omit <b>FC</b>, <b>FFLAGS</b>, and the <b>.f</b> inference rules. Implementations may  provide  additional
       macros and rules.

           <u>SPECIAL</u> <u>TARGETS</u>

           .SCCS_GET: sccs $(SCCSFLAGS) get $(SCCSGETFLAGS) $@

           .SUFFIXES: .o .c .y .l .a .sh .f .c~ .y~ .l~ .sh~ .f~

           <u>MACROS</u>

           MAKE=make
           AR=ar
           ARFLAGS=-rv
           YACC=yacc
           YFLAGS=
           LEX=lex
           LFLAGS=
           LDFLAGS=
           CC=c99
           CFLAGS=-O 1
           FC=fort77
           FFLAGS=-O 1
           GET=get
           GFLAGS=
           SCCSFLAGS=
           SCCSGETFLAGS=-s

           <u>SINGLE</u> <u>SUFFIX</u> <u>RULES</u>

           .c:
               $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $&lt;

           .f:
               $(FC) $(FFLAGS) $(LDFLAGS) -o $@ $&lt;

           .sh:
               cp $&lt; $@
               chmod a+x $@

           .c~:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.c
               $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $*.c

           .f~:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.f
               $(FC) $(FFLAGS) $(LDFLAGS) -o $@ $*.f

           .sh~:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.sh
               cp $*.sh $@
               chmod a+x $@

           <u>DOUBLE</u> <u>SUFFIX</u> <u>RULES</u>

           .c.o:
               $(CC) $(CFLAGS) -c $&lt;

           .f.o:
               $(FC) $(FFLAGS) -c $&lt;

           .y.o:
               $(YACC) $(YFLAGS) $&lt;
               $(CC) $(CFLAGS) -c y.tab.c
               rm -f y.tab.c
               mv y.tab.o $@

           .l.o:
               $(LEX) $(LFLAGS) $&lt;
               $(CC) $(CFLAGS) -c lex.yy.c
               rm -f lex.yy.c
               mv lex.yy.o $@

           .y.c:
               $(YACC) $(YFLAGS) $&lt;
               mv y.tab.c $@

           .l.c:
               $(LEX) $(LFLAGS) $&lt;
               mv lex.yy.c $@

           .c~.o:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.c
               $(CC) $(CFLAGS) -c $*.c

           .f~.o:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.f
               $(FC) $(FFLAGS) -c $*.f

           .y~.o:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.y
               $(YACC) $(YFLAGS) $*.y
               $(CC) $(CFLAGS) -c y.tab.c
               rm -f y.tab.c
               mv y.tab.o $@

           .l~.o:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.l
               $(LEX) $(LFLAGS) $*.l
               $(CC) $(CFLAGS) -c lex.yy.c
               rm -f lex.yy.c
               mv lex.yy.o $@

           .y~.c:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.y
               $(YACC) $(YFLAGS) $*.y
               mv y.tab.c $@

           .l~.c:
               $(GET) $(GFLAGS) -p $&lt; &gt; $*.l
               $(LEX) $(LFLAGS) $*.l
               mv lex.yy.c $@

           .c.a:
               $(CC) -c $(CFLAGS) $&lt;
               $(AR) $(ARFLAGS) $@ $*.o
               rm -f $*.o

           .f.a:
               $(FC) -c $(FFLAGS) $&lt;
               $(AR) $(ARFLAGS) $@ $*.o
               rm -f $*.o

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       When the <b>-q</b> option is specified, the <u>make</u> utility shall exit with one of the following values:

        0    Successful completion.

        1    The target was not up-to-date.

       &gt;1    An error occurred.

       When the <b>-q</b> option is not specified, the <u>make</u> utility shall exit with one of the following values:

        0    Successful completion.

       &gt;0    An error occurred.

</pre><h4><b>CONSEQUENCES</b> <b>OF</b> <b>ERRORS</b></h4><pre>
       Default.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       If  there  is  a  source  file  (such  as  <b>./source.c</b>)  and  there are two SCCS files corresponding to it
       (<b>./s.source.c</b> and <b>./SCCS/s.source.c</b>), on XSI-conformant systems <u>make</u> uses the SCCS file  in  the  current
       directory. However, users are advised to use the underlying SCCS utilities (<u>admin</u>, <u>delta</u>, <u>get</u>, and so on)
       or  the <u>sccs</u> utility for all source files in a given directory. If both forms are used for a given source
       file, future developers are very likely to be confused.

       It is incumbent upon portable makefiles to specify the <b>.POSIX</b> special target in order to  guarantee  that
       they are not affected by local extensions.

       The  <b>-k</b>  and <b>-S</b> options are both present so that the relationship between the command line, the <u>MAKEFLAGS</u>
       variable, and the makefile can be controlled precisely. If the <b>k</b>  flag  is  passed  in  <u>MAKEFLAGS</u>  and  a
       command is of the form:

           $(MAKE) -S foo

       then the default behavior is restored for the child <u>make</u>.

       When the <b>-n</b> option is specified, it is always added to <u>MAKEFLAGS</u>.  This allows a recursive <u>make</u> <b>-n</b> <u>target</u>
       to be used to see all of the action that would be taken to update <u>target</u>.

       Because  of  widespread  historical practice, interpreting a &lt;number-sign&gt; (<b>'#'</b>) inside a variable as the
       start of a comment has the unfortunate side-effect of making it impossible to place a &lt;number-sign&gt; in  a
       variable, thus forbidding something like:

           CFLAGS = "-D COMMENT_CHAR='#'"

       Many  historical  <u>make</u>  utilities  stop  chaining together inference rules when an intermediate target is
       nonexistent. For example, it might be possible for a <u>make</u> to determine that both <b>.y.c</b> and <b>.c.o</b>  could  be
       used to convert a <b>.y</b> to a <b>.o</b>.  Instead, in this case, <u>make</u> requires the use of a <b>.y.o</b> rule.

       The  best way to provide portable makefiles is to include all of the rules needed in the makefile itself.
       The rules provided use only features provided by other parts of this volume of POSIX.1‐2017. The  default
       rules  include  rules  for  optional  commands  in  this volume of POSIX.1‐2017. Only rules pertaining to
       commands that are provided are needed in an implementation's default set.

       Macros used within other macros are evaluated when the new macro is used rather than when the  new  macro
       is defined. Therefore:

           MACRO = <u>value1</u>
           NEW   = $(MACRO)
           MACRO = <u>value2</u>

           target:
               echo $(NEW)

       would  produce  <u>value2</u>  and not <u>value1</u> since <b>NEW</b> was not expanded until it was needed in the <u>echo</u> command
       line.

       Some historical applications have been known to intermix  <u>target_name</u>  and  <u>macro=name</u>  operands  on  the
       command  line,  expecting  that all of the macros are processed before any of the targets are dealt with.
       Conforming applications do not do this, although some backwards-compatibility support may be included  in
       some implementations.

       The following characters in filenames may give trouble: <b>'='</b>, <b>':'</b>, <b>'`'</b>, single-quote, and <b>'@'</b>.  In include
       filenames,  pattern matching characters and <b>'"'</b> should also be avoided, as they may be treated as special
       by some implementations.

       For inference rules, the description of $&lt; and $? seem similar.  However,  an  example  shows  the  minor
       difference. In a makefile containing:

           foo.o: foo.h

       if  <b>foo.h</b>  is newer than <b>foo.o</b>, yet <b>foo.c</b> is older than <b>foo.o</b>, the built-in rule to make <b>foo.o</b> from <b>foo.c</b>
       is used, with $&lt; equal to <b>foo.c</b> and $? equal to <b>foo.h</b>.  If <b>foo.c</b> is also newer than <b>foo.o</b>, $&lt; is equal to
       <b>foo.c</b> and $? is equal to <b>foo.h</b> <b>foo.c</b>.

       As a consequence of the general rules for target updating, a useful special case is that if a target  has
       no  prerequisites and no commands, and the target of the rule is a nonexistent file, then <u>make</u> acts as if
       this target has been updated whenever its rule is run.

       <b>Note:</b>     This implies that all targets depending on this one will always have their commands run.

       Shell command sequences like <u>make;</u> <u>cp</u> <u>original</u> <u>copy;</u> <u>make</u> may have  problems  on  filesystems  where  the
       timestamp  resolution  is  the  minimum  (1  second)  required  by  the standard and where <u>make</u> considers
       identical timestamps to be up-to-date. Conversely, rules  like  <u>copy:</u> <u>original;</u> <u>cp</u> <u>-p</u> <u>original</u> <u>copy</u>  will
       result in redundant work on <u>make</u> implementations that consider identical timestamps to be out-of-date.

       This  standard  does  not  specify  precedence between macro definition and include directives. Thus, the
       behavior of:

           include =foo.mk

       is unspecified. To define a variable named include, either the white space before the &lt;equal-sign&gt; should
       be removed, or another macro should be used, as in:

           INCLUDE_NAME = include
           $(INCLUDE_NAME) =foo.mk

       On the other hand, if the intent is to include a file which  starts  with  an  &lt;equal-sign&gt;,  either  the
       filename should be changed to <u>./=foo.mk</u>, or the makefile should be written as:

           INCLUDE_FILE = =foo.mk
           include $(INCLUDE_FILE)

</pre><h4><b>EXAMPLES</b></h4><pre>
        1. The following command:

               make

           makes the first target found in the makefile.

        2. The following command:

               make junk

           makes the target <b>junk</b>.

        3. The  following makefile says that <b>pgm</b> depends on two files, <b>a.o</b> and <b>b.o</b>, and that they in turn depend
           on their corresponding source files (<b>a.c</b> and <b>b.c</b>), and a common file <b>incl.h</b>:

               .POSIX:
               pgm: a.o b.o
                   c99 a.o b.o -o pgm
               a.o: incl.h a.c
                   c99 -c a.c
               b.o: incl.h b.c
                   c99 -c b.c

        4. An example for making optimized <b>.o</b> files from <b>.c</b> files is:

               .c.o:
                   c99 -c -O 1 $*.c

           or:

               .c.o:
                   c99 -c -O 1 $&lt;

        5. The most common use of the archive interface follows. Here, it is assumed that the source  files  are
           all C-language source:

               lib: lib(file1.o) lib(file2.o) lib(file3.o)
                   @echo lib is now up-to-date

           The <b>.c.a</b> rule is used to make <b>file1.o</b>, <b>file2.o</b>, and <b>file3.o</b> and insert them into <b>lib</b>.

           The  treatment  of  escaped  &lt;newline&gt; characters throughout the makefile is historical practice. For
           example, the inference rule:

               .c.o\
               :

           works, and the macro:

               f=  bar baz\
                   biz
               a:
                   echo ==$f==

           echoes <b>"==bar</b> <b>baz</b> <b>biz=="</b>.

           If $? were:

               <a href="file:/usr/include/stdio.h">/usr/include/stdio.h</a> <a href="file:/usr/include/unistd.h">/usr/include/unistd.h</a> foo.h

           then $(?D) would be:

               <a href="file:/usr/include">/usr/include</a> <a href="file:/usr/include">/usr/include</a> .

           and $(?F) would be:

               stdio.h unistd.h foo.h

        6. The contents of the built-in rules can be viewed by running:

               make -p -f /dev/null 2&gt;/dev/null

</pre><h4><b>RATIONALE</b></h4><pre>
       The <u>make</u> utility described in this volume of POSIX.1‐2017 is intended to provide the means  for  changing
       portable  source  code into executables that can be run on an POSIX.1‐2008-conforming system. It reflects
       the most common features present in System V and BSD <u>make</u>s.

       Historically,  the  <u>make</u>  utility  has  been  an  especially  fertile  ground  for  vendor  and  research
       organization-specific syntax modifications and extensions. Examples include:

        *  Syntax supporting parallel execution (such as from various multi-processor vendors, GNU, and others)

        *  Additional ``operators'' separating targets and their prerequisites (System V, BSD, and others)

        *  Specifying that command lines containing the strings <b>"${MAKE}"</b> and <b>"$(MAKE)"</b> are executed when the <b>-n</b>
           option is specified (GNU and System V)

        *  Modifications of the meaning of internal macros when referencing libraries (BSD and others)

        *  Using a single instance of the shell for all of the command lines of the target (BSD and others)

        *  Allowing &lt;space&gt; characters as well as &lt;tab&gt; characters to delimit command lines (BSD)

        *  Adding C preprocessor-style ``include'' and ``ifdef'' constructs (System V, GNU, BSD, and others)

        *  Remote execution of command lines (Sprite and others)

        *  Specifying additional special targets (BSD, System V, and most others)

        *  Specifying an alternate shell to use to process commands.

       Additionally, many vendors and research organizations have rethought the basic concepts of <u>make</u>, creating
       vastly  extended,  as well as completely new, syntaxes. Each of these versions of <u>make</u> fulfills the needs
       of a different community of users; it is unreasonable for this volume of POSIX.1‐2017 to require behavior
       that would be incompatible (and probably inferior) to historical practice for such a community.

       In similar circumstances, when the industry has enough sufficiently incompatible formats as to make  them
       irreconcilable,  this  volume of POSIX.1‐2017 has followed one or both of two courses of action. Commands
       have been renamed (<u>cksum</u>, <u>echo</u>, and <u>pax</u>) and/or command line options have been  provided  to  select  the
       desired behavior (<u>grep</u>, <u>od</u>, and <u>pax</u>).

       Because  the syntax specified for the <u>make</u> utility is, by and large, a subset of the syntaxes accepted by
       almost all versions of <u>make</u>, it was decided that it would be counter-productive to change the name.   And
       since the makefile itself is a basic unit of portability, it would not be completely effective to reserve
       a  new  option  letter,  such as <u>make</u> <b>-P</b>, to achieve the portable behavior. Therefore, the special target
       <b>.POSIX</b> was added to the makefile, allowing users to specify ``standard'' behavior.  This  special  target
       does  not preclude extensions in the <u>make</u> utility, nor does it preclude such extensions being used by the
       makefile specifying the target; it does, however, preclude any extensions from being applied  that  could
       alter  the  behavior  of  previously  valid  syntax;  such extensions must be controlled via command line
       options or new special targets. It is incumbent upon portable makefiles to  specify  the  <b>.POSIX</b>  special
       target in order to guarantee that they are not affected by local extensions.

       The  portable version of <u>make</u> described in this reference page is not intended to be the state-of-the-art
       software generation tool and, as such, some newer and more leading-edge features have not been  included.
       An  attempt  has  been  made  to  describe  the portable makefile in a manner that does not preclude such
       extensions as long as they do not disturb the portable behavior described here.

       When the <b>-n</b> option is specified, it is always added to <u>MAKEFLAGS</u>.  This allows a recursive <u>make</u> <b>-n</b> <u>target</u>
       to be used to see all of the action that would be taken to update <u>target</u>.

       The definition of <u>MAKEFLAGS</u> allows both the System V letter string and the BSD command line formats.  The
       two formats are sufficiently different to allow implementations to support both without ambiguity.

       Early proposals stated that an ``unquoted'' &lt;number-sign&gt; was treated as the start of a comment. The <u>make</u>
       utility  does  not  pay  any  attention  to  quotes.  A  &lt;number-sign&gt; starts a comment regardless of its
       surroundings.

       The text about ``other implementation-defined pathnames may also be tried'' in addition to <b>./makefile</b> and
       <b>./Makefile</b> is to allow  such  extensions  as  <b>SCCS/s.Makefile</b>  and  other  variations.  It  was  made  an
       implementation-defined   requirement  (as  opposed  to  unspecified  behavior)  to  highlight  surprising
       implementations that might select something unexpected like <b>/etc/Makefile</b>.  XSI-conformant  systems  also
       try <b>./s.makefile</b>, <b>SCCS/s.makefile</b>, <b>./s.Makefile</b>, and <b>SCCS/s.Makefile</b>.

       Early proposals contained the macro <b>NPROC</b> as a means of specifying that <u>make</u> should use <u>n</u> processes to do
       the  work  required.  While this feature is a valuable extension for many systems, it is not common usage
       and could require other non-trivial extensions to makefile syntax. This extension is not required by this
       volume of POSIX.1‐2017, but could be provided as a compatible extension. The macro <b>PARALLEL</b>  is  used  by
       some  historical  systems  with  essentially  the same meaning (but without using a name that is a common
       system limit value). It is suggested that  implementors  recognize  the  existing  use  of  <b>NPROC</b>  and/or
       <b>PARALLEL</b> as extensions to <u>make</u>.

       The  default  rules are based on System V. The default <b>CC=</b> value is <u>c99</u> instead of <u>cc</u> because this volume
       of POSIX.1‐2017 does not standardize the utility named <u>cc</u>.  Thus, every conforming application  would  be
       required to define <b>CC=</b><u>c99</u> to expect to run. There is no advantage conferred by the hope that the makefile
       might  hit the ``preferred'' compiler because this cannot be guaranteed to work. Also, since the portable
       makescript can only use the <u>c99</u> options, no advantage is conferred in terms of what the  script  can  do.
       It is a quality-of-implementation issue as to whether <u>c99</u> is as valuable as <u>cc</u>.

       The  <b>-d</b>  option  to  <u>make</u> is frequently used to produce debugging information, but is too implementation-
       defined to add to this volume of POSIX.1‐2017.

       The <b>-p</b> option is not passed in <u>MAKEFLAGS</u> on most historical implementations  and  to  change  this  would
       cause many implementations to break without sufficiently increased portability.

       Commands  that begin with a &lt;plus-sign&gt; (<b>'+'</b>) are executed even if the <b>-n</b> option is present. Based on the
       GNU version of <u>make</u>, the behavior of <b>-n</b> when the &lt;plus-sign&gt; prefix is encountered has been  extended  to
       apply  to  <b>-q</b>  and <b>-t</b> as well. However, the System V convention of forcing command execution with <b>-n</b> when
       the command line of a target contains either of the strings <b>"$(MAKE)"</b> or <b>"${MAKE}"</b> has not been  adopted.
       This  functionality appeared in early proposals, but the danger of this approach was pointed out with the
       following example of a portion of a makefile:

           subdir:
               cd subdir; rm all_the_files; $(MAKE)

       The loss of the System V behavior in this case is well-balanced by the safety afforded to other makefiles
       that were not aware of this situation. In any event, the command line &lt;plus-sign&gt; prefix can provide  the
       desired functionality.

       The  double  &lt;colon&gt;  in the target rule format is supported in BSD systems to allow more than one target
       line containing the same target name to have commands associated with it. Since this is not functionality
       described in the SVID or XPG3 it has been allowed as an extension, but not mandated.

       The default rules are provided with text specifying that the built-in rules shall be the same as  if  the
       listed  set were used. The intent is that implementations should be able to use the rules without change,
       but will be allowed to alter them in ways that do not affect the primary behavior.

       One point of discussion was whether to drop the default rules list from this volume of POSIX.1‐2017. They
       provide convenience, but do not enhance portability of applications. The prime benefit is in  portability
       of users who wish to type <u>make</u> <u>command</u> and have the command build from a <b>command.c</b> file.

       The  historical  <u>MAKESHELL</u>  feature,  and  related  features provided by other <u>make</u> implementations, were
       omitted. In some implementations it is used to let a user override the shell  to  be  used  to  run  <u>make</u>
       commands.  This  was  confusing;  for a portable <u>make</u>, the shell should be chosen by the makefile writer.
       Further, a makefile writer cannot require an alternate shell to be used and still consider  the  makefile
       portable.  While  it  would  be  possible  to  standardize a mechanism for specifying an alternate shell,
       existing implementations do not agree on such a mechanism, and makefile writers  can  already  invoke  an
       alternate shell by specifying the shell name in the rule for a target; for example:

           python -c "foo"

       The  <u>make</u>  utilities in most historical implementations process the prerequisites of a target in left-to-
       right order, and the makefile format requires this. It supports the standard idiom used in many makefiles
       that produce <u>yacc</u> programs; for example:

           foo: y.tab.o lex.o main.o
               $(CC) $(CFLAGS) -o $@ t.tab.o lex.o main.o

       In this example, if <u>make</u> chose any arbitrary order, the <b>lex.o</b> might not be made with the correct <b>y.tab.h</b>.
       Although there may be better  ways  to  express  this  relationship,  it  is  widely  used  historically.
       Implementations  that  desire to update prerequisites in parallel should require an explicit extension to
       <u>make</u> or the makefile format to accomplish it, as described previously.

       The algorithm for determining a new entry for target rules  is  partially  unspecified.  Some  historical
       <u>make</u>s  allow  comment lines (including blank and empty lines) within the collection of commands marked by
       leading &lt;tab&gt; characters. A conforming makefile must ensure that each command starts with  a  &lt;tab&gt;,  but
       implementations are free to ignore comments without triggering the start of a new entry.

       The  ASYNCHRONOUS  EVENTS  section  includes  having  SIGTERM and SIGHUP, along with the more traditional
       SIGINT and SIGQUIT, remove the current target unless directed not to do so. SIGTERM and SIGHUP were added
       to parallel other utilities that have historically cleaned up their work as a result  of  these  signals.
       When  <u>make</u> receives any signal other than SIGQUIT, it is required to resend itself the signal it received
       so that it exits with a status  that  reflects  the  signal.  The  results  from  SIGQUIT  are  partially
       unspecified  because, on systems that create <b>core</b> files upon receipt of SIGQUIT, the <b>core</b> from <u>make</u> would
       conflict with a <b>core</b> file from the command that was running when the SIGQUIT arrived.  The  main  concern
       was to prevent damaged files from appearing up-to-date when <u>make</u> is rerun.

       The   <b>.PRECIOUS</b>   special  target  was  extended  to  affect  all  targets  globally  (by  specifying  no
       prerequisites). The <b>.IGNORE</b> and <b>.SILENT</b> special targets were extended  to  allow  prerequisites;  it  was
       judged  to  be  more  useful in some cases to be able to turn off errors or echoing for a list of targets
       than for the entire makefile. These extensions to <u>make</u> in System V were made to match historical practice
       from the BSD <u>make</u>.

       Macros are not exported to the environment of commands to  be  run.  This  was  never  the  case  in  any
       historical  <u>make</u>  and  would have serious consequences. The environment is the same as the environment to
       <u>make</u> except that <u>MAKEFLAGS</u> and macros defined on the <u>make</u> command line are added, and except that  macros
       defined  by the <u>MAKEFLAGS</u> environment variable and macros defined in the makefile(s) may update the value
       of an existing environment variable (other than <u>SHELL</u>).

       Some implementations do not use <u>system</u>() for all command lines, as  required  by  the  portable  makefile
       format; as a performance enhancement, they select lines without shell metacharacters for direct execution
       by  <u>execve</u>().   There  is  no  requirement  that  <u>system</u>() be used specifically, but merely that the same
       results be achieved.  The metacharacters typically used to bypass the direct <u>execve</u>() execution have been
       any of:

           =  |  ^  (  )  ;  &amp;  &lt;  &gt;  *  ?  [  ]  :  $  `  '  "  \  \n

       The default in some advanced versions of <u>make</u> is to group all the command lines for a target and  execute
       them using a single shell invocation; the System V method is to pass each line individually to a separate
       shell.  The  single-shell method has the advantages in performance and the lack of a requirement for many
       continued lines. However, converting to this newer method  has  caused  portability  problems  with  many
       historical  makefiles,  so  the  behavior  with the POSIX makefile is specified to be the same as that of
       System V. It is suggested that the special target <b>.ONESHELL</b> be used as  an  implementation  extension  to
       achieve the single-shell grouping for a target or group of targets.

       Novice  users of <u>make</u> have had difficulty with the historical need to start commands with a &lt;tab&gt;.  Since
       it is often difficult to discern differences between &lt;tab&gt; and &lt;space&gt; characters on terminals or printed
       listings, confusing bugs can arise. In early proposals, an attempt was made to correct  this  problem  by
       allowing  leading  &lt;blank&gt;  characters  instead  of &lt;tab&gt; characters. However, implementors reported many
       makefiles that failed in subtle ways following this change, and it is difficult to implement a <u>make</u>  that
       unambiguously  can differentiate between macro and command lines.  There is extensive historical practice
       of allowing leading &lt;space&gt; characters before macro definitions. Forcing macro lines into column 1  would
       be  a significant backwards-compatibility problem for some makefiles.  Therefore, historical practice was
       restored.

       There is substantial variation in the handling of include lines by  different  implementations.  However,
       there  is  enough  commonality  for the standard to be able to specify a minimum set of requirements that
       allow the feature to be used portably. Known variations have been explicitly called  out  as  unspecified
       behavior in the description.

       The System V dynamic dependency feature was not included. It would support:

           cat: $$@.c

       that would expand to;

           cat: cat.c

       This  feature  exists  only  in the new version of System V <u>make</u> and, while useful, is not in wide usage.
       This means that macros are expanded twice for prerequisites: once at makefile  parse  time  and  once  at
       target update time.

       Consideration  was  given  to  adding  metarules to the POSIX <u>make</u>.  This would make <b>%.o:</b> <b>%.c</b> the same as
       <b>.c.o:</b>.  This is quite useful and available from some vendors, but it would cause too many changes to this
       <u>make</u> to support. It would have introduced rule chaining and new substitution rules.  However,  the  rules
       for  target  names  have  been set to reserve the <b>'%'</b> and <b>'"'</b> characters. These are traditionally used to
       implement metarules and quoting of target names, respectively. Implementors are  strongly  encouraged  to
       use these characters only for these purposes.

       A  request  was  made  to  extend  the  suffix  delimiter character from a &lt;period&gt; to any character. The
       metarules feature in newer <u>make</u>s solves this problem in a more general way. This volume  of  POSIX.1‐2017
       is staying with the more conservative historical definition.

       The  standard output format for the <b>-p</b> option is not described because it is primarily a debugging option
       and because the format is not generally useful to programs. In historical implementations the  output  is
       not  suitable  for  use  in  generating  makefiles.  The  <b>-p</b>  format  has been variable across historical
       implementations. Therefore, the definition of <b>-p</b> was only to provide  a  consistently  named  option  for
       obtaining <u>make</u> script debugging information.

       Some historical implementations have not cleared the suffix list with <b>-r</b>.

       Implementations  should  be  aware  that  some  historical  applications  have intermixed <u>target_name</u> and
       <u>macro</u>=<u>value</u> operands on the command line, expecting that all of the macros are processed  before  any  of
       the  targets  are  dealt  with.  Conforming applications do not do this, but some backwards-compatibility
       support may be warranted.

       Empty inference rules are specified with a &lt;semicolon&gt; command rather  than  omitting  all  commands,  as
       described  in  an  early  proposal.  The  latter  case  has  no  traditional  meaning and is reserved for
       implementation extensions, such as in GNU <u>make</u>.

       Earlier versions of this standard defined comment lines only as lines with <b>'#'</b> as  the  first  character.
       Many  places then talked about comments, blank lines, and empty lines; but some places inadvertently only
       mentioned comments when blank lines and empty lines had also been accepted in all known  implementations.
       The  standard  now  defines  comment  lines to be blank lines, empty lines, and lines starting with a <b>'#'</b>
       character and explictily lists cases where blank lines and empty lines are not acceptable.

       On most historic systems, the <u>make</u> utility considered a target with a prerequisite that had an  identical
       timestamp  as  up-to-date.  The  HP-UX implementation of <u>make</u> treated it as out-of-date. The standard now
       allows either behavior, but implementations are encouraged to follow the example set by HP-UX.   This  is
       especially important on file systems where the timestamp resolution is the minimum (1 second) required by
       the  standard.  All  implementations  of  <u>make</u>  should  make  full use of the finest timestamp resolution
       available on the file systems holding targets and prerequisites to ensure  that  targets  are  up-to-date
       even  for  prerequisite  files  with timestamps that were updated within the same second. However, if the
       timestamp resolutions of the file systems containing a target  and  a  prerequisite  are  different,  the
       timestamp  with  the more precise resolution should be rounded down to the resolution of the less precise
       timestamp for the comparison.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       Some implementations of <u>make</u> include  an  <u>export</u>  directive  to  add  specified  <u>make</u>  variables  to  the
       environment. This may be considered for standardization in a future version.

       A   future   version   of   this   standard   may   require   that   macro  expansions  using  the  forms
       $(<u>string1</u><b>:[</b><u>op</u><b>]%[</b><u>os</u><b>]=[</b><u>np</u><b>][%][</b><u>ns</u><b>]</b>)  or  ${<u>string1</u><b>:[</b><u>op</u><b>]%[</b><u>os</u><b>]=[</b><u>np</u><b>][%][</b><u>ns</u><b>]</b>}  are  treated  as  pattern   macro
       expansions.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Chapter</u> <u>2</u>, <u>Shell</u> <u>Command</u> <u>Language</u>, <u>ar</u>, <u>c99</u>, <u>get</u>, <u>lex</u>, <u>sccs</u>, <u>sh</u>, <u>yacc</u>

       The  Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>6.1</u>, <u>Portable</u> <u>Character</u> <u>Set</u>, <u>Chapter</u> <u>8</u>, <u>Environment</u>
       <u>Variables</u>, <u>Section</u> <u>12.2</u>, <u>Utility</u> <u>Syntax</u> <u>Guidelines</u>

       The System Interfaces volume of POSIX.1‐2017, <u>exec</u>, <u>system</u>()

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                          <u><a href="../man1POSIX/MAKE.1POSIX.html">MAKE</a></u>(1POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>