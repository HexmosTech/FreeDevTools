<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix">manpages-posix_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       lex — generate programs for lexical tasks (<b>DEVELOPMENT</b>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       lex <b>[</b>-t<b>]</b> <b>[</b>-n|-v<b>]</b> <b>[</b><u>file</u>...<b>]</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>lex</u>  utility shall generate C programs to be used in lexical processing of character input, and that
       can be used as an interface to <u>yacc</u>.  The C programs shall be generated from <u>lex</u> source code and  conform
       to  the  ISO C  standard,  without  depending  on  any  undefined, unspecified, or implementation-defined
       behavior, except in cases where the code is copied directly from the supplied source, or  in  cases  that
       are  documented  by  the implementation. Usually, the <u>lex</u> utility shall write the program it generates to
       the file <b>lex.yy.c</b>; the state of this file is unspecified if <u>lex</u> exits with a non-zero  exit  status.  See
       the EXTENDED DESCRIPTION section for a complete description of the <u>lex</u> input language.

</pre><h4><b>OPTIONS</b></h4><pre>
       The  <u>lex</u>  utility  shall  conform  to  the Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>12.2</u>, <u>Utility</u>
       <u>Syntax</u> <u>Guidelines</u>, except for Guideline 9.

       The following options shall be supported:

       <b>-n</b>        Suppress the summary of statistics usually written with the <b>-v</b> option. If no  table  sizes  are
                 specified in the <u>lex</u> source code and the <b>-v</b> option is not specified, then <b>-n</b> is implied.

       <b>-t</b>        Write the resulting program to standard output instead of <b>lex.yy.c</b>.

       <b>-v</b>        Write  a  summary  of  <u>lex</u>  statistics to the standard output. (See the discussion of <u>lex</u> table
                 sizes in <u>Definitions</u> <u>in</u> <u>lex</u>.)  If the <b>-t</b> option is specified and  <b>-n</b>  is  not  specified,  this
                 report shall be written to standard error. If table sizes are specified in the <u>lex</u> source code,
                 and if the <b>-n</b> option is not specified, the <b>-v</b> option may be enabled.

</pre><h4><b>OPERANDS</b></h4><pre>
       The following operand shall be supported:

       <u>file</u>      A  pathname  of  an  input  file.  If  more than one such <u>file</u> is specified, all files shall be
                 concatenated to produce a single <u>lex</u> program. If no <u>file</u> operands are specified, or if  a  <u>file</u>
                 operand is <b>'-'</b>, the standard input shall be used.

</pre><h4><b>STDIN</b></h4><pre>
       The  standard  input  shall  be used if no <u>file</u> operands are specified, or if a <u>file</u> operand is <b>'-'</b>.  See
       INPUT FILES.

</pre><h4><b>INPUT</b> <b>FILES</b></h4><pre>
       The input files shall be text files containing <u>lex</u> source code, as described in the EXTENDED  DESCRIPTION
       section.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       The following environment variables shall affect the execution of <u>lex</u>:

       <u>LANG</u>      Provide a default value for the internationalization variables that are unset or null. (See the
                 Base  Definitions  volume  of POSIX.1‐2017, <u>Section</u> <u>8.2</u>, <u>Internationalization</u> <u>Variables</u> for the
                 precedence  of  internationalization  variables  used  to  determine  the  values   of   locale
                 categories.)

       <u>LC_ALL</u>    If  set  to a non-empty string value, override the values of all the other internationalization
                 variables.

       <u>LC_COLLATE</u>
                 Determine the locale for the behavior  of  ranges,  equivalence  classes,  and  multi-character
                 collating elements within regular expressions. If this variable is not set to the POSIX locale,
                 the results are unspecified.

       <u>LC_CTYPE</u>  Determine  the  locale  for the interpretation of sequences of bytes of text data as characters
                 (for example, single-byte as opposed to multi-byte characters in arguments  and  input  files),
                 and  the  behavior of character classes within regular expressions. If this variable is not set
                 to the POSIX locale, the results are unspecified.

       <u>LC_MESSAGES</u>
                 Determine the locale that should be used to  affect  the  format  and  contents  of  diagnostic
                 messages written to standard error.

       <u>NLSPATH</u>   Determine the location of message catalogs for the processing of <u>LC_MESSAGES</u>.

</pre><h4><b>ASYNCHRONOUS</b> <b>EVENTS</b></h4><pre>
       Default.

</pre><h4><b>STDOUT</b></h4><pre>
       If  the <b>-t</b> option is specified, the text file of C source code output of <u>lex</u> shall be written to standard
       output.

       If the <b>-t</b> option is not specified:

        *  Implementation-defined informational, error, and warning messages  concerning  the  contents  of  <u>lex</u>
           source code input shall be written to either the standard output or standard error.

        *  If  the  <b>-v</b>  option  is  specified  and  the <b>-n</b> option is not specified, <u>lex</u> statistics shall also be
           written to either the standard output or standard error, in an implementation-defined  format.  These
           statistics  may also be generated if table sizes are specified with a <b>'%'</b> operator in the <u>Definitions</u>
           section, as long as the <b>-n</b> option is not specified.

</pre><h4><b>STDERR</b></h4><pre>
       If the <b>-t</b>  option  is  specified,  implementation-defined  informational,  error,  and  warning  messages
       concerning the contents of <u>lex</u> source code input shall be written to the standard error.

       If the <b>-t</b> option is not specified:

        1. Implementation-defined  informational,  error,  and  warning  messages concerning the contents of <u>lex</u>
           source code input shall be written to either the standard output or standard error.

        2. If the <b>-v</b> option is specified and the <b>-n</b> option is  not  specified,  <u>lex</u>  statistics  shall  also  be
           written  to  either the standard output or standard error, in an implementation-defined format. These
           statistics may also be generated if table sizes are specified with a <b>'%'</b> operator in the  <u>Definitions</u>
           section, as long as the <b>-n</b> option is not specified.

</pre><h4><b>OUTPUT</b> <b>FILES</b></h4><pre>
       A  text  file  containing C source code shall be written to <b>lex.yy.c</b>, or to the standard output if the <b>-t</b>
       option is present.

</pre><h4><b>EXTENDED</b> <b>DESCRIPTION</b></h4><pre>
       Each input file shall contain <u>lex</u> source code, which is a table of regular expressions with corresponding
       actions in the form of C program fragments.

       When <b>lex.yy.c</b> is compiled and linked with the  <u>lex</u>  library  (using  the  <b>-l</b> <b>l</b>  operand  with  <u>c99</u>),  the
       resulting  program shall read character input from the standard input and shall partition it into strings
       that match the given expressions.

       When an expression is matched, these actions shall occur:

        *  The input string that was matched shall be left in <u>yytext</u> as a null-terminated string;  <u>yytext</u>  shall
           either be an external character array or a pointer to a character string. As explained in <u>Definitions</u>
           <u>in</u>  <u>lex</u>,  the  type  can  be  explicitly  selected using the <b>%array</b> or <b>%pointer</b> declarations, but the
           default is implementation-defined.

        *  The external <b>int</b> <u>yyleng</u> shall be set to the length of the matching string.

        *  The expression's corresponding program fragment, or action, shall be executed.

       During pattern matching, <u>lex</u> shall search the set of patterns for  the  single  longest  possible  match.
       Among rules that match the same number of characters, the rule given first shall be chosen.

       The general format of <u>lex</u> source shall be:

              <u>Definitions</u> <b>%%</b> <u>Rules</u> <b>%%</b> <u>User</u>Subroutines

       The  first  <b>"%%"</b>  is  required  to mark the beginning of the rules (regular expressions and actions); the
       second <b>"%%"</b> is required only if user subroutines follow.

       Any line in the <u>Definitions</u> section beginning with a &lt;blank&gt; shall be assumed to be a C program  fragment
       and  shall  be  copied  to  the external definition area of the <b>lex.yy.c</b> file. Similarly, anything in the
       <u>Definitions</u> section included between delimiter lines containing only <b>"%{"</b> and <b>"%}"</b> shall also  be  copied
       unchanged to the external definition area of the <b>lex.yy.c</b> file.

       Any  such  input  (beginning  with  a  &lt;blank&gt;  or within <b>"%{"</b> and <b>"%}"</b> delimiter lines) appearing at the
       beginning of the <u>Rules</u> section before any rules are specified shall be  written  to  <b>lex.yy.c</b>  after  the
       declarations  of  variables for the <u>yylex</u>() function and before the first line of code in <u>yylex</u>().  Thus,
       user variables local to <u>yylex</u>() can be declared here, as well as application code to execute  upon  entry
       to <u>yylex</u>().

       The  action  taken  by  <u>lex</u>  when encountering any input beginning with a &lt;blank&gt; or within <b>"%{"</b> and <b>"%}"</b>
       delimiter lines appearing in the <u>Rules</u> section but coming after one  or  more  rules  is  undefined.  The
       presence of such input may result in an erroneous definition of the <u>yylex</u>() function.

       C-language code in the input shall not contain C-language trigraphs.  The C-language code within <b>"%{"</b> and
       <b>"%}"</b> delimiter lines shall not contain any lines consisting only of <b>"%}"</b>, or only of <b>"%%"</b>.

   <b>Definitions</b> <b>in</b> <b>lex</b>
       <u>Definitions</u>  appear  before the first <b>"%%"</b> delimiter. Any line in this section not contained between <b>"%{"</b>
       and <b>"%}"</b> lines and not beginning with a &lt;blank&gt; shall be assumed to define a <u>lex</u> substitution string. The
       format of these lines shall be:

           <u>name</u> <u>substitute</u>

       If a <u>name</u> does not meet the requirements for identifiers in the ISO C standard, the result is  undefined.
       The string <u>substitute</u> shall replace the string {<u>name</u>} when it is used in a rule. The <u>name</u> string shall be
       recognized in this context only when the braces are provided and when it does not appear within a bracket
       expression or within double-quotes.

       In  the  <u>Definitions</u> section, any line beginning with a &lt;percent-sign&gt; (<b>'%'</b>) character and followed by an
       alphanumeric word beginning with either <b>'s'</b> or <b>'S'</b> shall define a  set  of  start  conditions.  Any  line
       beginning  with a <b>'%'</b> followed by a word beginning with either <b>'x'</b> or <b>'X'</b> shall define a set of exclusive
       start conditions. When the generated scanner is in a <b>%s</b> state, patterns with no state specified shall  be
       also  active;  in  a  <b>%x</b>  state, such patterns shall not be active. The rest of the line, after the first
       word, shall be considered to be one or more &lt;blank&gt;-separated names of start conditions. Start  condition
       names  shall be constructed in the same way as definition names. Start conditions can be used to restrict
       the matching of regular expressions to one or more states as described in <u>Regular</u> <u>Expressions</u> <u>in</u> <u>lex</u>.

       Implementations shall  accept  either  of  the  following  two  mutually-exclusive  declarations  in  the
       <u>Definitions</u> section:

       <b>%array</b>    Declare the type of <u>yytext</u> to be a null-terminated character array.

       <b>%pointer</b>  Declare the type of <u>yytext</u> to be a pointer to a null-terminated character string.

       The  default  type of <u>yytext</u> is implementation-defined. If an application refers to <u>yytext</u> outside of the
       scanner source file (that is, via an <b>extern</b>), the application shall include  the  appropriate  <b>%array</b>  or
       <b>%pointer</b> declaration in the scanner source file.

       Implementations  shall  accept declarations in the <u>Definitions</u> section for setting certain internal table
       sizes. The declarations are shown in the following table.

                                         <b>Table:</b> <b>Table</b> <b>Size</b> <b>Declarations</b> <b>in</b> <u>lex</u>
                         ┌─────────────┬────────────────────────────────────┬───────────────┐
                         │ <b>Declaration</b> │            <b>Description</b>             │ <b>Minimum</b> <b>Value</b> │
                         ├─────────────┼────────────────────────────────────┼───────────────┤
                         │ %<b>p</b> <u>n</u>        │ Number of positions                │     2500      │
                         │ %<b>n</b> <u>n</u>        │ Number of states                   │      500      │
                         │ %<b>a</b> <u>n</u>        │ Number of transitions              │     2000      │
                         │ %<b>e</b> <u>n</u>        │ Number of parse tree nodes         │     1000      │
                         │ %<b>k</b> <u>n</u>        │ Number of packed character classes │     1000      │
                         │ %<b>o</b> <u>n</u>        │ Size of the output array           │     3000      │
                         └─────────────┴────────────────────────────────────┴───────────────┘

       In the table, <u>n</u> represents a positive decimal integer, preceded by one or more  &lt;blank&gt;  characters.  The
       exact  meaning  of  these table size numbers is implementation-defined. The implementation shall document
       how these numbers affect the <u>lex</u> utility and how they are related to any output that may be generated  by
       the  implementation  should limitations be encountered during the execution of <u>lex</u>.  It shall be possible
       to determine from this output which of the table size values needs  to  be  modified  to  permit  <u>lex</u>  to
       successfully generate tables for the input language. The values in the column Minimum Value represent the
       lowest values conforming implementations shall provide.

   <b>Rules</b> <b>in</b> <b>lex</b>
       The  rules  in <u>lex</u> source files are a table in which the left column contains regular expressions and the
       right column contains actions (C program fragments) to be executed when the expressions are recognized.

           <u>ERE</u> <u>action</u>
           <u>ERE</u> <u>action</u>
           ...

       The extended regular expression (ERE) portion of a row shall be separated from  <u>action</u>  by  one  or  more
       &lt;blank&gt;  characters.  A regular expression containing &lt;blank&gt; characters shall be recognized under one of
       the following conditions:

        *  The entire expression appears within double-quotes.

        *  The &lt;blank&gt; characters appear within double-quotes or square brackets.

        *  Each &lt;blank&gt; is preceded by a &lt;backslash&gt; character.

   <b>User</b> <b>Subroutines</b> <b>in</b> <b>lex</b>
       Anything in the user subroutines section shall be copied to <b>lex.yy.c</b> following <u>yylex</u>().

   <b>Regular</b> <b>Expressions</b> <b>in</b> <b>lex</b>
       The <u>lex</u> utility shall support the set of extended regular expressions (see the Base Definitions volume of
       POSIX.1‐2017, <u>Section</u> <u>9.4</u>, <u>Extended</u> <u>Regular</u> <u>Expressions</u>), with the following additions and exceptions  to
       the syntax:

       "..."     Any string enclosed in double-quotes shall represent the characters within the double-quotes as
                 themselves,  except  that  &lt;backslash&gt;-escapes  (which  appear in the following table) shall be
                 recognized. Any &lt;backslash&gt;-escape sequence shall be  terminated  by  the  closing  quote.  For
                 example, <b>"\01""1"</b> represents a single string: the octal value 1 followed by the character <b>'1'</b>.

       &lt;<u>state</u>&gt;<u>r</u>, &lt;<u>state1,state2,</u>...&gt;<u>r</u>
                 The  regular  expression  <u>r</u>  shall  be  matched  only  when  the program is in one of the start
                 conditions indicated by <u>state</u>, <u>state1</u>, and so on; see <u>Actions</u> <u>in</u> <u>lex</u>.  (As an exception to  the
                 typographical conventions of the rest of this volume of POSIX.1‐2017, in this case &lt;<u>state</u>&gt; does
                 not  represent  a metavariable, but the literal angle-bracket characters surrounding a symbol.)
                 The start condition shall be recognized as such only at the beginning of a regular expression.

       <u>r</u>/<u>x</u>       The regular expression <u>r</u> shall be matched only if it is followed by an  occurrence  of  regular
                 expression <u>x</u> (<u>x</u> is the instance of trailing context, further defined below). The token returned
                 in  <u>yytext</u>  shall  only  match <u>r</u>.  If the trailing portion of <u>r</u> matches the beginning of <u>x</u>, the
                 result is unspecified. The <u>r</u> expression cannot include further  trailing  context  or  the  <b>'$'</b>
                 (match-end-of-line)  operator; <u>x</u> cannot include the <b>'^'</b> (match-beginning-of-line) operator, nor
                 trailing context, nor the <b>'$'</b> operator. That is, only one occurrence  of  trailing  context  is
                 allowed  in a <u>lex</u> regular expression, and the <b>'^'</b> operator only can be used at the beginning of
                 such an expression.

       {<u>name</u>}    When <u>name</u> is one of  the  substitution  symbols  from  the  <u>Definitions</u>  section,  the  string,
                 including the enclosing braces, shall be replaced by the <u>substitute</u> value. The <u>substitute</u> value
                 shall  be  treated in the extended regular expression as if it were enclosed in parentheses. No
                 substitution shall occur if {<u>name</u>} occurs within a bracket expression or within double-quotes.

       Within an ERE, a &lt;backslash&gt; character shall be considered to begin an escape sequence  as  specified  in
       the  table  in  the Base Definitions volume of POSIX.1‐2017, <u>Chapter</u> <u>5</u>, <u>File</u> <u>Format</u> <u>Notation</u> (<b>'\\'</b>, <b>'\a'</b>,
       <b>'\b'</b>, <b>'\f'</b>, <b>'\n'</b>, <b>'\r'</b>, <b>'\t'</b>, <b>'\v'</b>).  In addition, the escape sequences in the following table  shall  be
       recognized.

       A  literal  &lt;newline&gt;  cannot  occur  within  an ERE; the escape sequence <b>'\n'</b> can be used to represent a
       &lt;newline&gt;.  A &lt;newline&gt; shall not be matched by a period operator.

                                            <b>Table:</b> <b>Escape</b> <b>Sequences</b> <b>in</b> <u>lex</u>
                          ┌──────────┬──────────────────────────┬──────────────────────────┐
                          │  <b>Escape</b>  │                          │                          │
                          │ <b>Sequence</b> │       <b>Description</b>        │         <b>Meaning</b>          │
                          ├──────────┼──────────────────────────┼──────────────────────────┤
                          │ \<u>digits</u>  │ A &lt;backslash&gt; character  │ The character whose      │
                          │          │ followed by the longest  │ encoding is represented  │
                          │          │ sequence of one, two, or │ by the one, two, or      │
                          │          │ three octal-digit        │ three-digit octal        │
                          │          │ characters (01234567).   │ integer. Multi-byte      │
                          │          │ If all of the digits are │ characters require       │
                          │          │ 0 (that is,              │ multiple, concatenated   │
                          │          │ representation of the    │ escape sequences of this │
                          │          │ NUL character), the      │ type, including the      │
                          │          │ behavior is undefined.   │ leading &lt;backslash&gt; for  │
                          │          │                          │ each byte.               │
                          ├──────────┼──────────────────────────┼──────────────────────────┤
                          │ \x<u>digits</u> │ A &lt;backslash&gt; character  │ The character whose      │
                          │          │ followed by the longest  │ encoding is represented  │
                          │          │ sequence of hexadecimal- │ by the hexadecimal       │
                          │          │ digit characters         │ integer.                 │
                          │          │ (01234567abcdefABCDEF).  │                          │
                          │          │ If all of the digits are │                          │
                          │          │ 0 (that is,              │                          │
                          │          │ representation of the    │                          │
                          │          │ NUL character), the      │                          │
                          │          │ behavior is undefined.   │                          │
                          ├──────────┼──────────────────────────┼──────────────────────────┤
                          │ \c       │ A &lt;backslash&gt; character  │ The character <b>'c'</b>,       │
                          │          │ followed by any          │ unchanged.               │
                          │          │ character not described  │                          │
                          │          │ in this table or in the  │                          │
                          │          │ table in the Base        │                          │
                          │          │ Definitions volume of    │                          │
                          │          │ POSIX.1‐2017, <u>Chapter</u> <u>5</u>, │                          │
                          │          │ <u>File</u> <u>Format</u> <u>Notation</u>     │                          │
                          │          │ (<b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, <b>'\f'</b>, │                          │
                          │          │ <b>'\n'</b>, <b>'\r'</b>, <b>'\t'</b>, <b>'\v'</b>). │                          │
                          └──────────┴──────────────────────────┴──────────────────────────┘

       <b>Note:</b>     If a <b>'\x'</b> sequence needs to be  immediately  followed  by  a  hexadecimal  digit  character,  a
                 sequence  such  as  <b>"\x1""1"</b>  can be used, which represents a character containing the value 1,
                 followed by the character <b>'1'</b>.

       The order of precedence given to extended regular expressions for <u>lex</u> differs from that specified in  the
       Base  Definitions  volume  of  POSIX.1‐2017,  <u>Section</u>  <u>9.4</u>,  <u>Extended</u>  <u>Regular</u> <u>Expressions</u>.  The order of
       precedence for <u>lex</u> shall be as shown in the following table, from high to low.

       <b>Note:</b>     The escaped characters entry is not meant to imply that  these  are  operators,  but  they  are
                 included  in  the table to show their relationships to the true operators. The start condition,
                 trailing context, and anchoring notations have been omitted  from  the  table  because  of  the
                 placement  restrictions  described  in  this  section; they can only appear at the beginning or
                 ending of an ERE.

                                             <b>Table:</b> <b>ERE</b> <b>Precedence</b> <b>in</b> <u>lex</u>
                             ┌───────────────────────────────────┬──────────────────────┐
                             │    <b>Extended</b> <b>Regular</b> <b>Expression</b>    │      <b>Precedence</b>      │
                             ├───────────────────────────────────┼──────────────────────┤
                             │ <u>collation-related</u> <u>bracket</u> <u>symbols</u> │ [= =]  [: :]  [. .]  │
                             │ <u>escaped</u> <u>characters</u>                │ \&lt;<u>special</u> <u>character</u>&gt; │
                             │ <u>bracket</u> <u>expression</u>                │ [ ]                  │
                             │ <u>quoting</u>                           │ "..."                │
                             │ <u>grouping</u>                          │ ( )                  │
                             │ <u>definition</u>                        │ {<u>name</u>}               │
                             │ <u>single-character</u> <u>RE</u> <u>duplication</u>   │ * + ?                │
                             │ <u>concatenation</u>                     │                      │
                             │ <u>interval</u> <u>expression</u>               │ {m,n}                │
                             │ <u>alternation</u>                       │ |                    │
                             └───────────────────────────────────┴──────────────────────┘

       The ERE anchoring operators <b>'^'</b> and <b>'$'</b> do not appear in the table. With <u>lex</u> regular  expressions,  these
       operators  are  restricted  in their use: the <b>'^'</b> operator can only be used at the beginning of an entire
       regular expression, and the <b>'$'</b> operator only at the end. The  operators  apply  to  the  entire  regular
       expression. Thus, for example, the pattern <b>"(^abc)|(def$)"</b> is undefined; it can instead be written as two
       separate  rules,  one with the regular expression <b>"^abc"</b> and one with <b>"def$"</b>, which share a common action
       via the special <b>'|'</b> action (see below). If the pattern were written <b>"^abc|def$"</b>, it  would  match  either
       <b>"abc"</b> or <b>"def"</b> on a line by itself.

       Unlike  the  general ERE rules, embedded anchoring is not allowed by most historical <u>lex</u> implementations.
       An example of embedded anchoring would be for patterns such as <b>"(^|</b> <b>)foo(</b> <b>|$)"</b> to  match  <b>"foo"</b>  when  it
       exists as a complete word. This functionality can be obtained using existing <u>lex</u> features:

           ^foo/[ \n]      |
           " foo"/[ \n]    /* Found foo as a separate word. */

       Note  also  that <b>'$'</b> is a form of trailing context (it is equivalent to <b>"/\n"</b>) and as such cannot be used
       with regular expressions containing another instance of the operator (see  the  preceding  discussion  of
       trailing context).

       The  additional regular expressions trailing-context operator <b>'/'</b> can be used as an ordinary character if
       presented within double-quotes, <b>"/"</b>; preceded by a &lt;backslash&gt;, <b>"\/"</b>; or  within  a  bracket  expression,
       <b>"[/]"</b>.   The  start-condition  <b>'&lt;'</b>  and  <b>'&gt;'</b>  operators shall be special only in a start condition at the
       beginning of a regular expression; elsewhere in the regular expression they shall be treated as  ordinary
       characters.

   <b>Actions</b> <b>in</b> <b>lex</b>
       The  action  to  be  taken  when  an  ERE  is  matched can be a C program fragment or the special actions
       described below; the program fragment can contain one or more C statements, and can also include  special
       actions. The empty C statement <b>';'</b> shall be a valid action; any string in the <b>lex.yy.c</b> input that matches
       the  pattern  portion of such a rule is effectively ignored or skipped. However, the absence of an action
       shall not be valid, and the action <u>lex</u> takes in such a condition is undefined.

       The specification for an action, including C statements and special actions, can  extend  across  several
       lines if enclosed in braces:

           <u>ERE</u> &lt;<u>one</u> <u>or</u> <u>more</u> <u>blanks</u>&gt; { <u>program</u> <u>statement</u>
                                      <u>program</u> <u>statement</u> }

       The program statements shall not contain unbalanced curly brace preprocessing tokens.

       The  default  action  when  a  string in the input to a <b>lex.yy.c</b> program is not matched by any expression
       shall be to copy the string to the output. Because the default behavior of a program generated by <u>lex</u>  is
       to  read  the  input  and  copy  it  to the output, a minimal <u>lex</u> source program that has just <b>"%%"</b> shall
       generate a C program that simply copies the input to the output unchanged.

       Four special actions shall be available:

           |   ECHO;   REJECT;   BEGIN

       |         The action <b>'|'</b> means that the action for the next rule is the action for this rule.  Unlike the
                 other three actions, <b>'|'</b> cannot  be  enclosed  in  braces  or  be  &lt;semicolon&gt;-terminated;  the
                 application shall ensure that it is specified alone, with no other actions.

       <b>ECHO;</b>     Write the contents of the string <u>yytext</u> on the output.

       <b>REJECT;</b>   Usually  only  a  single  expression  is  matched by a given string in the input.  <b>REJECT</b> means
                 ``continue to the next expression that matches the current input'', and  shall  cause  whatever
                 rule  was  the  second  choice  after the current rule to be executed for the same input. Thus,
                 multiple rules can be matched and executed for one input string or overlapping  input  strings.
                 For example, given the regular expressions <b>"xyz"</b> and <b>"xy"</b> and the input <b>"xyz"</b>, usually only the
                 regular  expression  <b>"xyz"</b>  would  match. The next attempted match would start after <b>z.</b>  If the
                 last action in the <b>"xyz"</b> rule is <b>REJECT</b>, both this rule and the <b>"xy"</b> rule  would  be  executed.
                 The  <b>REJECT</b>  action may be implemented in such a fashion that flow of control does not continue
                 after it, as if it were equivalent to a <b>goto</b> to another part of <u>yylex</u>().  The use of <b>REJECT</b> may
                 result in somewhat larger and slower scanners.

       <b>BEGIN</b>     The action:

                     BEGIN <u>newstate</u>;

                 switches the state (start condition) to <u>newstate</u>.  If the string <u>newstate</u> has not been declared
                 previously as a start condition in the <u>Definitions</u> section, the results  are  unspecified.  The
                 initial state is indicated by the digit <b>'0'</b> or the token <b>INITIAL</b>.

       The  functions  or  macros  described  below are accessible to user code included in the <u>lex</u> input. It is
       unspecified whether they appear in the C code output of <u>lex</u>, or are  accessible  only  through  the  <b>-l</b> <b>l</b>
       operand to <u>c99</u> (the <u>lex</u> library).

       <b>int</b> <u>yylex</u>(<b>void</b>)
             Performs  lexical analysis on the input; this is the primary function generated by the <u>lex</u> utility.
             The function shall return zero when the end of input is reached; otherwise, it  shall  return  non-
             zero values (tokens) determined by the actions that are selected.

       <b>int</b> <u>yymore</u>(<b>void</b>)
             When  called,  indicates that when the next input string is recognized, it is to be appended to the
             current value of  <u>yytext</u>  rather  than  replacing  it;  the  value  in  <u>yyleng</u>  shall  be  adjusted
             accordingly.

       <b>int</b> <u>yyless</u>(<b>int</b> <u>n</u>)
             Retains  <u>n</u>  initial characters in <u>yytext</u>, NUL-terminated, and treats the remaining characters as if
             they had not been read; the value in <u>yyleng</u> shall be adjusted accordingly.

       <b>int</b> <u>input</u>(<b>void</b>)
             Returns the next character from the input, or zero on end-of-file. It shall obtain input  from  the
             stream  pointer  <u>yyin</u>, although possibly via an intermediate buffer. Thus, once scanning has begun,
             the effect of altering the value of <u>yyin</u> is undefined. The character read shall be removed from the
             input stream of the scanner without any processing by the scanner.

       <b>int</b> <u>unput</u>(<b>int</b> <u>c</u>)
             Returns the character <b>'c'</b> to the input; <u>yytext</u> and <u>yyleng</u> are undefined until the  next  expression
             is matched. The result of using <u>unput</u>() for more characters than have been input is unspecified.

       The  following  functions  shall appear only in the <u>lex</u> library accessible through the <b>-l</b> <b>l</b> operand; they
       can therefore be redefined by a conforming application:

       <b>int</b> <u>yywrap</u>(<b>void</b>)
             Called by <u>yylex</u>() at end-of-file; the default <u>yywrap</u>() shall always return 1.  If  the  application
             requires  <u>yylex</u>()  to  continue  processing  with another source of input, then the application can
             include a function <u>yywrap</u>(), which associates another file with the external variable <b>FILE</b>  <b>*</b>  <u>yyin</u>
             and shall return a value of zero.

       <b>int</b> <u>main</u>(<b>int</b> <u>argc</u>, <b>char</b> <b>*</b><u>argv</u>[])
             Calls  <u>yylex</u>() to perform lexical analysis, then exits. The user code can contain <u>main</u>() to perform
             application-specific operations, calling <u>yylex</u>() as applicable.

       Except for <u>input</u>(), <u>unput</u>(), and <u>main</u>(), all external and static names generated by <u>lex</u> shall begin  with
       the prefix <b>yy</b> or <b>YY</b>.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       The following exit values shall be returned:

        0    Successful completion.

       &gt;0    An error occurred.

</pre><h4><b>CONSEQUENCES</b> <b>OF</b> <b>ERRORS</b></h4><pre>
       Default.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       Conforming applications are warned that in the <u>Rules</u> section, an ERE without an action is not acceptable,
       but need not be detected as erroneous by <u>lex</u>.  This may result in compilation or runtime errors.

       The  purpose of <u>input</u>() is to take characters off the input stream and discard them as far as the lexical
       analysis is concerned. A common use is to discard the body of a comment once the beginning of  a  comment
       is recognized.

       The  <u>lex</u> utility is not fully internationalized in its treatment of regular expressions in the <u>lex</u> source
       code or generated lexical analyzer. It would seem desirable to have the lexical  analyzer  interpret  the
       regular  expressions  given  in  the  <u>lex</u>  source according to the environment specified when the lexical
       analyzer is executed, but this is not possible with the current <u>lex</u>  technology.  Furthermore,  the  very
       nature  of  the lexical analyzers produced by <u>lex</u> must be closely tied to the lexical requirements of the
       input language being described, which is frequently locale-specific  anyway.  (For  example,  writing  an
       analyzer that is used for French text is not automatically useful for processing other languages.)

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  is  an  example  of a <u>lex</u> program that implements a rudimentary scanner for a Pascal-like
       syntax:

           %{
           /* Need this for the call to atof() below. */
           #include &lt;<a href="file:/usr/include/math.h">math.h</a>&gt;
           /* Need this for printf(), fopen(), and stdin below. */
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           %}

           DIGIT    [0-9]
           ID       [a-z][a-z0-9]*

           %%

           {DIGIT}+ {
               printf("An integer: %s (%d)\n", yytext,
                   atoi(yytext));
               }

           {DIGIT}+"."{DIGIT}*        {
               printf("A float: %s (%g)\n", yytext,
                   atof(yytext));
               }

           if|then|begin|end|procedure|function        {
               printf("A keyword: %s\n", yytext);
               }

           {ID}    printf("An identifier: %s\n", yytext);

           "+"|"-"|"*"|"/"        printf("An operator: %s\n", yytext);

           "{"[^}\n]*"}"    /* Eat up one-line comments. */

           [ \t\n]+        /* Eat up white space. */

           .  printf("Unrecognized character: %s\n", yytext);

           %%

           int main(int argc, char *argv[])
           {
               ++argv, --argc;  /* Skip over program name. */
               if (argc &gt; 0)
                   yyin = fopen(argv[0], "r");
               else
                   yyin = stdin;

               yylex();
           }

</pre><h4><b>RATIONALE</b></h4><pre>
       Even though the <b>-c</b> option and references to the C language are retained in this description, <u>lex</u>  may  be
       generalized to other languages, as was done at one time for EFL, the Extended FORTRAN Language. Since the
       <u>lex</u> input specification is essentially language-independent, versions of this utility could be written to
       produce Ada, Modula-2, or Pascal code, and there are known historical implementations that do so.

       The  current  description  of  <u>lex</u>  bypasses  the issue of dealing with internationalized EREs in the <u>lex</u>
       source code or generated lexical analyzer. If it follows the model  used  by  <u>awk</u>  (the  source  code  is
       assumed  to  be  presented  in  the POSIX locale, but input and output are in the locale specified by the
       environment variables), then the tables in the lexical analyzer produced  by  <u>lex</u>  would  interpret  EREs
       specified  in  the  <u>lex</u> source in terms of the environment variables specified when <u>lex</u> was executed. The
       desired effect would be to have the lexical analyzer interpret the EREs given in the <u>lex</u> source according
       to the environment specified when the lexical analyzer is executed, but this is  not  possible  with  the
       current <u>lex</u> technology.

       The  description  of  octal  and hexadecimal-digit escape sequences agrees with the ISO C standard use of
       escape sequences.

       Earlier versions of this standard allowed for implementations with bytes other than eight bits, but  this
       has been modified in this version.

       There  is  no  detailed  output  format  specification. The observed behavior of <u>lex</u> under four different
       historical implementations was that none of these implementations consistently reported the line  numbers
       for  error and warning messages. Furthermore, there was a desire that <u>lex</u> be allowed to output additional
       diagnostic messages. Leaving message formats unspecified avoids these formatting questions  and  problems
       with internationalization.

       Although the <b>%x</b> specifier for <u>exclusive</u> start conditions is not historical practice, it is believed to be
       a  minor change to historical implementations and greatly enhances the usability of <u>lex</u> programs since it
       permits an application to obtain the expected functionality with fewer statements.

       The <b>%array</b> and <b>%pointer</b> declarations were added as a compromise between historical systems.   The  System
       V-based  <u>lex</u>  copies  the  matched  text  to  a  <u>yytext</u> array. The <u>flex</u> program, supported in BSD and GNU
       systems, uses a pointer. In the latter case, significant performance improvements are available for  some
       scanners. Most historical programs should require no change in porting from one system to another because
       the  string being referenced is null-terminated in both cases. (The method used by <u>flex</u> in its case is to
       null-terminate the token in place by remembering the character that used to come right  after  the  token
       and  replacing it before continuing on to the next scan.) Multi-file programs with external references to
       <u>yytext</u> outside the scanner source file should continue to operate on their historical systems, but  would
       require one of the new declarations to be considered strictly portable.

       The description of EREs avoids unnecessary duplication of ERE details because their meanings within a <u>lex</u>
       ERE are the same as that for the ERE in this volume of POSIX.1‐2017.

       The  reason  for the undefined condition associated with text beginning with a &lt;blank&gt; or within <b>"%{"</b> and
       <b>"%}"</b> delimiter lines appearing in the <u>Rules</u> section is historical practice. Both the BSD and System V <u>lex</u>
       copy the indented (or enclosed) input in the <u>Rules</u> section (except at the beginning) to unreachable areas
       of the <u>yylex</u>() function (the code is written directly after a <u>break</u> statement). In some cases, the System
       V <u>lex</u> generates an error message or a syntax error, depending on the form of indented input.

       The intention in breaking the list of functions into those that may appear in <b>lex.yy.c</b> <u>versus</u> those  that
       only  appear  in  <b>libl.a</b> is that only those functions in <b>libl.a</b> can be reliably redefined by a conforming
       application.

       The descriptions of standard output and standard error are somewhat complicated  because  historical  <u>lex</u>
       implementations chose to issue diagnostic messages to standard output (unless <b>-t</b> was given). POSIX.1‐2008
       allows  this  behavior,  but leaves an opening for the more expected behavior of using standard error for
       diagnostics.  Also, the System V behavior of writing the statistics when any table  sizes  are  given  is
       allowed,  while  BSD-derived systems can avoid it. The programmer can always precisely obtain the desired
       results by using either the <b>-t</b> or <b>-n</b> options.

       The OPERANDS section does not mention the use of <b>-</b> as a synonym for standard input;  not  all  historical
       implementations support such usage for any of the <u>file</u> operands.

       A  description  of  the  <u>translation</u> <u>table</u> was deleted from early proposals because of its relatively low
       usage in historical applications.

       The change to the definition of the  <u>input</u>()  function  that  allows  buffering  of  input  presents  the
       opportunity for major performance gains in some applications.

       The  following  examples  clarify the differences between <u>lex</u> regular expressions and regular expressions
       appearing elsewhere in this volume of POSIX.1‐2017. For regular expressions of the form <b>"r/x"</b>, the string
       matching <u>r</u> is always returned; confusion may arise when the beginning of <u>x</u> matches the  trailing  portion
       of  <u>r</u>.   For  example, given the regular expression <b>"a*b/cc"</b> and the input <b>"aaabcc"</b>, <u>yytext</u> would contain
       the string <b>"aaab"</b> on this match. But given the regular expression <b>"x*/xy"</b> and the input <b>"xxxy"</b>, the token
       <b>xxx</b>, not <b>xx</b>, is returned by some implementations because <b>xxx</b> matches <b>"x*"</b>.

       In the rule <b>"ab*/bc"</b>, the <b>"b*"</b> at the end of <u>r</u> extends <u>r</u>'s match  into  the  beginning  of  the  trailing
       context, so the result is unspecified. If this rule were <b>"ab/bc"</b>, however, the rule matches the text <b>"ab"</b>
       when  it  is  followed  by  the text <b>"bc"</b>.  In this latter case, the matching of <u>r</u> cannot extend into the
       beginning of <u>x</u>, so the result is specified.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>c99</u>, <u>ed</u>, <u>yacc</u>

       The Base Definitions volume of POSIX.1‐2017, <u>Chapter</u> <u>5</u>, <u>File</u>  <u>Format</u>  <u>Notation</u>,  <u>Chapter</u>  <u>8</u>,  <u>Environment</u>
       <u>Variables</u>, <u>Chapter</u> <u>9</u>, <u>Regular</u> <u>Expressions</u>, <u>Section</u> <u>12.2</u>, <u>Utility</u> <u>Syntax</u> <u>Guidelines</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                           <u><a href="../man1POSIX/LEX.1POSIX.html">LEX</a></u>(1POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>