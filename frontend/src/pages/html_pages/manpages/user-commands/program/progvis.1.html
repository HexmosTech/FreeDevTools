<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>progvis - visualization tool for concurrent C/C++ programs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/progvis">progvis_0.6.28-3build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       progvis - visualization tool for concurrent C/C++ programs

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>progvis</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Progvis  is  a program visualization tool aimed at concurrent C/C++ programs. It allows loading arbitrary
       programs and stepping through them. The tool also informs about a number of concurrency issues,  such  as
       race conditions. Only a subset of C/C++ is supported. For C, most notably <u>void</u> pointers are not supported
       (for  type  safety).  For  C++, only fundamental language constructs are implemented (e.g. no templates).
       Much of the standard libraries both for C and C++ are not implemented either.

</pre><h4><b>SYNCHRONIZATION</b></h4><pre>
       The   system   provides   C-style   synchronization   primitives   as   implemented   in   Pintos,   see:
       <a href="http://www.scs.stanford.edu/07au-cs140/pintos/pintos_6.html">http://www.scs.stanford.edu/07au-cs140/pintos/pintos_6.html</a>#SEC97 In summary, they are as follows:

       <b>struct</b> <b>semaphore</b>
              An implementation of a semaphore.

       <b>sema_init(struct</b> <b>semaphore</b> <b>*sema,</b> <b>int</b> <b>value)</b>
              Initialize a semaphore object to a particular (positive) value.

       <b>sema_up(struct</b> <b>semaphore</b> <b>*sema)</b>
              Increase the counter in the semaphore. Also known as <u>signal</u>.

       <b>sema_down(struct</b> <b>semaphore</b> <b>*sema)</b>
              Decrease  the  counter  in  the  semaphore, waits if it would become less than zero. Also known as
              <u>wait</u>.

       <b>struct</b> <b>lock</b>
              An implementation of a lock.

       <b>lock_init(struct</b> <b>lock</b> <b>*lock)</b>
              Initialize a lock.

       <b>lock_acquire(struct</b> <b>lock</b> <b>*lock)</b>
              Acquire a lock. Might wait.

       <b>lock_release(struct</b> <b>lock</b> <b>*lock)</b>
              Release a lock. Has to be done by the same thread that called <u>lock_acquire</u>.

       <b>struct</b> <b>condition</b>
              Implementation of a condition variable.

       <b>cond_init(struct</b> <b>condition</b> <b>*cond)</b>
              Initialize a condition variable.

       <b>cond_wait(struct</b> <b>condition</b> <b>*cond,</b> <b>struct</b> <b>lock</b> <b>*lock)</b>
              Cause the current thread to wait until the condition is signalled. Assumes that the lock is  held.
              The lock will be released while the thread is waiting, but it will be re-acquired before <u>cond_wait</u>
              returns.

       <b>cond_signal(struct</b> <b>condition</b> <b>*cond,</b> <b>struct</b> <b>lock</b> <b>*lock)</b>
              Wake one thread that is currently waiting inside <u>cond_wait</u>. Assumes that the lock is held.

       <b>cond_broadcast(struct</b> <b>condition</b> <b>*cond,</b> <b>struct</b> <b>lock</b> <b>*lock)</b>
              Wake <u>all</u> threads that are currently waiting inside <u>cond_wait</u>.

</pre><h4><b>ATOMIC</b> <b>OPERATIONS</b></h4><pre>
       A  number  of  atomic  operations  are  also  supported. Most of these are generic, meaning that they are
       overloaded to work for more than one type. Here, we use <b>P</b> to mean any pointer type, <b>I</b> to mean any integer
       type (i.e. signed and unsigned integers, as well as booleans), and <b>P/I</b> to mean  any  pointer  or  integer
       type.

       <b>I</b> <b>test_and_set(I</b> <b>*v)</b>
              Read <u>v</u> and return its value, also setting <u>v</u> to 1.

       <b>I</b> <b>atomic_add(I</b> <b>*v,</b> <b>I</b> <b>add)</b>
              Adds <u>add</u> to the value pointed to by <u>v</u>. Returns the old value.

       <b>I</b> <b>atomic_sub(I</b> <b>*v,</b> <b>I</b> <b>sub)</b>
              Subtracts <u>sub</u> from the value pointed to by <u>v</u>. Returns the old value.

       <b>P/I</b> <b>atomic_read(P/I</b> <b>*v)</b>
              Read from <u>v</u> and return the value.

       <b>void</b> <b>atomic_write(P/I</b> <b>*to,</b> <b>P/I</b> <b>v)</b>
              Write to <u>to</u>.

       <b>P/I</b> <b>atomic_swap(P/I</b> <b>*v,</b> <b>P/I</b> <b>replace)</b>
              Read the value pointed to by <u>v</u>, and replace it with the value <u>replace</u>. Returns the old value.

       <b>P/I</b> <b>compare_and_swap(P/I</b> <b>*v,</b> <b>P/I</b> <b>compare,</b> <b>P/I</b> <b>swap)</b>
              Read the value from <u>v</u>, if it was equal to <u>compare</u>, replace it with <u>swap</u>. Returns the old value.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/storm.1.html">storm</a></b>(1) - the language in which Progvis is implemented.

                                                 October 15 2023                                      <u><a href="../man1/PROGVIS.1.html">PROGVIS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>