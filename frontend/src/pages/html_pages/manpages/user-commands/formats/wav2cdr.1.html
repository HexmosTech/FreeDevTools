<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wav2cdr - converts input in (or similar to) wav format to cdr format suitable for writing onto audio CDs.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/wav2cdr">wav2cdr_2.3.4-5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wav2cdr - converts input in (or similar to) wav format to cdr format suitable for writing onto audio CDs.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>wav2cdr</b> [<u>options</u> ...] [<u>infile</u> [<u>outfile</u>]] [--cut <u>cutnumber</u> ...]

</pre><h4><b>VERSION</b></h4><pre>
       This man page describes wav2cdr version 2.3.4.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       wav2cdr  is  a  conversion  program  for  audio  data which adopts automatically to big and little endian
       machines. Its primary use was to convert wav to cdr, but it is a little more flexible now and can  handle
       some  file  formats  and  perform  some  operations  on the data. These formats are possible (reading and
       writing):

           wav   MS Windows sound
           cdr   audio CD
           raw   fixed sampling rate, channels, and bytes per sample
                 (= that of cdr); byte order must be specified

       These operations can be performed on the data (combinations are possible as long as they are meaningful):

           Scaling (volume change), integer arithmetic
           Scaling (volume change), floating point arithmetic
           Cutting of the input into pieces / tracks
           Conversion to mono and back to stereo
           Swapping of the 2 channels
           Adding silence to (or removing from, see cutting) the
             start and/or end
           Generation of cut numbers along silent intervals, e.g.
             to break up a record into tracks
           Information about non-silent intervals
           Fading in and out

</pre><h4><b>OPTIONS</b></h4><pre>
       <u>--cut</u> <b>NUM</b> <b>NUM</b> <b>[NUM...]</b>
              Cut the input into pieces, cutting at positions NUM.  See sections  about  argument  scanning  and
              splitting below.

       <u>--endsilence</u><b>,</b> <u>--es</u> <b>DUR</b>
              Adds the given amount of silence to the end of each output file.

       <u>--fadein</u> <b>LEN</b>
              Fade  in at the start over a duration of LEN.  The syntax for LEN is the same as for a cut number,
              see section about argument scanning below.  If cutting  is  active,  fade-in  is  applied  to  the
              beginning of each cut.

              Fading  in  is  performed by increasing the amplitude for CD sectors by an amount derived from LEN
              over a duration of LEN. <u>--fadein</u> 3 would result in the amplitude of the first  sector  lowered  to
              1/4,  of the second sector to 2/4, and the third sector to 3/4. The fourth sector is unchanged and
              has then reached full amplitude.

       <u>--fadeout</u> <b>LEN</b>
              Fade out at the end over a duration of LEN.  The syntax for LEN is the same as for a  cut  number,
              see section about argument scanning below.  If cutting is active, fad-out is applied to the end of
              each cut.

              The  computation  is  similar to <u>--fadein</u>. <u>--fadein</u> 3 would result in the last 3 CD sectors having
              their amplitudes lowered to 3/4, 2/4, and 1/4. The (non-existant) following sector is  assumed  to
              be silent.

              To add silent sector(s) to the end of the audio file, use <u>--endsilence</u>.

              Fading  out  can  only  be  performed  if the input size can be determined (i.e. the input must be
              seekable and cannot be a pipe). If cutting is active, the end of the cut is always known  and  the
              fade-out can be applied.

              If  the  fade-out  starts  before  the  fade-in is finished, both will overlap, producing sensible
              results.

       <u>--fscale</u> <b>FLOAT</b>
              Scale data by FLOAT, i.e. multiply by FLOAT (1.0 does nothing).

       <u>-h</u><b>,</b> <u>-u</u><b>,</b> <u>--usage</u>
              Display usage.

       <u>--help</u> Display extensive help. (The information is derived from and equivalent to this manual page.)

       <u>--inbig</u><b>,</b> <u>-I</u>
              Input data is big endian (MSB, LSB) (Motorola).

       <u>--incdr</u>
              Read cdr format (default is wav). Sets the correct byte order.

       <u>--infile</u><b>,</b> <u>-r</u> <b>NAME</b>
              Input filename. Defaults to stdin. '-' = stdin.

       <u>--inlittle</u><b>,</b> <u>-i</u>
              Input data is little endian (LSB, MSB) (Intel).

       <u>--inraw</u>
              Read raw format. Byte order should be specified with <u>-i</u>/<u>-I</u> (default big).

       <u>--inwav</u>
              Read wav format (default). Sets the correct byte order.

       <u>--iscale</u> <b>NUM</b>
              Scale data to NUM percent (100 does nothing).

       <u>--monostereo</u>
              Convert input to mono and immediately back to stereo. The result is 2 channels with the same data.
              This can be useful in some cases.

       <u>--noswapchannels</u>
              Don't swap channels. (default)

       <u>--outfile</u><b>,</b> <u>-w</u> <b>NAME</b>
              Write output to file NAME.  The track number is appended as a 2-digit number.  The default  is  to
              write output to stdout.  A NAME of '-' means stdout.  When cutting is active and more than one cut
              is made, output can not be written to stdout and the use of this option is mandatory.

       <u>--outbig</u><b>,</b> <u>-O</u>
              Output data in big endian (MSB, LSB) (Motorola) byte order.

       <u>--outlittle</u><b>,</b> <u>-o</u>
              Output data in little endian (LSB, MSB) (Intel) byte order.

       <u>--quiet</u>
              Suppress  progress  output.   The  name  of  this  option might be misleading: it does not prevent
              copious output in other places which might be turned on by <u>--verbose</u>.

       <u>--silencecuts</u>
              Generate cut numbers for cutting out silent intervals. This is  useful  when  digitising  a  whole
              record  and  then cutting it into tracks. The cut numbers are output on stdout and can be fed back
              into <u>--cut</u>.  After cutting, every second  track  (those  with  even  numbers)  contains  a  silent
              interval and can be deleted.

              Together  with  <u>--verbose</u>,  the silence value of each sector is printed as well (can't be fed back
              into <u>--cut</u> then). This most likely produces some VERY long lines.

              Silence is detected by applying a threshold (<u>--silencethresh</u>) to a  value  computed  for  each  CD
              sector;  the  value  must  be  below  the  threshold  for  a  minimum  number  of  sectors  (delay
              <u>--silencedelay</u>). Currently, the average is computed first (this is the  DC  component);  then  the
              average of the absolute of the difference between each sample and the DC component. The difference
              between  these  2 averages is compared with the threshold. Check whether the cuts really fall into
              the silent intervals, and adjust threshold and duration if not (or edit the cut numbers manually).

              The silence delay period is part of the signal interval, not the silence interval. This means that
              each non-silent period has <u>--silencedelay</u> silence at the start and  at  the  end.  If  the  silent
              interval  between  two  signal  intervals is less than (2 * silence delay), the silent part at the
              start of the second signal period will be shortened.

       <u>--silencedelay</u> <b>DELAY</b>
              The duration for which the "input" must be below the threshold in order to be detected as a silent
              interval. In other words, the number of sectors which must be silent before a silent  interval  is
              detected.  Ignored without <u>--silencecuts</u>. The delay can be specified with units in the same way as
              for <u>--cut</u>, and is truncated to full CD sectors. Default is 30C (=0.4s).

       <u>--silenceinfo</u>
              Similar to <u>--silencecuts</u>, but it generates more information. Silent and non-silent  intervals  are
              listed  in  a  tabular format.  The output format is useful for documentation, but not for feeding
              back into <u>--cut</u>.  With <u>--verbose</u>, the silence values of each CD sector are shown  as  well.   This
              produces lots of output, but it is useful for finding a suitable <u>--silencethresh</u>.

       <u>--silencethresh</u> <b>THRESHOLD</b>
              Threshold  for  silence  detection. Ignored without <u>--silencecuts</u>.  Default is 10. Always select a
              threshold as low as possible. When cutting a record into tracks, the threshold must be high enough
              to recognise the crackling between pieces as silence. When the threshold is too high, a little  at
              the beginning and end of each piece might be chopped off.

              As  a  special  case,  if the threshold is set to 0 the usual numerical computation of the silence
              value is bypassed, and the sector is deemed to be silent if all samples are 0.

       <u>--startsilence</u><b>,</b> <u>--ss</u> <b>DUR</b>
              Adds the given amount of silence to the start of each output file.

       <u>--swapchannels</u>
              Swap the left with the right channel.

       <u>--tocdr</u>
              Write data in cdr format (default). Sets the correct byte order.

       <u>--toraw</u>
              Write data in raw format. Byte order should be specified with <u>-o</u>/<u>-O</u> (default big).

       <u>--towav</u>
              Write data in wav format. Sets the correct byte order.

       <u>--verbose</u>
              Produce more output. Currently only used by <u>--silencecuts</u> and <u>--silenceinfo</u>.

       <u>--version</u><b>,</b> <u>-V</u>
              Display version information.

       <u>--</u>     Stop argument processing.  Remaining arguments can only be filenames, or cut numbers if cutting is
              used.

</pre><h4><b>Command</b> <b>line</b> <b>option</b> <b>scanning:</b></h4><pre>
       From left to right. Later settings may override previous ones. Beware to switch file formats before  byte
       ordering,  or  a  byte  order  might  be  rejected  for the (then active) format. When not using cutting,
       remaining arguments are used to fill up  input  and  output  filenames.  When  using  cutting,  remaining
       arguments  are  assumed  to  be  cut numbers. When using negative cut numbers, use -- to terminate option
       processing or the negative numbers can be mistaken as options (this is a must with GNU getopt()).

       All options which take an argument denoting a time accept the following number format. The number may  be
       in  decimal, octal (leading 0), or hexadecimal (leading 0x or 0X). A one-letter unit may be following. If
       there is space between the number and the unit, both must be quoted,  as  in  "55  C".  These  units  are
       recognised:  b  (bytes),  C  (audio  CD  sectors),  s (seconds). When no unit is given, C is assumed. The
       progress display might only show numbers in some of these units. Fractions for seconds are allowed.

       Negative cut numbers are only allowed if the input size can be determined (which will not be possible  if
       the  input comes from a pipe), and are shown as the equivalent positive ones. If the last cut number is 0
       it means the end of the file. If the input file size can not be determined  the  longest  possible  input
       (about 405 minutes) is substituted.

       A filename of '-' is taken as stdin/stdout.

       If  wav2cdr  was compiled to use GNU getopt(), argument scanning is more powerful and long options can be
       shortened to significance. Options are also re-ordered; this is nice but can be a  trap.  Use  --  if  in
       doubt, and don't mix options with filename or cut number arguments.

</pre><h4><b>Data</b> <b>formats:</b></h4><pre>
       All  data  handling  currently  assumes signed 16-bit integers, interleaved for 2 channels, at a sampling
       rate of that of a CD. Only wav files with these parameters can be read correctly. cdr files are  in  that
       format, and only raw formats with these parameters can be processed. The only flexibility allowed for raw
       is the byte order, which can be specified for both reading and writing. The byte ordering for wav and cdr
       is fixed.

</pre><h4><b>Channel</b> <b>swapping:</b></h4><pre>
       Left  and  right  channel  are swapped, which is the same as swapping consecutive 16 bit values with each
       other. Also see 'CDR Format' below.

</pre><h4><b>Scaling</b> <b>/</b> <b>Volume</b> <b>change:</b></h4><pre>
       Scaling can be performed with either integer or floating point arithmetic.  Integer arithmetic is  faster
       but  possibly not as precise. Values will saturate (i.e. be clipped), rather than be truncated. The speed
       of this operation depends on the endianness of the input data, output data, and host. It is slowest  when
       bytes  have  to be swapped before scaling and swapped back after.  Negative scale factors are allowed but
       might be of dubious value.

</pre><h4><b>Mono</b> <b>/</b> <b>stereo:</b></h4><pre>
       Input data can be converted to mono and then back to stereo. The result is 2 channels with the same data.
       This can be useful in some cases.

</pre><h4><b>Output</b> <b>file</b> <b>naming:</b></h4><pre>
       Unless output is to stdout, the resulting filename is the name given  with  <u>--outfile</u>.  A  period  and  a
       2-digit track number are appended.

</pre><h4><b>Input</b> <b>data</b> <b>splitting:</b></h4><pre>
       Input data can be split into pieces resp. tracks. Currently cuts can only be placed at multiples of audio
       CD sectors (at the sector boundaries), whether the input format is cdr or not.

       The cuts are placed at the given positions, which must be in ascending order (or equal). Negative numbers
       are  counted  from  the  end  of the input data. This only works if the input is seekable (Unix pipes are
       not). Sectors of the input are numbered from 0. Bytes of a header, which the input format might have, are
       not counted.

       Any number of cuts can be made, but only 99 tracks can be put on a CD. All sectors before the  first  but
       not  including the first sector number are discarded, as well as all sectors after and including the last
       sector number.  At least 2 sector numbers (cut numbers) must be given, in which case  one  piece  is  cut
       out.

       If there are only 2 cut numbers (1 track to cut out) data can be written to stdout or file. More than one
       track  can  only  be written to file, the track number will be added as an extension to the filename.  To
       avoid the track number to be appended to the filename when only one cut is made, don't use <u>--outfile</u>  but
       write to stdout and use output redirection.

        Example (assuming 50000 sectors in the input):
           wav2cdr &lt; INPUT --outfile NAME --cut 500 20000 40000
                sectors     0-  499: discarded
                          500-19999: saved to NAME.01
                        20000-39999: saved to NAME.02
                        40000-49999: discarded

</pre><h4><b>Cutting</b> <b>out</b> <b>silent</b> <b>intervals:</b></h4><pre>
       Assuming a digitised record is stored in record.wav, and is to be cut into tracks.

         wav2cdr &lt; record.wav &gt; cuts --silencecuts --silencedelay 2s
         wav2cdr &lt; record.wav --of tracks --cut `cat cuts`

       Will  store  the  tracks of the record in track.01, track.02, ..., with the delay for cutting at a silent
       part set to 2 seconds. The threshold used is the default. Note the `` syntax works under Unix and in this
       case puts the contents of file "cuts" on the command line.

</pre><h4><b>Information</b> <b>about</b> <b>silences</b> <b>and</b> <b>actual</b> <b>sound</b> <b>parts:</b></h4><pre>
       <u>--silenceinfo</u> can be used in the same way as <u>--silencecuts</u>.  It produces output like

       (stdin):
        silnc         0 b,      0 C,    0 s, 00:00.00 min
         DIFF    811440 b,    345 C,    4 s, 00:04.22 min
          --&gt;    811440 b,    345 C,    4 s, 00:04.22 min

        AUDIO    811440 b,    345 C,    4 s, 00:04.22 min
         DIFF  20603520 b,   8760 C,  116 s, 01:56.05 min
          --&gt;  21414960 b,   9105 C,  121 s, 02:01.02 min

       showing the beginning, length ("DIFF"), and end ("--&gt;") of  both  silent  ("silnc")  and  and  non-silent
       ("AUDIO") intervals. This is useful for examining existing tracks, but it can not be used with <u>--cut</u>.

</pre><h4><b>Messages:</b></h4><pre>
       Progress messages and statistics are written to stderr when writing to stdout, and to stdout when writing
       to file. It is currently not possible to suppress this, other than by redirection to the bit bucket.

</pre><h4><b>Writing</b> <b>wav</b> <b>format:</b></h4><pre>
       Only  wav  files  with  2 channels, 16 bits per sample, and audio CD sampling rate can be written. If the
       input data is different, the resulting wav file is incorrect. Scaling can be performed when writing  wav.
       Cutting  can  only be performed in multiples of an audio CD sector size. When writing wav the output must
       be seekable (e.g. no pipes).

</pre><h4><b>CDR</b> <b>Format:</b></h4><pre>
       Raw sample data at a sampling rate of 44100 Hz. The channels are interleaved.  The  numbers  are  16  bit
       signed  integers  with  this byte order: MSByte Left, LSByte Left, MSByte Right, LSByte Right.  The track
       size must be a multiple of the sector size of 2352 bytes.  There are 75 sectors per second.

</pre><h4><b>BUGS</b> <b>/</b> <b>LIMITATIONS</b></h4><pre>
       All operations can only be performed on a minimum of 1 CD block or a multiple thereof.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C)
       Nov, Dec 1997, Jan, Mar, Apr, May 1998, Feb, May, Jun, Jul,
       Aug 1999, Oct 2000, Jan 2006 by
       Volker Kuhlmann  &lt;<a href="mailto:VolkerKuhlmann@gmx.de">VolkerKuhlmann@gmx.de</a>&gt;
       formerly c/o EEE Dept, University of Canterbury
       Christchurch, New Zealand

       Permission granted to use and distribute this software free of charge, provided any improvements are sent
       back to the author. Comments and bug reports welcome.  All rights reserved. Standard disclaimer applies.

</pre><h4><b>AUTHOR</b></h4><pre>
       Volker Kuhlmann

wav2cdr                                            18 Jan 2006                                        <u><a href="../man1/wav2cdr.1.html">wav2cdr</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>