<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MRF - monochrome recursive format (compressed bitmaps)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/netpbm">netpbm_11.09.02-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MRF - monochrome recursive format (compressed bitmaps)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This document describes the MRF format recognized by <b><a href="../man1/Netpbm.1.html">Netpbm</a></b>(1).

       MRF is a compressed format for bilevel (1-bit mono) images.  It achieves better compression for some such
       images  than  either GIF or PNG. (It's also very easy to implement (about the same difficulty as RLE, I'd
       say) and an MRF reader needs no tables/buffers, which may make it useful for tiny machines).

       In case the above hasn't made it sufficiently clear, I'll make this next  point  explicitly:  <u>MRF</u>  <u>cannot</u>
       <u>represent</u>  <u>color</u>  <u>at</u> <u>all.</u> Nor can it represent grayscale.  It's a specifically mono format.  (If you want
       to compress a color or grayscale image, my advice is to use JPEG2000).

       First, here's what goes where in an MRF file. I'll explain how the compression works afterward.

       Offset Description

       0      magic number - "MRF1" (in ASCII)

       4      width (32-bit, MSB first (i.e. big-endian))

       8      height (same)

       12     reserved (single byte, must be zero)

       13     compressed data

       Note that there is no end-of-file marker in the file itself - the compressed data carries on right up  to
       EOF.

       The  way  the  picture  is  compressed  is  essentially very simple, but as they say, the devil is in the
       detail.  So don't be put off if it sounds confusing.

       The image is treated as a number of 64x64 squares, forming a grid large enough to encompass  it.  (If  an
       image  is  (say)  129x65,  it'll be treated in the same way as a 192x128 one. On decompression, the extra
       area which was encoded (the contents of this area is undefined) should be ignored.) Each of these squares
       in turn (in left-to-right, top-to-bottom order) is recursively subdivided until the  smallest  completely
       black  or  white  squares are found. Some pseudocode (eek!)  for the recursive subdivision routine should
       make things clearer:

           if square size &gt; 1x1 and square is all one color, output 1 bit
           if whole square is black, output a 0 bit and return
           if whole square is white, output a 1 bit and return
           output a 0 bit
           divide the square into four quarters, calling routine for
           each in this order: top-left, top-right, bottom-left, bottom-right

       (Note that the "output a 0 bit" stage is not reached for squares of size 1x1,  which  is  what  stops  it
       recursing infinitely.  I mention this as it may not be immediately obvious.)

       The  whole of the compressed data is made up of the bits output by the above routine. The bits are packed
       into bytes MSB first, so for example outputting the bits 1,0,0,0,0,0,0,0 would result in a 80h byte being
       output. Any `unused' bits in the last byte output are undefined; these  are  effectively  after  EOF  and
       their value is unimportant.

       If  writing  that  sounds  too  much like hard work :-), you could always adapt <b>pbmtomrf</b> and/or <b>mrftopbm</b>.
       That's the main reason their source code is public domain, after all.

       Above, I said the contents of any extra area encoded (when a bitmap smaller than the grid of  squares  is
       compressed)  is  undefined.   This  is  deliberate so that the MRF compressor can make these unseen areas
       anything it wants so as to maximize compression, rather than simply leaving it  blank.  <b>pbmtomrf</b>  does  a
       little in this respect but could definitely be improved upon.

       <b>mrftopbm</b>'s  <b>-1</b>  option  causes  it  to  include the edges, if any, in the output PBM.  This may help when
       debugging a compressor's edge optimization.

       Note that the "F" in the name "MRF" comes from "format," which is redundant because it is the name  of  a
       format.  That sort of makes "MRF format" sound as stupid as "PIN number," but it's not really that bad.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/mrftopbm.1.html">mrftopbm</a></b>(1), <b><a href="../man1/pbmtomrf.1.html">pbmtomrf</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       Russell Marks.

</pre><h4><b>DOCUMENT</b> <b>SOURCE</b></h4><pre>
       This  manual  page was generated by the Netpbm tool 'makeman' from HTML source.  The master documentation
       is at

              <b><a href="http://netpbm.sourceforge.net/doc/mrf.html">http://netpbm.sourceforge.net/doc/mrf.html</a></b>

netpbm documentation                                  1991                     <u>MRF</u> <u>image</u> <u>format</u> <u><a href="../man1/specification.1.html">specification</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>