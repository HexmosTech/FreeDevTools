<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>orterun,  mpirun,  mpiexec  -  Execute  serial and parallel jobs in Open MPI.  oshrun, shmemrun - Execute</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/noble/+package/openmpi-bin">openmpi-bin_4.1.6-7ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       orterun,  mpirun,  mpiexec  -  Execute  serial and parallel jobs in Open MPI.  oshrun, shmemrun - Execute
       serial and parallel jobs in Open SHMEM.

       <b>Note:</b> <u>mpirun</u>, <u>mpiexec</u>, and <u>orterun</u> are all synonyms for each other as well as <u>oshrun</u>,  <u>shmemrun</u>  in  case
       Open SHMEM is installed.  Using any of the names will produce the same behavior.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Single Process Multiple Data (SPMD) Model:

       <b>mpirun</b> [ options ] <b>&lt;program&gt;</b> [ &lt;args&gt; ]

       Multiple Instruction Multiple Data (MIMD) Model:

       <b>mpirun</b> [ global_options ]
              [ local_options1 ] <b>&lt;program1&gt;</b> [ &lt;args1&gt; ] :
              [ local_options2 ] <b>&lt;program2&gt;</b> [ &lt;args2&gt; ] :
              ... :
              [ local_optionsN ] <b>&lt;programN&gt;</b> [ &lt;argsN&gt; ]

       Note  that  in  both  models,  invoking  <u>mpirun</u> via an absolute path name is equivalent to specifying the
       <u>--prefix</u> option with a <u>&lt;dir&gt;</u> value equivalent to the directory  where  <u>mpirun</u>  resides,  minus  its  last
       subdirectory.  For example:

           <b>%</b> /usr/local/bin/mpirun ...

       is equivalent to

           <b>%</b> mpirun --prefix <a href="file:/usr/local">/usr/local</a>

</pre><h4><b>QUICK</b> <b>SUMMARY</b></h4><pre>
       If  you  are simply looking for how to run an MPI application, you probably want to use a command line of
       the following form:

           <b>%</b> mpirun [ -np X ] [ --hostfile &lt;filename&gt; ]  &lt;program&gt;

       This will run X copies of <u>&lt;program&gt;</u> in your current run-time environment (if running  under  a  supported
       resource  manager,  Open  MPI's  <u>mpirun</u> will usually automatically use the corresponding resource manager
       process starter, as opposed to, for example, <u>rsh</u> or <u>ssh</u>, which require the use of  a  hostfile,  or  will
       default  to  running  all X copies on the localhost), scheduling (by default) in a round-robin fashion by
       CPU slot.  See the rest of this page for more details.

       Please note that mpirun automatically binds processes as of the start of the v1.8 series.  Three  binding
       patterns are used in the absence of any further directives:

       <b>Bind</b> <b>to</b> <b>core:</b>     when the number of processes is &lt;= 2

       <b>Bind</b> <b>to</b> <b>socket:</b>   when the number of processes is &gt; 2

       <b>Bind</b> <b>to</b> <b>none:</b>     when oversubscribed

       If  your  application uses threads, then you probably want to ensure that you are either not bound at all
       (by specifying --bind-to none), or bound to multiple cores using an appropriate binding level or specific
       number of processing elements per application process.

</pre><h4><b>DEFINITION</b> <b>OF</b> <b>'SLOT'</b></h4><pre>
       The term "slot" is used extensively in the rest of this manual page.  A slot is an allocation unit for  a
       process.  The number of slots on a node indicate how many processes can potentially execute on that node.
       By default, Open MPI will allow one process per slot.

       If  Open  MPI  is not explicitly told how many slots are available on a node (e.g., if a hostfile is used
       and the number of slots is not specified for a given node), it will determine a maximum number  of  slots
       for that node in one of two ways:

       1. Default behavior
          By  default, Open MPI will attempt to discover the number of processor cores on the node, and use that
          as the number of slots available.

       2. When <u>--use-hwthread-cpus</u> is used
          If <u>--use-hwthread-cpus</u> is specified on the <u>mpirun</u> command line, then Open MPI will attempt to discover
          the number of hardware threads on the node, and use that as the number of slots available.

       This default behavior also occurs when specifying the  <u>-host</u>  option  with  a  single  host.   Thus,  the
       command:

       mpirun --host node1 ./a.out
           launches a number of processes equal to the number of cores on node node1, whereas:

       mpirun --host node1 --use-hwthread-cpus ./a.out
           launches a number of processes equal to the number of hardware threads on node1.

       When Open MPI applications are invoked in an environment managed by a resource manager (e.g., inside of a
       SLURM job), and Open MPI was built with appropriate support for that resource manager, then Open MPI will
       be informed of the number of slots for each node by the resource manager.  For example:

       mpirun ./a.out
           launches  one  process  for  every  slot  (on  every  node)  as  dictated by the resource manager job
           specification.

       Also note that the one-process-per-slot restriction can be overridden in  unmanaged  environments  (e.g.,
       when  using  hostfiles  without  a  resource  manager)  if oversubscription is enabled (by default, it is
       disabled).  Most MPI applications and HPC environments do not oversubscribe; for simplicity, the majority
       of this documentation assumes that oversubscription is not enabled.

   <b>Slots</b> <b>are</b> <b>not</b> <b>hardware</b> <b>resources</b>
       Slots are frequently incorrectly conflated with hardware resources.  It  is  important  to  realize  that
       slots are an entirely different metric than the number (and type) of hardware resources available.

       Here are some examples that may help illustrate the difference:

       1. More processor cores than slots

          Consider  a  resource  manager job environment that tells Open MPI that there is a single node with 20
          processor cores and 2 slots available.  By default, Open MPI will only let you run up to 2 processes.

          Meaning: you run out of slots long before you run out of processor cores.

       2. More slots than processor cores

          Consider a hostfile with a single node listed with  a  "slots=50"  qualification.   The  node  has  20
          processor cores.  By default, Open MPI will let you run up to 50 processes.

          Meaning: you can run many more processes than you have processor cores.

</pre><h4><b>DEFINITION</b> <b>OF</b> <b>'PROCESSOR</b> <b>ELEMENT'</b></h4><pre>
       By  default,  Open  MPI  defines  that  a  "processing  element" is a processor core.  However, if <u>--use-</u>
       <u>hwthread-cpus</u> is specified on the <u>mpirun</u> command line, then a "processing element" is a hardware thread.

</pre><h4><b>OPTIONS</b></h4><pre>
       <u>mpirun</u> will send the name of the directory where it was invoked on the local node to each of  the  remote
       nodes,  and  attempt  to change to that directory.  See the "Current Working Directory" section below for
       further details.

       <b>&lt;program&gt;</b> The program executable. This is identified as the first non-recognized argument to mpirun.

       <b>&lt;args&gt;</b>    Pass these run-time arguments to every new process.  These must always be the last arguments to
                 <u>mpirun</u>. If an app context file is used, <u>&lt;args&gt;</u> will be ignored.

       <b>-h</b>, <b>--help</b>
                 Display help for this command

       <b>-q</b>, <b>--quiet</b>
                 Suppress informative messages from orterun during application execution.

       <b>-v</b>, <b>--verbose</b>
                 Be verbose

       <b>-V</b>, <b>--version</b>
                 Print version number.  If no other arguments are given, this will also cause orterun to exit.

       <b>-N</b> &lt;num&gt;
                 Launch num processes per node on all allocated nodes (synonym for npernode).

       <b>-display-map</b>, <b>--display-map</b>
                 Display a table showing the mapped location of each process prior to launch.

       <b>-display-allocation</b>, <b>--display-allocation</b>
                 Display the detected resource allocation.

       <b>-output-proctable</b>, <b>--output-proctable</b>
                 Output the debugger proctable after launch.

       <b>-dvm</b>, <b>--dvm</b>
                 Create a persistent distributed virtual machine (DVM).

       <b>-max-vm-size</b>, <b>--max-vm-size</b> &lt;size&gt;
                 Number of processes to run.

       <b>-novm</b>, <b>--novm</b>
                 Execute without creating an allocation-spanning virtual machine (only start  daemons  on  nodes
                 hosting application procs).

       <b>-hnp</b>, <b>--hnp</b> &lt;arg0&gt;
                 Specify  the  URI  of  the  Head  Node  Process  (HNP),  or  the name of the file (specified as
                 file:filename) that contains that info.

       Use one of the following options to specify which hosts (nodes) of the cluster to run on. Note that as of
       the start of the v1.8 release, mpirun will launch a daemon onto each host in the allocation (as  modified
       by  the  following  options) at the very beginning of execution, regardless of whether or not application
       processes will eventually be mapped to execute there. This  is  done  to  allow  collection  of  hardware
       topology  information  from  the  remote nodes, thus allowing us to map processes against known topology.
       However, it is a change from the behavior in prior  releases  where  daemons  were  only  launched  after
       mapping  was  complete,  and  thus  only  occurred on nodes where application processes would actually be
       executing.

       <b>-H</b>, <b>-host</b>, <b>--host</b> &lt;host1,host2,...,hostN&gt;
              List of hosts on which to invoke processes.

       <b>-hostfile</b>, <b>--hostfile</b> &lt;hostfile&gt;
              Provide a hostfile to use.

       <b>-default-hostfile</b>, <b>--default-hostfile</b> &lt;hostfile&gt;
              Provide a default hostfile.

       <b>-machinefile</b>, <b>--machinefile</b> &lt;machinefile&gt;
              Synonym for <u>-hostfile</u>.

       <b>-cpu-set</b>, <b>--cpu-set</b> &lt;list&gt;
              Restrict launched processes to the specified logical cpus on  each  node  (comma-separated  list).
              Note that the binding options will still apply within the specified envelope - e.g., you can elect
              to bind each process to only one cpu within the specified cpu set.

       The  following  options  specify the number of processes to launch. Note that none of the options imply a
       particular binding policy - e.g., requesting N  processes  for  each  socket  does  not  imply  that  the
       processes will be bound to the socket.

       <b>-c</b>, <b>-n</b>, <b>--n</b>, <b>-np</b> &lt;#&gt;
              Run  this many copies of the program on the given nodes.  This option indicates that the specified
              file is an executable program and not an application context. If no  value  is  provided  for  the
              number  of copies to execute (i.e., neither the "-np" nor its synonyms are provided on the command
              line), Open MPI will automatically execute a copy of the program on each process slot  (see  below
              for  description  of  a "process slot"). This feature, however, can only be used in the SPMD model
              and will return an error (without beginning execution of the application) otherwise.

       <b>—map-by</b> <b>ppr:N:&lt;object&gt;</b>
              Launch N times the number of objects of the specified type on each node.

       <b>-npersocket</b>, <b>--npersocket</b> &lt;#persocket&gt;
              On each node, launch this many processes times the number of processor sockets on the  node.   The
              <u>-npersocket</u>  option  also  turns  on the <u>-bind-to-socket</u> option.  (deprecated in favor of --map-by
              ppr:n:socket)

       <b>-npernode</b>, <b>--npernode</b> &lt;#pernode&gt;
              On each node, launch this many processes.  (deprecated in favor of --map-by ppr:n:node)

       <b>-pernode</b>, <b>--pernode</b>
              On each node, launch one process -- equivalent to <u>-npernode</u> 1.  (deprecated in favor  of  --map-by
              ppr:1:node)

       To map processes:

       <b>--map-by</b> &lt;foo&gt;
              Map  to  the specified object, defaults to <u>socket</u>. Supported options include <u>slot</u>, <u>hwthread</u>, <u>core</u>,
              <u>L1cache</u>, <u>L2cache</u>, <u>L3cache</u>, <u>socket</u>, <u>numa</u>, <u>board</u>, <u>node</u>, <u>sequential</u>, <u>distance</u>, and  <u>ppr</u>.  Any  object
              can  include  modifiers  by  adding a <u>:</u> and any combination of <u>PE=n</u> (bind n processing elements to
              each proc), <u>SPAN</u> (load balance the processes across the  allocation),  <u>OVERSUBSCRIBE</u>  (allow  more
              processes  on a node than processing elements), and <u>NOOVERSUBSCRIBE</u>.  This includes <u>PPR</u>, where the
              pattern would be terminated by another colon to separate it from the modifiers.

       <b>-bycore</b>, <b>--bycore</b>
              Map processes by core (deprecated in favor of --map-by core)

       <b>-byslot</b>, <b>--byslot</b>
              Map and rank processes round-robin by slot.

       <b>-nolocal</b>, <b>--nolocal</b>
              Do not run any copies of the launched application on the same node as orterun  is  running.   This
              option will override listing the localhost with <b>--host</b> or any other host-specifying mechanism.

       <b>-nooversubscribe</b>, <b>--nooversubscribe</b>
              Do  not oversubscribe any nodes; error (without starting any processes) if the requested number of
              processes would cause oversubscription.  This option implicitly  sets  "max_slots"  equal  to  the
              "slots" value for each node. (Enabled by default).

       <b>-oversubscribe</b>, <b>--oversubscribe</b>
              Nodes  are  allowed  to be oversubscribed, even on a managed system, and overloading of processing
              elements.

       <b>-bynode</b>, <b>--bynode</b>
              Launch processes one per node, cycling by node in a round-robin fashion.  This  spreads  processes
              evenly among nodes and assigns MPI_COMM_WORLD ranks in a round-robin, "by node" manner.

       <b>-cpu-list</b>, <b>--cpu-list</b> &lt;cpus&gt;
              Comma-delimited  list  of  processor IDs to which to bind processes [default=NULL].  Processor IDs
              are interpreted as hwloc logical core IDs.  Run the hwloc <u><a href="../man1/lstopo.1.html">lstopo</a>(1)</u>  command  to  see  a  list  of
              available cores and their logical IDs.

       To order processes' ranks in MPI_COMM_WORLD:

       <b>--rank-by</b> &lt;foo&gt;
              Rank in round-robin fashion according to the specified object, defaults to <u>slot</u>. Supported options
              include slot, hwthread, core, L1cache, L2cache, L3cache, socket, numa, board, and node.

       For process binding:

       <b>--bind-to</b> &lt;foo&gt;
              Bind  processes  to  the  specified  object,  defaults  to  <u>core</u>.  Supported options include slot,
              hwthread, core, l1cache, l2cache, l3cache, socket, numa, board, cpu-list, and none.

       <b>-cpus-per-proc</b>, <b>--cpus-per-proc</b> &lt;#perproc&gt;
              Bind each process to the specified number of cpus.  (deprecated in favor of --map-by &lt;obj&gt;:PE=n)

       <b>-cpus-per-rank</b>, <b>--cpus-per-rank</b> &lt;#perrank&gt;
              Alias for <u>-cpus-per-proc</u>.  (deprecated in favor of --map-by &lt;obj&gt;:PE=n)

       <b>-bind-to-core</b>, <b>--bind-to-core</b>
              Bind processes to cores (deprecated in favor of --bind-to core)

       <b>-bind-to-socket</b>, <b>--bind-to-socket</b>
              Bind processes to processor sockets  (deprecated in favor of --bind-to socket)

       <b>-report-bindings</b>, <b>--report-bindings</b>
              Report any bindings for launched processes.

       For rankfiles:

       <b>-rf</b>, <b>--rankfile</b> &lt;rankfile&gt;
              Provide a rankfile file.

       To manage standard I/O:

       <b>-output-filename</b>, <b>--output-filename</b> &lt;filename&gt;
              Redirect the stdout, stderr, and stddiag of all processes  to  a  process-unique  version  of  the
              specified  filename.  Any  directories in the filename will automatically be created.  Each output
              file will consist of filename.id, where the id will be  the  processes'  rank  in  MPI_COMM_WORLD,
              left-filled  with zero's for correct ordering in listings. A relative path value will be converted
              to an absolute path based on the cwd where mpirun is executed. Note that this  <u>will</u>  <u>not</u>  work  on
              environments where the file system on compute nodes differs from that where mpirun is executed.

       <b>-stdin</b>, <b>--stdin</b> &lt;rank&gt;
              The  MPI_COMM_WORLD  rank of the process that is to receive stdin. The default is to forward stdin
              to MPI_COMM_WORLD rank 0, but this option can be used to forward stdin to any process. It is  also
              acceptable to specify <u>none</u>, indicating that no processes are to receive stdin.

       <b>-merge-stderr-to-stdout</b>, <b>--merge-stderr-to-stdout</b>
              Merge stderr to stdout for each process.

       <b>-tag-output</b>, <b>--tag-output</b>
              Tag  each  line of output to stdout, stderr, and stddiag with <b>[jobid,</b> <b>MCW_rank]&lt;stdxxx&gt;</b> indicating
              the process jobid and MPI_COMM_WORLD rank of the  process  that  generated  the  output,  and  the
              channel which generated it.

       <b>-timestamp-output</b>, <b>--timestamp-output</b>
              Timestamp each line of output to stdout, stderr, and stddiag.

       <b>-xml</b>, <b>--xml</b>
              Provide all output to stdout, stderr, and stddiag in an xml format.

       <b>-xml-file</b>, <b>--xml-file</b> &lt;filename&gt;
              Provide all output in XML format to the specified file.

       <b>-xterm</b>, <b>--xterm</b> &lt;ranks&gt;
              Display  the  output from the processes identified by their MPI_COMM_WORLD ranks in separate xterm
              windows. The ranks are specified as a comma-separated list of ranges, with a -1 indicating all.  A
              separate  window  will be created for each specified process.  <b>Note:</b> xterm will normally terminate
              the window upon termination of the process running within it. However, by adding a "!" to the  end
              of the list of specified ranks, the proper options will be provided to ensure that xterm keeps the
              window  open  <u>after</u>  the  process  terminates, thus allowing you to see the process' output.  Each
              xterm window will subsequently need to be manually closed.  <b>Note:</b> In some environments, xterm  may
              require  that the executable be in the user's path, or be specified in absolute or relative terms.
              Thus, it may be necessary to specify a local executable as "./foo" instead of just "foo". If xterm
              fails to find the executable, mpirun will hang, but still respond correctly to a ctrl-c.  If  this
              happens, please check that the executable is being specified correctly and try again.

       To manage files and runtime environment:

       <b>-path</b>, <b>--path</b> &lt;path&gt;
              &lt;path&gt;  that will be used when attempting to locate the requested executables.  This is used prior
              to using the local PATH setting.

       <b>--prefix</b> &lt;dir&gt;
              Prefix directory that will be used to set the <u>PATH</u> and <u>LD_LIBRARY_PATH</u> on the remote  node  before
              invoking Open MPI or the target process.  See the "Remote Execution" section, below.

       <b>--noprefix</b>
              Disable the automatic --prefix behavior

       <b>-s</b>, <b>--preload-binary</b>
              Copy  the  specified  executable(s)  to  remote  machines  prior to starting remote processes. The
              executables will be copied to the Open MPI session directory and will be deleted  upon  completion
              of the job.

       <b>--preload-files</b> &lt;files&gt;
              Preload  the comma separated list of files to the current working directory of the remote machines
              where processes will be launched prior to starting those processes.

       <b>-set-cwd-to-session-dir</b>, <b>--set-cwd-to-session-dir</b>
              Set the working directory of the started processes to their session directory.

       <b>-wd</b> &lt;dir&gt;
              Synonym for <u>-wdir</u>.

       <b>-wdir</b> &lt;dir&gt;
              Change to the directory &lt;dir&gt; before the  user's  program  executes.   See  the  "Current  Working
              Directory"  section  for  notes  on relative paths.  <b>Note:</b> If the <u>-wdir</u> option appears both on the
              command line and in an application context, the context will  take  precedence  over  the  command
              line.  Thus,  if  the  path to the desired wdir is different on the backend nodes, then it must be
              specified as an absolute path that is correct for the backend node.

       <b>-x</b> &lt;env&gt;
              Export the specified environment variables to the remote nodes before executing the program.  Only
              one environment variable can be specified per <u>-x</u> option.  Existing environment  variables  can  be
              specified or new variable names specified with corresponding values.  For example:
                  <b>%</b> mpirun -x DISPLAY -x OFILE=/tmp/out ...

              The parser for the <u>-x</u> option is not very sophisticated; it does not even understand quoted values.
              Users  are  advised  to  set  variables in the environment, and then use <u>-x</u> to export (not define)
              them.

       Setting MCA parameters:

       <b>-gmca</b>, <b>--gmca</b> &lt;key&gt; &lt;value&gt;
              Pass global MCA parameters that are applicable to all  contexts.  <u>&lt;key&gt;</u>  is  the  parameter  name;
              <u>&lt;value&gt;</u> is the parameter value.

       <b>-mca</b>, <b>--mca</b> &lt;key&gt; &lt;value&gt;
              Send arguments to various MCA modules.  See the "MCA" section, below.

       <b>-am</b> &lt;arg0&gt;
              Aggregate MCA parameter set file list.

       <b>-tune</b>, <b>--tune</b> &lt;tune_file&gt;
              Specify  a  tune file to set arguments for various MCA modules and environment variables.  See the
              "Setting MCA parameters and environment variables from file" section, below.

       For debugging:

       <b>-debug</b>, <b>--debug</b>
              Invoke the user-level debugger indicated by the <u>orte_base_user_debugger</u> MCA parameter.

       <b>--get-stack-traces</b>
              When paired with the <b>--timeout</b> option, <u>mpirun</u> will obtain and print  out  stack  traces  from  all
              launched  processes  that  are  still  alive  when the timeout expires.  Note that obtaining stack
              traces can take a little time and produce a lot of  output,  especially  for  large  process-count
              jobs.

       <b>-debugger</b>, <b>--debugger</b> &lt;args&gt;
              Sequence   of   debuggers   to   search   for   when   <u>--debug</u>   is  used  (i.e.   a  synonym  for
              <u>orte_base_user_debugger</u> MCA parameter).

       <b>--timeout</b> &lt;seconds&gt;
              The maximum number of seconds that <u>mpirun</u> (also known as <u>mpiexec</u>,  <u>oshrun</u>,  <u>orterun</u>,  etc.)   will
              run.   After  this  many seconds, <u>mpirun</u> will abort the launched job and exit with a non-zero exit
              status.  Using <b>--timeout</b> can be also useful when combined with the <b>--get-stack-traces</b> option.

       <b>-tv</b>, <b>--tv</b>
              Launch processes under the TotalView debugger.  Deprecated backwards compatibility  flag.  Synonym
              for <u>--debug</u>.

       There are also other options:

       <b>--allow-run-as-root</b>
              Allow  <u>mpirun</u>  to run when executed by the root user (<u>mpirun</u> defaults to aborting when launched as
              the root user).  Be sure to see the <u>Running</u> <u>as</u> <u>root</u> section, below, for more detail.

       <b>--app</b> &lt;appfile&gt;
              Provide an appfile, ignoring all other command line options.

       <b>-cf</b>, <b>--cartofile</b> &lt;cartofile&gt;
              Provide a cartography file.

       <b>-continuous</b>, <b>--continuous</b>
              Job is to run until explicitly terminated.

       <b>-disable-recovery</b>, <b>--disable-recovery</b>
              Disable recovery (resets all recovery options to off).

       <b>-do-not-launch</b>, <b>--do-not-launch</b>
              Perform all necessary operations to prepare to launch the application, but do not actually  launch
              it.

       <b>-do-not-resolve</b>, <b>--do-not-resolve</b>
              Do not attempt to resolve interfaces.

       <b>-enable-recovery</b>, <b>--enable-recovery</b>
              Enable recovery from process failure [Default = disabled].

       <b>-index-argv-by-rank</b>, <b>--index-argv-by-rank</b>
              Uniquely index argv[0] for each process using its rank.

       <b>-leave-session-attached</b>, <b>--leave-session-attached</b>
              Do  not  detach  OmpiRTE  daemons  used  by  this application. This allows error messages from the
              daemons as well as the underlying environment (e.g., when  failing  to  launch  a  daemon)  to  be
              output.

       <b>-max-restarts</b>, <b>--max-restarts</b> &lt;num&gt;
              Max number of times to restart a failed process.

       <b>-ompi-server</b>, <b>--ompi-server</b> &lt;uri or file&gt;
              Specify  the  URI of the Open MPI server (or the mpirun to be used as the server), the name of the
              file (specified as file:filename) that contains that info, or the PID (specified as pid:#) of  the
              mpirun  to  be  used as the server.  The Open MPI server is used to support multi-application data
              exchange via the MPI-2 MPI_Publish_name and MPI_Lookup_name functions.

       <b>-personality</b>, <b>--personality</b> &lt;list&gt;
              Comma-separated list of programming model, languages, and containers being used (default="ompi").

       <b>--ppr</b> &lt;list&gt;
              Comma-separated list of number of processes on a given resource type [default: none].

       <b>-report-child-jobs-separately</b>, <b>--report-child-jobs-separately</b>
              Return the exit status of the primary job only.

       <b>-report-events</b>, <b>--report-events</b> &lt;URI&gt;
              Report events to a tool listening at the specified URI.

       <b>-report-pid</b>, <b>--report-pid</b> &lt;channel&gt;
              Print out mpirun's PID during startup. The channel must be either a '-' to indicate that  the  pid
              is to be output to stdout, a '+' to indicate that the pid is to be output to stderr, or a filename
              to which the pid is to be written.

       <b>-report-uri</b>, <b>--report-uri</b> &lt;channel&gt;
              Print  out  mpirun's URI during startup. The channel must be either a '-' to indicate that the URI
              is to be output to stdout, a '+' to indicate that the URI is to be output to stderr, or a filename
              to which the URI is to be written.

       <b>-show-progress</b>, <b>--show-progress</b>
              Output a brief periodic report on launch progress.

       <b>-terminate</b>, <b>--terminate</b>
              Terminate the DVM.

       <b>-use-hwthread-cpus</b>, <b>--use-hwthread-cpus</b>
              Use hardware threads as independent CPUs.

              Note that if a number of slots is not provided to Open MPI (e.g., via the  "slots"  keyword  in  a
              hostfile  or  from  a  resource manager such as SLURM), the use of this option changes the default
              calculation of number of slots on a node.  See "DEFINITION OF 'SLOT'", above.

              Also note that the use of this option changes the Open MPI's definition of a  "processor  element"
              from a processor core to a hardware thread.  See "DEFINITION OF 'PROCESSOR ELEMENT'", above.

       <b>-use-regexp</b>, <b>--use-regexp</b>
              Use regular expressions for launch.

       The  following  options  are useful for developers; they are not generally useful to most ORTE and/or MPI
       users:

       <b>-d</b>, <b>--debug-devel</b>
              Enable debugging of the OmpiRTE (the run-time layer in Open MPI).  This is  not  generally  useful
              for most users.

       <b>--debug-daemons</b>
              Enable debugging of any OmpiRTE daemons used by this application.

       <b>--debug-daemons-file</b>
              Enable debugging of any OmpiRTE daemons used by this application, storing output in files.

       <b>-display-devel-allocation</b>, <b>--display-devel-allocation</b>
              Display a detailed list of the allocation being used by this job.

       <b>-display-devel-map</b>, <b>--display-devel-map</b>
              Display a more detailed table showing the mapped location of each process prior to launch.

       <b>-display-diffable-map</b>, <b>--display-diffable-map</b>
              Display a diffable process map just before launch.

       <b>-display-topo</b>, <b>--display-topo</b>
              Display the topology as part of the process map just before launch.

       <b>-launch-agent</b>, <b>--launch-agent</b>
              Name  of  the executable that is to be used to start processes on the remote nodes. The default is
              "orted". This option can be used to test new daemon concepts, or  to  pass  options  back  to  the
              daemons  without  having  mpirun  itself see them. For example, specifying a launch agent of orted
              -mca odls_base_verbose 5 allows the developer to  ask  the  orted  for  debugging  output  without
              clutter from mpirun itself.

       <b>--report-state-on-timeout</b>
              When  paired  with  the <b>--timeout</b> command line option, report the run-time subsystem state of each
              process when the timeout expires.

       There may be other options listed with <u>mpirun</u> <u>--help</u>.

   <b>Environment</b> <b>Variables</b>
       <b>MPIEXEC_TIMEOUT</b>
              Synonym for the <b>--timeout</b> command line option.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       One invocation of <u>mpirun</u> starts an MPI application running under Open MPI. If the application  is  single
       process multiple data (SPMD), the application can be specified on the <u>mpirun</u> command line.

       If the application is multiple instruction multiple data (MIMD), comprising of multiple programs, the set
       of  programs  and  argument  can  be  specified  in one of two ways: Extended Command Line Arguments, and
       Application Context.

       An application context describes the MIMD program set including all arguments in a separate  file.   This
       file  essentially  contains  multiple <u>mpirun</u> command lines, less the command name itself.  The ability to
       specify different options for different  instantiations  of  a  program  is  another  reason  to  use  an
       application context.

       Extended  command  line arguments allow for the description of the application layout on the command line
       using colons (<u>:</u>) to separate the specification of programs and arguments. Some options are  globally  set
       across  all  specified  programs  (e.g.  --hostfile), while others are specific to a single program (e.g.
       -np).

   <b>Specifying</b> <b>Host</b> <b>Nodes</b>
       Host nodes can be identified on the <u>mpirun</u> command line with the <u>-host</u> option or in a hostfile.

       For example,

       mpirun -H aa,aa,bb ./a.out
           launches two processes on node aa and one on bb.

       Or, consider the hostfile

          <b>%</b> cat myhostfile
          aa slots=2
          bb slots=2
          cc slots=2

       Here, we list both the host names (aa, bb, and cc) but also how many slots there are for each.

       mpirun -hostfile myhostfile ./a.out
           will launch two processes on each of the three nodes.

       mpirun -hostfile myhostfile -host aa ./a.out
           will launch two processes, both on node aa.

       mpirun -hostfile myhostfile -host dd ./a.out
           will find no hosts to run on and abort with an error.  That is, the specified host dd is not  in  the
           specified hostfile.

       When running under resource managers (e.g., SLURM, Torque, etc.), Open MPI will obtain both the hostnames
       and the number of slots directly from the resource manger.

   <b>Specifying</b> <b>Number</b> <b>of</b> <b>Processes</b>
       As  we  have  just  seen, the number of processes to run can be set using the hostfile.  Other mechanisms
       exist.

       The number of processes launched can be specified as a multiple of  the  number  of  nodes  or  processor
       sockets available.  For example,

       mpirun -H aa,bb -npersocket 2 ./a.out
           launches  processes  0-3  on node aa and process 4-7 on node bb, where aa and bb are both dual-socket
           nodes.  The <u>-npersocket</u> option also turns on the <u>-bind-to-socket</u> option,  which  is  discussed  in  a
           later section.

       mpirun -H aa,bb -npernode 2 ./a.out
           launches processes 0-1 on node aa and processes 2-3 on node bb.

       mpirun -H aa,bb -npernode 1 ./a.out
           launches one process per host node.

       mpirun -H aa,bb -pernode ./a.out
           is the same as <u>-npernode</u> 1.

       Another alternative is to specify the number of processes with the <u>-np</u> option.  Consider now the hostfile

          <b>%</b> cat myhostfile
          aa slots=4
          bb slots=4
          cc slots=4

       Now,

       mpirun -hostfile myhostfile -np 6 ./a.out
           will  launch  processes  0-3  on  node  aa  and processes 4-5 on node bb.  The remaining slots in the
           hostfile will not be used since the <u>-np</u> option indicated that only 6 processes should be launched.

   <b>Mapping</b> <b>Processes</b> <b>to</b> <b>Nodes:</b> <b>Using</b> <b>Policies</b>
       The examples above illustrate the default mapping of process processes to nodes.  This mapping  can  also
       be controlled with various <u>mpirun</u> options that describe mapping policies.

       Consider the same hostfile as above, again with <u>-np</u> 6:

                                 node aa      node bb      node cc

         mpirun                  0 1 2 3      4 5

         mpirun --map-by node    0 3          1 4          2 5

         mpirun -nolocal                      0 1 2 3      4 5

       The  <u>--map-by</u>  <u>node</u>  option  will  load  balance the processes across the available nodes, numbering each
       process in a round-robin fashion.

       The <u>-nolocal</u> option prevents any processes from being mapped onto the local host (in this case node  aa).
       While  <u>mpirun</u>  typically  consumes few system resources, <u>-nolocal</u> can be helpful for launching very large
       jobs where <u>mpirun</u> may actually need to use noticeable amounts of memory and/or processing time.

       Just as <u>-np</u> can specify fewer processes than there are slots, it can also oversubscribe the  slots.   For
       example, with the same hostfile:

       mpirun -hostfile myhostfile -np 14 ./a.out
           will  launch processes 0-3 on node aa, 4-7 on bb, and 8-11 on cc.  It will then add the remaining two
           processes to whichever nodes it chooses.

       One can also specify limits to oversubscription.  For example, with the same hostfile:

       mpirun -hostfile myhostfile -np 14 -nooversubscribe ./a.out
           will produce an error since <u>-nooversubscribe</u> prevents oversubscription.

       Limits to oversubscription can also be specified in the hostfile itself:
        % cat myhostfile
        aa slots=4 max_slots=4
        bb         max_slots=4
        cc slots=4

       The <u>max_slots</u> field specifies such a limit.  When it does, the <u>slots</u> value defaults to the limit.  Now:

       mpirun -hostfile myhostfile -np 14 ./a.out
           causes the first 12 processes to be launched as before, but  the  remaining  two  processes  will  be
           forced  onto  node cc.  The other two nodes are protected by the hostfile against oversubscription by
           this job.

       Using the <u>--nooversubscribe</u> option can be helpful since Open  MPI  currently  does  not  get  "max_slots"
       values from the resource manager.

       Of course, <u>-np</u> can also be used with the <u>-H</u> or <u>-host</u> option.  For example,

       mpirun -H aa,bb -np 8 ./a.out
           launches  8 processes.  Since only two hosts are specified, after the first two processes are mapped,
           one to aa and one to bb, the remaining processes oversubscribe the specified hosts.

       And here is a MIMD example:

       mpirun -H aa -np 1 hostname : -H bb,cc -np 2 uptime
           will launch process 0 running <u>hostname</u> on node aa and processes 1 and 2 each running <u>uptime</u> on  nodes
           bb and cc, respectively.

   <b>Mapping,</b> <b>Ranking,</b> <b>and</b> <b>Binding:</b> <b>Oh</b> <b>My!</b>
       Open MPI employs a three-phase procedure for assigning process locations and ranks:

       <b>mapping</b>   Assigns a default location to each process

       <b>ranking</b>   Assigns an MPI_COMM_WORLD rank value to each process

       <b>binding</b>   Constrains each process to run on specific processors

       The <u>mapping</u> step is used to assign a default location to each process based on the mapper being employed.
       Mapping  by slot, node, and sequentially results in the assignment of the processes to the node level. In
       contrast, mapping by object, allows the mapper to assign the process to an actual object on each node.

       <b>Note:</b> the location assigned to the process is independent of where it will be bound - the  assignment  is
       used solely as input to the binding algorithm.

       The  mapping  of  process  processes  to nodes can be defined not just with general policies but also, if
       necessary, using arbitrary mappings that cannot be described  by  a  simple  policy.   One  can  use  the
       "sequential  mapper,"  which  reads  the  hostfile line by line, assigning processes to nodes in whatever
       order the hostfile specifies.  Use the <u>-mca</u> <u>rmaps</u> <u>seq</u> option.  For example, using the  same  hostfile  as
       before:

       mpirun -hostfile myhostfile -mca rmaps seq ./a.out

       will  launch  three  processes, one on each of nodes aa, bb, and cc, respectively.  The slot counts don't
       matter;  one process is launched per line on whatever node is listed on the line.

       Another way to specify arbitrary mappings is with a rankfile,  which  gives  you  detailed  control  over
       process binding as well.  Rankfiles are discussed below.

       The  second  phase  focuses  on  the  <u>ranking</u>  of  the process within the job's MPI_COMM_WORLD.  Open MPI
       separates this from the mapping procedure to allow more flexibility in  the  relative  placement  of  MPI
       processes.  This  is  best  illustrated  by considering the following two cases where we used the —map-by
       ppr:2:socket option:

                                 node aa       node bb

           rank-by core         0 1 ! 2 3     4 5 ! 6 7

          rank-by socket        0 2 ! 1 3     4 6 ! 5 7

          rank-by socket:span   0 4 ! 1 5     2 6 ! 3 7

       Ranking by core and by slot provide the identical result - a simple progression of  MPI_COMM_WORLD  ranks
       across  each node. Ranking by socket does a round-robin ranking within each node until all processes have
       been assigned an MCW rank, and then progresses to the next node. Adding the <u>span</u> modifier to the  ranking
       directive  causes the ranking algorithm to treat the entire allocation as a single entity - thus, the MCW
       ranks are assigned across all sockets before circling back around to the beginning.

       The <u>binding</u> phase actually binds each process to a given set of processors. This can improve  performance
       if  the  operating  system  is  placing processes suboptimally.  For example, it might oversubscribe some
       multi-core  processor  sockets,  leaving  other  sockets  idle;   this  can  lead  processes  to  contend
       unnecessarily  for  common  resources.   Or,  it  might  spread  processes  out  too widely;  this can be
       suboptimal if application performance is sensitive to interprocess communication costs.  Binding can also
       keep the operating system from  migrating  processes  excessively,  regardless  of  how  optimally  those
       processes were placed to begin with.

       The processors to be used for binding can be identified in terms of topological groupings - e.g., binding
       to an l3cache will bind each process to all processors within the scope of a single L3 cache within their
       assigned  location.  Thus,  if  a  process is assigned by the mapper to a certain socket, then a <u>—bind-to</u>
       <u>l3cache</u> directive will cause the process to be bound to the processors  that  share  a  single  L3  cache
       within that socket.

       Alternatively,  processes  can  be  assigned  to processors based on their local rank on a node using the
       <u>--bind-to</u> <u>cpu-list:ordered</u> option with an associated <u>--cpu-list</u>  <u>"0,2,5"</u>.  In  this  example,  the  first
       process  on a node will be bound to cpu 0, the second process on the node will be bound to cpu 2, and the
       third process on the node will be bound to cpu 5. <u>--bind-to</u> will also accept <u>cpulist:ortered</u> as a synonym
       to <u>cpu-list:ordered</u>.  Note that an error will result if more processes are assigned to a node  than  cpus
       are provided.

       To  help balance loads, the binding directive uses a round-robin method when binding to levels lower than
       used in the mapper. For example, consider the case where a job is mapped to the socket  level,  and  then
       bound  to  core.  Each  socket  will  have multiple cores, so if multiple processes are mapped to a given
       socket, the binding algorithm will assign each process located to a socket to a unique core in  a  round-
       robin manner.

       Alternatively,  processes  mapped  by  l2cache  and  then bound to socket will simply be bound to all the
       processors in the socket where they are located. In this manner, users can exert  detailed  control  over
       relative MCW rank location and binding.

       Finally, <u>--report-bindings</u> can be used to report bindings.

       As  an  example,  consider  a  node with two processor sockets, each comprised of four cores, and each of
       those cores contains one hardware thread.  We run <u>mpirun</u> with <u>-np</u> <u>4</u> <u>--report-bindings</u> and  the  following
       additional options:

        % mpirun ... --map-by core --bind-to core
        [...] ... binding child [...,0] to cpus 0001
        [...] ... binding child [...,1] to cpus 0002
        [...] ... binding child [...,2] to cpus 0004
        [...] ... binding child [...,3] to cpus 0008

        % mpirun ... --map-by socket --bind-to socket
        [...] ... binding child [...,0] to socket 0 cpus 000f
        [...] ... binding child [...,1] to socket 1 cpus 00f0
        [...] ... binding child [...,2] to socket 0 cpus 000f
        [...] ... binding child [...,3] to socket 1 cpus 00f0

        % mpirun ... --map-by slot:PE=2 --bind-to core
        [...] ... binding child [...,0] to cpus 0003
        [...] ... binding child [...,1] to cpus 000c
        [...] ... binding child [...,2] to cpus 0030
        [...] ... binding child [...,3] to cpus 00c0

        % mpirun ... --bind-to none

       Here,  <u>--report-bindings</u>  shows  the binding of each process as a mask.  In the first case, the processes
       bind to successive cores as indicated by the masks 0001, 0002, 0004,  and  0008.   In  the  second  case,
       processes bind to all cores on successive sockets as indicated by the masks 000f and 00f0.  The processes
       cycle through the processor sockets in a round-robin fashion as many times as are needed.

       In the third case, the masks show us that 2 cores have been bound per process.  Specifically, the mapping
       by  slot  with  the  <u>PE=2</u> qualifier indicated that each slot (i.e., process) should consume two processor
       elements.  Since <u>--use-hwthread-cpus</u> was not specified, Open MPI defined "processor element"  as  "core",
       and  therefore  the  <u>--bind-to</u>  <u>core</u> caused each process to be bound to both of the cores to which it was
       mapped.

       In the fourth case, binding is turned off and no bindings are reported.

       Open MPI's support for process binding depends on the underlying operating  system.   Therefore,  certain
       process binding options may not be available on every system.

       Process  binding can also be set with MCA parameters.  Their usage is less convenient than that of <u>mpirun</u>
       options.  On the other hand, MCA parameters can  be  set  not  only  on  the  <u>mpirun</u>  command  line,  but
       alternatively  in  a system or user mca-params.conf file or as environment variables, as described in the
       MCA section below.  Some examples include:

           mpirun option          MCA parameter key         value

         --map-by core          rmaps_base_mapping_policy   core
         --map-by socket        rmaps_base_mapping_policy   socket
         --rank-by core         rmaps_base_ranking_policy   core
         --bind-to core         hwloc_base_binding_policy   core
         --bind-to socket       hwloc_base_binding_policy   socket
         --bind-to none         hwloc_base_binding_policy   none

   <b>Rankfiles</b>
       Rankfiles are text files that specify detailed information  about  how  individual  processes  should  be
       mapped  to  nodes, and to which processor(s) they should be bound.  Each line of a rankfile specifies the
       location of one process (for MPI jobs, the process' "rank" refers to its rank  in  MPI_COMM_WORLD).   The
       general form of each line in the rankfile is:

           rank &lt;N&gt;=&lt;hostname&gt; slot=&lt;slot list&gt;

       For example:

           $ cat myrankfile
           rank 0=aa slot=1:0-2
           rank 1=bb slot=0:0,1
           rank 2=cc slot=1-2
           $ mpirun -H aa,bb,cc,dd -rf myrankfile ./a.out

       Means that

         Rank 0 runs on node aa, bound to logical socket 1, cores 0-2.
         Rank 1 runs on node bb, bound to logical socket 0, cores 0 and 1.
         Rank 2 runs on node cc, bound to logical cores 1 and 2.

       Rankfiles  can alternatively be used to specify <u>physical</u> processor locations. In this case, the syntax is
       somewhat different. Sockets are no longer recognized, and the slot number given must be the number of the
       physical PU as most OS's do not assign a unique physical identifier to each core in  the  node.  Thus,  a
       proper physical rankfile looks something like the following:

           $ cat myphysicalrankfile
           rank 0=aa slot=1
           rank 1=bb slot=8
           rank 2=cc slot=6

       This means that

         Rank 0 will run on node aa, bound to the core that contains physical PU 1
         Rank 1 will run on node bb, bound to the core that contains physical PU 8
         Rank 2 will run on node cc, bound to the core that contains physical PU 6

       Rankfiles  are  treated as <u>logical</u> by default, and the MCA parameter rmaps_rank_file_physical must be set
       to 1 to indicate that the rankfile is to be considered as <u>physical</u>.

       The hostnames listed above are "absolute," meaning  that  actual  resolveable  hostnames  are  specified.
       However, hostnames can also be specified as "relative," meaning that they are specified in relation to an
       externally-specified  list  of  hostnames  (e.g.,  by  mpirun's  --host  argument,  a  hostfile, or a job
       scheduler).

       The "relative" specification is of the form "+n&lt;X&gt;", where X is an integer specifying the Xth hostname in
       the set of all available hostnames, indexed from 0.  For example:

           $ cat myrankfile
           rank 0=+n0 slot=1:0-2
           rank 1=+n1 slot=0:0,1
           rank 2=+n2 slot=1-2
           $ mpirun -H aa,bb,cc,dd -rf myrankfile ./a.out

       Starting with Open MPI v1.7, all socket/core slot locations are be specified as <u>logical</u> indexes (the Open
       MPI v1.6 series used <u>physical</u> indexes).  You can use tools such as HWLOC's "lstopo" to find  the  logical
       indexes of socket and cores.

   <b>Application</b> <b>Context</b> <b>or</b> <b>Executable</b> <b>Program?</b>
       To  distinguish  the  two  different  forms, <u>mpirun</u> looks on the command line for <u>--app</u> option.  If it is
       specified, then the file named on the command line is assumed to be an application context.  If it is not
       specified, then the file is assumed to be an executable program.

   <b>Locating</b> <b>Files</b>
       If no relative or absolute path is specified for a file, Open MPI will first look for files by  searching
       the  directories  specified by the <u>--path</u> option.  If there is no <u>--path</u> option set or if the file is not
       found at the <u>--path</u> location, then Open MPI will search the user's PATH environment variable  as  defined
       on the source node(s).

       If  a relative directory is specified, it must be relative to the initial working directory determined by
       the specific starter used. For example when using the rsh or ssh starters, the initial directory is $HOME
       by default. Other starters may set the initial directory  to  the  current  working  directory  from  the
       invocation of <u>mpirun</u>.

   <b>Current</b> <b>Working</b> <b>Directory</b>
       The <u>-wdir</u> mpirun option (and its synonym, <u>-wd</u>) allows the user to change to an arbitrary directory before
       the  program is invoked.  It can also be used in application context files to specify working directories
       on specific nodes and/or for specific applications.

       If the <u>-wdir</u> option appears both in a context file and on the command line, the  context  file  directory
       will override the command line value.

       If  the  <u>-wdir</u>  option is specified, Open MPI will attempt to change to the specified directory on all of
       the remote nodes. If this fails, <u>mpirun</u> will abort.

       If the <u>-wdir</u> option is <b>not</b> specified, Open MPI will send the directory name where <u>mpirun</u> was  invoked  to
       each  of  the  remote  nodes.  The  remote nodes will try to change to that directory. If they are unable
       (e.g., if the directory does not exist on that node), then  Open  MPI  will  use  the  default  directory
       determined by the starter.

       All  directory  changing  occurs before the user's program is invoked; it does not wait until <u>MPI_INIT</u> is
       called.

   <b>Standard</b> <b>I/O</b>
       Open MPI directs UNIX standard input to /dev/null on all  processes  except  the  MPI_COMM_WORLD  rank  0
       process.  The  MPI_COMM_WORLD  rank  0  process inherits standard input from <u>mpirun</u>.  <b>Note:</b> The node that
       invoked <u>mpirun</u> need not be the same as the node where the MPI_COMM_WORLD rank 0 process resides. Open MPI
       handles the redirection of <u>mpirun</u>'s standard input to the rank 0 process.

       Open MPI directs UNIX standard output and error from remote nodes to the node  that  invoked  <u>mpirun</u>  and
       prints  it  on the standard output/error of <u>mpirun</u>.  Local processes inherit the standard output/error of
       <u>mpirun</u> and transfer to it directly.

       Thus it is possible to redirect standard I/O for  Open  MPI  applications  by  using  the  typical  shell
       redirection procedure on <u>mpirun</u>.

             <b>%</b> mpirun -np 2 my_app &lt; my_input &gt; my_output

       Note that in this example <u>only</u> the MPI_COMM_WORLD rank 0 process will receive the stream from <u>my_input</u> on
       stdin.   The  stdin on all the other nodes will be tied to /dev/null.  However, the stdout from all nodes
       will be collected into the <u>my_output</u> file.

   <b>Signal</b> <b>Propagation</b>
       When orterun receives a SIGTERM and SIGINT, it will attempt  to  kill  the  entire  job  by  sending  all
       processes  in the job a SIGTERM, waiting a small number of seconds, then sending all processes in the job
       a SIGKILL.

       SIGUSR1 and SIGUSR2 signals received by orterun are propagated to all processes in the job.

       A SIGTSTOP signal to mpirun will cause a SIGSTOP signal to be sent to all  of  the  programs  started  by
       mpirun and likewise a SIGCONT signal to mpirun will cause a SIGCONT sent.

       Other signals are not currently propagated by orterun.

   <b>Process</b> <b>Termination</b> <b>/</b> <b>Signal</b> <b>Handling</b>
       During  the  run  of  an  MPI application, if any process dies abnormally (either exiting before invoking
       <u>MPI_FINALIZE</u>, or dying as the result of a signal), <u>mpirun</u> will print out an error message  and  kill  the
       rest of the MPI application.

       User  signal handlers should probably avoid trying to cleanup MPI state (Open MPI is currently not async-
       signal-safe; see <a href="../man3/MPI_Init_thread.3.html">MPI_Init_thread</a>(3) for  details  about  <u>MPI_THREAD_MULTIPLE</u>  and  thread  safety).   For
       example,  if  a  segmentation fault occurs in <u>MPI_SEND</u> (perhaps because a bad buffer was passed in) and a
       user signal handler is invoked, if this user handler attempts to invoke <u>MPI_FINALIZE</u>,  Bad  Things  could
       happen  since  Open  MPI was already "in" MPI when the error occurred.  Since <u>mpirun</u> will notice that the
       process died due to a signal, it is probably not necessary (and safest) for the user  to  only  clean  up
       non-MPI state.

   <b>Process</b> <b>Environment</b>
       Processes  in  the  MPI  application  inherit their environment from the Open RTE daemon upon the node on
       which they are running.  The environment is typically inherited from the user's shell.  On remote  nodes,
       the  exact  environment  is  determined by the boot MCA module used.  The <u>rsh</u> launch module, for example,
       uses either <u>rsh</u>/<u>ssh</u> to launch the Open RTE daemon on remote nodes, and typically executes one or more  of
       the  user's  shell-setup  files  before  launching  the Open RTE daemon.  When running dynamically linked
       applications which require the <u>LD_LIBRARY_PATH</u> environment variable to be set,  care  must  be  taken  to
       ensure that it is correctly set when booting Open MPI.

       See the "Remote Execution" section for more details.

   <b>Remote</b> <b>Execution</b>
       Open  MPI requires that the <u>PATH</u> environment variable be set to find executables on remote nodes (this is
       typically only necessary in <u>rsh</u>- or <u>ssh</u>-based environments -- batch/scheduled environments typically copy
       the current environment to the execution of remote jobs, so if the current environment  has  <u>PATH</u>  and/or
       <u>LD_LIBRARY_PATH</u> set properly, the remote nodes will also have it set properly).  If Open MPI was compiled
       with  shared  library  support, it may also be necessary to have the <u>LD_LIBRARY_PATH</u> environment variable
       set on remote nodes as  well  (especially  to  find  the  shared  libraries  required  to  run  user  MPI
       applications).

       However,  it  is  not  always  desirable  or  possible  to  edit  shell  startup files to set <u>PATH</u> and/or
       <u>LD_LIBRARY_PATH</u>.  The <u>--prefix</u> option is provided for  some  simple  configurations  where  this  is  not
       possible.

       The  <u>--prefix</u>  option  takes  a  single argument: the base directory on the remote node where Open MPI is
       installed.  Open MPI will use this directory to set the remote <u>PATH</u> and <u>LD_LIBRARY_PATH</u> before  executing
       any  Open  MPI or user applications.  This allows running Open MPI jobs without having pre-configured the
       <u>PATH</u> and <u>LD_LIBRARY_PATH</u> on the remote nodes.

       Open MPI adds the basename of the current node's "bindir" (the directory where Open MPI's executables are
       installed) to the prefix and uses that to set the <u>PATH</u> on the remote node.  Similarly, Open MPI adds  the
       basename  of  the current node's "libdir" (the directory where Open MPI's libraries are installed) to the
       prefix and uses that to set the <u>LD_LIBRARY_PATH</u> on the remote node.  For example:

       Local bindir:  /local/node/directory/bin

       Local libdir:  /local/node/directory/lib64

       If the following command line is used:

           <b>%</b> mpirun --prefix /remote/node/directory

       Open MPI will add "/remote/node/directory/bin" to the  <u>PATH</u>  and  "/remote/node/directory/lib64"  to  the
       <u>LD_LIBRARY_PATH</u> on the remote node before attempting to execute anything.

       The <u>--prefix</u> option is not sufficient if the installation paths on the remote node are different than the
       local  node  (e.g.,  if "<a href="file:/lib">/lib</a>" is used on the local node, but "<a href="file:/lib64">/lib64</a>" is used on the remote node), or if
       the installation paths are something other than a subdirectory under a common prefix.

       Note that executing <u>mpirun</u> via an absolute pathname is equivalent to specifying <u>--prefix</u> without the last
       subdirectory in the absolute pathname to <u>mpirun</u>.  For example:

           <b>%</b> /usr/local/bin/mpirun ...

       is equivalent to

           <b>%</b> mpirun --prefix <a href="file:/usr/local">/usr/local</a>

   <b>Exported</b> <b>Environment</b> <b>Variables</b>
       All environment variables that are named in the  form  OMPI_*  will  automatically  be  exported  to  new
       processes  on  the  local and remote nodes. Environmental parameters can also be set/forwarded to the new
       processes using the MCA parameter <u>mca_base_env_list</u>. The <u>-x</u> option to <u>mpirun</u> has been deprecated, but the
       syntax of the MCA param follows that prior example. While the syntax of  the  <u>-x</u>  option  and  MCA  param
       allows  the  definition  of  new variables, note that the parser for these options are currently not very
       sophisticated - it does not even understand quoted values.  Users are advised to  set  variables  in  the
       environment and use the option to export them; not to define them.

   <b>Setting</b> <b>MCA</b> <b>Parameters</b>
       The <u>-mca</u> switch allows the passing of parameters to various MCA (Modular Component Architecture) modules.
       MCA  modules  have  direct  impact on MPI programs because they allow tunable parameters to be set at run
       time (such as which BTL communication device driver to use, what parameters to pass to that BTL, etc.).

       The <u>-mca</u> switch takes two arguments: <u>&lt;key&gt;</u> and <u>&lt;value&gt;</u>.  The <u>&lt;key&gt;</u> argument generally specifies which MCA
       module will receive the value.  For example, the <u>&lt;key&gt;</u> "btl" is used to select which BTL to be  used  for
       transporting MPI messages.  The <u>&lt;value&gt;</u> argument is the value that is passed.  For example:

       mpirun -mca btl tcp,self -np 1 foo
           Tells Open MPI to use the "tcp" and "self" BTLs, and to run a single copy of "foo" an allocated node.

       mpirun -mca btl self -np 1 foo
           Tells Open MPI to use the "self" BTL, and to run a single copy of "foo" an allocated node.

       The  <u>-mca</u>  switch can be used multiple times to specify different <u>&lt;key&gt;</u> and/or <u>&lt;value&gt;</u> arguments.  If the
       same <u>&lt;key&gt;</u> is specified more than once, the <u>&lt;value&gt;</u>s are concatenated with a comma (",") separating them.

       Note that the <u>-mca</u> switch is simply a shortcut for setting environment variables.  The same effect may be
       accomplished by setting corresponding environment variables before  running  <u>mpirun</u>.   The  form  of  the
       environment variables that Open MPI sets is:

             OMPI_MCA_&lt;key&gt;=&lt;value&gt;

       Thus,  the  <u>-mca</u>  switch overrides any previously set environment variables.  The <u>-mca</u> settings similarly
       override MCA  parameters  set  in  the  $OPAL_PREFIX/etc/openmpi-mca-params.conf  or  $HOME/.openmpi/mca-
       params.conf file.

       Unknown  <u>&lt;key&gt;</u>  arguments  are  still set as environment variable -- they are not checked (by <u>mpirun</u>) for
       correctness.  Illegal or incorrect <u>&lt;value&gt;</u> arguments may or may not be reported  --  it  depends  on  the
       specific MCA module.

       To find the available component types under the MCA architecture, or to find the available parameters for
       a  specific component, use the <u>ompi_info</u> command.  See the <u><a href="../man1/ompi_info.1.html">ompi_info</a>(1)</u> man page for detailed information
       on the command.

   <b>Setting</b> <b>MCA</b> <b>parameters</b> <b>and</b> <b>environment</b> <b>variables</b> <b>from</b> <b>file.</b>
       The <u>-tune</u> command line option and its synonym <u>-mca</u> <u>mca_base_envar_file_prefix</u> allows a user  to  set  mca
       parameters and environment variables with the syntax described below.  This option requires a single file
       or list of files separated by "," to follow.

       A  valid  line  in  the  file may contain zero or many "-x", "-mca", or “--mca” arguments.  The following
       patterns are supported: -mca var val -mca var "val" -x var=val -x var.  If any argument is duplicated  in
       the file, the last value read will be used.

       MCA  parameters  and  environment  specified  on  the  command line have higher precedence than variables
       specified in the file.

   <b>Running</b> <b>as</b> <b>root</b>
       The Open MPI team strongly advises against executing <u>mpirun</u> as the root user.  MPI applications should be
       run as regular (non-root) users.

       Reflecting this advice, mpirun will refuse to run as root by default.  To override this default, you  can
       add  the  <u>--allow-run-as-root</u>  option  to  the  <u>mpirun</u>  command  line,  or  you can set the environmental
       parameters <u>OMPI_ALLOW_RUN_AS_ROOT=1</u> and <u>OMPI_ALLOW_RUN_AS_ROOT_CONFIRM=1</u>.  Note that it takes setting <u>two</u>
       environment variables to effect the same behavior as <u>--allow-run-as-root</u> in order to stress the Open  MPI
       team's  strong  advice against running as the root user.  After extended discussions with communities who
       use containers (where running as the root user is the default), there was a persistent desire to be  able
       to  enable  root  execution  of <u>mpirun</u> via an environmental control (vs. the existing <u>--allow-run-as-root</u>
       command line parameter).  The compromise of using <u>two</u> environment variables was reached: it  allows  root
       execution  via  an environmental control, but it conveys the Open MPI team's strong recomendation against
       this behavior.

   <b>Exit</b> <b>status</b>
       There is no standard definition for what <u>mpirun</u> should return  as  an  exit  status.  After  considerable
       discussion,  we  settled  on  the  following  method  for  assigning the <u>mpirun</u> exit status (note: in the
       following description, the "primary" job is the initial application started by mpirun - all jobs that are
       spawned by that job are designated "secondary" jobs):

       • if all processes in the primary job normally terminate with exit status 0, we return 0

       • if one or more processes in the primary job normally terminate with non-zero exit status, we return the
         exit status of the process with the lowest MPI_COMM_WORLD rank to have a non-zero status

       • if all processes in the primary job normally terminate with exit status 0, and one or more processes in
         a secondary job normally terminate with non-zero exit status, we (a) return  the  exit  status  of  the
         process  with  the  lowest  MPI_COMM_WORLD  rank in the lowest jobid to have a non-zero status, and (b)
         output a message summarizing the exit status of the primary and all secondary jobs.

       • if the cmd line option --report-child-jobs-separately is set, we will return -only- the exit status  of
         the  primary job. Any non-zero exit status in secondary jobs will be reported solely in a summary print
         statement.

       By default, the job will abort when any process  terminates  with  non-zero  status.  The  MCA  parameter
       "orte_abort_on_non_zero_status" can be set to "false" (or "0") to cause OMPI to not abort a job if one or
       more  processes  return  a  non-zero  status. In that situation the OMPI records and notes that processes
       exited with non-zero termination status to report the approprate exit status of <u>mpirun</u> (per bullet points
       above).

</pre><h4><b>EXAMPLES</b></h4><pre>
       Be sure also to see the examples throughout the sections above.

       mpirun -np 4 -mca btl ib,tcp,self prog1
           Run 4 copies of prog1 using the "ib", "tcp", and "self" BTL's for the transport of MPI messages.

       mpirun -np 4 -mca btl tcp,sm,self
           --mca btl_tcp_if_include eth0 prog1
           Run 4 copies of prog1 using the "tcp", "sm" and "self" BTLs for the transport of MPI  messages,  with
           TCP  using  only the eth0 interface to communicate.  Note that other BTLs have similar if_include MCA
           parameters.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u>mpirun</u> returns 0 if all processes started by <u>mpirun</u> exit after calling MPI_FINALIZE.  A non-zero value is
       returned if an internal error occurred in  mpirun,  or  one  or  more  processes  exited  before  calling
       MPI_FINALIZE.  If an internal error occurred in mpirun, the corresponding error code is returned.  In the
       event that one or more processes exit before calling MPI_FINALIZE, the return value of the MPI_COMM_WORLD
       rank  of  the  process that <u>mpirun</u> first notices died before calling MPI_FINALIZE will be returned.  Note
       that, in general, this will be the first process that died but is not guaranteed to be so.

       If the <b>--timeout</b> command line option is used and the timeout expires before the  job  completes  (thereby
       forcing  <u>mpirun</u>  to  kill the job) <u>mpirun</u> will return an exit status equivalent to the value of <b>ETIMEDOUT</b>
       (which is typically 110 on Linux and OS X systems).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/MPI_Init_thread.3.html">MPI_Init_thread</a>(3)

4.1.6                                             Sep 30, 2023                                         <u><a href="../man1/MPIRUN.1.html">MPIRUN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>