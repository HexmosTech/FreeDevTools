<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>chibi-scheme - a tiny Scheme interpreter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/chibi-scheme">chibi-scheme_0.9.1-3ubuntu0.22.04.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       chibi-scheme - a tiny Scheme interpreter

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>chibi-scheme</b> [<u>options</u>] [--] [<u>script</u> <u>argument</u> ...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>chibi-scheme</b>  is  a  sample interactive Scheme interpreter for the <u>chibi-scheme</u> library.  It serves as an
       example of how to embed <u>chibi-scheme</u> in applications, and can be useful on its own  for  writing  scripts
       and interactive development.

       When  <u>script</u>  is given, it will be loaded with SRFI-22 semantics, calling the procedure <u>main</u> (if defined)
       with a single parameter as a list of the command-line arguments, beginning with the  script  name.   This
       works as expected with shell #! semantics.

       Otherwise,  if  no  script  given  and  no  <b>-e</b> or <b>-p</b> options are present, an interactive REPL is entered,
       reading, evaluating, and then printing expressions until EOF is  reached.   The  provided  REPL  is  very
       minimal.   For  a  more  sophisticated REPL with readline support, signal handling, module management and
       smarter read/write you may want to use the (chibi repl) module.  It can be  launched  automatically  with
       <b>chibi-scheme</b> <b>-R</b>.

       For  convenience  the  default  language is the (scheme small) module which includes every library in the
       R7RS small standard, and some other dependencies.  All of this together is actually quite large, so for a
       more minimal startup language you'll want to use the <b>-x</b><u>module</u> option described  below.   The  get  mostly
       R5RS-compatible  language,  use  <b>chibi-scheme</b>  <b>-xscheme.r5rs</b>,  or  to get just the core language used for
       bootstrapping, use <b>chibi-scheme</b> <b>-xchibi</b> (or its shortcut <b>chibi-scheme</b> <b>-q</b>).

</pre><h4><b>OPTIONS</b></h4><pre>
       Space is optional between options and their arguments.  Options without  arguments  <u>may</u>  <u>not</u>  be  chained
       together.

       To  reduce  the  need for shell escapes, options with module arguments (<b>-m</b>, <b>-x</b> and <b>-R</b>) are written in dot
       notation.  That is, spell module name (<u>foo</u> <u>bar</u>) as <u>foo.bar</u> on the command line.

       <b>-V</b>     Print the version information and exit immediately.

       <b>-q</b>     "Quick" load, a shortcut for <b>chibi-scheme</b> <b>-xchibi</b>.  This is slightly different from (scheme  base)
              -- which may load faster -- and is guaranteed to not load any additional shared libraries.

       <b>-Q</b>     "Extra quick" load, a shortcut for <b>chibi-scheme</b> <b>-xchibi.primitive</b>.  The resulting environment will
              only  contain  the  core  syntactic  forms  and  primitives  coded in C.  This is very fast and is
              guaranteed to not load any external files, but is also very limited.

       <b>-r</b>[<u>main</u>]
              Run the "main" procedure when the script finishes loading as in SRFI-22.

       <b>-R</b>[<u>module</u>]
              Load the given module and run the "main" procedure it defines (which need not be exported) with  a
              single  argument  of  the  list  of  command-line arguments as in SRFI-22.  The name "main" can be
              overridden with the <b>-r</b> option.  <u>module</u> may be omitted, in which case it defaults to  "chibi.repl".
              Thus <b>chibi-scheme</b> <b>-R</b> is the recommended way to get an advanced REPL.

       <b>-s</b>     Strict mode, treating warnings as fatal errors.

       <b>-f</b>     Enable case-folding of symbols by the reader as in R5RS.

       <b>-T</b>     Disable tail-call optimization.  This can be useful for debugging in some cases, but also makes it
              very easy to overflow the stack.

       <b>-h</b><u>size</u>[/<u>max_size</u>]
              Specify  the  initial  size of the heap in bytes, optionally followed by the maximum size the heap
              can grow up to.  <u>size</u> can be any integer value, optionally suffixed with "K"  for  kilobytes,  "M"
              for megabytes, or "G" for gigabytes (all powers of 1024).  <b>-h</b> must be specified before any options
              which load or evaluate Scheme code.

       <b>-I</b><u>path</u> Insert <u>path</u> in front of the load path list.

       <b>-A</b><u>path</u> Append <u>path</u> to the load path list.

       <b>-D</b><u>feature</u>
              Add <u>feature</u> to the feature list, useful for cond-expanding different library code.

       <b>-m</b><u>module</u>

       <b>-x</b><u>module</u>
              Import  <u>module</u>  as  if  "(import  <u>module</u>)" were evaluated.  If the <b>-x</b> version is used, then <u>module</u>
              replaces the current environment instead of extending it.

       <b>-l</b><u>file</u> Load Scheme code from <u>file</u> searched for in the default load path.

       <b>-e</b><u>expr</u> Evaluate Scheme expression <u>expr</u>.

       <b>-p</b><u>expr</u> Evaluate Scheme expression <u>expr</u> and print the result to stdout.

       <b>-t</b><u>module.id</u>
              Enable tracing for the given identifier <u>id</u> in <u>module</u>.

       <b>-d</b><u>image-file</u>
              Dump the current Scheme heap to <u>image-file</u> and exit.

              This feature is experimental.

       <b>-i</b><u>image-file</u>
              Load the Scheme heap from <u>image-file</u> instead of compiling the init file on the fly.

              This feature is experimental.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>CHIBI_MODULE_PATH</b>
              A colon-separated list of directories to search for  module  files,  inserted  before  the  system
              default load paths.  <b>chibi-scheme</b> searches for modules in directories in the following order:

              •   directories specified with the <b>-I</b> path option

              •   directories from CHIBI_MODULE_PATH

              •   system default directories

              •   directories specified with the <b>-A</b> path option

              If  CHIBI_MODULE_PATH  is  not  set,  directories  ".<a href="file:/lib">/lib</a>"  and "." are searched before the system
              defaults (in that order).

</pre><h4><b>AUTHORS</b></h4><pre>
       Alex Shinn

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Please report bugs on Github.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/chibi-doc.1.html">chibi-doc</a></b>(1) <b><a href="../man1/chibi-ffi.1.html">chibi-ffi</a></b>(1) <b><a href="../man1/snow-chibi.1.html">snow-chibi</a></b>(1)

0.9 (fluorine)                                     2020-08-08                                    <u><a href="../man1/CHIBI-SCHEME.1.html">CHIBI-SCHEME</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>