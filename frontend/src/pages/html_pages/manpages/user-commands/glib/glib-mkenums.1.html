<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>glib-mkenums - C language enum description generation utility</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libgio-2.0-dev-bin">libgio-2.0-dev-bin_2.84.1-1ubuntu0.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       glib-mkenums - C language enum description generation utility

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>glib-mkenums</b> [OPTION…] [FILE…]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>glib-mkenums</b>  is  a  small  utility  that  parses  C  code  to extract enum definitions and produces enum
       descriptions based on text templates specified by the user. Typically, you can use this tool to  generate
       enumeration types for the GType type system, for GObject properties and signal marshalling; additionally,
       you can use it to generate enumeration values of GSettings schemas.

       <b>glib-mkenums</b>  takes  a  list  of valid C code files as input. The options specified control the text that
       generated, substituting various keywords enclosed in <b>@</b> characters in the templates.

       Since version 2.74, GLib provides the <b>G_DEFINE_ENUM_TYPE</b> and <b>G_DEFINE_FLAGS_TYPE</b> C pre-processor  macros.
       These  macros  can  be used to define a GType for projects that have few, small enumeration types without
       going through the complexities of generating code at build time.

   <b>PRODUCTION</b> <b>TEXT</b> <b>SUBSTITUTIONS</b>
       Certain keywords enclosed in <b>@</b> characters will be substituted in the emitted text. For  the  substitution
       examples of the keywords below, the following example enum definition is assumed:

          typedef enum
          {
            PREFIX_THE_XVALUE    = 1 &lt;&lt; 3,
            PREFIX_ANOTHER_VALUE = 1 &lt;&lt; 4
          } PrefixTheXEnum;

       <b>@EnumName@</b>
          The  name  of the enum currently being processed, enum names are assumed to be properly namespaced and
          to use mixed capitalization to separate words (e.g. <b>PrefixTheXEnum</b>).

       <b>@enum_name@</b>
          The enum name with words lowercase and word-separated by underscores (e.g. <b>prefix_the_xenum</b>).

       <b>@ENUMNAME@</b>
          The enum name with words uppercase and word-separated by underscores (e.g. <b>PREFIX_THE_XENUM</b>).

       <b>@ENUMSHORT@</b>
          The enum  name  with  words  uppercase  and  word-separated  by  underscores,  prefix  stripped  (e.g.
          <b>THE_XENUM</b>).

       <b>@ENUMPREFIX@</b>
          The prefix of the enum name (e.g. <b>PREFIX</b>).

       <b>@VALUENAME@</b>
          The  enum value name currently being processed with words uppercase and word-separated by underscores,
          this is the assumed literal notation of enum values in the C sources (e.g. <b>PREFIX_THE_XVALUE</b>).

       <b>@valuenick@</b>
          A nick name for the enum value currently being processed,  this  is  usually  generated  by  stripping
          common  prefix  words  of  all  the  enum  values  of  the  current  enum, the words are lowercase and
          underscores are substituted by a minus (e.g. <b>the-xvalue</b>).

       <b>@valuenum@</b>
          The integer value for the  enum  value  currently  being  processed.  If  the  evaluation  fails  then
          <b>glib-mkenums</b> will exit with an error status, but this only happens if <b>@valuenum@</b> appears in your value
          production template. (Since: 2.26)

       <b>@type@</b>
          This  is  substituted  either  by  ‘enum’  or ‘flags’, depending on whether the enum value definitions
          contained bit-shift operators (e.g. <b>flags</b>).

       <b>@Type@</b>
          The same as <b>@type@</b> with the first letter capitalized (e.g. <b>Flags</b>).

       <b>@TYPE@</b>
          The same as <b>@type@</b> with all letters uppercased (e.g. <b>FLAGS</b>).

       <b>@filename@</b>
          The full path of the input file currently being processed (e.g. <b>/build/environment/project/src/foo.h</b>).

       <b>@basename@</b>
          The base name of the input file currently being processed (e.g. <b>foo.h</b>).  Typically  you  want  to  use
          <b>@basename@</b>  in  place  of  <b>@filename@</b>  in your templates, to improve the reproducibility of the build.
          (Since: 2.22)

   <b>TRIGRAPH</b> <b>EXTENSIONS</b>
       Some C comments are treated specially in the parsed enum definitions, such comments start  out  with  the
       trigraph sequence <b>/*&lt;</b> and end with the trigraph sequence <b>&gt;*/</b>.

       The following options can be specified per enum definition:

       <b>skip</b>
          Indicates this enum definition should be skipped.

       <b>flags</b>
          Indicates this enum should be treated as a flags definition.

       <b>underscore_name</b>
          Specifies   the   word   separation   used   in   the   <b>*_get_type()</b>   function.   For  instance,  <b>/*&lt;</b>
          <b>underscore_name=gnome_vfs_uri_hide_options</b> <b>&gt;*/</b>.

       <b>since</b>
          Specifies the version tag that will be used to substitute the <b>@enumsince@</b>  keyword  in  the  template,
          useful when documenting methods generated from the enums (e.g. <b>Since:</b> <b>@enumsince@</b>). (Since: 2.66)

       The following options can be specified per value definition:

       <b>skip</b>
          Indicates the value should be skipped.

       <b>nick</b>
          Specifies the otherwise auto-generated nickname.

       Examples:

          typedef enum /*&lt; skip &gt;*/
          {
            PREFIX_FOO
          } PrefixThisEnumWillBeSkipped;
          typedef enum /*&lt; flags,prefix=PREFIX,since=1.0 &gt;*/
          {
            PREFIX_THE_ZEROTH_VALUE,   /*&lt; skip &gt;*/
            PREFIX_THE_FIRST_VALUE,
            PREFIX_THE_SECOND_VALUE,
            PREFIX_THE_THIRD_VALUE,    /*&lt; nick=the-last-value &gt;*/
          } PrefixTheFlagsEnum;

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>--fhead</b> <b>&lt;TEXT&gt;</b>
          Emits <b>TEXT</b> prior to processing input files.

          You can specify this option multiple times, and the <b>TEXT</b> will be concatenated.

          When used along with a template file, <b>TEXT</b> will be prepended to the template’s <b>file-header</b> section.

       <b>--fprod</b> <b>&lt;TEXT&gt;</b>
          Emits <b>TEXT</b> every time a new input file is being processed.

          You can specify this option multiple times, and the <b>TEXT</b> will be concatenated.

          When used along with a template file, <b>TEXT</b> will be appended to the template’s <b>file-production</b> section.

       <b>--ftail</b> <b>&lt;TEXT&gt;</b>
          Emits <b>TEXT</b> after all input files have been processed.

          You can specify this option multiple times, and the <b>TEXT</b> will be concatenated.

          When used along with a template file, <b>TEXT</b> will be appended to the template’s <b>file-tail</b> section.

       <b>--eprod</b> <b>&lt;TEXT&gt;</b>
          Emits <b>TEXT</b> every time an enum is encountered in the input files.

       <b>--vhead</b> <b>&lt;TEXT&gt;</b>
          Emits <b>TEXT</b> before iterating over the set of values of an enum.

          You can specify this option multiple times, and the <b>TEXT</b> will be concatenated.

          When used along with a template file, <b>TEXT</b> will be prepended to the template’s <b>value-header</b> section.

       <b>--vprod</b> <b>&lt;TEXT&gt;</b>
          Emits <b>TEXT</b> for every value of an enum.

          You can specify this option multiple times, and the <b>TEXT</b> will be concatenated.

          When  used  along  with  a  template  file,  <b>TEXT</b>  will be appended to the template’s <b>value-production</b>
          section.

       <b>--vtail</b> <b>&lt;TEXT&gt;</b>
          Emits <b>TEXT</b> after iterating over all values of an enum.

          You can specify this option multiple times, and the <b>TEXT</b> will be concatenated.

          When used along with a template file, <b>TEXT</b> will be appended to the template’s <b>value-tail</b> section.

       <b>--comments</b> <b>&lt;TEXT&gt;</b>
          Template for auto-generated comments, the default (for C code generations) is <b>"/*</b> <b>@comment@</b> <b>*/"</b>.

       <b>--template</b> <b>&lt;FILE&gt;</b>
          Read templates from the given file. The templates are enclosed in specially-formatted C comments:

              /*** BEGIN section ***/
              /*** END section ***/

          <b>section</b>  may  be  <b>file-header</b>,  <b>file-production</b>,  <b>file-tail</b>,   <b>enumeration-production</b>,   <b>value-header</b>,
          <b>value-production</b>, <b>value-tail</b> or <b>comment</b>.

       <b>--identifier-prefix</b> <b>&lt;PREFIX&gt;</b>
          Indicates  what  portion  of  the  enum  name  should  be  interpreted  as the prefix (e.g. the <b>Gtk</b> in
          <b>GtkDirectionType</b>). Normally this will be figured out automatically, but you may need to  override  the
          default if your namespace is capitalized oddly.

       <b>--symbol-prefix</b> <b>&lt;PREFIX&gt;</b>
          Indicates  what  prefix  should  be  used to correspond to the identifier prefix in related C function
          names (e.g. the <b>gtk</b> in <b>gtk_direction_type_get_type</b>). Equivalently, this is the  lowercase  version  of
          the  prefix  component  of the enum value names (e.g. the <b>GTK</b> in <b>GTK_DIR_UP</b>). The default value is the
          identifier prefix, converted to lowercase.

       <b>--help</b>
          Print brief help and exit.

       <b>--version</b>
          Print version and exit.

       <b>--output</b> <b>&lt;FILE&gt;</b>
          Write output to <b>FILE</b> instead of stdout.

       <b>@RSPFILE</b>
          When passed as the sole argument, read and parse the actual arguments from <b>RSPFILE</b>. Useful on  systems
          with a low command-line length limit. For example, Windows has a limit of 8191 characters.

</pre><h4><b>USING</b> <b>TEMPLATES</b></h4><pre>
       Instead  of  passing the various sections of the generated file to the command line of <b>glib-mkenums</b>, it’s
       strongly recommended to use a template file, especially for generating C sources.

       A C header template file will typically look like this:

          /*** BEGIN file-header ***/
          #pragma once

          /* Include the main project header */
          #include "project.h"

          G_BEGIN_DECLS
          /*** END file-header ***/

          /*** BEGIN file-production ***/

          /* enumerations from "@basename@" */
          /*** END file-production ***/

          /*** BEGIN value-header ***/
          GType @enum_name@_get_type (void) G_GNUC_CONST;
          #define @ENUMPREFIX@_TYPE_@ENUMSHORT@ (@enum_name@_get_type ())
          /*** END value-header ***/

          /*** BEGIN file-tail ***/
          G_END_DECLS
          /*** END file-tail ***/

       A C source template file will typically look like this:

          /*** BEGIN file-header ***/
          #include "config.h"
          #include "enum-types.h"

          /*** END file-header ***/

          /*** BEGIN file-production ***/
          /* enumerations from "@basename@" */
          /*** END file-production ***/

          /*** BEGIN value-header ***/
          GType
          @enum_name@_get_type (void)
          {
            static GType static_g_@type@_type_id = 0;

            if (g_once_init_enter_pointer (&amp;static_g_@type@_type_id))
              {
                static const G@Type@Value values[] = {
          /*** END value-header ***/

          /*** BEGIN value-production ***/
                  { @VALUENAME@, "@VALUENAME@", "@valuenick@" },
          /*** END value-production ***/

          /*** BEGIN value-tail ***/
                  { 0, NULL, NULL }
                };

                GType g_@type@_type_id =
                  g_@type@_register_static (g_intern_static_string ("@EnumName@"), values);

                g_once_init_leave_pointer (&amp;static_g_@type@_type_id, g_@type@_type_id);
              }

            return static_g_@type@_type_id;
          }

          /*** END value-tail ***/

       Template files are easier to modify and update, and can be used to  generate  various  types  of  outputs
       using the same command line or tools during the build.

</pre><h4><b>USING</b> <b>GLIB-MKENUMS</b> <b>WITH</b> <b>MESON</b></h4><pre>
       Meson supports generating enumeration types using <b>glib-mkenums</b> out of the box in its <b>gnome</b> module.

       In  your <b>meson.build</b> file you will typically call the <b>gnome.mkenums_simple()</b> method to generate idiomatic
       enumeration types from a list of headers to inspect:

          project_headers = [
            'project-foo.h',
            'project-bar.h',
            'project-baz.h',
          ]

          gnome = import('gnome')
          enum_files = gnome.mkenums_simple('enum-types',
            sources: project_headers,
          )

       The <b>enum_files</b> variable will contain an array of two elements in the following order:

       1. a build target for the source file

       2. a build target for the header file

       You should use the returned objects to provide a dependency on every other build target  that  references
       the source or header file; for instance, if you are using the source to build a library:

          mainlib = library('project',
            sources: project_sources + enum_files,
            …
          )

       Additionally,  if  you  are including the generated header file inside a build target that depends on the
       library you just built, you must ensure that the internal dependency includes the generated header  as  a
       required source file:

          mainlib_dep = declare_dependency(sources: enum_files[1], link_with: mainlib)

       You should not include the generated source file as well, otherwise it will be built separately for every
       target  that  depends  on it, causing build failures. To know more about why all this is required, please
       refer to the corresponding Meson FAQ entry  &lt;https://mesonbuild.com/FAQ.html#how-do-i-tell-meson-that-my-
       sources-use-generated-headers&gt; .

       If  you  are  generating  C  header  and  source  files  that  require  special  templates,  you  can use
       <b>gnome.mkenums()</b> to provide those headers, for instance:

          enum_files = gnome.mkenums('enum-types',
            sources: project_headers,
            h_template: 'enum-types.h.in',
            c_template: 'enum-types.c.in',
            install_header: true,
          )

       For    more    information,    see     the     Meson     documentation     &lt;https://mesonbuild.com/Gnome-
       module.html#gnomegenmarshal&gt;

       for <b>gnome.mkenums()</b>.

</pre><h4><b>USING</b> <b>GLIB-MKENUMS</b> <b>WITH</b> <b>AUTOTOOLS</b></h4><pre>
       In  order  to  use  <b>glib-mkenums</b> in your project when using Autotools as the build system, you will first
       need to modify your <b>configure.ac</b> file to ensure  you  find  the  appropriate  command  using  <b>pkg-config</b>,
       similarly as to how you discover the compiler and linker flags for GLib:

          PKG_PROG_PKG_CONFIG([0.28])

          PKG_CHECK_VAR([GLIB_MKENUMS], [glib-2.0], [glib_mkenums])

       In your <b>Makefile.am</b> file you will typically use rules like these:

          # A list of headers to inspect
          project_headers = \
                  project-foo.h \
                  project-bar.h \
                  project-baz.h

          enum-types.h: $(project_headers) enum-types.h.in
                  $(AM_V_GEN)$(GLIB_MKENUMS) \
                          --template=enum-types.h.in \
                          --output=$@ \
                         $(project_headers)

          enum-types.c: $(project_headers) enum-types.c.in enum-types.h
                  $(AM_V_GEN)$(GLIB_MKENUMS) \
                          --template=enum-types.c.in \
                          --output=$@ \
                          $(project_headers)

          # Build the enum types files before every other target
          BUILT_SOURCES += enum-types.h enum-types.c
          CLEANFILES += enum-types.h enum-types.c
          EXTRA_DIST += enum-types.h.in enum-types.c.in

       In  the  example  above, we have a variable called <b>project_headers</b> where we reference all header files we
       want to inspect for generating enumeration GTypes.  In the <b>enum-types.h</b> rule we use <b>glib-mkenums</b>  with  a
       template called <b>enum-types.h.in</b> in order to generate the header file; similarly, in the <b>enum-types.c</b> rule
       we use a template called <b>enum-types.c.in</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        &lt;<a href="../man1/glib-genmarshal.1.html">glib-genmarshal</a>(1)&gt;

                                                                                                  <u>GLIB-MKENUMS</u>()
</pre>
 </div>
</div></section>
</div>
</body>
</html>