<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>perlunicook - cookbookish examples of handling Unicode in Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/perl-doc">perl-doc_5.40.1-2ubuntu0.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       perlunicook - cookbookish examples of handling Unicode in Perl

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This manpage contains short recipes demonstrating how to handle common Unicode operations in Perl, plus
       one complete program at the end. Any undeclared variables in individual recipes are assumed to have a
       previous appropriate value in them.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>‚Ñû</b> <b>0:</b> <b>Standard</b> <b>preamble</b>
       Unless otherwise notes, all examples below require this standard preamble to work correctly, with the
       "#!" adjusted to work on your system:

        #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?env">/usr/bin/env</a> perl

        use v5.36;     # or later to get "unicode_strings" feature,
                       #   plus strict, warnings
        use utf8;      # so literals and identifiers can be in UTF-8
        use warnings  qw(FATAL utf8);    # fatalize encoding glitches
        use open      qw(:std :encoding(UTF-8)); # undeclared streams in UTF-8
        use charnames qw(:full :short);  # unneeded in v5.16

       This <u>does</u> make even Unix programmers "binmode" your binary streams, or open them with ":raw", but that's
       the only way to get at them portably anyway.

       <b>WARNING</b>: "use autodie" (pre 2.26) and "use open" do not get along with each other.

   <b>‚Ñû</b> <b>1:</b> <b>Generic</b> <b>Unicode-savvy</b> <b>filter</b>
       Always decompose on the way in, then recompose on the way out.

        use Unicode::Normalize;

        while (&lt;&gt;) {
            $_ = NFD($_);   # decompose + reorder canonically
            ...
        } continue {
            print NFC($_);  # recompose (where possible) + reorder canonically
        }

   <b>‚Ñû</b> <b>2:</b> <b>Fine-tuning</b> <b>Unicode</b> <b>warnings</b>
       As of v5.14, Perl distinguishes three subclasses of UTF‚Äë8 warnings.

        use v5.14;                  # subwarnings unavailable any earlier
        no warnings "nonchar";      # the 66 forbidden non-characters
        no warnings "surrogate";    # UTF-16/CESU-8 nonsense
        no warnings "non_unicode";  # for codepoints over 0x10_FFFF

   <b>‚Ñû</b> <b>3:</b> <b>Declare</b> <b>source</b> <b>in</b> <b>utf8</b> <b>for</b> <b>identifiers</b> <b>and</b> <b>literals</b>
       Without the all-critical "use utf8" declaration, putting UTF‚Äë8 in your literals and identifiers won‚Äôt
       work right.  If you used the standard preamble just given above, this already happened.  If you did, you
       can do things like this:

        use utf8;

        my $measure   = "√Öngstr√∂m";
        my @Œºsoft     = qw( cp852 cp1251 cp1252 );
        my @·ΩëœÄ·Ω≥œÅŒºŒµŒ≥Œ±œÇ = qw( ·ΩëœÄ·Ω≥œÅ  ŒºŒµŒ≥Œ±œÇ );
        my @ÈØâ        = qw( koi8-f koi8-u koi8-r );
        my $motto     = "üë™ üíó üê™"; # FAMILY, GROWING HEART, DROMEDARY CAMEL

       If you forget "use utf8", high bytes will be misunderstood as separate characters, and nothing will work
       right.

   <b>‚Ñû</b> <b>4:</b> <b>Characters</b> <b>and</b> <b>their</b> <b>numbers</b>
       The "ord" and "chr" functions work transparently on all codepoints, not just on ASCII alone ‚Äî nor in
       fact, not even just on Unicode alone.

        # ASCII characters
        ord("A")
        <a href="../man65/chr.65.html">chr</a>(65)

        # characters from the Basic Multilingual Plane
        ord("Œ£")
        <a href="../man0x3A3/chr.0x3A3.html">chr</a>(0x3A3)

        # beyond the BMP
        ord("ùëõ")               # MATHEMATICAL ITALIC SMALL N
        <a href="../man0x1D45B/chr.0x1D45B.html">chr</a>(0x1D45B)

        # beyond Unicode! (up to MAXINT)
        ord("\x{20_0000}")
        <a href="../man0x20_0000/chr.0x20_0000.html">chr</a>(0x20_0000)

   <b>‚Ñû</b> <b>5:</b> <b>Unicode</b> <b>literals</b> <b>by</b> <b>character</b> <b>number</b>
       In an interpolated literal, whether a double-quoted string or a regex, you may specify a character by its
       number using the "\x{<u>HHHHHH</u>}" escape.

        String: "\x{3a3}"
        Regex:  /\x{3a3}/

        String: "\x{1d45b}"
        Regex:  /\x{1d45b}/

        # even non-BMP ranges in regex work fine
        /[\x{1D434}-\x{1D467}]/

   <b>‚Ñû</b> <b>6:</b> <b>Get</b> <b>character</b> <b>name</b> <b>by</b> <b>number</b>
        use charnames ();
        my $name = charnames::<a href="../man0x03A3/viacode.0x03A3.html">viacode</a>(0x03A3);

   <b>‚Ñû</b> <b>7:</b> <b>Get</b> <b>character</b> <b>number</b> <b>by</b> <b>name</b>
        use charnames ();
        my $number = charnames::vianame("GREEK CAPITAL LETTER SIGMA");

   <b>‚Ñû</b> <b>8:</b> <b>Unicode</b> <b>named</b> <b>characters</b>
       Use the "\N{<u>charname</u>}" notation to get the character by that name for use in interpolated literals
       (double-quoted strings and regexes).  In v5.16, there is an implicit

        use charnames qw(:full :short);

       But prior to v5.16, you must be explicit about which set of charnames you want.  The ":full" names are
       the official Unicode character name, alias, or sequence, which all share a namespace.

        use charnames qw(:full :short latin greek);

        "\N{MATHEMATICAL ITALIC SMALL N}"      # :full
        "\N{GREEK CAPITAL LETTER SIGMA}"       # :full

       Anything else is a Perl-specific convenience abbreviation.  Specify one or more scripts by names if you
       want short names that are script-specific.

        "\N{Greek:Sigma}"                      # :short
        "\N{ae}"                               #  latin
        "\N{epsilon}"                          #  greek

       The v5.16 release also supports a ":loose" import for loose matching of character names, which works just
       like loose matching of property names: that is, it disregards case, whitespace, and underscores:

        "\N{euro sign}"                        # :loose (from v5.16)

       Starting in v5.32, you can also use

        qr/\p{name=euro sign}/

       to get official Unicode named characters in regular expressions.  Loose matching is always done for
       these.

   <b>‚Ñû</b> <b>9:</b> <b>Unicode</b> <b>named</b> <b>sequences</b>
       These look just like character names but return multiple codepoints.  Notice the %vx vector-print
       functionality in "printf".

        use charnames qw(:full);
        my $seq = "\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}";
        printf "U+%v04X\n", $seq;
        U+0100.0300

   <b>‚Ñû</b> <b>10:</b> <b>Custom</b> <b>named</b> <b>characters</b>
       Use ":alias" to give your own lexically scoped nicknames to existing characters, or even to give unnamed
       private-use characters useful names.

        use charnames ":full", ":alias" =&gt; {
            ecute =&gt; "LATIN SMALL LETTER E WITH ACUTE",
            "APPLE LOGO" =&gt; 0xF8FF, # private use character
        };

        "\N{ecute}"
        "\N{APPLE LOGO}"

   <b>‚Ñû</b> <b>11:</b> <b>Names</b> <b>of</b> <b>CJK</b> <b>codepoints</b>
       Sinograms like ‚ÄúÊù±‰∫¨‚Äù come back with character names of "CJK UNIFIED IDEOGRAPH-6771" and "CJK UNIFIED
       IDEOGRAPH-4EAC", because their ‚Äúnames‚Äù vary.  The CPAN "Unicode::Unihan" module has a large database for
       decoding these (and a whole lot more), provided you know how to understand its output.

        # cpan -i Unicode::Unihan
        use Unicode::Unihan;
        my $str = "Êù±‰∫¨";
        my $unhan = Unicode::Unihan-&gt;new;
        for my $lang (qw(Mandarin Cantonese Korean JapaneseOn JapaneseKun)) {
            printf "CJK $str in %-12s is ", $lang;
            say $unhan-&gt;$lang($str);
        }

       prints:

        CJK Êù±‰∫¨ in Mandarin     is DONG1JING1
        CJK Êù±‰∫¨ in Cantonese    is dung1ging1
        CJK Êù±‰∫¨ in Korean       is TONGKYENG
        CJK Êù±‰∫¨ in JapaneseOn   is TOUKYOU KEI KIN
        CJK Êù±‰∫¨ in JapaneseKun  is HIGASHI AZUMAMIYAKO

       If you have a specific romanization scheme in mind, use the specific module:

        # cpan -i Lingua::JA::Romanize::Japanese
        use Lingua::JA::Romanize::Japanese;
        my $k2r = Lingua::JA::Romanize::Japanese-&gt;new;
        my $str = "Êù±‰∫¨";
        say "Japanese for $str is ", $k2r-&gt;chars($str);

       prints

        Japanese for Êù±‰∫¨ is toukyou

   <b>‚Ñû</b> <b>12:</b> <b>Explicit</b> <b>encode/decode</b>
       On rare occasion, such as a database read, you may be given encoded text you need to decode.

         use Encode qw(encode decode);

         my $chars = decode("shiftjis", $bytes, 1);
        # OR
         my $bytes = encode("MIME-Header-ISO_2022_JP", $chars, 1);

       For streams all in the same encoding, don't use encode/decode; instead set the file encoding when you
       open the file or immediately after with "binmode" as described later below.

   <b>‚Ñû</b> <b>13:</b> <b>Decode</b> <b>program</b> <b>arguments</b> <b>as</b> <b>utf8</b>
            $ perl -CA ...
        or
            $ export PERL_UNICODE=A
        or
           use Encode qw(decode);
           @ARGV = map { decode('UTF-8', $_, 1) } @ARGV;

   <b>‚Ñû</b> <b>14:</b> <b>Decode</b> <b>program</b> <b>arguments</b> <b>as</b> <b>locale</b> <b>encoding</b>
           # cpan -i Encode::Locale
           use Encode qw(locale);
           use Encode::Locale;

           # use "locale" as an arg to encode/decode
           @ARGV = map { decode(locale =&gt; $_, 1) } @ARGV;

   <b>‚Ñû</b> <b>15:</b> <b>Declare</b> <b>STD{IN,OUT,ERR}</b> <b>to</b> <b>be</b> <b>utf8</b>
       Use a command-line option, an environment variable, or else call "binmode" explicitly:

            $ perl -CS ...
        or
            $ export PERL_UNICODE=S
        or
            use open qw(:std :encoding(UTF-8));
        or
            binmode(STDIN,  ":encoding(UTF-8)");
            binmode(STDOUT, ":utf8");
            binmode(STDERR, ":utf8");

   <b>‚Ñû</b> <b>16:</b> <b>Declare</b> <b>STD{IN,OUT,ERR}</b> <b>to</b> <b>be</b> <b>in</b> <b>locale</b> <b>encoding</b>
           # cpan -i Encode::Locale
           use Encode;
           use Encode::Locale;

           # or as a stream for binmode or open
           binmode STDIN,  ":encoding(console_in)"  if -t STDIN;
           binmode STDOUT, ":encoding(console_out)" if -t STDOUT;
           binmode STDERR, ":encoding(console_out)" if -t STDERR;

   <b>‚Ñû</b> <b>17:</b> <b>Make</b> <b>file</b> <b>I/O</b> <b>default</b> <b>to</b> <b>utf8</b>
       Files opened without an encoding argument will be in UTF-8:

            $ perl -CD ...
        or
            $ export PERL_UNICODE=D
        or
            use open qw(:encoding(UTF-8));

   <b>‚Ñû</b> <b>18:</b> <b>Make</b> <b>all</b> <b>I/O</b> <b>and</b> <b>args</b> <b>default</b> <b>to</b> <b>utf8</b>
            $ perl -CSDA ...
        or
            $ export PERL_UNICODE=SDA
        or
            use open qw(:std :encoding(UTF-8));
            use Encode qw(decode);
            @ARGV = map { decode('UTF-8', $_, 1) } @ARGV;

   <b>‚Ñû</b> <b>19:</b> <b>Open</b> <b>file</b> <b>with</b> <b>specific</b> <b>encoding</b>
       Specify stream encoding.  This is the normal way to deal with encoded text, not by calling low-level
       functions.

        # input file
            open(my $in_file, "&lt; :encoding(UTF-16)", "wintext");
        OR
            open(my $in_file, "&lt;", "wintext");
            binmode($in_file, ":encoding(UTF-16)");
        THEN
            my $line = &lt;$in_file&gt;;

        # output file
            open($out_file, "&gt; :encoding(cp1252)", "wintext");
        OR
            open(my $out_file, "&gt;", "wintext");
            binmode($out_file, ":encoding(cp1252)");
        THEN
            print $out_file "some text\n";

       More layers than just the encoding can be specified here. For example, the incantation ":raw
       :encoding(UTF-16LE) :crlf" includes implicit CRLF handling.

   <b>‚Ñû</b> <b>20:</b> <b>Unicode</b> <b>casing</b>
       Unicode casing is very different from ASCII casing.

        uc("henry ‚Ö∑")  # "HENRY ‚Öß"
        uc("tsch√º√ü")   # "TSCH√úSS"  notice √ü =&gt; SS

        # both are true:
        "tsch√º√ü"  =~ /TSCH√úSS/i   # notice √ü =&gt; SS
        "Œ£·Ω∑œÉœÖœÜŒøœÇ" =~ /Œ£·øõŒ£Œ•Œ¶ŒüŒ£/i   # notice Œ£,œÉ,œÇ sameness

   <b>‚Ñû</b> <b>21:</b> <b>Unicode</b> <b>case-insensitive</b> <b>comparisons</b>
       Also available in the CPAN Unicode::CaseFold module, the new "fc" ‚Äúfoldcase‚Äù function from v5.16 grants
       access to the same Unicode casefolding as the "/i" pattern modifier has always used:

        use feature "fc"; # fc() function is from v5.16

        # sort case-insensitively
        my @sorted = sort { fc($a) cmp fc($b) } @list;

        # both are true:
        fc("tsch√º√ü")  eq fc("TSCH√úSS")
        fc("Œ£·Ω∑œÉœÖœÜŒøœÇ") eq fc("Œ£·øõŒ£Œ•Œ¶ŒüŒ£")

   <b>‚Ñû</b> <b>22:</b> <b>Match</b> <b>Unicode</b> <b>linebreak</b> <b>sequence</b> <b>in</b> <b>regex</b>
       A Unicode linebreak matches the two-character CRLF grapheme or any of seven vertical whitespace
       characters.  Good for dealing with textfiles coming from different operating systems.

        \R

        s/\R/\n/g;  # normalize all linebreaks to \n

   <b>‚Ñû</b> <b>23:</b> <b>Get</b> <b>character</b> <b>category</b>
       Find the general category of a numeric codepoint.

        use Unicode::UCD qw(charinfo);
        my $cat = <a href="../man0x3A3/charinfo.0x3A3.html">charinfo</a>(0x3A3)-&gt;{category};  # "Lu"

   <b>‚Ñû</b> <b>24:</b> <b>Disabling</b> <b>Unicode-awareness</b> <b>in</b> <b>builtin</b> <b>charclasses</b>
       Disable "\w", "\b", "\s", "\d", and the POSIX classes from working correctly on Unicode either in this
       scope, or in just one regex.

        use v5.14;
        use re "/a";

        # OR

        my($num) = $str =~ /(\d+)/a;

       Or use specific un-Unicode properties, like "\p{ahex}" and "\p{POSIX_Digit"}.  Properties still work
       normally no matter what charset modifiers ("/d /u /l /a /aa") should be effect.

   <b>‚Ñû</b> <b>25:</b> <b>Match</b> <b>Unicode</b> <b>properties</b> <b>in</b> <b>regex</b> <b>with</b> <b>\p,</b> <b>\P</b>
       These all match a single codepoint with the given property.  Use "\P" in place of "\p" to match one
       codepoint lacking that property.

        \pL, \pN, \pS, \pP, \pM, \pZ, \pC
        \p{Sk}, \p{Ps}, \p{Lt}
        \p{alpha}, \p{upper}, \p{lower}
        \p{Latin}, \p{Greek}
        \p{script_extensions=Latin}, \p{scx=Greek}
        \p{East_Asian_Width=Wide}, \p{EA=W}
        \p{Line_Break=Hyphen}, \p{LB=HY}
        \p{Numeric_Value=4}, \p{NV=4}

   <b>‚Ñû</b> <b>26:</b> <b>Custom</b> <b>character</b> <b>properties</b>
       Define at compile-time your own custom character properties for use in regexes.

        # using private-use characters
        sub In_Tengwar { "E000\tE07F\n" }

        if (/\p{In_Tengwar}/) { ... }

        # blending existing properties
        sub Is_GraecoRoman_Title {&lt;&lt;'END_OF_SET'}
        +utf8::IsLatin
        +utf8::IsGreek
        &amp;utf8::IsTitle
        END_OF_SET

        if (/\p{Is_GraecoRoman_Title}/ { ... }

   <b>‚Ñû</b> <b>27:</b> <b>Unicode</b> <b>normalization</b>
       Typically render into NFD on input and NFC on output. Using NFKC or NFKD functions improves recall on
       searches, assuming you've already done to the same text to be searched. Note that this is about much more
       than just pre- combined compatibility glyphs; it also reorders marks according to their canonical
       combining classes and weeds out singletons.

        use Unicode::Normalize;
        my $nfd  = NFD($orig);
        my $nfc  = NFC($orig);
        my $nfkd = NFKD($orig);
        my $nfkc = NFKC($orig);

   <b>‚Ñû</b> <b>28:</b> <b>Convert</b> <b>non-ASCII</b> <b>Unicode</b> <b>numerics</b>
       Unless you‚Äôve used "/a" or "/aa", "\d" matches more than ASCII digits only, but Perl‚Äôs implicit string-
       to-number conversion does not current recognize these.  Here‚Äôs how to convert such strings manually.

        use v5.14;  # needed for num() function
        use Unicode::UCD qw(num);
        my $str = "got ‚Ö´ and ‡•™‡•´‡•¨‡•≠ and ‚Öû and here";
        my @nums = ();
        while ($str =~ /(\d+|\N)/g) {  # not just ASCII!
           push @nums, num($1);
        }
        say "@nums";   #     12      4567      0.875

        use charnames qw(:full);
        my $nv = num("\N{RUMI DIGIT ONE}\N{RUMI DIGIT TWO}");

   <b>‚Ñû</b> <b>29:</b> <b>Match</b> <b>Unicode</b> <b>grapheme</b> <b>cluster</b> <b>in</b> <b>regex</b>
       Programmer-visible ‚Äúcharacters‚Äù are codepoints matched by "/./s", but user-visible ‚Äúcharacters‚Äù are
       graphemes matched by "/\X/".

        # Find vowel *plus* any combining diacritics,underlining,etc.
        my $nfd = NFD($orig);
        $nfd =~ / (?=[aeiou]) \X /xi

   <b>‚Ñû</b> <b>30:</b> <b>Extract</b> <b>by</b> <b>grapheme</b> <b>instead</b> <b>of</b> <b>by</b> <b>codepoint</b> <b>(regex)</b>
        # match and grab five first graphemes
        my($first_five) = $str =~ /^ ( \X{5} ) /x;

   <b>‚Ñû</b> <b>31:</b> <b>Extract</b> <b>by</b> <b>grapheme</b> <b>instead</b> <b>of</b> <b>by</b> <b>codepoint</b> <b>(substr)</b>
        # cpan -i Unicode::GCString
        use Unicode::GCString;
        my $gcs = Unicode::GCString-&gt;new($str);
        my $first_five = $gcs-&gt;substr(0, 5);

   <b>‚Ñû</b> <b>32:</b> <b>Reverse</b> <b>string</b> <b>by</b> <b>grapheme</b>
       Reversing by codepoint messes up diacritics, mistakenly converting "cr√®me br√ªl√©e" into "√©elÃÇurb emÃÄerc"
       instead of into "e√©l√ªrb em√®rc"; so reverse by grapheme instead.  Both these approaches work right no
       matter what normalization the string is in:

        $str = join("", reverse $str =~ /\X/g);

        # OR: cpan -i Unicode::GCString
        use Unicode::GCString;
        $str = reverse Unicode::GCString-&gt;new($str);

   <b>‚Ñû</b> <b>33:</b> <b>String</b> <b>length</b> <b>in</b> <b>graphemes</b>
       The string "br√ªl√©e" has six graphemes but up to eight codepoints.  This counts by grapheme, not by
       codepoint:

        my $str = "br√ªl√©e";
        my $count = 0;
        while ($str =~ /\X/g) { $count++ }

         # OR: cpan -i Unicode::GCString
        use Unicode::GCString;
        my $gcs = Unicode::GCString-&gt;new($str);
        my $count = $gcs-&gt;length;

   <b>‚Ñû</b> <b>34:</b> <b>Unicode</b> <b>column-width</b> <b>for</b> <b>printing</b>
       Perl‚Äôs "printf", "sprintf", and "format" think all codepoints take up 1 print column, but many take 0 or
       2.  Here to show that normalization makes no difference, we print out both forms:

        use Unicode::GCString;
        use Unicode::Normalize;

        my @words = qw/cr√®me br√ªl√©e/;
        @words = map { NFC($_), NFD($_) } @words;

        for my $str (@words) {
            my $gcs = Unicode::GCString-&gt;new($str);
            my $cols = $gcs-&gt;columns;
            my $pad = " " x (10 - $cols);
            say str, $pad, " |";
        }

       generates this to show that it pads correctly no matter the normalization:

        cr√®me      |
        creÃÄme      |
        br√ªl√©e     |
        bruÃÇleÃÅe     |

   <b>‚Ñû</b> <b>35:</b> <b>Unicode</b> <b>collation</b>
       Text sorted by numeric codepoint follows no reasonable alphabetic order; use the UCA for sorting text.

        use Unicode::Collate;
        my $col = Unicode::Collate-&gt;new();
        my @list = $col-&gt;sort(@old_list);

       See the <u>ucsort</u> program from the Unicode::Tussle CPAN module for a convenient command-line interface to
       this module.

   <b>‚Ñû</b> <b>36:</b> <b>Case-</b> <u><b>and</b></u> <b>accent-insensitive</b> <b>Unicode</b> <b>sort</b>
       Specify a collation strength of level 1 to ignore case and diacritics, only looking at the basic
       character.

        use Unicode::Collate;
        my $col = Unicode::Collate-&gt;new(level =&gt; 1);
        my @list = $col-&gt;sort(@old_list);

   <b>‚Ñû</b> <b>37:</b> <b>Unicode</b> <b>locale</b> <b>collation</b>
       Some locales have special sorting rules.

        # either use v5.12, OR: cpan -i Unicode::Collate::Locale
        use Unicode::Collate::Locale;
        my $col = Unicode::Collate::Locale-&gt;new(locale =&gt; "de__phonebook");
        my @list = $col-&gt;sort(@old_list);

       The <u>ucsort</u> program mentioned above accepts a "--locale" parameter.

   <b>‚Ñû</b> <b>38:</b> <b>Making</b> <b>"cmp"</b> <b>work</b> <b>on</b> <b>text</b> <b>instead</b> <b>of</b> <b>codepoints</b>
       Instead of this:

        @srecs = sort {
            $b-&gt;{AGE}   &lt;=&gt;  $a-&gt;{AGE}
                        ||
            $a-&gt;{NAME}  cmp  $b-&gt;{NAME}
        } @recs;

       Use this:

        my $coll = Unicode::Collate-&gt;new();
        for my $rec (@recs) {
            $rec-&gt;{NAME_key} = $coll-&gt;getSortKey( $rec-&gt;{NAME} );
        }
        @srecs = sort {
            $b-&gt;{AGE}       &lt;=&gt;  $a-&gt;{AGE}
                            ||
            $a-&gt;{NAME_key}  cmp  $b-&gt;{NAME_key}
        } @recs;

   <b>‚Ñû</b> <b>39:</b> <b>Case-</b> <u><b>and</b></u> <b>accent-insensitive</b> <b>comparisons</b>
       Use a collator object to compare Unicode text by character instead of by codepoint.

        use Unicode::Collate;
        my $es = Unicode::Collate-&gt;new(
            level =&gt; 1,
            normalization =&gt; undef
        );

         # now both are true:
        $es-&gt;eq("Garc√≠a",  "GARCIA" );
        $es-&gt;eq("M√°rquez", "MARQUEZ");

   <b>‚Ñû</b> <b>40:</b> <b>Case-</b> <u><b>and</b></u> <b>accent-insensitive</b> <b>locale</b> <b>comparisons</b>
       Same, but in a specific locale.

        my $de = Unicode::Collate::Locale-&gt;new(
                   locale =&gt; "de__phonebook",
                 );

        # now this is true:
        $de-&gt;eq("tsch√º√ü", "TSCHUESS");  # notice √º =&gt; UE, √ü =&gt; SS

   <b>‚Ñû</b> <b>41:</b> <b>Unicode</b> <b>linebreaking</b>
       Break up text into lines according to Unicode rules.

        # cpan -i Unicode::LineBreak
        use Unicode::LineBreak;
        use charnames qw(:full);

        my $para = "This is a super\N{HYPHEN}long string. " x 20;
        my $fmt = Unicode::LineBreak-&gt;new;
        print $fmt-&gt;break($para), "\n";

   <b>‚Ñû</b> <b>42:</b> <b>Unicode</b> <b>text</b> <b>in</b> <b>DBM</b> <b>hashes,</b> <b>the</b> <b>tedious</b> <b>way</b>
       Using a regular Perl string as a key or value for a DBM hash will trigger a wide character exception if
       any codepoints won‚Äôt fit into a byte.  Here‚Äôs how to manually manage the translation:

           use DB_File;
           use Encode qw(encode decode);
           tie %dbhash, "DB_File", "pathname";

        # STORE

           # assume $uni_key and $uni_value are abstract Unicode strings
           my $enc_key   = encode("UTF-8", $uni_key, 1);
           my $enc_value = encode("UTF-8", $uni_value, 1);
           $dbhash{$enc_key} = $enc_value;

        # FETCH

           # assume $uni_key holds a normal Perl string (abstract Unicode)
           my $enc_key   = encode("UTF-8", $uni_key, 1);
           my $enc_value = $dbhash{$enc_key};
           my $uni_value = decode("UTF-8", $enc_value, 1);

   <b>‚Ñû</b> <b>43:</b> <b>Unicode</b> <b>text</b> <b>in</b> <b>DBM</b> <b>hashes,</b> <b>the</b> <b>easy</b> <b>way</b>
       Here‚Äôs how to implicitly manage the translation; all encoding and decoding is done automatically, just as
       with streams that have a particular encoding attached to them:

           use DB_File;
           use DBM_Filter;

           my $dbobj = tie %dbhash, "DB_File", "pathname";
           $dbobj-&gt;Filter_Value("utf8");  # this is the magic bit

        # STORE

           # assume $uni_key and $uni_value are abstract Unicode strings
           $dbhash{$uni_key} = $uni_value;

         # FETCH

           # $uni_key holds a normal Perl string (abstract Unicode)
           my $uni_value = $dbhash{$uni_key};

   <b>‚Ñû</b> <b>44:</b> <b>PROGRAM:</b> <b>Demo</b> <b>of</b> <b>Unicode</b> <b>collation</b> <b>and</b> <b>printing</b>
       Here‚Äôs a full program showing how to make use of locale-sensitive sorting, Unicode casing, and managing
       print widths when some of the characters take up zero or two columns, not just one column each time.
       When run, the following program produces this nicely aligned output:

           Cr√®me Br√ªl√©e....... ‚Ç¨2.00
           √âclair............. ‚Ç¨1.60
           Fideu√†............. ‚Ç¨4.20
           Hamburger.......... ‚Ç¨6.00
           Jam√≥n Serrano...... ‚Ç¨4.45
           Lingui√ßa........... ‚Ç¨7.00
           P√¢t√©............... ‚Ç¨4.15
           Pears.............. ‚Ç¨2.00
           P√™ches............. ‚Ç¨2.25
           Sm√∏rbr√∏d........... ‚Ç¨5.75
           Sp√§tzle............ ‚Ç¨5.50
           Xori√ßo............. ‚Ç¨3.00
           Œì·ΩªœÅŒøœÇ.............. ‚Ç¨6.50
           ÎßâÍ±∏Î¶¨............. ‚Ç¨4.00
           „Åä„ÇÇ„Å°............. ‚Ç¨2.65
           „ÅäÂ•Ω„ÅøÁÑº„Åç......... ‚Ç¨8.00
           „Ç∑„É•„Éº„ÇØ„É™„Éº„É†..... ‚Ç¨1.85
           ÂØøÂè∏............... ‚Ç¨9.99
           ÂåÖÂ≠ê............... ‚Ç¨7.50

       Here's that program.

        #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?env">/usr/bin/env</a> perl
        # umenu - demo sorting and printing of Unicode food
        #
        # (obligatory and increasingly long preamble)
        #
        use v5.36;
        use utf8;
        use warnings  qw(FATAL utf8);    # fatalize encoding faults
        use open      qw(:std :encoding(UTF-8)); # undeclared streams in UTF-8
        use charnames qw(:full :short);  # unneeded in v5.16

        # std modules
        use Unicode::Normalize;          # std perl distro as of v5.8
        use List::Util <a href="../manmax/qw.max.html">qw</a>(max);          # std perl distro as of v5.10
        use Unicode::Collate::Locale;    # std perl distro as of v5.14

        # cpan modules
        use Unicode::GCString;           # from CPAN

        my %price = (
            "Œ≥·ΩªœÅŒøœÇ"             =&gt; 6.50, # gyros
            "pears"             =&gt; 2.00, # like um, pears
            "lingui√ßa"          =&gt; 7.00, # spicy sausage, Portuguese
            "xori√ßo"            =&gt; 3.00, # chorizo sausage, Catalan
            "hamburger"         =&gt; 6.00, # burgermeister meisterburger
            "√©clair"            =&gt; 1.60, # dessert, French
            "sm√∏rbr√∏d"          =&gt; 5.75, # sandwiches, Norwegian
            "sp√§tzle"           =&gt; 5.50, # Bayerisch noodles, little sparrows
            "ÂåÖÂ≠ê"              =&gt; 7.50, # bao1 zi5, steamed pork buns, Mandarin
            "jam√≥n serrano"     =&gt; 4.45, # country ham, Spanish
            "p√™ches"            =&gt; 2.25, # peaches, French
            "„Ç∑„É•„Éº„ÇØ„É™„Éº„É†"    =&gt; 1.85, # cream-filled pastry like eclair
            "ÎßâÍ±∏Î¶¨"            =&gt; 4.00, # makgeolli, Korean rice wine
            "ÂØøÂè∏"              =&gt; 9.99, # sushi, Japanese
            "„Åä„ÇÇ„Å°"            =&gt; 2.65, # omochi, rice cakes, Japanese
            "cr√®me br√ªl√©e"      =&gt; 2.00, # crema catalana
            "fideu√†"            =&gt; 4.20, # more noodles, Valencian
                                         # (Catalan=fideuada)
            "p√¢t√©"              =&gt; 4.15, # gooseliver paste, French
            "„ÅäÂ•Ω„ÅøÁÑº„Åç"        =&gt; 8.00, # okonomiyaki, Japanese
        );

        my $width = 5 + max map { colwidth($_) } keys %price;

        # So the Asian stuff comes out in an order that someone
        # who reads those scripts won't freak out over; the
        # CJK stuff will be in JIS X 0208 order that way.
        my $coll  = Unicode::Collate::Locale-&gt;new(locale =&gt; "ja");

        for my $item ($coll-&gt;sort(keys %price)) {
            print pad(entitle($item), $width, ".");
            printf " ‚Ç¨%.2f\n", $price{$item};
        }

        sub pad ($str, $width, $padchar) {
            return $str . ($padchar x ($width - colwidth($str)));
        }

        sub colwidth ($str) {
            return Unicode::GCString-&gt;new($str)-&gt;columns;
        }

        sub entitle ($str) {
            $str =~ s{ (?=\pL)(\S)     (\S*) }
                     { ucfirst($1) . lc($2)  }xge;
            return $str;
        }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See these manpages, some of which are CPAN modules: perlunicode, perluniprops, perlre, perlrecharclass,
       perluniintro, perlunitut, perlunifaq, PerlIO, DB_File, DBM_Filter, DBM_Filter::utf8, Encode,
       Encode::Locale, Unicode::UCD, Unicode::Normalize, Unicode::GCString, Unicode::LineBreak,
       Unicode::Collate, Unicode::Collate::Locale, Unicode::Unihan, Unicode::CaseFold, Unicode::Tussle,
       Lingua::JA::Romanize::Japanese, Lingua::ZH::Romanize::Pinyin, Lingua::KO::Romanize::Hangul.

       The Unicode::Tussle CPAN module includes many programs to help with working with Unicode, including these
       programs to fully or partly replace standard utilities: <u>tcgrep</u> instead of <u>egrep</u>, <u>uniquote</u> instead of <u>cat</u>
       <u>-v</u> or <u>hexdump</u>, <u>uniwc</u> instead of <u>wc</u>, <u>unilook</u> instead of <u>look</u>, <u>unifmt</u> instead of <u>fmt</u>, and <u>ucsort</u> instead of
       <u>sort</u>.  For exploring Unicode character names and character properties, see its <u>uniprops</u>, <u>unichars</u>, and
       <u>uninames</u> programs.  It also supplies these programs, all of which are general filters that do Unicode-y
       things: <u>unititle</u> and <u>unicaps</u>; <u>uniwide</u> and <u>uninarrow</u>; <u>unisupers</u> and <u>unisubs</u>; <u>nfd</u>, <u>nfc</u>, <u>nfkd</u>, and <u>nfkc</u>; and
       <u>uc</u>, <u>lc</u>, and <u>tc</u>.

       Finally, see the published Unicode Standard (page numbers are from version 6.0.0), including these
       specific annexes and technical reports:

       ¬ß3.13 Default Case Algorithms, page 113; ¬ß4.2  Case, pages 120‚Äì122; Case Mappings, page 166‚Äì172,
       especially Caseless Matching starting on page 170.
       UAX #44: Unicode Character Database
       UTS #18: Unicode Regular Expressions
       UAX #15: Unicode Normalization Forms
       UTS #10: Unicode Collation Algorithm
       UAX #29: Unicode Text Segmentation
       UAX #14: Unicode Line Breaking Algorithm
       UAX #11: East Asian Width

</pre><h4><b>AUTHOR</b></h4><pre>
       Tom  Christiansen  &lt;<a href="mailto:tchrist@perl.com">tchrist@perl.com</a>&gt;  wrote this, with occasional kibbitzing from Larry Wall and Jeffrey
       Friedl in the background.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       Copyright ¬© 2012 Tom Christiansen.

       This program is free software; you may redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       Most  of these examples taken from the current edition of the ‚ÄúCamel Book‚Äù; that is, from the 4·µó ∞ Edition
       of <u>Programming</u> <u>Perl</u>, Copyright ¬© 2012 Tom Christiansen &lt;et al.&gt;, 2012-02-13 by O‚ÄôReilly Media.  The  code
       itself  is  freely redistributable, and you are encouraged to transplant, fold, spindle, and mutilate any
       of the examples in this manpage however you please for inclusion  into  your  own  programs  without  any
       encumbrance whatsoever.  Acknowledgement via code comment is polite but not required.

</pre><h4><b>REVISION</b> <b>HISTORY</b></h4><pre>
       v1.0.0 ‚Äì first public release, 2012-02-27

perl v5.40.1                                       2025-04-14                                     <u><a href="../man1/PERLUNICOOK.1.html">PERLUNICOOK</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>