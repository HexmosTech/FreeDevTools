<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ssh-copy-id — use locally available keys to authorise logins on a remote machine</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/openssh-client">openssh-client_9.9p1-3ubuntu3.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ssh-copy-id — use locally available keys to authorise logins on a remote machine

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>ssh-copy-id</b>   [<b>-f</b>]   [<b>-n</b>]   [<b>-s</b>]   [<b>-x</b>]   [<b>-i</b>   [<u>identity_file</u>]]   [<b>-t</b>   <u>target_path</u>]   [<b>-F</b>   <u>ssh_config</u>]
                   [[<b>-o</b> <u>ssh_option</u>] ...] [<b>-p</b> <u>port</u>] [<u>user</u>@]<u>hostname</u>
       <b>ssh-copy-id</b> <b>-h</b> | <b>-</b>?

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>ssh-copy-id</b> is a script that uses <u><a href="../man1/ssh.1.html">ssh</a></u>(1) to log into a remote machine (presumably using a login password,
       so password authentication should be enabled, unless you've done some clever use of multiple identities).
       It assembles a list of one or more fingerprints (as described below) and tries to log in with  each  key,
       to see if any of them are already installed (of course, if you are not using <u><a href="../man1/ssh-agent.1.html">ssh-agent</a></u>(1) this may result
       in you being repeatedly prompted for pass-phrases).  It then assembles a list of those that failed to log
       in  and,  using <u><a href="../man1/ssh.1.html">ssh</a></u>(1), enables logins with those keys on the remote server.  By default it adds the keys
       by appending them to the remote user's <u><a href="file:~/.ssh/authorized_keys">~/.ssh/authorized_keys</a></u>  (creating  the  file,  and  directory,  if
       necessary).   It is also capable of detecting if the remote system is a NetScreen, and using its ‘set ssh
       pka-dsa key ...’ command instead.

       The options are as follows:

       <b>-i</b> [<u>identity_file</u>]
               Use only the key(s) contained in <u>identity_file</u> (rather than looking for identities via <u><a href="../man1/ssh-add.1.html">ssh-add</a></u>(1)
               or in the <b>default_ID_file</b>).  If the filename does not end in <u>.pub</u> this is added.  If the filename
               is omitted, the <b>default_ID_file</b> is used.

               Note that this can be used to ensure that the keys copied have the  comment  one  prefers  and/or
               extra  options  applied, by ensuring that the key file has these set as preferred before the copy
               is attempted.

       <b>-f</b>      Forced mode: doesn't check if the keys are present on the remote server.  This means that it does
               not need the private key.  Of course, this can result in more than one  copy  of  the  key  being
               installed on the remote system.

       <b>-n</b>      do  a  dry-run.   Instead  of  installing keys on the remote system simply prints the key(s) that
               would have been installed.

       <b>-s</b>      SFTP mode: usually the public keys are installed by executing commands on the remote side.   With
               this  option  the  user's  <u><a href="file:~/.ssh/authorized_keys">~/.ssh/authorized_keys</a></u>  file  will be downloaded, modified locally and
               uploaded with sftp.  This option is useful if the server has restrictions on commands  which  can
               be used on the remote side.

       <b>-t</b> <u>target_path</u>
               the path on the target system where the keys should be added (defaults to ".ssh/authorized_keys")

       <b>-p</b> <u>port</u>
               Specifies the port to connect to on the remote host.

       <b>-F</b> <u>ssh_config</u>, <b>-o</b> <u>ssh_option</u>
               These options are simply passed through untouched (with their argument) to ssh/sftp, allowing one
               to set an alternative config file, or other options, respectively.

               Rather  than  specifying  these  as  command  line  options, it is often better to use (per-host)
               settings in <u><a href="../man1/ssh.1.html">ssh</a></u>(1)'s configuration file: <u><a href="../man5/ssh_config.5.html">ssh_config</a></u>(5).

       <b>-x</b>      This option is for debugging the <b>ssh-copy-id</b> script itself.  It sets the shell's -x flag, so that
               you can see the commands being run.

       <b>-h</b>, <b>-</b>?  Print Usage summary

       Default behaviour without <b>-i</b>, is to check if ‘ssh-add -L’ provides any output, and if so those  keys  are
       used.   Note  that this results in the comment on the key being the filename that was given to <u><a href="../man1/ssh-add.1.html">ssh-add</a></u>(1)
       when the key was loaded into your <u><a href="../man1/ssh-agent.1.html">ssh-agent</a></u>(1) rather than the comment contained in that file, which is a
       bit of a shame.  Otherwise, if <u><a href="../man1/ssh-add.1.html">ssh-add</a></u>(1) provides no keys contents of the <b>default_ID_file</b> will be used.

       The <b>default_ID_file</b> is the most recent file that matches: <u><a href="file:~/.ssh/id">~/.ssh/id</a>*.pub</u>,  (excluding  those  that  match
       <u><a href="file:~/.ssh/">~/.ssh/</a>*-cert.pub</u>)  so  if  you  create  a  key that is not the one you want <b>ssh-copy-id</b> to use, just use
       <u><a href="../man1/touch.1.html">touch</a></u>(1) on your preferred key's <u>.pub</u> file to reinstate it as the most recent.

</pre><h4><b>EXAMPLES</b></h4><pre>
       If you have already installed keys from one system on a lot of remote hosts, and you then  create  a  new
       key,  on  a  new  client machine, say, it can be difficult to keep track of which systems on which you've
       installed the new key.  One way of dealing with this is to load both the new key and old key(s) into your
       <u><a href="../man1/ssh-agent.1.html">ssh-agent</a></u>(1).  Load the new key first, without the <b>-c</b> option, then load one or more  old  keys  into  the
       agent,  possibly  by  ssh-ing  to  the client machine that has that old key, using the <b>-A</b> option to allow
       agent forwarding:

             user@newclient$ ssh-add
             user@newclient$ ssh -A old.client
             user@oldl$ ssh-add -c
             ... prompt for pass-phrase ...
             user@old$ logoff
             user@newclient$ ssh someserver

       now, if the new key is installed on the server, you'll be allowed in unprompted, whereas if you only have
       the old key(s) enabled, you'll be asked for confirmation, which is your cue to log back out and run

             user@newclient$ ssh-copy-id -i someserver

       The reason you might want to specify the <b>-i</b> option in this case is to ensure  that  the  comment  on  the
       installed  key  is  the  one  from the <u>.pub</u> file, rather than just the filename that was loaded into your
       agent.  It also ensures that only the id you intended is installed, rather than all  the  keys  that  you
       have  in  your  <u><a href="../man1/ssh-agent.1.html">ssh-agent</a></u>(1).   Of  course,  you  can  specify  another  id,  or  use the contents of the
       <u><a href="../man1/ssh-agent.1.html">ssh-agent</a></u>(1) as you prefer.

       Having mentioned <u><a href="../man1/ssh-add.1.html">ssh-add</a></u>(1)'s <b>-c</b> option, you might consider using this whenever using agent forwarding to
       avoid your key being hijacked, but it is much better to instead use <u><a href="../man1/ssh.1.html">ssh</a></u>(1)'s <u>ProxyCommand</u> and <b>-W</b>  option,
       to  bounce  through  remote  servers  while  always doing direct end-to-end authentication.  This way the
       middle hop(s) don't get access to your <u><a href="../man1/ssh-agent.1.html">ssh-agent</a></u>(1).  A web search for ‘ssh proxycommand nc’ should prove
       enlightening (NB the modern approach is to use the <b>-W</b> option, rather than <u><a href="../man1/nc.1.html">nc</a></u>(1)).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/ssh.1.html">ssh</a></u>(1), <u><a href="../man1/ssh-agent.1.html">ssh-agent</a></u>(1), <u><a href="../man8/sshd.8.html">sshd</a></u>(8)

Debian                                            June 17, 2010                                   <u><a href="../man1/SSH-COPY-ID.1.html">SSH-COPY-ID</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>