<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lcalc - Compute zeros and values of L-functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/lcalc">lcalc_2.0.5-1.1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lcalc - Compute zeros and values of L-functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>lcalc</b> [<u>OPTIONS</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       lcalc  is  a  command-line program for computing the zeros and values of L-functions. Several L-functions
       are built-in, and the default is the Riemann zeta function. You can also specify your own  L-function  in
       the form of a data file that describes it; see the <b>DATA</b> <b>FILE</b> <b>FORMAT</b> section below.

</pre><h4><b>COMPUTING</b> <b>ZEROS</b></h4><pre>
       Given  an L-function (by default, the Riemann zeta), lcalc can compute its zeros using either the <u>--zeros</u>
       or <u>--zeros-interval</u> flags. For example,

       <u>$</u> <u>lcalc</u> <u>--zeros</u> <u>1000</u>

       will compute the first thousand zeros of the Riemann zeta  function,  while  checking  the  (generalized)
       Riemann  hypothesis  and  making sure that no zeros are missed. The output consists only of the imaginary
       parts of the zeros, since all of the real parts should be <u>0.5</u>.

       The (generalized) Riemann hypothesis is confirmed by comparing the number of zeros found to the main term
       in the formula for <u>N(T)</u>. The difference, <u>S(T)</u>, should be small on average.  If not,  then  missing  zeros
       are  detected and the program backtracks looking for sign changes in more refined steps. This is repeated
       until the missing zeros are found within reasonable time. Otherwise, the program exits.

       The found zeros are also verified before being output, using the explicit formula to  compare  sums  over
       the  zeros to sums over primes. The program uses this comparison to dynamically set the output precision,
       and exits if both sides do not agree to at least two  places  after  the  decimal.  More  precisely,  the
       Riemann-Weil explicit formula is checked repeatedly, as zeros are outputted. Let the non-trivial zeros of
       <u>L(s)</u> be <u>1/2</u> <u>+</u> <u>i</u> <u>gamma</u>.  Let <u>f</u> be a function of the form <u>f(x)</u> <u>=</u> <u>exp(-A(x-x_0)^2)</u>, where <u>A</u> <u>=</u> <u><a href="../man10/log.10.html">log</a>(10)/Digits</u>
       and <u>Digits</u> is the working number of digits of precision (fifteen for built in doubles), and <u>x_0</u> varies as
       explained shortly.

       Then, the sums over the zeros

                <u>-----</u>
                 <u>\</u>
                  <u>)</u>    <u>f(gamma)</u>
                 <u>/</u>
                <u>-----</u>
                <u>gamma</u>

       are  computed  in  two  ways to working precision: first using the numerically computed zeros, and second
       using the explicit formula to express the sum over zeros as a sum  over  primes  powers.  These  two  are
       compared,  and  the  program  uses  the  amount  of  agreement  between the two to help decide the output
       precision of the zeros. If the two do not agree to at least  two  digits  after  the  decimal,  then  the
       program quits.

       The  value  <u>x_0</u>  is  chosen  to coincide with a zero of <u>L(s)</u>, say <u>gamma_j</u>, but translated by <u>0.5</u> so as to
       desymmetrize the function <u>f</u>  (not  translating  would  leave  it  an  even  function,  and  it  would  be
       quadratically, rather than linearly, sensitive to inaccuracies in the zeros).

       At first, a separate test function <u>f</u> is used for each of the zeros, with <u>x_0</u> coinciding with those zeros.
       After a while, however, a new <u>f</u> is taken only once every five zeros, with <u>x_0</u> coinciding similarly.

       You can also start after the Nth zero. For example,

       <u>$</u> <u>lcalc</u> <u>--zeros</u> <u>5</u> <u>--N</u> <u>5</u>

       outputs  the  sixth  through  tenth  zeros.  Caution:  the <u>--N</u> option evaluates <u>N(T)</u> by using the formula
       involving the main term (from the Gamma factors) and <u>S(T)</u>. <u>S(T)</u> is computed by looking at the  change  of
       arg of <u>L(s)</u> as one goes from <u>1/2</u> <u>-</u> <u>iT</u> to <u>infinity</u> <u>-</u> <u>iT</u> and then up to <u>infinity</u> <u>+</u> <u>iT</u> and to <u>1/2</u> <u>+</u> <u>iT</u>. This
       can take a long time if <u>T</u> is near the ordinate of a zero. One could improve this by implementing Turing's
       method  for  finding the Nth zero (only looking at sign changes on the critical line), or by tweaking the
       starting point and suppressing a corresponding number of zeros should the program take too long, but  for
       now, only the contour integral is computed.

       A  variant  of  Turing's  method which only looks on the critical line <b>is</b> used for the <u>--zeros</u> option, to
       test that all zeros have been found. However, with regards to the <u>--N</u> option, <u>S(T)</u> is initially  computed
       via contour integration to zoom in on the Nth zero.

       If  you  aren't concerned about verifying the (generalized) Riemann hypothesis, or if you don't expect it
       to hold (for instance, if you plan to study Dirichlet series without Euler products) then you can  search
       for zeros in an "interval" using the <u>--zeros-interval</u> option. For example,

       <u>$</u> <u>lcalc</u> <u>--zeros-interval</u> <u>--x=10</u> <u>--y=100</u> <u>--stepsize=0.1</u>

       searches  for  zeros  of the Riemann zeta function in the interval from <u>1/2</u> <u>+</u> <u>10i</u> to 1/2 + 100i, checking
       for sign changes advancing in steps of size <u>0.1</u>. The first column of the output  contains  the  imaginary
       part  of  the zero, and the second column contains a quantity related to <u>S(T)</u> --- it increases roughly by
       two whenever a sign change, that is, a pair of zeros, is missed. Higher up the critical strip you  should
       use  a  smaller stepsize so as not to miss zeros. The <u>--zeros-interval</u> options makes sense if you want to
       output zeros as they are found.

       The <u>--zeros</u> option, which <b>does</b> verify the (generalized) Riemann hypothesis, looks for several dozen zeros
       to make sure none have been missed before outputting any zeros at all; as a result, it takes longer  than
       <u>--zeros-interval</u>  to  output the first few zeros. For collecting more than just a handful of zeros, or to
       make certain that no zeros have been missed, one should use the <u>--zeros</u> option.

</pre><h4><b>COMPUTING</b> <b>VALUES</b></h4><pre>
       The lcalc program can also compute the <b>values</b> of an L-function by using the <u>--value</u> flag. For example,

       <u>$</u> <u>lcalc</u> <u>--value</u> <u>--x=0.5</u> <u>--y=100</u>

       will compute the value of the (default) Riemann zeta function at the point <u>x</u> <u>+</u> <u>yi</u> <u>=</u> <u>0.5</u> <u>+</u> <u>100i</u>. Both real
       and complex parts are output, separated by a space; in this case, the output is approximately <u>2.692619886</u>
       <u>-0.0203860296</u> which represents <u>zeta(x+yi)</u> <u>=</u> <u>2.692619886</u> <u>-</u> <u>0.0203860296i</u>.

       You can also compute values along a line segment at equally spaced points:

       <u>$</u> <u>lcalc</u> <u>--value-line-segment</u> <u>--x=0.5</u> <u>--X=0.5</u> <u>--y=0</u> <u>--Y=10</u> <u>--number-samples=100</u>

       computes the values of the Riemann zeta function from <u>0.5</u> <u>+</u> <u>0i</u> through <u>0.5</u> <u>+</u> <u>100i</u> at <u>1000</u>  equally-spaced
       points.  The  output  contains  four  columns:  the  real  and  imaginary parts of the current point (two
       columns), followed by the real and imaginary parts of the function value (two columns).

</pre><h4><b>ELLIPTIC</b> <b>CURVE</b> <b>L-FUNCTIONS</b></h4><pre>
       If lcalc was built with PARI support, the <u>--elliptic-curve</u> option can be combined with the  <u>--a1</u>  through
       <u>--a6</u> flags to specify an elliptic curve L-function. For example,

       <u>$</u> <u>lcalc</u> <u>--zeros=5</u> <u>--elliptic-curve</u> <u>--a1=0</u> <u>--a2=0</u> <u>--a3=0</u> <u>--a4=0</u> <u>--a6=1</u>

       computes the first five zeros of the L-function associated with the elliptic curve <u>y^2</u> <u>=</u> <u>x^3</u> <u>+</u> <u>1</u>.

</pre><h4><b>TWISTS</b></h4><pre>
       Twists  by  Dirichlet  characters  are  currently  available  for all zeta and cusp-form L-functions. For
       example,

       <u>$</u> <u>lcalc</u> <u>--value</u> <u>--x=0.5</u> <u>--y=0</u> <u>--twist-quadratic</u> <u>--start</u> <u>-100</u> <u>--finish</u> <u>100</u>

       will output <u>L(1/2,</u> <u>chi_d)</u> for <u>d</u> between <u>-100</u> and <u>100</u>, inclusive. Other twisting  options  are  available.
       For example

       <u>$</u> <u>lcalc</u> <u>--zeros=200</u> <u>--twist-primitive</u> <u>--start</u> <u>3</u> <u>--finish</u> <u>100</u>

       gives  the  first  two-hundred  zeros  of  all  primitive  <u>L(s,chi)</u>  with  a conductor between <u>3</u> and <u>100</u>,
       inclusive.

       Notice that with the <u>--twist-quadratic</u> option one is specifying the discriminant which can  be  negative,
       while with the <u>--twist-primitive</u> option one is specifying the conductor which should be positive.

       When  using  the  various  twisting  options, other than <u>--twist-quadratic</u>, the second output column is a
       label for the character modulo <u>n</u>. It is an integer between  <u>1</u>  and  <u>phi(n)</u>.  If  one  is  restricting  to
       primitive charcters, then only a subset of these integers appear in the second column.

       One  can  obtain  a  table  of characters using the <u>--output-character</u> option. This doesn't work with the
       <u>--twist-quadratic</u> option, but does with the other twisting options.

       The <u>--output-character</u> option takes an argument of either <u>1</u> or <u>2</u>. An argument of  <u>1</u>,  for  example,  will
       print a comprehensive table of <u>chi(n)</u> for all <u>gcd(n,conductor)</u> <u>=</u> <u>1</u>.

       The characters are constructed multiplicatively in terms of generators of the cyclic groups mod the prime
       powers  that  divide <u>n</u>, and there's no simple formula to go from the label to the character. As a result,
       <u>--output-character</u> will also output a table for  each  character  before  outputting  the  zeros  of  the
       corresponding L-function (but not with the <u>--twist-quadratic</u> option).

       These tables contain six columns:

       1     the value of <u>n</u>

       2     a label for the character, an integer between <u>1</u> and <u>phi(n)</u>

       3     the conductor of the inducing character (same as the first column, if primitive).

       4     column 4: <u>m</u>, an integer that is coprime with <u>n</u>

       5     <u>Re(<a href="../manm/chi.m.html">chi</a>(m))</u>

       6     <u>Im(<a href="../manm/chi.m.html">chi</a>(m))</u>

       If,  instead, <u>--output-character=2</u> is given, then only the value of <u>chi(-1)</u> (that is, whether <u>chi</u> is even
       or odd) and whether <u>chi</u> is primitive or not will be printed.

</pre><h4><b>OPTIONS</b></h4><pre>
       For basic program usage, run

       <u>$</u> <u>lcalc</u> <u>--help</u>

       Most of lcalc's options  are  sufficiently  explained  by  its  output.  Here  we  collect  some  further
       information about specific options.

       <b>--rank-compute</b>, <b>-r</b>
              Compute  the analytic rank. Analytic rank works well even for high rank since the method used does
              not compute derivatives, but rather looks at the behaviour of the  L-function  near  the  critical
              point.

       <b>--derivative=&lt;n&gt;</b>, <b>-d</b> <b>&lt;n&gt;</b>
              Compute  the  <u>n</u>th derivative. Presently the derivative option uses numeric differentiation (taking
              linear combinations of <u>L(s</u> <u>+</u> <u>mh)</u> for integers <u>m</u>, to pull out the relevant  Taylor  coefficient  of
              <u>L(s)</u>).  To get good results with higher derivatives, one should build libLfunction/lcalc with more
              precision.

</pre><h4><b>EXAMPLES</b></h4><pre>
       • Compute the first thousand zeros of the Riemann zeta function using  the  <u>--zeros</u>  option,  and  output
         their imaginary parts (after verifying that their real parts are all one-half):

         <u>$</u> <u>lcalc</u> <u>--zeros</u> <u>1000</u>

       • Compute the value of the Riemann zeta function at <u>x</u> <u>+</u> <u>iy</u> using the --value, --x, and --y options:

         <u>$</u> <u>lcalc</u> <u>--value</u> <u>--x=0.5</u> <u>--y=14.134725141738</u>

       • Compute the first 10 zeros of the Ramanujan tau L-function using the --tau and --zeros (-z) options:

         <u>$</u> <u>lcalc</u> <u>--tau</u> <u>--zeros=10</u>

       • Compute  the  first  zero  of  the  real  quadratic Dirichlet L-function of conductor 4 after using the
         --twist-quadratic, --start, and --finish options to specify the L-function:

         <u>$</u> <u>lcalc</u> <u>--twist-quadratic</u> <u>--start=-4</u> <u>--finish=-4</u> <u>--zeros=1</u>

</pre><h4><b>DATA</b> <b>FILE</b> <b>FORMAT</b></h4><pre>
       The <u>lcalc</u> <u>-F</u> option allows you to load L-function data from a file.  Here we explain the format  of  this
       file.  Basically  it must contain the functional equation, Dirichlet coefficients, and some other helpful
       information.

       The first line should contain an integer, either <u>1</u>, <u>2</u>, or <u>3</u>: <u>1</u> specifies that the Dirichlet  coefficients
       are  to be given as integers (up to thirty-two bits long), <u>2</u> that they are floating point numbers, <u>3</u> that
       they are complex numbers. So, for example, the first line would be a 2 for cusp form  or  Maass  form  L-
       function  (we  normalize the L-functional so that the functional equation is <u>s</u> <u>&lt;-&gt;</u> <u>1-s</u>, so the normalized
       Dirichlet coefficients for a cusp form L-function are not integers).

       The second line specifies info that the calculator can exploit (or will exploit at some future date).  It
       is an integer that is assigned to different types of L-functions. Currently:

       • <u>-2</u> for <u>L(s,chi)</u> but where the number of coefficients computed is less than the period

       • <u>-1</u> for zeta

       • <u>0</u> for unknown

       • <u>1</u> for periodic, including <u>L(s,chi)</u>

       • <u>2</u> for cusp form (in <u>S_K(Gamma_0(N)</u>)

       • <u>3</u> for Maass form for <u>SL_2(Z)</u>

       • other integers reserved for future types.

         The  third  line  is  an  integer that specifies how many Dirichlet coefficients to read from the file;
         there should be at least this many Dirichlet coefficients in the file. This is  a  useful  quantity  to
         specify  sincethe data file might have, say, a million coefficients, but one might want to read in just
         ten thousand of them.

         The fourth line is either <u>0</u>, if the Dirichlet coefficients are <b>not</b>  periodic,  or  a  positive  integer
         specifying  the  period otherwise (this happens in the case of Dirichlet L-functions). For a Maass form
         it should be <u>0</u>.

         The fifth line is a positive integer, the quasi-degree. This is the number of gamma factors of the form
         <u>Gamma(gamma</u> <u>s</u> <u>+</u> <u>lambda)</u> in the functional equation, where gamma is either <u>0.5</u> or <u>1</u>,  and  lambda  is  a
         complex number with <u>Re(lambda)</u> <u>&gt;=</u> <u>0</u>. For example, it is <u>1</u> for Dirichlet L-functions, <u>1</u> for cusp form L-
         functions,  <u>2</u>  for  Maass form L-functions, etc. Note that the "1" for cusp form L-functions could be a
         "2" if you wish to split the gamma factor up using the Legendre duplication formula.  But  it's  better
         not to.

         Next  come  the  gamma  factors,  with two lines for each gamma factor. The first of each pair of lines
         contains gamma (either <u>0.5</u> or <u>1</u>), and the second  line  contains  a  pair  of  floating  point  numbers
         separated  by  a  space  specifying the real and imaginary parts of lambda (even if purely real, lambda
         should be given as a pair of numbers, the second one then being <u>0</u>).

         Next you specify the functional equation. Let

                              <u>a</u>
                           <u>--------'</u>
                          <u>'</u>  <u>|</u>  <u>|</u>
                             <u>|</u>  <u>|</u>
           <u>Lambda(s)</u> <u>=</u> <u>Q^s</u>   <u>|</u>  <u>|</u>  <u>Gamma(gamma_j*s</u> <u>+</u> <u>lambda_j)*L(s)</u>
                             <u>|</u>  <u>|</u>
                            <u>j</u> <u>=</u> <u>1</u>

         satisfy <u>Lambda(s)</u> <u>=</u> <u>omega*conj(Lambda(1-conj(s)))</u>, where <u>Q</u> is  a  real  number,  <u>omega</u>  is  complex,and
         "conj"  denotes  the complex conjugate. Notice that the functional equation is <u>s</u> into <u>1-s</u>; that is, the
         gamma factors and Dirichlet coefficients of <u>L(s)</u> should be normalized correctly so as to have  critical
         line <u>Re(s)</u> <u>=</u> <u>1/2</u>.

         The  next  line  in  the  datafile is <u>Q</u> giving as a floating point number, and the one after that gives
         omega as a pair <u>x</u> <u>y</u> of floating point numbers, specifying the real and imaginary parts of  omega  (even
         when  omega  is unity, it should be given as a pair of floating points, for example <u>1</u> <u>0</u> to indicate <u>1</u> <u>+</u>
         <u>0i</u>).

         We need to allow for the possibility of poles. For example, if <u>L(s)</u> <u>=</u> <u>zeta(s)</u> then <u>Lambda(s)</u> has simple
         poles with residue <u>1</u> at <u>s=1</u> and residue <u>-1</u> at <u>s=0</u>.  To take into account such  possibilities  I  assume
         that  Lambda(s)  has at most simple poles.  So, the next line specifies the number of poles (usually <u>0</u>)
         and then, for each pole there are two lines. The first line in each pair gives the pole <u>x+iy</u> as a  pair
         <u>x</u>  <u>y</u>  of  floating point numbers. The second line specifies the residue at that pole, also as a pair of
         floating point numbers.

         Finally the Dirichlet coefficients. The remaining lines  in  the  file  contain  a  list  of  Dirichlet
         coefficients,  at  least  as  many  as indicated in line three of the datafile. The coefficients can be
         integers, real, or complex. If complex they should, as usual, be given as a pair <u>x</u> <u>y</u> of floating  point
         numbers  separated  by a space. Otherwise they should be given as single column of integers or floating
         point numbers respectively.

         The datafile should only contain numbers and no comments. The  comments  below  are  for  the  sake  of
         understanding the structure of the datafile.

         An  example  data  file  for  the  Maass  form  for  <u>SL_2(Z)</u>  associated  to  the  eigenvalue  with <u>R</u> <u>=</u>
         <u>13.779751351891</u> is given below (beware: the Dirichlet coefficients for this particular  L-function  are
         only accurate to a handful of decimal places, especially near the tail of the file).

         <u>2</u>                    <u>the</u> <u>Dirichlet</u> <u>coefficients</u> <u>are</u> <u>real</u>
         <u>3</u>                    <u>this</u> <u>is</u> <u>a</u> <u>Maass</u> <u>form</u> <u>L-function</u>
         <u>29900</u>                <u>use</u> <u>this</u> <u>many</u> <u>of</u> <u>the</u> <u>Dirichlet</u> <u>coefficients</u>
         <u>0</u>                    <u>zero</u> <u>since</u> <u>the</u> <u>coefficients</u> <u>are</u> <u>not</u> <u>periodic</u>
         <u>2</u>                    <u>two</u> <u>gamma</u> <u>factors</u>
         <u>.5</u>                   <u>the</u> <u>first</u> <u>gamma</u> <u>factor</u>
         <u>0</u> <u>6.88987567594535</u>   <u>the</u> <u>first</u> <u>lambda</u>
         <u>.5</u>                   <u>the</u> <u>second</u> <u>gamma</u> <u>factor</u>
         <u>0</u> <u>-6.88987567594535</u>  <u>the</u> <u>second</u> <u>lambda</u>
         <u>.3183098861837906715</u> <u>the</u> <u>Q</u> <u>in</u> <u>the</u> <u>functional</u> <u>equation</u>
         <u>1</u> <u>0</u>                  <u>the</u> <u>omega</u> <u>1</u> <u>+</u> <u>0i</u> <u>in</u> <u>the</u> <u>functional</u> <u>equation</u>
         <u>0</u>                    <u>the</u> <u>number</u> <u>of</u> <u>poles</u> <u>of</u> <u>Lambda(s)</u>
         <u>1</u>                    <u>the</u> <u>first</u> <u>Dirichlet</u> <u>coefficient</u>
         <u>1.549304477941</u>       <u>the</u> <u>second</u> <u>Dirichlet</u> <u>coefficient</u>
         <u>0.246899772454</u>       <u>the</u> <u>third</u> <u>Dirichlet</u> <u>coefficient</u>
         <u>1.400344365369</u>       <u>the</u> <u>fourth</u> <u>Dirichlet</u> <u>coefficient</u>
         <u>...</u>

         Several such example data files are included with lcalc.

</pre><h4><b>BUGS</b></h4><pre>
       Report bugs to https://gitlab.com/sagemath/lcalc/issues

                                                                                                        <u><a href="../man1/lcalc.1.html">lcalc</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>