<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>makeppreplay -- Fast repeater of selected makepp actions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/makepp">makepp_2.0.98.5-2.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       makeppreplay -- Fast repeater of selected makepp actions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>?:</b> -?,  <b>A:</b> -A,
         --args-file,
         --arguments-file,  <b>C:</b> -C,
         -c,  <b>D:</b> --directory,
         --dry-run,  <b>H:</b> -h,
         --help,  <b>I:</b> -I,
         --include,
         --include-dir,  <b>J:</b> --just-print,  <b>K:</b> -k,
         --keep-going,  <b>L:</b> --log,
         --log-file,  <b>M:</b> -M,
         $MAKEPPREPLAYFLAGS,
         --module,  <b>N:</b> -n,
         --no-log,
         --no-print-directory,
         --no-warn,  <b>P:</b> --profile,  <b>R:</b> --recon,
         --root-dir,
         --root-directory,  <b>S:</b> -s,
         --sed,  <b>T:</b> -t,
         --temporary,  <b>V:</b> -V,
         --version

       <b>makeppreplay</b> [ <u>option</u> ... ] [ <u>VAR=value</u> ] [ <u>target</u> ... ]

       <b>mppr</b> [ <u>option</u> ... ] [ <u>VAR=value</u> ] [ <u>target</u> ... ]

       Makeppreplay tries to do the same things makepp did.  It does this solely based on the remembered build
       info, saving much time by not reading makefiles, not parsing commands, not scanning files and not looking
       at every repository file, to see whether it fits.  But unlike makepp it reuses all repository links it
       finds.

       It does not know about phony or default targets, so you have to give it real files or directories, as a
       shortcut for all files makepp has built therein.  By default it builds all files makepp built in the
       current or chosen directory.

       This approach is only correct when there are no structural changes, i.e. no different modules to be
       linked, no moved files, no different "#include" statements, which should possibly have caused those files
       to be (re)built.  After updating from version control, or when building against a repository, where
       others may have caused such changes, you should call makepp once after potential changes (e.g. in the
       morning after an overnight repository update), to be sure your build infos are up to date.

       Not reading makefiles means, it will not know any subs (Perl functions) defined in them.  For this you
       should put all your functions into an external module.  It will also not know about any variable
       settings, which is only a problem if your Perl code accesses them (because in rule actions they have
       already been expanded).

</pre><h4><b>TODO</b></h4><pre>
       This is still experimental and imperfect.

       •   Build up a complete dependency tree starting from the given targets and decide which of them to build
           based on their build check methods.  That requires the method to be remembered in the build info.

       •   After implementing the previous bullet item, accept more makepp opts, like "-j" or "--dont-build".

       •   Allow  build cache with implicit "--no-populate-bc" (because makeppreplay doesn't guarantee a correct
           build).  Makepp might later publish to the build cache anything it retains.

       •   Have makepp remember build info for all failed commands and for those it didn't attempt because their
           dependencies failed.  This is only partially possible, because dependencies may  only  be  found  out
           after building the files that require them.  What should happen with (a has no build info):

               a: b
               b: c
                   cmd_producing_a_and_b

</pre><h4><b>OPTIONS</b></h4><pre>
       Options include some of the makepp options, plus two new ones, for loading modules that would normally be
       loaded from a makefile.

       -A <u>filename</u>
       --args-file=<u>filename</u>
       --arguments-file=<u>filename</u>
           Read the file and parse it as possibly quoted whitespace- and/or newline-separated options.

       -C <u>directory</u>
       --directory=<u>directory</u>
           Cd  to the given directory before loading the makefile and trying to build the targets.  This is more
           or less equivalent to specifying a directory with "-F", except that subsequent "-C", "-f", "-F", "-I"
           and "-R" options are interpreted relative to the new directory, rather than the old one.

       -c
       --root-dir
       --root-directory
           Cd up to the directory containing a RootMakeppfile.

       -I <u>directory</u>
       --include=<u>directory</u>
       --include-dir=<u>directory</u>
           Add <u>directory</u> to Perl load path @INC.

       -?
       -h
       --help
           Print out a brief summary of the options.

       -k
       --keep-going
           Build as many files as possible, even if some of them have errors.  By default, makepp stops when  it
           encounters  the first error, even if there are other files that need to be built that don't depend on
           the erroneous file.

       --log=<u>logfilename</u>
       --log-file=<u>logfilename</u>
           Changes the name of the log file to  the  indicated  name.   By  default,  the  log  file  is  called
           <u>.makepp/log</u>.  This file is readable with makepplog, mppl.

       -M <u>module[=arg,...]</u>
       --module=<u>module[=arg,...]</u>
           Load module and import any functions it exports.

       -n
       --dry-run
       --just-print
       --recon
           Print out commands without actually executing them.

       --no-log
           Don't bother writing a detailed description of what was done to the log file.

       --no-print-directory
           Turn off the entering or leaving directory messages.

       --profile
           Output raw timestamps before and after each action.

       -s <u>perl-expression</u>
       --sed=<u>perl-expression</u>
           Run  the perl expression against the command before running it, like for preprocessor "-s 's/ -c / -E
           /; s/\.o\b/.i/g'".  This would transform a compilation command  ("-c")  into  a  preprocessor  ("-E")
           invocation,  changing the <u>.o</u> suffix to <u>.i</u>, which is a conventional suffix for preprocessed C.  Or you
           might want to add some debug output to your linker.  If you have only one command in  the  rule,  you
           can do this by substituting it into the first space: "-s 's/ / -Wl,-t /'".

           When  the  command  is  altered,  nothing  is  remembered about this, i.e. makepp will think you have
           manually modified the file, causing a rebuild.

           Note that (unlike makepp) makeppreplay does not parse the command, so it won't notice that the target
           filename was changed.  So you must still request the <u>.o</u> target, even though a <u>.i</u> will be built.   And
           makeppclean won't know to remove it.

       -t
       --temporary
           Makeppreplay  modifies  the  build  info  of  all  files  it touched and of all dependencies it found
           modified.  It marks them in such a way that makepp nevertheless knows that it needs to  rescan  these
           files.  But with this option you can prevent these modifications, so that makepp will simply consider
           all files makeppreplay created as incorrect.

       -V
       --version
           Print out the version number.

       --no-warn
           Don't print any warning messages.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Probably the most common use is relinking either a program or a library after editing a source file:

           makeppreplay subdir/foo.o bin/bar
           mppr subdir/foo.o lib/libbar.so

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       Makeppreplay looks at the following environment variable:

       $MAKEPPREPLAYFLAGS
           Any options you may want to always pass.

</pre><h4><b>AUTHOR</b></h4><pre>
       Daniel Pfeiffer (<a href="mailto:occitan@esperanto.org">occitan@esperanto.org</a>)

perl v5.32.0                                       2021-01-06                                    <u><a href="../man1/MAKEPPREPLAY.1.html">MAKEPPREPLAY</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>