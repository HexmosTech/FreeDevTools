<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>abidiff - compare ABIs of ELF files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/abigail-tools">abigail-tools_2.6-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       abidiff - compare ABIs of ELF files

       abidiff compares the Application Binary Interfaces (ABI) of two shared libraries in <u>ELF</u> format.  It emits
       a meaningful report describing the differences between the two ABIs.

       This  tool  can  also  compare  the textual representations of the ABI of two ELF binaries (as emitted by
       <b>abidw</b>) or an ELF binary against a textual representation of another ELF binary.

       For a comprehensive ABI change report between two input shared  libraries  that  includes  changes  about
       function  and variable sub-types, <b>abidiff</b> uses by default, debug information in <u>DWARF</u> format, if present,
       otherwise it compares interfaces using debug information in <u>CTF</u> or <u>BTF</u> formats, if present.  Finally,  if
       no debug info in these formats is found, it only considers <u>ELF</u> symbols and report about their addition or
       removal.

       This  tool uses the libabigail library to analyze the binary as well as its associated debug information.
       Here is its general mode of operation.

       When instructed to do so, a binary and its associated debug information is read and  analyzed.   To  that
       effect,  libabigail  analyzes  by  default  the  descriptions  of  the  types reachable by the interfaces
       (functions and variables) that are visible outside of their translation  unit.   Once  that  analysis  is
       done,  an  Application  Binary  Interface  Corpus  is constructed by only considering the subset of types
       reachable from interfaces associated to <u>ELF</u> symbols that are defined and exported by  the  binary.   It’s
       that final ABI corpus which libabigail considers as representing the ABI of the analyzed binary.

       Libabigail  then  has  capabilities  to  generate  textual  representations of ABI Corpora, compare them,
       analyze their changes and report about them.

</pre><h4><b>INVOCATION</b></h4><pre>
          abidiff [options] &lt;first-shared-library&gt; &lt;second-shared-library&gt;

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       abidiff loads two default <u>suppression</u> <u>specifications</u> <u>files</u>, merges their content and use it to filter out
       ABI change reports that might be considered as false positives to users.

       • Default system-wide suppression specification file

         It’s located by the optional environment variable LIBABIGAIL_DEFAULT_SYSTEM_SUPPRESSION_FILE.  If  that
         environment   variable   is   not   set,   then   abidiff   tries   to   load   the   suppression  file
         $libdir/libabigail/libabigail-default.abignore.   If  that  file  is  not  present,  then  no   default
         system-wide suppression specification file is loaded.

       • Default user suppression specification file.

         It’s located by the optional environment LIBABIGAIL_DEFAULT_USER_SUPPRESSION_FILE.  If that environment
         variable  is not set, then abidiff tries to load the suppression file $HOME/.abignore.  If that file is
         not present, then no default user suppression specification is loaded.

</pre><h4><b>OPTIONS</b></h4><pre>
          • <b>--help</b> <b>|</b> <b>-h</b>

            Display a short help about the command and exit.

          • <b>--debug-self-comparison</b>

            In this mode, error messages are emitted  for  types  which  fail  type  canonicalization,  in  some
            circumstances, when comparing a binary against itself.

            When  comparing  a  binary  against itself, canonical types of the second binary should be equal (as
            much as possible) to canonical types of the first binary.  When some discrepancies are  detected  in
            this  mode,  an  abort  signal is emitted and execution is halted.  This option should be used while
            executing the tool in a debugger, for troubleshooting purposes.

            This is an optional debugging and sanity check option.  To enable it the libabigail package needs to
            be configured with the –enable-debug-self-comparison configure option.

          • <b>--debug-tc</b>

            In this mode, the process of type canonicalization is put under heavy scrutiny.   Basically,  during
            type canonicalization, each type comparison is performed twice: once in a structural mode (comparing
            every  sub-type member-wise), and once using canonical comparison.  The two comparisons should yield
            the same result.  Otherwise, an abort  signal  is  emitted  and  the  process  can  be  debugged  to
            understand why the two kinds of comparison yield different results.

            This is an optional debugging and sanity check option.  To enable it the libabigail package needs to
            be configured with the –enable-debug-type-canonicalization configure option.

          • <b>--version</b> <b>|</b> <b>-v</b>

            Display the version of the program and exit.

          • <b>--debug-info-dir1</b> <b>|</b> <b>--d1</b> &lt;<u>di-path1</u>&gt;

            For  cases  where  the debug information for <u>first-shared-library</u> is split out into a separate file,
            tells <b>abidiff</b> where to find that separate debug information file.

            Note that <u>di-path</u> must point to the root directory under which the debug information is arranged  in
            a tree-like manner.  Under Red Hat based systems, that directory is usually <b>&lt;root&gt;/usr/lib/debug</b>.

            This  option  can  be provided several times with different root directories.  In that case, <b>abidiff</b>
            will  potentially  look  into  all  those  root  directories  to  find  the  split  debug  info  for
            <u>first-shared-library</u>.

            Note  also  that this option is not mandatory for split debug information installed by your system’s
            package manager because then <b>abidiff</b> knows where to find it.

          • <b>--debug-info-dir2</b> <b>|</b> <b>--d2</b> &lt;<u>di-path2</u>&gt;

            Like <b>--debug-info-dir1</b>, this options tells <b>abidiff</b> where to find the split debug information for the
            <u>second-shared-library</u> file.

            This option can be provided several times with different root directories.  In  that  case,  <b>abidiff</b>
            will  potentially  look  into  all  those  root  directories  to  find  the  split  debug  info  for
            <u>second-shared-library</u>.

          • <b>--headers-dir1</b> <b>|</b> <b>--hd1</b> &lt;headers-directory-path-1&gt;

            Specifies where to find the public headers of the first shared library (or binary in  general)  that
            the  tool  has to consider.  The tool will thus filter out ABI changes on types that are not defined
            in public headers.

            Note that several public header directories can be specified for the first shared library.  In  that
            case  the  <b>--headers-dir1</b>  option  should  be present several times on the command line, like in the
            following example:

                $ abidiff --headers-dir1 /some/path       \
                          --headers-dir1 /some/other/path \
                          binary-version-1 binary-version-2

          • <b>--header-file1</b> <b>|</b> <b>--hf1</b> &lt;header-file-path-1&gt;

            Specifies where to find one public header of the first shared library that the tool has to consider.
            The tool will thus filter out ABI changes on types that are not defined in public headers.

          • <b>--headers-dir2</b> <b>|</b> <b>--hd2</b> &lt;headers-directory-path-2&gt;

            Specifies where to find the public headers of the  second  shared  library  that  the  tool  has  to
            consider.   The  tool  will  thus  filter  out  ABI  changes on types that are not defined in public
            headers.

            Note that several public header directories can be specified for the second shared library.  In that
            case the <b>--headers-dir2</b> option should be present several times like in the following example:

                $ abidiff --headers-dir2 /some/path       \
                          --headers-dir2 /some/other/path \
                          binary-version-1 binary-version-2

          • <b>--header-file2</b> <b>|</b> <b>--hf2</b> &lt;header-file-path-2&gt;

            Specifies where to find one public header of  the  second  shared  library  that  the  tool  has  to
            consider.   The  tool  will  thus  filter  out  ABI  changes on types that are not defined in public
            headers.

          • <b>--add-binaries1</b> &lt;<u>bin1,bin2,bin3,..</u>&gt;

            For each of the comma-separated binaries given in argument to this option, if the binary is found in
            the directory specified by the <b>--added-binaries-dir1</b> option, then <b>abidiff</b> loads the  ABI  corpus  of
            the  binary  and  adds  it  to a set of corpora (called an ABI Corpus Group) that includes the first
            argument of <b>abidiff</b>.

            That ABI corpus group is then compared against the second corpus group given in argument to <b>abidiff</b>.

          • <b>--add-binaries2</b> &lt;<u>bin1,bin2,bin3,..</u>&gt;

            For each of the comma-separated binaries given in argument to this option, if the binary is found in
            the directory specified by the <b>--added-binaries-dir2</b> option, then <b>abidiff</b> loads the  ABI  corpus  of
            the  binary  and  adds  it  to a set of corpora(called an ABI Corpus Group) that includes the second
            argument of <b>abidiff</b>.

            That ABI corpus group is then compared against the first corpus group given in argument to <b>abidiff</b>.

          • <b>--follow-dependencies</b> <b>|</b> <b>--fdeps</b>

            For each dependency of the first argument of <b>abidiff</b>, if it’s found in the  directory  specified  by
            the  <b>--added-binaries-dir1</b>  option,  then construct an ABI corpus out of the dependency, add it to a
            set of corpora (called an ABI Corpus Group) that includes the first argument of <b>abidiff</b>.

            Similarly, for each dependency of the second argument of <b>abidiff</b>, if it’s  found  in  the  directory
            specified  by  the <b>--added-binaries-dir2</b> option, then construct an ABI corpus out of the dependency,
            add it to an ABI corpus group that includes the second argument of <b>abidiff</b>.

            These two ABI corpus groups are then compared against each other.

            Said otherwise, this makes <b>abidiff</b> compare the set of its first input and its  dependencies  against
            the set of its second input and its dependencies.

          • <b>list-dependencies</b> <b>|</b> <b>--ldeps</b>

            This  option  lists  all  the  dependencies  of the input arguments of <b>abidiff</b> that are found in the
            directories specified by the options <b>--added-binaries-dir1</b> and <b>--added-binaries-dir2</b>

          • <b>--added-binaries-dir1</b> <b>|</b> <b>--abd1</b> &lt;added-binaries-directory-1&gt;

            This option is to be  used  in  conjunction  with  the  <b>--add-binaries1</b>,  <b>--follow-dependencies</b>  and
            <b>--list-dependencies</b>  options.   Binaries  referred  to  by  these options, if found in the directory
            <u>added-binaries-directory-1</u>, are loaded as ABI corpus and are added to the  first  ABI  corpus  group
            that is to be used in the comparison.

          • <b>--added-binaries-dir2</b> <b>|</b> <b>--abd2</b> &lt;added-binaries-directory-2&gt;

            This  option  is  to  be  used  in  conjunction  with the <b>--add-binaries2</b>, <b>--follow-dependencies</b> and
            <b>--list-dependencies</b> options.  Binaries referred to by these  options,  if  found  in  the  directory
            <u>added-binaries-directory-2</u>, are loaded as ABI corpus and are added to the second ABI corpus group to
            be used in the comparison.

          • <b>--no-linux-kernel-mode</b>

            Without this option, if abidiff detects that the binaries it is looking at are Linux Kernel binaries
            (either  vmlinux  or  modules)  then it only considers functions and variables which ELF symbols are
            listed in the __ksymtab and __ksymtab_gpl sections.

            With this option, abidiff considers the binary as a  non-special  ELF  binary.   It  thus  considers
            functions and variables which are defined and exported in the ELF sense.

          • <b>--kmi-whitelist</b> <b>|</b> <b>-kaw</b> &lt;<u>path-to-whitelist</u>&gt;

            When  analyzing  a Linux kernel binary, this option points to the white list of names of ELF symbols
            of functions and variables which ABI must be considered.  That white list is called a “Kernel Module
            Interface white list”.  This is because for the Kernel, we don’t talk  about  <b>ABI</b>;  we  rather  talk
            about the interface between the Kernel and its module. Hence the term <b>KMI</b> rather than <b>ABI</b>.

            Any  other  function  or  variable  which  ELF symbol are not present in that white list will not be
            considered by this tool.

            If this option is not provided – thus if no white list is provided – then the entire KMI,  that  is,
            the  set  of  all  publicly  defined and exported functions and global variables by the Linux Kernel
            binaries, is considered.

          • <b>--drop-private-types</b>

            This option is to be used with the <b>--headers-dir1</b>,  <b>header-file1</b>,  <b>header-file2</b>  and  <b>--headers-dir2</b>
            options.   With this option, types that are <u>NOT</u> defined in the headers are entirely dropped from the
            internal representation build by Libabigail to represent the  ABI.   They  thus  don’t  have  to  be
            filtered  out  from  the  final  ABI change report because they are not even present in Libabigail’s
            representation.

            Without this option however, those private types are kept in the internal representation  and  later
            filtered out from the report.

            This options thus potentially makes Libabigail consume less memory.  It’s meant to be mainly used to
            optimize  the memory consumption of the tool on binaries with a lot of publicly defined and exported
            types.

          • <b>--exported-interfaces-only</b>

            By default, when looking at the debug information accompanying a  binary,  this  tool  analyzes  the
            descriptions  of  the  types  reachable by the interfaces (functions and variables) that are visible
            outside of their translation unit.  Once that analysis is done, an ABI corpus is constructed by only
            considering the subset of types reachable from interfaces associated to <u>ELF</u> symbols that are defined
            and exported by the binary.  It’s those final ABI Corpora that are compared by this tool.

            The problem with that approach however is that analyzing all the interfaces that  are  visible  from
            outside  their  translation  unit  can  amount  to a lot of data, especially when those binaries are
            applications, as opposed to shared libraries.  One example of such applications is the <u>Linux</u> <u>Kernel</u>.
            Analyzing massive ABI corpora like these can be extremely slow.

            To mitigate that performance issue, this option allows libabigail to only  analyze  types  that  are
            reachable from interfaces associated with defined and exported <u>ELF</u> symbols.

            Note  that  this  option  is  turned on by default when analyzing the <u>Linux</u> <u>Kernel</u>.  Otherwise, it’s
            turned off by default.

          • <b>--allow-non-exported-interfaces</b>

            When looking at the debug information accompanying a binary, this tool analyzes the descriptions  of
            the  types  reachable  by the interfaces (functions and variables) that are visible outside of their
            translation unit.  Once that analysis is done, an ABI corpus is constructed by only considering  the
            subset of types reachable from interfaces associated to <u>ELF</u> symbols that are defined and exported by
            the binary.  It’s those final ABI Corpora that are compared by this tool.

            The  problem  with  that approach however is that analyzing all the interfaces that are visible from
            outside their translation unit can amount to a lot of  data,  especially  when  those  binaries  are
            applications, as opposed to shared libraries.  One example of such applications is the <u>Linux</u> <u>Kernel</u>.
            Analyzing massive ABI Corpora like these can be extremely slow.

            In  the  presence  of an “average sized” binary however one can afford having libabigail analyze all
            interfaces that are visible outside of their translation unit, using this option.

            Note that this option is turned on by default, unless we are in the presence of the <u>Linux</u> <u>Kernel</u>.

          • <b>--stat</b>

            Rather  than  displaying   the   detailed   ABI   differences   between   <u>first-shared-library</u>   and
            <u>second-shared-library</u>, just display some summary statistics about these differences.

          • <b>--symtabs</b>

            Only display the symbol tables of the <u>first-shared-library</u> and <u>second-shared-library</u>.

          • <b>--deleted-fns</b>

            In    the    resulting    report    about   the   differences   between   <u>first-shared-library</u>   and
            <u>second-shared-library</u>,  only  display  the  globally  defined  functions  that  got   deleted   from
            <u>first-shared-library</u>.

          • <b>--changed-fns</b>

            In    the    resulting    report    about   the   differences   between   <u>first-shared-library</u>   and
            <u>second-shared-library</u>, only display the changes in sub-types of  the  global  functions  defined  in
            <u>first-shared-library</u>.

          • <b>--added-fns</b>

            In    the    resulting    report    about   the   differences   between   <u>first-shared-library</u>   and
            <u>second-shared-library</u>,  only  display  the  globally  defined   functions   that   were   added   to
            <u>second-shared-library</u>.

          • <b>--deleted-vars</b>

            In    the    resulting    report    about   the   differences   between   <u>first-shared-library</u>   and
            <u>second-shared-library</u>,  only  display  the  globally  defined  variables  that  were  deleted   from
            <u>first-shared-library</u>.

          • <b>--changed-vars</b>

            In    the    resulting    report    about   the   differences   between   <u>first-shared-library</u>   and
            <u>second-shared-library</u>, only display the changes in the sub-types of the global variables defined  in
            <u>first-shared-library</u>

          • <b>--added-vars</b>

            In    the    resulting    report    about   the   differences   between   <u>first-shared-library</u>   and
            <u>second-shared-library</u>,  only  display  the  global  variables   that   were   added   (defined)   to
            <u>second-shared-library</u>.

          • <b>--non-reachable-types|-t</b>

            Analyze  and  emit  change  reports  for  all  the types of the binary, including those that are not
            reachable from global functions and variables.

            This option might incur some serious performance degradation as the number of types analyzed can  be
            huge.   However,  if  paired  with  the  <b>--headers-dir{1,2}</b>  and/or  <b>header-file{1,2}</b>  options,  the
            additional non-reachable types analyzed are restricted to those defined  in  public  headers  files,
            thus hopefully making the performance hit acceptable.

            Also,  using  this  option  alongside  suppression  specifications (by also using the <b>--suppressions</b>
            option) might help keep the number of analyzed types (and the potential performance degradation)  in
            control.

            Note that without this option, only types that are reachable from global functions and variables are
            analyzed, so the tool detects and reports changes on these reachable types only.

          • <b>--no-added-syms</b>

            In    the    resulting    report    about   the   differences   between   <u>first-shared-library</u>   and
            <u>second-shared-library</u>, do not display added functions or variables.  Do not display added  functions
            or  variables  ELF  symbols  either.   All  other  kinds  of  changes  are displayed unless they are
            explicitely forbidden by other options on the command line.

          • <b>--no-linkage-name</b>

            In the resulting report, do not display  the  linkage  names  of  the  added,  removed,  or  changed
            functions or variables.

          • <b>--no-show-locs</b>
              Do not show information about where in the <u>second</u> <u>shared</u> <u>library</u> the respective type was changed.

          • <b>--show-bytes</b>

            Show sizes and offsets in bytes, not bits.  By default, sizes and offsets are shown in bits.

          • <b>--show-bits</b>

            Show sizes and offsets in bits, not bytes.  This option is activated by default.

          • <b>--show-hex</b>

            Show sizes and offsets in hexadecimal base.

          • <b>--show-dec</b>

            Show sizes and offsets in decimal base.  This option is activated by default.

          • <b>--ignore-soname</b>

            Ignore differences in the SONAME when doing a comparison

          • <b>--no-show-relative-offset-changes</b>

            Without  this  option, when the offset of a data member changes, the change report not only mentions
            the older and newer offset, but it also mentions by how many bits the  data  member  changes.   With
            this option, the latter is not shown.

          • <b>--no-unreferenced-symbols</b>

            In  the resulting report, do not display change information about function and variable symbols that
            are not referenced by any debug information.  Note that for these  symbols  not  referenced  by  any
            debug information, the change information displayed is either added or removed symbols.

          • <b>--no-default-suppression</b>

            Do not load the <u>default</u> <u>suppression</u> <u>specification</u> <u>files</u>.

          • <b>--suppressions</b> <b>|</b> <b>--suppr</b> &lt;<u>path-to-suppressions</u>&gt;

            Use  a  <u>suppression</u>  <u>specification</u>  file located at <u>path-to-suppressions</u>.  Note that this option can
            appear multiple times on  the  command  line.   In  that  case,  all  of  the  provided  suppression
            specification files are taken into account.

            Please  note  that,  by  default,  if  this  option  is  not  provided, then the <u>default</u> <u>suppression</u>
            <u>specification</u> <u>files</u> are loaded .

          • <b>--drop</b> &lt;<u>regex</u>&gt;

            When reading the <u>first-shared-library</u> and <u>second-shared-library</u> ELF input files, drop  the  globally
            defined  functions  and  variables  which  name match the regular expression <u>regex</u>.  As a result, no
            change involving these functions or variables will be emitted in the diff report.

          • <b>--drop-fn</b> &lt;<u>regex</u>&gt;

            When reading the <u>first-shared-library</u> and <u>second-shared-library</u> ELF input files, drop  the  globally
            defined  functions  which name match the regular expression <u>regex</u>.  As a result, no change involving
            these functions will be emitted in the diff report.

          • <b>--drop-var</b> &lt;<u>regex</u>&gt;

            When reading the <u>first-shared-library</u> and <u>second-shared-library</u> ELF input files, drop  the  globally
            defined variables matching a the regular expression <u>regex</u>.

          • <b>--keep</b> &lt;<u>regex</u>&gt;

            When  reading  the <u>first-shared-library</u> and <u>second-shared-library</u> ELF input files, keep the globally
            defined functions and variables which names match the regular expression <u>regex</u>.  All other functions
            and variables are dropped on the floor and will thus not appear in the resulting diff report.

          • <b>--keep-fn</b> &lt;<u>regex</u>&gt;

            When reading the <u>first-shared-library</u> and <u>second-shared-library</u> ELF input files, keep  the  globally
            defined functions which name match the regular expression <u>regex</u>.  All other functions are dropped on
            the floor and will thus not appear in the resulting diff report.

          • <b>--keep-var</b> &lt;<u>regex</u>&gt;

            When  reading  the <u>first-shared-library</u> and <u>second-shared-library</u> ELF input files, keep the globally
            defined which names match the regular expression <u>regex</u>.  All other  variables  are  dropped  on  the
            floor and will thus not appear in the resulting diff report.

          • <b>--harmless</b>

            In  the  diff  report,  display  only  the  <u>harmless</u>  changes.  By default, the harmless changes are
            filtered out of the diff report keep the clutter to a minimum and have a greater chance to spot real
            ABI issues.

          • <b>--no-harmful</b>

            In the diff report, do not display the <u>harmful</u> changes.  By default, only the  harmful  changes  are
            displayed in diff report.

          • <b>--redundant</b>

            In  the  diff  report,  do  display redundant changes.  A redundant change is a change that has been
            displayed elsewhere in the report.

          • <b>--no-redundant</b>

            In the diff report, do <u>NOT</u> display redundant changes.  A redundant change is a change that has  been
            displayed elsewhere in the report.  This option is switched on by default.

          • <b>--no-architecture</b>

            Do not take architecture in account when comparing ABIs.

          • <b>--no-corpus-path</b>

            Do not emit the path attribute for the ABI corpus.

          • <b>--fail-no-debug-info</b>

            If  no  debug  info  was found, then this option makes the program to fail.  Otherwise, without this
            option, the program will attempt to compare properties of the binaries that are not related to debug
            info, like pure ELF properties.

          • <b>--leaf-changes-only|-l</b> only show leaf changes, so don’t show impact analysis  report.   This  option
            implies <b>--redundant</b>.

            The typical output of abidiff when comparing two binaries looks like this

                $ abidiff libtest-v0.so libtest-v1.so
                Functions changes summary: 0 Removed, 1 Changed, 0 Added function
                Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                1 function with some indirect sub-type change:

                  [C]'function void fn(C&amp;)' at test-v1.cc:13:1 has some indirect sub-type changes:
                    parameter 1 of type 'C&amp;' has sub-type changes:
                      in referenced type 'struct C' at test-v1.cc:7:1:
                        type size hasn't changed
                        1 data member change:
                         type of 'leaf* C::m0' changed:
                           in pointed to type 'struct leaf' at test-v1.cc:1:1:
                             type size changed from 32 to 64 bits
                             1 data member insertion:
                               'char leaf::m1', at offset 32 (in bits) at test-v1.cc:4:1

                $

            So  in  that  example  the  report  emits  information about how the data member insertion change of
            “struct leaf” is reachable from function “void fn(C&amp;)”.  In other words, the report not  only  shows
            the data member change on “struct leaf”, but it also shows the impact of that change on the function
            “void fn(C&amp;)”.

            In   abidiff   parlance,   the   change   on  “struct  leaf”  is  called  a  leaf  change.   So  the
            <b>--leaf-changes-only</b> <b>--impacted-interfaces</b> options show, well, only the leaf  change.   And  it  goes
            like this:

                $ abidiff -l libtest-v0.so libtest-v1.so
                'struct leaf' changed:
                  type size changed from 32 to 64 bits
                  1 data member insertion:
                    'char leaf::m1', at offset 32 (in bits) at test-v1.cc:4:1

                  one impacted interface:
                    function void fn(C&amp;)
                $

            Note how the report ends by showing the list of interfaces impacted by the leaf change.

            Now  if  you  don’t  want to see that list of impacted interfaces, then you can just avoid using the
            <b>--impacted-interface</b> option.  You can learn about that option below, in any case.

          • <b>--impacted-interfaces</b>

            When showing leaf changes, this option instructs abidiff to show the list  of  impacted  interfaces.
            This option is thus to be used in addition the <b>--leaf-changes-only</b> option, otherwise, it’s ignored.

          • <b>--dump-diff-tree</b>
              After the diff report, emit a textual representation of the diff nodes tree used by the comparison
              engine  to  represent  the changed functions and variables.  That representation is emitted to the
              error output for debugging purposes.  Note that this diff tree is relevant only to  functions  and
              variables  that  have some sub-type changes.  Added or removed functions and variables do not have
              any diff nodes tree associated to them.

          • <b>--no-assume-odr-for-cplusplus</b>

            When analysing a binary originating from C++ code using <u>DWARF</u> debug information, libabigail  assumes
            the  <u>One</u>  <u>Definition</u>  <u>Rule</u> to speed-up the analysis.  In that case, when several types have the same
            name in the binary, they are assumed to all be equal.

            This option disables that assumption and instructs libabigail to actually actually compare the types
            to determine if they are equal.

          • <b>--no-leverage-dwarf-factorization</b>

            When analysing a binary which <u>DWARF</u> debug information was processed with  the  <u>DWZ</u>  tool,  the  type
            information  is  supposed  to  be already factorized.  That context is used by libabigail to perform
            some speed optimizations.

            This option disables those optimizations.

          • <b>--no-change-categorization</b> <b>|</b> <b>-x</b>

            This option disables the categorization of changes into harmless and  harmful  changes.   Note  that
            this  categorization  is  a  pre-requisite for the filtering of changes so this option disables that
            filtering.  The goal of this option is to speed-up the execution of the program for cases where  the
            graph  of  changes  is  huge and where the user is just interested in looking at, for instance, leaf
            node changes without caring about their possible impact on interfaces.  In that  case,  this  option
            would be used along with the <b>--leaf-changes-only</b> one.

          • <b>--ctf</b>

            When comparing binaries, extract ABI information from <u>CTF</u> debug information, if present.

          • <b>--btf</b>

            When comparing binaries, extract ABI information from <u>BTF</u> debug information, if present.

          • <b>--stats</b>

            Emit statistics about various internal things.

          • <b>--verbose</b>

            Emit verbose logs about the progress of miscellaneous internal things.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The  exit code of the <b>abidiff</b> command is either 0 if the ABI of the binaries being compared are equal, or
       non-zero if they differ or if the tool encountered an error.

       In the later case, the exit code is a 8-bits-wide bit field in which each bit has a specific meaning.

       The first bit, of value 1, named <b>ABIDIFF_ERROR</b> means there was an error.

       The second bit, of value 2, named <b>ABIDIFF_USAGE_ERROR</b> means there was  an  error  in  the  way  the  user
       invoked  the  tool.   It might be set, for instance, if the user invoked the tool with an unknown command
       line switch, with a wrong number or argument, etc.  If this bit is set, then the <b>ABIDIFF_ERROR</b>  bit  must
       be set as well.

       The  third  bit,  of  value  4, named <b>ABIDIFF_ABI_CHANGE</b> means the ABI of the binaries being compared are
       different.

       The fourth bit, of value 8, named <b>ABIDIFF_ABI_INCOMPATIBLE_CHANGE</b> means the ABI of the binaries  compared
       are different in an incompatible way.  If this bit is set, then the <b>ABIDIFF_ABI_CHANGE</b> bit must be set as
       well.   If  the  <b>ABIDIFF_ABI_CHANGE</b>  is set and the <b>ABIDIFF_INCOMPATIBLE_CHANGE</b> is <u>NOT</u> set, then it means
       that the ABIs being compared might or might not be compatible.  In that case,  a  human  being  needs  to
       review the ABI changes to decide if they are compatible or not.

       Note that, at the moment, there are only a few kinds of ABI changes that would result in setting the flag
       <b>ABIDIFF_ABI_INCOMPATIBLE_CHANGE</b>.  Those ABI changes are either:

          • the removal of the symbol of a function or variable that has been defined and exported.

          • the  modification  of  the  index  of  a  member  of  a virtual function table (for C++ programs and
            libraries).

       With time, when more ABI change patterns are found to <u>always</u> constitute incompatible ABI changes, we will
       adapt the code to recognize those cases and set the <b>ABIDIFF_ABI_INCOMPATIBLE_CHANGE</b> accordingly.  So,  if
       you find such patterns, please let us know.

       The remaining bits are not used for the moment.

</pre><h4><b>USAGE</b> <b>EXAMPLES</b></h4><pre>
          1. Detecting a change in a sub-type of a function:

                 $ cat -n test-v0.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                          3
                          4      struct S0
                          5      {
                          6        int m0;
                          7      };
                          8
                          9      void
                         10      foo(S0* /*parameter_name*/)
                         11      {
                         12        // do something with parameter_name.
                         13      }
                 $
                 $ cat -n test-v1.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                          3
                          4      struct type_base
                          5      {
                          6        int inserted;
                          7      };
                          8
                          9      struct S0 : public type_base
                         10      {
                         11        int m0;
                         12      };
                         13
                         14      void
                         15      foo(S0* /*parameter_name*/)
                         16      {
                         17        // do something with parameter_name.
                         18      }
                 $
                 $ g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                 $ g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                 $
                 $ ../build/tools/abidiff libtest-v0.so libtest-v1.so
                 Functions changes summary: 0 Removed, 1 Changed, 0 Added function
                 Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                 1 function with some indirect sub-type change:

                   [C]'function void foo(S0*)' has some indirect sub-type changes:
                         parameter 0 of type 'S0*' has sub-type changes:
                           in pointed to type 'struct S0':
                             size changed from 32 to 64 bits
                             1 base class insertion:
                               struct type_base
                             1 data member change:
                              'int S0::m0' offset changed from 0 to 32
                 $

          2. Detecting another change in a sub-type of a function:

                 $ cat -n test-v0.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                          3
                          4      struct S0
                          5      {
                          6        int m0;
                          7      };
                          8
                          9      void
                         10      foo(S0&amp; /*parameter_name*/)
                         11      {
                         12        // do something with parameter_name.
                         13      }
                 $
                 $ cat -n test-v1.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                          3
                          4      struct S0
                          5      {
                          6        char inserted_member;
                          7        int m0;
                          8      };
                          9
                         10      void
                         11      foo(S0&amp; /*parameter_name*/)
                         12      {
                         13        // do something with parameter_name.
                         14      }
                 $
                 $ g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                 $ g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                 $
                 $ ../build/tools/abidiff libtest-v0.so libtest-v1.so
                 Functions changes summary: 0 Removed, 1 Changed, 0 Added function
                 Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                 1 function with some indirect sub-type change:

                   [C]'function void foo(S0&amp;)' has some indirect sub-type changes:
                         parameter 0 of type 'S0&amp;' has sub-type changes:
                           in referenced type 'struct S0':
                             size changed from 32 to 64 bits
                             1 data member insertion:
                               'char S0::inserted_member', at offset 0 (in bits)
                             1 data member change:
                              'int S0::m0' offset changed from 0 to 32

                 $

          3. Detecting that functions got removed or added to a library:

                 $ cat -n test-v0.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                          3
                          4      struct S0
                          5      {
                          6        int m0;
                          7      };
                          8
                          9      void
                         10      foo(S0&amp; /*parameter_name*/)
                         11      {
                         12        // do something with parameter_name.
                         13      }
                 $
                 $ cat -n test-v1.cc
                          1      // Compile this with:
                          2      //   g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                          3
                          4      struct S0
                          5      {
                          6        char inserted_member;
                          7        int m0;
                          8      };
                          9
                         10      void
                         11      bar(S0&amp; /*parameter_name*/)
                         12      {
                         13        // do something with parameter_name.
                         14      }
                 $
                 $ g++ -g -Wall -shared -o libtest-v0.so test-v0.cc
                 $ g++ -g -Wall -shared -o libtest-v1.so test-v1.cc
                 $
                 $ ../build/tools/abidiff libtest-v0.so libtest-v1.so
                 Functions changes summary: 1 Removed, 0 Changed, 1 Added functions
                 Variables changes summary: 0 Removed, 0 Changed, 0 Added variable

                 1 Removed function:
                   'function void foo(S0&amp;)'    {_Z3fooR2S0}

                 1 Added function:
                   'function void bar(S0&amp;)'    {_Z3barR2S0}

                 $

          4. Comparing two sets of binaries that are passed on the command line:

                 $ abidiff --add-binaries1=file2-v1              \
                           --add-binaries2=file2-v2,file2-v1     \
                           --added-binaries-dir1 dir1            \
                           --added-binaries-dir2 dir2            \
                           file1-v1 file1-v2

             Note  that  the  files  <b>file2-v1</b>,  and  <b>file2-v2</b> are to be found in <b>dir1</b> and <b>dir2</b> or in the current
             directory.

          5. Compare two libraries and their dependencies:

                 $ abidiff --follow-dependencies                      \
                           --added-binaries-dir1 /some/where          \
                           --added-binaries-dir2 /some/where/else     \
                           foo bar

             This compares the set of binaries comprised by <b>foo</b> and its dependencies against the set of binaries
             comprised by <b>bar</b> and its dependencies.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dodji Seketeli

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2014-2024, Red Hat, Inc.

                                                  Nov 13, 2024                                        <u><a href="../man1/ABIDIFF.1.html">ABIDIFF</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>