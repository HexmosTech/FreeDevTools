<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>openssl-verification-options - generic X.509 certificate verification options</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/openssl">openssl_3.4.1-1ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       openssl-verification-options - generic X.509 certificate verification options

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>openssl</b> <u>command</u> [ <u>options</u> ... ] [ <u>parameters</u> ... ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       There are many situations where X.509 certificates are verified within the OpenSSL libraries and in
       various OpenSSL commands.

       Certificate verification is implemented by <b><a href="../man3/X509_verify_cert.3.html">X509_verify_cert</a></b>(3).  It is a complicated process consisting
       of a number of steps and depending on numerous options.  The most important of them are detailed in the
       following sections.

       In a nutshell, a valid chain of certificates needs to be built up and verified starting from the <u>target</u>
       <u>certificate</u> that is to be verified and ending in a certificate that due to some policy is trusted.
       Certificate validation can be performed in the context of a <u>purpose</u>, which is a high-level specification
       of the intended use of the target certificate, such as "sslserver" for TLS servers, or (by default) for
       any purpose.

       The details of how each OpenSSL command handles errors are documented on the specific command page.

       DANE support is documented in <b><a href="../man1/openssl-s_client.1.html">openssl-s_client</a></b>(1), <b><a href="../man3/SSL_CTX_dane_enable.3.html">SSL_CTX_dane_enable</a></b>(3), <b><a href="../man3/SSL_set1_host.3.html">SSL_set1_host</a></b>(3),
       <b><a href="../man3/X509_VERIFY_PARAM_set_flags.3.html">X509_VERIFY_PARAM_set_flags</a></b>(3), and <b><a href="../man3/X509_check_host.3.html">X509_check_host</a></b>(3).

   <b>Trust</b> <b>Anchors</b>
       In general, according to RFC 4158 and RFC 5280, a <u>trust</u> <u>anchor</u> is any public key and related subject
       distinguished name (DN) that for some reason is considered trusted and thus is acceptable as the root of
       a chain of certificates.

       In practice, trust anchors are given in the form of certificates, where their essential fields are the
       public key and the subject DN.  In addition to the requirements in RFC 5280, OpenSSL checks the validity
       period of such certificates and makes use of some further fields.  In particular, the subject key
       identifier extension, if present, is used for matching trust anchors during chain building.

       In the most simple and common case, trust anchors are by default all self-signed "root" CA certificates
       that are placed in the <u>trust</u> <u>store</u>, which is a collection of certificates that are trusted for certain
       uses.  This is akin to what is used in the trust stores of Mozilla Firefox, or Apple's and Microsoft's
       certificate stores, ...

       From the OpenSSL perspective, a trust anchor is a certificate that should be augmented with an explicit
       designation for which uses of a target certificate the certificate may serve as a trust anchor.  In PEM
       encoding, this is indicated by the "TRUSTED CERTIFICATE" string.  Such a designation provides a set of
       positive trust attributes explicitly stating trust for the listed purposes and/or a set of negative trust
       attributes explicitly rejecting the use for the listed purposes.  The purposes are encoded using the
       values defined for the extended key usages (EKUs) that may be given in X.509 extensions of end-entity
       certificates.  See also the "Extended Key Usage" section below.

       The currently recognized uses are <b>clientAuth</b> (SSL client use), <b>serverAuth</b> (SSL server use),
       <b>emailProtection</b> (S/MIME email use), <b>codeSigning</b> (object signer use), <b>OCSPSigning</b> (OCSP responder use),
       <b>OCSP</b> (OCSP request use), <b>timeStamping</b> (TSA server use), and <b>anyExtendedKeyUsage</b>.  As of OpenSSL 1.1.0,
       the last of these blocks all uses when rejected or enables all uses when trusted.

       A certificate, which may be CA certificate or an end-entity certificate, is considered a trust anchor for
       the given use if and only if all the following conditions hold:

       •   It is an an element of the trust store.

       •   It does not have a negative trust attribute rejecting the given use.

       •   It  has  a  positive  trust  attribute  accepting  the given use or (by default) one of the following
           compatibility conditions apply: It is self-signed  or  the  <b>-partial_chain</b>  option  is  given  (which
           corresponds to the <b>X509_V_FLAG_PARTIAL_CHAIN</b> flag being set).

   <b>Certification</b> <b>Path</b> <b>Building</b>
       First, a certificate chain is built up starting from the target certificate and ending in a trust anchor.

       The  chain is built up iteratively, looking up in turn a certificate with suitable key usage that matches
       as an issuer of the current "subject" certificate as described below.  If there is  such  a  certificate,
       the first one found that is currently valid is taken, otherwise the one that expired most recently of all
       such  certificates.   For  efficiency,  no  backtracking  is performed, thus any further candidate issuer
       certificates that would match equally are ignored.

       When a self-signed certificate has been added, chain construction stops.  In  this  case  it  must  fully
       match a trust anchor, otherwise chain building fails.

       A candidate issuer certificate matches a subject certificate if all of the following conditions hold:

       •   Its subject name matches the issuer name of the subject certificate.

       •   If  the  subject certificate has an authority key identifier extension, each of its sub-fields equals
           the corresponding subject key identifier, serial number, and issuer field  of  the  candidate  issuer
           certificate, as far as the respective fields are present in both certificates.

       •   The  certificate signature algorithm used to sign the subject certificate is supported and equals the
           public key algorithm of the candidate issuer certificate.

       The lookup first searches for issuer certificates in the trust store.  If it does not find a match  there
       it consults the list of untrusted ("intermediate" CA) certificates, if provided.

   <b>Certification</b> <b>Path</b> <b>Validation</b>
       When  the  certificate  chain  building  process  was successful the chain components and their links are
       checked thoroughly.

       The first step is to check that each certificate is well-formed.  Part of these checks are  enabled  only
       if the <b>-x509_strict</b> option is given.

       The second step is to check the X.509v3 extensions of every certificate for consistency with the intended
       specific  purpose,  if  any.  If the <b>-purpose</b> option is not given then no such checks are done except for
       CMS signature checking, where by default "smimesign" is checked, and SSL/(D)TLS connection  setup,  where
       by  default  "sslserver"  or  "sslclient"  are  checked.   The X.509v3 extensions of the target or "leaf"
       certificate must be compatible with the specified purpose.  All other certificates  down  the  chain  are
       checked  to  be  valid CA certificates, and possibly also further non-standard checks are performed.  The
       precise extensions required are described in detail in the "Certificate Extensions" section below.

       The third step is to check the trust settings on the last certificate (which typically is  a  self-signed
       root CA certificate).  It must be trusted for the given use.  For compatibility with previous versions of
       OpenSSL, a self-signed certificate with no trust attributes is considered to be valid for all uses.

       The  fourth,  and final, step is to check the validity of the certificate chain.  For each element in the
       chain, including the root CA certificate, the  validity  period  as  specified  by  the  "notBefore"  and
       "notAfter"  fields  is  checked  against  the current system time.  The <b>-attime</b> flag may be used to use a
       reference time other than "now."  The certificate signature is checked as well (except for the  signature
       of  the  typically self-signed root CA certificate, which is verified only if the <b>-check_ss_sig</b> option is
       given).  When verifying a certificate signature the keyUsage extension  (if  present)  of  the  candidate
       issuer  certificate  is  checked  to  permit digitalSignature for signing proxy certificates or to permit
       keyCertSign for signing other certificates, respectively.  If all operations complete  successfully  then
       certificate is considered valid. If any operation fails then the certificate is not valid.

</pre><h4><b>OPTIONS</b></h4><pre>
   <b>Trusted</b> <b>Certificate</b> <b>Options</b>
       The  following  options  specify  how  to  supply  the certificates that can be used as trust anchors for
       certain uses.  As mentioned, a collection of such certificates is called a <u>trust</u> <u>store</u>.

       Note that OpenSSL does not provide a default set of trust anchors.  Many Linux  distributions  include  a
       system default and configure OpenSSL to point to that.  Mozilla maintains an influential trust store that
       can be found at &lt;https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/&gt;.

       The certificates to add to the trust store can be specified using following options.

       <b>-CAfile</b> <u>file</u>
           Load  the specified file which contains a trusted certificate in DER format or potentially several of
           them in case the input is in PEM format.  PEM-encoded certificates may  also  have  trust  attributes
           set.

       <b>-no-CAfile</b>
           Do not load the default file of trusted certificates.

       <b>-CApath</b> <u>dir</u>
           Use  the  specified  directory  as  a collection of trusted certificates, i.e., a trust store.  Files
           should be named with the hash value of the X.509 SubjectName of each certificate. This is so that the
           library can extract the IssuerName, hash  it,  and  directly  lookup  the  file  to  get  the  issuer
           certificate.  See <b><a href="../man1/openssl-rehash.1.html">openssl-rehash</a></b>(1) for information on creating this type of directory.

       <b>-no-CApath</b>
           Do not use the default directory of trusted certificates.

       <b>-CAstore</b> <u>uri</u>
           Use  <u>uri</u>  as  a  store  of  CA certificates.  The URI may indicate a single certificate, as well as a
           collection of them.  With URIs in the "file:" scheme, this acts as <b>-CAfile</b> or <b>-CApath</b>,  depending  on
           if  the URI indicates a single file or directory.  See <b><a href="../man7/ossl_store-file.7.html">ossl_store-file</a></b>(7) for more information on the
           "file:" scheme.

           These certificates are also used when  building  the  server  certificate  chain  (for  example  with
           <b><a href="../man1/openssl-s_server.1.html">openssl-s_server</a></b>(1)) or client certificate chain (for example with <b><a href="../man1/openssl-s_time.1.html">openssl-s_time</a></b>(1)).

       <b>-no-CAstore</b>
           Do not use the default store of trusted CA certificates.

   <b>Verification</b> <b>Options</b>
       The certificate verification can be fine-tuned with the following flags.

       <b>-verbose</b>
           Print extra information about the operations being performed.

       <b>-attime</b> <u>timestamp</u>
           Perform validation checks using time specified by <u>timestamp</u> and not current system time. <u>timestamp</u> is
           the number of seconds since January 1, 1970 (i.e., the Unix Epoch).

       <b>-no_check_time</b>
           This  option  suppresses  checking  the  validity period of certificates and CRLs against the current
           time. If option <b>-attime</b> is used to specify a verification time, the check is not suppressed.

       <b>-x509_strict</b>
           This disables  non-compliant  workarounds  for  broken  certificates.   Thus  errors  are  thrown  on
           certificates not compliant with RFC 5280.

           When  this  option  is  set,  among  others, the following certificate well-formedness conditions are
           checked:

           •   The basicConstraints of CA certificates must be marked critical.

           •   CA certificates must explicitly include the keyUsage extension.

           •   If a pathlenConstraint is given the key usage keyCertSign must be allowed.

           •   The pathlenConstraint must not be given for non-CA certificates.

           •   The issuer name of any certificate must not be empty.

           •   The  subject  name  of   CA   certs,   certs   with   keyUsage   crlSign,   and   certs   without
               subjectAlternativeName must not be empty.

           •   If a subjectAlternativeName extension is given it must not be empty.

           •   The signatureAlgorithm field and the cert signature must be consistent.

           •   Any given authorityKeyIdentifier and any given subjectKeyIdentifier must not be marked critical.

           •   The authorityKeyIdentifier must be given for X.509v3 certs unless they are self-signed.

           •   The subjectKeyIdentifier must be given for all X.509v3 CA certs.

       <b>-ignore_critical</b>
           Normally  if  an  unhandled  critical  extension  is  present  that  is  not supported by OpenSSL the
           certificate is rejected (as required by RFC5280).  If this option  is  set  critical  extensions  are
           ignored.

       <b>-issuer_checks</b>
           Ignored.

       <b>-crl_check</b>
           Checks  end  entity certificate validity by attempting to look up a valid CRL.  If a valid CRL cannot
           be found an error occurs.

       <b>-crl_check_all</b>
           Checks the validity of <b>all</b> certificates in the chain by attempting to look up valid CRLs.

       <b>-use_deltas</b>
           Enable support for delta CRLs.

       <b>-extended_crl</b>
           Enable extended CRL features such as indirect CRLs and alternate CRL signing keys.

       <b>-suiteB_128_only</b>, <b>-suiteB_128</b>, <b>-suiteB_192</b>
           Enable the Suite B mode operation at 128 bit Level of Security, 128 bit or 192 bit, or only  192  bit
           Level  of  Security  respectively.   See  RFC6460  for details. In particular the supported signature
           algorithms are reduced to support only ECDSA and SHA256 or SHA384 and only the elliptic curves  P-256
           and P-384.

       <b>-auth_level</b> <u>level</u>
           Set  the certificate chain authentication security level to <u>level</u>.  The authentication security level
           determines the acceptable signature and public key strength when verifying certificate chains.  For a
           certificate chain to validate, the public keys of  all  the  certificates  must  meet  the  specified
           security  <u>level</u>.   The signature algorithm security level is enforced for all the certificates in the
           chain except for the chain's <u>trust</u> <u>anchor</u>, which is either directly trusted  or  validated  by  means
           other  than  its  signature.   See <b><a href="../man3/SSL_CTX_set_security_level.3.html">SSL_CTX_set_security_level</a></b>(3) for the definitions of the available
           levels.  The default security level is -1, or "not set".  At security level 0 or lower all algorithms
           are acceptable.  Security level 1  requires  at  least  80-bit-equivalent  security  and  is  broadly
           interoperable, though it will, for example, reject MD5 signatures or RSA keys shorter than 1024 bits.

       <b>-partial_chain</b>
           Allow  verification  to  succeed  if  an incomplete chain can be built.  That is, a chain ending in a
           certificate that normally would not be trusted (because it has no matching positive trust  attributes
           and is not self-signed) but is an element of the trust store.  This certificate may be self-issued or
           belong to an intermediate CA.

       <b>-check_ss_sig</b>
           Verify the signature of the last certificate in a chain if the certificate is supposedly self-signed.
           This  is  prohibited  and  will  result in an error if it is a non-conforming CA certificate with key
           usage restrictions not including the keyCertSign bit.   This  verification  is  disabled  by  default
           because it doesn't add any security.

       <b>-allow_proxy_certs</b>
           Allow the verification of proxy certificates.

       <b>-trusted_first</b>
           As of OpenSSL 1.1.0 this option is on by default and cannot be disabled.

           When  constructing  the  certificate  chain, the trusted certificates specified via <b>-CAfile</b>, <b>-CApath</b>,
           <b>-CAstore</b> or <b>-trusted</b> are always used before any certificates specified via <b>-untrusted</b>.

       <b>-no_alt_chains</b>
           As of OpenSSL 1.1.0, since <b>-trusted_first</b> always on, this option has no effect.

       <b>-trusted</b> <u>file</u>
           Parse <u>file</u> as a set of one or more certificates.  Each of them qualifies as trusted if has a suitable
           positive trust attribute or it is self-signed or the <b>-partial_chain</b> option is specified.  This option
           implies the <b>-no-CAfile</b>, <b>-no-CApath</b>, and <b>-no-CAstore</b> options and it cannot be used with  the  <b>-CAfile</b>,
           <b>-CApath</b>  or  <b>-CAstore</b>  options,  so  only  certificates specified using the <b>-trusted</b> option are trust
           anchors.  This option may be used multiple times.

       <b>-untrusted</b> <u>file</u>
           Parse <u>file</u> as a set of one or more certificates.  All certificates (typically  of  intermediate  CAs)
           are considered untrusted and may be used to construct a certificate chain from the target certificate
           to a trust anchor.  This option may be used multiple times.

       <b>-policy</b> <u>arg</u>
           Enable policy processing and add <u>arg</u> to the user-initial-policy-set (see RFC5280). The policy <u>arg</u> can
           be an object name or an OID in numeric form.  This argument can appear more than once.

       <b>-explicit_policy</b>
           Set policy variable require-explicit-policy (see RFC5280).

       <b>-policy_check</b>
           Enables certificate policy processing.

       <b>-policy_print</b>
           Print out diagnostics related to policy processing.

       <b>-inhibit_any</b>
           Set policy variable inhibit-any-policy (see RFC5280).

       <b>-inhibit_map</b>
           Set policy variable inhibit-policy-mapping (see RFC5280).

       <b>-purpose</b> <u>purpose</u>
           A  high-level  specification  of  the  intended  use of the target certificate.  Currently predefined
           purposes  are  "sslclient",  "sslserver",  "nssslserver",  "smimesign",  "smimeencrypt",   "crlsign",
           "ocsphelper", "timestampsign", "codesign" and "any".  If peer certificate verification is enabled, by
           default  the  TLS  implementation  and  thus the commands <b><a href="../man1/openssl-s_client.1.html">openssl-s_client</a></b>(1) and <b><a href="../man1/openssl-s_server.1.html">openssl-s_server</a></b>(1)
           check for consistency with TLS server ("sslserver") or TLS client  use  ("sslclient"),  respectively.
           By  default,  CMS  signature validation, which can be done via <b><a href="../man1/openssl-cms.1.html">openssl-cms</a></b>(1), checks for consistency
           with S/MIME signing use ("smimesign").

           While IETF RFC 5280 says that <b>id-kp-serverAuth</b> and <b>id-kp-clientAuth</b> are only for WWW use, in practice
           they are used for all kinds of TLS clients and servers, and this is what OpenSSL assumes as well.

       <b>-verify_depth</b> <u>num</u>
           Limit the certificate chain to <u>num</u> intermediate CA certificates.  A maximal depth chain can  have  up
           to  <u>num</u>+2  certificates,  since  neither  the end-entity certificate nor the trust-anchor certificate
           count against the <b>-verify_depth</b> limit.

       <b>-verify_email</b> <u>email</u>
           Verify if <u>email</u> matches the email address in Subject Alternative Name or the  email  in  the  subject
           Distinguished Name.

       <b>-verify_hostname</b> <u>hostname</u>
           Verify  if  <u>hostname</u>  matches  DNS  name  in  Subject  Alternative Name or Common Name in the subject
           certificate.

       <b>-verify_ip</b> <u>ip</u>
           Verify if <u>ip</u> matches the IP address in Subject Alternative Name of the subject certificate.

       <b>-verify_name</b> <u>name</u>
           Use a set of verification parameters, also known as verification  method,  identified  by  <u>name</u>.  The
           currently  predefined  methods are named "ssl_client", "ssl_server", "smime_sign" with alias "pkcs7",
           "code_sign", and "default".  These mimic the combinations of  purpose  and  trust  settings  used  in
           SSL/(D)TLS, CMS/PKCS7 (including S/MIME), and code signing.

           The  verification  parameters  include the trust model, various flags that can partly be set also via
           other command-line options, and the verification purpose, which in turn implies certificate key usage
           and extended key usage requirements.

           The trust model determines which auxiliary trust or reject OIDs are applicable to verifying the given
           certificate chain.  They can be given using the <b>-addtrust</b> and <b>-addreject</b> options for <b><a href="../man1/openssl-x509.1.html">openssl-x509</a></b>(1).

   <b>Extended</b> <b>Verification</b> <b>Options</b>
       Sometimes there may be more than one certificate  chain  leading  to  an  end-entity  certificate.   This
       usually  happens  when  a  root  or  intermediate  CA  signs  a  certificate  for  another  a CA in other
       organization.  Another reason is when a CA might have intermediates  that  use  two  different  signature
       formats, such as a SHA-1 and a SHA-256 digest.

       The  following  options  can  be  used to provide data that will allow the OpenSSL command to generate an
       alternative chain.

       <b>-xkey</b> <u>infile</u>, <b>-xcert</b> <u>infile</u>, <b>-xchain</b>
           Specify an extra certificate, private key and certificate chain. These behave in the same  manner  as
           the  <b>-cert</b>,  <b>-key</b>  and  <b>-cert_chain</b>  options.  When specified, the callback returning the first valid
           chain will be in use by the client.

       <b>-xchain_build</b>
           Specify whether the application should build the certificate chain to be provided to the  server  for
           the extra certificates via the <b>-xkey</b>, <b>-xcert</b>, and <b>-xchain</b> options.

       <b>-xcertform</b> <b>DER</b>|<b>PEM</b>|<b>P12</b>
           The  input  format for the extra certificate.  This option has no effect and is retained for backward
           compatibility only.

       <b>-xkeyform</b> <b>DER</b>|<b>PEM</b>|<b>P12</b>
           The input format for the extra key.   This  option  has  no  effect  and  is  retained  for  backward
           compatibility only.

   <b>Certificate</b> <b>Extensions</b>
       Options  like  <b>-purpose</b> and <b>-verify_name</b> trigger the processing of specific certificate extensions, which
       determine what certificates can be used for.

       <u>Basic</u> <u>Constraints</u>

       The basicConstraints extension CA flag is used to determine whether the certificate can be used as a  CA.
       If  the CA flag is true then it is a CA, if the CA flag is false then it is not a CA. <b>All</b> CAs should have
       the CA flag set to true.

       If the basicConstraints extension is absent, which includes the case that it is an  X.509v1  certificate,
       then  the  certificate  is considered to be a "possible CA" and other extensions are checked according to
       the intended use of the certificate.  The treatment of certificates without basicConstraints as a  CA  is
       presently supported, but this could change in the future.

       <u>Key</u> <u>Usage</u>

       If  the keyUsage extension is present then additional restraints are made on the uses of the certificate.
       A CA certificate <b>must</b> have the keyCertSign bit set if the keyUsage extension is present.

       <u>Extended</u> <u>Key</u> <u>Usage</u>

       The extKeyUsage (EKU) extension places additional restrictions on certificate use. If this  extension  is
       present  (whether  critical  or  not)  in an end-entity certficiate, the key is allowed only for the uses
       specified, while the special EKU <b>anyExtendedKeyUsage</b> allows for all uses.

       Note that according to RFC 5280 section 4.2.1.12, the Extended Key Usage extension will  appear  only  in
       end-entity  certificates,  and  consequently  the standard certification path validation described in its
       section 6 does not include EKU checks for CA certificates.  The CA/Browser Forum requires for TLS server,
       S/MIME, and code signing use the presence of  respective  EKUs  in  subordinate  CA  certificates  (while
       excluding  them  for  root  CA  certificates),  while  taking over from RFC 5280 the certificate validity
       concept and certificate path validation.

       For historic reasons, OpenSSL has its  own  way  of  interpreting  and  checking  EKU  extensions  on  CA
       certificates,  which  may change in the future.  It does not require the presence of EKU extensions in CA
       certificates,  but  in  case  the  verification  purpose  is  "sslclient",  "nssslserver",   "sslserver",
       "smimesign",  or  "smimeencrypt",  it  checks  that  any  present  EKU  extension  (that does not contain
       <b>anyExtendedKeyUsage</b>) contains the respective EKU as detailed below.  Moreover, it does these checks  even
       for trust anchor certificates.

       <u>Checks</u> <u>Implied</u> <u>by</u> <u>Specific</u> <u>Predefined</u> <u>Policies</u>

       A specific description of each check is given below. The comments about basicConstraints and keyUsage and
       X.509v1 certificates above apply to <b>all</b> CA certificates.

       <b>(D)TLS</b> <b>Client</b> ("sslclient")
           Any given extended key usage extension must allow for "clientAuth" ("TLS WWW client authentication").

           For  target certificates, the key usage must allow for "digitalSignature" and/or "keyAgreement".  The
           Netscape certificate type must be absent or have the SSL client bit set.

           For all other certificates the normal CA checks apply. In addition,  the  Netscape  certificate  type
           must  be  absent  or  have  the SSL CA bit set.  This is used as a workaround if the basicConstraints
           extension is absent.

       <b>(D)TLS</b> <b>Server</b> ("sslserver")
           Any given extended key usage extension must allow for "serverAuth" ("TLS WWW server  authentication")
           and/or include one of the SGC OIDs.

           For  target  certificates, the key usage must allow for "digitalSignature", "keyEncipherment", and/or
           "keyAgreement".  The Netscape certificate type must be absent or have the SSL server bit set.

           For all other certificates the normal CA checks apply. In addition,  the  Netscape  certificate  type
           must  be  absent  or  have  the SSL CA bit set.  This is used as a workaround if the basicConstraints
           extension is absent.

       <b>Netscape</b> <b>SSL</b> <b>Server</b> ("nssslserver")
           In addition to what has been described for <b>sslserver</b>, for a Netscape SSL client to connect to an  SSL
           server, its EE certficate must have the <b>keyEncipherment</b> bit set if the keyUsage extension is present.
           This  isn't always valid because some cipher suites use the key for digital signing.  Otherwise it is
           the same as a normal SSL server.

       <b>Common</b> <b>S/MIME</b> <b>Checks</b>
           Any given extended key usage extension must allow for "emailProtection".

           For target certificates, the Netscape certificate type must be absent or should have the  S/MIME  bit
           set.   If  the  S/MIME  bit  is  not  set in the Netscape certificate type then the SSL client bit is
           tolerated as an alternative but a warning is shown.  This is because some Verisign certificates don't
           set the S/MIME bit.

           For all other certificates the normal CA checks apply. In addition,  the  Netscape  certificate  type
           must  be  absent or have the S/MIME CA bit set.  This is used as a workaround if the basicConstraints
           extension is absent.

       <b>S/MIME</b> <b>Signing</b> ("smimesign")
           In addition to the common S/MIME checks, for  target  certficiates  the  key  usage  must  allow  for
           "digitalSignature" and/or <b>nonRepudiation</b>.

       <b>S/MIME</b> <b>Encryption</b> ("smimeencrypt")
           In  addition  to  the  common  S/MIME  checks,  for  target certficiates the key usage must allow for
           "keyEncipherment".

       <b>CRL</b> <b>Signing</b> ("crlsign")
           For target certificates, the key usage must allow for "cRLSign".

           For all other certifcates the normal CA checks apply.   Except  in  this  case  the  basicConstraints
           extension must be present.

       <b>OCSP</b> <b>Helper</b> ("ocsphelper")
           For  target  certificates,  no  checks  are  performed  at  this stage, but special checks apply; see
           <b><a href="../man3/OCSP_basic_verify.3.html">OCSP_basic_verify</a></b>(3).

           For all other certifcates the normal CA checks apply.

       <b>Timestamp</b> <b>Signing</b> ("timestampsign")
           For target certificates, if the key usage extension is present, it  must  include  "digitalSignature"
           and/or  "nonRepudiation"  and  must  not  include  other bits.  The EKU extension must be present and
           contain "timeStamping" only.  Moreover, it must be marked as critical.

           For all other certifcates the normal CA checks apply.

       <b>Code</b> <b>Signing</b> ("codesign")
           For target certificates, the key usage extension must be present  and  marked  critical  and  include
           &lt;digitalSignature&gt;,  but  must  not  include  "keyCertSign" nor "cRLSign".  The EKU extension must be
           present and contain "codeSign", but must not include "anyExtendedKeyUsage" nor "serverAuth".

           For all other certifcates the normal CA checks apply.

</pre><h4><b>BUGS</b></h4><pre>
       The issuer checks still suffer from limitations in the underlying X509_LOOKUP API.   One  consequence  of
       this  is  that trusted certificates with matching subject name must appear in a file (as specified by the
       <b>-CAfile</b> option), a directory (as specified by <b>-CApath</b>), or a store (as specified by <b>-CAstore</b>).  If  there
       are  multiple such matches, possibly in multiple locations, only the first one (in the mentioned order of
       locations) is recognised.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/X509_verify_cert.3.html">X509_verify_cert</a></b>(3),    <b><a href="../man3/OCSP_basic_verify.3.html">OCSP_basic_verify</a></b>(3),    <b><a href="../man1/openssl-verify.1.html">openssl-verify</a></b>(1),    <b><a href="../man1/openssl-ocsp.1.html">openssl-ocsp</a></b>(1),    <b><a href="../man1/openssl-ts.1.html">openssl-ts</a></b>(1),
       <b><a href="../man1/openssl-s_client.1.html">openssl-s_client</a></b>(1), <b><a href="../man1/openssl-s_server.1.html">openssl-s_server</a></b>(1), <b><a href="../man1/openssl-smime.1.html">openssl-smime</a></b>(1), <b><a href="../man1/openssl-cmp.1.html">openssl-cmp</a></b>(1), <b><a href="../man1/openssl-cms.1.html">openssl-cms</a></b>(1)

</pre><h4><b>HISTORY</b></h4><pre>
       The checks enabled by <b>-x509_strict</b> have been extended in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.4.1                                              2025-04-03                 <u><a href="../man1SSL/OPENSSL-VERIFICATION-OPTIONS.1SSL.html">OPENSSL-VERIFICATION-OPTIONS</a></u>(1SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>