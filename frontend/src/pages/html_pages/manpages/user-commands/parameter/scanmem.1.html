<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scanmem - locate and modify variables in an executing process.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/scanmem">scanmem_0.17-5build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       scanmem - locate and modify variables in an executing process.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>scanmem</b> [options] <u>[target-program-pid]</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>scanmem</b>  is  an interactive debugging utility that can be used to isolate the address of a variable in an
       executing process by successively scanning the process' address space looking for matching values.
       By informing <b>scanmem</b> how the value of the variable  changes  over  time,  it  can  determine  the  actual
       location (or locations) of the variable by successively eliminating non-matches.
       <b>scanmem</b> determines where to look by searching for mappings with <u>read</u>/<u>write</u> permission, these are referred
       to  as regions. Users can eliminate regions they believe are likely unrelated to the target variable (for
       example, located in a shared library unrelated to the variable in question), this will improve the  speed
       of the scan, which can initially be quite slow in large programs.

       Once a variable has been found, <b>scanmem</b> can monitor the variable, or change it to a user specified value,
       either once, or continually over a period of time.

       <b>scanmem</b> works similarly to the "<u>pokefinders</u>" once commonly used to cheat at video games, this function is
       a good demonstration of how to use <b>scanmem</b>, and is used in the documentation.

</pre><h4><b>USAGE</b></h4><pre>
       <b>scanmem</b>  should  be  invoked  with  the process id of the program you wish to debug as an argument.  Once
       started, <b>scanmem</b> accepts interactive commands.  These are described below, however entering <b>help</b> at the <b>&gt;</b>
       prompt will allow you to access <b>scanmem</b>'s online documentation.

       The <u>target-program-pid</u> can be specified in decimal, hexadecimal, or octal using the standard  C  language
       notation (leading 0x for hexadecimal, leading 0 for octal, anything else is assumed to be decimal).

       <b>-p,</b> <b>--pid=</b><u>pid</u>
              Set the <u>target-program-pid</u>.

       <b>-c,</b> <b>--command=</b><u>cmd1[;cmd2][;...]</u>
              Run given commands (separated by ";") before starting the interactive shell.

       <b>-v,</b> <b>--version</b>
              Print version and exit.

       <b>-h,</b> <b>--help</b>
              Print a short description of command line options then exit.

       <b>-d,</b> <b>--debug</b>
              Run in debug mode, more information will be outputted.

       <b>-e,</b> <b>--errexit</b>
              Exit on initial commands error, ignored during interactive mode.

</pre><h4><b>COMMANDS</b></h4><pre>
       While  in  interactive  mode,  <b>scanmem</b>  prints  a decimal number followed by <b>&gt;</b>, the number is the current
       number of possible candidates for the target  variable  that  are  known.  The  absence  of  said  number
       indicates that no possible variables have been eliminated yet.
       The default scan data type is "int".  It can be changed with the <b>option</b> command.

       <b>n</b>      Where  <b>n</b>  represents  any number in decimal, octal or hexadecimal, this command tells <b>scanmem</b> that
              the current value of the target variable is exactly <b>n</b>.  <b>scanmem</b> will begin a search of the  entire
              address space, or the existing known matches (if any), eliminating any variable that does not have
              this value.

       <b>n..m</b>   This  is  like the <b>n</b> command but <b>scanmem</b> searches for a range of numbers between <b>n</b> and <b>m</b> inclusive
              instead.

       <b>&gt;</b>, <b>&lt;</b>, <b>+</b>, <b>-</b>, <b>=</b>, <b>!=</b>
              The following commands are extremely useful for locating a variable whose exact  value  we  cannot
              see,  but  we can see how it changes over time, e.g. an health bar.  These commands usually cannot
              be used for the first scan but there are some exceptions: <b>&gt;</b> n, <b>&lt;</b> n, <b>=</b> n and <b>!=</b> n.

              <b>&gt;</b> <u>[n]</u>  If <u>n</u> is given, match values that are greater than <u>n</u>.  Otherwise match all values that  have
                     increased.

              <b>&lt;</b> <u>[n]</u>  If  <u>n</u>  is  given,  match values that are less than <u>n</u>.  Otherwise match all values that have
                     decreased.

              <b>+</b> <u>[n]</u>  If <u>n</u> is given, match values that have been increased by <u>n</u>.  Otherwise match all values that
                     have increased (same as <b>&gt;</b>).

              <b>-</b> <u>[n]</u>  If <u>n</u> is given, match values that have been decreased by <u>n</u>.  Otherwise match all values that
                     have decreased (same as <b>&lt;</b>).

              <b>=</b> <u>[n]</u>  If <u>n</u> is given, match values that are equal to <u>n</u> (same as <b>n</b>).  Otherwise  match  all  values
                     that have not changed.

              <b>!=</b> <u>[n]</u> If  <u>n</u>  is  given,  match values that are different from <u>n</u>.  Otherwise match all values that
                     have changed.

       <b>snapshot</b>
              Match any value. This is useful when an initial value or range is not known for  subsequent  scans
              with <b>&gt;</b>, <b>&lt;</b>, <b>+</b>, <b>-</b>, <b>=</b>, and <b>!=</b>.

       <b>"</b> <u>text</u> Search for the provided <u>text</u> in memory if the scan data type is set to "string".

       <b>update</b> Scans  the  current process, getting the current values of all matches. These values can be viewed
              with <b>list</b>, and are also the old values that <b>scanmem</b> compares to when  using  <b>&gt;</b>,  <b>&lt;</b>,  or  <b>=</b>.   This
              command is equivalent to a search command that all current results match.

       <b>list</b> <u>[max_to_print]</u>
              List  up  to  <u>max_to_print</u>  (default:  <u>10k</u>)  possible  candidates currently known, including their
              address, region id, match offset, region type, last known value and  possible  value  types.   The
              value  in the first column is the match id, and can be used in conjunction with the <b>delete</b> command
              to eliminate matches.

              The match offset is determined by subtracting the load address  of  the  associated  ELF  file  or
              region from the address. It can be used to bypass Address Space Layout Randomization (ASLR).

       <b>delete</b> <u>match-id_set</u>
              Delete  matches  in  the  <u>match-id_set</u>.   The  <u>match-ids</u>  can be found from the output of the <b>list</b>
              command.  Set notation: <u>[!][..a](,b..c</u> <u>|</u> <u>d,</u> <u>...)[e..]</u>.
              To delete all known matches, see the <b>reset</b> command.
              To delete all the matches associated with a particular library, see  the  <b>dregion</b>  command,  which
              also removes any associated matches.
              Please note that match-ids may be recalculated after matches are removed or added.

       <b>watch</b> <u>match-id</u>
              Monitor  the  value  of <u>match-id</u>, and print its value as it changes. Every change is printed along
              with a timestamp, you can interrupt this command with ^C to stop monitoring.

       <b>set</b> <u>[match-id_set=]value[/delay]</u> <u>[...]</u>
              Set the value <u>value</u> into the match  numbers  specified  in  <u>match-id_set</u>,  or  if  just  <u>value</u>  is
              specified,  all known matches.  <u>value</u> can be specified in standard C language notation.  All known
              matches, along with their match-id's can be displayed using the  <b>list</b>  command.   Multiple  <u>match-</u>
              <u>id_set</u>s can be specified, terminated with an <u>=</u> sign.  Set notation: <u>[!][..a](,b..c</u> <u>|</u> <u>d,</u> <u>...)[e..]</u>.
              To  set  a  value continually, suffix the command with <u>/</u> followed by the number of seconds to wait
              between sets. You can interrupt the set command with ^C to return to the <b>scanmem</b> prompt.  This can
              be used to sustain the value of a variable which decreases over time, for example a timer that  is
              decremented  every  second  can  be set to 100 every 10 seconds to prevent some property from ever
              changing.

              This command is used to change the value of the variable(s) once  found  by  elimination.   Please
              note, some applications will store values in multiple locations.

       <b>write</b> <u>value_type</u> <u>address</u> <u>value</u>
              Manually set the value of the variable at the specified address.
              Names  of  <u>value_type</u>  are subject to change in different versions of <b>scanmem</b>, see more info using
              the `help write` command.

       <b>dump</b> <u>address</u> <u>length</u> <u>[filename]</u>
              Dump the memory region starting from <u>address</u> of length <u>length</u> in a human-readable format.

              If <u>filename</u> is given, data will be saved into the  file,  otherwise  data  will  be  displayed  on
              stdout.

       <b>pid</b> <u>[new-pid]</u>
              Print  out  the  process  id of the current target program, or change the target to <u>new-pid</u>, which
              will reset existing regions and matches.

       <b>reset</b>  Forget all known regions and matches and start again.

       <b>lregions</b>
              List all the known regions, this can be used in combination with the <b>dregion</b> command to  eliminate
              regions  that  the  user  believes  are not related to the variable in question, thus reducing the
              address space required to search in. The value in the first column is the <u>region-id</u> which must  be
              passed  to  the  <b>dregion</b> command. Besides the start address, the size and path (if applicable) are
              also printed. This can be used to eliminate regions located in shared libraries that are  unlikely
              to be relevant to the variable required.

              For  experts:  Also  the  region  type  and  the  load  address are displayed. The types are "exe"
              (executable) "code" (library), "heap", "stack" or "misc" (everything else). The  load  address  is
              the  memory location where an ELF file (exe/lib) has been loaded to. This helps to convert between
              the addresses in memory and in the associated ELF file. If the region does not belong  to  an  ELF
              file, then it is the same as the start address.

       <b>dregion</b> <u>region-id_set</u>
              Delete  the  regions  in <u>region-id_set</u>, along with any matches from the match list.  Set notation:
              <u>[!][..a](,b..c</u> <u>|</u> <u>d,</u> <u>...)[e..]</u>.
              The <u>region-id</u>'s can be found in the output of the <b>lregions</b> command.

       <b>option</b> <u>name</u> <u>value</u>
              Change options at runtime. E.g. the scan data type can be changed.   See  `help  option`  for  all
              possible names/values.

       <b>shell</b> <u>shell-command</u>
              Execute <u>shell-command</u> using <a href="file:/bin/sh">/bin/sh</a>, then return.

       <b>show</b> <u>info</u>
              Display information relating to <u>info</u> - see `help show` for details.

       <b>version</b>
              Print the version of <b>scanmem</b> in use.

       <b>help</b>   Print a short summary of available commands.

       <b>exit</b>   Detach from the target program and exit immediately.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Cheat at nethack, on systems where nethack is not installed sgid.

       <b>ATTENTION:</b> <b>scanmem</b> usually requires root privileges. See <b>KNOWN</b> <b>ISSUES</b> for details.

       $ sudo scanmem `pgrep nethack`
       info: maps file located at /proc/14658/maps opened.
       info: 9 suitable regions found.
       Please enter current value, or "help" for other commands.
       &gt;

       I enter how much gold I currently have (58 pieces) and let <b>scanmem</b> find the potential candidates.

       &gt; 58
       01/09 searching   0x79f000 -   0x7b0000..........ok
       02/09 searching   0x7b0000 -   0x7cc000..........ok
       03/09 searching  0x24d2000 -  0x24f3000..........ok
       04/09 searching 0x7fcc04baa000 - 0x7fcc04bae000..........ok
       05/09 searching 0x7fcc04de1000 - 0x7fcc04de2000..........ok
       06/09 searching 0x7fcc051f7000 - 0x7fcc051fb000..........ok
       07/09 searching 0x7fcc05227000 - 0x7fcc0522a000..........ok
       08/09 searching 0x7fcc0522c000 - 0x7fcc0522d000..........ok
       09/09 searching 0x7ffc8c113000 - 0x7ffc8c134000..........ok
       info: we currently have 16 matches.
       16&gt; list
       [ 0]       7b09e0,  1 +       3b09e0,   exe, 58, [I64 I32 I16 I8 ]
       [ 1]       7b907a,  1 +       3b907a,   exe, 58, [I8 ]
       [ 2]      24d4b6c,  2 +         2b6c,  heap, 58, [I16 I8 ]
       [ 3]      24d567e,  2 +         367e,  heap, 58, [I16 I8 ]
       [ 4]      24d5740,  2 +         3740,  heap, 58, [I8 ]
       [ 5] 7fcc05229951,  6 +         2951,  misc, 58, [I8 ]
       [ 6] 7ffc8c12ee28,  8 +        1be28, stack, 58, [I16 I8 ]
       [ 7] 7ffc8c132381,  8 +        1f381, stack, 58, [I8 ]
       [ 8] 7ffc8c132389,  8 +        1f389, stack, 58, [I8 ]
       [ 9] 7ffc8c132391,  8 +        1f391, stack, 58, [I8 ]
       [10] 7ffc8c132399,  8 +        1f399, stack, 58, [I8 ]
       [11] 7ffc8c1323a1,  8 +        1f3a1, stack, 58, [I8 ]
       [12] 7ffc8c1323a9,  8 +        1f3a9, stack, 58, [I8 ]
       [13] 7ffc8c1331a3,  8 +        201a3, stack, 58, [I8 ]
       [14] 7ffc8c13325f,  8 +        2025f, stack, 58, [I8 ]
       [15] 7ffc8c133264,  8 +        20264, stack, 58, [I8 ]
       16&gt;

       16 potential matches were found. This is also displayed in the prompt.  Many of them are quite unrelated,
       as they are part of the stack, belong to libraries or miscellaneous memory-mapped files. Even the heap is
       unlikely  for  a  very  old  command  line game. We could make <b>scanmem</b> eliminate these manually using the
       <b>delete</b> command, however just waiting until the amount of gold changes and telling <b>scanmem</b> the  new  value
       should be enough. I find some more gold, and tell <b>scanmem</b> the new value, 83.

       16&gt; 83
       ..........info: we currently have 1 matches.
       info: match identified, use "set" to modify value.
       info: enter "help" for other commands.
       1&gt; list
       [ 0]       7b09e0,  1 +       3b09e0,   exe, 83, [I64 I32 I16 I8 ]

       Only  one of the 16 original candidates now has the value 83, so this must be where the amount of gold is
       stored. I'll try setting it to 10,000 pieces.

       1&gt; set 10000
       info: setting *0x7b09e0 to 0x2710...
       1&gt;

       The resulting nethack status:

       Dlvl:1  $:10000 HP:<a href="../man15/15.15.html">15</a>(15) Pw:<a href="../man2/2.2.html">2</a>(2) AC:7  Exp:1

       Conclusion: We've found and modified the gold value as I32 in static memory of the executable at  virtual
       memory address 0x7b09e0. This address belongs to the region with id 1.

       Now  it  is important to know if this is a position-independent executable (PIE). We list the regions for
       this and check the load address of the executable.

       1&gt; lregions
       [ 0]       79f000,   69632 bytes,   exe,       400000, rw-, /usr/lib/nethack/nethack.tty
       [ 1]       7b0000,  114688 bytes,   exe,       400000, rw-, unassociated
       [ 2]      24d2000,  135168 bytes,  heap,      24d2000, rw-, [heap]
       [ 3] 7fcc04baa000,   16384 bytes,  misc, 7fcc04baa000, rw-, unassociated
       [ 4] 7fcc04de1000,    4096 bytes,  misc, 7fcc04de1000, rw-, unassociated
       [ 5] 7fcc051f7000,   16384 bytes,  misc, 7fcc051f7000, rw-, unassociated
       [ 6] 7fcc05227000,   12288 bytes,  misc, 7fcc05227000, rw-, unassociated
       [ 7] 7fcc0522c000,    4096 bytes,  misc, 7fcc0522c000, rw-, unassociated
       [ 8] 7ffc8c113000,  135168 bytes, stack, 7ffc8c113000, rw-, [stack]

       We are on x86_64 and 0x400000 is the static load address for executables there. This means that  this  is
       not  a  PIE  and  the  gold  is  always stored at 0x7b09e0. This makes it easy to use a game trainer like
       GameConqueror which refills the gold value periodically.

       With a PIE we have to use the match offset (0x3b09e0 here) instead and an advanced game trainer with  PIE
       support  has to determine and add the current load address to it to get the current memory address of the
       gold value of the current game run.

</pre><h4><b>NOTES</b></h4><pre>
       <b>scanmem</b> has been tested on multiple large programs, including the 3d shoot-em-up quake3  linux.   <b>scanmem</b>
       is also tested on ARM platforms and comes with Android support since version 0.16.

       Obviously, <b>scanmem</b> can crash your program if used incorrectly.

       Some programs store values in multiple locations, this is why <b>set</b> will change all known matches.

       Address Space Layout Randomization (ASLR) together with position-independent executables (PIE), position-
       independent  code  (PIC)  or dynamic memory on the heap causes variables to be loaded to different memory
       addresses at every game start. Advanced game trainers like ugtrain are required  to  periodically  refill
       variables is such memory regions.

</pre><h4><b>KNOWN</b> <b>ISSUES</b></h4><pre>
       <b>scanmem</b>  usually  requires  root  privileges  for  <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2)  because  security  modules control ptrace()
       capabilities. On  x86  and  x86_64  there  is  usually  the  <b>Yama</b>  security  module  providing  the  file
       <u><a href="file:/proc/sys/kernel/yama/ptrace_scope">/proc/sys/kernel/yama/ptrace_scope</a></u>.   It  is  available  since Linux 3.4. If this file contains "1", then
       only parents may ptrace() their children without root privileges. This means that <b>scanmem</b> would  have  to
       run the game. This is not possible as this would require major design changes. So we run <b>scanmem</b> as root.

       The  first  scan  can  be very slow on large programs, this is not a problem for subsequent scans as huge
       portions of the address space are usually eliminated. This  could  be  improved  in  future,  perhaps  by
       assuming all integers are aligned by default. Suggestions welcome.

       The <b>snapshot</b> command uses memory inefficiently, and should probably not be used on large programs.

</pre><h4><b>HOMEPAGE</b></h4><pre>
       https://github.com/scanmem/scanmem

</pre><h4><b>AUTHORS</b></h4><pre>
       Tavis Ormandy &lt;taviso(a)sdf.lonestar.org&gt; <a href="http://taviso.decsystem.org/">http://taviso.decsystem.org/</a>
       Eli   Dupree  &lt;elidupree(a)charter.net&gt;
       WANG  Lu      &lt;coolwanglu(a)gmail.com&gt;
       Sebastian Parschauer &lt;s.parschauer(a)gmx.de&gt;
       Andrea Stacchiotti &lt;andreastacchiotti(a)gmail.com&gt;

       All bug reports, suggestions or feedback welcome.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/gameconqueror.1.html">gameconqueror</a>(1) <a href="../man2/ptrace.2.html">ptrace</a>(2) <a href="../man5/proc.5.html">proc</a>(5) <a href="../man6/nethack.6.html">nethack</a>(6) <a href="../man8/pidof.8.html">pidof</a>(8)

scanmem-0.17                                       2017-10-11                                         <u><a href="../man1/scanmem.1.html">scanmem</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>