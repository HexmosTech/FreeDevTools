<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>likwid-pin - pin a sequential or threaded application to dedicated processors</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/likwid">likwid_5.4.1+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       likwid-pin - pin a sequential or threaded application to dedicated processors

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>likwid-pin</b> [-vhSpqim] [<b>-V</b> <u>&lt;verbosity&gt;</u>] [<b>-c/-C</b> <u>&lt;corelist&gt;</u>] [<b>-s</b> <u>&lt;skip_mask&gt;</u>] [<b>-d</b> <u>&lt;delim&gt;</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>likwid-pin</b>  is  a  command line application to pin a sequential or multithreaded application to dedicated
       processors. It can be used as replacement for taskset.  Opposite to taskset no affinity mask  but  single
       processors are specified.  For multithreaded applications based on the pthread library the <b>pthread_create</b>
       library  call is overloaded through LD_PRELOAD and each created thread is pinned to a dedicated processor
       as specified in <u>core_list</u> <u>.</u>

       Per default every generated thread is pinned to the core in the order of calls to  <b>pthread_create</b>  it  is
       possible to skip single threads.

       The  OpenMP  implementations  of  GCC and ICC compilers are explicitly supported.  Clang's OpenMP backend
       should also work as it is built on top of Intel's OpenMP runtime library.  Others may also  work  <b>likwid-</b>
       <b>pin</b>  sets  the  environment variable <b>OMP_NUM_THREADS</b> for you if not already present.  It will set as many
       threads as present in the pin expression. Be aware that with pthreads the parent thread is always pinned.
       If you create for example 4 threads with <b>pthread_create</b> and do not use the parent process as  worker  you
       still have to provide <b>num_threads+1</b> processor ids.

       <b>likwid-pin</b> supports different numberings for pinning. See section <b>CPU</b> <b>EXPRESSION</b> for details.

       For  applications  where  first touch policy on NUMA systems cannot be employed <b>likwid-pin</b> can be used to
       turn on interleave memory placement. This can significantly speed up  the  performance  of  memory  bound
       multithreaded codes. All NUMA nodes the user pinned threads to are used for interleaving.

       LIKWID  introduces the concept of affinity domains which can be described as all hardware threads sharing
       a topological entity. There are, for example, affinity domains for each CPU socket in the system and each
       of these affinity domains contains the hardware threads that belong to the  socket.  There  is  always  a
       virtual  affinity  domain  'N' for the whole node, thus all hardware threads. Further names are 'Sx' with
       'x' as socket offset ('S0', 'S1', 'S2', ...), 'Dy' with 'y' as CPU die offset,  'Mz'  with  'z'  as  NUMA
       domain offset and 'Cx' with 'x' as last level cache offset. It is the offset of the topological entities,
       so  when  there  are  two  sockets  with  IDs 74 und 10023 (systems like this exist), the socket affinity
       domains are 'S0' and 'S1'.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-h,--help</b>
              prints a help message to standard output, then exits.

       <b>-v,--version</b>
              prints version information to standard output, then exits.

       <b>-V,</b> <b>--verbose</b> <b>&lt;level&gt;</b>
              verbose output during execution for debugging. 0 for only errors, 1 for  informational  output,  2
              for detailed output and 3 for developer output

       <b>-c,-C</b> <b>&lt;cpu</b> <b>expression&gt;</b>
              specify  a numerical list of processors. The list may contain multiple  items, separated by comma,
              and ranges. For example 0,3,9-11. Other format are available, see the <b>CPU</b> <b>EXPRESSION</b> section.

       <b>-s,</b> <b>--skip</b> <b>&lt;skip_mask&gt;</b>
              Specify skip mask as HEX number. For each set bit the corresponding thread is skipped.

       <b>-S,--sweep</b>
              All ccNUMA memory domains belonging to the specified thread list will be cleaned before  the  run.
              Can solve file buffer cache problems on Linux.

       <b>-p</b>     prints the available thread domains for logical pinning

       <b>-i</b>     set NUMA memory policy to interleave involving all NUMA nodes involved in pinning

       <b>-m</b>     set NUMA memory policy to membind involving all NUMA nodes involved in pinning

       <b>-d</b> <b>&lt;delim&gt;</b>
              usable with <b>-p</b> to specify the CPU delimiter in the cpulist

       <b>-q,--quiet</b>
              silent execution without output

</pre><h4><b>CPU</b> <b>EXPRESSION</b></h4><pre>
       1.  The  most intuitive CPU selection method is a comma-separated list of hardware thread IDs. An example
           for this is <b>0,2</b> which schedules the threads on hardware threads <b>0</b> and <b>2.</b>  The physical numbering also
           allows the usage of ranges like <b>0-2</b> which results in the list <b>0,1,2.</b>

       2.  The  CPUs  can  be  selected  by  their  indices  inside  of  an  affinity  domain.  The  format   is
           <b>L:&lt;domain&gt;:&lt;indexlist&gt;</b>  for  selecting the CPUs inside the given domain. Assuming an virtual affinity
           domain <b>'P'</b> that contains the CPUs <b>0,4,1,5,2,6,3,7.</b>   After  sorting  it  to  have  physical  hardware
           threads  first we get: <b>0,1,2,3,4,5,6,7.</b>  The logical numbering <b>L:P:0-2</b> results in the selection <b>0,1,2</b>
           from the physical hardware threads first list.

       3.  The expression syntax enables the selection according to an selection function  with  variable  input
           parameters.   The   format   is   either  <b>E:&lt;affinity</b>  <b>domain&gt;:&lt;numberOfThreads&gt;</b>  to  use  the  first
           &lt;numberOfThreads&gt;    threads    in    affinity    domain    &lt;affinity    domain&gt;    or    <b>E:&lt;affinity</b>
           <b>domain&gt;:&lt;numberOfThreads&gt;:&lt;chunksize&gt;:&lt;stride&gt;</b>  to  use  &lt;numberOfThreads&gt;  threads  with &lt;chunksize&gt;
           threads selected in row while  skipping  &lt;stride&gt;  threads  in  affinity  domain  &lt;affinity  domain&gt;.
           Examples  are <b>E:N:4:1:2</b> for selecting the first four physical CPUs on a system with 2 hardware thread
           per CPU core or <b>E:P:4:2:4</b> for choosing the first two threads in affinity domain <b>P,</b> skipping 2 threads
           and selecting again two threads. The resulting CPU list for virtual affinity domain <b>P</b> is <b>0,4,2,6</b>

       3.  The last format schedules the threads not only in a  single  affinity  domain  but  distributed  them
           evenly  over  all  available affinity domains of the same kind. In contrast to the other formats, the
           selection is done using the physical hardware threads first and then  the  virtual  hardware  threads
           (aka  SMT threads). The format is <b>&lt;affinity</b> <b>domain</b> <b>without</b> <b>number&gt;:scatter</b> like <b>M:scatter</b> to schedule
           the threads evenly in all available memory affinity domains. Assuming the two  socket  domains  <b>S0</b>  <b>=</b>
           <b>0,4,1,5</b>  and  <b>S1</b>  <b>=</b>  <b>2,6,3,7</b> the expression <b>S:scatter</b> results in the CPU list <b>0,2,1,3,4,6,5,7</b> Besides
           scatter, there is also 'balanced' (close pinning over  domains  in  natural  order)  and  'cbalanced'
           (close  pinning  over  domain  with  physical  cores first). If we assume the socket setup above, the
           expression <b>S:balanced:4</b> results in the CPU list  <b>0,4,2,6</b>  while  with  cbalanced,  the  CPU  list  is
           (assuming 4-7 being SMT threads) <b>0,1,2,3</b>

</pre><h4><b>EXAMPLE</b></h4><pre>
       1.   For standard pthread application:

       <b>likwid-pin</b> <b>-c</b> <b>0,2,4-6</b> <b>./myApp</b>

       The  parent  process  is  pinned  to  processor 0 which is likely to be thread 0 in <b>./myApp.</b>  Thread 1 is
       pinned to processor 2, thread 2 to processor 4, thread 3 to processor 5 and thread 4 to processor  6.  If
       more threads are created than specified in the processor list, these threads are pinned to processor 0 as
       fallback.

       2.   For  selection  of  CPUs  inside  of a CPUset only the logical numbering is allowed. Assuming CPUset
            <b>0,4,1,5:</b>

       <b>likwid-pin</b> <b>-c</b> <b>L:N:1,3</b> <b>./myApp</b>

       This command pins <b>./myApp</b> on CPU <b>4</b> and the thread started by <b>./myApp</b> on CPU <b>5</b>

       3.   A common use-case for the numbering by expression is pinning of an application on the Intel Xeon Phi
            coprocessor with its 60 cores each having 4 SMT threads.

       <b>likwid-pin</b> <b>-c</b> <b>E:N:60:1:4</b> <b>./myApp</b>

       This command schedules one applicationn thread per physical CPU core for <b>./myApp.</b>

</pre><h4><b>IMPORTANT</b> <b>NOTICE</b></h4><pre>
       The detection of shepard threads works for Intel's/LLVM OpenMP runtime (&gt;=12.0), for GCC's OpenMP runtime
       as well as for PGI's OpenMP runtime. If you encounter problems with pinning, please  set  a  proper  skip
       mask  to  skip  the  not-detected shepard threads.  Intel OpenMP runtime 11.0/11.1 requires to set a skip
       mask of <b>0x1.</b>

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Thomas Gruber &lt;<a href="mailto:thomas.roehl@googlemail.com">thomas.roehl@googlemail.com</a>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       Report Bugs on &lt;https://github.com/RRZE-HPC/likwid/issues&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/taskset.1.html">taskset</a>(1), <a href="../man1/likwid-perfctr.1.html">likwid-perfctr</a>(1), <a href="../man1/likwid-features.1.html">likwid-features</a>(1), <a href="../man1/likwid-topology.1.html">likwid-topology</a>(1),

likwid-VERSION                                     09.12.2024                                      <u><a href="../man1/LIKWID-PIN.1.html">LIKWID-PIN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>