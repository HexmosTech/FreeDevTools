<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mpirun  and  mpiexec  are  synonyms  for  each  other.   Indeed,  they  are symbolic links to the same</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/openmpi-bin">openmpi-bin_5.0.7-1_amd64</a> <br><br><pre>
</pre><h4><b>NOTE:</b></h4><pre>
          <b>mpirun</b>  and  <b>mpiexec</b>  are  synonyms  for  each  other.   Indeed,  they  are symbolic links to the same
          executable.  Using either of the names will produce the exact same behavior.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Single Process Multiple Data (SPMD) Model:

          mpirun [ options ] &lt;program&gt; [ &lt;args&gt; ]

       Multiple Instruction Multiple Data (MIMD) Model:

          mpirun [ global_options ]
                 [ local_options1 ] &lt;program1&gt; [ &lt;args1&gt; ] :
                 [ local_options2 ] &lt;program2&gt; [ &lt;args2&gt; ] :
                 ... :
                 [ local_optionsN ] &lt;programN&gt; [ &lt;argsN&gt; ]

       Note that in both models, invoking <b>mpirun</b> via an absolute path  name  is  equivalent  to  specifying  the
       <b>--prefix</b>  option  with  a  <b>&lt;dir&gt;</b>  value  equivalent to the directory where <b>mpirun</b> resides, minus its last
       subdirectory.  For example:

          shell$ /usr/local/bin/mpirun ...

       is equivalent to

          shell$ mpirun --prefix <a href="file:/usr/local">/usr/local</a>

</pre><h4><b>QUICK</b> <b>SUMMARY</b></h4><pre>
       If you are simply looking for how to run an MPI application, you probably want to use a command  line  of
       the following form:

          shell$ mpirun [ -n X ] [ --hostfile &lt;filename&gt; ]  &lt;program&gt;

       This  will  run  <b>X</b> copies of <b>&lt;program&gt;</b> in your current run-time environment (if running under a supported
       resource manager, Open MPI’s <b>mpirun</b> will usually automatically use  the  corresponding  resource  manager
       process starter, as opposed to <b>ssh</b> (for example), which require the use of a hostfile, or will default to
       running  all  <b>X</b>  copies  on the localhost), scheduling (by default) in a round-robin fashion by CPU slot.
       See the rest of this documentation for more details.

       Please note that <b>mpirun</b> automatically binds processes to hardware resources. Three binding  patterns  are
       used in the absence of any further directives (See <u>map/rank/bind</u> <u>defaults</u> for more details):

       • <b>Bind</b> <b>to</b> <b>core</b>:     when the number of processes is &lt;= 2

       • <b>Bind</b> <b>to</b> <b>package</b>:  when the number of processes is &gt; 2

       • <b>Bind</b> <b>to</b> <b>none</b>:     when oversubscribed

       If  your  application uses threads, then you probably want to ensure that you are either not bound at all
       (by specifying <b>--bind-to</b> <b>none</b>), or bound to multiple cores using an appropriate binding level or specific
       number of processing elements per application process.

</pre><h4><b>OPEN</b> <b>MPI’S</b> <b>USE</b> <b>OF</b> <b>PRRTE</b></h4><pre>
       Open MPI uses the  PMIx  Reference  Runtime  Environment  (PRRTE)  as  the  main  engine  for  launching,
       monitoring, and terminating MPI processes.

       Much  of the documentation below is directly imported from PRRTE.  As such, it frequently refers to PRRTE
       concepts and command line options.  Except where noted, these concepts and command line argument are  all
       applicable  to  Open  MPI  as  well.  Open MPI extends the available PRRTE command line options, and also
       slightly modifies the PRRTE’s default behaviors in a few cases.  These will be specifically described  in
       the docuemtnation below.

</pre><h4><b>COMMAND</b> <b>LINE</b> <b>OPTIONS</b></h4><pre>
       The core of Open MPI’s <b>mpirun</b> processing is performed via the <u>PRRTE</u>.  Specifically: <b>mpirun</b> is effectively
       a wrapper around <b>prterun</b>, but <b>mpirun</b>’s CLI options are slightly different than PRRTE’s CLI commands.

   <b>No</b> <b>content</b>
       There is no meaningful content in this file because Open MPI was either:

       • Built without PRRTE support.

       • Built  with  a  PRRTE  that  was  too  old  to  include  machine-readable  documentation  that could be
         incorporated into Open MPI’s documentation.

       If you build Open MPI with a newer version of PRRTE (and have the Sphinx tool available when you run Open
       MPI’s <b>configure</b> command), you should get more meaningful documentation here.

       Hence, there is no documentation for this section.

       Sorry!

</pre><h4><b>OPTIONS</b> <b>(OLD</b> <b>/</b> <b>HARD-CODED</b> <b>CONTENT</b> <b>—</b> <b>TO</b> <b>BE</b> <b>AUDITED</b></h4><pre>
          This is old content

                 This is the old section of manually hard-coded content.  It should probably be read  /  audited
                 and see what we want to keep and what we want to discard.

                 Feel  free  to refer to <u>https://docs.prrte.org/</u> rather than replicating content here (e.g., for
                 the definition of a slot and other things).

       mpirun will send the name of the directory where it was invoked on the local node to each of  the  remote
       nodes,  and  attempt  to change to that directory.  See the “Current Working Directory” section below for
       further details.

       • <b>&lt;program&gt;</b>: The program executable. This is identified as the first non-recognized argument to mpirun.

       • <b>&lt;args&gt;</b>: Pass these run-time arguments to every new process.  These must always be the last arguments to
         mpirun. If an app context file is used, <b>&lt;args&gt;</b> will be ignored.

       • <b>-h</b>, <b>--help</b>: Display help for this command

       • <b>-q</b>, <b>--quiet</b>: Suppress informative messages from orterun during application execution.

       • <b>-v</b>, <b>--verbose</b>:` Be verbose

       • <b>-V</b>, <b>--version</b>: Print version number.  If no other arguments are given, this will also cause orterun  to
         exit.

       • <b>-N</b> <b>&lt;num&gt;</b>: Launch num processes per node on all allocated nodes (synonym for <b>--npernode</b>).

       • <b>--display-map</b>: Display a table showing the mapped location of each process prior to launch.

       • <b>--display-allocation</b>: Display the detected resource allocation.

       • <b>--output-proctable</b>: Output the debugger proctable after launch.

       • <b>--dvm</b>: Create a persistent distributed virtual machine (DVM).

       • <b>--max-vm-size</b> <b>&lt;size&gt;</b>: Number of daemons to start.

       Use one of the following options to specify which hosts (nodes) of the cluster to run on. Note that as of
       the  start of the v1.8 release, mpirun will launch a daemon onto each host in the allocation (as modified
       by the following options) at the very beginning of execution, regardless of whether  or  not  application
       processes  will  eventually  be  mapped  to  execute  there. This is done to allow collection of hardware
       topology information from the remote nodes, thus allowing us to map  processes  against  known  topology.
       However,  it  is  a  change  from  the  behavior in prior releases where daemons were only launched after
       mapping was complete, and thus only occurred on nodes  where  application  processes  would  actually  be
       executing.

       • <b>-H</b>, <b>--host</b> <b>&lt;host1,host2,...,hostN&gt;</b>: list of hosts on which to invoke processes.

       • <b>--hostfile</b> <b>&lt;hostfile&gt;</b>: Provide a hostfile to use.

       • <b>--default-hostfile</b> <b>&lt;hostfile&gt;</b>: Provide a default hostfile.

       • <b>--machinefile</b> <b>&lt;machinefile&gt;</b>: Synonym for <b>--hostfile</b>.

       • <b>--cpu-set</b>   <b>&lt;list&gt;</b>:   Restrict   launched  processes  to  the  specified  logical  CPUs  on  each  node
         (comma-separated list). Note that the binding options will still apply within the specified envelope  —
         e.g., you can elect to bind each process to only one CPU within the specified CPU set.

       The  following  options  specify the number of processes to launch. Note that none of the options imply a
       particular binding policy — e.g., requesting N processes  for  each  package  does  not  imply  that  the
       processes will be bound to the package.

       • <b>-n</b>,  <b>--n</b>,  <b>-c</b>,  <b>-np</b> <b>&lt;#&gt;</b>: Run this many copies of the program on the given nodes.  This option indicates
         that the specified file is an executable program and  not  an  application  context.  If  no  value  is
         provided for the number of copies to execute (i.e., neither the <b>-n</b> nor its synonyms are provided on the
         command  line),  Open  MPI  will  automatically execute a copy of the program on each process slot (see
         PRRTE’s <u>defintion</u> <u>of</u> <u>“slot”</u> for description of a “process slot”). This feature, however,  can  only  be
         used  in  the  SPMD  model  and  will  return an error (without beginning execution of the application)
         otherwise.

         <b>NOTE:</b>
            The <b>-n</b> option is the preferred option to be used to specify the number of copies of the  program  to
            be executed, but the alternate options are also accepted.

       • <b>--map-by</b> <b>ppr:N:&lt;object&gt;</b>: Launch N times the number of objects of the specified type on each node.

       • <b>--npersocket</b>  <b>&lt;#persocket&gt;</b>:  On  each  node,  launch  this many processes times the number of processor
         sockets on the node.  The -npersocket option also turns on the <b>--bind-to-socket</b> option.  (deprecated in
         favor of <b>--map-by</b> <b>ppr:n:package</b>)

       • <b>--npernode</b> <b>&lt;#pernode&gt;</b>: On each node, launch this many processes.   (deprecated  in  favor  of  <b>--map-by</b>
         <b>ppr:n:node</b>).

       • <b>--pernode</b>:  On  each  node,  launch  one process — equivalent to <b>--npernode</b> <b>1</b>.  (deprecated in favor of
         <b>--map-by</b> <b>ppr:1:node</b>)

       To map processes:

       • <b>--map-by</b> <b>&lt;object&gt;</b>: Map to the specified object, defaults to <b>package</b>. Supported  options  include  <b>slot</b>,
         <b>hwthread</b>, <b>core</b>, <b>L1cache</b>, <b>L2cache</b>, <b>L3cache</b>, <b>package</b>, <b>numa</b>, <b>node</b>, <b>seq</b>, <b>rankfile</b>, <b>pe-list=#</b>, and <b>ppr</b>.  Any
         object can include modifiers by adding a <b>:</b> and any combination of the following:

            • <b>pe=n</b>: bind <b>n</b> processing elements to each proc

            • <b>span</b>: load balance the processes across the allocation

            • <b>oversubscribe</b>: allow more processes on a node than processing elements

            • <b>nooversubscribe</b>: do <u>not</u> allow more processes on a node than processing elements (default)

            • <b>nolocal</b>: do not place processes on the same host as the <b>mpirun</b> process

            • <b>hwtcpus</b>: use hardware threads as CPU slots for mapping

            • <b>corecpus</b>: use processor cores as CPU slots for mapping (default)

            • <b>file=filename</b>: used with <b>rankfile</b>; use <b>filename</b> to specify the file to use

            • <b>ordered</b>: used with <b>pe-list</b> to bind each process to one of the specified processing elements

         <b>NOTE:</b>
            <b>socket</b> is also accepted as an alias for <b>package</b>.

       • <b>--bycore</b>: Map processes by core (deprecated in favor of <b>--map-by</b> <b>core</b>).

       • <b>--byslot</b>: Map and rank processes round-robin by slot (deprecated in favor of <b>--map-by</b> <b>slot</b>).

       • <b>--nolocal</b>:  Do  not  run any copies of the launched application on the same node as orterun is running.
         This option will override listing the localhost with <b>--host</b> or  any  other  host-specifying  mechanism.
         Alias for <b>--map-by</b> <b>:nolocal</b>.

       • <b>--nooversubscribe</b>:  Do  not  oversubscribe  any  nodes;  error  (without starting any processes) if the
         requested number of processes would cause oversubscription.  This option  implicitly  sets  “max_slots”
         equal to the “slots” value for each node. (Enabled by default). Alias for <b>--map-by</b> <b>:nooversubscribe</b>.

       • <b>--oversubscribe</b>:  Nodes  are allowed to be oversubscribed, even on a managed system, and overloading of
         processing elements.  Alias for <b>--map-by</b> <b>:oversubscribe</b>.

       • <b>--bynode</b>: Launch processes one per node, cycling by  node  in  a  round-robin  fashion.   This  spreads
         processes  evenly  among  nodes  and  assigns  <b>MPI_COMM_WORLD</b> ranks in a round-robin, “by node” manner.
         (deprecated in favor of <b>--map-by</b> <b>node</b>)

       • <b>--cpu-list</b> <b>&lt;cpus&gt;</b>: Comma-delimited list of processor IDs to which to bind processes [default=``NULL``].
         Processor IDs are interpreted as hwloc logical core IDs.

         <b>NOTE:</b>
            You can run Run the hwloc <b><a href="../man1/lstopo.1.html">lstopo</a>(1)</b> command to see a list of available cores and their logical IDs.

       To order processes’ ranks in <b>MPI_COMM_WORLD</b>:

       • <b>--rank-by</b> <b>&lt;mode&gt;</b>: Rank in round-robin fashion according  to  the  specified  mode,  defaults  to  slot.
         Supported options include <b>slot</b>, <b>node</b>, <b>fill</b>, and <b>span</b>.

       For process binding:

       • <b>--bind-to</b>  <b>&lt;object&gt;</b>:  Bind  processes  to  the  specified  object, defaults to <b>core</b>.  Supported options
         include <b>slot</b>, <b>hwthread</b>, <b>core</b>, <b>l1cache</b>, <b>l2cache</b>, <b>l3cache</b>, <b>package</b>, <b>numa</b>, and <b>none</b>.

       • <b>--cpus-per-proc</b> <b>&lt;#perproc&gt;</b>: Bind each process to the specified number of cpus.  (deprecated in favor of
         <b>--map-by</b> <b>&lt;obj&gt;:PE=n</b>)

       • <b>--cpus-per-rank</b> <b>&lt;#perrank&gt;</b>: Alias for <b>--cpus-per-proc</b>.  (deprecated in favor of <b>--map-by</b> <b>&lt;obj&gt;:PE=n</b>)

       • <b>--bind-to-core</b> Bind processes to cores (deprecated in favor of <b>--bind-to</b> <b>core</b>)

       • <b>--bind-to-socket</b>: Bind processes to processor sockets (deprecated in favor of <b>--bind-to</b> <b>package</b>)

       • <b>--report-bindings</b>: Report any bindings for launched processes.

       For rankfiles:

       • <b>--rankfile</b> <b>&lt;rankfile&gt;</b>: Provide a rankfile file.  (deprecated in favor of <b>--map-by</b> <b>rankfile:file=FILE</b>)

       To manage standard I/O:

       • <b>--output-filename</b> <b>&lt;filename&gt;</b>:  Redirect  the  stdout,  stderr,  and  stddiag  of  all  processes  to  a
         process-unique version of the specified filename. Any directories in the filename will automatically be
         created.   Each  output  file  will consist of <b>filename.id</b>, where the <b>id</b> will be the processes’ rank in
         <b>MPI_COMM_WORLD</b>, left-filled with zero’s for correct ordering in listings. A relative path value will be
         converted to an absolute path based on the cwd where mpirun is executed. Note that this will  not  work
         on environments where the file system on compute nodes differs from that where <u><a href="../man1/mpirun.1.html">mpirun</a>(1)</u> is executed.

       • <b>--stdin</b>  <b>&lt;rank&gt;</b>:  The  <b>MPI_COMM_WORLD</b>  rank of the process that is to receive stdin.  The default is to
         forward stdin to <b>MPI_COMM_WORLD</b> rank 0, but this option can be used to forward stdin to any process. It
         is also acceptable to specify none, indicating that no processes are to receive stdin.

       • <b>--merge-stderr-to-stdout</b>: Merge stderr to stdout for each process.

       • <b>--tag-output</b>: Tag each line of output to stdout, stderr, and  stddiag  with  <b>[jobid,</b>  <b>MCW_rank]&lt;stdxxx&gt;</b>
         indicating  the process jobid and <b>MPI_COMM_WORLD</b> rank of the process that generated the output, and the
         channel which generated it.

       • <b>--timestamp-output</b>: Timestamp each line of output to stdout, stderr, and stddiag.

       • <b>--xml</b>: Provide all output to stdout, stderr, and stddiag in an XML format.

       • <b>--xml-file</b> <b>&lt;filename&gt;</b> Provide all output in XML format to the specified file.

       • <b>--xterm</b> <b>&lt;ranks&gt;</b>: Display the output from the processes identified  by  their  <b>MPI_COMM_WORLD</b>  ranks  in
         separate  xterm  windows.  The  ranks  are  specified  as  a  comma-separated list of ranges, with a <b>-1</b>
         indicating all. A separate window will be created for each specified process.

         <b>NOTE:</b>
            xterm will normally terminate the window upon termination of the process running within it. However,
            by adding a <b>!</b> to the end of the list of specified ranks, the proper  options  will  be  provided  to
            ensure  that  xterm keeps the window open after the process terminates, thus allowing you to see the
            process’ output.  Each xterm window will subsequently need to be manually  closed.   Note:  In  some
            environments,  xterm  may  require  that  the  executable  be in the user’s path, or be specified in
            absolute or relative terms. Thus, it may be necessary to specify a local executable as  <b>./my_mpi_app</b>
            instead  of  just  <b>my_mpi_app</b>.  If  xterm  fails to find the executable, <b>mpirun</b> will hang, but still
            respond correctly to a ctrl-C.  If this happens, please check that the executable is being specified
            correctly and try again.

       To manage files and runtime environment:

       • <b>--path</b> <b>&lt;path&gt;</b>: <b>&lt;path&gt;</b> that will be used when attempting to locate the requested executables.   This  is
         used prior to using the local <b>PATH</b> environment variable setting.

       • <b>--prefix</b>  <b>&lt;dir&gt;</b>:  Prefix  directory that will be used to set the <b>PATH</b> and <b>LD_LIBRARY_PATH</b> on the remote
         node before invoking Open MPI or the target process.  See the <u>Remote</u> <u>Execution</u> section, below.

       • <b>--noprefix</b>: Disable the automatic <b>--prefix</b> behavior

       • <b>--preload-binary</b>: Copy the  specified  executable(s)  to  remote  machines  prior  to  starting  remote
         processes.  The  executables  will be copied to the Open MPI session directory and will be deleted upon
         completion of the job.

       • <b>--preload-files</b> <b>&lt;files&gt;</b>: Preload the comma-separated list of files to the current working directory  of
         the remote machines where processes will be launched prior to starting those processes.

       • <b>--set-cwd-to-session-dir</b>:  Set  the  working  directory  of  the  started  processes  to  their session
         directory.

       • <b>--wd</b> <b>&lt;dir&gt;</b>: Synonym for <b>-wdir</b>.

       • <b>--wdir</b> <b>&lt;dir&gt;</b>: Change to the directory <b>&lt;dir&gt;</b> before  the  user’s  program  executes.   See  the  <u>Current</u>
         <u>Working</u>  <u>Directory</u> section for notes on relative paths.  Note: If the <b>--wdir</b> option appears both on the
         command line and in an application context, the context will take precedence  over  the  command  line.
         Thus,  if  the path to the desired wdir is different on the backend nodes, then it must be specified as
         an absolute path that is correct for the backend node.

       • <b>-x</b> <b>&lt;env&gt;</b>: Export the specified environment variables to the remote nodes before executing the  program.
         Only  one  environment  variable can be specified per <b>-x</b> option.  Existing environment variables can be
         specified or new variable names specified with corresponding values.  For example:

            shell$ mpirun -x DISPLAY -x OFILE=/tmp/out ...

         The parser for the <b>-x</b> option is not very sophisticated; it does  not  even  understand  quoted  values.
         Users are advised to set variables in the environment, and then use <b>-x</b> to export (not define) them.

       Setting MCA parameters:

       • <b>--gmca</b>  <b>&lt;key&gt;</b>  <b>&lt;value&gt;</b>:  Pass  global MCA parameters that are applicable to all contexts.  <b>&lt;key&gt;</b> is the
         parameter name; <b>&lt;value&gt;</b> is the parameter value.

       • <b>--mca</b> <b>&lt;key&gt;</b> <b>&lt;value&gt;</b>: Send arguments to various MCA modules.  See the <u>Setting</u> <u>MCA</u> <u>Parameters</u> section for
         more details.

         <b>NOTE:</b>
            Open MPI will attempt to discern PMIx and PRRTE MCA parameters passed  via  <b>--mca</b>  and  handle  them
            appropriately,  but  it  may  not always guess correctly.  It is best to use <b>--pmixmca</b> and <b>--prtemca</b>
            when passing MCA parammeters to PMIx and PRRTE, respectively.

       • <b>--pmixmca</b> <b>&lt;key&gt;</b> <b>&lt;value&gt;</b>: Send arguments to MCA modules in the PMIx  subsystem.   See  the  <u>Setting</u>  <u>MCA</u>
         <u>Parameters</u> section for more details.

       • <b>--prtemca</b>  <b>&lt;key&gt;</b>  <b>&lt;value&gt;</b>:  Send  arguments  to  MCA  modules in the PMIx Reference Runtime Environment
         (PRRTE) subsystem.  See the <u>Setting</u> <u>MCA</u> <u>Parameters</u> section for more details.

       • <b>--tune</b> <b>&lt;tune_file&gt;</b>: Specify a tune file to set  arguments  for  various  MCA  modules  and  environment
         variables.    See   the   :ref:`   Setting   MCA   parameters   and  environment  variables  from  file
         &lt;man1-mpirun-setting-mca-params-from-file&gt;`. <b>--am</b> <b>&lt;arg&gt;</b> is an alias for <b>--tune</b> <b>&lt;arg&gt;</b>.

       For debugging:

       • <b>--get-stack-traces</b>: When paired with the <b>--timeout</b> option, <b>mpirun</b>  will  obtain  and  print  out  stack
         traces  from all launched processes that are still alive when the timeout expires.  Note that obtaining
         stack traces can take a little time and produce a lot of output,  especially  for  large  process-count
         jobs.

       • <b>--timeout</b>  <b>&lt;seconds&gt;</b>:  The  maximum  number  of seconds that <b>mpirun</b> will run.  After this many seconds,
         <b>mpirun</b> will abort the launched job and exit with a non-zero exit status.  Using <b>--timeout</b> can  be  also
         useful when combined with the <b>--get-stack-traces</b> option.

       There are also other options:

       • <b>--allow-run-as-root</b>:  Allow  <b>mpirun</b>  to run when executed by the root user (<b>mpirun</b> defaults to aborting
         when launched as the root user).  Be sure to see the <u>Running</u> <u>as</u> <u>root</u> section for more detail.

       • <b>--app</b> <b>&lt;appfile&gt;</b>: Provide an appfile, ignoring all other command line options.

       • <b>--continuous</b>: Job is to run until explicitly terminated.

       • <b>--disable-recovery</b>: Disable recovery (resets all recovery options to off).

       • <b>--do-not-launch</b>: Perform all necessary operations to prepare to launch  the  application,  but  do  not
         actually launch it.

       • <b>--enable-recovery</b>: Enable recovery from process failure (default: disabled)

       • <b>--leave-session-attached</b>:  Do  not  detach back-end daemons used by this application. This allows error
         messages from the daemons as well as the underlying environment (e.g., when failing to launch a daemon)
         to be output.

       • <b>--max-restarts</b> <b>&lt;num&gt;</b>: Max number of times to restart a failed process.

       • <b>--personality</b> <b>&lt;list&gt;</b>: Comma-separated list of programming model, languages, and containers  being  used
         (default=``ompi``).

       • <b>--ppr</b>  <b>&lt;list&gt;</b>:  Comma-separated  list  of number of processes on a given resource type (default: none).
         Alias for <b>--map-by</b> <b>ppr:N:OBJ</b>.

       • <b>--report-child-jobs-separately</b>: Return the exit status of the primary job only.

       • <b>--report-events</b> <b>&lt;URI&gt;</b>: Report events to a tool listening at the specified URI.

       • <b>--report-pid</b> <b>&lt;channel&gt;</b>: Print out <b>mpirun</b>’s PID during startup. The  channel  must  be  either  a  <b>-</b>  to
         indicate  that  the  PID  is  to  be  output to stdout, a <b>+</b> to indicate that the PID is to be output to
         stderr, or a filename to which the PID is to be written.

       • <b>--report-uri</b> <b>&lt;channel&gt;</b>: Print out <b>mpirun</b>’s URI during startup. The  channel  must  be  either  a  <b>-</b>  to
         indicate  that  the  URI  is  to  be  output to stdout, a <b>+</b> to indicate that the URI is to be output to
         stderr, or a filename to which the URI is to be written.

       • <b>--show-progress</b>: Output a brief periodic report on launch progress.

       • <b>--terminate</b>: Terminate the DVM.

       • <b>--use-hwthread-cpus</b>: Use hardware threads as independent CPUs.

         Note that if a number of slots is not provided to Open MPI (e.g., via the <b>slots</b> keyword in  a  hostfile
         or  from  a  resource manager such as Slurm), the use of this option changes the default calculation of
         number of slots on a node.  See the PRRTE’s <u>defintion</u> <u>of</u> <u>“slot”</u> for more details.

         Also note that the use of this option changes the Open MPI’s definition of a “processor element” from a
         processor core to a hardware thread.  See PRRTE’s <u>defintion</u> <u>of</u> <u>a</u> <u>“processor</u> <u>element”</u> for more details.

       The following options are useful for developers; they are not generally useful to most Open MPI users:

       • <b>--debug-daemons</b>: Enable debugging of the run-time daemons used by this application.

       • <b>--debug-daemons-file</b>: Enable debugging of the run-time daemons used by this application, storing output
         in files.

       • <b>--display-devel-map</b>: Display a more detailed table showing the mapped location of each process prior to
         launch.

       • <b>--display-topo</b>: Display the topology as part of the process map just before launch.

       • <b>--launch-agent</b>: Name of the executable that is to be used to start processes on the remote  nodes.  The
         default  is  <b>prted</b>. This option can be used to test new daemon concepts, or to pass options back to the
         daemons without having mpirun itself see  them.  For  example,  specifying  a  launch  agent  of  <b>prted</b>
         <b>--prtemca</b>  <b>odls_base_verbose</b>  <b>5</b>  allows  the  developer  to  ask the <b>prted</b> for debugging output without
         clutter from <b>mpirun</b> itself.

       • <b>--report-state-on-timeout</b>: When paired with the <b>--timeout</b> command  line  option,  report  the  run-time
         subsystem state of each process when the timeout expires.

       There may be other options listed with <b>mpirun</b> <b>--help</b>.

   <b>Environment</b> <b>Variables</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       • <b>MPIEXEC_TIMEOUT</b>: Synonym for the <b>--timeout</b> command line option.

</pre><h4><b>DESCRIPTION</b></h4><pre>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       One  invocation  of <b>mpirun</b> starts an MPI application running under Open MPI. If the application is single
       process multiple data (SPMD), the application can be specified on the <b>mpirun</b> command line.

       If the application is multiple instruction multiple data (MIMD), comprising of multiple programs, the set
       of programs and argument can be specified in one of  two  ways:  Extended  Command  Line  Arguments,  and
       Application Context.

       An  application  context describes the MIMD program set including all arguments in a separate file.  This
       file essentially contains multiple mpirun command lines, less the command name itself.   The  ability  to
       specify  different  options  for  different  instantiations  of  a  program  is  another reason to use an
       application context.

       Extended command line arguments allow for the description of the application layout on the  command  line
       using  colons  (<b>:</b>) to separate the specification of programs and arguments. Some options are globally set
       across all specified programs (e.g., <b>--hostfile</b>), while others are specific to a  single  program  (e.g.,
       <b>-n</b>).

   <b>Specifying</b> <b>Host</b> <b>Nodes</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       Host nodes can be identified on the <b>mpirun</b> command line with the <b>--host</b> option or in a hostfile.

       For example:

          shell$ mpirun -H aa,aa,bb ./a.out

       Launches two processes on node <b>aa</b> and one on <b>bb</b>.

       Or, consider the hostfile:

          shell$ cat myhostfile
          aa slots=2
          bb slots=2
          cc slots=2

       Here, we list both the host names (<b>aa</b>, <b>bb</b>, and <b>cc</b>) but also how many slots there are for each.

          shell$ mpirun --hostfile myhostfile ./a.out

       will launch two processes on each of the three nodes.

          shell$ mpirun --hostfile myhostfile --host aa ./a.out

       will launch two processes, both on node <b>aa</b>.

          shell$ mpirun --hostfile myhostfile --host dd ./a.out

       will  find no hosts to run on and will abort with an error.  That is, the specified host <b>dd</b> is not in the
       specified hostfile.

       When running under resource managers (e.g., Slurm, Torque, etc.), Open MPI will obtain both the hostnames
       and the number of slots directly from the resource manager.

   <b>Specifying</b> <b>Number</b> <b>of</b> <b>Processes</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       As we have just seen, the number of processes to run can be set using  the  hostfile.   Other  mechanisms
       exist.

       The  number  of  processes  launched  can  be specified as a multiple of the number of nodes or processor
       packages available.  For example,

          shell$ mpirun -H aa,bb --map-by ppr:2:package ./a.out

       launches processes 0-3 on node <b>aa</b> and process 4-7 on node <b>bb</b> (assuming <b>aa</b> and <b>bb</b>  both  contain  4  slots
       each).

          shell$ mpirun -H aa,bb --map-by ppr:2:node ./a.out

       launches processes 0-1 on node <b>aa</b> and processes 2-3 on node <b>bb</b>.

          shell$ mpirun -H aa,bb --map-by ppr:1:node ./a.out

       launches one process per host node.

          mpirun -H aa,bb --pernode ./a.out

       is the same as <b>--map-by</b> <b>ppr:1:node</b> and <b>--npernode</b> <b>1</b>.

       Another alternative is to specify the number of processes with the <b>-n</b> option.  Consider now the hostfile:

          shell$ cat myhostfile
          aa slots=4
          bb slots=4
          cc slots=4

       Now run with <b>myhostfile</b>:

          shell$ mpirun --hostfile myhostfile -n 6 ./a.out

       will  launch  processes 0-3 on node <b>aa</b> and processes 4-5 on node <b>bb</b>.  The remaining slots in the hostfile
       will not be used since the <b>-n</b> option indicated that only 6 processes should be launched.

   <b>Mapping</b> <b>Processes</b> <b>to</b> <b>Nodes:</b> <b>Using</b> <b>Policies</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       The examples above illustrate the default mapping of process processes to nodes.  This mapping  can  also
       be controlled with various <b>mpirun</b> options that describe mapping policies.

       Consider the same hostfile as above, again with <b>-n</b> <b>6</b>.  The table below lists a few <b>mpirun</b> variations, and
       shows which <b>MPI_COMM_WORLD</b> ranks end up on which node:
                                ┌──────────────────────┬─────────┬─────────┬─────────┐
                                │ Command              │ Node <b>aa</b> │ Node <b>bb</b> │ Node <b>cc</b> │
                                ├──────────────────────┼─────────┼─────────┼─────────┤
                                │ <b>mpirun</b>               │ 0 1 2 3 │ 4 5     │         │
                                ├──────────────────────┼─────────┼─────────┼─────────┤
                                │ <b>mpirun</b> <b>--map-by</b> <b>node</b> │ 0 3     │ 1 4     │ 2 5     │
                                ├──────────────────────┼─────────┼─────────┼─────────┤
                                │ <b>mpirun</b> <b>--nolocal</b>     │         │ 0 1 2 3 │ 4 5     │
                                └──────────────────────┴─────────┴─────────┴─────────┘

       The  <b>--map-by</b>  <b>node</b>  option  will  load  balance the processes across the available nodes, numbering each
       process in a round-robin fashion.

       The <b>--nolocal</b> option prevents any processes from being mapped onto the local host (in this case node <b>aa</b>).
       While <b>mpirun</b> typically consumes few system resources, <b>--nolocal</b> can be helpful for launching  very  large
       jobs where mpirun may actually need to use noticeable amounts of memory and/or processing time.

       Just  as  <b>-n</b>  can specify fewer processes than there are slots, it can also oversubscribe the slots.  For
       example, with the same hostfile:

          shell$ mpirun --hostfile myhostfile -n 14 ./a.out

       will launch processes 0-3 on node <b>aa</b>, 4-7 on <b>bb</b>, and 8-11 on <b>cc</b>.  It will  then  add  the  remaining  two
       processes to whichever nodes it chooses.

       One can also specify limits to oversubscription.  For example, with the same hostfile:

          shell$ mpirun --hostfile myhostfile -n 14 --nooversubscribe ./a.out

       will produce an error since <b>--nooversubscribe</b> prevents oversubscription.

       Limits to oversubscription can also be specified in the hostfile itself:

          shell$ cat myhostfile
          aa slots=4 max_slots=4
          bb         max_slots=4
          cc slots=4

       The <b>max_slots</b> field specifies such a limit.  When it does, the slots value defaults to the limit.  Now:

          shell$ mpirun --hostfile myhostfile -n 14 ./a.out

       causes  the  first  12 processes to be launched as before, but the remaining two processes will be forced
       onto node <b>cc</b>.  The other two nodes are protected by the hostfile against oversubscription by this job.

       Using the <b>--nooversubscribe</b> option can be helpful since Open MPI currently does not get <b>max_slots</b>  values
       from the resource manager.

       Of course, <b>-n</b> can also be used with the <b>-H</b> or <b>-host</b> option.  For example:

          shell$ mpirun -H aa,bb -n 8 ./a.out

       launches  8 processes.  Since only two hosts are specified, after the first two processes are mapped, one
       to <b>aa</b> and one to <b>bb</b>, the remaining processes oversubscribe the specified hosts.

       And here is a MIMD example:

          shell$ mpirun -H aa -n 1 hostname : -H bb,cc -n 2 uptime

       will launch process 0 running hostname on node <b>aa</b> and processes 1 and 2 each running uptime on  nodes  <b>bb</b>
       and <b>cc</b>, respectively.

   <b>Mapping,</b> <b>Ranking,</b> <b>and</b> <b>Binding:</b> <b>Oh</b> <b>My!</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       Open MPI employs a three-phase procedure for assigning process locations and ranks:

       1. <b>Mapping</b>: Assigns a default location to each process

       2. <b>Ranking</b>: Assigns an <b>MPI_COMM_WORLD</b> rank value to each process

       3. <b>Binding</b>: Constrains each process to run on specific processors

       The mapping step is used to assign a default location to each process based on the mapper being employed.
       Mapping  by slot, node, and sequentially results in the assignment of the processes to the node level. In
       contrast, mapping by object, allows the mapper to assign the process to an actual object on each node.

       Note that the location assigned to the process is independent of where it will be bound — the  assignment
       is used solely as input to the binding algorithm.

       The  mapping  of  process  processes  to nodes can be defined not just with general policies but also, if
       necessary, using arbitrary mappings that cannot be described  by  a  simple  policy.   One  can  use  the
       “sequential  mapper,”  which  reads  the  hostfile line by line, assigning processes to nodes in whatever
       order the hostfile specifies.  Use the <b>---map-by</b> <b>seq</b> option.  For example, using  the  same  hostfile  as
       before:

          shell$ mpirun -hostfile myhostfile --map-by seq ./a.out

       will  launch  three  processes, one on each of nodes <b>aa</b>, <b>bb</b>, and <b>cc</b>, respectively.  The slot counts don’t
       matter; one process is launched per line on whatever node is listed on the line.

       Another way to specify arbitrary mappings is with a rankfile,  which  gives  you  detailed  control  over
       process binding as well.  Rankfiles are discussed <u>below</u>.

       The  second  phase  focuses  on  the  ranking  of  the process within the job’s <b>MPI_COMM_WORLD</b>.  Open MPI
       separates this from the mapping procedure to allow more flexibility in  the  relative  placement  of  MPI
       processes.  This is best illustrated by considering the following cases where we used the <b>--np</b> <b>8</b> <b>--map-by</b>
       <b>ppr:2:package</b> <b>--host</b> <b>aa:4,bb:4</b> option:
                               ┌──────────────────────────────┬───────────┬───────────┐
                               │ Option                       │ Node <b>aa</b>   │ Node <b>bb</b>   │
                               ├──────────────────────────────┼───────────┼───────────┤
                               │ <b>--rank-by</b> <b>fill</b> (i.e.,  dense │ 0 1 | 2 3 │ 4 5 | 6 7 │
                               │ packing) Default             │           │           │
                               ├──────────────────────────────┼───────────┼───────────┤
                               │ <b>--rank-by</b> <b>span</b> (i.e., sparse │ 0 4 | 1 5 │ 2 6 | 3 7 │
                               │ or load balanced packing)    │           │           │
                               ├──────────────────────────────┼───────────┼───────────┤
                               │ <b>--rank-by</b> <b>node</b>               │ 0 2 | 4 6 │ 1 3 | 5 7 │
                               └──────────────────────────────┴───────────┴───────────┘

       Ranking  by  <b>fill</b> assigns MCW ranks in a simple progression across each node. Ranking by <b>span</b> and by <b>slot</b>
       provide the identical result — a  round-robin  progression  of  the  packages  across  all  nodes  before
       returning  to  the  first  package  on  the first node. Ranking by <b>node</b> assigns MCW ranks iterating first
       across nodes then by package.

       The binding phase actually binds each process to a given set of processors. This can improve  performance
       if  the  operating  system  is  placing processes suboptimally.  For example, it might oversubscribe some
       multi-core processor  packages,  leaving  other  packages  idle;  this  can  lead  processes  to  contend
       unnecessarily for common resources.  Or, it might spread processes out too widely; this can be suboptimal
       if  application  performance is sensitive to interprocess communication costs.  Binding can also keep the
       operating system from migrating processes excessively, regardless of how optimally those  processes  were
       placed to begin with.

       The processors to be used for binding can be identified in terms of topological groupings — e.g., binding
       to an <b>l3cache</b> will bind each process to all processors within the scope of a single L3 cache within their
       assigned  location.  Thus,  if a process is assigned by the mapper to a certain package, then a <b>--bind-to</b>
       <b>l3cache</b> directive will cause the process to be bound to the processors  that  share  a  single  L3  cache
       within that package.

       Alternatively,  processes  can be mapped and bound to specified cores using the <b>--map-by</b> <b>pe-list=</b> option.
       For example, <b>--map-by</b> <b>pe-list=0,2,5</b> will map three processes all three of which will be bound to  logical
       cores  <b>0,2,5</b>.  If  you  intend  to  bind each of the three processes to different cores then the <b>:ordered</b>
       qualifier can be used like <b>--map-by</b> <b>pe-list=0,2,5:ordered</b>. In this example, the first process on  a  node
       will  be  bound to CPU 0, the second process on the node will be bound to CPU 2, and the third process on
       the node will be bound to CPU 5.

       Finally, <b>--report-bindings</b> can be used to report bindings.

       As an example, consider a node with two processor packages, each comprised of four  cores,  and  each  of
       those cores contains one hardware thread.  The <b>--report-bindings</b> option shows the binding of each process
       in a descriptive manner. Below are some examples.

          shell$ mpirun --np 4 --report-bindings --map-by core --bind-to core
          [...] Rank 0 bound to package[0][core:0]
          [...] Rank 1 bound to package[0][core:1]
          [...] Rank 2 bound to package[0][core:2]
          [...] Rank 3 bound to package[0][core:3]

       In the above case, the processes bind to successive cores.

          shell$ mpirun --np 4 --report-bindings --map-by package --bind-to package
          [...] Rank 0 bound to package[0][core:0-3]
          [...] Rank 1 bound to package[0][core:0-3]
          [...] Rank 2 bound to package[1][core:4-7]
          [...] Rank 3 bound to package[1][core:4-7]

       In  the  above case, processes bind to all cores on successive packages.  The processes cycle through the
       processor packages in a round-robin fashion as many times as are needed. By default,  the  processes  are
       ranked in a <b>fill</b> manner.

          shell$ mpirun --np 4 --report-bindings --map-by package --bind-to package --rank-by span
          [...] Rank 0 bound to package[0][core:0-3]
          [...] Rank 1 bound to package[1][core:4-7]
          [...] Rank 2 bound to package[0][core:0-3]
          [...] Rank 3 bound to package[1][core:4-7]

       The  above  case  demonstrates  the  difference in ranking when the <b>span</b> qualifier is used instead of the
       default.

          shell$ mpirun --np 4 --report-bindings --map-by slot:PE=2 --bind-to core
          [...] Rank 0 bound to package[0][core:0-1]
          [...] Rank 1 bound to package[0][core:2-3]
          [...] Rank 2 bound to package[0][core:4-5]
          [...] Rank 3 bound to package[0][core:6-7]

       In the above case, the output shows us that 2 cores have  been  bound  per  process.   Specifically,  the
       mapping  by  <b>slot</b>  with  the  <b>PE=2</b>  qualifier indicated that each slot (i.e., process) should consume two
       processor elements.  By default, Open MPI defines  “processor  element”  as  “core”,  and  therefore  the
       <b>--bind-to</b> <b>core</b> caused each process to be bound to both of the cores to which it was mapped.

          shell$ mpirun --np 4 --report-bindings --map-by slot:PE=2 --use-hwthread-cpus
          [...]] Rank 0 bound to package[0][hwt:0-1]
          [...]] Rank 1 bound to package[0][hwt:2-3]
          [...]] Rank 2 bound to package[0][hwt:4-5]
          [...]] Rank 3 bound to package[0][hwt:6-7]

       In  the  above  case,  we replace the <b>--bind-to</b> <b>core</b> with <b>--use-hwthread-cpus</b>. The <b>--use-hwthread-cpus</b> is
       converted into <b>--bind-to</b> <b>hwthread</b> and tells the <b>--report-bindings</b> output to show the hardware threads  to
       which a process is bound. In this case, processes are bound to 2 hardware threads per process.

          shell$ mpirun --np 4 --report-bindings --bind-to none
          [...] Rank 0 is not bound (or bound to all available processors)
          [...] Rank 1 is not bound (or bound to all available processors)
          [...] Rank 2 is not bound (or bound to all available processors)
          [...] Rank 3 is not bound (or bound to all available processors)

       In the above case, binding is turned off and are reported as such.

       Open  MPI’s  support  for process binding depends on the underlying operating system.  Therefore, certain
       process binding options may not be available on every system.

       Process binding can also be set with MCA parameters.  Their usage is less convenient than that of  <b>mpirun</b>
       options.   On  the  other  hand,  MCA  parameters  can  be  set  not only on the mpirun command line, but
       alternatively in a system or user <b>mca-params.conf</b> file or as environment variables, as described  in  the
       <u>Setting</u>  <u>MCA</u>  <u>Parameters</u>.  These  are  MCA  parameters for the PRRTE runtime so the command line argument
       <b>--prtemca</b> (yes, <b>prte</b> with a single <b>r</b>, not two <b>r</b>’s) must be used to pass the MCA parameter key/value pair.
       Alternatively, the MCA parameter key/value pair may be specific on the command line by prefixing the  key
       with <b>PRTE_MCA_</b> (again, that is not a typo: <b>PRTE</b> not <b>PRRTE</b>).  Some examples include:
                            ┌───────────────────┬──────────────────────────────┬─────────┐
                            │ Option            │ PRRTE MCA parameter key      │ Value   │
                            ├───────────────────┼──────────────────────────────┼─────────┤
                            │ <b>--map-by</b> <b>core</b>     │ <b>rmaps_default_mapping_policy</b> │ <b>core</b>    │
                            ├───────────────────┼──────────────────────────────┼─────────┤
                            │ <b>--map-by</b> <b>package</b>  │ <b>rmaps_default_mapping_policy</b> │ <b>package</b> │
                            ├───────────────────┼──────────────────────────────┼─────────┤
                            │ <b>--rank-by</b> <b>fill</b>    │ <b>rmaps_default_ranking_policy</b> │ <b>fill</b>    │
                            ├───────────────────┼──────────────────────────────┼─────────┤
                            │ <b>--bind-to</b> <b>core</b>    │ <b>hwloc_default_binding_policy</b> │ <b>core</b>    │
                            ├───────────────────┼──────────────────────────────┼─────────┤
                            │ <b>--bind-to</b> <b>package</b> │ <b>hwloc_default_binding_policy</b> │ <b>package</b> │
                            ├───────────────────┼──────────────────────────────┼─────────┤
                            │ <b>--bind-to</b> <b>none</b>    │ <b>hwloc_default_binding_policy</b> │ <b>none</b>    │
                            └───────────────────┴──────────────────────────────┴─────────┘

   <b>Defaults</b> <b>for</b> <b>Mapping,</b> <b>Ranking,</b> <b>and</b> <b>Binding</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       If  the  user  does not specify each of <b>--map-by</b>, <b>--rank-by</b>, and <b>--bind-to</b> option then the default values
       are as follows:

       • If no options are specified then

            • If the number of processes is less than or equal to 2, then:

                  • <b>--map-by</b> is <b>core</b>

                  • <b>--bind-to</b> is <b>core</b>

                  • <b>--rank-by</b> is <b>span</b>

                  • Result: <b>--map-by</b> <b>core</b> <b>--bind-to</b> <b>core</b> <b>--rank-by</b> <b>span</b>

            • Otherwise:

                  • <b>--map-by</b> is <b>package</b>

                  • <b>--bind-to</b> is <b>package</b>

                  • <b>--rank-by</b> is <b>fill</b>

                  • Result: <b>--map-by</b> <b>package</b> <b>--bind-to</b> <b>package</b> <b>--rank-by</b> <b>fill</b>

       • If only <b>--map-by</b> <b>OBJ</b> (where <b>OBJ</b> is something like <b>core</b>) is specified, then:

            • <b>--map-by</b> specified <b>OBJ</b>

            • <b>--bind-to</b> uses the same <b>OBJ</b> as <b>--map-by</b>

            • <b>--rank-by</b> defaults to <b>fill</b>

            • Result: <b>--map-by</b> <b>OBJ</b> <b>--bind-to</b> <b>OBJ</b> <b>--rank-by</b> <b>fill</b>

       • If only <b>--bind-to</b> <b>OBJ</b> (where <b>OBJ</b> is something like <b>core</b>) is specified, then:

            • <b>--map-by</b> is either <b>core</b> or <b>package</b> depending on the number of processes

            • <b>--bind-to</b> specified <b>OBJ</b>

            • <b>--rank-by</b> defaults to <b>fill</b>

            • Result: <b>--map-by</b> <b>OBJ</b> <b>--bind-to</b> <b>OBJ</b> <b>--rank-by</b> <b>fill</b>

       • If <b>--map-by</b> <b>OBJ1</b> <b>--bind-to</b> <b>OBJ2</b>, then:

            • <b>--map-by</b> specified <b>OBJ1</b>

            • <b>--bind-to</b> specified <b>OBJ2</b>

            • <b>--rank-by</b> defaults to <b>fill</b>

            • Result: <b>--map-by</b> <b>OBJ2</b> <b>--bind-to</b> <b>OBJ2</b> <b>--rank-by</b> <b>fill</b>

       Consider 2 identical hosts (<b>hostA</b> and <b>hostB</b>) with 2 packages (denoted by <b>[]</b>) each with 8  cores  (denoted
       by <b><a href="file:/../">/../</a></b>) and 2 hardware threads per core (denoted by a <b>.</b>).

       Default of <b>--map-by</b> <b>core</b> <b>--bind-to</b> <b>core</b> <b>--rank-by</b> <b>span</b> when the number of processes is less than or equal
       to 2.

          shell$ mpirun --np 2 --host hostA:4,hostB:2 ./a.out
          R0  hostA  [BB/..<a href="file:/../../../../../..">/../../../../../..</a>][..<a href="file:/../../../../../../..">/../../../../../../..</a>]
          R1  hostA  [../BB/../../../../../..][..<a href="file:/../../../../../../..">/../../../../../../..</a>]

       Default of <b>--map-by</b> <b>package</b> <b>--bind-to</b> <b>package</b> <b>--rank-by</b> <b>fill</b> when the number of processes is greater than
       2.

          shell$ mpirun --np 4 --host hostA:4,hostB:2 ./a.out
          R0  hostA  [BB/BB/BB/BB/BB/BB/BB/BB][..<a href="file:/../../../../../../..">/../../../../../../..</a>]
          R1  hostA  [BB/BB/BB/BB/BB/BB/BB/BB][..<a href="file:/../../../../../../..">/../../../../../../..</a>]
          R2  hostA  [..<a href="file:/../../../../../../..">/../../../../../../..</a>][BB/BB/BB/BB/BB/BB/BB/BB]
          R3  hostA  [..<a href="file:/../../../../../../..">/../../../../../../..</a>][BB/BB/BB/BB/BB/BB/BB/BB]

       If  only  <b>--map-by</b>  <b>OBJ</b>  is  specified,  then  it implies <b>--bind-to</b> <b>OBJ</b> <b>--rank-by</b> <b>fill</b>. The example below
       results in <b>--map-by</b> <b>hwthread</b> <b>--bind-to</b> <b>hwthread</b> <b>--rank-by</b> <b>fill</b>

          shell$ mpirun --np 4 --map-by hwthread --host hostA:4,hostB:2 ./a.out
          R0  hostA  [B.<a href="file:/../../../../../../..">/../../../../../../..</a>][..<a href="file:/../../../../../../..">/../../../../../../..</a>]
          R1  hostA  [.B/..<a href="file:/../../../../../..">/../../../../../..</a>][..<a href="file:/../../../../../../..">/../../../../../../..</a>]
          R0  hostA  [../B./../../../../../..][..<a href="file:/../../../../../../..">/../../../../../../..</a>]
          R1  hostA  [../.B/../../../../../..][..<a href="file:/../../../../../../..">/../../../../../../..</a>]

       If only <b>--bind-to</b> <b>OBJ</b> is specified, then <b>--map-by</b> is determined by the number of processes and  <b>--rank-by</b>
       <b>fill</b>. The example below results in <b>--map-by</b> <b>package</b> <b>--bind-to</b> <b>core</b> <b>--rank-by</b> <b>fill</b>

          shell$ mpirun --np 4 --bind-to core --host hostA:4,hostB:2 ./a.out
          R0  hostA  [BB/..<a href="file:/../../../../../..">/../../../../../..</a>][..<a href="file:/../../../../../../..">/../../../../../../..</a>]
          R1  hostA  [../BB/../../../../../..][..<a href="file:/../../../../../../..">/../../../../../../..</a>]
          R2  hostA  [..<a href="file:/../../../../../../..">/../../../../../../..</a>][BB/..<a href="file:/../../../../../..">/../../../../../..</a>]
          R3  hostA  [..<a href="file:/../../../../../../..">/../../../../../../..</a>][../BB/../../../../../..]

       The mapping pattern might be better seen if we change the default <b>--rank-by</b> from <b>fill</b> to <b>span</b>. First, the
       processes  are  mapped by package iterating between the two marking a core at a time. Next, the processes
       are ranked in a spanning manner that load balances them across  the  object  they  were  mapped  against.
       Finally, the processes are bound to the core that they were mapped againast.

          shell$ mpirun --np 4 --bind-to core --rank-by span --host hostA:4,hostB:2 ./a.out
          R0  hostA  [BB/..<a href="file:/../../../../../..">/../../../../../..</a>][..<a href="file:/../../../../../../..">/../../../../../../..</a>]
          R1  hostA  [..<a href="file:/../../../../../../..">/../../../../../../..</a>][BB/..<a href="file:/../../../../../..">/../../../../../..</a>]
          R2  hostA  [../BB/../../../../../..][..<a href="file:/../../../../../../..">/../../../../../../..</a>]
          R3  hostA  [..<a href="file:/../../../../../../..">/../../../../../../..</a>][../BB/../../../../../..]

   <b>Rankfiles</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       Rankfiles  are  text  files  that  specify  detailed information about how individual processes should be
       mapped to nodes, and to which processor(s) they should be bound.  Each line of a rankfile  specifies  the
       location  of  one  process (for MPI jobs, the process’ “rank” refers to its rank in <b>MPI_COMM_WORLD</b>).  The
       general form of each line in the rankfile is:

          rank &lt;N&gt;=&lt;hostname&gt; slot=&lt;slot list&gt;

       For example:

          shell$ cat myrankfile
          rank 0=aa slot=1:0-2
          rank 1=bb slot=0:0,1
          rank 2=cc slot=2-3
          shell$ mpirun -H aa,bb,cc,dd --map-by rankfile:file=myrankfile ./a.out

       Means that:

       • Rank 0 runs on node aa, bound to logical package 1, cores 0-2.

       • Rank 1 runs on node bb, bound to logical package 0, cores 0 and 1.

       • Rank 2 runs on node cc, bound to logical cores 2 and 3.

       Note that only logicical processor locations are supported. By default, the values specifed  are  assumed
       to  be cores. If you intend to specify specific hardware threads then you must add the <b>:hwtcpus</b> qualifier
       to the <b>--map-by</b> command line option (e.g., <b>--map-by</b> <b>rankfile:file=myrankfile:hwtcpus</b>).

       If the binding specification overlaps between any two ranks then an error occurs. If you intend to  allow
       processes  to  share  the same logical processing unit then you must pass the <b>--bind-to</b> <b>:overload-allowed</b>
       command line option to tell the runtime to ignore this check.

       The hostnames listed above are “absolute,” meaning  that  actual  resolveable  hostnames  are  specified.
       However, hostnames can also be specified as “relative,” meaning that they are specified in relation to an
       externally-specified  list  of  hostnames  (e.g.,  by  <b>mpirun</b>’s  <b>--host</b>  argument,  a  hostfile, or a job
       scheduler).

       The “relative” specification is of the form <b>+n&lt;X&gt;</b>, where X is an integer specifying the Xth  hostname  in
       the set of all available hostnames, indexed from 0.  For example:

          shell$ cat myrankfile
          rank 0=+n0 slot=1:0-2
          rank 1=+n1 slot=0:0,1
          rank 2=+n2 slot=2-3
          shell$ mpirun -H aa,bb,cc,dd --map-by rankfile:file=myrankfile ./a.out

       All package/core slot locations are specified as logical indexes.

       <b>NOTE:</b>
          The  Open  MPI  v1.6 series used physical indexes. Starting in Open MPI v5.0 only logicial indexes are
          supported and the <b>rmaps_rank_file_physical</b> MCA parameter is no longer recognized.

       You can use tools such as Hwloc’s <u><a href="../man1/lstopo.1.html">lstopo</a>(1)</u> to find the logical indexes of package and cores.

   <b>Application</b> <b>Context</b> <b>or</b> <b>Executable</b> <b>Program?</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       To distinguish the two different forms, mpirun looks on the command line for  <b>--app</b>  option.   If  it  is
       specified, then the file named on the command line is assumed to be an application context.  If it is not
       specified, then the file is assumed to be an executable program.

   <b>Locating</b> <b>Files</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       If  no relative or absolute path is specified for a file, Open MPI will first look for files by searching
       the directories specified by the <b>--path</b> option.  If there is no <b>--path</b> option set or if the file  is  not
       found  at  the <b>--path</b> location, then Open MPI will search the user’s <b>PATH</b> environment variable as defined
       on the source node(s).

       If a relative directory is specified, it must be relative to the initial working directory determined  by
       the  specific  starter  used.  For  example when using the ssh starter, the initial directory is <b>$HOME</b> by
       default.  Other starters may set the  initial  directory  to  the  current  working  directory  from  the
       invocation of <b>mpirun</b>.

   <b>Current</b> <b>Working</b> <b>Directory</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       The  <b>--wdir</b>  <b>mpirun</b>  option  (and  its synonym, <b>--wd</b>) allows the user to change to an arbitrary directory
       before the program is invoked.  It can also be used in  application  context  files  to  specify  working
       directories on specific nodes and/or for specific applications.

       If  the  <b>--wdir</b> option appears both in a context file and on the command line, the context file directory
       will override the command line value.

       If the <b>-wdir</b> option is specified, Open MPI will attempt to change to the specified directory  on  all  of
       the remote nodes. If this fails, <b>mpirun</b> will abort.

       If  the  <b>-wdir</b> option is not specified, Open MPI will send the directory name where <b>mpirun</b> was invoked to
       each of the remote nodes.  The remote nodes will try to change to that directory.   If  they  are  unable
       (e.g.,  if  the  directory  does  not  exist  on that node), then Open MPI will use the default directory
       determined by the starter.

       All directory changing occurs before the user’s program is invoked; it does not wait until <u><a href="../man3/MPI_INIT.3.html">MPI_INIT</a>(3)</u> is
       called.

   <b>Standard</b> <b>I/O</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       Open MPI directs UNIX standard input to <b>/dev/null</b> on all  processes  except  the  <b>MPI_COMM_WORLD</b>  rank  0
       process. The <b>MPI_COMM_WORLD</b> rank 0 process inherits standard input from <b>mpirun</b>.

       <b>NOTE:</b>
          The  node that invoked <b>mpirun</b> need not be the same as the node where the <b>MPI_COMM_WORLD</b> rank 0 process
          resides. Open MPI handles the redirection of <b>mpirun</b>’s standard input to the rank 0 process.

       Open MPI directs UNIX standard output and error from remote nodes to the node  that  invoked  <b>mpirun</b>  and
       prints  it  on the standard output/error of <b>mpirun</b>.  Local processes inherit the standard output/error of
       <b>mpirun</b> and transfer to it directly.

       Thus it is possible to redirect standard I/O for  Open  MPI  applications  by  using  the  typical  shell
       redirection procedure on <b>mpirun</b>.  For example:

          shell$ mpirun -n 2 my_app &lt; my_input &gt; my_output

       Note that in this example only the <b>MPI_COMM_WORLD</b> rank 0 process will receive the stream from <b>my_input</b> on
       stdin.   The  stdin on all the other nodes will be tied to <b>/dev/null</b>.  However, the stdout from all nodes
       will be collected into the <b>my_output</b> file.

   <b>Signal</b> <b>Propagation</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       When <b>mpirun</b> receives a SIGTERM and SIGINT, it will  attempt  to  kill  the  entire  job  by  sending  all
       processes  in the job a SIGTERM, waiting a small number of seconds, then sending all processes in the job
       a SIGKILL.

       SIGUSR1 and SIGUSR2 signals received by <b>mpirun</b> are propagated to all processes in the job.

       A SIGTSTOP signal to <b>mpirun</b> will cause a SIGSTOP signal to be sent to all  of  the  programs  started  by
       <b>mpirun</b> and likewise a SIGCONT signal to <b>mpirun</b> will cause a SIGCONT sent.

       Other signals are not currently propagated by <b>mpirun</b>.

   <b>Process</b> <b>Termination</b> <b>/</b> <b>Signal</b> <b>Handling</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       During  the  run  of  an  MPI application, if any process dies abnormally (either exiting before invoking
       <u><a href="../man3/MPI_FINALIZE.3.html">MPI_FINALIZE</a>(3)</u>, or dying as the result of a signal), <b>mpirun</b> will print out an error message and kill the
       rest of the MPI application.

       User signal handlers should probably avoid trying to  cleanup  MPI  state  (Open  MPI  is  currently  not
       async-signal-safe;  see <u><a href="../man3/MPI_INIT_THREAD.3.html">MPI_INIT_THREAD</a>(3)</u> for details about MPI_THREAD_MULTIPLE and thread safety).  For
       example, if a segmentation fault occurs in <u><a href="../man3/MPI_SEND.3.html">MPI_SEND</a>(3)</u> (perhaps because a bad buffer was passed in) and a
       user signal handler is invoked, if this user handler attempts to invoke <u><a href="../man3/MPI_FINALIZE.3.html">MPI_FINALIZE</a>(3)</u>, Bad Things could
       happen since Open MPI was already “in” MPI when the error occurred.  Since <b>mpirun</b> will  notice  that  the
       process  died  due  to  a signal, it is probably not necessary (and safest) for the user to only clean up
       non-MPI state.

   <b>Process</b> <b>Environment</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       Processes in the MPI application inherit their environment from the PRRTE daemon upon the node  on  which
       they  are  running.   The environment is typically inherited from the user’s shell.  On remote nodes, the
       exact environment is determined by the boot MCA module used.  The rsh launch module,  for  example,  uses
       either  rsh/ssh  to  launch  the  PRRTE daemon on remote nodes, and typically executes one or more of the
       user’s shell-setup files before launching the PRRTE daemon.  When running dynamically linked applications
       which require the <b>LD_LIBRARY_PATH</b> environment variable to be set, care must be taken to ensure that it is
       correctly set when booting Open MPI.

       See the <u>Remote</u> <u>Execution</u> section for more details.

   <b>Remote</b> <b>Execution</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       Open MPI requires that the <b>PATH</b> environment variable be set to find executables on remote nodes (this  is
       typically  only necessary in rsh- or ssh-based environments — batch/scheduled environments typically copy
       the current environment to the execution of remote jobs, so if the current environment  has  <b>PATH</b>  and/or
       <b>LD_LIBRARY_PATH</b> set properly, the remote nodes will also have it set properly).  If Open MPI was compiled
       with  shared  library  support, it may also be necessary to have the <b>LD_LIBRARY_PATH</b> environment variable
       set on remote nodes as  well  (especially  to  find  the  shared  libraries  required  to  run  user  MPI
       applications).

       However,  it  is  not  always  desirable  or  possible  to  edit  shell  startup files to set <b>PATH</b> and/or
       <b>LD_LIBRARY_PATH</b>.  The <b>--prefix</b> option is provided for  some  simple  configurations  where  this  is  not
       possible.

       The  <b>--prefix</b>  option  takes  a  single argument: the base directory on the remote node where Open MPI is
       installed.  Open MPI will use this directory to set the remote <b>PATH</b> and <b>LD_LIBRARY_PATH</b> before  executing
       any  Open  MPI or user applications.  This allows running Open MPI jobs without having pre-configured the
       <b>PATH</b> and <b>LD_LIBRARY_PATH</b> on the remote nodes.

       Open MPI adds the basename of the current node’s <b>$bindir</b> (the directory where Open MPI’s executables were
       installed) to the prefix and uses that to set the <b>PATH</b> on the remote node.  Similarly, Open MPI adds  the
       basename  of  the current node’s <b>$libdir</b> (the directory where Open MPI’s libraries were installed) to the
       prefix and uses that to set the <b>LD_LIBRARY_PATH</b> on the remote node.  For example:

       • Local bindir: <b>/local/node/directory/bin</b>

       • Local libdir: <b>/local/node/directory/lib64</b>

       If the following command line is used:

          shell$ mpirun --prefix /remote/node/directory

       Open MPI will  add  <b>/remote/node/directory/bin</b>  to  the  <b>PATH</b>  and  <b>/remote/node/directory/lib64</b>  to  the
       <b>LD_LIBRARY_PATH</b> on the remote node before attempting to execute anything.

       The <b>--prefix</b> option is not sufficient if the installation paths on the remote node are different than the
       local  node  (e.g.,  if <b><a href="file:/lib">/lib</a></b> is used on the local node, but <b><a href="file:/lib64">/lib64</a></b> is used on the remote node), or if the
       installation paths are something other than a subdirectory under a common prefix.

       Note that executing <b>mpirun</b> via an absolute pathname is equivalent to specifying <b>--prefix</b> without the last
       subdirectory in the absolute pathname to <b>mpirun</b>.  For example:

          shell$ /usr/local/bin/mpirun ...

       is equivalent to

          shell$ mpirun --prefix <a href="file:/usr/local">/usr/local</a>

   <b>Exported</b> <b>Environment</b> <b>Variables</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       All environment variables that are named in the  form  <b>OMPI_*</b>  will  automatically  be  exported  to  new
       processes  on  the local and remote nodes.  Environmental parameters can also be set/forwarded to the new
       processes using the MCA parameter <b>mca_base_env_list</b>. The <b>-x</b> option to mpirun has been deprecated, but the
       syntax of the MCA param follows that prior example. While the syntax of  the  <b>-x</b>  option  and  MCA  param
       allows  the  definition  of  new variables, note that the parser for these options are currently not very
       sophisticated — it does not even understand quoted values.  Users are advised to  set  variables  in  the
       environment and use the option to export them; not to define them.

   <b>Setting</b> <b>MCA</b> <b>Parameters</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       The  <b>--mca</b>  switch  allows  the  passing  of  parameters  to various MCA (Modular Component Architecture)
       modules.  MCA modules have direct impact on MPI programs because they allow tunable parameters to be  set
       at  run  time (such as which BTL communication device driver to use, what parameters to pass to that BTL,
       etc.).

       The <b>--mca</b> switch takes two arguments: <b>&lt;key&gt;</b> and <b>&lt;value&gt;</b>.  The <b>&lt;key&gt;</b> argument  generally  specifies  which
       MCA module will receive the value.  For example, the <b>&lt;key&gt;</b> <b>btl</b> is used to select which BTL to be used for
       transporting MPI messages.  The <b>&lt;value&gt;</b> argument is the value that is passed.  For example:

          shell$ mpirun --mca btl tcp,self -n 1 my_mpi_app

       This  tells  Open  MPI  to use the <b>tcp</b> and <b>self</b> BTLs, and to run a single copy of <b>my_mpi_app</b> an allocated
       node.

          shell$ mpirun --mca btl self -n 1 my_mpi_app

       Tells Open MPI to use the <b>self</b> BTL, and to run a single copy of <b>my_mpi_app</b> an allocated node.

       The <b>--mca</b> switch can be used multiple times to specify different &lt;key&gt; and/or <b>&lt;value&gt;</b> arguments.  If  the
       same  <b>&lt;key&gt;</b>  is  specified  more than once, the <b>&lt;value&gt;``s</b> <b>are</b> <b>concatenated</b> <b>with</b> <b>a</b> <b>comma</b> <b>(</b>,``) separating
       them.

       Note that the <b>--mca</b> switch is simply a shortcut for setting environment variables.  The same  effect  may
       be  accomplished  by  setting corresponding environment variables before running <b>mpirun</b>.  The form of the
       environment variables that Open MPI sets is:

          OMPI_MCA_&lt;key&gt;=&lt;value&gt;

       Thus, the <b>--mca</b> switch overrides any previously set environment variables.  The <b>--mca</b> settings  similarly
       override     MCA     parameters     set     in     the     <b>$OPAL_PREFIX/etc/openmpi-mca-params.conf</b>    or
       <b>$HOME/.openmpi/mca-params.conf</b> file.

       Unknown <b>&lt;key&gt;</b> arguments are still set as environment variable — they are  not  checked  (by  mpirun)  for
       correctness.   Illegal  or  incorrect  <b>&lt;value&gt;</b>  arguments  may or may not be reported — it depends on the
       specific MCA module.

       To find the available component types under the MCA architecture, or to find the available parameters for
       a specific component, use the ompi_info command.  See the <u><a href="../man1/ompi_info.1.html">ompi_info</a>(1)</u> man page for detailed  information
       on this command.

   <b>Setting</b> <b>MCA</b> <b>parameters</b> <b>and</b> <b>environment</b> <b>variables</b> <b>from</b> <b>file</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       The  <b>--tune</b> command line option and its synonym <b>--mca</b> <b>mca_base_envar_file_prefix</b> allows a user to set MCA
       parameters and environment variables with the syntax described below.  This option requires a single file
       or list of files separated by “,” to follow.

       A valid line in the file may contain zero or more <b>-x</b> or <b>--mca</b>. The following patterns are supported:

       • <b>--mca</b> <b>var</b> <b>val</b>

       • <b>--mca</b> <b>var</b> <b>"val"</b>

       • <b>-x</b> <b>var=val</b>

       • <b>-x</b> <b>var</b>

       If any argument is duplicated in the file, the last value read will be used.

       MCA parameters and environment specified on the  command  line  have  higher  precedence  than  variables
       specified in the file.

   <b>Running</b> <b>as</b> <b>root</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       <b>WARNING:</b>
          The Open MPI team <b>strongly</b> advises against executing <b>mpirun</b> as the root user.  MPI applications should
          be run as regular (non-root) users.

       <b>mpirun</b> will refuse to run as root by default.

       To  override  this default, you can add the <b>--allow-run-as-root</b> option to the mpirun command line, or you
       can set the environmental parameters <b>OMPI_ALLOW_RUN_AS_ROOT=1</b> and <b>OMPI_ALLOW_RUN_AS_ROOT_CONFIRM=1</b>.  Note
       that it takes setting two environment variables to effect the same  behavior  as  <b>--allow-run-as-root</b>  in
       order to stress the Open MPI team’s strong advice against running as the root user.

       After  extended  discussions  with  communities who use containers (where running as the root user is the
       default), there was a  persistent  desire  to  be  able  to  enable  root  execution  of  <b>mpirun</b>  via  an
       environmental  control  (vs. the existing <b>--allow-run-as-root</b> command line parameter).  The compromise of
       using two environment variables was reached: it allows root execution via an environmental  control,  but
       it conveys the Open MPI team’s strong recommendation against this behavior.

   <b>Exit</b> <b>status</b>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       There  is  no  standard  definition  for  what <b>mpirun</b> should return as an exit status. After considerable
       discussion, we settled on the following method for  assigning  the  <b>mpirun</b>  exit  status  (note:  in  the
       following description, the “primary” job is the initial application started by mpirun — all jobs that are
       spawned by that job are designated “secondary” jobs):

       • If all processes in the primary job normally terminate with exit status 0, <b>mpirun</b> returns 0.

       • If  one  or  more  processes  in  the  primary job normally terminate with non-zero exit status, <b>mpirun</b>
         returns the exit status of the process with the lowest <b>MPI_COMM_WORLD</b> rank to have a non-zero status.

       • If all processes in the primary job normally terminate with exit status 0, and one or more processes in
         a secondary job normally terminate with non-zero exit status, <b>mpirun</b>:

         1. Returns the exit status of the process with the lowest <b>MPI_COMM_WORLD</b> rank in the  lowest  jobid  to
            have a non-zero status, and

         2. Outputs a message summarizing the exit status of the primary and all secondary jobs.

       • If  the  command line option <b>--report-child-jobs-separately</b> is set, we will return <u>only</u> the exit status
         of the primary job. Any non-zero exit status in secondary jobs will be reported  solely  in  a  summary
         print statement.

       By  default,  the  job  will  abort  when  any process terminates with non-zero status. The MCA parameter
       <b>--prtemca</b> <b>state_base_error_non_zero_exit</b> can be set to “false” (or “0”) to cause Open MPI to not abort  a
       job  if  one or more processes return a non-zero status. In that situation the Open MPI records and notes
       that processes exited with non-zero termination status to report the appropriate exit  status  of  <b>mpirun</b>
       (per bullet points above).

</pre><h4><b>EXAMPLES</b></h4><pre>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       Be sure also to see the examples throughout the sections above.

          shell$ mpirun -n 4 --mca btl tcp,sm,self prog1

       Run  4  copies  of  <b>prog1</b>  using  the  <b>tcp</b>, <b>sm</b> (shared memory), and <b>self</b> (process loopback) BTL’s for the
       transport of MPI messages.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
          This is old, hard-coded content

                 Is this content still current / accurate?  Should it be updated and retained, or removed?

       <b>mpirun</b> returns 0 if all processes started by mpirun exit after calling <u><a href="../man3/MPI_FINALIZE.3.html">MPI_FINALIZE</a>(3)</u>.  A non-zero value
       is returned if an internal error occurred in mpirun, or one  or  more  processes  exited  before  calling
       <u><a href="../man3/MPI_FINALIZE.3.html">MPI_FINALIZE</a>(3)</u>.   If an internal error occurred in mpirun, the corresponding error code is returned.  In
       the event that one or more processes exit  before  calling  <u><a href="../man3/MPI_FINALIZE.3.html">MPI_FINALIZE</a>(3)</u>,  the  return  value  of  the
       <b>MPI_COMM_WORLD</b>  rank of the process that mpirun first notices died before calling <u><a href="../man3/MPI_FINALIZE.3.html">MPI_FINALIZE</a>(3)</u> will be
       returned.  Note that, in general, this will be the first process that died but is not  guaranteed  to  be
       so.

       If  the  <b>--timeout</b>  command line option is used and the timeout expires before the job completes (thereby
       forcing mpirun to kill the job) mpirun will return an exit status equivalent to the  value  of  ETIMEDOUT
       (which is typically 110 on Linux and OS X systems).

       <b>SEE</b> <b>ALSO:</b>
          <u><a href="../man3/MPI_INIT.3.html">MPI_INIT</a>(3)</u>, <u><a href="../man3/MPI_INIT_THREAD.3.html">MPI_INIT_THREAD</a>(3)</u>, <u><a href="../man3/MPI_FINALIZE.3.html">MPI_FINALIZE</a>(3)</u>, <u><a href="../man1/ompi_info.1.html">ompi_info</a>(1)</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Feb 17, 2025                                         <u><a href="../man1/MPIRUN.1.html">MPIRUN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>