<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>stag-ir.pl - information retrieval using a simple relational index</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libdbix-dbstag-perl">libdbix-dbstag-perl_0.12-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       stag-ir.pl - information retrieval using a simple relational index

</pre><h4><b>SYNOPSIS</b></h4><pre>
         stag-ir.pl -r person -k social_security_no -d Pg:mydb myrecords.xml
         stag-ir.pl -d Pg:mydb -q 999-9999-9999 -q 888-8888-8888

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Indexes stag nodes (XML Elements) in a simple relational db structure - keyed by ID with an XML Blob as a
       value

       Imagine you have a very large file of data, in a stag compatible format such as XML. You want to index
       all the elements of type <b>person</b>; each person can be uniquely identified by <b>social_security_no</b>, which is a
       direct subnode of <b>person</b>

       The first thing to do is to build the index file, which will be stored in the database mydb

         stag-ir.pl -r person -k social_security_no -d Pg:mydb myrecords.xml

       You can then use the index "person-idx" to retrieve <b>person</b> nodes by their social security number

         stag-ir.pl -d Pg:mydb -q 999-9999-9999 &gt; some-person.xml

       You can export using different stag formats

         stag-ir.pl -d Pg:mydb -q 999-9999-9999 -w sxpr &gt; some-person.xml

       You can retrieve multiple nodes (although these need to be rooted to make a valid file)

         stag-ir.pl -d Pg:mydb -q 999-9999-9999 -q 888-8888-8888 -top personset

       Or you can use a list of IDs from a file (newline delimited)

         stag-ir.pl -d Pg:mydb -qf my_ss_nmbrs.txt -top personset

   <b>ARGUMENTS</b>
       <u>-d</u> <u>DB_NAME</u>

       This database will be used for storing the stag nodes

       The name can be a logical name or DBI locator or DBStag shorthand - see DBIx::DBStag

       The database must already exist

       <u>-clear</u>

       Deletes all data from the relation type (specified with <b>-r</b>) before loading

       <u>-insertonly</u>

       Does not check if the ID in the file exists in the db - will always attempt an INSERT (and will fail if
       ID already exists)

       This is the fastest way to load data (only one SQL operation per node rather than two) but is only safe
       if there is no existing data

       (Default is clobber mode - existing data with same ID will be replaced)

       <u>-newonly</u>

       If there is already data in the specified relation in the db, and the XML being loaded specifies an ID
       that is already in the db, then this node will be ignored

       (Default is clobber mode - existing data with same ID will be replaced)

       <u>-transaction_size</u>

       A commit will be performed every n UPDATEs/COMMITs (and at the end)

       Default is autocommit

       note that if you are using -insertonly, and you are using transactions, and the input file contains an ID
       already in the database, then the transaction will fail because this script will try and insert a
       duplicate ID

       <u>-r</u> <u>RELATION-NAME</u>

       This is the name of the stag node (XML element) that will be stored in the index; for example, with the
       XML below you may want to use the node name <b>person</b> and the unique key <b>id</b>

         &lt;person_set&gt;
           &lt;person&gt;
             &lt;id&gt;...&lt;/id&gt;
           &lt;/person&gt;
           &lt;person&gt;
             &lt;id&gt;...&lt;/id&gt;
           &lt;/person&gt;
           ...
         &lt;/person_set&gt;

       This flag should only be used when you want to store data

       <u>-k</u> <u>UNIQUE-KEY</u>

       This node will be used as the unique/primary key for the data

       This node should be nested directly below the node that is being stored in the index - if it is more that
       one below, specify a path

       This flag should only be used when you want to store data

       <u>-u</u> <u>UNIQUE-KEY</u>

       Synonym for <b>-k</b>

       <u>-create</u>

       If specified, this will create a table for the relation name specified below; you should use this the
       first time you index a relation

       <u>-idtype</u> <u>TYPE</u>

       (optional)

       This is the SQL datatype for the unique key; it defaults to <a href="../man255/VARCHAR.255.html">VARCHAR</a>(255)

       If you know that your id is an integer, you can specify INTEGER here

       If your id is always a 8-character field you can do this

         -idtype '<a href="../man8/CHAR.8.html">CHAR</a>(8)'

       This option only makes sense when combined with the <b>-c</b> option

       <u>-p</u> <u>PARSER</u>

       This can be the name of a stag supported format (xml, sxpr, itext) - XML is assumed by default

       It can also be a module name - this module is used to parse the input file into a stag stream; see
       Data::Stag::BaseGenerator for details on writing your own parsers/event generators

       This flag should only be used when you want to store data

       <u>-q</u> <u>QUERY-ID</u>

       Fetches the relation/node with unique key value equal to query-id

       Multiple arguments can be passed by specifying -q multple times

       This flag should only be used when you want to query data

       <u>-top</u> <u>NODE-NAME</u>

       If this is specified in conjunction with <b>-q</b> or <b>-qf</b> then all the query result nodes will be nested inside
       a node with this name (ie this provides a root for the resulting document tree)

       <u>-qf</u> <u>QUERY-FILE</u>

       This is a file of newline-seperated IDs; this is useful for querying the index in batch

       <u>-keys</u>

       This will write a list of all primary keys in the index

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Data::Stag

       For more complex stag to database mapping, see DBIx::DBStag and the scripts

       stag-db.pl use file DBM indexes

       stag-storenode.pl is for storing fully normalised stag trees

       selectall_xml

perl v5.36.0                                       2022-10-14                                        <u><a href="../man1p/STAG-IR.1p.html">STAG-IR</a></u>(1p)
</pre>
 </div>
</div></section>
</div>
</body>
</html>