<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>justbuild - a generic build tool</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/justbuild">justbuild_1.4.1-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       justbuild - a generic build tool

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>justbuild</b> <b>version</b>
       <b>justbuild</b> {<b>analyse</b>|<b>build</b>} [<u>OPTION</u>]...  [[<u>module</u>] <u>target</u>]
       <b>justbuild</b> <b>install</b> [<u>OPTION</u>]...  <b>-o</b> <u>OUTPUT_DIR</u> [[<u>module</u>] <u>target</u>]
       <b>justbuild</b> <b>install-cas</b> [<u>OPTION</u>]...  <u>OBJECT_ID</u>
       <b>justbuild</b> <b>add-to-cas</b> [<u>OPTION</u>]...  <u>PATH</u>
       <b>justbuild</b> <b>describe</b> [<u>OPTION</u>]...  [[<u>module</u>] <u>target</u>]
       <b>justbuild</b> <b>rebuild</b> [<u>OPTION</u>]...  [[<u>module</u>] <u>target</u>]
       <b>justbuild</b> <b>traverse</b> [<u>OPTION</u>]...  <b>-o</b> <u>OUTPUT_DIR</u> <b>-g</b> <u>GRAPH_FILE</u>
       <b>justbuild</b> <b>gc</b> [<u>OPTION</u>]...
       <b>justbuild</b> <b>execute</b> [<u>OPTION</u>]...
       <b>justbuild</b> <b>serve</b> <u>SERVE_CONFIG_FILE</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Just  is  a  generic  multi-repository build system; language-specific knowledge is described in separate
       rule files.  For every build action, the relative location of the inputs is independent of their physical
       location.  This staging allows taking sources from different locations (logical repositories),  including
       bare  Git  repositories.   Targets  are  defined  using  JSON  format, in proper files (by default, named
       <u>TARGETS</u>).  Targets are uniquely identified by their name, the repository, and the module they belong  to.
       A  module  is  the relative path from the repository target root directory to a subdirectory containing a
       target file.

       The module’s name of the targets defined at the target root level is the empty  string.   Specifying  the
       correct  repository,  target root, module, and target name allows to process that target independently of
       the current working directory.

       If the module is not specified on the command line,  <b>justbuild</b>  sets  the  module  corresponding  to  the
       current working directory.

       If  a  target  is  not  specified, the lexicographically-first target, according to native byte order, is
       used.  So, a target named with an empty string will always be the default target for that module.

       If a target depends on other targets defined in other modules or repositories, <b>justbuild</b> will recursively
       visit all and only the required modules.

       The main repository is the repository containing the target specified on  the  command  line.   The  main
       repository  can either be read from the multi-repository configuration file if it contains the key <u>"main"</u>
       or through the option <b>--main</b>.  The command-line option <b>--main</b> overrides what is eventually read from  the
       multi-repository  configuration  file.   If  neither the multi-repository configuration file contains the
       <u>"main"</u>  key  nor  the  <b>--main</b>  option  is  provided,  the  lexicographical  first  repository  from   the
       multi-repository configuration file is used as main.

       The  <u>workspace_root</u> of the main repository is then defined as follows.  If the option <b>--workspace-root</b> is
       provided, then <u>workspace_root</u> is set accordingly.  If the option is not provided, <b>justbuild</b> checks if  it
       is  specified  within the multi-repository configuration file.  If it is, then it is set accordingly.  If
       not, <b>justbuild</b> starts looking for a marker in the  current  directory  first,  then  in  all  the  parent
       directories until it finds one.  The supported markers are

       • <u>ROOT</u> file (can be empty, content is ignored)

       • <u>WORKSPACE</u> (can be empty, content is ignored)

       • <u>.git</u> (can be either a file - empty or not, content is ignored - or the famous directory)

       If it fails, <b>justbuild</b> errors out.

       For   non-main   repositories,  the  <u>workspace_root</u>  entry  must  be  declared  in  the  multi-repository
       configuration file.

       Afterwards, <u>target_root</u>, <u>rule_root</u>, and <u>expression_root</u> directories for the main repository are set using
       the following strategy.  If the corresponding command-line option  is  specified,  then  it  is  honored.
       Otherwise,  it is read from the multi-repo configuration file.  If it is not specified there, the default
       value is used.  The default value of <u>target_root</u> is <u>workspace_root</u>, of <u>rule_root</u> is <u>target_root</u>,  and  of
       <u>expression_root</u> is <u>rule_root</u>.

       Finally,  the  file  names where <u>targets</u>, <u>rules</u>, and <u>expressions</u> are defined for the main repository.  If
       the corresponding key is present in the multi-repository configuration file, it is set  accordingly.   If
       the  user  gives  the  corresponding  command-line option, it overwrites what is eventually read from the
       configuration file.  If they are not explicitly stated neither within the multi-repository  configuration
       file  nor  on  the  command line, the default values are used, which are <u>TARGETS</u>, <u>RULES</u>, and <u>EXPRESSIONS</u>,
       respectively.

       For non-main repositories (i.e., repositories defining targets  required  by  the  target  given  on  the
       command line), <u>target_root</u>, <u>rule_root</u>, <u>expression_root</u>, and file names of targets, rules and expressions,
       if different from the default values, must be declared in the multi-repository configuration file.

</pre><h4><b>SUBCOMMANDS</b></h4><pre>
   <b>version</b>
       Print  on  stdout  a  JSON object providing version information about the version of the tool used.  This
       JSON object will contain at least the following keys.

       • <u>"version"</u> The version, as a list of numbers of length at least 3, following the usual  convention  that
         version numbers are compared lexicographically.

       • <u>"suffix"</u>  The  version  suffix  as a string.  Generally, suffixes starting with a + symbol are positive
         offsets to the version, while suffixes starting with a <u>~</u> symbol are negative offsets.

       • <u>"SOURCE_DATE_EPOCH"</u> Either a number or <u>null</u>.  If it is a number, it is the time, in seconds  since  the
         epoch,  of  the last commit that went into this binary.  It is <u>null</u> if that time is not known (e.g., in
         development builds).

   <b>analyse</b>|<b>build</b>|<b>install</b>
       The subcommands <b>analyse</b>, <b>build</b>, and <b>install</b> are strictly related.  In fact, from left to right, one is  a
       subset  of  the  other.  <b>build</b> performs work on top of <b>analyse</b>, and <b>install</b> on top of <b>build</b>.  When a user
       issues <b>build</b>, the <b>analyse</b> is called underneath.  In particular, there is  no  need  to  run  these  three
       subcommands sequentially.

   <b>analyse</b>
       analyse  reads  the  target  graph  from  <u>TARGETS</u>  files  for the given target, computes the action graph
       (required by e.g., <b>build</b>, <b>install</b>, <b>traverse</b>), and reports the artifacts, provides, and  runfiles  of  the
       analysed target.

       In  short,  the  <b>analyse</b>  subcommand  identifies  all  the steps required to <b>build</b> a given target without
       actually performing those steps.

       This subcommand, issued with proper flags, can dump  in  JSON  format  artifacts,  action  graph,  nodes,
       actions, (transitive) targets (both named and anonymous), and trees.

   <b>build</b>
       This subcommand performs the actions contained in the action graph computed through the <b>analyse</b> phase.

       If  building  locally,  the  building process is performed in temporary separate directories to allow for
       staging according to the logical path described in the <u>TARGETS</u> file.  Since artifacts are only stored  in
       the CAS, the user has to use either the <b>install</b> or <b>install-cas</b> subcommand to get them.

       <b>justbuild</b>  allows  for  both  local  (i.e.,  on  the  same  machine  where  <b>justbuild</b> is used) and remote
       compilation (i.e., by sending requests over a TCP connection, e.g., to a different  machine,  cluster  or
       cloud  infrastructure).   In  case of a remote compilation, artifacts are compiled remotely and stored in
       the remote CAS.  <b>install</b> and <b>install-cas</b> subcommands can be used to locally fetch and stage  the  desired
       artifacts.

   <b>install</b>
       The  <b>install</b>  subcommand  determines which (if any) actions need to be (re)done and issues the command to
       (re)run them.  Then, it installs the artifacts (stored in the local  or  remote  CAS)  of  the  processed
       target  under  the  given <u>OUTPUT_DIR</u> (set by option <b>-o</b>) honoring the logical path (aka, staging).  If the
       output path does not exist, it will create all the  necessary  folders  and  subfolders.   If  files  are
       already present, they will be overwritten.

   <b>rebuild</b>
       This subcommand inspects if builds are fully reproducible or not (e.g., time stamps are used).  It simply
       rebuilds and compares artifacts to the cached build reporting actions with different output.  To do so in
       a meaningful way, it requires that previous build is already in the cache (local or remote).

   <b>describe</b>
       The  <b>describe</b>  subcommand  allows  for  describing the rule generating a target.  The rule is resolved in
       precisely the same way as during the analysis.  The doc-strings (if any) from  the  rule  definition  (if
       user-defined)  are  reported,  together  with  a  summary  of  the  declared fields and their types.  The
       multi-repository configuration is honored in the same way as during <b>analyse</b> and <b>build</b>; in particular, the
       rule definition can also reside in a git-tree root.

   <b>install-cas</b>
       <b>install-cas</b> fetches artifacts from CAS (Content Addressable Storage) by means of their <u>OBJECT_ID</u>  (object
       identifier).   The  canonical  format  of  an  object identifier is <u>[&lt;hash&gt;:&lt;size&gt;:&lt;type&gt;]</u>; however, when
       parsing an object identifier, <b>install-cas</b> uses the following default rules, to make usage simpler.

       • The square brackets are optional.

       • If the size is missing (e.g., because the argument contains no colon), or cannot be parsed as a number,
         this is not an error, and the value 0 is assumed.  While this is almost never the  correct  size,  many
         CAS implementations, including the local CAS of justbuild itself, ignore the size for lookups.

       • From the type, only the first letter (<u>f</u> for non-executable file, <u>x</u> for executable file, and <u>t</u> for tree)
         is  significant; the rest is ignored.  If the type is missing (e.g., because the argument contains less
         than two colons), or its first letter is not one of the valid ones, <u>f</u> is assumed.

       Depending on whether the output path is set or not, the behavior is different.

   <b>Output</b> <b>path</b> <b>is</b> <b>omitted</b>
       If the output path is omitted, it prints the artifact content to stdout and if the artifact is a tree, it
       will print a human readable description.

   <b>Output</b> <b>path</b> <b>is</b> <b>set</b>
       1. Output path does not exist

           The artifact will be staged to that path.  If artifact is a file, the installed  one  will  have  the
           name of the output path.  If the artifact is a tree, it will create a directory named like the output
           path, and will stage all the entries (subtrees included) under that directory.

       2. Output path exists and it is a directory

           If the artifact is a tree, a directory named with the hash of tree itself is created under the output
           path, and all the entries and subtrees are installed inside the hash-named directory.

           If  the  artifact is a file, it is installed under the output path and named according to the hash of
           the artifact itself.

       3. Output path exists and it is a file

           If the artifact is a file, it will replace the existing file.  If the artifact is  a  tree,  it  will
           cause an error.

   <b>add-to-cas</b>
       <b>add-to-cas</b>  adds  a  file  or  directory  to  the  local  CAS  and reports the hash (without size or type
       information) on stdout.  If a remote endpoint is given, the object is also uploaded there.   A  main  use
       case  of  this  command  is  to  simplify  the  setup of "git tree" repositories, where it can also avoid
       checking out a repository of a foreign version-control system twice.

   <b>traverse</b>
       It allows for the building and staging of  requested  artifacts  from  a  well-defined  <u>GRAPH_FILE</u>.   See
       <b><a href="../man5/just-graph-file.5.html">just-graph-file</a></b>(5) for more details.

   <b>gc</b>
       The  <b>gc</b>  subcommand triggers garbage collection of the local cache.  More precisely, it rotates the cache
       and CAS generations.  During a build, upon cache hit, everything related to that cache hit is uplinked to
       the youngest generation; therefore, upon a call to <b>gc</b> everything not referenced since the last call to <b>gc</b>
       is purged and the corresponding disk space reclaimed.

       Additionally, and before doing  generation  rotation,  -  left-over  temporary  directories  (e.g.,  from
       interrupted  justbuild  invocations) are removed, and - large files are split and only the chunks and the
       information how to assemble the file from the chunks are kept; in this way disk space  is  saved  without
       losing information.

       As the non-rotating tasks can be useful in their own right, the --no-rotate option can be used to request
       only the clean-up tasks that do not lose information.

   <b>execute</b>
       This subcommand starts a single node remote execution service, honoring the just native remote protocol.

       If  the  flag  <b>--compatible</b>  is  provided,  the  execution  service  will honor the original remote build
       execution protocol.

   <b>serve</b>
       This subcommand starts a service that provides target dependencies needed for a remote  execution  build.
       It  expects  as  its  only  and mandatory argument the path to a configuration file, following the format
       described in <b><a href="../man5/just-serve-config.5.html">just-serve-config</a></b>(5).

</pre><h4><b>OPTIONS</b></h4><pre>
   <b>Generic</b> <b>program</b> <b>information</b>
       <b>-h</b>, <b>--help</b>
       Output a usage message and exit.
       Supported by: all subcommands.

   <b>Compatibility</b> <b>options</b>
       <b>--compatible</b>
       At increased computational effort, be compatible with the original remote build execution  protocol.   As
       the change affects identifiers, the flag must be used consistently for all related invocations.
       Supported by: add-to-cas|analyse|build|describe|install-cas|install|rebuild|traverse|execute.

   <b>Build</b> <b>configuration</b> <b>options</b>
       <b>--action-timeout</b> <u>NUM</u>
       Action timeout in seconds.  (Default: 300).  The timeout is honored only for the remote build.
       Supported by: build|install|rebuild|traverse.

       <b>-c</b>, <b>--config</b> <u>PATH</u>
       Path to configuration file.
       Supported by: analyse|build|describe|install|rebuild.

       <b>-C</b>, <b>--repository-config</b> <u>PATH</u>
       Path to configuration file for multi-repository builds.  See <b><a href="../man5/just-repository-config.5.html">just-repository-config</a></b>(5) for more details.
       Supported by: analyse|build|describe|install|rebuild|traverse.

       <b>-D</b>, <b>--defines</b> <u>JSON</u>
       Defines,  via  an  in-line  JSON  object  a  configuration  to overlay (in the sense of <u>map_union</u>) to the
       configuration obtained by the <b>--config</b> option.  If <b>-D</b> is given several times, the <b>-D</b> options  overlay  in
       the order they are given on the command line.
       Supported by: analyse|build|describe|install|rebuild.

       <b>--request-action-input</b> <u>ACTION</u>
       Modify  the request to be, instead of the analysis result of the requested target, the input stage of the
       specified action as artifacts, with empty runfiles and a provides map providing the remaining information
       about the action, in particular as <u>"cmd"</u> the arguments vector and <u>"env"</u> the environment.

       An action can be specified in the following ways

       • an action identifier prefixed by the <u>%</u> character

       • a number prefixed by the <u>#</u> character (note that it requires quoting on most  shells).   This  specifies
         the  action with that index of the actions associated directly with that target; the indices start from
         0 onwards, and negative indices count from the end of the array of actions.

       • an action identifier or number without prefix, provided the  action  identifier  does  not  start  with
         either <u>%</u> or <u>#</u> and the number does not happen to be a valid action identifier.

       Supported by: analyse|build|describe|install|rebuild.

       <b>--expression-file-name</b> <u>TEXT</u>
       Name of the expressions file.
       Supported by: analyse|build|describe|install|rebuild.

       <b>--expression-root</b> <u>PATH</u>
       Path of the expression files’ root directory.  Default: Same as <b>--rule-root</b>.
       Supported by: analyse|build|describe|install|rebuild.

       <b>-L</b>, <b>--local-launcher</b> <u>JSON_ARRAY</u>
       JSON  array  with the list of strings representing the launcher to prepend actions’ commands before being
       executed locally.  Default value: <u>["env",</u> <u>"--"]</u>
       Supported by: build|install|rebuild|traverse|execute.

       <b>--local-build-root</b> <u>PATH</u>
       Root for local CAS, cache, and build directories.  The path will be created if it does not exist already.
       Supported by: add-to-cas|build|describe|install-cas|install|rebuild|traverse|gc|execute.

       <b>--main</b> <u>NAME</u>
       The repository to take the target from.
       Supported by: analyse|build|describe|install|rebuild|traverse.

       <b>--rule-file-name</b> <u>TEXT</u>
       Name of the rules file.
       Supported by: analyse|build|describe|install|rebuild.

       <b>--rule-root</b> <u>PATH</u>
       Path of the rule files’ root directory.  Default: Same as <b>--target-root</b>
       Supported by: analyse|build|describe|install|rebuild.

       <b>--target-file-name</b> <u>TEXT</u>
       Name of the targets file.
       Supported by: analyse|build|describe|install|rebuild.

       <b>--target-root</b> <u>PATH</u>
       Path of the target files’ root directory.  Default: Same as <b>--workspace-root</b>
       Supported by: analyse|build|describe|install|rebuild.

       <b>-w</b>, <b>--workspace-root</b> <u>PATH</u>
       Path of the workspace’s root directory.
       Supported by: analyse|build|describe|install|rebuild|traverse.

   <b>General</b> <b>output</b> <b>options</b>
       <b>--dump-artifacts-to-build</b> <u>PATH</u>
       File path for writing the artifacts to build to.  Output format is JSON map with staging path as key, and
       intentional artifact description as value.
       Supported by: analyse|build|install|rebuild.

       <b>--dump-artifacts</b> <u>PATH</u>
       Dump artifacts generated by the given target.  Using <u>-</u> as PATH, it is interpreted as stdout.  Note  that,
       passing  <u>.</u>/<u>-</u> will instead create a file named <u>-</u> in the current directory.  Output format is JSON map with
       staging path as key, and object id description (hash, type, size) as value.  Each artifact is  guaranteed
       to be <u>KNOWN</u> in CAS.  Therefore, this option cannot be used with <b>analyse</b>.
       Supported by: build|install|rebuild|traverse.

       <b>--dump-graph</b> <u>PATH</u>
       File path for writing the action graph description to.  See <b><a href="../man5/just-graph-file.5.html">just-graph-file</a></b>(5) for more details.
       Supported by: analyse|build|install|rebuild.

       <b>--dump-plain-graph</b> <u>PATH</u>
       File path for writing the action graph description to, however without the additional "origins" key.  See
       <b><a href="../man5/just-graph-file.5.html">just-graph-file</a></b>(5) for more details.
       Supported by: analyse|build|install|rebuild.

       <b>-f</b>, <b>--log-file</b> <u>PATH</u>
       Path  to  local  log  file.  <b>justbuild</b> will store the information printed on stderr in the log file along
       with the thread id and timestamp when the output has been generated.
       Supported by: add-to-cas|analyse|build|describe|install|install-cas|rebuild|traverse|gc|execute.

       <b>--log-limit</b> <u>NUM</u>
       Log limit (higher is more verbose) in interval [0,6] (Default: 3).
       Supported by: add-to-cas|analyse|build|describe|install|install-cas|rebuild|traverse|gc|execute.

       <b>--restrict-stderr-log-limit</b> <u>NUM</u>
       Restrict logging on console to the minimum of the specified <b>--log-limit</b> and the value specified  in  this
       option.  The default is to not additionally restrict the log level at the console.
       Supported by: add-to-cas|analyse|build|describe|install|install-cas|rebuild|traverse|gc|execute.

       <b>--plain-log</b>
       Do not use ANSI escape sequences to highlight messages.
       Supported by: add-to-cas|analyse|build|describe|install|install-cas|rebuild|traverse|gc|execute.

       <b>--log-append</b>
       Append messages to log file instead of overwriting existing.
       Supported by: add-to-cas|analyse|build|describe|install|install-cas|rebuild|traverse|gc|execute.

       <b>--expression-log-limit</b> <u>NUM</u>
       In  error  messages,  truncate  the  entries in the enumeration of the active environment, as well as the
       expression to be evaluated, to the specified number of characters (default: 320).
       Supported by: analyse|build|install.

       <b>--serve-errors-log</b> <u>PATH</u>
       Path to local file in which <b>justbuild</b> will write, in machine readable form, the references to all  errors
       that  occurred  on  the  serve side.  More precisely, the value will be a JSON array with one element per
       failure, where the element is a pair (array of length 2) consisting of the configured target (serialized,
       as usual, as a pair of qualified target name an configuration) and a string with the  hex  representation
       of  the  blob identifier of the log; the log itself is guaranteed to be available on the remote-execution
       side.  Supported by: analyse|build|install.

       <b>-P</b>, <b>--print-to-stdout</b> <u>LOGICAL_PATH</u>
       After building, print the specified artifact to stdout.
       Supported by: build|install|rebuild|traverse.

       <b>-s</b>, <b>--show-runfiles</b>
       Do not omit runfiles in build report.
       Supported by: build|install|rebuild|traverse.

       <b>--target-cache-write-strategy</b> <u>STRATEGY</u>
       Strategy for creating target-level cache entries.  Supported values are

       • <u>sync</u> Synchronize the artifacts of the export targets and write target-level cache entries.  This is the
         default behaviour.

       • <u>split</u> Synchronize the artifacts of the export targets, using blob  splitting  if  the  remote-execution
         endpoint  supports  it,  and  write  target-level  cache  entries.  As opposed to the default strategy,
         additional entries (the chunks) are created in the CAS, but subsequent syncs  of  similar  blobs  might
         need less traffic.

       • <u>disable</u>  Do  not  write any target-level cache entries.  As no artifacts have to be synced, this can be
         useful for one-off builds of a project or when the  connection  to  the  remote-execution  endpoint  is
         behind a very slow network.

       Supported by: build|install|rebuild.

   <b>Output</b> <b>dir</b> <b>and</b> <b>path</b>
       <b>-o</b>, <b>--output-dir</b> <u>PATH</u>
       Path  of  the  directory where outputs will be copied.  If the output path does not exist, it will create
       all the necessary folders and subfolders.  If the artifacts  have  been  already  staged,  they  will  be
       overwritten.
       Required by: install|traverse.

       <b>-o</b>, <b>--output-path</b> <u>PATH</u>
       Install path for the artifact.  Refer to <b>install-cas</b> section for more details.
       Supported by: install-cas.

       <b>--archive</b>
       Instead  of installing the requested tree, install an archive with the content of the tree.  It is a user
       error to specify <b>--archive</b> and not request a tree.
       Supported by: install-cas.

       <b>--raw-tree</b>
       When installing a tree to stdout, i.e., when no option <b>-o</b> is given, dump  the  raw  tree  rather  than  a
       pretty-printed version.  This option is ignored if <b>--archive</b> is given.
       Supported by: install-cas.

       <b>-P</b>, <b>--sub-object-path</b> <u>PATH</u>
       Instead of the specified tree object take the object at the specified logical path inside.
       Supported by: install-cas.

       <b>--remember</b>
       Ensure that all installed artifacts are available in local CAS as well, even when using remote execution.
       Supported by: install|traverse|install-cas.

   <b>Parallelism</b> <b>options</b>
       <b>-J</b>, <b>--build-jobs</b> <u>NUM</u>
       Number of jobs to run during build phase.  Default: same as <b>--jobs</b>.
       Supported by: build|install|rebuild|traverse.

       <b>-j</b>, <b>--jobs</b> <u>NUM</u>
       Number of jobs to run.  Default: Number of cores.
       Supported by: analyse|build|describe|install|rebuild|traverse.

   <b>Remote</b> <b>execution</b> <b>options</b>
       As  remote  execution  properties shard the target-level cache, they are also available for analysis.  In
       this way, the same action identifiers can be achieved despite  the  extensional  projection  inherent  to
       target level caching, e.g., in conjunction with <b>--request-action-input</b>.

       <b>--remote-execution-property</b> <u>KEY</u>:<u>VAL</u>
       Property  for  remote execution as key-value pair.  Specifying this option multiple times will accumulate
       pairs.  If multiple pairs with the same key are given, the latest wins.
       Supported by: analyse|build|install|rebuild|traverse.

       <b>-r</b>, <b>--remote-execution-address</b> <u>NAME</u>:<u>PORT</u>
       Address of the remote execution service.
       Supported by: add-to-cas|analyse|build|describe|install-cas|install|rebuild|traverse.

       <b>--endpoint-configuration</b> FILE
       File containing a description on how to dispatch to different remote-execution  endpoints  based  on  the
       execution  properties.   The format is a JSON list of pairs (lists of length two) of an object of strings
       and a string.  The first entry describes a condition (the remote-execution properties have  to  agree  on
       the domain of this object), the second entry is a remote-execution address in the NAME:PORT format as for
       the  <b>-r</b>  option.   The  first  matching  entry  (if any) is taken; if none matches, the default execution
       endpoint is taken (either as specified by <b>-r</b>, or local execution if no endpoint is specified).
       Supported by: analyse|build|install|rebuild|traverse.

       <b>--max-attempts</b> <u>NUM</u>
       If a remote procedure call (rpc) returns grpc::StatusCode::UNAVAILABLE, that rpc is retried at  most  <u>NUM</u>
       times.  (Default: 1, i.e., no retry).
       Supported by: analyse|build|describe|install|rebuild|traverse.

       <b>--initial-backoff-seconds</b> <u>NUM</u>
       Before  retrying  the  second  time,  the  client will wait the given amount of seconds plus a jitter, to
       better distribute the workload.  (Default: 1).
       Supported by: analyse|build|describe|install|rebuild|traverse.

       <b>--max-backoff-seconds</b> <u>NUM</u>
       From the third attempt (included) on, the backoff time is doubled at each attempt, until it  exceeds  the
       max-backoff-seconds parameter.  From that point, the waiting time is computed as max-backoff-seconds plus
       a jitter.  (Default: 60)
       Supported by: analyse|build|describe|install|rebuild|traverse.

       <b>--max-attempts</b> <u>NUM</u>
       If  a  remote procedure call (rpc) returns grpc::StatusCode::UNAVAILABLE, that rpc is retried at most <u>NUM</u>
       times.  (Default: 1, i.e., no retry).
       Supported by: analyse|build|install|rebuild|traverse.

       <b>--initial-backoff-seconds</b> <u>NUM</u>
       Before retrying the second time, the client will wait the given amount  of  seconds  plus  a  jitter,  to
       better distribute the workload.  (Default: 1).
       Supported by: analyse|build|install|rebuild|traverse.

       <b>--max-backoff-seconds</b> <u>NUM</u>
       From  the  third attempt (included) on, the backoff time is doubled at each attempt, until it exceeds the
       max-backoff-seconds parameter.  From that point, the waiting time is computed as max-backoff-seconds plus
       a jitter.  (Default: 60)
       Supported by: analyse|build|install|rebuild|traverse.

   <b>Remote</b> <b>serve</b> <b>options</b>
       <b>-R</b>, <b>--remote-serve-address</b> <u>NAME</u>:<u>PORT</u>
       Address of the remote execution service.
       Supported by: analyse|build|describe|install|rebuild.

   <b>Authentication</b> <b>options</b>
       Only TLS and mutual TLS (mTLS) are supported.

       <b>--tls-ca-cert</b> <u>PATH</u>
       Path to a TLS CA certificate that is trusted to sign the server certificate.
       Supported by: add-to-cas|analyse|build|describe|install-cas|install|rebuild|traverse|execute.

       <b>--tls-client-cert</b> <u>PATH</u>
       Path to a TLS client certificate to enable mTLS.  It must be passed in conjunction with  <b>--tls-client-key</b>
       and <b>--tls-ca-cert</b>.
       Supported by: add-to-cas|analyse|build|describe|install-cas|install|rebuild|traverse.

       <b>--tls-client-key</b> <u>PATH</u>
       Path  to  a  TLS  client key to enable mTLS.  It must be passed in conjunction with <b>--tls-client-cert</b> and
       <b>--tls-ca-cert</b>.
       Supported by: add-to-cas|analyse|build|describe|install-cas|install|rebuild|traverse.

   <b>analyse</b> specific options
       <b>--dump-actions</b> <u>PATH</u>
       Dump actions to file.  <u>-</u> is treated as stdout.  Output is a list of action descriptions, in JSON  format,
       for the given target.

       <b>--dump-anonymous</b> <u>PATH</u>
       Dump  anonymous  targets  to  file.   <u>-</u>  is  treated as stdout.  Output is a JSON map, for all transitive
       targets, with two entries: <u>nodes</u> and <u>rule_maps</u>.  The former contains maps between node id  and  the  node
       description.   <u>rule_maps</u>  states  the  maps  between the <u>mode_type</u> and the rule to use in order to make a
       target out of the node.

       <b>--dump-blobs</b> <u>PATH</u>
       Dump blobs to file.  <u>-</u> is treated as stdout.  The term <u>blob</u> identifies a collection of strings  that  the
       execution back end should be aware of before traversing the action graph.  A blob, will be referred to as
       a <u>KNOWN</u> artifact in the action graph.

       <b>--dump-nodes</b> <u>PATH</u>
       Dump  nodes of only the given target to file.  <u>-</u> is treated as stdout.  Output is a JSON map between node
       id and its description.

       <b>--dump-vars</b> <u>PATH</u>
       Dump configuration variables to file.  <u>-</u> is treated as stdout.  The  output  is  a  JSON  list  of  those
       variable  names  (in  lexicographic  order)  at  which  the configuration influenced the analysis of this
       target.  This might contain variables unset in the configuration if the fact that they  were  unset  (and
       hence treated as the default <u>null</u>) was relevant for the analysis of that target.

       <b>--dump-targets</b> <u>PATH</u>
       Dump  all transitive targets to file for the given target.  <u>-</u> is treated as stdout.  Output is a JSON map
       of all targets encoded as tree by their entity name:

              { "#": // anonymous targets
                { "&lt;rule_map_id&gt;":
                  { "&lt;node_id&gt;": ["&lt;serialized config1&gt;", ...] } // all configs this target is configured with
                }
              , "@": // "normal" targets
                { "&lt;repo&gt;":
                  { "&lt;module&gt;":
                    { "&lt;target&gt;": ["&lt;serialized config1&gt;", ...] } // all configs this target is configured with
                  }
                }
              }

       <b>--dump-export-targets</b> <u>PATH</u>
       Dump all transitive targets to file for the given target that  are  export  targets.   <u>-</u>  is  treated  as
       stdout.  The output format is the same as for <b>--dump-targets</b>.

       <b>--dump-targets-graph</b> <u>PATH</u>
       Dump  the graph of configured targets to a file (even if it is called <u>-</u>).  In this graph, only non-source
       targets are reported.  The graph is represented as a JSON object.  The keys are the nodes of  the  graph,
       and  for  each  node,  the  value  is  a  JSON object containing the different kind of dependencies (each
       represented as a list of nodes).

       • <u>"declared"</u> are the dependencies coming from the target fields in the definition of the target

       • <u>"implicit"</u> are the dependencies implicit from the rule definition

       • <u>"anonymous"</u> are the dependencies on anonymous targets implicitly referenced during  the  evaluation  of
         that rule

       While  the  node  names  are  strings (so that they can be keys in a JSON object), they can themselves be
       decoded as JSON and in this way precisely name the configured target.  More precisely, the JSON  decoding
       of  a  node  name  is  a  list  of length two, with the first entry being the target name (as <u>["@",</u> <u>repo,</u>
       <u>module,</u> <u>target]</u> or <u>["#",</u> <u>rule_map_id,</u> <u>node_id]</u>) and the second entry the effective configuration.

       <b>--dump-trees</b> <u>PATH</u>
       Dump trees and all subtrees of the given target to file.  <u>-</u> is treated as stdout.  Output is a  JSON  map
       between tree ids and the corresponding artifact map, which maps the path to the artifact description.

       <b>--dump-provides</b> <u>PATH</u>
       Dump  the provides map of the given target to file.  <u>-</u> is treated as stdout.  The output is a JSON object
       mapping the providers to their values, serialized as JSON; in particular, artifacts  are  replaced  by  a
       JSON object with their intensional description.  Therefore, the dumped JSON is not uniquely readable, but
       requires an out-of-band understanding where artifacts are to be expected.

       <b>--dump-result</b> <u>PATH</u>
       Dump the result of the analysis for the requested target to file.  <u>-</u> is treated as stdout.  The output is
       a JSON object with the keys <u>"artifacts"</u>, <u>"provides"</u>, and <u>"runfiles"</u>.

       <b>--dump-provides</b> <u>PATH</u>
       Dump  the provides map of the given target to file.  <u>-</u> is treated as stdout.  The output is a JSON object
       mapping the providers to their values, serialized as JSON; in particular, artifacts  are  replaced  by  a
       JSON object with their intensional description.  Therefore, the dumped JSON is not uniquely readable, but
       requires an out-of-band understanding where artifacts are to be expected.

   <b>rebuild</b> specific options
       <b>--vs</b> <u>NAME</u>:<u>PORT</u>|<u>"local"</u>
       Cache endpoint to compare against (use <u>"local"</u> for local cache).

       <b>--dump-flaky</b> <u>PATH</u>
       Dump flaky actions to file.

   <b>add-to-cas</b> specific options
       <b>--follow-symlinks</b>
       Resolve the positional argument to not be a symbolic link by following symbolic links.  The default is to
       add the link itself, i.e., the string obtained by <b><a href="../man2/readlink.2.html">readlink</a></b>(2), as blob.

   <b>traverse</b> specific options
       <b>-a</b>, <b>--artifacts</b> <u>TEXT</u>
       JSON maps between relative path where to copy the artifact and its description (as JSON object as well).

       <b>-g</b>, <b>--graph-file</b> <u>TEXT</u> <u>[[REQUIRED]]</u>
       Path of the file containing the description of the actions.  See <b><a href="../man5/just-graph-file.5.html">just-graph-file</a></b>(5) for more details.

       <b>--git-cas</b> <u>TEXT</u>
       Path to a Git repository, containing blobs of potentially missing <u>KNOWN</u> artifacts.

   <b>describe</b> specific options
       <b>--json</b>
       Omit pretty-printing and describe rule in JSON format.

       <b>--rule</b>
       Module and target arguments refer to a rule instead of a target.

   <b>execute</b> specific options
       <b>-p</b>, <b>--port</b> <u>INT</u>
       Execution  service  will  listen  to this port.  If unset, the service will listen to the first available
       one.

       <b>--info-file</b> <u>TEXT</u>
       Write the used port, interface, and pid to this file in JSON format.  If the  file  exists,  it  will  be
       overwritten.

       <b>-i</b>, <b>--interface</b> <u>TEXT</u>
       Interface to use.  If unset, the loopback device is used.

       <b>--pid-file</b> <u>TEXT</u>
       Write pid to this file in plain txt.  If the file exists, it will be overwritten.

       <b>--tls-server-cert</b> <u>TEXT</u>
       Path to the TLS server certificate.

       <b>--tls-server-key</b> <u>TEXT</u>
       Path to the TLS server key.

       <b>--log-operations-threshold</b> <u>INT</u>
       Once   the   number   of   operations  stored  exceeds  twice  <u>2^n</u>,  where  <u>n</u>  is  given  by  the  option
       <b>--log-operations-threshold</b>, at most <u>2^n</u> operations will be removed, in a FIFO scheme.  If unset, defaults
       to 14.  Must be in the range [0,63].

   <b>gc</b> specific options
       <b>--no-rotate</b>
       Do not rotate gargabe-collection generations.  Instead, only carry out clean up tasks that do not  affect
       what is stored in the cache.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       The exit status of <b>justbuild</b> is one of the following values:

       • 0: the command completed successfully

       • 1:  the  command  could  not  complete due to some errors (e.g., compilation errors, missing arguments,
         syntax errors, etc.)

       • 2: the command successfully parsed all the needed files  (e.g.,  <u>TARGETS</u>),  successfully  compiled  the
         eventually required objects, but the generation of some artifacts failed (e.g., a test failed).

</pre><h4><b>See</b> <b>also</b></h4><pre>
       <b><a href="../man5/just-repository-config.5.html">just-repository-config</a></b>(5), <b><a href="../man5/just-serve-config.5.html">just-serve-config</a></b>(5), <b><a href="../man1/just-mr.1.html">just-mr</a></b>(1)

                                                                                                    <u><a href="../man1/JUSTBUILD.1.html">JUSTBUILD</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>