<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>r.walk   -  Creates  a  raster  map  showing  the anisotropic cumulative cost of moving between different</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>r.walk</b>   -  Creates  a  raster  map  showing  the anisotropic cumulative cost of moving between different
       geographic locations on an input raster map whose cell category values represent cost.

</pre><h4><b>KEYWORDS</b></h4><pre>
       raster, cost surface, cumulative costs, cost allocation

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>r.walk</b>
       <b>r.walk</b> <b>--help</b>
       <b>r.walk</b> [-<b>knrib</b>] <b>elevation</b>=<u>name</u> <b>friction</b>=<u>name</u> <b>output</b>=<u>name</u>  [<b>solver</b>=<u>name</u>]   [<b>nearest</b>=<u>name</u>]    [<b>outdir</b>=<u>name</u>]
       [<b>start_points</b>=<u>name</u>]                         [<b>stop_points</b>=<u>name</u>]                        [<b>start_raster</b>=<u>name</u>]
       [<b>start_coordinates</b>=<u>east,north</u>[,<u>east,north</u>,...]]            [<b>stop_coordinates</b>=<u>east,north</u>[,<u>east,north</u>,...]]
       [<b>max_cost</b>=<u>value</u>]    [<b>null_cost</b>=<u>value</u>]    [<b>memory</b>=<u>memory</u>  <u>in</u>  <u>MB</u>]    [<b>walk_coeff</b>=<u>a,b,c,d</u>]   [<b>lambda</b>=<u>float</u>]
       [<b>slope_factor</b>=<u>float</u>]   [--<b>overwrite</b>]  [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-k</b>
           Use the ’Knight’s move’; slower, but more accurate

       <b>-n</b>
           Keep null values in output raster map

       <b>-r</b>
           Start with values in raster map

       <b>-i</b>
           Print info about disk space and memory requirements and exit

       <b>-b</b>
           Create bitmask encoded directions

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>elevation</b>=<u>name</u> <b>[required]</b>
           Name of input elevation raster map

       <b>friction</b>=<u>name</u> <b>[required]</b>
           Name of input raster map containing friction costs

       <b>output</b>=<u>name</u> <b>[required]</b>
           Name for output raster map to contain walking costs

       <b>solver</b>=<u>name</u>
           Name of input raster map solving equal costs
           Helper variable to pick a direction if two directions have equal cumulative costs (smaller is better)

       <b>nearest</b>=<u>name</u>
           Name for output raster map with nearest start point

       <b>outdir</b>=<u>name</u>
           Name for output raster map to contain movement directions

       <b>start_points</b>=<u>name</u>
           Name of starting vector points map
           Or data source for direct OGR access

       <b>stop_points</b>=<u>name</u>
           Name of stopping vector points map
           Or data source for direct OGR access

       <b>start_raster</b>=<u>name</u>
           Name of starting raster points map

       <b>start_coordinates</b>=<u>east,north[,east,north</u>,...]
           Coordinates of starting point(s) (E,N)

       <b>stop_coordinates</b>=<u>east,north[,east,north</u>,...]
           Coordinates of stopping point(s) (E,N)

       <b>max_cost</b>=<u>value</u>
           Maximum cumulative cost
           Default: <u>0</u>

       <b>null_cost</b>=<u>value</u>
           Cost assigned to null cells. By default, null cells are excluded

       <b>memory</b>=<u>memory</u> <u>in</u> <u>MB</u>
           Maximum memory to be used (in MB)
           Cache size for raster rows
           Default: <u>300</u>

       <b>walk_coeff</b>=<u>a,b,c,d</u>
           Coefficients for walking energy formula parameters a,b,c,d
           Default: <u>0.72,6.0,1.9998,-1.9998</u>

       <b>lambda</b>=<u>float</u>
           Lambda coefficients for combining walking energy and friction cost
           Default: <u>1.0</u>

       <b>slope_factor</b>=<u>float</u>
           Slope factor determines travel energy cost per height step
           Default: <u>-0.2125</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>r.walk</u> computes anisotropic cumulative cost of moving between different geographic locations on an  input
       elevation  raster  map  whose  cell category values represent elevation combined with an input raster map
       layer whose cell values represent friction cost.

       <u>r.walk</u> outputs 1) a raster map showing the lowest cumulative cost (time) of moving between each cell  and
       the  user-specified starting points and 2) a second raster map showing the movement direction to the next
       cell on the path back to the start point (see Movement Direction). It uses an input elevation raster  map
       whose cell category values represent elevation, combined with a second input raster map whose cell values
       represent friction costs.

       This function is similar to <u>r.cost</u>, but in addition to a friction map, it considers an anisotropic travel
       time due to the different walking speed associated with downhill and uphill movements.

</pre><h4><b>NOTES</b></h4><pre>
       The  formula from Aitken 1977/Langmuir 1984 (based on Naismith’s rule for walking times) has been used to
       estimate the cost parameters of specific slope intervals:
       T = a*delta_S + b*delta_H_uphill + c*delta_H_moderate_downhill + d*delta_H_steep_downhill
       where:

           •   T is time of movement in seconds,

           •   delta S is the horizontal distance covered in meters,

           •   delta H is the altitude difference in meters.

       The a, b, c, d <b>walk_coeff</b> parameters take in account movement speed in the different conditions  and  are
       linked to:

           •   a: time in seconds it takes to walk for 1 meter a flat surface (1/walking speed)

           •   b: additional walking time in seconds, per meter of elevation gain on uphill slopes

           •   c:  additional  walking  time in seconds, per meter of elevation loss on moderate downhill slopes
               (use positive value for decreasing cost)

           •   d: additional walking time in seconds, per meter of elevation loss on steep downhill slopes  (use
               negative value for increasing cost)
       It  has been proved that moving downhill is favourable up to a specific slope value threshold, after that
       it becomes unfavourable. The default slope value threshold (<b>slope_factor</b>) is  -0.2125,  corresponding  to
       tan(-12),  calibrated  on  human  behaviour  (&gt;5  and  &lt;12 degrees: moderate downhill; &gt;12 degrees: steep
       downhill). The default values for a, b, c, d <b>walk_coeff</b> parameters are those proposed by Langmuir  (0.72,
       6.0, 1.9998, -1.9998), based on man walking effort in standard conditions.

       The  <b>friction</b>  cost  parameter represents a time penalty in seconds of additional walking time to cross 1
       meter distance.  Friction cost can be any floating point value  ≥  0.   A  friction  map  is  a  required
       parameter;  if no friction costs are desired, a friction map should be a raster in which all cells have a
       value of 0.

       The <b>lambda</b> parameter is a dimensionless scaling factor of the friction cost:
       total cost = movement time cost + lambda * friction costs * delta_S

       For a more accurate result, the "knight’s move" option can be used (although it is more time  consuming).
       In  the diagram below, the center location (O) represents a grid cell from which cumulative distances are
       calculated. Those neighbours marked with an x are always considered for cumulative cost updates. With the
       "knight’s move" option, the neighbours marked with a K are also considered.
         K   K
       K x x x K
         x O x
       K x x x K
         K   K

       The minimum cumulative costs are computed using Dijkstra’s algorithm, that find an optimum solution  (for
       more details see <u>r.cost</u>, that uses the same algorithm).

</pre><h4><b>Movement</b> <b>Direction</b></h4><pre>
       The  movement  direction  surface  is  created  to record the sequence of movements that created the cost
       accumulation surface. This movement direction surface can be used by <u>r.path</u> to recover a path from an end
       point back to the start point.  The direction of each cell points towards the next cell.  The  directions
       are recorded as degrees CCW from East:
              112.5      67.5         i.e. a cell with the value 135
       157.5  135   90   45   22.5    means the next cell is to the north-west
              180   x   360
       202.5  225  270  315  337.5
              247.5     292.5

       Once <u>r.walk</u> computes the cumulative cost map as a linear combination of friction cost (from friction map)
       and  the  altitude  and  distance  covered  (from  the  digital elevation model), the associated movement
       direction map can be used by <u>r.path</u> to find the minimum cost path.

       <u>r.walk</u>, like most all GRASS raster programs, is also made to be run  on  maps  larger  that  can  fit  in
       available  computer  memory.  As the algorithm works through the dynamic list of cells it can move almost
       randomly around the entire area. <u>r.walk</u> divides the entire area into a number of pieces and  swaps  these
       pieces  in  and  out  of  memory  (to  and  from disk) as needed. This provides a virtual memory approach
       optimally designed for 2-D raster maps. The amount of memory to be used by <u>r.walk</u> can be controlled  with
       the  <b>memory</b>  option,  default is 300 MB. For systems with less memory this value will have to be set to a
       lower value.

</pre><h4><b>EXAMPLES</b></h4><pre>
       We compute a map showing how far a lost person could get from the point where he or  she  was  last  seen
       while taking into account the topography and landcover.
       g.region swwake_30m -p
       # create friction map based on land cover
       r.recode landclass96 out=friction rules=- &lt;&lt; EOF
       1:3:0.1:0.1
       4:5:10.:10.
       6:6:1000.0:1000.0
       7:7:0.3:0.3
       EOF
       r.walk -k elevation=elev_ned_30m friction=friction output=walkcost \
           start_coordinates=635576,216485 lambda=0.5 max=10000
       # compute contours on the cost surface to better understand
       # how far the person can get in certain time (1000 is in seconds)
       r.contour walkcost output=walkcost step=1000
       <u>Figure:</u> <u>Walkshed</u> <u>over</u> <u>a</u> <u>cost</u> <u>surface</u> <u>derived</u> <u>from</u> <u>topography</u> <u>and</u> <u>landcover</u>

</pre><h4><b>REFERENCES</b></h4><pre>
           •   Aitken, R. 1977. Wilderness areas in Scotland. Unpublished Ph.D. thesis.  University of Aberdeen.

           •   Steno  Fontanari,  University  of  Trento,  Italy,  Ingegneria  per  l’Ambiente  e il Territorio,
               2000-2001.  Svilluppo di metodologie GIS per la  determinazione  dell’accessibilità  territoriale
               come supporto alle decisioni nella gestione ambientale.

           •   Langmuir,  E.  1984.  Mountaincraft  and  leadership.  The  Scottish Sports Council/MLTB. Cordee,
               Leicester.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>r.cost,</u> <u>r.path,</u> <u>r.in.ascii,</u> <u>r.mapcalc,</u> <u>r.recode,</u> <u>r.out.ascii</u>

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>Based</b> <b>on</b> <b>r.cost</b> <b>written</b> <b>by</b> <b>:</b>
       Antony Awaida, Intelligent Engineering, Systems Laboratory, M.I.T.
       James Westervelt, U.S.Army Construction Engineering Research Laboratory
       Updated for Grass 5 by Pierre de Mouveaux (<a href="mailto:pmx@audiovu.com">pmx@audiovu.com</a>)

       <b>Initial</b> <b>version</b> <b>of</b> <b>r.walk:</b>
       Steno Fontanari, 2002

       <b>Current</b> <b>version</b> <b>of</b> <b>r.walk:</b>
       Franceschetti Simone, Sorrentino Diego, Mussi Fabiano and Pasolli Mattia
       Correction by: Fontanari Steno, Napolitano Maurizio and  Flor Roberto
       In collaboration with: Franchi Matteo, Vaglia  Beatrice,  Bartucca  Luisa,  Fava  Valentina  and  Tolotti
       Mathias, 2004

       <b>Updated</b> <b>for</b> <b>GRASS</b> <b>6.1:</b>
       Roberto Flor and Markus Neteler

       <b>Updated</b> <b>for</b> <b>GRASS</b> <b>GIS</b> <b>7:</b>
       Markus Metz
       Multiple path directions sponsored by mundialis

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: r.walk source code (history)

       Accessed: Friday Apr 04 01:19:48 2025

       Main index | Raster index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                       <u><a href="../man1grass/r.walk.1grass.html">r.walk</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>