<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>super - execute commands setuid root.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/super">super_3.30.3-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       super - execute commands setuid root.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       To execute a command:
            <b>super</b> [ -r reqpath<u>]</u> <u>command</u> [ <u>args</u> ]
            <b>super</b> [ -r reqpath<u>]</u> <b>-o</b> <u>path</u> [ <u>args</u> ]
            <b>command</b> [ <u>args</u> ]

       To list available commands:
            <b>super</b> [<u>-H</u>|<u>-f</u>] [<u>-S</u>]

       For usage and/or version information:
            <b>super</b> [<u>-h</u>] [<u>-V</u>]

       For debugging and development:
            <b>super</b> <b>-b</b>
            <b>super</b> <b>-c</b> [ <u>superfile</u> ]
            <b>super</b> [<u>-d</u>|<u>-D</u>|<u>-t</u>] [<u>-S</u>] [<u>MasqOptions</u>] [<u>-H</u>|<u>-f</u>|<u>command...</u>]

            MasqOptions:
                     <u>-F</u> <u>file</u>
                     <u>-T</u> <u>hh:mm/dayname</u>
                     <u>-G</u> <u>gid</u>
                     <u>-U</u> <u>uid</u>
                     <u>-M</u> <u>mach</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Super</b>  allows  specified users to execute scripts (or other commands) as if they were root; or it can set
       the uid, gid, and/or supplementary groups on a per-command basis before executing  the  command.   It  is
       intended  to  be a secure alternative to making scripts setuid root.  Super also allows ordinary users to
       supply commands for execution by others; these execute with the uid, gid, and groups of the user offering
       the command.

       <b>Super</b> consults a ``<u>super.tab</u>'' file to see if the user is allowed to execute the requested  <u>command</u>.   If
       permission  is  granted,  <b>super</b>  will exec <u>pgm</u> [ <u>args</u> ], where <u>pgm</u> is the program that is associated with
       this <u>command.</u>  (Root is allowed execution by default, but can still be denied if a  rule  excludes  root.
       Ordinary users are disallowed execution by default.)

       The  most  common sort of entry in a <u>super.tab</u> file pairs a simple <u>command</u> with a <u>pgm</u> path.  But in fact,
       the command in the <u>super.tab</u> file is actually treated as a pattern, and  <u>any</u>  user-entered  command  that
       matches  this  pattern causes the associated <u>pgm</u> to be executed.  If the listed <u>pgm</u> contains an asterisk,
       then the asterisk is replaced with the command entered by the user.  One  use  of  this  is  to  let  any
       program in a certain directory be executed by a user.  For example, if the entry contains the command/pgm
       pairs
            <u>CommandPattern</u>      <u>Program</u>
            <b>scripts/*</b>        <b>→</b>  <b>/usr/local/super/*</b>
               <b>*</b>             <b>→</b>  <b>/usr/local/somedir/*</b>
       then the translations made are
            <u>User's</u> <u>Command</u>      <u>Executed</u> <u>Program</u>
            <b>scripts/xyz</b>      <b>→</b>  <b>/usr/local/super/scripts/xyz</b>
            <b>xyz</b>              <b>→</b>  <b>/usr/local/somedir/xyz</b>

       Some  commands can only be run after the user enters his or her password.  These commands can then be run
       multiple times until some expiration time, at which point the password needs to be re-entered.  The  list
       of password-requiring commands and the password durations are set in the same file that records the valid
       users for each command.

       If <u>command</u> is a symbolic link (or hard link, too) to the <b>super</b> program, then typing
            % <u>command</u> <u>args</u>
       is equivalent to typing
            % <b>super</b> <u>command</u> <u>args</u>
       (The <u>command</u> must not be <b>super</b>, or <b>super</b> will not recognize that it's being invoked via a link.)

       <b>Super</b> without any arguments will display the list of commands that may be executed by the user.

       For security, the following precautions are taken before exec'ing:

       (a)    all descriptors save 0,1,2 are closed;

       (b)    all of the user's environment variables are discarded, save for TERM, LINES, and COLUMNS.  If TERM
              contains  any  characters  other  than  {-/:+._a-zA-Z0-9},  it  is discarded.  If LINES or COLUMNS
              contains any characters other than [0-9], it is discarded.  To these are added  reasonable  values
              for:

              USER and LOGNAME: both are set to the username associated with the real uid of the program running
                     under <b>super</b>;

              HOME: set to the login directory of the user running <b>super</b>;

              ORIG_USER,  ORIG_LOGNAME,  ORIG_HOME: the values of USER, LOGNAME, and HOME that refer to the user
                     who invoked <b>super</b>.  (These values are computed by <b>super</b>, and are not the values set by  the
                     caller,  so  they  are  a  reliable description of the caller.  These are normally the same
                     values as USER, LOGNAME, and HOME, but they will differ if the super command changes uid or
                     gid before executing the program.);

              IFS: set to blank, tab, newline;

              PATH: set to <u><a href="file:/bin">/bin</a>:<a href="file:/usr/bin">/usr/bin</a></u>.

              SUPERCMD: set to <u>command</u>.

              additional environment variables as specified in the <u>super.tab</u> file (see below).

       (c)    all signal handling is reset to the default.

       If <u>Super</u> is executed without arguments, it will print the commands that the user may execute, one command
       per line.  <b>Super</b> <b>-H</b> prints a long-winded description of each command that the user may execute.
       The <u>CmdPat</u> is the command pattern, and <u>FullPath</u> is the full path that will be  executed.   The  super.tab
       file  can  specify  initial  arguments that that precede any user-supplied arguments; these arguments, if
       any, are printed after the <u>FullPath</u> column.

</pre><h4><b>User-Defined</b> <b>Super.tab</b> <b>Files</b></h4><pre>
       Ordinary users can supply their own super files.  This  lets  users  give  well-controlled  setuid/setgid
       access  to  their programs: the user who offers the program gets the assurance of safe IFS settings, safe
       environment variable settings, etc; and the user who executes the program  knows  that  it  will  execute
       under the uid and gid of the offering user.  If a <u>command</u> is entered in the form
              <b>super</b> <u>loginname</u><b>:</b><u>cmd</u>
       <u>super</u>  looks  for <u>cmd</u> in the file <b>.supertab</b>, in the home directory of account <u>loginname</u>.  The <u>cmd</u> will be
       executed using the uid, gid, and supplementary groups (if any) of user <u>loginname</u>.

       The usual super options (such as <b>-H</b>) can be applied to  a  user's  .supertab  file.   For  example,  help
       information about one command can be had by using:
            <b>super</b> <b>-H</b> <u>loginname</u><b>:</b><u>cmd</u>
       Likewise, help information about all of <u>loginname</u>'s commands can be obtained with:
            <b>super</b> <b>-H</b> <u>loginname</u><b>:</b>

       Links  to  per-user  commands  can  be  created  and used in a manner similar to making symlinks to <u>super</u>
       itself.  If <u>command</u> is a symbolic link to a user's .supertab file, and that .supertab file is

              (a)  executable, and

              (b)  begins with
                     <b>#!</b> <b>/path/to/super</b> <b>-o</b>

       then the following pair are completely equivalent:
              <u>%</u> <b>super</b> <u>loginname</u><b>:</b><u>command</u>
              <u>%</u> <u>command</u>
       If the <b>#!</b>-line would be longer than the typical Unix limit of 32 characters, you can  instead  start  the
       .supertab file with:
              #! <a href="file:/bin/sh">/bin/sh</a>
              # Keep this backslash -&gt; \
                   exec /long/path/to/the/super/executable -o $0 ${1+"$@"}
       (The  above  takes  advantage  of  the fact that super allows comments to be backslash-continued, but the
       shell doesn't.)

       Per-user .supertab linking works as follows: if <u>/path/to/xyz</u> is a symlink to some user's .supertab  file,
       and  the .supertab file begins with <u>#!</u> <u>/path/to/super</u> <u>-o</u>, then the shell will invoke <u>super</u> with arguments
       something like
              <b>super</b> <b>-o</b> <b>/path/to/xyz</b> <b>[args]</b>
       Super checks that <u>/path/to/xyz</u> is a link to a real .supertab file, and then always turns the last part of
       the path (here <u>xyz</u>) into the command to execute.

                                                <b>**</b> <b>Security</b> <b>Warning</b> <b>**</b>
       Note that if you use symlinks to a per-user .supertab file, then you must trust that the  .supertab  file
       will  actually  execute  a super command, instead of doing something nasty.  That is because <u>super</u> itself
       isn't invoked until the shell has opened the .supertab file and done whatever the .supertab file tells it
       to do.  By contrast, the direct command <b>super</b> <u>loginname</u><b>:</b><u>cmd</u> doesn't involve any shell processing  of  the
       .supertab file.

</pre><h4><b>REGULAR</b> <b>OPTIONS</b></h4><pre>
       <b>-V</b>     Print the super version number.

       <b>-S</b>     When  <b>super</b>  prompts  for  a  password,  this  forces  it  to prompt on stdin, even if the default
              (<b>/dev/tty</b>) is readable and writable.  <u>Note:</u> This only applies to  password-type  authentication  —
              that  is,  the  older  type  of  authentication wherein <b>super</b> itself prompts for the password; PAM
              authentication is handled by your system's PAM modules.

       <b>-f</b>     This requests a list of available commands in a terse format useful  for  processing  by  scripts.
              (<b>-f</b> stands for facts, as in ``just the facts, m'am'').

       <b>-r</b><u>reqpath</u>
              Tells super to generate an error if the program associated with this <u>command</u> is not <u>reqpath.</u>  This
              helps  you write scripts that ensure that super only executes what they expect it to execute.  See
              step 4 of the section, ``Creating Super Scripts'', for an example of its use.

       <b>-H</b>     Causes <b>super</b> to print a verbose listing of the commands available to the user.  It prints both the
              <u>command</u> and its translation to a program <u>pgm</u>.  If the displayed <u>pgm</u> contains an asterisk, then the
              actual program executed is formed by replacing the asterisk with the <u>command</u> entered by the  user.
              The following examples show the kinds of lines that may be displayed with the <b>-H</b> option:

              <u>Example</u> <u>1.</u>
                   <b>super</b> <b>skill</b> → <u>/usr/local/bin/skill</u>

              Typing <b>super</b> <b>skill</b> will execute <b>/usr/local/bin/skill</b>.

              <u>Example</u> <u>2.</u>
                   <b>super</b> <b>{lp*}</b> → <u><a href="file:/usr/bin/">/usr/bin/</a>*</u>

              This  example  contains asterisks on both the left and right sides.  The left side shows the valid
              pattern you must match to execute the command shown on the right-hand side.  Usually,  the  right-
              hand  side  has  no  asterisk,  just a full path to a command to execute.  If there <u>is</u> an asterisk
              present, it is replaced by the command you entered, thereby forming the actual  executed  command.
              Thus, if you type <b>super</b> <b>lp</b><u>xxx</u> (where <u>xxx</u> is any string), <b>super</b> will execute <b>/usr/bin/lp</b><u>xxx.</u>

              <u>Example</u> <u>3.</u>
                   <b>super</b> <b>{co*}</b> → <u>/usr/bin/compress</u>

              The  asterisk on the left-hand side means you can enter <b>super</b> <b>co</b><u>xxx</u> (where <u>xxx</u> is any string), but
              since  the  right-hand  side  doesn't   contain   an   asterisk,   <b>co</b><u>xxx</u>   will   always   execute
              <b>/usr/bin/compress</b>.

       <b>-t</b>     This  enables  ``test''  mode.   It  does  all normal checks except for those requiring user input
              (passwords and variables that the user must enter), but doesn't execute any command.  Instead,  it
              exits with status code 0 if the command is ok to execute, else 1.  All normal error message output
              is  generated in the usual way, but no special debug messages are generated.  Thus, it is a useful
              means for a script to check if a command is likely to work, and hence reasonable  to  exec  super.
              Let's say that a script /usr/local/bin/foo wants to invoke itself using <u>super</u> <u>foo</u> (See the section
              ``Creating  Super  Scripts'' for how to avoid infinite loops when doing this!)  the script can use
              the <b>-r</b> option to ensure that <u>super</u> <u>foo</u> refers to the correct file, and it can  use  test  mode  to
              ensure that <u>super</u> <u>foo</u> is a valid command:
                   prog=`basename $0`
                   /usr/local/bin/super -t -r $0 $prog
                   case $? in
                   0 ) exec /usr/local/bin/super -t -r $0 $prog ;;
                   * ) echo "Super $prog doesn't work!"
                       ... So take appropriate action ...
                       ;;
                   esac

</pre><h4><b>DEBUG</b> <b>AND</b> <b>DEVELOPMENT</b> <b>OPTIONS</b></h4><pre>
       These  options  are  useful when creating and debugging <u>super.tab</u> files.  They have little or no value to
       the everyday user.  With the exception of the <b>-b</b> option, they can be combined with the  regular  options,
       above.

       <b>-b</b>     Print  the  names and values of built-in variables, then exit.  Useful for administrators to learn
              the values against which builtin variables can be tested.

       <b>-c</b>[<u>superfile</u>]
              Tells <u>super</u> to check the syntax of the entries in the <u>superfile</u>, but not to execute  any  command.
              If  no  <u>superfile</u>  is  given,  the regular <u>super.tab</u> is checked.  The exit code is 0 if the file's
              syntax is ok; otherwise the exit code is 1 (and an error message is printed).  After  modifying  a
              super file, you should use this option to check its integrity.

              Note  that  <u>super</u> <u>-c</u> isn't a complete check that you've correctly set up an entry, because you can
              create syntactically valid entries that don't do exactly what you  want.   Therefore,  you  should
              also  use  <u>super</u>  <u>-d</u>  <u>cmd</u>  to  make sure that the command you've entered will be executed with the
              correct arguments, uid, gid, umask, and so on.

       <b>-d</b>     This enables debug mode, in which case (a) debugging information is printed while checking a  user
              for  validity, and (b) the command isn't actually executed.  Useful to check if a new entry in the
              <u>super.tab</u> file (see below) has been handled properly.

       <b>-D</b>     Same as <b>-d</b>, plus prints more information about variables defined in the <u>super.tab</u> file.

       <b>-F</b><u>superfile</u>
              This option is only used for debugging, and lets you test a superfile before  installing  it.   No
              command  will actually be executed.  It also turns on a non-verbose debugging, showing the matched
              command names and reasons for accepting or rejecting the command.

       <b>-G</b><u>gid</u>  This option is also used for debugging, and tells <u>super</u> to act  as  if  the  caller's  groupid  or
              groupname was <u>gid</u>.  It carries the same restrictions and debug info as the -F option.

       <b>-U</b><u>uid</u>  This  option is also used for debugging, and tells <u>super</u> to act as if the caller's uid or username
              was <u>uid</u>.  It carries the same restrictions and debug info as the -F option.

       <b>-M</b><u>mach</u> This option is also used for debugging, and tells <u>super</u> to act as if the caller's  host  (machine)
              was <u>mach</u>.  It carries the same restrictions and debug info as the -F option.

       <b>-T</b><u>hh</u>:<u>mm</u>/<u>dayname</u>
              This  option  is  also  used  for  debugging,  and  tells <u>super</u> to act as if the execution time is
              <u>hh</u>:<u>mm</u>/<u>dayname</u>.  This lets you check if a time specification in  the  <u>super.tab</u>  file  is  properly
              restricting execution.  It carries the same restrictions and debug info as the -F option.

</pre><h4><b>FILES</b></h4><pre>
       <u>/etc/super.tab</u>
              contains  the  list  of  commands  that  <b>super</b> may execute, along with the names of the user/group
              combinations who may execute each command.  The valid-user line can  restrict  use  to  particular
              users or groups on different hosts, so a single super.tab file can be used across a network.

       <u>/run/superstamps/</u>username
              is used as a timestamp for the last time that the user entered his or her password.

</pre><h4><b>CREATING</b> <b>SUPER</b> <b>SCRIPTS</b></h4><pre>
       You  must  be  exceedingly  careful  when  writing  scripts  for <b>super</b>.  A surprising variety of ordinary
       commands can, when run setuid-root, be exploited for nasty purposes.  Always  make  your  scripts  do  as
       little as possible, and give the user as few options as possible.

       Think  twice  about  side-effects  and  alternative  uses of these scripts.  For instance, make sure your
       script doesn't quietly invoke the user's <u>.cshrc</u> or similar file.  Or, you might write a script  to  allow
       users to mount cd-rom's by executing <b><a href="../man8/mount.8.html">mount</a>(8)</b>.  But if you don't write it carefully, a user could mount a
       floppy disk containing, say, a setuid-root shell.

       Security issues aside, here are some hints on creating super scripts:

       1.     Scripts must begin with <b>#!</b> <u>interpreter-path</u>.

       2.     Some  variants  of csh will not run setuid scripts unless the -b flag (force a "break" from option
              processing) is set:
                   #!/bin/csh -fb
              Similarly, if your <u>super.tab</u> file starts a shell such as csh or tcsh, you may want to include  the
              -b option in the <u>super.tab</u> file, so that you don't have to remember to type it on the command line
              every time; use a line like the following in the <u>super.tab</u> file:
                   SHELL  "/usr/bin/csh -fb"  some_priv_user
              N.B.  This is by way of example only; it's not a very good idea to really let somebody become root
              without any password check.

       3.     Better  still,  avoid  csh  scripts  entirely -- they are harder to write safely than Bourne-shell
              scripts.

       4.     It's nice to make the <b>super</b> call transparent to users, so that they can type
                   % <b>cdmount</b> <u>args</u>
              instead of
                   % <b>super</b> <b>cdmount</b> <u>args</u>
              You can make a script <b>super</b> itself by beginning the script in the following way:
                   #!<a href="file:/bin/sh">/bin/sh</a>
                   prog=`basename $0`
                   test "X$SUPERCMD" = "X$prog" ||
                                       exec /usr/local/bin/super -r $0 $prog ${1+"$@"}
              Here, the path that is exec'd should be replaced with the path at your site that leads  to  <u>super.</u>
              The  option  <u>-r</u>$0  is  a sanity-check option: it tells super that it's an error if ``super $prog''
              doesn't execute ``$0'', ie this self-same program.  (Also, see the <b>-t</b> option for how a script  can
              check that <u>super</u> <u>$prog</u> will work before doing an <u>exec</u> <u>super</u>.)

       5.     Some  programs  need  certain  directories  in  the  path.   Your  super  scripts  may have to add
              directories like <u><a href="file:/etc">/etc</a></u> or <u>/usr/etc</u> to make commands work.  For instance, SunOS 4.1  needs  <u>/usr/etc</u>
              in the path before it can mount filesystems of type ``hsfs''.

       6.     By default, <b>super</b> only changes the effective uid.  Some programs (e.g. <b>exportfs</b> under SunOS 4.1.x)
              require  the  real  uid  to  be root.  In that case, you should put an option like ``<u>uid=root</u>'' or
              ``<u>u+g=root</u>'' into the <u>super.tab</u> file.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man5/super.tab.5.html">super.tab</a></b>(5).

</pre><h4><b>AUTHOR</b></h4><pre>
       Will Deich
       <a href="mailto:will@ucolick.org">will@ucolick.org</a>

</pre><h4><b>NOTES</b></h4><pre>
       If the <u>super.tab</u> file isn't owned by root, or if it is group- or world-writable, <b>super</b> won't run  setuid-
       root.   (If  the user's real uid is root, <b>super</b> won't run at all; otherwise, the effective uid reverts to
       real uid.)

       There is a race condition when using password-requiring commands, but it doesn't affect  security:  if  a
       user  is running two copies of <b>super</b> simultaneously, and both processes try to update the user's password
       timestamp file at the same time, then it is possible for one of the <b>super</b> commands to fail.   Workaround:
       a single user shouldn't execute two password-requiring <b>super</b> programs simultaneously.

                                                      local                                             <u><a href="../man1/SUPER.1.html">SUPER</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>