<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>llvm-symbolizer - convert addresses into source code locations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/llvm-19">llvm-19_19.1.7-3ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       llvm-symbolizer - convert addresses into source code locations

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>llvm-symbolizer</b> [<u>options</u>] [<u>addresses...</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>llvm-symbolizer</b>  reads  input  names  and addresses from the command-line and prints corresponding source
       code locations to  standard  output.  It  can  also  symbolize  logs  containing  <u>Symbolizer</u>  <u>Markup</u>  via
       <u>--filter-markup</u>. Addresses may be specified as numbers or symbol names.

       If  no  address is specified on the command-line, it reads the addresses from standard input. If no input
       name is specified on the command-line, but addresses are, the first address value is treated as an  input
       name. If an input value is not recognized, it reports that source information is not found.

       Input  names  can  be  specified  together  with  the addresses either on standard input or as positional
       arguments on the command-line. By default, input names are interpreted as  object  file  paths.  However,
       prefixing a name with <b>BUILDID:</b> states that it is a hex build ID rather than a path. This will look up the
       corresponding  debug binary. For consistency, prefixing a name with <b>FILE:</b> explicitly states that it is an
       object file path (the default).

       A positional argument or standard input value can be preceded by "DATA" or "CODE" to  indicate  that  the
       address  should be symbolized as data or executable code respectively. If neither is specified, "CODE" is
       assumed. DATA is symbolized as address and symbol size rather than line number.

       <b>llvm-symbolizer</b> parses options from the environment variable <b>LLVM_SYMBOLIZER_OPTS</b> after  parsing  options
       from  the  command  line.   <b>LLVM_SYMBOLIZER_OPTS</b>  is  primarily useful for supplementing the command-line
       options when <b>llvm-symbolizer</b> is invoked by another program or runtime.

</pre><h4><b>EXAMPLES</b></h4><pre>
       All of the following examples use the following two source files as input. They use a mixture of  C-style
       and C++-style linkage to illustrate how these names are printed differently (see <u>--demangle</u>).

          // test.h
          extern "C" inline int foz() {
            return 1234;
          }

          // test.cpp
          #include "test.h"
          int bar=42;

          int foo() {
            return bar;
          }

          int baz() {
            volatile int k = 42;
            return foz() + k;
          }

          int main() {
            return foo() + baz();
          }

       These files are built as follows:

          $ clang -g test.cpp -o test.elf
          $ clang -g -O2 test.cpp -o inlined.elf

       Example 1 - addresses and object on command-line:

          $ llvm-symbolizer --obj=test.elf 0x4004d0 0x400490
          foz
          /tmp/test.h:1:0

          baz()
          /tmp/test.cpp:11:0

       Example 2 - addresses on standard input:

          $ cat addr.txt
          0x4004a0
          0x400490
          0x4004d0
          $ llvm-symbolizer --obj=test.elf &lt; addr.txt
          main
          /tmp/test.cpp:15:0

          baz()
          /tmp/test.cpp:11:0

          foz
          /tmp/./test.h:1:0

       Example 3 - object specified with address:

          $ llvm-symbolizer "test.elf 0x400490" "FILE:inlined.elf 0x400480"
          baz()
          /tmp/test.cpp:11:0

          foo()
          /tmp/test.cpp:8:10

          $ cat addr2.txt
          FILE:test.elf 0x4004a0
          inlined.elf 0x400480

          $ llvm-symbolizer &lt; addr2.txt
          main
          /tmp/test.cpp:15:0

          foo()
          /tmp/test.cpp:8:10

       Example 4 - BUILDID and FILE prefixes:

          $ llvm-symbolizer "FILE:test.elf 0x400490" "DATA BUILDID:123456789abcdef 0x601028"
          baz()
          /tmp/test.cpp:11:0

          bar
          6295592 4

          $ cat addr3.txt
          FILE:test.elf 0x400490
          DATA BUILDID:123456789abcdef 0x601028

          $ llvm-symbolizer &lt; addr3.txt
          baz()
          /tmp/test.cpp:11:0

          bar
          6295592 4

       Example 5 - CODE and DATA prefixes:

          $ llvm-symbolizer --obj=test.elf "CODE 0x400490" "DATA 0x601028"
          baz()
          /tmp/test.cpp:11:0

          bar
          6295592 4

          $ cat addr4.txt
          CODE test.elf 0x4004a0
          DATA inlined.elf 0x601028

          $ llvm-symbolizer &lt; addr4.txt
          main
          /tmp/test.cpp:15:0

          bar
          6295592 4

       Example 6 - path-style options:

       This example uses the same source file as above, but the source file's full path is /tmp/foo/test.cpp and
       is  compiled  as follows. The first case shows the default absolute path, the second --basenames, and the
       third shows --relativenames.

          $ pwd
          <a href="file:/tmp">/tmp</a>
          $ clang -g foo/test.cpp -o test.elf
          $ llvm-symbolizer --obj=test.elf 0x4004a0
          main
          /tmp/foo/test.cpp:15:0
          $ llvm-symbolizer --obj=test.elf 0x4004a0 --basenames
          main
          test.cpp:15:0
          $ llvm-symbolizer --obj=test.elf 0x4004a0 --relativenames
          main
          foo/test.cpp:15:0

       Example 7 - Addresses as symbol names:

          $ llvm-symbolizer --obj=test.elf main
          main
          /tmp/test.cpp:14:0
          $ llvm-symbolizer --obj=test.elf "CODE foz"
          foz
          /tmp/test.h:1:0

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>--adjust-vma</b> <b>&lt;offset&gt;</b>
              Add the specified offset to object file addresses when performing lookups.  This can  be  used  to
              perform lookups as if the object were relocated by the offset.

       <b>--basenames,</b> <b>-s</b>
              Print just the file's name without any directories, instead of the absolute path.

       <b>--build-id</b>
              Look up the object using the given build ID, specified as a hexadecimal string. Mutually exclusive
              with <u>--obj</u>.

       <b>--color</b> <b>[=&lt;always|auto|never&gt;]</b>
              Specify  whether  to  use  color  in <u>--filter-markup</u> mode. Defaults to <b>auto</b>, which detects whether
              standard output supports color. Specifying <b>--color</b> alone is equivalent to <b>--color=always</b>.

       <b>--debug-file-directory</b> <b>&lt;path&gt;</b>
              Provide a path to a directory with a <u>.build-id</u> subdirectory to search for  debug  information  for
              stripped binaries. Multiple instances of this argument are searched in the order given.

       <b>--debuginfod,</b> <b>--no-debuginfod</b>
              Whether  or not to try debuginfod lookups for debug binaries. Unless specified, debuginfod is only
              enabled if libcurl was compiled in (<b>LLVM_ENABLE_CURL</b>) and at least one server URL was provided  by
              the environment variable <b>DEBUGINFOD_URLS</b>.

       <b>--demangle,</b> <b>-C</b>
              Print  demangled  function  names, if the names are mangled (e.g. the mangled name <b>_</b><u>Z3bazv</u> becomes
              <u>baz()</u>, whilst the non-mangled name <u>foz</u> is printed as is). Defaults to true.

       <b>--dwp</b> <b>&lt;path&gt;</b>
              Use the specified DWP file at <b>&lt;path&gt;</b> for any CUs that have split DWARF debug data.

       <b>--fallback-debug-path</b> <b>&lt;path&gt;</b>
              When a separate file contains debug data, and is referenced by a GNU debug link section,  use  the
              specified  path  as  a  basis  for  locating  the debug data if it cannot be found relative to the
              object.

       <b>--filter-markup</b>
              Reads from standard input, converts contained <u>Symbolizer</u>  <u>Markup</u>  into  human-readable  form,  and
              prints the results to standard output. The following markup elements are not yet supported:

              • <b>{{{hexdict}}}</b>

              • <b>{{{dumpfile}}}</b>

              The <b>{{{bt}}}</b> backtrace element reports frames using the following syntax:

              <b>#&lt;number&gt;[.&lt;inline&gt;]</b> <b>&lt;address&gt;</b> <b>&lt;function&gt;</b> <b>&lt;file&gt;:&lt;line&gt;:&lt;col&gt;</b> <b>(&lt;module&gt;+&lt;relative</b> <b>address&gt;)</b>

              <b>&lt;inline&gt;</b>  provides  frame numbers for calls inlined into the caller corresponding to <b>&lt;number&gt;</b>. The
              inlined call numbers start at 1 and increase from callee to caller.

              <b>&lt;address&gt;</b> is an address inside the call instruction to the function.  The address may not  be  the
              start  of the instruction.  <b>&lt;relative</b> <b>address&gt;</b> is the corresponding virtual offset in the <b>&lt;module&gt;</b>
              loaded at that address.

       <b>--functions</b> <b>[=&lt;none|short|linkage&gt;],</b> <b>-f</b>
              Specify the way function names are printed (omit function name,  print  short  function  name,  or
              print full linkage name, respectively). Defaults to <b>linkage</b>.

       <b>--help,</b> <b>-h</b>
              Show help and usage for this command.

       <b>--inlining,</b> <b>--inlines,</b> <b>-i</b>
              If  a  source  code location is in an inlined function, prints all the inlined frames. This is the
              default.

       <b>--no-inlines</b>
              Don't print inlined frames.

       <b>--no-demangle</b>
              Don't print demangled function names.

       <b>--obj</b> <b>&lt;path&gt;,</b> <b>--exe,</b> <b>-e</b>
              Path to object file to be symbolized. If <b>-</b>  is  specified,  read  the  object  directly  from  the
              standard input stream. Mutually exclusive with <u>--build-id</u>.

       <b>--output-style</b> <b>&lt;LLVM|GNU|JSON&gt;</b>
              Specify  the  preferred  output  style. Defaults to <b>LLVM</b>. When the output style is set to <b>GNU</b>, the
              tool follows the style of GNU's <b>addr2line</b>.  The differences from the <b>LLVM</b> style are:

              • Does not print the column of a source code location.

              • Does not add an empty line after the report for an address.

              • Does not replace the name of an inlined function with  the  name  of  the  topmost  caller  when
                inlined frames are not shown.

              • Prints  an  address's  debug-data  discriminator  when  it  is  non-zero.  One  way  to  produce
                discriminators is to compile with clang's -fdebug-info-for-profiling.

              <b>JSON</b> <b>style</b> <b>provides</b> <b>a</b> <b>machine</b> <b>readable</b> <b>output</b> <b>in</b> <b>JSON.</b> <b>If</b> <b>addresses</b> <b>are</b>
                     supplied via stdin, the output JSON will be a series of individual objects.  Otherwise, all
                     results will be contained in a single array.

                 $ llvm-symbolizer --obj=inlined.elf 0x4004be 0x400486 -p
                 baz() at /tmp/test.cpp:11:18
                  (inlined by) main at /tmp/test.cpp:15:0

                 foo() at /tmp/test.cpp:6:3

                 $ llvm-symbolizer --output-style=LLVM --obj=inlined.elf 0x4004be 0x400486 -p --no-inlines
                 main at /tmp/test.cpp:11:18

                 foo() at /tmp/test.cpp:6:3

                 $ llvm-symbolizer --output-style=GNU --obj=inlined.elf 0x4004be 0x400486 -p --no-inlines
                 baz() at /tmp/test.cpp:11
                 foo() at /tmp/test.cpp:6

                 $ clang -g -fdebug-info-for-profiling test.cpp -o profiling.elf
                 $ llvm-symbolizer --output-style=GNU --obj=profiling.elf 0x401167 -p --no-inlines
                 main at /tmp/test.cpp:15 (discriminator 2)

                 $ llvm-symbolizer --output-style=JSON --obj=inlined.elf 0x4004be 0x400486 -p
                 [
                   {
                     "Address": "0x4004be",
                     "ModuleName": "inlined.elf",
                     "Symbol": [
                       {
                         "Column": 18,
                         "Discriminator": 0,
                         "FileName": "/tmp/test.cpp",
                         "FunctionName": "baz()",
                         "Line": 11,
                         "StartAddress": "0x4004be",
                         "StartFileName": "/tmp/test.cpp",
                         "StartLine": 9
                       },
                       {
                         "Column": 0,
                         "Discriminator": 0,
                         "FileName": "/tmp/test.cpp",
                         "FunctionName": "main",
                         "Line": 15,
                         "StartAddress": "0x4004be",
                         "StartFileName": "/tmp/test.cpp",
                         "StartLine": 14
                       }
                     ]
                   },
                   {
                     "Address": "0x400486",
                     "ModuleName": "inlined.elf",
                     "Symbol": [
                       {
                         "Column": 3,
                         "Discriminator": 0,
                         "FileName": "/tmp/test.cpp",
                         "FunctionName": "foo()",
                         "Line": 6,
                         "StartAddress": "0x400486",
                         "StartFileName": "/tmp/test.cpp",
                         "StartLine": 5
                       }
                     ]
                   }
                 ]

       <b>--pretty-print,</b> <b>-p</b>
              Print human readable output. If <u>--inlining</u> is  specified,  the  enclosing  scope  is  prefixed  by
              (inlined  by).   For  JSON  output,  the  option will cause JSON to be indented and split over new
              lines. Otherwise, the JSON output will be printed in a compact form.

                 $ llvm-symbolizer --obj=inlined.elf 0x4004be --inlining --pretty-print
                 baz() at /tmp/test.cpp:11:18
                  (inlined by) main at /tmp/test.cpp:15:0

       <b>--print-address,</b> <b>--addresses,</b> <b>-a</b>
              Print address before the source code location. Defaults to false.

                 $ llvm-symbolizer --obj=inlined.elf --print-address 0x4004be
                 0x4004be
                 baz()
                 /tmp/test.cpp:11:18
                 main
                 /tmp/test.cpp:15:0

                 $ llvm-symbolizer --obj=inlined.elf 0x4004be --pretty-print --print-address
                 0x4004be: baz() at /tmp/test.cpp:11:18
                  (inlined by) main at /tmp/test.cpp:15:0

       <b>--print-source-context-lines</b> <b>&lt;N&gt;</b>
              Print <b>N</b> lines of source context for each symbolized address.

                 $ llvm-symbolizer --obj=test.elf 0x400490 --print-source-context-lines=3
                 baz()
                 /tmp/test.cpp:11:0
                 10  :   volatile int k = 42;
                 11 &gt;:   return foz() + k;
                 12  : }

       <b>--relativenames</b>
              Print the file's path relative to the compilation directory, instead of the absolute path. If  the
              command-line to the compiler included the full path, this will be the same as the default.

       <b>--verbose</b>
              Print verbose address, line and column information.

                 $ llvm-symbolizer --obj=inlined.elf --verbose 0x4004be
                 baz()
                   Filename: /tmp/test.cpp
                   Function start filename: /tmp/test.cpp
                   Function start line: 9
                   Function start address: 0x4004b6
                   Line: 11
                   Column: 18
                 main
                   Filename: /tmp/test.cpp
                   Function start filename: /tmp/test.cpp
                   Function start line: 14
                   Function start address: 0x4004b0
                   Line: 15
                   Column: 18

       <b>--version,</b> <b>-v</b>
              Print version information for the tool.

       <b>@&lt;FILE&gt;</b>
              Read command-line options from response file <u>&lt;FILE&gt;</u>.

</pre><h4><b>WINDOWS/PDB</b> <b>SPECIFIC</b> <b>OPTIONS</b></h4><pre>
       <b>--dia</b>  Use  the Windows DIA SDK for symbolization. If the DIA SDK is not found, llvm-symbolizer will fall
              back to the native implementation.

</pre><h4><b>MACH-O</b> <b>SPECIFIC</b> <b>OPTIONS</b></h4><pre>
       <b>--default-arch</b> <b>&lt;arch&gt;</b>
              If a binary contains object files for multiple  architectures  (e.g.  it  is  a  Mach-O  universal
              binary),  symbolize  the  object  file  for  a  given  architecture.   You  can  also  specify the
              architecture  by  writing  <b>binary_name:arch_name</b>  in  the  input  (see  example  below).  If   the
              architecture is not specified in either way, the address will not be symbolized. Defaults to empty
              string.

                 $ cat addr.txt
                 /tmp/mach_universal_binary:i386 0x1f84
                 /tmp/mach_universal_binary:x86_64 0x100000f24

                 $ llvm-symbolizer &lt; addr.txt
                 _main
                 /tmp/source_i386.cc:8

                 _main
                 /tmp/source_x86_64.cc:8

       <b>--dsym-hint</b> <b>&lt;path/to/file.dSYM&gt;</b>
              If  the  debug info for a binary isn't present in the default location, look for the debug info at
              the .dSYM path provided via this option. This flag can be used multiple times.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       <b>llvm-symbolizer</b> returns 0. Other exit codes imply an internal program error.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/llvm-addr2line.1.html">llvm-addr2line</a>(1)</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Maintained by the LLVM Team (https://llvm.org/).

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, LLVM Project

15                                                 2025-03-19                                 <u><a href="../man1/LLVM-SYMBOLIZER.1.html">LLVM-SYMBOLIZER</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>