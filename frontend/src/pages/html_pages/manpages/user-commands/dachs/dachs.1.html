<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dachs - data publishing infrastructure for the Virtual Observatory (VO)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/noble/+package/python3-gavo">python3-gavo_2.9.1+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dachs - data publishing infrastructure for the Virtual Observatory (VO)

</pre><h4><b>SYNOPSIS</b></h4><pre>
          dachs [global-options] &lt;subcommand&gt; [options] function-argument ...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       dachs   provides   support for data ingestion and publishing, for metadata handling, and for a variety of
       VO protocols and standards, e.g. the Table Access Protocol (TAP) or the Simple Cone Search (SCS).

       There are numerous sub-commands covering the various tasks (importing, controlling  the  server,  running
       tests, etc).

       Subcommand names can be abbreviated to the shortest unique prefix.

       A  centeral  concept  of  DaCHS is the Resource Descriptor (RD), and XML description of a data collection
       including metadata, ingestion rules,  service  definitions,  and  regression  tests.   They  are  usually
       referenced  through  their  RD ids, which are the relative paths from DaCHS' inputs directory to the file
       containing the RD, with the conventional extension <b>.rd</b> stripped.  For instance, in a default install, the
       file <b>/var/gavo/inputs/myrsc/q.rd</b> would have <b>myrsc/q</b> as RD id.

       Most commands dealing with RD ids will also pick up RDs if referenced by path; in the example  above,  if
       you are in <b>/var/gavo/inputs/myrsc</b>, you could also reference the RD as either <b>q</b> or <b>q.rd</b>.

       Several  commands  take  references  to RD elements (table definitions, exec items, direct grammar, etc).
       These consist of an RD id as just discussed, a hash mark, and the XML id of the target  element.   Tables
       have an id automatically, for other elements you may have to add an artificial id.

</pre><h4><b>GLOBAL</b> <b>OPTIONS</b></h4><pre>
       Global options are given before the subcommand name.

       <b>--debug</b>
              produce debug info as appropriate

       <b>--enable-pdb</b>
              run pdb on all errors

       <b>-h</b>, <b>--help</b>
              show this help message and exit

       <b>--hints</b>
              if there are hints on an error, display them

       <b>--profile-to=</b><u>PROFILEPATH</u>
              enable profiling and write a profile to PROFILEPATH

       <b>--suppress-log</b>
              suppress logging of exceptions to the dachs-specific log files

       <b>--version</b>
              shows  the  versions  of  the software, of the database schema expected by the software and of the
              database schema actually on disk (if the latter two disagree, run dachs upgrade).

</pre><h4><b>THE</b> <b>ADMIN</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs admin  [-h] subsubfunction [subfunction-arguments ...]

       This is a somewhat random collection of commands related to administering a data center.  In  particular,
       this is where you create and edit accounts.

       subsubcommands can be abbreviated as long as the abbreviation is unique.  For instance <b>dachs</b> <b>adm</b> <b>xsd</b> will
       do an XSD validation.

       For more information on the subsubfunctions, pass a <b>-h</b> flag.

   <b>Subsubcommands</b>
       • <b>addtogroup</b> <b>user</b> <b>group</b> -- adds a user to a group

       • <b>adduser</b> <b>user</b> <b>password</b> <b>[remarks]</b> -- add  a  user/password pair to the DaCHS user table.  Note that as of
         DaCHS  1.0  the  password  is  stored in clear text and also transmitted in clear text since DaCHS only
         supports HTTP basic authentication.  Do not use valuable passwords here

       • <b>changeuser</b> <b>user</b> <b>password</b> <b>[remarks]</b> -- change remarks and/or password for a DC user.   See  adduser  for
         details.

       • <b>cleantap</b> -- remove expired Universal Worker Service (UWS) jobs

       • <b>delfromgroup</b> <b>user</b> <b>group</b> -- remove a user from a group

       • <b>deluser</b> <b>user</b> -- remove a DaCHS user from the user table.

       • <b>dumpDF</b>  <b>path</b>  --  Dumps  the  source of a file included with the DaCHS distribution.  The argument is a
         package resource path (like /inputs/__system__/scs.rd); for system RDs, the special //rd-id  syntax  is
         supported.

       • <b>execute</b>  <b>exec-id</b>  --  Execute  the  contents  of  an  RD execute element. You must give that element an
         explicit id in order to make this work; then exec-id is rd-id#exec-id

       • <b>hipsfill</b> <b>[-d</b> <b>HIPSDIR]</b> <b>svcId</b> -- complete the properties file in HIPSDIR with metadata from  the  service
         referenced by svcId (e.g., q#hips).

       • <b>hipsgen</b> <b>dataId</b> <b>minOrder</b> -- Write a Hipsgen parameter file for making a HiPS out of the data imported by
         dataId  (e.g., q#import) to stdout.  minOrder is the minimal HEALPix order Hipsgen should generate (low
         orders are computationally expensive!)

       • <b>hashPassword</b> <b>pw</b> -- hash a password.  adduser and friends already hash themselves,  so  this  is  likely
         only useful for the [web]adminPasswd setting.

       • <b>indexStatements</b> <b>tableRef</b> -- show the statements to create the indices on a table.  The tableRef has the
         format RD-id#table-id; it is <u>not</u> a database table reference.

       • <b>listusers</b> -- dump the user table

       • <b>makedelrec</b>  <b>ivoid</b>  --  create  a registry record of ivoid saying the resource is removed.  This is only
         necessary when recovering from disasters that made you lose records from DaCHS' internal tables.

       • <b>suggestucds</b> <b>tableId</b> -- Make suggestions for UCDs of the columns of the referenced table (rd-id#table-id
         format) not having one.  This is based on their descriptions and uses a GAVO web service.

       • <b>tapabort</b> <b>jobId</b> <b>helpMsg</b> -- manually abort a TAP job and return helpMsg to the requesting user  as  error
         message.

       • <b>updateTAPSchema</b> -- Update the TAP_SCHEMA metadata for all RDs mentioned in TAP_SCHEMA.

       • <b>xsdValidate</b> <b>path</b> -- Validate a file against built-in VO schemas and with built-in schema validator.

</pre><h4><b>THE</b> <b>CONFIG</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs config [section-name] config-key

       This  outputs  values of DaCHS' configuration to stdout.  section-name defaults to general.  This is most
       commonly  used  to  make  external  components  aware   of   DaCHS'   file   locations,   e.g.,   through
       <b>inputs_dir=$(dachs</b> <b>config</b> <b>inputsDir)</b>.

       See the operator's guide for a documentation on DaCHS' configuration options.

</pre><h4><b>THE</b> <b>DATAPACK</b> <b>SUBCOMMAND</b></h4><pre>
       Synposis:

          dachs datapack [-h] {create,load} ...

       Management  of  full  DaCHS  resources  in  the  frictionless  data  package  format.   Note  that  while
       DaCHS-created data packages should work as normal data packages, DaCHS can only (automatically) load data
       packages generated by DaCHS itself -- there simply is not enough metadata in  generic  data  packages  to
       produce usable resources.

   <b>Subsubcommands</b>
   <b>datapack</b> <b>create</b>
       Synopsis:

          dachs datapack create [-h] id dest

       Positional arguments:

       <b>id</b>     Absolute RD id to produce a datapack for

       <b>dest</b>   Name of a zip file to dump to

       The  command  creates  a data package containing the RD, a README in the resource directory if it exists,
       auxiliary files (like a booster grammar or a custom core) the RD may have, and all data  files  that  the
       sources in the RD yield; for collecting these files, <b>sources</b> elements with <b>ignoreSources</b> children reading
       from the database are ignored, because that would make behaviour a bit too unpredictable.

       To  include  further  files, you can use the datapack-extrafiles property on the RD.  This must contain a
       json sequence literal with resdir-relative shell patterns that should be included as well.   Non-existing
       paths  and  directories  in  this  list  are  silently  ignored.  You cannot include files outside of the
       resource directory in a data package.

   <b>datapack</b> <b>load</b>
       Synopsis:

          dachs datapack load [-h] [-t] [--force] source

       Positional argument:

       <b>source</b> Name of a DaCHS-produced data package zip file.

       Optional arguments:

       <b>-t</b>, <b>--no-test</b>
              Do not run tests after importing.

       <b>--force</b>
              If the resdir the package declares already exists, remove it before unpacking (rather than bailing
              out.

       This unpacks a DaCHS-produced data package, imports it, and runs tests on it  (which  you  will  want  to
       suppress if you do not have a DaCHS server running locally).

</pre><h4><b>THE</b> <b>DROP</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          drop [-h] [-s] [--all] rd-id [dd-id ...]

       This is the reverse of import: Tables created by a <b>dachs</b> <b>imp</b> with identical arguments are being torn down
       by  <b>dachs</b> <b>drop</b>.  This will not work reliably if the RD has been modified between the imp and the drop, in
       particular if  the  RD  has  been  deleted.   In  such  situations,  you  can  use  the  <b>-f</b>  flag,  which
       unconditionally tears down everything DaCHS has recorded as coming from the referenced RD.

   <b>Arguments</b>
       <b>rd-id</b>  RD path or ID to drop

       <b>dd-id</b>  optional   data  descriptor  (DD)  ID(s)  if  you do not want to drop the entire RD; note that  no
              service publications will be undone if you give DD IDs

   <b>Options</b>
       <b>--all</b>  drop  all  DDs  in  the RD, not only the auto ones (overrides manual selection)

       <b>-s</b>, <b>--system</b>
              drop tables even if they are system tables

</pre><h4><b>THE</b> <b>DUMP</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs dump [-h] {load,create,ls} ...

       This is an interface to dumping database tables and inspecting and restoring the generated dumps.

       This is mainly intended for small to medium tables that are just  kept  in  the  database,  e.g.,  DaCHS'
       administrative tables and the like.  For normal user tables, built from science data, doing re-imports is
       the recommended way to deal with data loss.

       In  particular,  this  command  is  <u>not</u>  designed (at this point) for really large tables.  For technical
       reasons (that could be overcome), currently the individual dumps are kept in memory during creation  (but
       not during loading).

       Before  loading, the target tables are dropped if they are already present; note that this will also drop
       any views they might be part of, as well as any rows  that  have  foreign  keys  on  this  table.   After
       loading, indices and primary keys on the restored tables will be recreated, but no scripts or similar are
       run.  Hence, you will have to manually re-create any dependent resources after a restore.

       This   also   means   that,  for  example,  restoring  a  table  with  products  without  also  restoring
       //products#products will lose the products that previously were in the restored table from  the  products
       table.

   <b>Subsubcommands</b>
   <b>dump</b> <b>create</b>
       Synopsis:

          dachs dump create [options] dumpFile ids [ids ...]

       Dump one or more tables to DaCHS' dump format.  When you pass in RD ids, all onDisk-tables defined in the
       RD will be dumped.

       Positional arguments:

       <b>dumpFile</b>
              Name of a file to write the dump to; use - to dump to stderr.

       <b>ids</b>    ids of table definitions (as in myres/q#main) or RDs to dump.

       Options:

       <b>--text</b> write  dumps  in  text  format.   You  need  that  when  objects  in  the  tables  have  no binary
              representation.  At least in 2020, that is true for all pgsphere objects.

   <b>dump</b> <b>load</b>
       Synopsis:

          dachs dump load [-h] source

       Restore table(s) from a file created by the <b>dump</b> <b>create</b> subcommand before

       Positional argument:

       <b>source</b> File to restore from. Use - to restore from stdin.

   <b>dump</b> <b>ls</b>
       Synopsis:

          dachs dump ls [-h] source

       List tables and dump metadata from a DaCHS dump.

       Positional arguments:

       <b>source</b> source file to list

</pre><h4><b>THE</b> <b>GENCOL</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs gencol [-h] [-f {fits,vot,viz}] FILE

       The gencol subcommand quickly generates a set of basic column elements  for  inclusion  in  RDs.   It  is
       particularly convenient together with <b>dachs</b> <b>start</b>.

       This  currently  understands FITS binary tables, VOTables and Vizier-Style byte-by-byte descriptions (the
       latter somewhat haphazardly).  It assumes there is only one table in each file (and will ignore others in
       the FITS and VizieR case).

       It will extract what metadata there is and emit formatted RD XML to stdout; this should  work  just  fine
       for  cut-and-paste  into  &lt;table&gt;  elements in RD.  Note that usually, important metadata will be missing
       (e.g., UCDs for FITS and VizieR), and usually data  providers  are  not  terribly  careful  when  writing
       metadata.   Hence,  you  should  definitely thoroughly review the elements created before using them in a
       public service.

       The program tries to guess the applicable parser from a file name (e.g., README  or  anything  ending  in
       .txt will be treated as Vizier-like).  Where this fails, use the -f option.

       For Vizier-like descriptions, the program also dumps <b>colDefs</b> material for use in columnGrammar-s.

   <b>Argument</b>
       <b>FILE</b>   Source   file  to  generate  the  columns  from.  This  can  be  a  FITS,  a  VOTable,  or  Vizier
              Column-by-column description, and DaCHS will guess based on the extension. Use the  format  option
              if it guesses wrong.

   <b>Options</b>
       <b>-h</b>, <b>--help</b>
              show this help message and exit

       <b>-f</b> <u>FMT</u>, <b>--format</b> <u>FMT</u>
              Format of the input table: FITS binary (<b>fits</b>), VOTable (<b>vot</b>), or Vizier byte-by-byte (<b>viz</b>)

</pre><h4><b>THE</b> <b>IMPORT</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs import [options] rd-name [data-id]

       This  subcommand  is  used to ingest data described by an RD.  For special applications, ingestion can be
       restricted to specific data items within an RD.

   <b>Options</b>
       <b>-h</b>, <b>--help</b>
              show this help message and exit

       <b>-n</b>, <b>--updateRows</b>
              Deprecated.  Use updating data items instead.

       <b>-d</b>, <b>--dumpRows</b>
              Dump raw rows as they are emitted by the grammar.

       <b>-D</b>, <b>--dumpIngestees</b>
              Dump processed rows as emitted by the row makers.

       <b>-R</b>, <b>--redoIndex</b>
              Drop indices before updating a table and recreate them when done

       <b>-m</b>, <b>--meta-only</b>
              just update table meta (privileges, column descriptions,...).  This will also update  the  tables'
              obscore  clauses,  but  you  will have to <b>dachs</b> <b>imp</b> <b>//obscore</b> to update the obscore view itself in
              this case.

       <b>-I</b>, <b>--meta-and-index</b>
              do not import, but update table  meta  (privileges,  column  descriptions,...)  and  recreate  the
              indices

       <b>-u</b>, <b>--update</b>
              update mode -- don't drop tables before writing.

       <b>-s</b>, <b>--system</b>
              (re-)create system tables, too

       <b>-v</b>, <b>--verbose</b>
              talk a lot while working

       <b>-r</b>, <b>--reckless</b>
              Do not validate rows before ingestion

       <b>-M</b> <u>MAX</u>, <b>--stop-after=</b><u>MAX</u>
              Stop after having parsed MAX rows

       <b>-b</b> <u>N</u>, <b>--batch-size=</b><u>N</u>
              deliver N rows at a time to the database.

       <b>-c</b>, <b>--continue-bad</b>
              do not bail out after an error, just skip the current source and continue with the next one.

       <b>-L</b>, <b>--commit-after-meta</b>
              commit  the  importing  transaction  after  updating the meta tables.  Use this when loading large
              (hence -L) data sets to avoid keeping a lock on the meta tables for the  duration  of  the  input,
              i.e., potentially days.  The price is that users will see empty tables during the import.

       <b>--hide-adql</b>
              Interpret adql=True on tables as adql=hidden (this is for fallback mirrors)

</pre><h4><b>THE</b> <b>INFO</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs info [-h] table-id

       This  displays  column  statistics  about  the  table  referred to in the argument (which must be a fully
       qualified table name resolvable by the database system).

   <b>Argument</b>
       <b>table-id</b>
              table ID (of the form rdId#tableId)

</pre><h4><b>THE</b> <b>INIT</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs init [-h] [-d DSN] [--nodb]

       This initialises DaCHS' file system and database environment.  Calling <b>dachs</b> <b>init</b>  on  an  existing  site
       should  not  damage  anything.   It  might,  however,  fix  things  if, for instance, permissions on some
       directories went funny.

   <b>Options</b>
       <b>-d</b> <u>&lt;DSN&gt;</u>, <b>--dsn</b> <u>&lt;DSN&gt;</u>
              data source name (DSN) to use to  connect  to  the future DaCHS database; the DSN must  let  DaCHS
              connect  to  the  database  as  an  administrator;  dbname, host,  and  port  get  copied  to  the
              profile, if given; this is not required if the calling user has superuser privileges on a database
              running on  localhost.   Otherwise,  the  DSN  has  to  look  like  "host=example.org  dbname=mydb
              user=superuser password=secret".

       <b>--nodb</b> inhibit   initialization   of   the  database  (you may want to use this when refreshing the  file
              system hierarchy)

</pre><h4><b>THE</b> <b>LIMITS</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs limits [-h] [-t] [-s P] [-d] itemId [itemId ...]

       This creates or updates DaCHS' estimates of various metadata of RDs or  tables,  in  particular  the  STC
       coverage,  the  size  of the tables and, unless <b>-t</b> is given, the column statistics.  This may take a long
       time for large tables, in which case you may use the <b>--sample-percent</b> option, which makes DaCHS only look
       at a subset of the full data.

       When running <b>dachs</b> <b>limits</b> on an RD, it will skip views under the assumption that  in  the  typical  case,
       column  metadata  for the interesting columns will already have been obtained for the source tables.  For
       views for which this is assumption is wrong, set the forceStats property to True.

       You should in general run <b>dachs</b> <b>limits</b> before publishing a resource.

   <b>Arguments</b>
       <b>itemId</b> either an RD id or a table reference in the from rd-id#table-id.  A single ALL will expand to  all
              RDs that already have limits-obtained metadata.

   <b>Options</b>
       <b>-t</b>, <b>--tables-only</b>
              Only acquire table/resource-level metadata (rather than column metadata, which usually takes a lot
              longer).

       <b>-s</b> <u>P</u>, <b>--sample-percent</b> <u>P</u>
              Only look at P percent of the table to determine min/max/mean.

       <b>-d</b>, <b>--dump</b>
              Do not obtain statistics but rather dump the results of the last run

</pre><h4><b>THE</b> <b>MKBOOST</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs mkboost [option] &lt;id-of-directGrammar&gt;

       This  writes  a  C source skeleton for using the direct grammar referenced to fill a database table.  See
       the <u>Guide</u> <u>to</u> <u>Write</u> <u>Booster</u> <u>Grammars</u> in the DaCHS documentation for how to use this command.

   <b>Options</b>
       <b>-b</b>, <b>--binary</b>
              generate a skeleton for a binary parser

       <b>-s</b> <u>&lt;SPLITTER&gt;</u>, <b>--splitter=</b><u>&lt;SPLITTER&gt;</u>
              generate   a  split  skeleton  with  split  string &lt;SPLITTER&gt;

</pre><h4><b>THE</b> <b>MKRD</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs mkrd [option] sample

       Rudimentary support for generating RDs from data.  This was probably a bad idea.  Better use dachs start.

   <b>Options</b>
       <b>-f</b> <u>&lt;SRCFORM&gt;</u>, <b>--format=</b><u>&lt;SRCFORM&gt;</u>
              source format: FITS or VOT; default: detected from file name

       <b>-t</b> <u>&lt;TABLENAME&gt;</u>, <b>--table-name=</b><u>&lt;TABLENAME&gt;</u>
              name of the generated table

</pre><h4><b>THE</b> <b>PUBLISH</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs pub [-h] [-a] [-m] [-k] [-u] rd [rd ...]

       This marks data and/or services contained in an RD as published; this will make them displayed in  DaCHS'
       portal  page  or pushed to the VO registry through DaCHS' OAI-PMH endpoint.  See the <u>Operator's</u> <u>Guide</u> for
       details.

   <b>Arguments</b>
       <b>rd</b>     RDs to publish; you can give ids or file paths. Use the magic value ALL  to  check  all  published
              RDs,  ALL_RECURSE  to  look for RDs in the file system (check twice for detritus before doing that
              later thing).

   <b>Options</b>
       <b>-k</b>, <b>--keep-timestamps</b>
              Preserve the time stamp of the last record modification. This  may  sometimes  be  desirable  with
              minor updates to an RD that don't justify a re- publication to the VO.

       <b>-u</b>, <b>--unpublish</b>
              Unpublish  all  resources  coming  from  this  RD  Note  that this will in general create "deleted
              records", i.e., essentially empty resource records only stating that the resource referenced by an
              identifier is no longer available.  This is important for reliable operation in  the  presence  of
              incremental harvesting.

</pre><h4><b>THE</b> <b>PURGE</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs purge [-h] tablename [tablename...]

       This will delete tables in the database and also remove their metadata from DaCHS' internal tables (e.g.,
       TAP_SCHEMA,  table  of published records).  Use this if <b>dachs</b> <b>drop</b> fails for to remove some table for one
       reason or another.

   <b>Argument</b>
       <b>tablename</b>
              (SQL) name of the table to drop,  including  the  schema name

</pre><h4><b>THE</b> <b>SERVE</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs serve [-h] {debug | reload | restart | start | stop}

       This exposes various functionality for managing DaCHS' server component.  While these usually  are  being
       called  through  init  scripts  or  systemd  components,  the <b>debug</b> subfunction is very convenient during
       service development off the production environment.

       <b>serve</b> <b>start</b>, <b>stop</b>, and <b>restart</b> manage a PID file, which DaCHS does not do  when  running  under  systemd.
       Hence, do <u>not</u> use these subcommands when systemd manages your DaCHS.  expireRD is fine, though.

   <b>Subsubcommands</b>
       • <b>debug</b> -- run a server and remain in the foreground, dumping all kinds of stuff to the terminal.  If you
         have  an  SSL  certificate, this will try bind an https interface to port 40443; that's exclusively for
         little experiments, do not use it for actual operations.

       • <b>reload</b> -- reload server configuration (incomplete)

       • <b>restart</b> -- restart the server

       • <b>start</b> -- start the server and put it in the background

       • <b>stop</b> -- stop a running server

       • <b>expireRD</b> <b>&lt;rdId&gt;</b> -- forget the cached RD in the running server.  While in general, DaCHS reloads  an  RD
         if  it finds it changed, sometimes it does not realise some dependency has changed.  In that case, this
         subsubcommand can expunge the RD so it will be re-parsed when the next access occurs.  Note  that  this
         requires  [web]adminpasswd  be  set; the command uses [web]serverURL to figure out where to connect the
         running server.

       The <b>start</b> subcommand accepts a <b>--foreground/-f</b> option.  If you pass it, the server will not double-detach
       and not redirect stderr to a log file and instead stay in the foreground; it will also not check for  PID
       files or create them.  In contrast to <b>debug</b>, it will change users, etc., and not put the DaCHS into debug
       mode.  This option is primarily useful for systemd units.

</pre><h4><b>THE</b> <b>START</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs start [-h] (list|&lt;data-type-tag&gt;)

       The  start subcommand generates a template RD for a certain type of data that you can then fill out.  The
       data-type-tag can be something like scs (for catalogs), siap (for images), or ssap (for  spectra).   Pass
       <b>list</b> to see what is available.

       The template uses the name of current directory as resdir and schema name.  That means that if starting a
       data  collection,  you should create its resdir as a child of GAVO_ROOT/inputs and execute <b>dachs</b> <b>start</b> in
       that dicrectory.

       To fill out the template RD, load it into a text editor and, ina first go, search for the  pattern  %.*%.
       You  should  see  enough  hints  from  what  is  between  the  percent signs and the environment to get a
       reasonable shot at filling things out.  Then reead the comments; very typcially, you can get an extremely
       basic data publication without that, but a good service will normally  require  some  extra  work  beyond
       filling things out.

   <b>Argument</b>
       <b>data-type-tag</b>
              A  short  identifier  for  a  data  type.   Pass  <b>list</b>  here to see a list of known tags and their
              meanings.

</pre><h4><b>THE</b> <b>TEST</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs test [-h] [-v] [-V] [-d] [-t TAG] [-R N] [-T SECONDS] [-D FILE]
                      [-w SECONDS] [-u SERVERURL] [-n NTHREADS]
                      [--seed RANDOMSEED] [-k KEYWORDS]
                      id

       This runs regression tests embedded in the whatever is reference by id (can be an RD, a regression suite,
       or a single regression test).  For details, see the chapter on <u>regression</u> <u>testing</u> in the <u>DaCHS</u>  <u>Reference</u>
       <u>Manual</u>.

   <b>Argument</b>
       <b>id</b>     RD  id  or cross-RD identifier for a testable thing.  Write ALL here to have DaCHS search and test
              all RDs in the inputs, ignoring those in or below directories with a file named DACHS_PRUNE.

   <b>Options</b>
       <b>-h</b>, <b>--help</b>
              show this help message and exit

       <b>-v</b>, <b>--verbose</b>
              Talk while working

       <b>-d</b>, <b>--dump-negative</b>
              Dump the content of failing tests to stdout

       <b>-t</b> <u>TAG</u>, <b>--tag</b> <u>TAG</u>
              Also run tests tagged with TAG.

       <b>-R</b> <u>N</u>, <b>--n-repeat</b> <u>N</u>
              Run each test N times

       <b>-T</b> <u>SECONDS</u>, <b>--timeout</b> <u>SECONDS</u>
              Abort and fail requests after inactivity of SECONDS

       <b>-D</b> <u>FILE</u>, <b>--dump-to</b> <u>FILE</u>
              Dump the content of last failing test to FILE

       <b>-w</b> <u>SECONDS</u>, <b>--wait</b> <u>SECONDS</u>
              Wait SECONDS before executing a request

       <b>-u</b> <u>SERVERURL</u>, <b>--serverURL</b> <u>SERVERURL</u>
              URL of the DaCHS root at the server to test

       <b>-n</b> <u>NTHREADS</u>, <b>--number-par</b> <u>NTHREADS</u>
              Number of requests to be run in parallel

       <b>-k</b> <u>KEYWORDS</u>, <b>--keywords</b> <u>KEYWORDS</u>
              Only run tests with descriptions containing all (whitespace-separated) keywords. Sequential  tests
              will be run in full, nevertheless, if their head test matches.

</pre><h4><b>THE</b> <b>VALIDATE</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs validate [-h] [-x] [-v] rd [rd...]

       This checks RDs for well-formedness and some aspects  of  VO-friendliness

   <b>Arguments</b>
       <b>rd</b>     RD path or ID to validate.  Write ALL here to have DaCHS search and validate all RDs in your input
              and validate them, ignoring those in or below directories with a file named DACHS_PRUNE.

   <b>Options</b>
       <b>-h</b>, <b>--help</b>
              show this help message and exit

       <b>-p</b>, <b>--pre-publication</b>
              Validate  as  if  all services were IVOA published even if they are not (this may produce spurious
              errors if unpublished services are in the RD).

       <b>-v</b>, <b>--verbose</b>
              Talk while working

       <b>-t</b>, <b>--run-tests</b>
              Run regression tests embedded in the checked RDs

       <b>-T</b> <u>SECONDS</u>, <b>--timeout</b> <u>SECONDS</u>
              When running tests, abort and fail requests after inactivity of SECONDS

       <b>-c</b>, <b>--compare-db</b>
              Also make sure that tables that are on disk (somewhat) match the definition in the RD.

</pre><h4><b>THE</b> <b>UPGRADE</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs upgrade

       Each DaCHS version has an associated database schema version, encoding the structure of DaCHS'  (and  the
       implemented  protocol  versions')  ideas  of  how system and user tables should look like.  <b>dachs</b> <b>upgrade</b>
       attempts to work out how to change the database to match the expectations  of  the  current  version  and
       executes  the respective code.  It will not touch its data structures if it decrees that the installation
       is up to date.

       Operating system packages will usually try to run <b>dachs</b> <b>upgrade</b> as part of  their  management  operation.
       In  case  <b>dachs</b>  <b>upgrade</b> requires manual intervention, this may fail, in which case operators may need to
       call <b>dachs</b> <b>upgrade</b> manually.

       Operators keeping a manually installed DaCHS should run <b>dachs</b> <b>upgrade</b> after each  <b>svn</b>  <b>update</b>  or  update
       from tar.

       <b>dachs</b>  <b>upgrade</b> cannot perform actions requiring superuser privileges, since none of its roles have those.
       Currently, this is mainly updating postgres extensions DaCHS  uses  (if  you  use  extra  ones,  you  can
       configure  DaCHS'  watch list in [db]managedExtensions).  <b>dachs</b> <b>upgrade</b> <b>-e</b> will attempt to figure out the
       instructions necessary to update extensions and write them to stdout.  Hence,  operators  should  execute
       something  like  <b>dachs</b>  <b>upgrade</b> <b>-e</b> <b>|</b> <b>psql</b> <b>gavo</b> from a database superuser account after upgrading postgres
       extensions.

   <b>Options</b>
          <b>--force-dbversion</b> <u>FORCEDBVERSION</u>
                 assume this as the database's schema version. If you don't develop DaCHS, you almost  certainly
                 should stay clear of this flag

          <b>-e</b>, <b>--get-extension-script</b>
                 Dump  a  script  to  update  DaCHS-managed extensions (will print nothing if no extensions need
                 updating). This will return 0 if material was written, 1 otherwise.

          <b>-t</b>, <b>--update-tap-schema</b>
                 Update the TAP schema, i.e., re-read all the metadata  from  the  TAP-published  tables.   This
                 isn't  really  related  to  upgrading,  but  it  is  generally  a  good  idea  to  sync on-disk
                 representations with what you may have edited in the RDs.

</pre><h4><b>THE</b> <b>ADQL</b> <b>SUBCOMMAND</b></h4><pre>
       Synopsis:

          dachs adql query

       This subcommand executes ADQL queries locally and writes the resulting VOTable to  stdout.   We  consider
       removing it.

</pre><h4><b>INTERNAL</b> <b>OR</b> <b>DEPRECATED</b> <b>SUBCOMMANDS</b></h4><pre>
       The  subcommands  <b>show</b>,  <b>stc</b>  are deprecated and not documented here.  They may disappear without further
       notice.

       the subcommands <b>taprun</b>, <b>dlrun</b>, <b>uwsrun</b>, <b>gendoc</b>, <b>raise</b> are used internally and should not be directly  used
       by DaCHS operators.

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       To     report    bugs    and    request    support,    please    use    our    support    mailing    list
       <u><a href="http://lists.g-vo.org/cgi-bin/mailman/listinfo/dachs-support">http://lists.g-vo.org/cgi-bin/mailman/listinfo/dachs-support</a></u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Comprehensive, if always incomplete documentation on DaCHS is available in several documents available at
       <u><a href="http://docs.g-vo.org/DaCHS/">http://docs.g-vo.org/DaCHS/</a></u> (upstream site with PDF downloads and the formatted reference  documentation)
       and <u><a href="http://dachs-doc.readthedocs.io/en/latest/index.html">http://dachs-doc.readthedocs.io/en/latest/index.html</a></u> (with facilities for updating the documents).

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright    ©    2017    The   GAVO   project.    License   GPLv3+:  GNU  GPL  version  3  or  later  &lt;‐
       <u><a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a></u>&gt;.  This is free software: you are free  to   change   and   redistribute
       it.  There is NO WARRANTY, to the extent permitted by law.

</pre><h4><b>AUTHOR</b></h4><pre>
       Markus Demleitner &lt;<a href="mailto:gavo@ari.uni-heidelberg.de">gavo@ari.uni-heidelberg.de</a>&gt;

2.3                                                2021-02-04                                           <u><a href="../man1/DACHS.1.html">DACHS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>