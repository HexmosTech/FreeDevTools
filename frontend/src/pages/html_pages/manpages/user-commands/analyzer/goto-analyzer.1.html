<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>goto-analyzer - Data-flow analysis for C programs and goto binaries</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/cbmc">cbmc_6.4.1-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       goto-analyzer - Data-flow analysis for C programs and goto binaries

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>goto-analyzer</b> <b>[-?|-h|--help]</b>

       <b>goto-analyzer</b> <b>--version</b>

       <b>goto-analyzer</b> <b>[options]</b> <b>file.c|file.gb</b>

       <b>goto-analyzer</b> <b>[--no-standard-checks]</b> <u>file.c</u> <b>...</b>

       <b>goto-analyzer</b> <b>[--no-standard-checks]</b> <b>[--pointer-check]</b> <u>file.c</u> <b>...</b>

       <b>goto-analyzer</b> <b>[--no-bounds-check]</b> <u>file.c</u> <b>...</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>goto-analyzer</b>  is an abstract interpreter which uses the same front-end and GOTO binary representation as
       <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1).

       The key difference is that <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1) under-approximates the behavior of the program (execution traces  that
       are  too  long  or  require  too  many  loop  unwindings  are  not  considered) while <b>goto-analyzer</b> over-
       approximates the behavior of the program.  <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1) can determine if a property is A. true for  a  bounded
       number  of iterations or B.  false and giving an error trace.  In contrast <b>goto-analyzer</b> can determine if
       a property is A. true for all iterations or B. possibly false.  In this sense,  each  tool  has  its  own
       strengths and weaknesses.

       To use <b>goto-analyzer</b> you need to give options for:

              What <u>task</u> to perform after the abstract interpreter has run.

              How to format the <u>output</u>.

              Which <u>abstract</u> <u>interpreter</u> is used.

              Which <u>domain</u> is used to describe the state of the program at a point during execution.

              How the <u>history</u> of the control flow of the program determines the number of points of execution.

              The <u>storage</u> that links points of execution and domains.

</pre><h4><b>OPTIONS</b></h4><pre>
   <b>Task</b> <b>options:</b>
       <b>goto-analyzer</b>  first runs the abstract interpreter until it reaches a fix-point, then it will perform the
       task the user has chosen.

       <b>--show</b> Displays a domain for every instruction in the GOTO  binary.   The  format  and  information  will
              depend  on  the <u>domain</u> that has been selected.  If there are multiple domains corresponding to the
              same location (see <u>history</u> below) these will be merged before they are displayed.

       <b>--show-on-source</b>
              The source code of the program is displayed line-by-line with the abstract  domains  corresponding
              to  each location displayed between them.  As the analysis is done at the level of instructions in
              the GOTO binary, some domains may not be displayed.  Also if parts of the GOTO  binary  have  been
              generated  or  manipulated by other tools, these may not be displayed as there is no corresponding
              source.  <b>--show-on-source</b> is the more user-friendly output, but <b>--show</b> gives a better  picture  of
              exactly what is computed.

       <b>--verify</b>
              Every property in the program is checked to see whether it is true (it always holds), unreachable,
              false  if  it is reachable (due to the over-approximate analysis, it is not clear if locations are
              reachable or if it is an overapproximation, so this is the best that can be achieved) or  unknown.
              If  there  are multiple points of execution that reach the same location, each will be checked and
              the answers combined, with unknown taking precedence.

       <b>--simplify</b> <u>file_name</u>
              Writes a new version of the input program to <u>file_name</u> in which the program  has  been  simplified
              using  information  from  the  abstract  interpreter.  The exact simplification will depend on the
              domain that is used but typically this might be replacing  any  expression  that  has  a  constant
              value.   If  this  makes  instructions  unreachable  (for example if <b>GOTO</b> can be shown to never be
              taken) they will be removed.  Removal can be deactivated by passing <b>--no-simplify-slicing</b>.  In the
              ideal world simplify would be idempotent (i.e.  running  it  a  second  time  would  not  simplify
              anything  more than the first).  However there are edge cases which are difficult or prohibitively
              expensive to  handle  in  the  domain  which  can  result  in  a  second  (or  more)  runs  giving
              simplification.  Submitting bug reports for these is helpful but they may not be viable to fix.

       <b>--no-simplify-slicing</b>
              Do not remove instructions from which no property can be reached (use with <b>--simplify</b>).

       <b>--unreachable-instructions</b>
              Lists which instructions have a domain which is bottom (i.e. unreachable).  If <b>--function</b> has been
              used  to  set  the  program  entry  point  then  this  can  flag  things like the <u>main</u> function as
              unreachable.

       <b>--unreachable-functions</b>
              Similar to <b>--unreachable-instructions</b>, but reports  which  functions  are  definitely  unreachable
              rather than just instructions.

       <b>--reachable-functions</b>
              The  negation  of  <b>--unreachable-functions</b>,  reports  which functions may be reachable.  Note that
              because the analysis is over-approximate, it is possible this will  mark  functions  as  reachable
              when a more precise analysis (possibly using <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1)) will show that there are no execution traces
              that reach them.

   <b>Abstract</b> <b>interpreter</b> <b>options:</b>
       These options control which abstract interpreter is used and how the analysis is performed.  In principle
       this  can  significantly change the accuracy and performance of <b>goto-analyzer</b> but the current options are
       reasonably similar.

       If <b>--verbosity</b> is set above <b>8</b> the abstract interpreter will log what it is doing.  This  is  intended  to
       aid  developers  in  understanding  how  the  algorithms work, where time is being spent, etc. but can be
       generally quite instructive.

       <b>--legacy-ait</b>
              This is the default option.  Abstract interpretation is performed eagerly from the  start  of  the
              program  until  fixed-point is reached.  Functions are analyzed as needed and in the order of that
              they are reached.  This option also fixes the <u>history</u> and <u>storage</u> options to their defaults.

       <b>--recursive-interprocedural</b>
              This extends <b>--legacy-ait</b> by allowing the <u>history</u> and <u>storage</u>  to  be  configured.   As  the  name
              implies, function calls are handled by recursion within the interpreter.  This is a good all-round
              choice and will likely become the default at some point in the future.

       <b>--three-way-merge</b>
              This extends <b>--recursive-interprocedural</b> by performing a "modification aware" merge after function
              calls.   At  the time of writing only <b>--vsd</b> supports the necessary differential reasoning.  If you
              are using <b>--vsd</b> this is recommended as it is more accurate with little extra cost.

       <b>--legacy-concurrent</b>
              This extends <b>--legacy-ait</b> with very restricted and special  purpose  handling  of  threads.   This
              needs  the domain to have certain unusual properties for it to give a correct answer.  At the time
              of writing only <b>--dependence-graph</b> is compatible with it.

       <b>--location-sensitive</b>
              Use location-sensitive abstract interpreter.

   <b>History</b> <b>options:</b>
       To over-approximate what a program does, it is necessary to  consider  all  of  the  paths  of  execution
       through  the  program.   As  there  are a potentially infinite set of traces (and they can be potentially
       infinitely long) it  is  necessary  to  merge  some  of  them.   The  common  approach  (the  "collecting
       abstraction") is to merge all paths that reach the same instruction.  The abstract interpretation is then
       done  between  instructions  without  thinking about execution paths.  This ensures termination but means
       that it is not possible to distinguish different call sites, loop iterations or paths through a program.

       Note that <b>--legacy-ait</b>, the default abstract interpreter fixes the history to <b>--ahistorical</b> so  you  will
       need to choose another abstract interpreter to make use of these options.

       <b>--ahistorical</b>
              This  is  the default and the coarsest abstraction.  No history information is kept, so all traces
              that reach an instruction are merged.  This is the collecting abstraction that  is  used  in  most
              abstract interpreters.

       <b>--call-stack</b> <u>n</u>
              This  is  an  inter-procedural  abstraction;  it tracks the call stack and only merges traces that
              reach the same location and have the same call  stack.   The  effect  of  this  is  equivalent  to
              inlining  all  functions  and  then  using  <b>--ahistorical</b>.   In  larger  programs this can be very
              expensive in terms of both time and memory but can give much  more  accurate  results.   Recursive
              functions  create  a  challenge  as  the  call stack will be different each time.  To prevent non-
              termination, the parameter <u>n</u> limits how many times a loop of recursive functions  can  be  called.
              When <u>n</u> is reached all later ones will be merged.  Setting this to <u>0</u> will disable the limit.

       <b>--loop-unwind</b> <u>n</u>
              This  tracks  the  backwards  jumps that are taken in the current function.  Traces that reach the
              same location are merged if their history of backwards jumps is the same.  At most  <u>n</u>  traces  are
              kept  for  each  location, after that they are merged regardless of whether their histories match.
              This gives a similar effect to unrolling the loops <u>n</u> times and then using <b>--ahistorical</b>.   In  the
              case  of  nested  loops,  the  behavior can be a little different to unrolling as the limit is the
              number of times a location is reached, so a loop with  <u>x</u>  iterations  containing  a  loop  with  <u>y</u>
              iterations  will  require  <u>n</u> = <u>x*y</u>.  The time and memory taken by this option will rise (at worst)
              linearly in terms of <u>n</u>.  If <u>n</u> is <b>0</b> then there is no limit.  Be warned that if there are loops that
              can execute an unbounded number of iterations or if the domain  is  not  sufficiently  precise  to
              identify the termination conditions then the analysis will not terminate.

       <b>--branching</b> n
              This  works in a similar way to <b>--loop-unwind</b> but tracking forwards jumps (<b>if</b>, <b>switch</b>, <b>goto</b>, etc.)
              rather than backwards ones.  This gives per-path analysis but limiting the number  of  times  each
              location  is  visited.  There is not a direct form of program transformation that matches this but
              it is similar to the per-path analysis that symbolic execution does.  The scalability and the risk
              of non-termination if <u>n</u> is <b>0</b> remain the same.  Note that the goto-programs  generated  by  various
              language  front-ends  have  a conditional forwards jump to exit the loop if the condition fails at
              the start and an unconditional backwards jump at the end.  This means that <b>--branching</b> can wind up
              distinguishing different loop iterations — "has not exited for the last 3 iterations" rather  than
              "has jumped back to the top 3 times".

       <b>--loop-unwind-and-branching</b> <u>n</u>
              Again,  this  is  similar  to <b>--loop-unwind</b> but tracks both forwards and backwards jumps.  This is
              only a very small amount more expensive than <b>--branching</b> and  is  probably  the  best  option  for
              detailed analysis of each function.

   <b>Domain</b> <b>options:</b>
       These control how the possible states at a given execution point are represented and manipulated.

       <b>--dependence-graph</b>
              Tracks  data  flow  and  information  flow dependencies between instructions and produces a graph.
              This includes doing points-to analysis and tracking reaching definitions  (i.e.  use-def  chains).
              This is one of the most extensive, correct and feature complete domains.

       <b>--vsd</b>, <b>--variable-sensitivity</b>
              This  is  the  Variable  Sensitivity  Domain  (VSD).  It is a non-relational domain that stores an
              abstract object for each live variable.  Which kind of abstract objects are used  depends  on  the
              type  of  the  variable and the run-time configuration.  This means that sensitivity of the domain
              can be chosen — for example, do you want to track every element of an array independently, or just
              a few of them or simply ignore arrays all together.  A set of options to configure VSD  are  given
              below.   This domain is extensive and does not have any known architectural limits on correctness.
              As such it is a good choice for many kinds of analysis.

       <b>--dependence-graph-vs</b>
              This is a variant of the dependence graph domain that uses VSD to do the foundational pointer  and
              reaching  definitions  analysis.   This  means it can be configured using the VSD options and give
              more precise analysis (for example, field aware) of the dependencies.

       <b>--constants</b>
              The default option, this stores one constant value per variable.  This means it is fast  but  will
              only  find  things  that can be resolved by constant propagation.  The domain has some handling of
              arrays but limited support for pointers which means that in can potentially give unsound behavior.
              <b>--vsd</b> <b>--vsd-values</b> <u>constants</u> is probably a better choice for this kind of analysis.

       <b>--intervals</b>
              A domain that stores an interval for each integer and float variable.  At the time of writing  not
              all  operations are supported so the results can be quite over-approximate at points.  It also has
              limitations in the handling of pointers so can give unsound results.  <b>--vsd</b> <b>--vsd-values</b> <u>intervals</u>
              is probably a better choice for this kind of analysis.

       <b>--non-null</b>
              This domain is intended to find which pointers are not null.  Its implementation is  very  limited
              and it is not recommended.

   <b>Variable</b> <b>sensitivity</b> <b>domain</b> <b>(VSD)</b> <b>options:</b>
       VSD  has  a  wide  range  of  options  that  allow  you to choose what kind of abstract objects (and thus
       abstractions) are used to represent variables of each type.

       <b>--vsd-values</b> [<b>constants</b>|<b>intervals</b>|<b>set-of-constants</b>]
              This controls the abstraction used for  values,  both  <b>int</b>  and  <b>float</b>.   The  default  option  is
              <b>constants</b> which tracks if the variable has a constant value.  This is fast but not very precise so
              it  may  well  be  unable to prove very much.  <b>intervals</b> uses an interval that contains all of the
              possible values the variable can take.  It is more precise than <b>constants</b> in all cases but  a  bit
              slower.   It is good for numerical code. <b>set-of-constants</b> uses a set of up to <b>10</b> (currently fixed)
              constants.  This is more general than using a single constant but can make analysis up to 10 times
              (or in rare cases 100 times) slower.  It is good for control code with flags and modes.

       <b>--vsd-structs</b> [<b>top-bottom</b>|<b>every-field</b>]
              This controls how structures are handled.  The default is <b>top-bottom</b> which uses an abstract object
              with just two states (top and bottom).  In effect writes to structures are ignored and reads  from
              them  will  always  return  top (any value).  The other alternative is <b>every-field</b> which stores an
              abstract object for each field.  Depending on how many structures are live at any one time and how
              many fields they have this may increase the amount of memory used by <b>goto-analyzer</b> by a reasonable
              amount.  But this means that the analysis will be field-sensitive.

       <b>--vsd-arrays</b> [<b>top-bottom</b>|<b>smash</b>|<b>up-to-n-elements</b>|<b>every-element</b>]
              This controls how arrays are handled.   As  with  structures,  the  default  is  <b>top-bottom</b>  which
              effectively  ignores  writes  to  the  array and returns top on a read.  More precise than this is
              <b>smash</b> which stores one abstract element for all of the values.  This is relatively cheap but a lot
              more  precise,  particularly  if  used  with  <b>intervals</b>  or  <b>set-of-constants</b>.    <b>up-to-n-elements</b>
              generalizes  <b>smash</b>  by storing abstract objects for the first <u>n</u> elements of each array (<u>n</u> defaults
              to <b>10</b> and can be controlled by <b>--vsd-array-max-elements</b>) and then condensing  all  other  elements
              down  to a single abstract object.  This allows reasonably fine-grained control over the amount of
              memory used and can give much more precise results for small arrays.  <b>every-element</b>  is  the  most
              precise,  but  most  expensive  option  where an abstract element is stored for every entry in the
              array.

       <b>--vsd-array-max-elements</b>
              Configures the value of <b>n</b> in <b>--vsd-arrays</b> <b>up-to-n-elements</b> and defaults to 10 if not given.

       <b>--vsd-pointers</b> [<b>top-bottom</b>|<b>constants</b>|<b>value-set</b>]
              This controls the handling of pointers.  The default,  <b>top-bottom</b>  effectively  ignores  pointers,
              this  is OK if they are just read (all reads return top) but if they are written then there is the
              problem that we know that a variable is changed but we don't know which one, so we have to set the
              whole domain to top.  <b>constants</b> is somewhat misleadingly named as it uses an abstract object  that
              tracks  a  pointer to a single variable.  This includes the offset within the variable; a stack of
              field names for structs and abstract objects for offsets in arrays.  Offsets are tracked  even  if
              the  abstract  object  for  the  variable itself does not distinguish different fields or indexes.
              <b>value-set</b> is the most precise option; it stores a set of pointers to single variables as described
              above.

       <b>--vsd-unions</b> <b>top-bottom</b>
              At the time of writing there is only one option for unions which is <b>top-bottom</b>, discarding  writes
              and returning top for all reads from a variable of union type.

       <b>--vsd-data-dependencies</b>
              Wraps  each abstract object with a set of locations where the variable was last modified.  The set
              is reset when the variable is written and takes the union of the two sides' sets on  merge.   This
              was  originally  intended for <b>--dependence-graph-vs</b> but has proved useful for <b>--vsd</b> as well.  This
              is not strictly necessary for <b>--three-way-merge</b> as  the  mechanism  it  uses  to  work  out  which
              variables have changed is independent of this option.

       <b>--vsd-liveness</b>
              Wraps  each abstract object with the location of the last assignment or merge.  This is more basic
              and limited than <b>--vsd-data-dependencies</b> and is intended to track  SSA-like  regions  of  variable
              liveness.

       <b>--vsd-flow-insensitive</b>
              This  does  not alter the abstract objects used or their configuration.  It disables the reduction
              of the domain when a branch is taken or an assumption is reached.  This  normally  gives  a  small
              saving  in  time but at the cost of a large amount of precision.  This is why the default is to do
              the reduction.  It can be useful for debugging issues with the reduction.

   <b>Storage</b> <b>options:</b>
       The histories described above are used to keep track of where in the computation needs  to  be  explored.
       The  most  precise  option  is to keep one domain for every history but in some cases, to save memory and
       time, it may be desirable to share domains between histories.  The storage options  allow  this  kind  of
       sharing.

       <b>--one-domain-per-location</b>
              This  is the default option.  All histories that reach the same location will use the same domain.
              Setting this means that the results of other histories will be similar to  setting  <b>--ahistorical</b>.
              One  difference  is  how  and when widening occurs: <b>--one-domain-per-location</b> <b>--loop-unwind</b> <u>n</u> will
              wait until <u>n</u> iterations of a loop have been completed and then will start to widen.

       <b>--one-domain-per-history</b>
              This is the best option to use if you are using a history other than <b>--ahistorical</b>.  It stores one
              domain per history which can result in a significant increase in the amount of memory used.

   <b>Output</b> <b>options:</b>
       These options control how the result of the task is output.  The default is text to the standard  output.
       In  the case of tasks that produce goto-programs (<b>--simplify</b> for example), the output options only affect
       the logging and not the final form of the program.

       <b>--text</b> <u>file_name</u>
              Output results in plain text to given file.

       <b>--json</b> <u>file_name</u>
              Writes the output as a JSON object to <u>file_name</u>.

       <b>--xml</b> <u>file_name</u>
              Output results in XML format to <u>file_name</u>.

       <b>--dot</b> <u>file_name</u>
              Writes the output in <b><a href="../man1/dot.1.html">dot</a></b>(1) format to <u>file_name</u>.  This is only supported by some domains and tasks
              (for example <b>--show</b> <b>--dependence-graph</b>).

   <b>Specific</b> <b>analyses:</b>
       <b>--taint</b> file_name
              perform taint analysis using rules in given file

       <b>--show-taint</b>
              print taint analysis results on stdout

       <b>--show-local-may-alias</b>
              perform procedure-local may alias analysis

   <b>C/C++</b> <b>frontend</b> <b>options:</b>
       <b>-I</b> path
              set include path (C/C++)

       <b>--include</b> file
              set include file (C/C++)

       <b>-D</b> macro
              define preprocessor macro (C/C++)

       <b>--c89</b>, <b>--c99</b>, <b>--c11</b>
              set C language standard (default: c11)

       <b>--cpp98</b>, <b>--cpp03</b>, <b>--cpp11</b>
              set C++ language standard (default: cpp98)

       <b>--unsigned-char</b>
              make "char" unsigned by default

       <b>--round-to-nearest</b>, <b>--round-to-even</b>
              rounding towards nearest even (default)

       <b>--round-to-plus-inf</b>
              rounding towards plus infinity

       <b>--round-to-minus-inf</b>
              rounding towards minus infinity

       <b>--round-to-zero</b>
              rounding towards zero

       <b>--no-library</b>
              disable built-in abstract C library

       <b>--function</b> name
              set main function name

   <b>Platform</b> <b>options:</b>
       <b>--arch</b> <u>arch</u>
              Set analysis architecture, which defaults to the host architecture. Use one of: <b>alpha</b>, <b>arm</b>, <b>arm64</b>,
              <b>armel</b>, <b>armhf</b>, <b>hppa</b>, <b>i386</b>, <b>ia64</b>, <b>mips</b>,  <b>mips64</b>,  <b>mips64el</b>,  <b>mipsel</b>,  <b>mipsn32</b>,  <b>mipsn32el</b>,  <b>powerpc</b>,
              <b>ppc64</b>, <b>ppc64le</b>, <b>riscv64</b>, <b>s390</b>, <b>s390x</b>, <b>sh4</b>, <b>sparc</b>, <b>sparc64</b>, <b>v850</b>, <b>x32</b>, <b>x86_64</b>, or <b>none</b>.

       <b>--os</b> <u>os</u>
              Set  analysis  operating system, which defaults to the host operating system. Use one of: <b>freebsd</b>,
              <b>linux</b>, <b>macos</b>, <b>netbsd</b>, <b>openbsd</b>, <b>solaris</b>, <b>hurd</b>, or <b>windows</b>.

       <b>--i386-linux</b>, <b>--i386-win32</b>, <b>--i386-macos</b>, <b>--ppc-macos</b>, <b>--win32</b>, <b>--winx64</b>
              Set analysis architecture and operating system.

       <b>--LP64</b>, <b>--ILP64</b>, <b>--LLP64</b>, <b>--ILP32</b>, <b>--LP32</b>
              Set width of int, long and pointers, but don't override default architecture and operating system.

       <b>--16</b>, <b>--32</b>, <b>--64</b>
              Equivalent to <b>--LP32</b>, <b>--ILP32</b>, <b>--LP64</b> (on Windows: <b>--LLP64</b>).

       <b>--little-endian</b>
              allow little-endian word-byte conversions

       <b>--big-endian</b>
              allow big-endian word-byte conversions

       <b>--gcc</b>  use GCC as preprocessor

   <b>Program</b> <b>representations:</b>
       <b>--show-parse-tree</b>
              show parse tree

       <b>--show-symbol-table</b>
              show loaded symbol table

       <b>--show-goto-functions</b>
              show loaded goto program

       <b>--list-goto-functions</b>
              list loaded goto functions

       <b>--show-properties</b>
              show the properties, but don't run analysis

   <b>Program</b> <b>instrumentation</b> <b>options:</b>
       <b>--no-standard-checks</b>
              disable the standard (default) checks applied to a C/GOTO program (see below for more information)

       <b>--property</b> id
              enable selected properties only

       <b>--bounds-check</b>
              enable array bounds checks

       <b>--pointer-check</b>
              enable pointer checks

       <b>--memory-leak-check</b>
              enable memory leak checks

       <b>--memory-cleanup-check</b>
              Enable memory cleanup checks: assert that all dynamically allocated  memory  is  explicitly  freed
              before terminating the program.

       <b>--div-by-zero-check</b>
              enable division by zero checks for integer division

       <b>--float-div-by-zero-check</b>
              enable division by zero checks for floating-point division

       <b>--signed-overflow-check</b>
              enable signed arithmetic over- and underflow checks

       <b>--unsigned-overflow-check</b>
              enable arithmetic over- and underflow checks

       <b>--pointer-overflow-check</b>
              enable pointer arithmetic over- and underflow checks

       <b>--conversion-check</b>
              check whether values can be represented after type cast

       <b>--undefined-shift-check</b>
              check shift greater than bit-width

       <b>--float-overflow-check</b>
              check floating-point for +/-Inf

       <b>--nan-check</b>
              check floating-point for NaN

       <b>--enum-range-check</b>
              checks that all enum type expressions have values in the enum range

       <b>--pointer-primitive-check</b>
              checks that all pointers in pointer primitives are valid or null

       <b>--retain-trivial-checks</b>
              include checks that are trivially true

       <b>--error-label</b> label
              check that label is unreachable

       <b>--no-built-in-assertions</b>
              ignore assertions in built-in library

       <b>--no-assertions</b>
              ignore user assertions

       <b>--no-assumptions</b>
              ignore user assumptions

       <b>--assert-to-assume</b>
              convert user assertions to assumptions

       <b>--malloc-may-fail</b>
              allow malloc calls to return a null pointer

       <b>--malloc-fail-assert</b>
              set malloc failure mode to assert-then-assume

       <b>--malloc-fail-null</b>
              set malloc failure mode to return null

       <b>--string-abstraction</b>
              track C string lengths and zero-termination

   <b>Standard</b> <b>Checks</b>
       From  version  <b>6.0</b>  onwards, <b>cbmc</b>, <b>goto-analyzer</b> and some other tools apply some checks to the program by
       default (called the "standard checks"), with the aim to provide a better user experience for a non-expert
       user of the tool. These checks are:

       <b>--pointer-check</b>
              enable pointer checks

       <b>--bounds-check</b>
              enable array bounds checks

       <b>--undefined-shift-check</b>
              check shift greater than bit-width

       <b>--div-by-zero-check</b>
              enable division by zero checks

       <b>--pointer-primitive-check</b>
              checks that all pointers in pointer primitives are valid or null

       <b>--signed-overflow-check</b>
              enable signed arithmetic over- and underflow checks

       <b>--malloc-may-fail</b>
              allow malloc calls to return a null pointer

       <b>--malloc-fail-null</b>
              set malloc failure mode to return null

       <b>--unwinding-assertions</b> (<b>cbmc</b>-only)
              generate unwinding assertions (cannot be used with <b>--cover</b>)

       These checks can all be deactivated at once by using the <b>--no-standard-checks</b> flag  like  in  the  header
       example, or individually, by prepending a <b>no-</b> before the flag, like so:

       <b>--no-pointer-check</b>
              disable pointer checks

       <b>--no-bounds-check</b>
              disable array bounds checks

       <b>--no-undefined-shift-check</b>
              do not perform check for shift greater than bit-width

       <b>--no-div-by-zero-check</b>
              disable division by zero checks

       <b>--no-pointer-primitive-check</b>
              do not check that all pointers in pointer primitives are valid or null

       <b>--no-signed-overflow-check</b>
              disable signed arithmetic over- and underflow checks

       <b>--no-malloc-may-fail</b>
              do not allow malloc calls to fail by default

       <b>--no-unwinding-assertions</b> (<b>cbmc</b>-only)
              do not generate unwinding assertions (cannot be used with <b>--cover</b>)

       If  an  already  set flag is re-set, like calling <b>--pointer-check</b> when default checks are already on, the
       flag is simply ignored.

   <b>Other</b> <b>options:</b>
       <b>--validate-goto-model</b>
              enable additional well-formedness checks on the goto program

       <b>--validate-ssa-equation</b>
              enable additional well-formedness checks on the SSA representation

       <b>--version</b>
              show version and exit

       <b>--flush</b>
              flush every line of output

       <b>--verbosity</b> #
              verbosity level

       <b>--timestamp</b> [<b>monotonic</b>|<b>wall</b>]
              Print microsecond-precision timestamps.  <b>monotonic</b>: stamps increase monotonically.  <b>wall</b>: ISO-8601
              wall clock timestamps.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       All tools honor the TMPDIR environment variable when generating temporary files and directories.

</pre><h4><b>BUGS</b></h4><pre>
       If you encounter a problem please create an issue at <b>https://github.com/diffblue/cbmc/issues</b>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1), <b><a href="../man1/goto-cc.1.html">goto-cc</a></b>(1)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2017-2018, Daniel Kroening, Diffblue

goto-analyzer-5.59.0                                June 2022                                   <u><a href="../man1/GOTO-ANALYZER.1.html">GOTO-ANALYZER</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>