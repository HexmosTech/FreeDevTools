<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>re2zig - generate fast lexical analyzers for Zig</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/re2c">re2c_4.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       re2zig - generate fast lexical analyzers for Zig

</pre><h4><b>SYNOPSIS</b></h4><pre>
       re2zig <b>[</b> <b>OPTIONS</b> <b>]</b> <b>[</b> <b>WARNINGS</b> <b>]</b> <b>INPUT</b>

       Input can be either a file or <b>-</b> for stdin.

</pre><h4><b>INTRODUCTION</b></h4><pre>
       re2zig  works  as  a preprocessor. It reads the input file (which is usually a program in Zig, but can be
       anything) and looks for blocks of code enclosed in special-form start/end markers. The  text  outside  of
       these blocks is copied verbatim into the output file. The contents of the blocks are processed by re2zig.
       It translates them to code in Zig and outputs the generated code in place of the block.

       Here is an example of a small program that checks if a given string contains a decimal number:

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          fn lex(yyinput: [:0]const u8) bool {
              var yycursor: u32 = 0;
              %{
                  re2c:yyfill:enable = 0;

                  [1-9][0-9]* { return true; }
                  *           { return false; }
              %}
          }

          test {
              try std.testing.expect(lex("1234"));
          }

       In the output re2zig replaced the block in the middle with the generated code:

          // Generated by re2zig
          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          fn lex(yyinput: [:0]const u8) bool {
              var yycursor: u32 = 0;

              var yych: u8 = 0;
              var yystate: u32 = 0;
              yyl: while (true) {
                  switch (yystate) {
                      0 =&gt; {
                          yych = yyinput[yycursor];
                          yycursor += 1;
                          switch (yych) {
                              0x31...0x39 =&gt; {
                                  yystate = 2;
                                  continue :yyl;
                              },
                              else =&gt; {
                                  yystate = 1;
                                  continue :yyl;
                              },
                          }
                      },
                      1 =&gt; { return false; },
                      2 =&gt; {
                          yych = yyinput[yycursor];
                          switch (yych) {
                              0x30...0x39 =&gt; {
                                  yycursor += 1;
                                  yystate = 2;
                                  continue :yyl;
                              },
                              else =&gt; {
                                  yystate = 3;
                                  continue :yyl;
                              },
                          }
                      },
                      3 =&gt; { return true; },
                      else =&gt; { @panic("internal lexer error"); },
                  }
              }

          }

          test {
              try std.testing.expect(lex("1234"));
          }

</pre><h4><b>BASICS</b></h4><pre>
       A  re2zig  program  consists of a sequence of <u>blocks</u> intermixed with code in the target language. A block
       may contain <u>definitions</u>, <u>configurations</u>, <u>rules</u>, <u>actions</u> and <u>directives</u> in any order:

       <b>name</b> <b>=</b> <b>regular-expression</b> <b>;</b>
              A <u>definition</u> binds <b>name</b> to <b>regular-expression</b>.  Names  may  contain  alphanumeric  characters  and
              underscore.  The  regular  expressions  section  gives  an  overview  of re2zig syntax for regular
              expressions. Once defined, the <b>name</b> can be  used  in  other  regular  expressions  and  in  rules.
              Recursion  in named definitions is not allowed, and each name should be defined before it is used.
              A block inherits named definitions from the global scope. Redefining a name  that  exists  in  the
              current scope is an error.

       <b>configuration</b> <b>=</b> <b>value</b> <b>;</b>
              A  <u>configuration</u> allows one to change re2zig behavior and customize the generated code. For a full
              list of configurations supported  by  re2zig  see  the  configurations  section.  Depending  on  a
              particular  configuration,  the <b>value</b> can be a keyword, a nonnegative integer number or a one-line
              string which should be enclosed in double or single quotes  unless  it  consists  of  alphanumeric
              characters. A block inherits configurations from the global scope and may redefine them or add new
              ones.  Configurations defined inside of a block affect the whole block, even if they appear at the
              end of it.

       <b>regular-expression</b> <b>code</b>
              A <u>rule</u> binds <b>regular-expression</b> to its semantic action (a block of code  in  curly  braces,  or  a
              block of code that starts with <b>:=</b> and ends on a newline followed by any non-whitespace character).
              If  the <b>regular-expression</b> matches, the associated <b>code</b> is executed.  If multiple rules match, the
              longest match takes precedence. If multiple rules match the same string, the  earliest  one  takes
              precedence.  There are two special rules: the default rule <b>*</b> and the end of input rule <b>$</b>.  Default
              rule should always be defined, it has the lowest priority regardless of its place  in  the  block,
              and  it  matches  any  code  unit  (not  necessarily  a  valid character, see the encoding support
              section). The end of input rule should be defined if the corresponding method for handling the end
              of input is used.  With start conditions rules have more complex syntax.

       <b>!action</b> <b>code</b>
              An <u>action</u> binds a user-defined block of <b>code</b> to a particular place in the generated  finite  state
              machine  (in  the  same  way  as  semantic actions bind code to the final states). See the actions
              section for a full list of predefined actions.

       <b>!directive</b> <b>;</b>
              A <u>directive</u> is one of the special predefined statements. Each directive has a unique purpose.  See
              the directives section for details.

   <b>Blocks</b>
       Block start and end markers are either <b>/*!re2c</b> and <b>*/</b>, or <b>%{</b> and <b>%}</b> (both styles are supported). Starting
       from  version 2.2 blocks may have optional names that allow them to be referenced in other blocks.  There
       are different kinds of blocks:

       <b>/*!re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{[:&lt;name&gt;]</b> <b>...</b> <b>%}</b>
              A <u>global</u> <u>block</u> contains  definitions,  configurations,  rules  and  directives.   re2zig  compiles
              regular expressions associated with each rule into a deterministic finite automaton, encodes it in
              the  form  of  conditional  jumps in the target language and replaces the block with the generated
              code. Names and configurations defined in a global block are added to the global scope and  become
              visible  to  subsequent  blocks.  At the start of the program the global scope is initialized with
              command-line options.

       <b>/*!local:re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{local[:&lt;name&gt;]</b> <b>...</b> <b>%}</b>
              A <u>local</u> <u>block</u> is like a global block, but the names and configurations  in  it  have  local  scope
              (they do not affect other blocks).

       <b>/*!rules:re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{rules[:&lt;name&gt;]</b> <b>...</b> <b>%}</b>
              A  <u>rules</u> <u>block</u> is like a local block, but it does not generate any code by itself, nor does it add
              any definitions to the global scope -- it is meant to be reused in other blocks. This is a way  of
              sharing  code  (more  details  in  the reusable blocks section). Prior to re2zig version 2.2 rules
              blocks required <b>-r</b> <b>--reusable</b> option.

       <b>/*!use:re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{use[:&lt;name&gt;]</b> <b>...</b> <b>%}</b>
              A use block that references a previously defined rules block. If the  name  is  specified,  re2zig
              looks  for  a rules blocks with this name. Otherwise the most recent rules block is used (either a
              named or an unnamed one). A use block can add definitions, configurations and rules  of  its  own,
              which  are  added  to  those of the referenced rules block. Prior to re2zig version 2.2 use blocks
              required <b>-r</b> <b>--reusable</b> option.

       <b>/*!max:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{max[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%}</b>
              A block that generates <b>YYMAXFILL</b> definition. An optional  list  of  block  names  specifies  which
              blocks  should  be  included  when computing <b>YYMAXFILL</b> value (if the list is empty, all blocks are
              included).  By default the generated code is a macro-definition for C (<b>#define</b> <b>YYMAXFILL</b> <b>&lt;n&gt;</b>),  or
              a  global  variable  for  Go  (<b>var</b>  <b>YYMAXFILL</b>  <b>int</b>  <b>=</b>  <b>&lt;n&gt;</b>). It can be customized with an optional
              configuration <b>format</b> that specifies a template string where <b>@@{max}</b> (or <b>@@</b> for short) is  replaced
              with the numeric value of <b>YYMAXFILL</b>.

       <b>/*!maxnmatch:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{maxnmatch[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%}</b>
              A  block  that  generates  <b>YYMAXNMATCH</b>  definition  (it  requires  <b>-P</b> <b>--posix-captures</b> option). An
              optional list of block names specifies which blocks should be included when computing  <b>YYMAXNMATCH</b>
              value  (if  the  list  is  empty,  all  blocks  are included).  By default the generated code is a
              macro-definition for C (<b>#define</b> <b>YYMAXNMATCH</b> <b>&lt;n&gt;</b>), or a global variable for Go (<b>var</b> <b>YYMAXNMATCH</b> <b>int</b>
              <b>=</b> <b>&lt;n&gt;</b>). It can be customized with an optional  configuration  <b>format</b>  that  specifies  a  template
              string where <b>@@{max}</b> (or <b>@@</b> for short) is replaced with the numeric value of <b>YYMAXNMATCH</b>.

       <b>/*!stags:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/,</b> <b>/*!mtags:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/</b> <b>or</b>
       <b>%{stags[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%},</b> <b>%{mtags[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%{</b>
              Blocks  that  specify  a  template  piece  of  code that is expanded for each s-tag/m-tag variable
              generated by re2zig. An optional list of block names specifies which  blocks  should  be  included
              when  computing  the  set of tag variables (if the list is empty, all blocks are included).  There
              are two optional configurations: <b>format</b> and <b>separator</b>.  Configuration <b>format</b> specifies a  template
              string  where  <b>@@{tag}</b>  (or  <b>@@</b>  for  short)  is  replaced  with  the  name  of each tag variable.
              Configuration <b>separator</b> specifies a piece of code used to join the  generated  <b>format</b>  pieces  for
              different tag variables.

       <b>/*!svars:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/,</b> <b>/*!mvars:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/</b> <b>or</b>
       <b>%{svars[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%},</b> <b>%{mvars[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%{</b>
              Blocks  that specify a template piece of code that is expanded for each s-tag/m-tag that is either
              explicitly mentioned by the rules (with <b>--tags</b> option) or implicitly  generated  by  re2zig  (with
              <b>--captvars</b>  or  <b>--posix-captvars</b>  options). An optional list of block names specifies which blocks
              should be included when computing the set of tags (if the list is empty, all blocks are included).
              There are two optional configurations: <b>format</b> and <b>separator</b>.   Configuration  <b>format</b>  specifies  a
              template  string  where  <b>@@{tag}</b>  (or  <b>@@</b>  for  short)  is  replaced  with  the  name of each tag.
              Configuration <b>separator</b> specifies a piece of code used to join the  generated  <b>format</b>  pieces  for
              different tags.

       <b>/*!getstate:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{getstate[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%}</b>
              A  block  that  generates  conditional  dispatch  on the lexer state (it requires <b>--storable-state</b>
              option). An optional list of block names specifies which blocks should be included  in  the  state
              dispatch.  The  default  transition goes to the start label of the first block on the list. If the
              list is empty, all blocks are included, and the default transition goes to the first block in  the
              file that has a start label.  This block type is incompatible with the <b>--loop-switch</b> option, as it
              requires cross-block transitions that are unsupported without <b>goto</b> or function calls.

       <b>/*!conditions:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/,</b> <b>/*!types:re2c...</b> <b>*/</b> <b>or</b>
       <b>%{conditions[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%},</b> <b>%{types...</b> <b>%}</b>
              A  block  that generates condition enumeration (it requires <b>--conditions</b> option). An optional list
              of block names specifies which blocks should be included when computing the set of conditions  (if
              the  list  is  empty,  all  blocks are included).  By default the generated code is an enumeration
              <b>YYCONDTYPE</b>. It can be customized with optional configurations <b>format</b> and <b>separator</b>.  Configuration
              <b>format</b> specifies a template string where <b>@@{cond}</b> (or <b>@@</b> for short) is replaced with the  name  of
              each  condition,  and  <b>@@{num}</b>  is replaced with a numeric index of that condition.  Configuration
              <b>separator</b> specifies a piece of code used  to  join  the  generated  <b>format</b>  pieces  for  different
              conditions.

       <b>/*!include:re2c</b> <b>&lt;file&gt;</b> <b>*/</b> <b>or</b> <b>%{include</b> <b>&lt;file&gt;</b> <b>%}</b>
              This  block allows one to include <b>&lt;file&gt;</b>, which must be a double-quoted file path. The contents of
              the file are literally substituted in place of the block, in the same way  as  <b>#include</b>  works  in
              C/C++.  This  block  can  be  used  together  with  the  <b>--depfile</b> option to generate build system
              dependencies on the included files.

       <b>/*!header:re2c:on*/</b> <b>or</b> <b>%{header:on</b> <b>%}</b>
              This block marks the start of header file. Everything after it and up to the following  <b>header:off</b>
              block  is  processed  by  re2zig  and  written  to the header file specified with <b>-t</b> <b>--type-header</b>
              option.

       <b>/*!header:re2c:off*/</b> <b>or</b> <b>%{header:off</b> <b>%}</b>
              This block marks the end of header file started with <b>header:on*/</b> block.

       <b>/*!ignore:re2c</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{ignore</b> <b>...</b> <b>%}</b>
              A block which contents are ignored and removed from the output file.

   <b>Configurations</b>
       Here is a full list of configurations supported by re2zig:

       <b>re2c:api,</b> <b>re2c:input</b>
              Same as the <b>--api</b> option.

       <b>re2c:api:sigil</b>
              Specify the marker ("sigil") that is used for argument placeholders in  the  API  primitives.  The
              default  is <b>@@</b>. A placeholder starts with sigil followed by the argument name in curly braces. For
              example, if sigil is set to <b>$</b>, then placeholders will have the form <b>${name}</b>. Single-argument  APIs
              may  use  shorthand  notation without the name in braces. This option can be overridden by options
              for individual API primitives, e.g.  <b>re2c:YYFILL@len</b> for <b>YYFILL</b>.

       <b>re2c:api:style</b>
              Specify API style. Possible values are <b>functions</b> (the default for C) and  <b>free-form</b>  (the  default
              for  Go  and  Rust).   In  <b>functions</b>  style  API primitives are generated with an argument list in
              parentheses following the name of the primitive. The arguments are provided only for autogenerated
              parameters (such as the number of characters passed to <b>YYFILL</b>), but  not  for  the  general  lexer
              context,  so  the  primitives  behave  more  like  macros in C/C++ or closures in Go and Rust.  In
              free-form style API primitives do not have a  fixed  form:  they  should  be  defined  as  strings
              containing  free-form  pieces  of code with interpolated variables of the form <b>@@{var}</b> or <b>@@</b> (they
              correspond to arguments in  function-like  style).   This  configuration  may  be  overridden  for
              individual API primitives, see for example <b>re2c:YYFILL:naked</b> configuration for <b>YYFILL</b>.

       <b>re2c:bit-vectors,</b> <b>re2c:flags:bit-vectors,</b> <b>re2c:flags:b</b>
              Same as the <b>--bit-vectors</b> option, but can be configured on per-block basis.

       <b>re2c:captures,</b> <b>re2c:leftmost-captures</b>
              Same as the <b>--leftmost-captures</b> option, but can be configured on per-block basis.

       <b>re2c:captvars,</b> <b>re2c:leftmost-captvars</b>
              Same as the <b>--leftmost-captvars</b> option, but can be configured on per-block basis.

       <b>re2c:case-insensitive,</b> <b>re2c:flags:case-insensitive</b>
              Same as the <b>--case-insensitive</b> option, but can be configured on per-block basis.

       <b>re2c:case-inverted,</b> <b>re2c:flags:case-inverted</b>
              Same as the <b>--case-inverted</b> option, but can be configured on per-block basis.

       <b>re2c:case-ranges,</b> <b>re2c:flags:case-ranges</b>
              Same as the <b>--case-ranges</b> option, but can be configured on per-block basis.

       <b>re2c:computed-gotos,</b> <b>re2c:flags:computed-gotos,</b> <b>re2c:flags:g</b>
              Same as the <b>--computed-gotos</b> option, but can be configured on per-block basis.

       <b>re2c:computed-gotos:threshold,</b> <b>re2c:cgoto:threshold</b>
              If  computed <b>goto</b> is used, this configuration specifies the complexity threshold that triggers the
              generation of jump tables instead of nested <b>if</b> statements and bitmaps. The default value is <b>9</b>.

       <b>re2c:cond:abort</b>
              If set to a positive integer value, the default case in the generated  condition  dispatch  aborts
              program execution.

       <b>re2c:cond:goto</b>
              Specifies a piece of code used for the autogenerated shortcut rules <b>:=&gt;</b> in conditions. The default
              is  <b>goto</b>  <b>@@;</b>.   The  <b>@@</b>  placeholder  is  substituted  with  condition  name  (see configurations
              <b>re2c:api:sigil</b> and <b>re2c:cond:goto@cond</b>).

       <b>re2c:cond:goto@cond</b>
              Specifies the sigil used for argument substitution in <b>re2c:cond:goto</b> definition. The default value
              is <b>@@</b>.  Overrides the more generic <b>re2c:api:sigil</b> configuration.

       <b>re2c:cond:divider</b>
              Defines    the    divider    for    condition    blocks.     The    default    value     is     <b>/*</b>
              <b>***********************************</b>  <b>*/</b>.   Placeholders  are  substituted with condition name (see
              <b>re2c:api;sigil</b> and <b>re2c:cond:divider@cond</b>).

       <b>re2c:cond:divider@cond</b>
              Specifies the sigil used for argument substitution in <b>re2c:cond:divider</b> definition. The default is
              <b>@@</b>.  Overrides the more generic <b>re2c:api:sigil</b> configuration.

       <b>re2c:cond:prefix,</b> <b>re2c:condprefix</b>
              Specifies the prefix used for condition labels.  The default is <b>yyc_</b>.

       <b>re2c:cond:enumprefix,</b> <b>re2c:condenumprefix</b>
              Specifies the prefix used for condition identifiers.  The default is <b>yyc</b>.

       <b>re2c:debug-output,</b> <b>re2c:flags:debug-output,</b> <b>re2c:flags:d</b>
              Same as the <b>--debug-output</b> option, but can be configured on per-block basis.

       <b>re2c:empty-class,</b> <b>re2c:flags:empty-class</b>
              Same as the <b>--empty-class</b> option, but can be configured on per-block basis.

       <b>re2c:encoding:ebcdic,</b> <b>re2c:flags:ecb,</b> <b>re2c:flags:e</b>
              Same as the <b>--ebcdic</b> option, but can be configured on per-block basis.

       <b>re2c:encoding:ucs2,</b> <b>re2c:flags:wide-chars,</b> <b>re2c:flags:w</b>
              Same as the <b>--ucs2</b> option, but can be configured on per-block basis.

       <b>re2c:encoding:utf8,</b> <b>re2c:flags:utf-8,</b> <b>re2c:flags:8</b>
              Same as the <b>--utf8</b> option, but can be configured on per-block basis.

       <b>re2c:encoding:utf16,</b> <b>re2c:flags:utf-16,</b> <b>re2c:flags:x</b>
              Same as the <b>--utf16</b> option, but can be configured on per-block basis.

       <b>re2c:encoding:utf32,</b> <b>re2c:flags:unicode,</b> <b>re2c:flags:u</b>
              Same as the <b>--utf32</b> option, but can be configured on per-block basis.

       <b>re2c:encoding-policy,</b> <b>re2c:flags:encoding-policy</b>
              Same as the <b>--encoding-policy</b> option, but can be configured on per-block basis.

       <b>re2c:eof</b>
              Specifies the sentinel symbol used with the end-of-input rule <b>$</b>. The default value is <b>-1</b>  (<b>$</b>  rule
              is  not  used).  Other  possible  values  include  all  valid code units. Only decimal numbers are
              recognized.

       <b>re2c:fn:sep</b>
              Specifies separator used in <b>YYFN</b> elements (defaults to semicolon).

       <b>re2c:header,</b> <b>re2c:flags:type-header,</b> <b>re2c:flags:t</b>
              Specifies the name of the generated header file relative to the directory of the output file. Same
              as the <b>--header</b> option except that the file path is relative.

       <b>re2c:indent:string</b>
              Specifies the string used for indentation. The default is a  single  tab  character  <b>"\t"</b>.  Indent
              string  should  contain  whitespace  characters  only.   To disable indentation entirely, set this
              configuration to an empty string.

       <b>re2c:indent:top</b>
              Specifies the minimum amount of indentation to use. The default value is zero. The value should be
              a non-negative integer number.

       <b>re2c:invert-captures</b>
              Same as the <b>--invert-captures</b> option, but can be configured on per-block basis.

       <b>re2c:label:prefix,</b> <b>re2c:labelprefix</b>
              Specifies the prefix used for DFA state labels. The default is <b>yy</b>.

       <b>re2c:label:start,</b> <b>re2c:startlabel</b>
              Controls the generation of a block start label. The default value is zero, which  means  that  the
              start  label  is  generated  only  if  it  is  used. An integer value greater than zero forces the
              generation of start label even if it is unused by the lexer. A  string  value  also  forces  start
              label  generation and sets the label name to the specified string. This configuration applies only
              to the current block (it is reset to default for the next block).

       <b>re2c:label:yyFillLabel</b>
              Specifies the prefix of <b>YYFILL</b> labels used with <b>re2c:eof</b> and in storable state mode.

       <b>re2c:label:yyloop</b>
              Specifies the name of the label marking the start of the lexer loop with <b>--loop-switch</b> option. The
              default is <b>yyloop</b>.

       <b>re2c:label:yyNext</b>
              Specifies the name of the optional label that follows <b>YYGETSTATE</b> switch  in  storable  state  mode
              (enabled with <b>re2c:state:nextlabel</b>). The default is <b>yyNext</b>.

       <b>re2c:lookahead,</b> <b>re2c:flags:lookahead</b>
              Deprecated (see the deprecated <b>--no-lookahead</b> option).

       <b>re2c:monadic</b>
              If  set to non-zero, the generated lexer will use monadic notation (this configuration is specific
              to Haskell).

       <b>re2c:nested-ifs,</b> <b>re2c:flags:nested-ifs,</b> <b>re2c:flags:s</b>
              Same as the <b>--nested-ifs</b> option, but can be configured on per-block basis.

       <b>re2c:posix-captures,</b> <b>re2c:flags:posix-captures,</b> <b>re2c:flags:P</b>
              Same as the <b>--posix-captures</b> option, but can be configured on per-block basis.

       <b>re2c:posix-captvars</b>
              Same as the <b>--posix-captvars</b> option, but can be configured on per-block basis.

       <b>re2c:tags,</b> <b>re2c:flags:tags,</b> <b>re2c:flags:T</b>
              Same as the <b>--tags</b> option, but can be configured on per-block basis.

       <b>re2c:tags:expression</b>
              Specifies the expression used for tag variables.  By default re2zig generates expressions  of  the
              form  <b>yyt&lt;N&gt;</b>.  This might be inconvenient, for example if tag variables are defined as fields in a
              struct. All occurrences of <b>@@{tag}</b> or <b>@@</b> are replaced with  the  actual  tag  name.  For  example,
              <b>re2c:tags:expression</b>  <b>=</b> <b>"s.@@";</b> results in expressions of the form <b>s.yyt&lt;N&gt;</b> in the generated code.
              See also <b>re2c:api:sigil</b> configuration.

       <b>re2c:tags:negative</b>
              Specifies the constant expression that is used for negative tag value (typically this would be  <b>-1</b>
              if tags are integer offsets in the input string, or null pointer if they are pointers).

       <b>re2c:tags:prefix</b>
              Specifies the prefix for tag variable names. The default is <b>yyt</b>.

       <b>re2c:sentinel</b>
              Specifies  the  sentinel  symbol used for the end-of-input checks (when bounds checks are disabled
              with <b>re2c:yyfill:enable</b> <b>=</b> <b>0;</b> and <b>re2c:eof</b> is not set). This configuration  does  not  affect  code
              generation: its purpose is to verify that the sentinel is not allowed in the middle of a rule, and
              ensure  that  the  lexer won't read past the end of buffer. The default value is <u>-1`</u> (in that case
              re2zig assumes that the sentinel is zero, which is the most common case). Only decimal numbers are
              recognized.

       <b>re2c:state:abort</b>
              If set to a positive integer value, the default  case  in  the  generated  state  dispatch  aborts
              program execution, and an explicit <b>-1</b> case contains transition to the start of the block.

       <b>re2c:state:nextlabel</b>
              Controls if the <b>YYGETSTATE</b> switch is followed by an <b>yyNext</b> label (the default value is zero, which
              corresponds to no label).  Alternatively one can use <b>re2c:label:start</b> to generate a specific start
              label,  or  an explicit <b>getstate</b> block to generate the <b>YYGETSTATE</b> switch separately from the lexer
              block.

       <b>re2c:unsafe,</b> <b>re2c:flags:unsafe</b>
              Same as the <b>--no-unsafe</b> option, but can be configured on per-block basis.   If  set  to  zero,  it
              suppresses  the generation of <b>unsafe</b> wrappers around <b>YYPEEK</b>. The default is non-zero (wrappers are
              generated).  This configuration is specific to Rust.

       <b>re2c:YYBACKUP,</b> <b>re2c:define:YYBACKUP</b>
              Defines generic API primitive <b>YYBACKUP</b>.

       <b>re2c:YYBACKUPCTX,</b> <b>re2c:define:YYBACKUPCTX</b>
              Defines generic API primitive <b>YYBACKUPCTX</b>.

       <b>re2c:YYCONDTYPE,</b> <b>re2c:define:YYCONDTYPE</b>
              Defines API primitive <b>YYCONDTYPE</b>.

       <b>re2c:YYCTYPE,</b> <b>re2c:define:YYCTYPE</b>
              Defines API primitive <b>YYCTYPE</b>.

       <b>re2c:YYCTXMARKER,</b> <b>re2c:define:YYCTXMARKER</b>
              Defines API primitive <b>YYCTXMARKER</b>.

       <b>re2c:YYCURSOR,</b> <b>re2c:define:YYCURSOR</b>
              Defines API primitive <b>YYCURSOR</b>.

       <b>re2c:YYDEBUG,</b> <b>re2c:define:YYDEBUG</b>
              Defines API primitive <b>YYDEBUG</b>.

       <b>re2c:YYFILL,</b> <b>re2c:define:YYFILL</b>
              Defines API primitive <b>YYFILL</b>.

       <b>re2c:YYFILL@len,</b> <b>re2c:define:YYFILL@len</b>
              Specifies the sigil  used  for  argument  substitution  in  <b>YYFILL</b>  definition.  Defaults  to  <b>@@</b>.
              Overrides the more generic <b>re2c:api:sigil</b> configuration.

       <b>re2c:YYFILL:naked,</b> <b>re2c:define:YYFILL:naked</b>
              Overrides  the  more  generic  <b>re2c:api:style</b> configuration for <b>YYFILL</b>.  Zero value corresponds to
              free-form API style.

       <b>re2c:YYFN</b>
              Defines API primitive <b>YYFN</b>.

       <b>re2c:YYINPUT</b>
              Defines API primitive <b>YYINPUT</b>.

       <b>re2c:YYGETCOND,</b> <b>re2c:define:YYGETCONDITION</b>
              Defines API primitive <b>YYGETCOND</b>.

       <b>re2c:YYGETCOND:naked,</b> <b>re2c:define:YYGETCONDITION:naked</b>
              Overrides the more generic <b>re2c:api:style</b> configuration for <b>YYGETCOND</b>. Zero value  corresponds  to
              free-form API style.

       <b>re2c:YYGETSTATE,</b> <b>re2c:define:YYGETSTATE</b>
              Defines API primitive <b>YYGETSTATE</b>.

       <b>re2c:YYGETSTATE:naked,</b> <b>re2c:define:YYGETSTATE:naked</b>
              Overrides  the more generic <b>re2c:api:style</b> configuration for <b>YYGETSTATE</b>. Zero value corresponds to
              free-form API style.

       <b>re2c:YYGETACCEPT,</b> <b>re2c:define:YYGETACCEPT</b>
              Defines API primitive <b>YYGETACCEPT</b>.

       <b>re2c:YYLESSTHAN,</b> <b>re2c:define:YYLESSTHAN</b>
              Defines generic API primitive <b>YYLESSTHAN</b>.

       <b>re2c:YYLIMIT,</b> <b>re2c:define:YYLIMIT</b>
              Defines API primitive <b>YYLIMIT</b>.

       <b>re2c:YYMARKER,</b> <b>re2c:define:YYMARKER</b>
              Defines API primitive <b>YYMARKER</b>.

       <b>re2c:YYMTAGN,</b> <b>re2c:define:YYMTAGN</b>
              Defines generic API primitive <b>YYMTAGN</b>.

       <b>re2c:YYMTAGP,</b> <b>re2c:define:YYMTAGP</b>
              Defines generic API primitive <b>YYMTAGP</b>.

       <b>re2c:YYPEEK,</b> <b>re2c:define:YYPEEK</b>
              Defines generic API primitive <b>YYPEEK</b>.

       <b>re2c:YYRESTORE,</b> <b>re2c:define:YYRESTORE</b>
              Defines generic API primitive <b>YYRESTORE</b>.

       <b>re2c:YYRESTORECTX,</b> <b>re2c:define:YYRESTORECTX</b>
              Defines generic API primitive <b>YYRESTORECTX</b>.

       <b>re2c:YYRESTORETAG,</b> <b>re2c:define:YYRESTORETAG</b>
              Defines generic API primitive <b>YYRESTORETAG</b>.

       <b>re2c:YYSETCOND,</b> <b>re2c:define:YYSETCONDITION</b>
              Defines API primitive <b>YYSETCOND</b>.

       <b>re2c:YYSETCOND@cond,</b> <b>re2c:define:YYSETCONDITION@cond</b>
              Specifies the sigil used for argument substitution in <b>YYSETCOND</b> definition. The default  value  is
              <b>@@</b>.  Overrides the more generic <b>re2c:api:sigil</b> configuration.

       <b>re2c:YYSETCOND:naked,</b> <b>re2c:define:YYSETCONDITION:naked</b>
              Overrides  the  more generic <b>re2c:api:style</b> configuration for <b>YYSETCOND</b>. Zero value corresponds to
              free-form API style.

       <b>re2c:YYSETSTATE,</b> <b>re2c:define:YYSETSTATE</b>
              Defines API primitive <b>YYSETSTATE</b>.

       <b>re2c:YYSETSTATE@state,</b> <b>re2c:define:YYSETSTATE@state</b>
              Specifies the sigil used for argument substitution in <b>YYSETSTATE</b> definition. The default value  is
              <b>@@</b>.  Overrides the more generic <b>re2c:api:sigil</b> configuration.

       <b>re2c:YYSETSTATE:naked,</b> <b>re2c:define:YYSETSTATE:naked</b>
              Overrides  the more generic <b>re2c:api:style</b> configuration for <b>YYSETSTATE</b>. Zero value corresponds to
              free-form API style.

       <b>re2c:YYSETACCEPT,</b> <b>re2c:define:YYSETACCEPT</b>
              Defines API primitive <b>YYSETACCEPT</b>.

       <b>re2c:YYSKIP,</b> <b>re2c:define:YYSKIP</b>
              Defines generic API primitive <b>YYSKIP</b>.

       <b>re2c:YYSHIFT,</b> <b>re2c:define:YYSHIFT</b>
              Defines generic API primitive <b>YYSHIFT</b>.

       <b>re2c:YYCOPYMTAG,</b> <b>re2c:define:YYCOPYMTAG</b>
              Defines generic API primitive <b>YYCOPYMTAG</b>.

       <b>re2c:YYCOPYSTAG,</b> <b>re2c:define:YYCOPYSTAG</b>
              Defines generic API primitive <b>YYCOPYSTAG</b>.

       <b>re2c:YYSHIFTMTAG,</b> <b>re2c:define:YYSHIFTMTAG</b>
              Defines generic API primitive <b>YYSHIFTMTAG</b>.

       <b>re2c:YYSHIFTSTAG,</b> <b>re2c:define:YYSHIFTSTAG</b>
              Defines generic API primitive <b>YYSHIFTSTAG</b>.

       <b>re2c:YYSTAGN,</b> <b>re2c:define:YYSTAGN</b>
              Defines generic API primitive <b>YYSTAGN</b>.

       <b>re2c:YYSTAGP,</b> <b>re2c:define:YYSTAGP</b>
              Defines generic API primitive <b>YYSTAGP</b>.

       <b>re2c:yyaccept,</b> <b>re2c:variable:yyaccept</b>
              Defines API primitive <b>yyaccept</b>.

       <b>re2c:yybm,</b> <b>re2c:variable:yybm</b>
              Defines API primitive <b>yybm</b>.

       <b>re2c:yybm:hex,</b> <b>re2c:variable:yybm:hex</b>
              If set to nonzero, bitmaps for the <b>--bit-vectors</b> option are generated in hexadecimal  format.  The
              default is zero (bitmaps are in decimal format).

       <b>re2c:yych,</b> <b>re2c:variable:yych</b>
              Defines API primitive <b>yych</b>.

       <b>re2c:yych:emit,</b> <b>re2c:variable:yych:emit</b>
              If set to zero, <b>yych</b> definition is not generated.  The default is non-zero.

       <b>re2c:yych:conversion,</b> <b>re2c:variable:yych:conversion</b>
              If  set  to  non-zero,  re2zig  automatically generates a conversion to <b>YYCTYPE</b> every time <b>yych</b> is
              read. The default is to zero (no conversion).

       <b>re2c:yych:literals,</b> <b>re2c:variable:yych:literals</b>
              Specifies the form of literals that <b>yych</b> is matched against. Possible values are: <b>char</b>  (character
              literals in single quotes, non-printable ones use escape sequences that start with backslash), <b>hex</b>
              (hexadecimal  integers)  and  <b>char_or_hex</b>  (a  mixture  of  both, character literals for printable
              characters and hexadecimal integers for others).

       <b>re2c:yyctable,</b> <b>re2c:variable:yyctable</b>
              Defines API primitive <b>yyctable</b>.

       <b>re2c:yynmatch,</b> <b>re2c:variable:yynmatch</b>
              Defines API primitive <b>yynmatch</b>.

       <b>re2c:yypmatch,</b> <b>re2c:variable:yypmatch</b>
              Defines API primitive <b>yypmatch</b>.

       <b>re2c:yytarget,</b> <b>re2c:variable:yytarget</b>
              Defines API primitive <b>yytarget</b>.

       <b>re2c:yystable,</b> <b>re2c:variable:yystable</b>
              Deprecated.

       <b>re2c:yystate,</b> <b>re2c:variable:yystate</b>
              Defines API primitive <b>yystate</b>.

       <b>re2c:yyfill,</b> <b>re2c:variable:yyfill</b>
              Defines API primitive <b>yyfill</b>.

       <b>re2c:yyfill:check</b>
              If set to zero, suppresses the generation of pre-<b>YYFILL</b> check for the number of  input  characters
              (the  <b>YYLESSTHAN</b> definition in generic API and the <b>YYLIMIT</b>-based comparison in C pointer API). The
              default is non-zero (generate the check).

       <b>re2c:yyfill:enable</b>
              If set to zero, suppresses the generation of <b>YYFILL</b> (together with the check). This should be used
              when the whole input fits into one piece of memory (there  is  no  need  for  buffering)  and  the
              end-of-input  checks do not rely on the <b>YYFILL</b> checks (e.g. if a sentinel character is used).  Use
              warnings (<b>-W</b> option) and <b>re2c:sentinel</b> configuration to verify that  the  generated  lexer  cannot
              read past the end of input.  The default is non-zero (<b>YYFILL</b> is enabled).

       <b>re2c:yyfill:parameter</b>
              If  set  to  zero,  suppresses the generation of parameter passed to <b>YYFILL</b>.  The parameter is the
              minimum number of characters that must be  supplied.   Defaults  to  non-zero  (the  parameter  is
              generated).  This configuration can be overridden with <b>re2c:YYFILL:naked</b> or <b>re2c:api:style</b>.

   <b>Regular</b> <b>expressions</b>
       re2zig uses the following syntax for regular expressions:

       <b>"foo"</b>  Case-sensitive string literal.

       <b>'foo'</b>  Case-insensitive string literal.

       <b>[a-xyz],</b> <b>[^a-xyz]</b>
              Character class (possibly negated).

       <b>.</b>      Any character except newline.

       <b>R</b> <b>\</b> <b>S</b>  Difference of character classes <b>R</b> and <b>S</b>.

       <b>R*</b>     Zero or more occurrences of <b>R</b>.

       <b>R+</b>     One or more occurrences of <b>R</b>.

       <b>R?</b>     Optional <b>R</b>.

       <b>R{n}</b>   Repetition of <b>R</b> exactly <b>n</b> times.

       <b>R{n,}</b>  Repetition of <b>R</b> at least <b>n</b> times.

       <b>R{n,m}</b> Repetition of <b>R</b> from <b>n</b> to <b>m</b> times.

       <b>(R)</b>    Just  <b>R</b>;  parentheses are used to override precedence. If submatch extraction is enabled, <b>(R)</b> is a
              capturing or a non-capturing group depending on <b>--invert-captures</b> option.

       <b>(!R)</b>   If submatch extraction is enabled, <b>(!R)</b> is a non-capturing  or  a  capturing  group  depending  on
              <b>--invert-captures</b> option.

       <b>R</b> <b>S</b>    Concatenation: <b>R</b> followed by <b>S</b>.

       <b>R</b> <b>|</b> <b>S</b>  Alternative: <b>R</b> <b>or</b> <b>S</b>.

       <b>R</b> <b>/</b> <b>S</b>  Lookahead: <b>R</b> followed by <b>S</b>, but <b>S</b> is not consumed.

       <b>name</b>   Regular expression defined as <b>name</b> (or literal string <b>"name"</b> in Flex compatibility mode).

       <b>{name}</b> Regular expression defined as <b>name</b> in Flex compatibility mode.

       <b>@stag</b>  An <u>s-tag</u>: saves the last input position at which <b>@stag</b> matches in a variable named <b>stag</b>.

       <b>#mtag</b>  An <u>m-tag</u>: saves all input positions at which <b>#mtag</b> matches in a variable named <b>mtag</b>.

       Character classes and string literals may contain the following escape sequences: <b>\a</b>, <b>\b</b>, <b>\f</b>, <b>\n</b>, <b>\r</b>, <b>\t</b>,
       <b>\v</b>, <b>\\</b>, octal escapes <b>\ooo</b> and hexadecimal escapes <b>\xhh</b>, <b>\uhhhh</b> and <b>\Uhhhhhhhh</b>.

   <b>Actions</b>
       Here is a list of predefined actions supported by re2zig:

       <b>!entry</b> <b>code</b>
              Entry  action  binds  a  user-defined block of <b>code</b> to the start state of the current finite state
              machine. If start conditions are  used,  the  entry  action  can  be  set  individually  for  each
              condition.  This  action  may  be used to perform initialization, e.g. to save start location of a
              lexeme.

       <b>!pre_rule</b> <b>code</b>
              Pre-rule action prepends a user-defined block of <b>code</b> to semantic actions  of  all  rules  in  the
              current  block (or condition, if start conditions are used). This action may be used to factor out
              the common part of all semantic actions (e.g. saving the end location of a lexeme).

       <b>!post_rule</b> <b>code</b>
              Post-rule action appends a user-defined block of <b>code</b> to semantic actions  of  all  rules  in  the
              current  block  (or condition, if start conditions are used). This action may be used to emit trap
              statements that guard against unintended control flow.

   <b>Directives</b>
       Here is a full list of directives supported by re2zig:

       <b>!use:name</b> <b>;</b>
              An in-block use directive that merges a previously defined rules block  with  the  specified  <b>name</b>
              into  the  current  block. Named definitions, configurations and rules of the referenced block are
              added to the current ones. Conflicts between overlapping rules and configurations are resolved  in
              the usual way: the first rule takes priority, and the latest configuration overrides the preceding
              ones.  One  exception  is the special rules <b>*</b>, <b>$</b> and <b>&lt;!&gt;</b> for which a block-local definition always
              takes priority. A use directive can be placed  anywhere  inside  of  a  block,  and  multiple  use
              directives are allowed.

       <b>!include</b> <b>file</b> <b>;</b>
              This  directive  is  the  same as <b>include</b> block: it inserts <b>file</b> contents verbatim in place of the
              directive.

   <b>Program</b> <b>interface</b>
       The generated code interfaces with the outer program with the help of <u>primitives</u>,  collectively  referred
       to  as the <u>API</u>.  Which primitives should be defined for a particular program depends on multiple factors,
       including the complexity of regular expressions, input representation, buffering and the use  of  various
       features.  All  the  necessary primitives should be defined by the user in the form of macros, functions,
       variables or any other suitable form  that  makes  the  generated  code  syntactically  and  semantically
       correct.  re2zig  does  not  (and  cannot)  check  the  definitions, so if anything is missing or defined
       incorrectly, the generated program may have  compile-time  or  run-time  errors.   This  manual  provides
       examples of API definitions in the most common cases.

       re2zig has three API flavors that define the core set of primitives used by a program:

       <b>Simple</b> <b>API</b>
              This  is  the  default  API  for the Zig backend. It consists of the following primitives: <b>YYINPUT</b>
              (which should be defined as a sequence of code units,  e.g.  a  string)  and  <b>YYCURSOR</b>,  <b>YYMARKER</b>,
              <b>YYCTXMARKER</b>, <b>YYLIMIT</b> (which should be defined as indices in <b>YYINPUT</b>).

       <b>Record</b> <b>API</b>
              Record  API  is  useful  in cases when lexer state must be stored in a struct.  It is enabled with
              <b>--api</b> <b>record</b> option or <b>re2c:api</b> <b>=</b> <b>record</b> configuration. This API consists of a  variable  <b>yyrecord</b>
              (the  name  can  be  overridden with <b>re2c:yyrecord</b>) that should be defined as a struct with fields
              <b>yyinput</b>, <b>yycursor</b>, <b>yymarker</b>, <b>yyctxmarker</b>, <b>yylimit</b> (only the fields used by the generated code need
              to be defined, and their names can be configured).

       <b>Generic</b> <b>API</b>
              This is the most flexible API. It is enabled with <b>--api</b>  <b>generic</b>  option  or  <b>re2c:api</b>  <b>=</b>  <b>generic</b>
              configuration.    It  contains  primitives  for  generic  operations:  <b>YYPEEK</b>,  <b>YYSKIP</b>,  <b>YYBACKUP</b>,
              <b>YYBACKUPCTX</b>, <b>YYSTAGP</b>, <b>YYSTAGN</b>, <b>YYMTAGP</b>, <b>YYMTAGN</b>, <b>YYRESTORE</b>, <b>YYRESTORECTX</b>,  <b>YYRESTORETAG</b>,  <b>YYSHIFT</b>,
              <b>YYSHIFTSTAG</b>, <b>YYSHIFTMTAG</b>, <b>YYLESSTHAN</b>.

       Here  is  a full list of API primitives that may be used by the generated code in order to interface with
       the outer program.

       <b>YYCTYPE</b>
              The type of the input characters (code units).  For ASCII, EBCDIC and UTF-8 encodings it should be
              1-byte unsigned integer.  For UTF-16 or UCS-2 it should be 2-byte unsigned integer. For UTF-32  it
              should be 4-byte unsigned integer.

       <b>YYCURSOR</b>
              An  l-value  that  stores  the current input position (a pointer or an integer offset in <b>YYINPUT</b>).
              Initially <b>YYCURSOR</b> should point to the first input character, and later  it  is  advanced  by  the
              generated  code.  When  a  rule  matches,  <b>YYCURSOR</b>  position  is  the  one after the last matched
              character.

       <b>YYLIMIT</b>
              An r-value that stores the end of input position (a pointer or  an  integer  offset  in  <b>YYINPUT</b>).
              Initially <b>YYLIMIT</b> should point to the position after the last available input character. It is not
              changed  by  the  generated  code. The lexer compares <b>YYCURSOR</b> to <b>YYLIMIT</b> in order to determine if
              there are enough input characters left.

       <b>YYMARKER</b>
              An l-value that stores the position of the latest matched rule (a pointer or an integer offset  in
              <b>YYINPUT</b>).  It  is  used  to  restore the <b>YYCURSOR</b> position if the longer match fails and the lexer
              needs to rollback.  Initialization is not needed.

       <b>YYCTXMARKER</b>
              An l-value that stores the position of the trailing context (a pointer or  an  integer  offset  in
              <b>YYINPUT</b>).  No  initialization is needed. <b>YYCTXMARKER</b> is needed only if the lookahead operator <b>/</b> is
              used.

       <b>YYFILL</b> A generic API primitive with one variable <b>len</b>.  <b>YYFILL</b> should provide  at  least  <b>len</b>  more  input
              characters or fail.  If <b>re2c:eof</b> is used, then <b>len</b> is always <b>1</b> and  <b>YYFILL</b> should always return to
              the  calling  function; zero return value indicates success.  If <b>re2c:eof</b> is not used, then <b>YYFILL</b>
              return value is ignored and it should  not  return  on  failure.  The  maximum  value  of  <b>len</b>  is
              <b>YYMAXFILL</b>.

       <b>YYFN</b>   A  primitive that defines function prototype in <b>--recursive-functions</b> code model. Its value should
              be an array of one or more strings, where each string contains two or three  components  separated
              by  the  string  specified  in  <b>re2c:fn:sep</b> configuration (typically a semicolon). The first array
              element defines function name and return type (empty for a void  function).   Subsequent  elements
              define  function  arguments: first, the expression for the argument used in function body (usually
              just a name); second, argument type; third, an optional formal parameter (it defaults to the first
              component - usually both the argument and the parameter are the same identifier).

       <b>YYINPUT</b>
              An r-value that stores the current input character sequence (string, buffer, etc.).

       <b>YYMAXFILL</b>
              An integral constant equal to the maximum value of the argument to <b>YYFILL</b>.  It  can  be  generated
              with a <b>max</b> block.

       <b>YYLESSTHAN</b>
              A generic API primitive with one variable <b>len</b>.  It should be defined as an r-value of boolean type
              that equals <b>true</b> if and only if there are less than <b>len</b> input characters left.

       <b>YYPEEK</b> A  generic  API  primitive  with no variables.  It should be defined as an r-value of type <b>YYCTYPE</b>
              that is equal to the character at the current input position.

       <b>YYSKIP</b> A generic API primitive that should advance the current input position by one code unit.

       <b>YYBACKUP</b>
              A generic API primitive that should save the current input position (to be restored with <b>YYRESTORE</b>
              later).

       <b>YYRESTORE</b>
              A generic API primitive that should restore the current input  position  to  the  value  saved  by
              <b>YYBACKUP</b>.

       <b>YYBACKUPCTX</b>
              A  generic  API  primitive  that  should  save  the  current input position as the position of the
              trailing context (to be restored with <b>YYRESTORECTX</b> later).

       <b>YYRESTORECTX</b>
              A generic API primitive that should restore the trailing context position saved with <b>YYBACKUPCTX</b>.

       <b>YYRESTORETAG</b>
              A generic API primitive with one variable <b>tag</b> that should restore the trailing context position to
              the value of <b>tag</b>.

       <b>YYSTAGP</b>
              A generic API primitive with one variable <b>tag</b>, where <b>tag</b> can be a pointer or an offset in  <b>YYINPUT</b>
              (see  submatch  extraction  section  for  details).  <b>YYSTAGP</b>  should  set <b>tag</b> to the current input
              position.

       <b>YYSTAGN</b>
              A generic API primitive with one variable <b>tag</b>, where <b>tag</b> can be a pointer or an offset in  <b>YYINPUT</b>
              (see  submatch  extraction  section  for  details).  <b>YYSTAGN</b>  should  to  set  <b>tag</b> to a value that
              represents non-existent input position.

       <b>YYMTAGP</b>
              A generic API primitive with one variable <b>tag</b>.  <b>YYMTAGP</b> should append the current position to  the
              submatch history of <b>tag</b> (see the submatch extraction section for details.)

       <b>YYMTAGN</b>
              A  generic  API  primitive  with  one variable <b>tag</b>.  <b>YYMTAGN</b> should append a value that represents
              non-existent input position position to the submatch history of <b>tag</b> (see the  submatch  extraction
              section for details.)

       <b>YYSHIFT</b>
              A  generic  API  primitive with one variable <b>shift</b> that should shift the current input position by
              <b>shift</b> characters (the shift value may be negative).

       <b>YYCOPYSTAG</b>
              A generic API primitive with two variables, <b>lhs</b> and <b>rhs</b> that  should  copy  right-hand-side  s-tag
              variable  <b>rhs</b>  to  the  left-hand-side s-tag variable <b>lhs</b>. For most languages this primitive has a
              default definition that assigns <b>lhs</b> to <b>rhs</b>.

       <b>YYCOPYMTAG</b>
              A generic API primitive with two variables, <b>lhs</b> and <b>rhs</b> that  should  copy  right-hand-side  m-tag
              variable  <b>rhs</b>  to  the  left-hand-side m-tag variable <b>lhs</b>. For most languages this primitive has a
              default definition that assigns <b>lhs</b> to <b>rhs</b>.

       <b>YYSHIFTSTAG</b>
              A generic  API primitive with two variables, <b>tag</b> and <b>shift</b> that should shift  <b>tag</b>  by  <b>shift</b>  code
              units (the shift value may be negative).

       <b>YYSHIFTMTAG</b>
              A  generic  API  primitive with two variables, <b>tag</b> and <b>shift</b> that should shift the latest value in
              the history of <b>tag</b> by <b>shift</b> code units (the shift value may be negative).

       <b>YYMAXNMATCH</b>
              An integral constant equal to the maximal number of POSIX  capturing  groups  in  a  rule.  It  is
              generated with a <b>maxnmatch</b> block.

       <b>YYCONDTYPE</b>
              The  type  of  the  condition  enum.  It can be generated either with <b>conditions</b> block or <b>--header</b>
              option.

       <b>YYGETACCEPT</b>
              A primitive with one variable <b>var</b> that stores numeric selector of  the  accepted  rule.  For  most
              languages this primitive has a default definition that reads from <b>var</b>.

       <b>YYSETACCEPT</b>
              A  primitive  with  two  variables:  <b>var</b>  (an l-value that stores numeric selector of the accepted
              rule), and <b>val</b> (the value of selector). For most languages this primitive has a default definition
              that assigns <b>var</b> to <b>val</b>.

       <b>YYGETCOND</b>
              An r-value of type <b>YYCONDTYPE</b> that is equal to the current condition identifier.

       <b>YYSETCOND</b>
              A primitive with one variable <b>cond</b> that should set the current condition identifier to <b>cond</b>.

       <b>YYGETSTATE</b>
              An r-value of integer type that is equal to the current lexer state. It should be  initialized  to
              <b>-1</b>.

       <b>YYSETSTATE</b>
              A primitive with one variable <b>state</b> that should set the current lexer state to <b>state</b>.

       <b>YYDEBUG</b>
              This primitive is generated only with <b>-d</b>, <b>--debug-output</b> option.  Its purpose is to add logging to
              the  generated  code  (typical  <b>YYDEBUG</b>  definition  is a print statement). <b>YYDEBUG</b> statements are
              generated in every state and have two variables: <b>state</b> (either a DFA state index or <b>-1</b>) and <b>symbol</b>
              (the current input symbol).

       <b>yyaccept</b>
              An l-value of unsigned integral type that stores the number  of  the  latest  matched  rule.  User
              definition is necessary only with <b>--storable-state</b> option.

       <b>yybm</b>   A  table  containing  compressed bitmaps for up to 8 transitions (used with the <b>--bitmaps</b> option).
              The table contains 256 elements and is indexed by 1-byte code units. Each 8-bit  element  combines
              boolean  values for up to 8 transitions. k-Th bit of n-th element is true iff n-th code unit is in
              the range of k-th transition. The idea of this bitmap is to replace many  <u>if</u>  branches  or  <u>switch</u>
              cases with one check of a single bit in the table.

       <b>yych</b>   An  l-value of type <b>YYCTYPE</b> that stores the current input character.  User definition is necessary
              only with <b>-f</b> <b>--storable-state</b> option.

       <b>yyctable</b>
              Jump table generated  for  the  initial  condition  dispatch  (enabled  with  the  combination  of
              <b>--conditions</b> and <b>--computed-gotos</b> options).

       <b>yyfill</b> An  l-value  that  stores  the  result  of  <b>YYFILL</b> call (this may be necessary for pure functional
              languages, where <b>YYFILL</b> is a monadic function with complex return value).

       <b>yynmatch</b>
              An l-value of unsigned integral type that stores the number  of  POSIX  capturing  groups  in  the
              matched rule.  Used only with <b>-P</b> <b>--posix-captures</b> option.

       <b>yypmatch</b>
              An  array  of  l-values  that  are  used  to  hold  the  tag values corresponding to the capturing
              parentheses in the matching rule. Array length must be at least <b>yynmatch</b> <b>*</b> <b>2</b> (usually  <b>YYMAXNMATCH</b>
              <b>*</b> <b>2</b> is a good choice).  Used only with <b>-P</b> <b>--posix-captures</b> option.

       <b>yystable</b>
              Deprecated.

       <b>yystate</b>
              An l-value used with the <b>--loop-switch</b> option to store the current DFA state.

       <b>yytarget</b>
              Jump  table  that  contains  jump targets (label addresses) for all transitions from a state. This
              table is local to each state. Generation of  <b>yytarget</b>  tables  is  enabled  with  <b>--computed-gotos</b>
              option.

   <b>Options</b>
       Some of the options have corresponding configurations, others are global and cannot be changed after re2c
       starts  reading  the  input  file.  Debug options generally require building re2c in debug configuration.
       Internal options are useful for experimenting with the algorithms used in re2c.

       <b>-?</b> <b>--help</b> <b>-h</b>
              Show help message.

       <b>--api</b> <b>&lt;simple</b> <b>|</b> <b>record</b> <b>|</b> <b>generic&gt;</b>
              Specify the API used by the generated code to interface  with  used-defined  code.  Option  <b>simple</b>
              shold  be  used in simple cases when there's no need for buffer refilling and storing lexer state.
              Option <b>record</b> should be used when lexer state needs to be  stored  in  a  record  (struct,  class,
              etc.).   Option  <b>generic</b>  should be used in complex cases when the other two APIs are not flexible
              enough.

       <b>--bit-vectors</b> <b>-b</b>
              Optimize conditional jumps using bit masks.  This option implies <b>--nested-ifs</b>.

       <b>--captures,</b> <b>--leftmost-captures</b>
              Enable submatch extraction with leftmost greedy capturing groups. The result is collected into  an
              array  <b>yybmatch</b>  of  capacity <b>2</b> <b>*</b> <b>YYMAXNMATCH</b>, and <b>yynmatch</b> is set to the number of groups for the
              matching rule.

       <b>--captvars,</b> <b>--leftmost-captvars</b>
              Enable submatch extraction with leftmost greedy capturing groups. The  result  is  collected  into
              variables <b>yytl&lt;k&gt;</b>, <b>yytr&lt;k&gt;</b> for <b>k</b>-th capturing group.

       <b>--case-insensitive</b>
              Treat single-quoted and double-quoted strings as case-insensitive.

       <b>--case-inverted</b>
              Invert  the  meaning  of  single-quoted  and double-quoted strings: treat single-quoted strings as
              case-sensitive and double-quoted strings as case-insensitive.

       <b>--case-ranges</b>
              Collapse consecutive cases in a switch statements into a range of the  form  <b>low</b>  <b>...</b>  <b>high</b>.  This
              syntax  is  a C/C++ language extension that is supported by compilers like GCC, Clang and Tcc. The
              main advantage over using single cases is smaller  generated  code  and  faster  generation  time,
              although  for  some  compilers  like  Tcc  it also results in smaller binary size.  This option is
              supported only for C.

       <b>--computed-gotos</b> <b>-g</b>
              Optimize conditional jumps using non-standard "computed goto" extension (which must  be  supported
              by  the  compiler).  re2zig  generates jump tables only in complex cases with a lot of conditional
              branches. Complexity threshold can be configured with <b>cgoto:threshold</b> configuration.  This  option
              implies <b>--bit-vectors</b>. It is supported only for C.

       <b>--conditions</b> <b>--start-conditions</b> <b>-c</b>
              Enable  support  of Flex-like "conditions": multiple interrelated lexers within one block. This is
              an alternative to manually specifying different re2zig blocks  connected  with  <b>goto</b>  or  function
              calls.

       <b>--depfile</b> <b>FILE</b>
              Write  dependency  information to <b>FILE</b> in the form of a Makefile rule <b>&lt;output-file&gt;</b> <b>:</b> <b>&lt;input-file&gt;</b>
              <b>[include-file</b> <b>...]</b>. This allows one to  track  build  dependencies  in  the  presence  of  <b>include</b>
              blocks/directives,  so that updating include files triggers regeneration of the output file.  This
              option depends on the <b>--output</b> option.

       <b>--ebcdic</b> <b>--ecb</b> <b>-e</b>
              Generate a lexer that reads input in EBCDIC encoding. re2zig assumes that the character range is 0
              -- 0xFF and character size is 1 byte.

       <b>--empty-class</b> <b>&lt;match-empty</b> <b>|</b> <b>match-none</b> <b>|</b> <b>error&gt;</b>
              Define the way re2zig treats empty character classes. With <b>match-empty</b> (the default)  empty  class
              matches  empty  input  (which is illogical, but backwards-compatible). With <b>match-none</b> empty class
              always fails to match.  With <b>error</b> empty class raises a compilation error.

       <b>--encoding-policy</b> <b>&lt;fail</b> <b>|</b> <b>substitute</b> <b>|</b> <b>ignore&gt;</b>
              Define the way re2zig treats Unicode surrogates.  With <b>fail</b> re2zig aborts with  an  error  when  a
              surrogate is encountered.  With <b>substitute</b> re2zig silently replaces surrogates with the error code
              point  0xFFFD.  With  <b>ignore</b>  (the  default)  re2zig  treats surrogates as normal code points. The
              Unicode standard says that  standalone  surrogates  are  invalid,  but  real-world  libraries  and
              programs behave in different ways.

       <b>--flex-syntax</b> <b>-F</b>
              Partial  support for Flex syntax: in this mode named definitions don't need the equal sign and the
              terminating semicolon, and when used they must be surrounded  with  curly  braces.  Names  without
              curly braces are treated as double-quoted strings.

       <b>--goto-label</b>
              Use  "goto/label"  code  model:  encode  DFA  in  form  of labeled code blocks connected with <b>goto</b>
              transitions across blocks. This is only supported for languages that have a <b>goto</b> statement.

       <b>--header</b> <b>--type-header</b> <b>-t</b> <b>HEADER</b>
              Generate a <b>HEADER</b> file. The contents of the file can be specified using special  blocks  <b>header:on</b>
              and  <b>header:off</b>.  If  conditions  are  used,  the  generated  header  will  have  a condition enum
              automatically appended to it (unless there is an explicit <b>conditions</b> block).

       <b>-I</b> <b>PATH</b>
              Add <b>PATH</b> to the list of locations which are used when searching for include files. This option  is
              useful  in  combination with <b>include</b> block or directive. re2zig looks for <b>FILE</b> in the directory of
              the parent file and in the include locations specified with <b>-I</b> option.

       <b>--input</b> <b>&lt;default</b> <b>|</b> <b>custom&gt;</b>
              Deprecated alias for <b>--api</b>. Option <b>default</b> corresponds to <b>simple</b> (it is  indeed  the  default  for
              most backends, but not for all). Option <b>custom</b> corresponds to <b>generic</b>.

       <b>--input-encoding</b> <b>&lt;ascii</b> <b>|</b> <b>utf8&gt;</b>
              Specify  the way re2zig parses regular expressions.  With <b>ascii</b> (the default) re2zig handles input
              as ASCII-encoded: any sequence of code units is a sequence of standalone 1-byte characters.   With
              <b>utf8</b> re2zig handles input as UTF8-encoded and recognizes multibyte characters.

       <b>--invert-captures</b>
              Invert  the  meaning  of  capturing and non-capturing groups. By default <b>(...)</b> is capturing and <b>(!</b>
              <b>...)</b> is non-capturing. With this option <b>(!</b> <b>...)</b> is capturing and <b>(...)</b> is non-capturing.

       <b>--lang</b> <b>&lt;none</b> <b>|</b> <b>c</b> <b>|</b> <b>d</b> <b>|</b> <b>go</b> <b>|</b> <b>haskell</b> <b>|</b> <b>java</b> <b>|</b> <b>js</b> <b>|</b> <b>ocaml</b> <b>|</b> <b>python</b> <b>|</b> <b>rust</b> <b>|</b> <b>v</b> <b>|</b> <b>zig&gt;</b>
              Specify the target language. Supported languages are C, D, Go, Haskell, Java, JS,  OCaml,  Python,
              Rust, V, Zig (more languages can be added via user-defined syntax files, see the <b>--syntax</b> option).
              Option <b>none</b> disables default suntax configs, so that the target language is undefined.

       <b>--location-format</b> <b>&lt;gnu</b> <b>|</b> <b>msvc&gt;</b>
              Specify  location  format  in  messages.  With <b>gnu</b> locations are printed as 'filename:line:column:
              ...'.  With <b>msvc</b> locations are printed as 'filename(line,column) ...'.  The default is <b>gnu</b>.

       <b>--loop-switch</b>
              Use "loop/switch" code model: encode DFA in  form  of  a  loop  over  a  switch  statement,  where
              individual  states  are  switch  cases. State is stored in a variable <b>yystate</b>. Transitions between
              states update <b>yystate</b> to the case label of the destination state and  continue  execution  to  the
              head of the loop.

       <b>--nested-ifs</b> <b>-s</b>
              Use  nested  <b>if</b> statements instead of <b>switch</b> statements in conditional jumps. This usually results
              in more efficient code with non-optimizing compilers.

       <b>--no-debug-info</b> <b>-i</b>
              Do not output line directives. This may be useful when the generated code is stored in  a  version
              control system (to avoid huge autogenerated diffs on small changes).

       <b>--no-generation-date</b>
              Suppress date output in the generated file.

       <b>--no-version</b>
              Suppress version output in the generated file.

       <b>--no-unsafe</b>
              Do  not  generate  <b>unsafe</b>  wrapper  over <b>YYPEEK</b> (this option is specific to Rust). For performance
              reasons <b>YYPEEK</b> should avoid bounds-checking, as the lexer already performs end-of-input checks  in
              a  more  efficient  way.  The user may choose to provide a safe <b>YYPEEK</b> definition, or a definition
              that is unsafe only in release builds, in  which  case  the  <b>--no-unsafe</b>  option  helps  to  avoid
              warnings about redundant <b>unsafe</b> blocks.

       <b>--output</b> <b>-o</b> <b>OUTPUT</b>
              Specify the <b>OUTPUT</b> file.

       <b>--posix-captures,</b> <b>-P</b>
              Enable  submatch  extraction  with  POSIX-style  capturing groups. The result is collected into an
              array <b>yybmatch</b> of capacity <b>2</b> <b>*</b> <b>YYMAXNMATCH</b>, and <b>yynmatch</b> is set to the number of  groups  for  the
              matching rule.

       <b>--posix-captvars</b>
              Enable  submatch  extraction  with  POSIX-style  capturing  groups.  The  result is collected into
              variables <b>yytl&lt;k&gt;</b>, <b>yytr&lt;k&gt;</b> for <b>k</b>-th capturing group.

       <b>--recursive-functions</b>
              Use code model based on co-recursive functions, where each DFA state is a separate  function  that
              may call other state-functions or itself.

       <b>--reusable</b> <b>-r</b>
              Deprecated since version 2.2 (reusable blocks are allowed by default now).

       <b>--skeleton</b> <b>-S</b>
              Ignore user-defined interface code and generate a self-contained "skeleton" program. Additionally,
              generate  input  files  with strings derived from the regular grammar and compressed match results
              that are used to verify "skeleton" behavior on all inputs. This option is useful for finding  bugs
              in optimizations and code generation. This option is supported only for C.

       <b>--storable-state</b> <b>-f</b>
              Generate  a  lexer which can store its inner state.  This is useful in push-model lexers which are
              stopped by an outer program when there is not enough input,  and  then  resumed  when  more  input
              becomes  available.  In  this  mode  users  should  additionally  define <b>YYGETSTATE</b> and <b>YYSETSTATE</b>
              primitives, and variables <b>yych</b>, <b>yyaccept</b> and <b>state</b> should be part of the stored lexer state.

       <b>--syntax</b> <b>FILE</b>
              Load configurations from the specified <b>FILE</b> and apply them on top of the default syntax file. Note
              that <b>FILE</b> can define only a few configurations (if it's used to amend the default syntax file), or
              it can define a whole new language backend (in the latter case it is  recommended  to  use  <b>--lang</b>
              <b>none</b> option).

       <b>--tags</b> <b>-T</b>
              Enable submatch extraction with tags.

       <b>--ucs2</b> <b>--wide-chars</b> <b>-w</b>
              Generate  a  lexer  that reads UCS2-encoded input. re2zig assumes that the character range is 0 --
              0xFFFF and character size is 2 bytes.  This option implies <b>--nested-ifs</b>.

       <b>--utf8</b> <b>--utf-8</b> <b>-8</b>
              Generate a lexer that reads input in UTF-8 encoding. re2zig assumes that the character range is  0
              -- 0x10FFFF and character size is 1 byte.

       <b>--utf16</b> <b>--utf-16</b> <b>-x</b>
              Generate  a  lexer that reads UTF16-encoded input. re2zig assumes that the character range is 0 --
              0x10FFFF and character size is 2 bytes.  This option implies <b>--nested-ifs</b>.

       <b>--utf32</b> <b>--unicode</b> <b>-u</b>
              Generate a lexer that reads UTF32-encoded input. re2zig assumes that the character range is  0  --
              0x10FFFF and character size is 4 bytes.  This option implies <b>--nested-ifs</b>.

       <b>--verbose</b>
              Output a short message in case of success.

       <b>--vernum</b> <b>-V</b>
              Show version information in <b>MMmmpp</b> format (major, minor, patch).

       <b>--version</b> <b>-v</b>
              Show version information.

       <b>--single-pass</b> <b>-1</b>
              Deprecated. Does nothing (single pass is the default now).

       <b>--debug-output</b> <b>-d</b>
              Emit <b>YYDEBUG</b> invocations in the generated code. This is useful to trace lexer execution.

       <b>--dump-adfa</b>
              Debug option: output DFA after tunneling (in .dot format).

       <b>--dump-cfg</b>
              Debug option: output control flow graph of tag variables (in .dot format).

       <b>--dump-closure-stats</b>
              Debug option: output statistics on the number of states in closure.

       <b>--dump-dfa-det</b>
              Debug option: output DFA immediately after determinization (in .dot format).

       <b>--dump-dfa-min</b>
              Debug option: output DFA after minimization (in .dot format).

       <b>--dump-dfa-tagopt</b>
              Debug option: output DFA after tag optimizations (in .dot format).

       <b>--dump-dfa-tree</b>
              Debug  option: output DFA under construction with states represented as tag history trees (in .dot
              format).

       <b>--dump-dfa-raw</b>
              Debug option: output DFA under construction with expanded state-sets (in .dot format).

       <b>--dump-interf</b>
              Debug option: output interference table produced by liveness analysis of tag variables.

       <b>--dump-nfa</b>
              Debug option: output NFA (in .dot format).

       <b>--emit-dot</b> <b>-D</b>
              Instead of normal output generate lexer graph in .dot format.  The output can be converted  to  an
              image with the help of Graphviz (e.g. something like <b>dot</b> <b>-Tpng</b> <b>-odfa.png</b> <b>dfa.dot</b>).

       <b>--dfa-minimization</b> <b>&lt;moore</b> <b>|</b> <b>table&gt;</b>
              Internal  option:  DFA  minimization  algorithm  used  by  re2zig.  The  <b>moore</b> option is the Moore
              algorithm (it is the default). The <b>table</b> option is the "table filling" algorithm. Both  algorithms
              should  produce the same DFA up to states relabeling; table filling is simpler and much slower and
              serves as a reference implementation.

       <b>--eager-skip</b>
              Internal option: make the generated lexer advance the input position eagerly -- immediately  after
              reading  the  input  symbol. This changes the default behavior when the input position is advanced
              lazily -- after transition to the next state.

       <b>--no-lookahead</b>
              Internal option, deprecated.  It  used  to  enable  <a href="../man0/TDFA.0.html">TDFA</a>(0)  algorithm.  Unlike  <a href="../man1/TDFA.1.html">TDFA</a>(1),  <a href="../man0/TDFA.0.html">TDFA</a>(0)
              algorithm  does  not  use  one-symbol  lookahead.  It  applies register operations to the incoming
              transitions rather than the outgoing ones.  Benchmarks  showed  that  <a href="../man0/TDFA.0.html">TDFA</a>(0)  algorithm  is  less
              efficient than <a href="../man1/TDFA.1.html">TDFA</a>(1).

       <b>--no-optimize-tags</b>
              Internal option: suppress optimization of tag variables (useful for debugging).

       <b>--posix-closure</b> <b>&lt;gor1</b> <b>|</b> <b>gtop&gt;</b>
              Internal option: specify shortest-path algorithm used for the construction of epsilon-closure with
              POSIX  disambiguation semantics: <b>gor1</b> (the default) stands for Goldberg-Radzik algorithm, and <b>gtop</b>
              stands for "global topological order" algorithm.

       <b>--posix-prectable</b> <b>&lt;complex</b> <b>|</b> <b>naive&gt;</b>
              Internal option: specify the algorithm  used  to  compute  POSIX  precedence  table.  The  <b>complex</b>
              algorithm  computes  precedence  table  in  one  traversal  of  tag history tree and has quadratic
              complexity in the number of TNFA states; it is the default. The  <b>naive</b>  algorithm  has  worst-case
              cubic  complexity  in  the  number  of TNFA states, but it is much simpler than <b>complex</b> and may be
              slightly faster in non-pathological cases.

       <b>--stadfa</b>
              Internal option, deprecated.  It used to enable staDFA algorithm, which differs from TDFA in  that
              register operations are placed in states rather than on transitions. Benchmarks showed that staDFA
              algorithm is less efficient than TDFA.

       <b>--fixed-tags</b> <b>&lt;none</b> <b>|</b> <b>toplevel</b> <b>|</b> <b>all&gt;</b>
              Internal  option:  specify whether the fixed-tag optimization should be applied to all tags (<b>all</b>),
              none of them (<b>none</b>), or only those in toplevel  concatenation  (<b>toplevel</b>).  The  default  is  <b>all</b>.
              "Fixed" tags are those that are located within a fixed distance to some other tag (called "base").
              In  such  cases  only  the  base  tag  needs  to be tracked, and the value of the fixed tag can be
              computed as the value of the base tag plus a static offset. For tags that are under alternative or
              repetition it is also necessary to check if the base tag has a no-match value (in that case  fixed
              tag  should also be set to no-match, disregarding the offset). For tags in top-level concatenation
              the check is not needed, because they always match.

   <b>Warnings</b>
       Warnings can be invividually enabled, disabled and turned into an error.

       <b>-W</b>     Turn on all warnings.

       <b>-Werror</b>
              Turn warnings into errors. Note that this option alone doesn't  turn  on  any  warnings;  it  only
              affects those warnings that have been turned on so far or will be turned on later.

       <b>-W&lt;warning&gt;</b>
              Turn on <b>warning</b>.

       <b>-Wno-&lt;warning&gt;</b>
              Turn off <b>warning</b>.

       <b>-Werror-&lt;warning&gt;</b>
              Turn on <b>warning</b> and treat it as an error (this implies <b>-W&lt;warning&gt;</b>).

       <b>-Wno-error-&lt;warning&gt;</b>
              Don't treat this particular <b>warning</b> as an error. This doesn't turn off the warning itself.

       <b>-Wcondition-order</b>
              Warn if the generated program makes implicit assumptions about condition numbering. One should use
              either <b>--header</b> option or <b>conditions</b> block to generate a mapping of condition names to numbers and
              then use the autogenerated condition names.

       <b>-Wempty-character-class</b>
              Warn if a regular expression contains an empty character class. Trying to match an empty character
              class  makes no sense: it should always fail.  However, for backwards compatibility reasons re2zig
              permits empty character classes and treats them as empty strings. Use the <b>--empty-class</b> option  to
              change the default behavior.

       <b>-Wmatch-empty-string</b>
              Warn  if  a rule is nullable (matches an empty string).  If the lexer runs in a loop and the empty
              match is unintentional, the lexer may unexpectedly hang in an infinite loop.

       <b>-Wswapped-range</b>
              Warn if the lower bound of a range is greater than its upper bound. The  default  behavior  is  to
              silently swap the range bounds.

       <b>-Wundefined-control-flow</b>
              Warn  if  some  input  strings  cause undefined control flow in the lexer (the faulty patterns are
              reported). This is a dangerous and common mistake. It can be easily fixed by  adding  the  default
              rule  <b>*</b>  which  has  the lowest priority, matches any code unit, and always consumes a single code
              unit.

       <b>-Wunreachable-rules</b>
              Warn about rules that are shadowed by other rules and will never match.

       <b>-Wuseless-escape</b>
              Warn if a symbol is escaped when it shouldn't  be.   By  default,  re2zig  silently  ignores  such
              escapes, but this may as well indicate a typo or an error in the escape sequence.

       <b>-Wnondeterministic-tags</b>
              Warn if a tag has <b>n</b>-th degree of nondeterminism, where <b>n</b> is greater than 1.

       <b>-Wsentinel-in-midrule</b>
              Warn  if  the sentinel symbol occurs in the middle of a rule --- this may cause reads past the end
              of buffer, crashes or memory corruption in the generated lexer. This warning is only applicable if
              the sentinel method of checking for the end  of  input  is  used.   It  is  set  to  an  error  if
              <b>re2c:sentinel</b> configuration is used.

       <b>-Wundefined-syntax-config</b>
              Warn  if  the  syntax  file  specified  with  <b>--syntax</b>  option  is  missing  definitions  of  some
              configurations. This  helps  to  maintain  user-defined  syntax  files:  if  a  new  release  adds
              configurations,  old  syntax  file  will  raise  a warning, and the user will be notified. If some
              configurations are unused and do  not  need  a  definition,  they  should  be  explicitly  set  to
              <b>&lt;undefined&gt;</b>.

   <b>Syntax</b> <b>files</b>
       Support  for  different  languages  in  re2c  is  based  on the idea of <u>syntax</u> <u>files</u>.  A syntax file is a
       configuration file that defines syntax of the target language -- not the whole language, but a small part
       of it that is used by the generated code. Syntax files make re2c very flexible, but they  should  not  be
       used as a replacement for <b>re2c:</b> configurations: their purpose is to define syntax of the target language,
       not to customize one particular lexer. All supported languages have default syntax files that are part of
       the  distribution  (see <b>include/syntax</b> subdirectory); they are also embedded in the re2zig binary.  Users
       may provide a custom syntax file that overrides a few configurations for one of supported  languages,  or
       they  may choose to redefine all configurations (in that case <b>--lang</b> <b>none</b> option should be used).  Syntax
       files contain configurations of four different kinds: feature  lists,  language  configurations,  inplace
       configurations and code templates.

       <b>Feature</b> <b>lists</b>
          A  few  list  configurations  define various features supported by a given backend, so that re2zig may
          give a clear error if the user tries to enable an unsupported feature:

          <b>supported_apis</b>
                 A list of supported APIs with possible elements <b>simple</b>, <b>record</b>, <b>generic</b>.

          <b>supported_api_styles</b>
                 A list of supported API styles with possible elements <b>functions</b>, <b>free-form</b>.

          <b>supported_code_models</b>
                 A  list  of  supported  code   models   with   possible   elements   <b>goto-label</b>,   <b>loop-switch</b>,
                 <b>recursive-functions</b>.

          <b>supported_targets</b>
                 A list of supported codegen targets with possible elements <b>code</b>, <b>dot</b>, <b>skeleton</b>.

          <b>supported_features</b>
                 A  list  of  supported  features  with  possible  elements <b>nested-ifs</b>, <b>bitmaps</b>, <b>computed-gotos</b>,
                 <b>case-ranges</b>, <b>monadic</b>, <b>unsafe</b>, <b>tags</b>, <b>captures</b>, <b>captvars</b>.

       <b>Language</b> <b>configurations</b>
          A few boolean configurations describe features of the target language that affect  re2zig  parser  and
          code generator:

          <b>semicolons</b>
                 Non-zero if the language uses semicolons after statements.

          <b>backtick_quoted_strings</b>
                 Non-zero if the language has backtick-quoted strings.

          <b>single_quoted_strings</b>
                 Non-zero if the language has single-quoted strings.

          <b>indentation_sensitive</b>
                 Non-zero if the language is indentation sensitive.

          <b>wrap_blocks_in_braces</b>
                 Non-zero if compound statements must be wrapped in curly braces.

       <b>Inplace</b> <b>configurations</b>
          Syntax  files  define  initial  values  of  all <b>re2c:</b> configurations, as they may differ for different
          languages. See configurations section for a full list of all inplace configurations and their meaning.

       <b>Code</b> <b>templates</b>
          Code templates define syntax of the target language. They are  written  in  a  simple  domain-specific
          language with the following formal grammar:

              code-template ::
                    name '=' code-exprs ';'
                  | CODE_TEMPLATE ';'
                  | '&lt;undefined&gt;' ';'

              code-exprs ::
                    &lt;EMPTY&gt;
                  | code-exprs code-expr

              code-expr ::
                    STRING
                  | VARIABLE
                  | optional
                  | list

              optional ::
                    '(' CONDITIONAL '?' code-exprs ')'
                  | '(' CONDITIONAL '?' code-exprs ':' code-exprs ')'

              list ::
                    '[' VARIABLE ':' code-exprs ']'
                  | '[' VARIABLE '{' NUMBER '}' ':' code-exprs ']'
                  | '[' VARIABLE '{' NUMBER ',' NUMBER '}' ':' code-exprs ']'

          A  code  template  is  a  sequence  of  string  literals, variables, optional elements and lists, or a
          reference to another code template, or a special value <b>&lt;undefined&gt;</b>. Variables  are  placeholders  that
          are  substituted  during  code  generation  phase.  List  variables  are  special: when expanding list
          templates, re2zig repeats expressions the right hand side  of  the  column  a  few  times,  each  time
          replacing  occurrences  of  the  list  variable  with  a value specific to this repetition. Lists have
          optional bounds (negative values  are  counted  from  the  end,  e.g.  <b>-1</b>  means  the  last  element).
          Conditional  names start with a dot.  Both conditionals and variables may be either local (specific to
          the given code template) or global (allowed in all code templates). When re2zig reads syntax file,  it
          checks that each code template uses only the variables and conditionals that are allowed in it.

          For example, the following code template defines if-then-else construct for a C-like language:

              code:if_then_else =
                  [branch{0}: topindent "if " cond " {" nl
                      indent [stmt: stmt] dedent]
                  [branch{1:-1}: topindent "} else" (.cond ? " if " cond) " {" nl
                      indent [stmt: stmt] dedent]
                  topindent "}" nl;

          Here  <b>branch</b>  is a list variable: <b>branch{0}</b> expands to the first branch (which is special, as there is
          no <b>else</b> part), <b>branch{1:-1}</b> expands to all remaining branches (if any). <b>stmt</b> is also a list  variable:
          <b>[stmt:</b>  <b>stmt]</b> is a nested list that expands to a list of statements in the body of the current branch.
          <b>topindent</b>, <b>indent</b>, <b>dedent</b> and <b>nl</b> are global variables, and <b>.cond</b> is a local conditional (their meaning
          is described below). This code template could produce the following code:

              if x {
                  // do something
              } else if y {
                  // do something else
              } else {
                  // don't do anything
              }

          Here's a list of all code templates supported by re2zig with their local variables  and  conditionals.
          Note that a particular definition may, but does not have to use local variables and conditionals.  Any
          unused code templates should be set to <b>&lt;undefined&gt;</b>.

          <b>code:var_local</b>
                 Declaration  or  definition  of  a  local  variable. Supported variables: <b>type</b> (the type of the
                 variable), <b>name</b> (its name) and <b>init</b> (initial value, if any). Conditionals: <b>.init</b> (true if there
                 is an initializer).

          <b>code:var_global</b>
                 Same as <b>code:var_local</b>, except that it's used in top-level.

          <b>code:const_local</b>
                 Definition of a local constant. Supported variables: <b>type</b> (the type of the constant), <b>name</b> (its
                 name) and <b>init</b> (initial value).

          <b>code:const_global</b>
                 Same as <b>code:const_local</b>, except that it's used in top-level.

          <b>code:array_local</b>
                 Definition of a local array (table). Supported variables: <b>type</b> (the type  of  array  elements),
                 <b>name</b> (array name), <b>size</b> (its size), <b>row</b> (a list variable that does not itself produce any code,
                 but  expands  list  expression  as  many times as there are rows in the table) and <b>elem</b> (a list
                 variable that expands to all table elements in the current row -- it's meant to  be  nested  in
                 the <b>row</b> list).

          <b>code:array_global</b>
                 Same as <b>code:array_local</b>, except that it's used in top-level.

          <b>code:array_elem</b>
                 Reference to an element of an array (table). Supported variables: <b>array</b> (the name of the array)
                 and <b>index</b> (index of the element).

          <b>code:enum</b>
                 Definition  of  an  enumeration  (it  may  be  defined  using  a special language construct for
                 enumerations, or  simply  as  a  few  standalone  constants).   Supported  variables  are  <b>type</b>
                 (user-defined  enumeration  type or type of the constants), <b>elem</b> (list variable that expands to
                 the name of each member) and <b>init</b> (initializer for each member). Conditionals: <b>.init</b>  (true  if
                 there is an initializer).

          <b>code:enum_elem</b>
                 Enumeration  element  (a  member  of  a  user-defined enumeration type or a name of a constant,
                 depending on how <b>code:enum</b> is defined).  Supported variables are <b>name</b> (the name of the element)
                 and <b>type</b> (its type).

          <b>code:assign</b>
                 Assignment statement. Supported variables are <b>lhs</b> (left hand side) and <b>rhs</b> (right hand side).

          <b>code:type_int</b>
                 Signed integer type.

          <b>code:type_uint</b>
                 Unsigned integer type.

          <b>code:type_yybm</b>
                 Type of elements in the <b>yybm</b> table.

          <b>code:type_yytarget</b>
                 Type of elements in the <b>yytarget</b> table.

          <b>code:cmp_eq</b>
                 Operator "equals".

          <b>code:cmp_ne</b>
                 Operator "not equals".

          <b>code:cmp_lt</b>
                 Operator "less than".

          <b>code:cmp_gt</b>
                 Operator "greater than"

          <b>code:cmp_le</b>
                 Operator "less or equal"

          <b>code:cmp_ge</b>
                 Operator "greater or equal"

          <b>code:if_then_else</b>
                 If-then-else statement with one or more branches. Supported variables: <b>branch</b> (a list  variable
                 that  does  not itself produce any code, but expands list expression as many times as there are
                 branches), <b>cond</b> (condition of the current branch) and <b>stmt</b> (a list variable that expands to all
                 statements in the current branch). Conditionals: <b>.cond</b>  (true  if  the  current  branch  has  a
                 condition), <b>.many</b> (true if there's more than one branch).

          <b>code:if_then_else_oneline</b>
                 A  specialization of <b>code:if_then_else</b> for the case when all branches have one-line statements.
                 If this is <b>&lt;undefined&gt;</b>, <b>code:if_then_else</b> is used instead.

          <b>code:switch</b>
                 A switch statement  with  one  or  more  cases.  Supported  variables:  <b>expr</b>  (the  switched-on
                 expression) and <b>case</b> (a list variable that expands to all cases-groups with their code blocks).

          <b>code:switch_cases</b>
                 A  group of switch cases that maps to a single code block. Supported variables are <b>case</b> (a list
                 variable that expands to all cases in this group) and <b>stmt</b> (a list variable that expands to all
                 statements in the code block.

          <b>code:switch_cases_oneline</b>
                 A specialization of <b>code:switch_cases</b> for the case when the code block  consists  of  a  single
                 one-line statement. If this is <b>&lt;undefined&gt;</b>, <b>code:switch_cases</b> is used instead.

          <b>code:switch_case_range</b>
                 A  single  switch  case  that covers a range of values (possibly consisting of a single value).
                 Supported variable: <b>val</b> (a list variable that expands to all values in  the  range).  Supported
                 conditionals: <b>.many</b> (true if there's more than one value in the range) and <b>.char_literals</b> (true
                 if  this  is  a  switch on character literals -- some languages provide special syntax for this
                 case).

          <b>code:switch_case_default</b>
                 Default switch case.

          <b>code:loop</b>
                 A loop that runs forever (unless interrupted from the loop body).  Supported  variables:  <b>label</b>
                 (loop label), <b>stmt</b> (a list variable that expands to all statements in the loop body).

          <b>code:continue</b>
                 Continue statement. Supported variables: <b>label</b> (label from which to continue execution).

          <b>code:goto</b>
                 Goto statement. Supported variables: <b>label</b> (label of the jump target).

          <b>code:fndecl</b>
                 Function  declaration.  Supported  variables:  <b>name</b> (function name), <b>type</b> (return type), <b>arg</b> (a
                 list variable that does not itself produce code, but expands list expression as many  times  as
                 there  are  function  arguments),  <b>argname</b> (name of the current argument), <b>argtype</b> (type of the
                 current argument). Conditional: <b>.type</b> (true if this is a non-void function).

          <b>code:fndef</b>
                 Like <b>code:fndecl</b>, but used for function definitions, so it has  one  additional  list  variable
                 <b>stmt</b> that expands to all statements in the function body.

          <b>code:fncall</b>
                 Function  call  statement. Supported variables: <b>name</b> (function name), <b>retval</b> (l-value where the
                 return value is stored, if any)  and  <b>arg</b>  (a  list  variable  that  expands  to  all  function
                 arguments).   Conditionals:  <b>.args</b>  (true  if  the function has arguments) and <b>.retval</b> (true if
                 return value needs to be saved).

          <b>code:tailcall</b>
                 Tail call statement. Supported variables: <b>name</b> (function name), and <b>arg</b> (a list  variable  that
                 expands  to  all function arguments).  Conditionals: <b>.args</b> (true if the function has arguments)
                 and <b>.retval</b> (true if this is a non-void function).

          <b>code:recursive_functions</b>
                 Program body with <b>--recursive-functions</b> code model. Supported variables: <b>fn</b>  (a  list  variable
                 that  does  not itself produce any code, but expands list expression as many times as there are
                 functions), <b>fndecl</b> (declaration of the current function) and <b>fndef</b> (definition of  the  current
                 function).

          <b>code:fingerprint</b>
                 The  fingerprint  at  the  top  of  the generated output file. Supported variables: <b>ver</b> (re2zig
                 version that was used to generate this) and <b>date</b> (generation date).

          <b>code:line_info</b>
                 The format of line directives (if this is set to <b>&lt;undefined&gt;</b>,  no  directives  are  generated).
                 Supported variables: <b>line</b> (line number) and <b>file</b> (filename).

          <b>code:abort</b>
                 A statement that aborts program execution.

          <b>code:yydebug</b>
                 <b>YYDEBUG</b>  statement,  possibly  specialized  for  different APIs.  Supported variables: <b>YYDEBUG</b>,
                 <b>yyrecord</b>, <b>yych</b> (map to the corresponding <b>re2c:</b> configurations), <b>state</b> (DFA state number).

          <b>code:yypeek</b>
                 <b>YYPEEK</b> statement, possibly  specialized  for  different  APIs.   Supported  variables:  <b>YYPEEK</b>,
                 <b>YYCTYPE</b>,  <b>YYINPUT</b>,  <b>YYCURSOR</b>,  <b>yyrecord</b>,  <b>yych</b> (map to the corresponding <b>re2c:</b> configurations).
                 Conditionals: <b>.cast</b> (true if <b>re2c:yych:conversion</b> is set to non-zero).

          <b>code:yyskip</b>
                 <b>YYSKIP</b> statement, possibly  specialized  for  different  APIs.   Supported  variables:  <b>YYSKIP</b>,
                 <b>YYCURSOR</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations).

          <b>code:yybackup</b>
                 <b>YYBACKUP</b>  statement,  possibly  specialized for different APIs.  Supported variables: <b>YYBACKUP</b>,
                 <b>YYCURSOR</b>, <b>YYMARKER</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations).

          <b>code:yybackupctx</b>
                 <b>YYBACKUPCTX</b>  statement,  possibly  specialized  for  different  APIs.    Supported   variables:
                 <b>YYBACKUPCTX</b>, <b>YYCURSOR</b>, <b>YYCTXMARKER</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations).

          <b>code:yyskip_yypeek</b>
                 Combined   <b>code:yyskip</b>   and   <b>code:yypeek</b>  statement  (defaults  to  <b>code:yyskip</b>  followed  by
                 <b>code:yypeek</b>).

          <b>code:yypeek_yyskip</b>
                 Combined  <b>code:yypeek</b>  and  <b>code:yyskip</b>  statement  (defaults  to   <b>code:yypeek</b>   followed   by
                 <b>code:yyskip</b>).

          <b>code:yyskip_yybackup</b>
                 Combined   <b>code:yyskip</b>  and  <b>code:yybackup</b>  statement  (defaults  to  <b>code:yyskip</b>  followed  by
                 <b>code:yybackup</b>).

          <b>code:yybackup_yyskip</b>
                 Combined <b>code:yybackup</b>  and  <b>code:yyskip</b>  statement  (defaults  to  <b>code:yybackup</b>  followed  by
                 <b>code:yyskip</b>).

          <b>code:yybackup_yypeek</b>
                 Combined  <b>code:yybackup</b>  and  <b>code:yypeek</b>  statement  (defaults  to  <b>code:yybackup</b>  followed by
                 <b>code:yypeek</b>).

          <b>code:yyskip_yybackup_yypeek</b>
                 Combined <b>code:yyskip</b>,  <b>code:yybackup</b>  and  <b>code:yypeek</b>  statement  (defaults  to``code:yyskip``
                 followed by <b>code:yybackup</b> followed by <b>code:yypeek</b>).

          <b>code:yybackup_yypeek_yyskip</b>
                 Combined  <b>code:yybackup</b>,  <b>code:yypeek</b>  and  <b>code:yyskip</b> statement (defaults to``code:yybackup``
                 followed by <b>code:yypeek</b> followed by <b>code:yyskip</b>).

          <b>code:yyrestore</b>
                 <b>YYRESTORE</b> statement, possibly specialized for different APIs.  Supported variables:  <b>YYRESTORE</b>,
                 <b>YYCURSOR</b>, <b>YYMARKER</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations).

          <b>code:yyrestorectx</b>
                 <b>YYRESTORECTX</b>   statement,  possibly  specialized  for  different  APIs.   Supported  variables:
                 <b>YYRESTORECTX</b>, <b>YYCURSOR</b>, <b>YYCTXMARKER</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations).

          <b>code:yyrestoretag</b>
                 <b>YYRESTORETAG</b>  statement,  possibly  specialized  for  different  APIs.   Supported   variables:
                 <b>YYRESTORETAG</b>, <b>YYCURSOR</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>tag</b> (the name
                 of tag variable used to restore position).

          <b>code:yyshift</b>
                 <b>YYSHIFT</b>  statement,  possibly  specialized  for  different APIs.  Supported variables: <b>YYSHIFT</b>,
                 <b>YYCURSOR</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>offset</b> (the number of  code
                 units to shift the current position).

          <b>code:yyshiftstag</b>
                 <b>YYSHIFTSTAG</b>   statement,   possibly  specialized  for  different  APIs.   Supported  variables:
                 <b>YYSHIFTSTAG</b>, <b>yyrecord</b>, <b>negative</b> (map to  the  corresponding  <b>re2c:</b>  configurations),  <b>tag</b>  (tag
                 variable  which needs to be shifted), <b>offset</b> (the number of code units to shift). Conditionals:
                 <b>.nested</b>  (true  if  this  is  a  nested  tag  --  in  this  case  its  value   may   equal   to
                 <b>re2c:tags:negative</b>, which should not be shifted).

          <b>code:yyshiftmtag</b>
                 <b>YYSHIFTMTAG</b>   statement,   possibly  specialized  for  different  APIs.   Supported  variables:
                 <b>YYSHIFTMTAG</b> (maps to the corresponding <b>re2c:</b> configuration), <b>tag</b> (tag variable which  needs  to
                 be shifted), <b>offset</b> (the number of code units to shift).

          <b>code:yystagp</b>
                 <b>YYSTAGP</b>  statement,  possibly  specialized  for  different APIs.  Supported variables: <b>YYSTAGP</b>,
                 <b>YYCURSOR</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b>  configurations),  <b>tag</b>  (tag  variable  that
                 should be updated).

          <b>code:yymtagp</b>
                 <b>YYMTAGP</b> statement, possibly specialized for different APIs.  Supported variables: <b>YYMTAGP</b> (maps
                 to the corresponding <b>re2c:</b> configuration), <b>tag</b> (tag variable that should be updated).

          <b>code:yystagn</b>
                 <b>YYSTAGN</b>  statement,  possibly  specialized  for  different APIs.  Supported variables: <b>YYSTAGN</b>,
                 <b>negative</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b>  configurations),  <b>tag</b>  (tag  variable  that
                 should be updated).

          <b>code:yymtagn</b>
                 <b>YYMTAGN</b> statement, possibly specialized for different APIs.  Supported variables: <b>YYMTAGN</b> (maps
                 to the corresponding <b>re2c:</b> configuration), <b>tag</b> (tag variable that should be updated).

          <b>code:yycopystag</b>
                 <b>YYCOPYSTAG</b>   statement,   possibly   specialized  for  different  APIs.   Supported  variables:
                 <b>YYCOPYSTAG</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>lhs</b>, <b>rhs</b> (left and  right
                 hand side tag variables of the copy operation).

          <b>code:yycopymtag</b>
                 <b>YYCOPYMTAG</b>   statement,   possibly   specialized  for  different  APIs.   Supported  variables:
                 <b>YYCOPYMTAG</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>lhs</b>, <b>rhs</b> (left and  right
                 hand side tag variables of the copy operation).

          <b>code:yygetaccept</b>
                 <b>YYGETACCEPT</b>   statement,   possibly  specialized  for  different  APIs.   Supported  variables:
                 <b>YYGETACCEPT</b>,  <b>yyrecord</b>  (map  to  the  corresponding  <b>re2c:</b>  configurations),  <b>var</b>   (maps   to
                 <b>re2c:yyaccept</b> configuration).

          <b>code:yysetaccept</b>
                 <b>YYSETACCEPT</b>   statement,   possibly  specialized  for  different  APIs.   Supported  variables:
                 <b>YYSETACCEPT</b>,  <b>yyrecord</b>  (map  to  the  corresponding  <b>re2c:</b>  configurations),  <b>var</b>   (maps   to
                 <b>re2c:yyaccept</b> configuration) and <b>val</b> (numeric value of the accepted rule).

          <b>code:yygetcond</b>
                 <b>YYGETCOND</b>  statement, possibly specialized for different APIs.  Supported variables: <b>YYGETCOND</b>,
                 <b>yyrecord</b>  (map  to  the  corresponding  <b>re2c:</b>  configurations),  <b>var</b>   (maps   to   <b>re2c:yycond</b>
                 configuration).

          <b>code:yysetcond</b>
                 <b>YYSETCOND</b>  statement, possibly specialized for different APIs.  Supported variables: <b>YYSETCOND</b>,
                 <b>yyrecord</b>  (map  to  the  corresponding  <b>re2c:</b>  configurations),  <b>var</b>   (maps   to   <b>re2c:yycond</b>
                 configuration) and <b>val</b> (numeric condition identifier).

          <b>code:yygetstate</b>
                 <b>YYGETSTATE</b>   statement,   possibly   specialized  for  different  APIs.   Supported  variables:
                 <b>YYGETSTATE</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>var</b> (maps to <b>re2c:yystate</b>
                 configuration).

          <b>code:yysetstate</b>
                 <b>YYSETSTATE</b>  statement,  possibly  specialized  for  different   APIs.    Supported   variables:
                 <b>YYSETSTATE</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>var</b> (maps to <b>re2c:yystate</b>
                 configuration) and <b>val</b> (state number).

          <b>code:yylessthan</b>
                 <b>YYLESSTHAN</b>   statement,   possibly   specialized  for  different  APIs.   Supported  variables:
                 <b>YYLESSTHAN</b>, <b>YYCURSOR</b>, <b>YYLIMIT</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b>  configurations),  <b>need</b>
                 (the  number of code units to check against). Conditional: <b>.many</b> (true if the <b>need</b> is more than
                 one).

          <b>code:yybm_filter</b>
                 Condition that is used to filter out <b>yych</b> values that are not covered by the <b>yybm</b>  table  (used
                 with <b>--bitmaps</b> option).  Supported variable: <b>yych</b> (maps to <b>re2c:yych</b> configuration).

          <b>code:yybm_match</b>
                 The  format  of  <b>yybm</b> table check (generated with <b>--bitmaps</b> option). Supported variables: <b>yybm</b>,
                 <b>yych</b> (map to the corresponding <b>re2c:</b> configurations), <b>offset</b> (offset in  the  <b>yybm</b>  table  that
                 needs  to  be  added  to  <b>yych</b>) and <b>mask</b> (bit mask that should be applied to the table entry to
                 retrieve the boolean value that needs to be checked)

          Here's a list of all global variables that are allowed in syntax files:

          <b>nl</b>     A newline.

          <b>indent</b> A variable that does not produce any code, but has  a  side-effect  of  increasing  indentation
                 level.

          <b>dedent</b> A  variable  that  does  not  produce any code, but has a side-effect of decreasing indentation
                 level.

          <b>topindent</b>
                 Indentation string for the current statement. Indentation level is  tracked  and  automatically
                 updated by the code generator.

          Here's a list of all global conditionals that are allowed in syntax files:

          <b>.api.simple</b>
                 True if simple API is used (<b>--api</b> <b>simple</b> or <b>re2c:api</b> <b>=</b> <b>simple</b>).

          <b>.api.generic</b>
                 True if generic API is used (<b>--api</b> <b>generic</b> or <b>re2c:api</b> <b>=</b> <b>generic</b>).

          <b>.api.record</b>
                 True if record API is used (<b>--api</b> <b>record</b> or <b>re2c:api</b> <b>=</b> <b>record</b>).

          <b>.api_style.functions</b>
                 True if function-like API style is used (<b>re2c:api-style</b> <b>=</b> <b>functions</b>).

          <b>.api_style.freeform</b>
                 True if free-form API style is used (<b>re2c:api-style</b> <b>=</b> <b>free-form</b>).

          <b>.case_ranges</b>
                 True if case ranges feature is enabled (<b>--case-ranges</b> or <b>re2c:case-ranges</b> <b>=</b> <b>1</b>).

          <b>.code_model.goto_label</b>
                 True if  code model based on goto/label is used (<b>--goto-label</b>).

          <b>.code_model.loop_switch</b>
                 True if code model based on loop/switch is used (<b>--loop-switch</b>).

          <b>.code_model.recursive_functions</b>
                 True if code model based on recursive functions is used (<b>--recursive-function</b>).

          <b>.date</b>  True if the generated fingerprint should contain generation date.

          <b>.loop_label</b>
                 True  if  re2zig  generated  loops  must  have  a label (<b>re2c:label:yyloop</b> is set to a nonempty
                 string).

          <b>.monadic</b>
                 True if the generated code should be monadic (<b>re2c:monadic</b> <b>=</b> <b>1</b>).  This  is  only  relevant  for
                 pure functional languages.

          <b>.start_conditions</b>
                 True if start conditions are enabled (<b>--start-conditions</b>).

          <b>.storable_state</b>
                 True if storable state is enabled (<b>--storable-state</b>).

          <b>.unsafe</b>
                 True  if  re2zig  should  use  "unsafe"  blocks  in  order  to  generate faster code (<b>--unsafe</b>,
                 <b>re2c:unsafe</b> <b>=</b> <b>1</b>). This is only relevant for languages that have "unsafe" feature.

          <b>.version</b>
                 True if the generated fingerprint should contain re2zig version.

</pre><h4><b>HANDLING</b> <b>THE</b> <b>END</b> <b>OF</b> <b>INPUT</b></h4><pre>
       One of the main problems for the lexer is to know when to stop.  There are a few terminating conditions:

       • the lexer may match some rule (including default rule <b>*</b>) and come to a final state

       • the lexer may fail to match any rule and come to a default state

       • the lexer may reach the end of input

       The first two conditions terminate the lexer in a "natural" way: it comes to a  state  with  no  outgoing
       transitions,  and  the  matching automatically stops. The third condition, end of input, is different: it
       may happen in any state, and the lexer should be able to  handle  it.  Checking  for  the  end  of  input
       interrupts the normal lexer workflow and adds conditional branches to the generated program, therefore it
       is  necessary to minimize the number of such checks. re2zig supports a few different methods for handling
       the end of input. Which one to use depends on  the  complexity  of  regular  expressions,  the  need  for
       buffering, performance considerations and other factors. Here is a list of methods:

       • <b>Sentinel.</b>   This  method  eliminates  the need for the end of input checks altogether. It is simple and
         efficient, but limited to the case when there is a natural "sentinel" character that can never occur in
         valid input. This character may still occur in invalid input, but it  should  not  be  allowed  by  the
         regular  expressions,  except  perhaps as the last character of a rule. The sentinel is appended at the
         end of input and serves as a stop signal: when the lexer reads this character, it is  either  a  syntax
         error  or  the  end  of  input.  In  both cases the lexer should stop. This method is used if <b>YYFILL</b> is
         disabled with <b>re2c:yyfill:enable</b> <b>=</b> <b>0;</b> and <b>re2c:eof</b> has the default value <b>-1</b>.

       • <b>Sentinel</b> <b>with</b> <b>bounds</b> <b>checks.</b>  This method is generic:  it  allows  one  to  handle  any  input  without
         restrictions  on  the  regular  expressions. The idea is to reduce the number of end of input checks by
         performing them only on certain characters. Similar to the "sentinel" method, one of the characters  is
         chosen  as a "sentinel" and appended at the end of input. However, there is no restriction on where the
         sentinel may occur (in fact, any character can be chosen for a sentinel).  When the  lexer  reads  this
         character,  it  additionally  performs  a  bounds check.  If the current position is within bounds, the
         lexer resumes matching and handles the sentinel as a regular character.  Otherwise  it  invokes  <b>YYFILL</b>
         (unless  it  is  disabled).  If  more  input is supplied, the lexer will rematch the last character and
         continue as if the sentinel wasn't there. Otherwise it must be the real end of  input,  and  the  lexer
         stops.  This method is used when <b>re2c:eof</b> has non-negative value (it should be set to the numeric value
         of the sentinel). <b>YYFILL</b> is optional.

       • <b>Bounds</b> <b>checks</b> <b>with</b> <b>padding.</b>  This method is generic, and it may  be  faster  than  the  "sentinel  with
         bounds  checks"  method, but it is also more complex. The idea is to partition DFA states into strongly
         connected components (SCCs) and generate a single check per SCC for  enough  characters  to  cover  the
         longest  non-looping  path  in this SCC. This reduces the number of checks, but there is a problem with
         short lexemes at the end of input, as the check requires enough characters to cover the longest lexeme.
         This can be fixed by padding the input with a few fake characters that  do  not  form  a  valid  lexeme
         suffix (so that the lexer cannot match them). The length of padding should be <b>YYMAXFILL</b>, generated with
         a  <b>max</b>  block.  If there is not enough input, the lexer invokes <b>YYFILL</b> which should supply at least the
         required number of characters or not return.  This method is used if <b>YYFILL</b> is enabled and <b>re2c:eof</b>  is
         <b>-1</b> (this is the default configuration).

       • <b>Custom</b>  <b>checks.</b>   Generic  API  allows one to override basic operations like reading a character, which
         makes it possible to include the end-of-input checks as part of them.  This approach is error-prone and
         should be used with caution. To use a custom method, enable generic API with <b>--api</b> <b>custom</b> or <b>re2c:api</b> <b>=</b>
         <b>custom;</b> and disable default bounds checks with <b>re2c:yyfill:enable</b> <b>=</b> <b>0;</b> or <b>re2c:yyfill:check</b> <b>=</b> <b>0;</b>.

       The following subsections contain an example of each method.

   <b>Sentinel</b>
       This example uses a sentinel character to handle the end of input.  The  program  counts  space-separated
       words  in  a null-terminated string. The sentinel is null: it is the last character of each input string,
       and it is not allowed in the middle of a lexeme by any of the rules (in particular, it is not included in
       character ranges where it is easy to overlook). If a null occurs in the middle  of  a  string,  it  is  a
       syntax  error  and  the lexer will match default rule <b>*</b>, but it won't read past the end of input or crash
       (use -Wsentinel-in-midrule &lt;https://re2c.org/manual/basics/warnings/warnings.html#wsentinel-in-midrule&gt;

       warning and <b>re2c:sentinel</b> configuration to verify this). Configuration <b>re2c:yyfill:enable</b> <b>=</b> <b>0;</b> suppresses
       the generation of bounds checks and <b>YYFILL</b> invocations.

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          // Expects a null-terminated string.
          fn lex(yyinput: [:0]const u8) i32 {
              var yycursor: u32 = 0;
              var count: i32 = 0;

              loop: while (true) {
                  %{
                      re2c:yyfill:enable = 0;

                      *      { return -1; }
                      [\x00] { return count; }
                      [a-z]+ { count += 1; continue :loop; }
                      [ ]+   { continue :loop; }
                  %}
              }
          }

          test {
              try std.testing.expectEqual(lex(""), 0);
              try std.testing.expectEqual(lex("one two three"), 3);
              try std.testing.expectEqual(lex("f0ur"), -1);
          }

   <b>Sentinel</b> <b>with</b> <b>bounds</b> <b>checks</b>
       This example uses sentinel with bounds checks to handle the end  of  input  (this  method  was  added  in
       version  1.2).  The program counts space-separated single-quoted strings. The sentinel character is null,
       which is specified with <b>re2c:eof</b> <b>=</b> <b>0;</b> configuration.  As  in  the  sentinel  method,  null  is  the  last
       character  of  each  input string, but it is allowed in the middle of a rule (for example, <b>'aaa\0aa'\0</b> is
       valid input, but <b>'aaa\0</b> is a syntax error).  Bounds checks are generated in each state  that  matches  an
       input  character,  but  they  are  scoped  to the branch that handles null. Bounds checks are of the form
       <b>YYLIMIT</b> <b>&lt;=</b> <b>YYCURSOR</b> or <b><a href="../man1/YYLESSTHAN.1.html">YYLESSTHAN</a>(1)</b> with generic API. If the check condition is true, lexer has  reached
       the  end of input and should stop (<b>YYFILL</b> is disabled with <b>re2c:yyfill:enable</b> <b>=</b> <b>0;</b> as the input fits into
       one buffer, see the YYFILL with sentinel section for an example that uses <b>YYFILL</b>). Reaching  the  end  of
       input opens three possibilities: if the lexer is in the initial state it will match the end-of-input rule
       <b>$</b>,  otherwise  it may fallback to a previously matched rule (including default rule <b>*</b>) or go to a default
       state,                                  causing                                  -Wundefined-control-flow
       &lt;https://re2c.org/manual/basics/warnings/warnings.html#wundefined-control-flow&gt; .

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          // Expects a null-terminated string.
          fn lex(yyinput: [:0]const u8) i32 {
              var yycursor: usize = 0;
              var yymarker: usize = 0;
              const yylimit: usize = yyinput.len; // points at the terminating null
              var count: i32 = 0;

              loop: while (true) {
                  %{
                      re2c:yyfill:enable = 0;
                      re2c:eof = 0;

                      str = ['] ([^'\\] | [\\][^])* ['];

                      *    { return -1; }
                      $    { return count; }
                      str  { count += 1; continue :loop; }
                      [ ]+ { continue :loop; }
                  %}
              }
          }

          test {
              try std.testing.expectEqual(lex(""), 0);
              try std.testing.expectEqual(lex("'qu\x00tes' 'are' 'fine: \\'' "), 3);
              try std.testing.expectEqual(lex("'unterminated\\'"), -1);
          }

   <b>Bounds</b> <b>checks</b> <b>with</b> <b>padding</b>
       This  example  uses  bounds  checks  with  padding  to handle the end of input (this method is enabled by
       default). The program counts space-separated single-quoted strings. There is a padding of <b>YYMAXFILL</b>  null
       characters  appended  at the end of input, where <b>YYMAXFILL</b> value is autogenerated with a <b>max</b> block. It is
       not necessary to use null for padding --- any characters can be used as long as they do not form a  valid
       lexeme  suffix  (in  this example padding should not contain single quotes, as they may be mistaken for a
       suffix of a single-quoted string). There is a "stop" rule that matches the first padding character (null)
       and terminates the lexer (note that it checks if null is at the beginning of padding, otherwise it  is  a
       syntax  error).  Bounds  checks  are  generated  only  in some states that are determined by the strongly
       connected components of the underlying automaton. Checks have the  form  <b>(YYLIMIT</b>  <b>-</b>  <b>YYCURSOR)</b>  <b>&lt;</b>  <b>n</b>  or
       <b>YYLESSTHAN(n)</b> with generic API, where <b>n</b> is the minimum number of characters that are needed for the lexer
       to  proceed  (it  also means that the next bounds check will occur in at most <b>n</b> characters). If the check
       condition is true, the lexer has reached the end of input and will invoke <b>YYFILL(n)</b>  that  should  either
       supply  at least <b>n</b> input characters or not return. In this example <b>YYFILL</b> always fails and terminates the
       lexer with an error (which is fine because the input fits into one buffer). See the YYFILL  with  padding
       section for an example that refills the input buffer with <b>YYFILL</b>.

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          %{max %}

          fn lex(str: []const u8) !i32 {
              // Create a copy of the input string padded with yymaxfill zeroes at the end.
              var yyinput = try std.testing.allocator.alloc(u8, str.len + yymaxfill);
              defer std.testing.allocator.free(yyinput);
              std.mem.copyForwards(u8, yyinput[0..], str);
              std.mem.copyForwards(u8, yyinput[str.len..], &amp;[_]u8{0} ** yymaxfill); // zero padding

              var yycursor: usize = 0;
              const yylimit: usize = yyinput.len;
              var count: i32 = 0;

              loop: while (true) {
                  %{
                      re2c:YYFILL = "return -1;";

                      str = ['] ([^'\\] | [\\][^])* ['];

                      [\x00] {
                          // Check that it is the sentinel, not some unexpected null.
                          return if (yycursor - 1 == str.len) count else -1;
                      }
                      str  { count += 1; continue :loop; }
                      [ ]+ { continue :loop; }
                      *    { return -1; }
                  %}
              }
          }

          test {
              try std.testing.expectEqual(lex(""), 0);
              try std.testing.expectEqual(lex("'qu\x00tes' 'are' 'fine: \\'' "), 3);
              try std.testing.expectEqual(lex("'unterminated\\'"), -1);
              try std.testing.expectEqual(lex("'unexpected \x00 null\\'"), -1);
          }

   <b>Custom</b> <b>checks</b>
       This  example  uses  a  custom  end-of-input  handling  method  based on generic API.  The program counts
       space-separated single-quoted strings. It is the same as the sentinel example, except that the  input  is
       not  null-terminated.  To cover up for the absence of a sentinel character at the end of input, <b>YYPEEK</b> is
       redefined to perform a bounds check before it reads  the  next  input  character.   This  is  inefficient
       because  checks  are  done  very  often. If the check condition fails, <b>YYPEEK</b> returns the real character,
       otherwise it returns a fake sentinel character.

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          // Expects a string without terminating null.
          fn lex(str: []const u8) i32 {
              var cur: usize = 0;
              var count: i32 = 0;

              loop: while (true) {
                  %{
                      re2c:api = generic;
                      re2c:yyfill:enable = 0;
                      // YYPEEK returns "fake" terminating null if cursor has reached limit.
                      re2c:YYPEEK = "if (cur &gt;= str.len) 0 else str[cur]";
                      re2c:YYSKIP = "cur += 1;";

                      *      { return -1; }
                      [\x00] { return count; }
                      [a-z]+ { count += 1; continue :loop; }
                      [ ]+   { continue :loop; }
                  %}
              }
          }

          test {
              try std.testing.expectEqual(lex(""), 0);
              try std.testing.expectEqual(lex("one two three"), 3);
              try std.testing.expectEqual(lex("f0ur"), -1);
          }

</pre><h4><b>BUFFER</b> <b>REFILLING</b></h4><pre>
       The need for buffering arises when the input cannot be mapped in memory all at once:  either  it  is  too
       large, or it comes in a streaming fashion (like reading from a socket). The usual technique in such cases
       is to allocate a fixed-sized memory buffer and process input in chunks that fit into the buffer. When the
       current  chunk  is  processed,  it is moved out and new data is moved in. In practice it is somewhat more
       complex, because lexer state consists not  of  a  single  input  position,  but  a  set  of  interrelated
       positions:

       • cursor: the next input character to be read (<b>YYCURSOR</b> in C pointer API or <b>YYSKIP</b>/<b>YYPEEK</b> in generic API)

       • limit:  the  position  after  the  last available input character (<b>YYLIMIT</b> in C pointer API, implicitly
         handled by <b>YYLESSTHAN</b> in generic API)

       • marker: the position of the most recent match, if any (<b>YYMARKER</b> in default API or <b>YYBACKUP</b>/<b>YYRESTORE</b> in
         generic API)

       • token: the start of the current lexeme (implicit in re2zig API, as it is  not  needed  for  the  normal
         lexer operation and can be defined and updated by the user)

       • context   marker:   the   position   of   the  trailing  context  (<b>YYCTXMARKER</b>  in  C  pointer  API  or
         <b>YYBACKUPCTX</b>/<b>YYRESTORECTX</b> in generic API)

       • tag variables: submatch positions (defined with <b>stags</b> and  <b>mtags</b>  blocks  and  generic  API  primitives
         <b>YYSTAGP</b>/<b>YYSTAGN</b>/<b>YYMTAGP</b>/<b>YYMTAGN</b>)

       Not  all  these are used in every case, but if used, they must be updated by <b>YYFILL</b>. All active positions
       are contained in the segment between token and cursor, therefore  everything  between  buffer  start  and
       token  can  be  discarded,  the  segment  from  token and up to limit should be moved to the beginning of
       buffer, and the free space at the end of buffer should be filled  with  new  data.   In  order  to  avoid
       frequent  <b>YYFILL</b>  calls  it  is  best  to fill in as many input characters as possible (even though fewer
       characters might suffice to resume  the  lexer).  The  details  of  <b>YYFILL</b>  implementation  are  slightly
       different  depending  on which EOF handling method is used: the case of EOF rule is somewhat simpler than
       the case of bounds-checking with padding. Also note that if <b>-f</b> <b>--storable-state</b> option  is  used,  <b>YYFILL</b>
       has slightly different semantics (described in the section about storable state).

   <b>YYFILL</b> <b>with</b> <b>sentinel</b>
       If  EOF  rule  is used, <b>YYFILL</b> is a function-like primitive that accepts no arguments and returns a value
       which is checked against zero. <b>YYFILL</b> invocation is triggered by  condition  <b>YYLIMIT</b>  <b>&lt;=</b>  <b>YYCURSOR</b>  in  C
       pointer  API  and  <b>YYLESSTHAN()</b>  in  generic API. A non-zero return value means that <b>YYFILL</b> has failed. A
       successful <b>YYFILL</b> call must supply at least one character and adjust input positions  accordingly.  Limit
       must  always  be  set  to  one  after  the  last input position in buffer, and the character at the limit
       position must be the sentinel symbol specified by <b>re2c:eof</b> configuration. The  pictures  below  show  the
       relative  locations  of input positions in buffer before and after <b>YYFILL</b> call (sentinel symbol is marked
       with <b>#</b>, and the second picture shows the case when there is not enough input to fill the whole buffer).

                         &lt;-- shift --&gt;
                       &gt;-A------------B---------C-------------D#-----------E-&gt;
                       buffer       token    marker         limit,
                                                            cursor
          &gt;-A------------B---------C-------------D------------E#-&gt;
                       buffer,  marker        cursor        limit
                       token

                         &lt;-- shift --&gt;
                       &gt;-A------------B---------C-------------D#--E (EOF)
                       buffer       token    marker         limit,
                                                            cursor
          &gt;-A------------B---------C-------------D---E#........
                       buffer,  marker       cursor limit
                       token

       Here is an example of a program that reads input file <b>input.txt</b> in chunks of  4096  bytes  and  uses  EOF
       rule.

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          const bufsize = 4095;

          const State = struct {
              yyinput: [bufsize + 1]u8,
              yycursor: usize,
              yymarker: usize,
              yylimit: usize,
              token: usize,
              eof: bool
          };

          fn fill(st: *State, file: anytype) i32 {
              if (st.eof) { return -1; } // unexpected EOF

              // Error: lexeme too long. In real life can reallocate a larger buffer.
              if (st.token &lt; 1) { return -2; }

              // Shift buffer contents (discard everything up to the current token).
              std.mem.copyBackwards(
                  u8, st.yyinput[0..st.yylimit - st.token], st.yyinput[st.token..st.yylimit]);
              st.yycursor -= st.token;
              st.yymarker = @subWithOverflow(st.yymarker, st.token)[0];
              st.yylimit -= st.token;
              st.token = 0;

              // Fill free space at the end of buffer with new data from file.
              st.yylimit += file.read(st.yyinput[st.yylimit..bufsize]) catch 0;
              st.yyinput[st.yylimit] = 0; // append sentinel symbol

              // If read less than expected, this is the end of input.
              st.eof = st.yylimit &lt; bufsize;

              return 0;
          }

          fn lex(yyrecord: *State, file: anytype) i32 {
              var count: i32 = 0;
              loop: while (true) {
                  yyrecord.token = yyrecord.yycursor;
                  %{
                      re2c:api = record;
                      re2c:eof = 0;
                      re2c:YYFILL = "fill(yyrecord, file) == 0";

                      str = ['] ([^'\\] | [\\][^])* ['];

                      *    { return -1; }
                      $    { return count; }
                      str  { count += 1; continue :loop; }
                      [ ]+ { continue :loop; }
                  %}
              }
          }

          test {
              const fname = "input";
              const content = "'qu\x00tes' 'are' 'fine: \\'' " ** bufsize;
              const count = 3 * bufsize; // number of quoted strings written to file

              // Prepare input file: a few times the size of the buffer, containing
              // strings with zeroes and escaped quotes.
              var fw = try std.fs.cwd().createFile(fname, .{});
              try fw.writeAll(content);
              fw.close();

              // Prepare lexer state: all offsets are at the end of buffer.
              var fr = try std.fs.cwd().openFile(fname, .{ .mode = .read_only});
              // Normally file would be part of the state struct, but BufferedReader type is unclear.
              var br = std.io.bufferedReader(fr.reader());
              var st = State{
                  .yyinput = undefined,
                  .yycursor = bufsize,
                  .yymarker = bufsize,
                  .yylimit = bufsize,
                  .token = bufsize,
                  .eof = false,
              };
              // Sentinel at `yylimit` offset is set to zero, which triggers YYFILL.
              st.yyinput[st.yylimit] = 0;

              // Run the lexer.
              try std.testing.expectEqual(lex(&amp;st, &amp;br), count);

              // Cleanup: remove input file.
              fr.close();
              try std.fs.cwd().deleteFile(fname);
          }

   <b>YYFILL</b> <b>with</b> <b>padding</b>
       In the default case (when EOF rule is not used) <b>YYFILL</b> is a function-like primitive that accepts a single
       argument and does not return any value.  <b>YYFILL</b> invocation is triggered by condition <b>(YYLIMIT</b> <b>-</b> <b>YYCURSOR)</b>
       <b>&lt;</b>  <b>n</b>  in  C  pointer  API  and <b>YYLESSTHAN(n)</b> in generic API. The argument passed to <b>YYFILL</b> is the minimal
       number of characters that must be supplied. If it fails to do so, <b>YYFILL</b> must not  return  to  the  lexer
       (for  that  reason  it is best implemented as a macro that returns from the calling function on failure).
       In case of a successful <b>YYFILL</b> invocation the limit position must be set either to  one  after  the  last
       input  position  in  buffer,  or to the end of <b>YYMAXFILL</b> padding (in case <b>YYFILL</b> has successfully read at
       least <b>n</b> characters, but not enough to fill the entire buffer).  The  pictures  below  show  the  relative
       locations  of  input  positions  in  buffer  before and after <b>YYFILL</b> invocation (<b>YYMAXFILL</b> padding on the
       second picture is marked with <b>#</b> symbols).

                         &lt;-- shift --&gt;                 &lt;-- need --&gt;
                       &gt;-A------------B---------C-----D-------E---F--------G-&gt;
                       buffer       token    marker cursor  limit

          &gt;-A------------B---------C-----D-------E---F--------G-&gt;
                       buffer,  marker cursor               limit
                       token

                         &lt;-- shift --&gt;                 &lt;-- need --&gt;
                       &gt;-A------------B---------C-----D-------E-F        (EOF)
                       buffer       token    marker cursor  limit

          &gt;-A------------B---------C-----D-------E-F###############
                       buffer,  marker cursor                   limit
                       token                        &lt;- YYMAXFILL -&gt;

       Here is an example of a program that reads input  file  <b>input.txt</b>  in  chunks  of  4096  bytes  and  uses
       bounds-checking with padding.

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          %{max %}
          const bufsize = 4096;

          const State = struct {
              yyinput: [bufsize + yymaxfill]u8,
              yycursor: usize,
              yymarker: usize,
              yylimit: usize,
              token: usize,
              eof: bool
          };

          fn fill(st: *State, need: usize, file: anytype) i32 {
              if (st.eof) { return -1; } // unexpected EOF

              // Error: lexeme too long. In real life can reallocate a larger buffer.
              if (st.token &lt; need) { return -2; }

              // Shift buffer contents (discard everything up to the current token).
              std.mem.copyBackwards(
                  u8, st.yyinput[0..st.yylimit - st.token], st.yyinput[st.token..st.yylimit]);
              st.yycursor -= st.token;
              st.yymarker = @subWithOverflow(st.yymarker, st.token)[0];
              st.yylimit -= st.token;
              st.token = 0;

              // Fill free space at the end of buffer with new data from file.
              st.yylimit += file.read(st.yyinput[st.yylimit..bufsize]) catch 0;

              // If read less than expected, this is the end of input.
              if (st.yylimit &lt; bufsize) {
                  st.eof = true;
                  @memset(st.yyinput[st.yylimit..st.yylimit + yymaxfill], 0);
                  st.yylimit += yymaxfill;
              }

              return 0;
          }

          fn lex(yyrecord: *State, file: anytype) i32 {
              var count: i32 = 0;
              loop: while (true) {
                  yyrecord.token = yyrecord.yycursor;
                  %{
                      re2c:api = record;
                      re2c:YYFILL = "{ if (fill(yyrecord, @@, file) != 0) return -2; }";

                      str = ['] ([^'\\] | [\\][^])* ['];

                      [\x00] {
                          // Check that it is the sentinel, not some unexpected null.
                          return if (yyrecord.token == yyrecord.yylimit - yymaxfill) count else -1;
                      }
                      str  { count += 1; continue :loop; }
                      [ ]+ { continue :loop; }
                      *    { return -1; }
                  %}
              }
          }

          test {
              const fname = "input";
              const content = "'qu\x00tes' 'are' 'fine: \\'' " ** bufsize;
              const count = 3 * bufsize; // number of quoted strings written to file

              // Prepare input file: a few times the size of the buffer, containing
              // strings with zeroes and escaped quotes.
              var fw = try std.fs.cwd().createFile(fname, .{});
              try fw.writeAll(content);
              fw.close();

              // Prepare lexer state: all offsets are at the end of buffer.
              // This immediately triggers YYFILL, as the YYLESSTHAN condition is true.
              var fr = try std.fs.cwd().openFile(fname, .{ .mode = .read_only});
              // Normally file would be part of the state struct, but BufferedReader type is unclear.
              var br = std.io.bufferedReader(fr.reader());
              var st = State{
                  .yyinput = undefined,
                  .yycursor = bufsize,
                  .yymarker = bufsize,
                  .yylimit = bufsize,
                  .token = bufsize,
                  .eof = false,
              };
              @memset(st.yyinput[st.yylimit..st.yylimit + yymaxfill], 0); // zero-padding at the end

              // Run the lexer.
              try std.testing.expectEqual(lex(&amp;st, &amp;br), count);

              // Cleanup: remove input file.
              fr.close();
              try std.fs.cwd().deleteFile(fname);
          }

</pre><h4><b>FEATURES</b></h4><pre>
   <b>Multiple</b> <b>blocks</b>
       Sometimes  it  is  necessary  to have multiple interrelated lexers (for example, if there is a high-level
       state machine that transitions between lexer modes). This can be  implemented  using  multiple  connected
       re2zig blocks. Another option is to use start conditions.

       The  implementation of connections between blocks depends on the target language.  In languages that have
       <b>goto</b> statement (such as C/C++ and Go) one can have all blocks in one function, each of them prefixed with
       a label. Transition from one block to another is a simple <b>goto</b>.  In languages that do not have <b>goto</b> (such
       as Rust) it is necessary to use a loop with a  switch  on  a  state  variable,  similar  to  the  <b>yystate</b>
       loop/switch generated by re2zig, or else wrap each block in a function and use function calls.

       The example below uses multiple blocks to parse binary, octal, decimal and hexadecimal numbers. Each base
       has  its  own  block.  The  initial  block  determines  base  and  dispatches  to  other  blocks.  Common
       configurations are defined in a separate block at the beginning of the program; they are inherited by the
       other blocks.

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          // Store u32 number in u64 during parsing to simplify overflow handling.
          const State = struct {
              yyinput: [:0]const u8,
              yycursor: usize,
              yymarker: usize,
              num: u64,
          };

          // Common re2c definitions shared between all functions.
          %{
              re2c:api = record;
              re2c:yyrecord = st;
              re2c:yyfill:enable = 0;
          %}

          const ERROR: u64 = @as(u64, std.math.maxInt(u32)) + 1; // overflow

          // Add digit with the given base, checking for overflow.
          fn add(st: *State, offs: u8, base: u64) void {
              const digit = st.yyinput[st.yycursor - 1] - offs;
              st.num = @min(st.num * base + digit, ERROR);
          }

          // Convert u64 to optional u32 (null meaning overflow or parse error).
          fn maybeU32(num: u64) ?u32 {
              return if (num &lt; ERROR) @intCast(num) else null;
          }

          fn parse_u32(s: [:0]const u8) ?u32 {
              var st = State {.yyinput = s, .yycursor = 0, .yymarker = 0, .num = 0};
              %{
                  '0b' / [01]        { return parse_bin(&amp;st); }
                  "0"                { return parse_oct(&amp;st); }
                  "" / [1-9]         { return parse_dec(&amp;st); }
                  '0x' / [0-9a-fA-F] { return parse_hex(&amp;st); }
                  *                  { return null; }
              %}
          }

          fn parse_bin(st: *State) ?u32 {
              bin: while (true) {%{
                  [01] { add(st, 48, 2); continue :bin; }
                  *    { return maybeU32(st.num); }
              %}}
          }

          fn parse_oct(st: *State) ?u32 {
              oct: while (true) {%{
                  [0-7] { add(st, 48, 8); continue :oct; }
                  *     { return maybeU32(st.num); }
              %}}
          }

          fn parse_dec(st: *State) ?u32 {
              dec: while (true) {%{
                  [0-9] { add(st, 48, 10); continue :dec; }
                  *     { return maybeU32(st.num); }
              %}}
          }

          fn parse_hex(st: *State) ?u32 {
              hex: while (true) {%{
                  [0-9] { add(st, 48, 16); continue :hex; }
                  [a-f] { add(st, 87, 16); continue :hex; }
                  [A-F] { add(st, 55, 16); continue :hex; }
                  *     { return maybeU32(st.num); }
              %}}
          }

          test {
              try std.testing.expectEqual(parse_u32(""), null);
              try std.testing.expectEqual(parse_u32("1234567890"), 1234567890);
              try std.testing.expectEqual(parse_u32("0b1101"), 13);
              try std.testing.expectEqual(parse_u32("0x7Fe"), 2046);
              try std.testing.expectEqual(parse_u32("0644"), 420);
              try std.testing.expectEqual(parse_u32("9999999999"), null);
          }

   <b>Start</b> <b>conditions</b>
       Start conditions are enabled with <b>--start-conditions</b> option.  They  provide  a  way  to  encode  multiple
       interrelated automata within the same re2zig block.

       Each condition corresponds to a single automaton and has a unique name specified by the user and a unique
       internal  number defined by re2zig. The numbers are used to switch between conditions: the generated code
       uses <b>YYGETCOND</b> and <b>YYSETCOND</b> primitives to get the current condition or set it to the given  number.  Use
       <b>conditions</b> block, <b>--header</b> option or <b>re2c:header</b> configuration to generate numeric condition identifiers.
       Configuration <b>re2c:cond:enumprefix</b> specifies the generated identifier prefix.

       In  condition  mode  every  rule must be prefixed with a list of comma-separated condition names in angle
       brackets, or a wildcard <b>&lt;*&gt;</b> to denote all conditions. The rule syntax is extended as follows:

          <b>&lt;</b> <b>condition-list</b> <b>&gt;</b> <b>regular-expression</b> <b>code</b>
                 A rule that is merged to every condition on the <b>condition-list</b>.  It matches  <b>regular-expression</b>
                 and executes the associated <b>code</b>.

          <b>&lt;</b> <b>condition-list</b> <b>&gt;</b> <b>regular-expression</b> <b>=&gt;</b> <b>condition</b> <b>code</b>
                 A rule that is merged to every condition on the <b>condition-list</b>.  It matches <b>regular-expression</b>,
                 sets the current condition to <b>condition</b> and executes the associated <b>code</b>.

          <b>&lt;</b> <b>condition-list</b> <b>&gt;</b> <b>regular-expression</b> <b>:=&gt;</b> <b>condition</b>
                 A  rule that is merged to every condition on the <b>condition-list</b>.  It matches <b>regular-expression</b>
                 and immediately transitions to <b>condition</b> (there is no semantic action).

          <b>&lt;</b> <b>condition-list</b> <b>&gt;</b> <b>!action</b> <b>code</b>
                 A rule that binds <b>code</b> to the place defined by <b>action</b> in every condition on the  <b>condition-list</b>
                 (see the actions section for various types of actions).

          <b>&lt;!</b> <b>condition-list</b> <b>&gt;</b> <b>code</b>
                 A  rule  that  prepends  <b>code</b>  to  semantic  actions  of  all  rules for every condition on the
                 <b>condition-list</b>. This syntax is deprecated and the <b>!pre_rule</b> action should be used  instead  (it
                 does exactly the same).

          <b>&lt;</b> <b>&gt;</b> <b>code</b>
                 A  rule that creates a special entry condition with number zero and name <b>"0"</b> that executes <b>code</b>
                 before jumping to other conditions.  This syntax is deprecated, and the <b>!entry</b> action should be
                 used instead (it provides a more fine-grained control, as  the  code  can  be  specified  on  a
                 per-condition  basis,  and  one  can  jump  directly  to  condition start without going through
                 condition dispatch).

          <b>&lt;</b> <b>&gt;</b> <b>=&gt;</b> <b>condition</b> <b>code</b>
                 Same as the previous rule, except that it sets the next <b>condition</b>.

          <b>&lt;</b> <b>&gt;</b> <b>:=&gt;</b> <b>condition</b>
                 Same as the previous rule, except that it has no  associated  code  and  immediately  jumps  to
                 <b>condition</b>.

       The  code  re2zig  generates  for  conditions  depends  on  whether  re2zig  uses  goto/label approach or
       loop/switch approach to encode the automata.

       In languages that have <b>goto</b> statement (such as C/C++ and Go)  conditions  are  naturally  implemented  as
       blocks  of code prefixed with labels of the form <b>yyc_&lt;cond&gt;</b>, where <b>cond</b> is a condition name (label prefix
       can be changed with <b>re2c:cond:prefix</b>). Transitions between conditions  are  implemented  using  <b>goto</b>  and
       condition  labels.  Before  all conditions re2zig generates an initial switch on <b>YYGETSTATE</b> that jumps to
       the start state of the current condition.  The shortcut rules <b>:=&gt;</b> bypass  the  initial  switch  and  jump
       directly  to  the  specified  condition  (<b>re2c:cond:goto</b> can be used to change the default behavior). The
       rules with semantic actions do not automatically jump to the next condition; this should be done  by  the
       user-defined action code.

       In  languages  that do not have <b>goto</b> (such as Rust) re2zig reuses the <b>yystate</b> variable to store condition
       numbers. Each condition gets a numeric identifier equal to the number of its start state,  and  a  switch
       between  conditions  is  no different than a switch between DFA states of a single condition. There is no
       need for a separate initial condition switch.  (Since the same approach is  used  to  implement  storable
       states, <b>YYGETCOND</b>/<b>YYSETCOND</b> are redundant if both storable states and conditions are used).

       The program below uses start conditions to parse binary, octal, decimal and hexadecimal numbers. There is
       a  single  block  where each base has its own condition, and the initial condition is connected to all of
       them. User-defined variable <b>cond</b> stores the current condition number; it is initialized to the number  of
       the initial condition generated with <b>conditions</b> block.

          // re2zig $INPUT -o $OUTPUT -c

          const std = @import("std");

          %{conditions %}

          const ERROR: u64 = @as(u64, std.math.maxInt(u32)) + 1; // overflow

          // Add digit with the given base, checking for overflow.
          fn add(num: *u64, str: [:0]const u8, cur: usize, offs: u8, base: u64) void {
              num.* = @min(num.* * base + (str[cur - 1] - offs), ERROR);
          }

          fn parse_u32(yyinput: [:0]const u8) ?u32 {
              var yycursor: usize = 0;
              var yymarker: usize = 0;
              var yycond = yycinit;
              var num: u64 = 0; // Store number in u64 to simplify overflow checks.

              loop: while(true) {
              %{
                  re2c:yyfill:enable = 0;

                  &lt;init&gt; '0b' / [01]        :=&gt; bin
                  &lt;init&gt; "0"                :=&gt; oct
                  &lt;init&gt; "" / [1-9]         :=&gt; dec
                  &lt;init&gt; '0x' / [0-9a-fA-F] :=&gt; hex
                  &lt;init&gt; * { return null; }

                  &lt;bin&gt; [01]  { add(&amp;num, yyinput, yycursor, 48, 2);  continue :loop; }
                  &lt;oct&gt; [0-7] { add(&amp;num, yyinput, yycursor, 48, 8);  continue :loop; }
                  &lt;dec&gt; [0-9] { add(&amp;num, yyinput, yycursor, 48, 10); continue :loop; }
                  &lt;hex&gt; [0-9] { add(&amp;num, yyinput, yycursor, 48, 16); continue :loop; }
                  &lt;hex&gt; [a-f] { add(&amp;num, yyinput, yycursor, 87, 16); continue :loop; }
                  &lt;hex&gt; [A-F] { add(&amp;num, yyinput, yycursor, 55, 16); continue :loop; }

                  &lt;bin, oct, dec, hex&gt; * {
                      return if (num &lt; ERROR) @intCast(num) else null;
                  }
              %}}
          }

          test {
              try std.testing.expectEqual(parse_u32(""), null);
              try std.testing.expectEqual(parse_u32("1234567890"), 1234567890);
              try std.testing.expectEqual(parse_u32("0b1101"), 13);
              try std.testing.expectEqual(parse_u32("0x7Fe"), 2046);
              try std.testing.expectEqual(parse_u32("0644"), 420);
              try std.testing.expectEqual(parse_u32("9999999999"), null);
          }

   <b>Storable</b> <b>state</b>
       With  <b>--storable-state</b>  option  re2zig  generates a lexer that can store its current state, return to the
       caller, and later resume operations exactly where it left off. The default mode of operation in re2zig is
       a "pull" model, in which the lexer "pulls" more input whenever it needs it. This may be  unacceptable  in
       cases  when  the  input  becomes  available  piece  by piece (for example, if the lexer is invoked by the
       parser, or if the lexer program communicates via a socket protocol with some other program that must wait
       for a reply from the lexer before it transmits the next message).  Storable  state  feature  is  intended
       exactly  for  such  cases:  it  allows one to generate lexers that work in a "push" model. When the lexer
       needs more input, it stores its state  and  returns  to  the  caller.  Later,  when  more  input  becomes
       available,  the  caller  resumes  the  lexer  exactly where it stopped. There are a few changes necessary
       compared to the "pull" model:

       • Define <b>YYSETSTATE()</b> and <b>YYGETSTATE(state)</b> primitives.

       • Define <b>yych</b>, <b>yyaccept</b> (if used) and <b>state</b> variables as a part of  persistent  lexer  state.  The  <b>state</b>
         variable should be initialized to <b>-1</b>.

       • <b>YYFILL</b>  should  return  to the outer program instead of trying to supply more input. Return code should
         indicate that lexer needs more input.

       • The outer program should recognize situations when lexer needs more input and respond appropriately.

       • Optionally use <b>getstate</b> block to generate <b>YYGETSTATE</b> switch detached from the  main  lexer.  This  only
         works for languages that have <b>goto</b> (not in <b>--loop-switch</b> mode).

       • Use  <b>re2c:eof</b>  and  the  sentinel  with  bounds checks method to handle the end of input. Padding-based
         method may not work because it is unclear when to append padding: the current end of input may  not  be
         the  ultimate end of input, and appending padding too early may cut off a partially read greedy lexeme.
         Furthermore, due to high-level program logic getting more input may depend on processing the lexeme  at
         the end of buffer (which already is blocked due to the end-of-input condition).

       Here  is an example of a "push" model lexer that simulates reading packets from a socket. The lexer loops
       until it encounters the end of input and returns to the calling function. The calling  function  provides
       more  input by "sending" the next packet and resumes lexing. This process stops when all the packets have
       been sent, or when there is an error.

          // re2zig $INPUT -o $OUTPUT -f

          const std = @import("std");

          const Status = enum {
              end,
              ready,
              waiting,
              bad_packet,
              big_packet
          };

          // Use a small buffer to cover the case when a lexeme doesn't fit.
          // In real world use a larger buffer.
          const bufsize = 10;

          const State = struct {
              yyinput: [bufsize + 1]u8,
              yycursor: usize,
              yymarker: usize,
              yylimit: usize,
              token: usize,
              yystate: i32,
              received: usize,
          };

          fn fill(st: *State, file: anytype) Status {
              // Error: lexeme too long. In real life can reallocate a larger buffer.
              if (st.token &lt; 1) { return Status.big_packet; }

              // Shift buffer contents (discard everything up to the current token).
              std.mem.copyBackwards(
                  u8, st.yyinput[0..st.yylimit - st.token], st.yyinput[st.token..st.yylimit]);
              st.yycursor -= st.token;
              st.yymarker = @subWithOverflow(st.yymarker, st.token)[0];
              st.yylimit -= st.token;
              st.token = 0;

              // Fill free space at the end of buffer with new data from file.
              st.yylimit += file.read(st.yyinput[st.yylimit..bufsize]) catch 0;
              st.yyinput[st.yylimit] = 0; // append sentinel symbol

              return Status.ready;
          }

          fn lex(yyrecord: *State) Status {
              var yych: u8 = 0;
              loop: while (true) {
                  yyrecord.token = yyrecord.yycursor;
                  %{
                      re2c:api = record;
                      re2c:eof = 0;
                      re2c:YYFILL = "return Status.waiting;";

                      packet = [a-z]+[;];

                      *      { return Status.bad_packet; }
                      $      { return Status.end; }
                      packet { yyrecord.received += 1; continue :loop; }
                  %}
              }
          }

          fn run(expect: Status, packets: []const []const u8) !void {
              // Create a "pipe" (open the same file for reading and writing).
              const fname = "input";
              var fw = try std.fs.cwd().createFile(fname, .{});
              var fr = try std.fs.cwd().openFile(fname, .{ .mode = .read_only});

              // Initialize lexer state: `state` value is -1, all offsets are at the end
              // of buffer. Normally file would be part of the state, but BufferedReader
              // type is unclear.
              var br = std.io.bufferedReader(fr.reader());
              var st = State{
                  .yyinput = undefined,
                  .yycursor = bufsize,
                  .yymarker = bufsize,
                  .yylimit = bufsize,
                  .token = bufsize,
                  .yystate = -1,
                  .received = 0,
              };
              // Sentinel at `yylimit` offset is set to zero, which triggers YYFILL.
              st.yyinput[st.yylimit] = 0;

              // Main loop. The buffer contains incomplete data which appears packet by
              // packet. When the lexer needs more input it saves its internal state and
              // returns to the caller which should provide more input and resume lexing.
              var status = Status.ready;
              var send: usize = 0;
              while (true) {
                  status = lex(&amp;st);
                  if (status == Status.end) {
                      break;
                  } else if (status == Status.waiting) {
                      if (send &lt; packets.len) {
                          std.log.debug("sending packet {}", .{send});
                          try fw.writeAll(packets[send]);
                          send += 1;
                      }
                      status = fill(&amp;st, &amp;br);
                      std.log.debug("filled buffer [{s}], status {}", .{st.yyinput, status});
                      if (status != Status.ready) {
                          break;
                      }
                  } else if (status == Status.bad_packet) {
                      break;
                  }
              }

              // Check results.
              try std.testing.expectEqual(status, expect);
              if (status == Status.end) { try std.testing.expectEqual(st.received, send); }

              // Cleanup: remove input file.
              fw.close();
              fr.close();
              try std.fs.cwd().deleteFile(fname);
          }

          test {
              try run(Status.end, &amp;[_][]const u8{});
              try run(Status.end, &amp;[_][]const u8{"zero;", "one;", "two;", "three;", "four;"});
              try run(Status.bad_packet, &amp;[_][]const u8{"??;"});
              try run(Status.big_packet, &amp;[_][]const u8{"looooooooooooong;"});
          }

   <b>Reusable</b> <b>blocks</b>
       Reusable blocks of the form <b>/*!rules:re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> or <b>%{rules[:&lt;name&gt;]</b> <b>...</b> <b>%}</b> can  be  reused  any
       number  of times and combined with other re2zig blocks. The <b>&lt;name&gt;</b> is optional. A rules block can be used
       in a <b>use</b> block or directive. The code for a rules block is generated at every point of use.

       Use blocks are defined with <b>/*!use:re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> or <b>%{use[:&lt;name&gt;]</b> <b>...</b> <b>%}</b>. The <b>&lt;name&gt;</b> is optional:
       if it's not specified, the associated rules block is the most recent one (whether named or  unnamed).   A
       use  block can add named definitions, configurations and rules of its own.  An important use case for use
       blocks is a lexer that supports multiple input encodings: the same rules block is reused  multiple  times
       with encoding-specific configurations (see the example below).

       In-block  use  directive <b>!use:&lt;name&gt;;</b> can be used from inside of a re2zig block. It merges the referenced
       block <b>&lt;name&gt;</b> into the current one. If some of the  merged  rules  and  configurations  overlap  with  the
       previously  defined  ones, conflicts are resolved in the usual way: the earliest rule takes priority, and
       latest configuration overrides preceding ones. One exception are the special rules <b>*</b>, <b>$</b> and (in condition
       mode) <b>&lt;!&gt;</b>, for which a block-local definition overrides any inherited ones. Use directive allows  one  to
       combine different re2zig blocks together in one block (see the example below).

       Named  blocks  and  in-block use directive were added in re2zig version 2.2.  Since that version reusable
       blocks are allowed by default (no special option is needed). Before version 2.2 reuse  mode  was  enabled
       with <b>-r</b> <b>--reusable</b> option. Before version 1.2 reusable blocks could not be mixed with normal blocks.

   <b>Example</b> <b>of</b> <b>a</b> <b>!use</b> <b>directive</b>
          // re2zig $INPUT -o $OUTPUT

          // This example shows how to combine reusable re2c blocks: two blocks
          // ('colors' and 'fish') are merged into one. The 'salmon' rule occurs
          // in both blocks; the 'fish' block takes priority because it is used
          // earlier. Default rule * occurs in all three blocks; the local (not
          // inherited) definition takes priority.

          const std = @import("std");

          const Ans = enum {color, fish, dunno};

          %{rules:colors
              *                            { @panic("ah"); }
              "red" | "salmon" | "magenta" { return Ans.color; }
          %}

          %{rules:fish
              *                            { @panic("oh"); }
              "haddock" | "salmon" | "eel" { return Ans.fish; }
          %}

          fn lex(yyinput: [:0]const u8) Ans {
              var yycursor: usize = 0;
              var yymarker: usize = 0;
              %{
                  re2c:yyfill:enable = 0;

                  !use:fish;
                  !use:colors;
                  * { return Ans.dunno; } // overrides inherited '*' rules
              %}
          }

          test {
              try std.testing.expectEqual(lex("salmon"), Ans.fish);
              try std.testing.expectEqual(lex("what?"), Ans.dunno);
          }

   <b>Example</b> <b>of</b> <b>a</b> <b>/*!use:re2c</b> <b>...</b> <b>*/</b> <b>block</b>
          // re2zig $INPUT -o $OUTPUT --input-encoding utf8

          // This example supports multiple input encodings: UTF-8 and UTF-32.
          // Both lexers are generated from the same rules block, and the use
          // blocks add only encoding-specific configurations.

          const std = @import("std");

          %{rules
              re2c:yyfill:enable = 0;

              "∀x ∃y" { return yycursor; }
              *       { return null; }
          %}

          fn lex_utf8(yyinput: []const u8) ?usize {
              var yycursor: usize = 0;
              var yymarker: usize = 0;
              %{use
                  re2c:encoding:utf8 = 1;
                  re2c:YYCTYPE = u8; // the default
              %}
          }

          fn lex_utf32(yyinput: []const u32) ?usize {
              var yycursor: usize = 0;
              var yymarker: usize = 0;
              %{use
                  re2c:encoding:utf32 = 1;
                  re2c:YYCTYPE = u32;
              %}
          }

          test {
              const s8 = [_]u8{0xe2, 0x88, 0x80, 0x78, 0x20, 0xe2, 0x88, 0x83, 0x79};
              try std.testing.expectEqual(lex_utf8(&amp;s8), s8.len);

              const s32 = [_]u32{0x2200, 0x78, 0x20, 0x2203, 0x79};
              try std.testing.expectEqual(lex_utf32(&amp;s32), s32.len);
          }

   <b>Submatch</b> <b>extraction</b>
       re2zig has two options for submatch extraction.

       <b>Tags</b>   The  first  option  is  to use standalone <u>tags</u> of the form <b>@stag</b> or <b>#mtag</b>, where <b>stag</b> and <b>mtag</b> are
              arbitrary used-defined  names.   Tags  are  enabled  with  <b>-T</b>  <b>--tags</b>  option  or  <b>re2c:tags</b>  <b>=</b>  <b>1</b>
              configuration.  Semantically tags are position markers: they can be inserted anywhere in a regular
              expression, and they bind to the corresponding position  (or  multiple  positions)  in  the  input
              string.   <u>S-tags</u>  bind to the last matching position, and <u>m-tags</u> bind to a list of positions (they
              may be used in repetition  subexpressions,  where  a  single  position  in  a  regular  expression
              corresponds  to  multiple  positions in the input string). All tags should be defined by the user,
              either manually or with the help of <b>svars</b> and <b>mvars</b> blocks. If there is more than one way tags can
              be matched against the input, ambiguity is resolved using leftmost greedy disambiguation strategy.

       <b>Captures</b>
              The second option is to  use  <u>capturing</u>  <u>groups</u>.  They  are  enabled  with  <b>--captures</b>  option  or
              <b>re2c:captures</b>  <b>=</b>  <b>1</b>  configuration.  There are two flavours for different disambiguation policies,
              <b>--leftmost-captures</b> (the default) is for leftmost greedy  policy,  and,  <b>--posix-captures</b>  is  for
              POSIX longest-match policy. In this mode all parenthesized subexpressions are considered capturing
              groups,  and  a  bang  can  be used to mark non-capturing groups: <b>(!</b> <b>...</b> <b>)</b>. With <b>--invert-captures</b>
              option or <b>re2c:invert-captures</b> <b>=</b> <b>1</b> configuration the meaning of bang is inverted.  The  number  of
              groups  for  the  matching  rule is stored in a variable <b>yynmatch</b> (the whole regular expression is
              group number zero), and submatch results are stored in <b>yypmatch</b> array. Both <b>yynmatch</b> and  <b>yypmatch</b>
              should  be  defined  by the user, and <b>yypmatch</b> size must be at least <b>[yynmatch</b> <b>*</b> <b>2]</b>. Use <b>maxnmatch</b>
              block to  define <b>YYMAXNMATCH</b>, a constant that equals to the maximum value of  <b>yynmatch</b>  among  all
              rules.

       <b>Captvars</b>
              Another  way  to use capturing groups is the <b>--captvars</b> option or <b>re2c:captvars</b> <b>=</b> <b>1</b> configuration.
              The only difference with <b>--captures</b> is in the way the  generated  code  stores  submatch  results:
              instead of <b>yynmatch</b> and <b>yypmatch</b> re2zig generates variables <b>yytl&lt;k&gt;</b> and <b>yytr&lt;k&gt;</b> for <u>k</u>-th capturing
              group  (the  user  should declare these using an <b>svars</b> block). Captures with variables support two
              disambiguation policies: <b>--leftmost-captvars</b> or <b>re2c:leftmost-captvars</b> <b>=</b>  <b>1</b>  for  leftmost  greedy
              policy  (the  default  one)  and  <b>--posix-captvars</b>  or <b>re2c:posix-captvars</b> for POSIX longest-match
              policy.

       Under the hood all these options translate into  tags  and  Tagged  Deterministic  Finite  Automata  with
       Lookahead  &lt;https://arxiv.org/abs/1907.08837&gt;  .   The  core  idea of TDFA is to minimize the overhead on
       submatch extraction.  In the extreme, if there're no tags or captures in a regular  expression,  TDFA  is
       just an ordinary DFA. If the number of tags is moderate, the overhead is barely noticeable. The generated
       TDFA  uses a number of <u>tag</u> <u>variables</u> which do not map directly to tags: a single variable may be used for
       different tags, and a tag may require multiple variables to hold  all  its  possible  values.  Eventually
       ambiguity  is  resolved,  and  only  one final variable per tag survives. Tag variables should be defined
       using <b>stags</b> or <b>mtags</b> blocks. If lexer state is stored, tag variables should be part of it. They also need
       to be updated  by <b>YYFILL</b>.

       S-tags support the following operations:

       • save input position to an s-tag: <b>t</b> <b>=</b> <b>YYCURSOR</b> with C pointer API or a user-defined operation <b>YYSTAGP(t)</b>
         with generic API

       • save default value to an s-tag: <b>t</b> <b>=</b> <b>NULL</b> with C pointer API or a user-defined operation <b>YYSTAGN(t)</b> with
         generic API

       • copy one s-tag to another: <b>t1</b> <b>=</b> <b>t2</b>

       M-tags support the following operations:

       • append input position to an m-tag: a user-defined operation <b>YYMTAGP(t)</b> with both  default  and  generic
         API

       • append default value to an m-tag: a user-defined operation <b>YYMTAGN(t)</b> with both default and generic API

       • copy one m-tag to another: <b>t1</b> <b>=</b> <b>t2</b>

       S-tags  can  be  implemented  as  scalar  values  (pointers  or  offsets).  M-tags  need  a  more complex
       representation, as they need to  store  a  sequence  of  tag  values.  The  most  naive  and  inefficient
       representation of an m-tag is a list (array, vector) of tag values; a more efficient representation is to
       store  all  m-tags in a prefix-tree represented as array of nodes <b>(v,</b> <b>p)</b>, where <b>v</b> is tag value and <b>p</b> is a
       pointer to parent node.

       Here is a simple example of  using  s-tags  to  parse  semantic  versions  consisting  of  three  numeric
       components: major, minor, patch (the latter is optional).  See below for a more complex example that uses
       <b>YYFILL</b>.

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          const SemVer = struct {
              major: u32,
              minor: u32,
              patch: u32,
          };

          const none = std.math.maxInt(usize);

          fn s2n(str: []const u8) u32 { // convert a pre-parsed string to a number
              var n: u32 = 0;
              for (str) |c| { n = n * 10 + (c - 48); }
              return n;
          }

          fn parse(yyinput: [:0]const u8) ?SemVer {
              var yycursor: usize = 0;
              var yymarker: usize = 0;

              // Final tag variables available in semantic action.
              %{svars format = "var @@: usize = none;"; %}

              // Intermediate tag variables used by the lexer (must be autogenerated).
              %{stags format = "var @@: usize = none;"; %}

              %{
                  re2c:yyfill:enable = 0;
                  re2c:tags = 1;

                  num = [0-9]+;

                  @t1 num @t2 "." @t3 num @t4 ("." @t5 num)? [\x00] {
                      return SemVer {
                          .major = s2n(yyinput[t1..t2]),
                          .minor = s2n(yyinput[t3..t4]),
                          .patch = if (t5 == none) 0 else s2n(yyinput[t5..yycursor - 1]),
                      };
                  }
                  * { return null; }
              %}
          }

          test {
              try std.testing.expectEqual(parse("23.34"), SemVer{.major = 23, .minor = 34, .patch = 0});
              try std.testing.expectEqual(parse("1.2.99999"), SemVer{.major = 1, .minor = 2, .patch = 99999});
              try std.testing.expectEqual(parse("1.a"), null);
          }

       Here  is  a  more  complex  example  of  using  s-tags with <b>YYFILL</b> to parse a file with newline-separated
       semantic versions. Tag variables are part of the lexer state, and they are adjusted in <b>YYFILL</b> like  other
       input  positions.   Note  that  it  is  necessary  for  s-tags because their values are invalidated after
       shifting buffer contents. It may not be necessary in a custom implementation where  tag  variables  store
       offsets  relative  to  the  start  of the input string rather than the buffer, which may be the case with
       m-tags.

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          const bufsize = 4095;
          const none = std.math.maxInt(usize);

          const err = error.SyntaxError;

          const SemVer = struct {
              major: u32,
              minor: u32,
              patch: u32,
          };

          fn s2n(str: []const u8) u32 { // convert a pre-parsed string to a number
              var n: u32 = 0;
              for (str) |c| { n = n * 10 + (c - 48); }
              return n;
          }

          const State = struct {
              yyinput: [bufsize + 1]u8,
              yycursor: usize,
              yymarker: usize,
              yylimit: usize,
              token: usize,
              // Intermediate tag variables must be part of the lexer state passed to YYFILL.
              // They don't correspond to tags and should be autogenerated by re2c.
              %{stags format = "@@: usize,\n"; %}
              eof: bool
          };

          fn fill(st: *State, file: anytype) i32 {
              if (st.eof) { return -1; } // unexpected EOF

              // Error: lexeme too long. In real life can reallocate a larger buffer.
              if (st.token &lt; 1) { return -2; }

              // Shift buffer contents (discard everything up to the current token).
              std.mem.copyBackwards(
                  u8, st.yyinput[0..st.yylimit - st.token], st.yyinput[st.token..st.yylimit]);
              st.yycursor -= st.token;
              st.yymarker = @subWithOverflow(st.yymarker, st.token)[0];
              st.yylimit -= st.token;
              // Tag variables need to be shifted like other input positions. The check
              // for NONE is only needed if some tags are nested inside of alternative or
              // repetition, so that they can have NONE value.
              %{stags format = "if (st.@@ != none) st.@@ = @subWithOverflow(st.@@, st.token)[0];\n"; %}
              st.token = 0;

              // Fill free space at the end of buffer with new data from file.
              st.yylimit += file.read(st.yyinput[st.yylimit..bufsize]) catch 0;
              st.yyinput[st.yylimit] = 0; // append sentinel symbol

              // If read less than expected, this is the end of input.
              st.eof = st.yylimit &lt; bufsize;

              return 0;
          }

          fn parse(st: *State, file: anytype) !std.ArrayList(SemVer) {
              var vers = std.ArrayList(SemVer).init(std.testing.allocator);

              // Final tag variables available in semantic action.
              %{svars format = "var @@: usize = 0;\n"; %}

              loop: while (true) {
                  st.token = st.yycursor;
                  %{
                      re2c:api = record;
                      re2c:eof = 0;
                      re2c:tags = 1;
                      re2c:yyrecord = st;
                      re2c:YYFILL = "fill(st, file) == 0";

                      num = [0-9]+;

                      num @t1 "." @t2 num @t3 ("." @t4 num)? [\n] {
                          try vers.append(SemVer {
                              .major = s2n(st.yyinput[st.token..t1]),
                              .minor = s2n(st.yyinput[t2..t3]),
                              .patch = if (t4 == none) 0 else s2n(st.yyinput[t4..st.yycursor - 1]),
                          });
                          continue :loop;
                      }
                      $ { return vers; }
                      * { return error.SyntaxError; }
                  %}
              }
          }

          test {
              const fname = "input";
              const content = "1.22.333\n" ** bufsize;

              // Prepare input file: a few times the size of the buffer, containing
              // strings with zeroes and escaped quotes.
              var fw = try std.fs.cwd().createFile(fname, .{});
              try fw.writeAll(content);
              fw.close();

              // Prepare lexer state: all offsets are at the end of buffer.
              var fr = try std.fs.cwd().openFile(fname, .{ .mode = .read_only});
              // Normally file would be part of the state struct, but BufferedReader type is unclear.
              var br = std.io.bufferedReader(fr.reader());
              var st = State{
                  .yyinput = undefined,
                  .yycursor = bufsize,
                  .yymarker = bufsize,
                  .yylimit = bufsize,
                  .token = bufsize,
                  %{stags format = ".@@ = none,\n"; %}
                  .eof = false,
              };
              // Sentinel at `yylimit` offset is set to zero, which triggers YYFILL.
              st.yyinput[st.yylimit] = 0;

              // Manually construct expected result.
              var expect = std.ArrayList(SemVer).init(std.testing.allocator);
              for (0..bufsize) |_| try expect.append(SemVer{.major = 1, .minor = 22, .patch = 333});

              // Run the lexer.
              var result = try parse(&amp;st, &amp;br);
              try std.testing.expectEqualDeep(result, expect);

              // Cleanup: free memory and remove input file.
              expect.deinit();
              result.deinit();
              fr.close();
              try std.fs.cwd().deleteFile(fname);
          }

       Here is an example of using capturing groups to parse semantic versions.

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          const none = std.math.maxInt(usize);

          const SemVer = struct {
              major: u32,
              minor: u32,
              patch: u32,
          };

          fn s2n(str: []const u8) u32 { // convert pre-parsed string to a number
              var n: u32 = 0;
              for (str) |c| { n = n * 10 + (c - 48); }
              return n;
          }

          fn parse(yyinput: [:0]const u8) ?SemVer {
              var yycursor: usize = 0;
              var yymarker: usize = 0;

              // Final tag variables available in semantic action.
              %{svars format = "var @@: usize = none;"; %}

              // Intermediate tag variables used by the lexer (must be autogenerated).
              %{stags format = "var @@: usize = none;"; %}

              %{
                  re2c:yyfill:enable = 0;
                  re2c:captvars = 1;

                  num = [0-9]+;

                  (num) "." (num) ("." num)? [\x00] {
                      return SemVer {
                          .major = s2n(yyinput[yytl1..yytr1]),
                          .minor = s2n(yyinput[yytl2..yytr2]),
                          .patch = if (yytl3 == none) 0 else s2n(yyinput[yytl3 + 1..yytr3])
                      };
                  }
                  * { return null; }
              %}
          }

          test {
              try std.testing.expectEqual(parse("23.34"), SemVer{.major = 23, .minor = 34, .patch = 0});
              try std.testing.expectEqual(parse("1.2.99999"), SemVer{.major = 1, .minor = 2, .patch = 99999});
              try std.testing.expectEqual(parse("1.a"), null);
          }

       Here is an example of using m-tags to parse a version with a variable number of components. Tag variables
       are stored in a trie.

          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          const none = std.math.maxInt(usize);
          const mtag_root = none - 1;

          const err = error.SyntaxError;

          // An m-tag tree is a way to store histories with an <a href="../man1/O.1.html">O</a>(1) copy operation.
          // Histories naturally form a tree, as they have common start and fork at some
          // point. The tree is stored as an array of pairs (tag value, link to parent).
          // An m-tag is represented with a single link in the tree (array index).
          const MtagElem = struct {
              elem: usize, // tag value
              pred: usize, // index of the predecessor node or root
          };

          // Append a single value to an m-tag history.
          fn add_mtag(trie: *std.ArrayList(MtagElem), mtag: usize, value: usize) !usize {
              try trie.append(MtagElem{.elem = value, .pred = mtag});
              return trie.items.len - 1;
          }

          // Recursively unwind tag histories and collect version components.
          fn unwind(trie: *std.ArrayList(MtagElem),
                    x: usize,
                    y: usize,
                    str: []const u8,
                    ver: *std.ArrayList(u32)) !void {
              // Reached the root of the m-tag tree, stop recursion.
              if (x == mtag_root and y == mtag_root) return;

              // Unwind history further.
              try unwind(trie, trie.items[x].pred, trie.items[y].pred, str, ver);

              // Get tag values. Tag histories must have equal length.
              std.debug.assert(x != mtag_root and y != mtag_root);
              const ex = trie.items[x].elem;
              const ey = trie.items[y].elem;

              if (ex != none and ey != none) {
                  // Both tags are valid string indices, extract component.
                  try ver.append(s2n(str[ex..ey]));
              } else {
                  // Both tags are none (this corresponds to zero repetitions).
                  std.debug.assert(ex == none and ey == none);
              }
          }

          fn s2n(str: []const u8) u32 { // convert a pre-parsed string to a number
              var n: u32 = 0;
              for (str) |c| { n = n * 10 + (c - 48); }
              return n;
          }

          fn parse(yyinput: [:0]const u8) !std.ArrayList(u32) {
              var yycursor: usize = 0;
              var yymarker: usize = 0;
              var mt = std.ArrayList(MtagElem).init(std.testing.allocator);
              defer mt.deinit();

              // Final tag variables available in semantic action.
              %{svars format = "var @@: usize = none;"; %}
              %{mvars format = "var @@: usize = mtag_root;"; %}

              // Intermediate tag variables used by the lexer (must be autogenerated).
              %{stags format = "var @@: usize = none;"; %}
              %{mtags format = "var @@: usize = mtag_root;"; %}

              %{
                  re2c:YYMTAGP = "@@ = add_mtag(&amp;mt, @@, yycursor) catch none;";
                  re2c:YYMTAGN = "@@ = add_mtag(&amp;mt, @@, none) catch none;";
                  re2c:yyfill:enable = 0;
                  re2c:tags = 1;

                  num = [0-9]+;

                  @t1 num @t2 ("." #t3 num #t4)* [\x00] {
                      var ver = std.ArrayList(u32).init(std.testing.allocator);
                      try ver.append(s2n(yyinput[t1..t2]));
                      try unwind(&amp;mt, t3, t4, yyinput, &amp;ver);
                      return ver;
                  }
                  * { return error.SyntaxError; }
              %}
          }

          test {
              var result = try parse("1");
              var expect = std.ArrayList(u32).init(std.testing.allocator);
              try expect.appendSlice(&amp;[_]u32{1});
              try std.testing.expectEqualDeep(result, expect);
              expect.deinit();
              result.deinit();
          }

          test {
              var result = try parse("1.2.3.4.5.6.7");
              var expect = std.ArrayList(u32).init(std.testing.allocator);
              try expect.appendSlice(&amp;[_]u32{1, 2, 3, 4, 5, 6, 7});
              try std.testing.expectEqualDeep(result, expect);
              expect.deinit();
              result.deinit();
          }

          test {
              const result = parse("1.2.") catch null;
              try std.testing.expectEqualDeep(result, null);
          }

   <b>Encoding</b> <b>support</b>
       It is necessary to understand the difference between <b>code</b> <b>points</b> and  <b>code</b>  <b>units</b>.  A  code  point  is  a
       numeric identifier of a symbol. A code unit is the smallest unit of storage in the encoded text. A single
       code point may be represented with one or more code units. In a fixed-length encoding all code points are
       represented  with  the  same  number  of  code  units.  In  a variable-length encoding code points may be
       represented with a different number of code units.  Note that the "any" rule <b>[^]</b> matches any code  point,
       but  not necessarily any code unit (the only way to match any code unit regardless of the encoding is the
       default rule <b>*</b>).  The generated lexer works with a stream of code units: <b>yych</b> stores  a  code  unit,  and
       <b>YYCTYPE</b>  is  the  code  unit type. Regular expressions, on the other hand, are specified in terms of code
       points. When re2zig compiles regular expressions to automata it translates code  points  to  code  units.
       This  is  generally  not a simple mapping: in variable-length encodings a single code point range may get
       translated to a complex code unit graph.  The following encodings are supported:

       • <b>ASCII</b> (enabled by default). It is a fixed-length encoding with  code  space  <b>[0-255]</b>  and  1-byte  code
         points and code units.

       • <b>EBCDIC</b>  (enabled  with <b>--ebcdic</b> or <b>re2c:encoding:ebcdic</b>). It is a fixed-length encoding with code space
         <b>[0-255]</b> and 1-byte code points and code units.

       • <b>UCS2</b> (enabled with <b>--ucs2</b> or <b>re2c:encoding:ucs2</b>).  It  is  a  fixed-length  encoding  with  code  space
         <b>[0-0xFFFF]</b> and 2-byte code points and code units.

       • <b>UTF8</b>  (enabled  with <b>--utf8</b> or <b>re2c:encoding:utf8</b>). It is a variable-length Unicode encoding. Code unit
         size is 1 byte. Code points are represented with 1 -- 4 code units.

       • <b>UTF16</b> (enabled with <b>--utf16</b> or <b>re2c:encoding:utf16</b>). It is a  variable-length  Unicode  encoding.  Code
         unit size is 2 bytes. Code points are represented with 1 -- 2 code units.

       • <b>UTF32</b>  (enabled  with  <b>--utf32</b> or <b>re2c:encoding:utf32</b>). It is a fixed-length Unicode encoding with code
         space <b>[0-0x10FFFF]</b> and 4-byte code points and code units.

       Include  file  <b>include/unicode_categories.re</b>  provides  re2zig  definitions  for  the  standard   Unicode
       categories.

       Option  <b>--input-encoding</b>  specifies source file encoding, which can be used to enable Unicode literals in
       regular expressions. For example <b>--input-encoding</b> <b>utf8</b> tells re2zig that the source file is in  UTF8  (it
       differs  from  <b>--utf8</b>  which sets input text encoding). Option <b>--encoding-policy</b> specifies the way re2zig
       handles Unicode surrogates (code points in range <b>[0xD800-0xDFFF]</b>).

       Below is an example of a lexer for UTF8 encoded Unicode identifiers.

          // re2zig $INPUT -o $OUTPUT --utf8

          const std = @import("std");

          %{include "unicode_categories.re" %}

          fn lex(yyinput: [:0]const u8) bool {
              var yycursor: u32 = 0;
              var yymarker: u32 = 0;

              %{
                  re2c:yyfill:enable = 0;

                  // Simplified "Unicode Identifier and Pattern Syntax"
                  // (see https://unicode.org/reports/tr31)
                  id_start    = L | Nl | [$_];
                  id_continue = id_start | Mn | Mc | Nd | Pc | [\u200D\u05F3];
                  identifier  = id_start id_continue*;

                  identifier { return true; }
                  *          { return false; }
              %}
          }

          test {
              try std.testing.expect(lex("_Ыдентификатор"));
          }

   <b>Include</b> <b>files</b>
       re2zig allows one to include other files using a block of the form <b>/*!include:re2c</b> <b>FILE</b> <b>*/</b>  or  <b>%{include</b>
       <b>FILE</b>  <b>%}</b>,  or  an  in-block  directive  <b>!include</b> <b>FILE</b> <b>;</b>, where <b>FILE</b> is a path to the file to be included.
       re2zig looks for include files in the directory of the including file and in include locations, which can
       be specified with the <b>-I</b> option. Include blocks/directives in re2zig  work  in  the  same  way  as  C/C++
       <b>#include</b>:  <b>FILE</b> contents are copy-pasted verbatim in place of the block/directive. Include files may have
       further includes of their own. Use <b>--depfile</b> option to track build dependencies of  the  output  file  on
       include  files.   re2zig  provides  some  predefined  include  files  that  can  be found in the <b>include/</b>
       subdirectory of the project. These files contain definitions that may be useful to other  projects  (such
       as  Unicode  categories)  and  form  something like a standard library for re2zig. Below is an example of
       using include files.

   <b>Include</b> <b>file</b> <b>1</b> <b>(definitions.zig)</b>
          const Num = enum { integer, floating, nan };

          %{
              number = [1-9][0-9]*;
          %}

   <b>Include</b> <b>file</b> <b>2</b> <b>(extra_rules.re.inc)</b>
          // floating-point numbers
          frac  = [0-9]* "." [0-9]+ | [0-9]+ ".";
          exp   = 'e' [+-]? [0-9]+;
          float = frac exp? | [0-9]+ exp;

          float { return Num.floating; }

   <b>Input</b> <b>file</b>
          // re2zig $INPUT -o $OUTPUT

          const std = @import("std");

          %{include "definitions.zig" %}

          fn lex(yyinput: [:0]const u8) Num {
              var yycursor: u32 = 0;
              var yymarker: u32 = 0;
              %{
                  re2c:yyfill:enable = 0;

                  *      { return Num.nan; }
                  number { return Num.integer; }
                  !include "extra_rules.re.inc";
              %}
          }

          test {
              try std.testing.expectEqual(lex("123"), Num.integer);
              try std.testing.expectEqual(lex("123.4567"), Num.floating);
          }

   <b>Header</b> <b>files</b>
       re2zig allows one to generate header file from the input <b>.re</b> file using <b>--header</b>  option  or  <b>re2c:header</b>
       configuration  and block pairs of the form <b>/*!header:re2c:on*/</b> and <b>/*!header:re2c:off*/</b>, or <b>%{header:on%}</b>
       and <b>%{header:off%}</b>. The first block marks the beginning of header file, and the second  block  marks  the
       end  of  it. Everything between these blocks is processed by re2zig, and the generated code is written to
       the file specified with <b>--header</b> option or <b>re2c:header</b> configuration (or <b>stdout</b>  if  neither  option  nor
       configuration  is used). Autogenerated header file may be needed in cases when re2zig is used to generate
       definitions  that must be visible from other translation units.

       Here is an example of generating a header file that contains definition  of  the  lexer  state  with  tag
       variables (the number variables depends on the regular grammar and is unknown to the programmer).

   <b>Input</b> <b>file</b>
          // re2zig $INPUT -o $OUTPUT --header lexer/state.zig

          const std = @import("std");
          const state = @import("lexer/state.zig"); // the module is generated by re2c

          %{header:on %}
          pub const State = struct {
              yyinput: [:0]const u8,
              yycursor: usize,
              %{stags format = "@@: usize,"; %}
          };
          %{header:off %}

          fn lex(yyrecord: *state.State) usize {
              var t: usize = 0;
              %{
                  re2c:header = "lexer/state.zig";
                  re2c:api = record;
                  re2c:yyfill:enable = 0;
                  re2c:tags = 1;

                  [a]* @t [b]* { return t; }
              %}
          }

          test {
              var st = state.State {
                  .yyinput = "ab",
                  .yycursor = 0,
                  %{stags format = ".@@ = 0,"; %}
              };
              try std.testing.expectEqual(lex(&amp;st), 1);
          }

   <b>Header</b> <b>file</b>
          // Generated by re2c

          pub const State = struct {
              yyinput: [:0]const u8,
              yycursor: usize,
              yyt1: usize,
          };

   <b>Skeleton</b> <b>programs</b>
       With  the  <b>-S,</b>  <b>--skeleton</b>  option,  re2zig  ignores all non-re2zig code and generates a self-contained C
       program that can be further compiled and executed.  The program consists of lexer code  and  input  data.
       For  each  constructed  DFA  (block  or  condition) re2zig generates a standalone lexer and two files: an
       <b>.input</b> file with strings derived from the DFA and a <b>.keys</b> file with expected match results.  The  program
       runs  each  lexer  on the corresponding <b>.input</b> file and compares results with the expectations.  Skeleton
       programs are very useful for a number of reasons:

       • They can check correctness of various re2zig optimizations (the data is generated early in the process,
         before any DFA transformations have taken place).

       • Generating a set of input data with good coverage may be useful for both testing and benchmarking.

       • Generating self-contained executable programs allows one to get minimized test cases (the original code
         may be large or have a lot of dependencies).

       The difficulty with generating input data is that for all but  the  most  trivial  cases  the  number  of
       possible input strings is too large (even if the string length is limited). re2zig solves this difficulty
       by  generating  sufficiently  many  strings  to  cover  almost all DFA transitions. It uses the following
       algorithm. First, it constructs a skeleton of the DFA. For encodings with 1-byte code unit size (such  as
       ASCII, UTF-8 and EBCDIC) skeleton is just an exact copy of the original DFA. For encodings with multibyte
       code  units  skeleton is a copy of DFA with certain transitions omitted: namely, re2zig takes at most 256
       code units for each disjoint continuous range that corresponds to a DFA transition.   The  chosen  values
       are  evenly  distributed  and  include range bounds. Instead of trying to cover all possible paths in the
       skeleton  (which  is  infeasible)  re2zig  generates  sufficiently  many  paths  to  cover  all  skeleton
       transitions,  and  thus  trigger  the  corresponding  conditional  jumps  in  the  lexer.   The algorithm
       implementation is limited by ~1Gb of transitions and consumes constant amount of  memory  (re2zig  writes
       data to file as soon as it is generated).

   <b>Visualization</b> <b>and</b> <b>debug</b>
       With the <b>-D,</b> <b>--emit-dot</b> option, re2zig does not generate code. Instead, it dumps the generated DFA in DOT
       format.   One  can convert this dump to an image of the DFA using Graphviz or another library.  Note that
       this option shows the final DFA after it has gone through a number of optimizations and  transformations.
       Earlier stages can be dumped with various debug options, such as <b>--dump-nfa</b>, <b>--dump-dfa-raw</b> etc. (see the
       full list of options).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       You  can find more information about re2c at the official website:  &lt;<a href="http://re2c.org">http://re2c.org</a>&gt; .  Similar programs
       are <a href="../man1/flex.1.html">flex</a>(1), <a href="../man1/lex.1.html">lex</a>(1), quex( &lt;<a href="http://quex.sourceforge.net">http://quex.sourceforge.net</a>&gt; ).

</pre><h4><b>AUTHORS</b></h4><pre>
       re2zig was originally written by Peter Bumbulis ( &lt;<a href="mailto:peter@csg.uwaterloo.ca">peter@csg.uwaterloo.ca</a>&gt; ) in 1993.  Marcus Boerger and
       Dan Nuffer spent several years to turn the original idea into a production ready  code  generator.  Since
       then  it  has  been  maintained  and  developed  by  multiple  volunteers,  most  notably,  Brian Young (
       &lt;<a href="mailto:bayoung@acm.org">bayoung@acm.org</a>&gt;    ),    Marcus    Boerger    &lt;https://github.com/helly25&gt;    ,    Dan     Nuffer     (
       &lt;<a href="mailto:nuffer@users.sourceforge.net">nuffer@users.sourceforge.net</a>&gt; ), Ulya Trofimovich &lt;https://github.com/skvadrik&gt;
        (   &lt;<a href="mailto:skvadrik@gmail.com">skvadrik@gmail.com</a>&gt;  ),  Serghei  Iakovlev  &lt;https://github.com/sergeyklay&gt;  ,  Sergei  Trofimovich
       &lt;https://github.com/trofi&gt; , Petr Skocik &lt;https://github.com/pskocik&gt; ,
        &lt;ligfx&gt;
        &lt;raekye&gt; and  &lt;PolarGoose&gt; .

                                                                                                       <u><a href="../man1/RE2ZIG.1.html">RE2ZIG</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>