<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>re2d - generate fast lexical analyzers for D</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/re2c">re2c_4.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       re2d - generate fast lexical analyzers for D

</pre><h4><b>SYNOPSIS</b></h4><pre>
       re2d <b>[</b> <b>OPTIONS</b> <b>]</b> <b>[</b> <b>WARNINGS</b> <b>]</b> <b>INPUT</b>

       Input can be either a file or <b>-</b> for stdin.

</pre><h4><b>INTRODUCTION</b></h4><pre>
       re2d  works  as  a  preprocessor.  It  reads  the input file (which is usually a program in D, but can be
       anything) and looks for blocks of code enclosed in special-form start/end markers. The  text  outside  of
       these  blocks  is copied verbatim into the output file. The contents of the blocks are processed by re2d.
       It translates them to code in D and outputs the generated code in place of the block.

       Here is an example of a small program that checks if a given string contains a decimal number:

          // re2d $INPUT -o $OUTPUT -i
          module main;

          private bool lex(const(char)* yycursor) {
              /*!re2c
                  re2c:YYCTYPE = char;
                  re2c:yyfill:enable = 0;

                  [1-9][0-9]* { return true; }
                  *           { return false; }
              */
          }

          void main() {
              assert(lex("1234"));
          }

       In the output re2d replaced the block in the middle with the generated code:

          /* Generated by re2d */
          // re2d $INPUT -o $OUTPUT -i
          module main;

          private bool lex(const(char)* yycursor) {

          {
              char yych;
              yych = *yycursor;
              switch (yych) {
                  case '1': .. case '9': goto yy2;
                  default: goto yy1;
              }
          yy1:
              ++yycursor;
              { return false; }
          yy2:
              yych = *++yycursor;
              switch (yych) {
                  case '0': .. case '9': goto yy2;
                  default: goto yy3;
              }
          yy3:
              { return true; }
          }

          }

          void main() {
              assert(lex("1234"));
          }

</pre><h4><b>BASICS</b></h4><pre>
       A re2d program consists of a sequence of <u>blocks</u> intermixed with code in the target language. A block  may
       contain <u>definitions</u>, <u>configurations</u>, <u>rules</u>, <u>actions</u> and <u>directives</u> in any order:

       <b>name</b> <b>=</b> <b>regular-expression</b> <b>;</b>
              A  <u>definition</u>  binds  <b>name</b>  to  <b>regular-expression</b>.  Names may contain alphanumeric characters and
              underscore. The regular  expressions  section  gives  an  overview  of  re2d  syntax  for  regular
              expressions.  Once  defined,  the  <b>name</b>  can  be  used  in other regular expressions and in rules.
              Recursion in named definitions is not allowed, and each name should be defined before it is  used.
              A  block  inherits  named  definitions from the global scope. Redefining a name that exists in the
              current scope is an error.

       <b>configuration</b> <b>=</b> <b>value</b> <b>;</b>
              A <u>configuration</u> allows one to change re2d behavior and customize the generated code.  For  a  full
              list of configurations supported by re2d see the configurations section. Depending on a particular
              configuration, the <b>value</b> can be a keyword, a nonnegative integer number or a one-line string which
              should  be  enclosed  in  double or single quotes unless it consists of alphanumeric characters. A
              block inherits configurations from the global scope  and  may  redefine  them  or  add  new  ones.
              Configurations defined inside of a block affect the whole block, even if they appear at the end of
              it.

       <b>regular-expression</b> <b>code</b>
              A  <u>rule</u>  binds  <b>regular-expression</b>  to  its semantic action (a block of code in curly braces, or a
              block of code that starts with <b>:=</b> and ends on a newline followed by any non-whitespace character).
              If the <b>regular-expression</b> matches, the associated <b>code</b> is executed.  If multiple rules match,  the
              longest  match  takes  precedence. If multiple rules match the same string, the earliest one takes
              precedence. There are two special rules: the default rule <b>*</b> and the end of input rule <b>$</b>.   Default
              rule  should  always  be defined, it has the lowest priority regardless of its place in the block,
              and it matches any code unit  (not  necessarily  a  valid  character,  see  the  encoding  support
              section). The end of input rule should be defined if the corresponding method for handling the end
              of input is used.  With start conditions rules have more complex syntax.

       <b>!action</b> <b>code</b>
              An  <u>action</u>  binds a user-defined block of <b>code</b> to a particular place in the generated finite state
              machine (in the same way as semantic actions bind code to  the  final  states).  See  the  actions
              section for a full list of predefined actions.

       <b>!directive</b> <b>;</b>
              A  <u>directive</u> is one of the special predefined statements. Each directive has a unique purpose. See
              the directives section for details.

   <b>Blocks</b>
       Block start and end markers are either <b>/*!re2c</b> and <b>*/</b>, or <b>%{</b> and <b>%}</b> (both styles are supported). Starting
       from version 2.2 blocks may have optional names that allow them to be referenced in other blocks.   There
       are different kinds of blocks:

       <b>/*!re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{[:&lt;name&gt;]</b> <b>...</b> <b>%}</b>
              A  <u>global</u> <u>block</u> contains definitions, configurations, rules and directives.  re2d compiles regular
              expressions associated with each rule into a deterministic finite automaton,  encodes  it  in  the
              form  of  conditional jumps in the target language and replaces the block with the generated code.
              Names and configurations defined in a global block are  added  to  the  global  scope  and  become
              visible  to  subsequent  blocks.  At the start of the program the global scope is initialized with
              command-line options.

       <b>/*!local:re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{local[:&lt;name&gt;]</b> <b>...</b> <b>%}</b>
              A <u>local</u> <u>block</u> is like a global block, but the names and configurations  in  it  have  local  scope
              (they do not affect other blocks).

       <b>/*!rules:re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{rules[:&lt;name&gt;]</b> <b>...</b> <b>%}</b>
              A  <u>rules</u> <u>block</u> is like a local block, but it does not generate any code by itself, nor does it add
              any definitions to the global scope -- it is meant to be reused in other blocks. This is a way  of
              sharing code (more details in the reusable blocks section). Prior to re2d version 2.2 rules blocks
              required <b>-r</b> <b>--reusable</b> option.

       <b>/*!use:re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{use[:&lt;name&gt;]</b> <b>...</b> <b>%}</b>
              A use block that references a previously defined rules block. If the name is specified, re2d looks
              for  a  rules blocks with this name. Otherwise the most recent rules block is used (either a named
              or an unnamed one). A use block can add definitions, configurations and rules of  its  own,  which
              are added to those of the referenced rules block. Prior to re2d version 2.2 use blocks required <b>-r</b>
              <b>--reusable</b> option.

       <b>/*!max:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{max[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%}</b>
              A  block  that  generates  <b>YYMAXFILL</b>  definition.  An optional list of block names specifies which
              blocks should be included when computing <b>YYMAXFILL</b> value (if the list is  empty,  all  blocks  are
              included).   By default the generated code is a macro-definition for C (<b>#define</b> <b>YYMAXFILL</b> <b>&lt;n&gt;</b>), or
              a global variable for Go (<b>var</b> <b>YYMAXFILL</b> <b>int</b>  <b>=</b>  <b>&lt;n&gt;</b>).  It  can  be  customized  with  an  optional
              configuration  <b>format</b> that specifies a template string where <b>@@{max}</b> (or <b>@@</b> for short) is replaced
              with the numeric value of <b>YYMAXFILL</b>.

       <b>/*!maxnmatch:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{maxnmatch[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%}</b>
              A block that generates  <b>YYMAXNMATCH</b>  definition  (it  requires  <b>-P</b>  <b>--posix-captures</b>  option).  An
              optional  list of block names specifies which blocks should be included when computing <b>YYMAXNMATCH</b>
              value (if the list is empty, all blocks are  included).   By  default  the  generated  code  is  a
              macro-definition for C (<b>#define</b> <b>YYMAXNMATCH</b> <b>&lt;n&gt;</b>), or a global variable for Go (<b>var</b> <b>YYMAXNMATCH</b> <b>int</b>
              <b>=</b>  <b>&lt;n&gt;</b>).  It  can  be  customized  with an optional configuration <b>format</b> that specifies a template
              string where <b>@@{max}</b> (or <b>@@</b> for short) is replaced with the numeric value of <b>YYMAXNMATCH</b>.

       <b>/*!stags:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/,</b> <b>/*!mtags:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/</b> <b>or</b>
       <b>%{stags[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%},</b> <b>%{mtags[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%{</b>
              Blocks that specify a template piece of code  that  is  expanded  for  each  s-tag/m-tag  variable
              generated  by re2d. An optional list of block names specifies which blocks should be included when
              computing the set of tag variables (if the list is empty, all blocks are included).  There are two
              optional configurations: <b>format</b> and <b>separator</b>.  Configuration <b>format</b> specifies a  template  string
              where  <b>@@{tag}</b>  (or  <b>@@</b>  for short) is replaced with the name of each tag variable.  Configuration
              <b>separator</b> specifies a piece of code used to join the generated <b>format</b>  pieces  for  different  tag
              variables.

       <b>/*!svars:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/,</b> <b>/*!mvars:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/</b> <b>or</b>
       <b>%{svars[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%},</b> <b>%{mvars[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%{</b>
              Blocks  that specify a template piece of code that is expanded for each s-tag/m-tag that is either
              explicitly mentioned by the rules (with <b>--tags</b> option)  or  implicitly  generated  by  re2d  (with
              <b>--captvars</b>  or  <b>--posix-captvars</b>  options). An optional list of block names specifies which blocks
              should be included when computing the set of tags (if the list is empty, all blocks are included).
              There are two optional configurations: <b>format</b> and <b>separator</b>.   Configuration  <b>format</b>  specifies  a
              template  string  where  <b>@@{tag}</b>  (or  <b>@@</b>  for  short)  is  replaced  with  the  name of each tag.
              Configuration <b>separator</b> specifies a piece of code used to join the  generated  <b>format</b>  pieces  for
              different tags.

       <b>/*!getstate:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{getstate[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%}</b>
              A  block  that  generates  conditional  dispatch  on the lexer state (it requires <b>--storable-state</b>
              option). An optional list of block names specifies which blocks should be included  in  the  state
              dispatch.  The  default  transition goes to the start label of the first block on the list. If the
              list is empty, all blocks are included, and the default transition goes to the first block in  the
              file that has a start label.  This block type is incompatible with the <b>--loop-switch</b> option, as it
              requires cross-block transitions that are unsupported without <b>goto</b> or function calls.

       <b>/*!conditions:re2c[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>*/,</b> <b>/*!types:re2c...</b> <b>*/</b> <b>or</b>
       <b>%{conditions[:&lt;name1&gt;[:&lt;name2&gt;...]]</b> <b>...</b> <b>%},</b> <b>%{types...</b> <b>%}</b>
              A  block  that generates condition enumeration (it requires <b>--conditions</b> option). An optional list
              of block names specifies which blocks should be included when computing the set of conditions  (if
              the  list  is  empty,  all  blocks are included).  By default the generated code is an enumeration
              <b>YYCONDTYPE</b>. It can be customized with optional configurations <b>format</b> and <b>separator</b>.  Configuration
              <b>format</b> specifies a template string where <b>@@{cond}</b> (or <b>@@</b> for short) is replaced with the  name  of
              each  condition,  and  <b>@@{num}</b>  is replaced with a numeric index of that condition.  Configuration
              <b>separator</b> specifies a piece of code used  to  join  the  generated  <b>format</b>  pieces  for  different
              conditions.

       <b>/*!include:re2c</b> <b>&lt;file&gt;</b> <b>*/</b> <b>or</b> <b>%{include</b> <b>&lt;file&gt;</b> <b>%}</b>
              This  block allows one to include <b>&lt;file&gt;</b>, which must be a double-quoted file path. The contents of
              the file are literally substituted in place of the block, in the same way  as  <b>#include</b>  works  in
              C/C++.  This  block  can  be  used  together  with  the  <b>--depfile</b> option to generate build system
              dependencies on the included files.

       <b>/*!header:re2c:on*/</b> <b>or</b> <b>%{header:on</b> <b>%}</b>
              This block marks the start of header file. Everything after it and up to the following  <b>header:off</b>
              block is processed by re2d and written to the header file specified with <b>-t</b> <b>--type-header</b> option.

       <b>/*!header:re2c:off*/</b> <b>or</b> <b>%{header:off</b> <b>%}</b>
              This block marks the end of header file started with <b>header:on*/</b> block.

       <b>/*!ignore:re2c</b> <b>...</b> <b>*/</b> <b>or</b> <b>%{ignore</b> <b>...</b> <b>%}</b>
              A block which contents are ignored and removed from the output file.

   <b>Configurations</b>
       Here is a full list of configurations supported by re2d:

       <b>re2c:api,</b> <b>re2c:input</b>
              Same as the <b>--api</b> option.

       <b>re2c:api:sigil</b>
              Specify  the  marker  ("sigil")  that is used for argument placeholders in the API primitives. The
              default is <b>@@</b>. A placeholder starts with sigil followed by the argument name in curly braces.  For
              example,  if sigil is set to <b>$</b>, then placeholders will have the form <b>${name}</b>. Single-argument APIs
              may use shorthand notation without the name in braces. This option can be  overridden  by  options
              for individual API primitives, e.g.  <b>re2c:YYFILL@len</b> for <b>YYFILL</b>.

       <b>re2c:api:style</b>
              Specify  API  style.  Possible values are <b>functions</b> (the default for C) and <b>free-form</b> (the default
              for Go and Rust).  In <b>functions</b> style API primitives  are  generated  with  an  argument  list  in
              parentheses following the name of the primitive. The arguments are provided only for autogenerated
              parameters  (such  as  the  number  of characters passed to <b>YYFILL</b>), but not for the general lexer
              context, so the primitives behave more like macros in C/C++  or  closures  in  Go  and  Rust.   In
              free-form  style  API  primitives  do  not  have  a  fixed form: they should be defined as strings
              containing free-form pieces of code with interpolated variables of the form <b>@@{var}</b>  or  <b>@@</b>  (they
              correspond  to  arguments  in  function-like  style).   This  configuration  may be overridden for
              individual API primitives, see for example <b>re2c:YYFILL:naked</b> configuration for <b>YYFILL</b>.

       <b>re2c:bit-vectors,</b> <b>re2c:flags:bit-vectors,</b> <b>re2c:flags:b</b>
              Same as the <b>--bit-vectors</b> option, but can be configured on per-block basis.

       <b>re2c:captures,</b> <b>re2c:leftmost-captures</b>
              Same as the <b>--leftmost-captures</b> option, but can be configured on per-block basis.

       <b>re2c:captvars,</b> <b>re2c:leftmost-captvars</b>
              Same as the <b>--leftmost-captvars</b> option, but can be configured on per-block basis.

       <b>re2c:case-insensitive,</b> <b>re2c:flags:case-insensitive</b>
              Same as the <b>--case-insensitive</b> option, but can be configured on per-block basis.

       <b>re2c:case-inverted,</b> <b>re2c:flags:case-inverted</b>
              Same as the <b>--case-inverted</b> option, but can be configured on per-block basis.

       <b>re2c:case-ranges,</b> <b>re2c:flags:case-ranges</b>
              Same as the <b>--case-ranges</b> option, but can be configured on per-block basis.

       <b>re2c:computed-gotos,</b> <b>re2c:flags:computed-gotos,</b> <b>re2c:flags:g</b>
              Same as the <b>--computed-gotos</b> option, but can be configured on per-block basis.

       <b>re2c:computed-gotos:threshold,</b> <b>re2c:cgoto:threshold</b>
              If computed <b>goto</b> is used, this configuration specifies the complexity threshold that triggers  the
              generation of jump tables instead of nested <b>if</b> statements and bitmaps. The default value is <b>9</b>.

       <b>re2c:cond:abort</b>
              If  set  to  a positive integer value, the default case in the generated condition dispatch aborts
              program execution.

       <b>re2c:cond:goto</b>
              Specifies a piece of code used for the autogenerated shortcut rules <b>:=&gt;</b> in conditions. The default
              is <b>goto</b>  <b>@@;</b>.   The  <b>@@</b>  placeholder  is  substituted  with  condition  name  (see  configurations
              <b>re2c:api:sigil</b> and <b>re2c:cond:goto@cond</b>).

       <b>re2c:cond:goto@cond</b>
              Specifies the sigil used for argument substitution in <b>re2c:cond:goto</b> definition. The default value
              is <b>@@</b>.  Overrides the more generic <b>re2c:api:sigil</b> configuration.

       <b>re2c:cond:divider</b>
              Defines     the     divider    for    condition    blocks.     The    default    value    is    <b>/*</b>
              <b>***********************************</b> <b>*/</b>.  Placeholders are substituted  with  condition  name  (see
              <b>re2c:api;sigil</b> and <b>re2c:cond:divider@cond</b>).

       <b>re2c:cond:divider@cond</b>
              Specifies the sigil used for argument substitution in <b>re2c:cond:divider</b> definition. The default is
              <b>@@</b>.  Overrides the more generic <b>re2c:api:sigil</b> configuration.

       <b>re2c:cond:prefix,</b> <b>re2c:condprefix</b>
              Specifies the prefix used for condition labels.  The default is <b>yyc_</b>.

       <b>re2c:cond:enumprefix,</b> <b>re2c:condenumprefix</b>
              Specifies the prefix used for condition identifiers.  The default is <b>yyc</b>.

       <b>re2c:debug-output,</b> <b>re2c:flags:debug-output,</b> <b>re2c:flags:d</b>
              Same as the <b>--debug-output</b> option, but can be configured on per-block basis.

       <b>re2c:empty-class,</b> <b>re2c:flags:empty-class</b>
              Same as the <b>--empty-class</b> option, but can be configured on per-block basis.

       <b>re2c:encoding:ebcdic,</b> <b>re2c:flags:ecb,</b> <b>re2c:flags:e</b>
              Same as the <b>--ebcdic</b> option, but can be configured on per-block basis.

       <b>re2c:encoding:ucs2,</b> <b>re2c:flags:wide-chars,</b> <b>re2c:flags:w</b>
              Same as the <b>--ucs2</b> option, but can be configured on per-block basis.

       <b>re2c:encoding:utf8,</b> <b>re2c:flags:utf-8,</b> <b>re2c:flags:8</b>
              Same as the <b>--utf8</b> option, but can be configured on per-block basis.

       <b>re2c:encoding:utf16,</b> <b>re2c:flags:utf-16,</b> <b>re2c:flags:x</b>
              Same as the <b>--utf16</b> option, but can be configured on per-block basis.

       <b>re2c:encoding:utf32,</b> <b>re2c:flags:unicode,</b> <b>re2c:flags:u</b>
              Same as the <b>--utf32</b> option, but can be configured on per-block basis.

       <b>re2c:encoding-policy,</b> <b>re2c:flags:encoding-policy</b>
              Same as the <b>--encoding-policy</b> option, but can be configured on per-block basis.

       <b>re2c:eof</b>
              Specifies  the  sentinel symbol used with the end-of-input rule <b>$</b>. The default value is <b>-1</b> (<b>$</b> rule
              is not used). Other possible values include  all  valid  code  units.  Only  decimal  numbers  are
              recognized.

       <b>re2c:fn:sep</b>
              Specifies separator used in <b>YYFN</b> elements (defaults to semicolon).

       <b>re2c:header,</b> <b>re2c:flags:type-header,</b> <b>re2c:flags:t</b>
              Specifies the name of the generated header file relative to the directory of the output file. Same
              as the <b>--header</b> option except that the file path is relative.

       <b>re2c:indent:string</b>
              Specifies  the  string  used  for  indentation. The default is a single tab character <b>"\t"</b>. Indent
              string should contain whitespace characters only.   To  disable  indentation  entirely,  set  this
              configuration to an empty string.

       <b>re2c:indent:top</b>
              Specifies the minimum amount of indentation to use. The default value is zero. The value should be
              a non-negative integer number.

       <b>re2c:invert-captures</b>
              Same as the <b>--invert-captures</b> option, but can be configured on per-block basis.

       <b>re2c:label:prefix,</b> <b>re2c:labelprefix</b>
              Specifies the prefix used for DFA state labels. The default is <b>yy</b>.

       <b>re2c:label:start,</b> <b>re2c:startlabel</b>
              Controls  the  generation  of a block start label. The default value is zero, which means that the
              start label is generated only if it is used.  An  integer  value  greater  than  zero  forces  the
              generation  of  start  label  even  if it is unused by the lexer. A string value also forces start
              label generation and sets the label name to the specified string. This configuration applies  only
              to the current block (it is reset to default for the next block).

       <b>re2c:label:yyFillLabel</b>
              Specifies the prefix of <b>YYFILL</b> labels used with <b>re2c:eof</b> and in storable state mode.

       <b>re2c:label:yyloop</b>
              Specifies the name of the label marking the start of the lexer loop with <b>--loop-switch</b> option. The
              default is <b>yyloop</b>.

       <b>re2c:label:yyNext</b>
              Specifies  the  name  of  the optional label that follows <b>YYGETSTATE</b> switch in storable state mode
              (enabled with <b>re2c:state:nextlabel</b>). The default is <b>yyNext</b>.

       <b>re2c:lookahead,</b> <b>re2c:flags:lookahead</b>
              Deprecated (see the deprecated <b>--no-lookahead</b> option).

       <b>re2c:monadic</b>
              If set to non-zero, the generated lexer will use monadic notation (this configuration is  specific
              to Haskell).

       <b>re2c:nested-ifs,</b> <b>re2c:flags:nested-ifs,</b> <b>re2c:flags:s</b>
              Same as the <b>--nested-ifs</b> option, but can be configured on per-block basis.

       <b>re2c:posix-captures,</b> <b>re2c:flags:posix-captures,</b> <b>re2c:flags:P</b>
              Same as the <b>--posix-captures</b> option, but can be configured on per-block basis.

       <b>re2c:posix-captvars</b>
              Same as the <b>--posix-captvars</b> option, but can be configured on per-block basis.

       <b>re2c:tags,</b> <b>re2c:flags:tags,</b> <b>re2c:flags:T</b>
              Same as the <b>--tags</b> option, but can be configured on per-block basis.

       <b>re2c:tags:expression</b>
              Specifies  the  expression  used  for tag variables.  By default re2d generates expressions of the
              form <b>yyt&lt;N&gt;</b>. This might be inconvenient, for example if tag variables are defined as fields  in  a
              struct.  All  occurrences  of  <b>@@{tag}</b>  or  <b>@@</b> are replaced with the actual tag name. For example,
              <b>re2c:tags:expression</b> <b>=</b> <b>"s.@@";</b> results in expressions of the form <b>s.yyt&lt;N&gt;</b> in the generated  code.
              See also <b>re2c:api:sigil</b> configuration.

       <b>re2c:tags:negative</b>
              Specifies  the constant expression that is used for negative tag value (typically this would be <b>-1</b>
              if tags are integer offsets in the input string, or null pointer if they are pointers).

       <b>re2c:tags:prefix</b>
              Specifies the prefix for tag variable names. The default is <b>yyt</b>.

       <b>re2c:sentinel</b>
              Specifies the sentinel symbol used for the end-of-input checks (when bounds  checks  are  disabled
              with  <b>re2c:yyfill:enable</b>  <b>=</b>  <b>0;</b>  and <b>re2c:eof</b> is not set). This configuration does not affect code
              generation: its purpose is to verify that the sentinel is not allowed in the middle of a rule, and
              ensure that the lexer won't read past the end of buffer. The default value is <u>-1`</u>  (in  that  case
              re2d  assumes  that the sentinel is zero, which is the most common case). Only decimal numbers are
              recognized.

       <b>re2c:state:abort</b>
              If set to a positive integer value, the default  case  in  the  generated  state  dispatch  aborts
              program execution, and an explicit <b>-1</b> case contains transition to the start of the block.

       <b>re2c:state:nextlabel</b>
              Controls if the <b>YYGETSTATE</b> switch is followed by an <b>yyNext</b> label (the default value is zero, which
              corresponds to no label).  Alternatively one can use <b>re2c:label:start</b> to generate a specific start
              label,  or  an explicit <b>getstate</b> block to generate the <b>YYGETSTATE</b> switch separately from the lexer
              block.

       <b>re2c:unsafe,</b> <b>re2c:flags:unsafe</b>
              Same as the <b>--no-unsafe</b> option, but can be configured on per-block basis.   If  set  to  zero,  it
              suppresses  the generation of <b>unsafe</b> wrappers around <b>YYPEEK</b>. The default is non-zero (wrappers are
              generated).  This configuration is specific to Rust.

       <b>re2c:YYBACKUP,</b> <b>re2c:define:YYBACKUP</b>
              Defines generic API primitive <b>YYBACKUP</b>.

       <b>re2c:YYBACKUPCTX,</b> <b>re2c:define:YYBACKUPCTX</b>
              Defines generic API primitive <b>YYBACKUPCTX</b>.

       <b>re2c:YYCONDTYPE,</b> <b>re2c:define:YYCONDTYPE</b>
              Defines API primitive <b>YYCONDTYPE</b>.

       <b>re2c:YYCTYPE,</b> <b>re2c:define:YYCTYPE</b>
              Defines API primitive <b>YYCTYPE</b>.

       <b>re2c:YYCTXMARKER,</b> <b>re2c:define:YYCTXMARKER</b>
              Defines API primitive <b>YYCTXMARKER</b>.

       <b>re2c:YYCURSOR,</b> <b>re2c:define:YYCURSOR</b>
              Defines API primitive <b>YYCURSOR</b>.

       <b>re2c:YYDEBUG,</b> <b>re2c:define:YYDEBUG</b>
              Defines API primitive <b>YYDEBUG</b>.

       <b>re2c:YYFILL,</b> <b>re2c:define:YYFILL</b>
              Defines API primitive <b>YYFILL</b>.

       <b>re2c:YYFILL@len,</b> <b>re2c:define:YYFILL@len</b>
              Specifies the sigil  used  for  argument  substitution  in  <b>YYFILL</b>  definition.  Defaults  to  <b>@@</b>.
              Overrides the more generic <b>re2c:api:sigil</b> configuration.

       <b>re2c:YYFILL:naked,</b> <b>re2c:define:YYFILL:naked</b>
              Overrides  the  more  generic  <b>re2c:api:style</b> configuration for <b>YYFILL</b>.  Zero value corresponds to
              free-form API style.

       <b>re2c:YYFN</b>
              Defines API primitive <b>YYFN</b>.

       <b>re2c:YYINPUT</b>
              Defines API primitive <b>YYINPUT</b>.

       <b>re2c:YYGETCOND,</b> <b>re2c:define:YYGETCONDITION</b>
              Defines API primitive <b>YYGETCOND</b>.

       <b>re2c:YYGETCOND:naked,</b> <b>re2c:define:YYGETCONDITION:naked</b>
              Overrides the more generic <b>re2c:api:style</b> configuration for <b>YYGETCOND</b>. Zero value  corresponds  to
              free-form API style.

       <b>re2c:YYGETSTATE,</b> <b>re2c:define:YYGETSTATE</b>
              Defines API primitive <b>YYGETSTATE</b>.

       <b>re2c:YYGETSTATE:naked,</b> <b>re2c:define:YYGETSTATE:naked</b>
              Overrides  the more generic <b>re2c:api:style</b> configuration for <b>YYGETSTATE</b>. Zero value corresponds to
              free-form API style.

       <b>re2c:YYGETACCEPT,</b> <b>re2c:define:YYGETACCEPT</b>
              Defines API primitive <b>YYGETACCEPT</b>.

       <b>re2c:YYLESSTHAN,</b> <b>re2c:define:YYLESSTHAN</b>
              Defines generic API primitive <b>YYLESSTHAN</b>.

       <b>re2c:YYLIMIT,</b> <b>re2c:define:YYLIMIT</b>
              Defines API primitive <b>YYLIMIT</b>.

       <b>re2c:YYMARKER,</b> <b>re2c:define:YYMARKER</b>
              Defines API primitive <b>YYMARKER</b>.

       <b>re2c:YYMTAGN,</b> <b>re2c:define:YYMTAGN</b>
              Defines generic API primitive <b>YYMTAGN</b>.

       <b>re2c:YYMTAGP,</b> <b>re2c:define:YYMTAGP</b>
              Defines generic API primitive <b>YYMTAGP</b>.

       <b>re2c:YYPEEK,</b> <b>re2c:define:YYPEEK</b>
              Defines generic API primitive <b>YYPEEK</b>.

       <b>re2c:YYRESTORE,</b> <b>re2c:define:YYRESTORE</b>
              Defines generic API primitive <b>YYRESTORE</b>.

       <b>re2c:YYRESTORECTX,</b> <b>re2c:define:YYRESTORECTX</b>
              Defines generic API primitive <b>YYRESTORECTX</b>.

       <b>re2c:YYRESTORETAG,</b> <b>re2c:define:YYRESTORETAG</b>
              Defines generic API primitive <b>YYRESTORETAG</b>.

       <b>re2c:YYSETCOND,</b> <b>re2c:define:YYSETCONDITION</b>
              Defines API primitive <b>YYSETCOND</b>.

       <b>re2c:YYSETCOND@cond,</b> <b>re2c:define:YYSETCONDITION@cond</b>
              Specifies the sigil used for argument substitution in <b>YYSETCOND</b> definition. The default  value  is
              <b>@@</b>.  Overrides the more generic <b>re2c:api:sigil</b> configuration.

       <b>re2c:YYSETCOND:naked,</b> <b>re2c:define:YYSETCONDITION:naked</b>
              Overrides  the  more generic <b>re2c:api:style</b> configuration for <b>YYSETCOND</b>. Zero value corresponds to
              free-form API style.

       <b>re2c:YYSETSTATE,</b> <b>re2c:define:YYSETSTATE</b>
              Defines API primitive <b>YYSETSTATE</b>.

       <b>re2c:YYSETSTATE@state,</b> <b>re2c:define:YYSETSTATE@state</b>
              Specifies the sigil used for argument substitution in <b>YYSETSTATE</b> definition. The default value  is
              <b>@@</b>.  Overrides the more generic <b>re2c:api:sigil</b> configuration.

       <b>re2c:YYSETSTATE:naked,</b> <b>re2c:define:YYSETSTATE:naked</b>
              Overrides  the more generic <b>re2c:api:style</b> configuration for <b>YYSETSTATE</b>. Zero value corresponds to
              free-form API style.

       <b>re2c:YYSETACCEPT,</b> <b>re2c:define:YYSETACCEPT</b>
              Defines API primitive <b>YYSETACCEPT</b>.

       <b>re2c:YYSKIP,</b> <b>re2c:define:YYSKIP</b>
              Defines generic API primitive <b>YYSKIP</b>.

       <b>re2c:YYSHIFT,</b> <b>re2c:define:YYSHIFT</b>
              Defines generic API primitive <b>YYSHIFT</b>.

       <b>re2c:YYCOPYMTAG,</b> <b>re2c:define:YYCOPYMTAG</b>
              Defines generic API primitive <b>YYCOPYMTAG</b>.

       <b>re2c:YYCOPYSTAG,</b> <b>re2c:define:YYCOPYSTAG</b>
              Defines generic API primitive <b>YYCOPYSTAG</b>.

       <b>re2c:YYSHIFTMTAG,</b> <b>re2c:define:YYSHIFTMTAG</b>
              Defines generic API primitive <b>YYSHIFTMTAG</b>.

       <b>re2c:YYSHIFTSTAG,</b> <b>re2c:define:YYSHIFTSTAG</b>
              Defines generic API primitive <b>YYSHIFTSTAG</b>.

       <b>re2c:YYSTAGN,</b> <b>re2c:define:YYSTAGN</b>
              Defines generic API primitive <b>YYSTAGN</b>.

       <b>re2c:YYSTAGP,</b> <b>re2c:define:YYSTAGP</b>
              Defines generic API primitive <b>YYSTAGP</b>.

       <b>re2c:yyaccept,</b> <b>re2c:variable:yyaccept</b>
              Defines API primitive <b>yyaccept</b>.

       <b>re2c:yybm,</b> <b>re2c:variable:yybm</b>
              Defines API primitive <b>yybm</b>.

       <b>re2c:yybm:hex,</b> <b>re2c:variable:yybm:hex</b>
              If set to nonzero, bitmaps for the <b>--bit-vectors</b> option are generated in hexadecimal  format.  The
              default is zero (bitmaps are in decimal format).

       <b>re2c:yych,</b> <b>re2c:variable:yych</b>
              Defines API primitive <b>yych</b>.

       <b>re2c:yych:emit,</b> <b>re2c:variable:yych:emit</b>
              If set to zero, <b>yych</b> definition is not generated.  The default is non-zero.

       <b>re2c:yych:conversion,</b> <b>re2c:variable:yych:conversion</b>
              If  set to non-zero, re2d automatically generates a conversion to <b>YYCTYPE</b> every time <b>yych</b> is read.
              The default is to zero (no conversion).

       <b>re2c:yych:literals,</b> <b>re2c:variable:yych:literals</b>
              Specifies the form of literals that <b>yych</b> is matched against. Possible values are: <b>char</b>  (character
              literals in single quotes, non-printable ones use escape sequences that start with backslash), <b>hex</b>
              (hexadecimal  integers)  and  <b>char_or_hex</b>  (a  mixture  of  both, character literals for printable
              characters and hexadecimal integers for others).

       <b>re2c:yyctable,</b> <b>re2c:variable:yyctable</b>
              Defines API primitive <b>yyctable</b>.

       <b>re2c:yynmatch,</b> <b>re2c:variable:yynmatch</b>
              Defines API primitive <b>yynmatch</b>.

       <b>re2c:yypmatch,</b> <b>re2c:variable:yypmatch</b>
              Defines API primitive <b>yypmatch</b>.

       <b>re2c:yytarget,</b> <b>re2c:variable:yytarget</b>
              Defines API primitive <b>yytarget</b>.

       <b>re2c:yystable,</b> <b>re2c:variable:yystable</b>
              Deprecated.

       <b>re2c:yystate,</b> <b>re2c:variable:yystate</b>
              Defines API primitive <b>yystate</b>.

       <b>re2c:yyfill,</b> <b>re2c:variable:yyfill</b>
              Defines API primitive <b>yyfill</b>.

       <b>re2c:yyfill:check</b>
              If set to zero, suppresses the generation of pre-<b>YYFILL</b> check for the number of  input  characters
              (the  <b>YYLESSTHAN</b> definition in generic API and the <b>YYLIMIT</b>-based comparison in C pointer API). The
              default is non-zero (generate the check).

       <b>re2c:yyfill:enable</b>
              If set to zero, suppresses the generation of <b>YYFILL</b> (together with the check). This should be used
              when the whole input fits into one piece of memory (there  is  no  need  for  buffering)  and  the
              end-of-input  checks do not rely on the <b>YYFILL</b> checks (e.g. if a sentinel character is used).  Use
              warnings (<b>-W</b> option) and <b>re2c:sentinel</b> configuration to verify that  the  generated  lexer  cannot
              read past the end of input.  The default is non-zero (<b>YYFILL</b> is enabled).

       <b>re2c:yyfill:parameter</b>
              If  set  to  zero,  suppresses the generation of parameter passed to <b>YYFILL</b>.  The parameter is the
              minimum number of characters that must be  supplied.   Defaults  to  non-zero  (the  parameter  is
              generated).  This configuration can be overridden with <b>re2c:YYFILL:naked</b> or <b>re2c:api:style</b>.

   <b>Regular</b> <b>expressions</b>
       re2d uses the following syntax for regular expressions:

       <b>"foo"</b>  Case-sensitive string literal.

       <b>'foo'</b>  Case-insensitive string literal.

       <b>[a-xyz],</b> <b>[^a-xyz]</b>
              Character class (possibly negated).

       <b>.</b>      Any character except newline.

       <b>R</b> <b>\</b> <b>S</b>  Difference of character classes <b>R</b> and <b>S</b>.

       <b>R*</b>     Zero or more occurrences of <b>R</b>.

       <b>R+</b>     One or more occurrences of <b>R</b>.

       <b>R?</b>     Optional <b>R</b>.

       <b>R{n}</b>   Repetition of <b>R</b> exactly <b>n</b> times.

       <b>R{n,}</b>  Repetition of <b>R</b> at least <b>n</b> times.

       <b>R{n,m}</b> Repetition of <b>R</b> from <b>n</b> to <b>m</b> times.

       <b>(R)</b>    Just  <b>R</b>;  parentheses are used to override precedence. If submatch extraction is enabled, <b>(R)</b> is a
              capturing or a non-capturing group depending on <b>--invert-captures</b> option.

       <b>(!R)</b>   If submatch extraction is enabled, <b>(!R)</b> is a non-capturing  or  a  capturing  group  depending  on
              <b>--invert-captures</b> option.

       <b>R</b> <b>S</b>    Concatenation: <b>R</b> followed by <b>S</b>.

       <b>R</b> <b>|</b> <b>S</b>  Alternative: <b>R</b> <b>or</b> <b>S</b>.

       <b>R</b> <b>/</b> <b>S</b>  Lookahead: <b>R</b> followed by <b>S</b>, but <b>S</b> is not consumed.

       <b>name</b>   Regular expression defined as <b>name</b> (or literal string <b>"name"</b> in Flex compatibility mode).

       <b>{name}</b> Regular expression defined as <b>name</b> in Flex compatibility mode.

       <b>@stag</b>  An <u>s-tag</u>: saves the last input position at which <b>@stag</b> matches in a variable named <b>stag</b>.

       <b>#mtag</b>  An <u>m-tag</u>: saves all input positions at which <b>#mtag</b> matches in a variable named <b>mtag</b>.

       Character classes and string literals may contain the following escape sequences: <b>\a</b>, <b>\b</b>, <b>\f</b>, <b>\n</b>, <b>\r</b>, <b>\t</b>,
       <b>\v</b>, <b>\\</b>, octal escapes <b>\ooo</b> and hexadecimal escapes <b>\xhh</b>, <b>\uhhhh</b> and <b>\Uhhhhhhhh</b>.

   <b>Actions</b>
       Here is a list of predefined actions supported by re2d:

       <b>!entry</b> <b>code</b>
              Entry  action  binds  a  user-defined block of <b>code</b> to the start state of the current finite state
              machine. If start conditions are  used,  the  entry  action  can  be  set  individually  for  each
              condition.  This  action  may  be used to perform initialization, e.g. to save start location of a
              lexeme.

       <b>!pre_rule</b> <b>code</b>
              Pre-rule action prepends a user-defined block of <b>code</b> to semantic actions  of  all  rules  in  the
              current  block (or condition, if start conditions are used). This action may be used to factor out
              the common part of all semantic actions (e.g. saving the end location of a lexeme).

       <b>!post_rule</b> <b>code</b>
              Post-rule action appends a user-defined block of <b>code</b> to semantic actions  of  all  rules  in  the
              current  block  (or condition, if start conditions are used). This action may be used to emit trap
              statements that guard against unintended control flow.

   <b>Directives</b>
       Here is a full list of directives supported by re2d:

       <b>!use:name</b> <b>;</b>
              An in-block use directive that merges a previously defined rules block  with  the  specified  <b>name</b>
              into  the  current  block. Named definitions, configurations and rules of the referenced block are
              added to the current ones. Conflicts between overlapping rules and configurations are resolved  in
              the usual way: the first rule takes priority, and the latest configuration overrides the preceding
              ones.  One  exception  is the special rules <b>*</b>, <b>$</b> and <b>&lt;!&gt;</b> for which a block-local definition always
              takes priority. A use directive can be placed  anywhere  inside  of  a  block,  and  multiple  use
              directives are allowed.

       <b>!include</b> <b>file</b> <b>;</b>
              This  directive  is  the  same as <b>include</b> block: it inserts <b>file</b> contents verbatim in place of the
              directive.

   <b>Program</b> <b>interface</b>
       The generated code interfaces with the outer program with the help of <u>primitives</u>,  collectively  referred
       to  as the <u>API</u>.  Which primitives should be defined for a particular program depends on multiple factors,
       including the complexity of regular expressions, input representation, buffering and the use  of  various
       features.  All  the  necessary primitives should be defined by the user in the form of macros, functions,
       variables or any other suitable form  that  makes  the  generated  code  syntactically  and  semantically
       correct.  re2d  does  not  (and  cannot)  check  the  definitions,  so  if anything is missing or defined
       incorrectly, the generated program may have  compile-time  or  run-time  errors.   This  manual  provides
       examples of API definitions in the most common cases.

       re2d has three API flavors that define the core set of primitives used by a program:

       <b>Simple</b> <b>API</b>
              This  is  the default API for D backend. It consists of primitives <b>YYCURSOR</b>, <b>YYMARKER</b>, <b>YYCTXMARKER</b>
              and <b>YYLIMIT</b>, which should be defined as pointers of type <b>YYCTYPE*</b>.

       <b>Record</b> <b>API</b>
              Record API is useful in cases when lexer state must be stored in a struct.   It  is  enabled  with
              <b>--api</b>  <b>record</b>  option or <b>re2c:api</b> <b>=</b> <b>record</b> configuration. This API consists of a variable <b>yyrecord</b>
              (the name can be overridden with <b>re2c:yyrecord</b>) that should be defined as  a  struct  with  fields
              <b>yycursor</b>,  <b>yymarker</b>,  <b>yyctxmarker</b>,  <b>yylimit</b> (only the fields used by the generated code need to be
              defined, and their names can be configured).

       <b>Generic</b> <b>API</b>
              This is the most flexible API. It is enabled with <b>--api</b>  <b>generic</b>  option  or  <b>re2c:api</b>  <b>=</b>  <b>generic</b>
              configuration.    It  contains  primitives  for  generic  operations:  <b>YYPEEK</b>,  <b>YYSKIP</b>,  <b>YYBACKUP</b>,
              <b>YYBACKUPCTX</b>, <b>YYSTAGP</b>, <b>YYSTAGN</b>, <b>YYMTAGP</b>, <b>YYMTAGN</b>, <b>YYRESTORE</b>, <b>YYRESTORECTX</b>,  <b>YYRESTORETAG</b>,  <b>YYSHIFT</b>,
              <b>YYSHIFTSTAG</b>, <b>YYSHIFTMTAG</b>, <b>YYLESSTHAN</b>.

       Here  is  a full list of API primitives that may be used by the generated code in order to interface with
       the outer program.

       <b>YYCTYPE</b>
              The type of the input characters (code units).  For ASCII, EBCDIC and UTF-8 encodings it should be
              1-byte unsigned integer.  For UTF-16 or UCS-2 it should be 2-byte unsigned integer. For UTF-32  it
              should be 4-byte unsigned integer.

       <b>YYCURSOR</b>
              An  l-value  that  stores  the current input position (a pointer or an integer offset in <b>YYINPUT</b>).
              Initially <b>YYCURSOR</b> should point to the first input character, and later  it  is  advanced  by  the
              generated  code.  When  a  rule  matches,  <b>YYCURSOR</b>  position  is  the  one after the last matched
              character.

       <b>YYLIMIT</b>
              An r-value that stores the end of input position (a pointer or  an  integer  offset  in  <b>YYINPUT</b>).
              Initially <b>YYLIMIT</b> should point to the position after the last available input character. It is not
              changed  by  the  generated  code. The lexer compares <b>YYCURSOR</b> to <b>YYLIMIT</b> in order to determine if
              there are enough input characters left.

       <b>YYMARKER</b>
              An l-value that stores the position of the latest matched rule (a pointer or an integer offset  in
              <b>YYINPUT</b>).  It  is  used  to  restore the <b>YYCURSOR</b> position if the longer match fails and the lexer
              needs to rollback.  Initialization is not needed.

       <b>YYCTXMARKER</b>
              An l-value that stores the position of the trailing context (a pointer or  an  integer  offset  in
              <b>YYINPUT</b>).  No  initialization is needed. <b>YYCTXMARKER</b> is needed only if the lookahead operator <b>/</b> is
              used.

       <b>YYFILL</b> A generic API primitive with one variable <b>len</b>.  <b>YYFILL</b> should provide  at  least  <b>len</b>  more  input
              characters or fail.  If <b>re2c:eof</b> is used, then <b>len</b> is always <b>1</b> and  <b>YYFILL</b> should always return to
              the  calling  function; zero return value indicates success.  If <b>re2c:eof</b> is not used, then <b>YYFILL</b>
              return value is ignored and it should  not  return  on  failure.  The  maximum  value  of  <b>len</b>  is
              <b>YYMAXFILL</b>.

       <b>YYFN</b>   A  primitive that defines function prototype in <b>--recursive-functions</b> code model. Its value should
              be an array of one or more strings, where each string contains two or three  components  separated
              by  the  string  specified  in  <b>re2c:fn:sep</b> configuration (typically a semicolon). The first array
              element defines function name and return type (empty for a void  function).   Subsequent  elements
              define  function  arguments: first, the expression for the argument used in function body (usually
              just a name); second, argument type; third, an optional formal parameter (it defaults to the first
              component - usually both the argument and the parameter are the same identifier).

       <b>YYINPUT</b>
              An r-value that stores the current input character sequence (string, buffer, etc.).

       <b>YYMAXFILL</b>
              An integral constant equal to the maximum value of the argument to <b>YYFILL</b>.  It  can  be  generated
              with a <b>max</b> block.

       <b>YYLESSTHAN</b>
              A generic API primitive with one variable <b>len</b>.  It should be defined as an r-value of boolean type
              that equals <b>true</b> if and only if there are less than <b>len</b> input characters left.

       <b>YYPEEK</b> A  generic  API  primitive  with no variables.  It should be defined as an r-value of type <b>YYCTYPE</b>
              that is equal to the character at the current input position.

       <b>YYSKIP</b> A generic API primitive that should advance the current input position by one code unit.

       <b>YYBACKUP</b>
              A generic API primitive that should save the current input position (to be restored with <b>YYRESTORE</b>
              later).

       <b>YYRESTORE</b>
              A generic API primitive that should restore the current input  position  to  the  value  saved  by
              <b>YYBACKUP</b>.

       <b>YYBACKUPCTX</b>
              A  generic  API  primitive  that  should  save  the  current input position as the position of the
              trailing context (to be restored with <b>YYRESTORECTX</b> later).

       <b>YYRESTORECTX</b>
              A generic API primitive that should restore the trailing context position saved with <b>YYBACKUPCTX</b>.

       <b>YYRESTORETAG</b>
              A generic API primitive with one variable <b>tag</b> that should restore the trailing context position to
              the value of <b>tag</b>.

       <b>YYSTAGP</b>
              A generic API primitive with one variable <b>tag</b>, where <b>tag</b> can be a pointer or an offset in  <b>YYINPUT</b>
              (see  submatch  extraction  section  for  details).  <b>YYSTAGP</b>  should  set <b>tag</b> to the current input
              position.

       <b>YYSTAGN</b>
              A generic API primitive with one variable <b>tag</b>, where <b>tag</b> can be a pointer or an offset in  <b>YYINPUT</b>
              (see  submatch  extraction  section  for  details).  <b>YYSTAGN</b>  should  to  set  <b>tag</b> to a value that
              represents non-existent input position.

       <b>YYMTAGP</b>
              A generic API primitive with one variable <b>tag</b>.  <b>YYMTAGP</b> should append the current position to  the
              submatch history of <b>tag</b> (see the submatch extraction section for details.)

       <b>YYMTAGN</b>
              A  generic  API  primitive  with  one variable <b>tag</b>.  <b>YYMTAGN</b> should append a value that represents
              non-existent input position position to the submatch history of <b>tag</b> (see the  submatch  extraction
              section for details.)

       <b>YYSHIFT</b>
              A  generic  API  primitive with one variable <b>shift</b> that should shift the current input position by
              <b>shift</b> characters (the shift value may be negative).

       <b>YYCOPYSTAG</b>
              A generic API primitive with two variables, <b>lhs</b> and <b>rhs</b> that  should  copy  right-hand-side  s-tag
              variable  <b>rhs</b>  to  the  left-hand-side s-tag variable <b>lhs</b>. For most languages this primitive has a
              default definition that assigns <b>lhs</b> to <b>rhs</b>.

       <b>YYCOPYMTAG</b>
              A generic API primitive with two variables, <b>lhs</b> and <b>rhs</b> that  should  copy  right-hand-side  m-tag
              variable  <b>rhs</b>  to  the  left-hand-side m-tag variable <b>lhs</b>. For most languages this primitive has a
              default definition that assigns <b>lhs</b> to <b>rhs</b>.

       <b>YYSHIFTSTAG</b>
              A generic  API primitive with two variables, <b>tag</b> and <b>shift</b> that should shift  <b>tag</b>  by  <b>shift</b>  code
              units (the shift value may be negative).

       <b>YYSHIFTMTAG</b>
              A  generic  API  primitive with two variables, <b>tag</b> and <b>shift</b> that should shift the latest value in
              the history of <b>tag</b> by <b>shift</b> code units (the shift value may be negative).

       <b>YYMAXNMATCH</b>
              An integral constant equal to the maximal number of POSIX  capturing  groups  in  a  rule.  It  is
              generated with a <b>maxnmatch</b> block.

       <b>YYCONDTYPE</b>
              The  type  of  the  condition  enum.  It can be generated either with <b>conditions</b> block or <b>--header</b>
              option.

       <b>YYGETACCEPT</b>
              A primitive with one variable <b>var</b> that stores numeric selector of  the  accepted  rule.  For  most
              languages this primitive has a default definition that reads from <b>var</b>.

       <b>YYSETACCEPT</b>
              A  primitive  with  two  variables:  <b>var</b>  (an l-value that stores numeric selector of the accepted
              rule), and <b>val</b> (the value of selector). For most languages this primitive has a default definition
              that assigns <b>var</b> to <b>val</b>.

       <b>YYGETCOND</b>
              An r-value of type <b>YYCONDTYPE</b> that is equal to the current condition identifier.

       <b>YYSETCOND</b>
              A primitive with one variable <b>cond</b> that should set the current condition identifier to <b>cond</b>.

       <b>YYGETSTATE</b>
              An r-value of integer type that is equal to the current lexer state. It should be  initialized  to
              <b>-1</b>.

       <b>YYSETSTATE</b>
              A primitive with one variable <b>state</b> that should set the current lexer state to <b>state</b>.

       <b>YYDEBUG</b>
              This primitive is generated only with <b>-d</b>, <b>--debug-output</b> option.  Its purpose is to add logging to
              the  generated  code  (typical  <b>YYDEBUG</b>  definition  is a print statement). <b>YYDEBUG</b> statements are
              generated in every state and have two variables: <b>state</b> (either a DFA state index or <b>-1</b>) and <b>symbol</b>
              (the current input symbol).

       <b>yyaccept</b>
              An l-value of unsigned integral type that stores the number  of  the  latest  matched  rule.  User
              definition is necessary only with <b>--storable-state</b> option.

       <b>yybm</b>   A  table  containing  compressed bitmaps for up to 8 transitions (used with the <b>--bitmaps</b> option).
              The table contains 256 elements and is indexed by 1-byte code units. Each 8-bit  element  combines
              boolean  values for up to 8 transitions. k-Th bit of n-th element is true iff n-th code unit is in
              the range of k-th transition. The idea of this bitmap is to replace many  <u>if</u>  branches  or  <u>switch</u>
              cases with one check of a single bit in the table.

       <b>yych</b>   An  l-value of type <b>YYCTYPE</b> that stores the current input character.  User definition is necessary
              only with <b>-f</b> <b>--storable-state</b> option.

       <b>yyctable</b>
              Jump table generated  for  the  initial  condition  dispatch  (enabled  with  the  combination  of
              <b>--conditions</b> and <b>--computed-gotos</b> options).

       <b>yyfill</b> An  l-value  that  stores  the  result  of  <b>YYFILL</b> call (this may be necessary for pure functional
              languages, where <b>YYFILL</b> is a monadic function with complex return value).

       <b>yynmatch</b>
              An l-value of unsigned integral type that stores the number  of  POSIX  capturing  groups  in  the
              matched rule.  Used only with <b>-P</b> <b>--posix-captures</b> option.

       <b>yypmatch</b>
              An  array  of  l-values  that  are  used  to  hold  the  tag values corresponding to the capturing
              parentheses in the matching rule. Array length must be at least <b>yynmatch</b> <b>*</b> <b>2</b> (usually  <b>YYMAXNMATCH</b>
              <b>*</b> <b>2</b> is a good choice).  Used only with <b>-P</b> <b>--posix-captures</b> option.

       <b>yystable</b>
              Deprecated.

       <b>yystate</b>
              An l-value used with the <b>--loop-switch</b> option to store the current DFA state.

       <b>yytarget</b>
              Jump  table  that  contains  jump targets (label addresses) for all transitions from a state. This
              table is local to each state. Generation of  <b>yytarget</b>  tables  is  enabled  with  <b>--computed-gotos</b>
              option.

   <b>Options</b>
       Some of the options have corresponding configurations, others are global and cannot be changed after re2c
       starts  reading  the  input  file.  Debug options generally require building re2c in debug configuration.
       Internal options are useful for experimenting with the algorithms used in re2c.

       <b>-?</b> <b>--help</b> <b>-h</b>
              Show help message.

       <b>--api</b> <b>&lt;simple</b> <b>|</b> <b>record</b> <b>|</b> <b>generic&gt;</b>
              Specify the API used by the generated code to interface  with  used-defined  code.  Option  <b>simple</b>
              shold  be  used in simple cases when there's no need for buffer refilling and storing lexer state.
              Option <b>record</b> should be used when lexer state needs to be  stored  in  a  record  (struct,  class,
              etc.).   Option  <b>generic</b>  should be used in complex cases when the other two APIs are not flexible
              enough.

       <b>--bit-vectors</b> <b>-b</b>
              Optimize conditional jumps using bit masks.  This option implies <b>--nested-ifs</b>.

       <b>--captures,</b> <b>--leftmost-captures</b>
              Enable submatch extraction with leftmost greedy capturing groups. The result is collected into  an
              array  <b>yybmatch</b>  of  capacity <b>2</b> <b>*</b> <b>YYMAXNMATCH</b>, and <b>yynmatch</b> is set to the number of groups for the
              matching rule.

       <b>--captvars,</b> <b>--leftmost-captvars</b>
              Enable submatch extraction with leftmost greedy capturing groups. The  result  is  collected  into
              variables <b>yytl&lt;k&gt;</b>, <b>yytr&lt;k&gt;</b> for <b>k</b>-th capturing group.

       <b>--case-insensitive</b>
              Treat single-quoted and double-quoted strings as case-insensitive.

       <b>--case-inverted</b>
              Invert  the  meaning  of  single-quoted  and double-quoted strings: treat single-quoted strings as
              case-sensitive and double-quoted strings as case-insensitive.

       <b>--case-ranges</b>
              Collapse consecutive cases in a switch statements into a range of the  form  <b>low</b>  <b>...</b>  <b>high</b>.  This
              syntax  is  a C/C++ language extension that is supported by compilers like GCC, Clang and Tcc. The
              main advantage over using single cases is smaller  generated  code  and  faster  generation  time,
              although  for  some  compilers  like  Tcc  it also results in smaller binary size.  This option is
              supported only for C.

       <b>--computed-gotos</b> <b>-g</b>
              Optimize conditional jumps using non-standard "computed goto" extension (which must  be  supported
              by  the  compiler).  re2d  generates  jump  tables only in complex cases with a lot of conditional
              branches. Complexity threshold can be configured with <b>cgoto:threshold</b> configuration.  This  option
              implies <b>--bit-vectors</b>. It is supported only for C.

       <b>--conditions</b> <b>--start-conditions</b> <b>-c</b>
              Enable  support  of Flex-like "conditions": multiple interrelated lexers within one block. This is
              an alternative to manually specifying different re2d blocks connected with <b>goto</b> or function calls.

       <b>--depfile</b> <b>FILE</b>
              Write dependency information to <b>FILE</b> in the form of a Makefile rule <b>&lt;output-file&gt;</b>  <b>:</b>  <b>&lt;input-file&gt;</b>
              <b>[include-file</b>  <b>...]</b>.  This  allows  one  to  track  build  dependencies in the presence of <b>include</b>
              blocks/directives, so that updating include files triggers regeneration of the output file.   This
              option depends on the <b>--output</b> option.

       <b>--ebcdic</b> <b>--ecb</b> <b>-e</b>
              Generate  a  lexer that reads input in EBCDIC encoding. re2d assumes that the character range is 0
              -- 0xFF and character size is 1 byte.

       <b>--empty-class</b> <b>&lt;match-empty</b> <b>|</b> <b>match-none</b> <b>|</b> <b>error&gt;</b>
              Define the way re2d treats empty character classes. With <b>match-empty</b>  (the  default)  empty  class
              matches  empty  input  (which is illogical, but backwards-compatible). With <b>match-none</b> empty class
              always fails to match.  With <b>error</b> empty class raises a compilation error.

       <b>--encoding-policy</b> <b>&lt;fail</b> <b>|</b> <b>substitute</b> <b>|</b> <b>ignore&gt;</b>
              Define the way re2d treats Unicode surrogates.  With  <b>fail</b>  re2d  aborts  with  an  error  when  a
              surrogate  is  encountered.  With <b>substitute</b> re2d silently replaces surrogates with the error code
              point 0xFFFD. With <b>ignore</b> (the default) re2d treats surrogates as normal code points. The  Unicode
              standard says that standalone surrogates are invalid, but real-world libraries and programs behave
              in different ways.

       <b>--flex-syntax</b> <b>-F</b>
              Partial  support for Flex syntax: in this mode named definitions don't need the equal sign and the
              terminating semicolon, and when used they must be surrounded  with  curly  braces.  Names  without
              curly braces are treated as double-quoted strings.

       <b>--goto-label</b>
              Use  "goto/label"  code  model:  encode  DFA  in  form  of labeled code blocks connected with <b>goto</b>
              transitions across blocks. This is only supported for languages that have a <b>goto</b> statement.

       <b>--header</b> <b>--type-header</b> <b>-t</b> <b>HEADER</b>
              Generate a <b>HEADER</b> file. The contents of the file can be specified using special  blocks  <b>header:on</b>
              and  <b>header:off</b>.  If  conditions  are  used,  the  generated  header  will  have  a condition enum
              automatically appended to it (unless there is an explicit <b>conditions</b> block).

       <b>-I</b> <b>PATH</b>
              Add <b>PATH</b> to the list of locations which are used when searching for include files. This option  is
              useful in combination with <b>include</b> block or directive. re2d looks for <b>FILE</b> in the directory of the
              parent file and in the include locations specified with <b>-I</b> option.

       <b>--input</b> <b>&lt;default</b> <b>|</b> <b>custom&gt;</b>
              Deprecated  alias  for  <b>--api</b>.  Option <b>default</b> corresponds to <b>simple</b> (it is indeed the default for
              most backends, but not for all). Option <b>custom</b> corresponds to <b>generic</b>.

       <b>--input-encoding</b> <b>&lt;ascii</b> <b>|</b> <b>utf8&gt;</b>
              Specify the way re2d parses regular expressions.  With <b>ascii</b> (the default) re2d handles  input  as
              ASCII-encoded:  any  sequence  of  code units is a sequence of standalone 1-byte characters.  With
              <b>utf8</b> re2d handles input as UTF8-encoded and recognizes multibyte characters.

       <b>--invert-captures</b>
              Invert the meaning of capturing and non-capturing groups. By default <b>(...)</b>  is  capturing  and  <b>(!</b>
              <b>...)</b> is non-capturing. With this option <b>(!</b> <b>...)</b> is capturing and <b>(...)</b> is non-capturing.

       <b>--lang</b> <b>&lt;none</b> <b>|</b> <b>c</b> <b>|</b> <b>d</b> <b>|</b> <b>go</b> <b>|</b> <b>haskell</b> <b>|</b> <b>java</b> <b>|</b> <b>js</b> <b>|</b> <b>ocaml</b> <b>|</b> <b>python</b> <b>|</b> <b>rust</b> <b>|</b> <b>v</b> <b>|</b> <b>zig&gt;</b>
              Specify  the  target language. Supported languages are C, D, Go, Haskell, Java, JS, OCaml, Python,
              Rust, V, Zig (more languages can be added via user-defined syntax files, see the <b>--syntax</b> option).
              Option <b>none</b> disables default suntax configs, so that the target language is undefined.

       <b>--location-format</b> <b>&lt;gnu</b> <b>|</b> <b>msvc&gt;</b>
              Specify location format in messages.  With <b>gnu</b> locations  are  printed  as  'filename:line:column:
              ...'.  With <b>msvc</b> locations are printed as 'filename(line,column) ...'.  The default is <b>gnu</b>.

       <b>--loop-switch</b>
              Use  "loop/switch"  code  model:  encode  DFA  in  form  of  a loop over a switch statement, where
              individual states are switch cases. State is stored in a  variable  <b>yystate</b>.  Transitions  between
              states  update  <b>yystate</b>  to  the case label of the destination state and continue execution to the
              head of the loop.

       <b>--nested-ifs</b> <b>-s</b>
              Use nested <b>if</b> statements instead of <b>switch</b> statements in conditional jumps. This  usually  results
              in more efficient code with non-optimizing compilers.

       <b>--no-debug-info</b> <b>-i</b>
              Do  not  output line directives. This may be useful when the generated code is stored in a version
              control system (to avoid huge autogenerated diffs on small changes).

       <b>--no-generation-date</b>
              Suppress date output in the generated file.

       <b>--no-version</b>
              Suppress version output in the generated file.

       <b>--no-unsafe</b>
              Do not generate <b>unsafe</b> wrapper over <b>YYPEEK</b> (this option is  specific  to  Rust).  For  performance
              reasons  <b>YYPEEK</b> should avoid bounds-checking, as the lexer already performs end-of-input checks in
              a more efficient way.  The user may choose to provide a safe <b>YYPEEK</b> definition,  or  a  definition
              that  is  unsafe  only  in  release  builds,  in  which case the <b>--no-unsafe</b> option helps to avoid
              warnings about redundant <b>unsafe</b> blocks.

       <b>--output</b> <b>-o</b> <b>OUTPUT</b>
              Specify the <b>OUTPUT</b> file.

       <b>--posix-captures,</b> <b>-P</b>
              Enable submatch extraction with POSIX-style capturing groups. The  result  is  collected  into  an
              array  <b>yybmatch</b>  of  capacity <b>2</b> <b>*</b> <b>YYMAXNMATCH</b>, and <b>yynmatch</b> is set to the number of groups for the
              matching rule.

       <b>--posix-captvars</b>
              Enable submatch extraction with  POSIX-style  capturing  groups.  The  result  is  collected  into
              variables <b>yytl&lt;k&gt;</b>, <b>yytr&lt;k&gt;</b> for <b>k</b>-th capturing group.

       <b>--recursive-functions</b>
              Use  code  model based on co-recursive functions, where each DFA state is a separate function that
              may call other state-functions or itself.

       <b>--reusable</b> <b>-r</b>
              Deprecated since version 2.2 (reusable blocks are allowed by default now).

       <b>--skeleton</b> <b>-S</b>
              Ignore user-defined interface code and generate a self-contained "skeleton" program. Additionally,
              generate input files with strings derived from the regular grammar and  compressed  match  results
              that  are used to verify "skeleton" behavior on all inputs. This option is useful for finding bugs
              in optimizations and code generation. This option is supported only for C.

       <b>--storable-state</b> <b>-f</b>
              Generate a lexer which can store its inner state.  This is useful in push-model lexers  which  are
              stopped  by  an  outer  program  when  there is not enough input, and then resumed when more input
              becomes available. In this  mode  users  should  additionally  define  <b>YYGETSTATE</b>  and  <b>YYSETSTATE</b>
              primitives, and variables <b>yych</b>, <b>yyaccept</b> and <b>state</b> should be part of the stored lexer state.

       <b>--syntax</b> <b>FILE</b>
              Load configurations from the specified <b>FILE</b> and apply them on top of the default syntax file. Note
              that <b>FILE</b> can define only a few configurations (if it's used to amend the default syntax file), or
              it  can  define  a  whole new language backend (in the latter case it is recommended to use <b>--lang</b>
              <b>none</b> option).

       <b>--tags</b> <b>-T</b>
              Enable submatch extraction with tags.

       <b>--ucs2</b> <b>--wide-chars</b> <b>-w</b>
              Generate a lexer that reads UCS2-encoded input. re2d assumes that the  character  range  is  0  --
              0xFFFF and character size is 2 bytes.  This option implies <b>--nested-ifs</b>.

       <b>--utf8</b> <b>--utf-8</b> <b>-8</b>
              Generate a lexer that reads input in UTF-8 encoding. re2d assumes that the character range is 0 --
              0x10FFFF and character size is 1 byte.

       <b>--utf16</b> <b>--utf-16</b> <b>-x</b>
              Generate  a  lexer  that  reads UTF16-encoded input. re2d assumes that the character range is 0 --
              0x10FFFF and character size is 2 bytes.  This option implies <b>--nested-ifs</b>.

       <b>--utf32</b> <b>--unicode</b> <b>-u</b>
              Generate a lexer that reads UTF32-encoded input. re2d assumes that the character  range  is  0  --
              0x10FFFF and character size is 4 bytes.  This option implies <b>--nested-ifs</b>.

       <b>--verbose</b>
              Output a short message in case of success.

       <b>--vernum</b> <b>-V</b>
              Show version information in <b>MMmmpp</b> format (major, minor, patch).

       <b>--version</b> <b>-v</b>
              Show version information.

       <b>--single-pass</b> <b>-1</b>
              Deprecated. Does nothing (single pass is the default now).

       <b>--debug-output</b> <b>-d</b>
              Emit <b>YYDEBUG</b> invocations in the generated code. This is useful to trace lexer execution.

       <b>--dump-adfa</b>
              Debug option: output DFA after tunneling (in .dot format).

       <b>--dump-cfg</b>
              Debug option: output control flow graph of tag variables (in .dot format).

       <b>--dump-closure-stats</b>
              Debug option: output statistics on the number of states in closure.

       <b>--dump-dfa-det</b>
              Debug option: output DFA immediately after determinization (in .dot format).

       <b>--dump-dfa-min</b>
              Debug option: output DFA after minimization (in .dot format).

       <b>--dump-dfa-tagopt</b>
              Debug option: output DFA after tag optimizations (in .dot format).

       <b>--dump-dfa-tree</b>
              Debug  option: output DFA under construction with states represented as tag history trees (in .dot
              format).

       <b>--dump-dfa-raw</b>
              Debug option: output DFA under construction with expanded state-sets (in .dot format).

       <b>--dump-interf</b>
              Debug option: output interference table produced by liveness analysis of tag variables.

       <b>--dump-nfa</b>
              Debug option: output NFA (in .dot format).

       <b>--emit-dot</b> <b>-D</b>
              Instead of normal output generate lexer graph in .dot format.  The output can be converted  to  an
              image with the help of Graphviz (e.g. something like <b>dot</b> <b>-Tpng</b> <b>-odfa.png</b> <b>dfa.dot</b>).

       <b>--dfa-minimization</b> <b>&lt;moore</b> <b>|</b> <b>table&gt;</b>
              Internal  option: DFA minimization algorithm used by re2d. The <b>moore</b> option is the Moore algorithm
              (it is the default). The <b>table</b> option is the "table filling"  algorithm.  Both  algorithms  should
              produce  the same DFA up to states relabeling; table filling is simpler and much slower and serves
              as a reference implementation.

       <b>--eager-skip</b>
              Internal option: make the generated lexer advance the input position eagerly -- immediately  after
              reading  the  input  symbol. This changes the default behavior when the input position is advanced
              lazily -- after transition to the next state.

       <b>--no-lookahead</b>
              Internal option, deprecated.  It  used  to  enable  <a href="../man0/TDFA.0.html">TDFA</a>(0)  algorithm.  Unlike  <a href="../man1/TDFA.1.html">TDFA</a>(1),  <a href="../man0/TDFA.0.html">TDFA</a>(0)
              algorithm  does  not  use  one-symbol  lookahead.  It  applies register operations to the incoming
              transitions rather than the outgoing ones.  Benchmarks  showed  that  <a href="../man0/TDFA.0.html">TDFA</a>(0)  algorithm  is  less
              efficient than <a href="../man1/TDFA.1.html">TDFA</a>(1).

       <b>--no-optimize-tags</b>
              Internal option: suppress optimization of tag variables (useful for debugging).

       <b>--posix-closure</b> <b>&lt;gor1</b> <b>|</b> <b>gtop&gt;</b>
              Internal option: specify shortest-path algorithm used for the construction of epsilon-closure with
              POSIX  disambiguation semantics: <b>gor1</b> (the default) stands for Goldberg-Radzik algorithm, and <b>gtop</b>
              stands for "global topological order" algorithm.

       <b>--posix-prectable</b> <b>&lt;complex</b> <b>|</b> <b>naive&gt;</b>
              Internal option: specify the algorithm  used  to  compute  POSIX  precedence  table.  The  <b>complex</b>
              algorithm  computes  precedence  table  in  one  traversal  of  tag history tree and has quadratic
              complexity in the number of TNFA states; it is the default. The  <b>naive</b>  algorithm  has  worst-case
              cubic  complexity  in  the  number  of TNFA states, but it is much simpler than <b>complex</b> and may be
              slightly faster in non-pathological cases.

       <b>--stadfa</b>
              Internal option, deprecated.  It used to enable staDFA algorithm, which differs from TDFA in  that
              register operations are placed in states rather than on transitions. Benchmarks showed that staDFA
              algorithm is less efficient than TDFA.

       <b>--fixed-tags</b> <b>&lt;none</b> <b>|</b> <b>toplevel</b> <b>|</b> <b>all&gt;</b>
              Internal  option:  specify whether the fixed-tag optimization should be applied to all tags (<b>all</b>),
              none of them (<b>none</b>), or only those in toplevel  concatenation  (<b>toplevel</b>).  The  default  is  <b>all</b>.
              "Fixed" tags are those that are located within a fixed distance to some other tag (called "base").
              In  such  cases  only  the  base  tag  needs  to be tracked, and the value of the fixed tag can be
              computed as the value of the base tag plus a static offset. For tags that are under alternative or
              repetition it is also necessary to check if the base tag has a no-match value (in that case  fixed
              tag  should also be set to no-match, disregarding the offset). For tags in top-level concatenation
              the check is not needed, because they always match.

   <b>Warnings</b>
       Warnings can be invividually enabled, disabled and turned into an error.

       <b>-W</b>     Turn on all warnings.

       <b>-Werror</b>
              Turn warnings into errors. Note that this option alone doesn't  turn  on  any  warnings;  it  only
              affects those warnings that have been turned on so far or will be turned on later.

       <b>-W&lt;warning&gt;</b>
              Turn on <b>warning</b>.

       <b>-Wno-&lt;warning&gt;</b>
              Turn off <b>warning</b>.

       <b>-Werror-&lt;warning&gt;</b>
              Turn on <b>warning</b> and treat it as an error (this implies <b>-W&lt;warning&gt;</b>).

       <b>-Wno-error-&lt;warning&gt;</b>
              Don't treat this particular <b>warning</b> as an error. This doesn't turn off the warning itself.

       <b>-Wcondition-order</b>
              Warn if the generated program makes implicit assumptions about condition numbering. One should use
              either <b>--header</b> option or <b>conditions</b> block to generate a mapping of condition names to numbers and
              then use the autogenerated condition names.

       <b>-Wempty-character-class</b>
              Warn if a regular expression contains an empty character class. Trying to match an empty character
              class  makes  no  sense: it should always fail.  However, for backwards compatibility reasons re2d
              permits empty character classes and treats them as empty strings. Use the <b>--empty-class</b> option  to
              change the default behavior.

       <b>-Wmatch-empty-string</b>
              Warn  if  a rule is nullable (matches an empty string).  If the lexer runs in a loop and the empty
              match is unintentional, the lexer may unexpectedly hang in an infinite loop.

       <b>-Wswapped-range</b>
              Warn if the lower bound of a range is greater than its upper bound. The  default  behavior  is  to
              silently swap the range bounds.

       <b>-Wundefined-control-flow</b>
              Warn  if  some  input  strings  cause undefined control flow in the lexer (the faulty patterns are
              reported). This is a dangerous and common mistake. It can be easily fixed by  adding  the  default
              rule  <b>*</b>  which  has  the lowest priority, matches any code unit, and always consumes a single code
              unit.

       <b>-Wunreachable-rules</b>
              Warn about rules that are shadowed by other rules and will never match.

       <b>-Wuseless-escape</b>
              Warn if a symbol is escaped when it shouldn't be.  By default, re2d silently ignores such escapes,
              but this may as well indicate a typo or an error in the escape sequence.

       <b>-Wnondeterministic-tags</b>
              Warn if a tag has <b>n</b>-th degree of nondeterminism, where <b>n</b> is greater than 1.

       <b>-Wsentinel-in-midrule</b>
              Warn if the sentinel symbol occurs in the middle of a rule --- this may cause reads past  the  end
              of buffer, crashes or memory corruption in the generated lexer. This warning is only applicable if
              the  sentinel  method  of  checking  for  the  end  of  input  is  used.  It is set to an error if
              <b>re2c:sentinel</b> configuration is used.

       <b>-Wundefined-syntax-config</b>
              Warn  if  the  syntax  file  specified  with  <b>--syntax</b>  option  is  missing  definitions  of  some
              configurations.  This  helps  to  maintain  user-defined  syntax  files:  if  a  new  release adds
              configurations, old syntax file will raise a warning, and the  user  will  be  notified.  If  some
              configurations  are  unused  and  do  not  need  a  definition,  they  should be explicitly set to
              <b>&lt;undefined&gt;</b>.

   <b>Syntax</b> <b>files</b>
       Support for different languages in re2c is based on the idea  of  <u>syntax</u>  <u>files</u>.   A  syntax  file  is  a
       configuration file that defines syntax of the target language -- not the whole language, but a small part
       of  it  that  is used by the generated code. Syntax files make re2c very flexible, but they should not be
       used as a replacement for <b>re2c:</b> configurations: their purpose is to define syntax of the target language,
       not to customize one particular lexer. All supported languages have default syntax files that are part of
       the distribution (see <b>include/syntax</b> subdirectory); they are also embedded in the re2d binary.  Users may
       provide a custom syntax file that overrides a few configurations for one of supported languages, or  they
       may choose to redefine all configurations (in that case <b>--lang</b> <b>none</b> option should be used).  Syntax files
       contain  configurations  of  four  different  kinds:  feature  lists,  language  configurations,  inplace
       configurations and code templates.

       <b>Feature</b> <b>lists</b>
          A few list configurations define various features supported by a given backend, so that re2d may  give
          a clear error if the user tries to enable an unsupported feature:

          <b>supported_apis</b>
                 A list of supported APIs with possible elements <b>simple</b>, <b>record</b>, <b>generic</b>.

          <b>supported_api_styles</b>
                 A list of supported API styles with possible elements <b>functions</b>, <b>free-form</b>.

          <b>supported_code_models</b>
                 A   list   of   supported   code   models   with  possible  elements  <b>goto-label</b>,  <b>loop-switch</b>,
                 <b>recursive-functions</b>.

          <b>supported_targets</b>
                 A list of supported codegen targets with possible elements <b>code</b>, <b>dot</b>, <b>skeleton</b>.

          <b>supported_features</b>
                 A list of supported  features  with  possible  elements  <b>nested-ifs</b>,  <b>bitmaps</b>,  <b>computed-gotos</b>,
                 <b>case-ranges</b>, <b>monadic</b>, <b>unsafe</b>, <b>tags</b>, <b>captures</b>, <b>captvars</b>.

       <b>Language</b> <b>configurations</b>
          A few boolean configurations describe features of the target language that affect re2d parser and code
          generator:

          <b>semicolons</b>
                 Non-zero if the language uses semicolons after statements.

          <b>backtick_quoted_strings</b>
                 Non-zero if the language has backtick-quoted strings.

          <b>single_quoted_strings</b>
                 Non-zero if the language has single-quoted strings.

          <b>indentation_sensitive</b>
                 Non-zero if the language is indentation sensitive.

          <b>wrap_blocks_in_braces</b>
                 Non-zero if compound statements must be wrapped in curly braces.

       <b>Inplace</b> <b>configurations</b>
          Syntax  files  define  initial  values  of  all <b>re2c:</b> configurations, as they may differ for different
          languages. See configurations section for a full list of all inplace configurations and their meaning.

       <b>Code</b> <b>templates</b>
          Code templates define syntax of the target language. They are  written  in  a  simple  domain-specific
          language with the following formal grammar:

              code-template ::
                    name '=' code-exprs ';'
                  | CODE_TEMPLATE ';'
                  | '&lt;undefined&gt;' ';'

              code-exprs ::
                    &lt;EMPTY&gt;
                  | code-exprs code-expr

              code-expr ::
                    STRING
                  | VARIABLE
                  | optional
                  | list

              optional ::
                    '(' CONDITIONAL '?' code-exprs ')'
                  | '(' CONDITIONAL '?' code-exprs ':' code-exprs ')'

              list ::
                    '[' VARIABLE ':' code-exprs ']'
                  | '[' VARIABLE '{' NUMBER '}' ':' code-exprs ']'
                  | '[' VARIABLE '{' NUMBER ',' NUMBER '}' ':' code-exprs ']'

          A  code  template  is  a  sequence  of  string  literals, variables, optional elements and lists, or a
          reference to another code template, or a special value <b>&lt;undefined&gt;</b>. Variables  are  placeholders  that
          are  substituted  during  code  generation  phase.  List  variables  are  special: when expanding list
          templates, re2d repeats expressions the right hand side of the column a few times, each time replacing
          occurrences of the list variable with a value specific to this repetition. Lists have optional  bounds
          (negative  values  are  counted from the end, e.g. <b>-1</b> means the last element). Conditional names start
          with a dot.  Both conditionals and variables may be either local (specific to the given code template)
          or global (allowed in all code templates). When re2d reads syntax  file,  it  checks  that  each  code
          template uses only the variables and conditionals that are allowed in it.

          For example, the following code template defines if-then-else construct for a C-like language:

              code:if_then_else =
                  [branch{0}: topindent "if " cond " {" nl
                      indent [stmt: stmt] dedent]
                  [branch{1:-1}: topindent "} else" (.cond ? " if " cond) " {" nl
                      indent [stmt: stmt] dedent]
                  topindent "}" nl;

          Here  <b>branch</b>  is a list variable: <b>branch{0}</b> expands to the first branch (which is special, as there is
          no <b>else</b> part), <b>branch{1:-1}</b> expands to all remaining branches (if any). <b>stmt</b> is also a list  variable:
          <b>[stmt:</b>  <b>stmt]</b> is a nested list that expands to a list of statements in the body of the current branch.
          <b>topindent</b>, <b>indent</b>, <b>dedent</b> and <b>nl</b> are global variables, and <b>.cond</b> is a local conditional (their meaning
          is described below). This code template could produce the following code:

              if x {
                  // do something
              } else if y {
                  // do something else
              } else {
                  // don't do anything
              }

          Here's a list of all code templates supported by re2d with their  local  variables  and  conditionals.
          Note that a particular definition may, but does not have to use local variables and conditionals.  Any
          unused code templates should be set to <b>&lt;undefined&gt;</b>.

          <b>code:var_local</b>
                 Declaration  or  definition  of  a  local  variable. Supported variables: <b>type</b> (the type of the
                 variable), <b>name</b> (its name) and <b>init</b> (initial value, if any). Conditionals: <b>.init</b> (true if there
                 is an initializer).

          <b>code:var_global</b>
                 Same as <b>code:var_local</b>, except that it's used in top-level.

          <b>code:const_local</b>
                 Definition of a local constant. Supported variables: <b>type</b> (the type of the constant), <b>name</b> (its
                 name) and <b>init</b> (initial value).

          <b>code:const_global</b>
                 Same as <b>code:const_local</b>, except that it's used in top-level.

          <b>code:array_local</b>
                 Definition of a local array (table). Supported variables: <b>type</b> (the type  of  array  elements),
                 <b>name</b> (array name), <b>size</b> (its size), <b>row</b> (a list variable that does not itself produce any code,
                 but  expands  list  expression  as  many times as there are rows in the table) and <b>elem</b> (a list
                 variable that expands to all table elements in the current row -- it's meant to  be  nested  in
                 the <b>row</b> list).

          <b>code:array_global</b>
                 Same as <b>code:array_local</b>, except that it's used in top-level.

          <b>code:array_elem</b>
                 Reference to an element of an array (table). Supported variables: <b>array</b> (the name of the array)
                 and <b>index</b> (index of the element).

          <b>code:enum</b>
                 Definition  of  an  enumeration  (it  may  be  defined  using  a special language construct for
                 enumerations, or  simply  as  a  few  standalone  constants).   Supported  variables  are  <b>type</b>
                 (user-defined  enumeration  type or type of the constants), <b>elem</b> (list variable that expands to
                 the name of each member) and <b>init</b> (initializer for each member). Conditionals: <b>.init</b>  (true  if
                 there is an initializer).

          <b>code:enum_elem</b>
                 Enumeration  element  (a  member  of  a  user-defined enumeration type or a name of a constant,
                 depending on how <b>code:enum</b> is defined).  Supported variables are <b>name</b> (the name of the element)
                 and <b>type</b> (its type).

          <b>code:assign</b>
                 Assignment statement. Supported variables are <b>lhs</b> (left hand side) and <b>rhs</b> (right hand side).

          <b>code:type_int</b>
                 Signed integer type.

          <b>code:type_uint</b>
                 Unsigned integer type.

          <b>code:type_yybm</b>
                 Type of elements in the <b>yybm</b> table.

          <b>code:type_yytarget</b>
                 Type of elements in the <b>yytarget</b> table.

          <b>code:cmp_eq</b>
                 Operator "equals".

          <b>code:cmp_ne</b>
                 Operator "not equals".

          <b>code:cmp_lt</b>
                 Operator "less than".

          <b>code:cmp_gt</b>
                 Operator "greater than"

          <b>code:cmp_le</b>
                 Operator "less or equal"

          <b>code:cmp_ge</b>
                 Operator "greater or equal"

          <b>code:if_then_else</b>
                 If-then-else statement with one or more branches. Supported variables: <b>branch</b> (a list  variable
                 that  does  not itself produce any code, but expands list expression as many times as there are
                 branches), <b>cond</b> (condition of the current branch) and <b>stmt</b> (a list variable that expands to all
                 statements in the current branch). Conditionals: <b>.cond</b>  (true  if  the  current  branch  has  a
                 condition), <b>.many</b> (true if there's more than one branch).

          <b>code:if_then_else_oneline</b>
                 A  specialization of <b>code:if_then_else</b> for the case when all branches have one-line statements.
                 If this is <b>&lt;undefined&gt;</b>, <b>code:if_then_else</b> is used instead.

          <b>code:switch</b>
                 A switch statement  with  one  or  more  cases.  Supported  variables:  <b>expr</b>  (the  switched-on
                 expression) and <b>case</b> (a list variable that expands to all cases-groups with their code blocks).

          <b>code:switch_cases</b>
                 A  group of switch cases that maps to a single code block. Supported variables are <b>case</b> (a list
                 variable that expands to all cases in this group) and <b>stmt</b> (a list variable that expands to all
                 statements in the code block.

          <b>code:switch_cases_oneline</b>
                 A specialization of <b>code:switch_cases</b> for the case when the code block  consists  of  a  single
                 one-line statement. If this is <b>&lt;undefined&gt;</b>, <b>code:switch_cases</b> is used instead.

          <b>code:switch_case_range</b>
                 A  single  switch  case  that covers a range of values (possibly consisting of a single value).
                 Supported variable: <b>val</b> (a list variable that expands to all values in  the  range).  Supported
                 conditionals: <b>.many</b> (true if there's more than one value in the range) and <b>.char_literals</b> (true
                 if  this  is  a  switch on character literals -- some languages provide special syntax for this
                 case).

          <b>code:switch_case_default</b>
                 Default switch case.

          <b>code:loop</b>
                 A loop that runs forever (unless interrupted from the loop body).  Supported  variables:  <b>label</b>
                 (loop label), <b>stmt</b> (a list variable that expands to all statements in the loop body).

          <b>code:continue</b>
                 Continue statement. Supported variables: <b>label</b> (label from which to continue execution).

          <b>code:goto</b>
                 Goto statement. Supported variables: <b>label</b> (label of the jump target).

          <b>code:fndecl</b>
                 Function  declaration.  Supported  variables:  <b>name</b> (function name), <b>type</b> (return type), <b>arg</b> (a
                 list variable that does not itself produce code, but expands list expression as many  times  as
                 there  are  function  arguments),  <b>argname</b> (name of the current argument), <b>argtype</b> (type of the
                 current argument). Conditional: <b>.type</b> (true if this is a non-void function).

          <b>code:fndef</b>
                 Like <b>code:fndecl</b>, but used for function definitions, so it has  one  additional  list  variable
                 <b>stmt</b> that expands to all statements in the function body.

          <b>code:fncall</b>
                 Function  call  statement. Supported variables: <b>name</b> (function name), <b>retval</b> (l-value where the
                 return value is stored, if any)  and  <b>arg</b>  (a  list  variable  that  expands  to  all  function
                 arguments).   Conditionals:  <b>.args</b>  (true  if  the function has arguments) and <b>.retval</b> (true if
                 return value needs to be saved).

          <b>code:tailcall</b>
                 Tail call statement. Supported variables: <b>name</b> (function name), and <b>arg</b> (a list  variable  that
                 expands  to  all function arguments).  Conditionals: <b>.args</b> (true if the function has arguments)
                 and <b>.retval</b> (true if this is a non-void function).

          <b>code:recursive_functions</b>
                 Program body with <b>--recursive-functions</b> code model. Supported variables: <b>fn</b>  (a  list  variable
                 that  does  not itself produce any code, but expands list expression as many times as there are
                 functions), <b>fndecl</b> (declaration of the current function) and <b>fndef</b> (definition of  the  current
                 function).

          <b>code:fingerprint</b>
                 The fingerprint at the top of the generated output file. Supported variables: <b>ver</b> (re2d version
                 that was used to generate this) and <b>date</b> (generation date).

          <b>code:line_info</b>
                 The  format  of  line  directives (if this is set to <b>&lt;undefined&gt;</b>, no directives are generated).
                 Supported variables: <b>line</b> (line number) and <b>file</b> (filename).

          <b>code:abort</b>
                 A statement that aborts program execution.

          <b>code:yydebug</b>
                 <b>YYDEBUG</b> statement, possibly specialized for  different  APIs.   Supported  variables:  <b>YYDEBUG</b>,
                 <b>yyrecord</b>, <b>yych</b> (map to the corresponding <b>re2c:</b> configurations), <b>state</b> (DFA state number).

          <b>code:yypeek</b>
                 <b>YYPEEK</b>  statement,  possibly  specialized  for  different  APIs.   Supported variables: <b>YYPEEK</b>,
                 <b>YYCTYPE</b>, <b>YYINPUT</b>, <b>YYCURSOR</b>, <b>yyrecord</b>, <b>yych</b> (map to  the  corresponding  <b>re2c:</b>  configurations).
                 Conditionals: <b>.cast</b> (true if <b>re2c:yych:conversion</b> is set to non-zero).

          <b>code:yyskip</b>
                 <b>YYSKIP</b>  statement,  possibly  specialized  for  different  APIs.   Supported variables: <b>YYSKIP</b>,
                 <b>YYCURSOR</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations).

          <b>code:yybackup</b>
                 <b>YYBACKUP</b> statement, possibly specialized for different APIs.   Supported  variables:  <b>YYBACKUP</b>,
                 <b>YYCURSOR</b>, <b>YYMARKER</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations).

          <b>code:yybackupctx</b>
                 <b>YYBACKUPCTX</b>   statement,   possibly  specialized  for  different  APIs.   Supported  variables:
                 <b>YYBACKUPCTX</b>, <b>YYCURSOR</b>, <b>YYCTXMARKER</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations).

          <b>code:yyskip_yypeek</b>
                 Combined  <b>code:yyskip</b>  and  <b>code:yypeek</b>  statement  (defaults  to   <b>code:yyskip</b>   followed   by
                 <b>code:yypeek</b>).

          <b>code:yypeek_yyskip</b>
                 Combined   <b>code:yypeek</b>   and   <b>code:yyskip</b>  statement  (defaults  to  <b>code:yypeek</b>  followed  by
                 <b>code:yyskip</b>).

          <b>code:yyskip_yybackup</b>
                 Combined  <b>code:yyskip</b>  and  <b>code:yybackup</b>  statement  (defaults  to  <b>code:yyskip</b>  followed   by
                 <b>code:yybackup</b>).

          <b>code:yybackup_yyskip</b>
                 Combined  <b>code:yybackup</b>  and  <b>code:yyskip</b>  statement  (defaults  to  <b>code:yybackup</b>  followed by
                 <b>code:yyskip</b>).

          <b>code:yybackup_yypeek</b>
                 Combined <b>code:yybackup</b>  and  <b>code:yypeek</b>  statement  (defaults  to  <b>code:yybackup</b>  followed  by
                 <b>code:yypeek</b>).

          <b>code:yyskip_yybackup_yypeek</b>
                 Combined  <b>code:yyskip</b>,  <b>code:yybackup</b>  and  <b>code:yypeek</b>  statement  (defaults to``code:yyskip``
                 followed by <b>code:yybackup</b> followed by <b>code:yypeek</b>).

          <b>code:yybackup_yypeek_yyskip</b>
                 Combined <b>code:yybackup</b>, <b>code:yypeek</b> and  <b>code:yyskip</b>  statement  (defaults  to``code:yybackup``
                 followed by <b>code:yypeek</b> followed by <b>code:yyskip</b>).

          <b>code:yyrestore</b>
                 <b>YYRESTORE</b>  statement, possibly specialized for different APIs.  Supported variables: <b>YYRESTORE</b>,
                 <b>YYCURSOR</b>, <b>YYMARKER</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations).

          <b>code:yyrestorectx</b>
                 <b>YYRESTORECTX</b>  statement,  possibly  specialized  for  different  APIs.   Supported   variables:
                 <b>YYRESTORECTX</b>, <b>YYCURSOR</b>, <b>YYCTXMARKER</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations).

          <b>code:yyrestoretag</b>
                 <b>YYRESTORETAG</b>   statement,  possibly  specialized  for  different  APIs.   Supported  variables:
                 <b>YYRESTORETAG</b>, <b>YYCURSOR</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>tag</b> (the name
                 of tag variable used to restore position).

          <b>code:yyshift</b>
                 <b>YYSHIFT</b> statement, possibly specialized for  different  APIs.   Supported  variables:  <b>YYSHIFT</b>,
                 <b>YYCURSOR</b>,  <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>offset</b> (the number of code
                 units to shift the current position).

          <b>code:yyshiftstag</b>
                 <b>YYSHIFTSTAG</b>  statement,  possibly  specialized  for  different  APIs.    Supported   variables:
                 <b>YYSHIFTSTAG</b>,  <b>yyrecord</b>,  <b>negative</b>  (map  to  the  corresponding <b>re2c:</b> configurations), <b>tag</b> (tag
                 variable which needs to be shifted), <b>offset</b> (the number of code units to shift).  Conditionals:
                 <b>.nested</b>   (true   if   this  is  a  nested  tag  --  in  this  case  its  value  may  equal  to
                 <b>re2c:tags:negative</b>, which should not be shifted).

          <b>code:yyshiftmtag</b>
                 <b>YYSHIFTMTAG</b>  statement,  possibly  specialized  for  different  APIs.    Supported   variables:
                 <b>YYSHIFTMTAG</b>  (maps  to the corresponding <b>re2c:</b> configuration), <b>tag</b> (tag variable which needs to
                 be shifted), <b>offset</b> (the number of code units to shift).

          <b>code:yystagp</b>
                 <b>YYSTAGP</b> statement, possibly specialized for  different  APIs.   Supported  variables:  <b>YYSTAGP</b>,
                 <b>YYCURSOR</b>,  <b>yyrecord</b>  (map  to  the  corresponding <b>re2c:</b> configurations), <b>tag</b> (tag variable that
                 should be updated).

          <b>code:yymtagp</b>
                 <b>YYMTAGP</b> statement, possibly specialized for different APIs.  Supported variables: <b>YYMTAGP</b> (maps
                 to the corresponding <b>re2c:</b> configuration), <b>tag</b> (tag variable that should be updated).

          <b>code:yystagn</b>
                 <b>YYSTAGN</b> statement, possibly specialized for  different  APIs.   Supported  variables:  <b>YYSTAGN</b>,
                 <b>negative</b>,  <b>yyrecord</b>  (map  to  the  corresponding <b>re2c:</b> configurations), <b>tag</b> (tag variable that
                 should be updated).

          <b>code:yymtagn</b>
                 <b>YYMTAGN</b> statement, possibly specialized for different APIs.  Supported variables: <b>YYMTAGN</b> (maps
                 to the corresponding <b>re2c:</b> configuration), <b>tag</b> (tag variable that should be updated).

          <b>code:yycopystag</b>
                 <b>YYCOPYSTAG</b>  statement,  possibly  specialized  for  different   APIs.    Supported   variables:
                 <b>YYCOPYSTAG</b>,  <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>lhs</b>, <b>rhs</b> (left and right
                 hand side tag variables of the copy operation).

          <b>code:yycopymtag</b>
                 <b>YYCOPYMTAG</b>  statement,  possibly  specialized  for  different   APIs.    Supported   variables:
                 <b>YYCOPYMTAG</b>,  <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>lhs</b>, <b>rhs</b> (left and right
                 hand side tag variables of the copy operation).

          <b>code:yygetaccept</b>
                 <b>YYGETACCEPT</b>  statement,  possibly  specialized  for  different  APIs.    Supported   variables:
                 <b>YYGETACCEPT</b>,   <b>yyrecord</b>   (map  to  the  corresponding  <b>re2c:</b>  configurations),  <b>var</b>  (maps  to
                 <b>re2c:yyaccept</b> configuration).

          <b>code:yysetaccept</b>
                 <b>YYSETACCEPT</b>  statement,  possibly  specialized  for  different  APIs.    Supported   variables:
                 <b>YYSETACCEPT</b>,   <b>yyrecord</b>   (map  to  the  corresponding  <b>re2c:</b>  configurations),  <b>var</b>  (maps  to
                 <b>re2c:yyaccept</b> configuration) and <b>val</b> (numeric value of the accepted rule).

          <b>code:yygetcond</b>
                 <b>YYGETCOND</b> statement, possibly specialized for different APIs.  Supported variables:  <b>YYGETCOND</b>,
                 <b>yyrecord</b>   (map   to   the  corresponding  <b>re2c:</b>  configurations),  <b>var</b>  (maps  to  <b>re2c:yycond</b>
                 configuration).

          <b>code:yysetcond</b>
                 <b>YYSETCOND</b> statement, possibly specialized for different APIs.  Supported variables:  <b>YYSETCOND</b>,
                 <b>yyrecord</b>   (map   to   the  corresponding  <b>re2c:</b>  configurations),  <b>var</b>  (maps  to  <b>re2c:yycond</b>
                 configuration) and <b>val</b> (numeric condition identifier).

          <b>code:yygetstate</b>
                 <b>YYGETSTATE</b>  statement,  possibly  specialized  for  different   APIs.    Supported   variables:
                 <b>YYGETSTATE</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>var</b> (maps to <b>re2c:yystate</b>
                 configuration).

          <b>code:yysetstate</b>
                 <b>YYSETSTATE</b>   statement,   possibly   specialized  for  different  APIs.   Supported  variables:
                 <b>YYSETSTATE</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>var</b> (maps to <b>re2c:yystate</b>
                 configuration) and <b>val</b> (state number).

          <b>code:yylessthan</b>
                 <b>YYLESSTHAN</b>  statement,  possibly  specialized  for  different   APIs.    Supported   variables:
                 <b>YYLESSTHAN</b>,  <b>YYCURSOR</b>,  <b>YYLIMIT</b>, <b>yyrecord</b> (map to the corresponding <b>re2c:</b> configurations), <b>need</b>
                 (the number of code units to check against). Conditional: <b>.many</b> (true if the <b>need</b> is more  than
                 one).

          <b>code:yybm_filter</b>
                 Condition  that  is used to filter out <b>yych</b> values that are not covered by the <b>yybm</b> table (used
                 with <b>--bitmaps</b> option).  Supported variable: <b>yych</b> (maps to <b>re2c:yych</b> configuration).

          <b>code:yybm_match</b>
                 The format of <b>yybm</b> table check (generated with <b>--bitmaps</b> option).  Supported  variables:  <b>yybm</b>,
                 <b>yych</b>  (map  to  the  corresponding <b>re2c:</b> configurations), <b>offset</b> (offset in the <b>yybm</b> table that
                 needs to be added to <b>yych</b>) and <b>mask</b> (bit mask that should be applied  to  the  table  entry  to
                 retrieve the boolean value that needs to be checked)

          Here's a list of all global variables that are allowed in syntax files:

          <b>nl</b>     A newline.

          <b>indent</b> A  variable  that  does  not  produce any code, but has a side-effect of increasing indentation
                 level.

          <b>dedent</b> A variable that does not produce any code, but has  a  side-effect  of  decreasing  indentation
                 level.

          <b>topindent</b>
                 Indentation  string  for  the current statement. Indentation level is tracked and automatically
                 updated by the code generator.

          Here's a list of all global conditionals that are allowed in syntax files:

          <b>.api.simple</b>
                 True if simple API is used (<b>--api</b> <b>simple</b> or <b>re2c:api</b> <b>=</b> <b>simple</b>).

          <b>.api.generic</b>
                 True if generic API is used (<b>--api</b> <b>generic</b> or <b>re2c:api</b> <b>=</b> <b>generic</b>).

          <b>.api.record</b>
                 True if record API is used (<b>--api</b> <b>record</b> or <b>re2c:api</b> <b>=</b> <b>record</b>).

          <b>.api_style.functions</b>
                 True if function-like API style is used (<b>re2c:api-style</b> <b>=</b> <b>functions</b>).

          <b>.api_style.freeform</b>
                 True if free-form API style is used (<b>re2c:api-style</b> <b>=</b> <b>free-form</b>).

          <b>.case_ranges</b>
                 True if case ranges feature is enabled (<b>--case-ranges</b> or <b>re2c:case-ranges</b> <b>=</b> <b>1</b>).

          <b>.code_model.goto_label</b>
                 True if  code model based on goto/label is used (<b>--goto-label</b>).

          <b>.code_model.loop_switch</b>
                 True if code model based on loop/switch is used (<b>--loop-switch</b>).

          <b>.code_model.recursive_functions</b>
                 True if code model based on recursive functions is used (<b>--recursive-function</b>).

          <b>.date</b>  True if the generated fingerprint should contain generation date.

          <b>.loop_label</b>
                 True if re2d generated loops must have a label (<b>re2c:label:yyloop</b> is set to a nonempty string).

          <b>.monadic</b>
                 True if the generated code should be monadic (<b>re2c:monadic</b> <b>=</b> <b>1</b>).  This  is  only  relevant  for
                 pure functional languages.

          <b>.start_conditions</b>
                 True if start conditions are enabled (<b>--start-conditions</b>).

          <b>.storable_state</b>
                 True if storable state is enabled (<b>--storable-state</b>).

          <b>.unsafe</b>
                 True if re2d should use "unsafe" blocks in order to generate faster code (<b>--unsafe</b>, <b>re2c:unsafe</b>
                 <b>=</b> <b>1</b>). This is only relevant for languages that have "unsafe" feature.

          <b>.version</b>
                 True if the generated fingerprint should contain re2d version.

</pre><h4><b>HANDLING</b> <b>THE</b> <b>END</b> <b>OF</b> <b>INPUT</b></h4><pre>
       One of the main problems for the lexer is to know when to stop.  There are a few terminating conditions:

       • the lexer may match some rule (including default rule <b>*</b>) and come to a final state

       • the lexer may fail to match any rule and come to a default state

       • the lexer may reach the end of input

       The  first  two  conditions  terminate the lexer in a "natural" way: it comes to a state with no outgoing
       transitions, and the matching automatically stops. The third condition, end of input,  is  different:  it
       may  happen  in  any  state,  and  the  lexer  should be able to handle it. Checking for the end of input
       interrupts the normal lexer workflow and adds conditional branches to the generated program, therefore it
       is necessary to minimize the number of such checks. re2d supports a few different  methods  for  handling
       the  end  of  input.  Which  one  to  use  depends on the complexity of regular expressions, the need for
       buffering, performance considerations and other factors. Here is a list of methods:

       • <b>Sentinel.</b>  This method eliminates the need for the end of input checks altogether.  It  is  simple  and
         efficient, but limited to the case when there is a natural "sentinel" character that can never occur in
         valid  input.  This  character  may  still  occur in invalid input, but it should not be allowed by the
         regular expressions, except perhaps as the last character of a rule. The sentinel is  appended  at  the
         end  of  input  and serves as a stop signal: when the lexer reads this character, it is either a syntax
         error or the end of input. In both cases the lexer should stop.  This  method  is  used  if  <b>YYFILL</b>  is
         disabled with <b>re2c:yyfill:enable</b> <b>=</b> <b>0;</b> and <b>re2c:eof</b> has the default value <b>-1</b>.

       • <b>Sentinel</b>  <b>with</b>  <b>bounds</b>  <b>checks.</b>   This  method  is  generic:  it allows one to handle any input without
         restrictions on the regular expressions. The idea is to reduce the number of end  of  input  checks  by
         performing  them only on certain characters. Similar to the "sentinel" method, one of the characters is
         chosen as a "sentinel" and appended at the end of input. However, there is no restriction on where  the
         sentinel  may  occur  (in fact, any character can be chosen for a sentinel).  When the lexer reads this
         character, it additionally performs a bounds check.  If the current  position  is  within  bounds,  the
         lexer  resumes  matching  and  handles the sentinel as a regular character. Otherwise it invokes <b>YYFILL</b>
         (unless it is disabled). If more input is supplied, the lexer  will  rematch  the  last  character  and
         continue  as  if  the  sentinel wasn't there. Otherwise it must be the real end of input, and the lexer
         stops. This method is used when <b>re2c:eof</b> has non-negative value (it should be set to the numeric  value
         of the sentinel). <b>YYFILL</b> is optional.

       • <b>Bounds</b>  <b>checks</b>  <b>with</b>  <b>padding.</b>   This  method  is generic, and it may be faster than the "sentinel with
         bounds checks" method, but it is also more complex. The idea is to partition DFA states  into  strongly
         connected  components  (SCCs)  and  generate  a single check per SCC for enough characters to cover the
         longest non-looping path in this SCC. This reduces the number of checks, but there is  a  problem  with
         short lexemes at the end of input, as the check requires enough characters to cover the longest lexeme.
         This  can  be  fixed  by  padding  the input with a few fake characters that do not form a valid lexeme
         suffix (so that the lexer cannot match them). The length of padding should be <b>YYMAXFILL</b>, generated with
         a <b>max</b> block. If there is not enough input, the lexer invokes <b>YYFILL</b> which should supply  at  least  the
         required  number of characters or not return.  This method is used if <b>YYFILL</b> is enabled and <b>re2c:eof</b> is
         <b>-1</b> (this is the default configuration).

       • <b>Custom</b> <b>checks.</b>  Generic API allows one to override basic operations like  reading  a  character,  which
         makes it possible to include the end-of-input checks as part of them.  This approach is error-prone and
         should be used with caution. To use a custom method, enable generic API with <b>--api</b> <b>custom</b> or <b>re2c:api</b> <b>=</b>
         <b>custom;</b> and disable default bounds checks with <b>re2c:yyfill:enable</b> <b>=</b> <b>0;</b> or <b>re2c:yyfill:check</b> <b>=</b> <b>0;</b>.

       The following subsections contain an example of each method.

   <b>Sentinel</b>
       This  example  uses  a  sentinel character to handle the end of input. The program counts space-separated
       words in a null-terminated string. The sentinel is null: it is the last character of each  input  string,
       and it is not allowed in the middle of a lexeme by any of the rules (in particular, it is not included in
       character  ranges  where  it  is  easy  to overlook). If a null occurs in the middle of a string, it is a
       syntax error and the lexer will match default rule <b>*</b>, but it won't read past the end of  input  or  crash
       (use -Wsentinel-in-midrule &lt;https://re2c.org/manual/basics/warnings/warnings.html#wsentinel-in-midrule&gt;

       warning and <b>re2c:sentinel</b> configuration to verify this). Configuration <b>re2c:yyfill:enable</b> <b>=</b> <b>0;</b> suppresses
       the generation of bounds checks and <b>YYFILL</b> invocations.

          // re2d $INPUT -o $OUTPUT
          module main;

          // Expect a null-terminated string.
          private int lex(const(char)* yycursor) {
              uint count = 0;

              for (;;) {
              /*!re2c
                  re2c:YYCTYPE = char;
                  re2c:yyfill:enable = 0;

                  *      { return -1; }
                  [\x00] { return count; }
                  [a-z]+ { ++count; continue; }
                  [ ]+   { continue; }
              */
              }
              <a href="../man0/assert.0.html">assert</a>(0); // unreachable
          }

          void main() {
              assert(lex("") == 0);
              assert(lex("one two three") == 3);
              assert(lex("f0ur") == -1);
          }

   <b>Sentinel</b> <b>with</b> <b>bounds</b> <b>checks</b>
       This  example  uses  sentinel  with  bounds  checks  to handle the end of input (this method was added in
       version 1.2). The program counts space-separated single-quoted strings. The sentinel character  is  null,
       which  is  specified  with  <b>re2c:eof</b>  <b>=</b>  <b>0;</b>  configuration.  As  in the sentinel method, null is the last
       character of each input string, but it is allowed in the middle of a rule (for  example,  <b>'aaa\0aa'\0</b>  is
       valid  input,  but  <b>'aaa\0</b> is a syntax error).  Bounds checks are generated in each state that matches an
       input character, but they are scoped to the branch that handles null.  Bounds  checks  are  of  the  form
       <b>YYLIMIT</b>  <b>&lt;=</b> <b>YYCURSOR</b> or <b><a href="../man1/YYLESSTHAN.1.html">YYLESSTHAN</a>(1)</b> with generic API. If the check condition is true, lexer has reached
       the end of input and should stop (<b>YYFILL</b> is disabled with <b>re2c:yyfill:enable</b> <b>=</b> <b>0;</b> as the input fits  into
       one  buffer,  see  the YYFILL with sentinel section for an example that uses <b>YYFILL</b>). Reaching the end of
       input opens three possibilities: if the lexer is in the initial state it will match the end-of-input rule
       <b>$</b>, otherwise it may fallback to a previously matched rule (including default rule <b>*</b>) or go to  a  default
       state,                                  causing                                  -Wundefined-control-flow
       &lt;https://re2c.org/manual/basics/warnings/warnings.html#wundefined-control-flow&gt; .

          // re2d $INPUT -o $OUTPUT
          module main;

          // Expect a null-terminated string.
          private int lex(immutable char[] s) {
              const(char)* yycursor = s.ptr, yylimit = s.ptr + s.length, yymarker;
              int count = 0;

              for (;;) {
              /*!re2c
                  re2c:YYCTYPE = char;
                  re2c:yyfill:enable = 0;
                  re2c:eof = 0;

                  str = ['] ([^'\\] | [\\][^])* ['];

                  *    { return -1; }
                  $    { return count; }
                  str  { ++count; continue; }
                  [ ]+ { continue; }
              */
              }
              <a href="../man0/assert.0.html">assert</a>(0); // unreachable
          }

          void main() {
              assert(lex("") == 0);
              assert(lex("'qu\0tes' 'are' 'fine: \\'' ") == 3);
              assert(lex("'unterminated\\'") == -1);
          }

   <b>Bounds</b> <b>checks</b> <b>with</b> <b>padding</b>
       This example uses bounds checks with padding to handle the end  of  input  (this  method  is  enabled  by
       default).  The program counts space-separated single-quoted strings. There is a padding of <b>YYMAXFILL</b> null
       characters appended at the end of input, where <b>YYMAXFILL</b> value is autogenerated with a <b>max</b> block.  It  is
       not  necessary to use null for padding --- any characters can be used as long as they do not form a valid
       lexeme suffix (in this example padding should not contain single quotes, as they may be  mistaken  for  a
       suffix of a single-quoted string). There is a "stop" rule that matches the first padding character (null)
       and  terminates  the lexer (note that it checks if null is at the beginning of padding, otherwise it is a
       syntax error). Bounds checks are generated only in some  states  that  are  determined  by  the  strongly
       connected  components  of  the  underlying  automaton.  Checks  have the form <b>(YYLIMIT</b> <b>-</b> <b>YYCURSOR)</b> <b>&lt;</b> <b>n</b> or
       <b>YYLESSTHAN(n)</b> with generic API, where <b>n</b> is the minimum number of characters that are needed for the lexer
       to proceed (it also means that the next bounds check will occur in at most <b>n</b> characters).  If  the  check
       condition  is  true,  the lexer has reached the end of input and will invoke <b>YYFILL(n)</b> that should either
       supply at least <b>n</b> input characters or not return. In this example <b>YYFILL</b> always fails and terminates  the
       lexer  with  an error (which is fine because the input fits into one buffer). See the YYFILL with padding
       section for an example that refills the input buffer with <b>YYFILL</b>.

          // re2d $INPUT -o $OUTPUT
          module main;

          import core.stdc.stdlib;
          import core.stdc.string;

          /*!max:re2c*/

          private int lex(immutable char[] s) {
              // Make a copy of the string with YYMAXFILL zeroes at the end.
              char *buf = cast(char*) malloc(s.length + YYMaxFill);
              memcpy(buf, cast(const(void*)) s, s.length);
              memset(buf + s.length, 0, YYMaxFill);

              const(char)* yycursor = buf;
              const(char)* yylimit = buf + s.length + YYMaxFill;
              int count = 0;

          loop:
              /*!re2c
                  re2c:YYCTYPE = char;
                  re2c:YYFILL = "goto fail;";

                  str = ['] ([^'\\] | [\\][^])* ['];

                  [\x00] {
                      // Check that it is the sentinel, not some unexpected null.
                      if (yycursor - 1 == buf + s.length) goto exit; else goto fail;
                  }
                  str  { ++count; goto loop; }
                  [ ]+ { goto loop; }
                  *    { goto fail; }
              */
          fail:
              count = -1;
          exit:
              free(buf);
              return count;
          }

          void main() {
              assert(lex("") == 0);
              assert(lex("'qu\0tes' 'are' 'fine: \\'' ") == 3);
              assert(lex("'unterminated\\'") == -1);
              assert(lex("'unexpected \0 null\\'") == -1);
          }

   <b>Custom</b> <b>checks</b>
       This example uses a custom end-of-input handling  method  based  on  generic  API.   The  program  counts
       space-separated  single-quoted  strings. It is the same as the sentinel example, except that the input is
       not null-terminated. To cover up for the absence of a sentinel character at the end of input,  <b>YYPEEK</b>  is
       redefined  to  perform  a  bounds  check  before  it reads the next input character.  This is inefficient
       because checks are done very often. If the check condition fails,  <b>YYPEEK</b>  returns  the  real  character,
       otherwise it returns a fake sentinel character.

          // re2d $INPUT -o $OUTPUT
          module main;

          import core.stdc.stdlib;
          import core.stdc.string;

          private int lex(immutable char[] s) {
              // For the sake of example create a string without terminating null.
              char *buf = cast(char*) malloc(s.length);
              memcpy(buf, cast(const(void*)) s, s.length);

              const(char) *cur = buf, lim = buf + s.length;
              int count = 0;

              for (;;) {
              /*!re2c
                  re2c:api = generic;
                  re2c:yyfill:enable = 0;
                  re2c:YYCTYPE = char;
                  re2c:YYPEEK = "cur &lt; lim ? *cur : 0";  // fake null
                  re2c:YYSKIP = "++cur;";

                  *      { count = -1; break; }
                  [\x00] { break;{} }
                  [a-z]+ { ++count; continue;{} }
                  [ ]+   { continue; }
              */
              }

              free(buf);
              return count;
          }

          void main() {
              assert(lex("") == 0);
              assert(lex("one two three ") == 3);
              assert(lex("f0ur") == -1);
          }

</pre><h4><b>BUFFER</b> <b>REFILLING</b></h4><pre>
       The  need  for  buffering  arises when the input cannot be mapped in memory all at once: either it is too
       large, or it comes in a streaming fashion (like reading from a socket). The usual technique in such cases
       is to allocate a fixed-sized memory buffer and process input in chunks that fit into the buffer. When the
       current chunk is processed, it is moved out and new data is moved in. In practice  it  is  somewhat  more
       complex,  because  lexer  state  consists  not  of  a  single  input  position, but a set of interrelated
       positions:

       • cursor: the next input character to be read (<b>YYCURSOR</b> in C pointer API or <b>YYSKIP</b>/<b>YYPEEK</b> in generic API)

       • limit: the position after the last available input character (<b>YYLIMIT</b>  in  C  pointer  API,  implicitly
         handled by <b>YYLESSTHAN</b> in generic API)

       • marker: the position of the most recent match, if any (<b>YYMARKER</b> in default API or <b>YYBACKUP</b>/<b>YYRESTORE</b> in
         generic API)

       • token:  the start of the current lexeme (implicit in re2d API, as it is not needed for the normal lexer
         operation and can be defined and updated by the user)

       • context  marker:  the  position  of  the  trailing  context  (<b>YYCTXMARKER</b>   in   C   pointer   API   or
         <b>YYBACKUPCTX</b>/<b>YYRESTORECTX</b> in generic API)

       • tag  variables:  submatch  positions  (defined  with  <b>stags</b> and <b>mtags</b> blocks and generic API primitives
         <b>YYSTAGP</b>/<b>YYSTAGN</b>/<b>YYMTAGP</b>/<b>YYMTAGN</b>)

       Not all these are used in every case, but if used, they must be updated by <b>YYFILL</b>. All  active  positions
       are  contained  in  the  segment  between token and cursor, therefore everything between buffer start and
       token can be discarded, the segment from token and up to limit  should  be  moved  to  the  beginning  of
       buffer,  and  the  free  space  at  the  end of buffer should be filled with new data.  In order to avoid
       frequent <b>YYFILL</b> calls it is best to fill in as many input  characters  as  possible  (even  though  fewer
       characters  might  suffice  to  resume  the  lexer).  The  details  of <b>YYFILL</b> implementation are slightly
       different depending on which EOF handling method is used: the case of EOF rule is somewhat  simpler  than
       the  case  of  bounds-checking with padding. Also note that if <b>-f</b> <b>--storable-state</b> option is used, <b>YYFILL</b>
       has slightly different semantics (described in the section about storable state).

   <b>YYFILL</b> <b>with</b> <b>sentinel</b>
       If EOF rule is used, <b>YYFILL</b> is a function-like primitive that accepts no arguments and  returns  a  value
       which  is  checked  against  zero.  <b>YYFILL</b>  invocation is triggered by condition <b>YYLIMIT</b> <b>&lt;=</b> <b>YYCURSOR</b> in C
       pointer API and <b>YYLESSTHAN()</b> in generic API. A non-zero return value means  that  <b>YYFILL</b>  has  failed.  A
       successful  <b>YYFILL</b>  call must supply at least one character and adjust input positions accordingly. Limit
       must always be set to one after the last input position  in  buffer,  and  the  character  at  the  limit
       position  must  be  the  sentinel symbol specified by <b>re2c:eof</b> configuration. The pictures below show the
       relative locations of input positions in buffer before and after <b>YYFILL</b> call (sentinel symbol  is  marked
       with <b>#</b>, and the second picture shows the case when there is not enough input to fill the whole buffer).

                         &lt;-- shift --&gt;
                       &gt;-A------------B---------C-------------D#-----------E-&gt;
                       buffer       token    marker         limit,
                                                            cursor
          &gt;-A------------B---------C-------------D------------E#-&gt;
                       buffer,  marker        cursor        limit
                       token

                         &lt;-- shift --&gt;
                       &gt;-A------------B---------C-------------D#--E (EOF)
                       buffer       token    marker         limit,
                                                            cursor
          &gt;-A------------B---------C-------------D---E#........
                       buffer,  marker       cursor limit
                       token

       Here  is  an  example  of  a program that reads input file <b>input.txt</b> in chunks of 4096 bytes and uses EOF
       rule.

          // re2d $INPUT -o $OUTPUT
          module main;

          import core.stdc.string;
          import core.stdc.stdio;

          enum BUFSIZE = 4095;

          struct Input {
              FILE* file;
              char[BUFSIZE + 1] buffer;// +1 for sentinel
              char* yylimit, yycursor, yymarker, token;
              bool eof;
          };

          private int fill(ref Input it) {
              if (it.eof) return 1;

              const size_t shift = it.token - it.buffer.ptr;
              const size_t used = it.yylimit - it.token;

              // Error: lexeme too long. In real life could reallocate a larger buffer.
              if (shift &lt; 1) return 2;

              // Shift buffer contents (discard everything up to the current token).
              memmove(cast(void*)it.buffer.ptr, it.token, used);
              it.yylimit -= shift;
              it.yycursor -= shift;
              it.yymarker -= shift;
              it.token -= shift;

              // Fill free space at the end of buffer with new data from file.
              it.yylimit += fread(it.yylimit, 1, BUFSIZE - used, it.file);
              it.yylimit[0] = 0;
              it.eof = it.yylimit &lt; (it.buffer.ptr + BUFSIZE);
              return 0;
          }

          private int lex(ref Input yyrecord) {
              int count = 0;
              for (;;) {
                  yyrecord.token = yyrecord.yycursor;
              /*!re2c
                  re2c:api = record;
                  re2c:YYCTYPE = "char";
                  re2c:YYFILL = "fill(yyrecord) == 0";
                  re2c:eof = 0;

                  str = ['] ([^'\\] | [\\][^])* ['];

                  *    { return -1; }
                  $    { return count; }
                  str  { ++count; continue; }
                  [ ]+ { continue; }
              */
              }
              <a href="../man0/assert.0.html">assert</a>(0);
          }

          void main() {
              const char[] fname = "input";
              const char[] content = "'qu\0tes' 'are' 'fine: \\'' ";

              // Prepare input file: a few times the size of the buffer, containing
              // strings with zeroes and escaped quotes.
              FILE* f = fopen(fname.ptr, "w");
              for (int i = 0; i &lt; BUFSIZE; ++i) {
                  fwrite(cast(const(void*)) content.ptr, 1, content.length - 1, f);
              }
              fclose(f);
              int count = 3 * BUFSIZE; // number of quoted strings written to file

              // Initialize lexer state: all pointers are at the end of buffer.
              Input it;
              it.file = fopen(fname.ptr, "r");
              it.yycursor = it.yymarker = it.token = it.yylimit = it.buffer.ptr + BUFSIZE;
              it.eof = 0;
              // Sentinel (at YYLIMIT pointer) is set to zero, which triggers YYFILL.
              it.yylimit[0] = 0;

              // Run the lexer.
              assert(lex(it) == count);

              // Cleanup: remove input file.
              fclose(it.file);
              remove(fname.ptr);
          }

   <b>YYFILL</b> <b>with</b> <b>padding</b>
       In the default case (when EOF rule is not used) <b>YYFILL</b> is a function-like primitive that accepts a single
       argument and does not return any value.  <b>YYFILL</b> invocation is triggered by condition <b>(YYLIMIT</b> <b>-</b> <b>YYCURSOR)</b>
       <b>&lt;</b> <b>n</b> in C pointer API and <b>YYLESSTHAN(n)</b> in generic API. The argument  passed  to  <b>YYFILL</b>  is  the  minimal
       number  of  characters  that  must be supplied. If it fails to do so, <b>YYFILL</b> must not return to the lexer
       (for that reason it is best implemented as a macro that returns from the calling  function  on  failure).
       In  case  of  a  successful <b>YYFILL</b> invocation the limit position must be set either to one after the last
       input position in buffer, or to the end of <b>YYMAXFILL</b> padding (in case <b>YYFILL</b>  has  successfully  read  at
       least  <b>n</b>  characters,  but  not  enough  to fill the entire buffer). The pictures below show the relative
       locations of input positions in buffer before and after  <b>YYFILL</b>  invocation  (<b>YYMAXFILL</b>  padding  on  the
       second picture is marked with <b>#</b> symbols).

                         &lt;-- shift --&gt;                 &lt;-- need --&gt;
                       &gt;-A------------B---------C-----D-------E---F--------G-&gt;
                       buffer       token    marker cursor  limit

          &gt;-A------------B---------C-----D-------E---F--------G-&gt;
                       buffer,  marker cursor               limit
                       token

                         &lt;-- shift --&gt;                 &lt;-- need --&gt;
                       &gt;-A------------B---------C-----D-------E-F        (EOF)
                       buffer       token    marker cursor  limit

          &gt;-A------------B---------C-----D-------E-F###############
                       buffer,  marker cursor                   limit
                       token                        &lt;- YYMAXFILL -&gt;

       Here  is  an  example  of  a  program  that  reads  input file <b>input.txt</b> in chunks of 4096 bytes and uses
       bounds-checking with padding.

          // re2d $INPUT -o $OUTPUT
          module main;

          import core.stdc.string;
          import core.stdc.stdio;

          /*!max:re2c*/
          enum BufSize = (4096 - YYMaxFill);

          struct Input {
              FILE* file;
              char[BufSize + YYMaxFill] buffer;
              char* yylimit, yycursor, token;
              bool eof;
          };

          private int fill(ref Input it, size_t need) {
              if (it.eof) return 1;

              const size_t shift = it.token - it.buffer.ptr;
              const size_t used = it.yylimit - it.token;

              // Error: lexeme too long. In real life could reallocate a larger buffer.
              if (shift &lt; need) return 2;

              // Shift buffer contents (discard everything up to the current token).
              memmove(it.buffer.ptr, it.token, used);
              it.yylimit -= shift;
              it.yycursor -= shift;
              it.token -= shift;

              // Fill free space at the end of buffer with new data from file.
              it.yylimit += fread(it.yylimit, 1, BufSize - used, it.file);

              // If read less than expected, this is end of input =&gt; add zero padding
              // so that the lexer can access characters at the end of buffer.
              if (it.yylimit &lt; it.buffer.ptr + BufSize) {
                  it.eof = true;
                  memset(it.yylimit, 0, YYMaxFill);
                  it.yylimit += YYMaxFill;
              }

              return 0;
          }

          private int lex(ref Input yyrecord) {
              int count = 0;
              for (;;) {
                  yyrecord.token = yyrecord.yycursor;
              /*!re2c
                  re2c:api = record;
                  re2c:YYCTYPE = "char";
                  re2c:YYFILL = "if (fill(yyrecord, @@) != 0) return -1;";

                  str = ['] ([^'\\] | [\\][^])* ['];

                  [\x00] {
                      // Check that it is the sentinel, not some unexpected null.
                      return yyrecord.token == yyrecord.yylimit - YYMaxFill ? count : -1;
                  }
                  str  { ++count; continue; }
                  [ ]+ { continue; }
                  *    { return -1; }
              */
              }
              <a href="../man0/assert.0.html">assert</a>(0);
          }

          void main() {
              const char[] fname = "input";
              const char[] content = "'qu\0tes' 'are' 'fine: \\'' ";

              // Prepare input file: a few times the size of the buffer, containing
              // strings with zeroes and escaped quotes.
              FILE* f = fopen(fname.ptr, "w");
              for (int i = 0; i &lt; BufSize; ++i) {
                  fwrite(content.ptr, 1, content.length - 1, f);
              }
              fclose(f);
              int count = 3 * BufSize; // number of quoted strings written to file

              // Initialize lexer state: all pointers are at the end of buffer.
              // This immediately triggers YYFILL, as the check `it.yycursor &lt; it.yylimit` fails.
              Input it;
              it.file = fopen(fname.ptr, "r");
              it.yycursor = it.token = it.yylimit = it.buffer.ptr + BufSize;
              it.eof = 0;

              // Run the lexer.
              assert(lex(it) == count);

              // Cleanup: remove input file.
              fclose(it.file);
              remove(fname.ptr);
          }

</pre><h4><b>FEATURES</b></h4><pre>
   <b>Multiple</b> <b>blocks</b>
       Sometimes it is necessary to have multiple interrelated lexers (for example, if  there  is  a  high-level
       state  machine  that  transitions  between lexer modes). This can be implemented using multiple connected
       re2d blocks. Another option is to use start conditions.

       The implementation of connections between blocks depends on the target language.  In languages that  have
       <b>goto</b> statement (such as C/C++ and Go) one can have all blocks in one function, each of them prefixed with
       a label. Transition from one block to another is a simple <b>goto</b>.  In languages that do not have <b>goto</b> (such
       as  Rust)  it  is  necessary  to  use  a  loop  with a switch on a state variable, similar to the <b>yystate</b>
       loop/switch generated by re2d, or else wrap each block in a function and use function calls.

       The example below uses multiple blocks to parse binary, octal, decimal and hexadecimal numbers. Each base
       has  its  own  block.  The  initial  block  determines  base  and  dispatches  to  other  blocks.  Common
       configurations are defined in a separate block at the beginning of the program; they are inherited by the
       other blocks.

          // re2d $INPUT -o $OUTPUT -i
          module main;

          enum ERROR = ulong.max;

          private void add(ulong BASE)(ref ulong u, int d) {
              u = u * BASE + d;
              if (u &gt; uint.max) { u = ERROR; }
          }

          private ulong parse_u32(const(char)* s) {
              const(char)* yycursor = s, yymarker;
              ulong u = 0;

              /*!re2c
                  re2c:yyfill:enable = 0;
                  re2c:YYCTYPE = char;

                  end = "\x00";

                  '0b' / [01]        { goto bin; }
                  "0"                { goto oct; }
                  "" / [1-9]         { goto dec; }
                  '0x' / [0-9a-fA-F] { goto hex; }
                  *                  { return ERROR; }
              */
          bin:
              /*!re2c
                  end   { return u; }
                  [01]  { add!(2)(u, yycursor[-1] - '0'); goto bin; }
                  *     { return ERROR; }
              */
          oct:
              /*!re2c
                  end   { return u; }
                  [0-7] { add!(8)(u, yycursor[-1] - '0'); goto oct; }
                  *     { return ERROR; }
              */
          dec:
              /*!re2c
                  end   { return u; }
                  [0-9] { add!(10)(u, yycursor[-1] - '0'); goto dec; }
                  *     { return ERROR; }
              */
          hex:
              /*!re2c
                  end   { return u; }
                  [0-9] { add!(16)(u, yycursor[-1] - '0');      goto hex; }
                  [a-f] { add!(16)(u, yycursor[-1] - 'a' + 10); goto hex; }
                  [A-F] { add!(16)(u, yycursor[-1] - 'A' + 10); goto hex; }
                  *     { return ERROR; }
              */
          }

          void main() {
              assert(parse_u32("") == ERROR);
              assert(parse_u32("1234567890") == 1234567890);
              assert(parse_u32("0b1101") == 13);
              assert(parse_u32("0x7Fe") == 2046);
              assert(parse_u32("0644") == 420);
              assert(parse_u32("9999999999") == ERROR);
          }

   <b>Start</b> <b>conditions</b>
       Start  conditions  are  enabled  with  <b>--start-conditions</b>  option.  They provide a way to encode multiple
       interrelated automata within the same re2d block.

       Each condition corresponds to a single automaton and has a unique name specified by the user and a unique
       internal number defined by re2d. The numbers are used to switch between conditions:  the  generated  code
       uses  <b>YYGETCOND</b>  and <b>YYSETCOND</b> primitives to get the current condition or set it to the given number. Use
       <b>conditions</b> block, <b>--header</b> option or <b>re2c:header</b> configuration to generate numeric condition identifiers.
       Configuration <b>re2c:cond:enumprefix</b> specifies the generated identifier prefix.

       In condition mode every rule must be prefixed with a list of comma-separated  condition  names  in  angle
       brackets, or a wildcard <b>&lt;*&gt;</b> to denote all conditions. The rule syntax is extended as follows:

          <b>&lt;</b> <b>condition-list</b> <b>&gt;</b> <b>regular-expression</b> <b>code</b>
                 A  rule that is merged to every condition on the <b>condition-list</b>.  It matches <b>regular-expression</b>
                 and executes the associated <b>code</b>.

          <b>&lt;</b> <b>condition-list</b> <b>&gt;</b> <b>regular-expression</b> <b>=&gt;</b> <b>condition</b> <b>code</b>
                 A rule that is merged to every condition on the <b>condition-list</b>.  It matches <b>regular-expression</b>,
                 sets the current condition to <b>condition</b> and executes the associated <b>code</b>.

          <b>&lt;</b> <b>condition-list</b> <b>&gt;</b> <b>regular-expression</b> <b>:=&gt;</b> <b>condition</b>
                 A rule that is merged to every condition on the <b>condition-list</b>.  It matches  <b>regular-expression</b>
                 and immediately transitions to <b>condition</b> (there is no semantic action).

          <b>&lt;</b> <b>condition-list</b> <b>&gt;</b> <b>!action</b> <b>code</b>
                 A  rule that binds <b>code</b> to the place defined by <b>action</b> in every condition on the <b>condition-list</b>
                 (see the actions section for various types of actions).

          <b>&lt;!</b> <b>condition-list</b> <b>&gt;</b> <b>code</b>
                 A rule that prepends <b>code</b> to  semantic  actions  of  all  rules  for  every  condition  on  the
                 <b>condition-list</b>.  This  syntax is deprecated and the <b>!pre_rule</b> action should be used instead (it
                 does exactly the same).

          <b>&lt;</b> <b>&gt;</b> <b>code</b>
                 A rule that creates a special entry condition with number zero and name <b>"0"</b> that executes  <b>code</b>
                 before jumping to other conditions.  This syntax is deprecated, and the <b>!entry</b> action should be
                 used  instead  (it  provides  a  more  fine-grained  control, as the code can be specified on a
                 per-condition basis, and one can  jump  directly  to  condition  start  without  going  through
                 condition dispatch).

          <b>&lt;</b> <b>&gt;</b> <b>=&gt;</b> <b>condition</b> <b>code</b>
                 Same as the previous rule, except that it sets the next <b>condition</b>.

          <b>&lt;</b> <b>&gt;</b> <b>:=&gt;</b> <b>condition</b>
                 Same  as  the  previous  rule,  except  that it has no associated code and immediately jumps to
                 <b>condition</b>.

       The code re2d generates for conditions depends on whether re2d uses goto/label  approach  or  loop/switch
       approach to encode the automata.

       In  languages  that  have  <b>goto</b>  statement (such as C/C++ and Go) conditions are naturally implemented as
       blocks of code prefixed with labels of the form <b>yyc_&lt;cond&gt;</b>, where <b>cond</b> is a condition name (label  prefix
       can  be  changed  with  <b>re2c:cond:prefix</b>).  Transitions between conditions are implemented using <b>goto</b> and
       condition labels. Before all conditions re2d generates an initial switch on <b>YYGETSTATE</b> that jumps to  the
       start state of the current condition.  The shortcut rules <b>:=&gt;</b> bypass the initial switch and jump directly
       to  the  specified  condition (<b>re2c:cond:goto</b> can be used to change the default behavior). The rules with
       semantic actions do not automatically jump to the next condition; this should be done by the user-defined
       action code.

       In languages that do not have <b>goto</b> (such as Rust) re2d reuses the <b>yystate</b>  variable  to  store  condition
       numbers.  Each  condition  gets a numeric identifier equal to the number of its start state, and a switch
       between conditions is no different than a switch between DFA states of a single condition.  There  is  no
       need  for  a  separate  initial condition switch.  (Since the same approach is used to implement storable
       states, <b>YYGETCOND</b>/<b>YYSETCOND</b> are redundant if both storable states and conditions are used).

       The program below uses start conditions to parse binary, octal, decimal and hexadecimal numbers. There is
       a single block where each base has its own condition, and the initial condition is connected  to  all  of
       them.  User-defined variable <b>cond</b> stores the current condition number; it is initialized to the number of
       the initial condition generated with <b>conditions</b> block.

          // re2d $INPUT -o $OUTPUT -ci
          module main;

          enum ERROR = ulong.max;
          /*!conditions:re2c*/

          private void add(ulong BASE)(ref ulong u, int d) {
              u = u * BASE + d;
              if (u &gt; uint.max) { u = ERROR; }
          }

          private ulong parse_u32(const(char)* s) {
              const(char)* yycursor = s, yymarker;
              YYCond yycond = YYCond.yycinit;
              ulong u = 0;

              /*!re2c
                  re2c:yyfill:enable = 0;
                  re2c:YYCTYPE = char;

                  &lt;*&gt; * { return ERROR; }
                  &lt;init&gt; '0b' / [01]        :=&gt; bin
                  &lt;init&gt; "0"                :=&gt; oct
                  &lt;init&gt; "" / [1-9]         :=&gt; dec
                  &lt;init&gt; '0x' / [0-9a-fA-F] :=&gt; hex
                  &lt;bin, oct, dec, hex&gt; "\x00" { return u; }
                  &lt;bin&gt; [01]  { add!(2)(u,  yycursor[-1] - '0');      goto yyc_bin; }
                  &lt;oct&gt; [0-7] { add!(8)(u,  yycursor[-1] - '0');      goto yyc_oct; }
                  &lt;dec&gt; [0-9] { add!(10)(u, yycursor[-1] - '0');      goto yyc_dec; }
                  &lt;hex&gt; [0-9] { add!(16)(u, yycursor[-1] - '0');      goto yyc_hex; }
                  &lt;hex&gt; [a-f] { add!(16)(u, yycursor[-1] - 'a' + 10); goto yyc_hex; }
                  &lt;hex&gt; [A-F] { add!(16)(u, yycursor[-1] - 'A' + 10); goto yyc_hex; }
              */
          }

          void main() {
              assert(parse_u32("") == ERROR);
              assert(parse_u32("1234567890") == 1234567890);
              assert(parse_u32("0b1101") == 13);
              assert(parse_u32("0x7Fe") == 2046);
              assert(parse_u32("0644") == 420);
              assert(parse_u32("9999999999") == ERROR);
          }

   <b>Storable</b> <b>state</b>
       With <b>--storable-state</b> option re2d generates a lexer that can store  its  current  state,  return  to  the
       caller, and later resume operations exactly where it left off. The default mode of operation in re2d is a
       "pull"  model,  in  which  the lexer "pulls" more input whenever it needs it. This may be unacceptable in
       cases when the input becomes available piece by piece (for example,  if  the  lexer  is  invoked  by  the
       parser, or if the lexer program communicates via a socket protocol with some other program that must wait
       for  a  reply  from  the  lexer before it transmits the next message). Storable state feature is intended
       exactly for such cases: it allows one to generate lexers that work in a  "push"  model.  When  the  lexer
       needs  more  input,  it  stores  its  state  and  returns  to  the caller. Later, when more input becomes
       available, the caller resumes the lexer exactly where it stopped.  There  are  a  few  changes  necessary
       compared to the "pull" model:

       • Define <b>YYSETSTATE()</b> and <b>YYGETSTATE(state)</b> primitives.

       • Define  <b>yych</b>,  <b>yyaccept</b>  (if  used)  and <b>state</b> variables as a part of persistent lexer state. The <b>state</b>
         variable should be initialized to <b>-1</b>.

       • <b>YYFILL</b> should return to the outer program instead of trying to supply more input.  Return  code  should
         indicate that lexer needs more input.

       • The outer program should recognize situations when lexer needs more input and respond appropriately.

       • Optionally  use  <b>getstate</b>  block  to generate <b>YYGETSTATE</b> switch detached from the main lexer. This only
         works for languages that have <b>goto</b> (not in <b>--loop-switch</b> mode).

       • Use <b>re2c:eof</b> and the sentinel with bounds checks method to  handle  the  end  of  input.  Padding-based
         method  may  not work because it is unclear when to append padding: the current end of input may not be
         the ultimate end of input, and appending padding too early may cut off a partially read greedy  lexeme.
         Furthermore,  due to high-level program logic getting more input may depend on processing the lexeme at
         the end of buffer (which already is blocked due to the end-of-input condition).

       Here is an example of a "push" model lexer that simulates reading packets from a socket. The lexer  loops
       until  it  encounters the end of input and returns to the calling function. The calling function provides
       more input by "sending" the next packet and resumes lexing. This process stops when all the packets  have
       been sent, or when there is an error.

          // re2d $INPUT -o $OUTPUT -f
          module main;

          import core.stdc.stdio;
          import core.stdc.string;

          // Use a small buffer to cover the case when a lexeme doesn't fit.
          // In real world use a larger buffer.
          enum BUFSIZE = 10;

          struct State {
              FILE* file;
              char[BUFSIZE + 1] buffer;
              char* yylimit, yycursor, yymarker, token;
              int yystate;
          };

          enum Status {END, READY, WAITING, BAD_PACKET, BIG_PACKET};

          private Status fill(ref State st) {
              const size_t shift = st.token - cast(char*)st.buffer;
              const size_t used = st.yylimit - st.token;
              const size_t free = BUFSIZE - used;

              // Error: no space. In real life can reallocate a larger buffer.
              if (free &lt; 1) return Status.BIG_PACKET;

              // Shift buffer contents (discard already processed data).
              memmove(cast(void*)st.buffer, st.token, used);
              st.yylimit -= shift;
              st.yycursor -= shift;
              st.yymarker -= shift;
              st.token -= shift;

              // Fill free space at the end of buffer with new data.
              const size_t read = fread(st.yylimit, 1, free, st.file);
              st.yylimit += read;
              st.yylimit[0] = 0; // append sentinel symbol

              return Status.READY;
          }

          private Status lex(ref State yyrecord, uint* recv) {
              char yych;
              /*!getstate:re2c*/

              for (;;) {
                  yyrecord.token = yyrecord.yycursor;
              /*!re2c
                  re2c:api = record;
                  re2c:YYCTYPE = char;
                  re2c:YYFILL = "return Status.WAITING;";
                  re2c:eof = 0;

                  packet = [a-z]+[;];

                  *      { return Status.BAD_PACKET; }
                  $      { return Status.END; }
                  packet { *recv = *recv + 1; continue; }
              */
              }
              <a href="../man0/assert.0.html">assert</a>(0); // unreachable
          }

          private void test(string[] packets, Status expect) {
              // Create a pipe (open the same file for reading and writing).
              const(char*) fname = "pipe";
              FILE* fw = fopen(fname, "w");
              FILE* fr = fopen(fname, "r");
              setvbuf(fw, null, _IONBF, 0);
              setvbuf(fr, null, _IONBF, 0);

              // Initialize lexer state: `state` value is -1, all pointers are at the end
              // of buffer.
              State st;
              st.file = fr;
              st.yycursor = st.yymarker = st.token = st.yylimit = cast(char*)st.buffer + BUFSIZE;
              // Sentinel (at YYLIMIT pointer) is set to zero, which triggers YYFILL.
              st.yylimit[0] = 0;
              st.yystate = -1;

              // Main loop. The buffer contains incomplete data which appears packet by
              // packet. When the lexer needs more input it saves its internal state and
              // returns to the caller which should provide more input and resume lexing.
              Status status;
              uint send = 0, recv = 0;
              for (;;) {
                  status = lex(st, &amp;recv);
                  if (status == Status.END) {
                      debug{printf("done: got %u packets\n", recv);}
                      break;
                  } else if (status == Status.WAITING) {
                      debug{printf("waiting...\n");}
                      if (send &lt; packets.length) {
                          debug{printf("sent packet %u\n", send);}
                          fprintf(fw, "%s", cast(char*)packets[send]);
                          ++send;
                      }
                      status = fill(st);
                      debug{printf("queue: '%s'\n", cast(char*)st.buffer);}
                      if (status == Status.BIG_PACKET) {
                          debug{printf("error: packet too big\n");}
                          break;
                      }
                      assert(status == Status.READY);
                  } else {
                      assert(status == Status.BAD_PACKET);
                      debug{printf("error: ill-formed packet\n");}
                      break;
                  }
              }

              // Check results.
              assert(status == expect);
              if (status == Status.END) assert(recv == send);

              // Cleanup: remove input file.
              fclose(fw);
              fclose(fr);
              remove(fname);
          }

          void main() {
              string[] packets1 = [];
              string[] packets2 = ["zero;", "one;", "two;", "three;", "four;"];
              string[] packets3 = ["zer0;"];
              string[] packets4 = ["looooooooooong;"];

              test(packets1, Status.END);
              test(packets2, Status.END);
              test(packets3, Status.BAD_PACKET);
              test(packets4, Status.BIG_PACKET);
          }

   <b>Reusable</b> <b>blocks</b>
       Reusable  blocks  of  the form <b>/*!rules:re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> or <b>%{rules[:&lt;name&gt;]</b> <b>...</b> <b>%}</b> can be reused any
       number of times and combined with other re2d blocks. The <b>&lt;name&gt;</b> is optional. A rules block can be used in
       a <b>use</b> block or directive. The code for a rules block is generated at every point of use.

       Use blocks are defined with <b>/*!use:re2c[:&lt;name&gt;]</b> <b>...</b> <b>*/</b> or <b>%{use[:&lt;name&gt;]</b> <b>...</b> <b>%}</b>. The <b>&lt;name&gt;</b> is optional:
       if it's not specified, the associated rules block is the most recent one (whether named or  unnamed).   A
       use  block can add named definitions, configurations and rules of its own.  An important use case for use
       blocks is a lexer that supports multiple input encodings: the same rules block is reused  multiple  times
       with encoding-specific configurations (see the example below).

       In-block  use  directive  <b>!use:&lt;name&gt;;</b>  can be used from inside of a re2d block. It merges the referenced
       block <b>&lt;name&gt;</b> into the current one. If some of the  merged  rules  and  configurations  overlap  with  the
       previously  defined  ones, conflicts are resolved in the usual way: the earliest rule takes priority, and
       latest configuration overrides preceding ones. One exception are the special rules <b>*</b>, <b>$</b> and (in condition
       mode) <b>&lt;!&gt;</b>, for which a block-local definition overrides any inherited ones. Use directive allows  one  to
       combine different re2d blocks together in one block (see the example below).

       Named  blocks  and  in-block  use  directive were added in re2d version 2.2.  Since that version reusable
       blocks are allowed by default (no special option is needed). Before version 2.2 reuse  mode  was  enabled
       with <b>-r</b> <b>--reusable</b> option. Before version 1.2 reusable blocks could not be mixed with normal blocks.

   <b>Example</b> <b>of</b> <b>a</b> <b>!use</b> <b>directive</b>
          // re2d $INPUT -o $OUTPUT
          module main;

          // This example shows how to combine reusable re2c blocks: two blocks
          // ('colors' and 'fish') are merged into one. The 'salmon' rule occurs
          // in both blocks; the 'fish' block takes priority because it is used
          // earlier. Default rule * occurs in all three blocks; the local (not
          // inherited) definition takes priority.

          enum What { COLOR, FISH, DUNNO };

          /*!rules:re2c:colors
              *                            { assert(false); }
              "red" | "salmon" | "magenta" { return What.COLOR; }
          */

          /*!rules:re2c:fish
              *                            { assert(false); }
              "haddock" | "salmon" | "eel" { return What.FISH; }
          */

          private What lex(const(char)* s) {
              const(char)* yycursor = s, yymarker;
              /*!re2c
                  re2c:YYCTYPE = "char";
                  re2c:yyfill:enable = 0;

                  !use:fish;
                  !use:colors;
                  * { return What.DUNNO; } // overrides inherited '*' rules
              */
          }

          void main() {
              assert(lex("salmon") == What.FISH);
              assert(lex("what?") == What.DUNNO);
          }

   <b>Example</b> <b>of</b> <b>a</b> <b>/*!use:re2c</b> <b>...</b> <b>*/</b> <b>block</b>
          // re2d $INPUT -o $OUTPUT --input-encoding utf8
          module main;

          import std.stdint;

          // This example supports multiple input encodings: UTF-8 and UTF-32.
          // Both lexers are generated from the same rules block, and the use
          // blocks add only encoding-specific configurations.
          /*!rules:re2c
              re2c:yyfill:enable = 0;

              "∀x ∃y" { return 0; }
              *       { return 1; }
          */

          private int lex_utf8(const(uint8_t)* s) {
              const(uint8_t)* yycursor = s, yymarker;
              /*!use:re2c
                  re2c:YYCTYPE = uint8_t;
                  re2c:encoding:utf8 = 1;
              */
          }

          private int lex_utf32(const(uint32_t)* s) {
              const(uint32_t)* yycursor = s, yymarker;
              /*!use:re2c
                  re2c:YYCTYPE = uint32_t;
                  re2c:encoding:utf32 = 1;
              */
          }

          void main() {
              immutable uint8_t[] s8 = // UTF-8
                  [ 0xe2, 0x88, 0x80, 0x78, 0x20, 0xe2, 0x88, 0x83, 0x79 ];

              immutable uint32_t[] s32 = // UTF32
                  [ 0x00002200, 0x00000078, 0x00000020, 0x00002203, 0x00000079 ];

              assert(lex_utf8(cast(const(uint8_t)*)s8) == 0);
              assert(lex_utf32(cast(const(uint32_t)*)s32) == 0);
          }

   <b>Submatch</b> <b>extraction</b>
       re2d has two options for submatch extraction.

       <b>Tags</b>   The  first  option  is  to use standalone <u>tags</u> of the form <b>@stag</b> or <b>#mtag</b>, where <b>stag</b> and <b>mtag</b> are
              arbitrary used-defined  names.   Tags  are  enabled  with  <b>-T</b>  <b>--tags</b>  option  or  <b>re2c:tags</b>  <b>=</b>  <b>1</b>
              configuration.  Semantically tags are position markers: they can be inserted anywhere in a regular
              expression, and they bind to the corresponding position  (or  multiple  positions)  in  the  input
              string.   <u>S-tags</u>  bind to the last matching position, and <u>m-tags</u> bind to a list of positions (they
              may be used in repetition  subexpressions,  where  a  single  position  in  a  regular  expression
              corresponds  to  multiple  positions in the input string). All tags should be defined by the user,
              either manually or with the help of <b>svars</b> and <b>mvars</b> blocks. If there is more than one way tags can
              be matched against the input, ambiguity is resolved using leftmost greedy disambiguation strategy.

       <b>Captures</b>
              The second option is to  use  <u>capturing</u>  <u>groups</u>.  They  are  enabled  with  <b>--captures</b>  option  or
              <b>re2c:captures</b>  <b>=</b>  <b>1</b>  configuration.  There are two flavours for different disambiguation policies,
              <b>--leftmost-captures</b> (the default) is for leftmost greedy  policy,  and,  <b>--posix-captures</b>  is  for
              POSIX longest-match policy. In this mode all parenthesized subexpressions are considered capturing
              groups,  and  a  bang  can  be used to mark non-capturing groups: <b>(!</b> <b>...</b> <b>)</b>. With <b>--invert-captures</b>
              option or <b>re2c:invert-captures</b> <b>=</b> <b>1</b> configuration the meaning of bang is inverted.  The  number  of
              groups  for  the  matching  rule is stored in a variable <b>yynmatch</b> (the whole regular expression is
              group number zero), and submatch results are stored in <b>yypmatch</b> array. Both <b>yynmatch</b> and  <b>yypmatch</b>
              should  be  defined  by the user, and <b>yypmatch</b> size must be at least <b>[yynmatch</b> <b>*</b> <b>2]</b>. Use <b>maxnmatch</b>
              block to  define <b>YYMAXNMATCH</b>, a constant that equals to the maximum value of  <b>yynmatch</b>  among  all
              rules.

       <b>Captvars</b>
              Another  way  to use capturing groups is the <b>--captvars</b> option or <b>re2c:captvars</b> <b>=</b> <b>1</b> configuration.
              The only difference with <b>--captures</b> is in the way the  generated  code  stores  submatch  results:
              instead  of  <b>yynmatch</b> and <b>yypmatch</b> re2d generates variables <b>yytl&lt;k&gt;</b> and <b>yytr&lt;k&gt;</b> for <u>k</u>-th capturing
              group (the user should declare these using an <b>svars</b> block). Captures with  variables  support  two
              disambiguation  policies:  <b>--leftmost-captvars</b>  or  <b>re2c:leftmost-captvars</b> <b>=</b> <b>1</b> for leftmost greedy
              policy (the default one) and  <b>--posix-captvars</b>  or  <b>re2c:posix-captvars</b>  for  POSIX  longest-match
              policy.

       Under  the  hood  all  these  options  translate  into tags and Tagged Deterministic Finite Automata with
       Lookahead &lt;https://arxiv.org/abs/1907.08837&gt; .  The core idea of TDFA is  to  minimize  the  overhead  on
       submatch  extraction.   In  the extreme, if there're no tags or captures in a regular expression, TDFA is
       just an ordinary DFA. If the number of tags is moderate, the overhead is barely noticeable. The generated
       TDFA uses a number of <u>tag</u> <u>variables</u> which do not map directly to tags: a single variable may be used  for
       different  tags,  and  a  tag  may require multiple variables to hold all its possible values. Eventually
       ambiguity is resolved, and only one final variable per tag survives.  Tag  variables  should  be  defined
       using <b>stags</b> or <b>mtags</b> blocks. If lexer state is stored, tag variables should be part of it. They also need
       to be updated  by <b>YYFILL</b>.

       S-tags support the following operations:

       • save input position to an s-tag: <b>t</b> <b>=</b> <b>YYCURSOR</b> with C pointer API or a user-defined operation <b>YYSTAGP(t)</b>
         with generic API

       • save default value to an s-tag: <b>t</b> <b>=</b> <b>NULL</b> with C pointer API or a user-defined operation <b>YYSTAGN(t)</b> with
         generic API

       • copy one s-tag to another: <b>t1</b> <b>=</b> <b>t2</b>

       M-tags support the following operations:

       • append  input  position  to an m-tag: a user-defined operation <b>YYMTAGP(t)</b> with both default and generic
         API

       • append default value to an m-tag: a user-defined operation <b>YYMTAGN(t)</b> with both default and generic API

       • copy one m-tag to another: <b>t1</b> <b>=</b> <b>t2</b>

       S-tags can  be  implemented  as  scalar  values  (pointers  or  offsets).  M-tags  need  a  more  complex
       representation,  as  they  need  to  store  a  sequence  of  tag  values.  The most naive and inefficient
       representation of an m-tag is a list (array, vector) of tag values; a more efficient representation is to
       store all m-tags in a prefix-tree represented as array of nodes <b>(v,</b> <b>p)</b>, where <b>v</b> is tag value and <b>p</b>  is  a
       pointer to parent node.

       Here  is  a  simple  example  of  using  s-tags  to  parse  semantic versions consisting of three numeric
       components: major, minor, patch (the latter is optional).  See below for a more complex example that uses
       <b>YYFILL</b>.

          // re2d $INPUT -o $OUTPUT
          module main;

          struct SemVer {
              int major;
              int minor;
              int patch;
          };

          private int s2n(const(char)* s, const(char)* e) { // pre-parsed string to number
              int n = 0;
              for (; s &lt; e; ++s) n = n * 10 + (*s - '0');
              return n;
          }

          private bool lex(const(char)* str, ref SemVer ver) {
              const(char)* yycursor = str, yymarker;

              // Final tag variables available in semantic action.
              /*!svars:re2c format = 'const(char)* @@;\n'; */

              // Intermediate tag variables used by the lexer (must be autogenerated).
              /*!stags:re2c format = 'const(char)* @@;\n'; */

              /*!re2c
                  re2c:yyfill:enable = 0;
                  re2c:tags = 1;
                  re2c:YYCTYPE = "char";

                  num = [0-9]+;

                  @t1 num @t2 "." @t3 num @t4 ("." @t5 num)? [\x00] {
                      ver.major = s2n(t1, t2);
                      ver.minor = s2n(t3, t4);
                      ver.patch = t5 != null ? s2n(t5, yycursor - 1) : 0;
                      return true;
                  }
                  * { return false; }
              */
          }

          void main() {
              SemVer v;
              assert(lex("23.34", v) &amp;&amp; v.major == 23 &amp;&amp; v.minor == 34 &amp;&amp; v.patch == 0);
              assert(lex("1.2.999", v) &amp;&amp; v.major == 1 &amp;&amp; v.minor == 2 &amp;&amp; v.patch == 999);
              assert(!lex("1.a", v));
          }

       Here is a more complex example of using s-tags  with  <b>YYFILL</b>  to  parse  a  file  with  newline-separated
       semantic  versions. Tag variables are part of the lexer state, and they are adjusted in <b>YYFILL</b> like other
       input positions.  Note that it is necessary  for  s-tags  because  their  values  are  invalidated  after
       shifting  buffer  contents.  It may not be necessary in a custom implementation where tag variables store
       offsets relative to the start of the input string rather than the buffer, which  may  be  the  case  with
       m-tags.

          // re2d $INPUT -o $OUTPUT --tags
          module main;

          import core.stdc.string;
          import core.stdc.stdio;
          import std.stdio;

          enum BUFSIZE = 4095;

          struct Input {
              FILE* file;
              char[BUFSIZE + 1] buffer;// +1 for sentinel
              char* yylimit, yycursor, yymarker, token;
              // Intermediate tag variables must be part of the lexer state passed to YYFILL.
              // They don't correspond to tags and should be autogenerated by re2c.
              /*!stags:re2c format = 'char* @@;'; */
              bool eof;
          };

          struct SemVer {
              int major;
              int minor;
              int patch;
          };

          private int s2n(const(char)* s, const(char)* e) { // pre-parsed string to number
              int n = 0;
              for (; s &lt; e; ++s) n = n * 10 + (*s - '0');
              return n;
          }

          private int fill(ref Input it) {
              if (it.eof) return 1;

              const size_t shift = it.token - it.buffer.ptr;
              const size_t used = it.yylimit - it.token;

              // Error: lexeme too long. In real life could reallocate a larger buffer.
              if (shift &lt; 1) return 2;

              // Shift buffer contents (discard everything up to the current token).
              memmove(cast(void*)it.buffer.ptr, it.token, used);
              it.yylimit -= shift;
              it.yycursor -= shift;
              it.yymarker -= shift;
              it.token -= shift;
              // Tag variables need to be shifted like other input positions. The check
              // for non-null is only needed if some tags are nested inside of alternative
              // or repetition, so that they can have null value.
              /*!stags:re2c format = "if (it.@@) it.@@ -= shift;\n"; */

              // Fill free space at the end of buffer with new data from file.
              it.yylimit += fread(it.yylimit, 1, BUFSIZE - used, it.file);
              it.yylimit[0] = 0;
              it.eof = it.yylimit &lt; (it.buffer.ptr + BUFSIZE);
              return 0;
          }

          private bool lex(ref Input yyrecord, ref SemVer[] vers) {
              // Final variables available in semantic actions.
              /*!svars:re2c format = 'char* @@;'; */
              for (;;) {
                  yyrecord.token = yyrecord.yycursor;
              /*!re2c
                  re2c:api = record;
                  re2c:YYCTYPE = "char";
                  re2c:YYFILL = "fill(yyrecord) == 0";
                  re2c:eof = 0;

                  num = [0-9]+;

                  num @t1 "." @t2 num @t3 ("." @t4 num)? [\n] {
                      int major = s2n(yyrecord.token, t1);
                      int minor = s2n(t2, t3);
                      int patch = t4 != null ? s2n(t4, yyrecord.yycursor - 1) : 0;
                      SemVer ver = SemVer(major, minor, patch);
                      vers ~= ver;
                      continue;
                  }
                  $ { return true; }
                  * { return false; }
              */
              }
              <a href="../man0/assert.0.html">assert</a>(0);
          }

          void main() {
              const char[] fname = "input";
              const char[] content = "1.22.333\n' ";

              SemVer[BUFSIZE] expect = SemVer(1, 22, 333);
              SemVer[] actual;

              // Prepare input file: a few times the size of the buffer, containing
              // strings with zeroes and escaped quotes.
              FILE* f = fopen(fname.ptr, "w");
              for (int i = 0; i &lt; BUFSIZE; ++i) {
                  fwrite(cast(const(void*)) content.ptr, 1, content.length - 2, f); // skip null-terminator
              }
              fclose(f);

              // Initialize lexer state: all pointers are at the end of buffer.
              Input it;
              it.file = fopen(fname.ptr, "r");
              it.yycursor = it.yymarker = it.token = it.yylimit = it.buffer.ptr + BUFSIZE;
              it.eof = 0;
              // Sentinel (at YYLIMIT pointer) is set to zero, which triggers YYFILL.
              it.yylimit[0] = 0;

              // Run the lexer.
              assert(lex(it, actual) &amp;&amp; actual == expect);

              // Cleanup: remove input file.
              fclose(it.file);
              remove(fname.ptr);
          }

       Here is an example of using capturing groups to parse semantic versions.

          // re2d $INPUT -o $OUTPUT
          module main;

          struct SemVer { int major, minor, patch; };

          private int s2n(const(char)* s, const(char)* e) { // pre-parsed string to number
              int n = 0;
              for (; s &lt; e; ++s) n = n * 10 + (*s - '0');
              return n;
          }

          private bool lex(const(char)* str, ref SemVer ver) {
              const(char)* yycursor = str, yymarker;

              // Final tag variables available in semantic action.
              /*!svars:re2c format = 'const(char)* @@;\n'; */

              // Intermediate tag variables used by the lexer (must be autogenerated).
              /*!stags:re2c format = 'const(char)* @@;\n'; */

              /*!re2c
                  re2c:yyfill:enable = 0;
                  re2c:captvars = 1;
                  re2c:YYCTYPE = "char";

                  num = [0-9]+;

                  (num) "." (num) ("." num)? [\x00] {
                      ver.major = s2n(yytl1, yytr1);
                      ver.minor = s2n(yytl2, yytr2);
                      ver.patch = yytl3 ? s2n(yytl3 + 1, yytr3) : 0;
                      return true;
                  }
                  * { return false; }
              */
          }

          void main() {
              SemVer v;
              assert(lex("23.34", v) &amp;&amp; v.major == 23 &amp;&amp; v.minor == 34 &amp;&amp; v.patch == 0);
              assert(lex("1.2.999", v) &amp;&amp; v.major == 1 &amp;&amp; v.minor == 2 &amp;&amp; v.patch == 999);
              assert(!lex("1.a", v));
          }

       Here is an example of using m-tags to parse a version with a variable number of components. Tag variables
       are stored in a trie.

          // re2d $INPUT -o $OUTPUT
          module main;

          enum MtagRoot = -1;

          // An m-tag tree is a way to store histories with an <a href="../man1/O.1.html">O</a>(1) copy operation.
          // Histories naturally form a tree, as they have common start and fork at some
          // point. The tree is stored as an array of pairs (tag value, link to parent).
          // An m-tag is represented with a single link in the tree (array index).
          struct Mtag {
              const(char)* elem; // tag value
              int pred; // index of the predecessor node or root
          };

          alias MtagTrie = Mtag[];
          alias Ver = int[];

          private int s2n(const(char)* s, const(char)* e) { // pre-parsed string to number
              int n = 0;
              for (; s &lt; e; ++s) n = n * 10 + (*s - '0');
              return n;
          }

          // Append a single value to an m-tag history.
          private void add_mtag(ref MtagTrie trie, ref int mtag, const(char)* value) {
              Mtag m = {value, mtag};
              mtag = cast(int)trie.length;
              trie ~= [m];
          }

          // Recursively unwind tag histories and collect version components.
          private void unfold(const ref MtagTrie trie, int x, int y, ref Ver ver) {
              // Reached the root of the m-tag tree, stop recursion.
              if (x == MtagRoot &amp;&amp; y == MtagRoot) return;

              // Unwind history further.
              unfold(trie, trie[x].pred, trie[y].pred, ver);

              // Get tag values. Tag histories must have equal length.
              assert(x != MtagRoot &amp;&amp; y != MtagRoot);
              const(char)* ex = trie[x].elem, ey = trie[y].elem;

              if (ex != null &amp;&amp; ey != null) {
                  // Both tags are valid pointers, extract component.
                  ver ~= [s2n(ex, ey)];
              } else {
                  // Both tags are null (this corresponds to zero repetitions).
                  assert(ex == null &amp;&amp; ey == null);
              }
          }

          private bool parse(const(char)* str, ref Ver ver) {
              const(char)* yycursor = str, yymarker;
              MtagTrie mt;

              // Final tag variables available in semantic action.
              /*!svars:re2c format = "const(char)* @@;"; */
              /*!mvars:re2c format = "int @@;"; */

              // Intermediate tag variables used by the lexer (must be autogenerated).
              /*!stags:re2c format = "const(char)* @@ = null;"; */
              /*!mtags:re2c format = "int @@ = MtagRoot;"; */

              /*!re2c
                  re2c:yyfill:enable = 0;
                  re2c:tags = 1;
                  re2c:YYCTYPE = "char";
                  re2c:YYMTAGP = "add_mtag(mt, @@, yycursor);";
                  re2c:YYMTAGN = "add_mtag(mt, @@, null);";

                  num = [0-9]+;
                  @t1 num @t2 ("." #t3 num #t4)* [\x00] {
                      ver = [];
                      ver ~= [s2n(t1, t2)];
                      unfold(mt, t3, t4, ver);
                      return true;
                  }
                  * { return false; }
              */
          }

          void main() {
              Ver v;
              assert(parse("1", v) &amp;&amp; v == [1]);
              assert(parse("1.2.3.4.5.6.7", v) &amp;&amp; v == [1, 2, 3, 4, 5, 6, 7]);
              assert(!parse("1.2.", v));
          }

   <b>Encoding</b> <b>support</b>
       It  is  necessary  to  understand  the  difference  between <b>code</b> <b>points</b> and <b>code</b> <b>units</b>. A code point is a
       numeric identifier of a symbol. A code unit is the smallest unit of storage in the encoded text. A single
       code point may be represented with one or more code units. In a fixed-length encoding all code points are
       represented with the same number of code  units.  In  a  variable-length  encoding  code  points  may  be
       represented  with a different number of code units.  Note that the "any" rule <b>[^]</b> matches any code point,
       but not necessarily any code unit (the only way to match any code unit regardless of the encoding is  the
       default  rule  <b>*</b>).   The  generated lexer works with a stream of code units: <b>yych</b> stores a code unit, and
       <b>YYCTYPE</b> is the code unit type. Regular expressions, on the other hand, are specified  in  terms  of  code
       points.  When re2d compiles regular expressions to automata it translates code points to code units. This
       is generally not a simple mapping: in variable-length  encodings  a  single  code  point  range  may  get
       translated to a complex code unit graph.  The following encodings are supported:

       • <b>ASCII</b>  (enabled  by  default).  It  is  a fixed-length encoding with code space <b>[0-255]</b> and 1-byte code
         points and code units.

       • <b>EBCDIC</b> (enabled with <b>--ebcdic</b> or <b>re2c:encoding:ebcdic</b>). It is a fixed-length encoding with  code  space
         <b>[0-255]</b> and 1-byte code points and code units.

       • <b>UCS2</b>  (enabled  with  <b>--ucs2</b>  or  <b>re2c:encoding:ucs2</b>).  It  is  a fixed-length encoding with code space
         <b>[0-0xFFFF]</b> and 2-byte code points and code units.

       • <b>UTF8</b> (enabled with <b>--utf8</b> or <b>re2c:encoding:utf8</b>). It is a variable-length Unicode encoding.  Code  unit
         size is 1 byte. Code points are represented with 1 -- 4 code units.

       • <b>UTF16</b>  (enabled  with  <b>--utf16</b>  or <b>re2c:encoding:utf16</b>). It is a variable-length Unicode encoding. Code
         unit size is 2 bytes. Code points are represented with 1 -- 2 code units.

       • <b>UTF32</b> (enabled with <b>--utf32</b> or <b>re2c:encoding:utf32</b>). It is a fixed-length Unicode  encoding  with  code
         space <b>[0-0x10FFFF]</b> and 4-byte code points and code units.

       Include file <b>include/unicode_categories.re</b> provides re2d definitions for the standard Unicode categories.

       Option  <b>--input-encoding</b>  specifies source file encoding, which can be used to enable Unicode literals in
       regular expressions. For example <b>--input-encoding</b> <b>utf8</b> tells re2d that the source file  is  in  UTF8  (it
       differs  from  <b>--utf8</b>  which  sets  input text encoding). Option <b>--encoding-policy</b> specifies the way re2d
       handles Unicode surrogates (code points in range <b>[0xD800-0xDFFF]</b>).

       Below is an example of a lexer for UTF8 encoded Unicode identifiers.

          // re2d $INPUT -o $OUTPUT -8 -i
          module main;

          /*!include:re2c "unicode_categories.re" */

          private int lex(const(char)* s) {
              const(char)* yycursor = s, yymarker;
              /*!re2c
                  re2c:YYCTYPE = "char";
                  re2c:yyfill:enable = 0;

                  // Simplified "Unicode Identifier and Pattern Syntax"
                  // (see https://unicode.org/reports/tr31)
                  id_start    = L | Nl | [$_];
                  id_continue = id_start | Mn | Mc | Nd | Pc | [\u200D\u05F3];
                  identifier  = id_start id_continue*;
                  identifier { return 0; }
                  *          { return 1; }
              */
          }

          void main() {
              assert(lex("_Ыдентификатор") == 0);
              assert(lex("!!!")==1);
          }

   <b>Include</b> <b>files</b>
       re2d allows one to include other files using a block of the form <b>/*!include:re2c</b>  <b>FILE</b>  <b>*/</b>  or  <b>%{include</b>
       <b>FILE</b> <b>%}</b>, or an in-block directive <b>!include</b> <b>FILE</b> <b>;</b>, where <b>FILE</b> is a path to the file to be included.  re2d
       looks  for  include  files  in the directory of the including file and in include locations, which can be
       specified with the <b>-I</b> option. Include blocks/directives in re2d work in the same way as  C/C++  <b>#include</b>:
       <b>FILE</b>  contents  are  copy-pasted verbatim in place of the block/directive. Include files may have further
       includes of their own. Use <b>--depfile</b> option to track build dependencies of the  output  file  on  include
       files.  re2d provides some predefined include files that can be found in the <b>include/</b> subdirectory of the
       project.  These  files  contain  definitions  that  may  be  useful  to  other  projects (such as Unicode
       categories) and form something like a standard library for re2d. Below is an  example  of  using  include
       files.

   <b>Include</b> <b>file</b> <b>1</b> <b>(definitions.d)</b>
          enum Result{ OK, FAIL };

          /*!re2c
              number = [1-9][0-9]*;
          */

   <b>Include</b> <b>file</b> <b>2</b> <b>(extra_rules.re.inc)</b>
          // floating-point numbers
          frac  = [0-9]* "." [0-9]+ | [0-9]+ ".";
          exp   = 'e' [+-]? [0-9]+;
          float = frac exp? | [0-9]+ exp;

          float { return Result.OK; }

   <b>Input</b> <b>file</b>
          // re2d $INPUT -o $OUTPUT -i

          /*!include:re2c "definitions.d" */

          private Result lex(const(char)* s) {
              const(char)* yycursor = s, yymarker;
              /*!re2c
                  re2c:YYCTYPE = "char";
                  re2c:yyfill:enable = 0;

                  *      { return Result.FAIL; }
                  number { return Result.OK; }
                  !include "extra_rules.re.inc";
              */
          }

          void main() {
              assert(lex("123") == Result.OK);
              assert(lex("123.4567") == Result.OK);
          }

   <b>Header</b> <b>files</b>
       re2d  allows  one  to  generate  header file from the input <b>.re</b> file using <b>--header</b> option or <b>re2c:header</b>
       configuration and block pairs of the form <b>/*!header:re2c:on*/</b> and <b>/*!header:re2c:off*/</b>, or  <b>%{header:on%}</b>
       and  <b>%{header:off%}</b>.  The  first block marks the beginning of header file, and the second block marks the
       end of it. Everything between these blocks is processed by re2d, and the generated code is written to the
       file specified with <b>--header</b> option or  <b>re2c:header</b>  configuration  (or  <b>stdout</b>  if  neither  option  nor
       configuration  is  used).  Autogenerated header file may be needed in cases when re2d is used to generate
       definitions  that must be visible from other translation units.

       Here is an example of generating a header file that contains definition  of  the  lexer  state  with  tag
       variables (the number variables depends on the regular grammar and is unknown to the programmer).

   <b>Input</b> <b>file</b>
          // re2d $INPUT -o $OUTPUT -i --header lexer/state.d
          module main;

          import core.stdc.stddef;
          import lexer.state; // the module is generated by re2c

          /*!header:re2c:on*/
          module lexer.state;

          struct LexerState {
              const(char)* str, yycursor;
              /*!stags:re2c format = "const(char)* @@;"; */
          };
          /*!header:re2c:off*/

          private long lex(ref LexerState yyrecord) {
              const(char)* t;
              /*!re2c
                  re2c:api = record;
                  re2c:YYCTYPE = "char";
                  re2c:tags = 1;
                  re2c:yyfill:enable = 0;
                  re2c:header = "lexer/state.d";

                  [a]* @t [b]* { return t - yyrecord.str; }
              */
          }

          void main() {
              const(char)* s = "ab";
              LexerState st = {s, s /*!stags:re2c format = ", null"; */};
              assert(lex(st) == 1);

              const(char)* s2 = "aaabbbbbbbb";
              LexerState st2 = {s2, s2 /*!stags:re2c format = ", null"; */};
              assert(lex(st2) == 3);
          }

   <b>Header</b> <b>file</b>
          /* Generated by re2c */

          module lexer.state;

          struct LexerState {
              const(char)* str, yycursor;
              const(char)* yyt1;
          };

   <b>Skeleton</b> <b>programs</b>
       With  the  <b>-S,</b> <b>--skeleton</b> option, re2d ignores all non-re2d code and generates a self-contained C program
       that can be further compiled and executed.  The program consists of lexer code and input data.  For  each
       constructed DFA (block or condition) re2d generates a standalone lexer and two files: an <b>.input</b> file with
       strings derived from the DFA and a <b>.keys</b> file with expected match results. The program runs each lexer on
       the  corresponding  <b>.input</b>  file  and compares results with the expectations.  Skeleton programs are very
       useful for a number of reasons:

       • They can check correctness of various re2d optimizations (the data is generated early in  the  process,
         before any DFA transformations have taken place).

       • Generating a set of input data with good coverage may be useful for both testing and benchmarking.

       • Generating self-contained executable programs allows one to get minimized test cases (the original code
         may be large or have a lot of dependencies).

       The  difficulty  with  generating  input  data  is  that for all but the most trivial cases the number of
       possible input strings is too large (even if the string length is limited). re2d solves  this  difficulty
       by  generating  sufficiently  many  strings  to  cover  almost all DFA transitions. It uses the following
       algorithm. First, it constructs a skeleton of the DFA. For encodings with 1-byte code unit size (such  as
       ASCII, UTF-8 and EBCDIC) skeleton is just an exact copy of the original DFA. For encodings with multibyte
       code  units  skeleton  is  a copy of DFA with certain transitions omitted: namely, re2d takes at most 256
       code units for each disjoint continuous range that corresponds to a DFA transition.   The  chosen  values
       are  evenly  distributed  and  include range bounds. Instead of trying to cover all possible paths in the
       skeleton (which is infeasible) re2d generates sufficiently many paths to cover all skeleton  transitions,
       and  thus  trigger  the  corresponding  conditional  jumps in the lexer.  The algorithm implementation is
       limited by ~1Gb of transitions and consumes constant amount of memory (re2d writes data to file  as  soon
       as it is generated).

   <b>Visualization</b> <b>and</b> <b>debug</b>
       With  the  <b>-D,</b> <b>--emit-dot</b> option, re2d does not generate code. Instead, it dumps the generated DFA in DOT
       format.  One can convert this dump to an image of the DFA using Graphviz or another library.   Note  that
       this  option shows the final DFA after it has gone through a number of optimizations and transformations.
       Earlier stages can be dumped with various debug options, such as <b>--dump-nfa</b>, <b>--dump-dfa-raw</b> etc. (see the
       full list of options).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       You can find more information about re2c at the official website:  &lt;<a href="http://re2c.org">http://re2c.org</a>&gt; .  Similar  programs
       are <a href="../man1/flex.1.html">flex</a>(1), <a href="../man1/lex.1.html">lex</a>(1), quex( &lt;<a href="http://quex.sourceforge.net">http://quex.sourceforge.net</a>&gt; ).

</pre><h4><b>AUTHORS</b></h4><pre>
       re2d  was  originally written by Peter Bumbulis ( &lt;<a href="mailto:peter@csg.uwaterloo.ca">peter@csg.uwaterloo.ca</a>&gt; ) in 1993.  Marcus Boerger and
       Dan Nuffer spent several years to turn the original idea into a production ready  code  generator.  Since
       then  it  has  been  maintained  and  developed  by  multiple  volunteers,  most  notably,  Brian Young (
       &lt;<a href="mailto:bayoung@acm.org">bayoung@acm.org</a>&gt;    ),    Marcus    Boerger    &lt;https://github.com/helly25&gt;    ,    Dan     Nuffer     (
       &lt;<a href="mailto:nuffer@users.sourceforge.net">nuffer@users.sourceforge.net</a>&gt; ), Ulya Trofimovich &lt;https://github.com/skvadrik&gt;
        (   &lt;<a href="mailto:skvadrik@gmail.com">skvadrik@gmail.com</a>&gt;  ),  Serghei  Iakovlev  &lt;https://github.com/sergeyklay&gt;  ,  Sergei  Trofimovich
       &lt;https://github.com/trofi&gt; , Petr Skocik &lt;https://github.com/pskocik&gt; ,
        &lt;ligfx&gt;
        &lt;raekye&gt; and  &lt;PolarGoose&gt; .

                                                                                                         <u><a href="../man1/RE2D.1.html">RE2D</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>