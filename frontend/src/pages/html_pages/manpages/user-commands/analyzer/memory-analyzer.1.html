<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>memory-analyzer - Snapshot program state for symbolic analysis</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/cbmc">cbmc_6.4.1-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       memory-analyzer - Snapshot program state for symbolic analysis

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>memory-analyzer</b> <b>[-?]</b> <b>[-h]</b> <b>[--help]</b>
              show help

       <b>memory-analyzer</b> <b>--version</b>
              show version

       <b>memory-analyzer</b> <b>--symbols</b> <u>symbol_list</u> [options] <u>binary</u>
              analyze binary

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>memory-analyzer</b> is a front-end that runs and queries <b><a href="../man1/gdb.1.html">gdb</a></b>(1) in order to obtain a snapshot of the state of
       an  input program at a particular program location.  Such a snapshot could be useful on its own: to check
       the values of variables at a particular program location. Furthermore, since the snapshot is a state of a
       valid concrete execution, it can also be used for subsequent analyses.

       In order to analyze a program with <b>memory-analyzer</b> it needs to be compiled with <b><a href="../man1/goto-gcc.1.html">goto-gcc</a></b>(1). This  yields
       an <b><a href="../man5/elf.5.html">elf</a></b>(5) executable that also includes a <u>goto-cc</u> section holding the goto model:

              goto-gcc -g input_program.c -o input_program_exe

       <b>memory-analyzer</b> supports two ways of running <b><a href="../man1/gdb.1.html">gdb</a></b>(1) on user code: either to run the code from a core-file
       or  up  to  a  break-point.  If  the  user  already  has a core-file, they can specify it with the option
       <b>--core-file</b> <u>cf</u>. If the user knows the point of their program from where they want to  run  the  analysis,
       they  can  specify  it  with  the option <b>--breakpoint</b> <u>bp</u>. Only one of core-file/break-point option can be
       used.

       The tool also expects a comma-separated list of symbols to be analyzed via <b>--symbols</b> <u>s1</u>,<u>s2</u>,<u>...</u>.  The tool
       invokes <b><a href="../man1/gdb.1.html">gdb</a></b>(1) to obtain the snapshot which is why the <b>-g</b> option is  necessary  when  compiling  for  the
       program symbols to be visible.

       Take for example the following program:
           <b>//</b> <b>main.c</b>
           void <b>checkpoint</b>() {}

           int array[] = {1, 2, 3};

           int <b>main</b>() {
             array[1] = 4;
             <b>checkpoint</b>();
             <b>return</b> 0;
           }

       Say  we  are interested in the evaluation of <u>array</u> at the call-site of <u>checkpoint</u>. We compile the program
       with

              goto-gcc -g main.c -o main_exe

       And then we call <b>memory-analyzer</b> with:

              memory-analyzer --breakpoint checkpoint --symbols array main_exe

       to obtain as output the human readable list of values for each requested symbol:
           {
             array = { 1, 4, 3 };
           }

       The above result is useful for the user and their  preliminary  analysis  but  does  not  contain  enough
       information  for  further automated analyses. To that end, memory analyzer has an option for the snapshot
       to be represented in the format of a symbol table (with <b>--symtab-snapshot</b>). Finally, to obtain an  output
       in JSON format, e.g., for further analyses by <b><a href="../man1/goto-harness.1.html">goto-harness</a></b>(1) the additional option <b>--json-ui</b> needs to be
       passed to <b>memory-analyzer</b>:

              memory-analyzer --symtab-snapshot --json-ui --breakpoint checkpoint
                --symbols array main_exe &gt; snapshot.json

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>--core-file</b> <u>file_name</u>
              Analyze from core dump <u>file_name</u>.

       <b>--breakpoint</b> <u>breakpoint</u>
              Analyze from given breakpoint.

       <b>--symbols</b> <u>symbol_list</u>
              List of symbols to analyze.

       <b>--symtab-snapshot</b>
              Output snapshot as JSON symbol table that can be used with <b><a href="../man1/symtab2gb.1.html">symtab2gb</a></b>(1).

       <b>--output-file</b> <u>file_name</u>
              Write snapshot to <u>file_name</u>.

       <b>--json-ui</b>
              Output snapshot in JSON format.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       All tools honor the TMPDIR environment variable when generating temporary files and directories.

</pre><h4><b>BUGS</b></h4><pre>
       If you encounter a problem please create an issue at <b>https://github.com/diffblue/cbmc/issues</b>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1), <b><a href="../man5/elf.5.html">elf</a></b>(5), <b><a href="../man1/gdb.1.html">gdb</a></b>(1), <b><a href="../man1/goto-gcc.1.html">goto-gcc</a></b>(1), <b><a href="../man1/goto-harness.1.html">goto-harness</a></b>(1), <b><a href="../man1/symtab2gb.1.html">symtab2gb</a></b>(1)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2019, Malte Mues, Diffblue

memory-analyzer-5.59.0                              June 2022                                 <u><a href="../man1/MEMORY-ANALYZER.1.html">MEMORY-ANALYZER</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>