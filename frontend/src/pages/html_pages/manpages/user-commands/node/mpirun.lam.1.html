<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mpirun - Run MPI programs on LAM nodes.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/lam-runtime">lam-runtime_7.1.4-7.2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mpirun - Run MPI programs on LAM nodes.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       mpirun  [-fhvO] [-c # | -np #] [-D | -wd dir] [-ger | -nger] [-sigs | -nsigs] [-ssi key value] [-nw | -w]
       [-nx] [-pty | -npty] [-s node] [-t | -toff | -ton]  [-tv]  [-x  VAR1[=VALUE1][,VAR2[=VALUE2],...]]   [[-p
       prefix_str] [-sa | -sf]] [where] program [-- args]

       <b>Note:</b> Although each are individually optional, at least one of <u>where</u>, <u>-np</u>, or <u>-c</u> must be specified in the
              above form (i.e., when a schema is not used).

       mpirun  [-fhvO]  [-D | -wd dir] [-ger | -nger] [-sigs | -nsigs] [-ssi key value] [-nw | -w] [-nx] [-pty |
              -npty] [-t | -toff | -ton] [-tv] [-x VAR1[=VALUE1][,VAR2[=VALUE2],...]]  schema

       <b>Note:</b> The <u>-c2c</u> and <u>-lamd</u> options are now obsolete.  Use <u>-ssi</u> instead.  See the "SSI" section, below.

</pre><h4><b>QUICK</b> <b>SUMMARY</b></h4><pre>
       If you're simply looking for how to run an MPI application, you probably want to use the  following  com‐
       mand line:

              % mpirun C my_mpi_application

       This  will  run  one copy of <u>my_mpi_application</u> on every CPU in the current LAM universe.  Alternatively,
       "N" can be used in place of "C", indicating that one copy of <u>my_mpi_application</u> should be  run  on  every
       node (as opposed to CPU) in the current LAM universe.  Finally:

              % mpirun -np 4 my_mpi_application

       can  be used to tell LAM to explicitly run four copies of <u>my_mpi_application</u>, scheduling in a round-robin
       fashion by CPU in the LAM universe.  See the rest of this page for more details, particularly the  "Loca‐
       tion Nomenclature" section.

</pre><h4><b>OPTIONS</b></h4><pre>
       There  are  two  forms of the <u>mpirun</u> command -- one for programs (i.e., SPMD-style applications), and one
       for application schemas (see <a href="../man5/appschema.5.html">appschema</a>(5)).  Both forms of <u>mpirun</u> use the following options  by  default:
       <u>-nger</u> <u>-w</u>.  These may each be overriden by their counterpart options, described below.

       Additionally,  <u>mpirun</u>  will send the name of the directory where it was invoked on the local node to each
       of the remote nodes, and attempt to change to that directory.  See the "Current Working  Directory"  sec‐
       tion, below.

       <b>-c</b> <b>#</b>      Synonym for <u>-np</u> (see below).

       <b>-D</b>        Use  the  executable  program  location as the current working directory for created processes.
                 The current working directory of the created processes will be set before the user's program is
                 invoked.  This option is mutually exclusive with <u>-wd</u>.

       <b>-f</b>        Do not configure standard I/O file descriptors - use defaults.

       <b>-h</b>        Print useful information on this command.

       <b>-ger</b>      Enable GER (Guaranteed Envelope Resources) communication protocol  and  error  reporting.   See
                 <a href="../man7/MPI.7.html">MPI</a>(7) for a description of GER.  This option is mutually exclusive with <u>-nger</u>.

       <b>-nger</b>     Disable GER (Guaranteed Envelope Resources).  This option is mutually exclusive with <u>-ger</u>.

       <b>-nsigs</b>    Do  not  have  LAM catch signals in the user application.  This is the default, and is mutually
                 exclusive with <u>-sigs</u>.

       <b>-np</b> <b>#</b>     Run this many copies of the program on the given nodes.  This option indicates that the  speci‐
                 fied  file  is an executable program and not an application schema.  If no nodes are specified,
                 all LAM nodes are considered for scheduling; LAM will schedule the programs  in  a  round-robin
                 fashion, "wrapping around" (and scheduling multiple copies on a single node) if necessary.

       <b>-npty</b>     Disable pseudo-tty support.  Unless you are having problems with pseudo-tty support, you proba‐
                 bly do not need this option.  Mutually exlclusive with -pty.

       <b>-nw</b>       Do  not  wait for all processes to complete before exiting <u>mpirun</u>.  This option is mutually ex‐
                 clusive with <u>-w</u>.

       <b>-nx</b>       Do not automatically export LAM_MPI_*, LAM_IMPI_*, or IMPI_* environment variables to  the  re‐
                 mote nodes.

       <b>-O</b>        Multicomputer  is  homogeneous.  Do no data conversion when passing messages.  THIS FLAG IS NOW
                 OBSOLETE.

       <b>-pty</b>      Enable pseudo-tty support.  Among other things, this enabled  line-buffered  output  (which  is
                 probably what you want).  This is the default.  Mutually exclusive with -npty.

       <b>-s</b> <b>node</b>   Load  the  program from this node.  This option is not valid on the command line if an applica‐
                 tion schema is specified.

       <b>-sigs</b>     Have LAM catch signals in the user process.  This options is mutually exclusive with <u>-nsigs</u>.

       <b>-ssi</b> <b>key</b> <b>value</b>
                 Send arguments to various SSI modules.  See the "SSI" section, below.

       <b>-t,</b> <b>-ton</b>  Enable execution trace generation for all processes.  Trace generation  will  proceed  with  no
                 further action.  These options are mutually exclusive with <u>-toff</u>.

       <b>-toff</b>     Enable  execution  trace  generation  for  all processes.  Trace generation for message passing
                 traffic will begin after processes collectively call <a href="../man2/MPIL_Trace_on.2.html">MPIL_Trace_on</a>(2).  Note that trace genera‐
                 tion for datatypes and communicators <u>will</u> proceed regardless of whether trace generation is en‐
                 abled for messages or not.  This option is mutually exclusive with <u>-t</u> and <u>-ton</u>.

       <b>-tv</b>       Launch processes under the TotalView Debugger.

       <b>-v</b>        Be verbose; report on important steps as they are done.

       <b>-w</b>        Wait for all applications to exit before <u>mpirun</u> exits.

       <b>-wd</b> <b>dir</b>   Change to the directory dir before the user's program executes.  Note that if  the  <u>-wd</u>  option
                 appears both on the command line and in an application schema, the schema will take precendence
                 over the command line.  This option is mutually exclusive with <u>-D</u>.

       <b>-x</b>        Export  the  specified  environment variables to the remote nodes before executing the program.
                 Existing environment variables can be specified (see the Examples section, below), or new vari‐
                 able names specified with corresponding values.  The parser for the <u>-x</u> option is not  very  so‐
                 phisticated;  it does not even understand quoted values.  Users are advised to set variables in
                 the environment, and then use <u>-x</u> to export (not define) them.

       <b>-sa</b>       Display the exit status of all MPI processes irrespecive of whether they fail or  run  success‐
                 fully.

       <b>-sf</b>       Display the exit status of all processes only if one of them fails.

       <b>-p</b> <b>prefix_str</b>
                 Prefixes each process status line displayed by [-sa] and [-sf] by the prefix_str.

       <b>where</b>     A set of node and/or CPU identifiers indicating where to start <b>program</b>.  See <a href="../man5/bhost.5.html">bhost</a>(5) for a de‐
                 scription  of  the  node  and  CPU  identifiers.   <u>mpirun</u>  will  schedule  adjoining  ranks  in
                 <u>MPI_COMM_WORLD</u> on the same node when CPU identifiers are used.  For example, if LAM was  booted
                 with  a  CPU count of 4 on n0 and a CPU count of 2 on n1 and <b>where</b> is C, ranks 0 through 3 will
                 be placed on n0, and ranks 4 and 5 will be placed on n1.

       <b>args</b>      Pass these runtime arguments to every new process.  These must always be the last arguments  to
                 <u>mpirun</u>.  This option is not valid on the command line if an application schema is specified.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       One invocation of <u>mpirun</u> starts an MPI application running under LAM.  If the application is simply SPMD,
       the application can be specified on the <u>mpirun</u> command line.  If the application is MIMD, comprising mul‐
       tiple programs, an application schema is required in a separate file.  See <a href="../man5/appschema.5.html">appschema</a>(5) for a description
       of  the  application  schema  syntax, but it essentially contains multiple <u>mpirun</u> command lines, less the
       command name itself.  The ability to specify different options for different instantiations of a  program
       is another reason to use an application schema.

   <b>Location</b> <b>Nomenclature</b>
       As described above, <u>mpirun</u> can specify arbitrary locations in the current LAM universe.  Locations can be
       specified  either  by  CPU or by node (noted by the "where" in the SYNTAX section, above).  Note that LAM
       does not bind processes to CPUs -- specifying a location "by CPU" is really a convenience  mechanism  for
       SMPs that ultimately maps down to a specific node.

       Note  that  LAM  effectively  numbers MPI_COMM_WORLD ranks from left-to-right in the where, regardless of
       which nomenclature is used.  This can be important because typical MPI programs tend to communicate  more
       with their immediate neighbors (i.e., myrank +/- X) than distant neighbors.  When neighbors end up on the
       same node, the shmem RPIs can be used for communication rather than the network RPIs, which can result in
       faster MPI performance.

       Specifying  locations  by node will launch one copy of an executable per specified node.  Using a capitol
       "N" tells LAM to use all available nodes that were lambooted (see <a href="../man1/lamboot.1.html">lamboot</a>(1)).  Ranges of specific  nodes
       can  also  be  specified  in the form "nR[,R]*", where R specifies either a single node number or a valid
       range of node numbers in the range of [0, num_nodes).  For example:

       mpirun N a.out
           Runs one copy of the the executable <u>a.out</u> on all available nodes in the LAM universe.  MPI_COMM_WORLD
           rank 0 will be on n0, rank 1 will be on n1, etc.

       mpirun n0-3 a.out
           Runs one copy of the the executable <u>a.out</u> on nodes 0 through 3.  MPI_COMM_WORLD rank 0 will be on n0,
           rank 1 will be on n1, etc.

       mpirun n0-3,8-11,15 a.out
           Runs one copy of the the executable <u>a.out</u> on nodes 0 through 3, 8 through 11, and 15.  MPI_COMM_WORLD
           ranks will be ordered as follows: (0, n0), (1, n1), (2, n2), (3, n3), (4, n8), (5, n9), (6, n10), (7,
           n11), (8, n15).

       Specifying by CPU is the preferred method of launching MPI jobs.  The intent is that the boot schema used
       with <a href="../man1/lamboot.1.html">lamboot</a>(1) will indicate how many CPUs are available on each node, and then a single, simple  <u>mpirun</u>
       command can be used to launch across all of them.  As noted above, specifying CPUs does not actually bind
       processes to CPUs -- it is only a convenience mechanism for launching on SMPs.  Otherwise, the by-CPU no‐
       tation is the same as the by-node notation, except that "C" and "c" are used instead of "N" and "n".

       Assume  in  the  following example that the LAM universe consists of four 4-way SMPs.  So c0-3 are on n0,
       c4-7 are on n1, c8-11 are on n2, and 13-15 are on n3.

       mpirun C a.out
           Runs one copy of the the executable <u>a.out</u> on all available CPUs in the LAM universe.  This  is  typi‐
           cally  the  simplest  (and  preferred)  method  of launching all MPI jobs (even if it resolves to one
           process per node).  MPI_COMM_WORLD ranks 0-3 will be on n0, ranks 4-7 will be on n1, ranks 8-11  will
           be on n2, and ranks 13-15 will be on n3.

       mpirun c0-3 a.out
           Runs one copy of the the executable <u>a.out</u> on CPUs 0 through 3.  All four ranks of MPI_COMM_WORLD will
           be on MPI_COMM_WORLD.

       mpirun c0-3,8-11,15 a.out
           Runs  one copy of the the executable <u>a.out</u> on CPUs 0 through 3, 8 through 11, and 15.  MPI_COMM_WORLD
           ranks 0-3 will be on n0, 4-7 will be on n2, and 8 will be on n3.

       The reason that the by-CPU nomenclature is preferred over the by-node nomenclature is best shown  through
       example.   Consider  trying  to run the first CPU example (with the same MPI_COMM_WORLD mapping) with the
       by-node nomenclature -- run one copy of <u>a.out</u> for every available CPU, and maximize the number  of  local
       neighbors to potentially maximize MPI performance.  One solution would be to use the following command:

       mpirun n0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3 a.out

       This  <u>works</u>,  but  is definitely klunky to type.  It is typically easier to use the by-CPU notation.  One
       might think that the following is equivalent:

       mpirun N -np 16 a.out

       This is <u>not</u> equivalent because the MPI_COMM_WORLD rank mappings will be assigned by node rather  than  by
       CPU.  Hence rank 0 will be on n0, rank 1 will be on n1, etc.  Note that the following, however, <u>is</u> equiv‐
       alent, because LAM interprets lack of a where as "C":

       mpirun -np 16 a.out

       However,  a  "C"  can  tend to be more convenient, especially for batch-queuing scripts because the exact
       number of processes may vary between queue submissions.  Since the batch system will determine the  final
       number  of  CPUs available, having a generic script that effectively says "run on everything you gave me"
       may lead to more portable / re-usable scripts.

       Finally, it should be noted that specifying multiple where clauses are perfectly  acceptable.   As  such,
       mixing of the by-node and by-CPU syntax is also valid, albiet typically not useful.  For example:

       mpirun C N a.out

       However, in some cases, specifying multiple where clauses can be useful.  Consider a parallel application
       where  MPI_COMM_WORLD  rank 0 will be a "manager" and therefore consume very few CPU cycles because it is
       usually waiting for "worker" processes to return results.  Hence, it is probably  desirable  to  run  one
       "worker" process on all available CPUs, and run one extra process that will be the "manager":

       mpirun c0 C manager-worker-program

   <b>Application</b> <b>Schema</b> <b>or</b> <b>Executable</b> <b>Program?</b>
       To  distinguish the two different forms, <u>mpirun</u> looks on the command line for where or the <u>-c</u> option.  If
       neither is specified, then the file named on the command line is assumed to be an application schema.  If
       either one or both are specified, then the file is assumed to be an executable program.  If where and  <u>-c</u>
       both  are  specified,  then copies of the program are started on the specified nodes/CPUs according to an
       internal LAM scheduling policy.  Specifying just one node effectively forces LAM to run all copies of the
       program in one place.  If <u>-c</u> is given, but not where, then all available CPUs on all LAM nodes are  used.
       If where is given, but not <u>-c</u>, then one copy of the program is run on each node.

   <b>Program</b> <b>Transfer</b>
       By default, LAM searches for executable programs on the target node where a particular instantiation will
       run.   If  the file system is not shared, the target nodes are homogeneous, and the program is frequently
       recompiled, it can be convenient to have LAM transfer the program from a source node (usually  the  local
       node) to each target node.  The <u>-s</u> option specifies this behavior and identifies the single source node.

   <b>Locating</b> <b>Files</b>
       LAM  looks for an executable program by searching the directories in the user's PATH environment variable
       as defined on the source node(s).  This behavior is consistent with logging into the source node and exe‐
       cuting the program from the shell.  On remote nodes, the "." path is the home directory.

       LAM looks for an application schema in three directories: the local directory, the value  of  the  LAMAP‐
       PLDIR  environment variable, and laminstalldir/boot, where "laminstalldir" is the directory where LAM/MPI
       was installed.

   <b>Standard</b> <b>I/O</b>
       LAM directs UNIX standard input to /dev/null on all remote nodes.  On the local node that invoked <u>mpirun</u>,
       standard input is inherited from <u>mpirun</u>.  The default is what used to be the -w option  to  prevent  con‐
       flicting access to the terminal.

       LAM directs UNIX standard output and error to the LAM daemon on all remote nodes.  LAM ships all captured
       output/error to the node that invoked <u>mpirun</u> and prints it on the standard output/error of <u>mpirun</u>.  Local
       processes inherit the standard output/error of <u>mpirun</u> and transfer to it directly.

       Thus  it is possible to redirect standard I/O for LAM applications by using the typical shell redirection
       procedure on <u>mpirun</u>.

              % mpirun C my_app  my_input  my_output

       Note that in this example <u>only</u> the local node (i.e., the node where mpirun was invoked from) will receive
       the stream from my_input on stdin.  The stdin on all the other nodes will be tied to /dev/null.  However,
       the stdout from all nodes will be collected into the my_output file.

       The <u>-f</u> option avoids all the setup required to support standard I/O described  above.   Remote  processes
       are completely directed to /dev/null and local processes inherit file descriptors from <a href="../man1/lamboot.1.html">lamboot</a>(1).

   <b>Pseudo-tty</b> <b>support</b>
       The  <u>-pty</u> option enabled pseudo-tty support for process output (it is also enabled by default).  This al‐
       lows, among other things, for line buffered output from remote nodes (which is probably what  you  want).
       This option can be disabled with the <u>-npty</u> switch.

   <b>Process</b> <b>Termination</b> <b>/</b> <b>Signal</b> <b>Handling</b>
       During the run of an MPI application, if any rank dies abnormally (either exiting before invoking <u>MPI_FI‐</u>
       <u>NALIZE</u>,  or dying as the result of a signal), <u>mpirun</u> will print out an error message and kill the rest of
       the MPI application.

       By default, LAM/MPI only installs a signal handler for one signal in user programs (SIGUSR2  by  default,
       but this can be overridden when LAM is configured and built).  Therefore, it is safe for users to install
       their  own  signal  handlers  in  LAM/MPI  programs  (LAM  notices death-by-signal cases by examining the
       process' return status provided by the operating system).

       User signal handlers should probably avoid trying to cleanup MPI state -- LAM is neither thread-safe  nor
       async-signal-safe.   For  example,  if  a  seg fault occurs in <u>MPI_SEND</u> (perhaps because a bad buffer was
       passed in) and a user signal handler is invoked, if this user handler attempts  to  invoke  <u>MPI_FINALIZE</u>,
       Bad  Things  could  happen since LAM/MPI was already "in" MPI when the error occurred.  Since <u>mpirun</u> will
       notice that the process died due to a signal, it is probably not necessary (and safest) for the  user  to
       only clean up non-MPI state.

       If  the <u>-sigs</u> option is used with <u>mpirun</u>, LAM/MPI will install several signal handlers to locally on each
       rank to catch signals, print out error messages, and kill the rest of the MPI application.  This is some‐
       what redundant behavior since this is now all handled by <u>mpirun</u>, but it has been left for backwards  com‐
       patability.

   <b>Process</b> <b>Exit</b> <b>Statuses</b>
       The  <u>-sa</u>,     <u>-sf</u>,  and  <u>-p</u>  parameters  can  be used to display the exist statuses of the individual MPI
       processes as they terminate.  <u>-sa</u> forces the exit statuses to be displayed for all  processes;  <u>-sf</u>  only
       displays the exist statuses if at least one process terminates either by a signal or a non-zero exit sta‐
       tus (note that exiting before invoking <u>MPI_FINALIZE</u> will cause a non-zero exit status).

       The status of each process is printed out, one per line, in the following format:

              prefix_string node pid killed status

       If  <u>killed</u> is 1, then <u>status</u> is the signal number.  If <u>killed</u> is 0, then <u>status</u> is the exit status of the
       process.

       The default <u>prefix_string</u> is "mpirun:", but the <u>-p</u> option can be used override this string.

   <b>Current</b> <b>Working</b> <b>Directory</b>
       The default behavior of mpirun has changed with respect to the directory that processes will  be  started
       in.

       The  <u>-wd</u> option to mpirun allows the user to change to an arbitrary directory before their program is in‐
       voked.  It can also be used in application schema files to specify working directories on specific  nodes
       and/or for specific applications.

       If  the  <u>-wd</u> option appears both in a schema file and on the command line, the schema file directory will
       override the command line value.

       The <u>-D</u> option will change the current working directory to the directory where  the  executable  resides.
       It cannot be used in application schema files.  <u>-wd</u> is mutually exclusive with <u>-D</u>.

       If neither <u>-wd</u> nor <u>-D</u> are specified, the local node will send the directory name where mpirun was invoked
       from  to  each of the remote nodes.  The remote nodes will then try to change to that directory.  If they
       fail (e.g., if the directory does not exists on that node), they will start with from the user's home di‐
       rectory.

       All directory changing occurs before the user's program is invoked; it does not wait  until  <u>MPI_INIT</u>  is
       called.

   <b>Process</b> <b>Environment</b>
       Processes  in  the  MPI  application inherit their environment from the LAM daemon upon the node on which
       they are running.  The environment of a LAM daemon is fixed upon booting of the LAM with  <a href="../man1/lamboot.1.html">lamboot</a>(1)  and
       is typically inherited from the user's shell.  On the origin node, this will be the shell from which lam‐
       <a href="../man1/boot.1.html">boot</a>(1)  was invoked; on remote nodes, the exact environment is determined by the boot SSI module used by
       <a href="../man1/lamboot.1.html">lamboot</a>(1).  The rsh boot module, for example, uses either rsh/ssh to launch the  LAM  daemon  on  remote
       nodes,  and  typically executes one or more of the user's shell-setup files before launching the LAM dae‐
       mon.  When running dynamically linked applications which require the LD_LIBRARY_PATH environment variable
       to be set, care must be taken to ensure that it is correctly set when booting the LAM.

   <b>Exported</b> <b>Environment</b> <b>Variables</b>
       All environment variables that are named in the form LAM_MPI_*, LAM_IMPI_*, or IMPI_* will  automatically
       be exported to new processes on the local and remote nodes.  This exporting may be inhibited with the <u>-nx</u>
       option.

       Additionally,  the  <u>-x</u>  option  to <u>mpirun</u> can be used to export specific environment variables to the new
       processes.  While the syntax of the <u>-x</u> option allows the definition of new variables, note that the pars‐
       er for this option is currently not very sophisticated - it  does  not  even  understand  quoted  values.
       Users are advised to set variables in the environment and use <u>-x</u> to export them; not to define them.

   <b>Trace</b> <b>Generation</b>
       Two  switches  control trace generation from processes running under LAM and both must be in the on posi‐
       tion for traces to actually be generated.  The first switch is controlled by <u>mpirun</u> and the second switch
       is initially set by <u>mpirun</u> but can be toggled at runtime  with  <a href="../man2/MPIL_Trace_on.2.html">MPIL_Trace_on</a>(2)  and  <a href="../man2/MPIL_Trace_off.2.html">MPIL_Trace_off</a>(2).
       The  <u>-t</u>  (<u>-ton</u> is equivalent) and <u>-toff</u> options all turn on the first switch.  Otherwise the first switch
       is off and calls to <a href="../man2/MPIL_Trace_on.2.html">MPIL_Trace_on</a>(2) in the application program are  ineffective.   The  <u>-t</u>  option  also
       turns on the second switch.  The <u>-toff</u> option turns off the second switch.  See <a href="../man2/MPIL_Trace_on.2.html">MPIL_Trace_on</a>(2) and lam‐
       <a href="../man1/trace.1.html">trace</a>(1) for more details.

   <b>MPI</b> <b>Data</b> <b>Conversion</b>
       LAM's MPI library converts MPI messages from local representation to LAM representation upon sending them
       and  then back to local representation upon receiving them.  If the case of a LAM consisting of a homoge‐
       neous network of machines where the local representation differs from the LAM representation this can re‐
       sult in unnecessary conversions.

       The <u>-O</u> switch used to be necessary to indicate to LAM whether the mulitcomputer was homogeneous  or  not.
       LAM now automatically determines whether a given MPI job is homogeneous or not.  The <u>-O</u> flag will silent‐
       ly be accepted for backwards compatability, but it is ignored.

   <b>SSI</b> <b>(System</b> <b>Services</b> <b>Interface)</b>
       The <u>-ssi</u> switch allows the passing of parameters to various SSI modules.  LAM's SSI modules are described
       in  detail in <a href="../man7/lamssi.7.html">lamssi</a>(7).  SSI modules have direct impact on MPI programs because they allow tunable para‐
       meters to be set at run time (such as which RPI communication device driver to use,  what  parameters  to
       pass to that RPI, etc.).

       The  <u>-ssi</u> switch takes two arguments: <u>key</u> and <u>value</u>.  The <u>key</u> argument generally specifies which SSI mod‐
       ule will receive the value.  For example, the <u>key</u> "rpi" is used to select which RPI to be used for trans‐
       porting MPI messages.  The <u>value</u> argument is the value that is passed.  For example:

       mpirun -ssi rpi lamd N foo
           Tells LAM to use the "lamd" RPI and to run a single copy of "foo" on every node.

       mpirun -ssi rpi tcp N foo
           Tells LAM to use the "tcp" RPI.

       mpirun -ssi rpi sysv N foo
           Tells LAM to use the "sysv" RPI.

       And so on.  LAM's RPI SSI modules are described in <a href="../man7/lamssi_rpi.7.html">lamssi_rpi</a>(7).

       The <u>-ssi</u> switch can be used multiple times to specify different <u>key</u> and/or <u>value</u> arguments.  If the  same
       <u>key</u> is specified more than once, the <u>value</u>s are concatenated with a comma (",") separating them.

       Note that the <u>-ssi</u> switch is simply a shortcut for setting environment variables.  The same effect may be
       accomplished by setting corresponding environment variables before running <u>mpirun</u>.  The form of the envi‐
       ronment variables that LAM sets are: <u>LAM_MPI_SSI_key=value</u>.

       Note that the <u>-ssi</u> switch overrides any previously set environment variables.  Also note that unknown <u>key</u>
       arguments are still set as environment variable -- they are not checked (by <u>mpirun</u>) for correctness.  Il‐
       legal or incorrect <u>value</u> arguments may or may not be reported -- it depends on the specific SSI module.

       The  <u>-ssi</u>  switch  obsoletes the old <u>-c2c</u> and <u>-lamd</u> switches.  These switches used to be relevant because
       LAM could only have two RPI's available at a time: the lamd RPI and one of the  C2C  RPIs.   This  is  no
       longer true -- all RPI's are now available and choosable at run-time.  Selecting the lamd RPI is shown in
       the  examples  above.   The  <u>-c2c</u> switch has no direct translation since "C2C" used to refer to all other
       RPI's that were not the lamd RPI.  As such, <u>-ssi</u> <u>rpi</u> <u>value</u> must be used to select  the  specific  desired
       RPI (whether it is "lamd" or one of the other RPI's).

   <b>Guaranteed</b> <b>Envelope</b> <b>Resources</b>
       By  default,  LAM  will guarantee a minimum amount of message envelope buffering to each MPI process pair
       and will impede or report an error to a process that attempts to overflow this system resource.  This ro‐
       bustness and debugging feature is implemented in a machine specific manner when direct  communication  is
       used.   For  normal  LAM communication via the LAM daemon, a protocol is used.  The <u>-nger</u> option disables
       GER and the measures taken to support it.  The minimum GER is configured by the system administrator when
       LAM is installed.  See <a href="../man7/MPI.7.html">MPI</a>(7) for more details.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Be sure to also see the examples in the "Location Nomenclature" section, above.

       mpirun N prog1
           Load and execute prog1 on all nodes.  Search the user's $PATH for the executable file on each node.

       mpirun -c 8 prog1
           Run 8 copies of prog1 wherever LAM wants to run them.

       mpirun n8-10 -v -nw -s n3 prog1 -q
           Load and execute prog1 on nodes 8, 9, and 10.  Search for prog1 on node 3  and  transfer  it  to  the
           three  target  nodes.   Report  as  each process is created.  Give "-q" as a command line to each new
           process.  Do not wait for the processes to complete before exiting <u>mpirun</u>.

       mpirun -v myapp
           Parse the application schema, myapp, and start all processes specified in it.  Report as each process
           is created.

       mpirun -npty -wd /work/output -x DISPLAY C my_application

           Start one copy of "my_application" on each available CPU.  The number of available CPUs on each  node
           was  previously  specified when LAM was booted with <a href="../man1/lamboot.1.html">lamboot</a>(1).  As noted above, <u>mpirun</u> will schedule
           adjoining rank in <u>MPI_COMM_WORLD</u> on the same node where possible.  For example, if n0 has a CPU count
           of 8, and n1 has a CPU count of 4, <u>mpirun</u> will place <u>MPI_COMM_WORLD</u> ranks 0 through 7 on  n0,  and  8
           through  11 on n1.  This tends to maximize on-node communication for many parallel applications; when
           used in conjunction with the multi-protocol network/shared memory RPIs in LAM (see the  RELEASE_NOTES
           and  INSTALL  files  with the LAM distribution), overall communication performance can be quite good.
           Also disable pseudo-tty support, change directory to /work/output, and export the DISPLAY variable to
           the new processes (perhaps my_application will invoke an X application such as xv to display output).

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       mpirun: Exec format error
           This usually means that either a number of processes or an appropriate where clause  was  not  speci‐
           fied,  indicating  that  LAM does not know how many processes to run.  See the EXAMPLES and "Location
           Nomenclature" sections, above, for examples on how to specify how many processes to run, and/or where
           to run them.  However, it can also mean that a non-ASCII character was detected  in  the  application
           schema.   This  is usually a command line usage error where <u>mpirun</u> is expecting an application schema
           and an executable file was given.

       mpirun: syntax error in application schema, line XXX
           The application schema cannot be parsed because of a usage or syntax error on the given line  in  the
           file.

       filename: No such file or directory
           This  error can occur in two cases.  Either the named file cannot be located or it has been found but
           the user does not have sufficient permissions to execute the program or read the application schema.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u>mpirun</u> returns 0 if all ranks started by <u>mpirun</u> exit after calling MPI_FINALIZE.  A non-zero value is re‐
       turned if an internal error occurred in mpirun, or one or more ranks exited before calling  MPI_FINALIZE.
       If an internal error occurred in mpirun, the corresponding error code is returned.  In the event that one
       or  more  ranks exit before calling MPI_FINALIZE, the return value of the rank of the process that <u>mpirun</u>
       first notices died before calling MPI_FINALIZE will be returned.  Note that, in general, this will be the
       first rank that died but is not guaranteed to be so.

       However, note that if the <u>-nw</u> switch is used, the return value from mpirun does  not  indicate  the  exit
       status of the ranks.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man5/bhost.5.html">bhost</a>(5), <a href="../man1/lamexec.1.html">lamexec</a>(1), <a href="../man7/lamssi.7.html">lamssi</a>(7), <a href="../man7/lamssi_rpi.7.html">lamssi_rpi</a>(7), <a href="../man1/lamtrace.1.html">lamtrace</a>(1), <a href="../man1/loadgo.1.html">loadgo</a>(1), <a href="../man2/MPIL_Trace_on.2.html">MPIL_Trace_on</a>(2), <a href="../man1/mpimsg.1.html">mpimsg</a>(1), mpi‐
       <a href="../man1/task.1.html">task</a>(1)

LAM 7.1.4                                          July, 2007                                          <u><a href="../man1/MPIRUN.1.html">MPIRUN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>