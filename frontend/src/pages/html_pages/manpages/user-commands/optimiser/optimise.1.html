<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>optimise - Yagi-Uda project antenna optimiser</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/yagiuda">yagiuda_1.19-12_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       optimise - Yagi-Uda project antenna optimiser

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>optimise</b> [ <b>-dhvwO</b> ] [ <b>-a</b><u>angular_stepsize</u> ] [ <b>-b</b><u>boom_extension</u> ] [ <b>-c</b><u>cleanliness_of_pattern</u> ] [ <b>-e</b><u>elements</u>
       ]   [   <b>-f</b><u>FBratio</u>   ]   [   <b>-g</b><u>GA_optimisation_method</u>   ]   <b>-l</b><u>percent</u>   ]  [  <b>-m</b><u>min_offset_from_peak</u>  ]  [
       <b>-o</b><u>optimisation_criteria</u> ] [ <b>-p</b><u>population</u>  ]  [  <b>-r</b><u>resistance</u>  ]  [  <b>-s</b><u>swr</u>  ]  [  <b>-t</b><u>length_tolerance</u>  ]  [
       <b>-x</b><u>reactance</u> ] [ <b>-A</b><u>Auto_gain</u> ] [ <b>-C</b><u>Currents_similar</u> ] [ <b>-F</b><u>weight_FB</u> ] [ <b>-G</b><u>weight_gain</u> ] [ <b>-K</b><u>keep_for_tries</u>
       ]  [  <b>-P</b><u>weight_pattern_cleanliness</u>  ] [ <b>-R</b><u>weight_resistance</u> ] [ <b>-S</b><u>weight_swr</u> ] [ <b>-T</b><u>position_tolerance</u> ] [
       <b>-W</b><u>Weighted_algorithm</u> ] [ <b>-X</b><u>weight_reactance</u> [ <b>-Z</b><u>Zo</u> ] filename iterations

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The program <b>optimise</b> is one of a number of executable programs that forms part  of  a  set  of  programs,
       collectively  known  as the <u>Yagi-Uda</u> <u>project</u> , which were designed for analysis and optimisation of Yagi-
       Uda antennas.  <u>optimise</u> attempts to optimise the performance of a Yagi antenna for one or more parameters
       that are considered important, such as gain, F/B ratio, VSWR etc. It does this by randomly  changing  the
       lengths  and  positions,  of  one  or  more elements, then comparing the performance before and after the
       change.  Any improvements are written to a new file called <u>filename.bes</u> where filename is the name of the
       antenna description file created by <u>input</u> or <u>first</u>

       When Yagi's are designed on paper, or  using  this  program,  its  possible  that  they  will  be  almost
       impossible  to build, if their performance depends too critically on the dimensions. To determine if this
       is the case with a design, we run optimise with just the options 't' and 'T'. These specify the tolerance
       with which you can build the antenna, expressed as a standard deviation in mm. In this case,  instead  of
       trying  to optimise a poor design, optimise will calculate the minimum gain, maximum VSWR, and minimum FB
       ratio of a number of designs, all slightly different from the input file. 99.7%  of  the  components  lie
       within  3  SD  of  the mean, so if you think you can cut elements to with 1 mm 99.7% of the time, specify
       t0.33. If you can put them in the boom to within 3 mm 99.7% of the time, specify T1.

       If while <u>optimise</u> is running using the methods that require weights to be attached to the gain,  FB,  SWR
       etc,  it  becomes  apparent, the weights are not optimum, its possible to pause the program and re-adjust
       the weights. If a file with the name of <u>changes</u> is created, the program  will  pause,  then  request  new
       weights are entered at the keyboard.

</pre><h4><b>AVAILABILITY</b></h4><pre>
</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-d</b>     Print  the  default  values of all the configureable parameters to stdout. Typing this option with
              any option that changes a parameter (see below) will display  the  new  value  of  the  parameter,
              rather than the default.

       <b>-h</b>     Print a help message.

       <b>-v</b>     Print verbose status information.

       <b>-w</b>     Instead  of  optimising at one fixed frequency (the design frequency), this directs the program to
              optimise at 3 separate frequencies (lowest, design and highest) then to average  data  at  all  3.
              This option is better for wideband antenna. Note that the input impedance printed is at the design
              frequency,  *not*  averaged  over  3 frequencies. Averaging an impedance, is likely to give a very
              misleading impression. The impedance averaged over 3 frequencies can be 50+i0 Ohms,  even  if  the
              VSWR is very poor over all 3 frequencies, as the following 3 pieces of data show.
              Z=147 + j 300  SWR= 15.46:1
              Z=2   + j 100  SWR= 125:1
              Z=1   - j 400  SWR= 3250:1
              note in the above three cases, the average impedance is 50 + j 0, but average SWR is 1130:1.

       <b>-O</b>     Over-optimisation  allowed.   By  default,  the  program  does  not over-optimise a parameter. For
              example, an SWR of 1.01 is usually considered good enough and any  change,  as  long  as  the  SWR
              stayed good, typically below 1.1:1, would be allowed, even if the SWR rose. By default, FB's of 27
              dB,  VSWR's  of  1.1  are  acceptable. However, by using the <b>-O</b> option, you can insist the program
              always improves things, no matter how good they are.

       <b>-a</b><u>Angular_stepsize</u>
              When optimimising by trying to get a clean pattern, specifies the step size to  use  when  looking
              for  features  in the pattern. If its set too small, the program  runs slow. If its set too large,
              the program may miss features in the pattern, such as a sidelobe. Then the resulting antenna  will
              have  poor  sidelobe  performance,  even though you think it will be good. The program attempts to
              calculate a sensible value, based on 1/10th the approximate 3 dB beamwidth, if you don't set.

       <b>-b</b><u>boom_extension</u>
              Generally speaking, the gain of a Yagi increases with boom length. Hence the optimiser would often
              give you a Yagi with a much longer boom than the input file. This may not be what you  desire  due
              to space restrictions. These long antennas often have high gain, but are very narrow in bandwidth.
              The  default  limits  the  antenna to 10x the original length, which means effectively there is no
              boom length limitation.  You can adjust the percentage by setting <u>boom_extension</u> to  whatever  you
              wish.  <u>-b30</u> will limit the boom to no more than 30% more than the original length.

       <b>-c</b><u>cleanliness_of_pattern</u>
              Specify  the  number  of  dB  down on the peak gain to aim to get the pattern. Any antenna pattern
              cleaner than this will not effect the fitness, nor will it be considered any better when comparing
              to antenna designs. 20 dB seems reasonable, so the default is 20, but this may of course change if
              it's deceided too. Check the source code to be certain (see REASONABLE_SIDELOBE in yagi.h).

       <b>-e</b><u>elements</u>
              is an integer which specifies the type of elements that are changed  in  the  optimisation  cycle.
              Possible values are:
               1 - alter only the driven element(s) length (useful to bring to resonance)
               2 - alter only the driven element position. Don't change its length.
               4 - alter only the reflector length. The position is always at x=0.
               8 - alter only the director lengths. Don't change positions.
               16 - alter only the director positions. Don't change lengths.
               32  -  randomly  adjust  one  element  length,  then  makes  all other the same. Don't change the
               positions.
               64 - apply a linear taper to the lengths.
               128 - Set the driven element to a resonate length. It may/may-not be altered after the first run,
               depending on the whether or not '1' is invoked too. Eg -e128 will make it resonate  and  keep  it
               there forever. However '-e129' will bring to resonance, then alter to maximuse performance.
              The  elements altered is made from a logical AND of the above, so for example to alter everything,
              except the driven element length, use -e30, since 2+4+8+16=30.  The  default is equivalent to <u>-e31</u>
              , which changes everything possible. Note the reflector position is *never* changed.  It's  always
              at x=0.

       <b>-f</b><u>FBratio</u>
              When  optimising  an antenna, consider any FB ratio greater than <u>FBratio</u> dB to be equal to <u>FBratio</u>
              dB. This avoids optimising to a very high FB ratio, which is impracticable, as the bandwidth  over
              which  this  FB  ratio will be maintained is very small and mechanical considerations will prevent
              you from constructing it with such a high FB ratio anyway. If this was not  prevented,  you  might
              just  happen  to  get an antenna with 100 dB FB ratio, but poor gain and swr. Since by default all
              parameters must improve, the optimisation routine will most likely never being able to improve  on
              the 100 dB FB ratio, so no improvement will result. Most people would prefer to get a few extra dB
              of gain, even if the FB ratio dropped to 30 dB.

       <b>-g</b><u>GA_optimisation_method</u>
              Use  a genetic algorithm. With the genetic algorithm, the program does not take any account any of
              the initial lengths/positions of elements  specified  in  the  input  file.  Rather  it  works  by
              initialising  a  number  of  different  antenna,  then  computing a 'fitness' value for each.  The
              fitness value can depend on the gain, FB, real part of the input impedance, reactive part  of  the
              input  impedance,  VSWR or the level of the sidelobes. The integer after the g tells the optimiser
              what to consider.  -g1  Use gain
              -g2  Use FB
              -g4  Use R
              -g8  Use X
              -g16 Use the SWR
              -g32 Use the level of the sidelobes.

              You can use a logical AND of these, so for example -g49 will use a genetic  algorithm,  optimising
              for gain, swr and sidelobe level, since 1(gain)+16(SWR)+32(sidelobe level)=49.

       <b>-l</b><u>percent</u>
              is  a  parameter  (floating  point  number)  which  specifies the maximum percentage change in the
              positions or lengths of an elements at each iteration. If the option is not used, it will  be  set
              internally at 10% for the first 25% of the iterations, 1% for the next 25%, 0.1% for the third 25%
              of  the iterations and 0.01% for the last 25% of the iterations. If set to a positive number x (eg
              optimise -l 0.3 145e10) then the percentage will be set at x% for 25% of iterations, x/10 for  the
              next  25%,  x/100  for  the next 25 and x/1000 for the last 25%. If set to a negative number y (eg
              optimise -l -0.5 145e10) then the parameters will stay fixed at y% (in this example 0.5%) all  the
              time.

       <b>-m</b><u>min_offset-from_peak</u>
              Sets the minimum angle in degrees offset from theta=90 degrees, where the side lobes start and the
              main lobe finishes. The higher the gain, the smaller it should be. It is set internally if not set
              on the command line.

       <b>-o</b><u>optimisation_criteria</u>
               1 -  Assume better if the gain has increased.
               2 -  Assume better if the front to back ratio has improved.
               4  -   Assume  better  if  the  real  part of the input impedance is closer to the value that the
               program was compiled for, or set using the '-Z' option.  This will usually be 50  Ohms,  but  you
               may  wish to set this to 12.5 Ohms if you use a 4:1 balun. Generally you can get higher gain from
               a Yagi if you allow the input impedance to fall, but of course feeding it becomes more difficult.
               8 -  Assume better if the magnitude of the reactive component of the  input  impedance  is  lower
               (ie. the antenna is nearer resonance).
               16 - Assume better if the VSWR is lower.
               32 - Assume better if the level of all sidelobes is lower.
              The  <u>optimisation_criteria</u>  may  be  formed  from  a  logical AND of these numbers, so for example
              choosing <u>-o19</u> will only consider a revised antenna better than the previous, if the SWR, gain  and
              F/B ratio have all simultaneously improved.

              Clearly  an antenna which originally had 12 dB gain and 1.01:1 VSWR but then changes to 20 dB gain
              @ 1.02:1 VSWR, would to most people be better, even though the VSWR  has  increased.  By  default,
              <u>optimise</u> only optimises to sensible maximums, so to not let the optimisation stall prematurely. By
              running  <u>optimise</u>  with  no  arguments,  the program will list the limits of acceptability.  These
              might be typically F/B ratio &gt; 27 dB, VSWR &lt; 1.1:1, magnitude of input reactance less than 5  Ohms
              and  the  real  part  of  the  input impedance within 5 Ohms of Zo. Choosing <u>-o19</u> (1+2+16=19) will
              optimise for gain (since G=1), FB (since FB=2) and SWR (Since SWR=16), but would consider a higher
              gain and FB ratio antenna better than a previous one, even if the SWR rose, as long as  it  stayed
              below  1.1:1  (or as was set during compilation). The default behaviour (no options) is equivalent
              to <u>-o37</u> which optimiseas for <a href="../man1/gain.1.html">gain</a>(1), the real part of the input  <a href="../man4/impedance.4.html">impedance</a>(4)  and  <a href="../man32/sidelobes.32.html">sidelobes</a>(32)
              but  this  may  be  changed at any time, so type <u>optimise</u> <u>-d</u> to check the current settings. If you
              insist on the program optimisang for the very best of all selected parameters, use the  -O  option
              too, but be warned the optimisation will probely stick once it gets one parameter really good.

       <b>-p</b><u>population</u>
              This determines the initial population used  with the genetic algorithm.

       <b>-r</b><u>resistance</u>
              When  optimising  an  antenna,  consider  any input resistance closer to Zo (usually 50 Ohms) than
              <u>resistance</u> Ohms to be acceptable. This avoids optimising to an input resistance too close  to  Zo,
              which  is  impracticable,  as the bandwidth over which the input resistance could be maintained is
              very small and mechanical considerations will prevent you from constructing the antenna with  such
              an ideal input resistance. If this was not prevented, you might just happen to get an antenna with
              an  input  resistance  of  50.000001  Ohms, but poor gain, FB and possibly even a poor swr, if the
              antenna is  well  away  from  resonance.  Since  by  default  all  parameters  must  improve,  the
              optimisation  routine  will get most likely never being able to improve on the antenna, whereas we
              might be happier with a few more dB gain, if the input resistance went to 50.1 Ohms. It should  be
              noted  that the default optimisation routine never uses the input resistance directly (only VSWR),
              so this option cant be used without the '-o'  option  to  optimise  for  other  than  the  default
              parameters (gain, VSWR and FB ratio).

       <b>-s</b><u>swr</u>  When  optimising  an  antenna,  consider  any  SWR  less  than  <u>swr</u> to be equal to <u>swr</u> This avoids
              optimising to a very low swr, which is impracticable, as the bandwidth over which such a  low  swr
              could  be  maintained  would  be  very  small  and mechanical considerations will prevent you from
              constructing such an antenna anyway. If this is was not prevented, you might just happen to get an
              antenna with an swr of 1.000000000001:1, but poor gain, FB ratio. Since by default all  parameters
              must  improve,  the  optimisation  routine  will  most  likely  never being able to improve on the
              antenna, even though in practice you would like to get a few extra dB of gain  if  the  SWR  would
              rise  to  1.02:1.  The default was equivalent to <u>-s1.1</u> but run <u>optimise</u> <u>-d</u> to display this and any
              other defaults.

       <b>-t</b><u>length_tolerance</u>
              <u>length_tolerance</u> is the standard deviation in mm of the accuracy with which you can cut  elements.
              Since  99.7%  of elements will be with 3 standard deviations of the mean length (stats theory says
              this), set -t0.2 if virtually all (well 99.7%) of elements are within 3x0.2=0.6 mm of the  correct
              length.  This option *must* be used with the '-T'  option and can't be used with any other options
              apart from '-Z', '-v' and '-d'.

       <b>-x</b><u>reactance</u>
              When optimising an antenna, consider any input reactance of less than <u>reactance</u> to  be  <u>reactance.</u>
              This avoids over optimising the reactance, at the expense of something else.

       <b>-A</b><u>auto_gain</u>
              When the <u>auto_gain</u> option is used. the program maximes the gain of the antenna (ignoring all other
              parameters  such as SWR, FB ratio etc) by adjusting the length (not position) of one element only.
              -A-1 will maximuse the gain, by adjusting the length of the reflector, -A0 will maximise the  gain
              by  adjusting  the  length  of the driven element. Its generally *not* a good idea to maximise the
              gain by adjusting the driven element, but the program lets you do it, but using  the  option  -A0.
              Using  -A1  will  maximise  gain  by  adjusting  the  length of the first director, -A2 the second
              director and so on, up to the last director. You must check carefully that the input impedance  in
              particular  does  not fall to silly values if you use this option. On a yagi with many elements (&gt;
              10 or so), you can pretty safely maximise the 8th or more director, but doing it on the reflector,
              driven element or early directors often leads to silly input impedances -  so  beware!   Note,  no
              matter  how  many  iterations you specify, this process is only done once.Its unlikely you will be
              able to do it again, without things going out of hand, but if you must  do  it,  you  must  re-run
              'optimise' again.

       <b>-C</b><u>currents_similar</u>
              If  this  option  is  used,  where  <u>currents_similar</u>  is an integer, the program looks to make the
              currents in the last <u>currents_similar</u> elements as similar as possible. It computes the sum of  the
              squares  of  the  deviations of the absolute values of the element currents from the mean. If this
              falls, and the criteria specified with the -W option is also satisfied, the antenna is  considered
              better.  If  <u>currents_similar</u>  is  three  less  than the number of directors, it tries to make the
              currents in the the directors (but ignoringing the first 3) all similar.  If  <u>currents_similar</u>  is
              equal  to  the  number  of directors, it tries to make all the directors have similar currents. If
              <u>currents_similar</u> is one more than the number of directors, it tries to make all the directors  and
              the reflector have similar currents. If <u>currents_similar</u> is equal to the total number of elements,
              then it fails with an error message.

       <b>-F</b><u>weight_FB</u>
              is  the floating point number (default 1.0) specifying the weight to attach to the FB ratio of the
              antenna when using the '-W' option, which calculates a fitness for the antenna  based  on  one  or
              more  parameters  (FB,  gain,  input  resistance,  input  reactance,  SWR,  cleanliness of antenna
              pattern). The '-F' option is similar to the options -G, -P, -R, -S, -X (which specify weights  for
              gain,  pattern  cleanliness, input resistance, SWR and input reactance).  When using the -W option
              the exact algorithm used to compute the fitness (and hence the effect of this parameter)  is  best
              checked  by  looking  at  the  source  code  (see perform.c). This is one area of constant program
              improvement/changes/development, so its difficult to say exactly the  effect  the  parameter  has.
              However,  increasing  the weight of a parameter (using the -F, -G, -R, -S or -X options) will make
              the associated parameter have a greater effect on the fitness.  However, unless you optimise for a
              high FB ratio with the -W option, then setting the -F option will have  no  effect.  For  example,
              setting  the  options -F2.5 -W1 is a complete waste of time. There you have used the -W1 option to
              optimise only for gain (see -W option section of man page) but have changed the weight of  the  FB
              ratio  from  its default 1.0 to 2.5. If you are not optimising for FB ratio, the weight you attach
              to it is irrelavent.

       <b>-G</b><u>weight_gain</u>
              is the floating point number (default 1.0) specifying the weight to attach  to  the  gain  of  the
              antenna  when  using  the  '-W' option, which calculates a fitness for the antenna based on one or
              more parameters (FB,  gain,  input  resistance,  input  reactance,  SWR,  cleanliness  of  antenna
              pattern).  The '-G' option is similar to the options -F, -P, -R, -S, -X (which specify weights for
              FB ratio, pattern cleanliness, input resistance, SWR and input  reactance).   When  using  the  -W
              option the exact algorithm used to compute the fitness (and hence the effect of this parameter) is
              best  checked  by looking at the source code (see perform.c). This is one area of constant program
              improvement/changes/development, so its difficult to say exactly the  effect  the  parameter  has.
              However,  increasing  the weight of a parameter (using the -F, -G, -R, -S or -X options) will make
              the associated parameter have a greater effect on the fitness.  However, unless you  optimise  for
              gain  with the -W option, then setting the -G option will have no effect. For example, setting the
              options -G2.5 -W2 is a complete waste of time. There you have used the -W2 option to optimise only
              for FB ratio (see -W option section of man page) but have changed the weight of the gain from  its
              default 1.0 to 2.5. If you are not optimising for gain, the weight you attach to it is irrelavent.

       <b>-K</b><u>keep_for_tries</u>
              <u>keep_for_tries</u>  is the number of tries for the optimise to persist using the original data file as
              the starting point for optimisation. By default it is 1, which means the program immediately looks
              from a new position once a better one is found. It is  theeoretically  possible  that  this  might
              result  in  a quick, but poor local maximum. If however, <u>keep_for_tries</u> is 1000, it will stay at a
              position for 1000 iterations after finding the last best result, before considering this to  be  a
              global optimum. Then it starts for the new position. In practice, I have found this option to make
              matters  worst  in most cases. It was added to avoid the local-minimum problem, but it appears the
              optimisation surface is pretty smooth, so it just slows the program, without gaining much. Anyway,
              it can stay as an option, but check the results with/without carefully before using extensively.

       <b>-P</b><u>pattern_cleanlyiness</u>
              is the floating point number (default 1.0) specifying the weight to attach to the cleanness of the
              antenna pattern when using the '-W' option, which calculates a fitness for the  antenna  based  on
              one  or  more parameters (FB, gain, input resistance, input reactance, SWR, cleanliness of antenna
              pattern). The '-P' option is similar to the options -F, -G, -R, -S, -X (which specify weights  for
              FB  ratio,  gain,  input resistance, SWR and input reactance).  When using the -W option the exact
              algorithm used to compute the fitness (and hence the effect of this parameter) is best checked  by
              looking   at   the   source   code   (see  perform.c).  This  is  one  area  of  constant  program
              improvement/changes/development, so its difficult to say exactly the  effect  the  parameter  has.
              However,  increasing  the weight of a parameter (using the -F, -G, -R, -S or -X options) will make
              the associated parameter have a greater effect on the fitness.  However, unless you optimise for a
              clean antenna pattern with the -W option, then setting the -P option  will  have  no  effect.  For
              example,  setting  the  options -P2.5 -W1 is a complete waste of time. There you have used the -W1
              option to optimise only for gain (see -W option section of man page) but have changed  the  weight
              of  the  pattern  cleanliness  from  its default 1.0 to 2.5. If you are not optimising for a clean
              radiation pattern, the weight you attach to it is irrelavent.  With  appropriate  use  of  the  -W
              option  (eg  -W49  for gain, SWR and a clean pattern), the computer program finds the level of the
              most significant sidelobe, wherever it may be outside the main bean. It then optimises  to  reduce
              this. The -P option tells it how much weight to put on reducing this sidelobe.

       <b>-R</b><u>weight_resistance</u>
              is  the  floating  point  number (default 1.0) specifying the weight to attach to the obtaining an
              input resistance close to Zo on the antenna when using the '-W' option, which calculates a fitness
              for the antenna based on one or more parameters (FB, gain, input resistance, input reactance, SWR,
              cleanliness of antenna pattern). The '-R' option is similar to the options  -F,  -G,  -P,  -S,  -X
              (which  specify  weights  for FB, gain, pattern cleanliness, SWR and input reactance).  When using
              the -W option the exact algorithm used to compute the  fitness  (and  hence  the  effect  of  this
              parameter)  is  best  checked  by  looking at the source code (see perform.c). This is one area of
              constant program improvement/changes/development, so its difficult to say exactly the  effect  the
              parameter  has.  However,  increasing  the  weight  of a parameter (using the -F, -G, -R, -S or -X
              options) will make  the associated parameter have a  greater  effect  on  the  fitness.   However,
              unless  you  optimise for an an input resistance close to Zo, with the -W option, then setting the
              -R option will have no effect. For example, setting the options -R2.5 -W1 is a complete  waste  of
              time.  There  you have used the -W1 option to optimise only for gain (see -W option section of man
              page) but have changed the weight of the resistance from its default 1.0 to 2.5. If  you  are  not
              optimising for an input resistance close to Zo, the weight you attach to it is irrelavent.

       <b>-S</b><u>weight_swr</u>
              is  the  floating  point  number  (default  1.0) specifying the weight to attach to the SWR of the
              antenna when using the '-W' option, which calculates a fitness for the antenna  based  on  one  or
              more  parameters  (FB,  gain,  input  resistance,  input  reactance,  SWR,  cleanliness of antenna
              pattern). The '-S' option is similar to the options -F, -G, -P, -R, -X (which specify weights  for
              FB,  gain,  pattern  cleanliness, input resistance and input reactance).  When using the -W option
              the exact algorithm used to compute the fitness (and hence the effect of this parameter)  is  best
              checked  by  looking  at  the  source  code  (see perform.c). This is one area of constant program
              improvement/changes/development, so its difficult to say exactly the  effect  the  parameter  has.
              However,  increasing  the weight of a parameter (using the -F, -G, -R, -S or -X options) will make
              the associated parameter have a greater effect on the fitness.  However, unless you  optimise  for
              SWR  with  the -W option, then setting the -S option will have no effect. For example, setting the
              options -S2.5 -W1 is a complete waste of time. There you have used the -W1 option to optimise only
              for gain (see -W option section of man page) but have changed the  weight  of  the  SWR  from  its
              default 1.0 to 2.5. If you are not optimising for SWR, the weight you attach to it is irrelavent.

       <b>-T</b><u>position_tolerance</u>
              <u>position_tolerance</u>  is  the  standard  deviation  in  mm  of  the  accuracy with which you can cut
              elements. Since 99.7% of elements will be with 3  standard  deviations  of  the  correct  position
              (stats theory says this), set -T2 if virtually all (well 99.7%) of elements are within 3x2=6 mm of
              the  correct  position.This option *must* be used with the '-t'  option and can't be used with any
              other options apart from '-Z', '-v' and '-d'.

       <b>-W</b><u>Weighted_algorithm</u>
              Try to get an antenna which is better according to a weighted combination  of  parameters,  rather
              than  require  them  all  to  improve.  The  integer  specifies  what  to consider in the weighted
              parameters.
              W1 Gain.
              W2 FB
              W4 R
              W8 X
              W16 SWR
              W32 SIDE_LOBE
              You can logically AND  these  together,  so  for  example  -W3  will  optimise  using  a  weighted
              combination  of gain and FB. -W49, will use a weighted combination of gain, swr and sidelobe leve,
              since 32+16+1=49.

       <b>-X</b><u>weight_reactance</u>
              is the floating point number (default 1.0) specifying the weight to  attach  to  achieving  a  low
              input  reactance  on  the  antenna  when using the '-W' option, which calculates a fitness for the
              antenna based on one or more  parameters  (FB,  gain,  input  resistance,  input  reactance,  SWR,
              cleanliness  of  antenna  pattern). The '-X' option is similar to the options -F, G, -P, -R and -S
              (which specify weights for FB ratio, gain, pattern cleanliness, input resistance, and SWR).   When
              using  the -W option the exact algorithm used to compute the fitness (and hence the effect of this
              parameter) is best checked by looking at the source code (see perform.c).  This  is  one  area  of
              constant  program  improvement/changes/development, so its difficult to say exactly the effect the
              parameter has. However, increasing the weight of a parameter (using the  -F,  -G,  -R,  -S  or  -X
              options)  will  make   the  associated  parameter  have a greater effect on the fitness.  However,
              unless you optimise for a low input reactance with the -W option, then setting the -X option  will
              have  no effect. For example, setting the options -X2.5 -W1 is a complete waste of time. There you
              have used the -W1 option to optimise only for gain (see -W option section of man  page)  but  have
              changed  the weight of the reactiance from its default 1.0 to 2.5. If you are not optimising for a
              low input reactance, the weight you attach to it is irrelavent.

       <b>-Z</b><u>Zo</u>
              <u>Zo</u> is the characteristic impedance used when evaluating the VSWR, reflection coefficient and other
              similar calculations. The optimiser usually tries to bring the input impedance of the  antenna  to
              this  value.  It is set by default to 50 Ohms, so the default is equivalent to <u>-Z50</u> but may be set
              to any positive number. Set to 12.5 Ohms if you are going to feed the antenna with  a  4:1  balun.
              Generally  speaking, the gain of a Yagi can be higher for low input impedances, but of course such
              antennas are more difficult to feed.

       <u>filename</u>
              This is the name of the file containing the antenna description. It is expected to be in a  format
              created  by  either <u>input</u> or <u>first</u> - two other programs in the <u>Yagi-Uda</u> <u>project.</u>  This is an ASCII
              text file.

       <u>iterations</u>
              is an integer specifying the number of iterations for the optimiser to perform to try to  get  the
              best  antenna. Time will limit the number you choose. 1000 iterations of a 1ele yagi takes about 5
              seconds, a 6ele approximately 60 seconds, an 11 element 350 seconds, a 20 element 1030 seconds,  a
              33ele 2440 seconds, a 50element 5400 seconds, 100ele 21320 seconds all on an old 25MHz 486 PC with
              no  external  cache.   When  using the <u>-A</u> option the <u>iterations</u> is automatically set internally so
              only one attempt is made.  When using the '-t' and '-T' options, <u>iterations</u> specifies  the  number
              of  iterations  to attempt to get a poorer design, to check the sensitivity of the design to small
              manufacturing tolerances.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Here are a number of examples of using <u>optimise.</u>

       1) optimise 5ele 1000

       Here the file 5ele will be optimised using the default system for  1000  iterations.  The  default  might
       typically  require gain, FB and SWR to all improve, but this may be changed at any time. In any case, the
       program tells you what its optimising for. By default the program will  only  optimise  to  the  selected
       parameters are good, not over-optimising any one at the detrement of the others.

       2) optimise -b30 -f50 -s2 5ele 1000

       This  is  similar  to  above,  but the boom can not extend by more than 30% from its  original length, FB
       ratios above 50 dB are considered acceptable, as are SWR's less than 2:1. The optimised resultant antenna
       is likely to have better FB ratio, but poorer SWR than in (1) above.

       3) optimise -o1 5ele 1000

       This will simply optimise 5ele for maximum forward gain. The resultant antenna may have a poor  FB  ratio
       and  is  likely  to  have  an  unacceptably  low  input impedance and hence high VSWR. This is not a very
       sensible method of optimisation.

       4) optimise -W49 -l7 5ele 10000

       This will optimise the file  5ele  using  for  10000  iterations.  It  will  require  that  the  weighted
       performance of the antenna in three important parameters (gain, sidelobe level and SWR) improves from one
       design  to  the  next.  One or two parameters can actually get worst from one design to the next, but the
       weighted performance is better. The positions of the elements or lengths of elements will not  change  by
       more than 7% in each iteration.

       5) optimise -g -S30 -G50 -F20 -p1500 5ele 10000

       This  will optimise the file 5ele using a genetic algorithm. 1500 antennas will be randomly designed. The
       performance of each of these will measured using a 'fitness' function, weighted 30% to SWR, 50%  to  gain
       and  20%  to FB ratio. The probability of breading from a pair of antennas is proportional to the fitness
       function.

       6) optimise -w atv_antenna 10000

       This will optimise the file atv_antenna for a best average performance over a  wide  band.  The  progrram
       calculates  the gain, FB and SWR at three frequencies, then computes an average (mean) performance of the
       antenna over the band. N iterations will take 3x as long to execute as N iterations on the  same  antenna
       without the '-w' option.

       7) optimise -t0.1 -T1  good_design 100

       This  will  take the file good_design and make 100 different antennas from it, to simulate the effects of
       building tolerances. Each element is assumed to be cut so that the mean error of all elements  is  0  mm,
       but  a  standard  deviation of 0.1 mm, so 68.4% of element lengths are within 0.1 mm, 95.4% within 0.2 mm
       and 99.7% with in 0.3 mm. The accuracy of placing elements along the boom is much lower, so here we  have
       specified  a  standard  deviation  of  1.0 mm, so 68.6% of elements are placed within 1 mm of the correct
       position, 95.4% within 2  mm  of  the  correct  position  etc.   The  program  will  report  the  *worst*
       performances  achieved.  If  the performance dips too mush, then you either need to build them better, or
       get a design that's less critical!

</pre><h4><b>STOPPING</b></h4><pre>
       <u>Optimise</u> will stop after the number of iterations specified in the parameter <u>iterations.</u>   It  will  also
       stop  if  a  file  <u>stop</u> exits in the current directory of the executable <u>optimise</u> This file can of course
       only be created using a multi-tasking operating system such as Unix. It is *not* advisable  to  stop  the
       program  by  hitting  the DEL key (Unix) or CONTROL-C (DOS), as one of the files may be open at the time,
       resulting in an empty file. Files are not open for any longer than necessary (they are closed immediately
       after writing to them), so this is not a likely occurrence, but can still occur.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       I'm not aware of any limitations, apart from  that  filenames,  including  full  path,  can't  exceed  90
       characters.

</pre><h4><b>FILES</b></h4><pre>
       filename           Antenna description, created by input or first.
       filename.up    Update file, listing achievements of optimise.
       filename.bes       Best file, containing the best design to date.
       changes         File that causes the program to pause to re-adjust weights.
       stop            File that stops optimisation process.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/first.1.html">first</a>(1), <a href="../man1/input.1.html">input</a>(1), <a href="../man1/output.1.html">output</a>(1), <a href="../man1/yagi.1.html">yagi</a>(1), <a href="../man5/first.5.html">first</a>(5), <a href="../man5/input.5.html">input</a>(5) <a href="../man5/output.5.html">output</a>(5) and <a href="../man5/optimise.5.html">optimise</a>(5).

</pre><h4><b>PLATFORMS</b></h4><pre>
       Both  DOS  and Unix versions have been built. The DOS version as distributed requires a 386 PC with a 387
       maths coprocessor.

       Although I have altered the source to make it more compatible with DOS (reduced file name  lengths  etc),
       my  wish  is  to  build a decent program, rather than fit the program to an outdated operating system. If
       there is a *good* reason to use code that is incompatible with DOS, this will be done.
       Since <u>optimise</u> takes  a while to optimise an antenna (I've optimised  one  design  for  a  week),  it  is
       obviously  more  sensible to build this program under a multi-tasking operating system, as otherwise a PC
       can be tied up for days.

</pre><h4><b>BUGS</b></h4><pre>
       Bugs should be reported to <b><a href="mailto:david.kirkby@onetel.net">david.kirkby@onetel.net</a></b>.  Bugs tend actually  to  be  fixed  if  they  can  be
       isolated, so it is in your interest to report them in such a way that they can be easily reproduced.

       The  program  will  dump  core  (crash) if asked to optimise a 1ele beam, without any arguments.  This is
       because a 1ele beam has no parasitic elements and by default the program only changes parasitic elements.

       Some of the options are not checked for sensible values, although most are now checked and report if they
       are out of range.

       If the user specifies very large manufacturing errors using the '-t' and '-T' options, its  possible  for
       elements  to  overlap  or  for  element lengths to become negative. This will cause numerical errors. Any
       reasonable values will not cause this.

       On long Yagi's (50 elements) optimise can go a bit silly. It can optimise say a 1296MHz Yagi to get 20 dB
       at 1296 MHz, but less than 0 dB at only 1 MHz away. Needs some thought!

       The level of the sidelobes is not computed with the GA or some other optimisation  types.  This  will  be
       corrected later.

       All those I don't know about.

</pre><h4><b>AUTHORS</b></h4><pre>
       Dr.  David  Kirkby  G8WRB  (<a href="mailto:david.kirkby@onetel.net">david.kirkby@onetel.net</a>).  with help with converting to DOS from Dr. Joe Mack
       NA3T (<a href="mailto:mack@fcrfv2.ncifcrf.gov">mack@fcrfv2.ncifcrf.gov</a>)

version 1.16                                     24 October 2000                                     <u><a href="../man1/OPTIMISE.1.html">OPTIMISE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>