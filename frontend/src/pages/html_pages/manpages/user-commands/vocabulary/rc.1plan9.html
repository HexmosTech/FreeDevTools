<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rc, cd, eval, exec, exit, flag, rfork, shift, wait, whatis, ., ~ - command language</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/9base">9base_6-14_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rc, cd, eval, exec, exit, flag, rfork, shift, wait, whatis, ., ~ - command language

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>rc</b> [ <b>-srdiIlxepvV</b> ] [ <b>-c</b> <b>command</b> ] [ <u>file</u> [ <u>arg</u> <u>...</u>  ]]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Rc</u>  is  the Plan 9 shell.  It executes command lines read from a terminal or a file or, with the <b>-c</b> flag,
       from <u>rc's</u> argument list.

   <b>Command</b> <b>Lines</b>
       A command line is a sequence of commands, separated by ampersands or semicolons (<b>&amp;</b> or <b>;</b>), terminated by a
       newline.  The commands are executed in sequence from left to right.  <u>Rc</u>  does  not  wait  for  a  command
       followed  by <b>&amp;</b> to finish executing before starting the following command.  Whenever a command followed by
       <b>&amp;</b> is executed, its process id is assigned to the <u>rc</u> variable <b>$apid</b>.  Whenever a command <u>not</u> followed by <b>&amp;</b>
       exits or is terminated, the <u>rc</u> variable <b>$status</b> gets the process's wait message (see <u><a href="../man3/wait.3.html">wait</a></u>(3)); it will be
       the null string if the command was successful.

       A long command line may be continued on subsequent lines by typing a backslash (<b>\</b>) followed by a newline.
       This sequence is treated as though it were a blank.  Backslash is not otherwise a special character.

       A number-sign (<b>#</b>) and any following characters up to (but not including) the next  newline  are  ignored,
       except in quotation marks.

   <b>Simple</b> <b>Commands</b>
       A simple command is a sequence of arguments interspersed with I/O redirections.  If the first argument is
       the  name  of an <u>rc</u> function or of one of <u>rc's</u> built-in commands, it is executed by <u>rc</u>.  Otherwise if the
       name starts with a slash (<b>/</b>), it must be the path name of the program to be executed.   Names  containing
       no  initial  slash  are  searched for in a list of directory names stored in <b>$path</b>.  The first executable
       file of the given name found in a directory in <b>$path</b> is the program to be executed.   To  be  executable,
       the  user must have execute permission (see <u><a href="../man3/stat.3.html">stat</a></u>(3)) and the file must be either an executable binary for
       the current machine's CPU type, or a shell script.  Shell scripts begin with a line containing  the  full
       path name of a shell (usually <b>/bin/rc</b>), prefixed by

       The  first  word of a simple command cannot be a keyword unless it is quoted or otherwise disguised.  The
       keywords are
            for in while if not switch fn ~ ! @

   <b>Arguments</b> <b>and</b> <b>Variables</b>
       A number of constructions may be used where <u>rc's</u> syntax requires an argument to appear.  In many cases  a
       construction's value will be a list of arguments rather than a single string.

       The simplest kind of argument is the unquoted word: a sequence of one or more characters none of which is
       a blank, tab, newline, or any of the following:
            # ; &amp; | ^ $ = ` ' { } ( ) &lt; &gt;
       An unquoted word that contains any of the characters <b>*</b> <b>?</b>  <b>[</b> is a pattern for matching against file names.
       The  character <b>*</b> matches any sequence of characters, <b>?</b>  matches any single character, and <b>[</b><u>class</u><b>]</b> matches
       any character in the <u>class</u>.  If the first character of <u>class</u> is <b>~</b>, the class is complemented.  The  <u>class</u>
       may  also  contain  pairs of characters separated by <b>-</b>, standing for all characters lexically between the
       two.  The character <b>/</b> must appear explicitly in a pattern, as must the first character of the  path  name
       components  <b>.</b>   and  <b>..</b>.   A  pattern is replaced by a list of arguments, one for each path name matched,
       except that a pattern matching no names is not replaced by the empty list, but rather stands for  itself.
       Pattern matching is done after all other operations.  Thus,
            x=<a href="file:/tmp">/tmp</a> echo $x^/*.c
       matches <b><a href="file:/tmp/">/tmp/</a>*.c</b>, rather than matching <b>/*.c</b> and then prefixing <b><a href="file:/tmp">/tmp</a></b>.

       A quoted word is a sequence of characters surrounded by single quotes (<b>'</b>).  A single quote is represented
       in a quoted word by a pair of quotes (<b>''</b>).

       Each of the following is an argument.
       <b>(</b><u>arguments</u><b>)</b>
              The  value  of a sequence of arguments enclosed in parentheses is a list comprising the members of
              each element of the sequence.  Argument lists have no recursive structure, although  their  syntax
              may suggest it.  The following are entirely equivalent:
                   echo hi there everybody
                   ((echo) (hi there) everybody)

       <b>$</b><u>argument</u>
       <b>$</b><u>argument</u><b>(</b><u>subscript</u><b>)</b>
              The <u>argument</u> after the <b>$</b> is the name of a variable whose value is substituted.  Multiple levels of
              indirection  are possible, but of questionable utility.  Variable values are lists of strings.  If
              <u>argument</u> is a number <u>n</u>, the value is the <u>n</u>th element of <b>$*</b>, unless <b>$*</b> doesn't have <u>n</u> elements,  in
              which case the value is empty.  If <u>argument</u> is followed by a parenthesized list of subscripts, the
              value  substituted  is a list composed of the requested elements (origin 1).  The parenthesis must
              follow the variable name with no spaces.  Subscripts can also take the form <u>m</u><b>-</b><u>n</u> or <u>m</u><b>-</b> to  indicate
              a sequence of elements.  Assignments to variables are described below.
       <b>$#</b><u>argument</u>
              The  value is the number of elements in the named variable.  A variable never assigned a value has
              zero elements.
       $"<u>argument</u>
              The value is a single string containing the components of the named variable separated by  spaces.
              A variable with zero elements yields the empty string.
       <b>`{</b><u>command</u><b>}</b>
              <u>rc</u>  executes  the  <u>command</u>  and  reads its standard output, splitting it into a list of arguments,
              using characters in <b>$ifs</b> as separators.  If <b>$ifs</b> is not otherwise set, its value is <b>'</b> <b>\t\n'</b>.
       <b>&lt;{</b><u>command</u><b>}</b>
       <b>&gt;{</b><u>command</u><b>}</b>
              The <u>command</u> is executed asynchronously with its standard output or standard input connected  to  a
              pipe.   The  value  of  the argument is the name of a file referring to the other end of the pipe.
              This allows the construction of  non-linear  pipelines.   For  example,  the  following  runs  two
              commands <b>old</b> and <b>new</b> and uses <b>cmp</b> to compare their outputs
                   cmp &lt;{old} &lt;{new}

       <u>argument</u><b>^</b><u>argument</u>
              The  <b>^</b>  operator  concatenates  its  two  operands.   If  the two operands have the same number of
              components, they are concatenated pairwise.  If not, then one operand must have one component, and
              the other must be non-empty, and concatenation is distributive.

   <b>Free</b> <b>Carets</b>
       In most circumstances, <u>rc</u> will insert the <b>^</b> operator automatically between words that are  not  separated
       by  white  space.   Whenever one of <b>$</b> <b>'</b> <b>`</b> follows a quoted or unquoted word or an unquoted word follows a
       quoted word with no intervening blanks or tabs, a <b>^</b> is inserted between the two.   If  an  unquoted  word
       immediately  follows  a  <b>$</b>  and contains a character other than an alphanumeric, underscore, or <b>*</b>, a <b>^</b> is
       inserted before the first such character.  Thus

              <b>cc</b> <b>-$flags</b> <b>$stem.c</b>

       is equivalent to

              <b>cc</b> <b>-^$flags</b> <b>$stem^.c</b>

   <b>I/O</b> <b>Redirections</b>
       The sequence <b>&gt;</b><u>file</u> redirects the standard output file (file descriptor 1, normally the terminal)  to  the
       named <u>file</u>; <b>&gt;&gt;</b><u>file</u> appends standard output to the file.  The standard input file (file descriptor 0, also
       normally  the  terminal)  may  be  redirected  from a file by the sequence <b>&lt;</b><u>file</u>, or from an inline `here
       document' by the sequence <b>&lt;&lt;</b><u>eof-marker</u>.  The contents of a here document are lines of text taken from the
       command input stream up to a line containing nothing but the <u>eof-marker</u>, which may be either a quoted  or
       unquoted word.  If <u>eof-marker</u> is unquoted, variable names of the form <b>$</b><u>word</u> have their values substituted
       from  <u>rc's</u>  environment.   If  <b>$</b><u>word</u>  is followed by a caret (<b>^</b>), the caret is deleted.  If <u>eof-marker</u> is
       quoted, no substitution occurs.

       Redirections may be applied to a file-descriptor other than standard input or output  by  qualifying  the
       redirection  operator  with  a  number  in  square  brackets.   For  example, the diagnostic output (file
       descriptor 2) may be redirected by writing <b>cc</b> <b>junk.c</b> <b>&gt;[2]junk</b>.

       A file descriptor may be redirected to an already open descriptor by writing  <b>&gt;[</b><u>fd0</u><b>=</b><u>fd1</u><b>]</b>  or  <b>&lt;[</b><u>fd0</u><b>=</b><u>fd1</u><b>]</b>.
       <u>Fd1</u>  is a previously opened file descriptor and <u>fd0</u> becomes a new copy (in the sense of <u><a href="../man3/dup.3.html">dup</a></u>(3)) of it.  A
       file descriptor may be closed by writing <b>&gt;[</b><u>fd0</u><b>=]</b> or <b>&lt;[</b><u>fd0</u><b>=]</b>.

       Redirections are executed from left to right.  Therefore, <b>cc</b>  <b>junk.c</b>  <b>&gt;/dev/null</b>  <b>&gt;[2=1]</b>  and  <b>cc</b>  <b>junk.c</b>
       <b>&gt;[2=1]</b>  <b>&gt;/dev/null</b>  have  different  effects:  the  first puts standard output in <b>/dev/null</b> and then puts
       diagnostic output in the same place, where the second directs diagnostic output to the terminal and sends
       standard output to <b>/dev/null</b>.

   <b>Compound</b> <b>Commands</b>
       A pair of commands separated by a pipe operator (<b>|</b>) is a  command.   The  standard  output  of  the  left
       command  is  sent  through  a  pipe to the standard input of the right command.  The pipe operator may be
       decorated to use different file descriptors.   <b>|[</b><u>fd</u><b>]</b>  connects  the  output  end  of  the  pipe  to  file
       descriptor  <u>fd</u>  rather than 1.  <b>|[</b><u>fd0</u><b>=</b><u>fd1</u><b>]</b> connects output to <u>fd1</u> of the left command and input to <u>fd0</u> of
       the right command.

       A pair of commands separated by <b>&amp;&amp;</b> or <b>||</b> is a command.  In either case, the left command is executed  and
       its  exit  status  examined.   If  the operator is <b>&amp;&amp;</b> the right command is executed if the left command's
       status is null.  <b>||</b> causes the right command to be executed if the left command's status is non-null.

       The exit status of a command may be inverted (non-null is changed to null, null is changed  to  non-null)
       by preceding it with a <b>!</b>.

       The  <b>|</b>  operator has highest precedence, and is left-associative (i.e. binds tighter to the left than the
       right).  <b>!</b>  has intermediate precedence, and <b>&amp;&amp;</b> and <b>||</b> have the lowest precedence.

       The unary <b>@</b> operator, with precedence equal to <b>!</b>, causes its operand to be executed in a subshell.

       Each of the following is a command.
       <b>if</b> <b>(</b> <u>list</u> <b>)</b> <u>command</u>
              A <u>list</u> is a sequence of commands, separated by <b>&amp;</b>, <b>;</b>, or newline.  It is executed and if  its  exit
              status is null, the <u>command</u> is executed.
       <b>if</b> <b>not</b> <u>command</u>
              The immediately preceding command must have been <b>if(</b><u>list</u><b>)</b> <u>command</u>.  If its condition was non-zero,
              the <u>command</u> is executed.
       <b>for(</b><u>name</u> <b>in</b> <u>arguments</u><b>)</b> <u>command</u>
       <b>for(</b><u>name</u><b>)</b> <u>command</u>
              The  <u>command</u>  is  executed  once  for  each  <u>argument</u> with that argument assigned to <u>name</u>.  If the
              argument list is omitted, <b>$*</b> is used.
       <b>while(</b><u>list</u><b>)</b> <u>command</u>
              The <u>list</u> is executed repeatedly until its exit status is non-null.   Each  time  it  returns  null
              status, the <u>command</u> is executed.  An empty <u>list</u> is taken to give null status.
       <b>switch(</b><u>argument</u><b>){</b><u>list</u><b>}</b>
              The <u>list</u> is searched for simple commands beginning with the word <b>case</b>.  (The search is only at the
              `top level' of the <u>list</u>.  That is, <b>cases</b> in nested constructs are not found.)  <u>Argument</u> is matched
              against each word following <b>case</b> using the pattern-matching algorithm described above, except that
              <b>/</b>  and  the first characters of <b>.</b>  and <b>..</b>  need not be matched explicitly.  When a match is found,
              commands in the list are executed up to the next following <b>case</b> command (at the top level) or  the
              closing brace.
       <b>{</b><u>list</u><b>}</b>
              Braces  serve  to  alter  the  grouping of commands implied by operator priorities.  The <u>body</u> is a
              sequence of commands separated by <b>&amp;</b>, <b>;</b>, or newline.
       <b>fn</b> <u>name</u><b>{</b><u>list</u><b>}</b>
       <b>fn</b> <u>name</u>
              The first form defines a function with the given <u>name</u>.  Subsequently,  whenever  a  command  whose
              first  argument  is  <u>name</u>  is  encountered,  the  current  value of the remainder of the command's
              argument list will be assigned to <b>$*</b>, after saving its current value,  and  <u>rc</u>  will  execute  the
              <u>list</u>.  The second form removes <u>name</u>'s function definition.
       <b>fn</b> <u>note</u><b>{</b><u>list</u><b>}</b>

       <b>fn</b> <u>note</u>
              A  function  with  a  special  name  will  be  called  when  <u>rc</u> receives a corresponding note; see
              <u><a href="../man3/notify.3.html">notify</a></u>(3).   The  valid  note  names  (and  corresponding  notes)  are  <b>sighup</b>  (<b>hangup</b>),   <b>sigint</b>
              (<b>interrupt</b>),  <b>sigalrm</b> (<b>alarm</b>), and <b>sigfpe</b> (floating point trap).  By default <u>rc</u> exits on receiving
              any signal, except when run interactively, in which case interrupts and quits normally cause <u>rc</u> to
              stop whatever it's doing and start reading a new command.  The second form causes <u>rc</u> to  handle  a
              signal  in the default manner.  <u>Rc</u> recognizes an artificial note, <b>sigexit</b>, which occurs when <u>rc</u> is
              about to finish executing.
       <u>name</u><b>=</b><u>argument</u> <u>command</u>
              Any command may be preceded by a sequence of  assignments  interspersed  with  redirections.   The
              assignments  remain  in effect until the end of the command, unless the command is empty (i.e. the
              assignments stand alone), in which case they are effective until rescinded by later assignments.

   <b>Built-in</b> <b>Commands</b>
       These commands are executed internally by <u>rc</u>, usually because their execution changes or depends on  <u>rc</u>'s
       internal state.
       <b>.</b> <u>file</u> <u>...</u>
              Execute  commands  from  <u>file</u>.   <b>$*</b>  is set for the duration to the remainder of the argument list
              following <u>file</u>.  <u>File</u> is searched for using <b>$path</b>.
       <b>builtin</b> <u>command</u> <u>...</u>
              Execute <u>command</u> as usual except that any function named <u>command</u> is ignored in favor of the  built-
              in meaning.
       <b>cd</b> <b>[</b><u>dir</u><b>]</b>
              Change  the current directory to <u>dir</u>.  The default argument is <b>$home</b>.  <u>dir</u> is searched for in each
              of the directories mentioned in <b>$cdpath</b>.
       <b>eval</b> <b>[</b><u>arg</u> <u>...</u><b>]</b>
              The arguments are concatenated separated by spaces into a single string, read as input to <u>rc</u>,  and
              executed.
       <b>exec</b> <b>[</b><u>command</u> <u>...</u><b>]</b>
              This instance of <u>rc</u> replaces itself with the given (non-built-in) <u>command</u>.
       <b>flag</b> <u>f</u> <b>[+-]</b>
              Either  set  (<b>+</b>),  clear (<b>-</b>), or test (neither <b>+</b> nor <b>-</b>) the flag <u>f</u>, where <u>f</u> is a single character,
              one of the command line flags (see Invocation, below).
       <b>exit</b> <b>[</b><u>status</u><b>]</b>
              Exit with the given exit status.  If none is given, the current value of <b>$status</b> is used.
       <b>rfork</b> [<b>nNeEsfFm</b>]
              Become a new process group using <b>rfork(</b><u>flags</u><b>)</b> where <u>flags</u> is composed of the  bitwise  OR  of  the
              <b>rfork</b> flags specified by the option letters (see <u><a href="../man2/fork.2.html">fork</a></u>(2)).  If no <u>flags</u> are given, they default to
              <b>ens</b>.   The <u>flags</u> and their meanings are: <b>n</b> is <b>RFNAMEG</b>; <b>N</b> is <b>RFCNAMEG</b>; <b>e</b> is <b>RFENVG</b>; <b>E</b> is <b>RFCENVG</b>; <b>s</b>
              is <b>RFNOTEG</b>; <b>f</b> is <b>RFFDG</b>; <b>F</b> is <b>RFCFDG</b>; and <b>m</b> is <b>RFNOMNT</b>.
       <b>shift</b> <b>[</b><u>n</u><b>]</b>
              Delete the first <u>n</u> (default 1) elements of <b>$*</b>.
       <b>wait</b> <b>[</b><u>pid</u><b>]</b>
              Wait for the process with the given <u>pid</u> to exit.  If no <u>pid</u> is given,  all  outstanding  processes
              are waited for.
       <b>whatis</b> <u>name</u> <u>...</u>
              Print  the  value of each <u>name</u> in a form suitable for input to <u>rc</u>.  The output is an assignment to
              any variable, the definition of any function, a call to <b>builtin</b> for any built-in command,  or  the
              completed pathname of any executable file.
       <b>~</b> <u>subject</u> <u>pattern</u> <u>...</u>
              The  <u>subject</u>  is  matched against each <u>pattern</u> in sequence.  If it matches any pattern, <b>$status</b> is
              set to zero.  Otherwise, <b>$status</b> is set to one.  Patterns are the same as for file name  matching,
              except  that <b>/</b> and the first character of <b>.</b>  and <b>..</b>  need not be matched explicitly.  The <u>patterns</u>
              are not subjected to file name matching before the <b>~</b> command is executed,  so  they  need  not  be
              enclosed in quotation marks.

   <b>Environment</b>
       The  <u>environment</u>  is a list of strings made available to executing binaries by the kernel.  <u>Rc</u> creates an
       environment entry for each variable whose value is non-empty, and for each function.  The  string  for  a
       variable  entry  has  the  variable's  name  followed by <b>=</b> and its value.  If the value has more than one
       component, these are separated by SOH (001) characters.  The string for a function is just the  <u>rc</u>  input
       that defines the function.  The name of a function in the environment is the function name preceded by

       When <u>rc</u> starts executing it reads variable and function definitions from its environment.

   <b>Special</b> <b>Variables</b>
       The following variables are set or used by <u>rc</u>.
       <b>$*</b>       Set  to  <u>rc</u>'s  argument  list  during  initialization.   Whenever  a <b>.</b>  command or a function is
                executed, the current value is saved and <b>$*</b> receives the new argument list.  The saved value  is
                restored on completion of the <b>.</b>  or function.
       <b>$apid</b>    Whenever a process is started asynchronously with <b>&amp;</b>, <b>$apid</b> is set to its process id.
       <b>$home</b>    The default directory for <b>cd</b>.
       <b>$ifs</b>     The  input  field  separators  used  in  backquote  substitutions.   If  <b>$ifs</b> is not set in <u>rc</u>'s
                environment, it is initialized to blank, tab and newline.
       <b>$path</b>    The search path used to find commands and input files for the <b>.</b>  command.  If  not  set  in  the
                environment,  it is initialized by parsing the <b>$PATH</b> variable (as in <u><a href="../man1/sh.1.html">sh</a></u>(1)) or by <b>path=(.</b> <b><a href="file:/bin">/bin</a>)</b>.
                The variables <b>$path</b> and <b>$PATH</b> are maintained together: changes to one will be reflected  in  the
                other.
       <b>$pid</b>     Set during initialization to <u>rc</u>'s process id.
       <b>$prompt</b>  When  <u>rc</u>  is  run  interactively,  the first component of <b>$prompt</b> is printed before reading each
                command.  The second component is printed whenever  a  newline  is  typed  and  more  lines  are
                required  to  complete  the  command.   If  not  set  in  the  environment, it is initialized by
                <b>prompt=('%</b> <b>'</b> <b>'</b> <b>')</b>.
       <b>$status</b>  Set to the wait message of the last-executed program.  (unless started with <b>&amp;).</b>  <b>!</b>  and  <b>~</b>  also
                change  <b>$status</b>.  Its value is used to control execution in <b>&amp;&amp;</b>, <b>||</b>, <b>if</b> and <b>while</b> commands.  When
                <u>rc</u> exits at end-of-file of its input or on executing an <b>exit</b> command with no  argument,  <b>$status</b>
                is its exit status.

   <b>Invocation</b>
       If  <u>rc</u>  is started with no arguments it reads commands from standard input.  Otherwise its first non-flag
       argument is the name of a file from which to read commands (but  see  <b>-c</b>  below).   Subsequent  arguments
       become the initial value of <b>$*</b>.  <u>Rc</u> accepts the following command-line flags.
       <b>-c</b> <u>string</u>  Commands are read from <u>string</u>.
       <b>-s</b>         Print out exit status after any command where the status is non-null.
       <b>-e</b>         Exit if <b>$status</b> is non-null after executing a simple command.
       <b>-i</b>         If  <b>-i</b>  is  present, or <u>rc</u> is given no arguments and its standard input is a terminal, it runs
                  interactively.  Commands are prompted for using <b>$prompt</b>.
       <b>-I</b>         Makes sure <u>rc</u> is not run interactively.
       <b>-l</b>         If <b>-l</b> is given or the  first  character  of  argument  zero  is  <b>-</b>,  <u>rc</u>  reads  commands  from
                  <b>$home/lib/profile</b>, if it exists, before reading its normal input.
       <b>-p</b>         A no-op.
       <b>-d</b>         A no-op.
       <b>-v</b>         Echo input on file descriptor 2 as it is read.
       <b>-x</b>         Print each simple command before executing it.
       <b>-r</b>         Print debugging information (internal form of commands as they are executed).

</pre><h4><b>SOURCE</b></h4><pre>
       <b>/src/cmd/rc</b>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Tom Duff, ``Rc - The Plan 9 Shell''.

</pre><h4><b>BUGS</b></h4><pre>
       There should be a way to match patterns against whole lists rather than just single strings.

       Using <b>~</b> to check the value of <b>$status</b> changes <b>$status</b>.

       Functions that use here documents don't work.

       Free carets don't get inserted next to keywords.

       The  <b>&lt;{</b><u>command</u><b>}</b> syntax depends on the underlying operating system providing a file descriptor device tree
       at <b><a href="file:/dev/fd">/dev/fd</a></b>.

       By default, FreeBSD 5 does not provide file descriptors greater than 2 in <b><a href="file:/dev/fd">/dev/fd</a></b>.  To fix this, add

              /fdescfs    <a href="file:/dev/fd">/dev/fd</a>    fdescfs    rw    0    0

       to <b><a href="file:/etc/fstab">/etc/fstab</a></b>, and then <b>mount</b> <b><a href="file:/dev/fd">/dev/fd</a></b>.  (Adding the line to <b>fstab</b> ensures causes  FreeBSD  to  mount  the
       file system automatically at boot time.)

                                                                                                      <u><a href="../man1plan9/RC.1plan9.html">RC</a></u>(1plan9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>