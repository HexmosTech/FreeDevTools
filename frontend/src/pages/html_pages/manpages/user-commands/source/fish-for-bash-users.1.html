<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fish spells command substitutions as $(command) or (command), but not `command`.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/fish-common">fish-common_4.0.1-1_all</a> <br><br><pre>
</pre><h4><b>COMMAND</b> <b>SUBSTITUTIONS</b></h4><pre>
       Fish spells command substitutions as <b>$(command)</b> or <b>(command)</b>, but not <b>`command`</b>.

       In addition, it only splits them on newlines instead of $IFS. If you want to split on something else, use
       <u>string</u> <u>split</u>, <u>string</u> <u>split0</u> or <u>string</u> <u>collect</u>. If those are  used  as  the  last  command  in  a  command
       substitution the splits they create are carried over. So:

          for i in (find . -print0 | string split0)

       will correctly handle all possible filenames.

</pre><h4><b>VARIABLES</b></h4><pre>
       Fish  sets  and  erases  variables  with  <u>set</u>  instead of <b>VAR=VAL</b> and a variety of separate builtins like
       <b>declare</b> and <b>unset</b> and <b>export</b>. <b>set</b> takes options to determine the scope and exportedness of a variable:

          # Define $PAGER *g*lobal and e*x*ported,
          # so this is like ``export PAGER=less``
          set -gx PAGER less

          # Define $alocalvariable only locally,
          # like ``local alocalvariable=foo``
          set -l alocalvariable foo

       or to erase variables:

          set -e PAGER

       <b>VAR=VAL</b> statements are available as environment overrides:

          PAGER=cat git log

       Fish does not perform word splitting. Once a variable has been set to a value, that value stays as it is,
       so double-quoting variable expansions isn't the necessity it is in bash. [1]

       For instance, here's bash

          &gt; foo="bar baz"
          &gt; printf '"%s"\n' $foo
          # will print two lines, because we didn't double-quote
          # this is word splitting
          "bar"
          "baz"

       And here is fish:

          &gt; set foo "bar baz"
          &gt; printf '"%s"\n' $foo
          # foo was set as one element,
          # so it will be passed as one element, so this is one line
          "bar baz"

       All variables are "arrays" (we use the term "lists"),  and  expanding  a  variable  expands  to  all  its
       elements, with each element as its own argument (like bash's <b>"${var[@]}"</b>:

          &gt; set var "foo bar" banana
          &gt; printf %s\n $var
          foo bar
          banana

       Specific elements of a list can be selected:

          echo $list[5..7]

       The arguments to <b>set</b> are ordinary, so you can also set a variable to the output of a command:

          # Set lines to all the lines in file, one element per line
          set lines (cat file)

       or a mixture of literal values and output:

          &gt; set numbers 1 2 3 (seq 5 8) 9
          &gt; printf '%s\n' $numbers
          1
          2
          3
          5
          6
          7
          8
          9

       A  <b>=</b> is unnecessary and unhelpful with <b>set</b> - <b>set</b> <b>foo</b> <b>=</b> <b>bar</b> will set the variable "foo" to two values: "="
       and "bar". <b>set</b> <b>foo=bar</b> will print an error.

       See <u>Shell</u> <u>variables</u> for more.

       [1]  zsh also does not perform word splitting by default (the SH_WORD_SPLIT option controls this)

</pre><h4><b>WILDCARDS</b> <b>(GLOBS)</b></h4><pre>
       Fish only supports the <b>*</b> and <b>**</b> glob (and the deprecated <b>?</b> glob) as syntax. If a glob  doesn't  match  it
       fails the command (like with bash's <b>failglob</b>) unless the command is <b>for</b>, <b>set</b> or <b>count</b> or the glob is used
       with  an  environment  override  (<b>VAR=*</b>  <b>command</b>),  in which case it expands to nothing (like with bash's
       <b>nullglob</b> option).

       Globbing doesn't happen on expanded variables, so:

          set foo "*"
          echo $foo

       will not match any files.

       There are no options to control globbing so it always behaves like that.

       The <b>**</b> glob will match in subdirectories as well. In other shells this often needs to be turned  on  with
       an option, like <b>setopt</b> <b>globstar</b> in bash.

       Unlike  bash,  fish will also follow symlinks, and will sort the results in a natural sort, with included
       numbers compared as numbers. That means it will sort e.g.  music  tracks  correctly  even  if  they  have
       numbers like <b>1</b> instead of <b>01</b>.

       See <u>Wildcards</u> for more.

</pre><h4><b>QUOTING</b></h4><pre>
       Fish  has  two quoting styles: <b>""</b> and <b>''</b>. Variables are expanded in double-quotes, nothing is expanded in
       single-quotes.

       There is no <b>$''</b>, instead the sequences that would transform are transformed <u>when</u> <u>unquoted</u>:

          &gt; echo a\nb
          a
          b

       See <u>Quotes</u> for more.

</pre><h4><b>STRING</b> <b>MANIPULATION</b></h4><pre>
       Fish does not have <b>${foo%bar}</b>, <b>${foo#bar}</b> and <b>${foo/bar/baz}</b>. Instead string manipulation is done by  the
       <u>string</u> builtin.

       For example, to replace "bar" with "baz":

          &gt; string replace bar baz "bar luhrmann"
          baz luhrmann

       It can also split strings:

          &gt; string split "," "foo,bar"
          foo
          bar

       Match regular expressions as a replacement for <b>grep</b>:

          &gt; echo bababa | string match -r 'aba$'
          aba

       Pad strings to a given width, with arbitrary characters:

          &gt; string pad -c x -w 20 "foo"
          xxxxxxxxxxxxxxxxxfoo

       Make strings lower/uppercase:

          &gt; string lower Foo
          foo

          &gt; string upper Foo
          FOO

       repeat strings, trim strings, escape strings or print a string's length or width (in terminal cells).

</pre><h4><b>SPECIAL</b> <b>VARIABLES</b></h4><pre>
       Some bash variables and their closest fish equivalent:

       • <b>$*</b>, <b>$@</b>, <b>$1</b> and so on: <b>$argv</b>

       • <b>$?</b>: <b>$status</b>

       • <b>$$</b>: <b>$fish_pid</b>

       • <b>$#</b>: No variable, instead use <b>count</b> <b>$argv</b>

       • <b>$!</b>: <b>$last_pid</b>

       • <b>$0</b>: <b>status</b> <b>filename</b>

       • <b>$-</b>: Mostly <b>status</b> <b>is-interactive</b> and <b>status</b> <b>is-login</b>

</pre><h4><b>PROCESS</b> <b>SUBSTITUTION</b></h4><pre>
       Instead of <b>&lt;(command)</b> fish uses <b>(command</b> <b>|</b> <b>psub)</b>. There is no equivalent to <b>&gt;(command)</b>.

       Note that both of these are bashisms, and most things can easily be expressed without. E.g. instead of:

          source (command | psub)

       just use:

          command | source

       as fish's <u>source</u> can read from stdin.

</pre><h4><b>HEREDOCS</b></h4><pre>
       Fish does not have <b>&lt;&lt;EOF</b> "heredocs". Instead of

          cat &lt;&lt;EOF
          some string
          some more string
          EOF

       use:

          printf %s\n "some string" "some more string"

       or:

          echo "some string
          some more string"

          # or if you want the quotes on separate lines:

          echo "\
          some string
          some more string\
          "

       Quotes are followed across newlines.

       What "heredocs" do is:

       1. Read/interpret the string, with special rules, up to the terminator. [2]

       2. Write the resulting string to a temporary file.

       3. Start the command the heredoc is attached to with that file as stdin.

       This means it is essentially the same as just reading from a pipe, so:

          echo "foo" | cat

       is mostly the same as

          cat &lt;&lt;EOF
          foo
          EOF

       Just  like  with  heredocs,  the  command  has to be prepared to read from stdin. Sometimes this requires
       special options to be used, often giving a filename of <b>-</b> turns it on.

       For example:

          echo "xterm
          rxvt-unicode" | pacman --remove -

          # is the same as (the `-` makes pacman read arguments from stdin)
          pacman --remove xterm rxvt-unicode

       and could be written in other shells as

          # This "-" is still necessary - the heredoc is *also* passed over stdin!
          pacman --remove - &lt;&lt; EOF
          xterm
          rxvt-unicode
          EOF

       So heredocs really are just minor syntactical sugar that introduces a lot of special rules, which is  why
       fish doesn't have them. Pipes are a core concept, and are simpler and compose nicer.

       [2]  For  example,  the  "EOF" is just a convention, the terminator can be an arbitrary string, something
            like "THISISTHEEND" also  works.  And  using  <b>&lt;&lt;-</b>  trims  leading  <u>tab</u>  characters  (but  not  other
            whitespace),  so  you  can indent the lines, but only with tabs. Substitutions (variables, commands)
            are done on the heredoc by default, but not if the terminator is quoted: <b>cat</b> <b>&lt;&lt;</b> <b>"EOF"</b>.

</pre><h4><b>TEST</b> <b>(TEST,</b> <b>[,</b> <b>[[)</b></h4><pre>
       Fish has a POSIX-compatible <b>test</b> or <b>[</b> builtin. There is no <b>[[</b> and <b>test</b> does not accept <b>==</b>  as  a  synonym
       for <b>=</b>. It can compare floating point numbers, however.

       <b>set</b> <b>-q</b> can be used to determine if a variable exists or has a certain number of elements (<b>set</b> <b>-q</b> <b>foo[2]</b>).

</pre><h4><b>ARITHMETIC</b> <b>EXPANSION</b></h4><pre>
       Fish does not have <b>$((i+1))</b> arithmetic expansion, computation is handled by <u>math</u>:

          math $i + 1

       Unlike bash's arithmetic, it can handle floating point numbers:

          &gt; math 5 / 2
          2.5

       And also has some functions, like for trigonometry:

          &gt; math cos 2 x pi
          1

       You  can  pass arguments to <b>math</b> separately like above or in quotes. Because fish uses <b>()</b> parentheses for
       <u>command</u> <u>substitutions</u>, quoting is needed if you want to use them in your expression:

          &gt; math '(5 + 2) * 4'

       Both <b>*</b> and <b>x</b> are valid ways to spell multiplication, but <b>*</b> needs to be quoted because  it  looks  like  a
       <u>glob</u>.

</pre><h4><b>PROMPTS</b></h4><pre>
       Fish does not use the <b>$PS1</b>, <b>$PS2</b> and so on variables. Instead the prompt is the output of the <u>fish_prompt</u>
       function,  plus  the <u>fish_mode_prompt</u> function if <u>vi</u> <u>mode</u> is enabled. The output of the <u>fish_right_prompt</u>
       function is used for the right-sided prompt.

       As an example, here's a relatively simple bash prompt:

          # &lt;$HOSTNAME&gt; &lt;$PWD in blue&gt; &lt;Prompt Sign in Yellow&gt; &lt;Rest in default light white&gt;
          PS1='\h\[\e[1;34m\]\w\[\e[m\] \[\e[1;32m\]\$\[\e[m\] '

       and a rough fish equivalent:

          function fish_prompt
              set -l prompt_symbol '$'
              fish_is_root_user; and set prompt_symbol '#'

              echo -s (prompt_hostname) \
              (set_color blue) (prompt_pwd) \
              (set_color yellow) $prompt_symbol (set_color normal)
          end

       This shows a few differences:

       • Fish provides <u>set_color</u> to color text. It can use the 16 named colors and also RGB  sequences  (so  you
         could also use <b>set_color</b> <b>5555FF</b>)

       • Instead  of  introducing specific escapes like <b>\h</b> for the hostname, the prompt is simply a function. To
         achieve the effect of <b>\h</b>, fish provides helper functions like <u>prompt_hostname</u>, which prints a shortened
         version of the hostname.

       • Fish offers other helper functions for adding things to the prompt, like <u>fish_vcs_prompt</u> for  adding  a
         display  for  common  version  control  systems  (git,  mercurial,  svn),  and <u>prompt_pwd</u> for showing a
         shortened <b>$PWD</b> (the user's home directory becomes <b>~</b> and any path component is shortened).

       The default prompt is reasonably full-featured and its code can be read via <b>type</b> <b>fish_prompt</b>.

       Fish does not have <b>$PS2</b> for continuation lines, instead it leaves the lines indented  to  show  that  the
       commandline isn't complete yet.

</pre><h4><b>BLOCKS</b> <b>AND</b> <b>LOOPS</b></h4><pre>
       Fish's blocking constructs look a little different. They all start with a word, end in <b>end</b> and don't have
       a second starting word:

          for i in 1 2 3; do
             echo $i
          done

          # becomes

          for i in 1 2 3
             echo $i
          end

          while true; do
             echo Weeee
          done

          # becomes

          while true
             echo Weeeeeee
          end

          {
             echo Hello
          }

          # becomes

          begin
             echo Hello
          end

          if true; then
             echo Yes I am true
          else
             echo "How is true not true?"
          fi

          # becomes

          if true
             echo Yes I am true
          else
             echo "How is true not true?"
          end

          foo() {
             echo foo
          }

          # becomes

          function foo
              echo foo
          end

          # (bash allows the word "function",
          #  but this is an extension)

       Fish does not have an <b>until</b>. Use <b>while</b> <b>not</b> or <b>while</b> <b>!</b>.

</pre><h4><b>SUBSHELLS</b></h4><pre>
       Bash has a feature called "subshells", where it will start another shell process for certain things. That
       shell  will  then  be independent and e.g. any changes it makes to variables won't be visible in the main
       shell.

       This includes things like:

          # A list of commands in `()` parentheses
          (foo; bar) | baz

          # Both sides of a pipe
          foo | while read -r bar; do
              # This will not be visible outside of the loop.
              VAR=VAL
              # This background process will not be, either
              baz &amp;
          done

       Fish does not currently have subshells. You will have to find a different  solution.  The  isolation  can
       usually  be  achieved by just scoping variables (with <b>set</b> <b>-l</b>), but if you really do need to run your code
       in a new shell environment you can use <b>fish</b> <b>-c</b> <b>'your</b> <b>code</b> <b>here'</b> to do so explicitly.

       <b>()</b> subshells are often confused with <b>{}</b> grouping, which does <u>not</u> use a subshell. When you  just  need  to
       group, you can use <b>begin;</b> <b>end</b> in fish:

          (foo; bar) | baz
          # when it should really have been:
          { foo; bar; } | baz
          # becomes
          begin; foo; bar; end | baz

       The pipe will simply be run in the same process, so <b>while</b> <b>read</b> loops can set variables outside:

          foo | while read bar
              set -g VAR VAL
              baz &amp;
          end

          echo $VAR # will print VAL
          jobs # will show "baz"

       Subshells  are  also  frequently  confused  with <u>command</u> <u>substitutions</u>, which bash writes as <b>`command`</b> or
       <b>$(command)</b> and fish writes as <b>$(command)</b> or <b>(command)</b>. Bash also <u>uses</u> subshells to implement them.

</pre><h4><b>BUILTINS</b> <b>AND</b> <b>OTHER</b> <b>COMMANDS</b></h4><pre>
       By now it has become apparent that fish puts much more of a focus on its builtins and  external  commands
       rather than its syntax. So here are some helpful builtins and their rough equivalent in bash:

       • <u>string</u>  - this replaces most of the string transformation (<b>${i%foo}</b> et al) and can also be used instead
         of <b>grep</b> and <b>sed</b> and such.

       • <u>math</u> - this replaces <b>$((i</b> <b>+</b> <b>1))</b> arithmetic and can also do floats and some simple functions  (sine  and
         friends).

       • <u>argparse</u>  -  this  can  handle a script's option parsing, for which bash would probably use <b>getopt</b> (zsh
         provides <b>zparseopts</b>).

       • <u>count</u> can be used to count things and therefore replaces <b>$#</b> and can be used instead of <b>wc</b>.

       • <u>status</u> provides information about the shell status, e.g.  if  it's  interactive  or  what  the  current
         linenumber is. This replaces <b>$-</b> and <b>$BASH_LINENO</b> and other variables.

       • <b><a href="../man1/seq.1.html">seq</a>(1)</b>  can  be  used  as a replacement for <b>{1..10}</b> range expansion. If your OS doesn't ship a <b>seq</b> fish
         includes a replacement function.

</pre><h4><b>OTHER</b> <b>FACILITIES</b></h4><pre>
       Bash has <b>set</b> <b>-x</b> or <b>set</b> <b>-o</b> <b>xtrace</b> to print all commands that are being executed. In fish,  this  would  be
       enabled by setting <u>fish_trace</u>.

       Or,  if  your  intention is to <u>profile</u> how long each line of a script takes, you can use <b>fish</b> <b>--profile</b> -
       see the <u>page</u> <u>for</u> <u>the</u> <u>fish</u> <u>command</u>.

</pre><h4><b>AUTHOR</b></h4><pre>
       fish-shell developers

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2024, fish-shell developers

4.0                                               Mar 13, 2025                            <u><a href="../man1/FISH-FOR-BASH-USERS.1.html">FISH-FOR-BASH-USERS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>