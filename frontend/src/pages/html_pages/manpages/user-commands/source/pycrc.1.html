<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pycrc - a free, easy to use Cyclic Redundancy Check (CRC) calculator and C source code generator.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/pycrc">pycrc_0.10.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pycrc - a free, easy to use Cyclic Redundancy Check (CRC) calculator and C source code generator.

</pre><h4><b>SYNOPSIS</b></h4><pre>

       <b>python</b> <b>pycrc.py</b> [OPTIONS]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>pycrc</b>[1] is a CRC reference implementation in Python and a C source code generator for parametrised CRC
       models. The generated C source code can be optimised for simplicity, speed or small memory footprint, as
       required on small embedded systems. The following operations are implemented:

       •   calculate the checksum of a string (ASCII or hex)

       •   calculate the checksum of a file

       •   generate the header and source files for a C implementation.

       pycrc supports the following variants of the CRC algorithm:

       •   <u>bit-by-bit</u> or <u>bbb</u>: the basic algorithm which operates individually on every bit of the augmented
           message (i.e. the input data with <u>Width</u> zero bits added at the end). This algorithm is a
           straightforward implementation of the basic polynomial division and is the easiest one to understand,
           but it is also the slowest one among all possible variants.

       •   <u>bit-by-bit-fast</u> or <u>bbf</u>: a variation of the simple <u>bit-by-bit</u> algorithm. This algorithm still iterates
           over every bit of the message, but does not augment it (does not add <u>Width</u> zero bits at the end). It
           gives the same result as the <u>bit-by-bit</u> method by carefully choosing the initial value of the
           algorithm. This method might be a good choice for embedded platforms, where code space is more
           important than execution speed.

       •   <u>table-driven</u> or <u>tbl</u>: the standard table driven algorithm. This is the fastest variant because it
           operates on one byte at a time, as opposed to one bit at the time. This method uses a look-up table
           (usually of 256 elements), which might not be acceptable for small embedded systems. The number of
           elements in the look-up table can be reduced with the <b>--table-idx-width</b> command line switch. The
           value of 4 bits for the table index (16 elements in the look-up table) can be a good compromise
           between execution speed and code size.

           The <b>--slice-by</b> option enables a variant of the <u>table-driven</u> algorithm that operates on 32 bits of
           data or more at a time rather than 8 bits. This can dramatically speed-up the calculation of the CRC,
           at the cost of increased code and data size.  <u>Note</u>: this option is experimental and not well-tested.
           Check your results and please raise bugs if you find problems.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>--version</b>
           show the program version number and exit.

       <b>-h</b>, <b>--help</b>
           show this help message and exit.

       <b>--verbose</b>
           be more verbose; in particular, print the value of the parameters and the chosen model to stdout.

       <b>--check-string=</b><u>STRING</u>
           calculate the checksum of a string (default: “<u>123456789</u>”). If the string contains non-ASCII
           characters then it will be UTF-8 decoded.

       <b>--check-hexstring=</b><u>STRING</u>
           calculate the checksum of a hexadecimal number string.

       <b>--check-file=</b><u>FILE</u>
           calculate the checksum of a file. If the file contains non-ASCII characters then it will be UTF-8
           decoded.

       <b>--generate=</b><u>CODE</u>
           generate C source code; choose the type from {<u>h</u>, <u>c</u>, <u>c-main</u>, <u>table</u>}.

       <b>--std=</b><u>STD</u>
           specify the C dialect of the generated code from {C89, ANSI, C99}.

       <b>--algorithm=</b><u>ALGO</u>
           choose an algorithm from {<u>bit-by-bit</u>, <u>bbb</u>, <u>bit-by-bit-fast</u>, <u>bbf</u>, <u>table-driven</u>, <u>tbl</u>, <u>all</u>}.

       <b>--model=</b><u>MODEL</u>
           choose a parameter set from {<u>crc-5</u>, <u>crc-8</u>, <u>dallas-1-wire</u>, <u>crc-12-3gpp</u>, <u>crc-15</u>, <u>crc-16</u>, <u>crc-16-usb</u>,
           <u>crc-16-modbus</u>, <u>crc-16-genibus</u>, <u>crc-16-ccitt</u>, <u>r-crc-16</u>, <u>kermit</u>, <u>x-25</u>, <u>xmodem</u>, <u>zmodem</u>, <u>crc-24</u>, <u>crc-32</u>,
           <u>crc-32c</u>, <u>crc-32-mpeg</u>, <u>crc-32-bzip2</u>, <u>posix</u>, <u>jam</u>, <u>xfer</u>, <u>crc-64</u>, <u>crc-64-jones</u>, <u>crc-64-xz</u>}.

       <b>--width=</b><u>NUM</u>
           use <u>NUM</u> bits in the <u>Polynomial</u>.

       <b>--poly=</b><u>HEX</u>
           use <u>HEX</u> as <u>Polynomial</u>.

       <b>--reflect-in=</b><u>BOOL</u>
           reflect the octets in the input message.

       <b>--xor-in=</b><u>HEX</u>
           use <u>HEX</u> as initial value.

       <b>--reflect-out=</b><u>BOOL</u>
           reflect the resulting checksum before applying the XorOut value.

       <b>--xor-out=</b><u>HEX</u>
           xor the final CRC value with <u>HEX</u>.

       <b>--slice-by=</b><u>NUM</u>
           speed-up the table-driven calculation by operating on <u>NUM</u> octets of data rather than a single octet
           at a time.  <u>NUM</u> must be one of the values {<u>4</u>, <u>8</u>, <u>16</u>}.

       <b>--table-idx-width=</b><u>NUM</u>
           use <u>NUM</u> bits to index the CRC table; <u>NUM</u> must be one of the values {<u>1</u>, <u>2</u>, <u>4</u>, <u>8</u>}.

       <b>--force-poly</b>
           override any errors about possibly unsuitable polynoms. pycrc does not allow even polynoms or
           polynoms that are wider than Width. Use this option to override the error, if you know what you are
           doing.

       <b>--symbol-prefix=</b><u>STRING</u>
           when generating source code, use <u>STRING</u> as prefix to the exported C symbols.

       <b>--crc-type=</b><u>STRING</u>
           when generating source code, use <u>STRING</u> as crc_t type.

       <b>--include-file=</b><u>FILE</u>
           when generating source code, include also <u>FILE</u> as header file. This option can be specified multiple
           times.

       <b>-o</b><u>FILE</u>, <b>--output=</b><u>FILE</u>
           write the generated code to <u>FILE</u> instead of stdout.

</pre><h4><b>THE</b> <b>CRC</b> <b>PARAMETRIC</b> <b>MODEL</b></h4><pre>
       The parametric model follows Ross N. Williams' convention described in <b>A</b> <b>Painless</b> <b>Guide</b> <b>to</b> <b>CRC</b> <b>Error</b>
       <b>Detection</b> <b>Algorithms</b>[2], often called the Rocksoft Model. Since most people are familiar with this kind
       of parameters, pycrc follows this convention, described as follows:

       <u>Width</u>
           The number of significant bits in the CRC <u>Polynomial</u>, excluding the most significant 1. This will
           also be the number of bits in the final CRC result. In previous versions of pycrc only multiples of 8
           could be used as <u>Width</u> for the <u>table-driven</u> algorithm. As of version 0.7.5 any value is accepted for
           <u>Width</u> for all algorithms.

       <u>Polynomial</u>
           The unreflected polynomial of the CRC algorithm.

           The <u>Polynomial</u> may be specified in its standard form, i.e. with bit <u>Width</u>+1 set to 1, but the most
           significant bit may also be omitted. For example, both numbers 0x18005 and 0x8005 are accepted for a
           16-bit <u>Polynomial</u>.

           Most polynomials used in real world applications are odd (the least significant bit is 1), but there
           are some good even ones. pycrc allows the use of even polynomials with the <b>--force-poly</b> option. Some
           even polynomials may yield incorrect checksums depending on the used algorithm. Use at your own risk
           and if at all possible use a well-known <u>MODEL</u> above.

       <u>ReflectIn</u>
           Reflect the octets of the message before processing them.

           A word is reflected or reversed by “flipping” its bits around the mid-point of the word. The most
           significant bit of the word is moved to the least significant position, the second-most significant
           bit is moved to the second-least significant position and so on. The reflected value of 0xa2
           (10100010b) is 0x45 (01000101b), for example.

           Some CRC algorithms can be implemented more efficiently in a bit reversed version, that's why many of
           the standard CRC models use reflected input octets.

       <u>XorIn</u>
           The initial value (usually all 0 or all 1) for algorithms which operate on the non-augmented message,
           that is, any algorithm other than the <u>bit-by-bit</u> one. This value can be interpreted as a value which
           will be XOR-ed into the CRC register after <u>Width</u> iterations of the <u>bit-by-bit</u> algorithm. This implies
           that the simple <u>bit-by-bit</u> algorithm must calculate the initial value using some sort of reverse CRC
           algorithm on the <u>XorIn</u> value.

       <u>ReflectOut</u>
           Reflect the final CRC result. This operation takes place before XOR-ing the final CRC value with the
           <u>XorOut</u> parameter.

       <u>XorOut</u>
           A value (usually all bits 0 or all 1) which will be XOR-ed to the final CRC value.

       <u>Check</u>
           This value is not exactly a parameter of a model but it is sometimes given together with the Rocksoft
           Model parameters. It is the CRC value of the parametrised model over the string “<u>123456789</u>” and can
           be used as a sanity check for a particular CRC implementation.

</pre><h4><b>CODE</b> <b>GENERATION</b></h4><pre>
       In the default configuration, the generated code is strict ISO C99. A minimal set of three functions are
       defined for each algorithm: <b>crc_init()</b>, <b>crc_update()</b> and <b>crc_finalize()</b>. Depending on the number of
       parameters given to pycrc, a different interface will be defined. A fully parametrised model has a
       simpler API, while the generated code for a runtime-specified implementation requires a pointer to a
       configuration structure as first parameter to all functions.

       The generated source code uses the type <b>crc_t</b>, which is used throughout the code to hold intermediate
       results and also the final CRC value. It is defined in the generated header file and its type may be
       overridden with the <b>--crc-type</b> option.

   <b>Fully</b> <b>parametrised</b> <b>models</b>
       The prototypes of the CRC functions are normally generated by pycrc using the <u>--generate</u> <u>h</u> option. The
       CRC functions for a fully parametrised model will look like:

       <b>#include</b> <b>&lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;</b>
       <b>typedef</b> <b>uint16_t</b> <b>crc_t;</b>         <b>/*</b> <b>pycrc</b> <b>will</b> <b>use</b> <b>an</b> <b>appropriate</b> <b>size</b> <b>here</b> <b>*/</b>

       <b>crc_t</b> <b>crc_init(void);</b>

       <b>crc_t</b> <b>crc_update(crc_t</b> <u>crc</u><b>,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>size_t</b> <u>data_len</u><b>);</b>

       <b>crc_t</b> <b>crc_finalize(crc_t</b> <u>crc</u><b>);</b>

       The code snippet below shows how to use the generated functions.

           #include "pycrc_generated_crc.h"
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

           int main(void)
           {
               static const unsigned char str1[] = "1234";
               static const unsigned char str2[] = "56789";
               crc_t crc;

               crc = crc_init();
               crc = crc_update(crc, str1, sizeof(str1) - 1);
               crc = crc_update(crc, str2, sizeof(str2) - 1);
               /* more calls to crc_update... */
               crc = crc_finalize(crc);

               printf("0x%lx\n", (long)crc);
               return 0;
           }

   <b>Models</b> <b>with</b> <b>runtime-configurable</b> <b>parameters</b>
       When the model is not fully defined then the missing parameters are stored in a structure of type
       <b>crc_cfg_t</b>. If a CRC function requires a value from the <b>crc_cfg_t</b> structure, then the first function
       argument is always a pointer to that structure. All fields of the configuration structure must be
       properly initialised before the first call to any CRC function.

       If the <u>Width</u> was not specified when the code was generated, then the <b>crc_cfg_t</b> structure will contain
       three more fields: <u>msb_mask</u>, <u>crc_mask</u> and <u>crc_shift</u>. They are defined for performance reasons and must be
       initialised to the value given next to the field definition.

       For example, a completely undefined CRC implementation will generate a <b>crc_cfg_t</b> structure as below:

           typedef struct {
               unsigned int width;
               crc_t poly;
               bool reflect_in;
               crc_t xor_in;
               bool reflect_out;
               crc_t xor_out;

               // internal parameters
               crc_t msb_mask;             // initialise as (crc_t)1u &lt;&lt; (cfg-&gt;width - 1)
               crc_t crc_mask;             // initialise as (cfg-&gt;msb_mask - 1) | cfg-&gt;msb_mask
               unsigned int crc_shift;     // initialise as cfg-&gt;width &lt; 8 ? 8 - cfg-&gt;width : 0
           } crc_cfg_t;

       <u>msb_mask</u> is a bitmask with the most significant bit of a <u>Width</u> bits wide data type set to 1.  <u>crc_mask</u> is
       a bitmask with all bits of a <u>Width</u> bits wide data type set to 1.  <u>crc_shift</u> is a shift counter that is
       used when <u>Width</u> is less than 8. It is the number of bits to shift the CRC register to align its top bit
       to a byte boundary.

       The file test/main.c in the source package of pycrc contains a fully featured example of how to use the
       generated source code. A shorter, more compact main() function can be generated with the <u>--generate</u>
       <u>c-main</u> option. This second variant is the better option as it will always output valid code when some of
       the CRC parameters are known and some are unknown during code generation.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Calculate the CRC-32 checksum of the string “123456789”:
           <b>python</b> <b>pycrc.py</b> <b>--model</b> <b>crc-32</b> <b>--check-string</b> <b>123456789</b>

       Generate the source code of the table-driven algorithm for an embedded application.
           The table index width of 4 bits ensures a moderate memory usage. To be precise, the size of the
           resulting table will be 16 * sizeof(crc_t).

           <b>python</b> <b>pycrc.py</b> <b>--model</b> <b>crc-16</b> <b>--algorithm</b> <b>table-driven</b> <b>--table-idx-width</b> <b>4</b> <b>--generate</b> <b>h</b> <b>-o</b> <b>crc.h</b>

           <b>python</b> <b>pycrc.py</b> <b>--model</b> <b>crc-16</b> <b>--algorithm</b> <b>table-driven</b> <b>--table-idx-width</b> <b>4</b> <b>--generate</b> <b>c</b> <b>-o</b> <b>crc.c</b>

           A variant of the <u>c</u> target is <u>c-main</u>: this target will generate a simple <u>main()</u> function in addition
           to the CRC functions:

           <b>python</b> <b>pycrc.py</b> <b>--model</b> <b>crc-16</b> <b>--algorithm</b> <b>table-driven</b> <b>--table-idx-width</b> <b>4</b> <b>--generate</b> <b>c-main</b> <b>-o</b>
           <b>crc.c</b>

       Generate the CRC table only:
           <b>python</b> <b>pycrc.py</b> <b>--model</b> <b>kermit</b> <b>--generate</b> <b>table</b> <b>-o</b> <b>crc-table.txt</b>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The homepage of pycrc is <b>https://pycrc.org</b>.

       A list of common CRC models is at <b>https://pycrc.org/models.html</b>. For a long list of known CRC models, see
       Greg Cook's <b>Catalogue</b> <b>of</b> <b>Parameterised</b> <b>CRC</b> <b>Algorithms</b>[3].

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This work is licensed under a <b>Creative</b> <b>Commons</b> <b>Attribution-ShareAlike</b> <b>4.0</b> <b>International</b>[4].

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Thomas</b> <b>Pircher</b> &lt;<a href="mailto:tehpeh-web@tty1.net">tehpeh-web@tty1.net</a>&gt;
           Author of pycrc and this manual page.

</pre><h4><b>NOTES</b></h4><pre>
        1. pycrc
           https://pycrc.org

        2. A Painless Guide to CRC Error Detection Algorithms
           <a href="http://www.ross.net/crc/crcpaper.html">http://www.ross.net/crc/crcpaper.html</a>

        3. Catalogue of Parameterised CRC Algorithms
           <a href="http://reveng.sourceforge.net/crc-catalogue/">http://reveng.sourceforge.net/crc-catalogue/</a>

        4. Creative Commons Attribution-ShareAlike 4.0 International
           https://creativecommons.org/licenses/by-sa/4.0/

pycrc 0.9.1                                        2017-08-11                                           <u><a href="../man1/PYCRC.1.html">PYCRC</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>