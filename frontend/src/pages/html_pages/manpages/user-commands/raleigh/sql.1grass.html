<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector  points,  lines  and areas usually have attribute data that are stored in DBMS. The attributes are</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>SQL</b> <b>support</b> <b>in</b> <b>GRASS</b> <b>GIS</b></h4><pre>
       Vector  points,  lines  and areas usually have attribute data that are stored in DBMS. The attributes are
       linked to each vector object using a category number (attribute ID, usually the  "cat"  integer  column).
       The category numbers are stored both in the vector geometry and the attribute table.

       GRASS  GIS  supports  various  RDBMS  (Relational database management system) and embedded databases. SQL
       (Structured Query Language) queries are directly passed to the underlying database  system.  The  set  of
       supported SQL commands depends on the RDMBS and database driver selected.

</pre><h4><b>Database</b> <b>drivers</b></h4><pre>
       The  default  database driver used by GRASS GIS 8 is SQLite. GRASS GIS handles multiattribute vector data
       by default. The <u>db.*</u> set of commands  provides basic SQL support  for  attribute  management,  while  the
       <u>v.db.*</u> set of commands operates on vector maps.

       Note: The list of available database drivers can vary in various binary distributions of GRASS GIS:

       sqlite                                                       Data storage in SQLite database files (default DB backend)   https://sqlite.org/

       dbf                                                          Data storage in DBF files                                    <a href="http://shapelib.maptools.org/dbf_api.html">http://shapelib.maptools.org/dbf_api.html</a>

       pg                                                           Data storage in PostgreSQL RDBMS                             https://postgresql.org/

       mysql                                                        Data storage in MySQL RDBMS                                  https://www.mysql.com/

       odbc                                                         Data storage via UnixODBC (PostgreSQL, Oracle, etc.)         https://www.unixodbc.org/

       ogr                                                          Data storage in OGR files                                    https://gdal.org/

</pre><h4><b>NOTES</b></h4><pre>
   <b>Database</b> <b>table</b> <b>name</b> <b>restrictions</b>
           •   No dots are allowed as SQL does not support ’.’ (dots) in table names.

           •   Supported table name characters are only:
               [A-Za-z][A-Za-z0-9_]*

           •   A table name must start with a character, not a number.

           •   Text-string  matching  requires  the  text part to be ’single quoted’.  When run from the command
               line multiple queries should be contained in "double quotes". e.g.
               d.vect map where="individual=’juvenile’ and area=’beach’"

           •   Attempts to use a reserved SQL word (depends on database backend) as column or  table  name  will
               cause a "SQL syntax error".

           •   An  error  message  such  as "dbmi: Protocol error" either indicates an invalid column name or an
               unsupported column type (then the GRASS SQL parser needs to be extended).

           •   DBF column names are limited to 10 characters (DBF API definition).

   <b>Database</b> <b>table</b> <b>column</b> <b>types</b>
       The supported types of columns depend on the database  backend.  However,  all  backends  should  support
       VARCHAR, INT, DOUBLE PRECISION and DATE.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Display</b> <b>of</b> <b>vector</b> <b>feature</b> <b>selected</b> <b>by</b> <b>attribute</b> <b>query</b>
       Display  all  vector  points  except for <u>LAMAR</u> valley and <u>extensive</u> <u>trapping</u> (brackets are superfluous in
       this example):
       g.region vector=schools_wake -p
       d.mon wx0
       d.vect roadsmajor
       # all schools
       d.vect schools_wake fcol=black icon=basic/diamond col=white size=13
       # numerical selection: show schools with capacity of above 1000 kids:
       d.vect schools_wake fcol=blue icon=basic/diamond col=white size=13 \
           where="CAPACITYTO &gt; 1000"
       # string selection: all schools outside of Raleigh
       #   along with higher level schools in Raleigh
       d.vect schools_wake fcol=red icon=basic/diamond col=white size=13 \
           where="ADDRCITY &lt;&gt; ’Raleigh’ OR (ADDRCITY = ’Raleigh’ AND GLEVEL = ’H’)"

       Select all attributes from table where <u>CORECAPACI</u> column values are smaller than 200 (children):
       # must be run from the mapset which contains the table
       echo "SELECT * FROM schools_wake WHERE CORECAPACI &lt; 200" | db.select input=-

       Example of subquery expressions from a list (not supported for DBF driver):
       v.db.select schools_wake where="ADDRCITY IN (’Apex’, ’Wendell’)"

   <b>Example</b> <b>of</b> <b>pattern</b> <b>matching</b>
       # field contains string:
       #  for DBF driver:
       v.extract schools_wake out=elementary_schools where="NAMELONG LIKE ’ELEM’"
       #  for SQLite driver:
       v.extract schools_wake out=rivers_noce where="DES LIKE ’%NOCE%’"
       v.extract schools_wake out=elementary_schools where="NAMELONG LIKE ’%ELEM%’"
       # match exactly number of characters (here: 2), does not work for DBF driver:
       v.db.select mysites where="id LIKE ’P__’"
       #define wildcard:
       v.db.select mysites where="id LIKE ’P%’"

   <b>Example</b> <b>of</b> <b>null</b> <b>handling</b>
       v.db.addcolumn map=roads col="nulltest int"
       v.db.update map=roads col=nulltest value=1 where="cat &gt; 2"
       d.vect roads where="nulltest is null"
       v.db.update map=roads col=nulltest value=2 where="cat &lt;= 2"

   <b>Update</b> <b>of</b> <b>attributes</b>
       Examples of complex expressions in updates (using v.db.*  modules):
       v.db.addcolumn map=roads column="exprtest double precision"
       v.db.update map=roads column=exprtest value="cat/nulltest"
       v.db.update map=roads column=exprtest value="cat/nulltest+cat" where="cat=1"
       # using data from another column
       v.db.update map=roads column=exprtest qcolumn="(cat*100.)/SHAPE_LEN."

       Examples of more complex expressions in updates (using db.*  modules):
       echo "UPDATE roads SET exprtest=null"
       echo "UPDATE roads SET exprtest=cat/2" | db.execute
       echo "UPDATE roads SET exprtest=cat/2+cat/3" | db.execute
       echo "UPDATE roads SET exprtest=NULL WHERE cat&gt;2" | db.execute
       echo "UPDATE roads SET exprtest=cat/3*(cat+1) WHERE exprtest IS NULL" | db.execute"

       Instead of creating and updating new columns with an expression, you can use the expression directly in a
       command:
       d.vect roads where="(cat/3*(cat+1))&gt;8"
       d.vect roads where="cat&gt;exprtest"

   <b>Example</b> <b>of</b> <b>changing</b> <b>a</b> <b>SQL</b> <b>type</b> <b>(type</b> <b>casting)</b>
       <u>Note:</u> <u>not</u> <u>supported</u> <u>for</u> <u>DBF</u> <u>driver.</u>

       North Carolina data set: convert string column to double precision:

       # first copy map into current mapset
       g.copy vect=geodetic_pts,mygeodetic_pts
       v.db.addcolumn mygeodetic_pts col="zval double precision"
       # the ’z_value’ col contains ’N/A’ strings, not to be converted
       v.db.update mygeodetic_pts col=zval \
                   qcol="CAST(z_value AS double precision)" \
                   where="z_value &lt;&gt; ’N/A’"

   <b>Example</b> <b>of</b> <b>concatenation</b> <b>of</b> <b>fields</b>
       <u>Note:</u> <u>not</u> <u>supported</u> <u>for</u> <u>DBF</u> <u>driver.</u>
       v.db.update vectormap column=column3 qcolumn="column1 || column2"

   <b>Example</b> <b>of</b> <b>conditions</b>
       Conditions (like if statements) are usually written as CASE statement in SQL:
       v.db.update vectormap column=species qcolumn="CASE WHEN col1 &gt;= 12 THEN cat else NULL end"
       # a more complex example with nested conditions
       v.db.update vectormap column=species qcolumn="CASE WHEN col1 &gt;= 1 THEN cat WHEN row = 13 then 0 ELSE NULL end"

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>db.connect,</u> <u>db.select,</u> <u>db.execute,</u> <u>v.db.connect,</u> <u>v.db.select,</u> <u>v.db.update</u>

       Database management in GRASS GIS, Help pages for database modules

</pre><h4><b>AUTHOR</b></h4><pre>
       Radim Blazek

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: SQL support in GRASS GIS source code (history)

       Accessed: Friday Apr 04 01:17:42 2025

       Main index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                          <u><a href="../man1grass/sql.1grass.html">sql</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>