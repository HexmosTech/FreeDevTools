<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>i.segment  - Identifies segments (objects) from imagery data.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>i.segment</b>  - Identifies segments (objects) from imagery data.

</pre><h4><b>KEYWORDS</b></h4><pre>
       imagery, segmentation, classification, object recognition

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>i.segment</b>
       <b>i.segment</b> <b>--help</b>
       <b>i.segment</b>  [-<b>dwap</b>] <b>group</b>=<u>name</u>[,<u>name</u>,...] <b>output</b>=<u>name</u>  [<b>band_suffix</b>=<u>name</u>]  <b>threshold</b>=<u>float</u>  [<b>radius</b>=<u>float</u>]
       [<b>hr</b>=<u>float</u>]    [<b>method</b>=<u>string</u>]     [<b>similarity</b>=<u>string</u>]     [<b>minsize</b>=<u>integer</u>]     [<b>memory</b>=<u>memory</u>   <u>in</u>   <u>MB</u>]
       [<b>iterations</b>=<u>integer</u>]     [<b>seeds</b>=<u>name</u>]     [<b>bounds</b>=<u>name</u>]     [<b>goodness</b>=<u>name</u>]     [--<b>overwrite</b>]    [--<b>help</b>]
       [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-d</b>
           Use 8 neighbors (3x3 neighborhood) instead of the default 4 neighbors for each pixel

       <b>-w</b>
           Weighted input, do not perform the default scaling of input raster maps

       <b>-a</b>
           Use adaptive bandwidth for mean shift
           Range (spectral) bandwidth is adapted for each moving window

       <b>-p</b>
           Use progressive bandwidth for mean shift
           Spatial bandwidth is increased, range (spectral) bandwidth is decreased in each iteration

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>group</b>=<u>name[,name</u>,...] <b>[required]</b>
           Name of input imagery group or raster maps

       <b>output</b>=<u>name</u> <b>[required]</b>
           Name for output raster map

       <b>band_suffix</b>=<u>name</u>
           Suffix for output bands with modified band values
           Name for output raster map

       <b>threshold</b>=<u>float</u> <b>[required]</b>
           Difference threshold between 0 and 1
           Threshold = 0 merges only identical segments; threshold = 1 merges all

       <b>radius</b>=<u>float</u>
           Spatial radius in number of cells
           Must be &gt;= 1, only cells within spatial bandwidth are considered for mean shift
           Default: <u>1.5</u>

       <b>hr</b>=<u>float</u>
           Range (spectral) bandwidth [0, 1]
           Only cells within range (spectral) bandwidth are considered for mean shift. Range bandwidth  is  used
           as conductance parameter for adaptive bandwidth

       <b>method</b>=<u>string</u>
           Segmentation method
           Options: <u>region_growing,</u> <u>mean_shift</u>
           Default: <u>region_growing</u>

       <b>similarity</b>=<u>string</u>
           Similarity calculation method
           Options: <u>euclidean,</u> <u>manhattan</u>
           Default: <u>euclidean</u>

       <b>minsize</b>=<u>integer</u>
           Minimum number of cells in a segment
           The final step will merge small segments with their best neighbor
           Options: <u>1-100000</u>
           Default: <u>1</u>

       <b>memory</b>=<u>memory</u> <u>in</u> <u>MB</u>
           Maximum memory to be used (in MB)
           Cache size for raster rows
           Default: <u>300</u>

       <b>iterations</b>=<u>integer</u>
           Maximum number of iterations

       <b>seeds</b>=<u>name</u>
           Name for input raster map with starting seeds

       <b>bounds</b>=<u>name</u>
           Name of input bounding/constraining raster map
           Must be integer values, each area will be segmented independent of the others

       <b>goodness</b>=<u>name</u>
           Name for output goodness of fit estimate map

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>i.segment</u> identifies segments (objects) from imagery data.

       Image  segmentation or object recognition is the process of grouping similar pixels into unique segments,
       also referred to as objects.  Boundary and region based  algorithms  are  described  in  the  literature,
       currently  a  region  growing  and  merging  algorithm  is  implemented.  Each  object  found  during the
       segmentation process is given a unique ID and is a collection of contiguous pixels meeting some criteria.
       Note the contrast with image classification where all pixels similar to each other are  assigned  to  the
       same  class and do not need to be contiguous.  The image segmentation results can be useful on their own,
       or used as a preprocessing step for image classification. The segmentation preprocessing step can  reduce
       noise and speed up the classification.

</pre><h4><b>NOTES</b></h4><pre>
   <b>Region</b> <b>Growing</b> <b>and</b> <b>Merging</b>
       This  segmentation algorithm sequentially examines all current segments in the raster map. The similarity
       between the current segment and each of its neighbors is  calculated  according  to  the  given  distance
       formula. Segments will be merged if they meet a number of criteria, including:

       <b>1</b>      The  pair  is mutually most similar to each other (the similarity distance will be smaller than to
              any other neighbor), and

       <b>2</b>      The similarity must be lower than the input threshold. The process is repeated until no merges are
              made during a complete pass.

   <b>Similarity</b> <b>and</b> <b>Threshold</b>
       The similarity between segments and unmerged objects is used  to  determine  which  objects  are  merged.
       Smaller distance values indicate a closer match, with a similarity score of zero for identical pixels.

       During  normal processing, merges are only allowed when the similarity between two segments is lower than
       the given threshold value. During the final pass, however, if a minimum segment size of 2  or  larger  is
       given  with  the  <b>minsize</b>  parameter,  segments with a smaller pixel count will be merged with their most
       similar neighbor even if the similarity is greater than the threshold.

       The <b>threshold</b> must be larger than 0.0 and smaller than 1.0. A threshold of 0 would allow  only  identical
       valued  pixels to be merged, while a threshold of 1 would allow everything to be merged. The threshold is
       scaled to the data range of the entire input data, not the current computational region.  This allows the
       application of the same threshold to different computational regions when working on  the  same  dataset,
       ensuring that this threshold has the same meaning in all subregions.

       Initial  empirical  tests indicate threshold values of 0.01 to 0.05 are reasonable values to start. It is
       recommended to start with a low value, e.g. 0.01, and then perform hierarchical segmentation by using the
       output of the last run as <b>seeds</b> for the next run.

   <b>Calculation</b> <b>Formulas</b>
       Both Euclidean and Manhattan distances use the normal definition, considering each raster  in  the  image
       group  as  a  dimension.   In  future,  the  distance  calculation  will also take into account the shape
       characteristics of the segments. The normal distances  are  then  multiplied  by  the  input  radiometric
       weight.  Next  an  additional  contribution is added: (1-radioweight) * {smoothness * smoothness weight +
       compactness * (1-smoothness weight)}, where compactness = Perimeter Length / sqrt( Area ) and  smoothness
       =  Perimeter  Length  /  Bounding Box. The perimeter length is estimated as the number of pixel sides the
       segment has.

   <b>Seeds</b>
       The seeds map can be used to provide either seed pixels (random or selected points from  which  to  start
       the  segmentation process) or seed segments. If the seeds are the results of a previous segmentation with
       lower threshold, hierarchical segmentation can be performed. The different approaches  are  automatically
       detected by the program: any pixels that have identical seed values and are contiguous will be assigned a
       unique segment ID.

   <b>Maximum</b> <b>number</b> <b>of</b> <b>segments</b>
       The  current  limit with CELL storage used for segment IDs is 2 billion starting segment IDs. Segment IDs
       are assigned whenever a yet unprocessed pixel is merged with another segment. Integer overflow can happen
       for computational regions with more than 2 billion cells and very low threshold values, resulting in many
       segments. If integer overflow occurs durin region growing, starting segments  can  be  used  (created  by
       initial classification or other methods).

   <b>Goodness</b> <b>of</b> <b>Fit</b>
       The  <b>goodness</b>  of  fit for each pixel is calculated as 1 - distance of the pixel to the object it belongs
       to. The distance is calculated with the selected <b>similarity</b> method. A value of 1 means identical  values,
       perfect fit, and a value of 0 means maximum possible distance, worst possible fit.

   <b>Mean</b> <b>shift</b>
       Mean  shift  image  segmentation  consists  of  2  steps:  anisotrophic  filtering and 2. clustering. For
       anisotrophic filtering new cell values are calculated from all pixels not farther  than  <b>hs</b>  pixels  away
       from the current pixel and with a spectral difference not larger than <b>hr</b>. That means that pixels that are
       too  different  from the current pixel are not considered in the calculation of new pixel values.  <b>hs</b> and
       <b>hr</b> are the  spatial  and  spectral  (range)  bandwidths  for  anisotrophic  filtering.  Cell  values  are
       iteratively  recalculated  (shifted  to  the  segment’s  mean)  until the maximum number of iterations is
       reached or until the largest shift is smaller than <b>threshold</b>.

       If input bands have been reprojected, they should not be reprojected  with  bilinear  resampling  because
       that  method  causes  smooth transitions between objects. More appropriate methods are bicubic or lanczos
       resampling.

   <b>Boundary</b> <b>Constraints</b>
       Boundary constraints limit the adjacency of pixels and segments.  Each unique value present in the <b>bounds</b>
       raster are considered as a MASK. Thus no segments in the final segmentated map  will  cross  a  boundary,
       even if their spectral data is very similar.

   <b>Minimum</b> <b>Segment</b> <b>Size</b>
       To  reduce  the  salt  and  pepper  effect,  a <b>minsize</b> greater than 1 will add one additional pass to the
       processing. During the final pass, the threshold is ignored for any segments smaller then the  set  size,
       thus forcing very small segments to merge with their most similar neighbor. A minimum segment size larger
       than 1 is recommended when using adaptive bandwidth selected with the <b>-a</b> flag.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Segmentation</b> <b>of</b> <b>RGB</b> <b>orthophoto</b>
       This example uses the ortho photograph included in the NC Sample Dataset. Set up an imagery group:
       i.group group=ortho_group input=ortho_2001_t792_1m@PERMANENT

       Set the region to a smaller test region (resolution taken from input ortho photograph).
       g.region -p raster=ortho_2001_t792_1m n=220446 s=220075 e=639151 w=638592
       Try out a low threshold and check the results.
       i.segment group=ortho_group output=ortho_segs_l1 threshold=0.02

       From  a  visual  inspection, it seems this results in too many segments.  Increasing the threshold, using
       the previous results as seeds, and setting a minimum size of 2:
       i.segment group=ortho_group output=ortho_segs_l2 threshold=0.05 seeds=ortho_segs_l1 min=2
       i.segment group=ortho_group output=ortho_segs_l3 threshold=0.1 seeds=ortho_segs_l2
       i.segment group=ortho_group output=ortho_segs_l4 threshold=0.2 seeds=ortho_segs_l3
       i.segment group=ortho_group output=ortho_segs_l5 threshold=0.3 seeds=ortho_segs_l4

       The  output  ortho_segs_l4  with  <b>threshold</b>=0.2  still  has  too  many  segments,  but  the  output  with
       <b>threshold</b>=0.3  has  too  few segments. A threshold value of 0.25 seems to be a good choice. There is also
       some noise in the image, lets next force all segments smaller than 10 pixels to be merged into their most
       similar neighbor (even if they are less similar than required by our threshold):

       Set the region to match the entire map(s) in the group.
       g.region -p raster=ortho_2001_t792_1m@PERMANENT

       Run <u>i.segment</u> on the full map:
       i.segment group=ortho_group output=ortho_segs_final threshold=0.25 min=10

       Processing the entire ortho image with nearly 10 million pixels took about 450 times more  then  for  the
       final run.

   <b>Segmentation</b> <b>of</b> <b>panchromatic</b> <b>channel</b>
       This  example  uses  the panchromatic channel of the Landsat7 scene included in the North Carolina sample
       dataset:
       # create group with single channel
       i.group group=singleband input=lsat7_2002_80
       # set computational region to Landsat7 PAN band
       g.region raster=lsat7_2002_80 -p
       # perform segmentation with minsize=5
       i.segment group=singleband threshold=0.05 minsize=5 \
         output=lsat7_2002_80_segmented_min5 goodness=lsat7_2002_80_goodness_min5
       # perform segmentation with minsize=100
       i.segment group=singleband threshold=0.05 minsize=100
         output=lsat7_2002_80_segmented_min100 goodness=lsat7_2002_80_goodness_min100

       Original panchromatic channel of the Landsat7 scene

       Segmented panchromatic channel, minsize=5

       Segmented panchromatic channel, minsize=100

</pre><h4><b>TODO</b></h4><pre>
   <b>Functionality</b>
           •   Further testing of the shape characteristics (smoothness,  compactness),  if  it  looks  good  it
               should be added.  (<b>in</b> <b>progress</b>)

           •   Malahanobis distance for the similarity calculation.

   <b>Use</b> <b>of</b> <b>Segmentation</b> <b>Results</b>
           •   Improve the optional output from this module, or better yet, add a module for <u>i.segment.metrics</u>.

           •   Providing  updates  to  <u>i.maxlik</u>  to  ensure the segmentation output can be used as input for the
               existing classification functionality.

           •   Integration/workflow for <u>r.fuzzy</u> (Addon).

   <b>Speed</b>
           •   See create_isegs.c

</pre><h4><b>REFERENCES</b></h4><pre>
       This project was first developed during GSoC 2012. Project documentation, Image Segmentation  references,
       and other information is at the project wiki.

       Information about classification in GRASS is at available on the wiki.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>g.gui.iclass,</u> <u>i.group,</u> <u>i.maxlik,</u> <u>i.smap,</u> <u>r.kappa</u>

</pre><h4><b>AUTHORS</b></h4><pre>
       Eric Momsen - North Dakota State University
       Markus Metz (GSoC Mentor)

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: i.segment source code (history)

       Accessed: Friday Apr 04 01:21:05 2025

       Main index | Imagery index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                    <u><a href="../man1grass/i.segment.1grass.html">i.segment</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>