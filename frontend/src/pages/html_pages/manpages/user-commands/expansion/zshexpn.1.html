<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zshexpn - zsh expansion and substitution</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/zsh-common">zsh-common_5.9-6ubuntu3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zshexpn - zsh expansion and substitution

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The following types of expansions are performed in the indicated order in five steps:

       <u>History</u> <u>Expansion</u>
              This is performed only in interactive shells.

       <u>Alias</u> <u>Expansion</u>
              Aliases  are expanded immediately before the command line is parsed as explained under Aliasing in
              <u><a href="../man1/zshmisc.1.html">zshmisc</a></u>(1).

       <u>Process</u> <u>Substitution</u>
       <u>Parameter</u> <u>Expansion</u>
       <u>Command</u> <u>Substitution</u>
       <u>Arithmetic</u> <u>Expansion</u>
       <u>Brace</u> <u>Expansion</u>
              These five are performed in left-to-right fashion.  On each argument, any of the five  steps  that
              are  needed  are  performed  one  after the other.  Hence, for example, all the parts of parameter
              expansion are completed before command substitution  is  started.   After  these  expansions,  all
              unquoted occurrences of the characters `<b>\</b>',`<b>'</b>' and `<b>"</b>' are removed.

       <u>Filename</u> <u>Expansion</u>
              If  the <b>SH_FILE_EXPANSION</b> option is set, the order of expansion is modified for compatibility with
              <b>sh</b> and <b>ksh</b>.  In that case <u>filename</u> <u>expansion</u>  is  performed  immediately  after  <u>alias</u>  <u>expansion</u>,
              preceding the set of five expansions mentioned above.

       <u>Filename</u> <u>Generation</u>
              This expansion, commonly referred to as <b>globbing</b>, is always done last.

       The following sections explain the types of expansion in detail.

</pre><h4><b>HISTORY</b> <b>EXPANSION</b></h4><pre>
       History expansion allows you to use words from previous command lines in the command line you are typing.
       This simplifies spelling corrections and the repetition of complicated commands or arguments.

       Immediately  before execution, each command is saved in the history list, the size of which is controlled
       by the <b>HISTSIZE</b> parameter.  The one most recent command is always  retained  in  any  case.   Each  saved
       command  in  the  history list is called a history <u>event</u> and is assigned a number, beginning with 1 (one)
       when the shell starts up.  The history number that you may see in your prompt (see  EXPANSION  OF  PROMPT
       SEQUENCES in <u><a href="../man1/zshmisc.1.html">zshmisc</a></u>(1)) is the number that is to be assigned to the <u>next</u> command.

   <b>Overview</b>
       A  history expansion begins with the first character of the <b>histchars</b> parameter, which is `<b>!</b>' by default,
       and may occur anywhere on the command line, including inside double quotes (but not inside single  quotes
       <b>'...'</b> or C-style quotes <b>$'...'</b> nor when escaped with a backslash).

       The first character is followed by an optional event designator (see the section `Event Designators') and
       then  an  optional  word  designator (the section `Word Designators'); if neither of these designators is
       present, no history expansion occurs.

       Input lines containing history  expansions  are  echoed  after  being  expanded,  but  before  any  other
       expansions  take  place and before the command is executed.  It is this expanded form that is recorded as
       the history event for later references.

       History expansions do not nest.

       By default, a history reference with no event designator refers  to  the  same  event  as  any  preceding
       history  reference  on  that command line; if it is the only history reference in a command, it refers to
       the previous command.  However, if the option <b>CSH_JUNKIE_HISTORY</b> is set,  then  every  history  reference
       with no event specification <u>always</u> refers to the previous command.

       For  example,  `<b>!</b>' is the event designator for the previous command, so `<b>!!:1</b>' always refers to the first
       word of the previous command, and `<b>!!$</b>' always refers to the last word of  the  previous  command.   With
       <b>CSH_JUNKIE_HISTORY</b>  set,  then  `<b>!:1</b>'  and  `<b>!$</b>'  function  in  the  same  manner  as  `<b>!!:1</b>'  and `<b>!!$</b>',
       respectively.  Conversely, if <b>CSH_JUNKIE_HISTORY</b> is unset, then `<b>!:1</b>' and `<b>!$</b>' refer  to  the  first  and
       last  words,  respectively, of the same event referenced by the nearest other history reference preceding
       them on the current command line, or to the previous command if there is no preceding reference.

       The character sequence `<b>^</b><u>foo</u><b>^</b><u>bar</u>' (where `<b>^</b>' is actually the second character of the <b>histchars</b> parameter)
       repeats the last command, replacing the string <u>foo</u> with <u>bar</u>.  More precisely, the sequence `<b>^</b><u>foo</u><b>^</b><u>bar</u><b>^</b>' is
       synonymous with `<b>!!:s^</b><u>foo</u><b>^</b><u>bar</u><b>^</b>', hence other modifiers (see the section `Modifiers') may follow the final
       `<b>^</b>'.  In particular, `<b>^</b><u>foo</u><b>^</b><u>bar</u><b>^:G</b>' performs a global substitution.

       If the shell encounters the character sequence `<b>!"</b>' in the input, the history  mechanism  is  temporarily
       disabled  until  the  current list (see <u><a href="../man1/zshmisc.1.html">zshmisc</a></u>(1)) is fully parsed.  The `<b>!"</b>' is removed from the input,
       and any subsequent `<b>!</b>' characters have no special significance.

       A less convenient but more comprehensible form of command history support is provided by the <b>fc</b> builtin.

   <b>Event</b> <b>Designators</b>
       An event designator is a reference to a command-line entry in the  history  list.   In  the  list  below,
       remember  that  the initial <b>`!'</b> in each item may be changed to another character by setting the <b>histchars</b>
       parameter.

       <b>!</b>      Start a history expansion, except when followed by a blank, newline,  `<b>=</b>'  or  `<b>(</b>'.   If  followed
              immediately  by  a  word  designator  (see  the  section `Word Designators'), this forms a history
              reference with no event designator (see the section `Overview').

       <b>!!</b>     Refer to the previous command.  By itself, this expansion repeats the previous command.

       <b>!</b><u>n</u>     Refer to command-line <u>n</u>.

       <b>!-</b><u>n</u>    Refer to the current command-line minus <u>n</u>.

       <b>!</b><u>str</u>   Refer to the most recent command starting with <u>str</u>.

       <b>!?</b><u>str</u>[<b>?</b>]
              Refer to the most recent command containing <u>str</u>.  The trailing `<b>?</b>' is necessary if this  reference
              is to be followed by a modifier or followed by any text that is not to be considered part of <u>str</u>.

       <b>!#</b>     Refer  to the current command line typed in so far.  The line is treated as if it were complete up
              to and including the word before the one with the `<b>!#</b>' reference.

       <b>!{</b>...<b>}</b> Insulate a history reference from adjacent characters (if necessary).

   <b>Word</b> <b>Designators</b>
       A word designator indicates which word or words of a given command line are to be included in  a  history
       reference.   A `<b>:</b>' usually separates the event specification from the word designator.  It may be omitted
       only if the word designator begins with a `<b>^</b>', `<b>$</b>', `<b>*</b>', `<b>-</b>' or `<b>%</b>'.  Word designators include:

       <b>0</b>      The first input word (command).
       <u>n</u>      The <u>n</u>th argument.
       <b>^</b>      The first argument.  That is, <b>1</b>.
       <b>$</b>      The last argument.
       <b>%</b>      The word matched by (the most recent) <b>?</b><u>str</u> search.
       <u>x</u><b>-</b><u>y</u>    A range of words; <u>x</u> defaults to <b>0</b>.
       <b>*</b>      All the arguments, or a null value if there are none.
       <u>x</u><b>*</b>     Abbreviates `<u>x</u><b>-$</b>'.
       <u>x</u><b>-</b>     Like `<u>x</u><b>*</b>' but omitting word <b>$</b>.

       Note that a `<b>%</b>' word designator works only when used in one of `<b>!%</b>', `<b>!:%</b>' or `<b>!?</b><u>str</u><b>?:%</b>', and  only  when
       used  after a <b>!?</b> expansion (possibly in an earlier command).  Anything else results in an error, although
       the error may not be the most obvious one.

   <b>Modifiers</b>
       After the optional word designator, you can add a sequence of one or more  of  the  following  modifiers,
       each  preceded  by  a  `<b>:</b>'.  These modifiers also work on the result of <u>filename</u> <u>generation</u> and <u>parameter</u>
       <u>expansion</u>, except where noted.

       <b>a</b>      Turn a file name into an absolute path:  prepends the current directory, if necessary; remove  `<b>.</b>'
              path segments; and remove `<b>..</b>' path segments and the segments that immediately precede them.

              This  transformation  is agnostic about what is in the filesystem, i.e. is on the logical, not the
              physical directory.  It takes place in the same manner as when changing directories  when  neither
              of  the  options <b>CHASE_DOTS</b> or <b>CHASE_LINKS</b> is set.  For example, `<b>/before/here/../after</b>' is always
              transformed to `<b>/before/after</b>', regardless of whether `<b>/before/here</b>' exists or what kind of object
              (dir, file, symlink, etc.) it is.

       <b>A</b>      Turn a file name into an absolute path as the `<b>a</b>' modifier does, and <u>then</u> pass the result  through
              the <b><a href="../man3/realpath.3.html">realpath</a>(3)</b> library function to resolve symbolic links.

              Note: on systems that do not have a <b><a href="../man3/realpath.3.html">realpath</a>(3)</b> library function, symbolic links are not resolved,
              so on those systems `<b>a</b>' and `<b>A</b>' are equivalent.

              Note:  <b>foo:A</b> and <b>realpath(foo)</b> are different on some inputs.  For <b>realpath(foo)</b> semantics, see the
              `<b>P</b>` modifier.

       <b>c</b>      Resolve a command name into an absolute path by searching the  command  path  given  by  the  <b>PATH</b>
              variable.   This  does not work for commands containing directory parts.  Note also that this does
              not usually work as a glob qualifier unless a file of the  same  name  is  found  in  the  current
              directory.

       <b>e</b>      Remove  all  but  the  part of the filename extension following the `<b>.</b>'; see the definition of the
              filename extension in the description of the <b>r</b>  modifier  below.   Note  that  according  to  that
              definition the result will be empty if the string ends with a `<b>.</b>'.

       <b>h</b> [ <u>digits</u> ]
              Remove  a  trailing  pathname  component,  shortening the path by one directory level: this is the
              `head' of the pathname.  This works like `<b>dirname</b>'.  If the <b>h</b> is  followed  immediately  (with  no
              spaces  or other separator) by any number of decimal digits, and the value of the resulting number
              is non-zero, that number of leading components is preserved instead of the final  component  being
              removed.   In  an  absolute  path  the  leading  `<b>/</b>'  is  the first component, so, for example, if
              <b>var=/my/path/to/something</b>, then <b>${var:h3}</b> substitutes <b>/my/path</b>.  Consecutive `/'s are treated  the
              same  as a single `/'.  In parameter substitution, digits may only be used if the expression is in
              braces, so for example the short form  substitution  <b>$var:h2</b>  is  treated  as  <b>${var:h}2</b>,  not  as
              <b>${var:h2}</b>.   No  restriction  applies  to  the  use  of digits in history substitution or globbing
              qualifiers.  If more components are requested than are present, the entire path is substituted (so
              this does not trigger a `failed modifier' error in history expansion).

       <b>l</b>      Convert the words to all lowercase.

       <b>p</b>      Print the new command but do not execute it.  Only works with history expansion.

       <b>P</b>      Turn a file name into an absolute path, like <b><a href="../man3/realpath.3.html">realpath</a>(3)</b>.  The resulting path  will  be  absolute,
              will  refer  to the same directory entry as the input filename, and none of its components will be
              symbolic links or equal to `<b>.</b>' or `<b>..</b>'.

              Unlike <b><a href="../man3/realpath.3.html">realpath</a>(3)</b>, non-existent trailing components are permitted and preserved.

       <b>q</b>      Quote the substituted words, escaping further substitutions.  Works  with  history  expansion  and
              parameter  expansion,  though  for  parameters  it  is  only useful if the resulting text is to be
              re-evaluated such as by <b>eval</b>.

       <b>Q</b>      Remove one level of quotes from the substituted words.

       <b>r</b>      Remove a filename extension leaving the root name.  Strings with no  filename  extension  are  not
              altered.  A filename extension is a `<b>.</b>' followed by any number of characters (including zero) that
              are neither `<b>.</b>' nor `<b>/</b>' and that continue to the end of the string.  For example, the extension of
              `<b>foo.orig.c</b>' is `<b>.c</b>', and `<b>dir.c/foo</b>' has no extension.

       <b>s/</b><u>l</u><b>/</b><u>r</u>[<b>/</b>]
              Substitute  <u>r</u>  for  <u>l</u> as described below.  The substitution is done only for the first string that
              matches <u>l</u>.  For arrays and for filename generation, this applies to  each  word  of  the  expanded
              text.  See below for further notes on substitutions.

              The forms `<b>gs/</b><u>l</u><b>/</b><u>r</u>' and `<b>s/</b><u>l</u><b>/</b><u>r</u><b>/:G</b>' perform global substitution, i.e. substitute every occurrence of
              <u>r</u> for <u>l</u>.  Note that the <b>g</b> or <b>:G</b> must appear in exactly the position shown.

              See further notes on this form of substitution below.

       <b>&amp;</b>      Repeat  the  previous  <b>s</b>  substitution.  Like <b>s</b>, may be preceded immediately by a <b>g</b>.  In parameter
              expansion the <b>&amp;</b> must appear inside braces, and in filename generation it must  be  quoted  with  a
              backslash.

       <b>t</b> [ <u>digits</u> ]
              Remove  all  leading  pathname  components,  leaving  the final component (tail).  This works like
              `<b>basename</b>'.  Any trailing slashes are first removed.  Decimal  digits  are  handled  as  described
              above  for  (h),  but  in this case that number of trailing components is preserved instead of the
              default 1; 0 is treated the same as 1.

       <b>u</b>      Convert the words to all uppercase.

       <b>x</b>      Like <b>q</b>, but break into words at whitespace.  Does not work with parameter expansion.

       The <b>s/</b><u>l</u><b>/</b><u>r</u><b>/</b> substitution works as follows.  By  default  the  left-hand  side  of  substitutions  are  not
       patterns,  but  character  strings.   Any  character  can  be  used  as the delimiter in place of `<b>/</b>'.  A
       backslash quotes the delimiter character.  The character `<b>&amp;</b>', in the right-hand-side <u>r</u>,  is  replaced  by
       the  text from the left-hand-side <u>l</u>.  The `<b>&amp;</b>' can be quoted with a backslash.  A null <u>l</u> uses the previous
       string either from the previous <u>l</u> or from the contextual scan string <u>s</u> from  `<b>!?</b><u>s</u>'.   You  can  omit  the
       rightmost delimiter if a newline immediately follows <u>r</u>; the rightmost `<b>?</b>' in a context scan can similarly
       be omitted.  Note the same record of the last <u>l</u> and <u>r</u> is maintained across all forms of expansion.

       Note  that  if  a  `<b>&amp;</b>'  is  used  within glob qualifiers an extra backslash is needed as a <b>&amp;</b> is a special
       character in this case.

       Also note that the order of expansions affects the interpretation of <u>l</u> and <u>r</u>.  When  used  in  a  history
       expansion,  which  occurs  before any other expansions, <u>l</u> and <u>r</u> are treated as literal strings (except as
       explained for <b>HIST_SUBST_PATTERN</b> below).  When used in parameter expansion, the replacement of <u>r</u> into the
       parameter's value is done first, and then any additional  process,  parameter,  command,  arithmetic,  or
       brace  references  are applied, which may evaluate those substitutions and expansions more than once if <u>l</u>
       appears more than once in the starting value.  When used  in  a  glob  qualifier,  any  substitutions  or
       expansions are performed once at the time the qualifier is parsed, even before the `<b>:s</b>' expression itself
       is divided into <u>l</u> and <u>r</u> sides.

       If  the  option  <b>HIST_SUBST_PATTERN</b>  is set, <u>l</u> is treated as a pattern of the usual form described in the
       section FILENAME GENERATION below.  This can be used in all the places  where  modifiers  are  available;
       note,  however, that in globbing qualifiers parameter substitution has already taken place, so parameters
       in the replacement string should be quoted to ensure they are replaced at the correct  time.   Note  also
       that  complicated  patterns  used  in  globbing  qualifiers may need the extended glob qualifier notation
       <b>(#q:s/</b><u>...</u><b>/</b><u>...</u><b>/)</b> in order for the shell to recognize the expression as a glob  qualifier.   Further,  note
       that  bad  patterns  in  the  substitution  are not subject to the <b>NO_BAD_PATTERN</b> option so will cause an
       error.

       When <b>HIST_SUBST_PATTERN</b> is set, <u>l</u> may start with a <b>#</b> to indicate that the pattern must match at the start
       of the string to be substituted, and a <b>%</b> may appear at the start or after  an  <b>#</b>  to  indicate  that  the
       pattern  must  match  at  the  end  of  the  string to be substituted.  The <b>%</b> or <b>#</b> may be quoted with two
       backslashes.

       For example, the following piece of filename generation code with the <b>EXTENDED_GLOB</b> option:

              <b>print</b> <b>-r</b> <b>--</b> <b>*.c(#q:s/#%(#b)s(*).c/'S${match[1]}.C'/)</b>

       takes the expansion of <b>*.c</b> and applies the glob qualifiers in the <b>(#q</b><u>...</u><b>)</b> expression, which consists of a
       substitution modifier anchored to the start and end of each word  (<b>#%</b>).   This  turns  on  backreferences
       (<b>(#b)</b>),  so  that  the parenthesised subexpression is available in the replacement string as <b>${match[1]}</b>.
       The replacement string is quoted so that the parameter is not substituted before the  start  of  filename
       generation.

       The  following  <b>f</b>, <b>F</b>, <b>w</b> and <b>W</b> modifiers work only with parameter expansion and filename generation.  They
       are listed here to provide a single point of reference for all modifiers.

       <b>f</b>      Repeats the immediately (without a colon) following modifier  until  the  resulting  word  doesn't
              change any more.

       <b>F:</b><u>expr</u><b>:</b>
              Like <b>f</b>, but repeats only <u>n</u> times if the expression <u>expr</u> evaluates to <u>n</u>.  Any character can be used
              instead  of  the  `<b>:</b>'; if `<b>(</b>', `<b>[</b>', or `<b>{</b>' is used as the opening delimiter, the closing delimiter
              should be '<b>)</b>', `<b>]</b>', or `<b>}</b>', respectively.

       <b>w</b>      Makes the immediately following modifier work on each word in the string.

       <b>W:</b><u>sep</u><b>:</b> Like <b>w</b> but words are considered to be the parts of the string  that  are  separated  by  <u>sep</u>.  Any
              character can be used instead of the `<b>:</b>'; opening parentheses are handled specially, see above.

</pre><h4><b>PROCESS</b> <b>SUBSTITUTION</b></h4><pre>
       Each  part  of  a  command  argument  that takes the form `<b>&lt;(</b><u>list</u><b>)</b>', `<b>&gt;(</b><u>list</u><b>)</b>' or `<b>=(</b><u>list</u><b>)</b>' is subject to
       process substitution.  The expression may be preceded or  followed  by  other  strings  except  that,  to
       prevent  clashes with commonly occurring strings and patterns, the last form must occur at the start of a
       command argument, and the forms are only expanded when first parsing  command  or  assignment  arguments.
       Process  substitutions  may  be used following redirection operators; in this case, the substitution must
       appear with no trailing string.

       Note that `<b>&lt;&lt;(</b><u>list</u><b>)</b>' is not a special syntax; it is equivalent to `<b>&lt;</b> <b>&lt;(</b><u>list</u><b>)</b>', redirecting standard input
       from the result of process substitution.  Hence all the following documentation applies.  The second form
       (with the space) is recommended for clarity.

       In the case of the <b>&lt;</b> or <b>&gt;</b> forms, the shell runs the commands in <u>list</u> as a subprocess of the job executing
       the shell command line.  If the system supports the <b><a href="file:/dev/fd">/dev/fd</a></b> mechanism, the command argument is  the  name
       of  the  device  file  corresponding  to a file descriptor; otherwise, if the system supports named pipes
       (FIFOs), the command argument will be a named pipe.  If the form with <b>&gt;</b> is selected then writing on  this
       special  file  will  provide  input  for <u>list</u>.  If <b>&lt;</b> is used, then the file passed as an argument will be
       connected to the output of the <u>list</u> process.  For example,

              <b>paste</b> <b>&lt;(cut</b> <b>-f1</b> <u>file1</u><b>)</b> <b>&lt;(cut</b> <b>-f3</b> <u>file2</u><b>)</b> <b>|</b>
              <b>tee</b> <b>&gt;(</b><u>process1</u><b>)</b> <b>&gt;(</b><u>process2</u><b>)</b> <b>&gt;/dev/null</b>

       cuts fields 1 and 3 from the files <u>file1</u> and <u>file2</u> respectively, pastes the results together,  and  sends
       it to the processes <u>process1</u> and <u>process2</u>.

       If  <b>=(</b><u>...</u><b>)</b> is used instead of <b>&lt;(</b><u>...</u><b>)</b>, then the file passed as an argument will be the name of a temporary
       file containing the output of the <u>list</u> process.  This may be used instead of the <b>&lt;</b>  form  for  a  program
       that expects to lseek (see <u><a href="../man2/lseek.2.html">lseek</a></u>(2)) on the input file.

       There  is an optimisation for substitutions of the form <b>=(&lt;&lt;&lt;</b><u>arg</u><b>)</b>, where <u>arg</u> is a single-word argument to
       the here-string redirection <b>&lt;&lt;&lt;</b>.  This form produces a file name containing the value of  <u>arg</u>  after  any
       substitutions  have  been  performed.   This  is  handled  entirely  within  the  current shell.  This is
       effectively the reverse of the special form <b>$(&lt;</b><u>arg</u><b>)</b> which treats <u>arg</u> as a file name and replaces it  with
       the file's contents.

       The  <b>=</b> form is useful as both the <b><a href="file:/dev/fd">/dev/fd</a></b> and the named pipe implementation of <b>&lt;(</b><u>...</u><b>)</b> have drawbacks.  In
       the former case, some programmes may automatically close the file descriptor in question before examining
       the file on the command line, particularly if this is necessary for security reasons  such  as  when  the
       programme  is  running setuid.  In the second case, if the programme does not actually open the file, the
       subshell attempting to read from or write to the  pipe  will  (in  a  typical  implementation,  different
       operating systems may have different behaviour) block for ever and have to be killed explicitly.  In both
       cases,  the shell actually supplies the information using a pipe, so that programmes that expect to lseek
       (see <u><a href="../man2/lseek.2.html">lseek</a></u>(2)) on the file will not work.

       Also note that the previous example can be more compactly and efficiently written (provided  the  <b>MULTIOS</b>
       option is set) as:

              <b>paste</b> <b>&lt;(cut</b> <b>-f1</b> <u>file1</u><b>)</b> <b>&lt;(cut</b> <b>-f3</b> <u>file2</u><b>)</b> <b>&gt;</b> <b>&gt;(</b><u>process1</u><b>)</b> <b>&gt;</b> <b>&gt;(</b><u>process2</u><b>)</b>

       The  shell  uses  pipes  instead  of FIFOs to implement the latter two process substitutions in the above
       example.

       There is an additional problem with <b>&gt;(</b><u>process</u><b>)</b>; when this is attached to an external command, the  parent
       shell  does  not wait for <u>process</u> to finish and hence an immediately following command cannot rely on the
       results being complete.  The problem and solution are the same as described in  the  section  <u>MULTIOS</u>  in
       <u><a href="../man1/zshmisc.1.html">zshmisc</a></u>(1).  Hence in a simplified version of the example above:

              <b>paste</b> <b>&lt;(cut</b> <b>-f1</b> <u>file1</u><b>)</b> <b>&lt;(cut</b> <b>-f3</b> <u>file2</u><b>)</b> <b>&gt;</b> <b>&gt;(</b><u>process</u><b>)</b>

       (note  that  no  <b>MULTIOS</b>  are involved), <u>process</u> will be run asynchronously as far as the parent shell is
       concerned.  The workaround is:

              <b>{</b> <b>paste</b> <b>&lt;(cut</b> <b>-f1</b> <u>file1</u><b>)</b> <b>&lt;(cut</b> <b>-f3</b> <u>file2</u><b>)</b> <b>}</b> <b>&gt;</b> <b>&gt;(</b><u>process</u><b>)</b>

       The extra processes here are spawned from the parent shell which will wait for their completion.

       Another problem arises any time a job with a substitution that requires a temporary file is  disowned  by
       the  shell,  including  the  case  where  `<b>&amp;!</b>'  or  `<b>&amp;|</b>'  appears  at  the  end of a command containing a
       substitution.  In that case the temporary file will not be cleaned up as the  shell  no  longer  has  any
       memory of the job.  A workaround is to use a subshell, for example,

              <b>(mycmd</b> <b>=(myoutput))</b> <b>&amp;!</b>

       as the forked subshell will wait for the command to finish then remove the temporary file.

       A  general  workaround  to  ensure a process substitution endures for an appropriate length of time is to
       pass it as a parameter to an anonymous shell function (a piece of shell code that is run immediately with
       function scope).  For example, this code:

              <b>()</b> <b>{</b>
                 <b>print</b> <b>File</b> <b>$1:</b>
                 <b>cat</b> <b>$1</b>
              <b>}</b> <b>=(print</b> <b>This</b> <b>be</b> <b>the</b> <b>verse)</b>

       outputs something resembling the following

              <b>File</b> <b>/tmp/zsh6nU0kS:</b>
              <b>This</b> <b>be</b> <b>the</b> <b>verse</b>

       The temporary file created by the process substitution will be deleted when the function exits.

</pre><h4><b>PARAMETER</b> <b>EXPANSION</b></h4><pre>
       The character `<b>$</b>' is used to introduce parameter  expansions.   See  <u><a href="../man1/zshparam.1.html">zshparam</a></u>(1)  for  a  description  of
       parameters,  including  arrays,  associative  arrays,  and  subscript notation to access individual array
       elements.

       Note in particular the fact that words of unquoted parameters are not automatically split  on  whitespace
       unless the option <b>SH_WORD_SPLIT</b> is set; see references to this option below for more details.  This is an
       important difference from other shells.  However, as in other shells, null words are elided from unquoted
       parameters' expansions.

       With default options, after the assignments:

              <b>array=("first</b> <b>word"</b> <b>""</b> <b>"third</b> <b>word")</b>
              <b>scalar="only</b> <b>word"</b>

       then  <b>$array</b>  substitutes two words, `<b>first</b> <b>word</b>' and `<b>third</b> <b>word</b>', and <b>$scalar</b> substitutes a single word
       `<b>only</b> <b>word</b>'.  Note that second element of <b>array</b> was elided.  Scalar parameters can be elided too if their
       value is null (empty).  To avoid elision, use quoting as follows: <b>"$scalar"</b> for scalars and <b>"${array[@]}"</b>
       or <b>"${(@)array}"</b> for arrays.  (The last two forms are equivalent.)

       Parameter  expansions  can  involve  <u>flags</u>,  as  in  `<b>${(@kv)aliases}</b>',  and  other  operators,  such  as
       `<b>${PREFIX:-"<a href="file:/usr/local">/usr/local</a>"}</b>'.   Parameter  expansions  can  also be nested.  These topics will be introduced
       below.  The full rules are complicated and are noted at the end.

       In the expansions discussed below that require a pattern, the form of the pattern is  the  same  as  that
       used  for  filename  generation;  see the section `Filename Generation'.  Note that these patterns, along
       with the replacement text of any substitutions, are themselves subject to  parameter  expansion,  command
       substitution,  and  arithmetic  expansion.   In addition to the following operations, the colon modifiers
       described in the section `Modifiers' in the section `History Expansion' can  be  applied:   for  example,
       <b>${i:s/foo/bar/}</b> performs string substitution on the expansion of parameter <b>$i</b>.

       In  the  following  descriptions,  `<u>word</u>'  refers  to  a single word substituted on the command line, not
       necessarily a space delimited word.

       <b>${</b><u>name</u><b>}</b>
              The value, if any, of the parameter <u>name</u> is substituted.  The braces are required if the expansion
              is to be followed by a letter, digit, or underscore that is not to be interpreted as part of <u>name</u>.
              In addition, more complicated forms of substitution usually require  the  braces  to  be  present;
              exceptions,  which  only  apply if the option <b>KSH_ARRAYS</b> is not set, are a single subscript or any
              colon modifiers appearing after the name, or any of the characters  `<b>^</b>',  `<b>=</b>',  `<b>~</b>',  `<b>#</b>'  or  `<b>+</b>'
              appearing before the name, all of which work with or without braces.

              If  <u>name</u>  is  an  array  parameter,  and  the <b>KSH_ARRAYS</b> option is not set, then the value of each
              element of <u>name</u> is substituted, one element per word.  Otherwise, the  expansion  results  in  one
              word  only; with <b>KSH_ARRAYS</b>, this is the first element of an array.  No field splitting is done on
              the result unless the <b>SH_WORD_SPLIT</b> option is set.  See also the flags <b>=</b> and <b>s:</b><u>string</u><b>:</b>.

       <b>${+</b><u>name</u><b>}</b>
              If <u>name</u> is the name of a set parameter `<b>1</b>' is substituted, otherwise `<b>0</b>' is substituted.

       <b>${</b><u>name</u><b>-</b><u>word</u><b>}</b>
       <b>${</b><u>name</u><b>:-</b><u>word</u><b>}</b>
              If <u>name</u> is set, or in the second form is non-null, then substitute its value; otherwise substitute
              <u>word</u>.  In the second form <u>name</u> may be omitted, in which case <u>word</u> is always substituted.

       <b>${</b><u>name</u><b>+</b><u>word</u><b>}</b>
       <b>${</b><u>name</u><b>:+</b><u>word</u><b>}</b>
              If <u>name</u> is set, or in the second form is non-null,  then  substitute  <u>word</u>;  otherwise  substitute
              nothing.

       <b>${</b><u>name</u><b>=</b><u>word</u><b>}</b>
       <b>${</b><u>name</u><b>:=</b><u>word</u><b>}</b>
       <b>${</b><u>name</u><b>::=</b><u>word</u><b>}</b>
              In  the  first form, if <u>name</u> is unset then set it to <u>word</u>; in the second form, if <u>name</u> is unset or
              null then set it to <u>word</u>; and in the third form, unconditionally set <u>name</u> to <u>word</u>.  In all  forms,
              the value of the parameter is then substituted.

       <b>${</b><u>name</u><b>?</b><u>word</u><b>}</b>
       <b>${</b><u>name</u><b>:?</b><u>word</u><b>}</b>
              In  the  first  form, if <u>name</u> is set, or in the second form if <u>name</u> is both set and non-null, then
              substitute its value; otherwise, print <u>word</u> and exit from the shell.  Interactive  shells  instead
              return to the prompt.  If <u>word</u> is omitted, then a standard message is printed.

       In  any of the above expressions that test a variable and substitute an alternate <u>word</u>, note that you can
       use standard shell quoting in  the  <u>word</u>  value  to  selectively  override  the  splitting  done  by  the
       <b>SH_WORD_SPLIT</b> option and the <b>=</b> flag, but not splitting by the <b>s:</b><u>string</u><b>:</b> flag.

       In  the  following expressions, when <u>name</u> is an array and the substitution is not quoted, or if the `<b>(@)</b>'
       flag or the <u>name</u><b>[@]</b> syntax is  used,  matching  and  replacement  is  performed  on  each  array  element
       separately.

       <b>${</b><u>name</u><b>#</b><u>pattern</u><b>}</b>
       <b>${</b><u>name</u><b>##</b><u>pattern</u><b>}</b>
              If  the <u>pattern</u> matches the beginning of the value of <u>name</u>, then substitute the value of <u>name</u> with
              the matched portion deleted; otherwise, just substitute the value of <u>name</u>.  In the first form, the
              smallest matching pattern is preferred; in the  second  form,  the  largest  matching  pattern  is
              preferred.

       <b>${</b><u>name</u><b>%</b><u>pattern</u><b>}</b>
       <b>${</b><u>name</u><b>%%</b><u>pattern</u><b>}</b>
              If  the  <u>pattern</u>  matches the end of the value of <u>name</u>, then substitute the value of <u>name</u> with the
              matched portion deleted; otherwise, just substitute the value of <u>name</u>.  In  the  first  form,  the
              smallest  matching  pattern  is  preferred;  in  the  second form, the largest matching pattern is
              preferred.

       <b>${</b><u>name</u><b>:#</b><u>pattern</u><b>}</b>
              If the <u>pattern</u> matches the value of <u>name</u>,  then  substitute  the  empty  string;  otherwise,  just
              substitute  the  value  of <u>name</u>.  If <u>name</u> is an array the matching array elements are removed (use
              the `<b>(M)</b>' flag to remove the non-matched elements).

       <b>${</b><u>name</u><b>:|</b><u>arrayname</u><b>}</b>
              If <u>arrayname</u> is the name (N.B., not contents) of an array variable, then any elements contained in
              <u>arrayname</u> are removed from the substitution of  <u>name</u>.   If  the  substitution  is  scalar,  either
              because  <u>name</u>  is  a  scalar  variable  or the expression is quoted, the elements of <u>arrayname</u> are
              instead tested against the entire expression.

       <b>${</b><u>name</u><b>:*</b><u>arrayname</u><b>}</b>
              Similar to the preceding substitution, but in the opposite sense, so that entries present in  both
              the original substitution and as elements of <u>arrayname</u> are retained and others removed.

       <b>${</b><u>name</u><b>:^</b><u>arrayname</u><b>}</b>
       <b>${</b><u>name</u><b>:^^</b><u>arrayname</u><b>}</b>
              Zips  two  arrays, such that the output array is twice as long as the shortest (longest for `<b>:^^</b>')
              of <b>name</b> and <b>arrayname</b>, with the elements alternatingly being picked from them. For `<b>:^</b>', if one of
              the input arrays is longer, the output will stop when the end of the  shorter  array  is  reached.
              Thus,

                     <b>a=(1</b> <b>2</b> <b>3</b> <b>4);</b> <b>b=(a</b> <b>b);</b> <b>print</b> <b>${a:^b}</b>

              will  output  `<b>1</b>  <b>a</b> <b>2</b> <b>b</b>'.  For `<b>:^^</b>', then the input is repeated until all of the longer array has
              been used up and the above will output `<b>1</b> <b>a</b> <b>2</b> <b>b</b> <b>3</b> <b>a</b> <b>4</b> <b>b</b>'.

              Either or both inputs may be a scalar, they will be treated as an  array  of  length  1  with  the
              scalar  as  the  only  element.  If either array is empty, the other array is output with no extra
              elements inserted.

              Currently the following code will output `<b>a</b> <b>b</b>' and `<b>1</b>' as two  separate  elements,  which  can  be
              unexpected.  The  second  print  provides  a  workaround  which should continue to work if this is
              changed.

                     <b>a=(a</b> <b>b);</b> <b>b=(1</b> <b>2);</b> <b>print</b> <b>-l</b> <b>"${a:^b}";</b> <b>print</b> <b>-l</b> <b>"${${a:^b}}"</b>

       <b>${</b><u>name</u><b>:</b><u>offset</u><b>}</b>
       <b>${</b><u>name</u><b>:</b><u>offset</u><b>:</b><u>length</u><b>}</b>
              This syntax gives effects similar to parameter subscripting in the form <b>$</b><u>name</u><b>[</b><u>start</u><b>,</b><u>end</u><b>]</b>,  but  is
              compatible  with  other  shells; note that both <u>offset</u> and <u>length</u> are interpreted differently from
              the components of a subscript.

              If <u>offset</u> is non-negative, then if the variable <u>name</u> is a scalar substitute the contents  starting
              <u>offset</u>  characters  from  the  first  character  of the string, and if <u>name</u> is an array substitute
              elements starting <u>offset</u> elements from the first element.  If <u>length</u>  is  given,  substitute  that
              many characters or elements, otherwise the entire rest of the scalar or array.

              A positive <u>offset</u> is always treated as the offset of a character or element in <u>name</u> from the first
              character or element of the array (this is different from native zsh subscript notation).  Hence 0
              refers to the first character or element regardless of the setting of the option <b>KSH_ARRAYS</b>.

              A  negative offset counts backwards from the end of the scalar or array, so that -1 corresponds to
              the last character or element, and so on.

              When positive, <u>length</u> counts from the <u>offset</u> position toward the end of the scalar or array.  When
              negative, <u>length</u> counts back from the end.  If this results in a position smaller than  <u>offset</u>,  a
              diagnostic is printed and nothing is substituted.

              The  option  <b>MULTIBYTE</b>  is  obeyed,  i.e.  the  offset and length count multibyte characters where
              appropriate.

              <u>offset</u> and <u>length</u> undergo the same set  of  shell  substitutions  as  for  scalar  assignment;  in
              addition, they are then subject to arithmetic evaluation.  Hence, for example

                     <b>print</b> <b>${foo:3}</b>
                     <b>print</b> <b>${foo:</b> <b>1</b> <b>+</b> <b>2}</b>
                     <b>print</b> <b>${foo:$((</b> <b>1</b> <b>+</b> <b>2))}</b>
                     <b>print</b> <b>${foo:$(echo</b> <b>1</b> <b>+</b> <b>2)}</b>

              all  have  the  same effect, extracting the string starting at the fourth character of <b>$foo</b> if the
              substitution would otherwise return a scalar, or the array starting at the fourth element if  <b>$foo</b>
              would  return  an  array.   Note  that  with  the  option  <b>KSH_ARRAYS</b> <b>$foo</b> always returns a scalar
              (regardless of the use of the offset syntax) and a form such as <b>${foo[*]:3}</b> is required to extract
              elements of an array named <b>foo</b>.

              If <u>offset</u> is negative, the <b>-</b> may not  appear  immediately  after  the  <b>:</b>  as  this  indicates  the
              <b>${</b><u>name</u><b>:-</b><u>word</u><b>}</b>  form of substitution.  Instead, a space may be inserted before the <b>-</b>.  Furthermore,
              neither <u>offset</u> nor <u>length</u> may begin with an alphabetic  character  or  <b>&amp;</b>  as  these  are  used  to
              indicate history-style modifiers.  To substitute a value from a variable, the recommended approach
              is  to  precede  it with a <b>$</b> as this signifies the intention (parameter substitution can easily be
              rendered unreadable); however, as arithmetic substitution  is  performed,  the  expression  <b>${var:</b>
              <b>offs}</b> does work, retrieving the offset from <b>$offs</b>.

              For  further  compatibility  with  other  shells there is a special case for array offset 0.  This
              usually accesses the first element of the array.  However,  if  the  substitution  refers  to  the
              positional  parameter array, e.g. <b>$@</b> or <b>$*</b>, then offset 0 instead refers to <b>$0</b>, offset 1 refers to
              <b>$1</b>, and so on.  In other  words,  the  positional  parameter  array  is  effectively  extended  by
              prepending <b>$0</b>.  Hence <b>${*:0:1}</b> substitutes <b>$0</b> and <b>${*:1:1}</b> substitutes <b>$1</b>.

       <b>${</b><u>name</u><b>/</b><u>pattern</u><b>/</b><u>repl</u><b>}</b>
       <b>${</b><u>name</u><b>//</b><u>pattern</u><b>/</b><u>repl</u><b>}</b>
       <b>${</b><u>name</u><b>:/</b><u>pattern</u><b>/</b><u>repl</u><b>}</b>
              Replace  the  longest possible match of <u>pattern</u> in the expansion of parameter <u>name</u> by string <u>repl</u>.
              The first form replaces just the first occurrence, the second form all occurrences, and the  third
              form  replaces  only  if  <u>pattern</u> matches the entire string.  Both <u>pattern</u> and <u>repl</u> are subject to
              double-quoted substitution, so that expressions like <b>${name/$opat/$npat}</b> will work, but  obey  the
              usual  rule  that  pattern  characters in <b>$opat</b> are not treated specially unless either the option
              <b>GLOB_SUBST</b> is set, or <b>$opat</b> is instead substituted as <b>${~opat}</b>.

              The <u>pattern</u> may begin with a `<b>#</b>', in which case the <u>pattern</u> must match at the start of the string,
              or `<b>%</b>', in which case it must match at the end of the string, or `<b>#%</b>' in which  case  the  <u>pattern</u>
              must  match  the  entire string.  The <u>repl</u> may be an empty string, in which case the final `<b>/</b>' may
              also be omitted.  To quote the final `<b>/</b>' in  other  cases  it  should  be  preceded  by  a  single
              backslash; this is not necessary if the `<b>/</b>' occurs inside a substituted parameter.  Note also that
              the  `<b>#</b>',  `<b>%</b>'  and  `<b>#%</b>  are not active if they occur inside a substituted parameter, even at the
              start.

              If, after quoting rules apply, <b>${</b><u>name</u><b>}</b> expands to an array, the replacements act on  each  element
              individually.   Note  also the effect of the <b>I</b> and <b>S</b> parameter expansion flags below; however, the
              flags <b>M</b>, <b>R</b>, <b>B</b>, <b>E</b> and <b>N</b> are not useful.

              For example,

                     <b>foo="twinkle</b> <b>twinkle</b> <b>little</b> <b>star"</b> <b>sub="t*e"</b> <b>rep="spy"</b>
                     <b>print</b> <b>${foo//${~sub}/$rep}</b>
                     <b>print</b> <b>${(S)foo//${~sub}/$rep}</b>

              Here, the `<b>~</b>' ensures that the text of <b>$sub</b> is treated as a pattern rather than  a  plain  string.
              In the first case, the longest match for <b>t*e</b> is substituted and the result is `<b>spy</b> <b>star</b>', while in
              the second case, the shortest matches are taken and the result is `<b>spy</b> <b>spy</b> <b>lispy</b> <b>star</b>'.

       <b>${#</b><u>spec</u><b>}</b>
              If  <u>spec</u>  is  one  of  the  above substitutions, substitute the length in characters of the result
              instead of the result itself.  If <u>spec</u> is an array expression, substitute the number  of  elements
              of  the  result.  This has the side-effect that joining is skipped even in quoted forms, which may
              affect other sub-expressions in <u>spec</u>.  Note that `<b>^</b>', `<b>=</b>', and `<b>~</b>', below, must appear to the left
              of `<b>#</b>' when these forms are combined.

              If the option <b>POSIX_IDENTIFIERS</b> is not set, and <u>spec</u>  is  a  simple  name,  then  the  braces  are
              optional;  this  is  true  even  for special parameters so e.g. <b>$#-</b> and <b>$#*</b> take the length of the
              string <b>$-</b> and the array <b>$*</b> respectively.  If <b>POSIX_IDENTIFIERS</b> is set, then  braces  are  required
              for the <b>#</b> to be treated in this fashion.

       <b>${^</b><u>spec</u><b>}</b>
       <b>${^^</b><u>spec</u><b>}</b>
              Turn on the <b>RC_EXPAND_PARAM</b> option for the evaluation of <u>spec</u>; if the `<b>^</b>' is doubled, turn it off.
              When  this  option is set, array expansions of the form <u>foo</u><b>${</b><u>xx</u><b>}</b><u>bar</u>, where the parameter <u>xx</u> is set
              to <b>(</b><u>a</u> <u>b</u> <u>c</u><b>)</b>, are substituted with `<u>fooabar</u> <u>foobbar</u> <u>foocbar</u>' instead of the default `<u>fooa</u>  <u>b</u>  <u>cbar</u>'.
              Note that an empty array will therefore cause all arguments to be removed.

              Internally,  each such expansion is converted into the equivalent list for brace expansion.  E.g.,
              <b>${^var}</b> becomes <b>{$var[1],$var[2],</b>...<b>}</b>, and  is  processed  as  described  in  the  section  `Brace
              Expansion'  below:  note,  however,  the  expansion  happens  immediately, with any explicit brace
              expansion happening later.  If word splitting is also in effect  the  <b>$var[</b><u>N</u><b>]</b>  may  themselves  be
              split into different list elements.

       <b>${=</b><u>spec</u><b>}</b>
       <b>${==</b><u>spec</u><b>}</b>
              Perform  word  splitting  using  the  rules  for  <b>SH_WORD_SPLIT</b> during the evaluation of <u>spec</u>, but
              regardless of whether the parameter appears in double quotes; if the `<b>=</b>' is doubled, turn it  off.
              This forces parameter expansions to be split into separate words before substitution, using <b>IFS</b> as
              a delimiter.  This is done by default in most other shells.

              Note  that  splitting  is applied to <u>word</u> in the assignment forms of <u>spec</u> <u>before</u> the assignment to
              <u>name</u> is performed.  This affects the result of array assignments with the <b>A</b> flag.

       <b>${~</b><u>spec</u><b>}</b>
       <b>${~~</b><u>spec</u><b>}</b>
              Turn on the <b>GLOB_SUBST</b> option for the evaluation of <u>spec</u>; if the `<b>~</b>'  is  doubled,  turn  it  off.
              When  this option is set, the string resulting from the expansion will be interpreted as a pattern
              anywhere  that  is  possible,  such  as  in  filename  expansion  and  filename   generation   and
              pattern-matching contexts like the right hand side of the `<b>=</b>' and `<b>!=</b>' operators in conditions.

              In  nested substitutions, note that the effect of the <b>~</b> applies to the result of the current level
              of substitution.  A surrounding pattern operation  on  the  result  may  cancel  it.   Hence,  for
              example,  if  the  parameter  <b>foo</b>  is set to <b>*</b>, <b>${~foo//\*/*.c}</b> is substituted by the pattern <b>*.c</b>,
              which may be expanded by filename generation, but <b>${${~foo}//\*/*.c}</b>  substitutes  to  the  string
              <b>*.c</b>, which will not be further expanded.

       If  a  <b>${</b>...<b>}</b>  type  parameter  expression or a <b>$(</b>...<b>)</b> type command substitution is used in place of <u>name</u>
       above, it is expanded first and the result is used as if it were the value of <u>name</u>.  Thus it is  possible
       to  perform  nested  operations:   <b>${${foo#head}%tail}</b> substitutes the value of <b>$foo</b> with both `<b>head</b>' and
       `<b>tail</b>' deleted.  The form with <b>$(</b>...<b>)</b> is often useful in combination with the flags described  next;  see
       the  examples  below.   Each  <u>name</u>  or  nested  <b>${</b>...<b>}</b> in a parameter expansion may also be followed by a
       subscript expression as described in <u>Array</u> <u>Parameters</u> in <u><a href="../man1/zshparam.1.html">zshparam</a></u>(1).

       Note that double quotes may appear around nested expressions, in which  case  only  the  part  inside  is
       treated  as  quoted;  for  example,  <b>${(f)"$(foo)"}</b>  quotes the result of <b>$(foo)</b>, but the flag `<b>(f)</b>' (see
       below) is applied using the rules for unquoted expansions.   Note  further  that  quotes  are  themselves
       nested  in this context; for example, in <b>"${(@f)"$(foo)"}"</b>, there are two sets of quotes, one surrounding
       the whole expression, the other (redundant) surrounding the <b>$(foo)</b> as before.

   <b>Parameter</b> <b>Expansion</b> <b>Flags</b>
       If the opening brace is directly followed by an opening  parenthesis,  the  string  up  to  the  matching
       closing parenthesis will be taken as a list of flags.  In cases where repeating a flag is meaningful, the
       repetitions  need  not  be  consecutive; for example, `(<b>q%q%q</b>)' means the same thing as the more readable
       `(<b>%%qqq</b>)'.  The following flags are supported:

       <b>#</b>      Evaluate the resulting words as numeric  expressions  and  interpret  these  as  character  codes.
              Output  the  corresponding characters.  Note that this form is entirely distinct from use of the <b>#</b>
              without parentheses.

              If the <b>MULTIBYTE</b> option is set and the number is greater than 127 (i.e. not an ASCII character) it
              is treated as a Unicode character.

       <b>%</b>      Expand all <b>%</b> escapes in the resulting words in the same way as in prompts (see EXPANSION OF PROMPT
              SEQUENCES in <u><a href="../man1/zshmisc.1.html">zshmisc</a></u>(1)). If this flag is given twice,  full  prompt  expansion  is  done  on  the
              resulting  words,  depending  on  the  setting of the <b>PROMPT_PERCENT</b>, <b>PROMPT_SUBST</b> and <b>PROMPT_BANG</b>
              options.

       <b>@</b>      In double quotes, array elements are put into separate words.  E.g., `<b>"${(@)foo}"</b>'  is  equivalent
              to  `<b>"${foo[@]}"</b>'  and  `<b>"${(@)foo[1,2]}"</b>' is the same as `<b>"$foo[1]"</b> <b>"$foo[2]"</b>'.  This is distinct
              from <u>field</u> <u>splitting</u> by the <b>f</b>, <b>s</b> or <b>z</b> flags, which still applies within each array element.

       <b>A</b>      Convert the substitution into an array expression, even if it otherwise would be scalar.  This has
              lower precedence than subscripting, so one level of nested expansion is  required  in  order  that
              subscripts apply to array elements.  Thus <b>${${(A)</b><u>name</u><b>}[1]}</b> yields the full value of <u>name</u> when <u>name</u>
              is scalar.

              This  assigns an array parameter with `<b>${</b>...<b>=</b>...<b>}</b>', `<b>${</b>...<b>:=</b>...<b>}</b>' or `<b>${</b>...<b>::=</b>...<b>}</b>'.  If this flag
              is repeated (as in `<b>AA</b>'), assigns an associative  array  parameter.   Assignment  is  made  before
              sorting  or  padding; if field splitting is active, the <u>word</u> part is split before assignment.  The
              <u>name</u> part may be a subscripted range for ordinary arrays; when assigning an associative array, the
              <u>word</u> part <u>must</u> be converted to an array, for example by using `<b>${(AA)=</b><u>name</u><b>=</b>...<b>}</b>' to activate field
              splitting.

              Surrounding context such as additional nesting or use of the value  in  a  scalar  assignment  may
              cause the array to be joined back into a single string again.

       <b>a</b>      Sort  in  array  index order; when combined with `<b>O</b>' sort in reverse array index order.  Note that
              `<b>a</b>' is therefore equivalent to the default but `<b>Oa</b>' is useful for obtaining an array's elements in
              reverse order.

       <b>b</b>      Quote with backslashes only characters that are special to pattern matching. This is  useful  when
              the contents of the variable are to be tested using <b>GLOB_SUBST</b>, including the <b>${~</b><u>...</u><b>}</b> switch.

              Quoting  using  one  of  the <b>q</b> family of flags does not work for this purpose since quotes are not
              stripped from non-pattern characters by <b>GLOB_SUBST</b>.  In other words,

                     <b>pattern=${(q)str}</b>
                     <b>[[</b> <b>$str</b> <b>=</b> <b>${~pattern}</b> <b>]]</b>

              works if <b>$str</b> is `<b>a*b</b>' but not if it is `<b>a</b> <b>b</b>', whereas

                     <b>pattern=${(b)str}</b>
                     <b>[[</b> <b>$str</b> <b>=</b> <b>${~pattern}</b> <b>]]</b>

              is always true for any possible value of <b>$str</b>.

       <b>c</b>      With <b>${#</b><u>name</u><b>}</b>, count the total number  of  characters  in  an  array,  as  if  the  elements  were
              concatenated with spaces between them.  This is not a true join of the array, so other expressions
              used with this flag may have an effect on the elements of the array before it is counted.

       <b>C</b>      Capitalize  the  resulting  words.   `Words'  in  this  case  refers  to sequences of alphanumeric
              characters separated by non-alphanumerics, <u>not</u> to words that result from field splitting.

       <b>D</b>      Assume the string or array elements contain directories and attempt to substitute the leading part
              of these by names.  The remainder of the path (the whole  of  it  if  the  leading  part  was  not
              substituted) is then quoted so that the whole string can be used as a shell argument.  This is the
              reverse of `<b>~</b>' substitution:  see the section FILENAME EXPANSION below.

       <b>e</b>      Perform  single  word  shell  expansions,  namely  <u>parameter</u>  <u>expansion</u>,  <u>command</u> <u>substitution</u> and
              <u>arithmetic</u> <u>expansion</u>, on the result. Such expansions can be nested but too deep recursion may have
              unpredictable effects.

       <b>f</b>      Split the result of the expansion at newlines. This is a shorthand for `<b>ps:\n:</b>'.

       <b>F</b>      Join the words of arrays together using newline as a separator.  This is a shorthand for `<b>pj:\n:</b>'.

       <b>g:</b><u>opts</u><b>:</b>
              Process escape sequences like the echo builtin when no  options  are  given  (<b>g::</b>).   With  the  <b>o</b>
              option,  octal escapes don't take a leading zero.  With the <b>c</b> option, sequences like `<b>^X</b>' are also
              processed.  With the <b>e</b> option, processes `<b>\M-t</b>' and similar  sequences  like  the  print  builtin.
              With  both  of  the  <b>o</b>  and <b>e</b> options, behaves like the print builtin except that in none of these
              modes is `<b>\c</b>' interpreted.

       <b>i</b>      Sort case-insensitively.  May be combined with `<b>n</b>' or `<b>O</b>'.

       <b>k</b>      If <u>name</u> refers to an associative array, substitute the <u>keys</u> (element names) rather than the values
              of the elements.  Used with subscripts (including ordinary arrays), force indices or  keys  to  be
              substituted  even  if the subscript form refers to values.  However, this flag may not be combined
              with subscript ranges.  With the <b>KSH_ARRAYS</b> option a subscript `<b>[*]</b>' or `<b>[@]</b>' is needed to operate
              on the whole array, as usual.

       <b>L</b>      Convert all letters in the result to lower case.

       <b>n</b>      Sort decimal integers numerically; if the first differing characters of two test strings  are  not
              digits,  sorting is lexical.  `<b>+</b>' and `<b>-</b>' are not treated specially; they are treated as any other
              non-digit.  Integers with more initial zeroes are sorted before those with fewer or  none.   Hence
              the  array  `<b>foo+24</b>  <b>foo1</b>  <b>foo02</b>  <b>foo2</b>  <b>foo3</b>  <b>foo20</b> <b>foo23</b>' is sorted into the order shown.  May be
              combined with `<b>i</b>' or `<b>O</b>'.

       <b>-</b>      As <b>n</b>, but a leading minus sign indicates a negative decimal integer.  A  leading  minus  sign  not
              followed  by  an  integer  does  not trigger numeric sorting.  Note that `<b>+</b>' signs are not handled
              specially (this may change in the future).

       <b>o</b>      Sort the resulting words in ascending order; if this appears on its own the sorting is lexical and
              case-sensitive (unless the locale renders it case-insensitive).  Sorting in ascending order is the
              default for other forms of sorting, so this is ignored if combined with `<b>a</b>', `<b>i</b>', `<b>n</b>' or `<b>-</b>'.

       <b>O</b>      Sort the resulting words in descending order; `<b>O</b>' without `<b>a</b>', `<b>i</b>', `<b>n</b>' or `<b>-</b>'  sorts  in  reverse
              lexical order.  May be combined with `<b>a</b>', `<b>i</b>', `<b>n</b>' or `<b>-</b>' to reverse the order of sorting.

       <b>P</b>      This  forces  the value of the parameter <u>name</u> to be interpreted as a further parameter name, whose
              value will be used where appropriate.  Note that flags set with  one  of  the  <b>typeset</b>  family  of
              commands  (in  particular  case transformations) are not applied to the value of <u>name</u> used in this
              fashion.

              If used with a nested parameter or command substitution, the result of that will  be  taken  as  a
              parameter  name  in  the  same way.  For example, if you have `<b>foo=bar</b>' and `<b>bar=baz</b>', the strings
              <b>${(P)foo}</b>, <b>${(P)${foo}}</b>, and <b>${(P)$(echo</b> <b>bar)}</b> will be expanded to `<b>baz</b>'.

              Likewise, if the reference is itself nested, the expression with the flag is treated as if it were
              directly replaced by the parameter name.  It is an error if this nested substitution  produces  an
              array  with  more  than  one  word.   For example, if `<b>name=assoc</b>' where the parameter <b>assoc</b> is an
              associative array, then `<b>${${(P)name}[elt]}</b>' refers to the element of the associative  subscripted
              `<b>elt</b>'.

       <b>q</b>      Quote  characters  that  are  special  to  the  shell  in  the  resulting  words with backslashes;
              unprintable or invalid characters are quoted using the <b>$'\</b><u>NNN</u><b>'</b> form, with separate quotes for each
              octet.

              If this flag is given twice, the resulting words are quoted in single quotes and if  it  is  given
              three  times,  the  words  are  quoted  in  double  quotes;  in these forms no special handling of
              unprintable or invalid characters is attempted.  If the flag is given four times,  the  words  are
              quoted  in  single  quotes preceded by a <b>$</b>.  Note that in all three of these forms quoting is done
              unconditionally, even if this does not change the way the resulting string would be interpreted by
              the shell.

              If a <b>q-</b> is given (only a single <b>q</b> may appear), a minimal form of single quoting is used that  only
              quotes  the  string  if  needed to protect special characters.  Typically this form gives the most
              readable output.

              If a <b>q+</b> is given, an extended form of minimal quoting is used that causes  unprintable  characters
              to  be rendered using <b>$'</b><u>...</u><b>'</b>.  This quoting is similar to that used by the output of values by the
              <b>typeset</b> family of commands.

       <b>Q</b>      Remove one level of quotes from the resulting words.

       <b>t</b>      Use a string describing the type of the parameter where the value of the parameter  would  usually
              appear.  This  string  consists  of  keywords separated by hyphens (`<b>-</b>'). The first keyword in the
              string describes the main type, it  can  be  one  of  `<b>scalar</b>',  `<b>array</b>',  `<b>integer</b>',  `<b>float</b>'  or
              `<b>association</b>'. The other keywords describe the type in more detail:

              <b>local</b>  for local parameters

              <b>left</b>   for left justified parameters

              <b>right_blanks</b>
                     for right justified parameters with leading blanks

              <b>right_zeros</b>
                     for right justified parameters with leading zeros

              <b>lower</b>  for parameters whose value is converted to all lower case when it is expanded

              <b>upper</b>  for parameters whose value is converted to all upper case when it is expanded

              <b>readonly</b>
                     for readonly parameters

              <b>tag</b>    for tagged parameters

              <b>tied</b>   for  parameters  tied to another parameter in the manner of <b>PATH</b> (colon-separated list) and
                     <b>path</b> (array), whether these are special parameters or user-defined with `<b>typeset</b> <b>-T</b>'

              <b>export</b> for exported parameters

              <b>unique</b> for arrays which keep only the first occurrence of duplicated values

              <b>hide</b>   for parameters with the `hide' flag

              <b>hideval</b>
                     for parameters with the `hideval' flag

              <b>special</b>
                     for special parameters defined by the shell

       <b>u</b>      Expand only the first occurrence of each unique word.

       <b>U</b>      Convert all letters in the result to upper case.

       <b>v</b>      Used with <b>k</b>, substitute (as two consecutive words) both the key and the value of each  associative
              array  element.   Used  with subscripts, force values to be substituted even if the subscript form
              refers to indices or keys.

       <b>V</b>      Make any special characters in the resulting words visible.

       <b>w</b>      With <b>${#</b><u>name</u><b>}</b>, count words in arrays or strings; the <b>s</b> flag may be used to set a word delimiter.

       <b>W</b>      Similar to <b>w</b> with the difference that empty words between repeated delimiters are also counted.

       <b>X</b>      With this flag, parsing errors occurring with the <b>Q</b>, <b>e</b> and <b>#</b> flags or the pattern  matching  forms
              such as `<b>${</b><u>name</u><b>#</b><u>pattern</u><b>}</b>' are reported.  Without the flag, errors are silently ignored.

       <b>z</b>      Split  the  result  of the expansion into words using shell parsing to find the words, i.e. taking
              into account any quoting in the value.   Comments  are  not  treated  specially  but  as  ordinary
              strings,  similar  to  interactive shells with the <b>INTERACTIVE_COMMENTS</b> option unset (however, see
              the <b>Z</b> flag below for related options)

              Note that this is done very late, even later than the `<b>(s)</b>' flag. So to access single words in the
              result use nested expansions as in `<b>${${(z)foo}[2]}</b>'.  Likewise,  to  remove  the  quotes  in  the
              resulting words use `<b>${(Q)${(z)foo}}</b>'.

       <b>0</b>      Split the result of the expansion on null bytes.  This is a shorthand for `<b>ps:\0:</b>'.

       The  following  flags  (except  <b>p</b>) are followed by one or more arguments as shown.  Any character, or the
       matching pairs `<b>(</b>...<b>)</b>', `<b>{</b>...<b>}</b>', `<b>[</b>...<b>]</b>', or `<b>&lt;</b>...<b>&gt;</b>', may be used in place of a colon as delimiters,  but
       note  that  when  a  flag  takes  more than one argument, a matched pair of delimiters must surround each
       argument.

       <b>p</b>      Recognize the same escape sequences as the <b>print</b> builtin in string arguments to any of  the  flags
              described below that follow this argument.

              Alternatively,  with  this option string arguments may be in the form <b>$</b><u>var</u> in which case the value
              of the variable is substituted.  Note this form is strict; the string argument  does  not  undergo
              general parameter expansion.

              For example,

                     <b>sep=:</b>
                     <b>val=a:b:c</b>
                     <b>print</b> <b>${(ps.$sep.)val}</b>

              splits the variable on a <b>:</b>.

       <b>~</b>      Strings inserted into the expansion by any of the flags below are to be treated as patterns.  This
              applies  to  the  string  arguments  of  flags  that  follow <b>~</b> within the same set of parentheses.
              Compare with <b>~</b> outside parentheses, which forces the entire substituted string to be treated as  a
              pattern.  Hence, for example,

                     <b>[[</b> <b>"?"</b> <b>=</b> <b>${(~j.|.)array}</b> <b>]]</b>

              treats  `<b>|</b>' as a pattern and succeeds if and only if <b>$array</b> contains the string `<b>?</b>' as an element.
              The <b>~</b> may be repeated to  toggle  the  behaviour;  its  effect  only  lasts  to  the  end  of  the
              parenthesised group.

       <b>j:</b><u>string</u><b>:</b>
              Join the words of arrays together using <u>string</u> as a separator.  Note that this occurs before field
              splitting by the <b>s:</b><u>string</u><b>:</b> flag or the <b>SH_WORD_SPLIT</b> option.

       <b>l:</b><u>expr</u><b>::</b><u>string1</u><b>::</b><u>string2</u><b>:</b>
              Pad  the  resulting  words  on  the left.  Each word will be truncated if required and placed in a
              field <u>expr</u> characters wide.

              The arguments <b>:</b><u>string1</u><b>:</b> and <b>:</b><u>string2</u><b>:</b> are optional; neither, the first,  or  both  may  be  given.
              Note that the same pairs of delimiters must be used for each of the three arguments.  The space to
              the left will be filled with <u>string1</u> (concatenated as often as needed) or spaces if <u>string1</u> is not
              given.   If  both  <u>string1</u> and <u>string2</u> are given, <u>string2</u> is inserted once directly to the left of
              each word, truncated if necessary, before <u>string1</u> is used to produce any remaining padding.

              If either of <u>string1</u> or <u>string2</u> is present but empty, i.e. there are two  delimiters  together  at
              that point, the first character of <b>$IFS</b> is used instead.

              If  the  <b>MULTIBYTE</b> option is in effect, the flag <b>m</b> may also be given, in which case widths will be
              used for the calculation of padding; otherwise individual  multibyte  characters  are  treated  as
              occupying one unit of width.

              If the <b>MULTIBYTE</b> option is not in effect, each byte in the string is treated as occupying one unit
              of width.

              Control  characters  are  always assumed to be one unit wide; this allows the mechanism to be used
              for generating repetitions of control characters.

       <b>m</b>      Only useful together with one of the flags <b>l</b> or <b>r</b> or with the <b>#</b> length operator when the <b>MULTIBYTE</b>
              option is in effect.  Use the character width reported by the system in calculating  how  much  of
              the  string  it  occupies  or  the overall length of the string.  Most printable characters have a
              width of one unit, however certain Asian character sets and  certain  special  effects  use  wider
              characters;  combining  characters  have  zero  width.   Non-printable  characters are arbitrarily
              counted as zero width; how they would actually be displayed will vary.

              If the <b>m</b> is repeated, the character either counts zero (if it has  zero  width),  else  one.   For
              printable character strings this has the effect of counting the number of glyphs (visibly separate
              characters),  except  for the case where combining characters themselves have non-zero width (true
              in certain alphabets).

       <b>r:</b><u>expr</u><b>::</b><u>string1</u><b>::</b><u>string2</u><b>:</b>
              As <b>l</b>, but pad the words on the right and insert <u>string2</u> immediately to the right of the string  to
              be padded.

              Left  and  right padding may be used together.  In this case the strategy is to apply left padding
              to the first half width of each of the resulting words, and right padding to the second half.   If
              the string to be padded has odd width the extra padding is applied on the left.

       <b>s:</b><u>string</u><b>:</b>
              Force field splitting at the separator <u>string</u>.  Note that a <u>string</u> of two or more characters means
              that all of them must match in sequence; this differs from the treatment of two or more characters
              in the <b>IFS</b> parameter.  See also the <b>=</b> flag and the <b>SH_WORD_SPLIT</b> option.  An empty string may also
              be given in which case every character will be a separate element.

              For  historical  reasons, the usual behaviour that empty array elements are retained inside double
              quotes is disabled for arrays generated by splitting; hence the following:

                     <b>line="one::three"</b>
                     <b>print</b> <b>-l</b> <b>"${(s.:.)line}"</b>

              produces two lines of output for <b>one</b> and <b>three</b> and elides  the  empty  field.   To  override  this
              behaviour, supply the `<b>(@)</b>' flag as well, i.e.  <b>"${(@s.:.)line}"</b>.

       <b>Z:</b><u>opts</u><b>:</b>
              As  <b>z</b>  but takes a combination of option letters between a following pair of delimiter characters.
              With no options the effect is identical to <b>z</b>.  The following options are available:

              <b>(Z+c+)</b> causes comments to be parsed as a string and retained; any field  in  the  resulting  array
                     beginning with an unquoted comment character is a comment.

              <b>(Z+C+)</b> causes  comments  to  be  parsed  and removed.  The rule for comments is standard: anything
                     between a word starting with the third character of <b>$HISTCHARS</b>, default <b>#</b>, up to  the  next
                     newline is a comment.

              <b>(Z+n+)</b> causes  unquoted newlines to be treated as ordinary whitespace, else they are treated as if
                     they are shell code delimiters and converted to semicolons.

              Options are combined within the same set of delimiters, e.g. <b>(Z+Cn+)</b>.

       <b>_:</b><u>flags</u><b>:</b>
              The underscore (<b>_</b>) flag is reserved for future use.  As of this revision  of  zsh,  there  are  no
              valid  <u>flags</u>; anything following an underscore, other than an empty pair of delimiters, is treated
              as an error, and the flag itself has no effect.

       The following flags are meaningful with the <b>${</b>...<b>#</b>...<b>}</b> or <b>${</b>...<b>%</b>...<b>}</b> forms.  The <b>S</b>, <b>I</b>, and  <b>*</b>  flags  may
       also be used with the <b>${</b>...<b>/</b>...<b>}</b> forms.

       <b>S</b>      With  <b>#</b>  or  <b>##</b>, search for the match that starts closest to the start of the string (a `substring
              match'). Of all matches at a particular position, <b>#</b> selects the shortest and <b>##</b> the longest:

                     <b>%</b> <b>str="aXbXc"</b>
                     <b>%</b> <b>echo</b> <b>${(S)str#X*}</b>
                     <b>abXc</b>
                     <b>%</b> <b>echo</b> <b>${(S)str##X*}</b>
                     <b>a</b>
                     <b>%</b>

              With <b>%</b> or <b>%%</b>, search for the match that starts closest to the end of the string:

                     <b>%</b> <b>str="aXbXc"</b>
                     <b>%</b> <b>echo</b> <b>${(S)str%X*}</b>
                     <b>aXbc</b>
                     <b>%</b> <b>echo</b> <b>${(S)str%%X*}</b>
                     <b>aXb</b>
                     <b>%</b>

              (Note that <b>%</b> and <b>%%</b> don't search for the match that ends closest to the end of the string, as  one
              might expect.)

              With  substitution  via  <b>${</b>...<b>/</b>...<b>}</b>  or  <b>${</b>...<b>//</b>...<b>}</b>, specifies non-greedy matching, i.e. that the
              shortest instead of the longest match should be replaced:

                     <b>%</b> <b>str="abab"</b>
                     <b>%</b> <b>echo</b> <b>${str/*b/_}</b>
                     <b>_</b>
                     <b>%</b> <b>echo</b> <b>${(S)str/*b/_}</b>
                     <b>_ab</b>
                     <b>%</b>

       <b>I:</b><u>expr</u><b>:</b>
              Search the <u>expr</u>th match (where <u>expr</u> evaluates to a number).  This only applies when searching  for
              substrings,  either  with the <b>S</b> flag, or with <b>${</b>...<b>/</b>...<b>}</b> (only the <u>expr</u>th match is substituted) or
              <b>${</b>...<b>//</b>...<b>}</b> (all matches from the <u>expr</u>th on are substituted).  The default is to  take  the  first
              match.

              The  <u>expr</u>th  match  is  counted  such  that there is either one or zero matches from each starting
              position in the string, although for global substitution matches overlapping previous replacements
              are ignored.  With the <b>${</b>...<b>%</b>...<b>}</b> and <b>${</b>...<b>%%</b>...<b>}</b> forms, the starting position for the match moves
              backwards from the end as the index increases, while with the other forms it  moves  forward  from
              the start.

              Hence with the string
                     <b>which</b> <b>switch</b> <b>is</b> <b>the</b> <b>right</b> <b>switch</b> <b>for</b> <b>Ipswich?</b>
              substitutions  of  the  form  <b>${</b>(<b>SI:</b><u>N</u><b>:</b>)<b>string#w*ch}</b>  as  <u>N</u>  increases from 1 will match and remove
              `<b>which</b>', `<b>witch</b>', `<b>witch</b>' and `<b>wich</b>'; the form using `<b>##</b>' will match and remove `<b>which</b>  <b>switch</b>  <b>is</b>
              <b>the</b>  <b>right</b>  <b>switch</b>  <b>for</b> <b>Ipswich</b>', `<b>witch</b> <b>is</b> <b>the</b> <b>right</b> <b>switch</b> <b>for</b> <b>Ipswich</b>', `<b>witch</b> <b>for</b> <b>Ipswich</b>' and
              `<b>wich</b>'. The form using `<b>%</b>' will remove the same matches as for `<b>#</b>', but in reverse order, and  the
              form using `<b>%%</b>' will remove the same matches as for `<b>##</b>' in reverse order.

       <b>*</b>      Enable  <b>EXTENDED_GLOB</b>  for  substitution  via  <b>${</b>...<b>/</b>...<b>}</b> or <b>${</b>...<b>//</b>...<b>}</b>.  Note that `<b>**</b>' does not
              disable extendedglob.

       <b>B</b>      Include the index of the beginning of the match in the result.

       <b>E</b>      Include the index one character past the end of the match in the result (note this is inconsistent
              with other uses of parameter index).

       <b>M</b>      Include the matched portion in the result.

       <b>N</b>      Include the length of the match in the result.

       <b>R</b>      Include the unmatched portion in the result (the <u>R</u>est).

   <b>Rules</b>
       Here is a summary of the rules for  substitution;  this  assumes  that  braces  are  present  around  the
       substitution,  i.e.  <b>${</b><u>...</u><b>}</b>.   Some  particular  examples are given below.  Note that the Zsh Development
       Group accepts <u>no</u> <u>responsibility</u> for any brain damage which may occur during the reading of the  following
       rules.

       <b>1.</b> <u>Nested</u> <u>substitution</u>
              If  multiple  nested <b>${</b><u>...</u><b>}</b> forms are present, substitution is performed from the inside outwards.
              At each level, the substitution takes account of whether the current  value  is  a  scalar  or  an
              array,  whether  the  whole  substitution  is in double quotes, and what flags are supplied to the
              current level of substitution, just as if the nested substitution were the outermost.   The  flags
              are  not  propagated  up  to enclosing substitutions; the nested substitution will return either a
              scalar or an array as determined by the flags, possibly adjusted for quoting.  All  the  following
              steps take place where applicable at all levels of substitution.

              Note  that,  unless  the `<b>(P)</b>' flag is present, the flags and any subscripts apply directly to the
              value of the nested substitution; for example, the expansion <b>${${foo}}</b> behaves exactly the same as
              <b>${foo}</b>.  When the `<b>(P)</b>' flag is present in a nested substitution, the other substitution rules are
              applied to the value <u>before</u> it  is  interpreted  as  a  name,  so  <b>${${(P)foo}}</b>  may  differ  from
              <b>${(P)foo}</b>.

              At  each  nested  level  of  substitution,  the substituted words undergo all forms of single-word
              substitution (i.e. not filename generation), including command substitution, arithmetic  expansion
              and  filename  expansion (i.e. leading <b>~</b> and <b>=</b>).  Thus, for example, <b>${${:-=cat}:h}</b> expands to the
              directory where the <b>cat</b> program resides.  (Explanation: the internal substitution has no parameter
              but a default value <b>=cat</b>, which is expanded by filename  expansion  to  a  full  path;  the  outer
              substitution then applies the modifier <b>:h</b> and takes the directory part of the path.)

       <b>2.</b> <u>Internal</u> <u>parameter</u> <u>flags</u>
              Any parameter flags set by one of the <b>typeset</b> family of commands, in particular the <b>-L</b>, <b>-R</b>, <b>-Z</b>, <b>-u</b>
              and  <b>-l</b> options for padding and capitalization, are applied directly to the parameter value.  Note
              these flags are options to the command, e.g. `<b>typeset</b> <b>-Z</b>'; they are not the same as the flags used
              within parameter substitutions.

              At the outermost level of substitution, the `<b>(P)</b>' flag (rule <b>4.</b>)   ignores  these  transformations
              and  uses  the  unmodified value of the parameter as the name to be replaced.  This is usually the
              desired behavior because padding may make the value syntactically illegal as a parameter name, but
              if capitalization changes are desired, use the <b>${${(P)foo}}</b> form (rule <b>25.</b>).

       <b>3.</b> <u>Parameter</u> <u>subscripting</u>
              If the value is a raw parameter reference with a subscript,  such  as  <b>${</b><u>var</u><b>[3]}</b>,  the  effect  of
              subscripting  is  applied  directly  to  the  parameter.   Subscripts are evaluated left to right;
              subsequent subscripts apply to the scalar or array value yielded by the previous subscript.   Thus
              if  <b>var</b> is an array, <b>${var[1][2]}</b> is the second character of the first word, but <b>${var[2,4][2]}</b> is
              the entire third word (the second word of the range of words two  through  four  of  the  original
              array).   Any  number  of  subscripts  may  appear.  Flags such as `<b>(k)</b>' and `<b>(v)</b>' which alter the
              result of subscripting are applied.

       <b>4.</b> <u>Parameter</u> <u>name</u> <u>replacement</u>
              At the outermost level of nesting only, the `<b>(P)</b>' flag is applied.  This treats the value  so  far
              as  a  parameter  name  (which  may  include  a  subscript  expression) and replaces that with the
              corresponding value.  This replacement occurs  later  if  the  `<b>(P)</b>'  flag  appears  in  a  nested
              substitution.

              If  the value so far names a parameter that has internal flags (rule <b>2.</b>), those internal flags are
              applied to the new value after replacement.

       <b>5.</b> <u>Double-quoted</u> <u>joining</u>
              If the value after this process is an array, and the substitution appears in  double  quotes,  and
              neither an `<b>(@)</b>' flag nor a `<b>#</b>' length operator is present at the current level, then words of the
              value  are joined with the first character of the parameter <b>$IFS</b>, by default a space, between each
              word (single word arrays are not modified).  If the `<b>(j)</b>'  flag  is  present,  that  is  used  for
              joining instead of <b>$IFS</b>.

       <b>6.</b> <u>Nested</u> <u>subscripting</u>
              Any  remaining  subscripts  (i.e.  of a nested substitution) are evaluated at this point, based on
              whether the value is an array or a scalar.  As with <b>3.</b>, multiple subscripts can appear.  Note that
              <b>${foo[2,4][2]}</b> is thus equivalent to <b>${${foo[2,4]}[2]}</b> and  also  to  <b>"${${(@)foo[2,4]}[2]}"</b>  (the
              nested  substitution  returns  an array in both cases), but not to <b>"${${foo[2,4]}[2]}"</b> (the nested
              substitution returns a scalar because of the quotes).

       <b>7.</b> <u>Modifiers</u>
              Any modifiers, as specified by a trailing `<b>#</b>',  `<b>%</b>',  `<b>/</b>'  (possibly  doubled)  or  by  a  set  of
              modifiers of the form `<b>:...</b>' (see the section `Modifiers' in the section `History Expansion'), are
              applied to the words of the value at this level.

       <b>8.</b> <u>Character</u> <u>evaluation</u>
              Any `<b>(#)</b>' flag is applied, evaluating the result so far numerically as a character.

       <b>9.</b> <u>Length</u>
              Any  initial  `<b>#</b>'  modifier,  i.e.  in  the  form  <b>${#</b><u>var</u><b>}</b>,  is used to evaluate the length of the
              expression so far.

       <b>10.</b> <u>Forced</u> <u>joining</u>
              If the `<b>(j)</b>' flag is present, or no `<b>(j)</b>' flag is present but the string is to be split  as  given
              by rule <b>11.</b>, and joining did not take place at rule <b>5.</b>, any words in the value are joined together
              using  the  given  string  or  the  first  character  of  <b>$IFS</b>  if none.  Note that the `<b>(F)</b>' flag
              implicitly supplies a string for joining in this manner.

       <b>11.</b> <u>Simple</u> <u>word</u> <u>splitting</u>
              If one of the `<b>(s)</b>' or `<b>(f)</b>' flags are present, or the `<b>=</b>' specifier was present  (e.g.  <b>${=</b><u>var</u><b>}</b>),
              the  word is split on occurrences of the specified string, or (for <b>=</b> with neither of the two flags
              present) any of the characters in <b>$IFS</b>.

              If no `<b>(s)</b>', `<b>(f)</b>' or `<b>=</b>' was given, but the word is not quoted and the  option  <b>SH_WORD_SPLIT</b>  is
              set,  the  word  is  split  on occurrences of any of the characters in <b>$IFS</b>.  Note this step, too,
              takes place at all levels of a nested substitution.

       <b>12.</b> <u>Case</u> <u>modification</u>
              Any case modification from one of the flags `<b>(L)</b>', `<b>(U)</b>' or `<b>(C)</b>' is applied.

       <b>13.</b> <u>Escape</u> <u>sequence</u> <u>replacement</u>
              First any replacements from the `<b>(g)</b>' flag are performed, then any  prompt-style  formatting  from
              the `<b>(%)</b>' family of flags is applied.

       <b>14.</b> <u>Quote</u> <u>application</u>
              Any quoting or unquoting using `<b>(q)</b>' and `<b>(Q)</b>' and related flags is applied.

       <b>15.</b> <u>Directory</u> <u>naming</u>
              Any directory name substitution using `<b>(D)</b>' flag is applied.

       <b>16.</b> <u>Visibility</u> <u>enhancement</u>
              Any modifications to make characters visible using the `<b>(V)</b>' flag are applied.

       <b>17.</b> <u>Lexical</u> <u>word</u> <u>splitting</u>
              If  the  '<b>(z)</b>'  flag  or one of the forms of the '<b>(Z)</b>' flag is present, the word is split as if it
              were a shell command line, so that quotation marks and other metacharacters  are  used  to  decide
              what  constitutes a word.  Note this form of splitting is entirely distinct from that described by
              rule <b>11.</b>: it does not use <b>$IFS</b>, and does not cause forced joining.

       <b>18.</b> <u>Uniqueness</u>
              If the result is an array and the `<b>(u)</b>' flag was present, duplicate elements are removed from  the
              array.

       <b>19.</b> <u>Ordering</u>
              If  the  result  is  still  an array and one of the `<b>(o)</b>' or `<b>(O)</b>' flags was present, the array is
              reordered.

       <b>20.</b> <b>RC_EXPAND_PARAM</b>
              At this point the decision is made whether any resulting array elements are to be combined element
              by element with surrounding text, as given by either the <b>RC_EXPAND_PARAM</b> option or the `<b>^</b>' flag.

       <b>21.</b> <u>Re-evaluation</u>
              Any `<b>(e)</b>' flag is  applied  to  the  value,  forcing  it  to  be  re-examined  for  new  parameter
              substitutions, but also for command and arithmetic substitutions.

       <b>22.</b> <u>Padding</u>
              Any padding of the value by the `<b>(l.</b><u>fill</u><b>.)</b>' or `<b>(r.</b><u>fill</u><b>.)</b>' flags is applied.

       <b>23.</b> <u>Semantic</u> <u>joining</u>
              In  contexts  where  expansion  semantics requires a single word to result, all words are rejoined
              with the first character of <b>IFS</b> between.  So in `<b>${(P)${(f)lines}}</b>' the value of <b>${lines}</b> is split
              at newlines, but then must be joined again before the `<b>(P)</b>' flag can be applied.

              If a single word is not required, this rule is skipped.

       <b>24.</b> <u>Empty</u> <u>argument</u> <u>removal</u>
              If the substitution does not appear in double quotes, any resulting zero-length argument,  whether
              from  a  scalar  or an element of an array, is elided from the list of arguments inserted into the
              command line.

              Strictly speaking, the removal happens later as the same happens with other forms of substitution;
              the point to note here is simply that it occurs after any of the above parameter operations.

       <b>25.</b> <u>Nested</u> <u>parameter</u> <u>name</u> <u>replacement</u>
              If the `<b>(P)</b>' flag is present and rule <b>4.</b> has not applied,  the  value  so  far  is  treated  as  a
              parameter  name  (which  may  include  a subscript expression) and replaced with the corresponding
              value, with internal flags (rule <b>2.</b>) applied to the new value.

   <b>Examples</b>
       The flag <b>f</b> is useful to split a double-quoted substitution line by line.  For  example,  <b>${(f)"$(&lt;</b><u>file</u><b>)"}</b>
       substitutes the contents of <u>file</u> divided so that each line is an element of the resulting array.  Compare
       this  with  the  effect  of <b>$(&lt;</b><u>file</u><b>)</b> alone, which divides the file up by words, or the same inside double
       quotes, which makes the entire content of the file a single string.

       The following illustrates the rules for nested parameter expansions.   Suppose  that  <b>$foo</b>  contains  the
       array <b>(bar</b> <b>baz)</b>:

       <b>"${(@)${foo}[1]}"</b>
              This  produces the result <b>b</b>.  First, the inner substitution <b>"${foo}"</b>, which has no array (<b>@</b>) flag,
              produces a single word result <b>"bar</b> <b>baz"</b>.  The outer substitution <b>"${(@)...[1]}"</b> detects that  this
              is a scalar, so that (despite the `<b>(@)</b>' flag) the subscript picks the first character.

       <b>"${${(@)foo}[1]}"</b>
              This  produces  the  result  `<b>bar</b>'.  In this case, the inner substitution <b>"${(@)foo}"</b> produces the
              array `<b>(bar</b> <b>baz)</b>'.  The outer substitution <b>"${...[1]}"</b> detects that this is an array and picks the
              first word.  This is similar to the simple case <b>"${foo[1]}"</b>.

       As an example of the rules for word splitting and joining, suppose <b>$foo</b> contains the array  `<b>(ax1</b>  <b>bx1)</b>'.
       Then

       <b>${(s/x/)foo}</b>
              produces the words `<b>a</b>', `<b>1</b> <b>b</b>' and `<b>1</b>'.

       <b>${(j/x/s/x/)foo}</b>
              produces `<b>a</b>', `<b>1</b>', `<b>b</b>' and `<b>1</b>'.

       <b>${(s/x/)foo%%1*}</b>
              produces  `<b>a</b>'  and  `  <b>b</b>' (note the extra space).  As substitution occurs before either joining or
              splitting, the operation  first generates the modified array <b>(ax</b> <b>bx)</b>, which is joined to give  <b>"ax</b>
              <b>bx"</b>,  and  then split to give `<b>a</b>', ` <b>b</b>' and `'.  The final empty string will then be elided, as it
              is not in double quotes.

</pre><h4><b>COMMAND</b> <b>SUBSTITUTION</b></h4><pre>
       A command enclosed in parentheses preceded by a dollar sign, like `<b>$(</b>...<b>)</b>', or quoted with grave accents,
       like `<b>`</b>...<b>`</b>', is replaced with  its  standard  output,  with  any  trailing  newlines  deleted.   If  the
       substitution is not enclosed in double quotes, the output is broken into words using the <b>IFS</b> parameter.

       The substitution `<b>$(cat</b> <u>foo</u><b>)</b>' may be replaced by the faster `<b>$(&lt;</b><u>foo</u><b>)</b>'.  In this case <u>foo</u> undergoes single
       word  shell  expansions  (<u>parameter</u>  <u>expansion</u>,  <u>command</u>  <u>substitution</u> and <u>arithmetic</u> <u>expansion</u>), but not
       filename generation.

       If the option <b>GLOB_SUBST</b> is set, the result of any unquoted command substitution, including  the  special
       form just mentioned, is eligible for filename generation.

</pre><h4><b>ARITHMETIC</b> <b>EXPANSION</b></h4><pre>
       A  string  of  the form `<b>$[</b><u>exp</u><b>]</b>' or `<b>$((</b><u>exp</u><b>))</b>' is substituted with the value of the arithmetic expression
       <u>exp</u>.  <u>exp</u> is subjected to <u>parameter</u> <u>expansion</u>, <u>command</u> <u>substitution</u> and <u>arithmetic</u> <u>expansion</u> before it is
       evaluated.  See the section `Arithmetic Evaluation'.

</pre><h4><b>BRACE</b> <b>EXPANSION</b></h4><pre>
       A string of the form `<u>foo</u><b>{</b><u>xx</u><b>,</b><u>yy</u><b>,</b><u>zz</u><b>}</b><u>bar</u>' is expanded to the individual words  `<u>fooxxbar</u>',  `<u>fooyybar</u>'  and
       `<u>foozzbar</u>'.   Left-to-right  order  is preserved.  This construct may be nested.  Commas may be quoted in
       order to include them literally in a word.

       An expression of the form `<b>{</b><u>n1</u><b>..</b><u>n2</u><b>}</b>', where <u>n1</u> and <u>n2</u> are integers, is expanded to every  number  between
       <u>n1</u>  and <u>n2</u> inclusive.  If either number begins with a zero, all the resulting numbers will be padded with
       leading zeroes to that minimum width, but for negative numbers the <b>-</b> character is also  included  in  the
       width.  If the numbers are in decreasing order the resulting sequence will also be in decreasing order.

       An  expression  of  the form `<b>{</b><u>n1</u><b>..</b><u>n2</u><b>..</b><u>n3</u><b>}</b>', where <u>n1</u>, <u>n2</u>, and <u>n3</u> are integers, is expanded as above, but
       only every <u>n3</u>th number starting from <u>n1</u> is output.  If <u>n3</u> is negative the numbers are output  in  reverse
       order,  this  is  slightly  different from simply swapping <u>n1</u> and <u>n2</u> in the case that the step <u>n3</u> doesn't
       evenly divide the range.  Zero padding can be specified in any of the three numbers, specifying it in the
       third can be useful to pad for example `<b>{-99..100..01}</b>' which is not possible to specify by putting  a  0
       on either of the first two numbers (i.e. pad to two characters).

       An  expression  of  the  form  `<b>{</b><u>c1</u><b>..</b><u>c2</u><b>}</b>',  where <u>c1</u> and <u>c2</u> are single characters (which may be multibyte
       characters), is expanded to every character in the range from <u>c1</u> to <u>c2</u> in whatever character sequence  is
       used  internally.  For characters with code points below 128 this is US ASCII (this is the only case most
       users will need).  If any intervening character is not printable, appropriate quotation is used to render
       it printable.  If the character sequence is reversed, the output is in reverse order,  e.g.  `<b>{d..a}</b>'  is
       substituted as `<b>d</b> <b>c</b> <b>b</b> <b>a</b>'.

       If  a brace expression matches none of the above forms, it is left unchanged, unless the option <b>BRACE_CCL</b>
       (an abbreviation for `brace character class') is set.  In that case, it is expanded  to  a  list  of  the
       individual  characters  between the braces sorted into the order of the characters in the ASCII character
       set (multibyte characters are not currently handled).  The syntax is similar to  a  <b>[</b>...<b>]</b>  expression  in
       filename  generation:  `<b>-</b>'  is  treated  specially to denote a range of characters, but `<b>^</b>' or `<b>!</b>' as the
       first character is treated normally.  For example, `<b>{abcdef0-9}</b>' expands to 16 words <b>0</b> <b>1</b> <b>2</b> <b>3</b> <b>4</b> <b>5</b> <b>6</b> <b>7</b> <b>8</b>  <b>9</b>
       <b>a</b> <b>b</b> <b>c</b> <b>d</b> <b>e</b> <b>f</b>.

       Note  that  brace  expansion  is  not  part  of  filename  generation  (globbing);  an expression such as
       <b>*/{foo,bar}</b> is split into two separate words <b>*/foo</b> and <b>*/bar</b> before filename generation takes place.   In
       particular,  note that this is liable to produce a `no match' error if <u>either</u> of the two expressions does
       not match; this is to be contrasted with <b>*/(foo|bar)</b>, which is treated as a single pattern but  otherwise
       has similar effects.

       To  combine  brace  expansion  with  array  expansion,  see  the  <b>${^</b><u>spec</u><b>}</b>  form described in the section
       `Parameter Expansion' above.

</pre><h4><b>FILENAME</b> <b>EXPANSION</b></h4><pre>
       Each word is checked to see if it begins with an unquoted `<b>~</b>'.  If it does, then the word up to a `<b>/</b>', or
       the end of the word if there is no `<b>/</b>', is checked to see if it can be substituted in  one  of  the  ways
       described here.  If so, then the `<b>~</b>' and the checked portion are replaced with the appropriate substitute
       value.

       A  `<b>~</b>'  by  itself  is  replaced  by the value of <b>$HOME</b>.  A `<b>~</b>' followed by a `<b>+</b>' or a `<b>-</b>' is replaced by
       current or previous working directory, respectively.

       A `<b>~</b>' followed by a number is replaced by the directory at that position in the directory stack.  `<b>~0</b>' is
       equivalent to `<b>~+</b>', and `<b>~1</b>' is the top of the stack.  `<b>~+</b>' followed by  a  number  is  replaced  by  the
       directory  at that position in the directory stack.  `<b>~+0</b>' is equivalent to `<b>~+</b>', and `<b>~+1</b>' is the top of
       the stack.  `<b>~-</b>' followed by a number is replaced by the directory that many positions from the bottom of
       the stack.  `<b>~-0</b>' is the bottom of the stack.  The <b>PUSHD_MINUS</b> option exchanges the effects of  `<b>~+</b>'  and
       `<b>~-</b>' where they are followed by a number.

   <b>Dynamic</b> <b>named</b> <b>directories</b>
       If  the function <b>zsh_directory_name</b> exists, or the shell variable <b>zsh_directory_name_functions</b> exists and
       contains an array of function names, then the functions are used to implement dynamic  directory  naming.
       The  functions  are  tried in order until one returns status zero, so it is important that functions test
       whether they can handle the case in question and return an appropriate status.

       A `<b>~</b>' followed by a string <u>namstr</u> in unquoted square brackets is treated specially as a dynamic directory
       name.  Note that the first unquoted closing square bracket always terminates <u>namstr</u>.  The shell  function
       is  passed  two arguments: the string <b>n</b> (for name) and <u>namstr</u>.  It should either set the array <b>reply</b> to a
       single element which is the directory corresponding to the name and  return  status  zero  (executing  an
       assignment  as  the  last  statement is usually sufficient), or it should return status non-zero.  In the
       former case the element of reply is used as the directory; in the latter case the substitution is  deemed
       to have failed.  If all functions fail and the option <b>NOMATCH</b> is set, an error results.

       The functions defined as above are also used to see if a directory can be turned into a name, for example
       when  printing the directory stack or when expanding <b>%~</b> in prompts.  In this case each function is passed
       two arguments: the string <b>d</b> (for directory) and the candidate for dynamic naming.   The  function  should
       either  return  non-zero  status,  if the directory cannot be named by the function, or it should set the
       array reply to consist of two elements: the first is the dynamic name for the directory (as would  appear
       within  `<b>~[</b><u>...</u><b>]</b>'),  and the second is the prefix length of the directory to be replaced.  For example, if
       the trial directory is <b>/home/myname/src/zsh</b> and the dynamic  name  for  <b>/home/myname/src</b>  (which  has  16
       characters) is <b>s</b>, then the function sets

              <b>reply=(s</b> <b>16)</b>

       The directory name so returned is compared with possible static names for parts of the directory path, as
       described  below; it is used if the prefix length matched (16 in the example) is longer than that matched
       by any static name.

       It is not a requirement that a function implements  both  <b>n</b>  and  <b>d</b>  calls;  for  example,  it  might  be
       appropriate  for certain dynamic forms of expansion not to be contracted to names.  In that case any call
       with the first argument <b>d</b> should cause a non-zero status to be returned.

       The completion system calls `<b>zsh_directory_name</b> <b>c</b>' followed by equivalent calls to elements of the  array
       <b>zsh_directory_name_functions</b>, if it exists, in order to complete dynamic names for directories.  The code
       for this should be as for any other completion function as described in <u><a href="../man1/zshcompsys.1.html">zshcompsys</a></u>(1).

       As  a  working example, here is a function that expands any dynamic names beginning with the string <b>p:</b> to
       directories below <b>/home/pws/perforce</b>.  In this simple case a static name for the directory would be  just
       as effective.

              <b>zsh_directory_name()</b> <b>{</b>
                <b>emulate</b> <b>-L</b> <b>zsh</b>
                <b>setopt</b> <b>extendedglob</b>
                <b>local</b> <b>-a</b> <b>match</b> <b>mbegin</b> <b>mend</b>
                <b>if</b> <b>[[</b> <b>$1</b> <b>=</b> <b>d</b> <b>]];</b> <b>then</b>
                  <b>#</b> <b>turn</b> <b>the</b> <b>directory</b> <b>into</b> <b>a</b> <b>name</b>
                  <b>if</b> <b>[[</b> <b>$2</b> <b>=</b> <b>(#b)(/home/pws/perforce/)([^/]##)*</b> <b>]];</b> <b>then</b>
                    <b>typeset</b> <b>-ga</b> <b>reply</b>
                    <b>reply=(p:$match[2]</b> <b>$((</b> <b>${#match[1]}</b> <b>+</b> <b>${#match[2]}</b> <b>))</b> <b>)</b>
                  <b>else</b>
                    <b>return</b> <b>1</b>
                  <b>fi</b>
                <b>elif</b> <b>[[</b> <b>$1</b> <b>=</b> <b>n</b> <b>]];</b> <b>then</b>
                  <b>#</b> <b>turn</b> <b>the</b> <b>name</b> <b>into</b> <b>a</b> <b>directory</b>
                  <b>[[</b> <b>$2</b> <b>!=</b> <b>(#b)p:(?*)</b> <b>]]</b> <b>&amp;&amp;</b> <b>return</b> <b>1</b>
                  <b>typeset</b> <b>-ga</b> <b>reply</b>
                  <b>reply=(/home/pws/perforce/$match[1])</b>
                <b>elif</b> <b>[[</b> <b>$1</b> <b>=</b> <b>c</b> <b>]];</b> <b>then</b>
                  <b>#</b> <b>complete</b> <b>names</b>
                  <b>local</b> <b>expl</b>
                  <b>local</b> <b>-a</b> <b>dirs</b>
                  <b>dirs=(/home/pws/perforce/*(/:t))</b>
                  <b>dirs=(p:${^dirs})</b>
                  <b>_wanted</b> <b>dynamic-dirs</b> <b>expl</b> <b>'dynamic</b> <b>directory'</b> <b>compadd</b> <b>-S\]</b> <b>-a</b> <b>dirs</b>
                  <b>return</b>
                <b>else</b>
                  <b>return</b> <b>1</b>
                <b>fi</b>
                <b>return</b> <b>0</b>
              <b>}</b>

   <b>Static</b> <b>named</b> <b>directories</b>
       A  `<b>~</b>'  followed  by  anything not already covered consisting of any number of alphanumeric characters or
       underscore (`<b>_</b>'), hyphen (`<b>-</b>'), or dot (`<b>.</b>') is looked up as a named directory, and replaced by the value
       of that named directory if found.  Named directories are typically home  directories  for  users  on  the
       system.  They may also be defined if the text after the `<b>~</b>' is the name of a string shell parameter whose
       value  begins  with  a  `<b>/</b>'.   Note  that trailing slashes will be removed from the path to the directory
       (though the original parameter is not modified).

       It is also possible to define directory names using the <b>-d</b> option to the <b>hash</b> builtin.

       When the shell prints a path (e.g. when expanding <b>%~</b> in prompts or when printing  the  directory  stack),
       the  path is checked to see if it has a named directory as its prefix.  If so, then the prefix portion is
       replaced with a `<b>~</b>' followed by the name of the directory.  The shorter of the two ways of  referring  to
       the  directory is used, i.e. either the directory name or the full path; the name is used if they are the
       same length.  The parameters <b>$PWD</b> and <b>$OLDPWD</b> are never abbreviated in this fashion.

   <b>`='</b> <b>expansion</b>
       If a word begins with an unquoted `<b>=</b>' and the <b>EQUALS</b> option is set, the remainder of the word is taken as
       the name of a command.  If a command exists by that name, the word is replaced by the  full  pathname  of
       the command.

   <b>Notes</b>
       Filename  expansion  is  performed  on  the  right  hand  side of a parameter assignment, including those
       appearing after commands of the <b>typeset</b> family.  In this case, the right hand side will be treated  as  a
       colon-separated  list  in  the  manner  of the <b>PATH</b> parameter, so that a `<b>~</b>' or an `<b>=</b>' following a `<b>:</b>' is
       eligible for expansion.  All such behaviour can be disabled by quoting the `<b>~</b>', the  `<b>=</b>',  or  the  whole
       expression (but not simply the colon); the <b>EQUALS</b> option is also respected.

       If  the  option <b>MAGIC_EQUAL_SUBST</b> is set, any unquoted shell argument in the form `<u>identifier</u><b>=</b><u>expression</u>'
       becomes eligible for file expansion as described in the previous paragraph.  Quoting the first  `<b>=</b>'  also
       inhibits this.

</pre><h4><b>FILENAME</b> <b>GENERATION</b></h4><pre>
       If  a  word contains an unquoted instance of one of the characters `<b>*</b>', `<b>(</b>', `<b>|</b>', `<b>&lt;</b>', `<b>[</b>', or `<b>?</b>', it is
       regarded as a pattern for filename generation, unless the <b>GLOB</b> option is  unset.   If  the  <b>EXTENDED_GLOB</b>
       option is set, the `<b>^</b>' and `<b>#</b>' characters also denote a pattern; otherwise they are not treated specially
       by the shell.

       The  word  is replaced with a list of sorted filenames that match the pattern.  If no matching pattern is
       found, the shell gives an error message, unless the <b>NULL_GLOB</b> option is set, in which case  the  word  is
       deleted; or unless the <b>NOMATCH</b> option is unset, in which case the word is left unchanged.

       In  filename  generation,  the  character  `<b>/</b>'  must  be  matched explicitly; also, a `<b>.</b>' must be matched
       explicitly at the beginning of a pattern or after a `<b>/</b>', unless the <b>GLOB_DOTS</b> option is set.  No filename
       generation pattern matches the files `<b>.</b>' or `<b>..</b>'.  In other instances of pattern matching,  the  `<b>/</b>'  and
       `<b>.</b>' are not treated specially.

   <b>Glob</b> <b>Operators</b>
       <b>*</b>      Matches any string, including the null string.

       <b>?</b>      Matches any character.

       <b>[</b>...<b>]</b>  Matches  any  of the enclosed characters.  Ranges of characters can be specified by separating two
              characters by a `<b>-</b>'.  A `<b>-</b>' or `<b>]</b>' may be matched by including it as the first  character  in  the
              list.   There  are  also  several  named  classes  of  characters, in the form `<b>[:</b><u>name</u><b>:]</b>' with the
              following meanings.  The first set use the macros provided by the operating system to test for the
              given character combinations, including any modifications due  to  local  language  settings,  see
              <u><a href="../man3/ctype.3.html">ctype</a></u>(3):

              <b>[:alnum:]</b>
                     The character is alphanumeric

              <b>[:alpha:]</b>
                     The character is alphabetic

              <b>[:ascii:]</b>
                     The character is 7-bit, i.e. is a single-byte character without the top bit set.

              <b>[:blank:]</b>
                     The character is a blank character

              <b>[:cntrl:]</b>
                     The character is a control character

              <b>[:digit:]</b>
                     The character is a decimal digit

              <b>[:graph:]</b>
                     The character is a printable character other than whitespace

              <b>[:lower:]</b>
                     The character is a lowercase letter

              <b>[:print:]</b>
                     The character is printable

              <b>[:punct:]</b>
                     The character is printable but neither alphanumeric nor whitespace

              <b>[:space:]</b>
                     The character is whitespace

              <b>[:upper:]</b>
                     The character is an uppercase letter

              <b>[:xdigit:]</b>
                     The character is a hexadecimal digit

              Another  set  of  named  classes  is  handled  internally by the shell and is not sensitive to the
              locale:

              <b>[:IDENT:]</b>
                     The character is allowed to form part of a shell identifier, such as a parameter name; this
                     test respects the <b>POSIX_IDENTIFIERS</b> option

              <b>[:IFS:]</b>
                     The character is used as an input field separator, i.e. is contained in the <b>IFS</b> parameter

              <b>[:IFSSPACE:]</b>
                     The character is an IFS white space  character;  see  the  documentation  for  <b>IFS</b>  in  the
                     <u><a href="../man1/zshparam.1.html">zshparam</a></u>(1) manual page.

              <b>[:INCOMPLETE:]</b>
                     Matches  a  byte  that  starts an incomplete multibyte character.  Note that there may be a
                     sequence of more than one bytes  that  taken  together  form  the  prefix  of  a  multibyte
                     character.    To  test  for  a  potentially  incomplete  byte  sequence,  use  the  pattern
                     `<b>[[:INCOMPLETE:]]*</b>'.  This will never match a sequence  starting  with  a  valid  multibyte
                     character.

              <b>[:INVALID:]</b>
                     Matches  a  byte  that  does  not  start  a  valid multibyte character.  Note this may be a
                     continuation byte of an incomplete multibyte character as any part of  a  multibyte  string
                     consisting of invalid and incomplete multibyte characters is treated as single bytes.

              <b>[:WORD:]</b>
                     The  character  is  treated  as  part of a word; this test is sensitive to the value of the
                     <b>WORDCHARS</b> parameter

              Note that the square brackets are additional to those enclosing the whole set of characters, so to
              test for a single alphanumeric character you need `<b>[[:alnum:]]</b>'.  Named character sets can be used
              alongside other types, e.g. `<b>[[:alpha:]0-9]</b>'.

       <b>[^</b>...<b>]</b>
       <b>[!</b>...<b>]</b> Like <b>[</b>...<b>]</b>, except that it matches any character which is not in the given set.

       <b>&lt;</b>[<u>x</u>]<b>-</b>[<u>y</u>]<b>&gt;</b>
              Matches any number in the range <u>x</u> to <u>y</u>, inclusive.  Either of the numbers may be omitted  to  make
              the  range open-ended; hence `<b>&lt;-&gt;</b>' matches any number.  To match individual digits, the <b>[</b>...<b>]</b> form
              is more efficient.

              Be careful when using other wildcards adjacent to patterns of this form; for example, <b>&lt;0-9&gt;*</b>  will
              actually  match any number whatsoever at the start of the string, since the `<b>&lt;0-9&gt;</b>' will match the
              first digit, and the `<b>*</b>' will match any others.  This is a trap for the unwary, but is in fact  an
              inevitable  consequence  of the rule that the longest possible match always succeeds.  Expressions
              such as `<b>&lt;0-9&gt;[^[:digit:]]*</b>' can be used instead.

       <b>(</b>...<b>)</b>  Matches the enclosed pattern.  This is used for grouping.  If the <b>KSH_GLOB</b> option is set,  then  a
              `<b>@</b>',  `<b>*</b>',  `<b>+</b>', `<b>?</b>' or `<b>!</b>' immediately preceding the `<b>(</b>' is treated specially, as detailed below.
              The option <b>SH_GLOB</b> prevents bare parentheses from being used in  this  way,  though  the  <b>KSH_GLOB</b>
              option is still available.

              Note  that grouping cannot extend over multiple directories: it is an error to have a `<b>/</b>' within a
              group (this only applies for patterns used in filename generation).  There is  one  exception:   a
              group  of  the  form  <b>(</b><u>pat</u><b>/)#</b>  appearing  as  a  complete  path  segment  can  match a sequence of
              directories.  For example, <b>foo/(a*/)#bar</b> matches <b>foo/bar</b>, <b>foo/any/bar</b>,  <b>foo/any/anyother/bar</b>,  and
              so on.

       <u>x</u><b>|</b><u>y</u>    Matches either <u>x</u> or <u>y</u>.  This operator has lower precedence than any other.  The `<b>|</b>' character must
              be within parentheses, to avoid interpretation as a pipeline.  The alternatives are tried in order
              from left to right.

       <b>^</b><u>x</u>     (Requires  <b>EXTENDED_GLOB</b>  to  be  set.)  Matches anything except the pattern <u>x</u>.  This has a higher
              precedence than `<b>/</b>', so `<b>^foo/bar</b>' will search directories in `<b>.</b>' except `<b>./foo</b>' for a file  named
              `<b>bar</b>'.

       <u>x</u><b>~</b><u>y</u>    (Requires  <b>EXTENDED_GLOB</b> to be set.)  Match anything that matches the pattern <u>x</u> but does not match
              <u>y</u>.  This has lower precedence than any operator except `<b>|</b>', so `<b>*/*~foo/bar</b>' will search  for  all
              files  in  all directories in `<b>.</b>'  and then exclude `<b>foo/bar</b>' if there was such a match.  Multiple
              patterns can be excluded by `<u>foo</u><b>~</b><u>bar</u><b>~</b><u>baz</u>'.  In the exclusion pattern (<u>y</u>),  `<b>/</b>'  and  `<b>.</b>'  are  not
              treated specially the way they usually are in globbing.

       <u>x</u><b>#</b>     (Requires  <b>EXTENDED_GLOB</b>  to  be  set.)   Matches zero or more occurrences of the pattern <u>x</u>.  This
              operator has high precedence; `<b>12#</b>' is equivalent to `<b>1(2#)</b>', rather than `<b>(12)#</b>'.  It is an error
              for an unquoted `<b>#</b>' to follow something which cannot be repeated; this includes an empty string, a
              pattern already followed by `<b>##</b>', or parentheses when part of a  <b>KSH_GLOB</b>  pattern  (for  example,
              `<b>!(</b><u>foo</u><b>)#</b>' is invalid and must be replaced by `<b>*(!(</b><u>foo</u><b>))</b>').

       <u>x</u><b>##</b>    (Requires  <b>EXTENDED_GLOB</b>  to  be  set.)   Matches  one or more occurrences of the pattern <u>x</u>.  This
              operator has high precedence; `<b>12##</b>' is equivalent to `<b>1(2##)</b>', rather  than  `<b>(12)##</b>'.   No  more
              than  two  active  `<b>#</b>'  characters  may  appear  together.   (Note  the  potential clash with glob
              qualifiers in the form `<b>1(2##)</b>' which should therefore be avoided.)

   <b>ksh-like</b> <b>Glob</b> <b>Operators</b>
       If the <b>KSH_GLOB</b> option is set, the effects of parentheses can be modified by a preceding `<b>@</b>',  `<b>*</b>',  `<b>+</b>',
       `<b>?</b>' or `<b>!</b>'.  This character need not be unquoted to have special effects, but the `<b>(</b>' must be.

       <b>@(</b>...<b>)</b> Match the pattern in the parentheses.  (Like `<b>(</b>...<b>)</b>'.)

       <b>*(</b>...<b>)</b> Match any number of occurrences.  (Like `<b>(</b>...<b>)#</b>', except that recursive directory searching is not
              supported.)

       <b>+(</b>...<b>)</b> Match  at least one occurrence.  (Like `<b>(</b>...<b>)##</b>', except that recursive directory searching is not
              supported.)

       <b>?(</b>...<b>)</b> Match zero or one occurrence.  (Like `<b>(|</b>...<b>)</b>'.)

       <b>!(</b>...<b>)</b> Match anything but the expression in parentheses.  (Like `<b>(^(</b>...<b>))</b>'.)

   <b>Precedence</b>
       The precedence of the operators given above is (highest) `<b>^</b>',  `<b>/</b>',  `<b>~</b>',  `<b>|</b>'  (lowest);  the  remaining
       operators  are  simply  treated from left to right as part of a string, with `<b>#</b>' and `<b>##</b>' applying to the
       shortest  possible  preceding  unit  (i.e.  a  character,  `<b>?</b>',  `<b>[</b>...<b>]</b>',  `<b>&lt;</b>...<b>&gt;</b>',  or  a  parenthesised
       expression).   As mentioned above, a `<b>/</b>' used as a directory separator may not appear inside parentheses,
       while a `<b>|</b>' must do so; in patterns used in other contexts than filename generation (for example, in <b>case</b>
       statements and tests within `<b>[[</b>...<b>]]</b>'), a `<b>/</b>' is not special; and `<b>/</b>' is also not  special  after  a  `<b>~</b>'
       appearing outside parentheses in a filename pattern.

   <b>Globbing</b> <b>Flags</b>
       There  are  various flags which affect any text to their right up to the end of the enclosing group or to
       the end of the pattern; they require the <b>EXTENDED_GLOB</b> option. All take the form <b>(#</b><u>X</u><b>)</b> where  <u>X</u>  may  have
       one of the following forms:

       <b>i</b>      Case  insensitive:   upper  or  lower  case  characters  in  the pattern match upper or lower case
              characters.

       <b>l</b>      Lower case characters in the pattern match upper or lower case characters; upper  case  characters
              in the pattern still only match upper case characters.

       <b>I</b>      Case sensitive:  locally negates the effect of <b>i</b> or <b>l</b> from that point on.

       <b>b</b>      Activate  backreferences  for  parenthesised groups in the pattern; this does not work in filename
              generation.  When a pattern with a set of active parentheses is matched, the  strings  matched  by
              the groups are stored in the array <b>$match</b>, the indices of the beginning of the matched parentheses
              in  the  array  <b>$mbegin</b>,  and the indices of the end in the array <b>$mend</b>, with the first element of
              each array corresponding to the first parenthesised group,  and  so  on.   These  arrays  are  not
              otherwise  special  to  the  shell.   The  indices  use  the  same  convention  as  does parameter
              substitution, so that elements of <b>$mend</b> and <b>$mbegin</b> may be  used  in  subscripts;  the  <b>KSH_ARRAYS</b>
              option  is  respected.   Sets  of globbing flags are not considered parenthesised groups; only the
              first nine active parentheses can be referenced.

              For example,

                     <b>foo="a_string_with_a_message"</b>
                     <b>if</b> <b>[[</b> <b>$foo</b> <b>=</b> <b>(a|an)_(#b)(*)</b> <b>]];</b> <b>then</b>
                       <b>print</b> <b>${foo[$mbegin[1],$mend[1]]}</b>
                     <b>fi</b>

              prints `<b>string_with_a_message</b>'.  Note that the first set of parentheses is  before  the  <b>(#b)</b>  and
              does not create a backreference.

              Backreferences  work  with  all forms of pattern matching other than filename generation, but note
              that when  performing  matches  on  an  entire  array,  such  as  <b>${</b><u>array</u><b>#</b><u>pattern</u><b>}</b>,  or  a  global
              substitution,  such as <b>${</b><u>param</u><b>//</b><u>pat</u><b>/</b><u>repl</u><b>}</b>, only the data for the last match remains available.  In
              the case of global replacements this may still be useful.  See the example for the <b>m</b> flag below.

              The numbering of backreferences strictly follows the order of the opening parentheses from left to
              right in the pattern string, although sets of parentheses may be nested.  There are special  rules
              for  parentheses  followed  by `<b>#</b>' or `<b>##</b>'.  Only the last match of the parenthesis is remembered:
              for example, in `<b>[[</b> <b>abab</b> <b>=</b> <b>(#b)([ab])#</b> <b>]]</b>', only the final `<b>b</b>' is stored in <b>match[1]</b>.  Thus  extra
              parentheses  may  be  necessary  to match the complete segment: for example, use `<b>X((ab|cd)#)Y</b>' to
              match a whole string of either `<b>ab</b>' or `<b>cd</b>' between `<b>X</b>' and `<b>Y</b>',  using  the  value  of  <b>$match[1]</b>
              rather than <b>$match[2]</b>.

              If  the  match  fails  none  of the parameters is altered, so in some cases it may be necessary to
              initialise them beforehand.  If some of the backreferences fail to match -- which happens if  they
              are  in  an  alternate  branch which fails to match, or if they are followed by <b>#</b> and matched zero
              times -- then the matched string is set to the empty string, and the start and end indices are set
              to -1.

              Pattern matching with backreferences is slightly slower than without.

       <b>B</b>      Deactivate backreferences, negating the effect of the <b>b</b> flag from that point on.

       <b>c</b><u>N</u><b>,</b><u>M</u>   The flag <b>(#c</b><u>N</u><b>,</b><u>M</u><b>)</b> can be used anywhere that the <b>#</b> or  <b>##</b>  operators  can  be  used  except  in  the
              expressions  `<b>(*/)#</b>' and `<b>(*/)##</b>' in filename generation, where `<b>/</b>' has special meaning; it cannot
              be combined with other globbing flags and a bad pattern error occurs if it is  misplaced.   It  is
              equivalent  to the form <b>{</b><u>N</u><b>,</b><u>M</u><b>}</b> in regular expressions.  The previous character or group is required
              to match between <u>N</u> and <u>M</u> times, inclusive.  The form <b>(#c</b><u>N</u><b>)</b> requires exactly <b>N</b> matches;  <b>(#c,</b><u>M</u><b>)</b>  is
              equivalent  to specifying <u>N</u> as 0; <b>(#c</b><u>N</u><b>,)</b> specifies that there is no maximum limit on the number of
              matches.

       <b>m</b>      Set references to the match data for the entire string matched; this is similar to backreferencing
              and does not work in filename generation.  The flag must be in effect at the end of  the  pattern,
              i.e.  not  local  to  a group. The parameters <b>$MATCH</b>,  <b>$MBEGIN</b> and <b>$MEND</b> will be set to the string
              matched and to the indices of the beginning and end of the string,  respectively.   This  is  most
              useful in parameter substitutions, as otherwise the string matched is obvious.

              For example,

                     <b>arr=(veldt</b> <b>jynx</b> <b>grimps</b> <b>waqf</b> <b>zho</b> <b>buck)</b>
                     <b>print</b> <b>${arr//(#m)[aeiou]/${(U)MATCH}}</b>

              forces  all  the  matches  (i.e.  all vowels) into uppercase, printing `<b>vEldt</b> <b>jynx</b> <b>grImps</b> <b>wAqf</b> <b>zhO</b>
              <b>bUck</b>'.

              Unlike backreferences, there is no speed penalty for using match references, other than the  extra
              substitutions required for the replacement strings in cases such as the example shown.

       <b>M</b>      Deactivate the <b>m</b> flag, hence no references to match data will be created.

       <b>a</b><u>num</u>   Approximate  matching: <u>num</u> errors are allowed in the string matched by the pattern.  The rules for
              this are described in the next subsection.

       <b>s</b>, <b>e</b>   Unlike the other flags, these have only a local effect, and each must appear on its  own:   `<b>(#s)</b>'
              and  `<b>(#e)</b>'  are  the  only  valid  forms.  The `<b>(#s)</b>' flag succeeds only at the start of the test
              string, and the `<b>(#e)</b>' flag succeeds only at the end of the test string; they  correspond  to  `<b>^</b>'
              and  `<b>$</b>'  in standard regular expressions.  They are useful for matching path segments in patterns
              other than those in filename generation (where path segments are in any case treated  separately).
              For  example,  `<b>*((#s)|/)test((#e)|/)*</b>'  matches  a  path  segment  `<b>test</b>' in any of the following
              strings: <b>test</b>, <b>test/at/start</b>, <b>at/end/test</b>, <b>in/test/middle</b>.

              Another use is in parameter substitution; for  example  `<b>${array/(#s)A*Z(#e)}</b>'  will  remove  only
              elements  of  an array which match the complete pattern `<b>A*Z</b>'.  There are other ways of performing
              many operations of this type, however the combination of the substitution operations `<b>/</b>' and  `<b>//</b>'
              with the `<b>(#s)</b>' and `<b>(#e)</b>' flags provides a single simple and memorable method.

              Note  that  assertions of the form `<b>(^(#s))</b>' also work, i.e. match anywhere except at the start of
              the string, although this actually means `anything except a zero-length portion at  the  start  of
              the  string';  you need to use `<b>(""~(#s))</b>' to match a zero-length portion of the string not at the
              start.

       <b>q</b>      A `<b>q</b>' and everything up to the closing parenthesis of  the  globbing  flags  are  ignored  by  the
              pattern  matching  code.   This is intended to support the use of glob qualifiers, see below.  The
              result is that the pattern `<b>(#b)(*).c(#q.)</b>' can be used both for globbing and for matching against
              a string.  In the former case, the `<b>(#q.)</b>' will be treated as a glob qualifier and the `<b>(#b)</b>' will
              not be useful, while in the latter case the `<b>(#b)</b>' is useful for backreferences  and  the  `<b>(#q.)</b>'
              will  be  ignored.   Note  that  colon  modifiers  in  the glob qualifiers are also not applied in
              ordinary pattern matching.

       <b>u</b>      Respect the current locale in determining the presence  of  multibyte  characters  in  a  pattern,
              provided  the shell was compiled with <b>MULTIBYTE_SUPPORT</b>.  This overrides the <b>MULTIBYTE</b> option; the
              default behaviour is taken from the option.  Compare <b>U</b>.  (Mnemonic: typically multibyte characters
              are from Unicode in the UTF-8 encoding, although any extension of ASCII supported  by  the  system
              library may be used.)

       <b>U</b>      All  characters  are  considered to be a single byte long.  The opposite of <b>u</b>.  This overrides the
              <b>MULTIBYTE</b> option.

       For example, the test string <b>fooxx</b> can be matched  by  the  pattern  <b>(#i)FOOXX</b>,  but  not  by  <b>(#l)FOOXX</b>,
       <b>(#i)FOO(#I)XX</b> or <b>((#i)FOOX)X</b>.  The string <b>(#ia2)readme</b> specifies case-insensitive matching of <b>readme</b> with
       up to two errors.

       When  using  the  ksh  syntax  for  grouping  both  <b>KSH_GLOB</b>  and  <b>EXTENDED_GLOB</b> must be set and the left
       parenthesis should be preceded by <b>@</b>.  Note also that the flags do not affect letters inside <b>[</b>...<b>]</b> groups,
       in other words <b>(#i)[a-z]</b> still matches only lowercase letters.  Finally, note that when  examining  whole
       paths case-insensitively every directory must be searched for all files which match, so that a pattern of
       the form <b>(#i)/foo/bar/...</b> is potentially slow.

   <b>Approximate</b> <b>Matching</b>
       When  matching approximately, the shell keeps a count of the errors found, which cannot exceed the number
       specified in the <b>(#a</b><u>num</u><b>)</b> flags.  Four types of error are recognised:

       1.     Different characters, as in <b>fooxbar</b> and <b>fooybar</b>.

       2.     Transposition of characters, as in <b>banana</b> and <b>abnana</b>.

       3.     A character missing in the target string, as with the pattern <b>road</b> and target string <b>rod</b>.

       4.     An extra character appearing in the target string, as with <b>stove</b> and <b>strove</b>.

       Thus, the pattern <b>(#a3)abcd</b> matches <b>dcba</b>, with the errors occurring by using the first rule twice and the
       second once, grouping the string as <b>[d][cb][a]</b> and <b>[a][bc][d]</b>.

       Non-literal parts of the pattern must match exactly, including  characters  in  character  ranges:  hence
       <b>(#a1)???</b>   matches  strings  of  length four, by applying rule 4 to an empty part of the pattern, but not
       strings of length two, since all the <b>?</b> must match.  Other characters which must match exactly are initial
       dots in filenames (unless the <b>GLOB_DOTS</b> option is set), and all slashes in filenames, so that <b>a/bc</b> is two
       errors from <b>ab/c</b> (the slash cannot be transposed with another character).  Similarly, errors are  counted
       separately for non-contiguous strings in the pattern, so that <b>(ab|cd)ef</b> is two errors from <b>aebf</b>.

       When  using  exclusion  via  the  <b>~</b> operator, approximate matching is treated entirely separately for the
       excluded part and must be activated  separately.   Thus,  <b>(#a1)README~READ_ME</b>  matches  <b>READ.ME</b>  but  not
       <b>READ_ME</b>,  as  the  trailing  <b>READ_ME</b> is matched without approximation.  However, <b>(#a1)README~(#a1)READ_ME</b>
       does not match any pattern of the form <b>READ</b><u>?</u><b>ME</b> as all such forms are now excluded.

       Apart from exclusions, there is only one overall error count; however, the maximum errors allowed may  be
       altered  locally,  and  this can be delimited by grouping.  For example, <b>(#a1)cat((#a0)dog)fox</b> allows one
       error in total, which may not occur in the <b>dog</b>  section,  and  the  pattern  <b>(#a1)cat(#a0)dog(#a1)fox</b>  is
       equivalent.   Note  that  the  point at which an error is first found is the crucial one for establishing
       whether to use approximation; for example, <b>(#a1)abc(#a0)xyz</b> will not match  <b>abcdxyz</b>,  because  the  error
       occurs at the `<b>x</b>', where approximation is turned off.

       Entire  path  segments may be matched approximately, so that `<b>(#a1)/foo/d/is/available/at/the/bar</b>' allows
       one error in any path segment.  This is much less efficient than without the <b>(#a1)</b>, however, since  every
       directory  in  the  path must be scanned for a possible approximate match.  It is best to place the <b>(#a1)</b>
       after any path segments which are known to be correct.

   <b>Recursive</b> <b>Globbing</b>
       A pathname component of the form `<b>(</b><u>foo</u><b>/)#</b>' matches a path consisting of zero or more directories matching
       the pattern <u>foo</u>.

       As a shorthand, `<b>**/</b>' is equivalent to `<b>(*/)#</b>'; note that this therefore matches  files  in  the  current
       directory as well as subdirectories.  Thus:

              <b>ls</b> <b>-ld</b> <b>--</b> <b>(*/)#bar</b>

       or

              <b>ls</b> <b>-ld</b> <b>--</b> <b>**/bar</b>

       does  a  recursive  directory  search  for files named `<b>bar</b>' (potentially including the file `<b>bar</b>' in the
       current directory).  This form does not follow symbolic links; the alternative form `<b>***/</b>' does,  but  is
       otherwise  identical.  Neither of these can be combined with other forms of globbing within the same path
       segment; in that case, the `<b>*</b>' operators revert to their usual effect.

       Even shorter forms are available when  the  option  <b>GLOB_STAR_SHORT</b>  is  set.   In  that  case  if  no  <b>/</b>
       immediately follows a <b>**</b> or <b>***</b> they are treated as if both a <b>/</b> plus a further <b>*</b> are present.  Hence:

              <b>setopt</b> <b>GLOBSTARSHORT</b>
              <b>ls</b> <b>-ld</b> <b>--</b> <b>**.c</b>

       is equivalent to

              <b>ls</b> <b>-ld</b> <b>--</b> <b>**/*.c</b>

   <b>Glob</b> <b>Qualifiers</b>
       Patterns  used  for  filename  generation  may  end in a list of qualifiers enclosed in parentheses.  The
       qualifiers specify which filenames that otherwise match  the  given  pattern  will  be  inserted  in  the
       argument list.

       If  the  option  <b>BARE_GLOB_QUAL</b>  is  set,  then  a  trailing  set of parentheses containing no `<b>|</b>' or `<b>(</b>'
       characters (or `<b>~</b>' if it is special) is taken as a set of glob qualifiers.   A  glob  subexpression  that
       would  normally  be  taken as glob qualifiers, for example `<b>(^x)</b>', can be forced to be treated as part of
       the glob pattern by doubling the parentheses, in this case producing `<b>((^x))</b>'.

       If the option <b>EXTENDED_GLOB</b> is set, a different syntax for glob qualifiers is available,  namely  `<b>(#q</b><u>x</u><b>)</b>'
       where <u>x</u> is any of the same glob qualifiers used in the other format.  The qualifiers must still appear at
       the  end  of  the  pattern.   However, with this syntax multiple glob qualifiers may be chained together.
       They are treated as a logical AND of the individual sets of flags.  Also, as the syntax  is  unambiguous,
       the  expression  will  be treated as glob qualifiers just as long any parentheses contained within it are
       balanced; appearance of `<b>|</b>', `<b>(</b>' or `<b>~</b>' does not  negate  the  effect.   Note  that  qualifiers  will  be
       recognised  in  this  form  even  if  a bare glob qualifier exists at the end of the pattern, for example
       `<b>*(#q*)(.)</b>' will recognise executable regular files if both options are set; however, mixed syntax should
       probably be avoided for the sake of clarity.  Note  that  within  conditions  using  the  `<b>[[</b>'  form  the
       presence  of  a parenthesised expression <b>(#q</b><u>...</u><b>)</b> at the end of a string indicates that globbing should be
       performed; the expression may include glob qualifiers, but it is also valid if it is simply  <b>(#q)</b>.   This
       does  not  apply  to  the  right  hand  side of pattern match operators as the syntax already has special
       significance.

       A qualifier may be any one of the following:

       <b>/</b>      directories

       <b>F</b>      `full' (i.e. non-empty)  directories.   Note  that  the  opposite  sense  <b>(^F)</b>  expands  to  empty
              directories and all non-directories.  Use <b>(/^F)</b> for empty directories.

       <b>.</b>      plain files

       <b>@</b>      symbolic links

       <b>=</b>      sockets

       <b>p</b>      named pipes (FIFOs)

       <b>*</b>      executable plain files (0100 or 0010 or 0001)

       <b>%</b>      device files (character or block special)

       <b>%b</b>     block special files

       <b>%c</b>     character special files

       <b>r</b>      owner-readable files (0400)

       <b>w</b>      owner-writable files (0200)

       <b>x</b>      owner-executable files (0100)

       <b>A</b>      group-readable files (0040)

       <b>I</b>      group-writable files (0020)

       <b>E</b>      group-executable files (0010)

       <b>R</b>      world-readable files (0004)

       <b>W</b>      world-writable files (0002)

       <b>X</b>      world-executable files (0001)

       <b>s</b>      setuid files (04000)

       <b>S</b>      setgid files (02000)

       <b>t</b>      files with the sticky bit (01000)

       <b>f</b><u>spec</u>  files  with  access rights matching <u>spec</u>. This <u>spec</u> may be a octal number optionally preceded by a
              `<b>=</b>', a `<b>+</b>', or a `<b>-</b>'. If none of these characters is given, the behavior is the same as  for  `<b>=</b>'.
              The  octal  number describes the mode bits to be expected, if combined with a `<b>=</b>', the value given
              must match the file-modes exactly, with a `<b>+</b>', at least the bits in the given number must  be  set
              in the file-modes, and with a `<b>-</b>', the bits in the number must not be set. Giving a `<b>?</b>' instead of
              a octal digit anywhere in the number ensures that the corresponding bits in the file-modes are not
              checked, this is only useful in combination with `<b>=</b>'.

              If the qualifier `<b>f</b>' is followed by any other character anything up to the next matching character
              (`<b>[</b>',  `<b>{</b>',  and  `<b>&lt;</b>' match `<b>]</b>', `<b>}</b>', and `<b>&gt;</b>' respectively, any other character matches itself) is
              taken as a list of comma-separated <u>sub-spec</u>s. Each <u>sub-spec</u> may  be  either  an  octal  number  as
              described  above  or  a list of any of the characters `<b>u</b>', `<b>g</b>', `<b>o</b>', and `<b>a</b>', followed by a `<b>=</b>', a
              `<b>+</b>', or a `<b>-</b>', followed by a list of any of the characters `<b>r</b>', `<b>w</b>', `<b>x</b>',  `<b>s</b>',  and  `<b>t</b>',  or  an
              octal  digit. The first list of characters specify which access rights are to be checked. If a `<b>u</b>'
              is given, those for the owner of the file are used, if a `<b>g</b>' is given,  those  of  the  group  are
              checked,  a `<b>o</b>' means to test those of other users, and the `<b>a</b>' says to test all three groups. The
              `<b>=</b>', `<b>+</b>', and `<b>-</b>' again says how the modes are  to  be  checked  and  have  the  same  meaning  as
              described for the first form above. The second list of characters finally says which access rights
              are  to  be  expected: `<b>r</b>' for read access, `<b>w</b>' for write access, `<b>x</b>' for the right to execute the
              file (or to search a directory), `<b>s</b>' for the setuid and setgid bits, and `<b>t</b>' for the sticky bit.

              Thus, `<b>*(f70?)</b>' gives the files for which the owner has read, write, and execute  permission,  and
              for  which other group members have no rights, independent of the permissions for other users. The
              pattern `<b>*(f-100)</b>' gives all files for which the owner  does  not  have  execute  permission,  and
              `<b>*(f:gu+w,o-rx:)</b>'  gives  the files for which the owner and the other members of the group have at
              least write permission, and for which other users don't have read or execute permission.

       <b>e</b><u>string</u>
       <b>+</b><u>cmd</u>   The <u>string</u> will be executed as shell code.  The filename will be included in the list if and  only
              if the code returns a zero status (usually the status of the last command).

              In  the  first form, the first character after the `<b>e</b>' will be used as a separator and anything up
              to the next matching separator will be taken  as the <u>string</u>; `<b>[</b>', `<b>{</b>', and `<b>&lt;</b>' match `<b>]</b>', `<b>}</b>', and
              `<b>&gt;</b>', respectively, while any other character matches itself. Note that expansions must  be  quoted
              in  the  <u>string</u>  to  prevent  them  from  being  expanded before globbing is done.  <u>string</u> is then
              executed as shell code.  The string  <b>globqual</b>  is  appended  to  the  array  <b>zsh_eval_context</b>  the
              duration of execution.

              During  the  execution of <u>string</u> the filename currently being tested is available in the parameter
              <b>REPLY</b>; the parameter may be altered to a string to be  inserted  into  the  list  instead  of  the
              original  filename.   In  addition,  the parameter <b>reply</b> may be set to an array or a string, which
              overrides the value of <b>REPLY</b>.  If set to an array, the latter is inserted into  the  command  line
              word by word.

              For  example,  suppose  a  directory  contains  a  single  file  `<b>lonely</b>'.   Then  the  expression
              `<b>*(e:'reply=(${REPLY}{1,2})':)</b>' will cause the words `<b>lonely1</b>' and `<b>lonely2</b>' to be  inserted  into
              the command line.  Note the quoting of <u>string</u>.

              The  form <b>+</b><u>cmd</u> has the same effect, but no delimiters appear around <u>cmd</u>.  Instead, <u>cmd</u> is taken as
              the longest sequence of characters following the <b>+</b> that are alphanumeric or underscore.  Typically
              <u>cmd</u> will be the name of a shell function that contains the appropriate test.  For example,

                     <b>nt()</b> <b>{</b> <b>[[</b> <b>$REPLY</b> <b>-nt</b> <b>$NTREF</b> <b>]]</b> <b>}</b>
                     <b>NTREF=reffile</b>
                     <b>ls</b> <b>-ld</b> <b>--</b> <b>*(+nt)</b>

              lists all files in the directory that have been modified more recently than <b>reffile</b>.

       <b>d</b><u>dev</u>   files on the device <u>dev</u>

       <b>l</b>[<b>-</b>|<b>+</b>]<u>ct</u>
              files having a link count less than <u>ct</u> (<b>-</b>), greater than <u>ct</u> (<b>+</b>), or equal to <u>ct</u>

       <b>U</b>      files owned by the effective user ID

       <b>G</b>      files owned by the effective group ID

       <b>u</b><u>id</u>    files owned by user ID <u>id</u> if that is a number.  Otherwise, <u>id</u> specifies a user name: the character
              after the `<b>u</b>' will be taken as a separator and  the  string  between  it  and  the  next  matching
              separator will be taken as a user name.  The starting separators `<b>[</b>', `<b>{</b>', and `<b>&lt;</b>' match the final
              separators  `<b>]</b>',  `<b>}</b>',  and  `<b>&gt;</b>',  respectively; any other character matches itself.  The selected
              files are those owned by this user.  For example, `<b>u:foo:</b>' or `<b>u[foo]</b>' selects files owned by user
              `<b>foo</b>'.

       <b>g</b><u>id</u>    like <b>u</b><u>id</u> but with group IDs or names

       <b>a</b>[<b>Mwhms</b>][<b>-</b>|<b>+</b>]<u>n</u>
              files accessed exactly <u>n</u> days ago.  Files accessed within the last <u>n</u> days  are  selected  using  a
              negative value for <u>n</u> (<b>-</b><u>n</u>).  Files accessed more than <u>n</u> days ago are selected by a positive <u>n</u> value
              (<b>+</b><u>n</u>).   Optional  unit  specifiers  `<b>M</b>',  `<b>w</b>',  `<b>h</b>', `<b>m</b>' or `<b>s</b>' (e.g. `<b>ah5</b>') cause the check to be
              performed  with  months  (of  30  days),  weeks,  hours,  minutes  or  seconds  instead  of  days,
              respectively.  An explicit `<b>d</b>' for days is also allowed.

              Any  fractional  part  of  the  difference  between  the  access  time and the current part in the
              appropriate units is ignored in the comparison.  For instance, `<b>echo</b>  <b>*(ah-5)</b>'  would  echo  files
              accessed  within  the last five hours, while `<b>echo</b> <b>*(ah+5)</b>' would echo files accessed at least six
              hours ago, as times strictly between five and six hours are treated as five hours.

       <b>m</b>[<b>Mwhms</b>][<b>-</b>|<b>+</b>]<u>n</u>
              like the file access qualifier, except that it uses the file modification time.

       <b>c</b>[<b>Mwhms</b>][<b>-</b>|<b>+</b>]<u>n</u>
              like the file access qualifier, except that it uses the file inode change time.

       <b>L</b>[<b>+</b>|<b>-</b>]<u>n</u>
              files less than <u>n</u> bytes (<b>-</b>), more than <u>n</u> bytes (<b>+</b>), or exactly <u>n</u> bytes in length.

              If this flag is directly followed by a <u>size</u> <u>specifier</u> `<b>k</b>' (`<b>K</b>'), `<b>m</b>' (`<b>M</b>'),  or  `<b>p</b>'  (`<b>P</b>')  (e.g.
              `<b>Lk-50</b>')  the check is performed with kilobytes, megabytes, or blocks (of 512 bytes) instead.  (On
              some systems additional specifiers are available for gigabytes, `<b>g</b>' or `<b>G</b>', and terabytes, `<b>t</b>'  or
              `<b>T</b>'.)  If  a  size  specifier  is  used  a file is regarded as "exactly" the size if the file size
              rounded up to the next unit is equal to the test size.  Hence `<b>*(Lm1)</b>' matches files from  1  byte
              up  to  1  Megabyte  inclusive.   Note  also  that the set of files "less than" the test size only
              includes files that would not match the equality test; hence `<b>*(Lm-1)</b>' only matches files of  zero
              size.

       <b>^</b>      negates all qualifiers following it

       <b>-</b>      toggles  between  making  the  qualifiers  work on symbolic links (the default) and the files they
              point to, if any; any symbolic link for whose target the `<b>stat</b>' system call  fails  (whatever  the
              cause of the failure) is treated as a file in its own right

       <b>M</b>      sets the <b>MARK_DIRS</b> option for the current pattern

       <b>T</b>      appends  a  trailing  qualifier mark to the filenames, analogous to the <b>LIST_TYPES</b> option, for the
              current pattern (overrides <b>M</b>)

       <b>N</b>      sets the <b>NULL_GLOB</b> option for the current pattern

       <b>D</b>      sets the <b>GLOB_DOTS</b> option for the current pattern

       <b>n</b>      sets the <b>NUMERIC_GLOB_SORT</b> option for the current pattern

       <b>Y</b><u>n</u>     enables short-circuit mode: the pattern will expand to at  most  <u>n</u>  filenames.   If  more  than  <u>n</u>
              matches exist, only the first <u>n</u> matches in directory traversal order will be considered.

              Implies <b>oN</b> when no <b>o</b><u>c</u> qualifier is used.

       <b>o</b><u>c</u>     specifies  how  the  names  of  the  files should be sorted. The following values of <u>c</u> sort in the
              following ways:

              <b>n</b>      By name.
              <b>L</b>      By the size (length) of the files.
              <b>l</b>      By number of links.
              <b>a</b>      By time of last access, youngest first.
              <b>m</b>      By time of last modification, youngest first.
              <b>c</b>      By time of last inode change, youngest first.
              <b>d</b>      By directories: files in subdirectories appear before those in  the  current  directory  at
                     each  level  of the search -- this is best combined with other criteria, for example `<b>odon</b>'
                     to sort on names for files within the same directory.
              <b>N</b>      No sorting is performed.
              <b>e</b><u>string</u>
              <b>+</b><u>cmd</u>   Sort by shell code (see below).

              Note that the modifiers <b>^</b> and <b>-</b> are used, so `<b>*(^-oL)</b>' gives a list of all files  sorted  by  file
              size  in  descending  order,  following  any  symbolic  links.   Unless <b>oN</b> is used, multiple order
              specifiers may occur to resolve ties.

              The default sorting is <b>n</b> (by name) unless the <b>Y</b> glob qualifier is used, in  which  case  it  is  <b>N</b>
              (unsorted).

              <b>oe</b>  and  <b>o+</b>  are  special cases; they are each followed by shell code, delimited as for the <b>e</b> glob
              qualifier and the <b>+</b> glob qualifier respectively (see  above).   The  code  is  executed  for  each
              matched  file  with the parameter <b>REPLY</b> set to the name of the file on entry and <b>globsort</b> appended
              to <b>zsh_eval_context</b>.  The code should modify the parameter <b>REPLY</b> in some fashion.  On return,  the
              value  of  the  parameter is used instead of the file name as the string on which to sort.  Unlike
              other sort operators, <b>oe</b> and <b>o+</b> may be  repeated,  but  note  that  the  maximum  number  of  sort
              operators of any kind that may appear in any glob expression is 12.

       <b>O</b><u>c</u>     like  `<b>o</b>', but sorts in descending order; i.e. `<b>*(^o</b><u>c</u><b>)</b>' is the same as `<b>*(O</b><u>c</u><b>)</b>' and `<b>*(^O</b><u>c</u><b>)</b>' is the
              same as `<b>*(o</b><u>c</u><b>)</b>'; `<b>Od</b>' puts files in the current directory before those in subdirectories  at  each
              level of the search.

       <b>[</b><u>beg</u>[<b>,</b><u>end</u>]<b>]</b>
              specifies  which  of  the matched filenames should be included in the returned list. The syntax is
              the same as for array subscripts. <u>beg</u> and the optional <u>end</u> may be mathematical expressions. As  in
              parameter subscripting they may be negative to make them count from the last match backward. E.g.:
              `<b>*(-OL[1,3])</b>' gives a list of the names of the three largest files.

       <b>P</b><u>string</u>
              The  <u>string</u>  will  be prepended to each glob match as a separate word.  <u>string</u> is delimited in the
              same way as arguments to the <b>e</b> glob qualifier described above.  The qualifier can be repeated; the
              words are prepended separately so that the resulting command line contains the words in  the  same
              order they were given in the list of glob qualifiers.

              A typical use for this is to prepend an option before all occurrences of a file name; for example,
              the pattern `<b>*(P:-f:)</b>' produces the command line arguments `<b>-f</b> <u>file1</u> <b>-f</b> <u>file2</u> ...'

              If  the  modifier  <b>^</b> is active, then <u>string</u> will be appended instead of prepended.  Prepending and
              appending is done independently so both can be used on the same glob expression;  for  example  by
              writing  `<b>*(P:foo:^P:bar:^P:baz:)</b>'  which  produces  the command line arguments `<b>foo</b> <b>baz</b> <u>file1</u> <b>bar</b>
              ...'

       More than one of these lists can be combined, separated by commas. The whole list matches if at least one
       of the sublists matches (they are `or'ed, the qualifiers in the sublists are `and'ed).  Some  qualifiers,
       however, affect all matches generated, independent of the sublist in which they are given.  These are the
       qualifiers `<b>M</b>', `<b>T</b>', `<b>N</b>', `<b>D</b>', `<b>n</b>', `<b>o</b>', `<b>O</b>' and the subscripts given in brackets (`<b>[</b><u>...</u><b>]</b>').

       If  a `<b>:</b>' appears in a qualifier list, the remainder of the expression in parenthesis is interpreted as a
       modifier (see the section `Modifiers' in  the  section  `History  Expansion').   Each  modifier  must  be
       introduced  by  a  separate  `<b>:</b>'.   Note  also  that the result after modification does not have to be an
       existing file.  The name of any existing file can be followed by a modifier of the form `<b>(:</b><u>...</u><b>)</b>' even  if
       no actual filename generation is performed, although note that the presence of the parentheses causes the
       entire expression to be subjected to any global pattern matching options such as <b>NULL_GLOB</b>. Thus:

              <b>ls</b> <b>-ld</b> <b>--</b> <b>*(-/)</b>

       lists all directories and symbolic links that point to directories, and

              <b>ls</b> <b>-ld</b> <b>--</b> <b>*(-@)</b>

       lists all broken symbolic links, and

              <b>ls</b> <b>-ld</b> <b>--</b> <b>*(%W)</b>

       lists all world-writable device files in the current directory, and

              <b>ls</b> <b>-ld</b> <b>--</b> <b>*(W,X)</b>

       lists all files in the current directory that are world-writable or world-executable, and

              <b>print</b> <b>-rC1</b> <b>/tmp/foo*(u0^@:t)</b>

       outputs  the basename of all root-owned files beginning with the string `<b>foo</b>' in <b><a href="file:/tmp">/tmp</a></b>, ignoring symlinks,
       and

              <b>ls</b> <b>-ld</b> <b>--</b> <b>*.*~(lex|parse).[ch](^D^l1)</b>

       lists all files having a link count of one whose names contain a dot (but not those starting with a  dot,
       since <b>GLOB_DOTS</b> is explicitly switched off) except for <b>lex.c</b>, <b>lex.h</b>, <b>parse.c</b> and <b>parse.h</b>.

              <b>print</b> <b>-rC1</b> <b>b*.pro(#q:s/pro/shmo/)(#q.:s/builtin/shmiltin/)</b>

       demonstrates  how  colon  modifiers and other qualifiers may be chained together.  The ordinary qualifier
       `<b>.</b>' is applied first, then the colon modifiers in order from left to right.  So if <b>EXTENDED_GLOB</b>  is  set
       and the base pattern matches the regular file <b>builtin.pro</b>, the shell will print `<b>shmiltin.shmo</b>'.

zsh 5.9                                           May 14, 2022                                        <u><a href="../man1/ZSHEXPN.1.html">ZSHEXPN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>