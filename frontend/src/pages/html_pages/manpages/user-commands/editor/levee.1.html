<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>levee - A Screen Oriented Editor.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/levee">levee_4.0-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>levee</b> - A Screen Oriented Editor.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>levee</b> [<u>+address</u>] [<u>file</u> <b>...</b>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Levee is a screen oriented  editor based on the  Unix editor "vi".  It provides a terse,  powerful way to
       enter and edit text.  (However,  if you want a word-processor,  you're better off with WordStar.)

       Levee  is  a  moded editor.  It operates in 3 modes  -- visual, command, and insert.  Most of the editing
       work is done is visual mode,  file reading and  writing is  done in  command mode,  and insert mode  does
       what you would expect.

       When  you  enter  Levee,   you may specify  an  address to start editing at.  These addresses  are in the
       same  format as command mode addresses,  except that a naked + will put  you at the very end of the file.

       Levee is copyright (c) 1982-2015 by David L. Parsons. (See the notice at the end  of  this  document  for
       distribution terms.)

</pre><h4><b>COMMAND</b> <b>MODE</b> <b>COMMANDS</b></h4><pre>
       These  commands  are  used  for   editing  new  files,   writing modified files,  changing options, doing
       substitutions,  and a subset of  the visual commands.  They take as  input whole lines,   terminated   by
       return (to execute),  or  escape (to abort.)

       Command mode is reached by typing ":" or "Q" from visual mode.  If you enter command  mode by typing ":",
       Levee  will  execute   one  command,   then return  to  visual  mode after prompting you  with  "[more]".
       If you type anything except a space or return, Levee will accept another  command,  and  so  forth.   If,
       however,  you  enter  command  mode  via  "Q",  Levee will  remain in  command mode  until  you enter the
       "visual" command.

   <b>A</b> <b>NOTE</b> <b>ON</b> <b>COMMAND</b> <b>SYNTAX</b>
       A command may be preceded by an optional line-range.  If you do not provide a line-range,  Levee will use
       the default line-range shown by the command.  A line-range is one or two address  specifications  in  the
       following format:

              (<b>.</b>|<b>$</b>|<b>'x</b>|<b>#</b>) [ (<b>+</b>|<b>-</b>) (<b>/</b><u>patt</u><b>/</b>|<b>?</b><u>patt</u><b>?</b>|<b>#</b>) ]

              <b>.</b>      current line.

              <b>$</b>      last line.

              <b>'x</b>     the line with mark x on it.

              <b>#</b>      line #.

       For  example,  ".-5,.+5p" will print every line within ten lines of the current line.  "$-5" is the fifth
       line from the end of the file,  and "/end/+2"  is the second line past  the  next   occurrence   of   the
       pattern "end".  Patterns  may  be regular expressions (see below.)

       Also,   a  naked line-range will  set the current  line to the first line in the range  and print all the
       lines in that range. "1,10" sets the current line to 1,  then prints lines 1 to 10.

       If you specify a non-existent line in a range, the command
        will abort and Levee will tell you "bad address".

   <b>Command</b> <b>mode</b> <b>commands</b>
       <b>args</b>   Show the current argument list, if one exists. The file that you are  currently  editing  will  be
              framed by '[' and ']'.

       <u>(.,.)</u><b>change</b>
              Delete lines, then enter insert mode.

       <u>(.,.)</u><b>delete</b>
              Delete lines. Deleted lines are stored in a Yank Buffer for later putback with "put".

       <b>edit[!]</b> <b>[file]</b>
              Discard  the  current  file and start editing a new one. If changes were made to the current file,
              you must enter "edit!"  to force Levee to discard the changes. If you do not specify  a  filename,
              Levee will try to reedit the current filename.

              When  Levee  reads in a new file, it will tell you how many bytes it read in, or [overflow] if the
              file is larger than the internal buffer (256000 bytes on most platforms; 20k on USCD Pascal.)

       <b>execmode</b>
              Remain in command mode until you use the "visual" command.

       <b>file</b><u>[name]</u>
              Echo what the current filename is, its status, and the current line. If  you  provide  it  with  a
              name, it will change the filename to that.

       <u>(.)</u><b>insert</b>
              Insert text above the current line. If you specify a line number, Levee will make that the current
              line, then insert above it.

   <b>Insert</b> <b>mode</b> <b>commands</b>
       <b>^W</b>     Back over the last word you entered.

       <b>^H</b>     Back over one character.

       <b>^U</b>     Back over all input on this line.

       <b>^V</b>     Escape the next character typed. (For example, <b>^V^H</b> will put a ^H into the file.)

       <b>ESC</b>    Exit insert mode.

       <b>^D</b>     If at start of line, reduce indentation 'shiftwidth' columns.

       <b>^T</b>     If at start of line, increase indentation 'shiftwidth' columns.

       When  in  insert  mode,  Levee  will not allow you to enter any control characters except return and tab.
       Return ends input on this line and opens a new line for input.

       <b>map[!]</b><u>[key</u><b>[text]]</b>
              Define/list macros.  There are 3 forms of map:

       <u>map.</u>   This lists all the active macros.

       <u>map</u>(key).
              This shows the macro associated with (key), if any.

       <u>map</u>(key) (text)
              This maps (key) to (text). You may map any key except ":" and escape. In the  normal  form  (map),
              the  macro  will be effective in visual mode, but in the alternate form, (map!), the macro will be
              effective in insert and command modes.

       For example, if you map!ped return to "hello world", every time you entered a return in command or visual
       mode, the string "hello world" would pop up.

       <b>next</b><u>[file</u><b>...]</b>
              Edit the next file in the arglist, or edit a new arglist. Levee takes its initial arglist off  the
              command  line when you execute it.  If "autowrite" is set, Levee will write out the changes to the
              current file before editing the next one.

       <u>(.)</u><b>open</b>
              Insert below the current line. Otherwise just like insert.

       <b>previous</b>
              Edit the previous file in the arglist. Otherwise, like next.

       <u>(.,.)</u><b>print</b>
              Display lines without changing the current line.

       <u>(.)</u><b>put</b> Put the contents of the yank buffer back on the line below the current  line.  If  you  specify  a
              line, it resets the current line, then puts the yank buffer back. The yank buffer is filled by the
              delete,  change,  or yank commands. Put does not destroy the yank buffer, so you may put back text
              multiple times.

       <b>quit[!]</b>
              Exit Levee. If you want to discard changes, use "quit!"

       <u>(.)</u><b>read</b><u>[file]</u>
              Put the contents of 'file' after the current line.

       <b>set</b><u>[option=value]</u>
              Set a tunable variable. Levee has a dozen or so user-definable variables which you can twiddle via
              this command. There are boolean, integer, and string variables that  you  can  set.  A  string  or
              integer variable is set by "set xxx=yyy", a boolean variable is set via "set xxx" or "set noxxx".

              Here are the settable variables (and abbreviations):

       <b>tabsize</b><u>(ts)</u>
              tab stop

       <b>shiftwidth</b><u>(sw)</u>
              columns to shift on ^D, ^T, &gt;&gt;, or &lt;&lt;

       <b>scroll</b> number of lines to scroll on ^D, ^U

       <b>autoindent</b><u>(ai)</u>
              Supply indentation during insert mode.

       <b>autowrite</b><u>(aw)</u>
              Write out changes before :next, :prev.

       <b>autocopy</b><u>(ac)</u>
              Make backup copies before writing changes.

       <b>list</b>   Display tabs as ^I, end of line as $.

       <b>magic</b>  Use regular expressions in searches.

       <b>suffix</b> If the filename does not have a . in it, supply the suffix. (This is the only string variable.)

       <b>overwrite</b><u>(ow)</u>
              Destroy old file first, then write.

       <b>beautify</b><u>(be)</u>
              When  set,  Levee  will not allow insert of any control character except tab and return unless you
              escape it with ctrl-V.

       <b>wrapscan</b>
              Searches wrap around end of buffer.

       <b>ignorecase</b><u>(ic)</u>
              Ignore the case of alphabetic characters during searches.

       <b>mapslash</b>
              (ST version only) Map "/" in filenames to "\".  If the environment contains `mapslash' when  levee
              is  called,  this  variable  will  default  to  true,  otherwise  it  defaults  to false. (See the
              documentation for the Teeny-shell on how the teeny-shell interprets `mapslash')

       <b>lines</b><u>(li)</u>
              (ST version only) How many lines on the display.  This is primarily for running levee through  the
              serial port - put set li=xx into your LVRC for a xx line terminal.

       <b>cols</b><u>(co)</u>
              (ST  version  only)  How  many  columns on the display.  Like the lines variable, it's for running
              levee through the serial port.

       You may set multiple variables on one line, as in 'set ws noai'.  To see the current  settings  of  these
       variables, :set -- without any arguments -- will show the current settings.

       At  startup, Levee looks in the environment variable LVRC for a list of variables to set (GEMDOS/MS-DOS).
       LVRC is one line of the form 'option=value ...'. If you have a LVRC defined that is 'ts=4 ow nows', Levee
       will set tabsize to 4, turn on overwrite, and turn off wrapscan.

       If you are using RMX, Levee looks in the  file  ":home:r?lvrc"  for  initialization.  If  you  are  using
       Osy/SWOs,  Levee  looks  in  the  file  "*.lvrc".  The  format of these files are different from the LVRC
       variable -- see "source" for more information.

       <b>source</b><u>file</u>
              Take command mode commands from 'file'. These commands can be any legal command, except  "visual".
              If a error happens during execution of 'file', Levee abandons that level of source'ing.

              In  Osy/SWOs,  there are a few differences in insert mode from within a sourced file. No character
              has special meaning except a line  containing nothing but a period, which terminates insert  mode.
              For example:

              :commands
              :insert
              blah blah blah blah blah blah
              blah blah blah blah blah blah
              blah blah blah blah blah blah
              :more commands

       If you are running Levee under any other operating system, you cannot do a insert from a :source file.

       <b>(.,.)substitute(delim)patt(delim)repl(delim)[qcpg]</b>

       <b>(.,.)substitute&amp;</b>

              Search  for  patt and replace it with repl. Levee will look for patt once on each line and replace
              it with repl. The delimiter may be any ascii character.

              The pattern is a regular expression, just like a search pattern.

              You may include parts of the pattern in the replacement string; A '&amp;' in the  replacement  pattern
              copies  in  the  whole  source  pattern, so if you do a 'sub/this/&amp; and that/g', every instance of
              'this' will be replaced with 'this and that'.  Also, you may pull parts  of  the  pattern  out  by
              using  the  \(  and  \)  argument  meta-characters.   Arguments gotten by \( &amp; \) are put into the
              replacement string everywhere you do a \1..\9 [ \1 is the first argument you set up with \(  &amp;  \)
              ].    So,   if   you   want   to   reverse   the   order   of   two   substrings,   you   can   do
              'sub/\(string1\)\(string2\)/\2\1/'.

              substitute&amp; redoes the last substitution.

              Options:

       <b>q,c</b>    Before doing the substitute, display the affected line and wait for you to type  a  character.  If
              you  type  'y', it will do the substitution. 'q' aborts the substitute,  'a'  does the rest of the
              change without prompting, and 'n' does not do it.

       <b>p</b>      Print the affected lines after the change.

       <b>g</b>      Do the change globally. That is, do it for every occurrence  of patt on a  line,  rather than just
              once.

       <b>undo</b>   Undo the last modification to the file (except :edit, :next, :rm, or :write.) You  can  only  undo
              the  last change to a file -- undo counts as a change. :undo followed by :undo does nothing to the
              file.

       <b>unmap</b><u>(key)</u>
              Undefine a macro (see map).

       <b>visual</b><u>[list]</u>
              If you entered command mode by "Q" or "execmode", return  to  visual  mode.   If  you  provide  an
              argument list, it also does a `:next' on that list.

       <b>version</b>
              Show which version of levee this is.

       <u>(.,.)</u><b>write</b> <u>[file]</u>
              Write  lines  to a file. If you write the everything to 'file', the filename is set to 'file', and
              if you do not specify a file, Levee will write to the filename.

       <u>(.,.)</u><b>wq</b> <u>[file]</u>
               Write to a file, then quit.

       <u>(.,.)</u><b>yank</b>
              Yank lines from the file into the yank buffer, for later putback with "put".

       <b>xit[!]</b> Write changes to the current file, then exit. If there are more files in the arglist, use "xit!"

       <b>![command]</b>
              Execute command.

              Example:

              !ls    =&gt; does a 'ls'.

       This command is available only under GEMDOS, MSDOS, RMX, and Unix.

       <b>($)=</b>   Give the line number of the addressed line. /end/= gives you the line number of the next line with
              a 'end' on it.

</pre><h4><b>VISUAL</b> <b>MODE</b> <b>COMMANDS</b></h4><pre>
       Visual mode commands move you around  and modify the file.  There  are  movement  commands  to  move  the
       cursor by a variety of objects.

       In the description,  a (#) means a optional  count.  If a command has a optional count,  it will tell you
       what  the  count  does in parenthesis.  A (*) means that the command can be used in the delete, yank, and
       change commands.

       Counts are made up by  entering digits.  If you type '45', the count will be  set  to  45.  To  cancel  a
       count, type ESC.

       This section discusses 'whitespace' occasionally.  Whitespace is tabs, spaces, and end of line.

   <b>How</b> <b>the</b> <b>display</b> <b>works</b>
       Characters   are   displayed  on  the  screen  as  you would expect,  except that  nonprinting characters
       are  shown as ^x, and tabs  expand to  spaces ( unless you  set the option list, then they show  as  ^I.)
       When sitting on a control character or tab, the cursor is placed on the FIRST character displayed. If you
       move the cursor to  any other part of them ( via j or k -- see below), any changes will start at the next
       character.

       Levee   does   not   display  a  end of  file marker, but lines past the end of the file are denoted by ~
       lines.

       If list is  set,  tabs  display as ^I, and the end of line displays as $.

       If a  line is too long for the screen,  it will  just disappear off the end of the screen.

       Levee will handle any screen resolution and any monospaced font you hand it ( if you are running  in  low
       resolution, Levee will give you a 25x40 window, for example.)

   <b>Visual</b> <b>mode</b> <b>commands</b>
       <b>^A</b>     Show  a  debugging  message  at the bottom of the screen. This is not at all useful unless you are
              debugging the editor. Ignore it.

       <b>(#)^D</b>  Scroll the screen down a half screen. If a count is specified, scroll down the specified number of
              lines.

       <b>^E</b>     Scroll down 1 line (shorthand for 1^D )

       <b>^G</b>     Show file statistics. Exactly like ':file'.

       <u>(*)</u><b>(#)^H</b>
              Move the cursor left one (count) chars.

       <b>^I</b>     Redraw the screen.

       <u>(*)</u><b>(#)^J</b>
              Move down one (count) lines. When you use ^J and ^K (below) to move up or down lines,  the  cursor
              will  remain  in  the  same  column, even if it is in the middle of a tabstop or past the end of a
              line.

       <u>(*)</u><b>(#)^K</b>
              Move up one (count) lines.

       <u>(*)</u><b>(#)^L</b>
              Move right one (count) characters.

       <u>(*)</u><b>(#)^M</b>
              Move to the first nonwhite space on the next line. If a count is  specified,  move  to  the  first
              nonwhite count lines down.

       <b>(#)^U</b>  Scroll the screen up a half page. If a count is specified, scroll up count lines.

       <b>^Y</b>     Scroll the screen up 1 line (shorthand for 1^U.)

       <b>(#)a</b>   Insert  text  AFTER  the cursor. If you give a count, the insertion will be repeated count times (
              40i-ESC will give you a line of 40 dashes).

              The commands in insert mode are the same for visual and command mode.

       <u>(*)</u><b>(#)b</b>
              Move to the beginning of the last word (the count'th word  back).   A  word  is  a  collection  of
              alphanumeric characters (a-z0-9$_#) or any other nonwhite character (i.e. anything but space, tab,
              eoln).

       <b>c</b>      Change  a  object. Change deletes an object, then enters insert mode without redrawing the screen.
              When you tell it the object to be changed, Levee puts a '$' on the last character of  the  object.
              You cannot change backwards.

              The object may be any visual mode command marked with a '(*) '. For example, 'c4l' will change the
              next 4 characters on the line to something else. (4cl does the same thing -- 4c4l changes the next
              16 characters on this line.)

               'cc' will change whole lines.

              When  changing,  deleting, or yanking a object, it will be placed into a yank buffer, where it can
              be retrieved by the 'p' or 'P' commands.

       <b>(#)d</b>   Delete an object. Like 'cc', 'dd' affects whole lines.

       <u>(*)</u><b>(#)e</b>
              Move to the end of the current word.

       <u>(*)</u><b>(#)f(x)</b>
              Find the next (count'th) occurrence of a character on the  current  line.   For  example,  if  the
              cursor  is sitting on the first character of the line 'abcdef', typing "ff" will put the cursor on
              the 'f'.

       <b>g</b>      Move to the start of the file.  Shorthand for 1G. (See below for G.)

       <u>(*)</u><b>(#)h</b>
              Move left one (count) characters. Exactly like ^H.

       <b>(#)i</b>   Start inserting characters at the cursor. If you specify a count, the insertion will be duplicated
              count times.

       <u>(*)</u><b>(#)j</b>
              Move down one (count) lines. Exactly like ^J.

       <u>(*)</u><b>(#)k</b>
              Move up one (count) lines. Exactly like ^K.

       <u>(*)</u><b>(#)l</b>
              Move right one (count) character. Exactly like ^L.

       <b>m(x)</b>   Set the marker (x). There are 26 markers available (a-z). You may move to a marker by use of the '
              or ` commands.

       <u>(*)</u><b>n</b>   Find the next occurrence of a search pattern. When you do a search with a / or  ?  command,  Levee
              will remember the pattern and the direction you searched in. 'n' will search in the same direction
              for the pattern, 'N' searches in the opposite direction.

       <b>o</b>      Open a line below the current line for insertion.

       <b>p</b>      Put  yanked/deleted  text  back  after  the cursor. Text is yanked by the delete (d,x,X,D), change
              (c,C,s,S), and yank (y,Y) commands.

       <b>(#)r(x)</b>
              Replace characters (up to end of line) with (x). '4ra' will change the next 4 characters after the
              cursor into 'aaaa'.

       <b>(#)s</b>   change one (count) characters. Shorthand for (#)cl.

       <u>(*)</u><b>(#)t(x)</b>
              Move up to a character on the current line. If you are on the first character of the line 'abcdef'
              and you type 'tf', you will end up sitting on the 'e'.

       <b>u</b>      Undo last modification. You can undo ANY modification command except :edit, :next, :rm, or :write.
              (Just like :undo).

       <u>(*)</u><b>(#)v</b>
              Move back to the very end of the previous (count'th) word.  See 'b' for the definition of a word.

       <u>(*)</u><b>(#)w</b>
              Move up to the very beginning of the next (count'th) word.

       <b>(#)x</b>   Delete one (count) characters forward. Shorthand for (#)dl.

       <b>y</b>      Yank an object for later use by put. 'yy' yanks whole lines.

       <b>A</b>      Append text at the end of the line. Shorthand for $a.

       <u>(*)</u><b>(#)B</b>
              Move to the beginning of the current word. Exactly like 'b'.

              <b>NOTE:</b> this is incorrect. the capitalized word movement commands should, and will in the future, be
              used for movement by space-delimited words.

       <b>C</b>      Change to the end of the line. Shorthand for c$.

       <b>D</b>      Delete to the end of the line. Shorthand for d$.

       <u>(*)</u><b>(#)F(x)</b>
              Move to the first (count'th) previous occurrence of a character on the current line.  If  you  are
              sitting at the end of the line 'abcdef', typing "Fa" will move you back to the 'a' at the start of
              the line.

       <u>(*)</u><b>(#)G</b>
              Goto  line.  If you specify a count, Levee will move to that line, and if there is no count, Levee
              moves to the absolute end of the file.

              To get to the start of the file, type "1G". To the end, just "G". As a convenience, "g" also moves
              to the start of the file.

       <u>(*)</u><b>H</b>   Move to the first nonwhite character at the top of the screen.

       <b>I</b>      Insert at the end of the current line. Shorthand for $i.

       <b>(#)J</b>   Join two (count+1) lines together. Joining appends the second  line  at  the  end  of  the  first,
              putting a space between them. If the first line ends in whitespace, Levee will not put in a space.

       <u>(*)</u><b>L</b>   Move to the last nonwhite character on the last line of the screen.

       <u>(*)</u><b>M</b>   Move to the first nonwhite character in the middle of the screen.

       <b>O</b>      Open a line above the current line. Otherwise works just like 'o'.

       <b>P</b>      Put back the yank buffer at the cursor. Otherwise works just like 'p'.

       <b>Q</b>      Enter  and  remain  in  command mode. Just like the command :exec. To get back to visual mode, you
              must enter the command ':visual'.

       <b>R</b>      Replace mode. A limited subset of insert mode that overwrites characters up to end of line. All of
              the normal insert mode commands apply.  If you overwrite a  character,  then  back  over  it  with
              ^H,^U, or ^W, it will reappear after you exit Replace mode.

              Escape exits replace mode.

              <b>NOTE:</b>  due  to a bug, entering a &lt;return&gt; in Replace mode will drop you back into visual mode with
              an error. The replacements you have made will remain.

       <b>S</b>      Change characters backwards. Shorthand for (#)ch.

       <u>(*)</u><b>(#)T(x)</b>
              Move back to character on current line. If you are on the last character  of  the  line  'abcdef',
              typing "Ta" will move you back to the 'b'.

       <u>(*)</u><b>(#)W</b>
              Move to end of word. Exactly like 'e'.

       <b>(#)X</b>   Delete characters backwards. Shorthand for (#)dh.

       <b>Y</b>      Yank to end of line. Shorthand for y$.

       <b>ZZ</b>     Write changes to current file and exit if last file in arglist.  Exactly like :xit.

       <u>(*)</u><b>(#)$</b>
              Move  to end of line. If you give a count, move to the end of the (count-1) line down (so 2$ moves
              you to the end of the next line.).

       <b>0</b>      Move to the beginning of the current line.  Shorthand for 0|.

       <b>(#)!</b>   Pipe an object through an external program. Like 'cc', '!!' affects whole lines.

       <u>(*)</u><b>%</b>   Find matching bracket, parenthesis, or squiggly bracket. If you are not  sitting  on  a  '[]{}()',
              Levee will search forward for one of them on the current line, then match whatever it finds.

       <b>[space]</b>
              Move to the first nonwhite character on the current line.

       <b>&amp;</b>      Redo last substitution command.

       <u>(*)</u><b>(#){</b>
              Move to the beginning of the count'th paragraph back. A paragraph is delimited by a blank line.

       <u>(*)</u><b>(#)}</b>
              Move to the end of the count'th paragraph forward.

       <u>(*)</u><b>(#)(</b>
              Move  to  the beginning of the count'th sentence back. A sentence is delimited by a ., a !, or a ?
              followed by a space, a tab, or end of line.

       <u>(*)</u><b>(#))</b>
              Move to the end of the count'th sentence forward.

       <u>(*)</u><b>(#)-</b>
              Move to the (count'th) previous line, first nonwhite.

       <u>(*)</u><b>(#)+</b>
              Move to the (count'th) next line, first nonwhite.

       <b>(#)~</b>   Change the case of the next count characters. Upper  case  becomes  lowercase,  lowercase  becomes
              uppercase.

       <u>(*)</u><b>`(x)</b>
              Move  to  the  exact  position  of  mark  (x). There is a special mark for some of the visual mode
              movement commands -- '' will move you to where you were before the last (,),',`,G,/,?,n,N command.

       <b>:</b>      Execute one command mode command. When the command is done, it will return to visual  mode  if  it
              produces  one  line  of  output,  but  if  it  scrolls the screen, Levee will prompt [more] before
              returning to visual mode. If you type a : in response to the [more] prompt, Levee will  remain  in
              command mode for one more command.

       <b>(#)&lt;(#)</b>
              Shift  one  (count)  objects left. If you specify a second count, Levee will shift the object left
              that many columns -- if you do not, they will be shifted shiftwidth columns.

              This is a nondestructive shift. If the shift would carry past the left margin, the objects will be
              moved up to the left margin but no farther.

              Like the other object movement commands, '&lt;&lt;' will affect whole lines.

       <b>(#)&gt;(#)</b>
              Shift one (count) objects right. Just like &lt;, except it will not  shift  objects  past  the  right
              margin  of  the  screen. If you do shift an object past the right margin of the screen, all of its
              indent will be removed and it will end up by the left margin.

       <b>.</b>      Repeat last modification command. (except undo)

       <u>(*)</u><b>?</b>   Search for pattern backwards. Escape aborts the search pattern, and a empty pattern  means  search
              for the last pattern again.

       <u>(*)</u><b>/</b>   Search for pattern forwards. Otherwise like ?.

       <b>(#)|</b>   Move to specified column. If you don't have a count, move to column 0.

</pre><h4><b>REGULAR</b> <b>EXPRESSIONS</b></h4><pre>
       Levee  gives   special meanings to  some characters during a pattern match.  The character "." will match
       any one char, the character "*" will match zero or  more occurrences of the previous char ( so,  a*  will
       match  'a','aa','aaa', etc, or it will match nothing at all). If a pattern begins with "^", it will  only
       match  at the  beginning of a line,  and patterns ending with a "$" will only match at the end of a line.

       Brackets ('[]') have special meaning as well.  They mean match any  one  of  the  characters  inside  the
       brackets. '[abc]' will  match  'a', 'b', or 'c'.  You may  specify  a range of characters inside brackets
       by  using a dash (-). '[a-z]' will match any lowercase alphabetic character.  If ^ is the first character
       in  the  bracket,  it means match  any  character except those in the  brackets.    '[^abc]'  will  match
       anything except 'a','b', or 'c'.

       Backslash  takes  away   special   meaning   for  these  chars,  but '\t' specifies  a  tab,  and \( &amp; \)
       delimit  arguments inside a pattern (used only by :substitute.)    The patterns \&lt; and  \&gt;  have  special
       meaning,  too;  they match the start and end of alpha-numeric tokens.

       If  you   turn  off   the  editor  variable   'magic',   none of the above  characters will  have special
       meaning  inside of a pattern (see 'set').

       Some example patterns:

       <b>^end$</b>  Find a line that is just 'end'.

       <b>[Ee][Nn][Dd]</b>
              Find a 'end', ignoring case.

       <b>[A-Za-z][A-Za-z0-9]*</b>
              Find the next identifier.

       <b>([*].*[*])</b>
              Find the next one-line pascal comment.

       <b>&lt;the&gt;</b>  Find the next occurrence of `the'.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       Levee can only edit files up to 256000 characters long. ^M is used as its  internal  line  separator,  so
       inserting ^M will have interesting consequences.

</pre><h4><b>BUGS</b></h4><pre>
       Probably infinite.

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>David</b> <b>L.</b> <b>Parsons</b> <u>(<a href="mailto:orc@pell.portland.or.us">orc@pell.portland.or.us</a>)</u>
       Testing, suggestions, and impractical design goals by: Jim Bolland. John Tainter. John Plocher.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 1982-2015 David L. Parsons
       All rights reserved.

       Redistribution  and  use  in  source  and  binary  forms,  without or without modification, are permitted
       provided that the above copyright notice and this paragraph are duplicated in all such forms and that any
       documentation,  advertising  materials,  and  other  materials  related  to  such  distribution  and  use
       acknowledge  that  the software was developed by David L. Parsons (<a href="mailto:orc@pell.portland.or.us">orc@pell.portland.or.us</a>).  My name may
       not be used to endorse or promote products derived from this  software  without  specific  prior  written
       permission.   THIS SOFTWARE IS PROVIDED AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
       WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

Mastodon Linux                                   29 August 1998                                         <u><a href="../man1/LEVEE.1.html">LEVEE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>