<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>runscript - script interpreter for minicom</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/minicom">minicom_2.10-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       runscript - script interpreter for minicom

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>runscript</b> scriptname [logfile [homedir]]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>runscript</b>  is  a  simple  script  interpreter  that  can be called from within the minicom communications
       program to automate tasks like logging in to a Unix system or your favorite BBS.

</pre><h4><b>INVOCATION</b></h4><pre>
       The program expects a script name and optionally a filename and the user's home directory  as  arguments,
       and  it  expects  that  it's  input  and  output  are  connected  to the "remote end", the system you are
       connecting to. All messages from <b>runscript</b> meant for the local screen are directed to the <b>stderr</b>  output.
       All  this  is  automatically  taken  care  of if you run it from <b>minicom</b>.  The logfile and home directory
       parameters are only used to tell the log command the name of the logfile and where to write  it.  If  the
       homedir  is  omitted,  runscript  uses the directory found in the $HOME environment variable. If also the
       logfile name is omitted, the log commands are ignored.

</pre><h4><b>KEYWORDS</b></h4><pre>
       Runscript recognizes the following commands:

            expect   send     goto     gosub    return   !&lt;   !
            exit     print    set      inc      dec      if   timeout
            verbose  sleep    break    call     log

</pre><h4><b>OVERVIEW</b> <b>OF</b> <b>KEYWORDS</b></h4><pre>
       <b>send</b> <b>&lt;string&gt;</b>
            &lt;string&gt; is sent to the modem. It is followed by a '\r'.  &lt;string&gt; can be:
              - regular text, e.g. 'send hello'
              - text enclosed in quotes, e.g. 'send "hello world"'

            Within &lt;string&gt; the following sequences are recognized:
                \n - newline
                \r - carriage return
                \a - bell
                \b - backspace
                \c - don't send the default '\r'.
                \f - formfeed
                \^ - the ^ character
                \o - send character <b>o</b> (<b>o</b> is an octal number)

            Control characters can be used in the string with the ^ prefix (^A to ^Z, ^[, ^ ^], ^^ and  ^_).  If
            you need to send the ^ character, you must prefix it with the \ escape character.
            Octal  characters  are  either  four-digit  or  delimited  by  a  non-digit character, e.g. the null
            character may be sent with \0000 and 'send 1234' is equivalent to 'send \0061234'.
            Also $(environment_variable) can be  used,  for  example  $(TERM).   Minicom  passes  three  special
            environment  variables:  $(LOGIN), which is the username, $(PASS), which is the password, as defined
            in the proper entry of the dialing directory, and $(TERMLIN) which is the number of actual  terminal
            lines on your screen (that is, the statusline excluded).

       <b>print</b> <b>&lt;string&gt;</b>
            Prints  &lt;string&gt;  to  the  local  screen. Default followed by '\r\n'.  See the description of 'send'
            above.

       <b>label:</b>
            Declares a label (with the name 'label') to use with goto or gosub.

       <b>goto</b> <b>&lt;label&gt;</b>
            Jump to another place in the program.

       <b>gosub</b> <b>&lt;label&gt;</b>
            Jumps to another place in the program. When the statement 'return' is encountered,  control  returns
            to the statement after the gosub.  Gosub's can be nested.

       <b>return</b>
            Return from a gosub.

       <b>!</b> <b>&lt;command&gt;</b>
            Runs a shell for you in which 'command' is executed. On return, the variable '$?' is set to the exit
            status of this command, so you can subsequently test it using 'if'.

       <b>!&lt;</b> <b>&lt;command&gt;</b>
            Runs a shell for you in which 'command' is executed. The stdout output of the command execution will
            be sent to the modem. On return, the variable '$?' is set to the exit status of this command, so you
            can subsequently test it using 'if'.

       <b>exit</b> <b>[value]</b>
            Exit from "runscript" with an optional exit status. (default 1)

       <b>set</b> <b>&lt;variable&gt;</b> <b>&lt;value&gt;</b>
            Sets the value of &lt;variable&gt; (which is a single letter a-z) to the value &lt;value&gt;. If &lt;variable&gt; does
            not exist, it will be created.  &lt;value&gt; can be a integer value or another variable.

       <b>inc</b> <b>&lt;variable&gt;</b>
            Increments the value of &lt;variable&gt; by one.

       <b>dec</b> <b>&lt;variable&gt;</b>
            Decrements the value of &lt;variable&gt; by one.

       <b>if</b> <b>&lt;value&gt;</b> <b>&lt;operator&gt;</b> <b>&lt;value&gt;</b> <b>&lt;statement&gt;</b>
            Conditional  execution  of  &lt;statement&gt;.  &lt;operator&gt;  can  be  &lt;,  &gt;,  !=  or =.  Eg, 'if a &gt; 3 goto
            exitlabel'.

       <b>timeout</b> <b>&lt;value&gt;</b>
            Sets the global timeout. By default, 'runscript' will exit after 120 seconds. This  can  be  changed
            with  this  command.  Warning:  this command acts differently within an 'expect' statement, but more
            about that later.

       <b>verbose</b> <b>&lt;on|off&gt;</b>
            By default, this is 'on'. That means that anything that is being read from the modem by 'runscript',
            gets echoed to the screen.  This is so that you can see what 'runscript' is doing.

       <b>sleep</b> <b>&lt;value&gt;</b>
            Suspend execution for &lt;value&gt; seconds.

       <b>expect</b>
              expect {
                pattern  [statement]
                pattern  [statement]
                [timeout &lt;value&gt; [statement] ]
                ....
              }
            The most important command of all. Expect keeps reading from the input until it reads a pattern that
            matches one of the specified ones.  If expect encounters an optional statement after  that  pattern,
            it will execute it. Otherwise the default is to just break out of the expect. 'pattern' is a string,
            just  as in 'send' (see above).  Normally, expect will timeout in 60 seconds and just exit, but this
            can be changed with the timeout command.

       <b>break</b>
            Break out of an 'expect' statement. This is normally only useful as argument to 'timeout' within  an
            expect, because the default action of timeout is to exit immediately.

       <b>call</b> <b>&lt;scriptname&gt;</b>
            Transfers  control  to  another  script  file.  When  that  script file finishes without errors, the
            original script will continue.

       <b>log</b> <b>&lt;text&gt;</b>
            Write text to the logfile.

</pre><h4><b>NOTES</b></h4><pre>
       If you want to make your script to exit minicom (for example when you use minicom to dial  up  your  ISP,
       and  then  start a PPP or SLIP session from a script), try the command "! killall -9 minicom" as the last
       script command. The -9 option should prevent minicom from hanging up the line  and  resetting  the  modem
       before exiting.
       Well,  I  don't  think this is enough information to make you an experienced 'programmer' in 'runscript',
       but together with the examples it shouldn't be too hard to write some useful script files. Things will be
       easier if you have experience with BASIC.  The <b>minicom</b>  source  code  comes  together  with  two  example
       scripts,  <b>scriptdemo</b>  and  <b>unixlogin</b>.  Especially  the  last  one is a good base to build on for your own
       scripts.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/minicom.1.html">minicom</a></b>(1)

</pre><h4><b>BUGS</b></h4><pre>
       Runscript should be built in to minicom.

</pre><h4><b>AUTHOR</b></h4><pre>
       Miquel van Smoorenburg, &lt;<a href="mailto:miquels@drinkel.ow.org">miquels@drinkel.ow.org</a>&gt; Jukka Lahtinen, &lt;<a href="mailto:walker@netsonic.fi">walker@netsonic.fi</a>&gt;

User's Manual                             $Date: 2007-10-07 18:13:51 $                              <u><a href="../man1/RUNSCRIPT.1.html">RUNSCRIPT</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>