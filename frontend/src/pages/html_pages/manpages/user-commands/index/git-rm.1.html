<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>git-rm - Remove files from the working tree and from the index</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/git-man">git-man_2.48.1-0ubuntu1.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       git-rm - Remove files from the working tree and from the index

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <u>git</u> <u>rm</u> [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]
                 [--quiet] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]]
                 [--] [&lt;pathspec&gt;...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Remove files matching pathspec from the index, or from the working tree and the index. <b>git</b> <b>rm</b> will not
       remove a file from just your working directory. (There is no option to remove a file only from the
       working tree and yet keep it in the index; use <b><a href="file:/bin/rm">/bin/rm</a></b> if you want to do that.) The files being removed
       have to be identical to the tip of the branch, and no updates to their contents can be staged in the
       index, though that default behavior can be overridden with the <b>-f</b> option. When <b>--cached</b> is given, the
       staged content has to match either the tip of the branch or the file on disk, allowing the file to be
       removed from just the index. When sparse-checkouts are in use (see <b><a href="../man1/git-sparse-checkout.1.html">git-sparse-checkout</a></b>(1)), <b>git</b> <b>rm</b> will
       only remove paths within the sparse-checkout patterns.

</pre><h4><b>OPTIONS</b></h4><pre>
       &lt;pathspec&gt;...
           Files to remove. A leading directory name (e.g.  <b>dir</b> to remove <b>dir/file1</b> and <b>dir/file2</b>) can be given
           to remove all files in the directory, and recursively all sub-directories, but this requires the <b>-r</b>
           option to be explicitly given.

           The command removes only the paths that are known to Git.

           File globbing matches across directory boundaries. Thus, given two directories <b>d</b> and <b>d2</b>, there is a
           difference between using <b>git</b> <b>rm</b> 'd*' and <b>git</b> <b>rm</b> 'd/*', as the former will also remove all of
           directory <b>d2</b>.

           For more details, see the <u>pathspec</u> entry in <b><a href="../man7/gitglossary.7.html">gitglossary</a></b>(7).

       -f, --force
           Override the up-to-date check.

       -n, --dry-run
           Don’t actually remove any file(s). Instead, just show if they exist in the index and would otherwise
           be removed by the command.

       -r
           Allow recursive removal when a leading directory name is given.

       --
           This option can be used to separate command-line options from the list of files, (useful when
           filenames might be mistaken for command-line options).

       --cached
           Use this option to unstage and remove paths only from the index. Working tree files, whether modified
           or not, will be left alone.

       --ignore-unmatch
           Exit with a zero status even if no files matched.

       --sparse
           Allow updating index entries outside of the sparse-checkout cone. Normally, <b>git</b> <b>rm</b> refuses to update
           index entries whose paths do not fit within the sparse-checkout cone. See <b><a href="../man1/git-sparse-checkout.1.html">git-sparse-checkout</a></b>(1) for
           more.

       -q, --quiet
           <b>git</b> <b>rm</b> normally outputs one line (in the form of an <b>rm</b> command) for each file removed. This option
           suppresses that output.

       --pathspec-from-file=&lt;file&gt;
           Pathspec is passed in <u>&lt;file&gt;</u> instead of commandline args. If <u>&lt;file&gt;</u> is exactly <b>-</b> then standard input
           is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained
           for the configuration variable <b>core.quotePath</b> (see <b><a href="../man1/git-config.1.html">git-config</a></b>(1)). See also <b>--pathspec-file-nul</b> and
           global <b>--literal-pathspecs</b>.

       --pathspec-file-nul
           Only meaningful with <b>--pathspec-from-file</b>. Pathspec elements are separated with NUL character and all
           other characters are taken literally (including newlines and quotes).

</pre><h4><b>REMOVING</b> <b>FILES</b> <b>THAT</b> <b>HAVE</b> <b>DISAPPEARED</b> <b>FROM</b> <b>THE</b> <b>FILESYSTEM</b></h4><pre>
       There is no option for <b>git</b> <b>rm</b> to remove from the index only the paths that have disappeared from the
       filesystem. However, depending on the use case, there are several ways that can be done.

   <b>Using</b> <b>“git</b> <b>commit</b> <b>-a”</b>
       If you intend that your next commit should record all modifications of tracked files in the working tree
       and record all removals of files that have been removed from the working tree with <b>rm</b> (as opposed to <b>git</b>
       <b>rm</b>), use <b>git</b> <b>commit</b> <b>-a</b>, as it will automatically notice and record all removals. You can also have a
       similar effect without committing by using <b>git</b> <b>add</b> <b>-u</b>.

   <b>Using</b> <b>“git</b> <b>add</b> <b>-A”</b>
       When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths
       and additions of new paths as well as modifications of existing paths.

       Typically you would first remove all tracked files from the working tree using this command:

           git ls-files -z | xargs -0 rm -f

       and then untar the new code in the working tree. Alternately you could <u>rsync</u> the changes into the working
       tree.

       After that, the easiest way to record all removals, additions, and modifications in the working tree is:

           git add -A

       See <b><a href="../man1/git-add.1.html">git-add</a></b>(1).

   <b>Other</b> <b>ways</b>
       If all you really want to do is to remove from the index the files that are no longer present in the
       working tree (perhaps because your working tree is dirty so that you cannot use <b>git</b> <b>commit</b> <b>-a</b>), use the
       following command:

           git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached

</pre><h4><b>SUBMODULES</b></h4><pre>
       Only submodules using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will be
       removed from the work tree, as their repository lives inside the .git directory of the superproject. If a
       submodule (or one of those nested inside it) still uses a .git directory, <b>git</b> <b>rm</b> will move the submodules
       git directory into the superprojects git directory to protect the submodule’s history. If it exists the
       submodule.&lt;name&gt; section in the <b><a href="../man5/gitmodules.5.html">gitmodules</a></b>(5) file will also be removed and that file will be staged
       (unless --cached or -n are used).

       A submodule is considered up to date when the HEAD is the same as recorded in the index, no tracked files
       are modified and no untracked files that aren’t ignored are present in the submodule’s work tree. Ignored
       files are deemed expendable and won’t stop a submodule’s work tree from being removed.

       If you only want to remove the local checkout of a submodule from your work tree without committing the
       removal, use <b><a href="../man1/git-submodule.1.html">git-submodule</a></b>(1) <b>deinit</b> instead. Also see <b><a href="../man7/gitsubmodules.7.html">gitsubmodules</a></b>(7) for details on submodule removal.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>git</b> <b>rm</b> <b>Documentation/</b>\*.txt
           Removes all *.txt files from the index that are under the <b>Documentation</b> directory and any of its
           subdirectories.

           Note that the asterisk * is quoted from the shell in this example; this lets Git, and not the shell,
           expand the pathnames of files and subdirectories under the <b>Documentation/</b> directory.

       <b>git</b> <b>rm</b> <b>-f</b> <b>git-</b>*.sh
           Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly),
           it does not remove <b>subdir/git-foo.sh</b>.

</pre><h4><b>BUGS</b></h4><pre>
       Each time a superproject update removes a populated submodule (e.g. when switching between commits before
       and after the removal) a stale submodule checkout will remain in the old location. Removing the old
       directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted
       too. This step will be obsolete when recursive submodule update has been implemented.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/git-add.1.html">git-add</a></b>(1)

</pre><h4><b>GIT</b></h4><pre>
       Part of the <b><a href="../man1/git.1.html">git</a></b>(1) suite

Git 2.48.1                                         07/02/2025                                          <u><a href="../man1/GIT-RM.1.html">GIT-RM</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>