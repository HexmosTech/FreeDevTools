<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zshzle - zsh command line editor</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/zsh-common">zsh-common_5.9-6ubuntu3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zshzle - zsh command line editor

</pre><h4><b>DESCRIPTION</b></h4><pre>
       If  the  <b>ZLE</b> option is set (which it is by default in interactive shells) and the shell input is attached
       to the terminal, the user is able to edit command lines.

       There are two display modes.  The first, multiline mode, is the default.   It  only  works  if  the  <b>TERM</b>
       parameter  is set to a valid terminal type that can move the cursor up.  The second, single line mode, is
       used if <b>TERM</b> is invalid or incapable of moving the cursor up, or if the <b>SINGLE_LINE_ZLE</b>  option  is  set.
       This  mode  is similar to <b>ksh</b>, and uses no termcap sequences.  If <b>TERM</b> is "emacs", the <b>ZLE</b> option will be
       unset by default.

       The parameters <b>BAUD</b>, <b>COLUMNS</b>, and <b>LINES</b> are also used by the line editor.  See  <u>Parameters</u>  <u>Used</u>  <u>By</u>  <u>The</u>
       <u>Shell</u> in <u><a href="../man1/zshparam.1.html">zshparam</a></u>(1).

       The  parameter  <b>zle_highlight</b>  is  also  used  by  the  line  editor;  see  <u>Character</u> <u>Highlighting</u> below.
       Highlighting of special characters and  the  region  between  the  cursor  and  the  mark  (as  set  with
       <b>set-mark-command</b>  in  Emacs  mode,  or  by  <b>visual-mode</b>  in  Vi mode) is enabled by default; consult this
       reference for more information.  Irascible conservatives will wish to know that all highlighting  may  be
       disabled by the following setting:

              <b>zle_highlight=(none)</b>

       In  many  places,  references  are made to the <b>numeric</b> <b>argument</b>.  This can by default be entered in emacs
       mode by holding the alt key and typing a number, or pressing escape before each digit, and in vi  command
       mode  by  typing  the  number  before entering a command.  Generally the numeric argument causes the next
       command entered to be repeated the specified number of times,  unless  otherwise  noted  below;  this  is
       implemented  by  the  <b>digit-argument</b> widget. See also the <u>Arguments</u> subsection of the <u>Widgets</u> section for
       some other ways the numeric argument can be modified.

</pre><h4><b>KEYMAPS</b></h4><pre>
       A keymap in ZLE contains a set of bindings between  key  sequences  and  ZLE  commands.   The  empty  key
       sequence cannot be bound.

       There  can  be  any  number  of  keymaps at any time, and each keymap has one or more names.  If all of a
       keymap's names are deleted, it disappears.  <b>bindkey</b> can be used to manipulate keymap names.

       Initially, there are eight keymaps:

       <b>emacs</b>  EMACS emulation
       <b>viins</b>  vi emulation - insert mode
       <b>vicmd</b>  vi emulation - command mode
       <b>viopp</b>  vi emulation - operator pending
       <b>visual</b> vi emulation - selection active
       <b>isearch</b>
              incremental search mode
       <b>command</b>
              read a command name
       <b>.safe</b>  fallback keymap

       The `<b>.safe</b>' keymap is special.  It can never be altered, and the name can never be removed.  However,  it
       can  be  linked  to other names, which can be removed.  In the future other special keymaps may be added;
       users should avoid using names beginning with `<b>.</b>' for their own keymaps.

       In addition to these names, either `<b>emacs</b>' or `<b>viins</b>' is also linked to the name `<b>main</b>'.  If one  of  the
       <b>VISUAL</b>  or  <b>EDITOR</b> environment variables contain the string `<b>vi</b>' when the shell starts up then it will be
       `<b>viins</b>', otherwise it will be `<b>emacs</b>'.  <b>bindkey</b>'s <b>-e</b> and <b>-v</b> options provide a convenient way to  override
       this default choice.

       When  the  editor starts up, it will select the `<b>main</b>' keymap.  If that keymap doesn't exist, it will use
       `<b>.safe</b>' instead.

       In the `<b>.safe</b>' keymap, each single key is bound to <b>self-insert</b>, except for ^J (line feed) and ^M (return)
       which are bound to <b>accept-line</b>.  This is deliberately not pleasant to use; if you are using it, it  means
       you deleted the main keymap, and you should put it back.

   <b>Reading</b> <b>Commands</b>
       When ZLE is reading a command from the terminal, it may read a sequence that is bound to some command and
       is  also  a  prefix  of  a longer bound string.  In this case ZLE will wait a certain time to see if more
       characters are typed, and if not (or they don't match any longer string) it  will  execute  the  binding.
       This  timeout is defined by the <b>KEYTIMEOUT</b> parameter; its default is 0.4 sec.  There is no timeout if the
       prefix string is not itself bound to a command.

       The key timeout is also applied when ZLE is reading the bytes from a multibyte character string  when  it
       is  in  the  appropriate  mode.   (This requires that the shell was compiled with multibyte mode enabled;
       typically also the locale has characters with the UTF-8 encoding, although any multibyte  encoding  known
       to the operating system is supported.)  If the second or a subsequent byte is not read within the timeout
       period, the shell acts as if <b>?</b> were typed and resets the input state.

       As well as ZLE commands, key sequences can be bound to other strings, by using `<b>bindkey</b> <b>-s</b>'.  When such a
       sequence  is read, the replacement string is pushed back as input, and the command reading process starts
       again using these fake keystrokes.  This input can itself invoke  further  replacement  strings,  but  in
       order  to  detect  loops the process will be stopped if there are twenty such replacements without a real
       command being read.

       A key sequence typed by the user can be turned into a command name for use in user-defined  widgets  with
       the  <b>read-command</b>  widget,  described in the subsection `Miscellaneous' of the section `Standard Widgets'
       below.

   <b>Local</b> <b>Keymaps</b>
       While for normal editing a single keymap is used exclusively, in many modes a  local  keymap  allows  for
       some  keys  to be customised. For example, in an incremental search mode, a binding in the <b>isearch</b> keymap
       will override a binding in the <b>main</b> keymap but all keys that are not overridden can still be used.

       If a key sequence is defined in a local keymap, it will hide a key sequence in the global keymap that  is
       a  prefix  of  that sequence. An example of this occurs with the binding of <b>iw</b> in <b>viopp</b> as this hides the
       binding of <b>i</b> in <b>vicmd</b>. However, a longer sequence in the global keymap that shares the  same  prefix  can
       still  apply  so for example the binding of <b>^Xa</b> in the global keymap will be unaffected by the binding of
       <b>^Xb</b> in the local keymap.

</pre><h4><b>ZLE</b> <b>BUILTINS</b></h4><pre>
       The ZLE module contains three related builtin commands. The <b>bindkey</b> command manipulates keymaps  and  key
       bindings;  the  <b>vared</b>  command  invokes  ZLE  on  the  value  of  a  shell parameter; and the <b>zle</b> command
       manipulates editing widgets and allows command line access to ZLE commands from within shell functions.

       <b>bindkey</b> [ <u>options</u> ] <b>-l</b> [ <b>-L</b> ] [ <u>keymap</u> ... ]
       <b>bindkey</b> [ <u>options</u> ] <b>-d</b>
       <b>bindkey</b> [ <u>options</u> ] <b>-D</b> <u>keymap</u> ...
       <b>bindkey</b> [ <u>options</u> ] <b>-A</b> <u>old-keymap</u> <u>new-keymap</u>
       <b>bindkey</b> [ <u>options</u> ] <b>-N</b> <u>new-keymap</u> [ <u>old-keymap</u> ]
       <b>bindkey</b> [ <u>options</u> ] <b>-m</b>
       <b>bindkey</b> [ <u>options</u> ] <b>-r</b> <u>in-string</u> ...
       <b>bindkey</b> [ <u>options</u> ] <b>-s</b> <u>in-string</u> <u>out-string</u> ...
       <b>bindkey</b> [ <u>options</u> ] <u>in-string</u> <u>command</u> ...
       <b>bindkey</b> [ <u>options</u> ] [ <u>in-string</u> ]
              <b>bindkey</b>'s options can be divided into three categories: keymap selection for the current  command,
              operation selection, and others.  The keymap selection options are:

              <b>-e</b>     Selects keymap `<b>emacs</b>' for any operations by the current command, and also links `<b>emacs</b>' to
                     `<b>main</b>' so that it is selected by default the next time the editor starts.

              <b>-v</b>     Selects keymap `<b>viins</b>' for any operations by the current command, and also links `<b>viins</b>' to
                     `<b>main</b>' so that it is selected by default the next time the editor starts.

              <b>-a</b>     Selects keymap `<b>vicmd</b>' for any operations by the current command.

              <b>-M</b> <u>keymap</u>
                     The  <u>keymap</u>  specifies  a  keymap  name  that is selected for any operations by the current
                     command.

              If a keymap selection is required and none of the options above are used,  the  `<b>main</b>'  keymap  is
              used.  Some operations do not permit a keymap to be selected, namely:

              <b>-l</b>     List all existing keymap names; if any arguments are given, list just those keymaps.

                     If  the  <b>-L</b> option is also used, list in the form of <b>bindkey</b> commands to create or link the
                     keymaps.  `<b>bindkey</b> <b>-lL</b> <b>main</b>' shows which keymap is linked to `<b>main</b>', if any, and  hence  if
                     the  standard  emacs  or  vi  emulation  is in effect.  This option does not show the <b>.safe</b>
                     keymap because it cannot be created in that  fashion;  however,  neither  is  `<b>bindkey</b>  <b>-lL</b>
                     <b>.safe</b>' reported as an error, it simply outputs nothing.

              <b>-d</b>     Delete all existing keymaps and reset to the default state.

              <b>-D</b> <u>keymap</u> ...
                     Delete the named <u>keymap</u>s.

              <b>-A</b> <u>old-keymap</u> <u>new-keymap</u>
                     Make  the  <u>new-keymap</u>  name  an  alias for <u>old-keymap</u>, so that both names refer to the same
                     keymap.  The names have equal standing; if either is deleted, the other remains.  If  there
                     is already a keymap with the <u>new-keymap</u> name, it is deleted.

              <b>-N</b> <u>new-keymap</u> [ <u>old-keymap</u> ]
                     Create  a  new keymap, named <u>new-keymap</u>.  If a keymap already has that name, it is deleted.
                     If an <u>old-keymap</u> name is given, the new keymap is initialized to  be  a  duplicate  of  it,
                     otherwise the new keymap will be empty.

              To  use  a  newly  created keymap, it should be linked to <b>main</b>.  Hence the sequence of commands to
              create and use a new keymap `<b>mymap</b>' initialized from the <b>emacs</b> keymap  (which  remains  unchanged)
              is:

                     <b>bindkey</b> <b>-N</b> <b>mymap</b> <b>emacs</b>
                     <b>bindkey</b> <b>-A</b> <b>mymap</b> <b>main</b>

              Note that while `<b>bindkey</b> <b>-A</b> <u>newmap</u> <b>main</b>' will work when <u>newmap</u> is <b>emacs</b> or <b>viins</b>, it will not work
              for <b>vicmd</b>, as switching from vi insert to command mode becomes impossible.

              The following operations act on the `<b>main</b>' keymap if no keymap selection option was given:

              <b>-m</b>     Add  the  built-in  set  of  meta-key  bindings to the selected keymap.  Only keys that are
                     unbound or bound to <b>self-insert</b> are affected.

              <b>-r</b> <u>in-string</u> ...
                     Unbind the specified <u>in-string</u>s in the selected keymap.   This  is  exactly  equivalent  to
                     binding the strings to <b>undefined-key</b>.

                     When <b>-R</b> is also used, interpret the <u>in-string</u>s as ranges.

                     When  <b>-p</b>  is  also  used,  the <u>in-string</u>s specify prefixes.  Any binding that has the given
                     <u>in-string</u> as a prefix, not including the binding for the <u>in-string</u> itself, if any, will  be
                     removed.  For example,

                            <b>bindkey</b> <b>-rpM</b> <b>viins</b> <b>'^['</b>

                     will  remove  all  bindings  in  the  vi-insert  keymap  beginning with an escape character
                     (probably cursor keys), but leave the binding for the  escape  character  itself  (probably
                     <b>vi-cmd-mode</b>).  This is incompatible with the option <b>-R</b>.

              <b>-s</b> <u>in-string</u> <u>out-string</u> ...
                     Bind each <u>in-string</u> to each <u>out-string</u>.  When <u>in-string</u> is typed, <u>out-string</u> will be pushed
                     back  and  treated  as  input  to  the  line  editor.   When <b>-R</b> is also used, interpret the
                     <u>in-string</u>s as ranges.

                     Note that both <u>in-string</u> and <u>out-string</u> are subject to the same form of interpretation,  as
                     described below.

              <u>in-string</u> <u>command</u> ...
                     Bind each <u>in-string</u> to each <u>command</u>.  When <b>-R</b> is used, interpret the <u>in-string</u>s as ranges.

              [ <u>in-string</u> ]
                     List  key  bindings.   If  an  <u>in-string</u>  is  specified,  the binding of that string in the
                     selected keymap is displayed.  Otherwise, all key  bindings  in  the  selected  keymap  are
                     displayed.   (As  a  special  case, if the <b>-e</b> or <b>-v</b> option is used alone, the keymap is <u>not</u>
                     displayed - the implicit linking of keymaps is the only thing that happens.)

                     When the option <b>-p</b> is used, the <u>in-string</u> must be present.  The listing shows all  bindings
                     which  have  the  given  key  sequence  as a prefix, not including any bindings for the key
                     sequence itself.

                     When the <b>-L</b> option is used, the list is in the form of <b>bindkey</b> commands to create  the  key
                     bindings.

              When  the  <b>-R</b>  option  is  used  as noted above, a valid range consists of two characters, with an
              optional `<b>-</b>' between them.  All characters between the two  specified,  inclusive,  are  bound  as
              specified.

              For either <u>in-string</u> or <u>out-string</u>, the following escape sequences are recognised:

              <b>\a</b>     bell character
              <b>\b</b>     backspace
              <b>\e</b>, <b>\E</b> escape
              <b>\f</b>     form feed
              <b>\n</b>     linefeed (newline)
              <b>\r</b>     carriage return
              <b>\t</b>     horizontal tab
              <b>\v</b>     vertical tab
              <b>\</b><u>NNN</u>   character code in octal
              <b>\x</b><u>NN</u>   character code in hexadecimal
              <b>\u</b><u>NNNN</u> unicode character code in hexadecimal
              <b>\U</b><u>NNNNNNNN</u>
                     unicode character code in hexadecimal
              <b>\M</b>[<b>-</b>]<u>X</u> character with meta bit set
              <b>\C</b>[<b>-</b>]<u>X</u> control character
              <b>^</b><u>X</u>     control character

              In  all  other  cases, `<b>\</b>' escapes the following character.  Delete is written as `<b>^?</b>'.  Note that
              `<b>\M^?</b>' and `<b>^\M?</b>' are not the same, and that (unlike emacs), the bindings  `<b>\M-</b><u>X</u>'  and  `<b>\e</b><u>X</u>'  are
              entirely distinct, although they are initialized to the same bindings by `<b>bindkey</b> <b>-m</b>'.

       <b>vared</b> [ <b>-Aacghe</b> ] [ <b>-p</b> <u>prompt</u> ] [ <b>-r</b> <u>rprompt</u> ]
             [ <b>-M</b> <u>main-keymap</u> ] [ <b>-m</b> <u>vicmd-keymap</u> ]
             [ <b>-i</b> <u>init-widget</u> ] [ <b>-f</b> <u>finish-widget</u> ]
             [ <b>-t</b> <u>tty</u> ] <u>name</u>
              The  value  of  the parameter <u>name</u> is loaded into the edit buffer, and the line editor is invoked.
              When the editor exits, <u>name</u> is set to the string value returned by the editor.  When the  <b>-c</b>  flag
              is  given, the parameter is created if it doesn't already exist.  The <b>-a</b> flag may be given with <b>-c</b>
              to create an array parameter, or the <b>-A</b> flag to create an associative array.  If the  type  of  an
              existing  parameter  does  not match the type to be created, the parameter is unset and recreated.
              The <b>-g</b> flag may be given to suppress warnings  from  the  <b>WARN_CREATE_GLOBAL</b>  and  <b>WARN_NESTED_VAR</b>
              options.

              If  an array or array slice is being edited, separator characters as defined in <b>$IFS</b> will be shown
              quoted with a backslash, as will backslashes themselves.  Conversely,  when  the  edited  text  is
              split into an array, a backslash quotes an immediately following separator character or backslash;
              no other special handling of backslashes, or any handling of quotes, is performed.

              Individual  elements  of  existing  array  or  associative array parameters may be edited by using
              subscript syntax on <u>name</u>.  New elements are created automatically, even without <b>-c</b>.

              If the <b>-p</b> flag is given, the following string will be taken as the prompt to display at the  left.
              If the <b>-r</b> flag is given, the following string gives the prompt to display at the right.  If the <b>-h</b>
              flag  is  specified,  the  history  can  be  accessed from ZLE. If the <b>-e</b> flag is given, typing <b>^D</b>
              (Control-D) on an empty line causes <b>vared</b> to exit immediately with a non-zero return value.

              The <b>-M</b> option gives a keymap to link to the <b>main</b> keymap during editing, and the <b>-m</b> option gives  a
              keymap  to  link  to the <b>vicmd</b> keymap during editing.  For vi-style editing, this allows a pair of
              keymaps to override <b>viins</b> and <b>vicmd</b>.  For emacs-style editing, only <b>-M</b> is normally needed but  the
              <b>-m</b> option may still be used.  On exit, the previous keymaps will be restored.

              <b>Vared</b>  calls  the  usual  `<b>zle-line-init</b>'  and  `<b>zle-line-finish</b>'  hooks before and after it takes
              control. Using the <b>-i</b> and <b>-f</b> options, it is possible to replace these with other custom widgets.

              If `<b>-t</b> <u>tty</u>' is given, <u>tty</u> is the name of a terminal device to  be  used  instead  of  the  default
              <b>/dev/tty</b>.  If <u>tty</u> does not refer to a terminal an error is reported.

       <b>zle</b>
       <b>zle</b> <b>-l</b> [ <b>-L</b> | <b>-a</b> ] [ <u>string</u> ... ]
       <b>zle</b> <b>-D</b> <u>widget</u> ...
       <b>zle</b> <b>-A</b> <u>old-widget</u> <u>new-widget</u>
       <b>zle</b> <b>-N</b> <u>widget</u> [ <u>function</u> ]
       <b>zle</b> <b>-f</b> <u>flag</u> [ <u>flag</u>... ]
       <b>zle</b> <b>-C</b> <u>widget</u> <u>completion-widget</u> <u>function</u>
       <b>zle</b> <b>-R</b> [ <b>-c</b> ] [ <u>display-string</u> ] [ <u>string</u> ... ]
       <b>zle</b> <b>-M</b> <u>string</u>
       <b>zle</b> <b>-U</b> <u>string</u>
       <b>zle</b> <b>-K</b> <u>keymap</u>
       <b>zle</b> <b>-F</b> [ <b>-L</b> | <b>-w</b> ] [ <u>fd</u> [ <u>handler</u> ] ]
       <b>zle</b> <b>-I</b>
       <b>zle</b> <b>-T</b> [ <b>tc</b> <u>function</u> | <b>-r</b> <b>tc</b> | <b>-L</b> ]
       <b>zle</b> <u>widget</u> [ <b>-n</b> <u>num</u> ] [ <b>-f</b> <u>flag</u> ] [ <b>-Nw</b> ] [ <b>-K</b> <u>keymap</u> ] <u>args</u> ...
              The <b>zle</b> builtin performs a number of different actions concerning ZLE.

              With  no  options  and  no  arguments,  only  the return status will be set.  It is zero if ZLE is
              currently active and widgets could be invoked using this builtin command and  non-zero  otherwise.
              Note  that  even if non-zero status is returned, zle may still be active as part of the completion
              system; this does not allow direct calls to ZLE widgets.

              Otherwise, which operation it performs depends on its options:

              <b>-l</b> [ <b>-L</b> | <b>-a</b> ] [ <u>string</u> ]
                     List all existing user-defined widgets.  If the <b>-L</b> option is used, list in the form of  <b>zle</b>
                     commands to create the widgets.

                     When  combined with the <b>-a</b> option, all widget names are listed, including the builtin ones.
                     In this case the <b>-L</b> option is ignored.

                     If at least one <u>string</u> is given, and <b>-a</b> is present or <b>-L</b>  is  not  used,  nothing  will  be
                     printed.   The  return status will be zero if all <u>string</u>s are names of existing widgets and
                     non-zero if at least one <u>string</u> is not a name of a defined widget.  If <b>-a</b> is also  present,
                     all  widget  names  are  used  for  the  comparison  including  builtin  widgets, else only
                     user-defined widgets are used.

                     If at least one <u>string</u> is present and the <b>-L</b> option is used, user-defined widgets  matching
                     any <u>string</u> are listed in the form of <b>zle</b> commands to create the widgets.

              <b>-D</b> <u>widget</u> ...
                     Delete the named <u>widget</u>s.

              <b>-A</b> <u>old-widget</u> <u>new-widget</u>
                     Make  the  <u>new-widget</u>  name  an  alias for <u>old-widget</u>, so that both names refer to the same
                     widget.  The names have equal standing; if either is deleted, the other remains.  If  there
                     is already a widget with the <u>new-widget</u> name, it is deleted.

              <b>-N</b> <u>widget</u> [ <u>function</u> ]
                     Create  a user-defined widget.  If there is already a widget with the specified name, it is
                     overwritten.  When the new widget is invoked from within the editor,  the  specified  shell
                     <u>function</u>  is called.  If no function name is specified, it defaults to the same name as the
                     widget.  For further information, see the section `Widgets' below.

              <b>-f</b> <u>flag</u> [ <u>flag</u>... ]
                     Set various flags on the running widget.  Possible values for <u>flag</u> are:

                     <b>yank</b> for indicating that the widget has yanked text into the  buffer.   If  the  widget  is
                     wrapping  an  existing  internal  widget,  no  further  action  is necessary, but if it has
                     inserted the text manually, then it should also take care to set  <b>YANK_START</b>  and  <b>YANK_END</b>
                     correctly.   <b>yankbefore</b>  does  the  same but is used when the yanked text appears after the
                     cursor.

                     <b>kill</b> for indicating that text has been killed into the cutbuffer.  When repeatedly invoking
                     a kill widget, text is appended to the cutbuffer instead of replacing it, but when wrapping
                     such widgets, it is necessary to call `<b>zle</b> <b>-f</b> <b>kill</b>' to retain this effect.

                     <b>vichange</b> for indicating that the widget represents a vi change that can be  repeated  as  a
                     whole  with  `<b>vi-repeat-change</b>'.  The  flag  should  be  set  early  in the function before
                     inspecting the value of <b>NUMERIC</b> or invoking other widgets. This has no effect for a  widget
                     invoked  from  insert  mode.  If insert mode is active when the widget finishes, the change
                     extends until next returning to command mode.

              <b>-C</b> <u>widget</u> <u>completion-widget</u> <u>function</u>
                     Create a user-defined completion widget named <u>widget</u>. The  completion  widget  will  behave
                     like  the  built-in completion-widget whose name is given as <u>completion-widget</u>. To generate
                     the completions, the shell function <u>function</u> will be called.  For further information,  see
                     <u><a href="../man1/zshcompwid.1.html">zshcompwid</a></u>(1).

              <b>-R</b> [ <b>-c</b> ] [ <u>display-string</u> ] [ <u>string</u> ... ]
                     Redisplay  the  command line.  If a <u>display-string</u> is given and not empty, this is shown in
                     the status line (immediately below the line being edited).

                     If the optional <u>string</u>s are given they are listed below the  prompt  in  the  same  way  as
                     completion lists are printed. If no <u>string</u>s are given but the <b>-c</b> option is used such a list
                     is cleared.

                     Note  that  immediately  after  returning  from  running  widgets, the command line will be
                     redisplayed and the strings displayed will be  erased.   Therefore,  this  option  is  only
                     useful for widgets that do not exit immediately after using it.

                     This  command  can  safely  be  called  outside user defined widgets; if zle is active, the
                     display will be refreshed, while if zle is not active, the command has no effect.  In  this
                     case there will usually be no other arguments.

                     The status is zero if zle was active, else one.

              <b>-M</b> <u>string</u>
                     As  with  the <b>-R</b> option, the <u>string</u> will be displayed below the command line; unlike the <b>-R</b>
                     option, the string will not be put into  the  status  line  but  will  instead  be  printed
                     normally  below  the  prompt.  This means that the <u>string</u> will still be displayed after the
                     widget returns (until it is overwritten by subsequent commands).

              <b>-U</b> <u>string</u>
                     This pushes the characters in the <u>string</u> onto the input stack of  ZLE.   After  the  widget
                     currently  executed  finishes ZLE will behave as if the characters in the <u>string</u> were typed
                     by the user.

                     As ZLE uses a stack, if this option is used repeatedly the  last  string  pushed  onto  the
                     stack will be processed first.  However, the characters in each <u>string</u> will be processed in
                     the order in which they appear in the string.

              <b>-K</b> <u>keymap</u>
                     Selects  the  keymap  named <u>keymap</u>.  An error message will be displayed if there is no such
                     keymap.

                     This keymap selection affects  the  interpretation  of  following  keystrokes  within  this
                     invocation  of  ZLE.   Any following invocation (e.g., the next command line) will start as
                     usual with the `<b>main</b>' keymap selected.

              <b>-F</b> [ <b>-L</b> | <b>-w</b> ] [ <u>fd</u> [ <u>handler</u> ] ]
                     Only available if your system supports one of the `poll' or  `select'  system  calls;  most
                     modern systems do.

                     Installs  <u>handler</u>  (the  name of a shell function) to handle input from file descriptor <u>fd</u>.
                     Installing a handler for an <u>fd</u> which is already handled causes the existing handler  to  be
                     replaced.   Any  number  of  handlers  for  any  number of readable file descriptors may be
                     installed.  Note that zle makes no attempt to check whether this <u>fd</u>  is  actually  readable
                     when  installing  the  handler.  The user must make their own arrangements for handling the
                     file descriptor when zle is not active.

                     When zle is attempting to read data, it will examine both the  terminal  and  the  list  of
                     handled  <u>fd</u>'s.   If  data  becomes available on a handled <u>fd</u>, zle calls <u>handler</u> with the fd
                     which is ready for reading as the first argument.  Under normal circumstances this  is  the
                     only  argument, but if an error was detected, a second argument provides details: `<b>hup</b>' for
                     a disconnect, `<b>nval</b>' for a closed or otherwise invalid descriptor, or `<b>err</b>' for  any  other
                     condition.  Systems that support only the `select' system call always use `<b>err</b>'.

                     If  the  option  <b>-w</b> is also given, the <u>handler</u> is instead a line editor widget, typically a
                     shell function made into a widget using `<b>zle</b> <b>-N</b>'.  In that case <u>handler</u>  can  use  all  the
                     facilities  of  zle to update the current editing line.  Note, however, that as handling <u>fd</u>
                     takes place at a low level changes to the display will not automatically appear; the widget
                     should call `<b>zle</b> <b>-R</b>' to force redisplay.  As of this writing, widget handlers only  support
                     a  single  argument  and thus are never passed a string for error state, so widgets must be
                     prepared to test the descriptor themselves.

                     If either type of handler produces output to the terminal, it should call `<b>zle</b>  <b>-I</b>'  before
                     doing so (see below).  Handlers should not attempt to read from the terminal.

                     If no <u>handler</u> is given, but an <u>fd</u> is present, any handler for that <u>fd</u> is removed.  If there
                     is none, an error message is printed and status 1 is returned.

                     If no arguments are given, or the <b>-L</b> option is supplied, a list of handlers is printed in a
                     form which can be stored for later execution.

                     An  <u>fd</u>  (but  not  a <u>handler</u>) may optionally be given with the <b>-L</b> option; in this case, the
                     function will list the handler if any, else silently return status 1.

                     Note that this feature should be used with care.  Activity on one of the <u>fd</u>'s which is  not
                     properly  handled  can  cause the terminal to become unusable.  Removing an <u>fd</u> handler from
                     within a signal trap may cause unpredictable behavior.

                     Here is a simple example of using this feature.  A connection  to  a  remote  TCP  port  is
                     created  using  the  ztcp  command;  see  the  description  of  the  <b>zsh/net/tcp</b>  module in
                     <u><a href="../man1/zshmodules.1.html">zshmodules</a></u>(1).  Then a handler is installed which simply prints out any data which  arrives
                     on  this  connection.   Note  that  `select'  will  indicate that the file descriptor needs
                     handling if the remote side has closed the connection; we handle  that  by  testing  for  a
                     failed read.

                            <b>if</b> <b>ztcp</b> <b>pwspc</b> <b>2811;</b> <b>then</b>
                              <b>tcpfd=$REPLY</b>
                              <b>handler()</b> <b>{</b>
                                <b>zle</b> <b>-I</b>
                                <b>local</b> <b>line</b>
                                <b>if</b> <b>!</b> <b>read</b> <b>-r</b> <b>line</b> <b>&lt;&amp;$1;</b> <b>then</b>
                                  <b>#</b> <b>select</b> <b>marks</b> <b>this</b> <b>fd</b> <b>if</b> <b>we</b> <b>reach</b> <b>EOF,</b>
                                  <b>#</b> <b>so</b> <b>handle</b> <b>this</b> <b>specially.</b>
                                  <b>print</b> <b>"[Read</b> <b>on</b> <b>fd</b> <b>$1</b> <b>failed,</b> <b>removing.]"</b> <b>&gt;&amp;2</b>
                                  <b>zle</b> <b>-F</b> <b>$1</b>
                                  <b>return</b> <b>1</b>
                                <b>fi</b>
                                <b>print</b> <b>-r</b> <b>-</b> <b>$line</b>
                              <b>}</b>
                              <b>zle</b> <b>-F</b> <b>$tcpfd</b> <b>handler</b>
                            <b>fi</b>

              <b>-I</b>     Unusually,  this  option is most useful outside ordinary widget functions, though it may be
                     used within if normal output to the terminal is required.  It invalidates the  current  zle
                     display  in preparation for output; typically this will be from a trap function.  It has no
                     effect if zle is not active.  When a trap exits, the shell checks to  see  if  the  display
                     needs  restoring, hence the following will print output in such a way as not to disturb the
                     line being edited:

                            <b>TRAPUSR1()</b> <b>{</b>
                              <b>#</b> <b>Invalidate</b> <b>zle</b> <b>display</b>
                              <b>[[</b> <b>-o</b> <b>zle</b> <b>]]</b> <b>&amp;&amp;</b> <b>zle</b> <b>-I</b>
                              <b>#</b> <b>Show</b> <b>output</b>
                              <b>print</b> <b>Hello</b>
                            <b>}</b>

                     In general, the trap function may need to test whether zle  is  active  before  using  this
                     method (as shown in the example), since the <b>zsh/zle</b> module may not even be loaded; if it is
                     not, the command can be skipped.

                     It is possible to call `<b>zle</b> <b>-I</b>' several times before control is returned to the editor; the
                     display will only be invalidated the first time to minimise disruption.

                     Note  that  there  are  normally  better  ways  of manipulating the display from within zle
                     widgets; see, for example, `<b>zle</b> <b>-R</b>' above.

                     The returned status is zero if zle was invalidated, even though this may  have  been  by  a
                     previous  call  to  `<b>zle</b>  <b>-I</b>'  or by a system notification.  To test if a zle widget may be
                     called at this point, execute <b>zle</b> with no arguments and examine the return status.

              <b>-T</b>     This is used to add, list or remove internal transformations on the processing performed by
                     the line editor.  It is typically used only for debugging or testing and  is  therefore  of
                     little interest to the general user.

                     `<b>zle</b>  <b>-T</b>  <u>transformation</u>  <u>func</u>'  specifies  that  the  given  <u>transformation</u> (see below) is
                     effected by shell function <u>func</u>.

                     `<b>zle</b> <b>-Tr</b> <u>transformation</u>' removes the given <u>transformation</u> if it was present (it is  not  an
                     error if none was).

                     `<b>zle</b> <b>-TL</b>' can be used to list all transformations currently in operation.

                     Currently  the only transformation is <b>tc</b>.  This is used instead of outputting termcap codes
                     to the terminal.  When the transformation is in operation the shell function is passed  the
                     termcap  code  that  would  be  output  as  its first argument; if the operation required a
                     numeric argument, that is passed as a second argument.  The function should set  the  shell
                     variable  <b>REPLY</b>  to  the  transformed termcap code.  Typically this is used to produce some
                     simply formatted version of the code and optional argument for debugging or testing.   Note
                     that  this  transformation is not applied to other non-printing characters such as carriage
                     returns and newlines.

              <u>widget</u> [ <b>-n</b> <u>num</u> ] [ <b>-f</b> <u>flag</u> ] [ <b>-Nw</b> ] [ <b>-K</b> <u>keymap</u> ] <u>args</u> ...
                     Invoke the specified <u>widget</u>.  This can only be done when ZLE is active; normally this  will
                     be within a user-defined widget.

                     With  the  options  <b>-n</b> and <b>-N</b>, the current numeric argument will be saved and then restored
                     after the call to <u>widget</u>; `<b>-n</b> <u>num</u>' sets the numeric argument temporarily to <u>num</u>, while `<b>-N</b>'
                     sets it to the default, i.e. as if there were none.

                     With the option <b>-K</b>, <u>keymap</u> will be used as the current keymap during the execution  of  the
                     widget.  The previous keymap will be restored when the widget exits.

                     Normally,  calling  a  widget  in  this  way  does not set the special parameter <b>WIDGET</b> and
                     related parameters, so that the environment appears as if the top-level  widget  called  by
                     the  user  were still active.  With the option <b>-w</b>, <b>WIDGET</b> and related parameters are set to
                     reflect the widget being executed by the <b>zle</b> call.

                     Normally, when <u>widget</u> returns the special parameter <b>LASTWIDGET</b> will point to it.  This  can
                     be inhibited by passing the option <b>-f</b> <b>nolast</b>.

                     Any further arguments will be passed to the widget; note that as standard argument handling
                     is  performed,  any  general  argument  list  should  be  preceded by <b>--</b>.  If it is a shell
                     function, these are passed down as positional parameters; for builtin widgets it is  up  to
                     the widget in question what it does with them.  Currently arguments are only handled by the
                     incremental-search commands, the <b>history-search-forward</b> and <b>-backward</b> and the corresponding
                     functions  prefixed  by <b>vi-</b>, and by <b>universal-argument</b>.  No error is flagged if the command
                     does not use the arguments, or only uses some of them.

                     The return status reflects the success or failure of  the  operation  carried  out  by  the
                     widget, or if it is a user-defined widget the return status of the shell function.

                     A  non-zero  return  status causes the shell to beep when the widget exits, unless the <b>BEEP</b>
                     options was unset or the widget was called via the <b>zle</b> command.  Thus  if  a  user  defined
                     widget requires an immediate beep, it should call the <b>beep</b> widget directly.

</pre><h4><b>ZLE</b> <b>WIDGETS</b></h4><pre>
       All  actions  in  the  editor are performed by `widgets'.  A widget's job is simply to perform some small
       action.  The ZLE commands that key sequences in keymaps are bound to are in fact widgets.  Widgets can be
       user-defined or built in.

       The standard widgets built into ZLE are listed in the section `Standard Widgets' below.   Other  built-in
       widgets  can  be  defined  by other modules (see <u><a href="../man1/zshmodules.1.html">zshmodules</a></u>(1)).  Each built-in widget has two names: its
       normal canonical name, and the same name preceded by a `<b>.</b>'.  The `<b>.</b>' name is special: it can't be rebound
       to a different widget.  This makes the widget available even when its usual name has been redefined.

       User-defined widgets are defined using `<b>zle</b> <b>-N</b>', and implemented as shell functions.  When the widget  is
       executed,  the  corresponding shell function is executed, and can perform editing (or other) actions.  It
       is recommended that user-defined widgets should not have names starting with `<b>.</b>'.

</pre><h4><b>USER-DEFINED</b> <b>WIDGETS</b></h4><pre>
       User-defined widgets, being implemented as shell functions, can execute any normal shell  command.   They
       can also run other widgets (whether built-in or user-defined) using the <b>zle</b> builtin command. The standard
       input  of  the  function  is  redirected from /dev/null to prevent external commands from unintentionally
       blocking ZLE by reading from the terminal, but <b>read</b> <b>-k</b> or  <b>read</b>  <b>-q</b>  can  be  used  to  read  characters.
       Finally,  they  can  examine  and  edit  the  ZLE  buffer being edited by reading and setting the special
       parameters described below.

       These special parameters are always available in widget functions, but are not in any way special outside
       ZLE.  If they have some normal value outside ZLE, that value is temporarily inaccessible, but will return
       when the widget function exits.  These special parameters in  fact  have  local  scope,  like  parameters
       created in a function using <b>local</b>.

       Inside completion widgets and traps called while ZLE is active, these parameters are available read-only.

       Note  that the parameters appear as local to any ZLE widget in which they appear.  Hence if it is desired
       to override them this needs to be done within a nested function:

              <b>widget-function()</b> <b>{</b>
                <b>#</b> <b>$WIDGET</b> <b>here</b> <b>refers</b> <b>to</b> <b>the</b> <b>special</b> <b>variable</b>
                <b>#</b> <b>that</b> <b>is</b> <b>local</b> <b>inside</b> <b>widget-function</b>
                <b>()</b> <b>{</b>
                   <b>#</b> <b>This</b> <b>anonymous</b> <b>nested</b> <b>function</b> <b>allows</b> <b>WIDGET</b>
                   <b>#</b> <b>to</b> <b>be</b> <b>used</b> <b>as</b> <b>a</b> <b>local</b> <b>variable.</b>  <b>The</b> <b>-h</b>
                   <b>#</b> <b>removes</b> <b>the</b> <b>special</b> <b>status</b> <b>of</b> <b>the</b> <b>variable.</b>
                   <b>local</b> <b>-h</b> <b>WIDGET</b>
                <b>}</b>
              <b>}</b>

       <b>BUFFER</b> (scalar)
              The entire contents of the edit buffer.  If it is written to,  the  cursor  remains  at  the  same
              offset, unless that would put it outside the buffer.

       <b>BUFFERLINES</b> (integer)
              The  number of screen lines needed for the edit buffer currently displayed on screen (i.e. without
              any changes to the preceding parameters done after the last redisplay); read-only.

       <b>CONTEXT</b> (scalar)
              The context in which zle was called to read a line; read-only.  One of the values:

              <b>start</b>  The start of a command line (at prompt <b>PS1</b>).

              <b>cont</b>   A continuation to a command line (at prompt <b>PS2</b>).

              <b>select</b> In a <b>select</b> loop (at prompt <b>PS3</b>).

              <b>vared</b>  Editing a variable in <b>vared</b>.

       <b>CURSOR</b> (integer)
              The offset of the cursor, within the edit buffer.  This is in the range 0 to <b>$#BUFFER</b>, and  is  by
              definition  equal to <b>$#LBUFFER</b>.  Attempts to move the cursor outside the buffer will result in the
              cursor being moved to the appropriate end of the buffer.

       <b>CUTBUFFER</b> (scalar)
              The last item cut using one of the `<b>kill-</b>' commands; the string which the next yank  would  insert
              in  the  line.   Later  entries in the kill ring are in the array <b>killring</b>.  Note that the command
              `<b>zle</b> <b>copy-region-as-kill</b> <u>string</u>' can be used to set the text  of  the  cut  buffer  from  a  shell
              function and cycle the kill ring in the same way as interactively killing text.

       <b>HISTNO</b> (integer)
              The  current history number.  Setting this has the same effect as moving up or down in the history
              to the corresponding history line.  An attempt to set it is ignored if the line is not  stored  in
              the history.  Note this is not the same as the parameter <b>HISTCMD</b>, which always gives the number of
              the  history  line  being  added  to  the  main  shell's history.  <b>HISTNO</b> refers to the line being
              retrieved within zle.

       <b>ISEARCHMATCH_ACTIVE</b> (integer)
       <b>ISEARCHMATCH_START</b> (integer)
       <b>ISEARCHMATCH_END</b> (integer)
              <b>ISEARCHMATCH_ACTIVE</b> indicates whether a part of the <b>BUFFER</b> is currently matched by an  incremental
              search  pattern. <b>ISEARCHMATCH_START</b> and <b>ISEARCHMATCH_END</b> give the location of the matched part and
              are in the same units as <b>CURSOR</b>. They are only  valid  for  reading  when  <b>ISEARCHMATCH_ACTIVE</b>  is
              non-zero.

              All parameters are read-only.

       <b>KEYMAP</b> (scalar)
              The name of the currently selected keymap; read-only.

       <b>KEYS</b> (scalar)
              The keys typed to invoke this widget, as a literal string; read-only.

       <b>KEYS_QUEUED_COUNT</b> (integer)
              The number of bytes pushed back to the input queue and therefore available for reading immediately
              before any I/O is done; read-only.  See also <b>PENDING</b>; the two values are distinct.

       <b>killring</b> (array)
              The  array  of previously killed items, with the most recently killed first.  This gives the items
              that would be retrieved by a <b>yank-pop</b> in the same order.  Note, however, that  the  most  recently
              killed item is in <b>$CUTBUFFER</b>; <b>$killring</b> shows the array of previous entries.

              The  default  size  for  the kill ring is eight, however the length may be changed by normal array
              operations.  Any empty string in the kill ring is ignored by the <b>yank-pop</b> command, hence the  size
              of  the  array  effectively sets the maximum length of the kill ring, while the number of non-zero
              strings gives the current length, both as seen by the user at the command line.

       <b>LASTABORTEDSEARCH</b> (scalar)
              The last search string used by an interactive search that  was  aborted  by  the  user  (status  3
              returned by the search widget).

       <b>LASTSEARCH</b> (scalar)
              The  last  search string used by an interactive search; read-only.  This is set even if the search
              failed (status 0, 1 or 2 returned by the search widget), but not if it was aborted by the user.

       <b>LASTWIDGET</b> (scalar)
              The name of the last widget that was executed; read-only.

       <b>LBUFFER</b> (scalar)
              The part of the buffer that lies to the left of the cursor position.  If it is assigned  to,  only
              that  part  of the buffer is replaced, and the cursor remains between the new <b>$LBUFFER</b> and the old
              <b>$RBUFFER</b>.

       <b>MARK</b> (integer)
              Like <b>CURSOR</b>, but for the mark. With vi-mode operators that wait for a movement command to select a
              region of text, setting <b>MARK</b> allows the selection to extend in both directions  from  the  initial
              cursor position.

       <b>NUMERIC</b> (integer)
              The  numeric argument. If no numeric argument was given, this parameter is unset. When this is set
              inside a widget function, builtin widgets called with the <b>zle</b> builtin command will use  the  value
              assigned.  If it is unset inside a widget function, builtin widgets called behave as if no numeric
              argument was given.

       <b>PENDING</b> (integer)
              The number of bytes pending for input, i.e. the number of bytes which have already been typed  and
              can  immediately  be  read.  On  systems where the shell is not able to get this information, this
              parameter will always have a value of zero.   Read-only.   See  also  <b>KEYS_QUEUED_COUNT</b>;  the  two
              values are distinct.

       <b>PREBUFFER</b> (scalar)
              In  a  multi-line input at the secondary prompt, this read-only parameter contains the contents of
              the lines before the one the cursor is currently in.

       <b>PREDISPLAY</b> (scalar)
              Text to be displayed before the start of the editable text buffer.  This does not  have  to  be  a
              complete  line;  to  display  a complete line, a newline must be appended explicitly.  The text is
              reset on each new invocation (but not recursive invocation) of zle.

       <b>POSTDISPLAY</b> (scalar)
              Text to be displayed after the end of the editable text buffer.   This  does  not  have  to  be  a
              complete  line;  to  display a complete line, a newline must be prepended explicitly.  The text is
              reset on each new invocation (but not recursive invocation) of zle.

       <b>RBUFFER</b> (scalar)
              The part of the buffer that lies to the right of the cursor position.  If it is assigned to,  only
              that  part  of the buffer is replaced, and the cursor remains between the old <b>$LBUFFER</b> and the new
              <b>$RBUFFER</b>.

       <b>REGION_ACTIVE</b> (integer)
              Indicates if the region is currently active.  It can be assigned 0 or 1 to deactivate and activate
              the region respectively. A value of 2 activates the region in line-wise mode with the  highlighted
              text extending for whole lines only; see <u>Character</u> <u>Highlighting</u> below.

       <b>region_highlight</b> (array)
              Each  element  of  this  array may be set to a string that describes highlighting for an arbitrary
              region of the command line that will take effect the next time the command  line  is  redisplayed.
              Highlighting  of  the  non-editable  parts  of  the command line in <b>PREDISPLAY</b> and <b>POSTDISPLAY</b> are
              possible, but note that the <b>P</b> flag is needed for character indexing to include <b>PREDISPLAY</b>.

              Each string consists of the following whitespace-separated parts:

                    Optionally, a `<b>P</b>' to signify that the start and end offset that follow include  any  string
                     set  by the <b>PREDISPLAY</b> special parameter; this is needed if the predisplay string itself is
                     to be highlighted.  Whitespace between the `<b>P</b>' and the start offset is optional.

                    A start offset in the same units as <b>CURSOR</b>.

                    An end offset in the same units as <b>CURSOR</b>.

                    A highlight specification in the  same  format  as  used  for  contexts  in  the  parameter
                     <b>zle_highlight</b>,  see  the  section  `Character Highlighting' below; for example, <b>standout</b> or
                     <b>fg=red,bold</b>.

                    Optionally, a string of the form `<b>memo=</b><u>token</u>'.  The <u>token</u> consists  of  everything  between
                     the  `<b>=</b>'  and  the  next  whitespace,  comma,  NUL, or the end of the string.  The <u>token</u> is
                     preserved verbatim but not parsed in any way.

                     Plugins may use this to identify array elements they have  added:  for  example,  a  plugin
                     might   set   <u>token</u>   to   its   (the  plugin's)  name  and  then  use  `<b>region_highlight=(</b>
                     <b>${region_highlight:#*memo=</b><u>token</u><b>}</b> <b>)</b>' in order to remove array elements it have added.

                     (This example uses the `<b>${</b><u>name</u><b>:#</b><u>pattern</u><b>}</b>' array-grepping syntax described  in  the  section
                     `Parameter Expansion' in <u><a href="../man1/zshexpn.1.html">zshexpn</a></u>(1).)

              For example,

                     <b>region_highlight=("P0</b> <b>20</b> <b>bold</b> <b>memo=foobar")</b>

              specifies  that  the first twenty characters of the text including any predisplay string should be
              highlighted in bold.

              Note that the effect of <b>region_highlight</b> is not saved and  disappears  as  soon  as  the  line  is
              accepted.

              Note  that  zsh  5.8  and  older  do not support the `<b>memo=</b><u>token</u>' field and may misparse the third
              (highlight specification) field when a memo is given.

              The final highlighting on the command line depends on both <b>region_highlight</b> and <b>zle_highlight</b>; see
              the section CHARACTER HIGHLIGHTING below for details.

       <b>registers</b> (associative array)
              The contents of each of the vi register buffers.  These  are  typically  set  using  <b>vi-set-buffer</b>
              followed by a delete, change or yank command.

       <b>SUFFIX_ACTIVE</b> (integer)
       <b>SUFFIX_START</b> (integer)
       <b>SUFFIX_END</b> (integer)
              <b>SUFFIX_ACTIVE</b>   indicates  whether  an  auto-removable  completion  suffix  is  currently  active.
              <b>SUFFIX_START</b> and <b>SUFFIX_END</b> give the location of the suffix and are in the same units  as  <b>CURSOR</b>.
              They are only valid for reading when <b>SUFFIX_ACTIVE</b> is non-zero.

              All parameters are read-only.

       <b>UNDO_CHANGE_NO</b> (integer)
              A  number  representing  the  state  of  the  undo history.  The only use of this is passing as an
              argument to the <b>undo</b> widget in order to undo back to the recorded point.  Read-only.

       <b>UNDO_LIMIT_NO</b> (integer)
              A number corresponding to an existing change in the undo history; compare <b>UNDO_CHANGE_NO</b>.  If this
              is set to a value greater than zero, the <b>undo</b> command will not allow the line to be undone  beyond
              the given change number.  It is still possible to use `<b>zle</b> <b>undo</b> <u>change</u>' in a widget to undo beyond
              that  point;  in that case, it will not be possible to undo at all until <b>UNDO_LIMIT_NO</b> is reduced.
              Set to 0 to disable the limit.

              A typical use of this variable in a widget function is as follows (note  the  additional  function
              scope is required):

                     <b>()</b> <b>{</b>
                       <b>local</b> <b>UNDO_LIMIT_NO=$UNDO_CHANGE_NO</b>
                       <b>#</b> <b>Perform</b> <b>some</b> <b>form</b> <b>of</b> <b>recursive</b> <b>edit.</b>
                     <b>}</b>

       <b>WIDGET</b> (scalar)
              The name of the widget currently being executed; read-only.

       <b>WIDGETFUNC</b> (scalar)
              The  name of the shell function that implements a widget defined with either <b>zle</b> <b>-N</b> or <b>zle</b> <b>-C</b>.  In
              the former case, this is the second argument to the <b>zle</b> <b>-N</b> command that defined the widget, or the
              first argument if there was no second argument.  In the latter case this is the third argument  to
              the <b>zle</b> <b>-C</b> command that defined the widget.  Read-only.

       <b>WIDGETSTYLE</b> (scalar)
              Describes  the  implementation  behind  the completion widget currently being executed; the second
              argument that followed <b>zle</b> <b>-C</b> when the widget  was  defined.   This  is  the  name  of  a  builtin
              completion widget.  For widgets defined with <b>zle</b> <b>-N</b> this is set to the empty string.  Read-only.

       <b>YANK_ACTIVE</b> (integer)
       <b>YANK_START</b> (integer)
       <b>YANK_END</b> (integer)
              <b>YANK_ACTIVE</b>  indicates whether text has just been yanked (pasted) into the buffer.  <b>YANK_START</b> and
              <b>YANK_END</b> give the location of the pasted text and are in the same units as <b>CURSOR</b>.  They are  only
              valid  for reading when <b>YANK_ACTIVE</b> is non-zero.  They can also be assigned by widgets that insert
              text in a yank-like fashion, for example wrappers of <b>bracketed-paste</b>.  See also <b>zle</b> <b>-f</b>.

              <b>YANK_ACTIVE</b> is read-only.

       <b>ZLE_RECURSIVE</b> (integer)
              Usually zero, but incremented inside any instance of <b>recursive-edit</b>.  Hence indicates the  current
              recursion level.

              <b>ZLE_RECURSIVE</b> is read-only.

       <b>ZLE_STATE</b> (scalar)
              Contains a set of space-separated words that describe the current <b>zle</b> state.

              Currently, the states shown are the insert mode as set by the <b>overwrite-mode</b> or <b>vi-replace</b> widgets
              and  whether  history  commands will visit imported entries as controlled by the set-local-history
              widget.  The string contains `<b>insert</b>' if characters to  be  inserted  on  the  command  line  move
              existing  characters  to  the right or `<b>overwrite</b>' if characters to be inserted overwrite existing
              characters. It contains  `<b>localhistory</b>'  if  only  local  history  commands  will  be  visited  or
              `<b>globalhistory</b>' if imported history commands will also be visited.

              The  substrings  are  sorted  in  alphabetical  order so that if you want to test for two specific
              substrings in a future-proof way, you can do match by doing:

                     <b>if</b> <b>[[</b> <b>$ZLE_STATE</b> <b>==</b> <b>*globalhistory*insert*</b> <b>]];</b> <b>then</b> <b>...;</b> <b>fi</b>

   <b>Special</b> <b>Widgets</b>
       There are a few user-defined widgets which are special to the shell.  If they do not  exist,  no  special
       action is taken.  The environment provided is identical to that for any other editing widget.

       <b>zle-isearch-exit</b>
              Executed  at  the  end of incremental search at the point where the isearch prompt is removed from
              the display.  See <b>zle-isearch-update</b> for an example.

       <b>zle-isearch-update</b>
              Executed within incremental search when the display is about to  be  redrawn.   Additional  output
              below  the  incremental  search  prompt can be generated by using `<b>zle</b> <b>-M</b>' within the widget.  For
              example,

                     <b>zle-isearch-update()</b> <b>{</b> <b>zle</b> <b>-M</b> <b>"Line</b> <b>$HISTNO";</b> <b>}</b>
                     <b>zle</b> <b>-N</b> <b>zle-isearch-update</b>

              Note the line output by `<b>zle</b> <b>-M</b>' is not deleted on exit from incremental search.  This can be done
              from a <b>zle-isearch-exit</b> widget:

                     <b>zle-isearch-exit()</b> <b>{</b> <b>zle</b> <b>-M</b> <b>"";</b> <b>}</b>
                     <b>zle</b> <b>-N</b> <b>zle-isearch-exit</b>

       <b>zle-line-pre-redraw</b>
              Executed whenever the input line is about to be redrawn, providing an opportunity  to  update  the
              region_highlight array.

       <b>zle-line-init</b>
              Executed every time the line editor is started to read a new line of input.  The following example
              puts the line editor into vi command mode when it starts up.

                     <b>zle-line-init()</b> <b>{</b> <b>zle</b> <b>-K</b> <b>vicmd;</b> <b>}</b>
                     <b>zle</b> <b>-N</b> <b>zle-line-init</b>

              (The command inside the function sets the keymap directly; it is equivalent to <b>zle</b> <b>vi-cmd-mode</b>.)

       <b>zle-line-finish</b>
              This is similar to <b>zle-line-init</b> but is executed every time the line editor has finished reading a
              line of input.

       <b>zle-history-line-set</b>
              Executed when the history line changes.

       <b>zle-keymap-select</b>
              Executed  every  time  the keymap changes, i.e. the special parameter <b>KEYMAP</b> is set to a different
              value, while the line editor is active.  Initialising the keymap when the line editor starts  does
              not cause the widget to be called.

              The  value  <b>$KEYMAP</b>  within the function reflects the new keymap.  The old keymap is passed as the
              sole argument.

              This can be used for detecting switches between the vi command (<b>vicmd</b>) and insert  (usually  <b>main</b>)
              keymaps.

</pre><h4><b>STANDARD</b> <b>WIDGETS</b></h4><pre>
       The following is a list of all the standard widgets, and their default bindings in emacs mode, vi command
       mode and vi insert mode (the `<b>emacs</b>', `<b>vicmd</b>' and `<b>viins</b>' keymaps, respectively).

       Note  that cursor keys are bound to movement keys in all three keymaps; the shell assumes that the cursor
       keys send the key sequences reported by the terminal-handling library (termcap  or  terminfo).   The  key
       sequences  shown  in  the list are those based on the VT100, common on many modern terminals, but in fact
       these are not necessarily bound.  In the case of the <b>viins</b> keymap, the initial escape  character  of  the
       sequences serves also to return to the <b>vicmd</b> keymap: whether this happens is determined by the <b>KEYTIMEOUT</b>
       parameter, see <u><a href="../man1/zshparam.1.html">zshparam</a></u>(1).

   <b>Movement</b>
       <b>vi-backward-blank-word</b> (unbound) (<b>B</b>) (unbound)
              Move backward one word, where a word is defined as a series of non-blank characters.

       <b>vi-backward-blank-word-end</b> (unbound) (<b>gE</b>) (unbound)
              Move to the end of the previous word, where a word is defined as a series of non-blank characters.

       <b>backward-char</b> (<b>^B</b> <b>ESC-[D</b>) (unbound) (unbound)
              Move backward one character.

       <b>vi-backward-char</b> (unbound) (<b>^H</b> <b>h</b> <b>^?</b>) (<b>ESC-[D</b>)
              Move backward one character, without changing lines.

       <b>backward-word</b> (<b>ESC-B</b> <b>ESC-b</b>) (unbound) (unbound)
              Move to the beginning of the previous word.

       <b>emacs-backward-word</b>
              Move to the beginning of the previous word.

       <b>vi-backward-word</b> (unbound) (<b>b</b>) (unbound)
              Move to the beginning of the previous word, vi-style.

       <b>vi-backward-word-end</b> (unbound) (<b>ge</b>) (unbound)
              Move to the end of the previous word, vi-style.

       <b>beginning-of-line</b> (<b>^A</b>) (unbound) (unbound)
              Move to the beginning of the line.  If already at the beginning of the line, move to the beginning
              of the previous line, if any.

       <b>vi-beginning-of-line</b>
              Move to the beginning of the line, without changing lines.

       <b>down-line</b> (unbound) (unbound) (unbound)
              Move down a line in the buffer.

       <b>end-of-line</b> (<b>^E</b>) (unbound) (unbound)
              Move to the end of the line.  If already at the end of the line, move to the end of the next line,
              if any.

       <b>vi-end-of-line</b> (unbound) (<b>$</b>) (unbound)
              Move to the end of the line.  If an argument is given to this command, the cursor will be moved to
              the end of the line (argument - 1) lines down.

       <b>vi-forward-blank-word</b> (unbound) (<b>W</b>) (unbound)
              Move forward one word, where a word is defined as a series of non-blank characters.

       <b>vi-forward-blank-word-end</b> (unbound) (<b>E</b>) (unbound)
              Move to the end of the current word, or, if at the end of the current word, to the end of the next
              word, where a word is defined as a series of non-blank characters.

       <b>forward-char</b> (<b>^F</b> <b>ESC-[C</b>) (unbound) (unbound)
              Move forward one character.

       <b>vi-forward-char</b> (unbound) (<b>space</b> <b>l</b>) (<b>ESC-[C</b>)
              Move forward one character.

       <b>vi-find-next-char</b> (<b>^X^F</b>) (<b>f</b>) (unbound)
              Read a character from the keyboard, and move to the next occurrence of it in the line.

       <b>vi-find-next-char-skip</b> (unbound) (<b>t</b>) (unbound)
              Read a character from the keyboard, and move to the position just before the next occurrence of it
              in the line.

       <b>vi-find-prev-char</b> (unbound) (<b>F</b>) (unbound)
              Read a character from the keyboard, and move to the previous occurrence of it in the line.

       <b>vi-find-prev-char-skip</b> (unbound) (<b>T</b>) (unbound)
              Read a character from the keyboard, and move to the position just after the previous occurrence of
              it in the line.

       <b>vi-first-non-blank</b> (unbound) (<b>^</b>) (unbound)
              Move to the first non-blank character in the line.

       <b>vi-forward-word</b> (unbound) (<b>w</b>) (unbound)
              Move forward one word, vi-style.

       <b>forward-word</b> (<b>ESC-F</b> <b>ESC-f</b>) (unbound) (unbound)
              Move  to  the  beginning  of  the  next  word.   The editor's idea of a word is specified with the
              <b>WORDCHARS</b> parameter.

       <b>emacs-forward-word</b>
              Move to the end of the next word.

       <b>vi-forward-word-end</b> (unbound) (<b>e</b>) (unbound)
              Move to the end of the next word.

       <b>vi-goto-column</b> (<b>ESC-|</b>) (<b>|</b>) (unbound)
              Move to the column specified by the numeric argument.

       <b>vi-goto-mark</b> (unbound) (<b>`</b>) (unbound)
              Move to the specified mark.

       <b>vi-goto-mark-line</b> (unbound) (<b>'</b>) (unbound)
              Move to beginning of the line containing the specified mark.

       <b>vi-repeat-find</b> (unbound) (<b>;</b>) (unbound)
              Repeat the last <b>vi-find</b> command.

       <b>vi-rev-repeat-find</b> (unbound) (<b>,</b>) (unbound)
              Repeat the last <b>vi-find</b> command in the opposite direction.

       <b>up-line</b> (unbound) (unbound) (unbound)
              Move up a line in the buffer.

   <b>History</b> <b>Control</b>
       <b>beginning-of-buffer-or-history</b> (<b>ESC-&lt;</b>) (<b>gg</b>) (unbound)
              Move to the beginning of the buffer, or if already there, move to the first event in  the  history
              list.

       <b>beginning-of-line-hist</b>
              Move  to  the  beginning  of  the  line.   If  already at the beginning of the buffer, move to the
              previous history line.

       <b>beginning-of-history</b>
              Move to the first event in the history list.

       <b>down-line-or-history</b> (<b>^N</b> <b>ESC-[B</b>) (<b>j</b>) (<b>ESC-[B</b>)
              Move down a line in the buffer, or if already at the bottom line, move to the next  event  in  the
              history list.

       <b>vi-down-line-or-history</b> (unbound) (<b>+</b>) (unbound)
              Move  down  a  line in the buffer, or if already at the bottom line, move to the next event in the
              history list.  Then move to the first non-blank character on the line.

       <b>down-line-or-search</b>
              Move down a line in the buffer, or if already at the bottom line, search forward  in  the  history
              for a line beginning with the first word in the buffer.

              If  called  from  a function by the <b>zle</b> command with arguments, the first argument is taken as the
              string for which to search, rather than the first word in the buffer.

       <b>down-history</b> (unbound) (<b>^N</b>) (unbound)
              Move to the next event in the history list.

       <b>history-beginning-search-backward</b>
              Search backward in the history for a line beginning with the current line up to the cursor.   This
              leaves the cursor in its original position.

       <b>end-of-buffer-or-history</b> (<b>ESC-&gt;</b>) (unbound) (unbound)
              Move to the end of the buffer, or if already there, move to the last event in the history list.

       <b>end-of-line-hist</b>
              Move to the end of the line.  If already at the end of the buffer, move to the next history line.

       <b>end-of-history</b>
              Move to the last event in the history list.

       <b>vi-fetch-history</b> (unbound) (<b>G</b>) (unbound)
              Fetch  the  history  line specified by the numeric argument.  This defaults to the current history
              line (i.e. the one that isn't history yet).

       <b>history-incremental-search-backward</b> (<b>^R</b> <b>^Xr</b>) (unbound) (unbound)
              Search backward incrementally for a specified string.   The  search  is  case-insensitive  if  the
              search  string  does not have uppercase letters and no numeric argument was given.  The string may
              begin with `<b>^</b>' to anchor the search to the beginning of the line.  When called from a user-defined
              function returns the following statuses: 0, if the search succeeded; 1, if the search  failed;  2,
              if the search term was a bad pattern; 3, if the search was aborted by the <b>send-break</b> command.

              A  restricted set of editing functions is available in the mini-buffer.  Keys are looked up in the
              special <b>isearch</b> keymap, and if not found there in the  main  keymap  (note  that  by  default  the
              <b>isearch</b>  keymap  is  empty).   An  interrupt signal, as defined by the stty setting, will stop the
              search and go back to the original line.  An undefined key will have the same effect.   Note  that
              the  following  always perform the same task within incremental searches and cannot be replaced by
              user defined widgets, nor can the set of functions be extended.  The supported functions are:

              <b>accept-and-hold</b>
              <b>accept-and-infer-next-history</b>
              <b>accept-line</b>
              <b>accept-line-and-down-history</b>
                     Perform the usual function after exiting incremental search.  The command line displayed is
                     executed.

              <b>backward-delete-char</b>
              <b>vi-backward-delete-char</b>
                     Back up one place in the search history.  If the search has been  repeated  this  does  not
                     immediately erase a character in the minibuffer.

              <b>accept-search</b>
                     Exit incremental search, retaining the command line but performing no further action.  Note
                     that this function is not bound by default and has no effect outside incremental search.

              <b>backward-delete-word</b>
              <b>backward-kill-word</b>
              <b>vi-backward-kill-word</b>
                     Back up one character in the minibuffer; if multiple searches have been performed since the
                     character was inserted the search history is rewound to the point just before the character
                     was entered.  Hence this has the effect of repeating <b>backward-delete-char</b>.

              <b>clear-screen</b>
                     Clear the screen, remaining in incremental search mode.

              <b>history-incremental-search-backward</b>
                     Find  the  next occurrence of the contents of the mini-buffer. If the mini-buffer is empty,
                     the most recent previously used search string is reinstated.

              <b>history-incremental-search-forward</b>
                     Invert the sense of the search.

              <b>magic-space</b>
                     Inserts a non-magical space.

              <b>quoted-insert</b>
              <b>vi-quoted-insert</b>
                     Quote the character to insert into the minibuffer.

              <b>redisplay</b>
                     Redisplay the command line, remaining in incremental search mode.

              <b>vi-cmd-mode</b>
                     Select the `<b>vicmd</b>' keymap; the `<b>main</b>' keymap (insert mode) will be selected initially.

                     In addition, the modifications that were made while in vi insert mode are merged to form  a
                     single undo event.

              <b>vi-repeat-search</b>
              <b>vi-rev-repeat-search</b>
                     Repeat the search.  The direction of the search is indicated in the mini-buffer.

              Any   character   that   is   not  bound  to  one  of  the  above  functions,  or  <b>self-insert</b>  or
              <b>self-insert-unmeta</b>, will cause the mode to be  exited.   The  character  is  then  looked  up  and
              executed in the keymap in effect at that point.

              When  called from a widget function by the <b>zle</b> command, the incremental search commands can take a
              string argument.  This will be treated as a string of  keys,  as  for  arguments  to  the  <b>bindkey</b>
              command, and used as initial input for the command.  Any characters in the string which are unused
              by the incremental search will be silently ignored.  For example,

                     <b>zle</b> <b>history-incremental-search-backward</b> <b>forceps</b>

              will search backwards for <b>forceps</b>, leaving the minibuffer containing the string `<b>forceps</b>'.

       <b>history-incremental-search-forward</b> (<b>^S</b> <b>^Xs</b>) (unbound) (unbound)
              Search forward incrementally for a specified string.  The search is case-insensitive if the search
              string  does  not  have uppercase letters and no numeric argument was given.  The string may begin
              with `<b>^</b>' to anchor the search to the beginning of  the  line.   The  functions  available  in  the
              mini-buffer are the same as for <b>history-incremental-search-backward</b>.

       <b>history-incremental-pattern-search-backward</b>
       <b>history-incremental-pattern-search-forward</b>
              These  widgets  behave  similarly  to  the  corresponding widgets with no <b>-pattern</b>, but the search
              string typed by the user is treated as a pattern, respecting the current settings of  the  various
              options  affecting  pattern  matching.  See FILENAME GENERATION in <u><a href="../man1/zshexpn.1.html">zshexpn</a></u>(1) for a description of
              patterns.  If no numeric argument was given lowercase letters  in  the  search  string  may  match
              uppercase  letters  in  the  history.   The  string may begin with `<b>^</b>' to anchor the search to the
              beginning of the line.

              The prompt changes to indicate an invalid pattern; this may simply indicate the pattern is not yet
              complete.

              Note that only non-overlapping matches are reported, so an expression with  wildcards  may  return
              fewer matches on a line than are visible by inspection.

       <b>history-search-backward</b> (<b>ESC-P</b> <b>ESC-p</b>) (unbound) (unbound)
              Search backward in the history for a line beginning with the first word in the buffer.

              If  called  from  a function by the <b>zle</b> command with arguments, the first argument is taken as the
              string for which to search, rather than the first word in the buffer.

       <b>vi-history-search-backward</b> (unbound) (<b>/</b>) (unbound)
              Search backward in the history for a specified string.  The string may begin with  `<b>^</b>'  to  anchor
              the search to the beginning of the line.

              A  restricted  set  of editing functions is available in the mini-buffer.  An interrupt signal, as
              defined by the stty setting,  will stop the search.  The functions available  in  the  mini-buffer
              are:     <b>accept-line</b>,     <b>backward-delete-char</b>,    <b>vi-backward-delete-char</b>,    <b>backward-kill-word</b>,
              <b>vi-backward-kill-word</b>, <b>clear-screen</b>, <b>redisplay</b>, <b>quoted-insert</b> and <b>vi-quoted-insert</b>.

              <b>vi-cmd-mode</b> is treated the same as accept-line, and <b>magic-space</b> is treated as a space.  Any  other
              character  that is not bound to self-insert or self-insert-unmeta will beep and be ignored. If the
              function is called from vi command mode, the bindings of the current insert mode will be used.

              If called from a function by the <b>zle</b> command with arguments, the first argument is  taken  as  the
              string for which to search, rather than the first word in the buffer.

       <b>history-search-forward</b> (<b>ESC-N</b> <b>ESC-n</b>) (unbound) (unbound)
              Search forward in the history for a line beginning with the first word in the buffer.

              If  called  from  a function by the <b>zle</b> command with arguments, the first argument is taken as the
              string for which to search, rather than the first word in the buffer.

       <b>vi-history-search-forward</b> (unbound) (<b>?</b>) (unbound)
              Search forward in the history for a specified string.  The string may begin with `<b>^</b>' to anchor the
              search to the beginning of the line. The functions available in the mini-buffer are  the  same  as
              for <b>vi-history-search-backward</b>.  Argument handling is also the same as for that command.

       <b>infer-next-history</b> (<b>^X^N</b>) (unbound) (unbound)
              Search in the history list for a line matching the current one and fetch the event following it.

       <b>insert-last-word</b> (<b>ESC-_</b> <b>ESC-.</b>) (unbound) (unbound)
              Insert  the  last  word  from  the  previous  history event at the cursor position.  If a positive
              numeric argument is given, insert that word from the end of the previous history  event.   If  the
              argument  is  zero  or  negative insert that word from the left (zero inserts the previous command
              word).  Repeating this command replaces the word just inserted with the last word from the history
              event prior to the one just used; numeric arguments can be used in the same way  to  pick  a  word
              from that event.

              When  called from a shell function invoked from a user-defined widget, the command can take one to
              three arguments.  The first argument specifies a history offset which applies to successive  calls
              to  this  widget:  if  it is -1, the default behaviour is used, while if it is 1, successive calls
              will move forwards through the history.  The value 0 can be used to indicate that the history line
              examined by the previous execution of the command will be reexamined.  Note that negative  numbers
              should be preceded by a `<b>--</b>' argument to avoid confusing them with options.

              If  two  arguments  are  given,  the second specifies the word on the command line in normal array
              index notation (as a more natural alternative to the numeric argument).   Hence  1  is  the  first
              word, and -1 (the default) is the last word.

              If  a  third  argument  is given, its value is ignored, but it is used to signify that the history
              offset is relative to the current history line, rather than the one remembered after the  previous
              invocations of <b>insert-last-word</b>.

              For example, the default behaviour of the command corresponds to

                     <b>zle</b> <b>insert-last-word</b> <b>--</b> <b>-1</b> <b>-1</b>

              while the command

                     <b>zle</b> <b>insert-last-word</b> <b>--</b> <b>-1</b> <b>1</b> <b>-</b>

              always  copies the first word of the line in the history immediately before the line being edited.
              This has the side effect that later invocations of the widget will be relative to that line.

       <b>vi-repeat-search</b> (unbound) (<b>n</b>) (unbound)
              Repeat the last vi history search.

       <b>vi-rev-repeat-search</b> (unbound) (<b>N</b>) (unbound)
              Repeat the last vi history search, but in reverse.

       <b>up-line-or-history</b> (<b>^P</b> <b>ESC-[A</b>) (<b>k</b>) (<b>ESC-[A</b>)
              Move up a line in the buffer, or if already at the top line, move to the  previous  event  in  the
              history list.

       <b>vi-up-line-or-history</b> (unbound) (<b>-</b>) (unbound)
              Move  up  a  line  in the buffer, or if already at the top line, move to the previous event in the
              history list.  Then move to the first non-blank character on the line.

       <b>up-line-or-search</b>
              Move up a line in the buffer, or if already at the top line, search backward in the history for  a
              line beginning with the first word in the buffer.

              If  called  from  a function by the <b>zle</b> command with arguments, the first argument is taken as the
              string for which to search, rather than the first word in the buffer.

       <b>up-history</b> (unbound) (<b>^P</b>) (unbound)
              Move to the previous event in the history list.

       <b>history-beginning-search-forward</b>
              Search forward in the history for a line beginning with the current line up to the  cursor.   This
              leaves the cursor in its original position.

       <b>set-local-history</b>
              By  default,  history  movement commands visit the imported lines as well as the local lines. This
              widget lets you toggle this on and off, or set it with the numeric argument. Zero for  both  local
              and imported lines and nonzero for only local lines.

   <b>Modifying</b> <b>Text</b>
       <b>vi-add-eol</b> (unbound) (<b>A</b>) (unbound)
              Move to the end of the line and enter insert mode.

       <b>vi-add-next</b> (unbound) (<b>a</b>) (unbound)
              Enter insert mode after the current cursor position, without changing lines.

       <b>backward-delete-char</b> (<b>^H</b> <b>^?</b>) (unbound) (unbound)
              Delete the character behind the cursor.

       <b>vi-backward-delete-char</b> (unbound) (<b>X</b>) (<b>^H</b>)
              Delete  the  character  behind  the cursor, without changing lines.  If in insert mode, this won't
              delete past the point where insert mode was last entered.

       <b>backward-delete-word</b>
              Delete the word behind the cursor.

       <b>backward-kill-line</b>
              Kill from the beginning of the line to the cursor position.

       <b>backward-kill-word</b> (<b>^W</b> <b>ESC-^H</b> <b>ESC-^?</b>) (unbound) (unbound)
              Kill the word behind the cursor.

       <b>vi-backward-kill-word</b> (unbound) (unbound) (<b>^W</b>)
              Kill the word behind the cursor, without going past the point where insert mode was last entered.

       <b>capitalize-word</b> (<b>ESC-C</b> <b>ESC-c</b>) (unbound) (unbound)
              Capitalize the current word and move past it.

       <b>vi-change</b> (unbound) (<b>c</b>) (unbound)
              Read a movement command from the keyboard, and kill from the cursor position to  the  endpoint  of
              the movement.  Then enter insert mode.  If the command is <b>vi-change</b>, change the current line.

              For  compatibility  with  vi,  if  the  command  is  <b>vi-forward-word</b> or <b>vi-forward-blank-word</b>, the
              whitespace after the word is not included. If you prefer the more consistent  behaviour  with  the
              whitespace included use the following key binding:

                     <b>bindkey</b> <b>-a</b> <b>-s</b> <b>cw</b> <b>dwi</b>

       <b>vi-change-eol</b> (unbound) (<b>C</b>) (unbound)
              Kill to the end of the line and enter insert mode.

       <b>vi-change-whole-line</b> (unbound) (<b>S</b>) (unbound)
              Kill the current line and enter insert mode.

       <b>copy-region-as-kill</b> (<b>ESC-W</b> <b>ESC-w</b>) (unbound) (unbound)
              Copy the area from the cursor to the mark to the kill buffer.

              If called from a ZLE widget function in the form `<b>zle</b> <b>copy-region-as-kill</b> <u>string</u>' then <u>string</u> will
              be taken as the text to copy to the kill buffer.  The cursor, the mark and the text on the command
              line are not used in this case.

       <b>copy-prev-word</b> (<b>ESC-^_</b>) (unbound) (unbound)
              Duplicate the word to the left of the cursor.

       <b>copy-prev-shell-word</b>
              Like  <b>copy-prev-word</b>,  but  the word is found by using shell parsing, whereas <b>copy-prev-word</b> looks
              for blanks. This makes a difference when the word is quoted and contains spaces.

       <b>vi-delete</b> (unbound) (<b>d</b>) (unbound)
              Read a movement command from the keyboard, and kill from the cursor position to  the  endpoint  of
              the movement.  If the command is <b>vi-delete</b>, kill the current line.

       <b>delete-char</b>
              Delete the character under the cursor.

       <b>vi-delete-char</b> (unbound) (<b>x</b>) (unbound)
              Delete the character under the cursor, without going past the end of the line.

       <b>delete-word</b>
              Delete the current word.

       <b>down-case-word</b> (<b>ESC-L</b> <b>ESC-l</b>) (unbound) (unbound)
              Convert the current word to all lowercase and move past it.

       <b>vi-down-case</b> (unbound) (<b>gu</b>) (unbound)
              Read  a movement command from the keyboard, and convert all characters from the cursor position to
              the endpoint of the movement to lowercase.  If the movement command is <b>vi-down-case</b>, swap the case
              of all characters on the current line.

       <b>kill-word</b> (<b>ESC-D</b> <b>ESC-d</b>) (unbound) (unbound)
              Kill the current word.

       <b>gosmacs-transpose-chars</b>
              Exchange the two characters behind the cursor.

       <b>vi-indent</b> (unbound) (<b>&gt;</b>) (unbound)
              Indent a number of lines.

       <b>vi-insert</b> (unbound) (<b>i</b>) (unbound)
              Enter insert mode.

       <b>vi-insert-bol</b> (unbound) (<b>I</b>) (unbound)
              Move to the first non-blank character on the line and enter insert mode.

       <b>vi-join</b> (<b>^X^J</b>) (<b>J</b>) (unbound)
              Join the current line with the next one.

       <b>kill-line</b> (<b>^K</b>) (unbound) (unbound)
              Kill from the cursor to the end of the line.  If already on the end of the line, kill the  newline
              character.

       <b>vi-kill-line</b> (unbound) (unbound) (<b>^U</b>)
              Kill from the cursor back to wherever insert mode was last entered.

       <b>vi-kill-eol</b> (unbound) (<b>D</b>) (unbound)
              Kill from the cursor to the end of the line.

       <b>kill-region</b>
              Kill from the cursor to the mark.

       <b>kill-buffer</b> (<b>^X^K</b>) (unbound) (unbound)
              Kill the entire buffer.

       <b>kill-whole-line</b> (<b>^U</b>) (unbound) (unbound)
              Kill the current line.

       <b>vi-match-bracket</b> (<b>^X^B</b>) (<b>%</b>) (unbound)
              Move to the bracket character (one of <b>{}</b>, <b>()</b> or <b>[]</b>) that matches the one under the cursor.  If the
              cursor  is not on a bracket character, move forward without going past the end of the line to find
              one, and then go to the matching bracket.

       <b>vi-open-line-above</b> (unbound) (<b>O</b>) (unbound)
              Open a line above the cursor and enter insert mode.

       <b>vi-open-line-below</b> (unbound) (<b>o</b>) (unbound)
              Open a line below the cursor and enter insert mode.

       <b>vi-oper-swap-case</b> (unbound) (<b>g~</b>) (unbound)
              Read a movement command from the keyboard, and swap the case of all  characters  from  the  cursor
              position  to the endpoint of the movement.  If the movement command is <b>vi-oper-swap-case</b>, swap the
              case of all characters on the current line.

       <b>overwrite-mode</b> (<b>^X^O</b>) (unbound) (unbound)
              Toggle between overwrite mode and insert mode.

       <b>vi-put-before</b> (unbound) (<b>P</b>) (unbound)
              Insert the contents of the kill buffer before the cursor.  If the kill buffer contains a  sequence
              of lines (as opposed to characters), paste it above the current line.

       <b>vi-put-after</b> (unbound) (<b>p</b>) (unbound)
              Insert  the  contents of the kill buffer after the cursor.  If the kill buffer contains a sequence
              of lines (as opposed to characters), paste it below the current line.

       <b>put-replace-selection</b> (unbound) (unbound) (unbound)
              Replace the contents of the current region or selection with the contents of the kill  buffer.  If
              the  kill buffer contains a sequence of lines (as opposed to characters), the current line will be
              split by the pasted lines.

       <b>quoted-insert</b> (<b>^V</b>) (unbound) (unbound)
              Insert the next character typed into the buffer literally.  An interrupt  character  will  not  be
              inserted.

       <b>vi-quoted-insert</b> (unbound) (unbound) (<b>^Q</b> <b>^V</b>)
              Display  a  `<b>^</b>'  at  the  cursor  position,  and  insert  the next character typed into the buffer
              literally.  An interrupt character will not be inserted.

       <b>quote-line</b> (<b>ESC-'</b>) (unbound) (unbound)
              Quote the current line; that is, put a `<b>'</b>' character at the beginning and the end, and convert all
              `<b>'</b>' characters to `<b>'\''</b>'.

       <b>quote-region</b> (<b>ESC-"</b>) (unbound) (unbound)
              Quote the region from the cursor to the mark.

       <b>vi-replace</b> (unbound) (<b>R</b>) (unbound)
              Enter overwrite mode.

       <b>vi-repeat-change</b> (unbound) (<b>.</b>) (unbound)
              Repeat the last vi mode text modification.  If a count was  used  with  the  modification,  it  is
              remembered.   If  a  count  is  given  to  this command, it overrides the remembered count, and is
              remembered for future uses of this command.  The cut buffer specification is similarly remembered.

       <b>vi-replace-chars</b> (unbound) (<b>r</b>) (unbound)
              Replace the character under the cursor with a character read from the keyboard.

       <b>self-insert</b> (printable characters) (unbound) (printable characters and some control characters)
              Insert a character into the buffer at the cursor position.

       <b>self-insert-unmeta</b> (<b>ESC-^I</b> <b>ESC-^J</b> <b>ESC-^M</b>) (unbound) (unbound)
              Insert a character into the buffer after stripping the meta bit and converting ^M to ^J.

       <b>vi-substitute</b> (unbound) (<b>s</b>) (unbound)
              Substitute the next character(s).

       <b>vi-swap-case</b> (unbound) (<b>~</b>) (unbound)
              Swap the case of the character under the cursor and move past it.

       <b>transpose-chars</b> (<b>^T</b>) (unbound) (unbound)
              Exchange the two characters to the left of the cursor  if  at  end  of  line,  else  exchange  the
              character under the cursor with the character to the left.

       <b>transpose-words</b> (<b>ESC-T</b> <b>ESC-t</b>) (unbound) (unbound)
              Exchange the current word with the one before it.

              With  a  positive numeric argument <u>N</u>, the word around the cursor, or following it if the cursor is
              between words, is transposed with the preceding <u>N</u> words.  The cursor is put  at  the  end  of  the
              resulting group of words.

              With  a negative numeric argument <u>-N</u>, the effect is the same as using a positive argument <u>N</u> except
              that the original cursor position is retained, regardless of how the words are rearranged.

       <b>vi-unindent</b> (unbound) (<b>&lt;</b>) (unbound)
              Unindent a number of lines.

       <b>vi-up-case</b> (unbound) (<b>gU</b>) (unbound)
              Read a movement command from the keyboard, and convert all characters from the cursor position  to
              the  endpoint  of the movement to lowercase.  If the movement command is <b>vi-up-case</b>, swap the case
              of all characters on the current line.

       <b>up-case-word</b> (<b>ESC-U</b> <b>ESC-u</b>) (unbound) (unbound)
              Convert the current word to all caps and move past it.

       <b>yank</b> (<b>^Y</b>) (unbound) (unbound)
              Insert the contents of the kill buffer at the cursor position.

       <b>yank-pop</b> (<b>ESC-y</b>) (unbound) (unbound)
              Remove the text just yanked, rotate the kill-ring (the history of previously killed text) and yank
              the new top.  Only works following <b>yank</b>, <b>vi-put-before</b>, <b>vi-put-after</b> or <b>yank-pop</b>.

       <b>vi-yank</b> (unbound) (<b>y</b>) (unbound)
              Read a movement command from the keyboard, and copy the region from the  cursor  position  to  the
              endpoint of the movement into the kill buffer.  If the command is <b>vi-yank</b>, copy the current line.

       <b>vi-yank-whole-line</b> (unbound) (<b>Y</b>) (unbound)
              Copy the current line into the kill buffer.

       <b>vi-yank-eol</b>
              Copy  the  region from the cursor position to the end of the line into the kill buffer.  Arguably,
              this is what Y should do in vi, but it isn't what it actually does.

   <b>Arguments</b>
       <b>digit-argument</b> (<b>ESC-0</b>..<b>ESC-9</b>) (<b>1</b>-<b>9</b>) (unbound)
              Start a new numeric argument, or add to the current one.  See also  <b>vi-digit-or-beginning-of-line</b>.
              This only works if bound to a key sequence ending in a decimal digit.

              Inside  a  widget  function, a call to this function treats the last key of the key sequence which
              called the widget as the digit.

       <b>neg-argument</b> (<b>ESC--</b>) (unbound) (unbound)
              Changes the sign of the following argument.

       <b>universal-argument</b>
              Multiply the argument of the next command by 4.  Alternatively, if this command is followed by  an
              integer (positive or negative), use that as the argument for the next command.  Thus digits cannot
              be  repeated  using this command.  For example, if this command occurs twice, followed immediately
              by <b>forward-char</b>, move forward sixteen spaces; if instead it is followed by <b>-2</b>, then  <b>forward-char</b>,
              move backward two spaces.

              Inside  a  widget  function, if passed an argument, i.e. `<b>zle</b> <b>universal-argument</b> <u>num</u>', the numeric
              argument will be set to <u>num</u>; this is equivalent to `<b>NUMERIC=</b><u>num</u>'.

       <b>argument-base</b>
              Use the existing numeric argument as a numeric base, which must be in the range 2 to 36 inclusive.
              Subsequent use of <b>digit-argument</b> and <b>universal-argument</b> will input a new numeric argument  in  the
              given base.  The usual hexadecimal convention is used: the letter <b>a</b> or <b>A</b> corresponds to 10, and so
              on.   Arguments  in  bases  requiring  digits  from  10  upwards  are more conveniently input with
              <b>universal-argument</b>, since <b>ESC-a</b> etc. are not usually bound to <b>digit-argument</b>.

              The function can be used with a command argument inside a user-defined widget.  The following code
              sets the base to 16 and lets the user input a hexadecimal argument until a key out  of  the  digit
              range is typed:

                     <b>zle</b> <b>argument-base</b> <b>16</b>
                     <b>zle</b> <b>universal-argument</b>

   <b>Completion</b>
       <b>accept-and-menu-complete</b>
              In  a  menu  completion,  insert  the  current completion into the buffer, and advance to the next
              possible completion.

       <b>complete-word</b>
              Attempt completion on the current word.

       <b>delete-char-or-list</b> (<b>^D</b>) (unbound) (unbound)
              Delete the character under the cursor.  If the cursor is at the end of  the  line,  list  possible
              completions for the current word.

       <b>expand-cmd-path</b>
              Expand the current command to its full pathname.

       <b>expand-or-complete</b> (<b>TAB</b>) (unbound) (<b>TAB</b>)
              Attempt shell expansion on the current word.  If that fails, attempt completion.

       <b>expand-or-complete-prefix</b>
              Attempt shell expansion on the current word up to cursor.

       <b>expand-history</b> (<b>ESC-space</b> <b>ESC-!</b>) (unbound) (unbound)
              Perform history expansion on the edit buffer.

       <b>expand-word</b> (<b>^X*</b>) (unbound) (unbound)
              Attempt shell expansion on the current word.

       <b>list-choices</b> (<b>ESC-^D</b>) (<b>^D</b> <b>=</b>) (<b>^D</b>)
              List possible completions for the current word.

       <b>list-expand</b> (<b>^Xg</b> <b>^XG</b>) (<b>^G</b>) (<b>^G</b>)
              List the expansion of the current word.

       <b>magic-space</b>
              Perform  history  expansion  and  insert a space into the buffer.  This is intended to be bound to
              space.

       <b>menu-complete</b>
              Like <b>complete-word</b>, except that menu completion is used.  See the <b>MENU_COMPLETE</b> option.

       <b>menu-expand-or-complete</b>
              Like <b>expand-or-complete</b>, except that menu completion is used.

       <b>reverse-menu-complete</b>
              Perform menu completion, like <b>menu-complete</b>, except that  if  a  menu  completion  is  already  in
              progress, move to the <u>previous</u> completion rather than the next.

       <b>end-of-list</b>
              When  a previous completion displayed a list below the prompt, this widget can be used to move the
              prompt below the list.

   <b>Miscellaneous</b>
       <b>accept-and-hold</b> (<b>ESC-A</b> <b>ESC-a</b>) (unbound) (unbound)
              Push the contents of the buffer on the buffer stack and execute it.

       <b>accept-and-infer-next-history</b>
              Execute the contents of the buffer.  Then search the history list for a line matching the  current
              one and push the event following onto the buffer stack.

       <b>accept-line</b> (<b>^J</b> <b>^M</b>) (<b>^J</b> <b>^M</b>) (<b>^J</b> <b>^M</b>)
              Finish editing the buffer.  Normally this causes the buffer to be executed as a shell command.

       <b>accept-line-and-down-history</b> (<b>^O</b>) (unbound) (unbound)
              Execute the current line, and push the next history event on the buffer stack.

       <b>auto-suffix-remove</b>
              If the previous action added a suffix (space, slash, etc.) to the word on the command line, remove
              it.  Otherwise do nothing.  Removing the suffix ends any active menu completion or menu selection.

              This widget is intended to be called from user-defined widgets to enforce a desired suffix-removal
              behavior.

       <b>auto-suffix-retain</b>
              If  the previous action added a suffix (space, slash, etc.) to the word on the command line, force
              it to be preserved.  Otherwise do nothing.  Retaining the suffix ends any active  menu  completion
              or menu selection.

              This   widget   is  intended  to  be  called  from  user-defined  widgets  to  enforce  a  desired
              suffix-preservation behavior.

       <b>beep</b>   Beep, unless the <b>BEEP</b> option is unset.

       <b>bracketed-paste</b> (<b>^[[200~</b>) (<b>^[[200~</b>) (<b>^[[200~</b>)
              This widget is invoked when text is pasted to the terminal emulator. It  is  not  intended  to  be
              bound  to  actual keys but instead to the special sequence generated by the terminal emulator when
              text is pasted.

              When invoked interactively, the pasted text is inserted to the buffer and placed in the cutbuffer.
              If a numeric argument is given, shell quoting will be applied to the  pasted  text  before  it  is
              inserted.

              When  a named buffer is specified with <b>vi-set-buffer</b> (<b>"x</b>), the pasted text is stored in that named
              buffer but not inserted.

              When called from a widget function as `<b>bracketed-paste</b> <u>name</u>`, the pasted text is assigned  to  the
              variable <u>name</u> and no other processing is done.

              See also the <b>zle_bracketed_paste</b> parameter.

       <b>vi-cmd-mode</b> (<b>^X^V</b>) (unbound) (<b>^[</b>)
              Enter  command  mode;  that is, select the `<b>vicmd</b>' keymap.  Yes, this is bound by default in emacs
              mode.

       <b>vi-caps-lock-panic</b>
              Hang until any lowercase key is pressed.  This is for vi users without the mental capacity to keep
              track of their caps lock key (like the author).

       <b>clear-screen</b> (<b>^L</b> <b>ESC-^L</b>) (<b>^L</b>) (<b>^L</b>)
              Clear the screen and redraw the prompt.

       <b>deactivate-region</b>
              Make the current region inactive. This disables vim-style visual selection mode if it is active.

       <b>describe-key-briefly</b>
              Reads a key sequence, then prints the function bound to that sequence.

       <b>exchange-point-and-mark</b> (<b>^X^X</b>) (unbound) (unbound)
              Exchange the cursor position (point) with the position of the mark.   Unless  a  negative  numeric
              argument  is  given, the region between point and mark is activated so that it can be highlighted.
              If a zero numeric argument is given, the region is activated but point and mark are not swapped.

       <b>execute-named-cmd</b> (<b>ESC-x</b>) (<b>:</b>) (unbound)
              Read the name of an editor command and  execute  it.   Aliasing  this  widget  with  `<b>zle</b>  <b>-A</b>'  or
              replacing   it   with   `<b>zle</b>   <b>-N</b>'  has  no  effect  when  interpreting  key  bindings,  but  `<b>zle</b>
              <b>execute-named-cmd</b>' will invoke such an alias or replacement.

              A restricted set of editing functions is available in the mini-buffer.  Keys are looked up in  the
              special  <b>command</b>  keymap,  and  if  not  found  there in the main keymap.  An interrupt signal, as
              defined by the stty setting, will abort the function.  Note that the following always perform  the
              same  task  within  the  <b>executed-named-cmd</b>  environment  and  cannot  be replaced by user defined
              widgets,  nor  can  the  set   of   functions   be   extended.    The   allowed   functions   are:
              <b>backward-delete-char</b>,    <b>vi-backward-delete-char</b>,    <b>clear-screen</b>,    <b>redisplay</b>,    <b>quoted-insert</b>,
              <b>vi-quoted-insert</b>,  <b>backward-kill-word</b>,   <b>vi-backward-kill-word</b>,   <b>kill-whole-line</b>,   <b>vi-kill-line</b>,
              <b>backward-kill-line</b>,     <b>list-choices</b>,     <b>delete-char-or-list</b>,     <b>complete-word</b>,     <b>accept-line</b>,
              <b>expand-or-complete</b> and <b>expand-or-complete-prefix</b>.

              <b>kill-region</b> kills the last word, and vi-cmd-mode is treated the same as  accept-line.   The  space
              and  tab  characters, if not bound to one of these functions, will complete the name and then list
              the possibilities if the <b>AUTO_LIST</b> option is set.  Any  other  character  that  is  not  bound  to
              <b>self-insert</b>  or  <b>self-insert-unmeta</b>  will beep and be ignored.  The bindings of the current insert
              mode will be used.

              Currently this command may not be redefined or called by name.

       <b>execute-last-named-cmd</b> (<b>ESC-z</b>) (unbound) (unbound)
              Redo the last function executed with <b>execute-named-cmd</b>.

              Like <b>execute-named-cmd</b>, this command may not be redefined, but it may be called by name.

       <b>get-line</b> (<b>ESC-G</b> <b>ESC-g</b>) (unbound) (unbound)
              Pop the top line off the buffer stack and insert it at the cursor position.

       <b>pound-insert</b> (unbound) (<b>#</b>) (unbound)
              If there is no # character at the beginning of the buffer, add one to the beginning of each  line.
              If there is one, remove a # from each line that has one.  In either case, accept the current line.
              The <b>INTERACTIVE_COMMENTS</b> option must be set for this to have any usefulness.

       <b>vi-pound-insert</b>
              If there is no # character at the beginning of the current line, add one.  If there is one, remove
              it.  The <b>INTERACTIVE_COMMENTS</b> option must be set for this to have any usefulness.

       <b>push-input</b>
              Push  the  entire  current  multiline  construct onto the buffer stack and return to the top-level
              (<b>PS1</b>) prompt.  If the current parser construct is  only  a  single  line,  this  is  exactly  like
              <b>push-line</b>.   Next  time  the  editor  starts  up or is popped with <b>get-line</b>, the construct will be
              popped off the top of the buffer stack and loaded into the editing buffer.

       <b>push-line</b> (<b>^Q</b> <b>ESC-Q</b> <b>ESC-q</b>) (unbound) (unbound)
              Push the current buffer onto the buffer stack and clear the buffer.  Next time the  editor  starts
              up, the buffer will be popped off the top of the buffer stack and loaded into the editing buffer.

       <b>push-line-or-edit</b>
              At  the  top-level  (<b>PS1</b>)  prompt, equivalent to <b>push-line</b>.  At a secondary (<b>PS2</b>) prompt, move the
              entire current multiline construct into the editor buffer.  The latter is equivalent to <b>push-input</b>
              followed by <b>get-line</b>.

       <b>read-command</b>
              Only useful from a user-defined widget.  A keystroke is read just  as  in  normal  operation,  but
              instead  of the command being executed the name of the command that would be executed is stored in
              the shell parameter <b>REPLY</b>.  This can be used as the argument of a future <b>zle</b> command.  If the  key
              sequence  is not bound, status 1 is returned; typically, however, <b>REPLY</b> is set to <b>undefined-key</b> to
              indicate a useless key sequence.

       <b>recursive-edit</b>
              Only useful from a user-defined widget.  At this point in the function, the editor regains control
              until one of the standard widgets which would normally cause zle to exit (typically an <b>accept-line</b>
              caused by hitting the return key) is executed.   Instead,  control  returns  to  the  user-defined
              widget.   The  status  returned is non-zero if the return was caused by an error, but the function
              still continues executing and hence may tidy up.  This makes it safe for the  user-defined  widget
              to alter the command line or key bindings temporarily.

              The following widget, <b>caps-lock</b>, serves as an example.

                     <b>self-insert-ucase()</b> <b>{</b>
                       <b>LBUFFER+=${(U)KEYS[-1]}</b>
                     <b>}</b>

                     <b>integer</b> <b>stat</b>

                     <b>zle</b> <b>-N</b> <b>self-insert</b> <b>self-insert-ucase</b>
                     <b>zle</b> <b>-A</b> <b>caps-lock</b> <b>save-caps-lock</b>
                     <b>zle</b> <b>-A</b> <b>accept-line</b> <b>caps-lock</b>

                     <b>zle</b> <b>recursive-edit</b>
                     <b>stat=$?</b>

                     <b>zle</b> <b>-A</b> <b>.self-insert</b> <b>self-insert</b>
                     <b>zle</b> <b>-A</b> <b>save-caps-lock</b> <b>caps-lock</b>
                     <b>zle</b> <b>-D</b> <b>save-caps-lock</b>

                     <b>((</b> <b>stat</b> <b>))</b> <b>&amp;&amp;</b> <b>zle</b> <b>send-break</b>

                     <b>return</b> <b>$stat</b>

              This  causes typed letters to be inserted capitalised until either <b>accept-line</b> (i.e. typically the
              return key) is typed or the <b>caps-lock</b> widget is invoked again; the later is handled by saving  the
              old  definition  of <b>caps-lock</b> as <b>save-caps-lock</b> and then rebinding it to invoke <b>accept-line</b>.  Note
              that an error from the recursive edit is detected as a non-zero return status  and  propagated  by
              using the <b>send-break</b> widget.

       <b>redisplay</b> (unbound) (<b>^R</b>) (<b>^R</b>)
              Redisplays the edit buffer.

       <b>reset-prompt</b> (unbound) (unbound) (unbound)
              Force  the  prompts on both the left and right of the screen to be re-expanded, then redisplay the
              edit buffer.  This reflects changes both to the prompt variables themselves  and  changes  in  the
              expansion  of  the  values  (for example, changes in time or directory, or changes to the value of
              variables referred to by the prompt).

              Otherwise, the prompt is only expanded each time  zle  starts,  and  when  the  display  has  been
              interrupted by output from another part of the shell (such as a job notification) which causes the
              command line to be reprinted.

              <b>reset-prompt</b> doesn't alter the special parameter <b>LASTWIDGET</b>.

       <b>send-break</b> (<b>^G</b> <b>ESC-^G</b>) (unbound) (unbound)
              Abort  the  current editor function, e.g. <b>execute-named-command</b>, or the editor itself, e.g. if you
              are in <b>vared</b>. Otherwise abort the parsing of the current line; in this case the  aborted  line  is
              available in the shell variable <b>ZLE_LINE_ABORTED</b>.  If the editor is aborted from within <b>vared</b>, the
              variable <b>ZLE_VARED_ABORTED</b> is set.

       <b>run-help</b> (<b>ESC-H</b> <b>ESC-h</b>) (unbound) (unbound)
              Push  the  buffer  onto the buffer stack, and execute the command `<b>run-help</b> <u>cmd</u>', where <u>cmd</u> is the
              current command.  <b>run-help</b> is normally aliased to <b>man</b>.

       <b>vi-set-buffer</b> (unbound) (<b>"</b>) (unbound)
              Specify a buffer to be used in the following command.  There are 37 buffers that can be specified:
              the 26 `named' buffers <b>"a</b> to <b>"z</b>, the `yank' buffer <b>"0</b>, the nine `queued' buffers <b>"1</b> to <b>"9</b> and  the
              `black hole' buffer <b>"_</b>.  The named buffers can also be specified as <b>"A</b> to <b>"Z</b>.

              When  a  buffer  is  specified  for a cut, change or yank command, the text concerned replaces the
              previous contents of the specified buffer. If a named buffer is specified  using  a  capital,  the
              newly  cut  text  is  appended  to the buffer instead of overwriting it. When using the <b>"_</b> buffer,
              nothing happens. This can be useful for deleting text without affecting any buffers.

              If no buffer is specified for a cut or change command, <b>"1</b> is used, and the contents of  <b>"1</b>  to  <b>"8</b>
              are  each  shifted  along  one buffer; the contents of <b>"9</b> is lost. If no buffer is specified for a
              yank command, <b>"0</b> is used. Finally, a paste command without a specified buffer will paste the  text
              from the most recent command regardless of any buffer that might have been used with that command.

              When called from a widget function by the <b>zle</b> command, the buffer can optionally be specified with
              an argument. For example,

                     <b>zle</b> <b>vi-set-buffer</b> <b>A</b>

       <b>vi-set-mark</b> (unbound) (<b>m</b>) (unbound)
              Set the specified mark at the cursor position.

       <b>set-mark-command</b> (<b>^@</b>) (unbound) (unbound)
              Set  the  mark at the cursor position.  If called with a negative numeric argument, do not set the
              mark but deactivate the region so that it is no longer highlighted (it is still usable  for  other
              purposes).  Otherwise the region is marked as active.

       <b>spell-word</b> (<b>ESC-$</b> <b>ESC-S</b> <b>ESC-s</b>) (unbound) (unbound)
              Attempt spelling correction on the current word.

       <b>split-undo</b>
              Breaks  the  undo  sequence  at  the current change.  This is useful in vi mode as changes made in
              insert mode are coalesced on entering command mode.  Similarly, <b>undo</b> will normally revert  as  one
              all the changes made by a user-defined widget.

       <b>undefined-key</b>
              This  command  is  executed  when  a  key  sequence that is not bound to any command is typed.  By
              default it beeps.

       <b>undo</b> (<b>^_</b> <b>^Xu</b> <b>^X^U</b>) (<b>u</b>) (unbound)
              Incrementally undo the last text modification.  When called from a user-defined widget,  takes  an
              optional   argument  indicating  a  previous  state  of  the  undo  history  as  returned  by  the
              <b>UNDO_CHANGE_NO</b> variable; modifications are undone until that state  is  reached,  subject  to  any
              limit imposed by the <b>UNDO_LIMIT_NO</b> variable.

              Note  that  when  invoked  from  vi  command  mode,  the  full prior change made in insert mode is
              reverted, the changes having been merged when command mode was selected.

       <b>redo</b> (unbound) (<b>^R</b>) (unbound)
              Incrementally redo undone text modifications.

       <b>vi-undo-change</b> (unbound) (unbound) (unbound)
              Undo the last text modification.  If repeated, redo the modification.

       <b>visual-mode</b> (unbound) (<b>v</b>) (unbound)
              Toggle vim-style visual selection mode. If line-wise visual mode is currently enabled then  it  is
              changed  to being character-wise. If used following an operator, it forces the subsequent movement
              command to be treated as a character-wise movement.

       <b>visual-line-mode</b> (unbound) (<b>V</b>) (unbound)
              Toggle vim-style line-wise visual selection mode.  If  character-wise  visual  mode  is  currently
              enabled  then  it  is  changed  to  being  line-wise. If used following an operator, it forces the
              subsequent movement command to be treated as a line-wise movement.

       <b>what-cursor-position</b> (<b>^X=</b>) (<b>ga</b>) (unbound)
              Print the character under the cursor, its code as an octal, decimal and  hexadecimal  number,  the
              current cursor position within the buffer and the column of the cursor in the current line.

       <b>where-is</b>
              Read  the  name  of  an  editor  command  and  print  the listing of key sequences that invoke the
              specified command.  A restricted set of editing functions is available in the  mini-buffer.   Keys
              are looked up in the special <b>command</b> keymap, and if not found there in the main keymap.

       <b>which-command</b> (<b>ESC-?</b>) (unbound) (unbound)
              Push  the  buffer onto the buffer stack, and execute the command `<b>which-command</b> <u>cmd</u>'. where <u>cmd</u> is
              the current command.  <b>which-command</b> is normally aliased to <b>whence</b>.

       <b>vi-digit-or-beginning-of-line</b> (unbound) (<b>0</b>) (unbound)
              If the last command executed  was  a  digit  as  part  of  an  argument,  continue  the  argument.
              Otherwise, execute vi-beginning-of-line.

   <b>Text</b> <b>Objects</b>
       Text objects are commands that can be used to select a block of text according to some criteria. They are
       a  feature  of the vim text editor and so are primarily intended for use with vi operators or from visual
       selection mode. However, they can also be used from vi-insert or emacs mode. Key  bindings  listed  below
       apply to the <b>viopp</b> and <b>visual</b> keymaps.

       <b>select-a-blank-word</b> (<b>aW</b>)
              Select  a  word  including  adjacent  blanks,  where  a  word  is defined as a series of non-blank
              characters. With a numeric argument, multiple words will be selected.

       <b>select-a-shell-word</b> (<b>aa</b>)
              Select the current command argument applying the normal rules for quoting.

       <b>select-a-word</b> (<b>aw</b>)
              Select a word including adjacent blanks, using the normal vi-style word definition. With a numeric
              argument, multiple words will be selected.

       <b>select-in-blank-word</b> (<b>iW</b>)
              Select a word, where a word is defined as  a  series  of  non-blank  characters.  With  a  numeric
              argument, multiple words will be selected.

       <b>select-in-shell-word</b> (<b>ia</b>)
              Select  the current command argument applying the normal rules for quoting. If the argument begins
              and ends with matching quote characters, these are not included in the selection.

       <b>select-in-word</b> (<b>iw</b>)
              Select a word, using the normal vi-style word definition. With a numeric argument, multiple  words
              will be selected.

</pre><h4><b>CHARACTER</b> <b>HIGHLIGHTING</b></h4><pre>
       The  line  editor  has  the ability to highlight characters or regions of the line that have a particular
       significance.  This is controlled by the array parameter <b>zle_highlight</b>, if it has been set by the user.

       If the parameter contains the single entry <b>none</b> all highlighting is turned off.  Note  the  parameter  is
       still expected to be an array.

       Otherwise  each entry of the array should consist of a word indicating a context for highlighting, then a
       colon, then a comma-separated list of the types of highlighting to apply in that context.

       The contexts available for highlighting are the following:

       <b>default</b>
              Any text within the command line not  affected  by  any  other  highlighting.   Text  outside  the
              editable area of the command line is not affected.

       <b>isearch</b>
              When one of the incremental history search widgets is active, the area of the command line matched
              by the search string or pattern.

       <b>region</b> The  currently  selected  text.  In  emacs  terminology,  this is referred to as the region and is
              bounded by the cursor (point) and the mark. The region is only highlighted if it is active,  which
              is  the  case  after  the mark is modified with <b>set-mark-command</b> or <b>exchange-point-and-mark</b>.  Note
              that whether or not the region is active has no effect on its use within emacs style  widgets,  it
              simply  determines  whether it is highlighted. In vi mode, the region corresponds to selected text
              in visual mode.

       <b>special</b>
              Individual characters that have no direct printable representation but  are  shown  in  a  special
              manner by the line editor.  These characters are described below.

       <b>suffix</b> This context is used in completion for characters that are marked as suffixes that will be removed
              if the completion ends at that point, the most obvious example being a slash (<b>/</b>) after a directory
              name.   Note that suffix removal is configurable; the circumstances under which the suffix will be
              removed may differ for different completions.

       <b>paste</b>  Following a command to paste text, the characters that were inserted.

       When <b>region_highlight</b> is set, the contexts that describe a region -- <b>isearch</b>, <b>region</b>, <b>suffix</b>,  and  <b>paste</b>
       --  are  applied  first,  then <b>region_highlight</b> is applied, then the remaining <b>zle_highlight</b> contexts are
       applied.  If a particular character is affected by multiple specifications, the last specification wins.

       <b>zle_highlight</b> may contain additional fields for controlling how terminal sequences to change colours  are
       output.   Each of the following is followed by a colon and a string in the same form as for key bindings.
       This will not be necessary for the vast majority of terminals as the defaults shown  in  parentheses  are
       widely used.

       <b>fg_start_code</b> (<b>\e[3</b>)
              The  start  of  the  escape  sequence for the foreground colour.  This is followed by one to three
              ASCII digits representing the colour.  Only used  for  palette  colors,  i.e.  not  24-bit  colors
              specified via a color triplet.

       <b>fg_default_code</b> (<b>9</b>)
              The number to use instead of the colour to reset the default foreground colour.

       <b>fg_end_code</b> (<b>m</b>)
              The end of the escape sequence for the foreground colour.

       <b>bg_start_code</b> (<b>\e[4</b>)
              The start of the escape sequence for the background colour.  See <b>fg_start_code</b> above.

       <b>bg_default_code</b> (<b>9</b>)
              The number to use instead of the colour to reset the default background colour.

       <b>bg_end_code</b> (<b>m</b>)
              The end of the escape sequence for the background colour.

       The  available  types  of  highlighting  are  the following.  Note that not all types of highlighting are
       available on all terminals:

       <b>none</b>   No highlighting is applied to the given context.  It is not useful for this to appear  with  other
              types of highlighting; it is used to override a default.

       <b>fg=</b><u>colour</u>
              The  foreground  colour  should  be set to <u>colour</u>, a decimal integer, the name of one of the eight
              most widely-supported colours or as a `<b>#</b>' followed by an RGB triplet in hexadecimal format.

              Not all terminals support this and, of those that do, not  all  provide  facilities  to  test  the
              support,  hence  the  user  should  decide based on the terminal type.  Most terminals support the
              colours <b>black</b>, <b>red</b>, <b>green</b>, <b>yellow</b>, <b>blue</b>, <b>magenta</b>, <b>cyan</b> and <b>white</b>, which can be set  by  name.   In
              addition.  <b>default</b> may be used to set the terminal's default foreground colour.  Abbreviations are
              allowed; <b>b</b> or <b>bl</b> selects black.  Some terminals  may  generate  additional  colours  if  the  <b>bold</b>
              attribute is also present.

              On  recent  terminals  and  on  systems with an up-to-date terminal database the number of colours
              supported may be tested by the command `<b>echotc</b> <b>Co</b>'; if this succeeds, it indicates a limit on  the
              number of colours which will be enforced by the line editor.  The number of colours is in any case
              limited to 256 (i.e. the range 0 to 255).

              Some  modern  terminal emulators have support for 24-bit true colour (16 million colours). In this
              case, the hex triplet format can be used. This consists of a `<b>#</b>' followed by either a three or six
              digit hexadecimal number describing the red, green and blue components of the colour. Hex triplets
              can  also  be  used  with  88  and  256  colour  terminals  via  the  <b>zsh/nearcolor</b>  module   (see
              <u><a href="../man1/zshmodules.1.html">zshmodules</a></u>(1)).

              Colour is also known as color.

       <b>bg=</b><u>colour</u>
              The  background  colour  should  be set to <u>colour</u>.  This works similarly to the foreground colour,
              except the background is not usually affected by the bold attribute.

       <b>bold</b>   The characters in the given context are shown in a bold font.  Not all terminals distinguish  bold
              fonts.

       <b>standout</b>
              The  characters in the given context are shown in the terminal's standout mode.  The actual effect
              is specific to the terminal; on many terminals it is inverse video.  On some such terminals, where
              the cursor does not blink it appears with standout mode negated, making it less than  clear  where
              the  cursor  actually  is.   On  such  terminals  one  of  the other effects may be preferable for
              highlighting the region and matched search string.

       <b>underline</b>
              The characters in the given context are shown underlined.  Some terminals show the foreground in a
              different colour instead; in this case whitespace will not be highlighted.

       The characters described above as `special' are as  follows.   The  formatting  described  here  is  used
       irrespective of whether the characters are highlighted:

       ASCII control characters
              Control characters in the ASCII range are shown as `<b>^</b>' followed by the base character.

       Unprintable multibyte characters
              This  item applies to control characters not in the ASCII range, plus other characters as follows.
              If the <b>MULTIBYTE</b> option is in effect, multibyte characters not in the ASCII character set that are
              reported as having zero width are treated as combining characters when the option  <b>COMBINING_CHARS</b>
              is  on.  If the option is off, or if a character appears where a combining character is not valid,
              the character is treated as unprintable.

              Unprintable multibyte characters are shown as a hexadecimal number between  angle  brackets.   The
              number  is  the  code  point  of  the  character in the wide character set; this may or may not be
              Unicode, depending on the operating system.

       Invalid multibyte characters
              If the <b>MULTIBYTE</b> option is in effect, any sequence of one or more bytes that does not form a valid
              character in the current character set is treated as a series of bytes each  shown  as  a  special
              character.   This  case  can  be  distinguished from other unprintable characters as the bytes are
              represented as two hexadecimal digits between angle brackets, as distinct from the four  or  eight
              digits  that  are  used  for  unprintable  characters  that  are  nonetheless valid in the current
              character set.

              Not all systems support this: for it to work, the system's representation of wide characters  must
              be code values from the Universal Character Set, as defined by IS0 10646 (also known as Unicode).

       Wrapped double-width characters
              When  a  double-width  character appears in the final column of a line, it is instead shown on the
              next line. The empty space left in the original position is highlighted as a special character.

       If <b>zle_highlight</b> is not set or no value applies  to  a  particular  context,  the  defaults  applied  are
       equivalent to

              <b>zle_highlight=(region:standout</b> <b>special:standout</b>
              <b>suffix:bold</b> <b>isearch:underline</b> <b>paste:standout)</b>

       i.e. both the region and special characters are shown in standout mode.

       Within   widgets,   arbitrary  regions  may  be  highlighted  by  setting  the  special  array  parameter
       <b>region_highlight</b>; see above.

zsh 5.9                                           May 14, 2022                                         <u><a href="../man1/ZSHZLE.1.html">ZSHZLE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>