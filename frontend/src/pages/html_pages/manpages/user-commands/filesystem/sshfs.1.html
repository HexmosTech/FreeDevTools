<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSHFS - filesystem client based on SSH</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/sshfs">sshfs_3.7.3-1.1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SSHFS - filesystem client based on SSH

</pre><h4><b>SYNOPSIS</b></h4><pre>
       To mount a filesystem:

          sshfs [user@]host:[dir] mountpoint [options]

       If <u>host</u> is a numeric IPv6 address, it needs to be enclosed in square brackets.

       To unmount it:

          fusermount3 -u mountpoint   # Linux
          umount mountpoint           # OS X, FreeBSD

</pre><h4><b>DESCRIPTION</b></h4><pre>
       SSHFS  allows  you  to mount a remote filesystem using SSH (more precisely, the SFTP subsystem). Most SSH
       servers support and enable this SFTP access by default, so SSHFS is very simple to use - there's  nothing
       to do on the server-side.

       By  default,  file permissions are ignored by SSHFS. Any user that can access the filesystem will be able
       to perform any operation that the remote server permits - based on the  credentials  that  were  used  to
       connect  to  the  server.  If  this  is  undesired,  local  permission  checking  can  be enabled with <b>-o</b>
       <b>default_permissions</b>.

       By default, only the mounting user will be able to access the filesystem. Access for other users  can  be
       enabled by passing <b>-o</b> <b>allow_other</b>. In this case you most likely also want to use <b>-o</b> <b>default_permissions</b>.

       It  is  recommended  to run SSHFS as regular user (not as root).  For this to work the mountpoint must be
       owned by the user.  If username is omitted SSHFS will  use  the  local  username.  If  the  directory  is
       omitted,  SSHFS  will  mount the (remote) home directory.  If you need to enter a password sshfs will ask
       for it (actually it just runs ssh which ask for the password if needed).

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-o</b> <b>opt,[opt...]</b>
              mount options, see below for details. A a variety of SSH options can be given here  as  well,  see
              the manual pages for <u><a href="../man1/sftp.1.html">sftp</a>(1)</u> and <u><a href="../man5/ssh_config.5.html">ssh_config</a>(5)</u>.

       <b>-h</b>, <b>--help</b>
              print help and exit.

       <b>-V</b>, <b>--version</b>
              print version information and exit.

       <b>-d</b>, <b>--debug</b>
              print debugging information.

       <b>-p</b> <u>PORT</u>
              equivalent to '-o port=PORT'

       <b>-f</b>     do not daemonize, stay in foreground.

       <b>-s</b>     Single threaded operation.

       <b>-C</b>     equivalent to '-o compression=yes'

       <b>-F</b> <u>ssh_configfile</u>
              specifies alternative ssh configuration file

       <b>-1</b>     equivalent to '-o ssh_protocol=1'

       <b>-o</b> <u>reconnect</u>
              automatically reconnect to server if connection is interrupted. Attempts to access files that were
              opened before the reconnection will give errors and need to be re-opened.

       <b>-o</b> <u>delay_connect</u>
              Don't immediately connect to server, wait until mountpoint is first accessed.

       <b>-o</b> <u>sshfs_sync</u>
              synchronous writes. This will slow things down, but may be useful in some situations.

       <b>-o</b> <u>no_readahead</u>
              Only read exactly the data that was requested, instead of speculatively reading more to anticipate
              the next read request.

       <b>-o</b> <u>sync_readdir</u>
              synchronous readdir. This will slow things down, but may be useful in some situations.

       <b>-o</b> <b>workaround=LIST</b>
              Enable  the  specified  workaround. See the <u>Caveats</u> section below for some additional information.
              Possible values are:

              <b>rename</b> Emulate overwriting an existing file by deleting and renaming.

              <b>renamexdev</b>
                     Make rename fail with EXDEV instead of the default  EPERM  to  allow  moving  files  across
                     remote filesystems.

              <b>truncate</b>
                     Work  around  servers  that  don't support truncate by coping the whole file, truncating it
                     locally, and sending it back.

              <b>fstat</b>  Work around broken servers that don't support <u>fstat()</u> by using <u>stat</u> instead.

              <b>buflimit</b>
                     Work around OpenSSH "buffer fillup" bug.

              <b>createmode</b>
                     Work around broken servers that produce an error when passing a non-zero mode to create, by
                     always passing a mode of 0.

       <b>-o</b> <b>idmap=TYPE</b>
              How to map remote UID/GIDs to local values. Possible values are:

              <b>none</b>   no translation of the ID space (default).

              <b>user</b>   map the UID/GID of the remote user to UID/GID of the mounting user.

              <b>file</b>   translate UIDs/GIDs based upon the contents of <u>--uidfile</u> and <u>--gidfile</u>.

       <b>-o</b> <b>uidfile=FILE</b>
              file containing <b>username:uid</b> mappings for <u>-o</u> <u>idmap=file</u>

       <b>-o</b> <b>gidfile=FILE</b>
              file containing <b>groupname:gid</b> mappings for <u>-o</u> <u>idmap=file</u>

       <b>-o</b> <b>nomap=TYPE</b>
              with idmap=file, how to handle missing mappings:

              <b>ignore</b> don't do any re-mapping

              <b>error</b>  return an error (default)

       <b>-o</b> <b>ssh_command=CMD</b>
              execute CMD instead of 'ssh'

       <b>-o</b> <b>ssh_protocol=N</b>
              ssh protocol to use (default: 2)

       <b>-o</b> <b>sftp_server=SERV</b>
              path to sftp server or subsystem (default: sftp)

       <b>-o</b> <b>directport=PORT</b>
              directly connect to PORT bypassing ssh

       <b>-o</b> <u>passive</u>
              communicate over stdin and stdout bypassing network. Useful for mounting local filesystem  on  the
              remote  side.   An  example  using dpipe command would be <b>dpipe</b> <b><a href="file:/usr/lib/openssh/sftp-server">/usr/lib/openssh/sftp-server</a></b> <b>=</b> <b>ssh</b>
              <b>RemoteHostname</b> <b>sshfs</b> <b>:/directory/to/be/shared</b> <b><a href="file:~/mnt/src">~/mnt/src</a></b> <b>-o</b> <b>passive</b>

       <b>-o</b> <u>disable_hardlink</u>
              With this option set, attempts to call <u><a href="../man2/link.2.html">link</a>(2)</u> will fail with error code ENOSYS.

       <b>-o</b> <u>transform_symlinks</u>
              transform absolute symlinks on remote side to relative symlinks. This means that if  e.g.  on  the
              server  side  <b>/foo/bar/com</b>  is  a  symlink  to  <b>/foo/blub</b>, SSHFS will transform the link target to
              <b>../blub</b> on the client side.

       <b>-o</b> <u>follow_symlinks</u>
              follow symlinks on the server, i.e. present them as regular files on the client. If a  symlink  is
              dangling  (i.e,  the  target does not exist) the behavior depends on the remote server - the entry
              may appear as a symlink on the client, or it may appear as a regular file that cannot be accessed.

       <b>-o</b> <u>no_check_root</u>
              don't check for existence of 'dir' on server

       <b>-o</b> <u>password_stdin</u>
              read password from stdin (only for pam_mount!)

       <b>-o</b> <b>dir_cache=BOOL</b>
              Enables (<u>yes</u>) or disables (<u>no</u>) the SSHFS directory cache.  The directory cache holds the names  of
              directory  entries.  Enabling  it  allows  <u><a href="../man3/readdir.3.html">readdir</a>(3)</u> system calls to be processed without network
              access.

       <b>-o</b> <b>dcache_max_size=N</b>
              sets the maximum size of the directory cache.

       <b>-o</b> <b>dcache_timeout=N</b>
              sets timeout for directory cache in seconds.

       <b>-o</b> <b>dcache_{stat,link,dir}_timeout=N</b>
              sets separate timeout for {attributes, symlinks, names} in  the directory cache.

       <b>-o</b> <b>dcache_clean_interval=N</b>
              sets the interval for automatic cleaning of the directory cache.

       <b>-o</b> <b>dcache_min_clean_interval=N</b>
              sets the interval for forced cleaning of the directory cache when full.

       <b>-o</b> <u>direct_io</u>
              This option disables the use of page cache (file content cache) in the kernel for this filesystem.
              This has several affects:

              1. Each read() or write() system call will initiate one or more read  or  write  operations,  data
                 will not be cached in the kernel.

              2. The return value of the read() and write() system calls will correspond to the return values of
                 the  read  and  write  operations.  This is useful for example if the file size is not known in
                 advance (before reading it).  e.g. <a href="file:/proc">/proc</a> filesystem

       <b>-o</b> <b>max_conns=N</b>
              sets the maximum number of simultaneous SSH connections to use.  Each  connection  is  established
              with a separate SSH process.  The primary purpose of this feature is to improve the responsiveness
              of  the  file  system  during  large  file  transfers.  When  using more than once connection, the
              <u>password_stdin</u> and <u>passive</u> options can not be used, and the <u>buflimit</u> workaround is not supported.

       In addition, SSHFS accepts several options common to all FUSE file systems. These are  described  in  the
       <u>mount.fuse</u> manpage (look for "general", "libfuse specific", and "high-level API" options).

</pre><h4><b>CAVEATS</b> <b>/</b> <b>WORKAROUNDS</b></h4><pre>
   <b>Hardlinks</b>
       If  the  SSH  server supports the <u>hardlinks</u> extension, SSHFS will allow you to create hardlinks. However,
       hardlinks will always appear as individual files when seen through an SSHFS mount, i.e. they will  appear
       to have different inodes and an <u>st_nlink</u> value of 1.

   <b>Rename</b>
       Some SSH servers do not support atomically overwriting the destination when renaming a file. In this case
       you  will get an error when you attempt to rename a file and the destination already exists. A workaround
       is to first remove the destination file, and then do the rename. SSHFS can do this automatically  if  you
       call it with <u>-o</u> <u>workaround=rename</u>. However, in this case it is still possible that someone (or something)
       recreates  the  destination  file after SSHFS has removed it, but before SSHFS had the time to rename the
       old file. In this case, the rename will still fail.

   <b>Permission</b> <b>denied</b> <b>when</b> <b>moving</b> <b>files</b> <b>across</b> <b>remote</b> <b>filesystems</b>
       Most SFTP servers return only a generic "failure" when failing to  rename  across  filesystem  boundaries
       (EXDEV).   sshfs  normally  converts  this  generic failure to a permission denied error (EPERM).  If the
       option <b>-o</b> <b>workaround=renamexdev</b> is given, generic failures will be considered  EXDEV  errors  which  will
       make programs like <u><a href="../man1/mv.1.html">mv</a>(1)</u> attempt to actually move the file after the failed rename.

   <b>SSHFS</b> <b>hangs</b> <b>for</b> <b>no</b> <b>apparent</b> <b>reason</b>
       In  some cases, attempts to access the SSHFS mountpoint may freeze if no filesystem activity has occurred
       for some time. This is typically caused by the SSH connection being dropped because of inactivity without
       SSHFS being informed about that. As a workaround, you can try to mount  with  <b>-o</b>  <b>ServerAliveInterval=15</b>.
       This will force the SSH connection to stay alive even if you have no activity.

   <b>SSHFS</b> <b>hangs</b> <b>after</b> <b>the</b> <b>connection</b> <b>was</b> <b>interrupted</b>
       By  default,  network  operations  in  SSHFS  run without timeouts, mirroring the default behavior of SSH
       itself. As a consequence, if the connection to the remote host is interrupted  (e.g.  because  a  network
       cable  was  removed),  operations  on  files  or  directories  under  the mountpoint will block until the
       connection is either restored or closed altogether (e.g. manually).  Applications that try to access such
       files or directories will generally appear to "freeze" when this happens.

       If it is acceptable to discard data being read or written, a quick workaround is to kill the  responsible
       <b>sshfs</b>  process,  which  will make any blocking operations on the mounted filesystem error out and thereby
       "unfreeze" the relevant applications. Note that force unmounting with <b>fusermount</b> <b>-zu</b>, on the other  hand,
       does not help in this case and will leave read/write operations in the blocking state.

       For  a  more  automatic solution, one can use the <b>-o</b> <b>ServerAliveInterval=15</b> option mentioned above, which
       will drop the connection after not receiving a response for 3 * 15 = 45 seconds from the remote host.  By
       also  supplying  <b>-o</b>  <b>reconnect</b>,  one can ensure that the connection is re-established as soon as possible
       afterwards. As before, this will naturally lead to loss of data that was in the process of being read  or
       written at the time when the connection was interrupted.

</pre><h4><b>MOUNTING</b> <b>FROM</b> <b>/ETC/FSTAB</b></h4><pre>
       To  mount  an  SSHFS filesystem from <b><a href="file:/etc/fstab">/etc/fstab</a></b>, simply use <b>sshfs</b> as the file system type. (For backwards
       compatibility, you may also use <b>fuse.sshfs</b>).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The <u><a href="../man8/mount.fuse.8.html">mount.fuse</a>(8)</u> manpage.

</pre><h4><b>GETTING</b> <b>HELP</b></h4><pre>
       If you need help, please  ask  on  the  &lt;<u><a href="mailto:fuse-sshfs@lists.sourceforge.net">fuse-sshfs@lists.sourceforge.net</a></u>&gt;  mailing  list  (subscribe  at
       <u>https://lists.sourceforge.net/lists/listinfo/fuse-sshfs</u>).

       Please report any bugs on the GitHub issue tracker at <u>https://github.com/libfuse/libfuse/issues</u>.

</pre><h4><b>AUTHORS</b></h4><pre>
       SSHFS  is currently maintained by Nikolaus Rath &lt;<u><a href="mailto:Nikolaus@rath.org">Nikolaus@rath.org</a></u>&gt;, and was created by Miklos Szeredi &lt;‐
       <u><a href="mailto:miklos@szeredi.hu">miklos@szeredi.hu</a></u>&gt;.

       This man page was originally written by  Bartosz  Fenski  &lt;<u><a href="mailto:fenio@debian.org">fenio@debian.org</a></u>&gt;  for  the  Debian  GNU/Linux
       distribution (but it may be used by others).

                                                                                                        <u><a href="../man1/SSHFS.1.html">SSHFS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>