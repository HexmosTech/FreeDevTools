<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>create_compressed_fs, extract_compressed_fs - convert and extract a filesystem to/from a cloop volume</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/cloop-utils">cloop-utils_3.14.1.3+nmu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       create_compressed_fs, extract_compressed_fs - convert and extract a filesystem to/from a cloop volume

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>create_compressed_fs</b> [ <b>OPTIONS</b> ] <b>image</b> <b>outfile</b>

       <b>extract_compressed_fs</b> <b>filename</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>create_compressed_fs</b>  compresses  a filesystem image to a compressed image suitable for mounting with the
       cloop driver.

       <b>extract_compressed_fs</b> uncompresses a filesystem image created by create_compressed_fs.

</pre><h4><b>OPTIONS</b></h4><pre>
       Run the <b>create_compressed_fs</b> command with "-h" to get a list of available options and description of data
       storages modes and advanced usage (eg. with a network cluster). Blocksize  must  be  a  multiple  of  512
       bytes.

       There  is an alternative set of options which is supported for compatibility with the original version of
       create_compressed_fs. When it's called with a pure number as output, it assumes the old syntax  and  maps
       the  default  options  to memory mode and the block size to the number. -b for best mode is recognized as
       well.

</pre><h4><b>EXAMPLES</b></h4><pre>
       create_compressed_fs image.ext2 image.ext2.cloop

       extract_compressed_fs image.ext2.cloop | cmp image.ext2 -

       mkcmd="genisoimage -joliet-long -D -r data"

       $mkcmd | create_compressed_fs -s $($mkcmd --print-size)i - file.cloop

       create_compressed_fs image.iso -S image.cloop.a0 - | split -b 1024m - image.cloop.

       cat image.cloop.* | cdrskin -

</pre><h4><b>NOTES</b></h4><pre>
       For optimal performance, create_compressed_fs should be used with real input and output files.

       Operation with STDIN or STDOUT is complicated. create_compressed_fs  cannot  operate  as  a  simple  pipe
       filter  because  it  needs  to  know  some  things  in  advance: a) the data length, b) the block lengths
       calculated during the compression. This meta data needs to be stored in the header AFTER the  compression
       is trough, therefore it is not possible to push all generated data to STDOUT on-the-fly.

       And  so compromises need to be made. The simpliest method (used by the ancient create_compressed_fs) is a
       big temporary memory buffer (option <b>-m</b>) to keep compressed data  in  RAM.  However,  the  overall  system
       performance suffers from such usage and this may drive other applications into OOM conditions.

       The  next alternative to this is storing the temprorary data in an extra file aside (the <b>-f</b> option). This
       improves the overall system performance but create_compressed_fs operation is slower because it needs  to
       copy  data  back when it's finished. Plus, double disk space for the output is required. If disk space is
       limited, the <b>-r</b> option could be used (reusing output file for temporary data), however the speed  of  the
       copy-back step may decrease significantly.

       There  are  strategies to avoid the temporary data storage completely.  First, only files should be used.
       If that is not possible, then the output should be a (seekable) file and the input data length should  be
       known (either specified with the <b>-s</b> option or detected from the input file size).

       Second, it is possible to store the header of the cloop volume in a separate file. After the work, header
       can  be  merged together with the compressed data with the cat command. The output data can be written to
       stdout. Since the header is stored too late, this method is not very usefull for immediate data transfer.
       However, it allows to do some tricks like piping to the split utility (to store  DVD  images  in  smaller
       files  on  VFAT)  or piping data trough ssh if the local system has no disk space (and copying the header
       separately).

</pre><h4><b>MOUNTING</b></h4><pre>
       You can pass an option to the cloop module on loading, or use losetup or  losetup  functionality  of  the
       mount command. Examples:

       insmod cloop.o file=/path/to/compressed/image

       losetup /dev/cloop1 /path/to/compressed/image

       mount -o ro -t whatever /dev/cloop /mnt/compressed

       mount cl /mnt/misc -oloop=/dev/cloop0

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>/usr/share/doc/cloop-utils/*</b>, <b>/usr/share/doc/cloop-src/*</b>

</pre><h4><b>AUTHOR</b></h4><pre>
       This  manual page was written by Eduard Bloch &lt;<a href="mailto:blade@debian.org">blade@debian.org</a>&gt; for the Debian GNU/Linux system (but may
       be used by others).  Permission is granted to copy, distribute and/or  modify  this  document  under  the
       terms of the GNU GPLv2.

                                                04 Dezember 2006                         <u><a href="../man1/CREATE_COMPRESSED_FS.1.html">CREATE_COMPRESSED_FS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>