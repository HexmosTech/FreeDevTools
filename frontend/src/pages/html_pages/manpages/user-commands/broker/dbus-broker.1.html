<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dbus-broker - D-Bus message broker</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/dbus-broker">dbus-broker_36-1ubuntu0.25.04.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dbus-broker - D-Bus message broker

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>dbus-broker</b> [ OPTIONS ]
       <b>dbus-broker</b> <b>--version</b>
       <b>dbus-broker</b> <b>--help</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>dbus-broker</b>  is  an  implementation  of the D-Bus Message Bus Specification [1]. Each instance provides a
       single, unique message bus that clients can connect to, and send messages over. The broker takes care  of
       message mediation, access control, subscriptions, and bus control, according to the D-Bus specification.

       <b>dbus-broker</b>  is  a <u>pure</u> implementation, meaning that it only implements the message mediation. It needs a
       controlling process that performs the bus setup and all external communication. <b><a href="../man1/dbus-broker-launch.1.html">dbus-broker-launch</a></b>(1)  is
       such  a controller aiming at perfect compatibility to <b><a href="../man1/dbus-daemon.1.html">dbus-daemon</a></b>(1), the D-Bus Reference Implementation.
       See <b><a href="../man1/dbus-broker-launch.1.html">dbus-broker-launch</a></b>(1) for details how to spawn a message bus.

       This   man-page   documents   the   interface   between   <b>dbus-broker</b>   and   its    controller    (e.g.,
       <b><a href="../man1/dbus-broker-launch.1.html">dbus-broker-launch</a></b>(1)).

</pre><h4><b>OPTIONS</b></h4><pre>
       The  following  command-line options are supported. If an option is passed, which is not listed here, the
       broker will deny startup and exit with an error.

       <b>-h</b>, <b>--help</b>
              print usage information and exit immediately

       <b>--version</b>
              print build-version and exit immediately

       <b>--audit</b>
              enable logging to the linux audit subsystem (no-op if audit support was not compiled in;  <b>Default</b>:
              off)

       <b>--controller=</b><u>FD</u>
              use  the inherited file-descriptor with the given number as the controlling socket (see <b>CONTROLLER</b>
              section; this option is mandatory)

       <b>--log</b> <u>FD</u>
              use the inherited file-descriptor with the given number to access  the  system  log  (see  <b>LOGGING</b>
              section; <b>Default</b>: no logging)

       <b>--machine-id=</b><u>ID</u>
              set  the  machine-id  to  be advertised by the broker via the org.freedesktop.DBus interface (this
              option is mandatory and usually sourced from <a href="file:/etc/machine-id">/etc/machine-id</a>)

       <b>--max-bytes=</b><u>BYTES</u>
              maximum number of bytes each user may allocate in the broker (<b>Default</b>: 16 MiB)

       <b>--max-fds=</b><u>FDS</u>
              maximum number of file descriptors each user may allocate in the broker (<b>Default</b>: 64)

       <b>--max-matches=</b><u>MATCHES</u>
              maximum number of match rules each user may allocate in the broker (<b>Default</b>: 16k)

       <b>--max-objects=</b><u>OBJECTS</u>
              maximum total number of names, peers, pending replies, etc each user may allocate  in  the  broker
              (<b>Default</b>: 16k)

</pre><h4><b>CONTROLLER</b></h4><pre>
       Every  instance  of  <b>dbus-broker</b>  inherits  a <b><a href="../man7/unix.7.html">unix</a></b>(7) socket from its parent process. This socket must be
       specified via the <b>--controller</b> option. The broker uses this socket to accept control  commands  from  its
       parent  process  (or  from whomever owns the other side of this socket, also called <u>The</u> <u>Controller</u>). This
       socket uses normal D-Bus P2P communication. The interfaces provided on this socket are described  in  the
       <b>API</b> section.

       By  default,  a broker instance is idle. That is, after forking and executing a broker, it starts with an
       empty list of bus-sockets to manage, as well as no way for clients to connect to it. The controller  must
       use  the  controller  interface  to  create  listener sockets, specify the bus policy, create activatable
       names, and react to bus events.

       The <b>dbus-broker</b> process never accesses any external resources other than those passed in either  via  the
       command-line  or  the controller interfaces. That is, no file-system access, no <b><a href="../man5/nss.5.html">nss</a></b>(5) calls, no external
       process communication, is performed by the broker.  On  the  contrary,  the  broker  never  accesses  any
       resources  but the sockets provided to it by the controller. This is guaranteed by the implementation. At
       the same time, this implies that the controller is required to perform all external resource acquisitions
       and communication on behalf of the broker (in case this is needed).

</pre><h4><b>LOGGING</b></h4><pre>
       If a logging FD is provided via the <b>--log</b> command-line option,  the  broker  will  log  some  information
       through this FD. Two different log-types are supported:

          1. If  the  FD  is  a  <b><a href="../man7/unix.7.html">unix</a></b>(7)  <b>SOCK_STREAM</b> socket, information is logged as human-readable line-based
             chunks.

          2. If the FD is a <b><a href="../man7/unix.7.html">unix</a></b>(7) <b>SOCK_DGRAM</b> socket, information is logged as key/value based  annotated  data
             blocks.  The  format  is  compatible  to  the  format used by the systemd-journal (though it is not
             dependent on systemd).  This key/value based logging is a lot more  verbose  as  the  stream  based
             logging.   A  lot  of  metadata  is  provided  as  separate  keys,  allowing  precise  tracing  and
             interpretation of the logged data.

       The broker has strict rules when it logs data. It logs during startup and shutdown, one message  each  to
       provide  information  on  its setup and environment.  At runtime, the broker only ever logs in unexpected
       situations. That is, every message the broker logs at runtime was triggered by a  malfunctioning  client.
       If a system is properly set up, no runtime log-message will be triggered.

       The situations where the broker logs are:

          1. During  startup  and  shutdown,  the  broker  submits  a short message including metadata about its
             controller, environment, and setup.

          2. Whenever a client-request is denied by the policy, a  message  is  logged  including  the  affected
             client and policies.

          3. Whenever a client exceeds its resource quota, a message is logged with information on the client.

</pre><h4><b>API</b></h4><pre>
       The  following  interfaces are implemented by the broker on the respective nodes.  The controller is free
       to call these at any time. The controller connection is considered trusted. No resource  accounting,  nor
       access control is performed.

       The  controller itself is also required to implement interfaces to be used by the broker. See the section
       below for a list of interfaces on the controller.

       <b>node</b> /org/bus1/DBus/Broker {
         <b>interface</b> org.bus1.DBus.Broker {

           # Create new activatable name @name, accounted on user @uid. The name
           # will be exposed by the controller as @path (which must fit the
           # template <u>/org/bus1/DBus/Name/%</u>).
           <b>method</b> AddName(<b>o</b> <u>path</u>, <b>s</b> <u>name</u>, <b>u</b> <u>uid</u>) -&gt; ()

           # Add a listener socket to this bus. The listener socket must be
           # ready in listening mode and specified as @socket. As soon as this
           # call returns, incoming client connection attempts will be served
           # on this socket.
           # The listener is exposed by the controller as @path (which must fit
           # the template <u>/org/bus1/DBus/Listener/%</u>).
           # The policy for all clients connecting through this socket is
           # provided as @policy. See <b>org.bus1.DBus.Listener.SetPolicy()</b> for
           # details.
           <b>method</b> AddListener(<b>o</b> <u>path</u>, <b>h</b> <u>socket</u>, <b>v</b> <u>policy</u>) -&gt; ()

           # This signal is raised according to client-requests of
           # <b>org.freedesktop.DBus.UpdateActivationEnvironment()</b>.
           <b>signal</b> SetActivationEnvironment(<b>a{ss}</b> <u>environment</u>)

         }
       }

       <b>node</b> /org/bus1/DBus/Listener/% {
         <b>interface</b> org.bus1.DBus.Listener {

           # Release this listener. It will immediately be removed by the broker
           # and no more connections will be served on it. All clients connected
           # through this listener are forcefully disconnected.
           <b>method</b> Release() -&gt; ()

           # Change the policy on this listener socket to @policy. The syntax of
           # the policy is still subject to change and not stable, yet.
           <b>method</b> SetPolicy(<b>v</b> <u>policy</u>) -&gt; ()

         }
       }

       <b>node</b> /org/bus1/DBus/Name/% {
         <b>interface</b> org.bus1.DBus.Name {

           # Release this activatable name. It will be removed with immediate
           # effect by the broker. Note that the name is still valid to be
           # acquired by clients, though no activation-features will be
           # supported on this name.
           <b>method</b> Release() -&gt; ()

           # Reset the activation state of this name. Any pending activation
           # requests are cancelled. The call requires a serial number to be
           # passed along. This must be the serial number received by the last
           # activation event on this name. Calls for other serial numbers are
           # silently ignored and considered stale.
           # A org.bus1.DBus.Name.Error string is also passed, giving a hint
           # about the reason the activation was reset. The list is defined below.
           <b>method</b> Reset(<b>t</b> <u>serial</u>, <b>s</b> <u>error</u>) -&gt; ()

           # Activation request failed: a concurrent deactivation request is already in progress
           <b>error</b> <u>org.bus1.DBus.Name.Error.DestructiveTransaction</u>
           # Activation request failed: unknown unit
           <b>error</b> <u>org.bus1.DBus.Name.Error.UnknownUnit</u>
           # Activation request failed: unit is masked
           <b>error</b> <u>org.bus1.DBus.Name.Error.MaskedUnit</u>
           # Activation request failed: unit is invalid
           <b>error</b> <u>org.bus1.DBus.Name.Error.InvalidUnit</u>
           # Unit activation job succeeded, but the unit failed afterwards
           <b>error</b> <u>org.bus1.DBus.Name.Error.UnitFailure</u>
           # The startup job was valid, but it failed during activation
           <b>error</b> <u>org.bus1.DBus.Name.Error.StartupFailure</u>
           # The startup job was valid, but it was skipped during activation
           <b>error</b> <u>org.bus1.DBus.Name.Error.StartupSkipped</u>
           # Activation request cancelled: bus name was released
           <b>error</b> <u>org.bus1.DBus.Name.Error.NameReleased</u>

           # This signal is sent whenever a client requests activation of this
           # name. Note that multiple activation requests are coalesced by the
           # broker. The controller can cancel outstanding requests via the
           # <b>Reset()</b> method.
           # The broker sends a serial number with the event. This number
           # represents the activation request and must be used when reacting
           # to the request with methods like <u>Reset()</u>. The serial number is
           # unique for each event, and is never reused. A serial number of 0
           # is never sent and considered invalid.
           <b>signal</b> Activate(<b>t</b> <u>serial</u>)

         }
       }

       The controller itself is required to implement  the  following  interfaces  on  the  given  nodes.  These
       interfaces  are  called  by  the broker to implement some parts of the driver-interface as defined by the
       D-Bus specification.

       Note that all method-calls performed by the broker are always fully asynchronous. That is, regardless how
       long it takes to serve the request, the broker is still fully operational and  might  even  send  further
       requests to the controller.

       A  controller is free to implement these calls in a blocking fashion. However, it is up to the controller
       to make sure not to perform <b>blocking</b> recursive calls back into the broker (via any means).

       <b>node</b> /org/bus1/DBus/Controller {
         <b>interface</b> org.bus1.DBus.Controller {

           # This function is called for each client-request of
           # <u>org.freedesktop.DBus.ReloadConfig()</u>.
           <b>method</b> ReloadConfig() -&gt; ()

         }
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/dbus-broker-launch.1.html">dbus-broker-launch</a></b>(1) <b><a href="../man1/dbus-daemon.1.html">dbus-daemon</a></b>(1)

</pre><h4><b>NOTES</b></h4><pre>
       [1]  D-Bus Specification:
             &lt;https://dbus.freedesktop.org/doc/dbus-specification.html&gt;

                                                                                                  <u><a href="../man1/DBUS-BROKER.1.html">DBUS-BROKER</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>