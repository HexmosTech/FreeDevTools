<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ns - network simulator (version 2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/ns2">ns2_2.35+dfsg-9_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ns - network simulator (version 2)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>ns</b> [ <u>file</u> [ <u>arg</u> <u>arg</u> <u>...</u>  ] ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>ns</u> is an event-driven network simulator.  An extensible simulation engine is implemented in C++ that uses
       MIT's  Object  Tool  Command  Language,  OTcl  (an  object  oriented  version  of Tcl) as the command and
       configuration interface.  A previous version of the simulator i.e. ns version 1  used  the  Tool  Command
       Language,  Tcl  as  the  configuration  language.   The current version still supports simulation scripts
       written in Tcl meant for the ns version 1 simulator.

       This manual page documents some of the interfaces for ns.  For much more complete  documentation,  please
       see "ns Notes and Documentation" [13], available in the distribution and on the web.

       The  simulator  is  invoked  via the <u>ns</u> interpreter, an extension of the vanilla <u>otclsh</u> command shell.  A
       simulation is defined by a OTcl script.  The scripts use the Simulator Class as the  principal  interface
       to  the  simulation  engine.   Using  the  methods  defined in this class, a network topology is defined,
       traffic sources and sinks are configured, the simulation is invoked, and the  statistics  are  collected.
       By building upon a fully functional language, arbitrary actions can be programmed into the configuration.

       The  first step in the simulation is to acquire an instance of the Simulator class.  Instances of objects
       in classes are created and destroyed in ns using the <u>new</u> and <u>delete</u> methods.  For example, an instance of
       the Simulator object is created by the following command:

            e.g. set ns [new Simulator]

       A network topology is realized using three primitive building blocks:  nodes,  links,  and  agents.   The
       Simulator  class  has methods to create/ configure each of these building blocks.  Nodes are created with
       the <u>node</u> Simulator method that automatically assigns an unique address to each node.  Links  are  created
       between  nodes  to  form  a  network  topology  with the <u>simplex-link</u> and <u>duplex-link</u> methods that set up
       unidirectional and bidirectional links respectively.  Agents are the  objects  that  actively  drive  the
       simulation.   <u>Agents</u>  can be thought of as the processes and/or transport entities that run on <u>nodes</u> that
       may be end hosts or routers.  Traffic sources and sinks, dynamic routing modules and the various protocol
       modules are all examples of agents.  Agents are created by instantiating objects in the subclass of class
       Agent i.e., <u>Agent/type</u> where type specifies the nature of the agent.  For example, a TCP agent is created
       using the command:

            set tcp [new Agent/TCP]

       Once the agents are created, they are attached to nodes with the  <u>attach-agent</u>  Simulator  method.   Each
       agent  is  automatically  assigned a port number unique across all agents on a given node (analogous to a
       tcp or udp port).  Some types of agents may have sources attached to them while others may generate their
       own data.  For example, you can attach ``ftp'' and ``telnet'' sources to ``tcp''  agents  but  ``constant
       bit-rate''  agents  generate  their  own  data.  Applications are attached to agents using the <u>attach-app</u>
       method.

       Each object has some configuration parameters associated with it that  can  be  modified.   Configuration
       parameters  are  instance  variables  of  the object.  These parameters are initialized during startup to
       default values that can simply be read from the instance variables of the object.  For example, <u>$tcp</u>  <u>set</u>
       <u>window</u><b>_</b>  returns  the  default window size for the tcp object.  The default values for that object can be
       explicitly overridden by simple assignment either before a simulation begins, or dynamically,  while  the
       simulation  is  in  progress.  For example the window-size for a particular TCP session can be changed in
       the following manner.

            $tcp set window_ 25

       The default values for the configuration parameters of all the class  objects  subsequently  created  can
       also be changed by simple assignment.  For example, we can say

            Agent/TCP set window_ 30

       to make all future tcp agent creations default to a window size of 30.

       Events  are  scheduled  in  ns using the <u>at</u> Simulator method that allows OTcl procedures to be invoked at
       arbitrary points in simulation time.  These OTcl callbacks provide a  flexible  simulation  mechanism  --
       they  can  be  used to start or stop sources, dump statistics, instantiate link failures, reconfigure the
       network topology etc.  The simulation is started via the <u>run</u> method and continues until there are no more
       events to be processed.  At this time, the original invocation of the <u>run</u> command  returns  and  the  Tcl
       script  can  exit  or  invoke  another simulation run after possible reconfiguration.  Alternatively, the
       simulation can be prematurely halted by invoking the <u>stop</u> command or by exiting  the  script  with  Tcl's
       standard <u>exit</u> command.

       Packets  are  forwarded  along the shortest path route from a source to a destination, where the distance
       metric is the sum of costs of the links traversed from the source to the destination.  The cost of a link
       is 1 by default; the distance metric is simply the hop count in this case.  The cost of  a  link  can  be
       changed  with  the  <u>cost</u> Simulator method.  A static topology model is used as the default in ns in which
       the states of nodes/links do not change during the course of a simulation.   Network  Dynamics  could  be
       specified  using  methods  described in NETWORK DYNAMICS METHODS section.  Also static unicast routing is
       the default in which the routes are pre-computed over the entire topology  once  prior  to  starting  the
       simulation.   Methods  to enable and configure dynamic unicast and multicast routing are described in the
       UNICAST ROUTING METHODS and MULTICAST ROUTING METHODS sections respectively.

</pre><h4><b>NS</b> <b>COMMANDS</b></h4><pre>
       This section describes the basic commands to create the building blocks of the simulation (i.e. the node,
       link and agent objects) and to run the simulation.

       The first step in running a simulation as stated before is to acquire an instance of the Simulator  class
       that  has  methods to configure and run the simulation.  Throughout this section the object variable name
       $ns is used to imply a Simulator object.

       <b>$ns</b> <b>node</b>
              Create a new node object and return a handle to it.

       <b>$ns</b> <b>all-nodes-list</b>
              Returns a list of all the node objects defined in the simulation.

       <b>$ns</b> <b>simplex-link</b> <u>node1</u> <u>node2</u> <u>bw</u> <u>delay</u> <u>type</u>
              Create a new unidirectional link between <u>node1</u> and <u>node2</u> with bandwidth <u>bw</u> in bits per second  and
              link  propagation delay <u>delay</u> in seconds.  <u>node1</u> and <u>node2</u> must have already been created with the
              <u>node</u> method.  <u>bw</u> and <u>delay</u> default to 1.5 Mbits/sec and 100 ms respectively.  The defaults can  be
              changed  by modifying the relevant configuration parameters of the DelayLink Object (see DELAYLINK
              OBJECTS section).  <u>node1</u> and <u>node2</u> must have already been  created  with  the  <u>node</u>  method.   The
              queuing  discipline  of  the  link is specified by <u>type,</u> which may be <b>DropTail,</b> <b>FQ,</b> <b>SFQ,</b> <b>DRR,</b> <b>RED,</b>
              <b>CBQ,</b> or <b>CBQ/WRR.</b>  A DropTail link is a simple FIFO queue which drops the last packet in the  queue
              when the queue overflows.  A FQ link is for Fair Queuing (for details see [?]).  A SFQ link is for
              Stochastic  Fair  Queuing (for details see [?]).  A DRR link is for deficit round robin scheduling
              (for details see [9]).  A RED link is a random-early drop queue (for details see [2]).  A CBQ link
              is for class-based queuing using a packet-by-packet round-robin scheduler (for details  see  [3]).
              A  CBQ/WRR  link  is  for class-based queuing with a weighted round robin scheduler.  If multicast
              routing is used links with interface labels are required.   Such  links  are  created  by  setting
              Simulator NumberInterfaces_ variable to 1.  All the subsequently created links will have interface
              labels.   To  disable  creation  of  interfaces  simply  reset NumberInterfaces_ to 0 (this is the
              default).

       <b>$ns</b> <b>duplex-link</b> <u>node1</u> <u>node2</u> <u>bw</u> <u>delay</u> <u>type</u>
              Create a new bidirectional link between <u>node1</u> and <u>node2</u> with bandwidth <u>bw</u> in bits per  second  and
              link  propagation delay <u>delay</u> in seconds.  <u>node1</u> and <u>node2</u> must have already been created with the
              <u>node</u> method.  <u>bw</u> and <u>delay</u> default to 1.5 Mbits/sec and 100 ms respectively.  The defaults can  be
              changed  by modifying the relevant configuration parameters of the DelayLink Object (see DELAYLINK
              OBJECTS section).  The queuing discipline of the link is specified by <u>type,</u> which may be <b>DropTail,</b>
              <b>FQ</b> <b>SFQ,</b> <b>DRR,</b> <b>RED,</b> <b>CBQ,</b> or <b>CBQ/WRR.</b>  A DropTail link is a simple FIFO queue which  drops  the  last
              packet  in  the  queue  when  the queue overflows.  A FQ link is for Fair Queuing (for details see
              [?]).  A SFQ link is for Stochastic Fair Queuing (for details see [?]).  A DRR link is for deficit
              round robin scheduling (for details see [9]).  A RED  link  is  a  random-early  drop  queue  (for
              details  see  [2]).   A  CBQ  link is for class-based queuing using a packet-by-packet round-robin
              scheduler (for details see [3]).  A CBQ/WRR link is for class-based queuing with a weighted  round
              robin  scheduler.   If  multicast  routing is used links with interface labels are required.  Such
              links are created by setting Simulator NumberInterfaces_ variable  to  1.   All  the  subsequently
              created  links  will  have  interface  labels.   To  disable  creation  of interfaces simply reset
              NumberInterfaces_ to 0 (this is the default).

       <b>$ns</b> <b>link</b> <u>node1</u> <u>node2</u>
              Returns a reference to the link connecting nodes <u>node1</u> and <u>node2.</u>  This is useful for setting link
              configuration parameters and to invoke tracing methods (see LINK OBJECTS section).

       <b>$ns</b> <b>queue-limit</b> <u>node1</u> <u>node2</u> <u>queue-limit</u>
              Set the maximum number of packets that can be queued on the link in the direction  from  <u>node1</u>  to
              <u>node2</u> to <u>queue-limit.</u>  The link between node1 and node2 should have already been created.

       <b>$ns</b> <b>delay</b> <u>node1</u> <u>node2</u> <u>time-interval</u>
              Set  the  latency  of the link in the direction from <u>node1</u> to <u>node2</u> to <u>time-interval</u> seconds.  The
              link between node1 and node2 should have already been created.

       <b>$ns</b> <b>cost</b>  <u>node1</u> <u>node2</u> <u>cost-val</u>
              Assign the cost <u>cost-val</u> to the link between nodes <u>node1</u> and <u>node2.</u>  The costs assigned  to  links
              are used in unicast route computations.  All the links default to a cost of 1.

       <b>$ns</b> <b>multi-link</b> <u>node-list</u> <u>bw</u> <u>delay</u> <u>type</u>
              Connects  the nodes specified in <u>node-list</u> by a mesh of duplex links (to simulate a broadcast LAN)
              with bandwidth <u>bw</u> in bits per second and link propagation delay <u>delay</u> in seconds.  <u>node-list</u> is  a
              list  of  node  object  handles that have already been created with the <u>node</u> method.  <u>bw</u> and <u>delay</u>
              default to 1.5 Mbits/sec and 100 ms respectively.  The defaults can be changed  by  modifying  the
              relevant  configuration  parameters  of the DelayLink Object (see DELAYLINK OBJECTS section).  The
              queuing discipline of the link is specified by <u>type,</u> which may be <b>DropTail,</b> <b>FQ</b> <b>SFQ,</b> <b>DRR,</b> <b>RED,</b> <b>CBQ,</b>
              or <b>CBQ/WRR.</b>  A DropTail link is a simple FIFO queue which drops the last packet in the queue  when
              the  queue  overflows.   A  FQ  link is for Fair Queuing (for details see [?]).  A SFQ link is for
              Stochastic Fair Queuing (for details see [?]).  A DRR link is for deficit round  robin  scheduling
              (for details see [9]).  A RED link is a random-early drop queue (for details see [2]).  A CBQ link
              is  for  class-based queuing using a packet-by-packet round-robin scheduler (for details see [3]).
              A CBQ/WRR link is for class-based queuing with a weighted round robin scheduler.

       <b>$ns</b> <b>multi-link-of-interfaces</b> <u>node-list</u> <u>bw</u> <u>delay</u> <u>type</u>
              Connects the nodes specified in <u>node-list</u> by a mesh of duplex links with interfaces (to simulate a
              broadcast LAN) with bandwidth <u>bw</u> in bits per second and link propagation delay <u>delay</u>  in  seconds.
              <u>node-list</u>  is  a  list of node object handles that have already been created with the <u>node</u> method.
              <u>bw</u> and <u>delay</u> default to 1.5 Mbits/sec and 100 ms respectively.  The defaults  can  be  changed  by
              modifying  the  relevant  configuration  parameters of the DelayLink Object (see DELAYLINK OBJECTS
              section).  The queuing discipline of the link is specified by <u>type,</u> which may be <b>DropTail,</b> <b>FQ</b> <b>SFQ,</b>
              <b>DRR,</b> <b>RED,</b> <b>CBQ,</b> or <b>CBQ/WRR.</b>  A DropTail link is a simple FIFO queue which drops the last packet  in
              the  queue  when the queue overflows.  A FQ link is for Fair Queuing (for details see [?]).  A SFQ
              link is for Stochastic Fair Queuing (for details see [?]).  A DRR link is for deficit round  robin
              scheduling  (for details see [9]).  A RED link is a random-early drop queue (for details see [2]).
              A CBQ link is for class-based queuing using a packet-by-packet round-robin scheduler (for  details
              see [3]).  A CBQ/WRR link is for class-based queuing with a weighted round robin scheduler.

       <b>new</b> <b>Agent/</b><u>type</u>
              Create an Agent of type <u>type</u> which may be:
                Null                  - Traffic Sink
                LossMonitor           - Traffic Sink that monitors loss parameters
                TCP                   - BSD Tahoe TCP
                TCP/FullTcp           - Full Reno TCP with two-way connections [11]
                TCP/Reno              - BSD Reno TCP
                TCP/Newreno           - a modified version of BSD Reno TCP
                TCP/Vegas             - Vegas TCP (from U. Arizonia via USC)
                TCP/Sack1             - BSD Reno TCP with selective ACKs
                TCP/Fack              - BSD Reno TCP with forward ACKs
                TCPSink               - standard TCP sink
                TCPSink/DelAck        - TCP sink that generates delayed ACKs
                TCPSink/Sack1         - TCP sink that generates selective ACKs
                TCPSink/Sack1/DelAck  - delayed-ack TCP sink with selective ACKs
                UDP                   - UDP Transport
                RTP                   - RTP agent
                Session/RTP           -
                RTCP                  - RTCP agent
                IVS/Source            -
                IVS/Receiver          -
                SRM                   -
              The  methods,  configuration  parameters  and  the  relevant state variables associated with these
              objects are discussed in detail in later sections.  Note that some agents e.g. TCP or SRM  do  not
              generate  their own data.  Such agents need sources attached to them to generate data (see attach-
              source and attach-traffic methods in AGENT OBJECTS section).

       <b>$ns</b> <b>attach-agent</b> <u>node</u> <u>agent</u>
              Attach the agent object <u>agent</u> to <u>node.</u>  The <u>agent</u>  and  <u>node</u>  objects  should  have  already  been
              created.

       <b>$ns</b> <b>detach-agent</b> <u>node</u> <u>agent</u>
              Detach the agent object <u>agent</u> from <u>node.</u>

       <b>$ns</b> <b>connect</b> <u>src</u> <u>dst</u>
              Establish a two-way connection between the agent <u>src</u> and the agent <u>dst.</u>  Returns the handle to <u>src</u>
              agent.   A helper method has been defined to facilitate creating and attaching an agent to each of
              two nodes and establishing a two-way connection between them.  (see BUILTINS section).

       <b>$ns</b> <b>use-scheduler</b> <u>type</u>
              Use an event scheduler of type <u>type</u> in the simulations.  <u>type</u> is  one  of  List,  Heap,  Calendar,
              RealTime.  The List scheduler is the default.  A Heap scheduler uses a heap for event queueing.  A
              Calendar  scheduler  uses a calendar queue to keep track of events.  RealTime scheduler is used in
              emulation mode when the simulator interacts with an external agent.

       <b>$ns</b> <b>at</b> <u>time</u> <u>procedure</u>
              Evaluate <u>procedure</u> at simulation time <u>time.</u>  The procedure could be a globally accessible function
              (proc) or an object method (instproc).  This command can  be  used  to  start  and  stop  sources,
              dynamically  reconfigure  the  simulator, dump statistics at specified intervals, etc.  Returns an
              event id.

       <b>$ns</b> <b>cancel</b> <u>eid</u>
              Remove the event specified by the event id <u>eid</u> from the event queue.

       <b>$ns</b> <b>now</b>
              Return the current simulation time.

       <b>$ns</b> <b>gen-map</b>
              Walks through the simulation topology and lists all the objects that have been created and the way
              they are hooked up to each other.  This is useful to debug simulation scripts.

       <b>ns-version</b>
              Return a string identifying the version of ns currently running.  This method is executed  in  the
              global context by the interpreter.

       <b>ns-random</b> <u>[</u> <u>seed</u> <u>]</u>
              If  <u>seed</u> is not present, return a pseudo-random integer between 0 and 2^31-1.  Otherwise, seed the
              pseudo-random number generator with <u>seed</u> and return the seed  used.   If  <u>seed</u>  is  0,  choose  an
              initial  seed  heuristically (which varies on successive invocations).  This method is executed in
              the global context by the interpreter.

       Ns has other facilities for random number generation; please see documentation for details [13].

</pre><h4><b>OBJECT</b> <b>HIERARCHY</b></h4><pre>
       A brief description of the object hierarchy in <u>ns</u> is presented in this section.  This description is  not
       intended  to  be  complete.   It has been provided to depict how the methods and configuration parameters
       associated with the various objects are inherited.   For  more  complete  information  see  "ns  notes  &amp;
       documentation" and the automatically generated class library information on the ns web page.

       Objects  are  associated with configuration parameters that can be dynamically set and queried, and state
       variables that can be queried (usually modified only when the  state  variables  need  to  be  reset  for
       another simulation run).

       Configuration  parameters  represent  simulation  parameters  that  are  usually  fixed during the entire
       simulation (like a link bandwidth), but can be changed dynamically if desired.  State variables represent
       values that are specific to a given object and that object's implementation.

       The following diagram depicts a portion the object hierarchy:
           Simulator
                 MultiSim
           Node
           Link
                 SimpleLink
                      CBQLink
                 DummyLink
           DelayLink
           Queue
                 DropTail
                 FQ
                 SFQ
                 DRR
                 RED
                 CBQ
                 CBQ/WRR
           QueueMonitor
                 ED
                      Flowmon
                      Flow
           rtObject
           RouteLogic
           Agent
                 rtProto
                      Static
                      Session
                      DV
                      Direct
                 Null
                 LossMonitor
                 TCP
                      FullTcp
                      Reno
                      Newreno
                      Sack1
                      Fack
                 TCPSink
                      DelAck
                      Sack1
                          DelAck
                 UDP
                 RTP
                 RTCP
                 IVS
                      Source
                      Receiver
                 SRM
                 Session
                      RTP [how is this diff from Agent/CBR/RTP]
           Appplication
                 FTP
                 Telnet
                 Traffic
                      Expoo
                      Pareto
                      CBR
                      Trace
           Integrator
           Samples

       For a complete, automatically generated, object hierarchy, see the link "class hierarchy"  (which  points
       to  <a href="http://www-sop.inria.fr/rodeo/personnel/Antoine.Clerget/ns/">http://www-sop.inria.fr/rodeo/personnel/Antoine.Clerget/ns/</a>) on the ns web pages.  (Thanks to Antoine
       Clerget for maintaining this!)

       For example, any method that is supported by a <u>TCP</u> agent is also supported by a <u>Reno</u> or  a  <u>Sack1</u>  agent.
       Default  configuration  parameters  are also inherited.  For example, <u>$tcp</u> <u>set</u> <u>window</u><b>_</b> <u>20</u> where $tcp is a
       TCP agent defines the default TCP window size for both <u>TCP</u> and <u>Reno</u> objects.

</pre><h4><b>OBJECT</b> <b>METHODS</b></h4><pre>
       The following sections document the methods, configuration parameters and state variables associated with
       the various objects as well as those to enable Network dynamics, Unicast routing, Multicast  routing  and
       Trace  and  Monitoring  support.  The object class is specified implicitly by the object variable name in
       the description.  For example, <b>$tcp</b> implies the tcp object class and all of its child classes.

</pre><h4><b>NODE</b> <b>OBJECTS</b></h4><pre>
       [NOTE: This section has not been verified to be up-to-date with the release.]

       <b>$node</b> <b>id</b>
              Returns the node id.

       <b>$node</b> <b>neighbors</b>
              Returns a list of the neighbour node objects.

       <b>$node</b> <b>attach</b> <u>agent</u>
              Attach an agent of type <u>agent</u> to this node.

       <b>$node</b> <b>detach</b> <u>agent</u>
              Detach an agent of type <u>agent</u> from this node.

       <b>$node</b> <b>agent</b> <u>port</u>
              Return a handle to the agent attached to port <u>port</u> on this node.  Returns an empty string  if  the
              port is not in use.

       <b>$node</b> <b>reset</b>
              Reset  all  agents attached to this node.  This would re-initialize the state variables associated
              with the various agents at this node.

       <b>$node</b> <b>rtObject?</b>
              Returns a handle to rtObject if there exists an instance of the object at that node.   Only  nodes
              that  take  part  in a dynamic unicast routing protocol will have this object (see UNICAST ROUTING
              METHODS and RTOBJECT OBJECTS section).

       <b>$node</b> <b>join-group</b> <u>agent</u> <u>group</u>
              Add the agent specified by the object handle <u>agent</u> to the multicast host group identified  by  the
              address <u>group.</u>  This causes the group membership protocol to arrange for the appropriate multicast
              traffic to reach this agent.  Multicast group address should be in the range 0x8000 - 0xFFFF.

       <b>$node</b> <b>allocaddr</b>
              Returns  multicast  group  address  in ascending order on each invocation starting from 0x8000 and
              ending at 0xFFFF.

       <b>$node</b> <b>shape</b> <u>shape</u>
              Set the shape of the node to "<u>shape</u>". When called before the simulator starts to run,  it  changes
              the default shape of the node in the nam trace file. The default shape of a node is """circle"""

       <b>$node</b> <b>color</b> <u>color</u>
              Set  the  color  of the node to <u>color</u>. It can be called anytime to change the current color of the
              node in nam trace file, if there is one.

       <b>$node</b> <b>get-attribute</b> <u>name</u>
              Get the specified attribute <u>name</u> of the node. Currently a Node object has  two  attributes:  <u>COLOR</u>
              and <u>SHAPE</u>. Note: these letters must be capital.

       <b>$node</b> <b>add-mark</b> <u>name</u> <u>color</u> <u>shape</u>
              Add  a  mark  (in  nam  trace  file)  with  <u>color</u>  and  <u>shape</u>  around  the  node. The shape can be
              """circle""", """hexagon""" and """square""" (case sensitive). The added mark will  be  identified
              by <u>name</u>.

       <b>$node</b> <b>delete-mark</b> <u>name</u>
              Delete the mark with <u>name</u> in the given node.

       There are no state variables or configuration parameters specific to the node class.

</pre><h4><b>LINK</b> <b>OBJECTS</b></h4><pre>
       [NOTE: This section has not been verified to be up-to-date with the release.]

       <b>$link</b> <b>trace-dynamics</b> <u>ns</u> <u>fileID</u>
              Trace  the  dynamics of this link and write the output to <u>fileID</u> filehandle.  <u>ns</u> is an instance of
              the Simulator or MultiSim object that  was  created  to  invoke  the  simulation  (see  TRACE  AND
              MONITORING METHODS section for the output trace format).

       <b>$link</b> <b>trace-callback</b> <u>ns</u> <u>cmd</u>
              Trace  all  packets  on  the  link  with  the  callback  <u>cmd</u>.  Cmd is invoked for each trace event
              (enqueue, dequeue, drop) with the text that would be logged as parameters.  (See  the  description
              of  the  log  file  for  this  information.)   A  demo  of  trace  callbacks  is  in  the  program
              tcl/ex/callback_demo.tcl in the distribution.

       <b>$link</b> <b>color</b> <u>color</u>
              Set the color of the Link object. It can be called anytime to change the current color of the link
              in nam trace file, if there is one.

       <b>$link</b> <b>get-attribute</b> <u>name</u>
              Get the specified attribute <u>name</u> of the Link. Currently a Link object has three attributes: <u>COLOR</u>,
              <u>ORIENTATION</u>, and <u>QUEUE_POS</u>.

       Currently the following two functions should not be directly  called.  Use  <b>$ns</b>  <b>duplex-link-op</b>  instead.
       Refer to the corresponding section in this man page.

       <b>$link</b> <b>orient</b> <u>ori</u>
              Set the orientation of the link to <u>ori</u>. When called before the simulator starts to run, it changes
              the  default  orientation  of  the  link  in  nam  trace  file, if there is one. If orientation is
              unspecified for any link(s), nam will use automatic layout. The  default  orientation  of  a  Link
              object is unspecified.

       <b>$link</b> <b>queuePos</b> <u>pos</u>
              Set  the  queue  position  of  the link to <u>pos</u>. When called before the simulator starts to run, it
              changes the default queue placement of the simplex link in nam trace file, if there  is  one.  <u>pos</u>
              specifies  the  angle  between the horizontal line and the line along which queued packets will be
              displayed.

</pre><h4><b>SIMPLELINK</b> <b>OBJECTS</b></h4><pre>
       [NOTE: This section has not been verified to be up-to-date with the release.]

       <b>$link</b> <b>cost</b> <u>cost-val</u>
              Make <u>cost-val</u> the cost of this link.

       <b>$link</b> <b>cost?</b>
              Return the cost of this link.

       Any configuration parameters or state variables?

</pre><h4><b>DELAYLINK</b> <b>OBJECTS</b></h4><pre>
       [NOTE: This section has not been verified to be up-to-date with  the  release.]   The  DelayLink  Objects
       determine  the  amount of time required for a packet to traverse a link.  This is defined to be size/bw +
       delay where size is the packet size, bw is the link bandwidth and delay is the  link  propagation  delay.
       There are no methods or state variables associated with this object.

       <b>Configuration</b> <b>Parameters</b>

              <u>bandwidth</u><b>_</b>
                     Link bandwidth in bits per second.

              <u>delay</u><b>_</b> Link propagation delay in seconds.

              There are no state variables associated with this object.

</pre><h4><b>NETWORK</b> <b>DYNAMICS</b> <b>METHODS</b></h4><pre>
       This  section  describes  methods to make the links and nodes in the topology go up and down according to
       various distributions.  A dynamic routing protocol should generally be used whenever a simulation  is  to
       be done with network dynamics.  Note that a static topology model is the default in ns.

       <b>$ns</b> <b>rtmodel</b> <u>model</u> <u>model-params</u> <u>node1</u> <u>[node2]</u>
              Make  the  link  between  <u>node1</u> and <u>node2</u> change between up and down states according to the model
              <u>model.</u>  In case only <u>node1</u> is specified all the links incident on the node would be brought up and
              down according to the specified <u>model.</u>  <u>model-params</u> contains  the  parameters  required  for  the
              relevant  model  and  is to be specified as a list i.e. the parameters are to be enclosed in curly
              brackets.  <u>model</u> can be one of <u>Deterministic,</u> <u>Exponential,</u> <u>Manual,</u> <u>Trace.</u>  Returns a handle  to  a
              model object corresponding to the specified <u>model.</u>

              In  the  Deterministic model <u>model-params</u> is <u>[start-time]</u> <u>up-interval</u> <u>down-interval</u> <u>[finish-time].</u>
              Starting from <u>start-time</u> the link is made up for  <u>up-interval</u>  and  down  for  <u>down-interval</u>  till
              <u>finish-time</u>  is  reached.  The default values for start-time, up-interval, down-interval are 0.5s,
              2.0s, 1.0s respectively.  finish-time defaults to the  end  of  the  simulation.   The  start-time
              defaults to 0.5s in order to let the routing protocol computation quiesce.

              If  the  Exponential model is used <u>model-params</u> is of the form <u>up-interval</u> <u>down-interval</u> where the
              link up-time is an exponential distribution around the mean <u>up-interval</u> and the link down-time  is
              an  exponential  distribution  around  the mean <u>down-interval.</u>  Default values for <u>up-interval</u> and
              <u>down-interval</u> are 10s and 1s respectively.

              If the Manual distribution is used <u>model-params</u> is <u>at</u> <u>op</u> where <u>at</u> specifies the time at which  the
              operation  <u>op</u>  should  occur.   <u>op</u> is one of <u>up,</u> <u>down.</u>  The Manual distribution could be specified
              alternately using the <u>rtmodel-at</u> method described later in the section.

              If Trace is specified as the <u>model</u> the link/node dynamics is read from a  Tracefile.   The  <u>model-</u>
              <u>params</u>  argument  would  in  this  case  be the file-handle of the Tracefile that has the dynamics
              information.  The tracefile format is identical to  the  trace  output  generated  by  the  trace-
              dynamics link method (see TRACE AND MONITORING METHODS SECTION).

       <b>$ns</b> <b>rtmodel-delete</b> <u>model-handle</u>
              Delete the instance of the route model specified by <u>model-handle.</u>

       <b>$ns</b> <b>rtmodel-at</b> <u>at</u> <u>op</u> <u>node1</u> <u>[node2]</u>
              Used to specify the up and down times of the link between nodes <u>node1</u> and <u>node2.</u>  If only <u>node1</u> is
              given  all  the  links incident on <u>node1</u> will be brought up and down.  <u>at</u> is the time at which the
              operation <u>op</u> that can be either <u>up</u> or <u>down</u> is to be performed on the specified link(s).

</pre><h4><b>QUEUE</b> <b>OBJECTS</b></h4><pre>
       A queue object is a general class of object capable of holding and possibly marking or discarding packets
       as they travel through the simulated topology.

       <b>Configuration</b> <b>Parameters</b>

              <u>limit</u><b>_</b> The queue size in packets.

              <u>blocked</u><b>_</b>
                     Set to false by default, this is true if the queue is blocked (unable to send a  packet  to
                     its downstream neighbor).

              <u>unblock_on_resume</u><b>_</b>
                     Set to true by default, indicates a queue should unblock itself at the time the last packet
                     packet sent has been transmitted (but not necessarily received).

</pre><h4><b>DROP-TAIL</b> <b>OBJECTS</b></h4><pre>
       Drop-tail objects are a subclass of Queue objects that implement simple FIFO queue.  There are no methods
       that  are specific to drop-tail objects.  The only configuration parameter is <u>drop-front</u><b>_</b>, which when set
       to true causes the queue to behave as a drop-from-front queueing discipline.  This  variable  is  set  to
       false by default.

</pre><h4><b>FQ</b> <b>OBJECTS</b></h4><pre>
       FQ  objects  are  a subclass of Queue objects that implement Fair queuing.  There are no methods that are
       specific to FQ objects.

       <b>Configuration</b> <b>Parameters</b>

              <u>secsPerByte</u><b>_</b>

              There are no state variables associated with this object.

</pre><h4><b>SFQ</b> <b>OBJECTS</b></h4><pre>
       SFQ objects are a subclass of Queue objects that implement Stochastic Fair queuing.  There are no methods
       that are specific to SFQ objects.

       <b>Configuration</b> <b>Parameters</b>

              <u>maxqueue</u><b>_</b>

              <u>buckets</u><b>_</b>

              There are no state variables associated with this object.

</pre><h4><b>DRR</b> <b>OBJECTS</b></h4><pre>
       DRR objects are a subclass of Queue objects that implement deficit round robin scheduling. These  objects
       implement  deficit  round  robin  scheduling amongst different flows ( A particular flow is one which has
       packets with the same node and port id OR packets which have the same node id alone). Also  unlike  other
       multi-queue objects, this queue object implements a single shared buffer space for its different flows.

       <b>Configuration</b> <b>Parameters</b>

              <u>buckets</u><b>_</b>
                     Indicates the total number of buckets to be used for hashing each of the flows.

              <u>blimit</u><b>_</b>
                     Indicates the shared buffer size in bytes.

              <u>quantum</u><b>_</b>
                     Indicates (in bytes) how much each flow can send during its turn.

              <u>mask</u><b>_</b>  mask_, when set to 1, means that a particular flow consists of packets having the same node
                     id  (and possibly different port ids), otherwise a flow consists of packets having the same
                     node and port ids.

</pre><h4><b>RED</b> <b>OBJECTS</b></h4><pre>
       RED objects are a subclass of Queue objects that implement random early-detection gateways.   The  object
       can  be  configured  to  either  drop or ``mark'' packets.  There are no methods that are specific to RED
       objects.

       <b>Configuration</b> <b>Parameters</b>

              <u>bytes</u><b>_</b> Set to "true" to enable ``byte-mode'' RED, where the size of arriving  packets  affect  the
                     likelihood of marking (dropping) packets.

              <u>queue-in-bytes</u><b>_</b>
                     Set  to  "true"  to  measure the average queue size in bytes rather than packets.  Enabling
                     this option also causes <u>thresh</u><b>_</b> and <u>maxthresh</u><b>_</b> to be automatically scaled by  <u>mean_pktsize</u><b>_</b>
                     (see below).

              <u>thresh</u><b>_</b>
                     The minimum threshold for the average queue size in packets.

              <u>maxthresh</u><b>_</b>
                     The maximum threshold for the average queue size in packets.

              <u>mean_pktsize</u><b>_</b>
                     A  rough  estimate  of  the  average packet size in bytes.  Used in updating the calculated
                     average queue size after an idle period.

              <u>q_weight</u><b>_</b>
                     The queue weight, used in the  exponential-weighted  moving  average  for  calculating  the
                     average queue size.

              <u>wait</u><b>_</b>  Set to true to maintain an interval between dropped packets.

              <u>linterm</u><b>_</b>
                     As  the  average  queue size varies between "thresh_" and "maxthresh_", the packet dropping
                     probability varies between 0 and "1/linterm".

              <u>setbit</u><b>_</b>
                     Set to "true" to mark packets by setting the congestion indication bit  in  packet  headers
                     rather than drop packets.

              <u>drop-tail</u><b>_</b>
                     Set  to  true  to  use  drop-tail rather than random-drop or drop-from-front when the queue
                     overflows or the average queue size exceeds "maxthresh_".  This is  the  default  behavior.
                     For a further explanation of these variables, see [2].

              <u>drop-rand</u><b>_</b>
                     Set  to  true  to  use  random-drop rather than drop-tail or drop-from-front when the queue
                     overflows or the average queue size exceeds "maxthresh_".

              <u>drop-front</u><b>_</b>
                     Set to true to use drop-from-front rather than drop-tail or  random  drop  when  the  queue
                     overflows or the average queue size exceeds "maxthresh_".

              <u>ns1-compat</u><b>_</b>
                     Set  to true to avoid resetting the count since the last packet drop, after a forced packet
                     is dropped.  This gives compatibility with previous behavior of RED.  The default is set to
                     false.

              entle_ Set to true to increase the packet drop rate slowly from max_p to 1 as  the  average  queue
                     size  ranges  from  maxthresh  to  twice maxthresh.  The default is set to false, and max_p
                     increases abruptly from max_p to 1 when the average queue size exceeds maxthresh.

              <b>State</b> <b>Variables</b>
                     None of the state variables of the RED implementation are accessible.

</pre><h4><b>CBQ</b> <b>OBJECTS</b></h4><pre>
       CBQ objects are a subclass of Queue objects that implement class-based queueing.

       <b>$cbq</b> <b>insert</b> <b>$class</b>
              Insert traffic class <u>class</u> into the link-sharing structure associated with link object <u>cbq.</u>

       <b>$cbq</b> <b>bind</b> <b>$cbqclass</b> <b>$id1</b> <b>[$id2]</b>
              Cause packets containing flow id <u>$id1</u> (or those in  the  range  <u>$id1</u>  to  <u>$id2</u>  inclusive)  to  be
              associated with the traffic class <u>$cbqclass.</u>

       <b>$cbq</b> <b>algorithm</b> <b>$alg</b>
              Select  the  CBQ  internal algorithm.  <u>$alg</u> may be set to one of: "ancestor-only", "top-level", or
              "formal".

</pre><h4><b>CBQ/WRR</b> <b>OBJECTS</b></h4><pre>
       CBQ/WRR objects are a subclass of CBQ  objects  that  implement  weighted  round-robin  scheduling  among
       classes  of  the  same  priority  level.  In contrast, CBQ objects implement packet-by-packet round-robin
       scheduling among classes of the same priority level.

       <b>Configuration</b> <b>Parameters</b>

              <u>maxpkt</u><b>_</b>
                     The maximum size of a packet in bytes.  This is used only by CBQ/WRR objects  in  computing
                     maximum bandwidth allocations for the weighted round-robin scheduler.

</pre><h4><b>CBQCLASS</b> <b>OBJECTS</b></h4><pre>
       CBQClass objects implement the traffic classes associated with CBQ objects.

       <b>$cbqclass</b> <b>setparams</b> <u>parent</u> <u>okborrow</u> <u>allot</u> <u>maxidle</u> <u>prio</u> <u>level</u> <u>extradelay</u>
              Sets several of the configuration parameters for the CBQ traffic class (see below).

       <b>$cbqclass</b> <b>parent</b> <b>[$cbqcl|none]</b>
              specify  the  parent  of  this  class  in  the  link-sharing tree.  The parent may be specified as
              ``none'' to indicate this class is a root.

       <b>$cbqclass</b> <b>newallot</b> <b>$a</b>
              Change the link allocation of this class to the specified amount (in range 0.0 to 1.0).  Note that
              only the specified class is affected.

       <b>$cbqclass</b> <b>install-queue</b> <b>$q</b>
              Install a Queue object into the compound CBQ or CBQ/WRR link structure.   When  a  CBQ  object  is
              initially created, it includes no internal queue (only a packet classifier and scheduler).

       <b>Configuration</b> <b>Parameters</b>

              <b>okborrow_</b>
                     is a boolean indicating the class is permitted to borrow bandwidth from its parent.

              <b>allot_</b> is the maximum fraction of link bandwidth allocated to the class expressed as a real number
                     between 0.0 and 1.0.

              <b>maxidle_</b>
                     is  the  maximum  amount  of time a class may be required to have its packets queued before
                     they are permitted to be forwarded

              <b>priority_</b>
                     is the class' priority level with respect to other classes.  This value may range from 0 to
                     10, and more than one class may exist at the same priority.   Priority  0  is  the  highest
                     priority.

              <b>level_</b> is the level of this class in the link-sharing tree.  Leaf nodes in the tree are considered
                     to be at level 1; their parents are at level 2, etc.

              <b>extradelay_</b>
                     increase the delay experienced by a delayed class by the specified number of seconds.

</pre><h4><b>QUEUEMONITOR</b> <b>Objects</b></h4><pre>
       QueueMonitor  Objects  are used to monitor a set of packet and byte arrival, departure and drop counters.
       It also includes support for aggregate statistics such as  average  queue  size,  etc.   [see  TRACE  AND
       MONITORING METHODS].

       <b>$queuemonitor</b> <b>reset</b>
              reset  all  the  cumulative  counters  described  below (arrivals, departures, and drops) to zero.
              Also, reset the integrators and delay sampler, if defined.

       <b>$queuemonitor</b> <b>set-delay-samples</b> <u>delaySamp</u><b>_</b>
              Set up the Samples object <u>delaySamp</u><b>_</b> to record statistics about queue  delays.   <u>delaySamp</u><b>_</b>  is  a
              handle to a Samples object i.e the Samples object should have already been created.

       <b>$queuemonitor</b> <b>get-bytes-integrator</b>
              Returns  an  Integrator  object  that can be used to find the integral of the queue size in bytes.
              (see Integrator Objects section).

       <b>$queuemonitor</b> <b>get-pkts-integrator</b>
              Returns an Integrator object that can be used to find the integral of the queue size  in  packets.
              (see Integrator Objects section).

       <b>$queuemonitor</b> <b>get-delay-samples</b>
              Returns  a  Samples object <u>delaySamp</u><b>_</b> to record statistics about queue delays (see Samples Objects
              section).

       There are no configuration parameters specific to this object.

       <b>State</b> <b>Variables</b>

              <u>size</u><b>_</b>  Instantaneous queue size in bytes.

              <u>pkts</u><b>_</b>  Instantaneous queue size in packets.

              <u>parrivals</u><b>_</b>
                     Running total of packets that have arrived.

              <u>barrivals</u><b>_</b>
                     Running total of bytes contained in packets that have arrived.

              <u>pdepartures</u><b>_</b>
                     Running total of packets that have departed (not dropped).

              <u>bdepartures</u><b>_</b>
                     Running total of bytes contained in packets that have departed (not dropped).

              <u>pdrops</u><b>_</b>
                     Total number of packets dropped.

              <u>bdrops</u><b>_</b>
                     Total number of bytes dropped.

              <u>bytesInt</u><b>_</b>
                     Integrator object that computes the integral of the queue size in bytes.  The <u>sum</u><b>_</b> variable
                     of this object has the running sum (integral) of the queue size in bytes.

              <u>pktsInt</u><b>_</b>
                     Integrator object that computes the integral of  the  queue  size  in  packets.   The  <u>sum</u><b>_</b>
                     variable of this object has the running sum (integral) of the queue size in packets.

</pre><h4><b>QUEUEMONITOR/ED</b> <b>Objects</b></h4><pre>
       This  derived  object  is  capable of differentiating regular packet drops from <u>early</u> drops.  Some queues
       distinguish regular drops (e.g. drops due to buffer exhaustion) from other drops (e.g.  random  drops  in
       RED queues).  Under some circumstances, it is useful to distinguish these two types of drops.

       <b>State</b> <b>Variables</b>

              <u>epdrops</u><b>_</b>
                     The number of packets that have been dropped ``early''.

              <u>ebdrops</u><b>_</b>
                     The number of bytes comprising packets that have been dropped ``early''

       <b>Note:</b>  because  this  class  is a subclass of QueueMonitor, objects of this type also have fields such as
       pdrops_ and bdrops_.  These fields describe the <u>total</u> number of dropped packets and bytes, including both
       early and non-early drops.

</pre><h4><b>QUEUEMONITOR/ED/FLOWMON</b> <b>Objects</b></h4><pre>
       These objects may be used in the place of a conventional QueueMonitor object when wishing to collect per-
       flow counts and statistics in addition to the aggregate counts  and  statistics  provided  by  the  basic
       QueueMonitor.

       <b>$fmon</b> <b>classifier</b> <b>[$cl]</b>
              insert  (read)  the specified classifier into (from) the flow monitor object.  This is used to map
              incoming packets to which flows they are associated with.

       <b>$fmon</b> <b>dump</b>
              Dump the current per-flow counters and statistics to the  I/O  channel  specified  in  a  previous
              attach operation.

       <b>$fmon</b> <b>flows</b>
              Return  a  character  string  containing the names of all flow objects known by this flow monitor.
              Each of these objects are of type QueueMonitor/ED/Flow.

       <b>$fmon</b> <b>attach</b> <b>$chan</b>
              Attach a tcl I/O channel to the flow monitor.  Flow statistics are written to the channel when the
              dump operation is executed.

       <b>Configuration</b> <b>Parameters</b>

              <b>enable_in_</b>
                     Set to true by default, indicates that per-flow arrival state should be kept  by  the  flow
                     monitor.  If set to false, only the aggregate arrival information is kept.

              <b>enable_out_</b>
                     Set  to true by default, indicates that per-flow departure state should be kept by the flow
                     monitor.  If set to false, only the aggregate departure information is kept.

              <b>enable_drop_</b>
                     Set to true by default, indicates that per-flow drop state  should  be  kept  by  the  flow
                     monitor.  If set to false, only the aggregate drop information is kept.

              <b>enable_edrop_</b>
                     Set to true by default, indicates that per-flow early drop state should be kept by the flow
                     monitor.  If set to false, only the aggregate early drop information is kept.

</pre><h4><b>QUEUEMONITOR/ED/FLOW</b> <b>Objects</b></h4><pre>
       These  objects  contain per-flow counts and statistics managed by a QUEUEMONITOR/ED/FLOWMON object.  They
       are generally created in an OTcl callback procedure when a flow monitor is given a packet it  cannot  map
       on  to a known flow.  Note that the flow monitor's classifier is responsible for mapping packets to flows
       in some arbitrary way.  Thus, depending on the type of classifier used, not all of  the  state  variables
       may  be  relevant  (e.g.  one  may  classify  packets based only on flow id, in which case the source and
       destination addresses may not be significant).

       <b>State</b> <b>Variables</b>

              <b>src_</b>   The source address of packets belonging to this flow.

              <b>dst_</b>   The destination address of packets belonging to this flow.

              <b>flowid_</b>
                     The flow id of packets belonging to this flow.

</pre><h4><b>UNICAST</b> <b>ROUTING</b> <b>METHODS</b></h4><pre>
       A dynamic unicast routing protocol can be specified to run on a subset of nodes in  the  topology.   Note
       that  a  dynamic  routing  protocol  should  be generally used whenever a simulation is done with network
       dynamics.

       <b>$ns</b> <b>rtproto</b> <u>proto</u> <u>node-list</u>
              Specifies the dynamic unicast routing protocol <u>proto</u> to be run on the  nodes  specified  by  <u>node-</u>
              <u>list.</u>  Currently <u>proto</u> can be one of Static, Session, DV.  Static routing is the default.  Session
              implies that the unicast routes over the entire topology are instantaneously recomputed whenever a
              link  goes  up  or  down.   DV  implies  that  a  simple distance vector routing protocol is to be
              simulated.  <u>node-list</u> defaults to all the nodes in the topology.

       <b>$ns</b> <b>compute-routes</b>
              Compute routes between all the nodes in the topology.  This can be used if static routing is  done
              and  the  routes  have  to  be  recomputed  as the state of a link has changed.  Note that Session
              routing (see <u>rtproto</u> method above) will recompute routes automatically whenever the state  of  any
              link in the topology changes.

       <b>$ns</b> <b>get-routelogic</b>
              Returns an handle to a RouteLogic object that has methods for route table lookup etc.

</pre><h4><b>ROUTELOGIC</b> <b>OBJECTS</b></h4><pre>
       <b>$routelogic</b> <b>lookup</b> <u>srcid</u> <u>destid</u>
              Returns  the  id  of the node that is the next hop from the node with id <u>srcid</u> to the node with id
              <u>destid.</u>

       <b>$routelogic</b> <b>dump</b> <u>nodeid</u>
              Dump the routing tables of all nodes whose id  is  less  than  <u>nodeid.</u>   Node  ids  are  typically
              assigned to nodes in ascending fashion starting from 0 by their order of creation.

</pre><h4><b>RTOBJECT</b> <b>OBJECTS</b></h4><pre>
       Every  node  that takes part in a dynamic unicast routing protocol will have an instance of rtObject (see
       NODE OBJECTS section for the method to get an handle to this object at a  particular  node).   Note  that
       nodes  will not have an instance of this object if Session routing is done as a detailed routing protocol
       is not being simulated in this case.

       <b>$rtobject</b> <b>dump-routes</b> <u>fileID</u>
              Dump the routing table to the output channel specified by <u>fileID.</u>  <u>fileID</u> must be  a  file  handle
              returned by the Tcl <u>open</u> command and it must have been opened for writing.

       <b>$rtobject</b> <b>rtProto?</b> <u>proto</u>
              Returns  a  handle  to  the  routing  protocol agent specified by <u>proto</u> if it exists at that node.
              Returns an empty string otherwise.

       <b>$rtobject</b> <b>nextHop?</b> <u>destID</u>
              Returns the id of the node that is the next hop to the  destination  specified  by  the  node  id,
              <u>destID.</u>

       <b>$rtobject</b> <b>rtpref?</b> <u>destID</u>

       <b>$rtobject</b> <b>metric?</b> <u>destID</u>

</pre><h4><b>MULTICAST</b> <b>ROUTING</b> <b>METHODS</b></h4><pre>
       Multicast  routing  is  enabled  by  setting Simulator EnableMcast_ variable to 1 at the beginning of the
       simulation.  Note that this variable must be set before any node, link or agent objects  are  created  in
       the  simulation.   Also  links must have been created with interface labels (see simplex-link and duplex-
       link methods in NS COMMANDS section).

       <b>$ns</b> <b>mrtproto</b> <u>proto</u> <u>node-list</u>
              Specifies the multicast routing protocol <u>proto</u> to be run on  the  nodes  specified  by  <u>node-list.</u>
              Currently  <u>proto</u>  can be one of CtrMcast, DM, detailedDM, dynamicDM, pimDM.  <u>node-list</u> defaults to
              all the nodes in the topology.  Returns an handle to a protocol-specific object that has  methods,
              configuration  parameters  specific  to that protocol.  Note that currently CtrMcastComp object is
              returned if CtrMcast is used but a null string is returned if DM, detailedDM, dynamicDM  or  pimDM
              are used.

              If  proto is 'CtrMcast' a Rendezvous Point (RP) rooted shared tree is built for a multicast group.
              The actual sending of prune, join messages etc.  to set up state at the nodes is not simulated.  A
              centralized computation agent is used  to  compute  the  fowarding  trees  and  set  up  multicast
              forwarding  state,  (*,G)  at the relevant nodes as new receivers join a group.  Data packets from
              the senders to a group are unicast to the RP.  Methods are provided  in  the  CtrMcastComp  object
              (see  CTRMCASTCOMP  OBJECTS  section)  that  is  returned by mrtproto to switch to source-specific
              trees, choose some nodes as candidate RPs etc.  When a node/link on a multicast distribution  tree
              goes down, the tree is instanteously recomputed.

              If  proto  is  'DM' DVMRP-like dense mode is simulated.  Parent-child lists are used to reduce the
              number of links over which the data packets are broadcast.  Prune messages are sent  by  nodes  to
              remove  branches  from  the  multicast forwarding tree that do not lead to any group members.  The
              prune timeout value is 0.5s by default (see DM OBJECTS section to change the default).  This  does
              not  adapt  to  network  changes.   There  is  also currently no support for proper functioning in
              topologies with LANs.

              If proto is 'detailedDM' a dense mode protocol based on Protocol  Independent  Multicast  -  Dense
              Mode  (PIM-DM)  is  simulated.   This  is  currently  the  most complete version of the dense mode
              protocol in the simulator and is recommended for use over the  other  dense  mode  protocols.   It
              adapts to network dynamics and functions correctly in topologies with LANs (where LANs are created
              using  the  multi-link-of-interfaces  method  -  see  NS  COMMANDS).   In  case there are multiple
              potential forwarders for a LAN, the node with the highest id is chosen as the forwarder  (this  is
              done  through the Assert mechanism).  The default values for the prune timeout, interface deletion
              timeout (used for LANs) and graft retransmission timeout are 0.5s, 0.1s  and  0.05s  respectively.
              (see Prune/Iface/Timer, Deletion/Iface/Timer and GraftRtx/Timer objects respectively to change the
              default values and for more information about the timers).

              If  proto  is  'dynamicDM'  DVMRP-like  dense  mode  protocol  that  adapts  to network changes is
              simulated.  'Poison-reverse' information (i.e. the information that a particular neighbouring node
              uses this node to reach a particular network) is read from  the  routing  tables  of  neighbouring
              nodes  in  order  to  adapt  to network dynamics (DVMRP runs its own unicast routing protocol that
              exchanges this information).  The current implementation does not support  proper  functioning  in
              topologies  with  LANs.   The  prune  timeout  value is 0.5s by default (see DM OBJECTS section to
              change the default).

              If proto is 'pimDM' Protocol Independent Multicast - Dense mode is simulated.  In  this  case  the
              data  packets  are broadcast over all the outgoing links except the incoming link.  Prune messages
              are sent by nodes to remove the branches of the multicast forwarding tree that do not lead to  any
              group members.  The current implementation does not adapt to network dynamics and does not support
              proper  functioning  in  topologies with LANs.  The prune timeout value is 0.5s by default (see DM
              OBJECTS section to change the default).

</pre><h4><b>CTRMCASTCOMP</b> <b>OBJECTS</b></h4><pre>
       A handle to the CtrMcastComp object is returned when the protocol is specified as 'CtrMcast' in mrtproto.

       <b>$ctrmcastcomp</b> <b>switch-treetype</b> <u>group-addr</u>
              Switch from the Rendezvous Point rooted  shared  tree  to  source-specific  trees  for  the  group
              specified  by  <u>group-addr.</u>   Note  that  this method cannot be used to switch from source-specific
              trees back to a shared tree for a multicast group.

       <b>$ctrmcastcomp</b> <b>set_c_rp</b> <u>node-list</u>
              Make all the nodes specified in <u>node-list</u> as candidate RPs and change the state of all  the  other
              nodes  to  not be candidate RPs.  Note that all nodes are candidate RPs by default.  Currently the
              node with the highest node id serves as the RP for all multicast groups.  This  method  should  be
              invoked before any source starts sending packets to the group or any receiver joins the group.

       <b>$ctrmcastcomp</b> <b>get_rp</b> <u>node</u> <u>group</u>
              Returns  the RP for the group as seen by the node <u>node</u> for the multicast group with address <u>group-</u>
              <u>addr.</u>  Note that different nodes may see different RPs for the group if the network is partitioned
              as the nodes might be in different partitions.

</pre><h4><b>DM</b> <b>OBJECTS</b></h4><pre>
       DM Objects implement DVMRP style densemode multicast where parent-child lists  are  used  to  reduce  the
       number  of  links over which initial data packets are broadcast.  There are no methods or state variables
       specific to this object.

       <b>Configuration</b> <b>parameters</b>

              <u>PruneTimeout</u>

              Timeout value for the prune state at nodes.

</pre><h4><b>PRUNE/IFACE/TIMER</b> <b>OBJECTS</b></h4><pre>
       The Prune/Iface/Timer objects are used to implement the prune timer for detailedDM.  There are no methods
       or state variables specific to this object.

       <b>Configuration</b> <b>parameters</b>

              <u>timeout</u>

              Timeout value for the prune state at nodes.

</pre><h4><b>DELETION/IFACE/TIMER</b> <b>OBJECTS</b></h4><pre>
       The Deletion/Iface/Timer objects are used to implement the interface deletion timer that are required for
       correct functioning at nodes that are part of LANs.  If a node has a LAN as its  incoming  interface  for
       packets  from  a  certain source and it does not have any downstream members it sends out a prune message
       onto the LAN.  Any node that has the LAN as its incoming interface for the same source and has downstream
       members on hearing the prune message sent on the LAN.  will send a join message onto the LAN.   When  the
       node  that  is  acting  as  the  forwarder  for the LAN hears the prune message from the LAN, it does not
       immediately prune off the LAN as its outgoing interface.  Instead it starts an interface  deletion  timer
       for  the outgoing interface.  The forwarder will remove the LAN as its outgoing interface only if it does
       not receive any join messages from the LAN before its deletion timer expires.  There are  no  methods  or
       state variables specific to this object.

       <b>Configuration</b> <b>parameters</b>

              <u>timeout</u>

              Timeout value for the interface deletion timer.

</pre><h4><b>GRAFTRTX/TIMER</b> <b>OBJECTS</b></h4><pre>
       The  GraftRtx/Timer  objects  are  used to implement the graft retransmission timer at nodes.  This is to
       ensure the reliability of grafts sent upstream by a node.

       <b>Configuration</b> <b>parameters</b>

              <u>timeout</u>

              Timeout value for the graft retransmission timer.

</pre><h4><b>AGENT</b> <b>OBJECTS</b></h4><pre>
       [NOTE: This section has not been verified to be up-to-date with the release.]

       <b>$agent</b> <b>port</b>
              Return the transport-level port of the agent.  Ports are used to identify agents within a node.

       <b>$agent</b> <b>dst-addr</b>
              Return the address of the destination node this agent is connected to.

       <b>$agent</b> <b>dst-port</b>
              Return the port at the destination node that this agent is connected to.

       <b>$agent</b> <b>attach-source</b> <u>type</u>
              Install a data source of type <u>type</u> in this agent.  <u>type</u> is one of FTP  or  bursty[???].   See  the
              corresponding object methods for information on configuration parameters.  Returns a handle to the
              source object.

       <b>$agent</b> <b>attach-traffic</b> <u>traffic-object</u>
              Attach <u>traffic-object</u> to this agent <u>traffic-object</u> is an instance of Traffic/Expoo, Traffic/Pareto
              or  Traffic/Trace.   Traffic/Expoo  generates traffic based on an Exponential On/Off distribution.
              Traffic/Pareto generates traffic based on a Pareto On/Off distribution.   Traffic/Trace  generates
              traffic  from  a  trace file.  The relevant configuration parameters for each of the above objects
              can be found in the TRAFFIC METHODS section.

       <b>$agent</b> <b>connect</b> <u>addr</u> <u>port</u>
              Connect this agent to the agent identified by the address <u>addr</u> and port <u>port.</u>  This causes packets
              transmitted from this agent to contain the address and port indicated, so that  such  packets  are
              routed to the intended agent.  The two agents must be compatible (e.g., a tcp-source/tcp-sink pair
              as opposed a cbr/tcp-sink pair).  Otherwise, the results of the simulation are unpredictable.

       <b>Configuration</b> <b>Parameters</b>

              <u>dst</u><b>_</b>   Address of destination that the agent is connected to. Currently 32 bits with the higher 24
                     bits the destination node ID and the lower 8 bits being the port number.

              There are no state variables specific to the generic agent class.

</pre><h4><b>NULL</b> <b>OBJECTS</b></h4><pre>
       [NOTE:  This  section  has  not  been  verified  to  be up-to-date with the release.]  Null objects are a
       subclass of agent objects that implement a traffic sink.  They inherit all of the  generic  agent  object
       functionality.   There  are  no  methods,  configuration  parameters  or state variables specific to this
       object.

</pre><h4><b>LOSSMONITOR</b> <b>OBJECTS</b></h4><pre>
       [NOTE: This section has not been verified to be up-to-date with the release.]  LossMonitor objects are  a
       subclass  of  agent  objects that implement a traffic sink which also maintains some statistics about the
       received data e.g., number of bytes received, number of packets  lost  etc.   They  inherit  all  of  the
       generic agent object functionality.

       <b>$lossmonitor</b> <b>clear</b>
              Resets the expected sequence number to -1.

       <b>Configuration</b> <b>Parameters</b>

              There are no configuration parameters specific to this object.

       <b>State</b> <b>Variables</b>

              <u>nlost</u><b>_</b> Number of packets lost.

              <u>npkts</u><b>_</b> Number of packets received.

              <u>bytes</u><b>_</b> Number of bytes received.

              <u>lastPktTime</u><b>_</b>
                     Time at which the last packet was received.

              <u>expected</u><b>_</b>
                     The expected sequence number of the next packet.

</pre><h4><b>TCP</b> <b>OBJECTS</b></h4><pre>
       TCP  objects  are  a  subclass  of  agent  objects that implement the BSD Tahoe TCP transport protocol as
       described in [7].  They inherit all of the generic agent functionality.

       To trace TCP parameters, mark each parameter with ``$tcp trace window_'' and then send the  output  to  a
       trace file with ``$tcp attach [open trace.tr w]''.

       Tcp  segments  can  be  sent  with  the advance and advanaceby commands.  When all data is sent, the done
       method will be invoked (which can be overridden in OTcl).

       <b>$tcp</b> <b>advance</b> <b>n</b>
              Send up to the nth packets.

       <b>$tcp</b> <b>advanceby</b> <b>n</b>
              Send n more packets.

       <b>$tcp</b> <b>done</b>
              Functional called when all packets (specified by advance/advanceby/maxpkts_) have been sent.   Can
              be overriden on a per-object basis.

              <b>Configuration</b> <b>Parameters</b>

              <u>window</u><b>_</b>
                     The upper bound on the advertised window for the TCP connection (in packets).

              <u>maxcwnd</u><b>_</b>
                     The  upper  bound  on the congestion window for the TCP connection.  Set to zero to ignore.
                     (This is the default.)  Measured in packets.

              <u>windowInit</u><b>_</b>
                     The initial size of the congestion window on slow-start.  (in packets).

              <u>wnd_init_option</u><b>_</b>
                     The algorithm used for determining the initial size of the congestion window.  Set to 1 for
                     a static algorithm using the value in <u>windowInit</u><b>_</b>.  Set to 2 for a dynamic algorithm  using
                     a function of <u>packetSize</u><b>_</b>.

              <u>syn</u><b>_</b>   Set to true to model the initial SYN/ACK exchange in one-way TCP.  Set to false as default.

              <u>delay_growth</u><b>_</b>
                     Set to true to delay the initial congestion window until after one packet has been sent and
                     acked.  Set to false as default.

              <u>windowOption</u><b>_</b>
                     The  algorithm  to  use  for  managing the congestion window in linear phase.  The standard
                     algorithm is 1 (the default).  Other experimental algorithms are documented in  the  source
                     code.

              <u>windowThresh</u><b>_</b>
                     Gain  constant  to  exponential  averaging  filter  used  to compute <u>awnd</u> (see below).  For
                     investigations of different window-increase algorithms.

              <u>overhead</u><b>_</b>
                     The range (in seconds) of a uniform random variable used to delay each output packet.   The
                     idea is to insert random delays at the source in order to avoid phase effects, when desired
                     [4].   This  has  only  been implemented for the Tahoe ("tcp") version of tcp, not for tcp-
                     reno.  This is not intended to be a realistic model of CPU processing overhead.

              <u>ecn</u><b>_</b>   Set to true to use explicit congestion notification in addition to packet drops  to  signal
                     congestion.   This  allows  a  Fast  Retransmit  after  a  quench() due to an ECN (explicit
                     congestion notification) bit.

              <u>packetSize</u><b>_</b>
                     The size in bytes to use for all packets from this source.

              <u>tcpip_base_hdr_size</u><b>_</b>
                     The size in bytes of the base TCP/IP header.

              <u>tcpTick</u><b>_</b>
                     The TCP clock granularity for measuring roundtrip times.  Note that it is set by default to
                     the non-standard value of 100ms.  Measured in seconds.

              <u>bugFix</u><b>_</b>
                     Set to true to remove a bug when multiple fast retransmits are allowed for packets  dropped
                     in a single window of data.

              <u>maxburst</u><b>_</b>
                     Set  to  zero to ignore.  Otherwise, the maximum number of packets that the source can send
                     in response to a single incoming ACK.

              <u>slow_start_restart</u><b>_</b>
                     Boolean; set to 1 to slow-start after the connection goes idle.  On by default.

              <u>srtt_init</u><b>_</b>
                     Initial value for the smoothed roundtrip time estimate.  Default is 0 seconds.

              <u>t_rttvar</u><b>_</b>
                     Initial value for the variance in roundtrip time.  Default is 3 seconds.

              <u>rtxcur_init</u><b>_</b>
                     Initial value for the retransmit value.  Default is 6 seconds.

              <u>T_SRTT_BITS</u>
                     Exponent of weight for updating the smoothed round-trip time t_srtt_.  Default is 3, for  a
                     weight of 1/2^T_SRTT_BITS or 1/8.

              <u>T_RTTVAR_BITS</u>
                     Exponent  of weight for updating variance in round-trip time, t_rttvar_.  Default is 2, for
                     a weight of 1/2^T_RTTVAR_BITS or 1/4.

              <u>rttvar_exp</u><b>_</b>
                     Exponent of multiple of the mean deviation in  calculating  the  current  retransmit  value
                     t_rtxcur_.  Default is 2, for a multiple of 2^rttvar_exp_ or 4.

       <b>Defined</b> <b>Constants</b>

              <u>MWS</u>    The  Maximum  Window  Size  in packets for a TCP connection.  MWS determines the size of an
                     array in tcp-sink.cc.  The default for MWS is 1024 packets.  For Tahoe  TCP,  the  "window"
                     parameter,  representing  the receiver's advertised window, should be less than MWS-1.  For
                     Reno TCP, the "window" parameter should be less than (MWS-1)/2.

       <b>State</b> <b>Variables</b>

              <u>dupacks</u><b>_</b>
                     Number of duplicate acks seen since any new data was acknowledged.

              <u>seqno</u><b>_</b> Highest sequence number for data from data source to TCP.

              <u>t_seqno</u><b>_</b>
                     Current transmit sequence number.

              <u>ack</u><b>_</b>   Highest acknowledgment seen from receiver.

              <u>cwnd</u><b>_</b>  Current value of the congestion window (in packets).

              <u>awnd</u><b>_</b>  Current value of a low-pass filtered version of the congestion window.  For  investigations
                     of different window-increase algorithms.

              <u>ssthresh</u><b>_</b>
                     Current value of the slow-start threshold (in packets).

              <u>rtt</u><b>_</b>   Round-trip time estimate.  In seconds (expressed in multiples of tcpTick_).

              <u>srtt</u><b>_</b>  Smoothed round-trip time estimate.  In seconds (in multiples of tcpTick_/8).

              <u>rttvar</u><b>_</b>
                     Round-trip time mean deviation estimate.

              <u>t_rtxcur</u><b>_</b>
                     Current retransmit value.  In seconds.

              <u>backoff</u><b>_</b>
                     Round-trip time exponential backoff constant.

</pre><h4><b>TCP/RENO</b> <b>OBJECTS</b></h4><pre>
       TCP/Reno  objects  are  a  subclass  of  TCP  objects  that  implement the Reno TCP transport protocol as
       described in [7].  There are no methods, configuration parameters or state  variables  specific  to  this
       object.

</pre><h4><b>TCP/NEWRENO</b> <b>OBJECTS</b></h4><pre>
       TCP/Newreno  objects  are a subclass of TCP objects that implement a modified version of the BSD Reno TCP
       transport protocol.

       There are no methods or state variables specific to this object.

       <b>Configuration</b> <b>Parameters</b>

              <u>newreno_changes</u><b>_</b>
                     Set to zero for the default NewReno described in [7].  Set  to  1  for  additional  NewReno
                     algorithms  as  suggested  in  [10]; this includes the estimation of the ssthresh parameter
                     during slow-start.

</pre><h4><b>TCP/VEGAS</b> <b>OBJECTS</b></h4><pre>
       This section of the man page has not yet been written.

</pre><h4><b>TCP/SACK1</b> <b>OBJECTS</b></h4><pre>
       TCP/Sack1 objects are a subclass of TCP objects that implement the BSD Reno TCP transport  protocol  with
       Selective Acknowledgement Extensions as described in [7].

       They  inherit  all  of  the  TCP object functionality.  There are no methods, configuration parameters or
       state variables specific to this object.

</pre><h4><b>TCP/FACK</b> <b>OBJECTS</b></h4><pre>
       TCP/Fack objects are a subclass of TCP objects that implement the BSD Reno TCP  transport  protocol  with
       Forward Acknowledgement congestion control.

       They  inherit  all  of the TCP object functionality.  There are no methods or state variables specific to
       this object.

       <b>Configuration</b> <b>Parameters</b>

              <u>ss-div4</u>
                     Overdamping algorithm. Divides ssthresh by 4 (instead  of  2)  if  congestion  is  detected
                     within 1/2 RTT of slow-start. (1=Enable, 0=Disable)

              <u>rampdown</u>
                     Rampdown  data  smoothing algorithm. Slowly reduces congestion window rather than instantly
                     halving it. (1=Enable, 0=Disable)

</pre><h4><b>TCP/FULLTCP</b> <b>OBJECTS</b></h4><pre>
       This section has not yet been added to the man page.  The implementation and the configuration parameters
       are described in [11].

</pre><h4><b>TCPSINK</b> <b>OBJECTS</b></h4><pre>
       TCPSink objects are a subclass of agent objects that implement a receiver for TCP packets.  The simulator
       only implements "one-way" TCP connections, where the TCP source sends data packets and the TCP sink sends
       ACK packets.  TCPSink objects inherit all of the generic agent functionality.  There are  no  methods  or
       state variables specific to the TCPSink object.

       <b>Configuration</b> <b>Parameters</b>

              <u>packetSize</u><b>_</b>
                     The size in bytes to use for all acknowledgment packets.

              <u>maxSackBlocks</u><b>_</b>
                     The  maximum  number  of  blocks  of data that can be acknowledged in a SACK option.  For a
                     receiver that is also using the time stamp option [RFC 1323], the SACK option specified  in
                     RFC  2018  has  room  to include three SACK blocks.  This is only used by the TCPSink/Sack1
                     subclass.  This value may not be increased within any particular TCPSink object after  that
                     object  has  been  allocated.  (Once a TCPSink object has been allocated, the value of this
                     parameter may be decreased but not increased).

</pre><h4><b>TCPSINK/DELACK</b> <b>OBJECTS</b></h4><pre>
       DelAck objects are a subclass of TCPSink that implement a delayed-ACK receiver  for  TCP  packets.   They
       inherit all of the TCPSink object functionality.  There are no methods or state variables specific to the
       DelAck object.

       <b>Configuration</b> <b>Parameters</b>

              <u>interval</u><b>_</b>
                     The  amount  of  time to delay before generating an acknowledgment for a single packet.  If
                     another packet arrives before this time expires, generate an acknowledgment immediately.

</pre><h4><b>TCPSINK/SACK1</b> <b>OBJECTS</b></h4><pre>
       TCPSink/Sack1 objects are a subclass of TCPSink that implement a SACK receiver  for  TCP  packets.   They
       inherit all of the TCPSink object functionality.  There are no methods, configuration parameters or state
       variables specific to this object.

</pre><h4><b>TCPSINK/SACK1/DELACK</b> <b>OBJECTS</b></h4><pre>
       TCPSink/Sack1/DelAck  objects  are a subclass of TCPSink/Sack1 that implement a delayed-SACK receiver for
       TCP packets.  They inherit all of the TCPSink/Sack1 object functionality.  There are no methods or  state
       variables specific to this object.

       <b>Configuration</b> <b>Parameters</b>

              <u>interval</u><b>_</b>
                     The  amount  of  time to delay before generating an acknowledgment for a single packet.  If
                     another packet arrives before this time expires, generate an acknowledgment immediately.

</pre><h4><b>SRM</b> <b>OBJECTS</b></h4><pre>
       SRM objects are a subclass of agent objects that implement the SRM reliable multicast transport protocol.
       They inherit all of the generic agent functionalities.

       <b>$srm</b> <b>traffic-source</b> <u>source</u>
              Attach a traffic source, e.g., Application/Traffic/CBR, to the SRM agent.

       <b>$srm</b> <b>start</b>
              Join the multicast group, start the SRM agent and its attached traffic source.

       <b>$srm</b> <b>delete</b>
              Stop the SRM agent, delete all its status and detach the traffic source.

       <b>$srm</b> <b>trace</b> <u>trace-file</u>
              Write the traces generated by the SRM agent to <u>trace-file</u>. The  traces  includes  timer  settings,
              request  and  repair  sending  and receipts, etc. Two related files that are not built into ns are
              <u>tcl/mcast/srm-debug.tcl</u> that permits more detailed tracing of the delay computation functions, and
              <u>tcl/mcast/srm-nam.tcl</u> that separately marks srm control messages from data.  The latter is  useful
              to enhance nam visualisation.

       <b>$srm</b> <b>log</b> <u>log-file</u>
              Write  the  recovery statistics during each request or repair to <u>log-file</u>.  The statistics include
              start time, duration, message id, total number of duplicate requests and repairs.

       <b>$srm</b> <b>distance?</b> <u>node</u>
              Return the distance estimate to <u>node</u> in this SRM agent.

       <b>$srm</b> <b>distances?</b> <u>node</u>
              Returns a list of &lt;group member,  distance&gt; tuples of the distances to all group members that this
              node is aware of.  The group member is identified as the address of the remote agent.   The  first
              tuple is this agent's token.  The list can be directly loaded into a Tcl array.

       <b>Configuration</b> <b>Parameters</b>

              <u>packetSize</u><b>_</b>
                     The  data  packet size in bytes that will be used for repair messages. The default value is
                     1024.

              <u>requestFunction</u><b>_</b>
                     The algorithm used to produce a retransmission request, e.g., setting request  timers.  The
                     default  value  is  SRM/request. Other possible request functions are SRM/request/Adaptive,
                     used by the Adaptive SRM code.

              <u>repairFunction</u><b>_</b>
                     The algorithm used to produce a repair, e.g., compute repair timers. The default  value  is
                     SRM/repair.  Other possible request functions are SRM/repair/Adaptive, used by the Adaptive
                     SRM code.

              <u>sessionFunction</u><b>_</b>
                     The algorithm used to generate session messages. Default is SRM/session

              <u>sessionDelay</u><b>_</b>
                     The basic interval of session messages. Slight random variation is added to  this  interval
                     to  avoid global synchronization of session messages. User may want to adjust this variable
                     according to their specific simulation.  Measured in seconds; default value is 1.0 seconds.

              <u>C1_,</u> <u>C2</u><b>_</b>
                     The parameters which control the request timer. Refer to [8] for detail. The default  value
                     is <u>C1</u><b>_</b> = <u>C2</u><b>_</b> = 2.0.

              <u>D1_,</u> <u>D2</u><b>_</b>
                     The  parameters  which control the repair timer. Refer to [8] for detail. The default value
                     is <u>D1</u><b>_</b> = <u>D2</u><b>_</b> = 1.0.

              <u>requestBackoffLimit</u><b>_</b>
                     The maximum number of exponential backoffs. Default value is 5.

       <b>State</b> <b>Variables</b>

              <u>stats</u><b>_</b> An array containing multiple statistics needed by adaptive SRM agent.  Including: duplicate
                     requests and repairs in current request/repair period, average number of duplicate requests
                     and repairs, request and repair delay in current request/repair period, average request and
                     repair delay.

</pre><h4><b>SRM/Adaptive</b> <b>OBJECTS</b></h4><pre>
       SRM/Adaptive objects are a subclass of the SRM objects that implement the adaptive SRM reliable multicast
       transport protocol. They inherit all of the SRM object functionalities.

       <b>State</b> <b>Variables</b> Refer to the SRM paper by Sally et al ([11]) for more detail.

              <u>pdistance</u><b>_</b>
                     This variable is used to pass the distance estimate provided  by  the  remote  agent  in  a
                     request or repair message.

              <u>D1_,</u> <u>D2</u><b>_</b>
                     The  same as that in SRM agents, except that they are initialized to log10(group size) when
                     generating the first repair.

              <u>MinC1_,</u> <u>MaxC1_,</u> <u>MinC2_,</u> <u>MaxC2</u><b>_</b>
                     The minimum/maximum values of C1_ and C2_. Default  initial  values  are  defined  in  [8].
                     These values define the dynamic range of <u>C1</u><b>_</b> and <u>C2</u><b>_</b>.

              <u>MinD1_,</u> <u>MaxD1_,</u> <u>MinD2_,</u> <u>MaxD2</u><b>_</b>
                     The minimum/maximum values of D1_ and D2_. Default initial values are defined in [8]. These
                     values define the dynamic range of <u>D1</u><b>_</b> and <u>D2</u><b>_</b>.

              <u>AveDups</u>
                     Higher bound for average duplicates.

              <u>AveDelay</u>
                     Higher bound for average delay.

              <u>eps</u>    <u>AveDups</u>  -  <u>dups</u>  determines  the  lower  bound of the number of duplicates, when we should
                     adjust parameters to decrease delay.

</pre><h4><b>APPLICATION</b> <b>OBJECTS</b></h4><pre>
       Application objects generate data for transport agents to send.

</pre><h4><b>FTP</b> <b>APPLICATION</b> <b>OBJECTS</b></h4><pre>
       Application/FTP objects  produce bulk data for a TCP object to send.

       <b>$ftp</b> <b>start</b>
              Causes FTP to produce packets indefinitely.

       <b>$ftp</b> <b>produce</b> <u>n</u>
              Causes the FTP object to produce <u>n</u> packets instantaneously.

       <b>$ftp</b> <b>stop</b>
              Causes the attached TCP object to stop sending data.

       <b>$ftp</b> <b>attach</b> <u>agent</u>
              Attaches an Application/FTP object to <u>agent</u>.

       <b>$ftp</b> <b>producemore</b> <u>count</u>
              Causes the Application/FTP object to produce <u>count</u> more packets.

       <b>Configuration</b> <b>Parameters</b>

              <u>maxpkts</u>
                     The maximum number of packets generated.

</pre><h4><b>TELNET</b> <b>APPLICATION</b> <b>OBJECTS</b></h4><pre>
       Application/Telnet objects produce individual packets with inter-arrival times as follows.  If  <u>interval</u><b>_</b>
       is non-zero, then inter-arrival times are chosen from an exponential distribution with average <u>interval</u><b>_</b>.
       If <u>interval</u><b>_</b> is zero, then inter-arrival times are chosen using the "tcplib" telnet distribution.

       <b>$telnet</b> <b>start</b>
              Causes the Application/Telnet object to start producing packets.

       <b>$telnet</b> <b>stop</b>
              Causes the Application/Telnet object to stop producing packets.

       <b>$telnet</b> <b>attach</b> <u>agent</u>
              Attaches a Application/Telnet object to <u>agent</u>.

       <b>Configuration</b> <b>Parameters</b>

              <u>interval</u><b>_</b>
                     The  average  inter-arrival time in seconds for packets generated by the Application/Telnet
                     object.

</pre><h4><b>TRAFFIC</b> <b>OBJECTS</b></h4><pre>
       Traffic objects create data  for  a  transport  protocol  to  send.   A  Traffic  object  is  created  by
       instantiating  an object of class Application/Traffic/<u>type</u> where <u>type</u> is one of Exponential, Pareto, CBR,
       Trace.

</pre><h4><b>EXPONENTIAL</b> <b>TRAFFIC</b> <b>OBJECTS</b></h4><pre>
       Application/Traffic/Exponential objects generate  On/Off  traffic.   During  "on"  periods,  packets  are
       generated at a constant burst rate.  During "off" periods, no traffic is generated.  Burst times and idle
       times are taken from exponential distributions.

       <b>Configuration</b> <b>Parameters</b>

              <u>packet_size</u><b>_</b>
                     The packet size in bytes.

              <u>burst_time</u><b>_</b>
                     Burst duration in seconds.

              <u>idle_time</u><b>_</b>
                     Idle time in seconds.

              <u>rate</u><b>_</b>  Peak rate in bits per second.

</pre><h4><b>PARETO</b> <b>TRAFFIC</b> <b>OBJECTS</b></h4><pre>
       Application/Traffic/Pareto  objects  generate  On/Off  traffic with burst times and idle times taken from
       pareto distributions.

       <b>Configuration</b> <b>Parameters</b>

              <u>packet_size</u><b>_</b>
                     The packet size in bytes.

              <u>burst_time</u><b>_</b>
                     Average on time in seconds.

              <u>idle_time</u><b>_</b>
                     Average off time in seconds.

              <u>rate</u><b>_</b>  Peak rate in bits per second.

              <u>shape</u><b>_</b> Pareto shape parameter.

</pre><h4><b>CBR</b> <b>(CONSTANT</b> <b>BIT</b> <b>RATE)</b> <b>TRAFFIC</b> <b>OBJECTS</b></h4><pre>
       Application/Traffic/CBR objects generate packets at  a  constant  rate.   Dither  can  be  added  to  the
       interarrival times by enabling the "random" flag.

       <b>Configuration</b> <b>Parameters</b>

              <u>rate</u><b>_</b>  Peak rate in bits per second.

              <u>packet_size</u><b>_</b>
                     The packet size in bytes.

              <u>random</u><b>_</b>
                     Flag that turns dithering on and off (default is off).

              <u>maxpkts</u><b>_</b>
                     Maximum number of packets to send.

</pre><h4><b>TRACE</b> <b>TRAFFIC</b> <b>OBJECTS</b></h4><pre>
       Application/Traffic/Trace objects are used to generate traffic from a trace file.

       <b>$trace</b> <b>attach-tracefile</b> <u>tfile</u>
              Attach  the  Tracefile  object <u>tfile</u> to this trace.  The Tracefile object specifies the trace file
              from  which  the  traffic  data  is  to  be  read  (see  TRACEFILE  OBJECTS  section).    Multiple
              Application/Traffic/Trace objects can be attached to the same Tracefile object.  A random starting
              place within the Tracefile is chosen for each Application/Traffic/Trace object.

       There are no configuration parameters for this object.

</pre><h4><b>TRACEFILE</b> <b>OBJECTS</b></h4><pre>
       Tracefile  objects  are  used  to  specify  the trace file that is to be used for generating traffic (see
       TRAFFIC/TRACE OBJECTS section).  $tracefile is an instance of the Tracefile Object.

       <b>$tracefile</b> <b>filename</b> <u>trace-input</u>
              Set the filename from which the traffic trace data is to be read to <u>trace-input.</u>

       There are no configuration parameters for this object.  A trace file consists  of  any  number  of  fixed
       length  records.   Each  record  consists of 2 32 bit fields.  The first indicates the interval until the
       next packet is generated in microseconds.  The second indicates the length of the next packet in bytes.

</pre><h4><b>TRACE</b> <b>AND</b> <b>MONITORING</b> <b>METHODS</b></h4><pre>
       [NOTE: This section has not been verified to be up-to-date with the release.]  Trace objects are used  to
       generate  event  level capture logs typically to an output file.  Throughout this section $ns refers to a
       Simulator object, $agent refers to an Agent object.

       <b>$ns</b> <b>create-trace</b> <u>type</u> <u>fileID</u> <u>node1</u> <u>node2</u> <u>[option]</u>
              Create a Trace object of type <u>type</u> and attach the filehandle <u>fileID</u> to it to  monitor  the  queues
              between  nodes  <u>node1</u>  and  <u>node2.</u>   <u>type</u> can be one of Enque, Deque, Drop.  Enque monitors packet
              arrival at a queue.  Deque monitors packet departure at a queue.  Drop monitors packet drops at  a
              queue.  <u>fileID</u> must be a file handle returned by the Tcl <u>open</u> command and it must have been opened
              for  writing.   If  <u>option</u> is not specified, the command will instruct the created trace object to
              generate ns traces. If <u>option</u> is """nam""" the new object will  produce  nam  traces.   Returns  a
              handle to the trace object.

       <b>$ns</b> <b>drop-trace</b> <u>node1</u> <u>node2</u> <u>trace</u>
              Remove  trace  object  attached to the link between nodes <u>node1</u> and <u>node2</u> with <u>trace</u> as the object
              handle.

       <b>$ns</b> <b>trace-queue</b> <u>node1</u> <u>node2</u> <u>fileID</u>
              Enable Enque, Deque and Drop tracing on the link between <u>node1</u> and <u>node2.</u>

       <b>$ns</b> <b>namtrace-queue</b> <u>node1</u> <u>node2</u> <u>fileID</u>
              Same function as <b>$ns</b> <b>trace-queue</b>, except it produces nam traces.

       <b>$ns</b> <b>trace-all</b> <u>fileID</u>
              Enable Enque, Deque, Drop Tracing on all the links in the topology created after  this  method  is
              invoked.   Also enables the tracing of network dynamics.  <u>fileID</u> must be a file handle returned by
              the Tcl <u>open</u> command and it must have been opened for writing.

       <b>$ns</b> <b>namtrace-all</b> <u>fileID</u>
              Same function as <b>$ns</b> <b>trace-all</b>, except it will produce all equivalent traces  in  nam  format.  In
              addition,   calling  this  command  <u>before</u>  the  simulator  starts  to  run  will  generate  color
              configurations (if any) and topology information needed by nam (nodes, links, queues). An  example
              can be found at ns-2/tcl/ex/nam-example.tcl.

       <b>$ns</b> <b>namtrace-config</b> <u>fileID</u>
              Assign  a  file to store nam configuration information, e.g., node/link/agents and some Simulator-
              related traces such as annotations.  When you don't want to trace every object. call this function
              and then use <u>$ns</u> <u>namtrace-queue</u>, <u>rtModel</u> <u>trace</u>, etc., to insert traces individually. Note that you
              should use the same file for individual traces and nam  configuration.  An  example  for  this  is
              available at ns-2/tcl/ex/nam-separate-trace.tcl.

       <b>$ns</b> <b>monitor-queue</b> <u>node1</u> <u>node2</u>
              Arrange  for  queue  length  of  link  between  nodes  <u>node1</u>  and  <u>node2</u>  to  be tracked.  Returns
              QueueMonitor object that can be queried to  learn  average  queue  size  etc.   [see  QueueMonitor
              Objects section]

       <b>$ns</b> <b>flush-trace</b>
              Flush the output channels attached to all the trace objects.

       <b>$link</b> <b>trace-dynamics</b> <u>ns</u> <u>fileID</u> <u>[option]</u>
              Trace  the  dynamics of this link and write the output to <u>fileID</u> filehandle.  <u>ns</u> is an instance of
              the Simulator or MultiSim object that was created to invoke the simulation.

       <b>$ns</b> <b>color</b> <u>id</u> <u>name</u>
              Create a color index, which links the number <u>id</u> to the color name <u>name</u>. All colors created  <u>before</u>
              the simulator starts to run will be written to nam trace file, if there is any.

       <b>$ns</b> <b>trace-annotate</b> <u>string</u>
              Writes  an annotation to ns and nam trace file, if there are any. The string should be enclosed in
              double quote to make it a single argument.

       <b>trace_annotate</b> <u>string</u>
              Another version of <b>$ns</b> <b>trace-annotate</b>, which is a global function and doesn't require  the  caller
              to know ns.

       <b>$ns</b> <b>duplex-link-op</b> <b>$node1</b> <b>$node2</b> <b>$op</b> <b>$args</b>
              Perform  a  given  operation  <u>$op</u>  on  the  given duplex link (<u>$node1</u>, <u>$node2</u>).  The following two
              operations may be used:
              orient         - Specify the nam orientation of the duplex link. Values can be
                          left, right, up, down, their mixture combined by '-' (e.g.,
                          left-down), and a number specifying the angle between the
                          link and the horizontal line.
              queuePos  - Construct a queue of the simplex link (<u>$node1</u>,
                          <u>$node2</u>) in nam, and specify the angle between the
                          horizontal line and the line along which the queued packets
                          will be displayed.

       <b>$ns</b> <b>add-agent-trace</b> <u>agent</u> <u>name</u> <u>[fileID]</u>
              Write a nam trace line, which will create a trace agent for <u>agent</u> when  interpreted  by  nam.  The
              trace  agent's  name  will be <u>name</u>. This nam trace agent is used to show the position of <u>agent</u> and
              can be used to write nam traces of variables associated with the agent.  By default traces will be
              written to the file assigned by <u>namtrace-all</u>.  <u>fileID</u> can be used to write traces to another file.

       <b>$agent</b> <b>tracevar</b> <u>name</u>
              Label OTcl variable <u>name</u> of <b>$agent</b> to be traced. Then whenever the variable <u>name</u> changes value,  a
              nam trace line will be written to nam trace file, if there is one. Note that <u>name</u> must be the same
              as the variable's real OTcl name.

       <b>$ns</b> <b>delete-agent-trace</b> <u>agent</u>
              Write  a nam trace line, which will delete the nam trace associated with <u>agent</u> when interpreted by
              nam.

       <b>$agent</b> <b>add-var-trace</b> <u>name</u> <u>value</u> <u>[type]</u>
              Write a nam trace line, which creates a variable trace  with  name  <u>name</u>  and  value  <u>value</u>,  when
              interpreted by nam. <u>type</u> indicates the type of the variable, e.g., is it a list, array, or a plain
              variable. Currently only plain variable is supported, for which <u>type</u> = 'v'.

       The following 2 functions should be called <u>after</u> the simulator starts running. This can be done using <b>$ns</b>
       <b>at</b>.

       <b>$agent</b> <b>delete-var-trace</b> <u>name</u>
              Write a nam trace line, which deletes the variable trace <u>name</u> when interpreted by nam.

       <b>$agent</b> <b>update-var-trace</b> <u>name</u> <u>value</u> <u>[type]</u>
              Write  a  nam trace line, which changes the value of traced variable <u>name</u> when interpreted by nam.
              Unlike <b>$agent</b> <b>tracevar</b>, the above 3 functions provide 'manual' variable tracing, in which variable
              tracing are done by placing <b>$agent</b> <b>update-var-trace</b> in OTcl  code,  while  <u>tracevar</u>  automatically
              generates nam traces when the traced variable changes value.

       The  tracefile  format is backward compatible with the output files in the ns version 1 simulator so that
       ns-1 post-processing scripts can still be used.  Trace records of traffic for link  objects  with  Enque,
       Deque or Drop Tracing have the following form:

                  &lt;code&gt; &lt;time&gt; &lt;hsrc&gt; &lt;hdst&gt; &lt;packet&gt;

       where

              &lt;code&gt; := [hd+-r] h=hop d=drop +=enque -=deque r=receive
              &lt;time&gt; := simulation time in seconds
              &lt;hsrc&gt; := first node address of hop/queuing link
              &lt;hdst&gt; := second node address of hop/queuing link
              &lt;packet&gt; :=  &lt;type&gt; &lt;size&gt; &lt;flags&gt; &lt;flowID&gt; &lt;src.sport&gt; &lt;dst.dport&gt; &lt;seq&gt; &lt;pktID&gt;
              &lt;type&gt; := tcp|telnet|cbr|ack etc.
              &lt;size&gt; := packet size in bytes
              &lt;flags&gt; := [CP]  C=congestion, P=priority
              &lt;flowID&gt; := flow identifier field as defined for IPv6
              &lt;src.sport&gt; := transport address (src=node,sport=agent)
              &lt;dst.sport&gt; := transport address (dst=node,dport=agent)
              &lt;seq&gt; := packet sequence number
              &lt;pktID&gt; := unique identifer for every new packet

              Only those agents interested in providing sequencing will generate sequence numbers and hence this
              field may not be useful for packets generated by some agents.

              For links that use RED gateways, there are additional trace records as follows:

                         &lt;code&gt; &lt;time&gt; &lt;value&gt;

              where

                     &lt;code&gt; := [Qap] Q=queue size, a=average queue size,
                          p=packet dropping probability
                     &lt;time&gt; := simulation time in seconds
                     &lt;value&gt; := value

              Trace records for link dynamics are of the form:

                         &lt;code&gt; &lt;time&gt; &lt;state&gt; &lt;src&gt; &lt;dst&gt;

              where

                     &lt;code&gt; := [v]
                     &lt;time&gt; := simulation time in seconds
                     &lt;state&gt; := [link-up | link-down]
                     &lt;src&gt; := first node address of link
                     &lt;dst&gt; := second node address of link

</pre><h4><b>INTEGRATOR</b> <b>Objects</b></h4><pre>
       Integrator  Objects support the approximate computation of continuous integrals using discrete sums.  The
       running sum(integral) is computed as: sum_ +=  [lasty_ * (x - lastx_)] where (x, y) is the  last  element
       entered  and  (lastx_,  lasty_) was the element previous to that added to the sum.  lastx_ and lasty_ are
       updated as new elements are added.  The first sample point defaults to  (0,0)  that  can  be  changed  by
       changing the values of (lastx_,lasty_).

       <b>$integrator</b> <b>newpoint</b> <u>x</u> <u>y</u>
              Add the point (x,y) to the sum.  Note that it does not make sense for x to be less than lastx_.

       There are no configuration parameters specific to this object.

       <b>State</b> <b>Variables</b>

              <u>lastx</u><b>_</b> x-coordinate of the last sample point.

              <u>lasty</u><b>_</b> y-coordinate of the last sample point.

              <u>sum</u><b>_</b>   Running sum (i.e. the integral) of the sample points.

</pre><h4><b>SAMPLES</b> <b>Objects</b></h4><pre>
       Samples Objects support the computation of mean and variance statistics for a given sample.

       <b>$samples</b> <b>mean</b>
              Returns mean of the sample.

       <b>$samples</b> <b>variance</b>
              Returns variance of the sample.

       <b>$samples</b> <b>cnt</b>
              Returns a count of the sample points considered.

       <b>$samples</b> <b>reset</b>
              Reset the Samples object to monitor a fresh set of samples.

       There are no configuration parameters or state variables specific to this object.

</pre><h4><b>BUILTINS</b></h4><pre>
       [NOTE:  This  section  has not been verified to be up-to-date with the release.]  Because <u>OTcl</u> is a full-
       fledged programming language,  it  is  easy  to  build  high-level  simulation  constructs  from  the  ns
       primitives.   Several  library  routines  have  been  built  in  this  way,  and are embedded into the ns
       interpreter as methods of the Simulator class.   Throughout  this  section  $ns  represents  a  Simulator
       object.

       <b>$ns</b> <b>create-connection</b> <u>srcType</u> <u>srcNode</u> <u>dstType</u> <u>dstNode</u> <u>class</u>
              Create  a  source  agent  of type <u>srcType</u> at node <u>srcNode</u> and connect it to a destination agent of
              type <u>dstType</u> at node <u>dstNode.</u>  Also, connect the destination  agent  to  the  source  agent.   The
              traffic class of both agents is set to <u>class.</u>  This method returns the source agent.

</pre><h4><b>EXAMPLE</b></h4><pre>
           set ns [new Simulator]

           #
           # Create two nodes
           #
           set n0 [$ns node]
           set n1 [$ns node]

           #
           # Create a trace and arrange for all the trace events of the
           # links subsequently created to be dumped to "out.tr"
           #
           set f [open out.tr w]
           $ns trace-all $f

           #
           # Connect the two nodes with a 1.5Mb link with a transmission
           # delay of 10ms using FIFO drop-tail queuing
           #
           $ns duplex-link $n0 $n1 1.5Mb 10ms DropTail

           #
           # Set up BSD Tahoe TCP connections in opposite directions.
           #
           set tcp_src1 [new Agent/TCP]
           set tcp_snk1 [new Agent/TCPSink]
           set tcp_src2 [new Agent/TCP]
           set tcp_snk2 [new Agent/TCPSink]
           $ns attach-agent $n0 $tcp_src1
           $ns attach-agent $n1 $tcp_snk1
           $ns attach-agent $n1 $tcp_src2
           $ns attach-agent $n0 $tcp_snk2
           $ns connect $tcp_src1 $tcp_snk1
           $ns connect $tcp_src2 $tcp_snk2

           #
           # Create ftp sources at the each node
           #
           set ftp1 [$tcp_src1 attach-source FTP]
           set ftp2 [$tcp_src2 attach-source FTP]

           #
           # Start up the first ftp at the time 0 and
           # the second ftp staggered 1 second later
           #

           $ns at 0.0 "$ftp1 start"
           $ns at 1.0 "$ftp2 start"

           #
           # run the simulation for 10 simulated seconds
           #
           $ns at 10.0 "exit 0"
           $ns run

</pre><h4><b>DEBUGGING</b></h4><pre>
       To enable debugging when building ns from source:
           % ./configure --enable-debug
           % make

       For more details about ns debugging please see &lt;<a href="http://www-mash.cs.berkeley.edu/ns/ns-debugging.html">http://www-mash.cs.berkeley.edu/ns/ns-debugging.html</a>&gt;.

</pre><h4><b>DIFFERENCES</b> <b>FROM</b> <b>NS-1</b></h4><pre>
       In  general,  more  complex  objects  in  ns-1  have been broken down into simpler components for greater
       flexibility and composability.  Details of differences between ns-1 and ns-2 can be found at &lt;<a href="http://www">http://www</a>-
       mash.cs.berkeley.edu/ns/ns.html&gt;.

</pre><h4><b>HISTORY</b></h4><pre>
       Work  on  the  LBL  Network  Simulator  began  in  May   1990   with   modifications   to   S.   Keshav's
       (<a href="mailto:keshav@research.att.com">keshav@research.att.com</a>) REAL network simulator, which he developed for his Ph.D. work at U.C. Berkeley.
       In  Summer  1991, the simulation description language was revamped, and later, the NEST threads model was
       replaced with an event driven framework and an efficient scheduler.   Among  other  contributions,  Sugih
       Jamin  (<a href="mailto:jamin@usc.edu">jamin@usc.edu</a>)  contributed  the  calendar-queue  based  scheduling  code  to this version of the
       program, which was known as <u>tcpsim.</u>  In December 1994, McCanne ported tcpsim  to  C++  and  replaced  the
       yacc-based simulation description language with a Tcl interface, and added preliminary multicast support.
       Also  at  this  time,  the  name  changed from <u>tcpsim</u> to the more generic <u>ns.</u>  Throughout, Floyd has made
       modifications to the TCP code and  added  additional  source  models  for  her  investigations  into  RED
       gateways,  resource  management, class-based queuing, explicit congestion notification, and traffic phase
       effects.   Many  of  the  papers  discussing  these  issues  are  available   through   URL   <a href="http://www">http://www</a>-
       nrg.ee.lbl.gov/.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/Tcl.1.html">Tcl</a>(1), <a href="../man1/tclsh.1.html">tclsh</a>(1), <a href="../man1/nam.1.html">nam</a>(1), otclsh

       <b>[1]</b>    S.  Keshav,  ``REAL:  A  Network  Simulator''.   UCB  CS  Tech  Report 88/472, December 1988.  See
              <a href="http://minnie.cs.adfa.oz.au/REAL/index.html">http://minnie.cs.adfa.oz.au/REAL/index.html</a> for more information.

       <b>[2]</b>    Floyd, S. and Jacobson, V.  Random Early Detection gateways for  Congestion  Avoidance.   IEEE/ACM
              Transactions on Networking, Vol. 1, No. 4.  August 1993.  pp. 397-413.  Available from <a href="http://www">http://www</a>-
              nrg.ee.lbl.gov/floyd/red.html.

       <b>[3]</b>    Floyd, S.  Simulator Tests.  July 1995.  URL <a href="ftp://ftp.ee.lbl.gov/papers/simtests.ps.Z">ftp://ftp.ee.lbl.gov/papers/simtests.ps.Z</a>.

       <b>[4]</b>    Floyd,   S.,   and   Jacobson,   V.    On  Traffic  Phase  Effects  in  Packet-Switched  Gateways.
              Internetworking: Research and Experience, V.3 N.3, September 1992.  pp. 115-156.

       <b>[5]</b>    Floyd, S., and Jacobson, V.  Link-sharing and Resource  Management  Models  for  Packet  Networks.
              IEEE/ACM Transactions on Networking, Vol. 3 No. 4, August 1995.  pp. 365-386.

       <b>[6]</b>    Floyd,  S.,  Notes  of Class-Based Queueing: Setting Parameters.  URL <a href="ftp://ftp.ee.lbl.gov/papers/">ftp://ftp.ee.lbl.gov/papers/</a>
              params.ps.Z.  September 1995.

       <b>[7]</b>    Fall, K., and Floyd, S.  Comparisons of Tahoe, Reno, and Sack TCP.   December  1995.   URL  ftp://
              ftp.ee.lbl.gov/papers/sacks.ps.Z.

       <b>[8]</b>    David   Wetherall   and  Christopher  J.  Linblad.   Extending  Tcl  for  Dynamic  Object-Oriented
              Programming.  In Proceedings of the USENIX Tcl/Tk Workshop, Toronto, Ontario, USENIX.  July, 1995.
              At &lt;<a href="http://www.tns.lcs.mit.edu/publications/tcltk95.djw.html">http://www.tns.lcs.mit.edu/publications/tcltk95.djw.html</a>&gt;.

       <b>[9]</b>    M. Shreedhar and G. Varghese. Efficient Fair Queueing Using  Deficit  Round  Robin.  In  Proc.  of
              SIGCOMM, pp. 231-242, 1995.

       <b>[10]</b>   Hoe,  J.,  Improving the Start-up Behavior of a Congestion Control Scheme for TCP.  in SIGCOMM 96,
              August 1996, pp. 270-280.  URL <a href="http://www.acm.org/sigcomm/sigcomm96/papers/hoe.html">http://www.acm.org/sigcomm/sigcomm96/papers/hoe.html</a>.

       <b>[11]</b>   Fall,  K.,  Floyd,  S.,  and  Henderson,  T.,  Ns  Simulator  Tests   for   Reno   FullTCP.    URL
              <a href="ftp://ftp.ee.lbl.gov/papers/fulltcp.ps">ftp://ftp.ee.lbl.gov/papers/fulltcp.ps</a>.  July 1997.

       <b>[12]</b>   Floyd, S., Jacobson, V., Liu, C.-G., McCanne, S. and Zhang, L., A Reliable Multicast Framework for
              Light-weight  Sessions  and  Application  Level  Framing.  To  appear  in  IEEE/ACK Transaction on
              Networking, November 1996.  <a href="ftp://ftp.ee.lbl.gov/papers/srm1.ps.gz">ftp://ftp.ee.lbl.gov/papers/srm1.ps.gz</a>

       <b>[13]</b>   Fall, K., and Varadhan, K., (eds.), "Ns notes and documentation", work in  progress.   <a href="http://www">http://www</a>-
              mash.cs.berkeley.edu/ns/nsDoc.ps.gz

       Research  using  ns  is  on-going.   A list of recent research contributions employing ns can be found at
       &lt;<a href="http://www-mash.cs.berkeley.edu/ns/ns-research.html">http://www-mash.cs.berkeley.edu/ns/ns-research.html</a>&gt;.

       Work on ns is on-going.   Information  about  the  most  recent  version  is  available  at  &lt;<a href="http://www">http://www</a>-
       mash.cs.berkeley.edu/ns/ns.html&gt;.

       A   mailing   list   for   ns  users  and  announcements  is  also  available,  send  mail  to  ns-users-
       <a href="mailto:request@mash.cs.berkeley.edu">request@mash.cs.berkeley.edu</a> or <a href="mailto:ns-announce-request@mash.cs.berkeley.edu">ns-announce-request@mash.cs.berkeley.edu</a> to join.   Questions  should  be
       forwarded to ns-users; ns-announce will be low-traffic announcements only.

</pre><h4><b>AUTHORS</b></h4><pre>
       Steven  McCanne  (<a href="mailto:mccanne@ee.lbl.gov">mccanne@ee.lbl.gov</a>),  University of California, Berkeley and Lawrence Berkeley National
       Laboratory, Berkeley, CA, and Sally  Floyd  (<a href="mailto:floyd@ee.lbl.gov">floyd@ee.lbl.gov</a>)  Lawrence  Berkeley  National  Laboratory,
       Berkeley,  CA.   A  complete  list  of  contributors  to ns is at &lt;<a href="http://www-mash.cs.berkeley.edu/ns/ns">http://www-mash.cs.berkeley.edu/ns/ns</a>-
       contributors.html&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       Not all of the functionality supported in ns-1 has been ported to ns-2.

       This manual page is incomplete.

                                                  25 July 1997                                             <u><a href="../man1/NS.1.html">NS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>