<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v4l2-compliance - An application to test video4linux drivers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/v4l-utils">v4l-utils_1.28.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       v4l2-compliance - An application to test video4linux drivers

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>v4l2-compliance</b> [<u>-h</u>] [<u>-d</u> <u>&lt;dev&gt;</u>] [many other options]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  v4l2-compliance  tool is used to test video4linux devices, either video, vbi, radio or swradio, both
       input and output. It attempts to test almost all aspects of a V4L2 device and it covers almost  all  V4L2
       ioctls.  It  has  very  good  support for video capture and output, VBI capture and output and (software)
       radio tuning and transmitting.

       The support for memory-to-memory devices is limited at the moment.

       If  you  have  questions  about  v4l2-compliance  then  mail  those  to  the  <a href="mailto:linux-media@vger.kernel.org">linux-media@vger.kernel.org</a>
       mailinglist.

       When  testing  a  driver  always  compile the utility from the latest source code from the git repository
       (<a href="http://git.linuxtv.org/cgit.cgi/v4l-utils.git/">http://git.linuxtv.org/cgit.cgi/v4l-utils.git/</a>). The version supplied by linux distributions  is  almost
       certainly too old.

       In  addition,  if a test fails then it will output the source and line where the failure occurred, so you
       often need access to the source code to see what that test is all about.

       Note that v4l2-compliance not only tests for compliance against the V4L2 API, but also whether the driver
       is using all the correct frameworks.  These  frameworks  often  automatically  provide  ioctls  that  are
       strictly  speaking  optional,  but  that  come  for  free if you use those frameworks. By requiring their
       presence the v4l2-compliance utility will enforce their use.

       If you want to submit a new V4L2 driver, then that driver must pass  the  v4l2-compliance  tests  without
       fails.  The  best  method  of  using this tool to test your driver is to first test without any streaming
       options and fix any failures from the first reported failure to the last. Sometimes earlier failures  can
       generate later failures, so just start fixing them in order and test again after each fix.

       Next  test  your driver with the <b>-s</b> option to do the basic streaming tests. This requires that there is a
       valid input or output.

       Whenever you run v4l2-compliance it will save the current driver state and restore it after all tests are
       done (including when  you  press  Ctrl-C).  All  the  streaming  tests  are  performed  using  the  saved
       configuration. This makes it possible to prepare for the streaming tests by configuring the device before
       calling v4l2-compliance.

       Finally  you  should  test your driver using the <b>-f</b> and <b>-c</b> options to verify that all video pixel formats
       are correctly supported. You need to perform all three streaming tests for all inputs  and  outputs.  You
       can use the <b>-a</b> option to automate that if that is possible for your hardware.

       If your driver passes all tests, then your can be confident that your driver is in very good shape!

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-d</b>, <b>--device</b> <u>&lt;dev&gt;</u>
              Use  device  <u>&lt;dev&gt;</u>  as  the  video  device.  If  <u>&lt;dev&gt;</u>  is a number, then /dev/video<u>&lt;dev&gt;</u> is used.
              Otherwise if <b>-z</b> was specified earlier, then <u>&lt;dev&gt;</u> is the entity name or interface ID (if  prefixed
              with 0x) as found in the topology of the media device with the bus info string as specified by the
              <b>-z</b> option.

       <b>-V</b>, <b>--vbi-device</b> <u>&lt;dev&gt;</u>
              Use  device  <u>&lt;dev&gt;</u> as the vbi device. If <u>&lt;dev&gt;</u> is a number, then /dev/vbi<u>&lt;dev&gt;</u> is used.  Otherwise
              if <b>-z</b> was specified earlier, then <u>&lt;dev&gt;</u> is the entity name or interface ID (if prefixed  with  0x)
              as  found  in  the  topology  of  the media device with the bus info string as specified by the <b>-z</b>
              option.

       <b>-r</b>, <b>--radio-device</b> <u>&lt;dev&gt;</u>
              Use device <u>&lt;dev&gt;</u> as the radio device.  If  <u>&lt;dev&gt;</u>  is  a  number,  then  /dev/radio<u>&lt;dev&gt;</u>  is  used.
              Otherwise  if <b>-z</b> was specified earlier, then <u>&lt;dev&gt;</u> is the entity name or interface ID (if prefixed
              with 0x) as found in the topology of the media device with the bus info string as specified by the
              <b>-z</b> option.

       <b>-S</b>, <b>--sdr-device</b> <u>&lt;dev&gt;</u>
              Use device <u>&lt;dev&gt;</u> as the SDR device.  If  <u>&lt;dev&gt;</u>  is  a  number,  then  /dev/swradio<u>&lt;dev&gt;</u>  is  used.
              Otherwise  if <b>-z</b> was specified earlier, then <u>&lt;dev&gt;</u> is the entity name or interface ID (if prefixed
              with 0x) as found in the topology of the media device with the bus info string as specified by the
              <b>-z</b> option.

       <b>-t</b>, <b>--touch-device</b> <u>&lt;dev&gt;</u>
              Use device <u>&lt;dev&gt;</u> as the touch device. If <u>&lt;dev&gt;</u> is a  number,  then  /dev/v4l-touch<u>&lt;dev&gt;</u>  is  used.
              Otherwise  if <b>-z</b> was specified earlier, then <u>&lt;dev&gt;</u> is the entity name or interface ID (if prefixed
              with 0x) as found in the topology of the media device with the bus info string as specified by the
              <b>-z</b> option.

       <b>-u</b>, <b>--subdev-device</b> <u>&lt;dev&gt;</u>
              Use device <u>&lt;dev&gt;</u> as the v4l-subdevX device. If <u>&lt;dev&gt;</u> is a  number,  then  /dev/v4l-subdev<u>&lt;dev&gt;</u>  is
              used.   Otherwise  if <b>-z</b> was specified earlier, then <u>&lt;dev&gt;</u> is the entity name <b>-e</b>, <b>--exp-buf-device</b>
              <u>&lt;dev&gt;</u> Use device <u>&lt;dev&gt;</u> as the video device used to export DMABUFfers for  doing  DMABUF  streaming
              tests. If <u>&lt;dev&gt;</u> is a number, then /dev/video<u>&lt;dev&gt;</u> is used.  Otherwise if <b>-z</b> was specified earlier,
              then  <u>&lt;dev&gt;</u>  is  the entity name or interface ID (if prefixed with 0x) as found in the topology of
              the media device with the bus info string as specified by the <b>-z</b> option.  If this  option  is  not
              specified, then the DMABUF streaming tests will be skipped.

       <b>-z</b>, <b>--media-bus-info</b> <u>&lt;bus-info&gt;</u>
              Find  the  media device with the given bus info string. If set, then the options above can use the
              entity  name  or  interface  ID  to  refer  to  the  device  nodes.  Example:  v4l2-compliance  -z
              platform:vivid-000 -d vivid-000-vid-cap

       <b>-m</b>, <b>--media-device</b> <u>&lt;dev&gt;</u>
              Use  device <u>&lt;dev&gt;</u> as the media controller device. Besides this device it also tests all interfaces
              it finds.  If <u>&lt;dev&gt;</u> starts with a digit, then /dev/media<u>&lt;dev&gt;</u> is used.  If  <u>&lt;dev&gt;</u>  doesn't  exist,
              then  attempt  to  find  a  media  device  with  a  bus  info  string  equal  to  <u>&lt;dev&gt;</u>.  Example:
              v4l2-compliance -m platform:vivid-000

       <b>-M</b>, <b>--media-device-only</b> <u>&lt;dev&gt;</u>
              Use device <u>&lt;dev&gt;</u> as the media controller device. Only test this device, don't walk  over  all  the
              interfaces.   If <u>&lt;dev&gt;</u> starts with a digit, then /dev/media<u>&lt;dev&gt;</u> is used.  If <u>&lt;dev&gt;</u> doesn't exist,
              then  attempt  to  find  a  media  device  with  a  bus  info  string  equal  to  <u>&lt;dev&gt;</u>.  Example:
              v4l2-compliance -M platform:vivid-000

       <b>--stream-from</b> <u>[&lt;pixelformat&gt;=]&lt;file&gt;</u>, <b>--stream-from-hdr</b> <u>[&lt;pixelformat&gt;=]&lt;file&gt;</u>
              Use  the  contents  of  the  file  to fill in output buffers.  If the fourcc of the pixelformat is
              given, then use the file for output buffers using that pixelformat  only.   The  --stream-from-hdr
              variant  uses  the  format  written  by  v4l2-ctl --stream-to-hdr where the payload sizes for each
              buffer are stored in a header. Useful for compressed formats.

       <b>-s</b>, <b>--streaming</b> <u>&lt;count&gt;</u>
              Enable the streaming tests. Set &lt;count&gt; to the number of frames  to  stream  (default  60).   This
              requires  that  before v4l2-compliance is called the device has been configured with a valid input
              (or output) and frequency (when the device has a tuner). For DMABUF testing --expbuf-device  needs
              to be set as well.

              The  configuration  of  the  driver  at  the  time v4l2-compliance was called will be used for the
              streaming tests.

       <b>-f</b>, <b>--stream-all-formats</b> <u>[&lt;count&gt;]</u>
              Test whether all available formats can be streamed. This attempts to stream  using  MMAP  mode  or
              read/write (if V4L2_MEMORY_MMAP is not available) for one second for all formats, at all sizes, at
              all  intervals and with all field values. In addition, if the driver supports scaling, cropping or
              composing it will test that as well in various combinations. If  the  driver  supports  a  lot  of
              combinations  then  this test can take a long time. If <u>&lt;count&gt;</u> is given, then stream for that many
              frames instead of for one second.

              The configuration of the driver at the time v4l2-compliance  was  called  will  be  used  for  the
              streaming tests.

       <b>-c</b>, <b>--stream-all-color</b> <b>color</b>=<u>red|green|blue</u>,<b>skip</b>=<u>&lt;skip&gt;</u>,<b>perc</b>=<u>&lt;perc&gt;</u>
              For all supported, non-compressed formats stream &lt;skip + 1&gt; frames. For the last frame go over all
              pixels and calculate which of the R, G and B color components of a pixel has the highest value and
              count that as a red, green or blue pixel.  The test succeeds if at least <u>perc</u> percent of the frame
              has the given <u>color</u>.  This requires that a valid and predominantly red, green or blue video signal
              is  present  on  the input(s). If <u>skip</u> is not specified, then just capture the first frame. A non-
              zero <u>skip</u> value is useful if it takes a few frames for the device to calibrate.  If  <u>perc</u>  is  not
              specified, then this defaults to 90%.

              Most  signal  generators  are  able to generate pure red, blue or green video. For cameras you can
              print a completely red, green or blue picture and hold it before the camera.

              The goal of this test is to determine if all pixel formats will interpret the red, green and  blue
              colors correctly and that no color components are swapped.

              The  configuration  of  the  driver  at  the  time v4l2-compliance was called will be used for the
              streaming tests.

       <b>-a</b>, <b>--stream-all-io</b>
              Do the <b>-s</b>, <b>-c</b> and <b>-f</b> streaming tests for all inputs or outputs instead of just the  current  input
              or  output.  This  requires that a valid video signal is present on all inputs or that all outputs
              are hooked up.

       <b>-E</b>, <b>--exit-on-fail</b>
              Exit this application when the  first  failure  occurs  instead  of  continuing  with  a  possible
              inconsistent state.

       <b>-C</b>, <b>--color</b> <u>&lt;when&gt;</u>
              Highlight  OK/warn/fail/FAIL  strings  with  colors.  OK is marked green, warn is marked bold, and
              fail/FAIL are marked bright red if enabled. <u>&lt;when&gt;</u> can be <u>always</u>, <u>never</u>, or <u>auto</u> (the default).

       <b>-n</b>, <b>--no-warnings</b>
              Turn off warning messages. They are still counted in the summary, but you won't see them.

       <b>-P</b>, <b>--no-progress</b>
              Turn off progress messages. Useful when redirecting the output to a file.

       <b>-T</b>, <b>--trace</b>
              Trace all called ioctls.

       <b>-v</b>, <b>--verbose</b>
              Turn on verbose reporting.

       <b>--version</b>
              Show version information.

       <b>-w</b>, <b>--wrapper</b>
              Use the libv4l2 wrapper library for all V4L2 device accesses. Note that doing this will cause some
              tests to fail because the libv4l2 library isn't fully V4L2 compliant. By  default  v4l2-compliance
              will bypass libv4l2 and access the V4L2 devices directly.

       <b>-W</b>, <b>--exit-on-warn</b>
              Exit this application when the first warning occurs instead of continuing.

       <b>-h</b>, <b>--help</b>
              Prints the help message.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       On success, it returns 0. Otherwise, it will return the error code.

</pre><h4><b>BUGS</b></h4><pre>
       This  is  a work in progress, and every so often it turns out that some tests done by v4l2-compliance are
       too strict or plain wrong. If you suspect that might be the case, then report such  bugs  to  the  linux-
       <a href="mailto:media@vger.kernel.org">media@vger.kernel.org</a> mailinglist.

v4l-utils 1.28.1                                   March 2015                                 <u><a href="../man1/V4L2-COMPLIANCE.1.html">V4L2-COMPLIANCE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>