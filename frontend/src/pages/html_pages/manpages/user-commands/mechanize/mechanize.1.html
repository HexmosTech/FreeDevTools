<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mechanize - mechanize Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/python3-mechanize">python3-mechanize_0.4.7-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mechanize - mechanize Documentation

       Stateful  programmatic  web browsing in Python. Browse pages programmatically with easy HTML form filling
       and clicking of links.

</pre><h4><b>FREQUENTLY</b> <b>ASKED</b> <b>QUESTIONS</b></h4><pre>
   <b>Contents</b>
       • <u>General</u>

         • <u>Which</u> <u>version</u> <u>of</u> <u>Python</u> <u>do</u> <u>I</u> <u>need?</u>

         • <u>What</u> <u>dependencies</u> <u>does</u> <u>mechanize</u> <u>need?</u>

         • <u>What</u> <u>license</u> <u>does</u> <u>mechanize</u> <u>use?</u>

       • <u>Usage</u>

         • <u>I'm</u> <u>not</u> <u>getting</u> <u>the</u> <u>HTML</u> <u>page</u> <u>I</u> <u>expected</u> <u>to</u> <u>see?</u>

         • <u>Is</u> <u>JavaScript</u> <u>supported?</u>

         • <u>My</u> <u>HTTP</u> <u>response</u> <u>data</u> <u>is</u> <u>truncated?</u>

         • <u>Is</u> <u>there</u> <u>any</u> <u>example</u> <u>code?</u>

       • <u>Cookies</u>

         • <u>Which</u> <u>HTTP</u> <u>cookie</u> <u>protocols</u> <u>does</u> <u>mechanize</u> <u>support?</u>

         • <u>What</u> <u>about</u> <u>RFC</u> <u>2109?</u>

         • <u>Why</u> <u>don't</u> <u>I</u> <u>have</u> <u>any</u> <u>cookies?</u>

         • <u>My</u> <u>response</u> <u>claims</u> <u>to</u> <u>be</u> <u>empty,</u> <u>but</u> <u>I</u> <u>know</u> <u>it's</u> <u>not?</u>

         • <u>What's</u> <u>the</u> <u>difference</u> <u>between</u> <u>the</u> <u>.load()</u> <u>and</u> <u>.revert()</u> <u>methods</u> <u>of</u> <u>CookieJar?</u>

         • <u>Is</u> <u>it</u> <u>threadsafe?</u>

         • <u>How</u> <u>do</u> <u>I</u> <u>do</u> <u>X?</u>

       • <u>Forms</u>

         • <u>How</u> <u>do</u> <u>I</u> <u>figure</u> <u>out</u> <u>what</u> <u>control</u> <u>names</u> <u>and</u> <u>values</u> <u>to</u> <u>use?</u>

         • <u>What</u> <u>do</u> <u>those</u> <u>'*'</u> <u>characters</u> <u>mean</u> <u>in</u> <u>the</u> <u>string</u> <u>representations</u> <u>of</u> <u>list</u> <u>controls?</u>

         • <u>What</u> <u>do</u> <u>those</u> <u>parentheses</u> <u>(round</u> <u>brackets)</u> <u>mean</u> <u>in</u> <u>the</u> <u>string</u> <u>representations</u> <u>of</u> <u>list</u> <u>controls?</u>

         • <u>Why</u> <u>doesn't</u> <u>&lt;some</u> <u>control&gt;</u> <u>turn</u> <u>up</u> <u>in</u> <u>the</u> <u>data</u> <u>returned</u> <u>by</u> <u>.click*()</u> <u>when</u> <u>that</u> <u>control</u>  <u>has</u>  <u>non-None</u>
           <u>value?</u>

         • <u>Why</u>  <u>does</u>  <u>mechanize</u>  <u>not</u>  <u>follow</u>  <u>the</u> <u>HTML</u> <u>4.0</u> <u>/</u> <u>RFC</u> <u>1866</u> <u>standards</u> <u>for</u> <u>RADIO</u> <u>and</u> <u>multiple-selection</u>
           <u>SELECT</u> <u>controls?</u>

         • <u>Why</u> <u>does</u> <u>.click()</u> <u>ing</u> <u>on</u> <u>a</u> <u>button</u> <u>not</u> <u>work</u> <u>for</u> <u>me?</u>

         • <u>How</u> <u>do</u> <u>I</u> <u>change</u> <u>INPUT</u> <u>TYPE=HIDDEN</u> <u>field</u> <u>values</u> <u>(for</u> <u>example,</u> <u>to</u>  <u>emulate</u>  <u>the</u>  <u>effect</u>  <u>of</u>  <u>JavaScript</u>
           <u>code)?</u>

         • <u>I'm</u> <u>having</u> <u>trouble</u> <u>debugging</u> <u>my</u> <u>code.</u>

         • <u>I</u>  <u>have</u>  <u>a</u>  <u>control</u> <u>containing</u> <u>a</u> <u>list</u> <u>of</u> <u>integers.</u>  <u>How</u> <u>do</u> <u>I</u> <u>select</u> <u>the</u> <u>one</u> <u>whose</u> <u>value</u> <u>is</u> <u>nearest</u> <u>to</u>
           <u>the</u> <u>one</u> <u>I</u> <u>want?</u>

       • <u>Miscellaneous</u>

         • <u>I</u> <u>want</u> <u>to</u> <u>see</u> <u>what</u> <u>my</u> <u>web</u> <u>browser</u> <u>is</u> <u>doing?</u>

         • <u>JavaScript</u> <u>is</u> <u>messing</u> <u>up</u> <u>my</u> <u>web-scraping.</u> <u>What</u> <u>do</u> <u>I</u> <u>do?</u>

   <b>General</b>
   <b>Which</b> <b>version</b> <b>of</b> <b>Python</b> <b>do</b> <b>I</b> <b>need?</b>
       mechanize works on all python versions, python 2 (&gt;= 2.7) and 3 (&gt;= 3.5).

   <b>What</b> <b>dependencies</b> <b>does</b> <b>mechanize</b> <b>need?</b>
          html5lib

   <b>What</b> <b>license</b> <b>does</b> <b>mechanize</b> <b>use?</b>
       mechanize is licensed under the <u>BSD-3-clause</u> license.

   <b>Usage</b>
   <b>I'm</b> <b>not</b> <b>getting</b> <b>the</b> <b>HTML</b> <b>page</b> <b>I</b> <b>expected</b> <b>to</b> <b>see?</b>
       See debugging.

   <b>Is</b> <b>JavaScript</b> <b>supported?</b>
       No, sorry.  See <u>JavaScript</u> <u>is</u> <u>messing</u> <u>up</u> <u>my</u> <u>web-scraping.</u> <u>What</u> <u>do</u> <u>I</u> <u>do?</u>

   <b>My</b> <b>HTTP</b> <b>response</b> <b>data</b> <b>is</b> <b>truncated?</b>
       <u>mechanize.Browser's</u> response objects support the <u>.seek()</u> method, and can still be used after <u>.close()</u> has
       been called.  Response data is not fetched until it is needed, so  navigation  away  from  a  URL  before
       fetching  all  of the response will truncate it.  Call <u>response.get_data()</u> before navigation if you don't
       want that to happen.

   <b>Is</b> <b>there</b> <b>any</b> <b>example</b> <b>code?</b>
       Look in the <u>examples/</u> directory.  Note that  the  examples  on  the  forms  page  are  executable  as-is.
       Contributions of example code would be very welcome!

   <b>Cookies</b>
   <b>Which</b> <b>HTTP</b> <b>cookie</b> <b>protocols</b> <b>does</b> <b>mechanize</b> <b>support?</b>
       Netscape and <u>RFC</u> <u>2965</u>.  RFC 2965 handling is switched off by default.

   <b>What</b> <b>about</b> <b>RFC</b> <b>2109?</b>
       RFC  2109  cookies  are  currently parsed as Netscape cookies, and treated by default as RFC 2965 cookies
       thereafter if RFC 2965 handling is enabled, or as Netscape cookies otherwise.

   <b>Why</b> <b>don't</b> <b>I</b> <b>have</b> <b>any</b> <b>cookies?</b>
       See cookies.

   <b>My</b> <b>response</b> <b>claims</b> <b>to</b> <b>be</b> <b>empty,</b> <b>but</b> <b>I</b> <b>know</b> <b>it's</b> <b>not?</b>
       Did you call <u>response.read()</u> (e.g., in a debug statement), then forget that all the data has already been
       read?  In that case, you may  want  to  use  <u>mechanize.response_seek_wrapper</u>.   <u>mechanize.Browser</u>  always
       returns seekable responses, so it's not necessary to use this explicitly in that case.

   <b>What's</b> <b>the</b> <b>difference</b> <b>between</b> <b>the</b> <u><b>.load()</b></u> <b>and</b> <u><b>.revert()</b></u> <b>methods</b> <b>of</b> <u><b>CookieJar</b></u><b>?</b>
       <u>.load()</u> <u>appends</u> cookies from a file.  <u>.revert()</u> discards all existing cookies held by the <u>CookieJar</u> first
       (but it won't lose any existing cookies if the loading fails).

   <b>Is</b> <b>it</b> <b>threadsafe?</b>
       See threading.

   <b>How</b> <b>do</b> <b>I</b> <b>do</b> <u><b>X</b></u><b>?</b>
       Refer to the API documentation in browser_api.

   <b>Forms</b>
   <b>How</b> <b>do</b> <b>I</b> <b>figure</b> <b>out</b> <b>what</b> <b>control</b> <b>names</b> <b>and</b> <b>values</b> <b>to</b> <b>use?</b>
       <u>print(form)</u>  is  usually  all  you  need.   In  your  code,  things  like the <u>HTMLForm.items</u> attribute of
       <b>mechanize.HTMLForm</b> instances can be useful to inspect forms at runtime.  Note that it's possible  to  use
       item  labels  instead  of  item  names,  which  can be useful — use the <u>by_label</u> arguments to the various
       methods, and the <u>.get_value_by_label()</u> / <u>.set_value_by_label()</u> methods on <u>ListControl</u>.

   <b>What</b> <b>do</b> <b>those</b> <u><b>'*'</b></u> <b>characters</b> <b>mean</b> <b>in</b> <b>the</b> <b>string</b> <b>representations</b> <b>of</b> <b>list</b> <b>controls?</b>
       A <u>*</u> next to an item means that item is selected.

   <b>What</b> <b>do</b> <b>those</b> <b>parentheses</b> <b>(round</b> <b>brackets)</b> <b>mean</b> <b>in</b> <b>the</b> <b>string</b> <b>representations</b> <b>of</b> <b>list</b> <b>controls?</b>
       Parentheses <u>(foo)</u> around an item mean that item is disabled.

   <b>Why</b> <b>doesn't</b> <u><b>&lt;some</b></u> <u><b>control&gt;</b></u> <b>turn</b> <b>up</b> <b>in</b> <b>the</b> <b>data</b> <b>returned</b> <b>by</b> <u><b>.click*()</b></u> <b>when</b> <b>that</b> <b>control</b> <b>has</b> <b>non-</b><u><b>None</b></u> <b>value?</b>
       Either the control is disabled, or it is not successful for some other reason. 'Successful' (see  <u>HTML</u>  <u>4</u>
       <u>specification</u>) means that the control will cause data to get sent to the server.

   <b>Why</b>  <b>does</b>  <b>mechanize</b>  <b>not</b>  <b>follow</b>  <b>the</b>  <b>HTML</b> <b>4.0</b> <b>/</b> <b>RFC</b> <b>1866</b> <b>standards</b> <b>for</b> <u><b>RADIO</b></u> <b>and</b> <b>multiple-selection</b> <u><b>SELECT</b></u>
       <b>controls?</b>
       Because by default, it follows browser behaviour  when  setting  the  initially-selected  items  in  list
       controls that have no items explicitly selected in the HTML.

   <b>Why</b> <b>does</b> <u><b>.click()</b></u> <b>ing</b> <b>on</b> <b>a</b> <b>button</b> <b>not</b> <b>work</b> <b>for</b> <b>me?</b>
       Clicking  on a <u>RESET</u> button doesn't do anything, by design - this is a library for web automation, not an
       interactive browser.  Even in an interactive browser, clicking on <u>RESET</u> sends nothing to the  server,  so
       there is little point in having <u>.click()</u> do anything special here.

       Clicking  on  a  <u>BUTTON</u> <u>TYPE=BUTTON</u> doesn't do anything either, also by design.  This time, the reason is
       that that <u>BUTTON</u> is only in the HTML standard so that one can attach JavaScript callbacks to its  events.
       Their  execution  may  result  in information getting sent back to the server.  mechanize, however, knows
       nothing about these callbacks, so it can't do anything useful with a click on  a  <u>BUTTON</u>  whose  type  is
       <u>BUTTON</u>.

       Generally,  JavaScript  may  be  messing things up in all kinds of ways.  See <u>JavaScript</u> <u>is</u> <u>messing</u> <u>up</u> <u>my</u>
       <u>web-scraping.</u> <u>What</u> <u>do</u> <u>I</u> <u>do?</u>.

   <b>How</b> <b>do</b> <b>I</b> <b>change</b> <u><b>INPUT</b></u> <u><b>TYPE=HIDDEN</b></u> <b>field</b> <b>values</b> <b>(for</b> <b>example,</b> <b>to</b> <b>emulate</b> <b>the</b> <b>effect</b> <b>of</b> <b>JavaScript</b> <b>code)?</b>
       As with any control, set the control's <u>readonly</u> attribute false.

          form.find_control("foo").readonly = False # allow changing .value of control foo
          form.set_all_readonly(False) # allow changing the .value of all controls

   <b>I'm</b> <b>having</b> <b>trouble</b> <b>debugging</b> <b>my</b> <b>code.</b>
       See debugging.

   <b>I</b> <b>have</b> <b>a</b> <b>control</b> <b>containing</b> <b>a</b> <b>list</b> <b>of</b> <b>integers.</b> <b>How</b> <b>do</b> <b>I</b> <b>select</b> <b>the</b> <b>one</b> <b>whose</b> <b>value</b> <b>is</b> <b>nearest</b> <b>to</b> <b>the</b>  <b>one</b>  <b>I</b>
       <b>want?</b>
          import bisect
          def closest_int_value(form, ctrl_name, value):
              values = map(int, [item.name for item in form.find_control(ctrl_name).items])
              return str(values[bisect.bisect(values, value) - 1])

          form["distance"] = [closest_int_value(form, "distance", 23)]

   <b>Miscellaneous</b>
   <b>I</b> <b>want</b> <b>to</b> <b>see</b> <b>what</b> <b>my</b> <b>web</b> <b>browser</b> <b>is</b> <b>doing?</b>
       Use  the  developer tools for your browser (you may have to install them first).  These provide excellent
       views into all HTTP requests/responses in the browser.

   <b>JavaScript</b> <b>is</b> <b>messing</b> <b>up</b> <b>my</b> <b>web-scraping.</b> <b>What</b> <b>do</b> <b>I</b> <b>do?</b>
       JavaScript is used in web pages for many purposes -- for example: creating content that was  not  present
       in  the  page  at load time, submitting or filling in parts of forms in response to user actions, setting
       cookies, etc.  mechanize does not provide any support for JavaScript.

       If you come across this in a page you want to automate, you have a few options.  Here they  are,  roughly
       in order of simplicity:

          • Figure  out what the JavaScript is doing and emulate it in your Python code. The simplest case is if
            the JavaScript is setting some cookies.  In that case you can inspect the cookies  in  your  browser
            and emulate setting them in mechanize with <b>mechanize.Browser.set_simple_cookie()</b>.

          • More  complex  is  to  use your browser developer tools to see exactly what requests are sent by the
            browser and emulate them in mechanize by using <b>mechanize.Request</b> to create the request manually  and
            open it with <b>mechanize.Browser.open()</b>.

          • Third  is  to  use  some  browser  automation  framework/library to scrape the site instead of using
            mechanize. These libraries typically drive a headless version of a full browser that can execute all
            JavaScript. They are typically much slower than using mechanize and far more resource intensive, but
            do work as a last resort.

</pre><h4><b>BROWSER</b> <b>API</b></h4><pre>
       API documentation for the mechanize <u>Browser</u> object.  You can create a mechanize <u>Browser</u> instance as:

          from mechanize import Browser
          br = Browser()

   <b>Contents</b>
       • <u>Browser</u> <u>API</u>

         • <u>The</u> <u>Browser</u>

         • <u>The</u> <u>Request</u>

         • <u>The</u> <u>Response</u>

         • <u>Miscellaneous</u>

   <b>The</b> <b>Browser</b>
       <b>class</b> <b>mechanize.Browser(history=None,</b> <b>request_class=None,</b> <b>content_parser=None,</b> <b>factory_class=&lt;class</b>
       <b>'mechanize._html.Factory'&gt;,</b> <b>allow_xhtml=False)</b>
              Browser-like class with support for history, forms and links.

              <b>BrowserStateError</b> is raised whenever the browser is in the wrong state to complete  the  requested
              operation  -  e.g., when <u>back()</u> is called when the browser history is empty, or when <u>follow_link()</u>
              is called when the current response does not contain HTML data.

              Public attributes:

              request: current request (<u>mechanize.Request</u>)

              form: currently selected form (see <u>select_form()</u>)

              <b>Parameters</b>

                     • <b>history</b> -- object implementing the <u>mechanize.History</u> interface.  Note this  interface  is
                       still experimental and may change in future. This object is owned by the browser instance
                       and must not be shared among browsers.

                     • <b>request_class</b> -- Request class to use. Defaults to <u>mechanize.Request</u>

                     • <b>content_parser</b> -- A function that is responsible for parsing received html/xhtml content.
                       See  the  builtin  <u>mechanize._html.content_parser()</u> function for details on the interface
                       this function must support.

                     • <b>factory_class</b> -- HTML Factory class to use. Defaults to <b>mechanize.Factory</b>

              <b>add_client_certificate(url,</b> <b>key_file,</b> <b>cert_file)</b>
                     Add an SSL client certificate, for HTTPS client auth.

                     key_file and cert_file must be filenames of the key and certificate files, in  PEM  format.
                     You can use e.g. OpenSSL to convert a p12 (PKCS 12) file to PEM format:

                     openssl  pkcs12  -clcerts  -nokeys  -in  cert.p12 -out cert.pem openssl pkcs12 -nocerts -in
                     cert.p12 -out key.pem

                     Note that client certificate password input is very inflexible ATM.   At  the  moment  this
                     seems  to  be  console  only,  which is presumably the default behaviour of libopenssl.  In
                     future mechanize may support third-party libraries that (I assume) allow more options here.

              <b>back(n=1)</b>
                     Go back n steps in history, and return response object.

                     n: go back this number of steps (default 1 step)

              <b>click(*args,</b> <b>**kwds)</b>
                     See <b>mechanize.HTMLForm.click()</b> for documentation.

              <b>click_link(link=None,</b> <b>**kwds)</b>
                     Find a link and return a Request object for it.

                     Arguments are as for <u>find_link()</u>, except that a link may be supplied as the first argument.

              <b>property</b> <b>cookiejar</b>
                     Return the current cookiejar (<b>mechanize.CookieJar</b>) or None

              <b>find_link(text=None,</b> <b>text_regex=None,</b> <b>name=None,</b> <b>name_regex=None,</b> <b>url=None,</b> <b>url_regex=None,</b>
              <b>tag=None,</b> <b>predicate=None,</b> <b>nr=0)</b>
                     Find a link in current page.

                     Links are returned as <u>mechanize.Link</u> objects. Examples:

                        # Return third link that .search()-matches the regexp "python" (by
                        # ".search()-matches", I mean that the regular expression method
                        # .search() is used, rather than .match()).
                        find_link(text_regex=re.compile("python"), nr=2)

                        # Return first http link in the current page that points to
                        # somewhere on python.org whose link text (after tags have been
                        # removed) is exactly "monty python".
                        find_link(text="monty python",
                                url_regex=re.compile("http.*python.org"))

                        # Return first link with exactly three HTML attributes.
                        find_link(predicate=lambda link: len(link.attrs) == 3)

                     Links include anchors <u>&lt;a&gt;</u>, image maps <u>&lt;area&gt;</u>, and frames <u>&lt;iframe&gt;</u>.

                     All arguments must be passed by keyword, not position.   Zero  or  more  arguments  may  be
                     supplied.  In order to find a link, all arguments supplied must match.

                     If a matching link is not found, <b>mechanize.LinkNotFoundError</b> is raised.

                     <b>Parameters</b>

                            • <b>text</b>  --  link  text  between  link  tags:  e.g.  &lt;a href="blah"&gt;this bit&lt;/a&gt; with
                              whitespace compressed.

                            • <b>text_regex</b> -- link text between tag (as defined  above)  must  match  the  regular
                              expression  object  or  regular  expression  string  passed  as  this argument, if
                              supplied

                            • <b>name</b> -- as for text and text_regex, but matched against the name HTML attribute of
                              the link tag

                            • <b>url</b> -- as for text and text_regex, but matched against the URL  of  the  link  tag
                              (note this matches against Link.url, which is a relative or absolute URL according
                              to how it was written in the HTML)

                            • <b>tag</b> -- element name of opening tag, e.g. "a"

                            • <b>predicate</b>  --  a function taking a Link object as its single argument, returning a
                              boolean result, indicating whether the links

                            • <b>nr</b> -- matches the nth link that matches all other criteria (default 0)

              <b>follow_link(link=None,</b> <b>**kwds)</b>
                     Find a link and <u>open()</u> it.

                     Arguments are as for <u>click_link()</u>.

                     Return value is same as for <u>open()</u>.

              <b>forms()</b>
                     Return iterable over forms.

                     The returned form objects implement the <b>mechanize.HTMLForm</b> interface.

              <b>geturl()</b>
                     Get URL of current document.

              <b>global_form()</b>
                     Return the global form object, or None if the factory implementation did not supply one.

                     The "global" form object contains all  controls  that  are  not  descendants  of  any  FORM
                     element.

                     The returned form object implements the <b>mechanize.HTMLForm</b> interface.

                     This  is a separate method since the global form is not regarded as part of the sequence of
                     forms in the document -- mostly for backwards-compatibility.

              <b>links(**kwds)</b>
                     Return iterable over links (<u>mechanize.Link</u> objects).

              <b>open(url_or_request,</b> <b>data=None,</b> <b>timeout=&lt;object</b> <b>object&gt;)</b>
                     Open a URL. Loads the page so that you can subsequently use <u>forms()</u>, <u>links()</u>, etc. on it.

                     <b>Parameters</b>

                            • <b>url_or_request</b> -- Either a URL or a <u>mechanize.Request</u>

                            • <b>data</b> (<u>dict</u>) -- data to send with a POST request

                            • <b>timeout</b> -- Timeout in seconds

                     <b>Returns</b>
                            A <b>mechanize.Response</b> object

              <b>open_novisit(url_or_request,</b> <b>data=None,</b> <b>timeout=&lt;object</b> <b>object&gt;)</b>
                     Open a URL without visiting it.

                     Browser state (including request, response, history, forms and links) is left unchanged  by
                     calling this function.

                     The interface is the same as for <u>open()</u>.

                     This is useful for things like fetching images.

                     See also <u>retrieve()</u>

              <b>reload()</b>
                     Reload current document, and return response object.

              <b>response()</b>
                     Return a copy of the current response.

                     The returned object has the same interface as the object returned by <u>open()</u>

              <b>retrieve(fullurl,</b> <b>filename=None,</b> <b>reporthook=None,</b> <b>data=None,</b> <b>timeout=&lt;object</b> <b>object&gt;,</b>
              <b>open=&lt;built-in</b> <b>function</b> <b>open&gt;)</b>
                     Returns (filename, headers).

                     For  remote  objects, the default filename will refer to a temporary file.  Temporary files
                     are removed when the OpenerDirector.close() method is called.

                     For file: URLs, at present the returned filename is None.  This may change in future.

                     If the actual number of bytes read is less than indicated  by  the  Content-Length  header,
                     raises  ContentTooShortError  (a  URLError  subclass).   The  exception's .result attribute
                     contains the (filename, headers) that would have been returned.

              <b>select_form(name=None,</b> <b>predicate=None,</b> <b>nr=None,</b> <b>**attrs)</b>
                     Select an HTML form for input.

                     This is a bit like giving a form the "input focus" in a browser.

                     If a form is selected, the Browser object supports the HTMLForm interface, so you can  call
                     methods like <b>set_value()</b>, <b>set()</b>, and <u>click()</u>.

                     Another way to select a form is to assign to the .form attribute.  The form assigned should
                     be one of the objects returned by the <u>forms()</u> method.

                     If no matching form is found, <b>mechanize.FormNotFoundError</b> is raised.

                     If <u>name</u> is specified, then the form must have the indicated name.

                     If  <u>predicate</u> is specified, then the form must match that function.  The predicate function
                     is passed the <b>mechanize.HTMLForm</b> as its single argument, and should return a boolean  value
                     indicating whether the form matched.

                     <u>nr</u>,  if  supplied,  is  the  sequence number of the form (where 0 is the first).  Note that
                     control 0 is the first form matching all the other  arguments  (if  supplied);  it  is  not
                     necessarily  the  first  control  in  the  form.  The "global form" (consisting of all form
                     controls not contained in any FORM element) is considered not to be part of  this  sequence
                     and to have no name, so will not be matched unless both name and nr are None.

                     You can also match on any HTML attribute of the <u>&lt;form&gt;</u> tag by passing in the attribute name
                     and  value as keyword arguments. To convert HTML attributes into syntactically valid python
                     keyword arguments, the following simple rule is used. The python keyword argument  name  is
                     converted to an HTML attribute name by: Replacing all underscores with hyphens and removing
                     any  trailing underscores. You can pass in strings, functions or regular expression objects
                     as the values to match. For example:

                        # Match form with the exact action specified
                        br.select_form(action='<a href="http://foo.com/submit.php">http://foo.com/submit.php</a>')
                        # Match form with a class attribute that contains 'login'
                        br.select_form(class_=lambda x: 'login' in x)
                        # Match form with a data-form-type attribute that matches a regex
                        br.select_form(data_form_type=re.compile(r'a|b'))

              <b>set_ca_data(cafile=None,</b> <b>capath=None,</b> <b>cadata=None,</b> <b>context=None)</b>
                     Set the SSL Context used for connecting to SSL servers.

                     This method accepts the same arguments as the <b>ssl.SSLContext.load_verify_locations()</b> method
                     from the python standard library. You can also pass a pre-built  context  via  the  <u>context</u>
                     keyword  argument.  Note  that  to  use this feature, you must be using python &gt;= 2.7.9. In
                     addition you can directly pass in a pre-built <b>ssl.SSLContext</b> as the <u>context</u> argument.

              <b>set_client_cert_manager(cert_manager)</b>
                     Set a mechanize.HTTPClientCertMgr, or None.

              <b>set_cookie(cookie_string)</b>
                     Set a cookie.

                     Note that it is NOT necessary to call this  method  under  ordinary  circumstances:  cookie
                     handling  is  normally entirely automatic.  The intended use case is rather to simulate the
                     setting of a cookie by client script in a web page (e.g. JavaScript).  In that case, use of
                     this method is necessary because mechanize currently does not support JavaScript, VBScript,
                     etc.

                     The cookie is added in the same way as if it had arrived with the current  response,  as  a
                     result  of  the current request.  This means that, for example, if it is not appropriate to
                     set the cookie based on the current request, no cookie will be set.

                     The cookie will be returned automatically with subsequent responses  made  by  the  Browser
                     instance whenever that's appropriate.

                     cookie_string should be a valid value of the Set-Cookie header.

                     For example:

                        browser.set_cookie(
                            "sid=abcdef; expires=Wednesday, 09-Nov-06 23:12:40 GMT")

                     Currently, this method does not allow for adding RFC 2986 cookies.  This limitation will be
                     lifted if anybody requests it.

                     See  also  <u>set_simple_cookie()</u> for an easier way to set cookies without needing to create a
                     Set-Cookie header string.

              <b>set_cookiejar(cookiejar)</b>
                     Set a mechanize.CookieJar, or None.

              <b>set_debug_http(handle)</b>
                     Print HTTP headers to sys.stdout.

              <b>set_debug_redirects(handle)</b>
                     Log information about HTTP redirects (including refreshes).

                     Logging is performed using module logging.  The logger name is  <u>"mechanize.http_redirects"</u>.
                     To actually print some debug output, eg:

                        import sys, logging
                        logger = logging.getLogger("mechanize.http_redirects")
                        logger.addHandler(logging.StreamHandler(sys.stdout))
                        logger.setLevel(logging.INFO)

                     Other logger names relevant to this module:

                     • <u>mechanize.http_responses</u>

                     • <u>mechanize.cookies</u>

                     To turn on everything:

                        import sys, logging
                        logger = logging.getLogger("mechanize")
                        logger.addHandler(logging.StreamHandler(sys.stdout))
                        logger.setLevel(logging.INFO)

              <b>set_debug_responses(handle)</b>
                     Log HTTP response bodies.

                     See <u>set_debug_redirects()</u> for details of logging.

                     Response  objects  may  be  .seek()able  if  this is set (currently returned responses are,
                     raised HTTPError exception responses are not).

              <b>set_handle_equiv(handle,</b> <b>head_parser_class=None)</b>
                     Set whether to treat HTML http-equiv headers like HTTP headers.

                     Response objects may be .seek()able if this  is  set  (currently  returned  responses  are,
                     raised HTTPError exception responses are not).

              <b>set_handle_gzip(handle)</b>
                     Add  header  indicating  to  server  that we handle gzip content encoding. Note that if the
                     server sends gzip'ed content, it is handled automatically in any case, regardless  of  this
                     setting.

              <b>set_handle_redirect(handle)</b>
                     Set whether to handle HTTP 30x redirections.

              <b>set_handle_referer(handle)</b>
                     Set whether to add Referer header to each request.

              <b>set_handle_refresh(handle,</b> <b>max_time=None,</b> <b>honor_time=True)</b>
                     Set whether to handle HTTP Refresh headers.

              <b>set_handle_robots(handle)</b>
                     Set whether to observe rules from robots.txt.

              <b>set_handled_schemes(schemes)</b>
                     Set sequence of URL scheme (protocol) strings.

                     For example: ua.set_handled_schemes(["http", "ftp"])

                     If this fails (with ValueError) because you've passed an unknown scheme, the set of handled
                     schemes will not be changed.

              <b>set_header(header,</b> <b>value=None)</b>
                     Convenience  method to set a header value in <u>self.addheaders</u> so that the header is sent out
                     with all requests automatically.

                     <b>Parameters</b>

                            • <b>header</b> -- The header name, e.g. User-Agent

                            • <b>value</b> -- The header value. If set to None the header is removed.

              <b>set_html(html,</b> <b>url='<a href="http://example.com/">http://example.com/</a>')</b>
                     Set the response to dummy with given HTML, and URL if given.

                     Allows you to then parse that HTML, especially to extract forms information. If no URL  was
                     given then the default is "example.com".

              <b>set_password_manager(password_manager)</b>
                     Set a mechanize.HTTPPasswordMgrWithDefaultRealm, or None.

              <b>set_proxies(proxies=None,</b> <b>proxy_bypass=None)</b>
                     Configure proxy settings.

                     <b>Parameters</b>

                            • <b>proxies</b>  --  dictionary mapping URL scheme to proxy specification.  None means use
                              the default system-specific settings.

                            • <b>proxy_bypass</b> -- function taking hostname, returning whether proxy should be  used.
                              None means use the default system-specific settings.

                     The  default  is to try to obtain proxy settings from the system (see the documentation for
                     urllib.urlopen for information about  the  system-specific  methods  used  --  note  that's
                     urllib, not urllib2).

                     To avoid all use of proxies, pass an empty proxies dict.

                     &gt;&gt;&gt; ua = UserAgentBase()
                     &gt;&gt;&gt; def proxy_bypass(hostname):
                     ...     return hostname == "noproxy.com"
                     &gt;&gt;&gt; ua.set_proxies(
                     ...     {"http": "joe:<a href="mailto:password@myproxy.example.com">password@myproxy.example.com</a>:3128",
                     ...      "ftp": "proxy.example.com"},
                     ...     proxy_bypass)

              <b>set_proxy_password_manager(password_manager)</b>
                     Set a mechanize.HTTPProxyPasswordMgr, or None.

              <b>set_request_gzip(handle)</b>
                     Add  header  indicating  to  server  that we handle gzip content encoding. Note that if the
                     server sends gzip'ed content, it is handled automatically in any case, regardless  of  this
                     setting.

              <b>set_response(response)</b>
                     Replace current response with (a copy of) response.

                     response may be None.

                     This is intended mostly for HTML-preprocessing.

              <b>set_simple_cookie(name,</b> <b>value,</b> <b>domain,</b> <b>path='/')</b>
                     Similar  to  <u>set_cookie()</u>  except that instead of using a cookie string, you simply specify
                     the <u>name</u>, <u>value</u>, <u>domain</u> and optionally the <u>path</u>.  The created cookie will never expire. For
                     example:

                        browser.set_simple_cookie('some_key', 'some_value', '.example.com',
                                                  path='/some-page')

              <b>submit(*args,</b> <b>**kwds)</b>
                     Submit current form.

                     Arguments are as for <b>mechanize.HTMLForm.click()</b>.

                     Return value is same as for <u>open()</u>.

              <b>title()</b>
                     Return title, or None if there is no title element in the document.

              <b>viewing_html()</b>
                     Return whether the current response contains HTML data.

              <b>visit_response(response,</b> <b>request=None)</b>
                     Visit the response, as if it had been <u>open()</u> ed.

                     Unlike <u>set_response()</u>, this updates history rather than replacing the current response.

   <b>The</b> <b>Request</b>
       <b>class</b> <b>mechanize.Request(url,</b> <b>data=None,</b> <b>headers={},</b> <b>origin_req_host=None,</b> <b>unverifiable=False,</b> <b>visit=None,</b>
       <b>timeout=&lt;object</b> <b>object&gt;,</b> <b>method=None)</b>
              A request for some network resource. Note that if you specify the method as 'GET' and the data  as
              a  dict,  then it will be automatically appended to the URL. If you leave method as None, then the
              method will be auto-set to POST and the data will become part of the POST request.

              <b>Parameters</b>

                     • <b>url</b> (<u>str</u>) -- The URL to request

                     • <b>data</b> -- Data to send with this request. Can be either a dictionary which will be  encoded
                       and  sent as application/x-www-form-urlencoded data or a bytestring which will be sent as
                       is. If you use a bytestring you should also set the Content-Type header appropriately.

                     • <b>headers</b> (<u>dict</u>) -- Headers to send with this request

                     • <b>method</b> (<u>str</u>) -- Method to use for HTTP requests. If not specified mechanize  will  choose
                       GET or POST automatically as appropriate.

                     • <b>timeout</b> (<u>float</u>) -- Timeout in seconds

              The remaining arguments are for internal use.

              <b>add_data(data)</b>
                     Set the data (a bytestring) to be sent with this request

              <b>add_header(key,</b> <b>val=None)</b>
                     Add  the  specified  header,  replacing existing one, if needed. If val is None, remove the
                     header.

              <b>add_unredirected_header(key,</b> <b>val)</b>
                     Same as <u>add_header()</u> except that this header will not be sent for redirected requests.

              <b>get_data()</b>
                     The data to be sent with this request

              <b>get_header(header_name,</b> <b>default=None)</b>
                     Get the value of the specified header. If absent, return <u>default</u>

              <b>get_method()</b>
                     The method used for HTTP requests

              <b>has_data()</b>
                     True iff there is some data to be sent with this request

              <b>has_header(header_name)</b>
                     Check if the specified header is present

              <b>has_proxy()</b>
                     Private method.

              <b>header_items()</b>
                     Get a copy of all headers for this request as a list of 2-tuples

              <b>set_data(data)</b>
                     Set the data (a bytestring) to be sent with this request

   <b>The</b> <b>Response</b>
       Response objects in mechanize are <u>seek()</u> able <b>file</b>-like objects that  support  some  additional  methods,
       depending  on  the protocol used for the connection. The documentation below is for HTTP(s) responses, as
       these are the most common.

       Additional methods present for HTTP responses:

       <b>class</b> <b>mechanize._mechanize.HTTPResponse</b>

              <b>code</b>   The HTTP status code

              <b>getcode()</b>
                     Return HTTP status code

              <b>geturl()</b>
                     Return the URL of the resource retrieved, commonly used to  determine  if  a  redirect  was
                     followed

              <b>get_all_header_names(normalize=True)</b>
                     Return a list of all headers names. When <u>normalize</u> is <u>True</u>, the case of the header names is
                     normalized.

              <b>get_all_header_values(name,</b> <b>normalize=True)</b>
                     Return a list of all values for the specified header <u>name</u> (which is case-insensitive. Since
                     headers  in  HTTP can be specified multiple times, the returned value is always a list. See
                     <b>rfc822.Message.getheaders()</b>.

              <b>info()</b> Return the headers of the response as a <b>rfc822.Message</b> instance.

              <b>__getitem__(header_name)</b>
                     Return the <u>last</u> HTTP Header matching the specified  name  as  string.   mechanize  Response
                     object  act  like  dictionaries  for  convenient  access  to  header  values.  For example:
                     <b>response['Date']</b>. You can access header values using the header names,  case-insensitively.
                     Note  that  when  more than one header with the same name is present, only the value of the
                     last header is returned, use <u>get_all_header_values()</u> to get the values of all headers.

              <b>get(header_name,</b> <b>default=None):</b>
                     Return the header value for the specified <u>header_name</u> or  <u>default</u>  if  the  header  is  not
                     present. See <b>__</b><u>getitem</u><b>__</b><u>()</u>.

   <b>Miscellaneous</b>
       <b>class</b> <b>mechanize.Link(base_url,</b> <b>url,</b> <b>text,</b> <b>tag,</b> <b>attrs)</b>
              A link in a HTML document

              <b>Variables</b>

                     • <b>absolute_url</b> -- The absolutized link URL

                     • <b>url</b> -- The link URL

                     • <b>base_url</b> -- The base URL against which this link is resolved

                     • <b>text</b> -- The link text

                     • <b>tag</b> -- The link tag name

                     • <b>attrs</b> -- The tag attributes

       <b>class</b> <b>mechanize.History</b>
              Though this will become public, the implied interface is not yet stable.

       <b>mechanize._html.content_parser(data,</b> <b>url=None,</b> <b>response_info=None,</b> <b>transport_encoding=None,</b>
       <b>default_encoding='utf-8',</b> <b>is_html=True)</b>
              Parse  data  (a  bytes  object)  into  an  etree  representation  such as <b>xml.etree.ElementTree</b> or
              <u>lxml.etree</u>

              <b>Parameters</b>

                     • <b>data</b> (<u>bytes</u>) -- The data to parse

                     • <b>url</b> -- The URL of the document being parsed or None

                     • <b>response_info</b>  --  Information  about  the  document  (contains  all  HTTP   headers   as
                       <b>HTTPMessage</b>)

                     • <b>transport_encoding</b>  --  The character encoding for the document being parsed as specified
                       in the HTTP headers or None.

                     • <b>default_encoding</b> -- The character encoding to use if no encoding could be detected and no
                       transport_encoding is specified

                     • <b>is_html</b> -- If the document is to be parsed as HTML.

</pre><h4><b>HTML</b> <b>FORMS</b> <b>API</b></h4><pre>
       Forms in HTML documents are represented by <u>mechanize.HTMLForm</u>. Every form is a  collection  of  controls.
       The different types of controls are represented by the various classes documented below.

       <b>class</b> <b>mechanize.HTMLForm(action,</b> <b>method='GET',</b> <b>enctype='application/x-www-form-urlencoded',</b> <b>name=None,</b>
       <b>attrs=None,</b> <b>request_class=&lt;class</b> <b>'mechanize._request.Request'&gt;,</b> <b>forms=None,</b> <b>labels=None,</b>
       <b>id_to_labels=None,</b> <b>encoding=None)</b>
              Bases: <b>object</b>

              Represents a single HTML &lt;form&gt; ... &lt;/form&gt; element.

              A  form  consists of a sequence of controls that usually have names, and which can take on various
              values.   The  values  of   the   various   types   of   controls   represent   variously:   text,
              zero-or-one-of-many  or  many-of-many  choices,  and  files  to be uploaded.  Some controls can be
              clicked on to submit the form, and clickable controls' values sometimes include the coordinates of
              the click.

              Forms can be filled in with data to be returned to the server, and then submitted, using the click
              method to  generate  a  request  object  suitable  for  passing  to  <b>mechanize.urlopen()</b>  (or  the
              click_request_data or click_pairs methods for integration with third-party code).

              Usually,  HTMLForm  instances  are  not created directly.  Instead, they are automatically created
              when visting a page with a mechanize Browser.  If you  do  construct  HTMLForm  objects  yourself,
              however,  note  that  an HTMLForm instance is only properly initialised after the fixup method has
              been called.  See <u>mechanize.ListControl</u> for the reason this is required.

              Indexing a form (form["control_name"]) returns the named Control's value attribute.  Assignment to
              a form index (form["control_name"] = something) is equivalent to assignment to the named Control's
              value attribute.  If you need to be more specific than just supplying the control's name, use  the
              set_value and get_value methods.

              ListControl values are lists of item names (specifically, the names of the items that are selected
              and  not  disabled,  and  hence are "successful" -- ie.  cause data to be returned to the server).
              The list item's name is the value of the corresponding HTML element's"value" attribute.

              Example:

                 &lt;INPUT type="CHECKBOX" name="cheeses" value="leicester"&gt;&lt;/INPUT&gt;
                 &lt;INPUT type="CHECKBOX" name="cheeses" value="cheddar"&gt;&lt;/INPUT&gt;

              defines a CHECKBOX control with  name  "cheeses"  which  has  two  items,  named  "leicester"  and
              "cheddar".

              Another example:

                 &lt;SELECT name="more_cheeses"&gt;
                   &lt;OPTION&gt;1&lt;/OPTION&gt;
                   &lt;OPTION value="2" label="CHEDDAR"&gt;cheddar&lt;/OPTION&gt;
                 &lt;/SELECT&gt;

              defines  a SELECT control with name "more_cheeses" which has two items, named "1" and "2" (because
              the  OPTION  element's  value  HTML  attribute  defaults  to   the   element   contents   --   see
              <u>mechanize.SelectControl</u> for more on these defaulting rules).

              To    select,    deselect    or    otherwise   manipulate   individual   list   items,   use   the
              <u>mechanize.HTMLForm.find_control()</u> and  <u>mechanize.ListControl.get()</u>  methods.   To  set  the  whole
              value, do as for any other control: use indexing or the <u>set_value/get_value</u> methods.

              Example:

                 # select *only* the item named "cheddar"
                 form["cheeses"] = ["cheddar"]
                 # select "cheddar", leave other items unaffected
                 form.find_control("cheeses").get("cheddar").selected = True

              Some  controls  (RADIO  and SELECT without the multiple attribute) can only have zero or one items
              selected at a time.  Some controls (CHECKBOX and SELECT with  the  multiple  attribute)  can  have
              multiple  items selected at a time.  To set the whole value of a ListControl, assign a sequence to
              a form index:

                 form["cheeses"] = ["cheddar", "leicester"]

              If the ListControl is not multiple-selection, the assigned list must be of length one.

              To check if a control has an item, if an item is selected, or if an item is  successful  (selected
              and not disabled), respectively:

                 "cheddar" in [item.name for item in form.find_control("cheeses").items]
                 "cheddar" in [item.name for item in form.find_control("cheeses").items
                                 and item.selected]
                 "cheddar" in form["cheeses"]
                 # or
                 "cheddar" in form.get_value("cheeses")

              Note that some list items may be disabled (see below).

              Note the following mistake:

                 form[control_name] = control_value
                 assert form[control_name] == control_value  # not necessarily true

              The  reason for this is that form[control_name] always gives the list items in the order they were
              listed in the HTML.

              List items (hence list values, too) can be referred to in terms of list item  labels  rather  than
              list  item  names  using  the  appropriate  label arguments.  Note that each item may have several
              labels.

              The question of default values of OPTION contents, labels and values is somewhat complicated:  see
              <u>mechanize.SelectControl</u> and <u>mechanize.ListControl.get_item_attrs()</u> if you think you need to know.

              Controls can be disabled or readonly.  In either case, the control's value cannot be changed until
              you  clear  those  flags  (see  example  below).   Disabled  is the state typically represented by
              browsers by 'greying out' a control.  Disabled controls are not 'successful' -- they  don't  cause
              data  to  get  returned  to the server.  Readonly controls usually appear in browsers as read-only
              text boxes.  Readonly controls are successful.  List items can  also  be  disabled.   Attempts  to
              select or deselect disabled items fail with AttributeError.

              If a lot of controls are readonly, it can be useful to do this:

                 form.set_all_readonly(False)

              To  clear a control's value attribute, so that it is not successful (until a value is subsequently
              set):

                 form.clear("cheeses")

              More examples:

                 control = form.find_control("cheeses")
                 control.disabled = False
                 control.readonly = False
                 control.get("gruyere").disabled = True
                 control.items[0].selected = True

              See the various Control classes for further documentation.  Many methods take  name,  type,  kind,
              id,   label   and   nr   arguments   to   specify   the   control   to   be   operated   on:   see
              <u>mechanize.HTMLForm.find_control()</u>.

              ControlNotFoundError (subclass of ValueError) is raised if the specified control can't  be  found.
              This  includes  occasions  where  a  non-ListControl  is  found, but the method (set, for example)
              requires a ListControl.  ItemNotFoundError (subclass of ValueError) is raised if a list item can't
              be found.  ItemCountError (subclass of ValueError) is raised if an attempt is made to select  more
              than  one  item  and  the control doesn't allow that, or set/get_single are called and the control
              contains more than one item.  AttributeError is raised  if  a  control  or  item  is  readonly  or
              disabled and an attempt is made to alter its value.

              Security  note:  Remember that any passwords you store in HTMLForm instances will be saved to disk
              in the clear if you pickle them (directly or indirectly).  The simplest solution  to  this  is  to
              avoid  pickling  HTMLForm  objects.  You could also pickle before filling in any password, or just
              set the password to "" before pickling.

              Public attributes:

              <b>Variables</b>

                     • <b>action</b> -- full (absolute URI) form action

                     • <b>method</b> -- "GET" or "POST"

                     • <b>enctype</b> -- form transfer encoding MIME type

                     • <b>name</b> -- name of form (None if no name was specified)

                     • <b>attrs</b> -- dictionary mapping original HTML form attributes to their values

                     • <b>controls</b>  --  list  of  Control  instances;  do  not  alter  this  list  (instead,   call
                       form.new_control  to make a Control and add it to the form, or control.add_to_form if you
                       already have a Control instance)

              Methods for form filling:

              Most of the these methods have very similar arguments.  See <u>mechanize.HTMLForm.find_control()</u>  for
              details of the name, type, kind, label and nr arguments.

                 def find_control(self,
                                 name=None, type=None, kind=None, id=None,
                                 predicate=None, nr=None, label=None)

                 get_value(name=None, type=None, kind=None, id=None, nr=None,
                         by_label=False,  # by_label is deprecated
                         label=None)
                 set_value(value,
                         name=None, type=None, kind=None, id=None, nr=None,
                         by_label=False,  # by_label is deprecated
                         label=None)

                 clear_all()
                 clear(name=None, type=None, kind=None, id=None, nr=None, label=None)

                 set_all_readonly(readonly)

              Method applying only to FileControls:

                 add_file(file_object,
                      content_type="application/octet-stream", filename=None,
                      name=None, id=None, nr=None, label=None)

              Methods applying only to clickable controls:

                 click(name=None, type=None, id=None, nr=0, coord=(1,1), label=None)
                 click_request_data(name=None, type=None, id=None, nr=0, coord=(1,1),
                                 label=None)
                 click_pairs(name=None, type=None, id=None, nr=0, coord=(1,1),
                                 label=None)

              <b>add_file(file_object,</b> <b>content_type=None,</b> <b>filename=None,</b> <b>name=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>label=None)</b>
                     Add a file to be uploaded.

                     <b>Parameters</b>

                            • <b>file_object</b>  --  file-like  object  (with  read method) from which to read data to
                              upload

                            • <b>content_type</b> -- MIME content type of data to upload

                            • <b>filename</b> -- filename to pass to server

                     If filename is None, no filename is sent to the server.

                     If content_type is None, the content type is guessed based on the  filename  and  the  data
                     from read from the file object.

                     At the moment, guessed content type is always application/octet-stream.

                     Note  the  following  useful  HTML  attributes of file upload controls (see HTML 4.01 spec,
                     section 17):

                        •

                          <u>accept</u><b>:</b> <b>comma-separated</b> <b>list</b> <b>of</b> <b>content</b> <b>types</b>
                                 that the server  will  handle  correctly;  you  can  use  this  to  filter  out
                                 non-conforming files

                        •

                          <u>size</u><b>:</b> <b>XXX</b> <b>IIRC,</b> <b>this</b> <b>is</b> <b>indicative</b> <b>of</b> <b>whether</b> <b>form</b>
                                 wants multiple or single files

                        • <u>maxlength</u>: XXX hint of max content length in bytes?

              <b>clear(name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>label=None)</b>
                     Clear the value attribute of a control.

                     As a result, the affected control will not be successful until a value is subsequently set.
                     AttributeError is raised on readonly controls.

              <b>clear_all()</b>
                     Clear the value attributes of all controls in the form.

                     See <u>mechanize.HTMLForm.clear()</u>

              <b>click(name=None,</b> <b>type=None,</b> <b>id=None,</b> <b>nr=0,</b> <b>coord=(1,</b> <b>1),</b> <b>request_class=&lt;class</b>
              <b>'mechanize._request.Request'&gt;,</b> <b>label=None)</b>
                     Return request that would result from clicking on a control.

                     The   request   object   is   a   mechanize.Request   instance,   which  you  can  pass  to
                     mechanize.urlopen.

                     Only some control types (INPUT/SUBMIT &amp; BUTTON/SUBMIT buttons and IMAGEs) can be clicked.

                     Will click on the first clickable control, subject to the name, type and nr  arguments  (as
                     for  find_control).  If no name, type, id or number is specified and there are no clickable
                     controls, a request will be returned for the form in its current, un-clicked, state.

                     IndexError is raised if any of name, type, id or nr is specified but no matching control is
                     found.  ValueError is raised  if  the  HTMLForm  has  an  enctype  attribute  that  is  not
                     recognised.

                     You  can  optionally specify a coordinate to click at, which only makes a difference if you
                     clicked on an image.

              <b>click_pairs(name=None,</b> <b>type=None,</b> <b>id=None,</b> <b>nr=0,</b> <b>coord=(1,</b> <b>1),</b> <b>label=None)</b>
                     As for click_request_data, but returns a list of (key, value) pairs.

                     You can use this list as an argument to urllib.urlencode.  This is usually only  useful  if
                     you're using httplib or urllib rather than mechanize.  It may also be useful if you want to
                     manually  tweak  the  keys and/or values, but this should not be necessary.  Otherwise, use
                     the click method.

                     Note that this method is only useful for forms  of  MIME  type  x-www-form-urlencoded.   In
                     particular,  it does not return the information required for file upload.  If you need file
                     upload and are not using mechanize, use click_request_data.

              <b>click_request_data(name=None,</b> <b>type=None,</b> <b>id=None,</b> <b>nr=0,</b> <b>coord=(1,</b> <b>1),</b> <b>request_class=&lt;class</b>
              <b>'mechanize._request.Request'&gt;,</b> <b>label=None)</b>
                     As for click method, but return a tuple (url, data, headers).

                     You can use this data to send a request to the server.  This  is  useful  if  you're  using
                     httplib or urllib rather than mechanize.  Otherwise, use the click method.

              <b>find_control(name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>predicate=None,</b> <b>nr=None,</b> <b>label=None)</b>
                     Locate and return some specific control within the form.

                     At  least  one of the name, type, kind, predicate and nr arguments must be supplied.  If no
                     matching control is found, ControlNotFoundError is raised.

                     If name is specified, then the control must have the indicated name.

                     If type is specified then the control must have the specified  type  (in  addition  to  the
                     types  possible  for  &lt;input&gt;  HTML  tags: "text", "password", "hidden", "submit", "image",
                     "button", "radio", "checkbox", "file" we also have "reset", "buttonbutton", "submitbutton",
                     "resetbutton", "textarea", "select").

                     If kind is specified, then the control must fall into the specified group,  each  of  which
                     satisfies a particular interface.  The types are "text", "list", "multilist", "singlelist",
                     "clickable" and "file".

                     If id is specified, then the control must have the indicated id.

                     If  predicate  is  specified,  then  the  control  must match that function.  The predicate
                     function is passed the control as its single argument, and should return  a  boolean  value
                     indicating whether the control matched.

                     nr,  if  supplied, is the sequence number of the control (where 0 is the first).  Note that
                     control 0 is the first control matching all the other arguments (if supplied);  it  is  not
                     necessarily  the first control in the form.  If no nr is supplied, AmbiguityError is raised
                     if multiple controls match the other arguments.

                     If label is specified, then the control must have this label.  Note that radio controls and
                     checkboxes never have labels: their items do.

              <b>fixup()</b>
                     Normalise form after all controls have been added.

                     This is usually called by ParseFile and ParseResponse.  Don't call it youself unless you're
                     building your own Control instances.

                     This method should only be called once, after all controls have been added to the form.

              <b>get_value(name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>by_label=False,</b> <b>label=None)</b>
                     Return value of control.

                     If only name and value arguments are supplied, equivalent to

                        form[name]

              <b>get_value_by_label(name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>label=None,</b> <b>nr=None)</b>
                     All arguments should be passed by name.

              <b>new_control(type,</b> <b>name,</b> <b>attrs,</b> <b>ignore_unknown=False,</b> <b>select_default=False,</b> <b>index=None)</b>
                     Adds a new control to the form.

                     This is usually called by mechanize.  Don't call it yourself unless  you're  building  your
                     own Control instances.

                     Note  that  controls  representing lists of items are built up from controls holding only a
                     single list item.  See <u>mechanize.ListControl</u> for further information.

                     <b>Parameters</b>

                            • <b>type</b> -- type of control (see <u>mechanize.Control</u> for a list)

                            • <b>attrs</b> -- HTML attributes of control

                            • <b>ignore_unknown</b> -- if true, use a dummy Control instance for  controls  of  unknown
                              type; otherwise, use a TextControl

                            • <b>select_default</b> -- for RADIO and multiple-selection SELECT controls, pick the first
                              item  as  the  default if no 'selected' HTML attribute is present (this defaulting
                              happens when the HTMLForm.fixup method is called)

                            • <b>index</b>    --    index     of     corresponding     element     in     HTML     (see
                              MoreFormTests.test_interspersed_controls for motivation)

              <b>possible_items(name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>by_label=False,</b> <b>label=None)</b>
                     Return a list of all values that the specified control can take.

              <b>set(selected,</b> <b>item_name,</b> <b>name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>by_label=False,</b>
              <b>label=None)</b>
                     Select / deselect named list item.

                     <b>Parameters</b>
                            <b>selected</b> -- boolean selected state

              <b>set_single(selected,</b> <b>name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>by_label=None,</b> <b>label=None)</b>
                     Select / deselect list item in a control having only one item.

                     If the control has multiple list items, ItemCountError is raised.

                     This  is  just  a convenience method, so you don't need to know the item's name -- the item
                     name in these single-item controls is usually something meaningless like "1" or "on".

                     For example, if a checkbox has a single item  named  "on",  the  following  two  calls  are
                     equivalent:

                        control.toggle("on")
                        control.toggle_single()

              <b>set_value(value,</b> <b>name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>by_label=False,</b> <b>label=None)</b>
                     Set value of control.

                     If only name and value arguments are supplied, equivalent to

                        form[name] = value

              <b>set_value_by_label(value,</b> <b>name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>label=None,</b> <b>nr=None)</b>
                     All arguments should be passed by name.

              <b>toggle(item_name,</b> <b>name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>by_label=False,</b> <b>label=None)</b>
                     Toggle selected state of named list item.

              <b>toggle_single(name=None,</b> <b>type=None,</b> <b>kind=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>by_label=None,</b> <b>label=None)</b>
                     Toggle selected state of list item in control having only one item.

                     The rest is as for <u>mechanize.HTMLForm.set_single()</u>

       <b>class</b> <b>mechanize.Control(type,</b> <b>name,</b> <b>attrs,</b> <b>index=None)</b>
              Bases: <b>object</b>

              An HTML form control.

              An  HTMLForm  contains a sequence of Controls.  The Controls in an HTMLForm are accessed using the
              HTMLForm.find_control method or the HTMLForm.controls attribute.

              Control instances are usually constructed using the ParseFile / ParseResponse functions.   If  you
              use  those  functions,  you  can  ignore  the  rest of this paragraph.  A Control is only properly
              initialised after the fixup method has been called.  In fact, this is only strictly necessary  for
              ListControl instances.  This is necessary because ListControls are built up from ListControls each
              containing  only a single item, and their initial value(s) can only be known after the sequence is
              complete.

              The types and values that are acceptable for assignment to the  value  attribute  are  defined  by
              subclasses.

              If  the disabled attribute is true, this represents the state typically represented by browsers by
              'greying out' a control.  If the disabled attribute is true, the Control will raise AttributeError
              if an attempt is made to change its value.  In  addition,  the  control  will  not  be  considered
              'successful' as defined by the W3C HTML 4 standard -- ie. it will contribute no data to the return
              value  of the HTMLForm.click* methods.  To enable a control, set the disabled attribute to a false
              value.

              If the readonly attribute is true, the Control will raise AttributeError if an attempt is made  to
              change its value.  To make a control writable, set the readonly attribute to a false value.

              All  controls  have  the  disabled  and readonly attributes, not only those that may have the HTML
              attributes of the same names.

              On  assignment  to  the  value  attribute,  the  following  exceptions  are   raised:   TypeError,
              AttributeError (if the value attribute should not be assigned to, because the control is disabled,
              for example) and ValueError.

              If  the  name  or  value  attributes are None, or the value is an empty list, or if the control is
              disabled, the control is not successful.

              Public attributes:

              <b>Variables</b>

                     • <b>type</b> (<u>str</u>) -- string describing type of control (see the keys of the  HTMLForm.type2class
                       dictionary for the allowable values) (readonly)

                     • <b>name</b> (<u>str</u>) -- name of control (readonly)

                     • <b>value</b>  --  current  value  of control (subclasses may allow a single value, a sequence of
                       values, or either)

                     • <b>disabled</b> (<u>bool</u>) -- disabled state

                     • <b>readonly</b> (<u>bool</u>) -- readonly state

                     • <b>id</b> (<u>str</u>) -- value of id HTML attribute

              <b>get_labels()</b>
                     Return all labels (Label instances) for this control.

                     If the control was surrounded by a &lt;label&gt; tag, that will be the  first  label;  all  other
                     labels, connected by 'for' and 'id', are in the order that appear in the HTML.

              <b>pairs()</b>
                     Return list of (key, value) pairs suitable for passing to urlencode.

       <b>class</b> <b>mechanize.ScalarControl(type,</b> <b>name,</b> <b>attrs,</b> <b>index=None)</b>
              Bases: <u>mechanize._form_controls.Control</u>

              Control whose value is not restricted to one of a prescribed set.

              Some ScalarControls don't accept any value attribute.  Otherwise, takes a single value, which must
              be string-like.

              Additional read-only public attribute:

              <b>Variables</b>
                     <b>attrs</b>  (<u>dict</u>) -- dictionary mapping the names of original HTML attributes of the control to
                     their values

              <b>get_labels()</b>
                     Return all labels (Label instances) for this control.

                     If the control was surrounded by a &lt;label&gt; tag, that will be the  first  label;  all  other
                     labels, connected by 'for' and 'id', are in the order that appear in the HTML.

              <b>pairs()</b>
                     Return list of (key, value) pairs suitable for passing to urlencode.

       <b>class</b> <b>mechanize.TextControl(type,</b> <b>name,</b> <b>attrs,</b> <b>index=None)</b>
              Bases: <u>mechanize._form_controls.ScalarControl</u>

              Textual input control.

              Covers HTML elements: INPUT/TEXT, INPUT/PASSWORD, INPUT/HIDDEN, TEXTAREA

              <b>get_labels()</b>
                     Return all labels (Label instances) for this control.

                     If  the  control  was  surrounded by a &lt;label&gt; tag, that will be the first label; all other
                     labels, connected by 'for' and 'id', are in the order that appear in the HTML.

              <b>pairs()</b>
                     Return list of (key, value) pairs suitable for passing to urlencode.

       <b>class</b> <b>mechanize.FileControl(type,</b> <b>name,</b> <b>attrs,</b> <b>index=None)</b>
              Bases: <u>mechanize._form_controls.ScalarControl</u>

              File upload with INPUT TYPE=FILE.

              The value attribute of a FileControl is always None.  Use add_file instead.

              Additional public method: <u>add_file()</u>

              <b>add_file(file_object,</b> <b>content_type=None,</b> <b>filename=None)</b>
                     Add data from the specified file to be uploaded. content_type and filename are sent in  the
                     HTTP headers if specified.

              <b>get_labels()</b>
                     Return all labels (Label instances) for this control.

                     If  the  control  was  surrounded by a &lt;label&gt; tag, that will be the first label; all other
                     labels, connected by 'for' and 'id', are in the order that appear in the HTML.

              <b>pairs()</b>
                     Return list of (key, value) pairs suitable for passing to urlencode.

       <b>class</b> <b>mechanize.IgnoreControl(type,</b> <b>name,</b> <b>attrs,</b> <b>index=None)</b>
              Bases: <u>mechanize._form_controls.ScalarControl</u>

              Control that we're not interested in.

              Covers html elements: INPUT/RESET, BUTTON/RESET, INPUT/BUTTON, BUTTON/BUTTON

              These controls are always unsuccessful, in the terminology of HTML 4 (ie.  they never require  any
              information to be returned to the server).

              BUTTON/BUTTON is used to generate events for script embedded in HTML.

              The value attribute of IgnoreControl is always None.

              <b>get_labels()</b>
                     Return all labels (Label instances) for this control.

                     If  the  control  was  surrounded by a &lt;label&gt; tag, that will be the first label; all other
                     labels, connected by 'for' and 'id', are in the order that appear in the HTML.

              <b>pairs()</b>
                     Return list of (key, value) pairs suitable for passing to urlencode.

       <b>class</b> <b>mechanize.ListControl(type,</b> <b>name,</b> <b>attrs={},</b> <b>select_default=False,</b> <b>called_as_base_class=False,</b>
       <b>index=None)</b>
              Bases: <u>mechanize._form_controls.Control</u>

              Control representing a sequence of items.

              The value attribute of a ListControl represents the successful list items  in  the  control.   The
              successful list items are those that are selected and not disabled.

              ListControl  implements both list controls that take a length-1 value (single-selection) and those
              that take length &gt;1 values (multiple-selection).

              ListControls accept sequence values only.  Some controls only accept sequences of length  0  or  1
              (RADIO, and single-selection SELECT).  In those cases, ItemCountError is raised if len(sequence) &gt;
              1.   CHECKBOXes and multiple-selection SELECTs (those having the "multiple" HTML attribute) accept
              sequences of any length.

              Note the following mistake:

                 control.value = some_value
                 assert control.value == some_value    # not necessarily true

              The reason for this is that the value attribute always gives the list items in the order they were
              listed in the HTML.

              ListControl items can also be referred to by  their  labels  instead  of  names.   Use  the  label
              argument to .get(), and the .set_value_by_label(), .get_value_by_label() methods.

              Note  that,  rather confusingly, though SELECT controls are represented in HTML by SELECT elements
              (which contain OPTION elements, representing individual list items), CHECKBOXes and RADIOs are not
              represented by <u>any</u> element.  Instead, those controls are represented  by  a  collection  of  INPUT
              elements.  For example, this is a SELECT control, named "control1":

                 &lt;select name="control1"&gt;
                 &lt;option&gt;foo&lt;/option&gt;
                 &lt;option value="1"&gt;bar&lt;/option&gt;
                 &lt;/select&gt;

              and this is a CHECKBOX control, named "control2":

                 &lt;input type="checkbox" name="control2" value="foo" id="cbe1"&gt;
                 &lt;input type="checkbox" name="control2" value="bar" id="cbe2"&gt;

              The  id  attribute  of  a  CHECKBOX  or RADIO ListControl is always that of its first element (for
              example, "cbe1" above).

              Additional read-only public attribute: multiple.

              <b>fixup()</b>
                     ListControls are built up from component list items (which are  also  ListControls)  during
                     parsing.    This   method   should  be  called  after  all  items  have  been  added.   See
                     <u>mechanize.ListControl</u> for the reason this is required.

              <b>get(name=None,</b> <b>label=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>exclude_disabled=False)</b>
                     Return item by name or label, disambiguating if necessary with nr.

                     All arguments must be passed by name, with the exception of 'name', which may be used as  a
                     positional argument.

                     If name is specified, then the item must have the indicated name.

                     If  label  is  specified,  then  the  item  must  have a label whose whitespace-compressed,
                     stripped, text substring-matches the indicated label  string  (e.g.  label="please  choose"
                     will match "  Do  please  choose an item ").

                     If id is specified, then the item must have the indicated id.

                     nr is an optional 0-based index of the items matching the query.

                     If nr is the default None value and more than item is found, raises AmbiguityError.

                     If  no  item  is  found,  or  if  items are found but nr is specified and not found, raises
                     ItemNotFoundError.

                     Optionally excludes disabled items.

              <b>get_item_attrs(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Return dictionary of HTML attributes for a single ListControl item.

                     The HTML element types that describe list items are: OPTION for SELECT controls, INPUT  for
                     the rest.  These elements have HTML attributes that you may occasionally want to know about
                     -- for example, the "alt" HTML attribute gives a text string describing the item (graphical
                     browsers usually display this as a tooltip).

                     The  returned  dictionary  maps  HTML  attribute names to values.  The names and values are
                     taken from the original HTML.

              <b>get_item_disabled(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Get disabled state of named list item in a ListControl.

              <b>get_items(name=None,</b> <b>label=None,</b> <b>id=None,</b> <b>exclude_disabled=False)</b>
                     Return matching items by name or label.

                     For argument docs, see the docstring for .get()

              <b>get_labels()</b>
                     Return all labels (Label instances) for this control.

                     If the control was surrounded by a &lt;label&gt; tag, that will be the  first  label;  all  other
                     labels, connected by 'for' and 'id', are in the order that appear in the HTML.

              <b>get_value_by_label()</b>
                     Return the value of the control as given by normalized labels.

              <b>pairs()</b>
                     Return list of (key, value) pairs suitable for passing to urlencode.

              <b>possible_items(by_label=False)</b>
                     Deprecated: return the names or labels of all possible items.

                     Includes disabled items, which may be misleading for some use cases.

              <b>set(selected,</b> <b>name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Deprecated:  given  a  name or label and optional disambiguating index nr, set the matching
                     item's selection to the bool value of selected.

                     Selecting items follows the behavior described in the docstring of the 'get' method.

                     if the item is disabled, or this control is disabled or readonly, raise AttributeError.

              <b>set_all_items_disabled(disabled)</b>
                     Set disabled state of all list items in a ListControl.

                     <b>Parameters</b>
                            <b>disabled</b> -- boolean disabled state

              <b>set_item_disabled(disabled,</b> <b>name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Set disabled state of named list item in a ListControl.

                     <b>Parameters</b>
                            <b>disabled</b> -- boolean disabled state

              <b>set_single(selected,</b> <b>by_label=None)</b>
                     Deprecated: set the selection of the single item in this control.

                     Raises ItemCountError if the control does not contain only one item.

                     by_label argument is ignored, and included only for backwards compatibility.

              <b>set_value_by_label(value)</b>
                     Set the value of control by item labels.

                     value is expected to be an iterable of strings that are substrings of the item labels  that
                     should  be  selected.   Before  substring matching is performed, the original label text is
                     whitespace-compressed (consecutive whitespace characters are converted to  a  single  space
                     character)  and  leading and trailing whitespace is stripped. Ambiguous labels: it will not
                     complain as long as all ambiguous labels share the same item name (e.g. OPTION value).

              <b>toggle(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Deprecated: given a name or label and optional disambiguating index nr, toggle the matching
                     item's selection.

                     Selecting items follows the behavior described in the docstring of the 'get' method.

                     if the item is disabled, or this control is disabled or readonly, raise AttributeError.

              <b>toggle_single(by_label=None)</b>
                     Deprecated: toggle the selection of the single item in this control.

                     Raises ItemCountError if the control does not contain only one item.

                     by_label argument is ignored, and included only for backwards compatibility.

       <b>class</b> <b>mechanize.RadioControl(type,</b> <b>name,</b> <b>attrs,</b> <b>select_default=False,</b> <b>index=None)</b>
              Bases: <u>mechanize._form_controls.ListControl</u>

              Covers:

              INPUT/RADIO

              <b>fixup()</b>
                     ListControls are built up from component list items (which are  also  ListControls)  during
                     parsing.    This   method   should  be  called  after  all  items  have  been  added.   See
                     <u>mechanize.ListControl</u> for the reason this is required.

              <b>get(name=None,</b> <b>label=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>exclude_disabled=False)</b>
                     Return item by name or label, disambiguating if necessary with nr.

                     All arguments must be passed by name, with the exception of 'name', which may be used as  a
                     positional argument.

                     If name is specified, then the item must have the indicated name.

                     If  label  is  specified,  then  the  item  must  have a label whose whitespace-compressed,
                     stripped, text substring-matches the indicated label  string  (e.g.  label="please  choose"
                     will match "  Do  please  choose an item ").

                     If id is specified, then the item must have the indicated id.

                     nr is an optional 0-based index of the items matching the query.

                     If nr is the default None value and more than item is found, raises AmbiguityError.

                     If  no  item  is  found,  or  if  items are found but nr is specified and not found, raises
                     ItemNotFoundError.

                     Optionally excludes disabled items.

              <b>get_item_attrs(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Return dictionary of HTML attributes for a single ListControl item.

                     The HTML element types that describe list items are: OPTION for SELECT controls, INPUT  for
                     the rest.  These elements have HTML attributes that you may occasionally want to know about
                     -- for example, the "alt" HTML attribute gives a text string describing the item (graphical
                     browsers usually display this as a tooltip).

                     The  returned  dictionary  maps  HTML  attribute names to values.  The names and values are
                     taken from the original HTML.

              <b>get_item_disabled(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Get disabled state of named list item in a ListControl.

              <b>get_items(name=None,</b> <b>label=None,</b> <b>id=None,</b> <b>exclude_disabled=False)</b>
                     Return matching items by name or label.

                     For argument docs, see the docstring for .get()

              <b>get_labels()</b>
                     Return all labels (Label instances) for this control.

                     If the control was surrounded by a &lt;label&gt; tag, that will be the  first  label;  all  other
                     labels, connected by 'for' and 'id', are in the order that appear in the HTML.

              <b>get_value_by_label()</b>
                     Return the value of the control as given by normalized labels.

              <b>pairs()</b>
                     Return list of (key, value) pairs suitable for passing to urlencode.

              <b>possible_items(by_label=False)</b>
                     Deprecated: return the names or labels of all possible items.

                     Includes disabled items, which may be misleading for some use cases.

              <b>set(selected,</b> <b>name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Deprecated:  given  a  name or label and optional disambiguating index nr, set the matching
                     item's selection to the bool value of selected.

                     Selecting items follows the behavior described in the docstring of the 'get' method.

                     if the item is disabled, or this control is disabled or readonly, raise AttributeError.

              <b>set_all_items_disabled(disabled)</b>
                     Set disabled state of all list items in a ListControl.

                     <b>Parameters</b>
                            <b>disabled</b> -- boolean disabled state

              <b>set_item_disabled(disabled,</b> <b>name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Set disabled state of named list item in a ListControl.

                     <b>Parameters</b>
                            <b>disabled</b> -- boolean disabled state

              <b>set_single(selected,</b> <b>by_label=None)</b>
                     Deprecated: set the selection of the single item in this control.

                     Raises ItemCountError if the control does not contain only one item.

                     by_label argument is ignored, and included only for backwards compatibility.

              <b>set_value_by_label(value)</b>
                     Set the value of control by item labels.

                     value is expected to be an iterable of strings that are substrings of the item labels  that
                     should  be  selected.   Before  substring matching is performed, the original label text is
                     whitespace-compressed (consecutive whitespace characters are converted to  a  single  space
                     character)  and  leading and trailing whitespace is stripped. Ambiguous labels: it will not
                     complain as long as all ambiguous labels share the same item name (e.g. OPTION value).

              <b>toggle(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Deprecated: given a name or label and optional disambiguating index nr, toggle the matching
                     item's selection.

                     Selecting items follows the behavior described in the docstring of the 'get' method.

                     if the item is disabled, or this control is disabled or readonly, raise AttributeError.

              <b>toggle_single(by_label=None)</b>
                     Deprecated: toggle the selection of the single item in this control.

                     Raises ItemCountError if the control does not contain only one item.

                     by_label argument is ignored, and included only for backwards compatibility.

       <b>class</b> <b>mechanize.CheckboxControl(type,</b> <b>name,</b> <b>attrs,</b> <b>select_default=False,</b> <b>index=None)</b>
              Bases: <u>mechanize._form_controls.ListControl</u>

              Covers:

              INPUT/CHECKBOX

              <b>fixup()</b>
                     ListControls are built up from component list items (which are  also  ListControls)  during
                     parsing.    This   method   should  be  called  after  all  items  have  been  added.   See
                     <u>mechanize.ListControl</u> for the reason this is required.

              <b>get(name=None,</b> <b>label=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>exclude_disabled=False)</b>
                     Return item by name or label, disambiguating if necessary with nr.

                     All arguments must be passed by name, with the exception of 'name', which may be used as  a
                     positional argument.

                     If name is specified, then the item must have the indicated name.

                     If  label  is  specified,  then  the  item  must  have a label whose whitespace-compressed,
                     stripped, text substring-matches the indicated label  string  (e.g.  label="please  choose"
                     will match "  Do  please  choose an item ").

                     If id is specified, then the item must have the indicated id.

                     nr is an optional 0-based index of the items matching the query.

                     If nr is the default None value and more than item is found, raises AmbiguityError.

                     If  no  item  is  found,  or  if  items are found but nr is specified and not found, raises
                     ItemNotFoundError.

                     Optionally excludes disabled items.

              <b>get_item_attrs(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Return dictionary of HTML attributes for a single ListControl item.

                     The HTML element types that describe list items are: OPTION for SELECT controls, INPUT  for
                     the rest.  These elements have HTML attributes that you may occasionally want to know about
                     -- for example, the "alt" HTML attribute gives a text string describing the item (graphical
                     browsers usually display this as a tooltip).

                     The  returned  dictionary  maps  HTML  attribute names to values.  The names and values are
                     taken from the original HTML.

              <b>get_item_disabled(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Get disabled state of named list item in a ListControl.

              <b>get_items(name=None,</b> <b>label=None,</b> <b>id=None,</b> <b>exclude_disabled=False)</b>
                     Return matching items by name or label.

                     For argument docs, see the docstring for .get()

              <b>get_labels()</b>
                     Return all labels (Label instances) for this control.

                     If the control was surrounded by a &lt;label&gt; tag, that will be the  first  label;  all  other
                     labels, connected by 'for' and 'id', are in the order that appear in the HTML.

              <b>get_value_by_label()</b>
                     Return the value of the control as given by normalized labels.

              <b>pairs()</b>
                     Return list of (key, value) pairs suitable for passing to urlencode.

              <b>possible_items(by_label=False)</b>
                     Deprecated: return the names or labels of all possible items.

                     Includes disabled items, which may be misleading for some use cases.

              <b>set(selected,</b> <b>name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Deprecated:  given  a  name or label and optional disambiguating index nr, set the matching
                     item's selection to the bool value of selected.

                     Selecting items follows the behavior described in the docstring of the 'get' method.

                     if the item is disabled, or this control is disabled or readonly, raise AttributeError.

              <b>set_all_items_disabled(disabled)</b>
                     Set disabled state of all list items in a ListControl.

                     <b>Parameters</b>
                            <b>disabled</b> -- boolean disabled state

              <b>set_item_disabled(disabled,</b> <b>name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Set disabled state of named list item in a ListControl.

                     <b>Parameters</b>
                            <b>disabled</b> -- boolean disabled state

              <b>set_single(selected,</b> <b>by_label=None)</b>
                     Deprecated: set the selection of the single item in this control.

                     Raises ItemCountError if the control does not contain only one item.

                     by_label argument is ignored, and included only for backwards compatibility.

              <b>set_value_by_label(value)</b>
                     Set the value of control by item labels.

                     value is expected to be an iterable of strings that are substrings of the item labels  that
                     should  be  selected.   Before  substring matching is performed, the original label text is
                     whitespace-compressed (consecutive whitespace characters are converted to  a  single  space
                     character)  and  leading and trailing whitespace is stripped. Ambiguous labels: it will not
                     complain as long as all ambiguous labels share the same item name (e.g. OPTION value).

              <b>toggle(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Deprecated: given a name or label and optional disambiguating index nr, toggle the matching
                     item's selection.

                     Selecting items follows the behavior described in the docstring of the 'get' method.

                     if the item is disabled, or this control is disabled or readonly, raise AttributeError.

              <b>toggle_single(by_label=None)</b>
                     Deprecated: toggle the selection of the single item in this control.

                     Raises ItemCountError if the control does not contain only one item.

                     by_label argument is ignored, and included only for backwards compatibility.

       <b>class</b> <b>mechanize.SelectControl(type,</b> <b>name,</b> <b>attrs,</b> <b>select_default=False,</b> <b>index=None)</b>
              Bases: <u>mechanize._form_controls.ListControl</u>

              Covers:

              SELECT (and OPTION)

              OPTION 'values', in HTML parlance, are Item 'names' in mechanize parlance.

              SELECT control values and labels are subject to some messy defaulting rules.  For example, if  the
              HTML representation of the control is:

                 &lt;SELECT name=year&gt;
                     &lt;OPTION value=0 label="2002"&gt;current year&lt;/OPTION&gt;
                     &lt;OPTION value=1&gt;2001&lt;/OPTION&gt;
                     &lt;OPTION&gt;2000&lt;/OPTION&gt;
                 &lt;/SELECT&gt;

              The  items,  in  order,  have  labels  "2002",  "2001" and "2000", whereas their names (the OPTION
              values) are "0", "1" and "2000" respectively.  Note that the value of  the  last  OPTION  in  this
              example  defaults  to  its  contents, as specified by RFC 1866, as do the labels of the second and
              third OPTIONs.

              The OPTION labels are sometimes more meaningful than the OPTION values, which can  make  for  more
              maintainable code.

              Additional read-only public attribute: attrs

              The  attrs attribute is a dictionary of the original HTML attributes of the SELECT element.  Other
              ListControls do not have this attribute, because in other cases the control as a  whole  does  not
              correspond  to any single HTML element.  control.get(...).attrs may be used as usual to get at the
              HTML attributes of the HTML elements corresponding to individual list items (for SELECT  controls,
              these are OPTION elements).

              Another  special case is that the Item.attrs dictionaries have a special key "contents" which does
              not correspond to any real HTML attribute, but rather contains the contents of the OPTION element:

                 &lt;OPTION&gt;this bit&lt;/OPTION&gt;

              <b>fixup()</b>
                     ListControls are built up from component list items (which are  also  ListControls)  during
                     parsing.    This   method   should  be  called  after  all  items  have  been  added.   See
                     <u>mechanize.ListControl</u> for the reason this is required.

              <b>get(name=None,</b> <b>label=None,</b> <b>id=None,</b> <b>nr=None,</b> <b>exclude_disabled=False)</b>
                     Return item by name or label, disambiguating if necessary with nr.

                     All arguments must be passed by name, with the exception of 'name', which may be used as  a
                     positional argument.

                     If name is specified, then the item must have the indicated name.

                     If  label  is  specified,  then  the  item  must  have a label whose whitespace-compressed,
                     stripped, text substring-matches the indicated label  string  (e.g.  label="please  choose"
                     will match "  Do  please  choose an item ").

                     If id is specified, then the item must have the indicated id.

                     nr is an optional 0-based index of the items matching the query.

                     If nr is the default None value and more than item is found, raises AmbiguityError.

                     If  no  item  is  found,  or  if  items are found but nr is specified and not found, raises
                     ItemNotFoundError.

                     Optionally excludes disabled items.

              <b>get_item_attrs(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Return dictionary of HTML attributes for a single ListControl item.

                     The HTML element types that describe list items are: OPTION for SELECT controls, INPUT  for
                     the rest.  These elements have HTML attributes that you may occasionally want to know about
                     -- for example, the "alt" HTML attribute gives a text string describing the item (graphical
                     browsers usually display this as a tooltip).

                     The  returned  dictionary  maps  HTML  attribute names to values.  The names and values are
                     taken from the original HTML.

              <b>get_item_disabled(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Get disabled state of named list item in a ListControl.

              <b>get_items(name=None,</b> <b>label=None,</b> <b>id=None,</b> <b>exclude_disabled=False)</b>
                     Return matching items by name or label.

                     For argument docs, see the docstring for .get()

              <b>get_labels()</b>
                     Return all labels (Label instances) for this control.

                     If the control was surrounded by a &lt;label&gt; tag, that will be the  first  label;  all  other
                     labels, connected by 'for' and 'id', are in the order that appear in the HTML.

              <b>get_value_by_label()</b>
                     Return the value of the control as given by normalized labels.

              <b>pairs()</b>
                     Return list of (key, value) pairs suitable for passing to urlencode.

              <b>possible_items(by_label=False)</b>
                     Deprecated: return the names or labels of all possible items.

                     Includes disabled items, which may be misleading for some use cases.

              <b>set(selected,</b> <b>name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Deprecated:  given  a  name or label and optional disambiguating index nr, set the matching
                     item's selection to the bool value of selected.

                     Selecting items follows the behavior described in the docstring of the 'get' method.

                     if the item is disabled, or this control is disabled or readonly, raise AttributeError.

              <b>set_all_items_disabled(disabled)</b>
                     Set disabled state of all list items in a ListControl.

                     <b>Parameters</b>
                            <b>disabled</b> -- boolean disabled state

              <b>set_item_disabled(disabled,</b> <b>name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Set disabled state of named list item in a ListControl.

                     <b>Parameters</b>
                            <b>disabled</b> -- boolean disabled state

              <b>set_single(selected,</b> <b>by_label=None)</b>
                     Deprecated: set the selection of the single item in this control.

                     Raises ItemCountError if the control does not contain only one item.

                     by_label argument is ignored, and included only for backwards compatibility.

              <b>set_value_by_label(value)</b>
                     Set the value of control by item labels.

                     value is expected to be an iterable of strings that are substrings of the item labels  that
                     should  be  selected.   Before  substring matching is performed, the original label text is
                     whitespace-compressed (consecutive whitespace characters are converted to  a  single  space
                     character)  and  leading and trailing whitespace is stripped. Ambiguous labels: it will not
                     complain as long as all ambiguous labels share the same item name (e.g. OPTION value).

              <b>toggle(name,</b> <b>by_label=False,</b> <b>nr=None)</b>
                     Deprecated: given a name or label and optional disambiguating index nr, toggle the matching
                     item's selection.

                     Selecting items follows the behavior described in the docstring of the 'get' method.

                     if the item is disabled, or this control is disabled or readonly, raise AttributeError.

              <b>toggle_single(by_label=None)</b>
                     Deprecated: toggle the selection of the single item in this control.

                     Raises ItemCountError if the control does not contain only one item.

                     by_label argument is ignored, and included only for backwards compatibility.

       <b>class</b> <b>mechanize.SubmitControl(type,</b> <b>name,</b> <b>attrs,</b> <b>index=None)</b>
              Covers:

              INPUT/SUBMIT BUTTON/SUBMIT

              <b>Members</b>

              <b>Inherited-members</b>

              <b>Show-inheritance</b>

       <b>class</b> <b>mechanize.ImageControl(type,</b> <b>name,</b> <b>attrs,</b> <b>index=None)</b>
              Bases: <u>mechanize._form_controls.SubmitControl</u>

              Covers:

              INPUT/IMAGE

              Coordinates are specified using one of the HTMLForm.click* methods.

              <b>get_labels()</b>
                     Return all labels (Label instances) for this control.

                     If the control was surrounded by a &lt;label&gt; tag, that will be the  first  label;  all  other
                     labels, connected by 'for' and 'id', are in the order that appear in the HTML.

              <b>pairs()</b>
                     Return list of (key, value) pairs suitable for passing to urlencode.

</pre><h4><b>ADVANCED</b> <b>TOPICS</b></h4><pre>
   <b>Thread</b> <b>safety</b>
       The  global <b>mechanize.urlopen()</b> and <b>mechanize.urlretrieve()</b> functions are thread safe. However, mechanize
       browser instances <b>are</b> <b>not</b> thread safe. If you want to  use  a  mechanize  Browser  instance  in  multiple
       threads,  clone  it,  using  <u>copy.copy(browser_object)</u> method. The clone will share the same, thread safe
       cookie jar, and have the same settings/handlers as the original, but  all  other  state  is  not  shared,
       making the clone safe to use in a different thread.

   <b>Using</b> <b>custom</b> <b>CA</b> <b>certificates</b>
       mechanize  supports the same mechanism for using custom CA certificates as python &gt;= 2.7.9. To change the
       certificates a mechanize browser instance uses, call the <b>mechanize.Browser.set_ca_data()</b> method on it.

   <b>Debugging</b>
       Hints for debugging programs that use mechanize.

   <b>Cookies</b>
       A common mistake is to use  <b>mechanize.urlopen()</b>,  <u>and</u>  the  <u>.extract_cookies()</u>  and  <u>.add_cookie_header()</u>
       methods  on  a  cookie object themselves.  If you use <u>mechanize.urlopen()</u> (or <u>OpenerDirector.open()</u>), the
       module handles extraction and adding of cookies by itself, so you should not call  <u>.extract_cookies()</u>  or
       <u>.add_cookie_header()</u>.

       Are you sure the server is sending you any cookies in the first place?  Maybe the server is keeping track
       of state in some other way (<u>HIDDEN</u> HTML form entries (possibly in a separate page referenced by a frame),
       URL-encoded session keys, IP address, HTTP <u>Referer</u> headers)?  Perhaps some embedded script in the HTML is
       setting cookies (see below)?  Turn on <u>Logging</u>.

       When  you  <u>.save()</u>  to  or  <u>.load()</u>/<u>.revert()</u>  from a file, single-session cookies will expire unless you
       explicitly request otherwise with the <u>ignore_discard</u> argument.  This may be  your  problem  if  you  find
       cookies are going away after saving and loading.

          import mechanize
          cj = mechanize.LWPCookieJar()
          opener = mechanize.build_opener(mechanize.HTTPCookieProcessor(cj))
          mechanize.install_opener(opener)
          r = mechanize.urlopen("<a href="http://foobar.com/">http://foobar.com/</a>")
          cj.save("/some/file", ignore_discard=True, ignore_expires=True)

       JavaScript code can set cookies; mechanize does not support this.  See jsfaq.

   <b>General</b>
       Enable <u>Logging</u>.

       Sometimes,  a  server  wants  particular  HTTP  headers  set  to the values it expects.  For example, the
       <u>User-Agent</u> header may need to be set (<b>mechanize.Browser.set_header()</b>) to a value like that of  a  popular
       browser.

       Check  that the browser is able to do manually what you're trying to achieve programmatically.  Make sure
       that what you do manually is <u>exactly</u> the same as what you're trying to do from Python -- you  may  simply
       be hitting a server bug that only gets revealed if you view pages in a particular order, for example.

       Try  comparing  the headers and data that your program sends with those that a browser sends.  Often this
       will give you the clue you need.  You can use the developer tools in any browser to see exactly what  the
       browser sends and receives.

       If  nothing is obviously wrong with the requests your program is sending and you're out of ideas, you can
       reliably locate the problem by copying the headers that a browser sends, and then changing headers  until
       your  program  stops working again.  Temporarily switch to explicitly sending individual HTTP headers (by
       calling <u>.add_header()</u>, or by using <u>httplib</u> directly).  Start by sending exactly the headers that  Firefox
       or  Chrome  send.  You may need to make sure that a valid session ID is sent -- the one you got from your
       browser may no longer be valid.  If that works, you can  begin  the  tedious  process  of  changing  your
       headers  and data until they match what your original code was sending.  You should end up with a minimal
       set of changes.  If you think that reveals a bug in mechanize, please report it.

   <b>Logging</b>
       To enable logging to stdout:

          import sys, logging
          logger = logging.getLogger("mechanize")
          logger.addHandler(logging.StreamHandler(sys.stdout))
          logger.setLevel(logging.DEBUG)

       You can reduce the amount  of  information  shown  by  setting  the  level  to  <u>logging.INFO</u>  instead  of
       <u>logging.DEBUG</u>, or by only enabling logging for one of the following logger names instead of <u>"mechanize"</u>:

          • <u>"mechanize"</u>: Everything.

          • <u>"mechanize.cookies"</u>:  Why  particular  cookies  are accepted or rejected and why they are or are not
            returned.  Requires logging enabled at the <u>DEBUG</u> level.

          • <u>"mechanize.http_responses"</u>: HTTP response body data.

          • <u>"mechanize.http_redirects"</u>: HTTP redirect information.

   <b>HTTP</b> <b>headers</b>
       An example showing how to enable printing of HTTP headers to stdout, logging of HTTP response bodies, and
       logging of information about redirections:

          import sys, logging
          import mechanize

          logger = logging.getLogger("mechanize")
          logger.addHandler(logging.StreamHandler(sys.stdout))
          logger.setLevel(logging.DEBUG)

          browser = mechanize.Browser()
          browser.set_debug_http(True)
          browser.set_debug_responses(True)
          browser.set_debug_redirects(True)
          response = browser.open("<a href="http://python.org/">http://python.org/</a>")

       Alternatively, you can examine request and response objects to see what's going on.  Note  that  requests
       may involve "sub-requests" in cases such as redirection, in which case you will not see everything that's
       going on just by examining the original request and final response.

</pre><h4><b>QUICKSTART</b></h4><pre>
       The examples below are written for a website that does not exist (<u>example.com</u>), so cannot be run.

          import re
          import mechanize

          br = mechanize.Browser()
          br.open("<a href="http://www.example.com/">http://www.example.com/</a>")
          # follow second link with element text matching regular expression
          response1 = br.follow_link(text_regex=r"cheese\s*shop", nr=1)
          print(br.title())
          print(response1.geturl())
          print(response1.info())  # headers
          print(response1.read())  # body

          br.select_form(name="order")
          # Browser passes through unknown attributes (including methods)
          # to the selected HTMLForm.
          br["cheeses"] = ["mozzarella", "caerphilly"]  # (the method here is __setitem__)
          # Submit current form.  Browser calls .close() on the current response on
          # navigation, so this closes response1
          response2 = br.submit()

          # print currently selected form (don't call .submit() on this, use br.submit())
          print(br.form)

          response3 = br.back()  # back to cheese shop (same data as response1)
          # the history mechanism returns cached response objects
          # we can still use the response, even though it was .close()d
          response3.get_data()  # like .<a href="../man0/seek.0.html">seek</a>(0) followed by .read()
          response4 = br.reload()  # fetches from server

          for form in br.forms():
              print(form)
          # .links() optionally accepts the keyword args of .follow_/.find_link()
          for link in br.links(url_regex="python.org"):
              print(link)
              br.follow_link(link)  # takes EITHER Link instance OR keyword args
              br.back()

       You  may  control  the  browser's  policy  by  using  the  methods  of  <u>mechanize.Browser</u>'s  base  class,
       <u>mechanize.UserAgent</u>.  For example:

          br = mechanize.Browser()
          # Explicitly configure proxies (Browser will attempt to set good defaults).
          # Note the userinfo ("joe:password@") and port number (":3128") are optional.
          br.set_proxies({"http": "joe:<a href="mailto:password@myproxy.example.com">password@myproxy.example.com</a>:3128",
                          "ftp": "proxy.example.com",
                          })
          # Add HTTP Basic/Digest auth username and password for HTTP proxy access.
          # (equivalent to using "joe:password@..." form above)
          br.add_proxy_password("joe", "password")
          # Add HTTP Basic/Digest auth username and password for website access.
          br.add_password("<a href="http://example.com/protected/">http://example.com/protected/</a>", "joe", "password")
          # Add an extra header to all outgoing requests, you can also
          # re-order or remove headers in this function.
          br.finalize_request_headers = lambda request, headers: headers.__setitem__(
            'My-Custom-Header', 'Something')
          # Don't handle HTTP-EQUIV headers (HTTP headers embedded in HTML).
          br.set_handle_equiv(False)
          # Ignore robots.txt.  Do not do this without thought and consideration.
          br.set_handle_robots(False)
          # Don't add Referer (sic) header
          br.set_handle_referer(False)
          # Don't handle Refresh redirections
          br.set_handle_refresh(False)
          # Don't handle cookies
          br.set_cookiejar()
          # Supply your own mechanize.CookieJar (NOTE: cookie handling is ON by
          # default: no need to do this unless you have some reason to use a
          # particular cookiejar)
          br.set_cookiejar(cj)
          # Tell the browser to send the Accept-Encoding: gzip header to the server
          # to indicate it supports gzip Content-Encoding
          br.set_request_gzip(True)
          # Do not verify SSL certificates
          import ssl
          br.set_ca_data(context=ssl._create_unverified_context(cert_reqs=ssl.CERT_NONE))
          # Log information about HTTP redirects and Refreshes.
          br.set_debug_redirects(True)
          # Log HTTP response bodies (i.e. the HTML, most of the time).
          br.set_debug_responses(True)
          # Print HTTP headers.
          br.set_debug_http(True)

          # To make sure you're seeing all debug output:
          logger = logging.getLogger("mechanize")
          logger.addHandler(logging.StreamHandler(sys.stdout))
          logger.setLevel(logging.INFO)

          # Sometimes it's useful to process bad headers or bad HTML:
          response = br.response()  # this is a copy of response
          headers = response.info()  # this is a HTTPMessage
          headers["Content-type"] = "text/html; charset=utf-8"
          response.set_data(response.get_data().replace("&lt;!---", "&lt;!--"))
          br.set_response(response)

       mechanize exports the complete interface of <u>urllib2</u>:

          import mechanize
          response = mechanize.urlopen("<a href="http://www.example.com/">http://www.example.com/</a>")
          print(response.read())

       When using mechanize, anything you would normally import from <u>urllib2</u> should be imported  from  mechanize
       instead.

       • genindex

       • modindex

       • search

</pre><h4><b>AUTHOR</b></h4><pre>
       Kovid Goyal

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2021, Kovid Goyal

0.4.7                                             Dec 30, 2021                                      <u><a href="../man1/MECHANIZE.1.html">MECHANIZE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>