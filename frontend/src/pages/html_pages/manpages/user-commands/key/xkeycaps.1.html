<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xkeycaps - graphically display and edit the X keyboard mapping</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/xkeycaps">xkeycaps_2.47-9_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       xkeycaps - graphically display and edit the X keyboard mapping

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>xkeycaps</b> [-<u>toolkitoption</u> ...] [-<u>option</u> ...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>xkeycaps</u>  program  displays  a  keyboard.   Moving  the  mouse  over a key describes the keysyms and
       modifiers that that key generates.  Clicking left on a key simulates a KeyPress event.  Clicking right on
       a key brings up a menu of operations, including a command to change the keysyms that the  key  generates.
       This program is, in part, a graphical front-end to <b><a href="../man1/xmodmap.1.html">xmodmap</a></b>(1).

</pre><h4><b>OPTIONS</b></h4><pre>
       <u>xkeycaps</u> accepts all of the standard toolkit options, and also accepts the following options:

       <b>-keyboard</b> <u>keyboard-name</u> or <b>-kbd</b> <u>keyboard-name</u>
           Specifies the type of keyboard to display.  There are many different computer keyboards in the world,
           and  <u>xkeycaps</u> must know which one you are using in order to function correctly.  Case does not matter
           when specifying a keyboard name.

           If you're running on the console display of a Sun or HP, then <u>xkeycaps</u> will interrogate the  attached
           keyboard  hardware directly to determine what keyboard you're using.  But if you're running remotely,
           or on another type of machine, then you must specify a keyboard somehow.

       <b>-help</b>
           Lists the recognized values for the <b>-keyboard</b> option.

       <b>-gutterwidth</b> <u>number</u> or <b>-gw</b> <u>number</u>
           Specifies the number of pixels of space to leave between each key.

       <b>-font</b> <u>fontname</u>
           Specifies the font to use to display the keycaps.

       The following standard X Toolkit command line arguments are commonly used with <u>xkeycaps</u>:

       <b>-display</b> <u>host:dpy</u>
           This option specifies the X server to contact.

       <b>-geometry</b> <u>geometry</u>
           This option specifies the preferred size and position of the window.

       <b>-bg</b> <u>color</u>
           This option specifies the color to use for the background of the window.  The default is light gray.

       <b>-fg</b> <u>color</u>
           This option specifies the color to use for the foreground of the window.  The default is black.

       <b>-bw</b> <u>number</u>
           This option specifies the width in pixels of the border surrounding the window.

       <b>-xrm</b> <u>resourcestring</u>
           This option specifies a resource string to be used.  This is especially useful for setting  resources
           that do not have separate command line options.

</pre><h4><b>DISPLAY</b></h4><pre>
       The  bottom  part  of  the window is a drawing of a keyboard.  In the top left of each key is printed the
       string which actually appears on the surface of the  key.   In  the  bottom  right  of  the  key  is  the
       (hexadecimal) keycode that this key generates.

       At  the  top  of  the  screen  are  several lines of text describing the key under the mouse (or the most
       recently typed key.)  These lines are:

       <b>KeyCode:</b>    This displays the text printed on the physical key, and the keycode generated by that key  in
                   hex, decimal, and octal.

       <b>KeySym:</b>     This displays the set of KeySyms that this key currently generates.

       <b>ASCII:</b>      This displays the ASCII equivalent of this key, taking into account the current modifier keys
                   which are down.

       <b>Modifiers:</b>  this  displays  the modifier bits which this key generates.  If a key generates modifiers, it
                   is a chord-key like <u>Shift</u> or <u>Control</u>.

       <b>AutoRepeat:</b> Whether the X server claims  that  this  key  autorepeats.   I  say  ``<u>claims</u>''  because  the
                   OpenWindows  X  server  is  the  only  one  I  have encountered for which this information is
                   accurate.  The per-key autorepeat flag seems to be almost-universally ignored.

</pre><h4><b>COMMANDS</b></h4><pre>
       There are several buttons in the upper left corner of the window.  They are:

       <b>Quit</b>
           Exits the program.

       <b>Select</b> <b>Keyboard</b>
           Pops up a dialog box from which you can change which keyboard is displayed.  The  left  column  lists
           the  known  types  of  keyboards,  and  the  right column lists the known layouts (mappings) of those
           keyboards.

       <b>Type</b> <b>At</b> <b>Window</b>
           After selecting this, you are asked to click on some other window.  After  doing  this,  clicking  on
           keys on the keyboard display will simulate key events on the window you selected.  Selecting the root
           window or the <u>xkeycaps</u> window turns this off.

           If you are using a window manager (for example, <b><a href="../man1/twm.1.html">twm</a></b>(1)) in which you can lock the keyboard focus on a
           window  and still click on other windows without having the focus change, then you can accomplish the
           same thing merely by focusing on another window and clicking on the keys in the <u>xkeycaps</u> window.

       <b>Restore</b> <b>Default</b> <b>Map</b>
           This command restores the keyboard  to  its  default  state.   If  you  execute  this  command  while
           displaying  a keyboard which is not the type of keyboard you are really using, your keymap will be in
           a nonsensical state.  There is no way for <u>xkeycaps</u> to tell what keyboard  you  are  using  except  by
           taking your word for it, so don't lie.

       <b>Write</b> <b>Output</b>
           This  command  writes an <u>xmodmap</u> input file representing the current state of the keyboard (including
           all of your changes) to a file in your home directory.  Note that this command DOES NOT write out the
           default keymap for this keyboard type unless you have clicked on Restore Default Map before.

           The file will be called <b>.xmodmap-</b><u>hostname</u>, where <u>hostname</u> is the name of the machine  you're  running
           on.  It will warn you if the file already exists.

           It  prompts  you  with  a  dialog box: you can either write an <u>xmodmap</u> file representing the state of
           every key, or you can write a smaller file which describes only the changes.

           The idea is that in the appropriate startup script, you would add a line like
           xmodmap  /.xmodmap-`uname -n`
           in the appropriate init file, so that those keyboard modifications are made each  time  you  log  in.
           (If  you're  not  sure  where this command should go, ask your system administrator, as that tends to
           vary from site to site.)

       Clicking left on a key simulates a <b>KeyPress</b> event.  Releasing the button simulates  a  <b>KeyRelease</b>  event.
       If  you  click  left on a key and move the mouse while the button is down, <b>KeyPress</b> and <b>KeyRelease</b> events
       will be simulated on every key you move the mouse over.  Think of the mouse as your finger: if  you  drag
       the mouse over several keys, they will go down and up in turn.

       Clicking  left on a key which is associated with modifier bits (such as Shift or Control) causes that key
       to ``lock'' down.  Clicking left again releases the key.  In this way, you can generate  key-chords  with
       the  mouse:  to generate <u>Control-C</u>, click left on the <u>Control</u> key, and then click on the <u>C</u> key.  Click on
       <u>Control</u> again to turn the control modifier off.

       Typing a key on the <u>real</u> keyboard simulates a  <b>KeyPress</b>/<b>KeyRelease</b>  event  pair  in  the  same  way  that
       clicking on a key does.

       You can also combine mouse and keyboard input: for example, if you use the mouse to select the <u>Shift</u> key,
       and type a character, the event that is simulated will have the <u>Shift</u> modifier set.  And if you hold down
       the  real  <u>Control</u>  key,  and  click  on  the  <u>C</u>  key in the window, a <u>Control-C</u> event will be generated.
       (Assuming, that is, that  your  window  manager  does  not  intercept  control-left-button  for  its  own
       purposes.)

       Clicking right on a key pops up a menu of commands for the given key.  They are:

       <b>Exchange</b> <b>Keys</b>
           After selecting this menu item, you are asked to click on another key.  That key and the key on which
           you brought up the menu will be exchanged.  This changes the keyboard mapping immediately.

       <b>Duplicate</b> <b>Key</b>
           After  selecting this menu item, you are asked to click on another key.  That key will be made a copy
           of the key on which you brought up the menu.  That is, the two keys will generate  the  same  set  of
           keysyms and modifiers.  This changes the keyboard mapping immediately.

       <b>Disable</b> <b>Key</b>
           The  key on which you brought up the menu will be made to generate no keysyms and no modifiers.  This
           changes the keyboard mapping immediately.

       <b>Restore</b> <b>Key</b> <b>To</b> <b>Default</b>
           The key on which you brought up the menu will be restored to its default state; no other key will  be
           altered.  This actually changes the current keyboard mapping.

       <b>Edit</b> <b>KeySyms</b> <b>of</b> <b>Key</b>
           This  pops  up  the  "Edit  Key"  window,  which  allows  you to arbitrarily change which keysyms and
           modifiers this key generates.

           On the left side of the window is the list of the keysyms that this key currently generates.  (A  key
           may  generate up to eight keysyms; the interpretation of these keysyms is described in the X protocol
           document, and is summarized later in the <b>KEYSYMS</b> <b>AND</b> <b>KEYCODES</b> section of this man page.)

           The second column is a multiple-choice list of the eight modifier bits that this  key  may  generate.
           For  example,  if  you  want  a  key  to  behave  as a ``control'' key, you should select the <b>Control</b>
           modifier.

           The third and fourth column (the scrolling lists) are for changing the  keysym  associated  with  the
           key.   When  you select a keysym-position from the first column, the character set and keysym will be
           displayed in the scrolling lists.  Clicking on a keysym in the ``KeySym'' column  will  install  that
           keysym in the highlighted slot in the first column.

           To  select  a  keysym  from  a different character set, click on the character set name in the second
           column.  (The <b>Latin1</b> and <b>Keyboard</b> character sets are the most commonly used.)

           At the bottom of the window are three buttons: <b>Undo</b>, <b>Abort</b>, and <b>Ok</b>.  Clicking  on  <b>Undo</b>  reverts  the
           Edit  Key  window  to  the  current  state  of the key in question.  <b>Abort</b> closes the Edit Key window
           without making any changes.  <b>Ok</b> closes the Edit Key window and installs  your  changes  (the  current
           keyboard mapping is modified.)

</pre><h4><b>KEYSYMS</b> <b>AND</b> <b>KEYCODES</b></h4><pre>
       To effectively edit your keyboard mapping, there are some terms you need to be familiar with:

       <u>KeyCode</u>   This is a raw scan-code that is read from the keyboard; each physical key on the keyboard has a
                 different number associated with it; this mapping cannot be changed (but that's ok.)

                 Generally,  every  keyboard has its own set of KeyCodes, which is why you will probably need to
                 have a different keymap for every system you use.

       <u>KeySym</u>    This is a symbol which can be generated by a single press of  one  key  on  the  keyboard:  for
                 example,  all  letters,  numbers,  and punctuation are keysyms, and so are more abstract things
                 like ``shift'' and ``control''.

                 Each KeyCode (that is, key on the keyboard) is associated with certain  KeySyms.   The  KeySyms
                 are what give the keys their semantics (and makes the A key generate an A), not the KeyCodes.

                 Usually  keys are associated with one or two keysyms, which correspond to the symbols generated
                 when the key is pressed, and when it is pressed while the shift key is held down.  There  is  a
                 special  case,  which is that if the key contains only one KeySym, and it is a letter, then the
                 Shift key does the obvious thing that one does to letters.

       <u>KeyCap</u>    Not to be confused with KeySyms, this refers to the text which is printed on the physical keys:
                 it is immutable (unless you repaint your keyboard...)

       <u>Chord</u>     This term refers to a set of two or more keys held down simultaneously (by analogy  with  piano
                 keyboards.)   All but one of the keys will generally be Modifier Keys.  Sometimes <u>Constellation</u>
                 is used to mean the same thing.

       <u>Modifier</u> <u>Key</u>
                 This is a key like shift or control, which is used to alter the interpretation  of  other  keys
                 which are held down at the same time.  Generally, pressing a modifier key without also pressing
                 a non-modifier key does nothing.

                 A  key is a modifier key if it has a Modifier KeySym on it.  (More specifically, if the KeyCode
                 of that key is associated with a Modifier KeySym.)

       <u>Modifier</u> <u>KeySym</u>
                 A KeySym is a modifier keysym if it has a Modifier Bit associated with it.  But, the rules  are
                 a little more complicated than that.  It's easier to describe by example:

                 For  a  key  to  behave as one expects a shift key to behave, the keycode should have the Shift
                 modifier bit set; and the key should generate one of  the  keysyms  Shift_L  and  Shift_R.   If
                 either of these is not true, the key will not behave as a shift key.

                 Analogously,  a  control  key  must  have  the Control modifier set, and use one of the keysyms
                 Control_L or Control_R.

                 This implies that if you wanted to swap your shift and control keys, it would not be enough  to
                 simply  swap  their  modifier  bits: you must swap their keysyms as well.  If you only swap the
                 modifier bits, it might appear to work at first, but other things would malfunction.

                 Keys like Meta (and Super, Hyper, etc.) are a bit more complicated (see below.)

       <u>Modifier</u> <u>Bit</u>
                 Modifier bits are  attributes  which  certain  keysyms  can  have.   Some  modifier  bits  have
                 predefined  semantics:  Shift,  Lock,  and  Control.  The remaining modifier bits (Mod1 through
                 Mod5) have semantics which are defined by the keys with which they are associated.

                 That is, the Control modifier means Control if it is attached to Control_L or Control_R, and is
                 illegal elsewhere.

                 But Mod1 means Meta if it is attached to Meta_L or Meta_R; but it would mean  Alt  if  it  were
                 attached  to  Alt_L  or  Alt_R;  or  Hyper  with Hyper_L or Hyper_R; and so on.  (It could not,
                 however, be attached to Control_L, since the Control modifier  has  already  spoken  for  those
                 keysyms.)

                 If you're thinking that this is all senselessly complicated... you're right.

</pre><h4><b>X</b> <b>PROTOCOL</b> <b>DOCUMENT</b> <b>ON</b> <b>KEYMAPS</b></h4><pre>
       The  following is a more precise technical explanation of how keymapping works.  This description is from
       the X Protocol document, and is reprinted here for your convenience:

           A list of KeySyms is associated with each KeyCode.  If that list (ignoring trailing <b>NoSymbol</b> entries)
           is a single KeySym ``K'', then the list is treated as if it were the list <b>``K</b> <b>NoSymbol</b> <b>K</b>  <b>NoSymbol''</b>.
           If  the  list  (ignoring  trailing <b>NoSymbol</b> entries) is a pair of KeySyms ``K1 K2'', then the list is
           treated as if it were the list <b>``K1</b> <b>K2</b> <b>K1</b> <b>K2''</b>.  If the list (ignoring trailing <b>NoSymbol</b> entries)  is
           a  triple  of  KeySyms  <b>``K1</b>  <b>K2</b>  <b>K3''</b>,  then  the  list is treated as if it were the list <b>``K1</b> <b>K2</b> <b>K3</b>
           <b>NoSymbol''</b>.

           The first four elements of the list are split into two groups of KeySyms.  Group 1 contains the first
           and second KeySyms, Group 2 contains third and fourth KeySyms.  Within  each  group,  if  the  second
           element  of the group is <b>NoSymbol</b>, then the group should be treated as if the second element were the
           same as the first element, except when the first element is an alphabetic KeySym ``K'' for which both
           lowercase and uppercase forms are defined.  In that case, the group should be treated as if the first
           element were the lowercase form of ``K'' and the second element were the uppercase form of ``K''.

           The standard rules for obtaining a KeySym from a KeyPress event make use of  only  the  Group  1  and
           Group  2  KeySyms;  no interpretation of other KeySyms in the list is given here.  (That is, the last
           four KeySyms are unused.)

           Which group to use is determined by modifier state.  Switching between groups is  controlled  by  the
           KeySym named <b>Mode_switch</b>.

           By  attaching that KeySym to some KeyCode and attaching that KeyCode to any one of the modifiers <b>Mod1</b>
           through <b>Mod5</b>.  This modifier is called the ``group modifier''.  For any KeyCode, Group 1 is used when
           the group modifier is off, and Group 2 is used when the group modifier is on.

           Within a group, which KeySym to use is also determined by modifier state.  The first KeySym  is  used
           when  the <b>Shift</b> and <b>Lock</b> modifiers are off.  The second KeySym is used when the <b>Shift</b> modifier is on,
           or when the <b>Lock</b> modifier is on and the second KeySym is  uppercase  alphabetic,  or  when  the  <b>Lock</b>
           modifier  is  on  and  is  interpreted  as <b>ShiftLock</b>.  Otherwise, when the <b>Lock</b> modifier is on and is
           interpreted as <b>CapsLock</b>, the state of the <b>Shift</b> modifier is applied first to select a KeySym, but  if
           that KeySym is lowercase alphabetic, then the corresponding uppercase KeySym is used instead.

</pre><h4><b>ICCCM</b> <b>ON</b> <b>THE</b> <b>MODIFIER</b> <b>MAPPING</b></h4><pre>
       The  following  is  a  more  precise  technical  explanation  of how modifier keys are interpreted.  This
       description is from the Inter-Client Communications Conventions Manual, and is reprinted  here  for  your
       convenience:

           X11 supports 8 modifier bits,  of which 3 are pre-assigned to <b>Shift</b>, <b>Lock</b> and <b>Control</b>.  Each modifier
           bit  is controlled by the state of a set of keys, and these sets are specified in a table accessed by
           <b>GetModifierMapping()</b> and <b>SetModifierMapping()</b>.

           A client needing to use one of the pre-assigned modifiers should assume that the modifier  table  has
           been  set  up  correctly to control these modifiers.  The <u>Lock</u> modifier should be interpreted as <u>Caps</u>
           <u>Lock</u> or <u>Shift</u> <u>Lock</u> according  as  the  keycodes  in  its  controlling  set  include  <b>XK_Caps_Lock</b>  or
           <b>XK_Shift_Lock</b>.

           Clients should determine the meaning of a modifier bit from the keysyms being used to control it.

           A client needing to use an extra modifier,  for example <u>Meta</u>,  should:

             Scan  the  existing modifier mappings.  If it finds a modifier that contains a keycode whose set of
             keysyms includes <b>XK_Meta_L</b> or <b>XK_Meta_R</b>, it should use that modifier bit.

             If there is no existing modifier controlled by <b>XK_Meta_L</b> or <b>XK_Meta_R</b>, it should select  an  unused
             modifier bit (one with an empty controlling set) and:

               If  there  is a keycode with <b>XL_Meta_L</b> in its set of keysyms, add that keycode to the set for the
               chosen modifier, then

               if there is a keycode with <b>XL_Meta_R</b> in its set of keysyms, add that keycode to the set  for  the
               chosen modifier, then

               if  the  controlling set is still empty,  interact with the user to select one or more keys to be
               <b>Meta</b>.

             If there are no unused modifier bits, ask the user to take corrective action.

       The above means that the <b>Mod1</b> modifier does not necessarily mean <u>Meta</u>, although some  applications  (such
       as <u>twm</u> and <u>emacs</u> <u>18</u>) assume that.  Any of the five unassigned modifier bits could mean Meta; what matters
       is that a modifier bit is generated by a keycode which is bound to the keysym <b>Meta_L</b> or <b>Meta_R</b>.

       Therefore,  if you want to make a ``meta'' key, the right way is to make the keycode in question generate
       both a <b>Meta</b> keysym, and some previously-unassigned modifier bit.

</pre><h4><b>THE</b> <b>MODE_SWITCH</b> <b>KEYSYM</b></h4><pre>
       In case the above didn't make sense, what the <b>Mode_switch</b> keysym does is, basically, act as an additional
       kind of shift key.  If you have four keysyms attached to the A key,  then  those  four  keysyms  will  be
       accessed by the chords: A; Shift-A, Mode_Switch-A; and Mode_Switch-Shift-A, respectively.

       Like  any  Modifier  Key,  for  Mode_switch to function, it must have a modifier bit attached to it.  So,
       select one of the bits Mod1 through Mod5 (whichever is unused) and attach that to the Mode_switch key.

</pre><h4><b>THE</b> <b>MULTI_KEY</b> <b>KEYSYM</b></h4><pre>
       Not to be confused with Mode_switch, <b>Multi_key</b> allows the input  of  multiple  character  sequences  that
       represent a single character (keysym.)  A more traditional name for this keysym might have been <u>Compose</u>.

       The  <b>Multi_key</b> keysym is <u>not</u> a modifier keysym.  That is, for it to function properly, it should not have
       any modifier bits associated with it.  This is because it is not a ``chording'' key: you do not  hold  it
       down along with other keys.  Rather, you press Multi_key, then release it, then press and release another
       key, and the two together yield a new character.

       For  example,  one traditional binding would be for <u>Multi_key</u>, followed by <u>single-quote</u>, followed by <u>A</u> to
       produce the <u>Aacute</u> keysym.

       Not all vendors support the use of the Multi_key keysym; in particular, Digital, Sun, and HP support  it,
       but  the  X  Consortium  does  not.   (The  reason for this, I am told, is that ``Compose'' sequences are
       considered obsolete; the party line is that you should be using Input Methods to do this.)

       Whether Multi_key works is a property of the <b>Xt</b> library (not the X server) so it's  possible  that  on  a
       single  system,  Multi_key  might  work  with  some  applications  and not others (depending on how those
       applications were compiled and linked.)

       If you use Lucid Emacs or XEmacs, then you can take advantage of Multi_key sequences even if your version
       of Xt doesn't support it, by loading the <u>x-compose</u> library, which simulates the traditional Xt  behavior.
       For  more  info,  read  the  commentary  at  the  top  of  the  file "/usr/local/lib/xemacs-*/lisp/x11/x-
       compose.el".

</pre><h4><b>DEAD</b> <b>KEYSYMS</b></h4><pre>
       Dead keys work similarly Multi_key, but they are two-keystroke commands instead of three.   For  example,
       pressing  the  <b>Dead_tilde</b>  key,  releasing  it,  then pressing the <u>A</u> key would generate the single keysym
       <u>Atilde</u>.  (They are called ``dead'' keys because they  do  not,  by  themselves,  insert  characters,  but
       instead modify the following character typed.  But HP likes to call them ``mute'' instead of ``dead,'' no
       doubt to avoid frightening the children.)

       Again, these are not supported by all versions of the Xt library (but can be simulated by XEmacs.)

       Also  note  that  different vendors have different names for the dead keysyms.  For example: depending on
       your vendor, X server version, and the phase of the moon, you might find that the name of  ``dead-tilde''
       is  Dead_Tilde,  Dtilde,  SunFA_Tilde,  SunXK_FA_Tilde,  DXK_tilde,  DXK_tilde_accent, hpmute_asciitilde,
       hpXK_mute_asciitilde, or even XK_mute_asciitilde.  It's a mess!  You'll have to just try it and see  what
       works, if anything.

</pre><h4><b>THINGS</b> <b>YOU</b> <b>CAN'T</b> <b>DO</b></h4><pre>
       People  often  ask  if xkeycaps or xmodmap can be used to make one key generate a sequence of characters.
       Unfortunately, no: you can't do this sort of thing by manipulating the server's keymaps.  The X  keyboard
       model just doesn't work that way.

       The way to do such things is to set translation resources on particular widgets.  It has to be done on an
       application-by-application  basis.   For  example,  here's  how you would convince <b><a href="../man1/xterm.1.html">xterm</a></b>(1) to insert the
       string <u>next</u> when you hit F17:
       xterm*VT100.Translations: #override \
           &lt;Key&gt;F17: string("next")
       Other applications may have different mechanisms for accomplishing the same thing, and some  applications
       might not support it at all.  Check the relevant man pages for specifics.

       Likewise,  you can't convince one key to generate another key with modifiers (for example, you can't make
       F1 behave like Ctrl-A except by using translations, as above.)

       It is also not possible to make a keyboard key behave as a mouse button.

</pre><h4><b>LOSER</b> <b>VENDORS</b></h4><pre>
       Both HP and S.u.S.E. ship their systems with broken keyboard settings by  default.   They  really  should
       know better, but they don't.

       As  explained  above,  it  is  <u>undefined</u> <u>behavior</u> for one modifier bit to be shared between two keys with
       dissimilar semantics.

       By default, HP uses <u>Mod1</u> for both <u>Meta</u> and <u>Mode_switch</u>.  This means that it's impossible for a program to
       tell the difference between, for example, Meta-X and Mode_switch-X.

       So, to repair this mess, you need to give the  Mode_switch  key  a  different  modifier  bit  (<u>mod2</u>,  for
       example.)  Or, you could just remove it from the keymap entirely.

       S.u.S.E.  Linux  is  even  more  screwed  up  than HP: whereas HP's default keymap contains only one bug,
       S.u.S.E.'s default map contains three completely different errors!

       First, their default keymap has the <u>Control</u> modifier attached to both the <u>Control</u> key and the  <u>Multi_key</u>.
       This  is completely crazy, because not only is <u>Multi_key</u> not a control key, it's not even a <u>chording</u> key!
       It mustn't have any modifier bits attached to it at all.

       Second, they attach <u>Mod1</u> to <u>Meta_L</u> and also to <u>Alt_R</u>.  Some people think that ``meta''  and  ``alt''  are
       synonyms,  but  the  fact  is  that  the X Window System does not agree.   Those are distinct keys.  It's
       possible to have both ``meta'' and ``alt'' keys on the keyboard at the same time, and  to  have  programs
       interpret  them distinctly.  But of course only if they don't bogusly share the same modifier bit, making
       the interpretation of that bit be ambiguous.

       Third, they attach <u>Mod5</u> to both <u>Scroll_Lock</u> and to <u>Hyper_R</u>, which is wrong for reasons that should by now
       be obvious.

       The easiest way to fix your S.u.S.E. configuration is to: remove <u>control</u> from <u>Multi_key</u>; change the  left
       Alt key to generate <u>Alt_L</u> instead of <u>Meta_L</u>; and delete the <u>Hyper_R</u> keysym from the keyboard.

       If you have any pull with these vendors, I encourage you to encourage them to get their act together.

</pre><h4><b>X</b> <b>RESOURCES</b></h4><pre>
       <u>XKeyCaps</u> understands all of the core resource names and classes as well as:

       <b>*Keyboard.keyboard</b> (class <b>Keyboard</b>)
           Which  keyboard  to  display;  this is the same as the <b>-keyboard</b> command-line option.  If this is not
           specified, the default keyboard is guessed, based on the server's vendor identification string.

       <b>*Keyboard.Keyboard.selectCursor</b> (class <b>Cursor</b>)
           The cursor to use when selecting a key or window with  the  mouse.   The  default  is  the  <u>crosshair</u>
           cursor.

       <b>*Keyboard.Key.highlight</b> (class <b>Background</b>)
           The  color  to  use  to  highlight a key when it is depressed.  If this is the same as the background
           color of the key, it is highlighted with a stipple pattern instead.

       <b>*Keyboard.Key.keycapColor</b> (class <b>Foreground</b>)
           The color to paint the keycap string.

       <b>*Keyboard.Key.keycodeColor</b> (class <b>Foreground</b>)
           The color to paint the keycode number.

       <b>*Keyboard.Key.borderColor</b> (class <b>Color</b>)
           The color of the box around each key.

       <b>*Keyboard.Key.keycapFont</b> (class <b>Font</b>)
           The font to use to draw the keycap string.

       <b>*Keyboard.Key.keycodeFont</b> (class <b>Font</b>)
           The font to use to draw the keycode number.

       <b>*Keyboard.Key.borderWidth</b> (class <b>Int</b>)
           The thickness of the box around each key.

       <b>*Keyboard.Key.gutterWidth</b> (class <b>Int</b>)
           How many pixels to leave between this key and it's neighbors to the right and bottom.

       The class of each key widget is ``Key,'' as you see above.  The name of each key is the string(s) printed
       on its face.  So if you wanted (for example) the <b>Shift</b> keys to have wider borders, you could specify that
       with
       xkeycaps*Keyboard.Shift.borderWidth: 2

</pre><h4><b>ACTIONS</b></h4><pre>
       It is possible to rebind the actions which happen when a key or mouse  button  is  pressed  or  released.
       These actions are available on the <b>Keyboard</b> widget:

       <b>HighlightKey(</b><u>condition</u><b>,</b> <u>arg</u><b>)</b>
           This places the key in question in the highlighted state.

           If  no  <u>argument</u> is passed to this action, then the key is determined by the event which invoked this
           action.  If this action is invoked by a <b>KeyPress</b> or <b>KeyRelease</b>  event,  the  key-widget  is  the  key
           corresponding  to  the  key  that  the  event  represents.  If it is a <b>ButtonPress</b>, <b>ButtonRelease</b>, or
           <b>PointerMotion</b> event, then the key-widget is the one under the mouse.

           The <u>argument</u> may be one of the words <u>mouse</u>, <u>highlighted</u>, or <u>displayed</u>,  meaning  the  key  under  the
           mouse,  the  key most recently highlighted, or the key currently being described in the ``Info'' area
           at the top of the window, respectively.

           The <u>condition</u> may be one of the words <u>ifmod</u>, <u>unlessmod</u>, <u>iftracking</u>, <u>unlesstracking</u>, <u>ifhighlighted</u>, or
           <u>unlesshighlighted</u>.  If <u>ifmod</u> was specified and the key in question (as determined by the <u>argument</u>  or
           by  the  invoking  event)  is  not  a  modifier key, then this action is not executed.  The <u>unlessmod</u>
           condition is the opposite.  The <u>iftracking</u> and <u>unlesstracking</u> conditions allow you to do some actions
           only if (or unless) the key is being ``tracked'' with the mouse (see below.)  The  <u>ifhighlighted</u>  and
           <u>unlesshighlighted</u>  actions  allow  you  to  do some things only if (or unless) the key in question is
           currently in the highlighted state.

       <b>UnhighlightKey(</b><u>condition</u><b>,</b> <u>arg</u><b>)</b>
           This places the key in question in the unhighlighted state.  Arguments are as above.

       <b>ToggleKey(</b><u>condition</u><b>,</b> <u>arg</u><b>)</b>
           This makes the key be highlighted if it is unhighlighted, or  unhighlighted  if  it  is  highlighted.
           Arguments are as above.

       <b>SimulateKeyPress(</b><u>condition</u><b>,</b> <u>arg</u><b>)</b>
           This  action  makes  a  <b>KeyPress</b>  event  corresponding to the key be synthesized on the focus window.
           Arguments are as above.

       <b>SimulateKeyRelease(</b><u>condition</u><b>,</b> <u>arg</u><b>)</b>
           This action makes a <b>KeyRelease</b> event corresponding to the key be synthesized  on  the  focus  window.
           Arguments are as above.

       <b>TrackKey(</b><u>condition</u><b>,</b> <u>arg</u><b>)</b>
           This  makes  the key in question begin being ``tracked'', which means that moving the mouse off of it
           will simulate a button-release action, and then will simulate a button-press action on the  key  that
           the  mouse  has  moved  on  to.   This action may only be invoked from a <b>ButtonPress</b> or <b>ButtonRelease</b>
           event.

       <b>UntrackKey(</b><u>condition</u><b>,</b> <u>arg</u><b>)</b>
           This makes the key in question no longer be ``tracked.''

       <b>DescribeKey(</b><u>condition</u><b>,</b> <u>arg</u><b>)</b>
           This action causes the key and its bindings to be displayed in the ``Info'' section at the top of the
           window, if it is not already described there.

       The default actions for the <b>Keyboard</b> widget are:
       &lt;Motion&gt;:   DescribeKey(mouse,unlessTracking)      \n\
       \
       &lt;KeyDown&gt;:  HighlightKey()                         \
                   DescribeKey(unlessMod)                 \
                   DescribeKey(displayed)                 \
                   SimulateKeyPress()                     \n\
       \
       &lt;KeyUp&gt;:    UnhighlightKey()                       \
                   DescribeKey(displayed)                 \
                   SimulateKeyRelease()                   \n\
       \
       &lt;Btn1Down&gt;: HighlightKey(unlessMod)                \
                   ToggleKey(ifMod)                       \
                   TrackKey(unlessMod)                    \
                   SimulateKeyPress(ifHighlighted)        \
                   SimulateKeyRelease(unlessHighlighted)  \n\
       \
       &lt;Btn1Up&gt;:   UntrackKey(highlighted)                \
                   SimulateKeyRelease(highlighted,unlessMod) \
                   UnhighlightKey(highlighted,unlessMod)  \n\
       \
       &lt;Btn3Down&gt;: XawPositionSimpleMenu(keyMenu)         \
                   MenuPopup(keyMenu)                     \n
       If you don't want a key to be described each time the mouse moves over it, you can  remove  the  <b>&lt;Motion&gt;</b>
       action.  In that case, you should probably add <b>DescribeKey()</b> to the <b>&lt;Btn1Down&gt;</b> and <b>&lt;KeyDown&gt;</b> actions.

       If  you  want  the key under the mouse to be described even while the mouse is moving with a button down,
       then remove the <u>unlessTracking</u> parameter from the <b>DescribeKey</b> action bound to <b>&lt;Motion&gt;</b>.

       If you don't want the modifier keys to toggle, then change the <b>Button1</b> actions to
       xkeycaps*Keyboard.actions:  #override               \
               &lt;Btn1Down&gt;: HighlightKey()                  \
                           TrackKey(unlessmod)             \
                           SimulateKeyPress()              \n\
               &lt;Btn1Up&gt;:   UntrackKey(highlighted)         \
                           SimulateKeyRelease(highlighted) \
                           UnhighlightKey(highlighted)     \n
       Remember that these actions exist on the <u>Keyboard</u> widget, not on the <u>Key</u> widgets.  If you add actions  to
       the <u>Key</u> widgets, things will malfunction.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>DISPLAY</b>
           to get the default host and display number.

       <b>XENVIRONMENT</b>
           to get the name of a resource file that overrides the global resources stored in the RESOURCE_MANAGER
           property.

       <b>XKEYSYMDB</b>
           to get the location of the <b>XKeysymDB</b> file, which lists the vendor-specific keysyms.

</pre><h4><b>UPGRADES</b></h4><pre>
       The latest version can always be found at <a href="http://ftp.debian.org/debian/pool/main/x/xkeycaps/">http://ftp.debian.org/debian/pool/main/x/xkeycaps/</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/X.1.html">X</a></b>(1), <b><a href="../man1/xmodmap.1.html">xmodmap</a></b>(1), <b><a href="../man1/xset.1.html">xset</a></b>(1), <b><a href="../man1/xdpyinfo.1.html">xdpyinfo</a></b>(1)

</pre><h4><b>BUGS</b></h4><pre>
       Because  this  program  has  default  colors that aren't "black" and "white", the <b>-rv</b> command-line option
       doesn't work.  But the incantation
       % xkeycaps -fg white -bg black -bd white
       will do what you want on a monochrome screen.

       The NeXT default map is believed to be incorrect; someone with access to a NeXT will need to debug this.

       There is no portable way to be sure what keyboard is being used; this means it will often not default  to
       the correct one, and if the user makes changes to the keymap while displaying a keyboard which is not the
       right one, very bad things can happen.

       If  you  depress more than a dozen keys at a time, many X servers get confused, and don't transmit enough
       <b>KeyRelease</b> events; the result of this is that the <u>xkeycaps</u> keys will get ``stuck'' until they are pressed
       again.  (Don't go like that.)

       The <b>AutoRepeat</b> flag is apparently useless on all X servers except the OpenWindows one  (I've  never  seen
       another server that didn't ignore it.)

       You  don't get to select from the set of <b>Vendor</b> keysyms (those keysyms which are defined in the <b>XKeysymDB</b>
       file) unless you're running X11r5 or newer.

       NCD's non-US keyboards do not use the standard R4/R5 mechanism for attaching more than two keysyms to one
       key; instead of simply having three or four keysyms attached to the keycode in question, the Compose  key
       changes  the  actual  keycode of the key (it turns its high bit on.)  The xkeycaps program doesn't really
       understand this.  Someone from NCD support told me that in future releases they will do things the  R4/R5
       way  instead  of  the  way  they do things now, so hacking xkeycaps to understand the current behavior is
       probably not worth the effort.

       The <u>Type</u> <u>at</u> <u>Window</u> command doesn't seem to work on the WreckStation version  of  XTerm.   I  assume  some
       variation of the normal XTerm's <u>Allow</u> <u>SendEvents</u> command is necessary.

       If  you  can't  select anything from the right-button popup menu, it might be because you have NumLock or
       CapsLock down.  I'm not sure how to fix this, it seems to be some dumb Xt thing.

       If the popup menu is always greyed out, or doesn't correspond to the key that you clicked on, it might be
       because you're running <u>xswarm</u>, an old version of <u>xautolock</u>,  or  some  other  program  that  antisocially
       interferes with event-propagation.  (Don't go like that.)

       Because  of the nonlinear way in which this program uses <b>XLookupString</b>, there's no sensible way for it to
       do compose processing, and show you the results of ``dead'' key or Multi_key sequences.

       It needs to know about more keyboard types (and no doubt always will...)

       L-shaped keys aren't drawn accurately.  We should use the Shape extension for that.

       In addition to displaying the ASCII version of the given character, it should display  the  corresponding
       character  in  the  character set (Latin2, Kana, Greek, etc.)  This would require having fonts for all of
       those character sets, though, and as far as I can tell, they don't all come standard.

       When running on a Sun and talking to an OpenWindows server, we should parse  the  appropriate  file  from
       $OPENWINHOME/etc/keytables/  to determine the default keymap.  No doubt there are system-specific ways of
       doing this in other environments as well.

       The HP C compiler complains about "invalid pointer initialization" in the header files.  This is a bug in
       that compiler, not in xkeycaps.  This compiler bug goes away if you invoke  HP's  cc  with  the  the  -Aa
       (ANSI) option.

       The  <u>xmodmap</u>  program still sucks.  Since its <u>ADD</u> and <u>REMOVE</u> directives take keysyms as arguments instead
       of keycodes, there are things that you can do with <u>XKeyCaps</u> that you can't represent in an <u>xmodmap</u> script
       (at least, not without great pain.)

       The <u>xmodmap</u> program has no commands for changing the autorepeat status of keys, so  that  information  is
       not  written  in  the  output.   Perhaps  we  could  write out an appropriate <u>xset</u> command instead.  (For
       example, to turn on autorepeat on PgUp (which happens to have key code 103) on  Solaris,  you  would  do:
       "xset r 103".)

       Some  versions of OpenWound use a nonstandard mechanism for specifying which keys have toggle (lock-like)
       behavior (whereas most other X servers base this behavior on the keysym: if Caps_Lock  or  Shift_Lock  is
       generated, the key locks, otherwise it does not.)  <u>XKeyCaps</u> doesn't know how to change the lock status on
       these servers.  This is because I don't know how, either.  If you know what system calls are necessary to
       hack this behavior, tell me.

       The  <u>XKB</u>  interface of X11R6 looks to provide most of the information which xkeycaps needs to know, but I
       haven't had time to investigate this yet.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 1991-1999 by Jamie Zawinski.  Copyright © 2005-2006 by Christoph Berg.   Permission  to  use,
       copy,  modify, distribute, and sell this software and its documentation for any purpose is hereby granted
       without fee, provided that the above copyright notice appear in all copies and that both  that  copyright
       notice  and this permission notice appear in supporting documentation.  No representations are made about
       the suitability of this software for any purpose.  It is provided "as  is"  without  express  or  implied
       warranty.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jamie Zawinski &lt;<a href="mailto:jwz@jwz.org">jwz@jwz.org</a>&gt;, 10-nov-91.

       <b>Please</b> <b>send</b> <b>in</b> <b>any</b> <b>changes</b> <b>you</b> <b>make!</b>  Especially new keyboards.  The strength of this program lies in the
       fact  that it knows about so many different keyboards, thanks to the hundreds contributions received over
       the years.  If you have to make your own modifications, please do your part!  Send the  changes  back  to
       &lt;<a href="mailto:cb@df7cb.de">cb@df7cb.de</a>&gt; to get them incorporated into a future release.

       Thanks to:
           Jonathan  Abbey,  Alon  Albert,  Vladimir  Alexiev,  David Arnold, David Axmark, Ruediger Back, Pedro
           Bayon, Corne Beerse, Eric Benson, Christoph Berg, Markus  Berndt,  Roger  Binns,  Stefan  Bjornelund,
           <a href="mailto:black@westford.ccur.com">black@westford.ccur.com</a>,  Mark Borges, Volker Bosch, Dave Brooks, Lorenzo M. Catucci, Michel Catudal,
           Francois Regis Colin, John Coppens, Cesar Crusius, Bart Van Cutsem, Matthew Davey, Christopher Davis,
           Albrecht Dress, Kristian Ejvind, Michael Elbel, Joe English, Eric Fischer, Morgan  Fletcher,  Olivier
           Galibert,  Carson  Gaspar,  Andre  Gerhard, Daniel Glastonbury, Christian F. Goetze, Dan R. Greening,
           Edgar Greuter, John Gotts, Berthold Gunreben, Jens  Hafsteinsson,  Adam  Hamilton,  Magnus  Hammerin,
           Kenneth  Harker,  Ben  Harris,  Mikael  Hedin, Tom Ivar Helbekkmo, Mick Hellstrom, Neil Hendin, Andre
           Heynatz, Mike Hicks, Alan Ho, Hide Horiuchi, Dirk Jablonowski, Alan Jaffray, Anders  Wegge  Jakobsen,
           Chris Jones, Jorgen Jonsson, Peter Kaiser, Heikki Kantola, Tufan Karadere, Benedikt Kessler, Philippe
           Kipfer, Edwin Klement, John Knox, Haavard Kvaalen, Frederic Leguern, Simon Leinen, Michael Lemke, Tor
           Lillqvist,  Torbjorn  Lindgren,  Tony  Lindstrom, Richard Lloyd, Ulric Longyear, Ulf Magnusson, Cliff
           Marcellus, John A. Martin, Tom McConnell, Grant McDorman,  Hein  Meling,  Jason  Merrill,  Aleksandar
           Milivojevic,  Manuel Moreno, Ken Nakata, Pekka Nikander, Todd Nix, Leif Nixon, Christian Nybo, Antoni
           Pamies Olive, Edgar Bonet Orozco, Steven W. Orr, Martin  Ouwehand,  Daniel  Packman,  John  Palmieri,
           Chris Paulson-Ellis, Antony Pavloff, Eduardo Perez, Michael Piotrowski, Andrej Presern, Jeremy Prior,
           Dominique  Quatravaux,  Matthias  Rabe, Garst R. Reese, Peter Remmers, Todd Richmond, Ken Rose, Pavel
           Rosendorf, Gael Roualland, Lucien Saviot, Johannes Schmidt-Fischer, Andreas Schuch, Larry  Schwimmer,
           Joe  Siegrist,  Jarrod  Smith,  Tom  Spindler,  Robin  Stephenson,  Joerg  Stippa,  D.  Stolte, A. A.
           Stoorvogel, Juergen Stuber, Markus Stumpf, Jeffrey Templon, Jay Thorne,  Anthony  Thyssen,  Christoph
           Tietz,  <a href="mailto:tkil@scrye.com">tkil@scrye.com</a>,  Juha  Vainikka, Poonlap Veeratanabutr, Ivo Vollrath, Gord Vreugdenhil, Ronan
           Waide, Jan Wedekind, Bjorn Wennberg, Mats Wichmann, Stephen Williams, Barry Warsaw, Steven  Winikoff,
           Carl Witty, Stephen Wray, Endre Witzoe, Kazutaka Yokota, Yair Zadik, and Robert Zwickenpflug.

XKeyCaps 2.47                                       02-Jan-06                                        <u><a href="../man1/XKeyCaps.1.html">XKeyCaps</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>