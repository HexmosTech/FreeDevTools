<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>moc - generate Qt meta object support code</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/qtbase5-dev-tools">qtbase5-dev-tools_5.15.15+dfsg-4ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       moc - generate Qt meta object support code

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>moc</b> [-o file] [-i] [-f] [-k] [-ldbg] [-nw] [-p path] [-q path] [-v] file

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  page  documents the <b>Meta</b> <b>Object</b> <b>Compiler</b> for the Qt GUI application framework. The <b>moc</b> reads one or
       more C++ class declarations from a C++ header or source file and generates one C++ source file containing
       meta object information for the classes. The C++ source file generated by the <b>moc</b> must  be  compiled  and
       linked with the implementation of the class (or it can be #included into the class's source file).

       If  you use <b>qmake</b> to create your Makefiles, build rules will be included that call the <b>moc</b> when required,
       so you will not need to use the <b>moc</b> directly.

       In brief, the meta object system is a structure used by Qt (see <b><a href="http://doc.trolltech.com">http://doc.trolltech.com</a></b>)  for  component
       programming  and  run  time  type  information.  It adds properties and inheritance information to (some)
       classes and provides a new type of communication between those instances of  those  classes,  signal-slot
       connections.

</pre><h4><b>OPTIONS</b></h4><pre>
       <u>-o</u> <u>file</u>
              Write output to <u>file</u> rather than to stdout.

       <u>-f</u>     Force  the generation of an #include statement in the output.  This is the default for files whose
              name matches the regular expression .[hH][^.]* (i.e. the extension starts with  <b>H</b>  or  <b>h</b>  ).  This
              option is only useful if you have header files that do not follow the standard naming conventions.

       <u>-i</u>     Do  not  generate  an #include statement in the output.  This may be used to run <b>moc</b> on a C++ file
              containing one or more class declarations. You should then #include the meta object  code  in  the
              .cpp file (see USAGE below).  If both <u>-f</u> and <u>-i</u> are present, the last one wins.

       <u>-nw</u>    Do not generate any warnings. Not recommended.

       <u>-ldbg</u>  Write a flood of lex debug information to stdout.

       <u>-p</u> <u>path</u>
              Makes  <b>moc</b>  prepend  <u>path</u>/  to  the  file  name  in  the  generated  #include statement (if one is
              generated).

       <u>-q</u> <u>path</u>
              Makes <b>moc</b> prepend <u>path</u>/ to the file name of qt #include files in the generated code.

       <u>-v</u>     Displays the version of <b>moc</b> and Qt.

       You can explicitly tell the <b>moc</b> not to parse parts of a header file. It recognizes any C++  comment  (//)
       that  contains  the  substrings MOC_SKIP_BEGIN or MOC_SKIP_END. They work as you would expect and you can
       have several levels of them. The net result as seen by the <b>moc</b> is as if you had removed all lines between
       a MOC_SKIP_BEGIN and a MOC_SKIP_END

</pre><h4><b>USAGE</b></h4><pre>
       <b>moc</b> is almost always invoked by <b><a href="../man1/make.1.html">make</a></b>(1), not by hand.

       <b>moc</b> is typically used with an input file containing class declarations like this:

           class YourClass : public QObject {
               Q_OBJECT
               Q_PROPERTY( ... )
               Q_CLASSINFO( ... )

           public:
               YourClass( QObject * parent=0, const char * name=0 );
               ~YourClass();

           signals:

           public slots:

           };

       Here is a useful makefile rule if you only use GNU make:

           m%.cpp: %.h
                   moc $&lt; -o $@

       If you want to write portably, you can use individual rules of the following form:

           mNAME.cpp: NAME.h
                   moc $&lt; -o $@

       You must also remember to add <u>mNAME.cpp</u> to your SOURCES (substitute  your  favorite  name)  variable  and
       <u>mNAME.o</u> to your OBJECTS variable.

       (While  we  prefer  to name our C++ source files .cpp, the <b>moc</b> doesn't know that, so you can use .C, .cc,
       .CC, .cxx or even .c++ if you prefer.)

       If you have class declarations in C++ files, we recommend that you use a makefile rule like this:

           NAME.o: mNAME.cpp

           mNAME.cpp: NAME.cpp
                   moc -i $&lt; -o $@

       This guarantees that <b><a href="../man1/make.1.html">make</a></b>(1) will run the <b>moc</b> before it compiles <u>NAME.cpp</u>.  You can then put

           #include "nNAME.cpp"

       at the end of <u>NAME.cpp</u>, where all the classes declared in that file are fully known.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Sometimes you may get linkage errors, saying that YourClass::className() is undefined or  that  YourClass
       lacks  a  vtbl.   Those errors happen most often when you forget to compile the moc-generated C++ code or
       include that object file in the link command.

       The <b>moc</b> will warn you about a number of dangerous or illegal constructs.

</pre><h4><b>BUGS</b></h4><pre>
       The <b>moc</b> does not expand #include or #define, it simply skips any preprocessor directives  it  encounters.
       This is regrettable, but is normally not a problem in practice.

       The  <b>moc</b>  does  not  handle  all of C++.  The main problem is that class templates cannot have signals or
       slots.  This is an important bug.  Here is an example:

           class SomeTemplate&lt;int&gt; : public QFrame {
               Q_OBJECT
               ....
           signals:
               void bugInMocDetected( int );
           };

       Less importantly, the following constructs are illegal.  All of them  have  have  alternatives  which  we
       think are usually better, so removing these limitations is not a high priority for us.

   <b>Multiple</b> <b>inheritance</b> <b>requires</b> <b>QObject</b> <b>to</b> <b>be</b> <b>first.</b>
       If  you  are  using  multiple  inheritance,  <b>moc</b>  assumes that the <b>first</b> inherited class is a subclass of
       QObject.  Also, be sure that <b>only</b> the first inherited class is a QObject.

           class SomeClass : public QObject, public OtherClass {
               ...
           };

       This bug is almost impossible to fix; since the <b>moc</b> does not expand #include or #define, it  cannot  find
       out which one of the base classes is a QObject.

   <b>Function</b> <b>pointers</b> <b>cannot</b> <b>be</b> <b>arguments</b> <b>to</b> <b>signals</b> <b>or</b> <b>slots.</b>
       In  most  cases  where you would consider that, we think inheritance is a better alternative.  Here is an
       example of illegal syntax:

           class SomeClass : public QObject {
               Q_OBJECT
               ...
           public slots:
               // illegal
               void apply( void (*apply)(List *, void *), void * );
           };

       You can work around this restriction like this:

           typedef void (*ApplyFunctionType)( List *, void * );

           class SomeClass : public QObject {
               Q_OBJECT
               ...
           public slots:
               void apply( ApplyFunctionType, char * );
           };

       It may sometimes be even better to replace the function pointer with inheritance and  virtual  functions,
       signals or slots.

   <b>Friend</b> <b>declarations</b> <b>cannot</b> <b>be</b> <b>placed</b> <b>in</b> <b>signals</b> <b>or</b> <b>slots</b> <b>sections</b>
       Sometimes  it  will  work,  but  in  general,  friend  declarations  cannot be placed in <b>signals</b> or <b>slots</b>
       sections.  Put them in the good old <b>private</b>, <b>protected</b> or <b>public</b> sections instead.  Here is an example of
       the illegal syntax:

           class SomeClass : public QObject {
               Q_OBJECT
               ...
           signals:
               friend class ClassTemplate&lt;char&gt;; // illegal
           };

   <b>Signals</b> <b>and</b> <b>slots</b> <b>cannot</b> <b>be</b> <b>upgraded</b>
       The C++ feature of upgrading an inherited member function to <b>public</b>  status  is  not  extended  to  cover
       signals and slots.  Here is an illegal example:

           class Whatever : public QButtonGroup {
               ...
           public slots:
               QButtonGroup::buttonPressed; // illegal
               ...
           };

       The QButtonGroup::buttonPressed() slot is protected.

       C++ quiz: What happens if you try to upgrade a protected member function which is overloaded?

              - All the functions are upgraded.

              - That is not legal C++.

   <b>Type</b> <b>macros</b> <b>cannot</b> <b>be</b> <b>used</b> <b>for</b> <b>signal</b> <b>and</b> <b>slot</b> <b>arguments</b>
       Since  the  <b>moc</b>  does  not expand #define, type macros that take an argument will not work in signals and
       slots. Here is an illegal example:

           #ifdef ultrix
           #define SIGNEDNESS(a) unsigned a
           #else
           #define SIGNEDNESS(a) a
           #endif
           class Whatever : public QObject {
               ...
           signals:
               void someSignal( SIGNEDNESS(int) ); // illegal
           };

       A #define without arguments works.

   <b>Nested</b> <b>classes</b> <b>cannot</b> <b>be</b> <b>in</b> <b>the</b> <b>signals</b> <b>or</b> <b>slots</b> <b>sections</b> <b>nor</b> <b>have</b> <b>signals</b> <b>or</b> <b>slots</b>
       Here's an example:

           class A {
               Q_OBJECT
           public:
               class B {
               public slots: // illegal
                   void b();
                   ...
               };
           signals:
               class B {  // illegal
                   void b();
                ...
               }:
           };

   <b>Constructors</b> <b>cannot</b> <b>be</b> <b>used</b> <b>in</b> <b>signals</b> <b>or</b> <b>slots</b> <b>sections</b>
       It is a mystery to us why anyone would put a constructor on either the <b>signals</b> or  <b>slots</b>  sections.   You
       can't,  anyway  (except that it happens to work in some cases).  Put them in <b>private</b>, <b>protected</b> or <b>public</b>
       sections, where they belong.  Here is an example of the illegal syntax:

           class SomeClass : public QObject {
               Q_OBJECT
           public slots:
               SomeClass( QObject *parent, const char *name )
                   : QObject( parent, name ) {} // illegal
               ...
           };

   <b>Properties</b> <b>need</b> <b>to</b> <b>be</b> <b>declared</b> <b>before</b> <b>the</b> <b>public</b> <b>section</b> <b>that</b> <b>contains</b> <b>the</b> <b>respective</b> <b>get</b> <b>and</b> <b>set</b> <b>functions</b>
       Declaring the first property within or after the public section that contains the type definition and the
       respective get and set functions does not work as expected. The <b>moc</b> will complain  that  it  can  neither
       find the functions nor resolve the type. Here is an example of the illegal syntax:

           class SomeClass : public QObject {
               Q_OBJECT
           public:
               ...
               // illegal
               Q_PROPERTY( Priority priority READ priority WRITE setPriority )
               Q_ENUMS( Priority )
               enum Priority { High, Low, VeryHigh, VeryLow };
               void setPriority( Priority );
               Priority priority() const;
               ...
           };

       Work  around this limitation by declaring all properties at the beginning of the class declaration, right
       after Q_OBJECT:

           class SomeClass : public QObject {
               Q_OBJECT
               Q_PROPERTY( Priority priority READ priority WRITE setPriority )
               Q_ENUMS( Priority )
           public:
               ...
               enum Priority { High, Low, VeryHigh, VeryLow };
               void setPriority( Priority );
               Priority priority() const;
               ...
           };

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="http://www.trolltech.com">http://www.trolltech.com</a></b>,   <b>C++</b>   <b>ARM,</b>   <b>section</b>   <b>r.11.3</b>   (for   the   answer   to   the   quiz),   and
       <b><a href="http://doc.trolltech.com">http://doc.trolltech.com</a></b> (for complete Qt documentation).

Trolltech AS                                      24 June 2001                                            <u><a href="../man1/moc.1.html">moc</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>