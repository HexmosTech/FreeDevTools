<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>git-rerere - Reuse recorded resolution of conflicted merges</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/git-man">git-man_2.48.1-0ubuntu1.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       git-rerere - Reuse recorded resolution of conflicted merges

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <u>git</u> <u>rerere</u> [clear | forget &lt;pathspec&gt;... | diff | status | remaining | gc]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       In a workflow employing relatively long lived topic branches, the developer sometimes needs to resolve
       the same conflicts over and over again until the topic branches are done (either merged to the "release"
       branch, or sent out and accepted upstream).

       This command assists the developer in this process by recording conflicted automerge results and
       corresponding hand resolve results on the initial manual merge, and applying previously recorded hand
       resolutions to their corresponding automerge results.

           <b>Note</b>

           You need to set the configuration variable <b>rerere.enabled</b> in order to enable this command.

</pre><h4><b>COMMANDS</b></h4><pre>
       Normally, <u>git</u> <u>rerere</u> is run without arguments or user-intervention. However, it has several commands that
       allow it to interact with its working state.

       <u>clear</u>
           Reset the metadata used by rerere if a merge resolution is to be aborted. Calling <u>git</u> <u>am</u>
           <u>[--skip|--abort]</u> or <u>git</u> <u>rebase</u> <u>[--skip|--abort]</u> will automatically invoke this command.

       <u>forget</u> &lt;pathspec&gt;
           Reset the conflict resolutions which rerere has recorded for the current conflict in &lt;pathspec&gt;.

       <u>diff</u>
           Display diffs for the current state of the resolution. It is useful for tracking what has changed
           while the user is resolving conflicts. Additional arguments are passed directly to the system <u>diff</u>
           command installed in PATH.

       <u>status</u>
           Print paths with conflicts whose merge resolution rerere will record.

       <u>remaining</u>
           Print paths with conflicts that have not been autoresolved by rerere. This includes paths whose
           resolutions cannot be tracked by rerere, such as conflicting submodules.

       <u>gc</u>
           Prune records of conflicted merges that occurred a long time ago. By default, unresolved conflicts
           older than 15 days and resolved conflicts older than 60 days are pruned. These defaults are
           controlled via the <b>gc.rerereUnresolved</b> and <b>gc.rerereResolved</b> configuration variables respectively.

</pre><h4><b>DISCUSSION</b></h4><pre>
       When your topic branch modifies an overlapping area that your master branch (or upstream) touched since
       your topic branch forked from it, you may want to test it with the latest master, even before your topic
       branch is ready to be pushed upstream:

                         o---*---o topic
                        /
               o---o---o---*---o---o master

       For such a test, you need to merge master and topic somehow. One way to do it is to pull master into the
       topic branch:

                   $ git switch topic
                   $ git merge master

                         o---*---o---+ topic
                        /           /
               o---o---o---*---o---o master

       The commits marked with * touch the same area in the same file; you need to resolve the conflicts when
       creating the commit marked with <b>+</b>. Then you can test the result to make sure your work-in-progress still
       works with what is in the latest master.

       After this test merge, there are two ways to continue your work on the topic. The easiest is to build on
       top of the test merge commit <b>+</b>, and when your work in the topic branch is finally ready, pull the topic
       branch into master, and/or ask the upstream to pull from you. By that time, however, the master or the
       upstream might have been advanced since the test merge <b>+</b>, in which case the final commit graph would look
       like this:

                   $ git switch topic
                   $ git merge master
                   $ ... work on both topic and master branches
                   $ git switch master
                   $ git merge topic

                         o---*---o---+---o---o topic
                        /           /         \
               o---o---o---*---o---o---o---o---+ master

       When your topic branch is long-lived, however, your topic branch would end up having many such "Merge
       from master" commits on it, which would unnecessarily clutter the development history. Readers of the
       Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a
       subsystem maintainer asked to pull from a branch full of "useless merges".

       As an alternative, to keep the topic branch clean of test merges, you could blow away the test merge, and
       keep building on top of the tip before the test merge:

                   $ git switch topic
                   $ git merge master
                   $ git reset --hard HEAD^ ;# rewind the test merge
                   $ ... work on both topic and master branches
                   $ git switch master
                   $ git merge topic

                         o---*---o-------o---o topic
                        /                     \
               o---o---o---*---o---o---o---o---+ master

       This would leave only one merge commit when your topic branch is finally ready and merged into the master
       branch. This merge would require you to resolve the conflict, introduced by the commits marked with *.
       However, this conflict is often the same conflict you resolved when you created the test merge you blew
       away. <u>git</u> <u>rerere</u> helps you resolve this final conflicted merge using the information from your earlier
       hand resolve.

       Running the <u>git</u> <u>rerere</u> command immediately after a conflicted automerge records the conflicted working
       tree files, with the usual conflict markers &lt;&lt;&lt;&lt;&lt;&lt;&lt;, <b>=======</b>, and &gt;&gt;&gt;&gt;&gt;&gt;&gt; in them. Later, after you are
       done resolving the conflicts, running <u>git</u> <u>rerere</u> again will record the resolved state of these files.
       Suppose you did this when you created the test merge of master into the topic branch.

       Next time, after seeing the same conflicted automerge, running <u>git</u> <u>rerere</u> will perform a three-way merge
       between the earlier conflicted automerge, the earlier manual resolution, and the current conflicted
       automerge. If this three-way merge resolves cleanly, the result is written out to your working tree file,
       so you do not have to manually resolve it. Note that <u>git</u> <u>rerere</u> leaves the index file alone, so you still
       need to do the final sanity checks with <b>git</b> <b>diff</b> (or <b>git</b> <b>diff</b> <b>-c</b>) and <u>git</u> <u>add</u> when you are satisfied.

       As a convenience measure, <u>git</u> <u>merge</u> automatically invokes <u>git</u> <u>rerere</u> upon exiting with a failed automerge
       and <u>git</u> <u>rerere</u> records the hand resolve when it is a new conflict, or reuses the earlier hand resolve
       when it is not. <u>git</u> <u>commit</u> also invokes <u>git</u> <u>rerere</u> when committing a merge result. What this means is
       that you do not have to do anything special yourself (besides enabling the rerere.enabled config
       variable).

       In our example, when you do the test merge, the manual resolution is recorded, and it will be reused when
       you do the actual merge later with the updated master and topic branch, as long as the recorded
       resolution is still applicable.

       The information <u>git</u> <u>rerere</u> records is also used when running <u>git</u> <u>rebase</u>. After blowing away the test
       merge and continuing development on the topic branch:

                         o---*---o-------o---o topic
                        /
               o---o---o---*---o---o---o---o   master

                   $ git rebase master topic

                                             o---*---o-------o---o topic
                                            /
               o---o---o---*---o---o---o---o   master

       you could run <b>git</b> <b>rebase</b> <b>master</b> <b>topic</b>, to bring yourself up to date before your topic is ready to be sent
       upstream. This would result in falling back to a three-way merge, and it would conflict the same way as
       the test merge you resolved earlier. <u>git</u> <u>rerere</u> will be run by <u>git</u> <u>rebase</u> to help you resolve this
       conflict.

       [NOTE] <u>git</u> <u>rerere</u> relies on the conflict markers in the file to detect the conflict. If the file already
       contains lines that look the same as lines with conflict markers, <u>git</u> <u>rerere</u> may fail to record a
       conflict resolution. To work around this, the <b>conflict-marker-size</b> setting in <b><a href="../man5/gitattributes.5.html">gitattributes</a></b>(5) can be
       used.

</pre><h4><b>GIT</b></h4><pre>
       Part of the <b><a href="../man1/git.1.html">git</a></b>(1) suite

Git 2.48.1                                         07/02/2025                                      <u><a href="../man1/GIT-RERERE.1.html">GIT-RERERE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>