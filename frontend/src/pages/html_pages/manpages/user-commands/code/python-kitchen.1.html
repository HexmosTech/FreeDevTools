<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kitchen - kitchen 1.2.6</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python-kitchen-doc">python-kitchen-doc_1.2.6-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       kitchen - kitchen 1.2.6

       <b>Author</b> Toshio Kuratomi

       <b>Date</b>   19 March 2011

       <b>Version</b>
              1.0.x

       We've  all  done  it.   In the process of writing a brand new application we've discovered that we need a
       little bit of code that we've invented before.  Perhaps it's something to handle unicode  text.   Perhaps
       it's  something  to  make a bit of python-2.5 code run on python-2.4.  Whatever it is, it ends up being a
       tiny bit of code that seems too small to worry about pushing into its own module so it sits there, a part
       of your current project, waiting to be cut and pasted into your next project.  And  the  next.   And  the
       next.   And since that little bittybit of code proved so useful to you, it's highly likely that it proved
       useful to someone else as well.  Useful enough that they've written it and copy and pasted  it  over  and
       over into each of their new projects.

       Well,  no  longer!  Kitchen aims to pull these small snippets of code into a few python modules which you
       can import and use within your project.  No more copy and paste!  Now you can let someone  else  maintain
       and release these small snippets so that you can get on with your life.

       This  package forms the core of Kitchen.  It contains some useful modules for using newer <u>python</u> <u>standard</u>
       <u>library</u> modules on older python  versions,  text  manipulation,  <u>PEP</u>  <u>386</u>  versioning,  and  initializing
       <b>gettext</b>.   With  this  package  we're  trying  to  provide a few useful features that don't have too many
       dependencies outside of the <u>python</u> <u>standard</u> <u>library</u>.  We'll be releasing other modules that drop into the
       kitchen namespace to add other features (possibly with larger deps) as time goes on.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       We've tried to keep the core kitchen module's requirements  lightweight.   At  the  moment  kitchen  only
       requires

       <b>python</b> 2.4 or later

       <b>WARNING:</b>
          Kitchen-1.1.0 was the last release to support python-2.3.x.

   <b>Soft</b> <b>Requirements</b>
       If  found, these libraries will be used to make the implementation of some part of kitchen better in some
       way.  If they are not present, the API that they enable will still exist but may function in a  different
       manner.

       <u>chardet</u>
              Used  in <u>guess_encoding()</u> and <u>guess_encoding_to_xml()</u> to help guess encoding of byte strings being
              converted.  If not present, unknown encodings will be converted as if they were <b>latin1</b>

</pre><h4><b>OTHER</b> <b>RECOMMENDED</b> <b>LIBRARIES</b></h4><pre>
       These libraries implement commonly used  functionality  that  everyone  seems  to  invent.   Rather  than
       reinvent  their  wheel, I simply list the things that they do well for now.  Perhaps if people can't find
       them normally, I'll add them as requirements in <b>setup.py</b> or link them into kitchen's namespace.  For now,
       I just mention them here:

       <u>bunch</u>  Bunch is a dictionary that you can use attribute lookup as well as  bracket  notation  to  access.
              Setting  it  apart  from  most  homebrewed  implementations  is the <b>bunchify()</b> function which will
              descend nested structures of lists and dicts, transforming the dicts to Bunch's.

       <u>hashlib</u>
              Python 2.5 and forward have a <b>hashlib</b> library that provides secure hash functions to  python.   If
              you're  developing  for  python2.4 though, you can install the standalone hashlib library and have
              access to the same functions.

       <u>iterutils</u>
              The python documentation for <b>itertools</b> has some examples of other nice iterable functions that can
              be built from the <b>itertools</b> functions.  This third-party module creates those recipes as a module.

       <u>ordereddict</u>
              Python 2.7 and forward have a <b>OrderedDict</b> that provides  a  <b>dict</b>  whose  items  are  ordered  (and
              indexable) as well as named.

       <u>unittest2</u>
              Python  2.7  has an updated <b>unittest</b> library with new functions not present in the <u>python</u> <u>standard</u>
              <u>library</u> for Python 2.6 or less.  If you want to use those new  functions  but  need  your  testing
              framework  to  be  compatible  with  older  Python the unittest2 library provides the update as an
              external module.

       <u>nose</u>   If you want to use a test discovery tool instead of the unittest framework, nosetests  provides  a
              simple to use way to do that.

</pre><h4><b>LICENSE</b></h4><pre>
       This  python  module is distributed under the terms of the <u>GNU</u> <u>Lesser</u> <u>General</u> <u>Public</u> <u>License</u> <u>Version</u> <u>2</u> <u>or</u>
       <u>later</u>.

       <b>NOTE:</b>
          Some parts of this module are licensed under terms less restrictive than the LGPLv2+.  If you separate
          these files from the work as a whole you are allowed to use them under the less restrictive  licenses.
          The following is a list of the files that are known:

          <u>Python</u> <u>2</u> <u>license</u>
                 <b>_subprocess.py</b>,   <b>test_subprocess.py</b>,   <b>defaultdict.py</b>,  <b>test_defaultdict.py</b>,  <b>_base64.py</b>,  and
                 <b>test_base64.py</b>

</pre><h4><b>CONTENTS</b></h4><pre>
   <b>Using</b> <b>kitchen</b> <b>to</b> <b>write</b> <b>good</b> <b>code</b>
       Kitchen's functions won't automatically make you a better programmer.  You have to learn when and how  to
       use  them  as  well.  This section of the documentation is intended to show you some of the ways that you
       can apply kitchen's functions to problems that may have arisen in your life.  The goal of this section is
       to give you enough information to understand what the kitchen API can do for you and where in the <u>Kitchen</u>
       <u>API</u> docs to look for something that can help you with your next issue.  Along the way, you might pick  up
       the  knack  for identifying issues with your code before you publish it.  And that <u>will</u> make you a better
       coder.

   <b>Overcoming</b> <b>frustration:</b> <b>Correctly</b> <b>using</b> <b>unicode</b> <b>in</b> <b>python2</b>
       In python-2.x, there's two types that deal with text.

       1. <b>str</b> is for strings of bytes.  These are very similar in nature to how strings are handled in C.

       2. <b>unicode</b> is for strings of unicode <u>code</u> <u>points</u>.

       <b>NOTE:</b>
          <b>Just</b> <b>what</b> <b>the</b> <b>dickens</b> <b>is</b> <b>"Unicode"?</b>

          One mistake that people encountering this issue for the first time make is confusing the <b>unicode</b>  type
          and  the  encodings of unicode stored in the <b>str</b> type.  In python, the <b>unicode</b> type stores an abstract
          sequence of <u>code</u> <u>points</u>.  Each <u>code</u> <u>point</u> represents a <u>grapheme</u>.   By  contrast,  byte  <b>str</b>  stores  a
          sequence  of  bytes  which  can then be mapped to a sequence of <u>code</u> <u>points</u>.  Each unicode encoding (‚Äê
          <u>UTF-8</u>, UTF-7, UTF-16, UTF-32, etc) maps different sequences of bytes to the unicode <u>code</u> <u>points</u>.

          What does that mean to you as a programmer?  When you're dealing with text manipulations (finding  the
          number  of  characters  in a string or cutting a string on word boundaries) you should be dealing with
          <b>unicode</b> strings as they abstract characters in a manner that's appropriate for thinking of them  as  a
          sequence of letters that you will see on a page.  When dealing with I/O, reading to and from the disk,
          printing  to  a  terminal, sending something over a network link, etc, you should be dealing with byte
          <b>str</b> as those devices are going to need to deal with concrete implementations of what  bytes  represent
          your abstract characters.

       In  the python2 world many APIs use these two classes interchangably but there are several important APIs
       where only one or the other will do the right thing.  When you give the wrong type of string  to  an  API
       that  wants  the  other  type,  you  may  end  up  with  an exception being raised (<b>UnicodeDecodeError</b> or
       <b>UnicodeEncodeError</b>).  However, these exceptions aren't always raised because python  implicitly  converts
       between types... <u>sometimes</u>.

   <b>Frustration</b> <b>#1:</b> <b>Inconsistent</b> <b>Errors</b>
       Although  converting  when  possible  seems like the right thing to do, it's actually the first source of
       frustration.  A programmer can test out their program with a string like: <b>The</b> <b>quick</b> <b>brown</b> <b>fox</b> <b>jumped</b> <b>over</b>
       <b>the</b> <b>lazy</b> <b>dog</b> and not encounter any issues.  But when they release their software into the  wild,  someone
       enters  the  string:  <b>I</b> <b>sat</b> <b>down</b> <b>for</b> <b>coffee</b> <b>at</b> <b>the</b> <b>caf√©</b> and suddenly an exception is thrown.  The reason?
       The mechanism that converts between the two types is only able to deal with <u>ASCII</u> characters.   Once  you
       throw non-<u>ASCII</u> characters into your strings, you have to start dealing with the conversion manually.

       So,  if  I manually convert everything to either byte <b>str</b> or <b>unicode</b> strings, will I be okay?  The answer
       is.... <u>sometimes</u>.

   <b>Frustration</b> <b>#2:</b> <b>Inconsistent</b> <b>APIs</b>
       The problem you run into when converting everything to byte <b>str</b> or <b>unicode</b>  strings  is  that  you'll  be
       using  someone  else's  API  quite often (this includes the APIs in the <u>python</u> <u>standard</u> <u>library</u>) and find
       that the API will only accept byte <b>str</b> or only accept <b>unicode</b> strings.  Or  worse,  that  the  code  will
       accept  either  when you're dealing with strings that consist solely of <u>ASCII</u> but throw an error when you
       give it a string that's got non-<u>ASCII</u> characters.  When you  encounter  these  APIs  you  first  need  to
       identify  which  type  will  work better and then you have to convert your values to the correct type for
       that code.  Thus the programmer that wants to proactively fix all unicode errors in their code  needs  to
       do two things:

       1. You must keep track of what type your sequences of text are.  Does <b>my_sentence</b> contain <b>unicode</b> or <b>str</b>?
          If you don't know that then you're going to be in for a world of hurt.

       2. Anytime  you  call  a function you need to evaluate whether that function will do the right thing with
          <b>str</b> or <b>unicode</b> values.  Sending the wrong value here will lead to a <b>UnicodeError</b> being thrown when the
          string contains non-<u>ASCII</u> characters.

       <b>NOTE:</b>
          There is one mitigating factor here.  The python community has been standardizing on using <b>unicode</b>  in
          all  its  APIs.   Although  there are some APIs that you need to send byte <b>str</b> to in order to be safe,
          (including things as ubiquitous as <b>print()</b> as we'll see in the next section), it's getting easier  and
          easier to use <b>unicode</b> strings with most APIs.

   <b>Frustration</b> <b>#3:</b> <b>Inconsistent</b> <b>treatment</b> <b>of</b> <b>output</b>
       Alright,  since  the  python  community  is  moving to using <b>unicode</b> strings everywhere, we might as well
       convert everything to <b>unicode</b> strings and use that by default, right?  Sounds good most of the  time  but
       there's  at  least one huge caveat to be aware of.  Anytime you output text to the terminal or to a file,
       the text has to be converted into a byte <b>str</b>.  Python will try to implicitly convert from <b>unicode</b> to byte
       <b>str</b>... but it will throw an exception if the bytes are non-<u>ASCII</u>:

          &gt;&gt;&gt; string = unicode(raw_input(), 'utf8')
          caf√©
          &gt;&gt;&gt; log = open('/var/tmp/debug.log', 'w')
          &gt;&gt;&gt; log.write(string)
          Traceback (most recent call last):
            File "&lt;stdin&gt;", line 1, in &lt;module&gt;
          UnicodeEncodeError: 'ascii' codec can't encode character u'\xe9' in position 3: ordinal not in <a href="../man128/range.128.html">range</a>(128)

       Okay, this is simple enough to solve:  Just convert to a byte <b>str</b> and we're all set:

          &gt;&gt;&gt; string = unicode(raw_input(), 'utf8')
          caf√©
          &gt;&gt;&gt; string_for_output = string.encode('utf8', 'replace')
          &gt;&gt;&gt; log = open('/var/tmp/debug.log', 'w')
          &gt;&gt;&gt; log.write(string_for_output)
          &gt;&gt;&gt;

       So that was simple, right?  Well... there's one gotcha that makes things a bit harder to debug sometimes.
       When you attempt to write non-<u>ASCII</u> <b>unicode</b> strings to a file-like object you get a traceback  everytime.
       But  what  happens  when  you  use  <b>print()</b>?   The  terminal  is a file-like object so it should raise an
       exception right?  The answer to that is....  <u>sometimes</u>:

          $ python
          &gt;&gt;&gt; print u'caf√©'
          caf√©

       No exception.  Okay, we're fine then?

       We are until someone does one of the following:

       ‚Ä¢ Runs the script in a different locale:

            $ LC_ALL=C python
            &gt;&gt;&gt; # Note: if you're using a good terminal program when running in the C locale
            &gt;&gt;&gt; # The terminal program will prevent you from entering non-ASCII characters
            &gt;&gt;&gt; # python will still recognize them if you use the codepoint instead:
            &gt;&gt;&gt; print u'caf\xe9'
            Traceback (most recent call last):
              File "&lt;stdin&gt;", line 1, in &lt;module&gt;
            UnicodeEncodeError: 'ascii' codec can't encode character u'\xe9' in position 3: ordinal not in <a href="../man128/range.128.html">range</a>(128)

       ‚Ä¢ Redirects output to a file:

            $ cat test.py
            #!/usr/bin/python -tt
            # -*- coding: utf-8 -*-
            print u'caf√©'
            $ ./test.py  &gt;t
            Traceback (most recent call last):
              File "./test.py", line 4, in &lt;module&gt;
                print u'caf√©'
            UnicodeEncodeError: 'ascii' codec can't encode character u'\xe9' in position 3: ordinal not in <a href="../man128/range.128.html">range</a>(128)

       Okay, the locale thing is a pain but understandable: the  C  locale  doesn't  understand  any  characters
       outside of <u>ASCII</u> so naturally attempting to display those won't work.  Now why does redirecting to a file
       cause  problems?   It's  because  <b>print()</b>  in  python2 is treated specially.  Whereas the other file-like
       objects in python always convert to <u>ASCII</u> unless you set them up differently, using <b>print()</b> to output  to
       the  terminal  will  use  the  user's  locale to convert before sending the output to the terminal.  When
       <b>print()</b> is not outputting to the terminal (being redirected to a file,  for  instance),  <b>print()</b>  decides
       that it doesn't know what locale to use for that file and so it tries to convert to <u>ASCII</u> instead.

       So  what  does  this  mean  for you, as a programmer?  Unless you have the luxury of controlling how your
       users use your code, you should always, always, always convert to a byte <b>str</b> before outputting strings to
       the terminal or to a file.  Python even provides you with a facility to do just this.  If you  know  that
       every <b>unicode</b> string you send to a particular file-like object (for instance, <b>stdout</b>) should be converted
       to a particular encoding you can use a <b>codecs.StreamWriter</b> object to convert from a <b>unicode</b> string into a
       byte  <b>str</b>.  In particular, <b>codecs.getwriter()</b> will return a <b>StreamWriter</b> class that will help you to wrap
       a file-like object for output.  Using our <b>print()</b> example:

          $ cat test.py
          #!/usr/bin/python -tt
          # -*- coding: utf-8 -*-
          import codecs
          import sys

          UTF8Writer = codecs.getwriter('utf8')
          sys.stdout = UTF8Writer(sys.stdout)
          print u'caf√©'
          $ ./test.py  &gt;t
          $ cat t
          caf√©

   <b>Frustrations</b> <b>#4</b> <b>and</b> <b>#5</b> <b>--</b> <b>The</b> <b>other</b> <b>shoes</b>
       In English, there's a saying "waiting for the other shoe to drop".  It means that when one event (usually
       bad) happens, you come to expect another event (usually worse) to come after.  In this case we  have  two
       other shoes.

   <b>Frustration</b> <b>#4:</b> <b>Now</b> <b>it</b> <b>doesn't</b> <b>take</b> <b>byte</b> <b>strings?!</b>
       If  you wrap <b>sys.stdout</b> using <b>codecs.getwriter()</b> and think you are now safe to print any variable without
       checking its type I am afraid I must inform you that you're not paying enough attention to <u>Murphy's</u>  <u>Law</u>.
       The  <b>StreamWriter</b> that <b>codecs.getwriter()</b> provides will take <b>unicode</b> strings and transform them into byte
       <b>str</b> before they get to <b>sys.stdout</b>.  The problem is if you give it something that's already a byte <b>str</b>  it
       tries  to  transform that as well.  To do that it tries to turn the byte <b>str</b> you give it into <b>unicode</b> and
       then transform that back into a byte <b>str</b>...   and  since  it  uses  the  <u>ASCII</u>  codec  to  perform  those
       conversions, chances are that it'll blow up when making them:

          &gt;&gt;&gt; import codecs
          &gt;&gt;&gt; import sys
          &gt;&gt;&gt; UTF8Writer = codecs.getwriter('utf8')
          &gt;&gt;&gt; sys.stdout = UTF8Writer(sys.stdout)
          &gt;&gt;&gt; print 'caf√©'
          Traceback (most recent call last):
            File "&lt;stdin&gt;", line 1, in &lt;module&gt;
            File "/usr/lib64/python2.6/codecs.py", line 351, in write
              data, consumed = self.encode(object, self.errors)
          UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 3: ordinal not in <a href="../man128/range.128.html">range</a>(128)

       To  work around this, kitchen provides an alternate version of <b>codecs.getwriter()</b> that can deal with both
       byte <b>str</b> and <b>unicode</b> strings.  Use <u>kitchen.text.converters.getwriter()</u> in place  of  the  <b>codecs</b>  version
       like this:

          &gt;&gt;&gt; import sys
          &gt;&gt;&gt; from kitchen.text.converters import getwriter
          &gt;&gt;&gt; UTF8Writer = getwriter('utf8')
          &gt;&gt;&gt; sys.stdout = UTF8Writer(sys.stdout)
          &gt;&gt;&gt; print u'caf√©'
          caf√©
          &gt;&gt;&gt; print 'caf√©'
          caf√©

   <b>Frustration</b> <b>#5:</b> <b>Inconsistent</b> <b>APIs</b> <b>Part</b> <b>deux</b>
       Sometimes  you  do  everything right in your code but other people's code fails you.  With unicode issues
       this happens more often than we want.  A glaring example of this is when  you  get  values  back  from  a
       function that aren't consistently <b>unicode</b> string or byte <b>str</b>.

       An example from the <u>python</u> <u>standard</u> <u>library</u> is <b>gettext</b>.  The <b>gettext</b> functions are used to help translate
       messages  that you display to users in the users' native languages.  Since most languages contain letters
       outside of the <u>ASCII</u> range, the values that are returned contain unicode  characters.   <b>gettext</b>  provides
       you  with  <b>ugettext()</b>  and  <b>ungettext()</b>  to  return  these translations as <b>unicode</b> strings and <b>gettext()</b>,
       <b>ngettext()</b>, <b>lgettext()</b>, and <b>lngettext()</b> to return them as encoded byte <b>str</b>.  Unfortunately,  even  though
       they're  documented  to  return only one type of string or the other, the implementation has corner cases
       where the wrong type can be returned.

       This means that even if you separate your <b>unicode</b> string and byte <b>str</b>  correctly  before  you  pass  your
       strings to a <b>gettext</b> function, afterwards, you might have to check that you have the right sort of string
       type again.

       <b>NOTE:</b>
          <u>kitchen.i18n</u>  provides alternate gettext translation objects that return only byte <b>str</b> or only <b>unicode</b>
          string.

   <b>A</b> <b>few</b> <b>solutions</b>
       Now that we've identified the issues, can we define a comprehensive strategy for dealing with them?

   <b>Convert</b> <b>text</b> <b>at</b> <b>the</b> <b>border</b>
       If you get some piece of text from a library, read from a file,  etc,  turn  it  into  a  <b>unicode</b>  string
       immediately.   Since  python  is  moving  in the direction of <b>unicode</b> strings everywhere it's going to be
       easier to work with <b>unicode</b> strings within your code.

       If your code is heavily involved with using things that are bytes, you can do the  opposite  and  convert
       all  text into byte <b>str</b> at the border and only convert to <b>unicode</b> when you need it for passing to another
       library or performing string operations on it.

       In either case, the important thing is to pick a default type for strings and stick  with  it  throughout
       your code.  When you mix the types it becomes much easier to operate on a string with a function that can
       only use the other type by mistake.

       <b>NOTE:</b>
          In  python3,  the  abstract  unicode  type  becomes  much  more  prominent.  The type named <b>str</b> is the
          equivalent of python2's <b>unicode</b> and python3's <b>bytes</b> type replaces python2's <b>str</b>.  Most  APIs  deal  in
          the  unicode type of string with just some pieces that are low level dealing with bytes.  The implicit
          conversions between bytes and unicode is removed and whenever you want to make the conversion you need
          to do so explicitly.

   <b>When</b> <b>the</b> <b>data</b> <b>needs</b> <b>to</b> <b>be</b> <b>treated</b> <b>as</b> <b>bytes</b> <b>(or</b> <b>unicode)</b> <b>use</b> <b>a</b> <b>naming</b> <b>convention</b>
       Sometimes you're converting nearly all of your data to <b>unicode</b> strings but you have  one  or  two  values
       where  you  have to keep byte <b>str</b> around.  This is often the case when you need to use the value verbatim
       with some external resource.  For instance, filenames or key values in a database.  When you do this, use
       a naming convention for the data you're working with so you (and others reading your  code  later)  don't
       get confused about what's being stored in the value.

       If  you  need  both a textual string to present to the user and a byte value for an exact match, consider
       keeping both versions around.  You can either use two variables for this or a <b>dict</b> whose key is the  byte
       value.

       <b>NOTE:</b>
          You  can  use  the  naming  convention  used  in  kitchen  as a guide for implementing your own naming
          convention.  It prefixes byte <b>str</b> variables of unknown encoding with <b>b_</b> and byte <b>str</b> of known encoding
          with the encoding name like: <b>utf8_</b>.  If the default was to handle <b>str</b> and  only  keep  a  few  <b>unicode</b>
          values, those variables would be prefixed with <b>u_</b>.

   <b>When</b> <b>outputting</b> <b>data,</b> <b>convert</b> <b>back</b> <b>into</b> <b>bytes</b>
       When  you  go  to  send  your  data  back  outside  of your program (to the filesystem, over the network,
       displaying to the user, etc) turn the data back into a byte <b>str</b>.  How you do  this  will  depend  on  the
       expected  output format of the data.  For displaying to the user, you can use the user's default encoding
       using <b>locale.getpreferredencoding()</b>.  For entering into a file, you're best  bet  is  to  pick  a  single
       encoding and stick with it.

       <b>WARNING:</b>
          When  using  the  encoding  that  the user has set (for instance, using <b>locale.getpreferredencoding()</b>,
          remember that they may have their encoding set to something that can't display  every  single  unicode
          character.   That  means  when  you  convert from <b>unicode</b> to a byte <b>str</b> you need to decide what should
          happen if the byte value is not valid in the user's encoding.  For purposes of displaying messages  to
          the  user,  it's  usually  okay  to  use  the  <b>replace</b>  encoding  error handler to replace the invalid
          characters with a question mark or other symbol meaning the character couldn't be displayed.

       You can use <u>kitchen.text.converters.getwriter()</u> to do this automatically for <b>sys.stdout</b>.   When  creating
       exception messages be sure to convert to bytes manually.

   <b>When</b> <b>writing</b> <b>unittests,</b> <b>include</b> <b>non-ASCII</b> <b>values</b> <b>and</b> <b>both</b> <b>unicode</b> <b>and</b> <b>str</b> <b>type</b>
       Unless  you know that a specific portion of your code will only deal with <u>ASCII</u>, be sure to include non-‚Äê
       <u>ASCII</u> values in your unittests.  Including a few characters from  several  different  scripts  is  highly
       advised  as  well  because some code may have special cased accented roman characters but not know how to
       handle characters used in Asian alphabets.

       Similarly, unless you know that that portion of your code will only be given <b>unicode</b> strings or only byte
       <b>str</b> be sure to try variables of both types in your unittests.   When  doing  this,  make  sure  that  the
       variables are also non-<u>ASCII</u> as python's implicit conversion will mask problems with pure <u>ASCII</u> data.  In
       many cases, it makes sense to check what happens if byte <b>str</b> and <b>unicode</b> strings that won't decode in the
       present locale are given.

   <b>Be</b> <b>vigilant</b> <b>about</b> <b>spotting</b> <b>poor</b> <b>APIs</b>
       Make  sure  that  the  libraries you use return only <b>unicode</b> strings or byte <b>str</b>.  Unittests can help you
       spot issues here by running many variations of data through your functions and checking that you're still
       getting the types of string that you expect.

   <b>Example:</b> <b>Putting</b> <b>this</b> <b>all</b> <b>together</b> <b>with</b> <b>kitchen</b>
       The kitchen library provides a wide array of functions to help you deal with byte <b>str</b> and <b>unicode</b> strings
       in your program.  Here's a short example that uses many kitchen functions to do its work:

          #!/usr/bin/python -tt
          # -*- coding: utf-8 -*-
          import locale
          import os
          import sys
          import unicodedata

          from kitchen.text.converters import getwriter, to_bytes, to_unicode
          from kitchen.i18n import get_translation_object

          if __name__ == '__main__':
              # Setup gettext driven translations but use the kitchen functions so
              # we don't have the mismatched bytes-unicode issues.
              translations = get_translation_object('example')
              # We use _() for marking strings that we operate on as unicode
              # This is pretty much everything
              _ = translations.ugettext
              # And b_() for marking strings that we operate on as bytes.
              # This is limited to exceptions
              b_ = translations.lgettext

              # Setup stdout
              encoding = locale.getpreferredencoding()
              Writer = getwriter(encoding)
              sys.stdout = Writer(sys.stdout)

              # Load data.  Format is filename\0description
              # description should be utf-8 but filename can be any legal filename
              # on the filesystem
              # Sample datafile.txt:
              #   <a href="file:/etc/shells">/etc/shells</a>\x00Shells available on caf\xc3\xa9.lan
              #   /var/tmp/file\xff\x00File with non-utf8 data in the filename
              #
              # And to create /var/tmp/file\xff (under bash or zsh) do:
              #   echo 'Some data' &gt; /var/tmp/file$'\377'
              datafile = open('datafile.txt', 'r')
              data = {}
              for line in datafile:
                  # We're going to keep filename as bytes because we will need the
                  # exact bytes to access files on a POSIX operating system.
                  # description, we'll immediately transform into unicode type.
                  b_filename, description = line.split('\0', 1)

                  # to_unicode defaults to decoding output from utf-8 and replacing
                  # any problematic bytes with the unicode replacement character
                  # We accept mangling of the description here knowing that our file
                  # format is supposed to use utf-8 in that field and that the
                  # description will only be displayed to the user, not used as
                  # a key value.
                  description = to_unicode(description, 'utf-8').strip()
                  data[b_filename] = description
              datafile.close()

              # We're going to add a pair of extra fields onto our data to show the
              # length of the description and the filesize.  We put those between
              # the filename and description because we haven't checked that the
              # description is free of NULLs.
              datafile = open('newdatafile.txt', 'w')

              # Name filename with a b_ prefix to denote byte string of unknown encoding
              for b_filename in data:
                  # Since we have the byte representation of filename, we can read any
                  # filename
                  if os.access(b_filename, os.F_OK):
                      size = os.path.getsize(b_filename)
                  else:
                      size = 0
                  # Because the description is unicode type,  we know the number of
                  # characters corresponds to the length of the normalized unicode
                  # string.
                  length = len(unicodedata.normalize('NFC', description))

                  # Print a summary to the screen
                  # Note that we do not let implici type conversion from str to
                  # unicode transform b_filename into a unicode string.  That might
                  # fail as python would use the ASCII filename.  Instead we use
                  # to_unicode() to explictly transform in a way that we know will
                  # not traceback.
                  print _(u'filename: %s') % to_unicode(b_filename)
                  print _(u'file size: %s') % size
                  print _(u'desc length: %s') % length
                  print _(u'description: %s') % data[b_filename]

                  # First combine the unicode portion
                  line = u'%s\0%s\0%s' % (size, length, data[b_filename])
                  # Since the filenames are bytes, turn everything else to bytes before combining
                  # Turning into unicode first would be wrong as the bytes in b_filename
                  # might not convert
                  b_line = '%s\0%s\n' % (b_filename, to_bytes(line))

                  # Just to demonstrate that getwriter will pass bytes through fine
                  print b_('Wrote: %s') % b_line
                  datafile.write(b_line)
              datafile.close()

              # And just to show how to properly deal with an exception.
              # Note two things about this:
              # 1) We use the b_() function to translate the string.  This returns a
              #    byte string instead of a unicode string
              # 2) We're using the b_() function returned by kitchen.  If we had
              #    used the one from gettext we would need to convert the message to
              #    a byte str first
              message = u'Demonstrate the proper way to raise exceptions.  Sincerely,  \u3068\u3057\u304a'
              raise Exception(<a href="../manmessage/b_.message.html">b_</a>(message))

       <b>SEE</b> <b>ALSO:</b>
          <u>kitchen.text.converters</u>

   <b>Designing</b> <b>Unicode</b> <b>Aware</b> <b>APIs</b>
       APIs that deal with byte <b>str</b> and <b>unicode</b> strings are difficult to get right.  Here are a  few  strategies
       with pros and cons of each.

   <b>Contents</b>
       ‚Ä¢ <u>Designing</u> <u>Unicode</u> <u>Aware</u> <u>APIs</u>

         ‚Ä¢ <u>Take</u> <u>either</u> <u>bytes</u> <u>or</u> <u>unicode,</u> <u>output</u> <u>only</u> <u>unicode</u>

         ‚Ä¢ <u>Take</u> <u>either</u> <u>bytes</u> <u>or</u> <u>unicode,</u> <u>output</u> <u>the</u> <u>same</u> <u>type</u>

         ‚Ä¢ <u>Separate</u> <u>functions</u>

         ‚Ä¢ <u>Deciding</u> <u>whether</u> <u>to</u> <u>take</u> <u>str</u> <u>or</u> <u>unicode</u> <u>when</u> <u>no</u> <u>value</u> <u>is</u> <u>returned</u>

           ‚Ä¢ <u>Writing</u> <u>to</u> <u>external</u> <u>data</u>

           ‚Ä¢ <u>Updating</u> <u>data</u> <u>structures</u>

         ‚Ä¢ <u>APIs</u> <u>to</u> <u>Avoid</u>

           ‚Ä¢ <u>Returning</u> <u>unicode</u> <u>unless</u> <u>a</u> <u>conversion</u> <u>fails</u>

           ‚Ä¢ <u>Ignoring</u> <u>values</u> <u>with</u> <u>no</u> <u>chance</u> <u>of</u> <u>recovery</u>

           ‚Ä¢ <u>Raising</u> <u>a</u> <u>UnicodeException</u> <u>with</u> <u>no</u> <u>chance</u> <u>of</u> <u>recovery</u>

         ‚Ä¢ <u>Knowing</u> <u>your</u> <u>data</u>

           ‚Ä¢ <u>Do</u> <u>you</u> <u>need</u> <u>to</u> <u>operate</u> <u>on</u> <u>both</u> <u>bytes</u> <u>and</u> <u>unicode?</u>

           ‚Ä¢ <u>Can</u> <u>you</u> <u>restrict</u> <u>the</u> <u>encodings?</u>

             ‚Ä¢ <u>Single</u> <u>byte</u> <u>encodings</u>

             ‚Ä¢ <u>Multibyte</u> <u>encodings</u>

               ‚Ä¢ <u>Fixed</u> <u>width</u>

               ‚Ä¢ <u>Variable</u> <u>Width</u>

                 ‚Ä¢ <u>ASCII</u> <u>compatible</u>

                 ‚Ä¢ <u>Escaped</u>

                 ‚Ä¢ <u>Other</u>

   <b>Take</b> <b>either</b> <b>bytes</b> <b>or</b> <b>unicode,</b> <b>output</b> <b>only</b> <b>unicode</b>
       In  this  strategy, you allow the user to enter either <b>unicode</b> strings or byte <b>str</b> but what you give back
       is always <b>unicode</b>.  This strategy is easy for novice endusers to start using immediately as they will  be
       able  to  feed  either  type of string into the function and get back a string that they can use in other
       places.

       However, it does lead to the novice writing code that functions correctly when testing it with <u>ASCII</u>-only
       data but fails when given data that contains non-<u>ASCII</u> characters.  Worse, if your API is not designed to
       be flexible, the consumer of your code won't be able to easily correct  those  problems  once  they  find
       them.

       Here's a good API that uses this strategy:

          from kitchen.text.converters import to_unicode

          def truncate(msg, max_length, encoding='utf8', errors='replace'):
              msg = to_unicode(msg, encoding, errors)
              return msg[:max_length]

       The  call  to  <b>truncate()</b> starts with the essential parameters for performing the task.  It ends with two
       optional keyword arguments that define the encoding to use to transform from a byte <b>str</b>  to  <b>unicode</b>  and
       the  strategy  to  use  if undecodable bytes are encountered.  The defaults may vary depending on the use
       cases you have in mind.  When the output  is  generally  going  to  be  printed  for  the  user  to  see,
       <b>errors='replace'</b>  is  a  good  default.   If you are constructing keys to a database, raisng an exception
       (with <b>errors='strict'</b>) may be a better default.  In either case, having both parameters allows the person
       using your API to choose how they want to handle any problems.  Having the values is also a clue to  them
       that a conversion from byte <b>str</b> to <b>unicode</b> string is going to occur.

       <b>NOTE:</b>
          If  you're  targeting  python-3.1  and  above,  <b>errors='surrogateescape'</b>  may be a better default than
          <b>errors='strict'</b>.  You need to be mindful of a few things when using <b>surrogateescape</b> though:

          ‚Ä¢ <b>surrogateescape</b> will cause issues if a non-<u>ASCII</u> compatible encoding is used (for  instance,  UTF-16
            and  UTF-32.)  That makes it unhelpful in situations where a true general purpose method of encoding
            must be found.  <u>PEP</u> <u>383</u> mentions that <b>surrogateescape</b> was specifically designed with the limitations
            of translating using system locales (where <u>ASCII</u> compatibility is generally seen as inescapable)  so
            you should keep that in mind.

          ‚Ä¢ If  you  use  <b>surrogateescape</b>  to decode from <b>bytes</b> to <b>unicode</b> you will need to use an error handler
            other than <b>strict</b> to encode as the lone surrogate that this error handler creates makes for  invalid
            unicode  that  must  be  handled when encoding.  In Python-3.1.2 or less, a bug in the encoder error
            handlers mean that you can only use <b>surrogateescape</b> to encode; anything else will throw an error.

          Evaluate your usages of the variables in question to see what makes sense.

       Here's a bad example of using this strategy:

          from kitchen.text.converters import to_unicode

          def truncate(msg, max_length):
              msg = <a href="../manmsg/to_unicode.msg.html">to_unicode</a>(msg)
              return msg[:max_length]

       In this example, we don't have the optional keyword arguments for <b>encoding</b> and <b>errors</b>.  A user  who  uses
       this  function  is  more  likely  to miss the fact that a conversion from byte <b>str</b> to <b>unicode</b> is going to
       occur.  And once an error is reported, they will have to look through their backtrace  and  think  harder
       about  where  they want to transform their data into <b>unicode</b> strings instead of having the opportunity to
       control how the conversion takes place in the function itself.  Note that the user does have the  ability
       to make this work by making the transformation to unicode themselves:

          from kitchen.text.converters import to_unicode

          msg = to_unicode(msg, encoding='euc_jp', errors='ignore')
          new_msg = truncate(msg, 5)

   <b>Take</b> <b>either</b> <b>bytes</b> <b>or</b> <b>unicode,</b> <b>output</b> <b>the</b> <b>same</b> <b>type</b>
       This  strategy  is sometimes called polymorphic because the type of data that is returned is dependent on
       the type of data that is received.  The concept is that when you are given a byte  <b>str</b>  to  process,  you
       return  a  byte  <b>str</b>  in  your output.  When you are given <b>unicode</b> strings to process, you return <b>unicode</b>
       strings in your output.

       This can work well for end users as the ones that know about the difference between the two string  types
       will  already  have transformed the strings to their desired type before giving it to this function.  The
       ones that don't can remain blissfully ignorant (at least, as far as your function is  concerned)  as  the
       function does not change the type.

       In  cases  where  the encoding of the byte <b>str</b> is known or can be discovered based on the input data this
       works well.  If you can't figure out the input encoding, however, this strategy can fail in  any  of  the
       following cases:

       1. It needs to do an internal conversion between byte <b>str</b> and <b>unicode</b> string.

       2. It cannot return the same data as either a <b>unicode</b> string or byte <b>str</b>.

       3. You may need to deal with byte strings that are not byte-compatible with <u>ASCII</u>

       First, a couple examples of using this strategy in a good way:

          def translate(msg, table):
              replacements = table.keys()
              new_msg = []
              for index, char in <a href="../manmsg/enumerate.msg.html">enumerate</a>(msg):
                  if char in replacements:
                      new_msg.append(table[char])
                  else:
                      new_msg.append(char)

              return ''.join(new_msg)

       In this example, all of the strings that we use (except the empty string which is okay because it doesn't
       have  any  characters to encode) come from outside of the function.  Due to that, the user is responsible
       for making sure that the <b>msg</b>, and the keys and values in <b>table</b> all match in terms  of  type  (<b>unicode</b>  vs
       <b>str</b>)  and  encoding  (You can do some error checking to make sure the user gave all the same type but you
       can't do the same for the user giving different encodings).  You do not  need  to  make  changes  to  the
       string that require you to know the encoding or type of the string; everything is a simple replacement of
       one element in the array of characters in message with the character in table.

          import json
          from kitchen.text.converters import to_unicode, to_bytes

          def first_field_from_json_data(json_string):
              '''Return the first field in a json data structure.

              The format of the json data is a simple list of strings.
              '["one", "two", "three"]'
              '''
              if isinstance(json_string, unicode):
                  # On all python versions, json.loads() returns unicode if given
                  # a unicode string
                  return json.loads(json_string)[0]

              # Byte str: figure out which encoding we're dealing with
              if '\x00' not in json_data[:2]
                  encoding = 'utf8'
              elif '\x00\x00\x00' == json_data[:3]:
                  encoding = 'utf-32-be'
              elif '\x00\x00\x00' == json_data[1:4]:
                  encoding = 'utf-32-le'
              elif '\x00' == json_data[0] and '\x00' == json_data[2]:
                  encoding = 'utf-16-be'
              else:
                  encoding = 'utf-16-le'

              data = json.loads(unicode(json_string, encoding))
              return data[0].encode(encoding)

       In  this  example  the  function takes either a byte <b>str</b> type or a <b>unicode</b> string that has a list in json
       format and returns the first field from it as the type of the input string.  The first section of code is
       very straightforward; we receive a <b>unicode</b> string, parse it with a function, and then  return  the  first
       field from our parsed data (which our function returned to us as json data).

       The second portion that deals with byte <b>str</b> is not so straightforward.  Before we can parse the string we
       have  to  determine what characters the bytes in the string map to.  If we didn't do that, we wouldn't be
       able to properly find which characters are present in the string.  In order to do that we have to  figure
       out  the  encoding  of the byte <b>str</b>.  Luckily, the json specification states that all strings are unicode
       and encoded with one of UTF32be, UTF32le, UTF16be, UTF16le, or <u>UTF-8</u>.  It further defines the format such
       that the first two characters are always <u>ASCII</u>.  Each of these has a different  sequence  of  NULLs  when
       they  encode  an  <u>ASCII</u>  character.  We can use that to detect which encoding was used to create the byte
       <b>str</b>.

       Finally, we return the byte <b>str</b> by encoding the <b>unicode</b> back to a byte <b>str</b>.

       As you can see, in this example we have to convert from byte <b>str</b> to <b>unicode</b> and back.  But we  know  from
       the  json  specification that byte <b>str</b> has to be one of a limited number of encodings that we are able to
       detect.  That ability makes this strategy work.

       Now for some examples of using this strategy in ways that fail:

          import unicodedata
          def <a href="../manmsg/first_char.msg.html">first_char</a>(msg):
              '''Return the first character in a string'''
              if not isinstance(msg, unicode):
                  try:
                      msg = unicode(msg, 'utf8')
                  except UnicodeError:
                      msg = unicode(msg, 'latin1')
              msg = unicodedata.normalize('NFC', msg)
              return msg[0]

       If you look at that code and think that there's something fragile and  prone  to  breaking  in  the  <b>try:</b>
       <b>except:</b> block you are correct in being suspicious.  This code will fail on multi-byte character sets that
       aren't  <u>UTF-8</u>.   It  can  also  fail on data where the sequence of bytes is valid <u>UTF-8</u> but the bytes are
       actually of a different encoding.  The reasons this code fails is that we don't know  what  encoding  the
       bytes are in and the code must convert from a byte <b>str</b> to a <b>unicode</b> string in order to function.

       In  order to make this code robust we must know the encoding of <b>msg</b>.  The only way to know that is to ask
       the user so the API must do that:

          import unicodedata
          def number_of_chars(msg, encoding='utf8', errors='strict'):
              if not isinstance(msg, unicode):
                  msg = unicode(msg, encoding, errors)
              msg = unicodedata.normalize('NFC', msg)
              return <a href="../manmsg/len.msg.html">len</a>(msg)

       Another example of failure:

          import os
          def listdir(directory):
              files = os.listdir(directory)
              if isinstance(directory, str):
                  return files
              # files could contain both bytes and unicode
              new_files = []
              for filename in files:
                  if not isinstance(filename, unicode):
                      # What to do here?
                      continue
                  new_files.appen(filename)
              return new_files

       This function illustrates the second failure  mode.   Here,  not  all  of  the  possible  values  can  be
       represented  as <b>unicode</b> without knowing more about the encoding of each of the filenames involved.  Since
       each filename could have a different encoding there's a few different options to pursue.  We  could  make
       this function always return byte <b>str</b> since that can accurately represent anything that could be returned.
       If we want to return <b>unicode</b> we need to at least allow the user to specify what to do in case of an error
       decoding  the  bytes  to  <b>unicode</b>.   We  can  also let the user specify the encoding to use for doing the
       decoding but that won't help in all cases since not all files will be  in  the  same  encoding  (or  even
       necessarily in any encoding):

          import locale
          import os
          def listdir(directory, encoding=locale.getpreferredencoding(), errors='strict'):
              # Note: In python-3.1+, surrogateescape may be a better default
              files = os.listdir(directory)
              if isinstance(directory, str):
                  return files
              new_files = []
              for filename in files:
                  if not isinstance(filename, unicode):
                      filename = unicode(filename, encoding=encoding, errors=errors)
                  new_files.append(filename)
              return new_files

       Note  that although we use <b>errors</b> in this example as what to pass to the codec that decodes to <b>unicode</b> we
       could also have an <b>errors</b> argument that decides other things to do like skip a filename entirely,  return
       a placeholder (<b>Nondisplayable</b> <b>filename</b>), or raise an exception.

       This leaves us with one last failure to describe:

          def first_field(csv_string):
              '''Return the first field in a comma separated values string.'''
              try:
                  return csv_string[:csv_string.index(',')]
              except ValueError:
                  return csv_string

       This code looks simple enough.  The hidden error here is that we are searching for a comma character in a
       byte <b>str</b> but not all encodings will use the same sequence of bytes to represent the comma.  If you use an
       encoding that's not <u>ASCII</u> compatible on the byte level, then the literal comma <b>','</b> in the above code will
       match inappropriate bytes.  Some examples of how it can fail:

       ‚Ä¢ Will find the byte representing an <u>ASCII</u> comma in another character

       ‚Ä¢ Will find the comma but leave trailing garbage bytes on the end of the string

       ‚Ä¢ Will not match the character that represents the comma in this encoding

       There  are  two ways to solve this.  You can either take the encoding value from the user or you can take
       the separator value from the user.  Of the two, taking the encoding is the better option for two reasons:

       1. Taking a separator argument doesn't clearly document for the API user that the reason they  must  give
          it  is  to  properly  match the encoding of the <b>csv_string</b>.  They're just as likely to think that it's
          simply a way to specify an alternate character (like ":" or "|") for the separator.

       2. It's possible for a variable width encoding to reuse the same byte sequence for  different  characters
          in multiple sequences.

          <b>NOTE:</b>
             <u>UTF-8</u>  is  resistant to this as any character's sequence of bytes will never be a subset of another
             character's sequence of bytes.

       With that in mind, here's how to improve the API:

          def first_field(csv_string, encoding='utf-8', errors='replace'):
              if not isinstance(csv_string, unicode):
                  u_string = unicode(csv_string, encoding, errors)
                  is_unicode = False
              else:
                  u_string = csv_string

              try:
                  field = u_string[:U_string.index(u',')]
              except ValueError:
                  return csv_string

              if not is_unicode:
                  field = field.encode(encoding, errors)
              return field

       <b>NOTE:</b>
          If you decide you'll never encounter a variable width encoding that reuses byte sequences you can  use
          this code instead:

              def first_field(csv_string, encoding='utf-8'):
                  try:
                      return csv_string[:csv_string.index(','.encode(encoding))]
                  except ValueError:
                      return csv_string

   <b>Separate</b> <b>functions</b>
       Sometimes  you  want to be able to take either byte <b>str</b> or <b>unicode</b> strings, perform similar operations on
       either one and then return data in the same format as was given.  Probably the easiest way to do that  is
       to  have  separate  functions for each and adopt a naming convention to show that one is for working with
       byte <b>str</b> and the other is for working with <b>unicode</b> strings:

          def translate_b(msg, table):
              '''Replace values in str with other byte values like unicode.translate'''
              if not isinstance(msg, str):
                  raise TypeError('msg must be of type str')
              str_table = [chr(s) for s in xrange(0,256)]
              delete_chars = []
              for chr_val in (k for k in table.keys() if isinstance(k, int)):
                  if chr_val &gt; 255:
                      raise ValueError('Keys in table must not exceed 255)')
                  if table[chr_val] == None:
                      delete_chars.append(chr(chr_val))
                  elif isinstance(table[chr_val], int):
                      if table[chr_val] &gt; 255:
                          raise TypeError('table values cannot be more than 255 or less than 0')
                      str_table[chr_val] = chr(table[chr_val])
                  else:
                      if not isinstance(table[chr_val], str):
                          raise TypeError('character mapping must return integer, None or str')
                      str_table[chr_val] = table[chr_val]
              str_table = ''.join(str_table)
              delete_chars = ''.join(delete_chars)
              return msg.translate(str_table, delete_chars)

          def translate(msg, table):
              '''Replace values in a unicode string with other values'''
              if not isinstance(msg, unicode):
                  raise TypeError('msg must be of type unicode')
              return msg.translate(table)

       There's several things that we have to do in this API:

       ‚Ä¢ Because the function names might not be enough of a clue to the user of  the  functions  of  the  value
         types that are expected, we have to check that the types are correct.

       ‚Ä¢ We  keep  the  behaviour  of the two functions as close to the same as possible, just with byte <b>str</b> and
         <b>unicode</b> strings substituted for each other.

   <b>Deciding</b> <b>whether</b> <b>to</b> <b>take</b> <b>str</b> <b>or</b> <b>unicode</b> <b>when</b> <b>no</b> <b>value</b> <b>is</b> <b>returned</b>
       Not all functions have a return value.  Sometimes a function is there to interact with something external
       to python, for instance, writing a file out to disk or a method exists to update the internal state of  a
       data  structure.   One of the main questions with these APIs is whether to take byte <b>str</b>, <b>unicode</b> string,
       or both.  The answer depends on your use case but I'll give some examples here.

   <b>Writing</b> <b>to</b> <b>external</b> <b>data</b>
       When your information is going to an external data source like writing to  a  file  you  need  to  decide
       whether  to  take in <b>unicode</b> strings or byte <b>str</b>.  Remember that most external data sources are not going
       to be dealing with unicode directly.  Instead, they're going to be dealing with a sequence of bytes  that
       may  be  interpreted as unicode.  With that in mind, you either need to have the user give you a byte <b>str</b>
       or convert to a byte <b>str</b> inside the function.

       Next you need to think about the type of  data  that  you're  receiving.   If  it's  textual  data,  (for
       instance,  this  is  a chat client and the user is typing messages that they expect to be read by another
       person) it probably makes sense to take in <b>unicode</b> strings and do the conversion  inside  your  function.
       On  the  other  hand,  if  this  is  a lower level function that's passing data into a network socket, it
       probably should be taking byte <b>str</b> instead.

       Just as noted in the API notes above, you should specify an <b>encoding</b> and <b>errors</b> argument if you  need  to
       transform from <b>unicode</b> string to byte <b>str</b> and you are unable to guess the encoding from the data itself.

   <b>Updating</b> <b>data</b> <b>structures</b>
       Sometimes  your  API  is  just  going  to  update  a  data structure and not immediately output that data
       anywhere.  Just as when writing external data, you should think about both what your function is going to
       do with the data eventually and what the caller of your function is thinking  that  they're  giving  you.
       Most  of  the time, you'll want to take <b>unicode</b> strings and enter them into the data structure as <b>unicode</b>
       when the data is textual in nature.  You'll want to take byte <b>str</b> and enter them into the data  structure
       as byte <b>str</b> when the data is not text.  Use a naming convention so the user knows what's expected.

   <b>APIs</b> <b>to</b> <b>Avoid</b>
       There  are  a  few  APIs that are just wrong.  If you catch yourself making an API that does one of these
       things, change it before anyone sees your code.

   <b>Returning</b> <b>unicode</b> <b>unless</b> <b>a</b> <b>conversion</b> <b>fails</b>
       This type of API usually deals with byte <b>str</b> at some point  and  converts  it  to  <b>unicode</b>  because  it's
       usually thought to be text.  However, there are times when the bytes fail to convert to a <b>unicode</b> string.
       When that happens, this API returns the raw byte <b>str</b> instead of a <b>unicode</b> string.  One example of this is
       present in the <u>python</u> <u>standard</u> <u>library</u>: python2's <b>os.listdir()</b>:

          &gt;&gt;&gt; import os
          &gt;&gt;&gt; import locale
          &gt;&gt;&gt; locale.getpreferredencoding()
          'UTF-8'
          &gt;&gt;&gt; os.mkdir('/tmp/mine')
          &gt;&gt;&gt; os.chdir('/tmp/mine')
          &gt;&gt;&gt; open('nonsense_char_\xff', 'w').close()
          &gt;&gt;&gt; open('all_ascii', 'w').close()
          &gt;&gt;&gt; os.listdir(u'.')
          [u'all_ascii', 'nonsense_char_\xff']

       The  problem  with  APIs  like this is that they cause failures that are hard to debug because they don't
       happen where the variables are set.  For instance, let's say you take the filenames from <b>os.listdir()</b> and
       give it to this function:

          def normalize_filename(filename):
              '''Change spaces and dashes into underscores'''
              return filename.translate({ord(u' '):u'_', ord(u' '):u'_'})

       When you test this, you use filenames that all are decodable in your preferred  encoding  and  everything
       seems  to  work.   But  when  this  code is run on a machine that has filenames in multiple encodings the
       filenames  returned  by  <b>os.listdir()</b>  suddenly  include  byte  <b>str</b>.   And  byte  <b>str</b>  has  a   different
       <b>string.translate()</b>  function that takes different values.  So the code raises an exception where it's not
       immediately obvious that <b>os.listdir()</b> is at fault.

   <b>Ignoring</b> <b>values</b> <b>with</b> <b>no</b> <b>chance</b> <b>of</b> <b>recovery</b>
       An early version of python3 attempted to fix the <b>os.listdir()</b> problem pointed out in the last section  by
       returning  all values that were decodable to <b>unicode</b> and omitting the filenames that were not.  This lead
       to the following output:

          &gt;&gt;&gt; import os
          &gt;&gt;&gt; import locale
          &gt;&gt;&gt; locale.getpreferredencoding()
          'UTF-8'
          &gt;&gt;&gt; os.mkdir('/tmp/mine')
          &gt;&gt;&gt; os.chdir('/tmp/mine')
          &gt;&gt;&gt; open(b'nonsense_char_\xff', 'w').close()
          &gt;&gt;&gt; open('all_ascii', 'w').close()
          &gt;&gt;&gt; os.listdir('.')
          ['all_ascii']

       The issue with this type of code is that it is silently doing something surprising.  The  caller  expects
       to  get  a  full  list  of files back from <b>os.listdir()</b>.  Instead, it silently ignores some of the files,
       returning only a subset.  This leads to code that doesn't do what is expected that may go unnoticed until
       the code is in production and someone notices that something important is being missed.

   <b>Raising</b> <b>a</b> <b>UnicodeException</b> <b>with</b> <b>no</b> <b>chance</b> <b>of</b> <b>recovery</b>
       Believe it or not, a few libraries exist that make it  impossible  to  deal  with  unicode  text  without
       raising  a  <b>UnicodeError</b>.   What seems to occur in these libraries is that the library has functions that
       expect to receive a <b>unicode</b> string.  However, internally,  those  functions  call  other  functions  that
       expect  to  receive  a  byte  <b>str</b>.   The programmer of the API was smart enough to convert from a <b>unicode</b>
       string to a byte <b>str</b> but they did not give the user the chance to specify the encodings to use or how  to
       deal  with  errors.   This  results  in exceptions when the user passes in a byte <b>str</b> because the initial
       function wants a <b>unicode</b> string and exceptions when the user passes  in  a  <b>unicode</b>  string  because  the
       function can't convert the string to bytes in the encoding that it's selected.

       Do not put the user in the position of not being able to use your API without raising a <b>UnicodeError</b> with
       certain  values.   If you can only safely take <b>unicode</b> strings, document that byte <b>str</b> is not allowed and
       vice versa.  If you have to convert internally, make sure to give the caller of your function  parameters
       to  control the encoding and how to treat errors that may occur during the encoding/decoding process.  If
       your code will raise a <b>UnicodeError</b> with non-<u>ASCII</u> values no matter what,  you  should  probably  rethink
       your API.

   <b>Knowing</b> <b>your</b> <b>data</b>
       If  you've  read  all the way down to this section without skipping you've seen several admonitions about
       the type of data you are processing affecting the viability of the various API choices.

       Here's a few things to consider in your data:

   <b>Do</b> <b>you</b> <b>need</b> <b>to</b> <b>operate</b> <b>on</b> <b>both</b> <b>bytes</b> <b>and</b> <b>unicode?</b>
       Much of the data in libraries, programs, and the general environment outside of python is  written  where
       strings  are sequences of bytes.  So when we interact with data that comes from outside of python or data
       that is about to leave python it may make sense to only operate on the data as a byte <b>str</b>.   There's  two
       times when this may make sense:

       1. The  user is intended to hand the data to the function and then the function takes care of sending the
          data outside of python (to the filesystem, over the network, etc).

       2. The data is not representable as text.  For instance, writing a binary file format.

       Even when your code is operating in this area you still need to think a little more about your data.  For
       instance, it might make sense for the person using your API to  pass  in  <b>unicode</b>  strings  and  let  the
       function convert that into the byte <b>str</b> that it then sends over the wire.

       There  are  also  times  when it might make sense to operate only on <b>unicode</b> strings.  <b>unicode</b> represents
       text so anytime that you are working on textual data  that  isn't  going  to  leave  python  it  has  the
       potential  to be a <b>unicode</b>-only API.  However, there's two things that you should consider when designing
       a <b>unicode</b>-only API:

       1. As your API gains popularity, people are going to use your API in places that you may not have thought
          of.  Corner cases in these other places may mean that processing bytes is desirable.

       2. In python2, byte <b>str</b> and <b>unicode</b> are often used interchangably  with  each  other.   That  means  that
          people  programming  against  your  API may have received <b>str</b> from some other API and it would be most
          convenient for their code if your API accepted it.

       <b>NOTE:</b>
          In python3, the separation between the text type and the byte type are more  clear.   So  in  python3,
          there's less need to have all APIs take both unicode and bytes.

   <b>Can</b> <b>you</b> <b>restrict</b> <b>the</b> <b>encodings?</b>
       If  you  determine  that  you  have  to  deal with byte <b>str</b> you should realize that not all encodings are
       created equal.  Each has different properties that may make it possible to provide a simpler API provided
       that you can reasonably tell the users of your API that they cannot use certain classes of encodings.

       As one example, if you are required to find a comma (<b>,</b>) in a byte <b>str</b> you have different choices based on
       what encodings are allowed.  If you  can  reasonably  restrict  your  API  users  to  only  giving  <u>ASCII</u>
       <u>compatible</u>  encodings  you  can  do this simply by searching for the literal comma character because that
       character will be represented by the same byte sequence in all <u>ASCII</u> <u>compatible</u> encodings.

       The following are some classes of encodings to be aware of as you decide how generic your code  needs  to
       be.

   <b>Single</b> <b>byte</b> <b>encodings</b>
       Single  byte  encodings  can  only  represent  256  total  characters.  They encode the <u>code</u> <u>points</u> for a
       character to the equivalent number in a single byte.

       Most single byte encodings are <u>ASCII</u> <u>compatible</u>.  <u>ASCII</u> <u>compatible</u> encodings are the most  likely  to  be
       usable  without changes to code so this is good news.  A notable exception to this is the <u>EBDIC</u> family of
       encodings.

   <b>Multibyte</b> <b>encodings</b>
       Multibyte encodings use more than one byte to encode some characters.

   <b>Fixed</b> <b>width</b>
       Fixed width encodings have a set number of bytes to represent all of the characters in the character set.
       <b>UTF-32</b> is an example of a fixed width encoding that uses four bytes per character and can  express  every
       unicode  characters.   There  are  a  number  of problems with writing APIs that need to operate on fixed
       width, multibyte characters.  To go back to our earlier example of finding a comma in a string,  we  have
       to  realize  that  even  in <b>UTF-32</b> where the <u>code</u> <u>point</u> for <u>ASCII</u> characters is the same as in <u>ASCII</u>, the
       byte sequence for them is different.  So you cannot search for the literal byte character as it may  pick
       up false positives and may break a byte sequence in an odd place.

   <b>Variable</b> <b>Width</b>
   <b>ASCII</b> <b>compatible</b>
       <u>UTF-8</u>  and  the  <u>EUC</u>  family  of  encodings  are examples of <u>ASCII</u> <u>compatible</u> multi-byte encodings.  They
       achieve this by adhering to two principles:

       ‚Ä¢ All of the <u>ASCII</u> characters are represented by the byte that they are in the <u>ASCII</u> encoding.

       ‚Ä¢ None of the <u>ASCII</u> byte sequences are reused in any other byte sequence for a different character.

   <b>Escaped</b>
       Some multibyte encodings work by using only bytes from the <u>ASCII</u> encoding but when a particular  sequence
       of  those  byes is found, they are interpreted as meaning something other than their <u>ASCII</u> values.  <b>UTF-7</b>
       is one such encoding that can encode all of the  unicode  <u>code</u>  <u>points</u>.   For  instance,  here's  a  some
       Japanese characters encoded as <b>UTF-7</b>:

          &gt;&gt;&gt; a = u'\u304f\u3089\u3068\u307f'
          &gt;&gt;&gt; print a
          „Åè„Çâ„Å®„Åø
          &gt;&gt;&gt; print a.encode('utf-7')

          +ME8wiTBoMH8-
       These  encodings  can  be used when you need to encode unicode data that may contain non-<u>ASCII</u> characters
       for inclusion in an <u>ASCII</u> only transport medium or file.

       However, they are not <u>ASCII</u> <u>compatible</u> in the sense that we used earlier as the bytes  that  represent  a
       <u>ASCII</u>  character  are being reused as part of other characters.  If you were to search for a literal plus
       sign in this encoded string, you would run across many false positives, for instance.

   <b>Other</b>
       There are many other popular variable width encodings, for instance <b>UTF-16</b> and <b>shift-JIS</b>.  Many of  these
       are  not  <u>ASCII</u>  <u>compatible</u>  so  you  cannot search for a literal <u>ASCII</u> character without danger of false
       positives or false negatives.

   <b>Kitchen</b> <b>API</b>
       Kitchen is structured as a collection of modules.  In its current configuration, Kitchen ships  with  the
       following  modules.   Other  addon modules that may drag in more dependencies can be found on the <u>project</u>
       <u>webpage</u>

   <b>Kitchen.i18n</b> <b>Module</b>
       <u>I18N</u> is an important piece of any modern program.  Unfortunately, setting up  <u>i18n</u>  in  your  program  is
       often a confusing process.  The functions provided here aim to make the programming side of that a little
       easier.

       Most projects will be able to do something like this when they startup:

          # myprogram/__init__.py:

          import os
          import sys

          from kitchen.i18n import easy_gettext_setup

          _, N_  = easy_gettext_setup('myprogram', localedirs=(
                  os.path.join(os.path.realpath(os.path.dirname(__file__)), 'locale'),
                  os.path.join(sys.prefix, 'lib', 'locale')
                  ))

       Then, in other files that have strings that need translating:

          # myprogram/commands.py:

          from myprogram import _, N_

          def print_usage():
              print _(u"""available commands are:
              --help              Display help
              --version           Display version of this program
              --bake-me-a-cake    as fast as you can
                  """)

          def print_invitations(age):
              print _('Please come to my party.')
              print N_('I will be turning %(age)s year old',
                  'I will be turning %(age)s years old', age) % {'age': age}

       See the documentation of <u>easy_gettext_setup()</u> and <u>get_translation_object()</u> for more details.

          <b>SEE</b> <b>ALSO:</b>

              <b>gettext</b>
                     for details of how the python gettext facilities work

              <u>babel</u>  The  babel  module  for  in depth information on gettext, <u>message</u> <u>catalogs</u>, and translating
                     your app.  babel provides some nice features for <u>i18n</u> on top of <b>gettext</b>

   <b>Functions</b>
       <u>easy_gettext_setup()</u> should satisfy the needs of most users.   <u>get_translation_object()</u>  is  designed  to
       ease the way for anyone that needs more control.

       <b>kitchen.i18n.easy_gettext_setup(domain,</b> <b>localedirs=(),</b> <b>use_unicode=True)</b>
              Setup translation functions for an application

              <b>Parameters</b>

                     ‚Ä¢ <b>domain</b>  --  Name of the message domain.  This should be a unique name that can be used to
                       lookup the <u>message</u> <u>catalog</u> for this app.

                     ‚Ä¢ <b>localedirs</b> -- Iterator of directories to look for  <u>message</u>  <u>catalogs</u>  under.   The  first
                       directory  to  exist  is used regardless of whether messages for this domain are present.
                       If none of the directories exist, fallback on  <b>sys.prefix</b>  +  <b>/share/locale</b>  Default:  No
                       directories to search so we just use the fallback.

                     ‚Ä¢ <b>use_unicode</b>  --  If  <b>True</b>  return  the  <b>gettext</b> functions for <b>str</b> strings else return the
                       functions for byte <b>bytes</b> for the translations.  Default is <b>True</b>.

              <b>Returns</b>
                     tuple of the <b>gettext</b> function and <b>gettext</b> function for plurals

              Setting up <b>gettext</b> can be a little tricky because of lack of documentation.   This  function  will
              setup  <b>gettext</b>   using  the <u>Class-based</u> <u>API</u> for you.  For the simple case, you can use the default
              arguments and call it like this:

                 _, N_ = easy_gettext_setup()

              This will get you two functions, <b>_()</b> and <b>N_()</b> that you can use to mark strings in  your  code  for
              translation.   <b>_()</b>  is  used to mark strings that don't need to worry about plural forms no matter
              what the value of the variable is.  <b>N_()</b> is used to mark strings that do need to have a  different
              form if a variable in the string is plural.

              <b>SEE</b> <b>ALSO:</b>

                 <u>Kitchen.i18n</u> <u>Module</u>
                        This module's documentation has examples of using <b>_()</b> and <b>N_()</b>

                 <u>get_translation_object()</u>
                        for information on how to use <b>localedirs</b> to get the proper <u>message</u> <u>catalogs</u> both when in
                        development and when installed to FHS compliant directories on Linux.

              <b>NOTE:</b>
                 The  gettext functions returned from this function should be superior to the ones returned from
                 <b>gettext</b>.  The traits  that  make  them  better  are  described  in  the  <u>DummyTranslations</u>  and
                 <u>NewGNUTranslations</u> documentation.

              Changed  in version kitchen-0.2.4: ; API kitchen.i18n 2.0.0 Changed <u>easy_gettext_setup()</u> to return
              the lgettext functions instead of gettext functions when use_unicode=False.

       <b>kitchen.i18n.get_translation_object(domain,</b> <b>localedirs=(),</b> <b>languages=None,</b> <b>class_=None,</b> <b>fallback=True,</b>
       <b>codeset=None,</b> <b>python2_api=True)</b>
              Get a translation object bound to the <u>message</u> <u>catalogs</u>

              <b>Parameters</b>

                     ‚Ä¢ <b>domain</b> -- Name of the message domain.  This should be a unique name that can be  used  to
                       lookup the <u>message</u> <u>catalog</u> for this app or library.

                     ‚Ä¢ <b>localedirs</b>  --  Iterator  of  directories  to  look  for  <u>message</u>  <u>catalogs</u>  under.   The
                       directories are searched in order for <u>message</u> <u>catalogs</u>.   For  each  of  the  directories
                       searched, we check for message catalogs in any language specified in:attr:<u>languages</u>.  The
                       <u>message</u>  <u>catalogs</u>  are  used  to  create  the  Translation  object  that  we return.  The
                       Translation object will attempt to lookup the msgid in the first catalog that  we  found.
                       If  it's  not  in  there, it will go through each subsequent catalog looking for a match.
                       For this reason, the order in which you specify the <b>localedirs</b> may be important.   If  no
                       <u>message</u>  <u>catalogs</u> are found, either return a <u>DummyTranslations</u> object or raise an <b>IOError</b>
                       depending on the value of  <b>fallback</b>.   Rhe  default  localedir  from   <b>gettext</b>  which  is
                       <b>os.path.join(sys.prefix,</b>  <b>'share',</b>  <b>'locale')</b>  on  Unix  is  implicitly  appended  to the
                       <b>localedirs</b>, making it the last directory searched.

                     ‚Ä¢ <b>languages</b> --

                       Iterator of language codes to check for <u>message</u> <u>catalogs</u>.   If  unspecified,  the  user's
                       locale settings will be used.

                       <b>SEE</b> <b>ALSO:</b>
                          <b>gettext.find()</b> for information on what environment variables are used.

                     ‚Ä¢ <b>class</b> -- The class to use to extract translations from the <u>message</u> <u>catalogs</u>.  Defaults to
                       <u>NewGNUTranslations</u>.

                     ‚Ä¢ <b>fallback</b>  -- If set to data:<u>False</u>, raise an <b>IOError</b> if no <u>message</u> <u>catalogs</u> are found.  If
                       <b>True</b>, the default, return a <u>DummyTranslations</u> object.

                     ‚Ä¢ <b>codeset</b> -- Set the character encoding to use when returning byte <b>bytes</b> objects.  This  is
                       equivalent  to  calling <b>output_charset()</b> on the Translations object that is returned from
                       this function.

                     ‚Ä¢ <b>python2_api</b> -- When data:<u>True</u> (default), return Translation objects that use the  python2
                       gettext  api  (<b>gettext()</b> and <b>lgettext()</b> return byte <b>bytes</b>.  <b>ugettext()</b> exists and returns
                       <b>str</b> strings).  When <b>False</b>, return Translation objects that use the  python3  gettext  api
                       (gettext returns <b>str</b> strings and lgettext returns byte <b>bytes</b>.  ugettext does not exist.)

              <b>Returns</b>
                     Translation object to get <b>gettext</b> methods from

              If  you  need more flexibility than <u>easy_gettext_setup()</u>, use this function.  It sets up a <b>gettext</b>
              Translation object and returns it to you.  Then you can access any of the methods  of  the  object
              that you need directly.  For instance, if you specifically need to access <b>lgettext()</b>:

                 translations = get_translation_object('foo')
                 translations.lgettext('My Message')

              This  function is similar to the <u>python</u> <u>standard</u> <u>library</u> <b>gettext.translation()</b> but makes it better
              in two ways

              1.

                 <b>It</b> <b>returns</b> <u>NewGNUTranslations</u> <b>or</b> <u>DummyTranslations</u>
                        objects  by  default.   These  are   superior   to   the   <b>gettext.GNUTranslations</b>   and
                        <b>gettext.NullTranslations</b>  objects  because  they  are consistent in the string type they
                        return and they fix several issues that can causethe <u>python</u> <u>standard</u> <u>library</u> objects  to
                        throw <b>UnicodeError</b>.

              2.

                 <b>This</b> <b>function</b> <b>takes</b> <b>multiple</b> <b>directories</b> <b>to</b> <b>search</b> <b>for</b>
                        <u>message</u> <u>catalogs</u>.

              The  latter  is  important  when  setting  up <b>gettext</b> in a portable manner.  There is not a common
              directory for translations across operating systems so one needs to look in  multiple  directories
              for  the  translations.   <u>get_translation_object()</u> is able to handle that if you give it a list of
              directories to search for catalogs:

                 translations = get_translation_object('foo', localedirs=(
                      os.path.join(os.path.realpath(os.path.dirname(__file__)), 'locale'),
                      os.path.join(sys.prefix, 'lib', 'locale')))

              This will search for several different directories:

              1. A  directory   named   <b>locale</b>   in   the   same   directory   as   the   module   that   called
                 <u>get_translation_object()</u>,

              2. In <b><a href="file:/usr/lib/locale">/usr/lib/locale</a></b>

              3. In <b><a href="file:/usr/share/locale">/usr/share/locale</a></b> (the fallback directory)

              This  allows  <b>gettext</b>  to  work  on  Windows  and  in  development (where the <u>message</u> <u>catalogs</u> are
              typically in the toplevel module directory) and also when installed under Linux (where the <u>message</u>
              <u>catalogs</u> are installed in <b><a href="file:/usr/share/locale">/usr/share/locale</a></b>).  You (or the system packager) just need  to  install
              the  <u>message</u> <u>catalogs</u> in <b><a href="file:/usr/share/locale">/usr/share/locale</a></b> and remove the <b>locale</b> directory from the module to make
              this work.  ie:

                 In development:
                     <a href="file:~/foo">~/foo</a>   # Toplevel module directory
                     <a href="file:~/foo/__init__.py">~/foo/__init__.py</a>
                     <a href="file:~/foo/locale">~/foo/locale</a>    # With message catalogs below here:
                     <a href="file:~/foo/locale/es/LC_MESSAGES/foo.mo">~/foo/locale/es/LC_MESSAGES/foo.mo</a>

                 Installed on Linux:
                     /usr/lib/python2.7/site-packages/foo
                     /usr/lib/python2.7/site-packages/foo/__init__.py
                     <a href="file:/usr/share/locale/">/usr/share/locale/</a>  # With message catalogs below here:
                     /usr/share/locale/es/LC_MESSAGES/foo.mo

              <b>NOTE:</b>
                 This function will setup Translation objects that attempt to lookup msgids in all of the  found
                 <u>message</u> <u>catalogs</u>.  This means if you have several versions of the <u>message</u> <u>catalogs</u> installed in
                 different  directories  that  the  function  searches,  you  need  to make sure that <b>localedirs</b>
                 specifies the directories so that newer <u>message</u> <u>catalogs</u> are searched  first.   It  also  means
                 that  if  a newer catalog does not contain a translation for a msgid but an older one that's in
                 <b>localedirs</b> does, the translation from that older catalog will be returned.

              Changed  in  version  kitchen-1.1.0:  ;  API   kitchen.i18n   2.1.0   Add   more   parameters   to
              <u>get_translation_object()</u> so it can more easily be used as a replacement for <b>gettext.translation()</b>.
              Also change the way we use localedirs.  We cycle through them until we find a suitable locale file
              rather  than  simply cycling through until we find a directory that exists.  The new code is based
              heavily on the <u>python</u> <u>standard</u> <u>library</u> <b>gettext.translation()</b> function.

              Changed in version kitchen-1.2.0: ; API kitchen.i18n 2.2.0 Add python2_api parameter

   <b>Translation</b> <b>Objects</b>
       The standard translation objects from the <b>gettext</b> module suffer from several problems:

       ‚Ä¢ They can throw <b>UnicodeError</b>

       ‚Ä¢ They can't find translations for non-<u>ASCII</u> byte <b>str</b> messages

       ‚Ä¢ They may return either <b>unicode</b> string or byte <b>str</b> from the same function even though the functions  say
         they will only return <b>unicode</b> or only return byte <b>str</b>.

       <u>DummyTranslations</u> and <u>NewGNUTranslations</u> were written to fix these issues.

       <b>class</b> <b>kitchen.i18n.DummyTranslations(fp=None,</b> <b>python2_api=True)</b>
              Safer version of <b>gettext.NullTranslations</b>

              This  Translations  class  doesn't  translate the strings and is intended to be used as a fallback
              when  there  were  errors  setting   up   a   real   Translations   object.    It's   safer   than
              <b>gettext.NullTranslations</b> in its handling of byte <b>bytes</b> vs <b>str</b> strings.

              Unlike  <b>NullTranslations</b>,  this  Translation class will never throw a <b>UnicodeError</b>.  The code that
              you have around a call to <u>DummyTranslations</u> might throw a <b>UnicodeError</b> but at least that  will  be
              in  code  you control and can fix.  Also, unlike <b>NullTranslations</b> all of this Translation object's
              methods guarantee to return byte <b>bytes</b> except for <b>ugettext()</b> and <b>ungettext()</b>  which  guarantee  to
              return <b>str</b> strings.

              When byte <b>bytes</b> are returned, the strings will be encoded according to this algorithm:

              1. If  a  fallback  has been added, the fallback will be called first.  You'll need to consult the
                 fallback to see whether it performs any encoding changes.

              2. If a byte <b>bytes</b> was given, the same byte <b>bytes</b> will be returned.

              3. If a <b>str</b> string was given and <u>set_output_charset()</u> has been called then we  encode  the  string
                 using the <u>output_charset</u>

              4. If  a  <b>str</b>  string was given and this is <b>gettext()</b> or <b>ngettext()</b> and <b>_charset</b> was set output in
                 that charset.

              5. If a <b>str</b> string was given and this is <b>gettext()</b> or <b>ngettext()</b> we encode it using 'utf-8'.

              6. If a <b>str</b> string was given and this is <b>lgettext()</b> or <b>lngettext()</b> we encode using  the  value  of
                 <b>locale.getpreferredencoding()</b>

              For  <b>ugettext()</b>  and  <b>ungettext()</b>,  we  go  through  the  same  set  of  steps  with the following
              differences:

              ‚Ä¢ We transform byte <b>bytes</b> into <b>str</b> strings for these methods.

              ‚Ä¢ The encoding used to decode the byte <b>bytes</b> is taken from <u>input_charset</u> if it's set, otherwise we
                decode using <u>UTF-8</u>.

              <b>input_charset</b>
                     is an extension to the <u>python</u> <u>standard</u>  <u>library</u>  <b>gettext</b>  that  specifies  what  charset  a
                     message is encoded in when decoding a message to <b>str</b>.  This is used for two purposes:

              1. If the message string is a byte <b>bytes</b>, this is used to decode the string to a <b>str</b> string before
                 looking it up in the <u>message</u> <u>catalog</u>.

              2. In  <b>ugettext()</b>  and  <b>ungettext()</b>  methods,  if  a  byte  <b>bytes</b>  is  given as the message and is
                 untranslated this is used as the encoding  when  decoding  to  <b>str</b>.   This  is  different  from
                 <b>_charset</b>  which  may  be  set when a <u>message</u> <u>catalog</u> is loaded because <u>input_charset</u> is used to
                 describe an encoding used in a python source file while <b>_charset</b> describes the encoding used in
                 the <u>message</u> <u>catalog</u> file.

              Any characters that aren't able to be transformed from a byte <b>bytes</b> to <b>str</b> string  or  vice  versa
              will  be  replaced with a replacement character (ie: <b>u'ÔøΩ'</b> in unicode based encodings, <b>'?'</b> in other
              <u>ASCII</u> compatible encodings).

              <b>SEE</b> <b>ALSO:</b>

                 <b>gettext.NullTranslations</b>
                        For information about what methods are available and what they do.

              Changed in version kitchen-1.1.0: ; API kitchen.i18n 2.1.0 * Although we  had  adapted  <b>gettext()</b>,
              <b>ngettext()</b>,
                <b>lgettext()</b>, and <b>lngettext()</b> to always return byte
                <b>bytes</b>, we hadn't forced those byte <b>bytes</b> to always be
                in a specified charset.  We now make sure that <b>gettext()</b> and
                <b>ngettext()</b> return byte <b>bytes</b> encoded using
                <u>output_charset</u> if set, otherwise <b>charset</b> and if
                neither of those, <u>UTF-8</u>.  With <b>lgettext()</b> and
                <b>lngettext()</b> <u>output_charset</u> if set, otherwise
                <b>locale.getpreferredencoding()</b>.  * Make setting <u>input_charset</u> and <u>output_charset</u> also
                set those attributes on any fallback translation objects.

              Changed in version kitchen-1.2.0: ; API kitchen.i18n 2.2.0 Add python2_api parameter to __init__()

              <b>output_charset()</b>
                     Compatibility for python2.3 which doesn't have output_charset

              <b>set_output_charset(charset)</b>
                     Set the output charset

                     This  serves  two  purposes.  The normal <b>gettext.NullTranslations.set_output_charset()</b> does
                     not set the output on fallback objects.  On  python-2.3,  <b>gettext.NullTranslations</b>  objects
                     don't contain this method.

       <b>class</b> <b>kitchen.i18n.NewGNUTranslations(fp=None,</b> <b>python2_api=True)</b>
              Safer version of <b>gettext.GNUTranslations</b>

              <b>gettext.GNUTranslations</b> suffers from two problems that this class fixes.

              1. <b>gettext.GNUTranslations</b>  can  throw a <b>UnicodeError</b> in <b>gettext.GNUTranslations.ugettext()</b> if the
                 message being translated has non-<u>ASCII</u> characters and there is no translation for it.

              2. <b>gettext.GNUTranslations</b> can return byte <b>bytes</b> from <b>gettext.GNUTranslations.ugettext()</b>  and  <b>str</b>
                 strings from the other <b>gettext()</b> methods if the message being translated is the wrong type

              When byte <b>bytes</b> are returned, the strings will be encoded according to this algorithm:

              1. If  a  fallback  has been added, the fallback will be called first.  You'll need to consult the
                 fallback to see whether it performs any encoding changes.

              2. If a byte <b>bytes</b> was given, the same byte <b>bytes</b> will be returned.

              3. If a <b>str</b> string was given and <b>set_output_charset()</b> has been called then we  encode  the  string
                 using the <b>output_charset</b>

              4. If  a  <b>str</b> string was given and this is <b>gettext()</b> or <b>ngettext()</b> and a charset was detected when
                 parsing the <u>message</u> <u>catalog</u>, output in that charset.

              5. If a <b>str</b> string was given and this is <b>gettext()</b> or <b>ngettext()</b> we encode it using <u>UTF-8</u>.

              6. If a <b>str</b> string was given and this is <b>lgettext()</b> or <b>lngettext()</b> we encode using  the  value  of
                 <b>locale.getpreferredencoding()</b>

              For  <b>ugettext()</b>  and  <b>ungettext()</b>,  we  go  through  the  same  set  of  steps  with the following
              differences:

              ‚Ä¢ We transform byte <b>bytes</b> into <b>str</b> strings for these methods.

              ‚Ä¢ The encoding used to decode the byte <b>bytes</b> is taken from <u>input_charset</u> if it's set, otherwise we
                decode using <u>UTF-8</u>

              <b>input_charset</b>
                     an extension to the <u>python</u> <u>standard</u> <u>library</u> <b>gettext</b> that specifies what charset  a  message
                     is encoded in when decoding a message to <b>str</b>.  This is used for two purposes:

              1. If the message string is a byte <b>bytes</b>, this is used to decode the string to a <b>str</b> string before
                 looking it up in the <u>message</u> <u>catalog</u>.

              2. In  <b>ugettext()</b>  and  <b>ungettext()</b>  methods,  if  a  byte  <b>bytes</b>  is  given as the message and is
                 untranslated his is used as the encoding when decoding to <b>str</b>.   This  is  different  from  the
                 <b>_charset</b>  parameter  that  may be set when a <u>message</u> <u>catalog</u> is loaded because <u>input_charset</u> is
                 used to describe an encoding used in a python source file while <b>_charset</b> describes the encoding
                 used in the <u>message</u> <u>catalog</u> file.

              Any characters that aren't able to be transformed from a byte <b>bytes</b> to <b>str</b> string  or  vice  versa
              will  be  replaced with a replacement character (ie: <b>u'ÔøΩ'</b> in unicode based encodings, <b>'?'</b> in other
              <u>ASCII</u> compatible encodings).

              <b>SEE</b> <b>ALSO:</b>

                 <b>gettext.GNUTranslations.gettext</b>
                        For information about what methods this class has and what they do

              Changed in version kitchen-1.1.0: ; API kitchen.i18n 2.1.0  Although  we  had  adapted  <b>gettext()</b>,
              <b>ngettext()</b>,  <b>lgettext()</b>,  and <b>lngettext()</b> to always return byte <b>bytes</b>, we hadn't forced those byte
              <b>bytes</b> to always be in a specified charset.  We now make sure that <b>gettext()</b> and <b>ngettext()</b>  return
              byte  <b>bytes</b> encoded using <b>output_charset</b> if set, otherwise <b>charset</b> and if neither of those, <u>UTF-8</u>.
              With <b>lgettext()</b> and <b>lngettext()</b> <b>output_charset</b> if set, otherwise <b>locale.getpreferredencoding()</b>.

   <b>Kitchen.text:</b> <b>unicode</b> <b>and</b> <b>utf8</b> <b>and</b> <b>xml</b> <b>oh</b> <b>my!</b>
       The kitchen.text module contains functions that deal with text manipulation.

   <b>Kitchen.text.converters</b>
       Functions to handle conversion of byte <b>bytes</b> and <b>str</b> strings.

       Changed in version kitchen: 0.2a2 ; API kitchen.text 2.0.0 Added <u>getwriter()</u>

       Changed  in  version  kitchen:  0.2.2    ;   API   kitchen.text   2.1.0   Added   <u>exception_to_unicode()</u>,
       <u>exception_to_bytes()</u>, <u>EXCEPTION_CONVERTERS</u>, and <u>BYTE_EXCEPTION_CONVERTERS</u>

       Changed  in version kitchen: 1.0.1 ; API kitchen.text 2.1.1 Deprecated <u>BYTE_EXCEPTION_CONVERTERS</u> as we've
       simplified <u>exception_to_unicode()</u> and <u>exception_to_bytes()</u> to make it unnecessary

   <b>Byte</b> <b>Strings</b> <b>and</b> <b>Unicode</b> <b>in</b> <b>Python2</b>
       Python2 has two string types,  <b>str</b>  and  <b>unicode</b>.   <b>unicode</b>  represents  an  abstract  sequence  of  text
       characters.  It can hold any character that is present in the unicode standard.  <b>str</b> can hold any byte of
       data.   The  operating system and python work together to display these bytes as characters in many cases
       but you should always keep in mind that the information is really a sequence of bytes, not a sequence  of
       characters.   In python2 these types are interchangeable a large amount of the time.  They are one of the
       few pairs of types that automatically convert when used in equality:

          &gt;&gt;&gt; # string is converted to unicode and then compared
          &gt;&gt;&gt; "I am a string" == u"I am a string"
          True
          &gt;&gt;&gt; # Other types, like int, don't have this special treatment
          &gt;&gt;&gt; 5 == "5"
          False

       However, this automatic conversion tends to lull people into a false  sense  of  security.   As  long  as
       you're  dealing with <u>ASCII</u> characters the automatic conversion will save you from seeing any differences.
       Once you start using characters  that  are  not  in  <u>ASCII</u>,  you  will  start  getting  <b>UnicodeError</b>  and
       <b>UnicodeWarning</b> as the automatic conversions between the types fail:

          &gt;&gt;&gt; "I am an √±" == u"I am an √±"
          __main__:1: UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal
          False

       Why  do  these  conversions  fail?   The  reason  is that the python2 <b>unicode</b> type represents an abstract
       sequence of unicode text known as <u>code</u> <u>points</u>.  <b>str</b>, on the other hand, really represents a  sequence  of
       bytes.  Those bytes are converted by your operating system to appear as characters on your screen using a
       particular  encoding  (usually  with  a  default  defined by the operating system and customizable by the
       individual user.) Although <u>ASCII</u> characters are fairly standard in what bytes represent  each  character,
       the  bytes  outside of the <u>ASCII</u> range are not.  In general, each encoding will map a different character
       to a particular byte.  Newer encodings map individual characters  to  multiple  bytes  (which  the  older
       encodings  will  instead treat as multiple characters).  In the face of these differences, python refuses
       to guess at an encoding and instead issues a warning or exception and refuses to convert.

       <b>SEE</b> <b>ALSO:</b>

          <u>Overcoming</u> <u>frustration:</u> <u>Correctly</u> <u>using</u> <u>unicode</u> <u>in</u> <u>python2</u>
                 For a longer introduction on this subject.

   <b>Strategy</b> <b>for</b> <b>Explicit</b> <b>Conversion</b>
       So what is the best method of dealing with this weltering babble  of  incoherent  encodings?   The  basic
       strategy is to explicitly turn everything into <b>unicode</b> when it first enters your program.  Then, when you
       send  it  to output, you can transform the unicode back into bytes.  Doing this allows you to control the
       encodings that are used and avoid getting tracebacks due to <b>UnicodeError</b>. Using the functions defined  in
       this module, that looks something like this:

          &gt;&gt;&gt; from kitchen.text.converters import to_unicode, to_bytes
          &gt;&gt;&gt; name = raw_input('Enter your name: ')
          Enter your name: Toshio „Åè„Çâ„Å®„Åø
          &gt;&gt;&gt; name
          'Toshio \xe3\x81\x8f\xe3\x82\x89\xe3\x81\xa8\xe3\x81\xbf'
          &gt;&gt;&gt; type(name)
          &lt;type 'str'&gt;
          &gt;&gt;&gt; unicode_name = to_unicode(name)
          &gt;&gt;&gt; type(unicode_name)
          &lt;type 'unicode'&gt;
          &gt;&gt;&gt; unicode_name
          u'Toshio \u304f\u3089\u3068\u307f'
          &gt;&gt;&gt; # Do a lot of other things before needing to save/output again:
          &gt;&gt;&gt; output = open('datafile', 'w')
          &gt;&gt;&gt; output.write(to_bytes(u'Name: %s\\n' % unicode_name))

       A few notes:

       Looking  at  line  6,  you'll  notice  that  the input we took from the user was a byte <b>str</b>.  In general,
       anytime we're getting a value from outside of python (The filesystem,  reading  data  from  the  network,
       interacting  with  an  external  command,  reading  values  from the environment) we are interacting with
       something that will want to give us a byte <b>str</b>.  Some <u>python</u> <u>standard</u> <u>library</u>  modules  and  third  party
       libraries  will  automatically  attempt to convert a byte <b>str</b> to <b>unicode</b> strings for you.  This is both a
       boon and a curse.  If the library can guess correctly about the encoding that the data  is  in,  it  will
       return  <b>unicode</b>  objects to you without you having to convert.  However, if it can't guess correctly, you
       may end up with one of several problems:

       <b>UnicodeError</b>
              The library attempted to decode a byte <b>str</b> into a <b>unicode</b>, string failed, and raises an exception.

       <b>Garbled</b> <b>data</b>
              If the library returns the data after decoding it with the wrong encoding, the characters you  see
              in the <b>unicode</b> string won't be the ones that you expect.

       <b>A</b> <b>byte</b> <b>str</b> <b>instead</b> <b>of</b> <b>unicode</b> <b>string</b>
              Some  libraries  will  return a <b>unicode</b> string when they're able to decode the data and a byte <b>str</b>
              when they can't.  This is generally the hardest problem to debug when it occurs.  Avoid it in your
              own code and try to avoid or open bugs against upstreams that do this. See <u>Designing</u> <u>Unicode</u> <u>Aware</u>
              <u>APIs</u> for strategies to do this properly.

       On line 8, we convert from a byte <b>str</b> to a <b>unicode</b> string.  <u>to_unicode()</u> does this for us.  It  has  some
       error  handling  and  sane  defaults  that  make  this  a nicer function to use than calling <b>str.decode()</b>
       directly:

       ‚Ä¢ Instead of defaulting to the <u>ASCII</u> encoding which fails  with  all  but  the  simple  American  English
         characters, it defaults to <u>UTF-8</u>.

       ‚Ä¢ Instead  of  raising  an  error if it cannot decode a value, it will replace the value with the unicode
         "Replacement character" symbol (<b>ÔøΩ</b>).

       ‚Ä¢ If you happen to call this method with something that is not a <b>str</b> or <b>unicode</b>, it will return an  empty
         <b>unicode</b> string.

       All  three  of  these  can  be  overridden  using  different  keyword arguments to the function.  See the
       <u>to_unicode()</u> documentation for more information.

       On line 15 we push the data back out to a file.  Two things you should note here:

       1. We deal with the strings as <b>unicode</b> until the last instant.  The string format  that  we're  using  is
          <b>unicode</b>  and  the variable also holds <b>unicode</b>.  People sometimes get into trouble when they mix a byte
          <b>str</b> format with a variable that holds a <b>unicode</b> string (or vice versa) at this stage.

       2. <u>to_bytes()</u>, does the reverse of <u>to_unicode()</u>.  In this case, we're using the default values which turn
          <b>unicode</b> into a byte <b>str</b> using <u>UTF-8</u>.  Any errors are replaced with a <b>ÔøΩ</b> and sending  nonstring  objects
          yield empty <b>unicode</b> strings.  Just like <u>to_unicode()</u>, you can look at the documentation for <u>to_bytes()</u>
          to find out how to override any of these defaults.

   <b>When</b> <b>to</b> <b>use</b> <b>an</b> <b>alternate</b> <b>strategy</b>
       The default strategy of decoding to <b>unicode</b> strings when you take data in and encoding to a byte <b>str</b> when
       you send the data back out works great for most problems but there are a few times when you shouldn't:

       ‚Ä¢ The values aren't meant to be read as text

       ‚Ä¢ The  values  need  to be byte-for-byte when you send them back out -- for instance if they are database
         keys or filenames.

       ‚Ä¢ You are transferring the data between several libraries that all expect byte <b>str</b>.

       In each of these instances, there is a reason to keep around the byte <b>str</b> version of a value.   Here's  a
       few hints to keep your sanity in these situations:

       1. Keep  your  <b>unicode</b>  and  <b>str</b> values separate.  Just like the pain caused when you have to use someone
          else's library that returns both <b>unicode</b> and <b>str</b> you can cause yourself pain  if  you  have  functions
          that can return both types or variables that could hold either type of value.

       2. Name  your  variables  so that you can tell whether you're storing byte <b>str</b> or <b>unicode</b> string.  One of
          the first things you end up having to do when debugging is determine what type of string you have in a
          variable and what type of string you are expecting.  Naming your variables consistently  so  that  you
          can tell which type they are supposed to hold will save you from at least one of those steps.

       3. When you get values initially, make sure that you're dealing with the type of value that you expect as
          you  save it.  You can use <b>isinstance()</b> or <u>to_bytes()</u> since <u>to_bytes()</u> doesn't do any modifications of
          the string if it's already a <b>str</b>.  When using <u>to_bytes()</u> for this purpose you might want to use:

             try:
                 b_input = to_bytes(input_should_be_bytes_already, errors='strict', nonstring='strict')
             except:
                 handle_errors_somehow()

          The reason is that the default of <u>to_bytes()</u> will take characters  that  are  illegal  in  the  chosen
          encoding and transform them to replacement characters.  Since the point of keeping this data as a byte
          <b>str</b>  is  to  keep  the  exact  same  bytes  when  you send it outside of your code, changing things to
          replacement characters should be rasing red flags that something is wrong.  Setting <b>errors</b>  to  <b>strict</b>
          will raise an exception which gives you an opportunity to fail gracefully.

       4. Sometimes  you will want to print out the values that you have in your byte <b>str</b>.  When you do this you
          will need to make sure that you transform <b>unicode</b> to <b>str</b> before combining them.  Also be sure that any
          other function calls (including <b>gettext</b>) are going to give you strings that are the  same  type.   For
          instance:

             print to_bytes(_('Username: %(user)s'), 'utf-8') % {'user': b_username}

   <b>Gotchas</b> <b>and</b> <b>how</b> <b>to</b> <b>avoid</b> <b>them</b>
       Even  when you have a good conceptual understanding of how python2 treats <b>unicode</b> and <b>str</b> there are still
       some things that can surprise you.  In most cases this is because, as noted earlier, python or one of the
       python libraries you depend on is  trying  to  convert  a  value  automatically  and  failing.   Explicit
       conversion at the appropriate place usually solves that.

   <b>str(obj)</b>
       One common idiom for getting a simple, string representation of an object is to use:

          str(obj)

       Unfortunately,  this  is  not  safe.  Sometimes str(obj) will return <b>unicode</b>.  Sometimes it will return a
       byte <b>str</b>.  Sometimes, it will attempt to convert from a <b>unicode</b> string to a byte <b>str</b>, fail, and  throw  a
       <b>UnicodeError</b>.  To be safe from all of these, first decide whether you need <b>unicode</b> or <b>str</b> to be returned.
       Then use <u>to_unicode()</u> or <u>to_bytes()</u> to get the simple representation like this:

          u_representation = to_unicode(obj, nonstring='simplerepr')
          b_representation = to_bytes(obj, nonstring='simplerepr')

   <b>print</b>
       python  has  a builtin <b>print()</b> statement that outputs strings to the terminal.  This originated in a time
       when python only dealt with byte <b>str</b>.  When <b>unicode</b> strings came about, some enhancements  were  made  to
       the  <b>print()</b>  statement so that it could print those as well.  The enhancements make <b>print()</b> work most of
       the time.  However, the times when it doesn't work tend to make for cryptic debugging.

       The basic issue is that <b>print()</b> has to figure out what encoding to use when it prints a <b>unicode</b> string to
       the terminal.  When python is attached to your terminal (ie, you're running the interpreter or running  a
       script  that  prints  to  the screen) python is able to take the encoding value from your locale settings
       <b>LC_ALL</b> or <b>LC_CTYPE</b> and print the characters allowed by that encoding.  On most modern Unix  systems,  the
       encoding is <u>utf-8</u> which means that you can print any <b>unicode</b> character without problem.

       There are two common cases of things going wrong:

       1. Someone has a locale set that does not accept all valid unicode characters.  For instance:

             $ LC_ALL=C python
             &gt;&gt;&gt; print u'\ufffd'
             Traceback (most recent call last):
               File "&lt;stdin&gt;", line 1, in &lt;module&gt;
             UnicodeEncodeError: 'ascii' codec can't encode character u'\ufffd' in position 0: ordinal not in <a href="../man128/range.128.html">range</a>(128)

          This  often  happens  when  a script that you've written and debugged from the terminal is run from an
          automated environment like <b>cron</b>.  It also occurs when you have written a script using  a  <u>utf-8</u>  aware
          locale  and  released  it  for  consumption  by  people all over the internet.  Inevitably, someone is
          running with a locale that can't handle all unicode characters and you get a traceback reported.

       2. You redirect output to a file.  Python isn't using the values in <b>LC_ALL</b> unconditionally to decide what
          encoding to use.  Instead it is using the encoding set for the terminal you are printing to  which  is
          set to accept different encodings by <b>LC_ALL</b>.  If you redirect to a file, you are no longer printing to
          the  terminal  so  <b>LC_ALL</b>  won't  have any effect.  At this point, python will decide it can't find an
          encoding and fallback to <u>ASCII</u> which will likely lead to <b>UnicodeError</b> being raised.  You can see  this
          in a short script:

             #! /usr/bin/python -tt
             print u'\ufffd'

          And then look at the difference between running it normally and redirecting to a file:

             $ ./test.py
             ÔøΩ
             $ ./test.py &gt; t
             Traceback (most recent call last):
               File "test.py", line 3, in &lt;module&gt;
                   print u'\ufffd'
             UnicodeEncodeError: 'ascii' codec can't encode character u'\ufffd' in position 0: ordinal not in <a href="../man128/range.128.html">range</a>(128)

       The  short  answer  to  dealing with this is to always use bytes when writing output.  You can do this by
       explicitly converting to bytes like this:

          from kitchen.text.converters import to_bytes
          u_string = u'\ufffd'
          print to_bytes(u_string)

       or you can wrap stdout and stderr with a <b>StreamWriter</b>.  A <b>StreamWriter</b> is  convenient  in  that  you  can
       assign  it to encode for <b>sys.stdout</b> or <b>sys.stderr</b> and then have output automatically converted but it has
       the drawback of still being able to throw <b>UnicodeError</b> if the writer can't encode  all  possible  unicode
       codepoints.     Kitchen    provides    an    alternate    version    which    can   be   retrieved   with
       <u>kitchen.text.converters.getwriter()</u> which will not traceback in its standard configuration.

   <b>Unicode,</b> <b>str,</b> <b>and</b> <b>dict</b> <b>keys</b>
       The <b>hash()</b> of the <u>ASCII</u> characters is the same for <b>unicode</b> and byte <b>str</b>.  When you use them in <b>dict</b> keys,
       they evaluate to the same dictionary slot:

          &gt;&gt;&gt; u_string = u'a'
          &gt;&gt;&gt; b_string = 'a'
          &gt;&gt;&gt; hash(u_string), hash(b_string)
          (12416037344, 12416037344)
          &gt;&gt;&gt; d = {}
          &gt;&gt;&gt; d[u_string] = 'unicode'
          &gt;&gt;&gt; d[b_string] = 'bytes'
          &gt;&gt;&gt; d
          {u'a': 'bytes'}

       When you deal with key values outside of <u>ASCII</u>, <b>unicode</b> and byte <b>str</b> evaluate unequally  no  matter  what
       their character content or hash value:

          &gt;&gt;&gt; u_string = u'√±'
          &gt;&gt;&gt; b_string = u_string.encode('utf-8')
          &gt;&gt;&gt; print u_string
          √±
          &gt;&gt;&gt; print b_string
          √±
          &gt;&gt;&gt; d = {}
          &gt;&gt;&gt; d[u_string] = 'unicode'
          &gt;&gt;&gt; d[b_string] = 'bytes'
          &gt;&gt;&gt; d
          {u'\\xf1': 'unicode', '\\xc3\\xb1': 'bytes'}
          &gt;&gt;&gt; b_string2 = '\\xf1'
          &gt;&gt;&gt; hash(u_string), hash(b_string2)
          (30848092528, 30848092528)
          &gt;&gt;&gt; d = {}
          &gt;&gt;&gt; d[u_string] = 'unicode'
          &gt;&gt;&gt; d[b_string2] = 'bytes'
          {u'\\xf1': 'unicode', '\\xf1': 'bytes'}

       How  do you work with this one?  Remember rule #1:  Keep your <b>unicode</b> and byte <b>str</b> values separate.  That
       goes for keys in a dictionary just like anything else.

       ‚Ä¢ For any given dictionary, make sure that all your keys are either <b>unicode</b> or <b>str</b>.  <b>Do</b> <b>not</b> <b>mix</b> <b>the</b>  <b>two.</b>
         If  you're  being  given  both <b>unicode</b> and <b>str</b> but you don't need to preserve separate keys for each, I
         recommend using <u>to_unicode()</u> or <u>to_bytes()</u> to convert all keys to one type or the other like this:

            &gt;&gt;&gt; from kitchen.text.converters import to_unicode
            &gt;&gt;&gt; u_string = u'one'
            &gt;&gt;&gt; b_string = 'two'
            &gt;&gt;&gt; d = {}
            &gt;&gt;&gt; d[to_unicode(u_string)] = 1
            &gt;&gt;&gt; d[to_unicode(b_string)] = 2
            &gt;&gt;&gt; d
            {u'two': 2, u'one': 1}

       ‚Ä¢ These issues also apply to using dicts with tuple keys that contain a mixture of <b>unicode</b> and <b>str</b>.  Once
         again the best fix is to standardise on either <b>str</b> or <b>unicode</b>.

       ‚Ä¢ If you absolutely need to store values in a dictionary where the keys could be either  <b>unicode</b>  or  <b>str</b>
         you can use <u>StrictDict</u> which has separate entries for all <b>unicode</b> and byte <b>str</b> and deals correctly with
         any <b>tuple</b> containing mixed <b>unicode</b> and byte <b>str</b>.

   <b>Functions</b>
   <b>Unicode</b> <b>and</b> <b>byte</b> <b>str</b> <b>conversion</b>
       <b>kitchen.text.converters.to_unicode(obj,</b> <b>encoding='utf-8',</b> <b>errors='replace',</b> <b>nonstring=None,</b>
       <b>non_string=None)</b>
              Convert an object into a <b>str</b> string

              <b>Parameters</b>

                     ‚Ä¢ <b>obj</b> -- Object to convert to a <b>str</b> string.  This should normally be a byte <b>bytes</b>

                     ‚Ä¢ <b>encoding</b> -- What encoding to try converting the byte <b>bytes</b> as.  Defaults to <u>utf-8</u>

                     ‚Ä¢ <b>errors</b>  --  If errors are found while decoding, perform this action.  Defaults to <b>replace</b>
                       which replaces the invalid bytes with a character that means the bytes were unable to  be
                       decoded.   Other  values  are  the  same  as the error handling schemes in the <u>codec</u> <u>base</u>
                       <u>classes</u>.  For instance <b>strict</b> which raises an exception and <b>ignore</b> which simply omits the
                       non-decodable characters.

                     ‚Ä¢ <b>nonstring</b> --

                       How to treat nonstring values.  Possible values are:

                       <b>simplerepr</b>
                              Attempt to call the object's "simple representation" method and return that value.
                              Python-2.3+  has  two  methods  that  try  to  return  a  simple   representation:
                              <b>object.__unicode__()</b>  and  <b>object.__str__()</b>.   We  first try to get a usable value
                              from <b>object.__unicode__()</b>.  If that fails we try the same with <b>object.__str__()</b>.

                       <b>empty</b>  Return an empty <b>str</b> string

                       <b>strict</b> Raise a <b>TypeError</b>

                       <b>passthru</b>
                              Return the object unchanged

                       <b>repr</b>   Attempt to return a <b>str</b> string of the repr of the object

                       Default is <b>simplerepr</b>

                     ‚Ä¢ <b>non_string</b> -- <u>Deprecated</u> Use <b>nonstring</b> instead

              <b>Raises</b>

                     ‚Ä¢ <b>TypeError</b> -- if <b>nonstring</b> is <b>strict</b> and a  non-<b>basestring</b>  object  is  passed  in  or  if
                       <b>nonstring</b> is set to an unknown value

                     ‚Ä¢ <b>UnicodeDecodeError</b>  --  if  <b>errors</b>  is  <b>strict</b>  and  <b>obj</b> is not decodable using the given
                       encoding

              <b>Returns</b>
                     <b>str</b> string or the original object depending on the value of <b>nonstring</b>.

              Usually this should be used on a byte <b>bytes</b> but it can  take  both  byte  <b>bytes</b>  and  <b>str</b>  strings
              intelligently.   Nonstring  objects  are handled in different ways depending on the setting of the
              <b>nonstring</b> parameter.

              The default values of this function are set so as to always return a <b>str</b> string and never raise an
              error when converting from a byte <b>bytes</b> to a <b>str</b> string.  However, when you do  not  pass  validly
              encoded  text  (or a nonstring object), you may end up with output that you don't expect.  Be sure
              you understand the requirements of your data, not just ignore errors by passing  it  through  this
              function.

              Changed  in  version  0.2.1a2:  Deprecated  <b>non_string</b> in favor of <b>nonstring</b> parameter and changed
              default value to <b>simplerepr</b>

       <b>kitchen.text.converters.to_bytes(obj,</b> <b>encoding='utf-8',</b> <b>errors='replace',</b> <b>nonstring=None,</b>
       <b>non_string=None)</b>
              Convert an object into a byte <b>bytes</b>

              <b>Parameters</b>

                     ‚Ä¢ <b>obj</b> -- Object to convert to a byte <b>bytes</b>.  This should normally be a <b>str</b> string.

                     ‚Ä¢ <b>encoding</b> -- Encoding to use to convert the <b>str</b> string into a  byte  <b>bytes</b>.   Defaults  to
                       <u>utf-8</u>.

                     ‚Ä¢ <b>errors</b> --

                       If  errors  are  found  while  encoding,  perform this action.  Defaults to <b>replace</b> which
                       replaces the invalid bytes with a character that  means  the  bytes  were  unable  to  be
                       encoded.   Other  values  are  the  same  as the error handling schemes in the <u>codec</u> <u>base</u>
                       <u>classes</u>.  For instance <b>strict</b> which raises an exception and <b>ignore</b> which simply omits the
                       non-encodable characters.

                     ‚Ä¢ <b>nonstring</b> --

                       How to treat nonstring values.  Possible values are:

                       <b>simplerepr</b>
                              Attempt to call the object's "simple representation" method and return that value.
                              Python-2.3+  has  two  methods  that  try  to  return  a  simple   representation:
                              <b>object.__unicode__()</b>  and  <b>object.__str__()</b>.   We  first try to get a usable value
                              from <b>object.__str__()</b>.  If that fails we try the same with <b>object.__unicode__()</b>.

                       <b>empty</b>  Return an empty byte <b>bytes</b>

                       <b>strict</b> Raise a <b>TypeError</b>

                       <b>passthru</b>
                              Return the object unchanged

                       <b>repr</b>   Attempt to return a byte <b>bytes</b> of the <b>repr()</b> of the object

                       Default is <b>simplerepr</b>.

                     ‚Ä¢ <b>non_string</b> -- <u>Deprecated</u> Use <b>nonstring</b> instead.

              <b>Raises</b>

                     ‚Ä¢ <b>TypeError</b> -- if <b>nonstring</b> is <b>strict</b> and a  non-<b>basestring</b>  object  is  passed  in  or  if
                       <b>nonstring</b> is set to an unknown value.

                     ‚Ä¢ <b>UnicodeEncodeError</b>  --  if  <b>errors</b> is <b>strict</b> and all of the bytes of <b>obj</b> are unable to be
                       encoded using <b>encoding</b>.

              <b>Returns</b>
                     byte <b>bytes</b> or the original object depending on the value of <b>nonstring</b>.

              <b>WARNING:</b>
                 If you pass a byte <b>bytes</b> into this function the byte <b>bytes</b> is returned unmodified.  It  is  <b>not</b>
                 re-encoded with the specified <b>encoding</b>.  The easiest way to achieve that is:

                     to_bytes(to_unicode(text), encoding='utf-8')

                 The  initial  <u>to_unicode()</u>  call  will ensure text is a <b>str</b> string.  Then, <u>to_bytes()</u> will turn
                 that into a byte <b>bytes</b> with the specified encoding.

              Usually, this should be used on a <b>str</b> string but it can take either a byte <b>bytes</b> or a  <b>str</b>  string
              intelligently.   Nonstring  objects  are handled in different ways depending on the setting of the
              <b>nonstring</b> parameter.

              The default values of this function are set so as to always return a byte <b>bytes</b> and never raise an
              error when converting from unicode to bytes.  However, when you do not pass an encoding  that  can
              validly  encode  the  object  (or  a non-string object), you may end up with output that you don't
              expect.  Be sure you understand the requirements of your data, not just ignore errors  by  passing
              it through this function.

              Changed  in  version  0.2.1a2:  Deprecated  <b>non_string</b> in favor of <b>nonstring</b> parameter and changed
              default value to <b>simplerepr</b>

       <b>kitchen.text.converters.getwriter(encoding)</b>
              Return a <b>codecs.StreamWriter</b> that resists tracing back.

              <b>Parameters</b>
                     <b>encoding</b> -- Encoding to use for transforming <b>str</b> strings into byte <b>bytes</b>.

              <b>Return</b> <b>type</b>
                     <b>codecs.StreamWriter</b>

              <b>Returns</b>
                     <b>StreamWriter</b> that you can instantiate to wrap output streams to automatically translate <b>str</b>
                     strings into <b>encoding</b>.

              This is a reimplemetation of <b>codecs.getwriter()</b> that returns a <b>StreamWriter</b> that  resists  issuing
              tracebacks.   The <b>StreamWriter</b> that is returned uses <u>kitchen.text.converters.to_bytes()</u> to convert
              <b>str</b> strings into byte <b>bytes</b>.  The departures from <b>codecs.getwriter()</b> are:

              1. The <b>StreamWriter</b> that is returned will take byte <b>bytes</b> as well as <b>str</b> strings.  Any byte  <b>bytes</b>
                 will be passed through unmodified.

              2. The  default error handler for unknown bytes is to <b>replace</b> the bytes with the unknown character
                 (<b>?</b> in most ascii-based encodings, <b>ÔøΩ</b> in the utf encodings) whereas  <b>codecs.getwriter()</b>  defaults
                 to  <b>strict</b>.   Like  <b>codecs.StreamWriter</b>,  the  returned <b>StreamWriter</b> can have its error handler
                 changed in code by setting <b>stream.errors</b> <b>=</b> <b>'new_handler_name'</b>

              Example usage:

                 $ LC_ALL=C python
                 &gt;&gt;&gt; import sys
                 &gt;&gt;&gt; from kitchen.text.converters import getwriter
                 &gt;&gt;&gt; UTF8Writer = getwriter('utf-8')
                 &gt;&gt;&gt; unwrapped_stdout = sys.stdout
                 &gt;&gt;&gt; sys.stdout = UTF8Writer(unwrapped_stdout)
                 &gt;&gt;&gt; print 'caf\xc3\xa9'
                 caf√©
                 &gt;&gt;&gt; print u'caf\xe9'
                 caf√©
                 &gt;&gt;&gt; ASCIIWriter = getwriter('ascii')
                 &gt;&gt;&gt; sys.stdout = ASCIIWriter(unwrapped_stdout)
                 &gt;&gt;&gt; print 'caf\xc3\xa9'
                 caf√©
                 &gt;&gt;&gt; print u'caf\xe9'
                 caf?

              <b>SEE</b> <b>ALSO:</b>
                 API docs for <b>codecs.StreamWriter</b> and <b>codecs.getwriter()</b> and <u>Print</u> <u>Fails</u> on the python wiki.

              Added in version kitchen: 0.2a2, API: kitchen.text 1.1.0

       <b>kitchen.text.converters.to_str(obj)</b>
              <u>Deprecated</u>

              This function converts something to a byte <b>bytes</b> if it isn't one.  It's  used  to  call  <b>str()</b>  or
              <b>unicode()</b> on the object to get its simple representation without danger of getting a <b>UnicodeError</b>.
              You should be using <u>to_unicode()</u> or <u>to_bytes()</u> explicitly instead.

              If you need <b>str</b> strings:

                 to_unicode(obj, nonstring='simplerepr')

              If you need byte <b>bytes</b>:

                 to_bytes(obj, nonstring='simplerepr')

       <b>kitchen.text.converters.to_utf8(obj,</b> <b>errors='replace',</b> <b>non_string='passthru')</b>
              <u>Deprecated</u>

              Convert <b>str</b> to an encoded <u>utf-8</u> byte <b>bytes</b>.  You should be using <u>to_bytes()</u> instead:

                 to_bytes(obj, encoding='utf-8', non_string='passthru')

   <b>Transformation</b> <b>to</b> <b>XML</b>
       <b>kitchen.text.converters.unicode_to_xml(string,</b> <b>encoding='utf-8',</b> <b>attrib=False,</b> <b>control_chars='replace')</b>
              Take a <b>str</b> string and turn it into a byte <b>bytes</b> suitable for xml

              <b>Parameters</b>

                     ‚Ä¢ <b>string</b> -- <b>str</b> string to encode into an XML compatible byte <b>bytes</b>

                     ‚Ä¢ <b>encoding</b>  -- encoding to use for the returned byte <b>bytes</b>.  Default is to encode to <u>UTF-8</u>.
                       If some of the characters in <b>string</b> are not  encodable  in  this  encoding,  the  unknown
                       characters will be entered into the output string using xml character references.

                     ‚Ä¢ <b>attrib</b>  --  If  <b>True</b>,  quote the string for use in an xml attribute.  If <b>False</b> (default),
                       quote for use in an xml text field.

                     ‚Ä¢ <b>control_chars</b> --

                       <u>control</u> <u>characters</u> are not allowed in XML documents.  When we encounter those we need  to
                       know what to do.  Valid options are:

                       <b>replace</b>
                              (default) Replace the control characters with <b>?</b>

                       <b>ignore</b> Remove the characters altogether from the output

                       <b>strict</b> Raise an <u>XmlEncodeError</u>  when we encounter a <u>control</u> <u>character</u>

              <b>Raises</b>

                     ‚Ä¢ <u>kitchen.text.exceptions.XmlEncodeError</u>  --  If  <b>control_chars</b>  is  set  to <b>strict</b> and the
                       string to be made suitable for output to xml contains <u>control</u> <u>characters</u> or if <b>string</b>  is
                       not a <b>str</b> string then we raise this exception.

                     ‚Ä¢ <b>ValueError</b> -- If <b>control_chars</b> is set to something other than <b>replace</b>, <b>ignore</b>, or <b>strict</b>.

              <b>Return</b> <b>type</b>
                     byte <b>bytes</b>

              <b>Returns</b>
                     representation of the <b>str</b> string as a valid XML byte <b>bytes</b>

              XML  files  consist mainly of text encoded using a particular charset.  XML also denies the use of
              certain bytes in the encoded text (example: <b>ASCII</b> <b>Null</b>).  There are also special  characters  that
              must be escaped if they are present in the input (example: <b>&lt;</b>).  This function takes care of all of
              those issues for you.

              There  are  a  few  different  ways  to  use  this function depending on your needs.  The simplest
              invocation is like this:

                 unicode_to_xml(u'String with non-ASCII characters: &lt;"√° „Å®"&gt;')

              This will return the following to you, encoded in <u>utf-8</u>:

                 'String with non-ASCII characters: &amp;lt;"√° „Å®"&amp;gt;'

              Pretty straightforward.  Now, what if you need to encode your document  in  something  other  than
              <u>utf-8</u>?  For instance, <b>latin-1</b>?  Let's see:

                 unicode_to_xml(u'String with non-ASCII characters: &lt;"√° „Å®"&gt;', encoding='latin-1')
                 'String with non-ASCII characters: &amp;lt;"√° &amp;#12392;"&amp;gt;'

              Because  the <b>„Å®</b> character is not available in the <b>latin-1</b> charset, it is replaced with <b>&amp;#12392;</b> in
              our output.  This is an  xml  character  reference  which  represents  the  character  at  unicode
              codepoint <b>12392</b>, the <b>„Å®</b> character.

              When you want to reverse this, use <u>xml_to_unicode()</u> which will turn a byte <b>bytes</b> into a <b>str</b> string
              and replace the xml character references with the unicode characters.

              XML  also  has  the  quirk  of  not  allowing <u>control</u> <u>characters</u> in its output.  The <b>control_chars</b>
              parameter allows us to specify what to do with those.  For use  cases  that  don't  need  absolute
              character  by character fidelity (example: holding strings that will just be used for display in a
              GUI app later), the default value of <b>replace</b> works well:

                 unicode_to_xml(u'String with disallowed control chars: \u0000\u0007')
                 'String with disallowed control chars: ??'

              If you do need to be able to reproduce all of the characters at a later  date  (examples:  if  the
              string  is a key value in a database or a path on a filesystem) you have many choices.  Here are a
              few that rely on <b>utf-7</b>, a verbose encoding that encodes <u>control</u> <u>characters</u> (as well  as  non-<u>ASCII</u>
              unicode  values)  to  characters from within the <u>ASCII</u> printable characters.  The good thing about
              doing this is that the code is pretty simple.  You just need to use <b>utf-7</b> both when  encoding  the
              field for xml and when decoding it for use in your python program:

                 unicode_to_xml(u'String with unicode: „Å® and control char: ', encoding='utf7')
                 'String with unicode: +MGg and control char: +AAc-'
                 # [...]
                 xml_to_unicode('String with unicode: +MGg and control char: +AAc-', encoding='utf7')
                 u'String with unicode: „Å® and control char: '

              As  you  can see, the <b>utf-7</b> encoding will transform even characters that would be representable in
              <u>utf-8</u>.  This can be a drawback if you want unicode characters in the file to be  readable  without
              being decoded first.  You can work around this with increased complexity in your application code:

                 encoding = 'utf-8'
                 u_string = u'String with unicode: „Å® and control char: '
                 try:
                     # First attempt to encode to utf8
                     data = unicode_to_xml(u_string, encoding=encoding, errors='strict')
                 except XmlEncodeError:
                     # Fallback to utf-7
                     encoding = 'utf-7'
                     data = unicode_to_xml(u_string, encoding=encoding, errors='strict')
                 write_tag('&lt;mytag encoding=%s&gt;%s&lt;/mytag&gt;' % (encoding, data))
                 # [...]
                 encoding = tag.attributes.encoding
                 u_string = xml_to_unicode(u_string, encoding=encoding)

              Using  code  similar  to  that,  you  can have some fields encoded using your default encoding and
              fallback to <b>utf-7</b> if there are <u>control</u> <u>characters</u> present.

              <b>NOTE:</b>
                 If your goal is to preserve the <u>control</u> <u>characters</u> you cannot save the entire file as <b>utf-7</b> and
                 set the xml encoding parameter to <b>utf-7</b> if your goal is to  preserve  the  <u>control</u>  <u>characters</u>.
                 Because  XML  doesn't  allow  <u>control</u>  <u>characters</u>,  you  have to encode those separate from any
                 encoding work that the XML parser itself knows about.

              <b>SEE</b> <b>ALSO:</b>

                 <u>bytes_to_xml()</u>
                        if you're dealing with bytes that are non-text or of an unknown encoding that  you  must
                        preserve on a byte for byte level.

                 <u>guess_encoding_to_xml()</u>
                        if  you're  dealing  with  strings in unknown encodings that you don't need to save with
                        char-for-char fidelity.

       <b>kitchen.text.converters.xml_to_unicode(byte_string,</b> <b>encoding='utf-8',</b> <b>errors='replace')</b>
              Transform a byte <b>bytes</b> from an xml file into a <b>str</b> string

              <b>Parameters</b>

                     ‚Ä¢ <b>byte_string</b> -- byte <b>bytes</b> to decode

                     ‚Ä¢ <b>encoding</b> -- encoding that the byte <b>bytes</b> is in

                     ‚Ä¢ <b>errors</b> -- What to do if not every character is  valid in <b>encoding</b>.  See the  <u>to_unicode()</u>
                       documentation for legal values.

              <b>Return</b> <b>type</b>
                     <b>str</b> string

              <b>Returns</b>
                     string decoded from <b>byte_string</b>

              This  function  attempts to reverse what <u>unicode_to_xml()</u> does.  It takes a byte <b>bytes</b> (presumably
              read in from an xml file) and expands all the html entities into unicode  characters  and  decodes
              the  byte  <b>bytes</b> into a <b>str</b> string.  One thing it cannot do is restore any <u>control</u> <u>characters</u> that
              were removed prior to inserting into the file.  If you need to keep such characters  you  need  to
              use  <u>xml_to_bytes()</u>  and <u>bytes_to_xml()</u> or use on of the strategies documented in <u>unicode_to_xml()</u>
              instead.

       <b>kitchen.text.converters.byte_string_to_xml(byte_string,</b> <b>input_encoding='utf-8',</b> <b>errors='replace',</b>
       <b>output_encoding='utf-8',</b> <b>attrib=False,</b> <b>control_chars='replace')</b>
              Make sure a byte <b>bytes</b> is validly encoded for xml output

              <b>Parameters</b>

                     ‚Ä¢ <b>byte_string</b> -- Byte <b>bytes</b> to turn into valid xml output

                     ‚Ä¢ <b>input_encoding</b> -- Encoding of <b>byte_string</b>.  Default <b>utf-8</b>

                     ‚Ä¢ <b>errors</b> --

                       How to handle errors encountered while decoding the <b>byte_string</b> into <b>str</b> at the beginning
                       of the process.  Values are:

                       <b>replace</b>
                              (default) Replace the invalid bytes with a <b>?</b>

                       <b>ignore</b> Remove the characters altogether from the output

                       <b>strict</b> Raise an <b>UnicodeDecodeError</b> when we encounter a non-decodable character

                     ‚Ä¢ <b>output_encoding</b> -- Encoding for the xml file that this string will go into.   Default  is
                       <b>utf-8</b>.   If  all  the  characters  in <b>byte_string</b> are not encodable in this encoding, the
                       unknown characters will be entered into the output string using xml character references.

                     ‚Ä¢ <b>attrib</b> -- If <b>True</b>, quote the string for use in an xml  attribute.   If  <b>False</b>  (default),
                       quote for use in an xml text field.

                     ‚Ä¢ <b>control_chars</b> --

                       XML  does  not allow <u>control</u> <u>characters</u>.  When we encounter those we need to know what to
                       do.  Valid options are:

                       <b>replace</b>
                              (default) Replace the <u>control</u> <u>characters</u> with <b>?</b>

                       <b>ignore</b> Remove the characters altogether from the output

                       <b>strict</b> Raise an error when we encounter a <u>control</u> <u>character</u>

              <b>Raises</b>

                     ‚Ä¢ <u>XmlEncodeError</u> -- If <b>control_chars</b> is set to <b>strict</b> and the string to  be  made  suitable
                       for output to xml contains <u>control</u> <u>characters</u> then we raise this exception.

                     ‚Ä¢ <b>UnicodeDecodeError</b>  -- If errors is set to <b>strict</b> and the <b>byte_string</b> contains bytes that
                       are not decodable using <b>input_encoding</b>, this error is raised

              <b>Return</b> <b>type</b>
                     byte <b>bytes</b>

              <b>Returns</b>
                     representation of the byte <b>bytes</b>  in  the  output  encoding  with  any  bytes  that  aren't
                     available in xml taken care of.

              Use this when you have a byte <b>bytes</b> representing text that you need to make suitable for output to
              xml.  There are several cases where this is the case.  For instance, if you need to transform some
              strings encoded in <b>latin-1</b> to <u>utf-8</u> for output:

                 utf8_string = byte_string_to_xml(latin1_string, input_encoding='latin-1')

              If  you  already  have  strings  in the proper encoding you may still want to use this function to
              remove <u>control</u> <u>characters</u>:

                 cleaned_string = byte_string_to_xml(string, input_encoding='utf-8', output_encoding='utf-8')

              <b>SEE</b> <b>ALSO:</b>

                 <u>unicode_to_xml()</u>
                        for other ideas on using this function

       <b>kitchen.text.converters.xml_to_byte_string(byte_string,</b> <b>input_encoding='utf-8',</b> <b>errors='replace',</b>
       <b>output_encoding='utf-8')</b>
              Transform a byte <b>bytes</b> from an xml file into <b>str</b> string

              <b>Parameters</b>

                     ‚Ä¢ <b>byte_string</b> -- byte <b>bytes</b> to decode

                     ‚Ä¢ <b>input_encoding</b> -- encoding that the byte <b>bytes</b> is in

                     ‚Ä¢ <b>errors</b> -- What to do if not every character is valid in <b>encoding</b>.  See  the  <u>to_unicode()</u>
                       docstring for legal values.

                     ‚Ä¢ <b>output_encoding</b> -- Encoding for the output byte <b>bytes</b>

              <b>Returns</b>
                     <b>str</b> string decoded from <b>byte_string</b>

              This  function  attempts to reverse what <u>unicode_to_xml()</u> does.  It takes a byte <b>bytes</b> (presumably
              read in from an xml file) and expands all the html entities into unicode  characters  and  decodes
              the  byte  <b>bytes</b> into a <b>str</b> string.  One thing it cannot do is restore any <u>control</u> <u>characters</u> that
              were removed prior to inserting into the file.  If you need to keep such characters  you  need  to
              use  <u>xml_to_bytes()</u> and <u>bytes_to_xml()</u> or use one of the strategies documented in <u>unicode_to_xml()</u>
              instead.

       <b>kitchen.text.converters.bytes_to_xml(byte_string,</b> <b>*args,</b> <b>**kwargs)</b>
              Return a byte <b>bytes</b> encoded so it is valid inside of any xml file

              <b>Parameters</b>

                     ‚Ä¢ <b>byte_string</b> -- byte <b>bytes</b> to transform

                     ‚Ä¢ <b>**kwargs</b> (<u>*args,</u>) --

                       extra arguments to this function are passed on to the function actually implementing  the
                       encoding.  You can use this to tweak the output in some cases but, as a general rule, you
                       shouldn't because the underlying encoding function is not guaranteed to remain the same.

              <b>Return</b> <b>type</b>
                     byte <b>bytes</b> consisting of all <u>ASCII</u> characters

              <b>Returns</b>
                     byte <b>bytes</b> representation of the input.  This will be encoded using base64.

              This function is made especially to put binary information into xml documents.

              This  function  is intended for encoding things that must be preserved byte-for-byte.  If you want
              to encode a byte string that's text and don't mind losing the actual bytes you  probably  want  to
              try <u>byte_string_to_xml()</u> or <u>guess_encoding_to_xml()</u> instead.

              <b>NOTE:</b>
                 Although  the current implementation uses <b>base64.b64encode()</b> and there's no plans to change it,
                 that isn't guaranteed.  If you want to make sure that you can encode and decode these  messages
                 it's best to use <u>xml_to_bytes()</u> if you use this function to encode.

       <b>kitchen.text.converters.xml_to_bytes(byte_string,</b> <b>*args,</b> <b>**kwargs)</b>
              Decode a string encoded using <u>bytes_to_xml()</u>

              <b>Parameters</b>

                     ‚Ä¢ <b>byte_string</b>  --  byte  <b>bytes</b>  to  transform.  This should be a base64 encoded sequence of
                       bytes originally generated by <u>bytes_to_xml()</u>.

                     ‚Ä¢ <b>**kwargs</b> (<u>*args,</u>) --

                       extra arguments to this function are passed on to the function actually implementing  the
                       encoding.  You can use this to tweak the output in some cases but, as a general rule, you
                       shouldn't because the underlying encoding function is not guaranteed to remain the same.

              <b>Return</b> <b>type</b>
                     byte <b>bytes</b>

              <b>Returns</b>
                     byte <b>bytes</b> that's the decoded input

              If you've got fields in an xml document that were encoded with <u>bytes_to_xml()</u> then you want to use
              this function to undecode them.  It converts a base64 encoded string into a byte <b>bytes</b>.

              <b>NOTE:</b>
                 Although  the current implementation uses <b>base64.b64decode()</b> and there's no plans to change it,
                 that isn't guaranteed.  If you want to make sure that you can encode and decode these  messages
                 it's best to use <u>bytes_to_xml()</u> if you use this function to decode.

       <b>kitchen.text.converters.guess_encoding_to_xml(string,</b> <b>output_encoding='utf-8',</b> <b>attrib=False,</b>
       <b>control_chars='replace')</b>
              Return a byte <b>bytes</b> suitable for inclusion in xml

              <b>Parameters</b>

                     ‚Ä¢ <b>string</b> -- <b>str</b> or byte <b>bytes</b> to be transformed into a byte <b>bytes</b> suitable for inclusion in
                       xml.  If string is a byte <b>bytes</b> we attempt to guess the encoding.  If we cannot guess, we
                       fallback to <b>latin-1</b>.

                     ‚Ä¢ <b>output_encoding</b> -- Output encoding for the byte <b>bytes</b>.  This should match the encoding of
                       your xml file.

                     ‚Ä¢ <b>attrib</b>  --  If  <b>True</b>,  escape  the  item for use in an xml attribute.  If <b>False</b> (default)
                       escape the item for use in a text node.

              <b>Returns</b>
                     <u>utf-8</u> encoded byte <b>bytes</b>

       <b>kitchen.text.converters.to_xml(string,</b> <b>encoding='utf-8',</b> <b>attrib=False,</b> <b>control_chars='ignore')</b>
              <u>Deprecated</u>: Use <u>guess_encoding_to_xml()</u> instead

   <b>Working</b> <b>with</b> <b>exception</b> <b>messages</b>
       <b>kitchen.text.converters.EXCEPTION_CONVERTERS</b> <b>=</b> <b>(&lt;function</b> <b>&lt;lambda&gt;&gt;,</b> <b>&lt;function</b> <b>&lt;lambda&gt;&gt;)</b>

              <b>Tuple</b> <b>of</b> <b>functions</b> <b>to</b> <b>try</b> <b>to</b> <b>use</b> <b>to</b> <b>convert</b> <b>an</b> <b>exception</b> <b>into</b> <b>a</b> <b>string</b>
                     representation.  Its main use is to extract a string  (<b>str</b>  or  <b>bytes</b>)  from  an  exception
                     object in <u>exception_to_unicode()</u> and <u>exception_to_bytes()</u>.  The functions here will try the
                     exception's  <b>args[0]</b>  and  the  exception  itself (roughly equivalent to <u>str(exception)</u>) to
                     extract the message. This is only a default and can be easily overridden when calling those
                     functions.  There are several reasons you might wish to do that.  If  you  have  exceptions
                     where  the best string representing the exception is not returned by the default functions,
                     you can add another function to extract from a different field:

                        from kitchen.text.converters import (EXCEPTION_CONVERTERS,
                                exception_to_unicode)

                        class MyError(Exception):
                            def __init__(self, message):
                                self.value = message

                        c = [lambda e: e.value]
                        c.extend(EXCEPTION_CONVERTERS)
                        try:
                            raise MyError('An Exception message')
                        except MyError, e:
                            print exception_to_unicode(e, converters=c)

                     Another reason would be if you're converting to a byte <b>bytes</b> and you know the  <b>bytes</b>  needs
                     to be a non-<u>utf-8</u> encoding.  <u>exception_to_bytes()</u> defaults to <u>utf-8</u> but if you convert into
                     a byte <b>bytes</b> explicitly using a converter then you can choose a different encoding:

                        from kitchen.text.converters import (EXCEPTION_CONVERTERS,
                                exception_to_bytes, to_bytes)
                        c = [lambda e: to_bytes(e.args[0], encoding='euc_jp'),
                                lambda e: to_bytes(e, encoding='euc_jp')]
                        c.extend(EXCEPTION_CONVERTERS)
                        try:
                            do_something()
                        except Exception, e:
                            log = open('logfile.euc_jp', 'a')
                            log.write('%s

              <b>'</b> <b>%</b> <b>exception_to_bytes(e,</b> <b>converters=c)</b>
                        log.close()

                     Each  function  in  this  list  should take the exception as its sole argument and return a
                     string containing the message representing the exception.  The  functions  may  return  the
                     message  as a :byte class:<u>bytes</u>, a <b>str</b> string, or even an object if you trust the object to
                     return a decent string representation.  The <u>exception_to_unicode()</u> and <u>exception_to_bytes()</u>
                     functions will make sure to convert the string to the proper type before returning.

                     Added in version 0.2.2.

       <b>kitchen.text.converters.BYTE_EXCEPTION_CONVERTERS</b> <b>=</b> <b>(&lt;function</b> <b>&lt;lambda&gt;&gt;,</b> <b>&lt;function</b> <b>to_bytes&gt;)</b>
              <u>Deprecated</u>: Use <u>EXCEPTION_CONVERTERS</u> instead.

              Tuple of functions to try to use to convert an exception into a string representation.  This tuple
              is similar to the one in <u>EXCEPTION_CONVERTERS</u> but it's  used  with  <u>exception_to_bytes()</u>  instead.
              Ideally,  these  functions should do their best to return the data as a byte <b>bytes</b> but the results
              will be run through <u>to_bytes()</u> before being returned.

              Added in version 0.2.2.

              Changed in version 1.0.1: Deprecated as simplifications allow <u>EXCEPTION_CONVERTERS</u> to perform  the
              same function.

       <b>kitchen.text.converters.exception_to_unicode(exc,</b> <b>converters=(&lt;function</b> <b>&lt;lambda&gt;&gt;,</b> <b>&lt;function</b> <b>&lt;lambda&gt;&gt;))</b>
              Convert an exception object into a unicode representation

              <b>Parameters</b>

                     ‚Ä¢ <b>exc</b> -- Exception object to convert

                     ‚Ä¢ <b>converters</b>  --  List  of  functions  to  use to convert the exception into a string.  See
                       <u>EXCEPTION_CONVERTERS</u> for the default value and an example of adding other  converters  to
                       the  defaults.   The  functions  in  the  list are tried one at a time to see if they can
                       extract a string from the exception.  The first one to do so without raising an exception
                       is used.

              <b>Returns</b>
                     <b>str</b> string representation of the exception.  The value extracted by the <b>converters</b> will  be
                     converted into <b>str</b> before being returned using the <u>utf-8</u> encoding.  If you know you need to
                     use  an  alternate  encoding  add  a  function  that  does that to the list of functions in
                     <b>converters</b>)

              Added in version 0.2.2.

       <b>kitchen.text.converters.exception_to_bytes(exc,</b> <b>converters=(&lt;function</b> <b>&lt;lambda&gt;&gt;,</b> <b>&lt;function</b> <b>&lt;lambda&gt;&gt;))</b>
              Convert an exception object into a str representation

              <b>Parameters</b>

                     ‚Ä¢ <b>exc</b> -- Exception object to convert

                     ‚Ä¢ <b>converters</b> -- List of functions to use to convert  the  exception  into  a  string.   See
                       <u>EXCEPTION_CONVERTERS</u>  for  the default value and an example of adding other converters to
                       the defaults.  The functions in the list are tried one at a  time  to  see  if  they  can
                       extract a string from the exception.  The first one to do so without raising an exception
                       is used.

              <b>Returns</b>
                     byte  <b>bytes</b> representation of the exception.  The value extracted by the <b>converters</b> will be
                     converted into <b>bytes</b> before being returned using the <u>utf-8</u> encoding.  If you know you  need
                     to  use  an  alternate  encoding  add a function that does that to the list of functions in
                     <b>converters</b>)

              Added in version 0.2.2.

              Changed in version 1.0.1: Code simplification allowed us to switch to  using  <u>EXCEPTION_CONVERTERS</u>
              as the default value of <b>converters</b>.

   <b>Format</b> <b>Text</b> <b>for</b> <b>Display</b>
       Functions  related  to  displaying  unicode text.  Unicode characters don't all have the same width so we
       need helper functions for displaying them.

       Added in version 0.2: kitchen.display API 1.0.0

       <b>kitchen.text.display.textual_width(msg,</b> <b>control_chars='guess',</b> <b>encoding='utf-8',</b> <b>errors='replace')</b>
              Get the <u>textual</u> <u>width</u> of a string

              <b>Parameters</b>

                     ‚Ä¢ <b>msg</b> -- <b>str</b> string or byte <b>bytes</b> to get the width of

                     ‚Ä¢ <b>control_chars</b> --

                       specify how to deal with <u>control</u> <u>characters</u>.  Possible values are:

                       <b>guess</b>  (default) will take a guess for <u>control</u> <u>character</u> widths.  Most codes will  return
                              zero  width.   <b>backspace</b>,  <b>delete</b>,  and  <b>clear</b> <b>delete</b> return -1.  <b>escape</b> currently
                              returns -1 as well but this is not guaranteed as it's not always correct

                       <b>strict</b> will raise <u>kitchen.text.exceptions.ControlCharError</u>  if  a  <u>control</u>  <u>character</u>  is
                              encountered

                     ‚Ä¢ <b>encoding</b>  -- If we are given a byte <b>bytes</b> this is used to decode it into <b>str</b> string.  Any
                       characters that are not decodable in this encoding will get  a  value  dependent  on  the
                       <b>errors</b> parameter.

                     ‚Ä¢ <b>errors</b>  --  How  to treat errors encoding the byte <b>bytes</b> to <b>str</b> string.  Legal values are
                       the same as for <u>kitchen.text.converters.to_unicode()</u>.  The default value of <b>replace</b>  will
                       cause  undecodable  byte  sequences  to  have a width of one. <b>ignore</b> will have a width of
                       zero.

              <b>Raises</b> <u>ControlCharError</u> -- if <b>msg</b> contains a <u>control</u> <u>character</u> and <b>control_chars</b> is <b>strict</b>.

              <b>Returns</b>
                     <u>Textual</u> <u>width</u> of the <b>msg</b>.  This is the amount of space that the string will  consume  on  a
                     monospace  display.   It's measured in the number of cell positions or columns it will take
                     up on a monospace display.  This is <b>not</b> the number of glyphs that are in the string.

              <b>NOTE:</b>
                 This function can be wrong sometimes because Unicode does not specify a strict width value  for
                 all  of the <u>code</u> <u>points</u>.  In particular, we've found that some Tamil characters take up to four
                 character cells but we return a lesser amount.

       <b>kitchen.text.display.textual_width_chop(msg,</b> <b>chop,</b> <b>encoding='utf-8',</b> <b>errors='replace')</b>
              Given a string, return it chopped to a given <u>textual</u> <u>width</u>

              <b>Parameters</b>

                     ‚Ä¢ <b>msg</b> -- <b>str</b> string or byte <b>bytes</b> to chop

                     ‚Ä¢ <b>chop</b> -- Chop <b>msg</b> if it exceeds this <u>textual</u> <u>width</u>

                     ‚Ä¢ <b>encoding</b> -- If we are given a byte <b>bytes</b>, this is used to decode it into  a  <b>str</b>  string.
                       Any characters that are not decodable in this encoding will be assigned a width of one.

                     ‚Ä¢ <b>errors</b>  -- How to treat errors encoding the byte <b>bytes</b> to <b>str</b>.  Legal values are the same
                       as for <u>kitchen.text.converters.to_unicode()</u>

              <b>Return</b> <b>type</b>
                     <b>str</b> string

              <b>Returns</b>
                     <b>str</b> string of the <b>msg</b> chopped at the given <u>textual</u> <u>width</u>

              This is what you want to use instead of <b>%.*s</b>, as it does the "right" thing with  regard  to  <u>UTF-8</u>
              sequences, <u>control</u> <u>characters</u>, and characters that take more than one cell position. Eg:

                 &gt;&gt;&gt; # Wrong: only displays 8 characters because it is operating on bytes
                 &gt;&gt;&gt; print "%.*s" % (10, 'caf√© √±unru!')
                 caf√© √±un
                 &gt;&gt;&gt; # Properly operates on graphemes
                 &gt;&gt;&gt; '%s' % (textual_width_chop('caf√© √±unru!', 10))
                 caf√© √±unru
                 &gt;&gt;&gt; # takes too many columns because the kanji need two cell positions
                 &gt;&gt;&gt; print '1234567890\n%.*s' % (10, u'‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ')
                 1234567890
                 ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ
                 &gt;&gt;&gt; # Properly chops at 10 columns
                 &gt;&gt;&gt; print '1234567890\n%s' % (textual_width_chop(u'‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ', 10))
                 1234567890
                 ‰∏Ä‰∫å‰∏âÂõõ‰∫î

       <b>kitchen.text.display.textual_width_fill(msg,</b> <b>fill,</b> <b>chop=None,</b> <b>left=True,</b> <b>prefix='',</b> <b>suffix='')</b>
              Expand a <b>str</b> string to a specified <u>textual</u> <u>width</u> or chop to same

              <b>Parameters</b>

                     ‚Ä¢ <b>msg</b> -- <b>str</b> string to format

                     ‚Ä¢ <b>fill</b> -- pad string until the <u>textual</u> <u>width</u> of the string is this length

                     ‚Ä¢ <b>chop</b>  -- before doing anything else, chop the string to this length.  Default: Don't chop
                       the string at all

                     ‚Ä¢ <b>left</b> -- If <b>True</b> (default) left justify the string and put the padding on the  right.   If
                       <b>False</b>, pad on the left side.

                     ‚Ä¢ <b>prefix</b> -- Attach this string before the field we're filling

                     ‚Ä¢ <b>suffix</b> -- Append this string to the end of the field we're filling

              <b>Return</b> <b>type</b>
                     <b>str</b> string

              <b>Returns</b>
                     <b>msg</b>  formatted  to  fill  the  specified  width.  If no <b>chop</b> is specified, the string could
                     exceed the fill length when completed.  If <b>prefix</b> or <b>suffix</b> are printable  characters,  the
                     string could be longer than the fill width.

              <b>NOTE:</b>
                 <b>prefix</b>  and  <b>suffix</b> should be used for "invisible" characters like highlighting, color changing
                 escape codes, etc.  The fill characters are appended outside of any <b>prefix</b> or <b>suffix</b>  elements.
                 This allows you to only highlight <b>msg</b> inside of the field you're filling.

              <b>WARNING:</b>
                 <b>msg</b>,  <b>prefix</b>, and <b>suffix</b> should all be representable as unicode characters.  In particular, any
                 escape sequences in <b>prefix</b> and <b>suffix</b> need to be convertible to <b>str</b>.  If you need to  use  byte
                 sequences here rather than unicode characters, use <u>byte_string_textual_width_fill()</u> instead.

              This  function  expands a string to fill a field of a particular <u>textual</u> <u>width</u>.  Use it instead of
              <b>%*.*s</b>, as it does the "right" thing with  regard  to  <u>UTF-8</u>  sequences,  <u>control</u>  <u>characters</u>,  and
              characters that take more than one cell position in a display.  Example usage:

                 &gt;&gt;&gt; msg = u'‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ'
                 &gt;&gt;&gt; # Wrong: This uses 10 characters instead of 10 cells:
                 &gt;&gt;&gt; u":%-*.*s:" % (10, 10, msg[:9])
                 :‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πù :
                 &gt;&gt;&gt; # This uses 10 cells like we really want:
                 &gt;&gt;&gt; u":%s:" % (textual_width_fill(msg[:9], 10, 10))
                 :‰∏Ä‰∫å‰∏âÂõõ‰∫î:

                 &gt;&gt;&gt; # Wrong: Right aligned in the field, but too many cells
                 &gt;&gt;&gt; u"%20.10s" % (msg)
                           ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ
                 &gt;&gt;&gt; # Correct: Right aligned with proper number of cells
                 &gt;&gt;&gt; u"%s" % (textual_width_fill(msg, 20, 10, left=False))
                           ‰∏Ä‰∫å‰∏âÂõõ‰∫î

                 &gt;&gt;&gt; # Wrong: Adding some escape characters to highlight the line but too many cells
                 &gt;&gt;&gt; u"%s%20.10s%s" % (prefix, msg, suffix)
                 u'[7m          ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ[0m'
                 &gt;&gt;&gt; # Correct highlight of the line
                 &gt;&gt;&gt; u"%s%s%s" % (prefix, display.textual_width_fill(msg, 20, 10, left=False), suffix)
                 u'[7m          ‰∏Ä‰∫å‰∏âÂõõ‰∫î[0m'

                 &gt;&gt;&gt; # Correct way to not highlight the fill
                 &gt;&gt;&gt; u"%s" % (display.textual_width_fill(msg, 20, 10, left=False, prefix=prefix, suffix=suffix))
                 u'          [7m‰∏Ä‰∫å‰∏âÂõõ‰∫î[0m'

       <b>kitchen.text.display.wrap(text,</b> <b>width=70,</b> <b>initial_indent='',</b> <b>subsequent_indent='',</b> <b>encoding='utf-8',</b>
       <b>errors='replace')</b>
              Works like we want <b>textwrap.wrap()</b> to work,

              <b>Parameters</b>

                     ‚Ä¢ <b>text</b> -- <b>str</b> string or byte <b>bytes</b> to wrap

                     ‚Ä¢ <b>width</b> -- <u>textual</u> <u>width</u> at which to wrap.  Default: 70

                     ‚Ä¢ <b>initial_indent</b> -- string to use to indent the first line.  Default: do not indent.

                     ‚Ä¢ <b>subsequent_indent</b> -- string to use to wrap subsequent lines.  Default: do not indent

                     ‚Ä¢ <b>encoding</b> -- Encoding to use if <b>text</b> is a byte <b>bytes</b>

                     ‚Ä¢ <b>errors</b>  --  error  handler  to  use if <b>text</b> is a byte <b>bytes</b> and contains some undecodable
                       characters.

              <b>Return</b> <b>type</b>
                     <b>list</b> of <b>str</b> strings

              <b>Returns</b>
                     list of lines that have been text wrapped and indented.

              <b>textwrap.wrap()</b> from the <u>python</u> <u>standard</u> <u>library</u> has two drawbacks that this attempts to fix:

              1. It does not handle <u>textual</u> <u>width</u>.  It only operates on  bytes  or  characters  which  are  both
                 inadequate (due to multi-byte and double width characters).

              2. It malforms lists and blocks.

       <b>kitchen.text.display.fill(text,</b> <b>*args,</b> <b>**kwargs)</b>
              Works like we want <b>textwrap.fill()</b> to work

              <b>Parameters</b>
                     <b>text</b> -- <b>str</b> string or byte <b>bytes</b> to process

              <b>Returns</b>
                     <b>str</b> string with each line separated by a newline

              <b>SEE</b> <b>ALSO:</b>

                 <u>kitchen.text.display.wrap()</u>
                        for other parameters that you can give this command.

              This  function is a light wrapper around <u>kitchen.text.display.wrap()</u>.  Where that function returns
              a <b>list</b> of lines, this function returns one string with each line separated by a newline.

       <b>kitchen.text.display.byte_string_textual_width_fill(msg,</b> <b>fill,</b> <b>chop=None,</b> <b>left=True,</b> <b>prefix='',</b>
       <b>suffix='',</b> <b>encoding='utf-8',</b> <b>errors='replace')</b>
              Expand a byte <b>bytes</b> to a specified <u>textual</u> <u>width</u> or chop to same

              <b>Parameters</b>

                     ‚Ä¢ <b>msg</b> -- byte <b>bytes</b> encoded in <u>UTF-8</u> that we want formatted

                     ‚Ä¢ <b>fill</b> -- pad <b>msg</b> until the <u>textual</u> <u>width</u> is this long

                     ‚Ä¢ <b>chop</b> -- before doing anything else, chop the string to this length.  Default: Don't  chop
                       the string at all

                     ‚Ä¢ <b>left</b>  --  If <b>True</b> (default) left justify the string and put the padding on the right.  If
                       <b>False</b>, pad on the left side.

                     ‚Ä¢ <b>prefix</b> -- Attach this byte <b>bytes</b> before the field we're filling

                     ‚Ä¢ <b>suffix</b> -- Append this byte <b>bytes</b> to the end of the field we're filling

              <b>Return</b> <b>type</b>
                     byte <b>bytes</b>

              <b>Returns</b>
                     <b>msg</b> formatted to fill the specified <u>textual</u> <u>width</u>.  If no <b>chop</b>  is  specified,  the  string
                     could exceed the fill length when completed.  If <b>prefix</b> or <b>suffix</b> are printable characters,
                     the string could be longer than fill width.

              <b>NOTE:</b>
                 <b>prefix</b>  and  <b>suffix</b> should be used for "invisible" characters like highlighting, color changing
                 escape codes, etc.  The fill characters are appended outside of any <b>prefix</b> or <b>suffix</b>  elements.
                 This allows you to only highlight <b>msg</b> inside of the field you're filling.

              <b>SEE</b> <b>ALSO:</b>

                 <u>textual_width_fill()</u>
                        For example usage.  This function has only two differences.

                        1. it  takes  byte <b>bytes</b> for <b>prefix</b> and <b>suffix</b> so you can pass in arbitrary sequences of
                           bytes, not just unicode characters.

                        2. it returns a byte <b>bytes</b> instead of a <b>str</b> string.

   <b>Internal</b> <b>Data</b>
       There are a few internal functions and variables in this module.  Code outside of kitchen  shouldn't  use
       them but people coding on kitchen itself may find them useful.

       <b>kitchen.text.display._COMBINING</b> <b>=</b> <b>((768,</b> <b>879),</b> <b>(1155,</b> <b>1161),</b> <b>(1425,</b> <b>1469),</b> <b>(1471,</b> <b>1471),</b> <b>(1473,</b> <b>1474),</b>
       <b>(1476,</b> <b>1477),</b> <b>(1479,</b> <b>1479),</b> <b>(1536,</b> <b>1539),</b> <b>(1552,</b> <b>1562),</b> <b>(1611,</b> <b>1631),</b> <b>(1648,</b> <b>1648),</b> <b>(1750,</b> <b>1764),</b> <b>(1767,</b>
       <b>1768),</b> <b>(1770,</b> <b>1773),</b> <b>(1807,</b> <b>1807),</b> <b>(1809,</b> <b>1809),</b> <b>(1840,</b> <b>1866),</b> <b>(1958,</b> <b>1968),</b> <b>(2027,</b> <b>2035),</b> <b>(2045,</b> <b>2045),</b>
       <b>(2070,</b> <b>2073),</b> <b>(2075,</b> <b>2083),</b> <b>(2085,</b> <b>2087),</b> <b>(2089,</b> <b>2093),</b> <b>(2137,</b> <b>2139),</b> <b>(2259,</b> <b>2273),</b> <b>(2275,</b> <b>2303),</b> <b>(2305,</b>
       <b>2306),</b> <b>(2364,</b> <b>2364),</b> <b>(2369,</b> <b>2376),</b> <b>(2381,</b> <b>2381),</b> <b>(2385,</b> <b>2388),</b> <b>(2402,</b> <b>2403),</b> <b>(2433,</b> <b>2433),</b> <b>(2492,</b> <b>2492),</b>
       <b>(2497,</b> <b>2500),</b> <b>(2509,</b> <b>2509),</b> <b>(2530,</b> <b>2531),</b> <b>(2558,</b> <b>2558),</b> <b>(2561,</b> <b>2562),</b> <b>(2620,</b> <b>2620),</b> <b>(2625,</b> <b>2626),</b> <b>(2631,</b>
       <b>2632),</b> <b>(2635,</b> <b>2637),</b> <b>(2672,</b> <b>2673),</b> <b>(2689,</b> <b>2690),</b> <b>(2748,</b> <b>2748),</b> <b>(2753,</b> <b>2757),</b> <b>(2759,</b> <b>2760),</b> <b>(2765,</b> <b>2765),</b>
       <b>(2786,</b> <b>2787),</b> <b>(2817,</b> <b>2817),</b> <b>(2876,</b> <b>2876),</b> <b>(2879,</b> <b>2879),</b> <b>(2881,</b> <b>2883),</b> <b>(2893,</b> <b>2893),</b> <b>(2902,</b> <b>2902),</b> <b>(2946,</b>
       <b>2946),</b> <b>(3008,</b> <b>3008),</b> <b>(3021,</b> <b>3021),</b> <b>(3134,</b> <b>3136),</b> <b>(3142,</b> <b>3144),</b> <b>(3146,</b> <b>3149),</b> <b>(3157,</b> <b>3158),</b> <b>(3260,</b> <b>3260),</b>
       <b>(3263,</b> <b>3263),</b> <b>(3270,</b> <b>3270),</b> <b>(3276,</b> <b>3277),</b> <b>(3298,</b> <b>3299),</b> <b>(3387,</b> <b>3388),</b> <b>(3393,</b> <b>3395),</b> <b>(3405,</b> <b>3405),</b> <b>(3530,</b>
       <b>3530),</b> <b>(3538,</b> <b>3540),</b> <b>(3542,</b> <b>3542),</b> <b>(3633,</b> <b>3633),</b> <b>(3636,</b> <b>3642),</b> <b>(3655,</b> <b>3662),</b> <b>(3761,</b> <b>3761),</b> <b>(3764,</b> <b>3772),</b>
       <b>(3784,</b> <b>3789),</b> <b>(3864,</b> <b>3865),</b> <b>(3893,</b> <b>3893),</b> <b>(3895,</b> <b>3895),</b> <b>(3897,</b> <b>3897),</b> <b>(3953,</b> <b>3966),</b> <b>(3968,</b> <b>3972),</b> <b>(3974,</b>
       <b>3975),</b> <b>(3984,</b> <b>3991),</b> <b>(3993,</b> <b>4028),</b> <b>(4038,</b> <b>4038),</b> <b>(4141,</b> <b>4144),</b> <b>(4146,</b> <b>4146),</b> <b>(4150,</b> <b>4151),</b> <b>(4153,</b> <b>4154),</b>
       <b>(4184,</b> <b>4185),</b> <b>(4237,</b> <b>4237),</b> <b>(4448,</b> <b>4607),</b> <b>(4957,</b> <b>4959),</b> <b>(5906,</b> <b>5908),</b> <b>(5938,</b> <b>5940),</b> <b>(5970,</b> <b>5971),</b> <b>(6002,</b>
       <b>6003),</b> <b>(6068,</b> <b>6069),</b> <b>(6071,</b> <b>6077),</b> <b>(6086,</b> <b>6086),</b> <b>(6089,</b> <b>6099),</b> <b>(6109,</b> <b>6109),</b> <b>(6155,</b> <b>6157),</b> <b>(6313,</b> <b>6313),</b>
       <b>(6432,</b> <b>6434),</b> <b>(6439,</b> <b>6440),</b> <b>(6450,</b> <b>6450),</b> <b>(6457,</b> <b>6459),</b> <b>(6679,</b> <b>6680),</b> <b>(6752,</b> <b>6752),</b> <b>(6773,</b> <b>6780),</b> <b>(6783,</b>
       <b>6783),</b> <b>(6832,</b> <b>6845),</b> <b>(6912,</b> <b>6915),</b> <b>(6964,</b> <b>6964),</b> <b>(6966,</b> <b>6970),</b> <b>(6972,</b> <b>6972),</b> <b>(6978,</b> <b>6978),</b> <b>(6980,</b> <b>6980),</b>
       <b>(7019,</b> <b>7027),</b> <b>(7082,</b> <b>7083),</b> <b>(7142,</b> <b>7142),</b> <b>(7154,</b> <b>7155),</b> <b>(7223,</b> <b>7223),</b> <b>(7376,</b> <b>7378),</b> <b>(7380,</b> <b>7392),</b> <b>(7394,</b>
       <b>7400),</b> <b>(7405,</b> <b>7405),</b> <b>(7412,</b> <b>7412),</b> <b>(7416,</b> <b>7417),</b> <b>(7616,</b> <b>7673),</b> <b>(7675,</b> <b>7679),</b> <b>(8203,</b> <b>8207),</b> <b>(8234,</b> <b>8238),</b>
       <b>(8288,</b> <b>8291),</b> <b>(8298,</b> <b>8303),</b> <b>(8400,</b> <b>8432),</b> <b>(11503,</b> <b>11505),</b> <b>(11647,</b> <b>11647),</b> <b>(11744,</b> <b>11775),</b> <b>(12330,</b> <b>12335),</b>
       <b>(12441,</b> <b>12442),</b> <b>(42607,</b> <b>42607),</b> <b>(42612,</b> <b>42621),</b> <b>(42654,</b> <b>42655),</b> <b>(42736,</b> <b>42737),</b> <b>(43014,</b> <b>43014),</b> <b>(43019,</b>
       <b>43019),</b> <b>(43045,</b> <b>43046),</b> <b>(43204,</b> <b>43204),</b> <b>(43232,</b> <b>43249),</b> <b>(43307,</b> <b>43309),</b> <b>(43347,</b> <b>43347),</b> <b>(43443,</b> <b>43443),</b>
       <b>(43456,</b> <b>43456),</b> <b>(43696,</b> <b>43696),</b> <b>(43698,</b> <b>43700),</b> <b>(43703,</b> <b>43704),</b> <b>(43710,</b> <b>43711),</b> <b>(43713,</b> <b>43713),</b> <b>(43766,</b>
       <b>43766),</b> <b>(44013,</b> <b>44013),</b> <b>(64286,</b> <b>64286),</b> <b>(65024,</b> <b>65039),</b> <b>(65056,</b> <b>65071),</b> <b>(65279,</b> <b>65279),</b> <b>(65529,</b> <b>65531),</b>
       <b>(66045,</b> <b>66045),</b> <b>(66272,</b> <b>66272),</b> <b>(66422,</b> <b>66426),</b> <b>(68097,</b> <b>68099),</b> <b>(68101,</b> <b>68102),</b> <b>(68108,</b> <b>68111),</b> <b>(68152,</b>
       <b>68154),</b> <b>(68159,</b> <b>68159),</b> <b>(68325,</b> <b>68326),</b> <b>(68900,</b> <b>68903),</b> <b>(69446,</b> <b>69456),</b> <b>(69702,</b> <b>69702),</b> <b>(69759,</b> <b>69759),</b>
       <b>(69817,</b> <b>69818),</b> <b>(69888,</b> <b>69890),</b> <b>(69939,</b> <b>69940),</b> <b>(70003,</b> <b>70003),</b> <b>(70080,</b> <b>70080),</b> <b>(70090,</b> <b>70090),</b> <b>(70197,</b>
       <b>70198),</b> <b>(70377,</b> <b>70378),</b> <b>(70459,</b> <b>70460),</b> <b>(70477,</b> <b>70477),</b> <b>(70502,</b> <b>70508),</b> <b>(70512,</b> <b>70516),</b> <b>(70722,</b> <b>70722),</b>
       <b>(70726,</b> <b>70726),</b> <b>(70750,</b> <b>70750),</b> <b>(70850,</b> <b>70851),</b> <b>(71103,</b> <b>71104),</b> <b>(71231,</b> <b>71231),</b> <b>(71350,</b> <b>71351),</b> <b>(71467,</b>
       <b>71467),</b> <b>(71737,</b> <b>71738),</b> <b>(72160,</b> <b>72160),</b> <b>(72244,</b> <b>72244),</b> <b>(72263,</b> <b>72263),</b> <b>(72345,</b> <b>72345),</b> <b>(72767,</b> <b>72767),</b>
       <b>(73026,</b> <b>73026),</b> <b>(73028,</b> <b>73029),</b> <b>(73111,</b> <b>73111),</b> <b>(92912,</b> <b>92916),</b> <b>(92976,</b> <b>92982),</b> <b>(113822,</b> <b>113822),</b>
       <b>(119141,</b> <b>119145),</b> <b>(119149,</b> <b>119170),</b> <b>(119173,</b> <b>119179),</b> <b>(119210,</b> <b>119213),</b> <b>(119362,</b> <b>119364),</b> <b>(122880,</b>
       <b>122886),</b> <b>(122888,</b> <b>122904),</b> <b>(122907,</b> <b>122913),</b> <b>(122915,</b> <b>122916),</b> <b>(122918,</b> <b>122922),</b> <b>(123184,</b> <b>123190),</b>
       <b>(123628,</b> <b>123631),</b> <b>(125136,</b> <b>125142),</b> <b>(125252,</b> <b>125258),</b> <b>(917505,</b> <b>917505),</b> <b>(917536,</b> <b>917631),</b> <b>(917760,</b>
       <b>917999))</b>
              Internal  table,  provided  by this module to list <u>code</u> <u>points</u> which combine with other characters
              and therefore should have no <u>textual</u> <u>width</u>.  This is a sorted <b>tuple</b> of non-overlapping  intervals.
              Each  interval  is  a <b>tuple</b> listing a starting <u>code</u> <u>point</u> and ending <u>code</u> <u>point</u>.  Every <u>code</u> <u>point</u>
              between the two end points is a combining character.

              <b>SEE</b> <b>ALSO:</b>

                 <b>_</b><u>generate_combining_table()</u>
                        for how this table is generated

              This table was last regenerated on python-3.8.0a3 with <b>unicodedata.unidata_version</b> 12.0.0

       <b>kitchen.text.display._generate_combining_table()</b>
              Combine Markus Kuhn's data with <b>unicodedata</b> to make combining char list

              <b>Return</b> <b>type</b>
                     <b>tuple</b> of tuples

              <b>Returns</b>
                     <b>tuple</b> of intervals of <u>code</u> <u>points</u> that are combining character.  Each interval is a 2-<b>tuple</b>
                     of the starting <u>code</u> <u>point</u> and the ending <u>code</u> <u>point</u> for the combining characters.

              In normal use, this function serves to tell how we're generating the  combining  char  list.   For
              speed reasons, we use this to generate a static list and just use that later.

              Markus  Kuhn's list of combining characters is more complete than what's in the python <b>unicodedata</b>
              library but the python <b>unicodedata</b> is synced against later versions of the unicode database

              This is used to generate the <b>_</b><u>COMBINING</u> table.

       <b>kitchen.text.display._print_combining_table()</b>
              Print out a new <b>_</b><u>COMBINING</u> table

              This will print a new <b>_</b><u>COMBINING</u> table in the format used in <b>kitchen/text/display.py</b>.  It's useful
              for updating the <b>_</b><u>COMBINING</u> table with updated data from a new python as the format  won't  change
              from what's already in the file.

       <b>kitchen.text.display._interval_bisearch(value,</b> <b>table)</b>
              Binary search in an interval table.

              <b>Parameters</b>

                     ‚Ä¢ <b>value</b> -- numeric value to search for

                     ‚Ä¢ <b>table</b>  --  Ordered list of intervals.  This is a list of two-tuples.  The elements of the
                       two-tuple define an interval's start and end points.

              <b>Returns</b>
                     If <b>value</b> is found within an interval in the <b>table</b> return <b>True</b>.  Otherwise, <b>False</b>

              This function checks whether a numeric value is present within a table of  intervals.   It  checks
              using  a  binary  search  algorithm,  dividing the list of values in half and checking against the
              values until it determines whether the value is in the table.

       <b>kitchen.text.display._ucp_width(ucs,</b> <b>control_chars='guess')</b>
              Get the <u>textual</u> <u>width</u> of a ucs character

              <b>Parameters</b>

                     ‚Ä¢ <b>ucs</b> -- integer representing a single unicode <u>code</u> <u>point</u>

                     ‚Ä¢ <b>control_chars</b> --

                       specify how to deal with <u>control</u> <u>characters</u>.  Possible values are:

                       <b>guess</b>  (default) will take a guess for <u>control</u> <u>character</u> widths.  Most codes will  return
                              zero  width.   <b>backspace</b>,  <b>delete</b>,  and  <b>clear</b> <b>delete</b> return -1.  <b>escape</b> currently
                              returns -1 as well but this is not guaranteed as it's not always correct

                       <b>strict</b> will raise <u>ControlCharError</u> if a <u>control</u> <u>character</u> is encountered

              <b>Raises</b> <u>ControlCharError</u> -- if the <u>code</u> <u>point</u> is a unicode <u>control</u> <u>character</u> and  <b>control_chars</b>  is
                     set to 'strict'

              <b>Returns</b>
                     <u>textual</u> <u>width</u> of the character.

              <b>NOTE:</b>
                 It's important to remember this is <u>textual</u> <u>width</u> and not the number of characters or bytes.

       <b>kitchen.text.display._textual_width_le(width,</b> <b>*args)</b>
              Optimize the common case when deciding which <u>textual</u> <u>width</u> is larger

              <b>Parameters</b>

                     ‚Ä¢ <b>width</b> -- <u>textual</u> <u>width</u> to compare against.

                     ‚Ä¢ <b>*args</b> -- <b>str</b> strings to check the total <u>textual</u> <u>width</u> of

              <b>Returns</b>
                     <b>True</b> if the total length of <b>args</b> are less than or equal to <b>width</b>.  Otherwise <b>False</b>.

              We  often  want  to  know "does X fit in Y".  It takes a while to use <u>textual_width()</u> to calculate
              this.  However, we know that the number of canonically composed <b>str</b> characters is always going  to
              have 1 or 2 for the <u>textual</u> <u>width</u> per character.  With this we can take the following shortcuts:

              1. If  the  number  of  canonically composed characters is more than width, the true <u>textual</u> <u>width</u>
                 cannot be less than width.

              2. If the number of canonically composed characters * 2 is less than the width  then  the  <u>textual</u>
                 <u>width</u> must be ok.

              <u>textual</u> <u>width</u> of a canonically composed <b>str</b> string will always be greater than or equal to the the
              number  of <b>str</b> characters.  So we can first check if the number of composed <b>str</b> characters is less
              than the asked for width.  If it is we can return <b>True</b> immediately.  If not, then  we  must  do  a
              full <u>textual</u> <u>width</u> lookup.

   <b>Miscellaneous</b> <b>functions</b> <b>for</b> <b>manipulating</b> <b>text</b>
       Collection of text functions that don't fit in another category.

       Changed  in  version  kitchen:  1.2.0,  API: kitchen.text 2.2.0 Added <u>isbasestring()</u>, <u>isbytestring()</u>, and
       <u>isunicodestring()</u> to help tell which string type is which on python2 and python3

       <b>kitchen.text.misc.byte_string_valid_encoding(byte_string,</b> <b>encoding='utf-8')</b>
              Detect if a byte <b>bytes</b> is valid in a specific encoding

              <b>Parameters</b>

                     ‚Ä¢ <b>byte_string</b> -- Byte <b>bytes</b> to test for bytes not valid in this encoding

                     ‚Ä¢ <b>encoding</b> -- encoding to test against.  Defaults to <u>UTF-8</u>.

              <b>Returns</b>
                     <b>True</b> if there are no invalid <u>UTF-8</u> characters.  <b>False</b> if an invalid character is detected.

              <b>NOTE:</b>
                 This function checks whether the byte <b>bytes</b> is valid in the specified encoding.   It  <b>does</b>  <b>not</b>
                 detect  whether the byte <b>bytes</b> actually was encoded in that encoding.  If you want that sort of
                 functionality, you probably want to use <u>guess_encoding()</u> instead.

       <b>kitchen.text.misc.byte_string_valid_xml(byte_string,</b> <b>encoding='utf-8')</b>
              Check that a byte <b>bytes</b> would be valid in xml

              <b>Parameters</b>

                     ‚Ä¢ <b>byte_string</b> -- Byte <b>bytes</b> to check

                     ‚Ä¢ <b>encoding</b> -- Encoding of the xml file.  Default: <u>UTF-8</u>

              <b>Returns</b>
                     <b>True</b> if the string is valid.  <b>False</b> if it would be invalid in the xml file

              In some cases you'll have a whole bunch of byte strings and rather than transforming them  to  <b>str</b>
              and  back  to byte <b>bytes</b> for output to xml, you will just want to make sure they work with the xml
              file you're constructing.  This function will help you do that.  Example:

                 ARRAY_OF_MOSTLY_UTF8_STRINGS = [...]
                 processed_array = []
                 for string in ARRAY_OF_MOSTLY_UTF8_STRINGS:
                     if byte_string_valid_xml(string, 'utf-8'):
                         processed_array.append(string)
                     else:
                         processed_array.append(guess_bytes_to_xml(string, encoding='utf-8'))
                 output_xml(processed_array)

       <b>kitchen.text.misc.guess_encoding(byte_string,</b> <b>disable_chardet=False)</b>
              Try to guess the encoding of a byte <b>bytes</b>

              <b>Parameters</b>

                     ‚Ä¢ <b>byte_string</b> -- byte <b>bytes</b> to guess the encoding of

                     ‚Ä¢ <b>disable_chardet</b> -- If this is True,  we  never  attempt  to  use  <b>chardet</b>  to  guess  the
                       encoding.   This  is  useful  if  you  need  to  have  reproducibility whether <b>chardet</b> is
                       installed or not.  Default: <b>False</b>.

              <b>Raises</b> <b>TypeError</b> -- if <b>byte_string</b> is not a byte <b>bytes</b> type

              <b>Returns</b>
                     string containing a guess at the encoding of <b>byte_string</b>.  This is appropriate to  pass  as
                     the encoding argument when encoding and decoding unicode strings.

              We start by attempting to decode the byte <b>bytes</b> as <u>UTF-8</u>.  If this succeeds we tell the world it's
              <u>UTF-8</u>  text.   If  it  doesn't and <b>chardet</b> is installed on the system and <b>disable_chardet</b> is False
              this function will use it to try detecting the encoding of <b>byte_string</b>.  If it is not installed or
              <b>chardet</b> cannot determine the encoding with a high enough confidence  then  we  rather  arbitrarily
              claim  that  it is <b>latin-1</b>.  Since <b>latin-1</b> will encode to every byte, decoding from <b>latin-1</b> to <b>str</b>
              will not cause <b>UnicodeErrors</b> although the output might be mangled.

       <b>kitchen.text.misc.html_entities_unescape(string)</b>
              Substitute unicode characters for HTML entities

              <b>Parameters</b>
                     <b>string</b> -- <b>str</b> string to substitute out html entities

              <b>Raises</b> <b>TypeError</b> -- if something other than a <b>str</b> string is given

              <b>Return</b> <b>type</b>
                     <b>str</b> string

              <b>Returns</b>
                     The plain text without html entities

       <b>kitchen.text.misc.isbasestring(obj)</b>
              Determine if obj is a byte <b>bytes</b> or <b>str</b> string

              In python2 this is eqiuvalent to isinstance(obj, basestring).  In python3 it  checks  whether  the
              object  is an instance of str, bytes, or bytearray.  This is an aid to porting code that needed to
              test whether an object was derived from basestring in  python2  (commonly  used  in  unicode-bytes
              conversion functions)

              <b>Parameters</b>
                     <b>obj</b> -- Object to test

              <b>Returns</b>
                     True if the object is a <b>basestring</b>.  Otherwise False.

              Added in version Kitchen:: 1.2.0, API kitchen.text 2.2.0

       <b>kitchen.text.misc.isbytestring(obj)</b>
              Determine if obj is a byte <b>bytes</b>

              In python2 this is equivalent to isinstance(obj, str).  In python3 it checks whether the object is
              an instance of bytes or bytearray.

              <b>Parameters</b>
                     <b>obj</b> -- Object to test

              <b>Returns</b>
                     True if the object is a byte <b>bytes</b>.  Otherwise, False.

              Added in version Kitchen:: 1.2.0, API kitchen.text 2.2.0

       <b>kitchen.text.misc.isunicodestring(obj)</b>
              Determine if obj is a <b>str</b> string

              In  python2  this  is  equivalent  to  isinstance(obj, unicode).  In python3 it checks whether the
              object is an instance of <b>bytes</b>.

              <b>Parameters</b>
                     <b>obj</b> -- Object to test

              <b>Returns</b>
                     True if the object is a <b>str</b> string.  Otherwise, False.

              Added in version Kitchen:: 1.2.0, API kitchen.text 2.2.0

       <b>kitchen.text.misc.process_control_chars(string,</b> <b>strategy='replace')</b>
              Look for and transform <u>control</u> <u>characters</u> in a string

              <b>Parameters</b>

                     ‚Ä¢ <b>string</b> -- string to search for and transform <u>control</u> <u>characters</u> within

                     ‚Ä¢ <b>strategy</b> --

                       XML does not allow <u>ASCII</u> <u>control</u> <u>characters</u>.  When we encounter those  we  need  to  know
                       what to do.  Valid options are:

                       <b>replace</b>
                              (default) Replace the <u>control</u> <u>characters</u> with <b>"?"</b>

                       <b>ignore</b> Remove the characters altogether from the output

                       <b>strict</b> Raise a <u>ControlCharError</u> when we encounter a control character

              <b>Raises</b>

                     ‚Ä¢ <b>TypeError</b> -- if <b>string</b> is not a unicode string.

                     ‚Ä¢ <b>ValueError</b> -- if the strategy is not one of replace, ignore, or strict.

                     ‚Ä¢ <u>kitchen.text.exceptions.ControlCharError</u>  --  if  the  strategy  is  <b>strict</b> and a <u>control</u>
                       <u>character</u> is present in the <b>string</b>

              <b>Returns</b>
                     <b>str</b> string with no <u>control</u> <u>characters</u> in it.

              Changed in version kitchen: 1.2.0, API: kitchen.text 2.2.0 Strip out the C1 control characters  in
              addition to the C0 control characters.

       <b>kitchen.text.misc.str_eq(str1,</b> <b>str2,</b> <b>encoding='utf-8',</b> <b>errors='replace')</b>
              Compare two strings, converting to byte <b>bytes</b> if one is <b>str</b>

              <b>Parameters</b>

                     ‚Ä¢ <b>str1</b> -- First string to compare

                     ‚Ä¢ <b>str2</b> -- Second string to compare

                     ‚Ä¢ <b>encoding</b>  --  If we need to convert one string into a byte <b>bytes</b> to compare, the encoding
                       to use.  Default is <u>utf-8</u>.

                     ‚Ä¢ <b>errors</b> -- What to  do  if  we  encounter  errors  when  encoding  the  string.   See  the
                       <u>kitchen.text.converters.to_bytes()</u>  documentation  for  possible  values.  The default is
                       <b>replace</b>.

              This function prevents <b>UnicodeError</b> (python-2.4  or  less)  and  <b>UnicodeWarning</b>  (python  2.5  and
              higher)  when  we  compare  a  <b>str</b>  string to a byte <b>bytes</b>.  The errors normally arise because the
              conversion is done to <u>ASCII</u>.  This function lets you convert to <u>utf-8</u> or another encoding instead.

              <b>NOTE:</b>
                 When we need to convert one of the strings from <b>str</b> in order to compare them we convert the <b>str</b>
                 string into a byte <b>bytes</b>.  That means that strings can compare differently if you use different
                 encodings for each.

              Note that <b>str1</b> <b>==</b> <b>str2</b> is faster than this function if you can accept the following limitations:

              ‚Ä¢ Limited to python-2.5+ (otherwise a <b>UnicodeDecodeError</b> may be thrown)

              ‚Ä¢ Will generate a <b>UnicodeWarning</b> if non-<u>ASCII</u> byte <b>bytes</b> is compared to <b>str</b> string.

   <b>UTF-8</b>
       Functions for operating on byte <b>bytes</b> encoded as <u>UTF-8</u>

       <b>NOTE:</b>
          In many cases, it is better to convert to <b>str</b>, operate on the strings, then  convert  back  to  <u>UTF-8</u>.
          <b>str</b>  type  can  handle  many  of  these functions itself.  For those that it doesn't (removing control
          characters from length calculations, for instance) the code to do so with a <b>str</b> type is often simpler.

       <b>WARNING:</b>
          All of the functions in this module are deprecated.  Most of them have been  replaced  with  functions
          that  operate  on  unicode  values  in  <u>kitchen.text.display</u>.  <u>kitchen.text.utf8.utf8_valid()</u> has been
          replaced with a function in <u>kitchen.text.misc</u>.

       <b>kitchen.text.utf8.utf8_text_fill(text,</b> <b>*args,</b> <b>**kwargs)</b>
              <b>Deprecated</b> Similar  to  <b>textwrap.fill()</b>  but  understands  <u>utf-8</u>  strings  and  doesn't  screw  up
              lists/blocks/etc.

              Use <u>kitchen.text.display.fill()</u> instead.

       <b>kitchen.text.utf8.utf8_text_wrap(text,</b> <b>width=70,</b> <b>initial_indent='',</b> <b>subsequent_indent='')</b>
              <b>Deprecated</b>   Similar   to  <b>textwrap.wrap()</b>  but  understands  <u>utf-8</u>  data  and  doesn't  screw  up
              lists/blocks/etc

              Use <u>kitchen.text.display.wrap()</u> instead

       <b><a href="../manmsg/kitchen.text.utf8.utf8_valid.msg.html">kitchen.text.utf8.utf8_valid</a>(msg)</b>
              <b>Deprecated</b> Detect if a string is valid <u>utf-8</u>

              Use <u>kitchen.text.misc.byte_string_valid_encoding()</u> instead.

       <b><a href="../manmsg/kitchen.text.utf8.utf8_width.msg.html">kitchen.text.utf8.utf8_width</a>(msg)</b>
              <b>Deprecated</b> Get the <u>textual</u> <u>width</u> of a <u>utf-8</u> string

              Use <u>kitchen.text.display.textual_width()</u> instead.

       <b>kitchen.text.utf8.utf8_width_chop(msg,</b> <b>chop=None)</b>
              <b>Deprecated</b> Return a string chopped to a given <u>textual</u> <u>width</u>

              Use <u>textual_width_chop()</u> and <u>textual_width()</u> instead:

                 &gt;&gt;&gt; msg = '„Åè ku „Çâ ra „Å® to „Åø mi'
                 &gt;&gt;&gt; # Old way:
                 &gt;&gt;&gt; utf8_width_chop(msg, 5)
                 (5, '„Åè ku')
                 &gt;&gt;&gt; # New way
                 &gt;&gt;&gt; from kitchen.text.converters import to_bytes
                 &gt;&gt;&gt; from kitchen.text.display import textual_width, textual_width_chop
                 &gt;&gt;&gt; (<a href="../manmsg/textual_width.msg.html">textual_width</a>(msg), to_bytes(textual_width_chop(msg, 5)))
                 (5, '„Åè ku')

       <b>kitchen.text.utf8.utf8_width_fill(msg,</b> <b>fill,</b> <b>chop=None,</b> <b>left=True,</b> <b>prefix='',</b> <b>suffix='')</b>
              <b>Deprecated</b> Pad a <u>utf-8</u> string to fill a specified width

              Use <u>byte_string_textual_width_fill()</u> instead

       <u>converters</u>
              deals with converting text for different encodings and to and from XML

       <u>display</u>
              deals with issues with printing text to a screen

       <u>misc</u>   is a catchall for text manipulation functions that don't seem to fit elsewhere

       <u>utf8</u>   contains deprecated functions to manipulate utf8 byte strings

   <b>Kitchen.collections</b>
   <b>StrictDict</b>
       <b>kitchen.collections.StrictDict</b> provides a dictionary that treats <b>bytes</b> and <b>str</b> as distinct key values.

       <b>kitchen.collections.strictdict.StrictDict</b>
              alias of <b>defaultdict</b>

   <b>Kitchen.iterutils</b> <b>Module</b>
       Functions to manipulate iterables

       Added in version Kitchen:: 0.2.1a1

       <u>Module</u> <u>author:</u> <u>Toshio</u> <u>Kuratomi</u> <u>&lt;<a href="mailto:toshio@fedoraproject.org">toshio@fedoraproject.org</a>&gt;</u>

       <u>Module</u> <u>author:</u> <u>Luke</u> <u>Macken</u> <u>&lt;<a href="mailto:lmacken@redhat.com">lmacken@redhat.com</a>&gt;</u>

       <b>kitchen.iterutils.isiterable(obj,</b> <b>include_string=False)</b>
              Check whether an object is an iterable

              <b>Parameters</b>

                     ‚Ä¢ <b>obj</b> -- Object to test whether it is an iterable

                     ‚Ä¢ <b>include_string</b> -- If <b>True</b> and <b>obj</b> is a byte <b>bytes</b> or <b>str</b> string this function will return
                       <b>True</b>.  If set to <b>False</b>, byte <b>bytes</b> and <b>str</b> strings will cause  this  function  to  return
                       <b>False</b>.  Default <b>False</b>.

              <b>Returns</b>
                     <b>True</b> if <b>obj</b> is iterable, otherwise <b>False</b>.

       <b>kitchen.iterutils.iterate(obj,</b> <b>include_string=False)</b>
              Generator that can be used to iterate over anything

              <b>Parameters</b>

                     ‚Ä¢ <b>obj</b> -- The object to iterate over

                     ‚Ä¢ <b>include_string</b>  -- if <b>True</b>, treat strings as iterables.  Otherwise treat them as a single
                       scalar value.  Default <b>False</b>

              This function will create an iterator out of any scalar or iterable.  It is useful  for  making  a
              value  given  to  you  an  iterable  before operating on it.  Iterables have their items returned.
              scalars are transformed into iterables.  A  string  is  treated  as  a  scalar  value  unless  the
              <b>include_string</b> parameter is set to <b>True</b>.  Example usage:

                 &gt;&gt;&gt; list(iterate(None))
                 [None]
                 &gt;&gt;&gt; list(iterate([None]))
                 [None]
                 &gt;&gt;&gt; list(iterate([1, 2, 3]))
                 [1, 2, 3]
                 &gt;&gt;&gt; list(iterate(set([1, 2, 3])))
                 [1, 2, 3]
                 &gt;&gt;&gt; list(iterate(dict(a='1', b='2')))
                 ['a', 'b']
                 &gt;&gt;&gt; list(<a href="../man1/iterate.1.html">iterate</a>(1))
                 [1]
                 &gt;&gt;&gt; list(iterate(iter([1, 2, 3])))
                 [1, 2, 3]
                 &gt;&gt;&gt; list(iterate('abc'))
                 ['abc']
                 &gt;&gt;&gt; list(iterate('abc', include_string=True))
                 ['a', 'b', 'c']

   <b>Helpers</b> <b>for</b> <b>versioning</b> <b>software</b>
   <b>PEP-386</b> <b>compliant</b> <b>versioning</b>
       <u>PEP</u>  <u>386</u>  defines  a  standard  format for version strings.  This module contains a function for creating
       strings in that format.

       <b>kitchen.versioning.version_tuple_to_string(version_info)</b>
              Return a <u>PEP</u> <u>386</u> version string from a <u>PEP</u> <u>386</u> style version tuple

              <b>Parameters</b>
                     <b>version_info</b> -- Nested set of tuples that describes the version.  See below for an example.

              <b>Returns</b>
                     a version string

              This function implements just enough of <u>PEP</u> <u>386</u> to satisfy our needs.  <u>PEP</u> <u>386</u> defines a  standard
              format  for  version strings and refers to a function that will be merged into the <u>python</u> <u>standard</u>
              <u>library</u> that transforms a tuple of version information  into  a  standard  version  string.   This
              function  is  an  implementation  of that function.  Once that function becomes available in the ‚Äê
              <u>python</u> <u>standard</u> <u>library</u> we will start using it and deprecate this function.

              <b>version_info</b> takes the form that <u>PEP</u> <u>386</u>'s <b>NormalizedVersion.from_parts()</b> uses:

                 ((Major, Minor, [Micros]), [(Alpha/Beta/rc marker, version)],
                     [(post/dev marker, version)])

                 Ex: ((1, 0, 0), ('a', 2), ('dev', 3456))

              It generates a <u>PEP</u> <u>386</u> compliant version string:

                 N.N[.N]+[{a|b|c|rc}N[.N]+][.postN][.devN]

                 Ex: 1.0.0a2.dev3456

              <b>WARNING:</b>
                 This function does next to no error checking.  It's up to the person defining the version tuple
                 to make sure that the values make sense.  If the <u>PEP</u> <u>386</u> compliant version parser  doesn't  get
                 released  soon  we'll  look  at  making  this function check that the version tuple makes sense
                 before transforming it into a string.

              It's recommended that you use this function to  keep  a  <b>__version_info__</b>  tuple  and  <b>__version__</b>
              string in your modules.  Why do we need both a tuple and a string?  The string is often useful for
              putting  into  human  readable  locations like release announcements, version strings in tarballs,
              etc.  Meanwhile the tuple is very easy for a computer to compare. For example, kitchen sets up its
              version information like this:

                 from kitchen.versioning import version_tuple_to_string
                 __version_info__ = ((0, 2, 1),)
                 __version__ = version_tuple_to_string(__version_info__)

              Other programs that depend on a kitchen version between 0.2.1  and  0.3.0  can  find  whether  the
              present version is okay with code like this:

                 from kitchen import __version_info__, __version__
                 if __version_info__ &lt; ((0, 2, 1),) or __version_info__ &gt;= ((0, 3, 0),):
                     print 'kitchen is present but not at the right version.'
                     print 'We need at least version 0.2.1 and less than 0.3.0'
                     print 'Currently found: kitchen-%s' % __version__

   <b>Exceptions</b>
       Kitchen  has  a  hierarchy of exceptions that should make it easy to catch many errors emitted by kitchen
       itself.

   <b>Base</b> <b>kitchen</b> <b>exceptions</b>
       Exception classes for kitchen and the root of the exception hierarchy for all kitchen modules.

       <b>exception</b> <b>kitchen.exceptions.KitchenError</b>
              Base exception class for any error thrown directly by kitchen.

   <b>Kitchen.text</b> <b>exceptions</b>
       Exception classes thrown by kitchen's text processing routines.

       <b>exception</b> <b>kitchen.text.exceptions.ControlCharError</b>
              Exception thrown when an ascii control character is encountered.

       <b>exception</b> <b>kitchen.text.exceptions.XmlEncodeError</b>
              Exception thrown by error conditions when encoding an xml string.

   <b>1.0.0</b> <b>Porting</b> <b>Guide</b>
       The 0.1 through 1.0.0 releases focused on bringing in functions from yum and python-fedora.  This porting
       guide tells how to port from those APIs to their kitchen replacements.

   <b>python-fedora</b>
                       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                       ‚îÇ python-fedora                 ‚îÇ kitchen replacement                  ‚îÇ
                       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                       ‚îÇ <b>fedora.iterutils.isiterable()</b> ‚îÇ <u>kitchen.iterutils.isiterable()</u> [1]   ‚îÇ
                       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                       ‚îÇ <b>fedora.textutils.to_unicode()</b> ‚îÇ <u>kitchen.text.converters.to_unicode()</u> ‚îÇ
                       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                       ‚îÇ <b>fedora.textutils.to_bytes()</b>   ‚îÇ <u>kitchen.text.converters.to_bytes()</u>   ‚îÇ
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

       [1]  <u>isiterable()</u> has changed slightly in kitchen.  The <b>include_string</b> attribute has switched its default
            value from <b>True</b> to <b>False</b>.  So you need to change code like:

          &gt;&gt;&gt; # Old code
          &gt;&gt;&gt; isiterable('abcdef')
          True
          &gt;&gt;&gt; # New code
          &gt;&gt;&gt; isiterable('abcdef', include_string=True)
          True

   <b>yum</b>
                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                   ‚îÇ yum                         ‚îÇ kitchen replacement                            ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.dummy_wrapper()</b>    ‚îÇ <b>kitchen.i18n.DummyTranslations.ugettext()</b>      ‚îÇ
                   ‚îÇ                             ‚îÇ [2]                                            ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.dummyP_wrapper()</b>   ‚îÇ <b>kitchen.i18n.DummyTanslations.ungettext()</b>      ‚îÇ
                   ‚îÇ                             ‚îÇ [2]                                            ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.utf8_width()</b>       ‚îÇ <u>kitchen.text.display.textual_width()</u>           ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.utf8_width_chop()</b>  ‚îÇ <u>kitchen.text.display.textual_width_chop()</u>      ‚îÇ
                   ‚îÇ                             ‚îÇ and  <u>kitchen.text.display.textual_width()</u>      ‚îÇ
                   ‚îÇ                             ‚îÇ [3] [5]                                        ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.utf8_valid()</b>       ‚îÇ <u>kitchen.text.misc.byte_string_valid_encoding()</u> ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.utf8_text_wrap()</b>   ‚îÇ <u>kitchen.text.display.wrap()</u> [4]                ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.utf8_text_fill()</b>   ‚îÇ <u>kitchen.text.display.fill()</u> [4]                ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.to_unicode()</b>       ‚îÇ <u>kitchen.text.converters.to_unicode()</u> [6]       ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.to_unicode_maybe()</b> ‚îÇ <u>kitchen.text.converters.to_unicode()</u> [6]       ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.to_utf8()</b>          ‚îÇ <u>kitchen.text.converters.to_bytes()</u> [6]         ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.to_str()</b>           ‚îÇ <u>kitchen.text.converters.to_unicode()</u>        or ‚îÇ
                   ‚îÇ                             ‚îÇ <u>kitchen.text.converters.to_bytes()</u> [7]         ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.str_eq()</b>           ‚îÇ <u>kitchen.text.misc.str_eq()</u>                     ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.misc.to_xml()</b>           ‚îÇ <u>kitchen.text.converters.unicode_to_xml()</u>    or ‚îÇ
                   ‚îÇ                             ‚îÇ <u>kitchen.text.converters.byte_string_to_xml()</u>   ‚îÇ
                   ‚îÇ                             ‚îÇ [8]                                            ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n._()</b>                ‚îÇ See: <u>Initializing</u> <u>Yum</u> <u>i18n</u>                     ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.P_()</b>               ‚îÇ See: <u>Initializing</u> <u>Yum</u> <u>i18n</u>                     ‚îÇ
                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                   ‚îÇ <b>yum.i18n.exception2msg()</b>    ‚îÇ <u>kitchen.text.converters.exception_to_unicode()</u> ‚îÇ
                   ‚îÇ                             ‚îÇ or <b>kitchen.text.converter.exception_to_bytes()</b> ‚îÇ
                   ‚îÇ                             ‚îÇ [9]                                            ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

       [2]  These  yum methods provided fallback support for <b>gettext</b> functions in case either <b>gaftonmode</b> was set
            or <b>gettext</b> failed to return an object.  In kitchen, we can  use  the  <u>kitchen.i18n.DummyTranslations</u>
            object  to  fulfill  that  role.  Please see <u>Initializing</u> <u>Yum</u> <u>i18n</u> for more suggestions on how to do
            this.

       [3]  The yum version of these functions returned a byte <b>str</b>.  The kitchen version listed here  returns  a
            <b>unicode</b>  string.   If  you  need  a  byte  <b>str</b> simply call <u>kitchen.text.converters.to_bytes()</u> on the
            result.

       [4]  The yum version of these functions would return either a byte <b>str</b> or a <b>unicode</b> string  depending  on
            what the input value was.  The kitchen version always returns <b>unicode</b> strings.

       [5]  <b>yum.i18n.utf8_width_chop()</b>  performed  two functions.  It returned the piece of the message that fit
            in a specified width and the width of that message.  In kitchen, you need to call two functions, one
            for each action:

          &gt;&gt;&gt; # Old way
          &gt;&gt;&gt; utf8_width_chop(msg, 5)
          (5, '„Åè ku')
          &gt;&gt;&gt; # New way
          &gt;&gt;&gt; from kitchen.text.display import textual_width, textual_width_chop
          &gt;&gt;&gt; (<a href="../manmsg/textual_width.msg.html">textual_width</a>(msg), textual_width_chop(msg, 5))
          (5, u'„Åè ku')

       [6]  If the yum version of <b>to_unicode()</b> or <b>to_utf8()</b> is given an object that is not a string, it  returns
            the  object  itself.   <u>kitchen.text.converters.to_unicode()</u>  and  <u>kitchen.text.converters.to_bytes()</u>
            default to returning the <b>simplerepr</b> of the object instead.  If you want the yum behaviour,  set  the
            <b>nonstring</b> parameter to <b>passthru</b>:

          &gt;&gt;&gt; from kitchen.text.converters import to_unicode
          &gt;&gt;&gt; <a href="../man5/to_unicode.5.html">to_unicode</a>(5)
          u'5'
          &gt;&gt;&gt; to_unicode(5, nonstring='passthru')
          5

       [7]  <b>yum.i18n.to_str()</b>  could  return  either a byte <b>str</b>.  or a <b>unicode</b> string In kitchen you can get the
            same effect but you get to choose whether you want a byte <b>str</b> or a <b>unicode</b> string.   Use  <u>to_bytes()</u>
            for <b>str</b> and <u>to_unicode()</u> for <b>unicode</b>.

       [8]  <b>yum.misc.to_xml()</b> was buggy as written.  I think the intention was for you to be able to pass a byte
            <b>str</b>  or  <b>unicode</b>  string  in  and  get out a byte <b>str</b> that was valid to use in an xml file.  The two
            kitchen functions <u>byte_string_to_xml()</u> and <u>unicode_to_xml()</u> do that for each string type.

       [9]  When porting <b>yum.i18n.exception2msg()</b> to use kitchen, you should setup two wrapper functions to  aid
            in your port.  They'll look like this:

          from kitchen.text.converters import EXCEPTION_CONVERTERS, \
              BYTE_EXCEPTION_CONVERTERS, exception_to_unicode, \
              exception_to_bytes
          def exception2umsg(e):
              '''Return a unicode representation of an exception'''
              c = [lambda e: e.value]
              c.extend(EXCEPTION_CONVERTERS)
              return exception_to_unicode(e, converters=c)
          def exception2bmsg(e):
              '''Return a utf8 encoded str representation of an exception'''
              c = [lambda e: e.value]
              c.extend(BYTE_EXCEPTION_CONVERTERS)
              return exception_to_bytes(e, converters=c)

       The  reason  to  define  this  wrapper is that many of the exceptions in yum put the message in the <b>value</b>
       attribute  of  the  <b>Exception</b>  instead  of  adding  it  to  the   <b>args</b>   attribute.    So   the   default
       <u>EXCEPTION_CONVERTERS</u>  don't know where to find the message.  The wrapper tells kitchen to check the <b>value</b>
       attribute  for  the  message.    The   reason   to   define   two   wrappers   may   be   less   obvious.
       <b>yum.i18n.exception2msg()</b>  can  return  a  <b>unicode</b> string or a byte <b>str</b> depending on a combination of what
       attributes are present on the <b>Exception</b> and what locale the function  is  being  run  in.   By  contrast,
       <u>kitchen.text.converters.exception_to_unicode()</u>       only      returns      <b>unicode</b>      strings      and
       <u>kitchen.text.converters.exception_to_bytes()</u> only returns byte <b>str</b>.  This is much safer as it keeps  code
       that  can only handle <b>unicode</b> or only handle byte <b>str</b> correctly from getting the wrong type when an input
       changes but it means you need to examine the calling code when porting from <b>yum.i18n.exception2msg()</b>  and
       use the appropriate wrapper.

   <b>Initializing</b> <b>Yum</b> <b>i18n</b>
       Previously, yum had several pieces of code to initialize i18n.  From the toplevel of <b>yum/i18n.py</b>:

          try:.
              '''
              Setup the yum translation domain and make _() and P_() translation wrappers
              available.
              using ugettext to make sure translated strings are in Unicode.
              '''
              import gettext
              t = gettext.translation('yum', fallback=True)
              _ = t.ugettext
              P_ = t.ungettext
          except:
              '''
              Something went wrong so we make a dummy _() wrapper there is just
              returning the same text
              '''
              _ = dummy_wrapper
              P_ = dummyP_wrapper

       With kitchen, this can be changed to this:

          from kitchen.i18n import easy_gettext_setup, DummyTranslations
          try:
              _, P_ = easy_gettext_setup('yum')
          except:
              translations = DummyTranslations()
              _ = translations.ugettext
              P_ = translations.ungettext

       <b>NOTE:</b>
          In  <u>Overcoming</u>  <u>frustration:</u>  <u>Correctly</u> <u>using</u> <u>unicode</u> <u>in</u> <u>python2</u>, it is mentioned that for some things
          (like exception messages), using the byte <b>str</b> oriented functions is  more  appropriate.   If  this  is
          desired, the setup portion is only a second call to <u>kitchen.i18n.easy_gettext_setup()</u>:

              b_, bP_ = easy_gettext_setup('yum', use_unicode=False)

       The second place where i18n is setup is in <b>yum.YumBase._getConfig()</b> in <b>yum/__init_.py</b> if <b>gaftonmode</b> is in
       effect:

          if startupconf.gaftonmode:
              global _
              _ = yum.i18n.dummy_wrapper

       This can be changed to:

          if startupconf.gaftonmode:
              global _
              _ = DummyTranslations().ugettext()

   <b>Conventions</b> <b>for</b> <b>contributing</b> <b>to</b> <b>kitchen</b>
   <b>Style</b>
       ‚Ä¢ Strive to be <u>PEP</u> <u>8</u> compliant

       ‚Ä¢ Run <u>:command:`pylint</u> ` over the code and try to resolve most of its nitpicking

   <b>Python</b> <b>2.4</b> <b>compatibility</b>
       At  the  moment, we're supporting python-2.4 and above.  Understand that there's a lot of python features
       that we cannot use because of this.

       Sometimes modules in the <u>python</u> <u>standard</u> <u>library</u> can be added to kitchen so that they're available.  When
       we do that we need to be careful of several things:

       1. Keep   the   module   in   sync    with    the    version    in    the    python-2.x    trunk.     Use
          <b>maintainers/sync-copied-files.py</b> for this.

       2. Sync the unittests as well as the module.

       3. Be  aware  that  not all modules are written to remain compatible with Python-2.4 and might use python
          language features that were not present then (generator  expressions,  relative  imports,  decorators,
          with,  try:  with  both  except:  and finally:, etc)  These are not good candidates for importing into
          kitchen as they require more work to keep synced.

   <b>Unittests</b>
       ‚Ä¢ At least smoketest your code (make sure a function will return expected values for one set of inputs).

       ‚Ä¢ Note that even 100% coverage is not a guarantee of working code!  Good tests will realize that you need
         to also give multiple inputs that test the code paths of called functions  that  are  outside  of  your
         code.  Example:

            def to_unicode(msg, encoding='utf8', errors='replace'):
                return unicode(msg, encoding, errors)

            # Smoketest only.  This will give 100% coverage for your code (it
            # tests all of the code inside of to_unicode) but it leaves a lot of
            # room for errors as it doesn't test all combinations of arguments
            # that are then passed to the unicode() function.

            tools.ok_(to_unicode('abc') == u'abc')

            # Better -- tests now cover non-ascii characters and that error conditions
            # occur properly.  There's a lot of other permutations that can be
            # added along these same lines.
            tools.ok_(to_unicode(u'caf√©', 'utf8', 'replace'))
            tools.assert_raises(UnicodeError, to_unicode, [u'caf√® √±unru'.encode('latin1')])

       ‚Ä¢ We're  using  nose  for  unittesting.  Rather than depend on unittest2 functionality, use the functions
         that nose provides.

       ‚Ä¢ Remember to maintain python-2.4 compatibility even in unittests.

   <b>Docstrings</b> <b>and</b> <b>documentation</b>
       We use sphinx to build our documentation.  We use the sphinx autodoc extension to pull docstrings out  of
       the  modules for API documentation.  This means that docstrings for subpackages and modules should follow
       a certain pattern.  The general structure is:

       ‚Ä¢ Introductory material about a module in the module's top level docstring.

         ‚Ä¢ Introductory material should begin with a level two title: an overbar and underbar of '-'.

       ‚Ä¢ docstrings for every function.

         ‚Ä¢ The first line is a short summary of what the function does

         ‚Ä¢ This is followed by a blank line

         ‚Ä¢ The next lines are a <u>field</u> <u>list</u>  <u>&lt;<a href="http://sphinx.pocoo.org/markup/desc.html">http://sphinx.pocoo.org/markup/desc.html</a>#info-field-lists&gt;</u><b>_</b>  giving
           information  about  the  function's signature.  We use the keywords: <b>arg</b>, <b>kwarg</b>, <b>raises</b>, <b>returns</b>, and
           sometimes <b>rtype</b>.  Use these to describe all arguments, key word  arguments,  exceptions  raised,  and
           return values using these.

           ‚Ä¢ Parameters that are <b>kwarg</b> should specify what their default behaviour is.

   <b>Kitchen</b> <b>versioning</b>
       Currently  the  kitchen  library  is in early stages of development.  While we're in this state, the main
       kitchen library uses the following pattern for version information:

       ‚Ä¢

         <b>Versions</b> <b>look</b> <b>like</b> <b>this::</b>
                __version_info__ = ((0, 1, 2),) __version__ = '0.1.2'

       ‚Ä¢ The Major version number remains at 0 until we decide to make the first 1.0  release  of  kitchen.   At
         that  point,  we're  declaring  that  we  have  some  confidence  that we won't need to break backwards
         compatibility for a while.

       ‚Ä¢ The Minor version increments for any backwards incompatible API changes.   When  this  is  updated,  we
         reset micro to zero.

       ‚Ä¢ The  Micro  version  increments for any other changes (backwards compatible API changes, pure bugfixes,
         etc).

       <b>NOTE:</b>
          Versioning is only updated for  releases  that  generate  sdists  and  new  uploads  to  the  download
          directory.   Usually  we  update  the  version  information  for  the library just before release.  By
          contrast, we update kitchen <u>Versioning</u> when an API change is made.  When in doubt, look at the version
          information in the last release.

   <b>I18N</b>
       All strings that are used as feedback for users need to be translated.  <b>kitchen</b> sets up several functions
       for this.  <b>_()</b> is used for marking things that are shown to users via print, GUIs,  or  other  "standard"
       methods.   Strings for exceptions are marked with <b>b_()</b>.  This function returns a byte <b>str</b> which is needed
       for use with exceptions:

          from kitchen import _, b_

          def print_message(msg, username):
              print _('%(user)s, your message of the day is:  %(message)s') % {
                      'message': msg, 'user': username}

              raise Exception b_('Test message')

       This serves several purposes:

       ‚Ä¢ It marks the strings to be extracted by an xgettext-like program.

       ‚Ä¢ <b>_()</b> is a function that will substitute available translations at runtime.

       <b>NOTE:</b>
          By using the <b>%()s</b> <b>with</b> <b>dict</b> style of string formatting, we make this string  friendly  to  translators
          that may need to reorder the variables when they're translating the string.

       <u>paver</u> <u>&lt;<a href="http://www.blueskyonmars.com/projects/paver/">http://www.blueskyonmars.com/projects/paver/</a>&gt;</u><b>_</b> and <u>babel</u> <u>&lt;<a href="http://babel.edgewall.org/">http://babel.edgewall.org/</a>&gt;</u><b>_</b> are used to
       extract the strings.

   <b>API</b> <b>updates</b>
       Kitchen  strives  to  have a long deprecation cycle so that people have time to switch away from any APIs
       that we decide to discard.  Discarded APIs should raise a <b>DeprecationWarning</b> and  clearly  state  in  the
       warning  message  and  the  docstring  how  to  convert old code to use the new interface.  An example of
       deprecating a function:

          import warnings

          from kitchen import _
          from  kitchen.text.converters import to_bytes, to_unicode
          from kitchen.text.new_module import new_function

          def old_function(param):
              '''**Deprecated**

              This function is deprecated.  Use
              :func:`kitchen.text.new_module.new_function` instead. If you want
              unicode strngs as output, switch to::

                  &gt;&gt;&gt; from kitchen.text.new_module import new_function
                  &gt;&gt;&gt; output = new_function(param)

              If you want byte strings, use::

                  &gt;&gt;&gt; from kitchen.text.new_module import new_function
                  &gt;&gt;&gt; from kitchen.text.converters import to_bytes
                  &gt;&gt;&gt; output = to_bytes(new_function(param))
              '''
              warnings.warn(_('kitchen.text.old_function is deprecated.  Use'
                  ' kitchen.text.new_module.new_function instead'),
                  DeprecationWarning, stacklevel=2)

              as_unicode = isinstance(param, unicode)
              message = new_function(to_unicode(param))
              if not as_unicode:
                  message = <a href="../manmessage/to_bytes.message.html">to_bytes</a>(message)
              return message

       If a particular API change is very intrusive, it may be better to create a new version of the  subpackage
       and ship both the old version and the new version.

   <b>NEWS</b> <b>file</b>
       Update  the  <b>NEWS</b> file when you make a change that will be visible to the users.  This is not a ChangeLog
       file so we don't need to list absolutely everything but it should give the  user  an  idea  of  how  this
       version differs from prior versions.  API changes should be listed here explicitly.  bugfixes can be more
       general:

          -----
          0.2.0
          -----
          * Relicense to LGPLv2+
          * Add kitchen.text.format module with the following functions:
            textual_width, textual_width_chop.
          * Rename the kitchen.text.utils module to kitchen.text.misc.  use of the
            old names is deprecated but still available.
          * bugfixes applied to kitchen.pycompat24.defaultdict that fixes some
            tracebacks

   <b>Kitchen</b> <b>subpackages</b>
       Kitchen itself is a namespace.  The kitchen sdist (tarball) provides certain useful subpackages.

       <b>SEE</b> <b>ALSO:</b>

          <u>Kitchen</u> <u>addon</u> <u>packages</u>
                 For  information  about  subpackages not distributed in the kitchen sdist that install into the
                 kitchen namespace.

   <b>Versioning</b>
       Each subpackage should have its own version  information  which  is  independent  of  the  other  kitchen
       subpackages  and the main kitchen library version. This is used so that code that depends on kitchen APIs
       can check the version information.  The standard way to do this is to put  something  like  this  in  the
       subpackage's <b>__init__.py</b>:

          from kitchen.versioning import version_tuple_to_string

          __version_info__ = ((1, 0, 0),)
          __version__ = version_tuple_to_string(__version_info__)

       <b>__version_info__</b>  is documented in <u>kitchen.versioning</u>.  The values of the first tuple should describe API
       changes to the module.  There are at least three numbers present in the  tuple:  (Major,  minor,  micro).
       The  major  version  number  is for backwards incompatible changes (For instance, removing a function, or
       adding a new mandatory argument to a function).  Whenever one of these occurs, you should  increment  the
       major number and reset minor and micro to zero.  The second number is the minor version.  Anytime new but
       backwards  compatible  changes  are  introduced  this  number should be incremented and the micro version
       number reset to zero.  The micro version should be incremented when a change is made that does not change
       the API at all.  This is a common case for bugfixes, for instance.

       Version information beyond the first three parts of the first tuple may  be  useful  for  versioning  but
       semantically have similar meaning to the micro version.

       <b>NOTE:</b>
          We  update  the  <b>__version_info__</b>  tuple  when  the  API  is updated.  This way there's less chance of
          forgetting to update the API version when a new release is made.  However, we try  to  only  increment
          the  version  numbers a single step for any release.  So if kitchen-0.1.0 has kitchen.text.__version__
          == '1.0.1', kitchen-0.1.1 should have kitchen.text.__version__ == '1.0.2' or '1.1.0' or '2.0.0'.

   <b>Criteria</b> <b>for</b> <b>subpackages</b> <b>in</b> <b>kitchen</b>
       Supackages within kitchen should meet these criteria:

       ‚Ä¢ Generally useful or needed for other pieces of kitchen.

       ‚Ä¢ No mandatory requirements outside of the <u>python</u> <u>standard</u> <u>library</u>.

         ‚Ä¢ Optional requirements from outside the <u>python</u> <u>standard</u> <u>library</u> are allowed.   Things  with  mandatory
           requirements are better placed in <u>kitchen</u> <u>addon</u> <u>packages</u>

       ‚Ä¢ Somewhat  API stable -- this is not a hard requirement.  We can change the kitchen api.  However, it is
         better not to as people may come to depend on it.

         <b>SEE</b> <b>ALSO:</b>
            <u>API</u> <u>Updates</u>

   <b>Kitchen</b> <b>addon</b> <b>packages</b>
       Addon packages are very similar to subpackages integrated into the  kitchen  sdist.   This  section  just
       lists some of the differences to watch out for.

   <b>setup.py</b>
       Your <b>setup.py</b> should contain entries like this:

          # It's suggested to use a dotted name like this so the package is easily
          # findable on pypi:
          setup(name='kitchen.config',
              # Include kitchen in the keywords, again, for searching on pypi
              keywords=['kitchen', 'configuration'],
              # This package lives in the directory kitchen/config
              packages=['kitchen.config'],
              # [...]
          )

   <b>Package</b> <b>directory</b> <b>layout</b>
       Create a <b>kitchen</b> directory in the toplevel.  Place the addon subpackage in there.  For example:

          ./                     &lt;== toplevel with README, setup.py, NEWS, etc
          kitchen/
          kitchen/__init__.py
          kitchen/config/        &lt;== subpackage directory
          kitchen/config/__init__.py

   <b>Fake</b> <b>kitchen</b> <b>module</b>
       The  :file::<b>__</b><u>init</u><b>__</b><u>.py</u>  in  the  <b>kitchen</b> directory is special.  It won't be installed.  It just needs to
       pull in the kitchen from the system so that you are able to test your module.  You should be able to  use
       this boilerplate:

          # Fake module.  This is not installed,  It's just made to import the real
          # kitchen modules for testing this module
          import pkgutil

          # Extend the __path__ with everything in the real kitchen module
          __path__ = pkgutil.extend_path(__path__, __name__)

       <b>NOTE:</b>
          <b>kitchen</b>  needs to be findable by python for this to work.  Installed in the <b>site-packages</b> directory or
          adding it to the <b>PYTHONPATH</b> will work.

       Your unittests should now be able to find both your submodule and the main kitchen module.

   <b>Versioning</b>
       It is recommended that  addon  packages  version  similarly  to  <u>Versioning</u>.   The  <b>__version_info__</b>  and
       <b>__version__</b>  strings  can  be  changed independently of  the version exposed by setup.py so that you have
       both an API version (<b>__version_info__</b>) and release version that's easier for people to  parse.   However,
       you  aren't  required  to do this and you could follow a different methodology if you want (for instance,
       <u>Kitchen</u> <u>versioning</u>)

   <b>Glossary</b>
       <b>"Everything</b> <b>but</b> <b>the</b> <b>kitchen</b> <b>sink"</b>
              An English idiom meaning to include nearly everything that you can think of.

       <b>API</b> <b>version</b>
              Version that is meant for computer consumption.   This  version  is  parsable  and  comparable  by
              computers.   It  contains  information  about a library's API so that computer software can decide
              whether it works with the software.

       <b>ASCII</b>  A character encoding that maps numbers to characters essential to American English.  It  maps  128
              characters using 7bits.

              <b>SEE</b> <b>ALSO:</b>
                 <u><a href="http://en.wikipedia.org/wiki/ASCII">http://en.wikipedia.org/wiki/ASCII</a></u>

       <b>ASCII</b> <b>compatible</b>
              An  encoding  in  which the particular byte that maps to a character in the <u>ASCII</u> character set is
              only used to map to that character.  This excludes EBDIC based encodings and many multi-byte fixed
              and variable width encodings since they reuse the bytes that make up the <u>ASCII</u> encoding for  other
              purposes.  <u>UTF-8</u> is notable as a variable width encoding that is <u>ASCII</u> compatible.

              <b>SEE</b> <b>ALSO:</b>

                 <u><a href="http://en.wikipedia.org/wiki/Variable-width_encoding">http://en.wikipedia.org/wiki/Variable-width_encoding</a></u>
                        For  another  explanation  of  various ways bytes are mapped to characters in a possibly
                        incompatible manner.

       <b>code</b> <b>points</b>
              <u>code</u> <u>point</u>

       <b>code</b> <b>point</b>
              A number that maps to a particular abstract character.  Code points make it  so  that  we  have  a
              number  pointing to a character without worrying about implementation details of how those numbers
              are stored for the computer to read.  Encodings define how  the  code  points  map  to  particular
              sequences of bytes on disk  and in memory.

       <b>control</b> <b>characters</b>
              <u>control</u> <u>character</u>

       <b>control</b> <b>character</b>
              The  set  of characters in unicode that are used, not to display glyphs on the screen, but to tell
              the display in program to do something.

              <b>SEE</b> <b>ALSO:</b>
                 <u><a href="http://en.wikipedia.org/wiki/Control_character">http://en.wikipedia.org/wiki/Control_character</a></u>

       <b>grapheme</b>
              characters or pieces of characters that you might write on a page to  make  words,  sentences,  or
              other pieces of text.

              <b>SEE</b> <b>ALSO:</b>
                 <u><a href="http://en.wikipedia.org/wiki/Grapheme">http://en.wikipedia.org/wiki/Grapheme</a></u>

       <b>I18N</b>   I18N  is  an  abbreviation  for  internationalization.   It's  often  used  to signify the need to
              translate words, number and date formats, and other pieces of data in a computer program  so  that
              it will work well for people who speak another language than yourself.

       <b>message</b> <b>catalogs</b>
              <u>message</u> <u>catalog</u>

       <b>message</b> <b>catalog</b>
              Message  catalogs  contain  translations  for  user-visible strings that are present in your code.
              Normally, you need to mark the strings to be translated by wrapping them in one of several <b>gettext</b>
              functions.  The function serves two purposes:

              1. It allows automated tools to find which strings are supposed to be extracted for translation.

              2. The functions perform the translation when the program is running.

              <b>SEE</b> <b>ALSO:</b>
                 <u>babel's</u> <u>documentation</u>
                     for one method of extracting message catalogs from source code.

       <b>Murphy's</b> <b>Law</b>
              "Anything that can go wrong, will go wrong."

              <b>SEE</b> <b>ALSO:</b>
                 <u><a href="http://en.wikipedia.org/wiki/Murphy">http://en.wikipedia.org/wiki/Murphy</a>%27s_Law</u>

       <b>release</b> <b>version</b>
              Version that is meant for human consumption.  This version is easy for  a  human  to  look  at  to
              decide how a particular version relates to other versions of the software.

       <b>textual</b> <b>width</b>
              The  amount of horizontal space a character takes up on a monospaced screen.  The units are number
              of character cells or columns that it takes the place of.

       <b>UTF-8</b>  A character encoding that maps all unicode <u>code</u> <u>points</u> to a sequence of bytes.  It  is  compatible
              with  <u>ASCII</u>.   It uses a variable number of bytes to encode all of unicode.  ASCII characters take
              one byte.  Characters from other parts of unicode take two to four bytes.  It is widespread as  an
              encoding on the internet and in Linux.

</pre><h4><b>INDICES</b> <b>AND</b> <b>TABLES</b></h4><pre>
       ‚Ä¢ <u>Index</u>

       ‚Ä¢ <u>Module</u> <u>Index</u>

       ‚Ä¢ <u>Search</u> <u>Page</u>

</pre><h4><b>PROJECT</b> <b>PAGES</b></h4><pre>
       More information about the project can be found on the <u>project</u> <u>webpage</u>

       The latest published version of this documentation can be found on the <u>documentation</u> <u>page</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Author name not set

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2012 Red Hat, Inc. and others

0.2                                               Dec 23, 2024                                        <u><a href="../man1/KITCHEN.1.html">KITCHEN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>