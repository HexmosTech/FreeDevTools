<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>escript - Run a script written in Erlang</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/erlang-doc">erlang-doc_27.3+dfsg-1ubuntu1.2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       escript - Run a script written in Erlang

</pre><h4><b>SYNOPSIS</b></h4><pre>
       script-name [arg1 arg2...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>escript</u>  provides  support for running short Erlang programs without having to compile them first, and an
       easy way to retrieve the command-line arguments. <u>escript</u>s are created by either writing them by  hand  or
       using <u>escript:create/2</u>.

       escripts are run by directly invoking them (does not work on Windows):

              script-name [arg1 arg2...]

       or by calling the <u>escript</u> program (works on all platforms):

              escript [escript-flags] script-name.escript [arg1 arg2...]

       For example:

              $ chmod u+x factorial
              $ cat factorial

              #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?env">/usr/bin/env</a> escript
              %% -*- erlang -*-
              %%! -sname factorial -mnesia debug verbose
              main([String]) -&gt;
                  try
                      N = list_to_integer(String),
                      F = fac(N),
                      io:format("factorial ~w = ~w\n", [N,F])
                  catch
                      _:_ -&gt;
                          usage()
                  end;
              main(_) -&gt;
                  usage().

              usage() -&gt;
                  io:format("usage: factorial integer\n"),
                  <a href="../man1/halt.1.html">halt</a>(1).

              <a href="../man0/fac.0.html">fac</a>(0) -&gt; 1;
              fac(N) -&gt; N * fac(N-1).

              $ ./factorial 5
              factorial 5 = 120
              $ ./factorial
              usage: factorial integer
              $ ./factorial five
              usage: factorial integer

       The  header  of  the  Erlang script in the example differs from a normal Erlang module. The first line is
       intended to be the interpreter line, which invokes <u>escript</u>.

       However, if you invoke the <u>escript</u> as follows, the contents of the first  line  do  not  matter,  but  it
       cannot contain Erlang code as it will be ignored:

              $ escript factorial 5

       The  second  line  in  the example contains an optional directive to the <u>Emacs</u> editor, which causes it to
       enter the major mode for editing Erlang source files. If the directive is present, it must be located  on
       the second line.

       If a comment selecting the encoding exists, it can be located on the second line.

       <b>NOTE:</b> The encoding specified by the above mentioned comment applies to the script itself. The encoding of
       the I/O-server, however, must be set explicitly as follows:

              io:setopts([{encoding, latin1}])

       The  default encoding of the I/O-server for <u>standard_io</u> is <u>unicode</u> if its supported. (see section Summary
       of Options) in the STDLIB User's Guide.

       On the third line (or second line depending on the presence of the Emacs  directive),  arguments  can  be
       specified to the emulator, for example:

              %%! -sname factorial -mnesia debug verbose

       Such  an  argument  line  must  start  with <u>%%!</u> and the remaining line is interpreted as arguments to the
       emulator.

       If you know the location of the <u>escript</u> executable, the first line can directly give the path to <u>escript</u>,
       for example:

              #!/usr/local/bin/escript

       As any other type of scripts, Erlang scripts do not work on Unix platforms if the execution bit  for  the
       script file is not set. (To turn on the execution bit, use <u>chmod</u> <u>+x</u> <u>script-name</u>.)

       The  remaining  Erlang  script  file  can  either contain Erlang <u>source</u> <u>code</u>, an <u>inlined</u> <u>beam</u> <u>file</u>, or an
       <u>inlined</u> <u>archive</u> <u>file</u>.

       An Erlang script file must always contain the <u>main/1</u>  function.  When  the  script  is  run,  the  <u>main/1</u>
       function is called with a list of strings representing the arguments specified to the script (not changed
       or interpreted in any way).

       If  the  <u>main/1</u>  function  in the script returns successfully, the exit status for the script is <u>0</u>. If an
       exception is generated during execution, a short message is printed and the script terminates  with  exit
       status <u>127</u>.

       To return your own non-zero exit code, call <u>halt(ExitCode)</u>, for example:

              <a href="../man1/halt.1.html">halt</a>(1).

       To  retrieve  the  pathname  of  the script, call <u>escript:script_name/0</u> from your script (the pathname is
       usually, but not always, absolute).

       If the file contains source code (as in the example above), it is processed by the <u>epp</u> preprocessor. This
       means that you, for example, can use predefined macros (such as <u>?MODULE</u>) and include directives like  the
       <u>-include_lib</u> directive. For example, use

              -include_lib("kernel/include/file.hrl").

       to  include  the  record definitions for the records used by function <u>file:read_link_info/1</u>. You can also
       select encoding by including an encoding comment here, but if a valid  encoding  comment  exists  on  the
       second line, it takes precedence.

       The  script  is  checked  for  syntactic and semantic correctness before it is run. If there are warnings
       (such as unused variables), they are printed and the script will still be run. If there are errors,  they
       are printed and the script will not be run and its exit status is <u>127</u>.

       Both the module declaration and the export declaration of the <u>main/1</u> function are optional.

       By default, the script will be compiled by the Erlang compiler.

       It  is  possible  to  force  it to be interpreted by including the following line somewhere in the script
       file:

              -mode(interpret).

       Execution of interpreted code is slower than compiled code, and some language constructs will  not  work,
       but there is no requirement for the Erlang compiler application to be available.

       <b>CHANGE:</b> Before Erlang/OTP 27 the script would be interpreted by default.

   <b>Precompiled</b> <b>escripts</b>
       A  script can also contains precompiled <u>beam</u> code. To create a precompiled escript it is recommended that
       you use <u>escript:create/2</u>. In a precompiled script, the interpretation of the script header is the same as
       in a script containing source code. This means that you can make a <u>beam</u> file executable by prepending the
       file with the lines starting with <u>#!</u> and <u>%%!</u>  mentioned  above.  In  a  precompiled  script,  the  <u>main/1</u>
       function must be exported.

       Another  option  is  to  have  an  entire  Erlang  archive  in  the  script.  In  an  archive script, the
       interpretation of the script header is the same as in a script containing source code.  This  means  that
       you  can  make  an archive file executable by prepending the file with the lines starting with <u>#!</u> and <u>%%!</u>
       mentioned above. In an archive script, the <u>main/1</u> function  must  be  exported.  By  default  the  <u>main/1</u>
       function  in  the module with the same name as the basename of the <u>escript</u> file is invoked. This behavior
       can be overridden by setting flag <u>-escript</u> <u>main</u> <u>Module</u> as one of the emulator flags. <u>Module</u> must  be  the
       name  of  a  module  that  has  an exported <u>main/1</u> function. For more information about archives and code
       loading, see <u>escript</u> and <u>code</u>.

       It is often very convenient to have a header in the escript, especially on Unix platforms.  However,  the
       header  is  optional,  so you directly can "execute" an Erlang module, Beam file, or archive file without
       adding any header to them. But then you have to invoke the script as follows:

              $ escript factorial.erl 5
              factorial 5 = 120
              $ escript factorial.beam 5
              factorial 5 = 120
              $ escript factorial.zip 5
              factorial 5 = 120

   <b>Bundling</b> <b>escripts</b>
       It is possible to bundle <u>escript</u>(s) with  an  Erlang  runtime  system  to  make  it  self-sufficient  and
       relocatable.  In  such  a standalone system, the <u>escript</u>(s) should be located in the top <u>bin</u> directory of
       the standalone system and given <u>.escript</u> as file extension. Further the (built-in) <u>escript</u> program should
       be copied to the same directory and given the script's original name (without  the  <u>.escript</u>  extension).
       This will enable use of the bundled Erlang runtime system.

       The  (built-in) <u>escript</u> program first determines which Erlang runtime system to use and then starts it to
       execute your script. Usually the runtime system is located in the same Erlang installation as the <u>escript</u>
       program itself. But for standalone systems with one or more escripts it may be the case that the  <u>escript</u>
       program  in  your  path actually starts the runtime system bundled with the escript. This is intentional,
       and typically happens when the standalone system <u>bin</u> directory is not in the execution path  (as  it  may
       cause  its <u>erl</u> program to override the desired one) and the <u>escript</u>(s) are referred to via symbolic links
       from a <u>bin</u> directory in the path.

   <b>Options</b> <b>Accepted</b> <b>By</b> <b>escript</b>
       -c
         Compiles the escript regardless of the value of the mode attribute.

       -d
         Debugs the escript. Starts the debugger, loads the module  containing  the  <u>main/1</u>  function  into  the
         debugger,  sets  a  breakpoint  in <u>main/1</u>, and invokes <u>main/1</u>. If the module is precompiled, it must be
         explicitly compiled with option <u>debug_info</u>.

       -i
         Interprets the escript regardless of the value of the mode attribute.

       -s
         Performs a syntactic and semantic check of the script file. Warnings and errors (if any) are written to
         the standard output, but the script will not be run. The exit status is <u>0</u>  if  any  errors  are  found,
         otherwise <u>127</u>.

       <b>NOTE:</b>  The  configuration  of  the  Erlang  emulator  invoked by <u>escript</u> can also be controlled using the
       environment variables understood by <u>erl</u>.

Ericsson AB                                        erts 15.2.3                                        <u><a href="../man1/escript.1.html">escript</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>