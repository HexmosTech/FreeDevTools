<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::Scilab - A guide for Scilab users.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/noble/+package/pdl">pdl_2.085-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::Scilab - A guide for Scilab users.

</pre><h4><b>INTRODUCTION</b></h4><pre>
       If you are a Scilab user, this page is for you. It explains the key differences between Scilab and PDL to
       help you get going as quickly as possible.

       <b>This</b> <b>document</b> <b>is</b> <b>not</b> <b>a</b> <b>tutorial</b>. For that, go to PDL::QuickStart. This document <b>complements</b> the Quick
       Start guide, as it highlights the key differences between Scilab and PDL.

</pre><h4><b>Perl</b></h4><pre>
       The key difference between Scilab and PDL is <b>Perl</b>.

       Perl is a general purpose programming language with thousands of modules freely available on the web. PDL
       is an extension of Perl. This gives PDL programs access to more features than most numerical tools can
       dream of.  At the same time, most syntax differences between Scilab and PDL are a result of its Perl
       foundation.

       <b>You</b> <b>do</b> <b>not</b> <b>have</b> <b>to</b> <b>learn</b> <b>much</b> <b>Perl</b> <b>to</b> <b>be</b> <b>effective</b> <b>with</b> <b>PDL</b>. But if you wish to learn Perl, there is
       excellent documentation available on-line (&lt;<a href="http://perldoc.perl.org">http://perldoc.perl.org</a>&gt;) or through the command "perldoc
       perl".  There is also a beginner's portal (&lt;<a href="http://perl-begin.org">http://perl-begin.org</a>&gt;).

       Perl's module repository is called CPAN (&lt;<a href="http://www.cpan.org">http://www.cpan.org</a>&gt;) and it has a vast array of modules. Run
       "perldoc cpan" for more information.

</pre><h4><b>TERMINOLOGY:</b> <b>NDARRAY</b></h4><pre>
       Scilab typically refers to vectors, matrices, and arrays. Perl already has arrays, and the terms "vector"
       and "matrix" typically refer to one- and two-dimensional collections of data. Having no good term to
       describe their object, PDL developers coined the term "<u>ndarray</u>" to give a name to their data type.

       An <u>ndarray</u> consists of a series of numbers organized as an N-dimensional data set. ndarrays provide
       efficient storage and fast computation of large N-dimensional matrices. They are highly optimized for
       numerical work.

       For more information, see "<b>ndarrays</b> <b>vs</b> <b>Perl</b> <b>Arrays</b>" later in this document.

</pre><h4><b>COMMAND</b> <b>WINDOW</b> <b>AND</b> <b>IDE</b></h4><pre>
       PDL does not come with a dedicated IDE. It does however come with an interactive shell and you can use a
       Perl IDE to develop PDL programs.

   <b>PDL</b> <b>interactive</b> <b>shell</b>
       To start the interactive shell, open a terminal and run "perldl" or "pdl2".  As in Scilab, the
       interactive shell is the best way to learn the language. To exit the shell, type "exit", just like
       Scilab.

   <b>Writing</b> <b>PDL</b> <b>programs</b>
       One popular IDE for Perl is called Padre (&lt;<a href="http://padre.perlide.org">http://padre.perlide.org</a>&gt;).  It is cross platform and easy to
       use.

       Whenever you write a stand-alone PDL program (i.e. outside the "perldl" or "pdl2" shells) you must start
       the program with "use PDL;".  This command imports the PDL module into Perl. Here is a sample PDL
       program:

         use PDL;             # Import main PDL module.
         use PDL::NiceSlice;  # Import additional PDL module.

         $y = pdl [2,3,4];              # Statements end in semicolon.
         $A = pdl [ [1,2,3],[4,5,6] ];  # 2-dimensional ndarray.

         print $A x $y-&gt;transpose;

       Save this file as "myprogram.pl" and run it with:

         perl myprogram.pl

   <b>New:</b> <b>Flexible</b> <b>syntax</b>
       In very recent versions of PDL (version 2.4.7 or later) there is a flexible matrix syntax that can look
       extremely similar to Scilab:

       1) Use a ';' to delimit rows:

         $y = pdl q[ 2,3,4 ];
         $A = pdl q[ 1,2,3 ; 4,5,6 ];

       2) Use spaces to separate elements:

         $y = pdl q[ 2 3 4 ];
         $A = pdl q[ 1 2 3 ; 4 5 6 ];

       Basically, as long as you put a "q" in front of the opening bracket, PDL should "do what you mean". So
       you can write in a syntax that is more comfortable for you.

</pre><h4><b>A</b> <b>MODULE</b> <b>FOR</b> <b>SCILAB</b> <b>USERS</b></h4><pre>
       Here is a module that Scilab users will want to use:

       PDL::NiceSlice
            Gives PDL a syntax for slices (sub-matrices) that is shorter and more familiar to Scilab users.

              // Scilab
              b(1:5)            --&gt;  Selects the first 5 elements from b.

              # PDL without NiceSlice
              $y-&gt;slice("0:4")  --&gt;  Selects the first 5 elements from $y.

              # PDL with NiceSlice
              $y(0:4)           --&gt;  Selects the first 5 elements from $y.

</pre><h4><b>BASIC</b> <b>FEATURES</b></h4><pre>
       This section explains how PDL's syntax differs from Scilab. Most Scilab users will want to start here.

   <b>General</b> <b>"gotchas"</b>
       Indices
            In PDL, indices start at '0' (like C and Java), not 1 (like Scilab).  For example, if $y is an array
            with 5 elements, the elements would be numbered from 0 to 4.

       Displaying an object
            Scilab  normally  displays object contents automatically. In PDL you display objects explicitly with
            the "print" command or the shortcut "p":

            Scilab:

             --&gt; a = 12
             a =  12.
             --&gt; b = 23;       // Suppress output.
             --&gt;

            PerlDL:

             pdl&gt; $x = 12    # No output.
             pdl&gt; print $x   # Print object.
             12
             pdl&gt; p $x       # "p" is a shorthand for "print" in the shell.
             12

   <b>Creating</b> <b>ndarrays</b>
       Variables in PDL
            Variables always start with the '$' sign.

             Scilab:    value  = 42
             PerlDL:    $value = 42

       Basic syntax
            Use the "pdl" constructor to create a new <u>ndarray</u>.

             Scilab:    v  = [1,2,3,4]
             PerlDL:    $v = pdl [1,2,3,4]

             Scilab:    A  =      [ 1,2,3  ;  3,4,5 ]
             PerlDL:    $A = pdl [ [1,2,3] , [3,4,5] ]

       Simple matrices
                                  Scilab       PDL
                                  ------       ------
              Matrix of ones      ones(5,5)    ones 5,5
              Matrix of zeros     zeros(5,5)   zeros 5,5
              Random matrix       rand(5,5)    random 5,5
              Linear vector       1:5          sequence 5

            Notice that in PDL the parenthesis in a function call are often optional.  It is important  to  keep
            an eye out for possible ambiguities. For example:

              pdl&gt; p zeros 2, 2 + 2

            Should this be interpreted as "zeros(2,2) + 2" or as "zeros 2, (2+2)"?  Both are valid statements:

              pdl&gt; p zeros(2,2) + 2
              [
               [2 2]
               [2 2]
              ]
              pdl&gt; p zeros 2, (2+2)
              [
               [0 0]
               [0 0]
               [0 0]
               [0 0]
              ]

            Rather  than  trying  to  memorize Perl's order of precedence, it is best to use parentheses to make
            your code unambiguous.

       Linearly spaced sequences
              Scilab:   --&gt; linspace(2,10,5)
                        ans = 2.  4.  6.  8.  10.

              PerlDL:   pdl&gt; p <a href="../man5/zeroes.5.html">zeroes</a>(5)-&gt;xlinvals(2,10)
                        [2 4 6 8 10]

            <b>Explanation</b>: Start with a 1-dimensional ndarray of 5 elements and give it equally spaced values from
            2 to 10.

            Scilab has a single function call for this. On the other hand, PDL's method is more flexible:

              pdl&gt; p zeros(5,5)-&gt;xlinvals(2,10)
              [
               [ 2  4  6  8 10]
               [ 2  4  6  8 10]
               [ 2  4  6  8 10]
               [ 2  4  6  8 10]
               [ 2  4  6  8 10]
              ]
              pdl&gt; p zeros(5,5)-&gt;ylinvals(2,10)
              [
               [ 2  2  2  2  2]
               [ 4  4  4  4  4]
               [ 6  6  6  6  6]
               [ 8  8  8  8  8]
               [10 10 10 10 10]
              ]
              pdl&gt; p zeros(3,3,3)-&gt;zlinvals(2,6)
              [
               [
                [2 2 2]
                [2 2 2]
                [2 2 2]
               ]
               [
                [4 4 4]
                [4 4 4]
                [4 4 4]
               ]
               [
                [6 6 6]
                [6 6 6]
                [6 6 6]
               ]
              ]

       Slicing and indices
            Extracting a subset from a collection of data is known as <u>slicing</u>.  The PDL shell and Scilab have  a
            similar syntax for slicing, but there are two important differences:

            1) PDL indices start at 0, as in C and Java. Scilab starts indices at 1.

            2) In Scilab you think "rows and columns". In PDL, think "x and y".

              Scilab                         PerlDL
              ------                         ------
              --&gt; A                           pdl&gt; p $A
              A =                            [
                   1.  2.  3.                 [1 2 3]
                   4.  5.  6.                 [4 5 6]
                   7.  8.  9.                 [7 8 9]
                                             ]
              -------------------------------------------------------
              (row = 2, col = 1)             (x = 0, y = 1)
              --&gt; A(2,1)                      pdl&gt; p $A(0,1)
              ans =                          [
                     4.                       [4]
                                             ]
              -------------------------------------------------------
              (row = 2 to 3, col = 1 to 2)   (x = 0 to 1, y = 1 to 2)
              --&gt; A(2:3,1:2)                  pdl&gt; p $A(0:1,1:2)
              ans =                          [
                     4.  5.                   [4 5]
                     7.  8.                   [7 8]
                                             ]

            <b>Warning</b>
                 When you write a stand-alone PDL program you have to include the PDL::NiceSlice module. See the
                 previous section "<b>MODULES</b> <b>FOR</b> <b>SCILAB</b> <b>USERS</b>" for more information.

                   use PDL;             # Import main PDL module.
                   use PDL::NiceSlice;  # Nice syntax for slicing.

                   $A = random 4,4;
                   print $A(0,1);

   <b>Matrix</b> <b>Operations</b>
       Matrix multiplication
                  Scilab:    A * B
                  PerlDL:    $A x $B

       Element-wise multiplication
                  Scilab:    A .* B
                  PerlDL:    $A * $B

       Transpose
                  Scilab:    A'
                  PerlDL:    $A-&gt;transpose

   <b>Functions</b> <b>that</b> <b>aggregate</b> <b>data</b>
       Some functions (like "sum", "max" and "min") aggregate data for an N-dimensional data set. Scilab and PDL
       both give you the option to apply these functions to the entire data set or to just one dimension.

       Scilab    In Scilab, these functions work along the entire data set by default, and an optional parameter
                 "r" or "c" makes them act over rows or columns.

                   --&gt; A = [ 1,5,4  ;  4,2,1 ]
                   A = 1.  5.  4.
                       4.  2.  1.
                   --&gt; max(A)
                   ans = 5
                   --&gt; max(A, "r")
                   ans = 4.    5.    4.
                   --&gt; max(A, "c")
                   ans = 5.
                         4.

       PDL       PDL offers two functions for each feature.

                   sum   vs   sumover
                   avg   vs   average
                   max   vs   maximum
                   min   vs   minimum

                 The <b>long</b> <b>name</b> works over a dimension, while the <b>short</b> <b>name</b> works over the entire ndarray.

                   pdl&gt; p $A = pdl [ [1,5,4] , [4,2,1] ]
                   [
                    [1 5 4]
                    [4 2 1]
                   ]
                   pdl&gt; p $A-&gt;maximum
                   [5 4]
                   pdl&gt; p $A-&gt;transpose-&gt;maximum
                   [4 5 4]
                   pdl&gt; p $A-&gt;max
                   5

   <b>Higher</b> <b>dimensional</b> <b>data</b> <b>sets</b>
       A  related  issue is how Scilab and PDL understand data sets of higher dimension. Scilab was designed for
       1D vectors and 2D matrices with higher dimensional objects added on top. In contrast,  PDL  was  designed
       for  N-dimensional  ndarrays  from the start. This leads to a few surprises in Scilab that don't occur in
       PDL:

       Scilab sees a vector as a 2D matrix.
              Scilab                       PerlDL
              ------                       ------
              --&gt; vector = [1,2,3,4];       pdl&gt; $vector = pdl [1,2,3,4]
              --&gt; size(vector)              pdl&gt; p $vector-&gt;dims
              ans = 1 4                    4

            Scilab sees "[1,2,3,4]" as a 2D matrix (1x4 matrix). PDL sees it as a 1D vector: A single  dimension
            of size 4.

       But Scilab ignores the last dimension of a 4x1x1 matrix.
              Scilab                       PerlDL
              ------                       ------
              --&gt; A = ones(4,1,1);          pdl&gt; $A = ones 4,1,1
              --&gt; size(A)                   pdl&gt; p $A-&gt;dims
              ans = 4 1                    4 1 1

       And Scilab treats a 4x1x1 matrix differently from a 1x1x4 matrix.
              Scilab                       PerlDL
              ------                       ------
              --&gt; A = ones(1,1,4);          pdl&gt; $A = ones 1,1,4
              --&gt; size(A)                   pdl&gt; p $A-&gt;dims
              ans = 1 1 4                  1 1 4

       Scilab has no direct syntax for N-D arrays.
              pdl&gt; $A = pdl [ [[1,2,3],[4,5,6]], [[2,3,4],[5,6,7]] ]
              pdl&gt; p $A-&gt;dims
              3 2 2

       Feature support.
            In  Scilab,  several  features  are  not  available  for  N-D arrays. In PDL, just about any feature
            supported by 1D and 2D ndarrays, is equally supported by N-dimensional ndarrays. There is usually no
            distinction:

              Scilab                       PerlDL
              ------                       ------
              --&gt; A = ones(3,3,3);         pdl&gt; $A = ones(3,3,3);
              --&gt; A'                       pdl&gt; transpose $A
                  =&gt; ERROR                         =&gt; OK

   <b>Loop</b> <b>Structures</b>
       Perl has many loop structures, but we will only show the one that is most familiar to Scilab users:

         Scilab              PerlDL
         ------              ------
         for i = 1:10        for $i (1..10) {
             disp(i)             print $i
         end                 }

       <b>Note</b> Never use for-loops for numerical work. Perl's for-loops are faster than  Scilab's,  but  they  both
            pale  against  a  "vectorized"  operation.   PDL  has  many tools that facilitate writing vectorized
            programs.   These  are  beyond  the  scope  of  this  guide.  To  learn  more,  see:  PDL::Indexing,
            PDL::Broadcasting, and PDL::PP.

            Likewise,  never use 1..10 for numerical work, even outside a for-loop.  1..10 is a Perl array. Perl
            arrays are designed for flexibility, not speed. Use <u>ndarrays</u> instead. To learn more,  see  the  next
            section.

   <b>ndarrays</b> <b>vs</b> <b>Perl</b> <b>Arrays</b>
       It  is  important  to note the difference between an <u>ndarray</u> and a Perl array. Perl has a general-purpose
       array object that can hold any type of element:

         @perl_array = 1..10;
         @perl_array = ( 12, "Hello" );
         @perl_array = ( 1, 2, 3, \@another_perl_array, <a href="../man5/sequence.5.html">sequence</a>(5) );

       Perl arrays allow you to create powerful data structures (see <b>Data</b> <b>structures</b> below), <b>but</b>  <b>they</b>  <b>are</b>  <b>not</b>
       <b>designed</b> <b>for</b> <b>numerical</b> <b>work</b>.  For that, use <u>ndarrays</u>:

         $pdl = pdl [ 1, 2, 3, 4 ];
         $pdl = sequence 10_000_000;
         $pdl = ones 600, 600;

       For example:

         $points =  pdl  1..10_000_000    # 4.7 seconds
         $points = sequence 10_000_000    # milliseconds

       <b>TIP</b>: You can use underscores in numbers ("10_000_000" reads better than 10000000).

   <b>Conditionals</b>
       Perl has many conditionals, but we will only show the one that is most familiar to Scilab users:

         Scilab                          PerlDL
         ------                          ------
         if value &gt; MAX                  if ($value &gt; $MAX) {
             disp("Too large")               print "Too large\n";
         elseif value &lt; MIN              } elsif ($value &lt; $MIN) {
             disp("Too small")               print "Too small\n";
         else                            } else {
             disp("Perfect!")                print "Perfect!\n";
         end                             }

       <b>Note</b> Here is a "gotcha":

              Scilab:  elseif
              PerlDL:  elsif

            If your conditional gives a syntax error, check that you wrote your "elsif"'s correctly.

   <b>TIMTOWDI</b> <b>(There</b> <b>Is</b> <b>More</b> <b>Than</b> <b>One</b> <b>Way</b> <b>To</b> <b>Do</b> <b>It)</b>
       One  of  the  most  interesting differences between PDL and other tools is the expressiveness of the Perl
       language. TIMTOWDI, or "There Is More Than One Way To Do It", is Perl's motto.

       Perl was written by a linguist, and one of its defining properties is that statements can  be  formulated
       in  different  ways  to  give the language a more natural feel. For example, you are unlikely to say to a
       friend:

        "While I am not finished, I will keep working."

       Human language is more flexible than that. Instead, you are more likely to say:

        "I will keep working until I am finished."

       Owing to its linguistic roots, Perl is the only programming language with this sort of  flexibility.  For
       example, Perl has traditional while-loops and if-statements:

         while ( ! finished() ) {
             keep_working();
         }

         if ( ! wife_angry() ) {
             kiss_wife();
         }

       But it also offers the alternative <b>until</b> and <b>unless</b> statements:

         until ( finished() ) {
             keep_working();
         }

         unless ( wife_angry() ) {
             kiss_wife();
         }

       And Perl allows you to write loops and conditionals in "postfix" form:

         keep_working() until finished();

         kiss_wife() unless wife_angry();

       In  this  way,  Perl  often allows you to write more natural, easy to understand code than is possible in
       more restrictive programming languages.

   <b>Functions</b>
       PDL's syntax for declaring functions differs significantly from Scilab's.

         Scilab                          PerlDL
         ------                          ------
         function retval = foo(x,y)      sub foo {
             retval = x.**2 + x.*y           my ($x, $y) = @_;
         endfunction                         return $x**2 + $x*$y;
                                         }

       Don't be intimidated by all the new syntax. Here is a quick run through a function declaration in PDL:

       1) "<b>sub</b>" stands for "subroutine".

       2) "<b>my</b>" declares variables to be local to the function.

       3) "<b>@_</b>" is a special Perl array that holds all the function parameters.  This might seem like  a  strange
       way  to  do functions, but it allows you to make functions that take a variable number of parameters. For
       example, the following function takes any number of parameters and adds them together:

         sub mysum {
             my ($i, $total) = (0, 0);
             for $i (@_) {
                 $total += $i;
             }
             return $total;
         }

       4) You can assign values to several variables at once using the syntax:

         ($x, $y, $z) = (1, 2, 3);

       So, in the previous examples:

         # This declares two local variables and initializes them to 0.
         my ($i, $total) = (0, 0);

         # This takes the first two elements of @_ and puts them in $x and $y.
         my ($x, $y) = @_;

       5) The "<b>return</b>" statement gives the return value of the function, if any.

</pre><h4><b>ADDITIONAL</b> <b>FEATURES</b></h4><pre>
   <b>Data</b> <b>structures</b>
       To create complex data structures, Scilab uses "<u>lists</u>" and "<u>structs</u>".  Perl's  arrays  and  hashes  offer
       similar  functionality.  This  section  is only a quick overview of what Perl has to offer. To learn more
       about this, please go to &lt;<a href="http://perldoc.perl.org/perldata.html">http://perldoc.perl.org/perldata.html</a>&gt; or run the command "perldoc perldata".

       Arrays
            Perl arrays are similar to Scilab's lists. They are  both  a  sequential  data  structure  that  can
            contain any data type.

              Scilab
              ------
              list( 1, 12, "hello", zeros(3,3) , list( 1, 2) );

              PerlDL
              ------
              @array = ( 1, 12, "hello" , zeros(3,3), [ 1, 2 ] )

            Notice that Perl array's start with the "@" prefix instead of the "$" used by ndarrays.

            <u>To</u>  <u>learn</u> <u>about</u> <u>Perl</u> <u>arrays,</u> <u>please</u> <u>go</u> <u>to</u> <u>&lt;<a href="http://perldoc.perl.org/perldata.html">http://perldoc.perl.org/perldata.html</a>&gt;</u> <u>or</u> <u>run</u> <u>the</u> <u>command</u>
            <u>"perldoc</u> <u>perldata".</u>

       Hashes
            Perl hashes are similar to Scilab's structure arrays:

              Scilab
              ------
              --&gt; drink = struct('type', 'coke', 'size', 'large', 'myarray', ones(3,3,3))
              --&gt; drink.type = 'sprite'
              --&gt; drink.price = 12          // Add new field to structure array.

              PerlDL
              ------
              pdl&gt; %drink = ( type =&gt; 'coke' , size =&gt; 'large', myndarray =&gt; ones(3,3,3) )
              pdl&gt; $drink{type} = 'sprite'
              pdl&gt; $drink{price} = 12   # Add new field to hash.

            Notice that Perl hashes start with the "%" prefix instead of the "@" for  arrays  and  "$"  used  by
            ndarrays.

            <u>To</u>  <u>learn</u> <u>about</u> <u>Perl</u> <u>hashes,</u> <u>please</u> <u>go</u> <u>to</u> <u>&lt;<a href="http://perldoc.perl.org/perldata.html">http://perldoc.perl.org/perldata.html</a>&gt;</u> <u>or</u> <u>run</u> <u>the</u> <u>command</u>
            <u>"perldoc</u> <u>perldata".</u>

   <b>Performance</b>
       PDL has powerful performance features, some of which are not normally available in numerical  computation
       tools. The following pages will guide you through these features:

       PDL::Indexing
            <b>Level</b>: Beginner

            This  beginner  tutorial  covers  the  standard  "vectorization"  feature that you already know from
            Scilab. Use this page to learn how to avoid for-loops to make your program more efficient.

       PDL::Broadcasting
            <b>Level</b>: Intermediate

            PDL's "vectorization" feature goes beyond what most numerical software  can  do.  In  this  tutorial
            you'll  learn  how  to  "broadcast"  over  higher dimensions, allowing you to vectorize your program
            further than is possible in Scilab.

       Benchmarks
            <b>Level</b>: Intermediate

            Perl comes with an easy to use benchmarks module to help you find  how  long  it  takes  to  execute
            different  parts  of  your code. It is a great tool to help you focus your optimization efforts. You
            can read about it online (&lt;<a href="http://perldoc.perl.org/Benchmark.html">http://perldoc.perl.org/Benchmark.html</a>&gt;) or through the command  "perldoc
            Benchmark".

       PDL::PP
            <b>Level</b>: Advanced

            PDL's  Pre-Processor  is  one  of  PDL's  most powerful features. You write a function definition in
            special markup and the pre-processor generates real C code which can be compiled.  With  PDL:PP  you
            get  the  full  speed  of  native  C  code  without having to deal with the full complexity of the C
            language.

   <b>Plotting</b>
       PDL has full-featured plotting abilities. Unlike Scilab, PDL relies more on third-party libraries (pgplot
       and PLplot) for its 2D plotting features.  Its 3D plotting and graphics uses OpenGL for  performance  and
       portability.  PDL has three main plotting modules:

       PDL::Graphics::PGPLOT
            <b>Best</b> <b>for</b>: Plotting 2D functions and data sets.

            This  is  an  interface to the venerable PGPLOT library. PGPLOT has been widely used in the academic
            and scientific communities for many years. In part because of its age, PGPLOT has  some  limitations
            compared  to  newer  packages  such as PLplot (e.g. no RGB graphics).  But it has many features that
            still make it popular in the scientific community.

       PDL::Graphics::PLplot
            <b>Best</b> <b>for</b>: Plotting 2D functions as well as 2D and 3D data sets.

            This is an interface to the PLplot plotting library. PLplot is a modern,  open  source  library  for
            making  scientific  plots.   It supports plots of both 2D and 3D data sets. PLplot is best supported
            for unix/linux/macosx platforms. It has  an  active  developers  community  and  support  for  win32
            platforms is improving.

       PDL::Graphics::TriD
            <b>Best</b> <b>for</b>: Plotting 3D functions.

            The  native  PDL  3D graphics library using OpenGL as a backend for 3D plots and data visualization.
            With OpenGL, it is easy to manipulate the resulting 3D objects with the mouse in real time.

   <b>Writing</b> <b>GUIs</b>
       Through Perl, PDL has access to all the major toolkits for  creating  a  cross  platform  graphical  user
       interface.  One  popular  option is wxPerl (&lt;<a href="http://wxperl.sourceforge.net">http://wxperl.sourceforge.net</a>&gt;). These are the Perl bindings
       for wxWidgets, a powerful GUI toolkit for writing cross-platform applications.

       wxWidgets is designed to make your application look and feel like a native application in every platform.
       For example, the Perl IDE <b>Padre</b> is written with wxPerl.

   <b>Xcos</b> <b>/</b> <b>Scicos</b>
       Xcos (formerly Scicos) is a graphical dynamical system modeler and simulator. It is part of the  standard
       Scilab  distribution.  PDL  and Perl do not have a direct equivalent to Scilab's Xcos. If this feature is
       important to you, you should probably keep a copy of Scilab around for that.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2010 Daniel Carrera (<a href="mailto:dcarrera@gmail.com">dcarrera@gmail.com</a>). You can distribute and/or modify this document  under
       the same terms as the current Perl license.

       See: <a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a>

perl v5.38.2                                       2024-04-10                                         <u><a href="../man1p/SCILAB.1p.html">SCILAB</a></u>(1p)
</pre>
 </div>
</div></section>
</div>
</body>
</html>