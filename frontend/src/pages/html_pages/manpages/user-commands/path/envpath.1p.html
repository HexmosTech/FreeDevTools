<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>envpath - Advanced operations on path variables</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libenv-path-perl">libenv-path-perl_0.19-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       envpath - Advanced operations on path variables

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Run this script with the "-help" option for usage details.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Parses the command line, modifies the specified path variable(s), and execs the remaining arguments.
       There are two modes, <b>simple</b> and <b>advanced</b>:

   <b>SIMPLE</b> <b>MODE</b>
       Simple mode presents an alternative, platform-independent syntax for specifying paths wherein the path
       separator is "," and environment variables can be expanded with @NAME@. For example

           envpath PATH=@PATH@,/usr/ucb -- printenv PATH

       appends "/usr/ucb" to $PATH and execs <u>printenv</u> <u>PATH</u>. The "--" is optional.

       You can also specify prepending or appending by using "+=" or "=+" respectively:

           # place /usr/ucb at the front
           envpath PATH+=/usr/ucb -- printenv PATH

           # place /usr/ucb at the back
           envpath PATH=+/usr/ucb -- printenv PATH

       Simple mode requires only this script; it does not require Env::Path to be installed.

   <b>ADVANCED</b> <b>MODE</b>
       Advanced mode basically provides command-line access to the features of Env::Path (see), which must be
       installed. The "-E" flag selects the path variable to operate on and other flags specify operations on
       it.  E.g.

           envpath -E MANPATH -A <a href="file:/tmp">/tmp</a> -R <a href="file:/usr/share/man">/usr/share/man</a> -N -U -- man ...

       would take MANPATH, append <a href="file:/tmp">/tmp</a> to it, remove any references to "<a href="file:/usr/share/man">/usr/share/man</a>", remove any dirs which
       don't exist ("-N") and remove redundant entries ("-U") before running <u>man</u>.

       The -Whence option allows patterns. Thus

           envpath -W "cat*"

       would find all programs on PATH which match cat*.

</pre><h4><b>CLEARCASE</b> <b>WINKINS</b></h4><pre>
       A big part of the motivation for this script was for use with ClearCase builds; iff you know or care
       about ClearCase read on. Typically, during builds (and not just with ClearCase), pathvars such as PATH,
       CLASSPATH, and LD_LIBRARY_PATH must be strictly controlled.  One choice is to force static values of
       these into the environment during the build process, another is to simply require/expect users to set
       their paths appropriately. Each of these can lead to subtle build or runtime errors, however, and makes
       it hard for new users to get up to speed since their personal environment must be just so.

       Another common choice is to use only full pathnames within the Makefile, avoiding reliance on search
       paths at all. This is often the best way to go but can suppress ClearCase winkins.  For example, say
       you're generating ascii files of some type with a binary executable you just built:

       $(INCDIR)/foo.h: $(BINDIR)/foomaker      $(BINDIR)/foomaker ...

       The problem with this is that $(BINDIR) likely contains a platform part such as 'solaris' or 'hpux',
       which makes it impossible to wink in the foo.h file on other platforms even though it's ascii. This same
       thing could come up even with a standard pre-built utility that's in different places on different
       platforms; "yacc", for instance, is in <a href="file:/usr/bin">/usr/bin</a> on Linux and /usr/ccs/bin on Solaris.

       You could modify the path on the fly:

       $(INCDIR)/foo.h: $(BINDIR)/foomaker      PATH=$(BINDIR)$(SEP)$$PATH foomaker ...

       but this suffers from the same problem: since $(BINDIR) and $PATH are expanded literally within the build
       script they'll suppress winkins.  Here's a solution using <u>envpath</u>:

       $(INCDIR)/foo.h: $(BINDIR)/foomaker      envpath PATH=@BINDIR@,@PATH@ foomaker ...

       This hides the evaluation of BINDIR and PATH such that <u>clearmake</u> never sees anything but the literals,
       thus clearing the field for winkins. Of course <u>envpath</u> is capable of doing more than this, but it's the
       original reason it was written.

</pre><h4><b>AUTHOR</b></h4><pre>
       David Boyce &lt;dsbperl AT boyski.com&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2000-2001 David Boyce. All rights reserved.  This Perl program is free software; you may
       redistribute and/or modify it under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), "perldoc Env::Path"

perl v5.36.0                                       2022-10-13                                        <u><a href="../man1p/ENVPATH.1p.html">ENVPATH</a></u>(1p)
</pre>
 </div>
</div></section>
</div>
</body>
</html>