<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tclsh - Simple shell containing Tcl interpreter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/tcl8.6">tcl8.6_8.6.16+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tclsh - Simple shell containing Tcl interpreter

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>tclsh</b> ?<b>-encoding</b> <u>name</u>? ?<u>fileName</u> <u>arg</u> <u>arg</u> <u>...</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Tclsh</b>  is  a  shell-like  application  that reads Tcl commands from its standard input or from a file and
       evaluates them.  If invoked with no arguments then it  runs  interactively,  reading  Tcl  commands  from
       standard  input  and  printing  command results and error messages to standard output.  It runs until the
       <b>exit</b> command is invoked or until it reaches end-of-file on its standard input.  If there  exists  a  file
       <b>.tclshrc</b>  (or  <b>tclshrc.tcl</b> on the Windows platforms) in the home directory of the user, interactive <b>tclsh</b>
       evaluates the file as a Tcl script just before reading the first command from standard input.

</pre><h4><b>SCRIPT</b> <b>FILES</b></h4><pre>
       If <b>tclsh</b> is invoked with arguments then the first few arguments specify the name of a script  file,  and,
       optionally,  the  encoding of the text data stored in that script file. Any additional arguments are made
       available to the script as variables (see below).  Instead of reading commands from standard input  <b>tclsh</b>
       will  read  Tcl  commands from the named file;  <b>tclsh</b> will exit when it reaches the end of the file.  The
       end of the file may be marked either by the physical end of the  medium,  or  by  the  character,  “\032”
       (“\u001a”, control-Z).  If this character is present in the file, the <b>tclsh</b> application will read text up
       to  but  not including the character.  An application that requires this character in the file may safely
       encode it as “\032”, “\x1A”, or “\u001a”; or may generate it by use of commands such as <b>format</b> or <b>binary</b>.
       There is no automatic evaluation of <b>.tclshrc</b> when the name of a script file is  presented  on  the  <b>tclsh</b>
       command line, but the script file can always <b>source</b> it if desired.

       If you create a Tcl script in a file whose first line is

              <b>#!/usr/local/bin/tclsh</b>

       then  you  can  invoke the script file directly from your shell if you mark the file as executable.  This
       assumes that <b>tclsh</b> has been installed in the default location in  <a href="file:/usr/local/bin">/usr/local/bin</a>;   if  it  is  installed
       somewhere  else then you will have to modify the above line to match.  Many UNIX systems do not allow the
       <b>#!</b> line to exceed about 30 characters in length, so be sure that the <b>tclsh</b>  executable  can  be  accessed
       with a short file name.

       An even better approach is to start your script files with the following three lines:

              <b>#!<a href="file:/bin/sh">/bin/sh</a></b>
              <b>#</b> <b>the</b> <b>next</b> <b>line</b> <b>restarts</b> <b>using</b> <b>tclsh</b> <b>\</b>
              <b>exec</b> <b>tclsh</b> <b>"$0"</b> <b>${1+"$@"}</b>

       This  approach  has three advantages over the approach in the previous paragraph.  First, the location of
       the <b>tclsh</b> binary does not have to be hard-wired into the script:  it can be anywhere in your shell search
       path.  Second, it gets around the 30-character file name limit in the  previous  approach.   Third,  this
       approach  will  work  even  if  <b>tclsh</b>  is itself a shell script (this is done on some systems in order to
       handle multiple architectures or operating systems:  the <b>tclsh</b> script selects one of several binaries  to
       run).   The  three  lines cause both <b>sh</b> and <b>tclsh</b> to process the script, but the <b>exec</b> is only executed by
       <b>sh</b>.  <b>sh</b> processes the script first;  it treats the second line as a comment and executes the third  line.
       The  <b>exec</b>  statement  cause  the  shell to stop processing and instead to start up <b>tclsh</b> to reprocess the
       entire script.  When <b>tclsh</b> starts up, it treats all three lines as comments, since the backslash  at  the
       end of the second line causes the third line to be treated as part of the comment on the second line.

       You  should  note that it is also common practice to install tclsh with its version number as part of the
       name.  This has the advantage of allowing multiple versions of Tcl to exist on the same system  at  once,
       but  also  the disadvantage of making it harder to write scripts that start up uniformly across different
       versions of Tcl.

</pre><h4><b>VARIABLES</b></h4><pre>
       <b>Tclsh</b> sets the following global Tcl variables in addition to those created  by  the  Tcl  library  itself
       (such as <b>env</b>, which maps environment variables such as <b>PATH</b> into Tcl):

       <b>argc</b>           Contains a count of the number of <u>arg</u> arguments (0 if none), not including the name of the
                      script file.

       <b>argv</b>           Contains  a Tcl list whose elements are the <u>arg</u> arguments, in order, or an empty string if
                      there are no <u>arg</u> arguments.

       <b>argv0</b>          Contains <u>fileName</u> if it was specified.  Otherwise, contains the name by  which  <b>tclsh</b>  was
                      invoked.

       <b>tcl_interactive</b>
                      Contains 1 if <b>tclsh</b> is running interactively (no <u>fileName</u> was specified and standard input
                      is a terminal-like device), 0 otherwise.

</pre><h4><b>PROMPTS</b></h4><pre>
       When  <b>tclsh</b>  is invoked interactively it normally prompts for each command with “<b>%</b> ”.  You can change the
       prompt by setting the global variables <b>tcl_prompt1</b> and <b>tcl_prompt2</b>.  If variable <b>tcl_prompt1</b> exists  then
       it  must  consist of a Tcl script to output a prompt;  instead of outputting a prompt <b>tclsh</b> will evaluate
       the script in <b>tcl_prompt1</b>.  The variable <b>tcl_prompt2</b> is used in a similar way when a newline is typed but
       the current command is not yet complete; if  <b>tcl_prompt2</b>  is  not  set  then  no  prompt  is  output  for
       incomplete commands.

</pre><h4><b>STANDARD</b> <b>CHANNELS</b></h4><pre>
       See <b>Tcl_StandardChannels</b> for more explanations.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/auto_path.3tcl.html">auto_path</a>(3tcl), <a href="../man3tcl/encoding.3tcl.html">encoding</a>(3tcl), <a href="../man3tcl/env.3tcl.html">env</a>(3tcl), <a href="../man3tcl/fconfigure.3tcl.html">fconfigure</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       application, argument, interpreter, prompt, script file, shell

Tcl                                                                                                     <u><a href="../man1/tclsh.1.html">tclsh</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>