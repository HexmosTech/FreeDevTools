<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>eatmydata - transparently disable fsync() and other data-to-disk synchronization calls</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/eatmydata">eatmydata_131-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       eatmydata - transparently disable fsync() and other data-to-disk synchronization calls

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>eatmydata</b> [--] <u>command</u> [ <u>command</u> <u>arguments</u> ... ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>eatmydata</b>  runs  a  command  in  the  environment where data-to-disk synchronization calls (like fsync(),
       fdatasync(), sync(), msync() and open() O_SYNC /  O_DSYNC  flags)  have  no  effect.  LD_PRELOAD  library
       <b>libeatmydata</b>   overrides   respective   C   library  calls  with  custom  functions  that  don't  trigger
       synchronization but return success nevertheless.

       You may use <b>eatmydata</b> in  two  ways.  In  normal  mode,  just  execute  <b>eatmydata</b>  directly  and  pass  a
       command-to-be-run  and  its arguments via command line. In order to use symlink mode, create a symlink to
       <u><a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?eatmydata">/usr/bin/eatmydata</a></u> with the filename (a.k.a  basename)  of  another  program  in  the  PATH  and  execute
       <b>eatmydata</b>  via  that  symlink.  Then  <b>eatmydata</b>  will  find  that  program  in the PATH and run it in the
       libeatmydata environment repassing all command line options.

</pre><h4><b>OPTIONS</b></h4><pre>
       Please note that <b>eatmydata</b> does not process any command line options in symlink mode.  All  command  line
       options will be repassed to the underlying executable as-is.

       <u>command</u>
              The  command  to execute. It may be either a full path or the name of the command in PATH. In case
              command cannot be found in PATH, <b>eatmydata</b> will fail.

       <u>command</u> <u>arguments</u>
              Arbitrary number of arguments to pass to the command being executed.

       --     Optional command separator for compatibility with similar utilities. Ignored at the moment.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Given PATH is <a href="file:/usr/bin">/usr/bin</a> and both /usr/bin/aptitude and <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?eatmydata">/usr/bin/eatmydata</a> are installed, the following:

           $ ln -s <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?eatmydata">/usr/bin/eatmydata</a> ./aptitude
           $ ./aptitude moo

       is equivalent to:

           $ eatmydata -- aptitude moo

       Therefore, you may  use  symlink  mode  to  automatically  run  specific  programs  in  the  libeatmydata
       environment whenever you run them from PATH. For example, given standard PATH settings, just do:

           # ln -s <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?eatmydata">/usr/bin/eatmydata</a> /usr/local/bin/aptitude

       and enjoy sync-free aptitude system-wide.

</pre><h4><b>CAVEAT</b></h4><pre>
       When  using  <b>eatmydata</b>  with  <b>setarch</b>  (including  alias  such as <b>linux32</b>), or anyway with chroots with a
       different architectures than the host's, make sure to install the matching architecture of  <b>libeatmydata1</b>
       both in the <b>setarch</b> environment and host's.

       Trying  to  load  libeatmydata manually (without using the wrapper script) and using it through a chroot,
       especially if the eatmydata version differ between outside and inside, is probably going to fail  do  the
       different position of the library on the file system.
       The safest way to manually load libeatmydata is by setting the following two environment variables (shell
       syntax):

           LD_LIBRARY_PATH=${LD_LIBRARY_PATH:+"$LD_LIBRARY_PATH:"}/usr/lib/libeatmydata
           LD_PRELOAD=${LD_PRELOAD:+"$LD_PRELOAD "}libeatmydata.so

       These  two  variables  accounts  the  case of a Debian Jessie host with a Debian Wheezy chroot, where the
       position of the library changed.

                                                  November 2014                                     <u><a href="../man1/eatmydata.1.html">eatmydata</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>