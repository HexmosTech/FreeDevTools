<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>encfs - mounts or creates an encrypted virtual filesystem</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/encfs">encfs_1.9.5-2ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       encfs - mounts or creates an encrypted virtual filesystem

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>encfs</b> [<b>--version</b>] [<b>-v</b>|<b>--verbose</b>] [<b>-c</b>|<b>--config</b>] [<b>-t</b>|<b>--syslogtag</b>] [<b>-s</b>] [<b>-f</b>] [<b>--annotate</b>] [<b>--standard</b>]
       [<b>--paranoia</b>] [<b>--insecure</b>] [<b>--reverse</b>] [<b>--reversewrite</b>] [<b>--extpass=program</b>] [<b>-S</b>|<b>--stdinpass</b>] [<b>--anykey</b>]
       [<b>--forcedecode</b>] [<b>-require-macs</b>] [<b>-i</b> <b>MINUTES</b>|<b>--idle=MINUTES</b>] [<b>-m</b>|<b>--ondemand</b>] [<b>--delaymount</b>] [<b>-u</b>|<b>--unmount</b>]
       [<b>--public</b>] [<b>--nocache</b>] [<b>--noattrcache</b>] [<b>--nodatacache</b>] [<b>--no-default-flags</b>] [<b>-o</b> <b>FUSE_OPTION</b>]
       [<b>-d</b>|<b>--fuse-debug</b>] [<b>-H</b>|<b>--fuse-help</b>] <u>rootdir</u> <u>mountPoint</u> [<b>--</b> [<u>Fuse</u> <u>Mount</u> <u>Options</u>]]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>EncFS</b> creates a virtual encrypted filesystem which stores encrypted data in the <u>rootdir</u> directory and
       makes the unencrypted data visible at the <u>mountPoint</u> directory.  The user must supply a password which is
       used to (indirectly) encrypt both filenames and file contents.

       If <b>EncFS</b> is unable to find a supported filesystem at the specified <u>rootdir</u>, then the user will be asked
       if they wish to create a new encrypted filesystem at the specified location.  Options will be presented
       to the user allowing some control over the algorithms to use.  As <b>EncFS</b> matures, there may be an
       increasing number of choices.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>--version</b>
           Shows <b>EncFS</b> version.  Using <b>--verbose</b> before <b>--version</b> may display additional information.

       <b>-c</b>, <b>--config</b>
           Causes <b>EncFS</b> to use the supplied file as the configuration file.

       <b>-v</b>, <b>--verbose</b>
           Causes  <b>EncFS</b>  to  enable  logging  of  various  debug channels within <b>EncFS</b>.  Normally these logging
           messages are disabled and have no effect.  It is recommended that you run  in  foreground  (<b>-f</b>)  mode
           when running with verbose enabled.

       <b>-t</b>, <b>--syslogtag</b>
           This  option  allows to set the syslog tag which will be used when messages are logged via syslog. By
           default the syslog tag is set to <b>encfs</b>.

       <b>-s</b>  The <b>-s</b> (<u>single</u> <u>threaded</u>) option causes <b>EncFS</b> to run in single threaded mode.  By default, <b>EncFS</b>  runs
           in  multi-threaded mode.  This option is used during <b>EncFS</b> development in order to simplify debugging
           and allow it to run under memory checking tools.

       <b>-f</b>  The <b>-f</b> (<u>foreground</u>) option causes <b>EncFS</b> to run in the foreground.  Normally <b>EncFS</b>  spawns  off  as  a
           daemon  and  runs in the background, returning control to the spawning shell.  With the <b>-f</b> option, it
           will run in the foreground and any warning/debug log messages will be displayed  on  standard  error.
           In the default (background) mode, all log messages are logged via syslog.

       <b>--annotate</b>
           Print annotation lines to stderr during configuration.

       <b>--standard</b>
           If creating a new filesystem, this automatically selects standard configuration options, to help with
           automatic  filesystem  creation.  This is the set of options that should be used unless you know what
           you're doing and have read the documentation.

           When not creating a filesystem, this flag does nothing.

       <b>--paranoia</b>
           Same as <b>--standard</b>, but for <b>paranoia</b> mode.

       <b>--insecure</b>
           Allows you to disable data encoding, thus to pass plain data as is.  Fully discouraged of course!

       <b>--reverse</b>
           Normally <b>EncFS</b> provides a plaintext view of data on demand: it stores enciphered  data  and  displays
           plaintext  data.   With  <b>--reverse</b> it takes as source plaintext data and produces enciphered data on-
           demand.  This can be useful for creating remote encrypted backups, where you do not wish to keep  the
           local files unencrypted.

           For example, the following would create an encrypted view in /tmp/crypt-view.

               encfs --reverse /home/me /tmp/crypt-view

           You could then copy the /tmp/crypt-view directory in order to have a copy of the encrypted data.  You
           must  also  keep  a  copy of the file /home/me/.encfs6.xml which contains the filesystem information.
           Together, the two can be used to reproduce the unencrypted data:

               ENCFS6_CONFIG=/home/me/.encfs6.xml encfs /tmp/crypt-view /tmp/plain-view

           Now /tmp/plain-view contains the same data as /home/me

           Note that <b>--reverse</b> mode only works with limited configuration  options,  so  many  settings  may  be
           disabled  when  used.   Incompatible options as for now : Filename Initialization Vector Chaining and
           External IV Chaining.

       <b>--reversewrite</b>
           Same as <b>--reverse</b> but will allow writes, if possible (configuration  must  have  UniqueIV  disabled).
           Incompatible option : Per-File Initialization Vectors.

       <b>--extpass=program</b>
           Specify  an  external  program  to  use  for getting the user password.  When the external program is
           spawned, the environment variable "RootDir" will be set to contain the path to  the  root  directory.
           The program should print the password to standard output.

           <b>EncFS</b>  takes  everything  returned from the program to be the password, except for a trailing newline
           (\n) which will be removed.

           For example, specifying <b>--extpass</b>=<u>/usr/lib/ssh/ssh-askpass</u> will cause <b>EncFS</b>  to  use  ssh's  password
           prompt program.

           <b>Note</b>:  <b>EncFS</b> reads at most 2k of data from the password program, and it removes any trailing newline.
           Versions before 1.4.x accepted only 64 bytes of text.

       <b>-S</b>, <b>--stdinpass</b>
           Read password from standard input, without prompting.  This may be useful for scripting encfs mounts.

           Note that you should make sure the filesystem and mount points exist  first.   Otherwise  encfs  will
           prompt for the filesystem creation options, which may interfere with your script.

       <b>--anykey</b>
           Turn off key validation checking.  This allows <b>EncFS</b> to be used with secondary passwords.  This could
           be  used  to  store a separate set of files in an encrypted filesystem.  <b>EncFS</b> ignores files which do
           not decode properly, so files  created  with  separate  passwords  will  only  be  visible  when  the
           filesystem is mounted with their associated password.

           Note that if the primary password is changed (using <b>encfsctl</b>), the other passwords will not be usable
           unless  the  primary  password  is set back to what it was, as the other passwords rely on an invalid
           decoding of the volume key, which will not remain the same if the primary password is changed.

           <b>Warning</b>: Use this option at your own risk.

       <b>--forcedecode</b>
           This option only has an effect on filesystems which use MAC block headers.  By default, if a block is
           decoded and the stored MAC doesn't match what is calculated, then an IO  error  is  returned  to  the
           application  and the block is not returned.  However, by specifying <b>--forcedecode</b>, only an error will
           be logged and the data will still be returned to the application.  This may be useful for  attempting
           to read corrupted files.

       <b>--require-macs</b>
           If  creating  a  new  filesystem,  this forces block authentication code headers to be enabled.  When
           mounting an existing filesystem, this causes encfs to exit if block authentication code  headers  are
           not enabled.

           This can be used to improve security in case the ciphertext is vulnerable to tampering, by preventing
           an attacker from disabling MACs in the config file.

       <b>-i</b>, <b>--idle=MINUTES</b>
           Enable  automatic unmount of the filesystem after a period of inactivity.  The period is specified in
           minutes, so the shortest timeout period that  can  be  requested  is  one  minute.   <b>EncFS</b>  will  not
           automatically  unmount  if there are files open within the filesystem, even if they are open in read-
           only mode.  However simply having files open does not count as activity.

       <b>-m</b>, <b>--ondemand</b>
           Mount the filesystem on-demand.  This currently only makes  sense  in  combination  with  <b>--idle</b>  and
           <b>--extpass</b> options.  When the filesystem becomes idle, instead of exiting, <b>EncFS</b> stops allowing access
           to  the  filesystem  by  internally  dropping its reference to it.  If someone attempts to access the
           filesystem again, the extpass program is used to prompt the user for the password.  If this succeeds,
           then the filesystem becomes available again.

       <b>--delaymount</b>
           Do not mount the filesystem when encfs starts; instead, delay mounting until first use.  This  option
           only makes sense with <b>--ondemand</b>.

       <b>-u</b>, <b>--unmount</b>
           Unmounts the specified <u>mountPoint</u>.

       <b>--public</b>
           Attempt  to  make  encfs  behave  as  a  typical  multi-user  filesystem.  By default, all FUSE based
           filesystems are visible only to the user who mounted them.  No other users (including root) can  view
           the  filesystem contents.  The <b>--public</b> option does two things.  It adds the FUSE flags "allow_other"
           and "default_permission" when mounting the filesystem, which tells  FUSE  to  allow  other  users  to
           access  the  filesystem,  and to use the ownership permissions provided by the filesystem.  Secondly,
           the <b>--public</b> flag changes how encfs's node creation functions  work  -  as  they  will  try  and  set
           ownership of new nodes based on the caller identification.

           <b>Warning</b>:  In  order  for  this  to  work, encfs must be run as root -- otherwise it will not have the
           ability to change ownership of  files.   I  recommend  that  you  instead  investigate  if  the  fuse
           allow_other option can be used to do what you want before considering the use of <b>--public</b>.

       <b>--nocache</b>
           Disable the kernel's cache of file attributes.  Setting this option makes EncFS pass "attr_timeout=0"
           and "entry_timeout=0" to FUSE. This makes sure that modifications to the backing file attributes that
           occour  outside  EncFS  show up immediately in the EncFS mount. The internal EncFS data cache is also
           disabled. The main use case for <b>--nocache</b> is reverse mode.

       <b>--noattrcache</b>
           Same as <b>--nocache</b> but for attributes only.

       <b>--nodatacache</b>
           Same as <b>--nocache</b> but for data only.

       <b>--no-default-flags</b>
           <b>Encfs</b> adds the FUSE flags "use_ino" and  "default_permissions"  by  default,  as  of  version  1.2.2,
           because  that  improves compatibility with some programs.  If for some reason you need to disable one
           or both of these flags, use the option <b>--no-default-flags</b>.

           The following command lines produce the same result:

               encfs raw crypt
               encfs --no-default-flags raw crypt -- -o use_ino,default_permissions

       <b>-o</b> <b>FUSE_ARG</b>
           Pass through <b>FUSE</b> args to the underlying library.  This makes it  easy  to  pass  FUSE  options  when
           mounting <b>EncFS</b> via mount (and <a href="file:/etc/fstab">/etc/fstab</a>).  Eg:

               mount encfs#/home/me-crypt /home/me -t fuse -o kernel_cache

           Note  that  encfs  arguments  cannot  be  set this way.  If you need to set encfs arguments, create a
           wrapper, such as  encfs-reverse;

               #!<a href="file:/bin/sh">/bin/sh</a>
               encfs --reverse "$@"

           Then mount using the script path

               mount encfs-reverse#/home/me /home/me-crypt -t fuse

       <b>-d</b>, <b>--fuse-debug</b>
           Enables debugging within the <b>FUSE</b> library.  This should only be used if you suspect a problem  within
           <b>FUSE</b> itself (not <b>EncFS</b>), as it generates a lot of low-level data and is not likely to be very helpful
           in general problem tracking.  Try <u>verbose</u> mode (<b>-v</b>) first, which gives a higher level view of what is
           happening within <b>EncFS</b>.

       <b>-H</b>, <b>--fuse-help</b>
           Shows <b>FUSE</b> help.

       <b>--</b>  The <b>--</b> option tells <b>EncFS</b> to send any remaining arguments directly to <b>FUSE</b>.  In turn, <b>FUSE</b> passes the
           arguments to <b>fusermount</b>.  See the <b>fusermount</b> help page for information on available commands.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       <b>ENCFS6_CONFIG</b>
           Which config file (typically named .encfs6.xml) to use.  By default, the config file is read from the
           encrypted  directory.  Using this option allows to store the config file separated from the encrypted
           files.

           Warning: If you lose the config file, the encrypted file contents are irrecoverably lost. It contains
           the master key encrypted with your password. Without the master key, recovery is impossible, even  if
           you know the password.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Create  a  new  encrypted  filesystem.   Store  the  raw  (encrypted)  data  in "<a href="file:~/.crypt">~/.crypt</a>" , and make the
       unencrypted data visible in "<a href="file:~/crypt">~/crypt</a>".  Both directories are in the home directory in this example.  This
       example shows the full output of encfs as it asks the user if they wish to create the filesystem:

           % encfs <a href="file:~/.crypt">~/.crypt</a> <a href="file:~/crypt">~/crypt</a>
           Directory "/home/me/.crypt" does not exist, create (y,n)?y
           Directory "/home/me/crypt" does not exist, create (y,n)?y
           Creating new encrypted volume.
           Please choose from one of the following options:
            enter "x" for expert configuration mode,
            enter "p" for pre-configured paranoia mode,
            anything else, or an empty line will select standard mode.
           ?&gt;

           Standard configuration selected.
           Using cipher Blowfish, key size 160, block size 512
           New Password: &lt;password entered here&gt;
           Verify: &lt;password entered here&gt;

       The filesystem is now mounted and visible in <u><a href="file:~/crypt">~/crypt</a></u>.  If files are created there, they can  be  seen  in
       encrypted form in <u><a href="file:~/.crypt">~/.crypt</a></u>.  To unmount the filesystem, use <u>fusermount</u> with the <b>-u</b> (unmount) option:

           % fusermount -u <a href="file:~/crypt">~/crypt</a>

       Another  example.   To mount the same filesystem, but have fusermount name the mount point '/dev/foo' (as
       shown in <u>df</u> and other tools which read <a href="file:/etc/mtab">/etc/mtab</a>), and also request kernel-level  caching  of  file  data
       (which are both special arguments to fusermount):

           % encfs <a href="file:~/.crypt">~/.crypt</a> <a href="file:~/crypt">~/crypt</a> -- -n /dev/foo -c

       Or,  if  you find strange behavior under some particular program when working in an encrypted filesystem,
       it may be helpful to run in verbose mode while reproducing the problem and send along the output with the
       problem report:

           % encfs -v -f <a href="file:~/.crypt">~/.crypt</a> <a href="file:~/crypt">~/crypt</a> 2&gt; encfs-report.txt

       In order to avoid leaking sensitive information through the debugging channels, all  warnings  and  debug
       messages  (as  output  in  verbose  mode)  contain  only  encrypted  filenames.  You can use the <u>encfsctl</u>
       program's <u>decode</u> function to decode filenames if desired.

</pre><h4><b>CAVEATS</b></h4><pre>
       <b>EncFS</b> is not a true filesystem.  It does not deal with any of the actual storage or maintenance of files.
       It simply translates requests (encrypting or decrypting as necessary) and passes the requests through  to
       the  underlying  host  filesystem.  Therefore any limitations of the host filesystem will be inherited by
       <b>EncFS</b> (or possibly be further limited).

       One such limitation is filename length.  If your underlying filesystem limits you to N  characters  in  a
       filename,  then  <b>EncFS</b>  will  limit  you  to approximately 3*(N-2)/4.  For example if the host filesystem
       limits to 255 characters, then <b>EncFS</b> will be  limited  to  189  character  filenames.   This  is  because
       encrypted filenames are always longer than plaintext filenames.

</pre><h4><b>FILESYSTEM</b> <b>OPTIONS</b></h4><pre>
       When  <b>EncFS</b>  is  given a root directory which does not contain an existing <b>EncFS</b> filesystem, it will give
       the option to create one.  Note that options can only be set at filesystem creation time.   There  is  no
       support for modifying a filesystem's options in-place.

       If  you  want to upgrade a filesystem to use newer features, then you need to create a new filesystem and
       mount both the old filesystem and new filesystem at the same time and copy the old to the new.

       Multiple instances of encfs can be run at the same time, including different versions of encfs,  as  long
       as they are compatible with the current FUSE module on your system.

       A  choice  is  provided for two pre-configured settings ('standard' and 'paranoia'), along with an expert
       configuration mode.

       <u>Standard</u> mode uses the following settings:
           Cipher: AES
           Key Size: 192 bits
           PBKDF2 with 1/2 second runtime, 160 bit salt
           Filesystem Block Size: 1024 bytes
           Filename Encoding: Block encoding with IV chaining
           Unique initialization vector file headers
           File holes passed through

       <u>Paranoia</u> mode uses the following settings:
           Cipher: AES
           Key Size: 256 bits
           PBKDF2 with 3 second runtime, 160 bit salt
           Filesystem Block Size: 1024 bytes
           Filename Encoding: Block encoding with IV chaining
           Unique initialization vector file headers
           Message Authentication Code block headers
           External IV Chaining
           File holes passed through

       In the expert / manual configuration mode, each of the above options is configurable.  Here is a list  of
       current options with some notes about what they mean:

</pre><h4><b>Key</b> <b>Derivation</b> <b>Function</b></h4><pre>
       As  of  version  1.5,  <b>EncFS</b>  now  uses  PBKDF2  as  the  default key derivation function.  The number of
       iterations in the keying function is selected based on wall clock time to generate the key.  In  standard
       mode, a target time of 0.5 seconds is used, and in paranoia mode a target of 3.0 seconds is used.

       On a 1.6Ghz AMD 64 system, roughly 64k iterations of the key derivation function can be handled in half a
       second.   The  exact  number of iterations to use is stored in the configuration file, as it is needed to
       remount the filesystem.

       If an <b>EncFS</b> filesystem configuration from 1.4.x is modified with version 1.5 (such as when using encfsctl
       to change the password), then the new PBKDF2 function will be used and the filesystem will no  longer  be
       readable by older versions.

       <u>Cipher</u>
           Which  encryption  algorithm  to  use.   The  list is generated automatically based on what supported
           algorithms <b>EncFS</b> found in the encryption libraries.  When using a recent version of <b>OpenSSL</b>, Blowfish
           and AES are the typical options.

           Blowfish is an 8 byte cipher - encoding 8 bytes at a time.  AES is a 16 byte cipher.

       <u>Cipher</u> <u>Key</u> <u>Size</u>
           Many, if not all, of the supported ciphers support multiple key lengths.  There is  not  really  much
           need to have enormous key lengths.  Even 160 bits (the default) is probably overkill.

       <u>Filesystem</u> <u>Block</u> <u>Size</u>
           This  is  the  size  (in  bytes)  that  <b>EncFS</b>  deals  with  at  one  time.   Each  block gets its own
           initialization vector and is encoded in the cipher's cipher-block-chaining mode.  A partial block  at
           the end of a file is encoded using a stream mode to avoid having to store the filesize somewhere.

           Having  larger  block  sizes  reduces the overhead of <b>EncFS</b> a little, but it can also add overhead if
           your programs read small parts of files.  In order to read a single byte  from  a  file,  the  entire
           block  that contains that byte must be read and decoded, so a large block size adds overhead to small
           requests.  With write calls it is even worse, as a block must be read and decoded, the change applied
           and the block encoded and written back out.

           The default is 512 bytes as of version 1.0.  It was hard coded to 64 bytes in version 0.x, which  was
           not as efficient as the current setting for general usage.

       <u>Filename</u> <u>Encoding</u>
           <b>New</b>  <b>in</b> <b>1.1</b>. A choice is given between stream encoding of filename and block encoding.  The advantage
           of stream encoding is that the encoded filenames will be  as  short  as  possible.   If  you  have  a
           filename  with  a  single  letter,  it will be very short in the encoded form, where as block encoded
           filenames are always rounded up to the block size of the encryption cipher (8 bytes for Blowfish  and
           16 bytes for AES).

           The  advantage  of  block  encoding  mode  is that filename lengths all come out as a multiple of the
           cipher block size.  This means that someone looking at your encrypted data can't tell as  much  about
           the length of your filenames.  It is on by default, as it takes a similar amount of time to using the
           stream  cipher.  However stream cipher mode may be useful if you want shorter encrypted filenames for
           some reason.

           Based on an underlying filesystem supporting a maximum of 255 characters in filenames,  here  is  the
           maximum  possible  filename  length  depending  on  the choosen encoding scheme : stream (189), block
           (176), block32 (143). Note that we should rather talk about bytes,  when  filenames  contain  special
           (multi-bytes) characters.

           Prior to version 1.1, only stream encoding was supported.

       <u>Filename</u> <u>Initialization</u> <u>Vector</u> <u>Chaining</u>
           <b>New</b>  <b>in</b>  <b>1.1</b>.  In previous versions of <b>EncFS</b>, each filename element in a path was encoded separately.
           So if "foo" encoded to "XXX", then it would always encode that way (given the same  encryption  key),
           no  matter  if  the  path was "a/b/foo", or "aa/foo/cc", etc.  That meant it was possible for someone
           looking at the encrypted data to see if two files in different directories had the  same  name,  even
           though they wouldn't know what that name decoded to.

           With  initialization  vector chaining, each directory gets its own initialization vector.  So "a/foo"
           and "b/foo" will have completely different encoded names for "foo".   This  features  has  almost  no
           performance impact (for most operations), and so is the default in all modes.

           <b>Note:</b>  One  significant  performance exception is directory renames.  Since the initialization vector
           for filename encoding depends on the directory path, any rename requires re-encoding  every  filename
           in the tree of the directory being changed.  If there are thousands of files, then EncFS will have to
           do  thousands  of  renames.  It may also be possible that EncFS will come across a file that it can't
           decode or doesn't have permission to move during the rename operation, in which case it will  attempt
           to undo any changes it made up to that point and the rename will fail.

       <u>Per-File</u> <u>Initialization</u> <u>Vectors</u>
           <b>New</b>  <b>in</b>  <b>1.1</b>.  In previous versions of <b>EncFS</b>, each file was encoded in the same way.  Each block in a
           file has always had its own initialization vector, but in a deterministic way, so that block N in one
           file was encoded in the same way as block N in another file.  That made it possible  for  someone  to
           tell if two files were identical (or parts of the file were identical) by comparing the encoded data.

           With  per-file initialization vectors, each file gets its own 64-bit random initialization vector, so
           that each file is encrypted in a different way.

           This option is enabled by default.

           Reverse mode derivates IV from inode number, it may then change for example  when  source  files  are
           copied from one FS to another.

       <u>External</u> <u>IV</u> <u>Chaining</u>
           <b>New</b>  <b>in</b>  <b>1.1.3</b>.   This  option  is  closely  related  to Per-File Initialization Vectors and Filename
           Initialization Vector Chaining.   Basically  it  extends  the  initialization  vector  chaining  from
           filenames to the per-file initialization vector.

           When  this  option is enabled, the per-file initialization vector is encoded using the initialization
           vector derived from the filename initialization vector chaining code.  This means that the data in  a
           file  becomes  tied  to  the  filename.  If an encrypted file is renamed outside of encfs, it will no
           longer be decodable within encfs.  Note that unless Block MAC headers are enabled, the decoding error
           will not be detected and will result in reading random looking data.

           There is a cost associated with this.  When External IV Chaining is enabled, hard links will  not  be
           allowed  within  the  filesystem, as there would be no way to properly decode two different filenames
           pointing to the same data.

           Also, renaming a file requires modifying the file header.  So renames will only be allowed  when  the
           user has write access to the file.

           Because of these limits, this option is disabled by default for standard mode (and enabled by default
           for paranoia mode).

           This  option  may  be  incompatible  with  some  cloud  providers, as during a rename, file's content
           changes, but not its timestamp. Due to this, file's  changes  may  no  be  correctly  seen  by  cloud
           providers' sync programs. It is then not recommended for cloud usage.

       <u>Block</u> <u>MAC</u> <u>headers</u>
           <b>New</b>  <b>to</b>  <b>1.1</b>.   If  this  is  enabled, every block in every file is stored along with a cryptographic
           checksum (Message Authentication Code).  This makes it virtually impossible to modify a file  without
           the change being detected by <b>EncFS</b>.  <b>EncFS</b> will refuse to read data which does not pass the checksum,
           and will log the error and return an IO error to the application.

           This  adds  substantial  overhead  (default  being  8 bytes per filesystem block), plus computational
           overhead, and is not enabled by default except in paranoia mode.

           When this is not enabled and if <b>EncFS</b> is asked to read modified or corrupted data, it  will  have  no
           way to verify that the decoded data is what was originally encoded.

       <u>File-hole</u> <u>pass-through</u>
           Make  encfs  leave  holes in files.  If a block is read as all zeros, it will be assumed to be a hole
           and will be left as 0's when read (not deciphered).  This is required if accessing  encfs  using  the
           SMB protocol.

           Enabled by default.  Can be disabled in expert mode.

</pre><h4><b>Attacks</b></h4><pre>
       The  primary  goal  of  <b>EncFS</b>  is to protect data off-line.  That is, provide a convenient way of storing
       files in a way that will frustrate any attempt to read them if the files are later intercepted.

       Some algorithms in <b>EncFS</b> are also meant to frustrate on-line attacks where an attacker is assumed  to  be
       able to modify the files.

       The  most  intrusive  attacks,  where  an  attacker  has  complete control of the user's machine (and can
       therefore modify <b>EncFS</b>, or <b>FUSE</b>, or the kernel itself) are not  guarded  against.   Do  not  assume  that
       encrypted  files will protect your sensitive data if you enter your password into a compromised computer.
       How you determine that the computer is safe to use is beyond the scope of this documentation.

       That said, here are some example attacks and data gathering techniques on the filesystem  contents  along
       with the algorithms <b>EncFS</b> supports to thwart them:

       <b>Attack</b>: modifying a few bytes of an encrypted file (without knowing what they will decode to).
           <b>EncFS</b>  does  not use any form of XOR encryption which would allow single bytes to be modified without
           affecting others.  Most modifications would affect dozens or more  bytes.   Additionally,  MAC  Block
           headers can be used to identify any changes to files.

       <b>Attack</b>: copying a random block of one file to a random block of another file.
           Each block has its own [deterministic] initialization vector.

       <b>Attack</b>: copying block N to block N of another file.
           When  the  Per-File Initialization Vector support is enabled (default in 1.1.x filesystems), a copied
           block will not decode properly when copied to another file.

       <b>Attack</b>: copying an entire file to another file.
           Can be prevented by enabling External IV Chaining mode.

       <b>Attack</b>: determine if two filenames are the same by looking at encrypted names.
           Filename Initialization Vector chaining prevents this by giving each  file  a  64-bit  initialization
           vector derived from its full path name.

       <b>Attack</b>: compare if two files contain the same data.
           Per-File Initialization Vector support prevents this.

</pre><h4><b>DISCLAIMER</b></h4><pre>
       This  library  is  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS  FOR  A  PARTICULAR  PURPOSE.   Please  refer  to  the
       "COPYING" file distributed with <b>EncFS</b> for complete details.

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>EncFS</b> was written by <b>Valient</b> <b>Gough</b> <b>&lt;<a href="mailto:vgough@pobox.com">vgough@pobox.com</a>&gt;</b>.

       Site : <b>https://vgough.github.io/encfs/</b>.

       Support, bug reports... : <b>https://github.com/vgough/encfs</b>.

       Mailing list : none.

       Cygwin, Windows ports : <b>https://github.com/vgough/encfs/wiki</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/encfsctl.1.html">encfsctl</a></b>(1)

1.9.5                                              2024-04-01                                           <u><a href="../man1/ENCFS.1.html">ENCFS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>