<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>blkparse - produce formatted output of event streams of block devices</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/blktrace">blktrace_1.2.0-5ubuntu4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       blkparse - produce formatted output of event streams of block devices

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>blkparse</b> <b>[</b> <u>options</u> ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>blkparse</u>  utility will attempt to combine streams of events for various devices on various CPUs, and
       produce a formatted output of the event information.  Specifically, it will take  the  (machine-readable)
       output of the <u>blktrace</u> utility and convert it to a nicely formatted and human-readable form.

       As  with  <u>blktrace</u>,  some details concerning <u>blkparse</u> will help in understanding the command line options
       presented below.

       - By default, <u>blkparse</u> expects to run in a post-processing mode; one where the  trace  events  have  been
         saved  by  a  previous  run  of blktrace, and blkparse is combining event streams and dumping formatted
         data.

         blkparse may be run in a live manner concurrently with blktrace by specifying <b>-i</b>  <b>-</b>  to  blkparse,  and
         combining it with the live option for blktrace.  An example would be:

            % blktrace -d /dev/sda -o - | blkparse -i -

       - You can set how many blkparse batches event reads via the <b>-b</b> option, the default is to handle events in
         batches of 512.

       - If you have saved event traces in blktrace with different output names (via the <b>-o</b> option to blktrace),
         you must specify the same input name via the <b>-i</b> option.

       - The  format of the output data can be controlled via the <b>-f</b> or <b>-F</b> options -- see OUTPUT DESCRIPTION AND
         FORMATTING for details.

       By default, blkparse sends formatted data to standard output. This may be changed via the <b>-o</b>  option,  or
       text  output  can  be  disabled  via  the  <b>-O</b> option. A merged binary stream can be produced using the <b>-d</b>
       option.

</pre><h4><b>OPTIONS</b></h4><pre>
       -A <u>hex-mask</u>
       --set-mask=<u>hex-mask</u>
              Set filter mask to <u>hex-mask</u>, see blktrace (8) for masks

       -a <u>mask</u>
       --act-mask=<u>mask</u>
              Add <u>mask</u> to current filter, see blktrace (8) for masks

       -D <u>dir</u>
       --input-directory=<u>dir</u>
              Prepend <u>dir</u> to input file names

       -b <u>batch</u>
       --batch={batch}
              Standard input read batching

       -i <u>file</u>
       --input=<u>file</u>
              Specifies base name for input files -- default is <u>device</u>.blktrace.<u>cpu</u>.

              As noted above, specifying <b>-i</b> <b>-</b> runs in live mode with blktrace (reading data from standard in).

       -F <u>typ,fmt</u>
       --format=<u>typ,fmt</u>
       -f <u>fmt</u>
       --format-spec=<u>fmt</u>
              Sets output format (See OUTPUT DESCRIPTION AND FORMATTING for details.)

              The -f form specifies a format for all events

              The -F form allows one to specify a format for a specific event  type.  The  single-character  <u>typ</u>
              field is one of the action specifiers described in ACTION IDENTIFIERS.

       -M
       --no-msgs
              When -d is specified, this will stop messages from being output to the file. (Can seriously reduce
              the size of the resultant file when using the CFQ I/O scheduler.)

       -h
       --hash-by-name
              Hash processes by name, not by PID

       -o <u>file</u>
       --output=<u>file</u>
              Output file

       -O
       --no-text-output
              Do <u>not</u> produce text output, used for binary (<b>-d</b>) only

       -d <u>file</u>
       --dump-binary=<u>file</u>
              Binary output file

       -q
       --quiet
              Quiet mode

       -s
       --per-program-stats
              Displays data sorted by program

       -t
       --track-ios
              Display time deltas per IO

       -w <u>span</u>
       --stopwatch=<u>span</u>
              Display traces for the <u>span</u> specified -- where span can be:
              <u>end-time</u> -- Display traces from time 0 through <u>end-time</u> (in ns)
              or
              <u>start:end-time</u> -- Display traces from time <u>start</u> through end-time (in ns).

       -v
       --verbose
              More verbose marginal on marginal errors

       -V
       --version
              Display version

</pre><h4><b>TRACE</b> <b>ACTIONS</b></h4><pre>
       The following trace actions are recognised:

       <b>C</b> <b>--</b> <b>complete</b> A previously issued request has been completed.  The output will detail the sector and size
           of that request, as well as the success or failure of it.

       <b>D</b>  <b>--</b>  <b>issued</b> A request that previously resided on the block layer queue or in the i/o scheduler has been
           sent to the driver.

       <b>I</b> <b>--</b> <b>inserted</b> A request is being sent to the i/o scheduler for addition to the internal queue  and  later
           service by the driver. The request is fully formed at this time.

       <b>Q</b> <b>--</b> <b>queued</b> This notes intent to queue i/o at the given location.  No real requests exists yet.

       <b>B</b> <b>--</b> <b>bounced</b> The data pages attached to this <u>bio</u> are not reachable by the hardware and must be bounced to
           a lower memory location. This causes a big slowdown in i/o performance, since the data must be copied
           to/from  kernel  buffers. Usually this can be fixed with using better hardware -- either a better i/o
           controller, or a platform with an IOMMU.

       <b>M</b> <b>--</b> <b>back</b> <b>merge</b> A previously inserted request exists that ends on the boundary of where this i/o  begins,
           so the i/o scheduler can merge them together.

       <b>F</b>  <b>--</b>  <b>front</b>  <b>merge</b>  Same  as  the  back merge, except this i/o ends where a previously inserted requests
           starts.

       <b>M</b> <b>--</b> <b>front</b> <b>or</b> <b>back</b> <b>merge</b> One of the above

       <b>M</b> <b>--</b> <b>front</b> <b>or</b> <b>back</b> <b>merge</b> One of the above.

       <b>G</b> <b>--</b> <b>get</b> <b>request</b> To send any type of request to a block  device,  a  <u>struct</u>  <u>request</u>  container  must  be
           allocated first.

       <b>S</b> <b>--</b> <b>sleep</b> No available request structures were available, so the issuer has to wait for one to be freed.

       <b>P</b>  <b>--</b>  <b>plug</b>  When  i/o  is  queued to a previously empty block device queue, Linux will plug the queue in
           anticipation of future ios being added before this data is needed.

       <b>U</b> <b>--</b> <b>unplug</b> Some request data already queued in the device, start sending requests to  the  driver.  This
           may  happen  automatically if a timeout period has passed (see next entry) or if a number of requests
           have been added to the queue.

       <b>T</b> <b>--</b> <b>unplug</b> <b>due</b> <b>to</b> <b>timer</b> If nobody requests the i/o that was queued after plugging the queue, Linux  will
           automatically unplug it after a defined period has passed.

       <b>X</b>  <b>--</b>  <b>split</b>  On raid or device mapper setups, an incoming i/o may straddle a device or internal zone and
           needs to be chopped up into smaller pieces for service. This may indicate a performance  problem  due
           to a bad setup of that raid/dm device, but may also just be part of normal boundary conditions. dm is
           notably bad at this and will clone lots of i/o.

       <b>A</b>  <b>--</b>  <b>remap</b> For stacked devices, incoming i/o is remapped to device below it in the i/o stack. The remap
           action details what exactly is being remapped to what.

</pre><h4><b>OUTPUT</b> <b>DESCRIPTION</b> <b>AND</b> <b>FORMATTING</b></h4><pre>
       The output from blkparse can be tailored for specific use -- in particular, to ease  parsing  of  output,
       and/or  limit  output  fields  to  those  the  user wants to see. The data for fields which can be output
       include:

       <b>a</b>   Action, a (small) string (1 or 2 characters) -- see table below for more details

       <b>c</b>   CPU id

       <b>C</b>   Command

       <b>d</b>   RWBS field, a (small) string (1-3 characters)  -- see section below for more details

       <b>D</b>   7-character string containing the major and minor numbers of  the  event's  device  (separated  by  a
           comma).

       <b>e</b>   Error value

       <b>m</b>   Minor number of event's device.

       <b>M</b>   Major number of event's device.

       <b>n</b>   Number of blocks

       <b>N</b>   Number of bytes

       <b>p</b>   Process ID

       <b>P</b>   Display packet data -- series of hexadecimal values

       <b>s</b>   Sequence numbers

       <b>S</b>   Sector number

       <b>t</b>   Time stamp (nanoseconds)

       <b>T</b>   Time stamp (seconds)

       <b>u</b>   Elapsed value in microseconds (<u>-t</u> command line option)

       <b>U</b>   Payload unsigned integer

       Note  that  the user can optionally specify field display width, and optionally a left-aligned specifier.
       These precede field specifiers, with a '%' character, followed by the optional  left-alignment  specifier
       (-) followed by the width (a decimal number) and then the field.

       Thus, to specify the command in a 12-character field that is left aligned:

           -f "%-12C"

</pre><h4><b>ACTION</b> <b>IDENTIFIERS</b></h4><pre>
       The following table shows the various actions which may be output:

       A      IO was remapped to a different device

       B      IO bounced

       C      IO completion

       D      IO issued to driver

       F      IO front merged with request on queue

       G      Get request

       I      IO inserted onto request queue

       M      IO back merged with request on queue

       P      Plug request

       Q      IO handled by request queue code

       S      Sleep request

       T      Unplug due to timeout

       U      Unplug request

       X      Split

</pre><h4><b>RWBS</b> <b>DESCRIPTION</b></h4><pre>
       This  is  a small string containing at least one character ('R' for read, 'W' for write, or 'D' for block
       discard operation), and optionally either  a  'B'  (for  barrier  operations)  or  'S'  (for  synchronous
       operations).

</pre><h4><b>DEFAULT</b> <b>OUTPUT</b></h4><pre>
       The standard header (or initial fields displayed) include:

           "%D %2c %8s %5T.%9t %5p %2a %3d"

       Breaking this down:

       <b>%D</b>     Displays the event's device major/minor as: %3d,%-3d.

       <b>%2c</b>    CPU ID (2-character field).

       <b>%8s</b>    Sequence number

       <b>%5T.%9t</b>
              5-character  field  for  the  seconds  portion  of  the time stamp and a 9-character field for the
              nanoseconds in the time stamp.

       <b>%5p</b>    5-character field for the process ID.

       <b>%2a</b>    2-character field for one of the actions.

       <b>%3d</b>    3-character field for the RWBS data.

              Seeing this in action:

                  8,0    3        1     0.000000000   697  G   W 223490 + 8 [kjournald]

              The header is the data in this line up to the 223490 (starting block).  The default output for all
              event types includes this header.

</pre><h4><b>DEFAULT</b> <b>OUTPUT</b> <b>PER</b> <b>ACTION</b></h4><pre>
       <b>C</b> <b>--</b> <b>complete</b>
           If a payload is present, this is presented between parenthesis following the header, followed by  the
           error value.

           If no payload is present, the sector and number of blocks are presented (with an intervening plus (+)
           character). If the <b>-t</b> option was specified, then the elapsed time is presented. In either case, it is
           followed by the error value for the completion.

       <b>B</b> <b>--</b> <b>bounced</b>
       <b>D</b> <b>--</b> <b>issued</b>
       <b>I</b> <b>--</b> <b>inserted</b>
       <b>Q</b> <b>--</b> <b>queued</b>
           If  a  payload  is  present,  the  number  of  payload  bytes  is  output, followed by the payload in
           hexadecimal between parenthesis.

           If no payload is present, the sector and number of blocks are presented (with an intervening plus (+)
           character). If the <b>-t</b> option was specified, then the elapsed time is presented (in  parenthesis).  In
           either case, it is followed by the command associated with the event (surrounded by square brackets).

       <b>F</b> <b>--</b> <b>front</b> <b>merge</b>
       <b>G</b> <b>--</b> <b>get</b> <b>request</b>
       <b>M</b> <b>--</b> <b>back</b> <b>merge</b>
       <b>S</b> <b>--</b> <b>sleep</b>
           The starting sector and number of blocks is output (with an intervening plus (+) character), followed
           by the command associated with the event (surrounded by square brackets).

       <b>P</b> <b>--</b> <b>plug</b>
           The command associated with the event (surrounded by square brackets) is output.

       <b>U</b> <b>--</b> <b>unplug</b>
       <b>T</b> <b>--</b> <b>unplug</b> <b>due</b> <b>to</b> <b>timer</b>
           The  command  associated  with  the  event (surrounded by square brackets) is output, followed by the
           number of requests outstanding.

       <b>X</b> <b>--</b> <b>split</b>
           The original starting sector followed by the new sector (separated by a slash (/) is output, followed
           by the command associated with the event (surrounded by square brackets).

       <b>A</b> <b>--</b> <b>remap</b>
           Sector and length is output, along with the original device and sector offset.

</pre><h4><b>EXAMPLES</b></h4><pre>
       To trace the i/o on the device <u>/dev/sda</u> <b>and</b> <b>parse</b> <b>the</b> <b>output</b> <b>to</b> <b>human</b> <b>readable</b> <b>form,</b>  <b>use</b>  <b>the</b>  <b>following</b>
       <b>command:</b>

           <b>%</b> <b>blktrace</b> <b>-d</b> <b>/dev/sda</b> <b>-o</b> <b>-</b> <b>|</b> <b>blkparse</b> <b>-i</b> <b>-</b>

       <b>(see</b>  <u>blktrace</u> (8) for more information).  This same behaviour can be achieve with the convenience script
       <u>btrace</u>.  The command

           % btrace /dev/sda

       has exactly the same effect as the previous command. See <u>btrace</u> (8) for more information.

       To trace the i/o on a device and save the output for later processing with <u>blkparse</u>,  use  <u>blktrace</u>  like
       this:

           % blktrace /dev/sda /dev/sdb

       This  will  trace i/o on the devices <u>/dev/sda</u> and <u>/dev/sdb</u> and save the recorded information in the files
       <u>sda</u> and <u>sdb</u> in  the  current  directory,  for  the  two  different  devices,  respectively.   This  trace
       information can later be parsed by the <u>blkparse</u> utility:

           % blkparse sda sdb

       which will output the previously recorded tracing information in human readable form to stdout.

</pre><h4><b>AUTHORS</b></h4><pre>
       <u>blkparse</u>  was  written  by Jens Axboe, Alan D. Brunelle and Nathan Scott.  This man page was created from
       the <u>blktrace</u> documentation by Bas Zoetekouw.

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<a href="mailto:linux-btrace@vger.kernel.org">linux-btrace@vger.kernel.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2006 Jens Axboe, Alan D. Brunelle and Nathan Scott.
       This is free software.  You may redistribute copies of it under the  terms  of  the  GNU  General  Public
       License &lt;<a href="http://www.gnu.org/licenses/gpl.html">http://www.gnu.org/licenses/gpl.html</a>&gt;.  There is NO WARRANTY, to the extent permitted by law.
       This manual page was created for Debian by Bas Zoetekouw.  It was derived from the documentation provided
       by  the  authors  and  it may be used, distributed and modified under the terms of the GNU General Public
       License, version 2.
       On   Debian   systems,   the   text   of   the   GNU   General   Public   License   can   be   found   in
       /usr/share/common-licenses/GPL-2.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       btrace (8), blktrace (8), verify_blkparse (1), blkrawverify (1), btt (1)

blktrace git-20070306202522                      March  6, 2007                                      <u><a href="../man1/BLKPARSE.1.html">BLKPARSE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>