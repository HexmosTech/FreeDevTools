<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>srec_input - input file specifications</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/srecord">srecord_1.64-4.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       srec_input - input file specifications

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>srec_*</b> <u>filename</u> [ <u>format</u> ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  manual  page  describes  the  input  file  specifications  for  the  <u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1),  <u><a href="../man1/srec_cmp.1.html">srec_cmp</a></u>(1)  and
       <u><a href="../man1/srec_info.1.html">srec_info</a></u>(1) commands.

       Input files may be qualified in a number of ways: you may  specify  their  format  and  you  may  specify
       filters to apply to them.  An input file specification looks like this:
              <u>filename</u> [ <u>format</u> ][ -ignore‐checksums ][ <u>filter</u> ... ]

       The  <u>filename</u>  may  be  specified as a file name, or the special name “-” which is understood to mean the
       standard input.

   <b>Grouping</b> <b>with</b> <b>Parentheses</b>
       There are some cases where operator precedence of the filters can be ambiguous.  Input specifications may
       also be enclosed by <b>(</b> parentheses <b>)</b> to make grouping explicit.  Remember that  the  parentheses  must  be
       separate  words,  <u>i.e.</u> surrounded by spaces, and they will need to be quoted to get them past the shell's
       interpretation of parentheses.

   <b>Those</b> <b>Option</b> <b>Names</b> <b>Sure</b> <b>Are</b> <b>Long</b>
       All options may be abbreviated; the abbreviation is documented as the upper case letters, all lower  case
       letters and underscores (_) are optional.  You must use consecutive sequences of optional letters.

       All options are case insensitive, you may type them in upper case or lower case or a combination of both,
       case is not important.

       For  example:  the  arguments “-help”, “-HEL” and “-h” are all interpreted to mean the <b>-Help</b> option.  The
       argument “-hlp” will not be understood, because consecutive optional characters were not supplied.

       Options and other command line arguments may be mixed arbitrarily on the command line.

       The GNU long option names are understood.  Since all option names for <u>srec_input</u>  are  long,  this  means
       ignoring the extra leading “-”.  The “<b>--</b><u>option</u><b>=</b><u>value</u>” convention is also understood.

   <b>File</b> <b>Formats</b>
       The <u>format</u> is specified by the argument <u>after</u> the file name.  The format defaults to Motorola S‐Record if
       not specified.  The format specifiers are:

       <b>-Absolute_Object_Module_Format</b>
               This  option  says  to use the Intel Absolute Object Module Format (AOMF) to read the file.  (See
               <u><a href="../man5/srec_aomf.5.html">srec_aomf</a></u>(5) for a description of this file format.)

       <b>-Ascii_Hex</b>
               This option says to use the Ascii‐Hex format to read  the  file.   See  <u><a href="../man5/srec_ascii_hex.5.html">srec_ascii_hex</a></u>(5)  for  a
               description of this file format.

       <b>-Atmel_Generic</b>
               This option says to use the Atmel Generic format to read the file.  See <u><a href="../man5/srec_atmel_genetic.5.html">srec_atmel_genetic</a></u>(5) for
               a description of this file format.

       <b>-Binary</b> This  option  says the file is a raw binary file, and should be read literally.  (This option may
               also be written -Raw.)  See <u><a href="../man5/srec_binary.5.html">srec_binary</a></u>(5) for more information.

       <b>-B‐Record</b>
               This option says to use the Freescale MC68EZ328 Dragonball bootstrap b‐record format to read  the
               file.  See <u><a href="../man5/srec_brecord.5.html">srec_brecord</a></u>(5) for a description of this file format.

       <b>-COsmac</b> This  option  says  to  use the RCA Cosmac Elf format to read the file.  See <u><a href="../man5/srec_cosmac.5.html">srec_cosmac</a></u>(5) for a
               description of this file format.

       <b>-Dec_Binary</b>
               This option says to use the DEC Binary (XXDP) format to read the  file.   See  <u><a href="../man5/srec_dec_binary.5.html">srec_dec_binary</a></u>(5)
               for a description of this file format.

       <b>-Elektor_Monitor52</b>
               This option says to use the EMON52 format to read the file.  See <u><a href="../man5/srec_emon52.5.html">srec_emon52</a></u>(5) for a description
               of this file format.

       <b>-FAIrchild</b>
               This option says to use the Fairchild Fairbug format to read the file.  See <u><a href="../man5/srec_fairchild.5.html">srec_fairchild</a></u>(5) for
               a description of this file format.

       <b>-Fast_Load</b>
               This  option  says  to use the LSI Logic Fast Load format to read the file.  See <u><a href="../man5/srec_fastload.5.html">srec_fastload</a></u>(5)
               for a description of this file format.

       <b>-Formatted_Binary</b>
               This  option  says  to   use   the   Formatted   Binary   format   to   read   the   file.    See
               <u><a href="../man5/srec_formatted_binary.5.html">srec_formatted_binary</a></u>(5) for a description of this file format.

       <b>-Four_Packed_Code</b>
               This  option  says  to use the FPC format to read the file.  See <u><a href="../man5/srec_fpc.5.html">srec_fpc</a></u>(5) for a description of
               this file format.

       <b>-Guess</b>  This option may be used to ask the command to guess  the  input  format.   This  is  slower  than
               specifying an explicit format, as it may open and scan and close the file a number of times.

       <b>-HEX_Dump</b>
               This  option says to try to read a hexadecimal dump file, more or less in the style output by the
               same option.  This is not an exact reverse mapping, because if there are ASCII equivalents on the
               right hand side, these may be confused for data bytes.  Also, it doesn't understand  white  space
               representing holes in the data in the line.

       <b>-IDT</b>    This  option  says  to  the  the  IDT/sim  binary format to read the file.  See <u><a href="../man5/srec_idt.5.html">srec_idt</a></u>(5) for a
               description of this file format.

       <b>-Intel</b>  This option says to use the Intel  hex  format  to  read  the  file.   See  <u><a href="../man5/srec_intel.5.html">srec_intel</a></u>(5)  for  a
               description of this file format.

       <b>-INtel_HeX_16</b>
               This  option  says to use the Intel hex 16 (INHX16) format to read the file.  See <u><a href="../man5/srec_intel16.5.html">srec_intel16</a></u>(5)
               for a description of this file format.

       <b>-LOGIsim</b>
               This format is read and written by the open source Logisim program.  See <u><a href="../man5/srec_logisim.5.html">srec_logisim</a></u>(5) for more
               informatuion.

       <b>-Memory_Initialization_File</b>
               This option says to use the Memory Initialization File (MIF) format by Altera to read  the  file.
               See <u>srec_mif</u> (5) for a description of this file format.

       <b>-Mips_Flash_Big_Endian</b>

       <b>-Mips_Flash_Little_Endian</b>
               These  options  say  to use the MIPS Flash file format to read the file.  See <u>srec_mips_flash</u> (5)
               for a description of this file format.

       <b>-MOS_Technologies</b>
               This option says to use the Mos Technologies format to read the file.  See <u><a href="../man5/srec_mos_tech.5.html">srec_mos_tech</a></u>(5) for a
               description of this file format.

       <b>-Motorola</b> [ <u>width</u> ]
               This option says to use the Motorola S‐Record format to read the file.  (May be written <b>-S‐Record</b>
               as well.)  See <u><a href="../man5/srec_motorola.5.html">srec_motorola</a></u>(5) for a description of this file format.

               The optional <u>width</u> argument describes the number of bytes which form each address multiple.   For
               normal  uses  the  default  of  one  (1) byte is appropriate.  Some systems with 16‐bit or 32‐bit
               targets mutilate the addresses in the file; this option will correct for that.  Unlike most other
               parameters, this one cannot be guessed.

       <b>-MsBin</b>  This option says to use the  Windows  CE  Binary  Image  Data  Format  to  read  the  file.   See
               <u><a href="../man5/srec_msbin.5.html">srec_msbin</a></u>(5) for a description of this file format.

       <b>-Needham_Hexadecimal</b>
               This  option  says  to  use  the  Needham  Electronics  ASCII  file format to read the file.  See
               <u><a href="../man5/srec_needham.5.html">srec_needham</a></u>(5) for a description of this file format.

       <b>-Ohio_Scientific</b>
               This option says to use the Ohio Scientific format.  See <u><a href="../man5/srec_os65v.5.html">srec_os65v</a></u>(5) for a description of  this
               file format.

       <b>-PPB</b>    This  option  says  to  use  the  Stag  Prom  Programmer  binary  format.   See <u><a href="../man5/srec_ppb.5.html">srec_ppb</a></u>(5) for a
               description of this file format.

       <b>-PPX</b>    This option says to use the Stag Prom Programmer  hexadecimal  format.   See  <u><a href="../man5/srec_ppx.5.html">srec_ppx</a></u>(5)  for  a
               description of this file format.

       <b>-SIGnetics</b>
               This  option  says to use the Signetics format.  See <u><a href="../man5/srec_spasm.5.html">srec_spasm</a></u>(5) for a description of this file
               format.

       <b>-SPAsm</b>  This is a synonym for the <b>-SPAsm_Big_Endian</b> option.

       <b>-SPAsm_Big_Endian</b>
               This option says to use the SPASM assembler output format (commonly  used  by  PIC  programmers).
               See <u><a href="../man5/srec_spasm.5.html">srec_spasm</a></u>(5) for a description of this file format.

       <b>-SPAsm_Little_Endian</b>
               This  option  says  to  use  the  SPASM  assembler output format, but with the data the other way
               around.

       <b>-STewie</b> This option says to use the Stewie binary format to read the  file.   See  <u><a href="../man5/srec_stewie.5.html">srec_stewie</a></u>(5)  for  a
               description of this file format.

       <b>-Tektronix</b>
               This  option  says to use the Tektronix hex format to read the file.  See <u><a href="../man5/srec_tektronix.5.html">srec_tektronix</a></u>(5) for a
               description of this file format.

       <b>-Tektronix_Extended</b>
               This  option  says  to  use  the  Tektronix  extended  hex  format  to  read   the   file.    See
               <u><a href="../man5/srec_tektronix_extended.5.html">srec_tektronix_extended</a></u>(5) for a description of this file format.

       <b>-Texas_Instruments_Tagged</b>
               This   option  says  to  use  the  Texas  Instruments  Tagged  format  to  read  the  file.   See
               <u><a href="../man5/srec_ti_tagged.5.html">srec_ti_tagged</a></u>(5) for a description of this file format.

       <b>-Texas_Instruments_Tagged_16</b>
               This option says to use  the  Texas  Instruments  SDSMAC  320  format  to  read  the  file.   See
               <u><a href="../man5/srec_ti_tagged_16.5.html">srec_ti_tagged_16</a></u>(5) for a description of this file format.

       <b>-Texas_Instruments_TeXT</b>
               This  option  says  to  use  the  Texas  Instruments  TXT  (MSP430) format to read the file.  See
               <u><a href="../man5/srec_ti_txt.5.html">srec_ti_txt</a></u>(5) for a description of this file format.

       <b>-TRS80</b>  This option says to use the Radio Shack  TRS‐80  object  file  format  to  read  the  file.   See
               <u><a href="../man5/srec_trs80.5.html">srec_trs80</a></u>(5) for a description of this file format.

       <b>-VMem</b>   This  option  says  to  use  the  Verilog  VMEM  format to read the file.  See <u><a href="../man5/srec_vmem.5.html">srec_vmem</a></u>(5) for a
               description of this file format.

       <b>-WILson</b> This option says to use the wilson format to read the file.  See <u><a href="../man5/srec_wilson.5.html">srec_wilson</a></u>(5) for a description
               of this file format.

   <b>Ignore</b> <b>Checksums</b>
       The <b>-IGnore‐Checksums</b> option may be used to disable checksum validation of input files, for those formats
       which have checksums at all.  Note that the checksum values are still read in and parsed (so it is  still
       an  error  if  they  are  missing)  but their values are not checked.  Used after an input file name, the
       option affects that file alone; used anywhere else on the command  line,  it  applies  to  all  following
       files.

       <b>-redundant‐bytes=</b><u>value</u>
               Use  this  option  to  permit  a file to contain redundant values for some memory locations.  The
               default is for this condition to be a warning.

               ignore
                   No warning or error is issued whena redundant settings are detected.

               warning
                   A warning is issued when  a  redundant  settings  are  observed,  the  warning  includes  the
                   problematic address.

               error
                   A  fatal  error  is  issued  when  a redundant settings are observed, the fatal error message
                   includes the problematic address and byte value.

       <b>-contradictory‐bytes=</b><u>value</u>
               Use this option to permit a file to contain contradictory values for some memory locations.   The
               last value in the input(s) will be used.  The default is for this condition to be a fatal error.

               ignore
                   No warning or error is issued when contradictory setting is detected.

               warning
                   A  warning  is  issued  when  a vontradictory settings are observed, the warning includes the
                   problematic address, and values.

               error
                   A fatal error is issued when contradictory settings are observed,  the  fatal  error  message
                   includes the problematic address and byte values.

   <b>Generators</b>
       It  is also possible to generate data, rather than read it from a file.  You may use a generator anywhere
       you could use a file.  An input generator specification looks like this:

         <b>-GENerate</b> <u>address‐range</u> <b>-</b><u>data‐source</u>

       The <b>-</b><u>data‐source</u> may be one of the following:

       <b>-CONSTant</b> <u>byte‐value</u>
               This generator manufactures data with the given byte value of the the given address range.  It is
               an error if the byte‐value is not in the range 0..255.

               For example, to fill memory addresses 100..199 with newlines (0x0A), you could use a command like

                 srec_cat -generate 100 200 -constant 10 -o newlines.srec

               This can, of course, be combined with data from files.

       <b>-REPeat_Data</b> <u>byte‐value</u>...
               This generator manufactures data with the given byte values repeating over the the given  address
               range.  It is an error if any of the the byte‐values are not in the range 0..255.

               For example, to create a data region with 0xDE in the even bytes and 0xAD in the odd bytes, use a
               generator like this:

                 srec_cat -generate 0x1000 0x2000 -repeat‐data 0xDE 0xAD

               The repeat boundaries are aligned with the base of the address range, modulo the number of bytes.

       <b>-REPeat_String</b> <u>text</u>
               This  generator  is  almost  identical to -repeat‐data except that the data to be repeated is the
               text of the given string.

               For example, to fill the holes in an EPROM image <u>eprom.srec</u> with the  text  “Copyright  (C)  1812
               Tchaikovsky”, combine a generator and an -exclude filter, such as the command

               If you need to inject binary data into the string (e.g. a terminating NUL character), use the URL
               encoding  that  uses  %  followed by two hexadeimal characters.  For example a backspace would be
               encoded as “%08”.

                 srec_cat eprom.srec \
                     -generate 0 0x100000 \
                         -repeat‐string 'Copyright (C) 1812 Tchaikovsky. ' \
                         -exclude -within eprom.srec \
                     -o eprom.filled.srec

               The thing to note is that we have two data sources: the <u>eprom.srec</u> file, and generated data  over
               an  address  range  which  covers  first  megabyte  of  memory but excluding areas covered by the
               <u>eprom.srec</u> data.

       <b>-CONSTant_Little_Endian</b> <u>value</u> <u>width</u>
               This generator manufactures data with the given numeric value, of a given byte width, in  little‐
               endian byte order.  It is an error if the given value does not fit into the given byte width.  It
               will repeat over and over within the address range range.

               For  example, to insert a subversion commit number into 4 bytes at 0x0008..0x000B you would use a
               command like

                 srec_cat -generate 8 12 -constant‐l‐e $VERSION 4 \
                     -o version.srec

               This generator is a convenience wrapper around the <b>-REPeat_Data</b> generator.  It can, of course, be
               combined with data from files.

       <b>-CONSTant_Big_Endian</b> <u>value</u> <u>width</u>
               As above, but using big‐endian byte ordering.

       Anything else will result in an error.

   <b>Input</b> <b>Filters</b>
       You may specify zero or more <u>filters</u> to be applied.  Filters are applied in the order the user specifies.

       <b>-Adler_16_Big_Endian</b> <u>address</u>
               This filter may be used to insert an “Adler” 16‐bit checksum of the  data  into  the  data.   Two
               bytes, big‐endian order, are inserted at the address given.  Holes in the input data are ignored.
               Bytes are processed in ascending address order (<u>not</u> in the order they appear in the input).

               <b>Note:</b>  If you have holes in your data, you will get a different Adler checksum than if there were
               no holes.  This is important because the in‐memory EPROM image will not have holes.   You  almost
               always want to use the <b>-fill</b> filter before any of the Adler checksum filters.  You will receive a
               warning if the data presented for Adler checksum has holes.

               You  should also be aware that the lower and upper bounds of your data may not be the same as the
               lower and upper bounds of your EPROM.  This is another reason to use the <b>-fill</b> filter, because it
               will establish the data across the full EPROM address range.

               <a href="http://en.wikipedia.org/wiki/Adler">http://en.wikipedia.org/wiki/Adler</a>‐32

       <b>-Adler_16_Little_Endian</b> <u>address</u>
               This filter may be used to insert an Adler 16‐bit checksum of the data into the data.  Two bytes,
               in little‐endian order, are inserted at the address given.  Holes in the input data are  ignored.
               Bytes are processed in ascending address order (<u>not</u> in the order they appear in the input).

               <b>Note:</b>  If you have holes in your data, you will get a different Adler checksum than if there were
               no holes.  This is important because the in‐memory EPROM image will not have holes.   You  almost
               always  want to use the <b>-fill</b> filter before any of the Adler filters.  You will receive a warning
               if the data presented for Adler checksum has holes.

               You should also be aware that the lower and upper bounds of your data may not be the same as  the
               lower and upper bounds of your EPROM.  This is another reason to use the <b>-fill</b> filter, because it
               will establish the data across the full EPROM address range.

               <a href="http://en.wikipedia.org/wiki/Adler">http://en.wikipedia.org/wiki/Adler</a>‐32

       <b>-Adler_32_Big_Endian</b> <u>address</u>
               This filter may be used to insert a Adler 32‐bit checksum of the data into the data.  Four bytes,
               big‐endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes
               are processed in ascending address order (<u>not</u> in the order they appear in the input).

               <b>Note:</b>  If you have holes in your data, you will get a different Adler checksum than if there were
               no holes.  This is important because the in‐memory EPROM image will not have holes.   You  almost
               always want to use the <b>-fill</b> filter before any of the Adler checksum filters.  You will receive a
               warning if the data presented for Adler checksum has holes.

               You  should also be aware that the lower and upper bounds of your data may not be the same as the
               lower and upper bounds of your EPROM.  This is another reason to use the <b>-fill</b> filter, because it
               will establish the data across the full EPROM address range.

               <a href="http://en.wikipedia.org/wiki/Adler">http://en.wikipedia.org/wiki/Adler</a>‐32

       <b>-Adler_32_Little_Endian</b> <u>address</u>
               This filter may be used to insert a Adler 32‐bit checksum of the data into the data.  Four bytes,
               in little‐endian order, are inserted at the address given.  Holes in the input data are  ignored.
               Bytes are processed in ascending address order (<u>not</u> in the order they appear in the input).

               <b>Note:</b>  If you have holes in your data, you will get a different Adler checksum than if there were
               no holes.  This is important because the in‐memory EPROM image will not have holes.   You  almost
               always want to use the <b>-fill</b> filter before any of the Adler checksum filters.  You will receive a
               warning if the data presented for Adler checksum has holes.

               You  should also be aware that the lower and upper bounds of your data may not be the same as the
               lower and upper bounds of your EPROM.  This is another reason to use the <b>-fill</b> filter, because it
               will establish the data across the full EPROM address range.

               <a href="http://en.wikipedia.org/wiki/Adler">http://en.wikipedia.org/wiki/Adler</a>‐32

       <b>-AND</b> <u>value</u>
               This filter may be used to bit‐wise AND a <u>value</u> to every data byte.  This is useful if  you  need
               to clear bits.  Only existing data is altered, no holes are filled.

       <b>-Bit_Reverse</b> [ <u>width</u> ]
               This  filter  may  be  used  to reverse the order of the bits in each data byte.  By specifying a
               width (in bytes) it is possible to reverse the order multi‐byte values; this is implemented using
               the byte‐swap filter.

       <b>-Byte_Swap</b> [ <u>width</u> ]
               This filter may be used to swap pairs of odd and even bytes.  By specifying a width (in bytes) it
               is possible to reverse the order of 4 and 8 bytes, the default is 2 bytes.  (Widths in excess  of
               8  are assumed to be number of bits.)  It is not possible to swap non‐power‐of‐two addresses.  To
               change the alignment, use the offset filter before and after.

       <b>-Checksum_BitNot_Big_Endian</b> <u>address</u> [ <u>nbytes</u> [ <u>width</u> ]]
               This filter may be used to insert the one's complement checksum of the data into the  data,  most
               significant  byte  first.   The data is literally summed; if there are duplicate bytes, this will
               produce an incorrect result, if there are holes, it will be as if they were  filled  with  zeros.
               If  the  data already contains bytes at the checksum location, you need to use an exclude filter,
               or this will generate errors.  You need to apply and crop or fill  filters  before  this  filter.
               The value will be written with the most significant byte first.  The number of bytes of resulting
               checksum defaults to 4.  The width (the width in bytes of the values being summed) defaults to 1.

       <b>-Checksum_BitNot_Little_Endian</b> <u>address</u> [ <u>nbytes</u> [ <u>width</u> ]]
               This  filter  may  be  used to insert the one's complement (bitnot) checksum of the data into the
               data, least significant byte first.  Otherwise similar to the above.

       <b>-Checksum_Negative_Big_Endian</b> <u>address</u> [ <u>nbytes</u> [ <u>width</u> ]]
               This filter may be used to insert the two's complement (negative) checksum of the data  into  the
               data.  Otherwise similar to the above.

       <b>-Checksum_Negative_Little_Endian</b> <u>address</u> [ <u>nbytes</u> [ <u>width</u> ]]
               This  filter  may be used to insert the two's complement (negative) checksum of the data into the
               data.  Otherwise similar to the above.

       <b>-Checksum_Positive_Big_Endian</b> <u>address</u> [ <u>nbytes</u> [ <u>width</u> ]]
               This filter may be used to insert the simple checksum of  the  data  into  the  data.   Otherwise
               similar to the above.

       <b>-Checksum_Positive_Little_Endian</b> <u>address</u> [ <u>nbytes</u> [ <u>width</u> ]]
               This  filter  may  be  used  to  insert the simple checksum of the data into the data.  Otherwise
               similar to the above.

       <b>-CRC16_Big_Endian</b> <u>address</u> [ <u>modifier</u>... ]
               This filter may be used to insert an industry standard 16‐bit CRC checksum of the data  into  the
               data.   Two  bytes, big‐endian order, are inserted at the address given.  Holes in the input data
               are ignored.  Bytes are processed in ascending address order (<u>not</u> in the order they appear in the
               input).

               The following additional modifiers are understood:

               <u>number</u>  Set the polynomial to be used to the given number.

               <b>-POLYnomial</b> <u>name</u>
                       This option may be used to set the CRC polynomial to be used, by name.  The  known  names
                       include:
                              ibm       0x8005
                              ansi      0x8005
                              ccitt     0x1021
                              t10‐dif   0x8bb7
                              dnp       0x3d65
                              dect      0x0589

                       See <a href="http://en.wikipedia.org/wiki/Cyclic_redundancy_check">http://en.wikipedia.org/wiki/Cyclic_redundancy_check</a> for a table of names and values.

               <b>-Most_To_Least</b>
                       The  CRC  calculation  is  performed with the most significant bit in each byte processed
                       first, and then proceeding towards the least significant bit.  This is the default.

               <b>-Least_To_Most</b>
                       The CRC calculation is performed with the least significant bit in  each  byte  processed
                       first, and then proceeding towards the most significant bit.

               <b>-CCITT</b>  The CCITT calculation is performed.  The initial seed is 0xFFFF.  This is the default.

               <b>-XMODEM</b> The alternate XMODEM calculation is performed.  The initial seed is 0x0000.

               <b>-BROKEN</b> A  common‐but‐broken  calculation  is  performed (see note 2 below).  The initial seed is
                       0x84CF.

               <b>-AUGment</b>
                       The CRC is augmented by sixteen zero bits at the end of the  calculation.   This  is  the
                       default.

               <b>-No‐AUGment</b>
                       The  CRC  is  not  augmented  at  the  end  of  the  calculation.   This is less standard
                       conforming, but some implementations do this.

               <b>Note:</b> If you have holes in your data, you will get a different CRC than if there were  no  holes.
               This  is important because the in‐memory EPROM image will not have holes.  You almost always want
               to use the <b>-fill</b> filter before any of the CRC filters.  You will receive a warning  if  the  data
               presented for CRC has holes.

               You  should also be aware that the lower and upper bounds of your data may not be the same as the
               lower and upper bounds of your EPROM.  This is another reason to use the <b>-fill</b> filter, because it
               will establish the data across the full EPROM address range.

               <b>Note</b> <b>2:</b> there are a great many CRC16 implementations  out  there,  see  <a href="http://www.joegeluso.com">http://www.joegeluso.com</a>‐
               /software/articles/ccitt.htm    (now    gone,   reproduced   at   <a href="http://srecord.sourceforge.net">http://srecord.sourceforge.net</a>‐
               /crc16-ccitt.html)   and   “A   painless   guide   to    CRC    error    detection    algorithms”
               <a href="http://www.repairfaq.org/filipg/LINK/F_crc_v3.html">http://www.repairfaq.org/filipg/LINK/F_crc_v3.html</a>  for  more  information.   If  all else fails,
               SRecord is open source software: read the SRecord source code.  The CRC16 source code  (found  in
               the srecord/crc16.cc file of the distribution tarball) has a great many explanatory comments.

               Please  try  all  twelve  combinations  of  the above options before reporting a bug in the CRC16
               calculation.

       <b>-CRC16_Little_Endian</b> <u>address</u> [ <u>modifier</u>... ]
               The same as the <b>-CRC16_Big_Endian</b> filter, except in little‐endian byte order.

       <b>-CRC32_Big_Endian</b> <u>address</u> [ <u>modifier</u>... ]
               This filter may be used to insert an industry standard 32‐bit CRC checksum of the data  into  the
               data.   Four bytes, big‐endian order, are inserted at the address given.  Holes in the input data
               are ignored.  Bytes are processed in ascending address order (<u>not</u> in the order they appear in the
               input).  See also the note about holes, above.

               The following additional modifiers are understood:

               <b>-CCITT</b>  The CCITT calculation is performed.  The initial seed is  all  one  bits.   This  is  the
                       default.

               <b>-XMODEM</b> An alternate XMODEM‐style calculation is performed.  The initial seed is all zero bits.

       <b>-CRC32_Little_Endian</b> <u>address</u>
               The same as the <b>-CRC32_Big_Endian</b> filter, except in little‐endian byte order.

       <b>-Crop</b> <u>address‐range</u>
               This filter may be used to isolate a section of data, and discard the rest.

       <b>-Exclude</b> <u>address‐range</u>
               This  filter  may  be  used  to exclude a section of data, and keep the rest.  The is the logical
               complement of the <b>-Crop</b> filter.

       <b>-Exclusive_Length_Big_Endian</b> <u>address</u> [ <u>nbytes</u> [ <u>width</u> ]]
               The same as the <b>-Length_Big_Endian</b> filter, except that the result does  <b>not</b>  include  the  length
               itself.

       <b>-Exclusive_Length_Little_Endian</b> <u>address</u> [ <u>nbytes</u> [ <u>width</u> ]]
               The  same as the <b>-Length_Little_Endian</b> filter, except that the result does <b>not</b> include the length
               itself.

       <b>-Exclusive_MAXimum_Big_Endian</b> <u>address</u> [ <u>nbytes</u> ]
               The same as the <b>-MAXimum_Big_Endian</b> filter, except that the result does <b>not</b> include  the  maximum
               itself.

       <b>-Exclusive_MAXimum_Little_Endian</b> <u>address</u> [ <u>nbytes</u> ]
               The  same  as  the  <b>-MAXimum_Little_Endian</b>  filter,  except  that the result does <b>not</b> include the
               maximum itself.

       <b>-Exclusive_MINimum_Big_Endian</b> <u>address</u> [ <u>nbytes</u> ]
               The same as the <b>-MINimum_Big_Endian</b> filter, except that the result does <b>not</b> include  the  minimum
               itself.

       <b>-Exclusive_MINimum_Little_Endian</b> <u>address</u> [ <u>nbytes</u> ]
               The  same  as  the  <b>-MINimum_Little_Endian</b>  filter,  except  that the result does <b>not</b> include the
               minimum itself.

       <b>-eXclusive‐OR</b> <u>value</u>
               This filter may be used to bit‐wise XOR a <u>value</u> to every data byte.  This is useful if  you  need
               to invert bits.  Only existing data is altered, no holes are filled.

       <b>-Fill</b> <u>value</u> <u>address‐range</u>
               This  filter  may  be used to fill any gaps in the data with bytes equal to <u>value</u>.  The fill will
               only occur in the address range given.

       <b>-Fletcher_16_Big_Endian</b> <u>address</u> [ <u>sum1</u> <u>sum2</u> [ <u>answer</u> ]]
               This filter may be used to insert an Fletcher 16‐bit checksum of the data  into  the  data.   Two
               bytes, big‐endian order, are inserted at the address given.  Holes in the input data are ignored.
               Bytes are processed in ascending address order (<u>not</u> in the order they appear in the input).

               <b>Note:</b>  If  you  have holes in your data, you will get a different Fletcher checksum than if there
               were no holes.  This is important because the in‐memory EPROM image will  not  have  holes.   You
               almost always want to use the <b>-fill</b> filter before any of the Fletcher checksum filters.  You will
               receive a warning if the data presented for Fletcher checksum has holes.

               You  should also be aware that the lower and upper bounds of your data may not be the same as the
               lower and upper bounds of your EPROM.  This is another reason to use the <b>-fill</b> filter, because it
               will establish the data across the full EPROM address range.

               <a href="http://en.wikipedia.org/wiki/Fletcher">http://en.wikipedia.org/wiki/Fletcher</a>%27s_checksum

               It is possible to select seed values for <u>sum1</u> and <u>sum2</u> in the algorithm, by adding seed values on
               the command line.  They each default to 0xFF if not explicitly stated.  The  default  values  (0)
               means  that  an  empty  EPROM  (all 0x00 or all 0xFF) will sum to zero; by changing the seeds, an
               empty EPROM will always fail.

               The third optional argument is the desired sum, when the checksum itself  is  summed.   A  common
               value  is  0x0000,  placed in the last two bytes of an EPROM, so that the Fletcher 16 checksum of
               the EPROM is exactly 0x0000.  No manipulation of the final value is performed if  this  value  if
               not specified.

       <b>-Fletcher_16_Little_Endian</b> <u>address</u>
               This  filter  may  be  used to insert an Fletcher 16‐bit checksum of the data into the data.  Two
               bytes, in little‐endian order, are inserted at the address given.  Holes in the  input  data  are
               ignored.   Bytes  are  processed  in ascending address order (<u>not</u> in the order they appear in the
               input).

               <b>Note:</b> If you have holes in your data, you will get a different Fletcher checksum  than  if  there
               were  no  holes.   This  is important because the in‐memory EPROM image will not have holes.  You
               almost always want to use the <b>-fill</b> filter before any of the Fletcher filters.  You will  receive
               a warning if the data presented for Fletcher checksum has holes.

               You  should also be aware that the lower and upper bounds of your data may not be the same as the
               lower and upper bounds of your EPROM.  This is another reason to use the <b>-fill</b> filter, because it
               will establish the data across the full EPROM address range.

               <a href="http://en.wikipedia.org/wiki/Fletcher">http://en.wikipedia.org/wiki/Fletcher</a>%27s_checksum

       <b>-Fletcher_32_Big_Endian</b> <u>address</u>
               This filter may be used to insert a Fletcher 32‐bit checksum of the data  into  the  data.   Four
               bytes, big‐endian order, are inserted at the address given.  Holes in the input data are ignored.
               Bytes are processed in ascending address order (<u>not</u> in the order they appear in the input).

               <b>Note:</b>  If  you  have holes in your data, you will get a different Fletcher checksum than if there
               were no holes.  This is important because the in‐memory EPROM image will  not  have  holes.   You
               almost always want to use the <b>-fill</b> filter before any of the Fletcher checksum filters.  You will
               receive a warning if the data presented for Fletcher checksum has holes.

               You  should also be aware that the lower and upper bounds of your data may not be the same as the
               lower and upper bounds of your EPROM.  This is another reason to use the <b>-fill</b> filter, because it
               will establish the data across the full EPROM address range.

               <a href="http://en.wikipedia.org/wiki/Fletcher">http://en.wikipedia.org/wiki/Fletcher</a>%27s_checksum

       <b>-Fletcher_32_Little_Endian</b> <u>address</u>
               This filter may be used to insert a Fletcher 32‐bit checksum of the data  into  the  data.   Four
               bytes,  in  little‐endian  order, are inserted at the address given.  Holes in the input data are
               ignored.  Bytes are processed in ascending address order (<u>not</u> in the order  they  appear  in  the
               input).

               <b>Note:</b>  If  you  have holes in your data, you will get a different Fletcher checksum than if there
               were no holes.  This is important because the in‐memory EPROM image will  not  have  holes.   You
               almost always want to use the <b>-fill</b> filter before any of the Fletcher checksum filters.  You will
               receive a warning if the data presented for Fletcher checksum has holes.

               You  should also be aware that the lower and upper bounds of your data may not be the same as the
               lower and upper bounds of your EPROM.  This is another reason to use the <b>-fill</b> filter, because it
               will establish the data across the full EPROM address range.

               <a href="http://en.wikipedia.org/wiki/Fletcher">http://en.wikipedia.org/wiki/Fletcher</a>%27s_checksum

       <b>-Length_Big_Endian</b> <u>address</u> [ <u>nbytes</u> [ <u>width</u> ]]
               This filter may be used to insert the length of the data (high water minus low  water)  into  the
               data.   This  includes  the  length  itself.   If  the  data already contains bytes at the length
               location, you need to use an exclude filter, or this will generate errors.   The  value  will  be
               written  with  the  most  significant  byte first.  The number of bytes defaults to 4.  The width
               defaults to 1, and is divided into the actual length, thus you can insert the width in  units  of
               words (2) or longs (4).

       <b>-Length_Little_Endian</b> <u>address</u> [ <u>nbytes</u> [ <u>width</u> ]]
               The  same  as  the  <b>-Length_Big_Endian</b>  filter,  except  the value will be written with the least
               significant byte first.

       <b>-MAXimum_Big_Endian</b> <u>address</u> [ <u>nbytes</u> ]
               This filter may be used to insert the maximum address of the data (high water
                + 1) into the data.  This includes the maximum itself.  If the data already  contains  bytes  at
               the  given  address,  you need to use an exclude filter, or this will generate errors.  The value
               will be written with the most significant byte first.  The number of bytes defaults to 4.

       <b>-MAXimum_Little_Endian</b> <u>address</u> [ <u>nbytes</u> ]
               The same as the <b>-MAXimum_Big_Endian</b> filter, except the value  will  be  written  with  the  least
               significant byte first.

       <b>-Message_Digest_5</b> <u>address</u>
               This filter may be used to insert a 16 byte MD5 hash into the data, at the address given.

       <b>-MINimum_Big_Endian</b> <u>address</u> [ <u>nbytes</u> ]
               This  filter  may  be  used  to insert the minimum address of the data (low water) into the data.
               This includes the minimum itself.  If the data already contains bytes at the given  address,  you
               need  to use an exclude filter, or this will generate errors.  The value will be written with the
               most significant byte first.  The number of bytes defaults to 4.

       <b>-MINimum_Little_Endian</b> <u>address</u> [ <u>nbytes</u> ]
               The same as the <b>-MINimum_Big_Endian</b> filter, except the value  will  be  written  with  the  least
               significant byte first.

       <b>-NOT</b>    This filter may be used to bit‐wise NOT the value of every data byte.  This is useful if you need
               to invert the data.  Only existing data is altered, no holes are filled.

       <b>-OFfset</b> <u>nbytes</u>
               This  filter  may be used to offset the addresses by the given number of bytes.  No data is lost,
               the addresses will wrap around in 32 bits, if necessary.  You may use negative  numbers  for  the
               offset, if you wish to move data lower in memory.

               Please  note: the execution start address is a different concept than the first address in memory
               of your data.  If you want to change where your monitor will start executing, use the <b>-execution‐</b>
               <b>start‐address</b> option (<u><a href="../man1/srec_cat.1.html">srec_cat</a></u>(1) only).

       <b>-OR</b> <u>value</u>
               This filter may be used to bit‐wise OR a <u>value</u> to every data byte.  This is useful if you need to
               set bits.  Only existing data is altered, no holes are filled.

       <b>-Random_Fill</b> <u>address‐range</u>
               This filter may be used to fill any gaps in the data with random bytes.  The fill will only occur
               in the address range given.

       <b>-Ripe_Message_Digest_160</b> <u>address</u>
               This filter may be used to insert an RMD160 hash into the data.

       <b>-Secure_Hash_Algorithm_1</b> <u>address</u>
               This filter may be used to insert a 20 byte SHA1 hash into the data, at the address given.

       <b>-Secure_Hash_Algorithm_224</b> <u>address</u>
               This filter may be used to insert a 28 byte SHA224 hash into the data, at the address given.  See
               Change Notice 1 for FIPS 180‐2 for the specification.

       <b>-Secure_Hash_Algorithm_256</b> <u>address</u>
               This filter may be used to insert a 32 byte SHA256 hash into the data, at the address given.  See
               FIPS 180‐2 for the specification.

       <b>-Secure_Hash_Algorithm_384</b> <u>address</u>
               This filter may be used to insert a 48 byte SHA384 hash into the data, at the address given.  See
               FIPS 180‐2 for the specification.

       <b>-Secure_Hash_Algorithm_512</b> <u>address</u>
               This filter may be used to insert a 64 byte SHA512 hash into the data, at the address given.  See
               FIPS 180‐2 for the specification.

       <b>-SPlit</b> <u>multiple</u> [ <u>offset</u> [ <u>width</u> ] ]
               This filter may be used to split the input into a subset of the data, and  compress  the  address
               range so as to leave no gaps.  This useful for wide data buses and memory striping.  The <u>multiple</u>
               is  the  bytes multiple to split over, the <u>offset</u> is the byte offset into this range (defaults to
               0), the <u>width</u> is the number of bytes to extract (defaults to 1) within the multiple.  In order to
               leave no gaps, the output addresses are (<u>width</u> / <u>multiple</u>) times the input addresses.

       <b>-STM32</b> <u>address</u>
               This is a synonym for the <b>-STM32_Little_Endian</b> filter.

       <b>-STM32_Little_Endian</b> <u>address</u>

       <b>-STM32_Big_Endian</b> <u>address</u>
               These filters many be use to generate the CRC used by the hardware CRC unit on the  STM32  series
               of  ARM  MPUs.   The  algorithm  used by the STM32 hardware unit is just a CRC32 with a different
               polynomial and word‐fed instead of byte‐fed.

               The <u>address</u> is where to place the 4‐byte STM32 CRC.

               The CRC used is documented in “RM0041, STM32F100xx  reference  manual”,  page  46,  chapter  “CRC
               Calculation Unit”, which can be found at
               <a href="http://www.st.com/internet/mcu/product/216844.jsp">http://www.st.com/internet/mcu/product/216844.jsp</a>

       <b>-TIGer</b> <u>address</u>
               This filter may be used to insert a 24 byte TIGER/192 hash into the data at the address given.

       <b>-UnFill</b> <u>value</u> [ <u>min‐run‐length</u> ]
               This  filter  may be used to create gaps in the data with bytes equal to <u>value</u>.  You can think of
               it as reversing the effects of the <b>-Fill</b> filter.  The gaps will only be created  if  the  are  at
               least <u>min‐run‐length</u> bytes in a row (defaults to 1).

       <b>-Un_SPlit</b> <u>multiple</u> [ <u>offset</u> [ <u>width</u> ] ]
               This filter may be used to reverse the effects of the split filter.  The arguments are identical.
               Note  that  the  address  range  is  expanded (<u>multiple</u> / <u>width</u>) times, leaving holes between the
               stripes.

       <b>-WHIrlpool</b> <u>address</u>
               This filter may be used to insert a 64 byte WHIRLPOOL hash into the data, at the address given.

   <b>Address</b> <b>Ranges</b>
       There are eight ways to specify an address range:

       <u>minimum</u> <u>maximum</u>
               If you specify two number on the command line (decimal, octal  and  hexadecimal  are  understood,
               using  the  C  conventions)  this  is  an  explicit address range.  The minimum is inclusive, the
               maximum is exclusive (one more than the last address).  If the maximum is given as zero then  the
               range extends to the end of the address space.

       <b>-Within</b> <u>input‐specification</u>
               This  says  to  use  the  specified  input file as a mask.  The range includes all the places the
               specified input has data, and holes where it has holes.  The input specification need not be just
               a file name, it may be anything any other input specification can be.

               See also the <b>-over</b> option for a discussion on operator precedence.

       <b>-OVER</b> <u>input‐specification</u>
               This says to use the specified input file as a mask.  The range extends from the minimum  to  the
               maximum  address  used  by  the input, without any holes, even if the input has holes.  The input
               specification need not be just a file name, it may be anything any other input specification  can
               be.

               You  may  need  to  enclose <u>input‐specification</u> in parentheses to make sure it can't misinterpret
               which arguments go with which input specification.  This is particularly important when a  filter
               is to follow.  For example
                      <u>filename</u> -fill 0 -over <u>filename2</u> -swap‐bytes
               groups as
                      <u>filename</u> -fill 0 -over '(' <u>filename2</u> -swap‐bytes ')'
               when what you actually wanted was
                      '(' <u>filename</u> -fill 0 -over <u>filename2</u> ')' -swap‐bytes
               The  command  line  expression  parsing  tends  to be “greedy” (or right associative) rather than
               conservative (or left associative).

       <u>address‐range</u> <b>-RAnge‐PADding</b> <u>number</u>
               It is also possible to pad ranges to be whole aligned multiples of the given number.  For example
                      <u>input‐file</u> -fill 0xFF -within <u>input‐file</u> -range‐pad 512
               will fill the <u>input‐file</u> so that it consists of  whole  512‐byte  blocks,  aligned  on  512  byte
               boundaries.   Any  large  holes  in the data will also be multiples of 512 bytes, though they may
               have been shrunk as blocks before and after are padded.

               This operator has the same precedence as the explicit union operator.

       <u>address‐range</u> <b>-INTERsect</b> <u>address‐range</u>
               You can intersect two address ranges to  produce  a  smaller  address  range.   The  intersection
               operator has higher precedence than the implicit union operator (evaluated left to right).

       <u>address‐range</u> <b>-UNIon</b> <u>address‐range</u>
               You can union two address ranges to produce a larger address range.  The union operator has lower
               precedence than the intersection operator (evaluated left to right).

       <u>address‐range</u> <b>-DIFference</b> <u>address‐range</u>
               You can difference two address ranges to produce a smaller address range.  The result is the left
               hand  range  with  all  of  the  right  hand range removed.  The difference operator has the same
               precedence as the implicit union operator (evaluated left to right).

       <u>address‐range</u> <u>address‐range</u>
               In addition, all of these methods may be used, and used more than once, and the results  will  be
               combined (implicit union operator, same precedence as explicit union operator).

   <b>Calculated</b> <b>Values</b>
       Most of the places above where a number is expected, you may supply one of the following:

       <b>-</b> <u>value</u>
               The  value of this expression is the negative of the expression argument.  Note the <b>space</b> between
               the minus sign and its argument: this space is mandatory.
                      srec_cat in.srec -offset − -minimum‐addr in.srec -o out.srec
               This example shows how to move data to the base of memory.

       ( <u>value</u> )
               You may use parentheses for grouping.  When using parentheses,  they  must  each  be  a  separate
               command  line  argument,  they can't be within the text of the preceding or following option, and
               you will need to quote them to get them past the shell, such as '(' and ')'.

       <b>-MINimum‐Address</b> <u>input‐specification</u>
               This inserts the minimum address of the specified input file.  The input specification  need  not
               be just a file name, it may be anything any other input specification can be.

               See also the <b>-over</b> option for a discussion on operator precedence.

       <b>-MAXimum‐Address</b> <u>input‐specification</u>
               This  inserts the maximum address of the specified input file, plus one.  The input specification
               need not be just a file name, it may be anything any other input specification can be.

               See also the <b>-over</b> option for a discussion on operator precedence.

       <b>-Length</b> <u>input‐specification</u>
               This inserts the length of the address range in the specified input  file,  ignoring  any  holes.
               The  input  specification  need  not  be  just  a  file  name, it may be anything any other input
               specification can be.

               See also the <b>-over</b> option for a discussion on operator precedence.

       For example, the <b>-OVER</b> <u>input‐specification</u> option can be thought of as short‐hand for <b>'('</b> <b>-min</b> <u>file</u>  <b>-max</b>
       <u>file</u> <b>')'</b>, except that it is much easier to type, and also more efficient.

       In addition, calculated values may optionally be rounded in one of three ways:

       <u>value</u> <b>-Round_Down</b> <u>number</u>
               The <u>value</u> is rounded down to the the largest integer smaller than or equal to a whole multiple of
               the <u>number</u>.

       <u>value</u> <b>-Round_Nearest</b> <u>number</u>
               The <u>value</u> is rounded to the the nearest whole multiple of the <u>number</u>.

       <u>value</u> <b>-Round_Up</b> <u>number</u>
               The  <u>value</u>  is rounded up to the the smallest integer larger than or equal to a whole multiple of
               the <u>number</u>.

       When using parentheses, they must each be a separate command line argument, they can't be within the text
       of the preceding or following option, and you will need to quote them to get them past the shell, as  '('
       and ')'.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       <u>srec_input</u> version 1.64
       Copyright  (C)  1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
       2013, 2014 Peter Miller

       The <u>srec_input</u> program comes with ABSOLUTELY NO  WARRANTY;  for  details  use  the  '<u>srec_input</u>  <u>-VERSion</u>
       <u>License</u>' command.  This is free software and you are welcome to redistribute it under certain conditions;
       for details use the '<u>srec_input</u> <u>-VERSion</u> <u>License</u>' command.

</pre><h4><b>MAINTAINER</b></h4><pre>
       Scott Finneran   E‐Mail:   <a href="mailto:scottfinneran@yahoo.com.au">scottfinneran@yahoo.com.au</a>
       Peter Miller     E‐Mail:   <a href="mailto:pmiller@opensource.org.au">pmiller@opensource.org.au</a>

Reference Manual                                     SRecord                                       <u><a href="../man1/srec_input.1.html">srec_input</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>