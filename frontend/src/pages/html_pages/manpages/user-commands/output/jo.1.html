<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jo - JSON output from a shell</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/jo">jo_1.9-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       jo - JSON output from a shell

</pre><h4><b>SYNOPSIS</b></h4><pre>
       jo [-p] [-a] [-B] [-D] [-e] [-n] [-v] [-V] [-d keydelim] [-f file] [–] [ [-s|-n|-b] word ...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>jo</u>  creates a JSON string on <u>stdout</u> from <u>word</u>s given it as arguments or read from <u>stdin</u>.  If <b>-f</b> is speci‐
       fied, <u>jo</u> first loads the contents of <u>file</u> as a JSON object or array, then  modifies  it  with  subsequent
       <u>word</u>s  before  printing  the  final  JSON string to <u>stdout</u>.  <u>file</u> may be specified as <b>-</b> to read from <u>jo</u>’s
       standard input; this takes precedence over reading <u>word</u>s from <u>stdin</u>.

       Without option <b>-a</b> it generates an object whereby each <u>word</u> is a <b>key=value</b> (or <b>key@value</b>)  pair  with  <u>key</u>
       being  the  JSON  object element and <u>value</u> its value.  <u>jo</u> attempts to guess the type of <u>value</u> in order to
       create number (using <u><a href="../man3/strtod.3.html">strtod</a>(3)</u>), string, or null values in JSON.

       A missing or empty <u>value</u> normally results in an element whose value is <b>null</b>.  If <b>-n</b>  is  specified,  this
       element is not created.

       <u>jo</u> normally treats <u>key</u> as a literal string value.  If the <b>-d</b> option is specified, <u>key</u> will be interpreted
       as an <u>object</u> <u>path</u>, whose individual components are separated by the first character of <u>keydelim</u>.

       <u>jo</u>  normally  treats  <u>value</u> as a literal string value, unless it begins with one of the following charac‐
       ters:

       value   action
       ──────────────────────────────────────────────
       @file   substitute the contents of <u>file</u> as-is
       %file   substitute the contents  of  <u>file</u>  in
               base64-encoded form
       :file   interpret  the  contents  of  <u>file</u> as
               JSON, and substitute the result

       Escape the special character with a backslash to prevent this interpretation.

       <u>jo</u> treats <b>key@value</b> specifically as boolean JSON elements: if the value begins with <b>T</b>, <b>t</b>, or the  numeric
       value is greater than zero, the result is <b>true</b>, else <b>false</b>.

       <u>jo</u> creates an array instead of an object when <b>-a</b> is specified.

       When  the  <b>:=</b>  operator is used in a <u>word</u>, the name to the right of <b>:=</b> is a file containing JSON which is
       parsed and assigned to the key left of the operator.  The file may be specified as <b>-</b> to  read  from  <u>jo</u>’s
       standard input.

</pre><h4><b>TYPE</b> <b>COERCION</b></h4><pre>
       <u>jo</u>’s type guesses can be overridden on a per-word basis by prefixing <u>word</u> with <b>-s</b> for <u>string</u>, <b>-n</b> for <u>num‐</u>
       <u>ber</u>,  or <b>-b</b> for <u>boolean</u>.  The list of <u>word</u>s <u>must</u> be prefixed with <b>--</b>, to indicate to <u>jo</u> that there are no
       more global options.

       Type coercion works as follows:

       word         -s               -n          -b          default
       ─────────────────────────────────────────────────────────────────────
       a=           “a”:“”           “a”:0       “a”:false   “a”:null
       a=string     “a”:“string”     “a”:6       “a”:true    “a”:“string”
       a="quoted"   “a”:“"quoted"”   “a”:8       “a”:true    “a”:“"quoted"”
       a=12345      “a”:“12345”      “a”:12345   “a”:true    “a”:12345
       a=true       “a”:“true”       “a”:1       “a”:true    “a”:true
       a=false      “a”:“false”      “a”:0       “a”:false   “a”:false
       a=null       “a”:“”           “a”:0       “a”:false   “a”:null

       Coercing a non-number string to number outputs the <u>length</u> of the string.

       Coercing a non-boolean string to boolean outputs <b>false</b> if the string is empty, <b>true</b> otherwise.

       Type coercion only applies to <b>key=value</b> words, and individual words in a <b>-a</b> array.  Coercing other  words
       has no effect.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Create an object.  Note how the incorrectly-formatted float value becomes a string:

              $ jo tst=1457081292 lat=12.3456 cc=FR badfloat=3.14159.26 name="JP Mens" nada= coffee@T
              {"tst":1457081292,"lat":12.3456,"cc":"FR","badfloat":"3.14159.26","name":"JP Mens","nada":null,"coffee":true}

       Pretty-print an array with a list of files in the current directory:

              $ jo -p -a *
              [
               "Makefile",
               "README.md",
               "jo.1",
               "jo.c",
               "jo.pandoc",
               "json.c",
               "json.h"
              ]

       Create  objects  within objects; this works because if the first character of value is an open brace or a
       bracket we attempt to decode the remainder as JSON.  Beware spaces in strings ...

              $ jo -p name=JP object=$(jo fruit=Orange hungry@0 point=$(jo x=10 y=20 list=$(jo -a 1 2 3 4 5)) number=17) sunday@0
              {
               "name": "JP",
               "object": {
                "fruit": "Orange",
                "hungry": false,
                "point": {
                 "x": 10,
                 "y": 20,
                 "list": [
                  1,
                  2,
                  3,
                  4,
                  5
                 ]
                },
                "number": 17
               },
               "sunday": false
              }

       Booleans as strings or as boolean (pay particular attention to <u>switch</u>; the <b>-B</b> option disables the default
       detection of the “<b>true</b>”, “<b>false</b>”, and “<b>null</b>” strings):

              $ jo switch=true morning@0
              {"switch":true,"morning":false}

              $ jo -B switch=true morning@0
              {"switch":"true","morning":false}

       Elements (objects and arrays) can be nested.  The following example nests an array called  <u>point</u>  and  an
       object named <u>geo</u>:

              $ jo -p name=Jane point[]=1 point[]=2 geo[lat]=10 geo[lon]=20
              {
                 "name": "Jane",
                 "point": [
                    1,
                    2
                 ],
                 "geo": {
                    "lat": 10,
                    "lon": 20
                 }
              }

       The same example, using object paths:

              $ jo -p -d. name=Jane point[]=1 point[]=2 geo.lat=10 geo.lon=20
              {
                 "name": "Jane",
                 "point": [
                    1,
                    2
                 ],
                 "geo": {
                    "lat": 10,
                    "lon": 20
                 }
              }

       Without <b>-d</b>, a different object is generated:

              $ jo -p name=Jane point[]=1 point[]=2 geo.lat=10 geo.lon=20
              {
                 "name": "Jane",
                 "point": [
                    1,
                    2
                 ],
                 "geo.lat": 10,
                 "geo.lon": 20
              }

       Create empty objects or arrays, intentionally or potentially:

              $ jo &lt; /dev/null
              {}

              $ MY_ARRAY=(a=1 b=2)
              $ jo -a "${MY_ARRAY[@]}" &lt; /dev/null
              ["a=1","b=2"]

       Type coercion:

              $ jo -p -- -s a=true b=true -s c=123 d=123 -b e="1" -b f="true" -n g="This is a test" -b h="This is a test"
              {
                 "a": "true",
                 "b": true,
                 "c": "123",
                 "d": 123,
                 "e": true,
                 "f": true,
                 "g": 14,
                 "h": true
              }

              $ jo -a -- -s 123 -n "This is a test" -b C_Rocks 456
              ["123",14,true,456]

       Read  element values from files: a value which starts with <b>@</b> is read in plain whereas if it begins with a
       <b>%</b> it will be base64-encoded and if it starts with <b>:</b> the contents are interpreted as JSON:

              $ jo program=jo authors=@AUTHORS
              {"program":"jo","authors":"Jan-Piet Mens &lt;<a href="mailto:jpmens@gmail.com">jpmens@gmail.com</a>&gt;"}

              $ jo filename=AUTHORS content=%AUTHORS
              {"filename":"AUTHORS","content":"SmFuLVBpZXQgTWVucyA8anBtZW5zQGdtYWlsLmNvbT4K"}

              $ jo nested=:nested.json
              {"nested":{"field1":123,"field2":"abc"}}

       These characters can be escaped to avoid interpretation:

              $ jo name="JP Mens" twitter='\@jpmens'
              {"name":"JP Mens","twitter":"@jpmens"}

              $ jo char=" " URIescape=\\%20
              {"char":" ","URIescape":"%20"}

              $ jo action="split window" vimcmd="\:split"
              {"action":"split window","vimcmd":":split"}

       Read element values from a file in order to overcome ARG_MAX limits during object assignment:

              $ ls | jo -a &gt; child.json
              $ jo files:=child.json
              {"files":["AUTHORS","COPYING","ChangeLog" ....

              $ ls *.c | jo -a &gt; source.json; ls *.h | jo -a &gt; headers.json
              $ jo -a :source.json :headers.json
              [["base64.c","jo.c","json.c"],["base64.h","json.h"]]

       Add elements to existing JSON:

              $ jo -f source.json 1 | jo -f - 2 3
              ["base64.c","jo.c","json.c",1,2,3]

              $ curl -s 'https://noembed.com/embed?url=https://www.youtube.com/watch?v=dQw4w9WgXcQ' | jo -f - status=Rickrolled
              { ...., "type":"video","author_url":"https://www.youtube.com/user/RickAstleyVEVO","status":"Rickrolled"}

       Deduplicate object keys (<u>jo</u> appends duplicate object keys by default):

              $ jo a=1 b=2 a=3
              {"a":1,"b":2,"a":3}
              $ jo -D a=1 b=2 a=3
              {"a":3,"b":2}

</pre><h4><b>OPTIONS</b></h4><pre>
       <u>jo</u> understands the following global options.

       -a     Interpret the list of <u>words</u> as array values and produce an array instead of an object.

       -B     By default, <u>jo</u> interprets the strings “<b>true</b>” and “<b>false</b>” as boolean elements <b>true</b>  and  <b>false</b>  re‐
              spectively, and “<b>null</b>” as <b>null</b>.  Disable with this option.

       -D     Deduplicate object keys.

       -e     Ignore empty stdin (i.e. don’t produce a diagnostic error when <u>stdin</u> is empty)

       -n     Do not add keys with empty values.

       -p     Pretty-print the JSON string on output instead of the terse one-line output it prints by default.

       -v     Show version and exit.

       -V     Show version as a JSON object and exit.

</pre><h4><b>BUGS</b></h4><pre>
       Probably.

       If  a  value given to <u>jo</u> expands to empty in the shell, then <u>jo</u> produces a <b>null</b> in object mode, and might
       appear to hang in array mode; it is not hanging, rather it’s reading <u>stdin</u>.  This is not a bug.

       Numeric values are converted to numbers which can produce undesired results.  If you quote a numeric val‐
       ue, <u>jo</u> will make it a string.  Compare the following:

              $ jo a=1.0
              {"a":1}
              $ jo a=\"1.0\"
              {"a":"1.0"}

       Omitting a closing bracket on a nested element causes a diagnostic message to print, but the output  con‐
       tains garbage anyway.  This was designed thusly.

</pre><h4><b>RETURN</b> <b>CODES</b></h4><pre>
       <u>jo</u> exits with a code 0 on success and non-zero on failure after indicating what caused the failure.

</pre><h4><b>AVAILABILITY</b></h4><pre>
       &lt;<a href="http://github.com/jpmens/jo">http://github.com/jpmens/jo</a>&gt;

</pre><h4><b>CREDITS</b></h4><pre>
       • This program uses <b>json.[ch]</b>, by Joseph A.  Adams.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       • &lt;https://stedolan.github.io/jq/&gt;

       • &lt;https://github.com/micha/jsawk&gt;

       • &lt;https://github.com/jtopjian/jsed&gt;

       • <a href="../man3/strtod.3.html">strtod</a>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       Jan-Piet Mens &lt;<a href="http://jpmens.net">http://jpmens.net</a>&gt;

User Manuals                                                                                               <u><a href="../man1/JO.1.html">JO</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>