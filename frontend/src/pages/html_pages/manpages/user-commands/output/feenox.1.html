<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FeenoX - a cloud-first free no-X uniX-like finite-element(ish) computational engineering tool</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/feenox">feenox_1.0.133-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FeenoX - a cloud-first free no-X uniX-like finite-element(ish) computational engineering tool

</pre><h4><b>SYNOPSIS</b></h4><pre>
       The basic usage is to execute the <b>feenox</b> binary passing a path to an input file that defines the problem,
       along with other options and command-line replacement arguments which are explained below:

       <b>feenox</b> [<u>options</u> ...]  <u>input-file</u> [<u>optional_commandline_replacement_arguments</u> ...]

       For large problems that do not fit in a single computer, a parallel run using <b><a href="../man1/mpirun.1.html">mpirun</a></b>(1) will be needed:

       <b>mpirun</b>  <b>-n</b> <u>number_of_threads</u> <b>feenox</b> [<u>options</u> ...]  <u>input-file</u> [<u>optional_commandline_replacement_arguments</u>
       ...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       FeenoX is a computational  tool  that  can  solve  engineering  problems  which  are  usually  casted  as
       differential-algebraic  equations  (DAEs)  or  partial  differential  equations  (PDEs).  It is to finite
       elements programs and libraries what Markdown is to Word and TeX, respectively.  In  particular,  it  can
       solve

       • dynamical systems defined by a set of user-provided DAEs (such as plant control dynamics for example)

       • mechanical elasticity

       • heat conduction

       • structural modal analysis

       • neutron diffusion

       • neutron transport

       FeenoX  reads  a plain-text input file which contains the problem definition and writes 100%-user defined
       results in ASCII (through PRINT or other user-defined output instructions within the  input  file).   For
       PDE  problems,  it needs a reference to at least one Gmsh mesh file for the discretization of the domain.
       It can write post-processing views in either .msh or .vtk formats.

       Keep in mind that FeenoX is just a back end reading a set of input files and  writing  a  set  of  output
       files  following  the  design  philosophy  of  Unix  (separation,  composition,  representation, economy,
       extensibility, etc).  Think of it as a transfer function (or a filter in computer-science jargon) between
       input files and output files:

                                           +------------+
               mesh (*.msh)  }             |            |             { terminal
               data (*.dat)  } input ----&gt; |   FeenoX   |----&gt; output { data files
               input (*.fee) }             |            |             { post (vtk/msh)
                                           +------------+

       Following the Unix programming philosophy, there are no graphical interfaces attached to the FeenoX core,
       although a wide variety of  pre  and  post-processors  can  be  used  with  FeenoX.   To  illustrate  the
       transfer-function approach, consider the following input file that solves Laplace’s equation ∇^2^<u>ϕ</u> = 0 on
       a square with some space-dependent boundary conditions:

       <u>ϕ</u>(<u>x</u>, <u>y</u>) = +<u>y</u>   for <u>x</u> = −1 (left)

       <u>ϕ</u>(<u>x</u>, <u>y</u>) = −<u>y</u>   for <u>x</u> = +1 (right)

       ∇<u>ϕ</u> ⋅ <u>n̂</u> = sin (<u>π</u>/2<u>x</u>)   for <u>y</u> = −1 (bottom)

       ∇<u>ϕ</u> ⋅ <u>n̂</u> = 0   for <u>y</u> = +1 (top)

              PROBLEM laplace 2d
              READ_MESH square-centered.msh # [-1:+1]x[-1:+1]

              # boundary conditions
              BC left    phi=+y
              BC right   phi=-y
              BC bottom  dphidn=sin(pi/2*x)
              BC top     dphidn=0

              SOLVE_PROBLEM

              # same output in .msh and in .vtk formats
              WRITE_MESH laplace-square.msh phi VECTOR dphidx dphidy 0
              WRITE_MESH laplace-square.vtk phi VECTOR dphidx dphidy 0

       Laplace’s equation solved with FeenoX

       The  .msh  file  can  be post-processed with Gmsh, and the .vtk file can be post-processed with Paraview.
       See https://www.caeplex.com for a mobile-friendly web-based interface for solving finite elements in  the
       cloud directly from the browser.

</pre><h4><b>OPTIONS</b></h4><pre>
              feenox [options] inputfile [replacement arguments] [petsc options]

       -h, --help
              display options and detailed explanations of command-line usage

       -v, --version
              display brief version information and exit

       -V, --versions
              display detailed version information

       -c, --check
              validates if the input file is sane or not

       --pdes list the types of PROBLEMs that FeenoX can solve, one per line

       --elements_info
              output a document with information about the supported element types

       --ast  dump an abstract syntax tree of the input

       --linear
              force FeenoX to solve the PDE problem as linear

       --non-linear
              force FeenoX to solve the PDE problem as non-linear

       --progress
              print ASCII progress bars when solving PDEs

       --mumps
              ask PETSc to use the direct linear solver MUMPS

       Instructions will be read from standard input if “-” is passed as inputfile, i.e.

              $ echo 'PRINT 2+2' | feenox -
              4

       The  optional  [replacement  arguments]  part of the command line mean that each argument after the input
       file that does not start with an hyphen will be expanded verbatim in the input file in each occurrence of
       $1, $2, etc.  For example

              $ echo 'PRINT $1+$2' | feenox - 3 4
              7

       PETSc and SLEPc options can be passed in [petsc options] (or [options]) as well, with the difference that
       two hyphens have to be used instead of only once.  For example, to pass the PETSc  option  -ksp_view  the
       actual FeenoX invocation should be

              $ feenox input.fee --ksp_view

       For PETSc options that take values, en equal sign has to be used:

              $ feenox input.fee --mg_levels_pc_type=sor

       See https://www.seamplex.com/feenox/examples for annotated examples.

</pre><h4><b>EXAMPLES</b></h4><pre>
</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
</pre><h4><b>ENVIRONMENT</b></h4><pre>
</pre><h4><b>FILES</b></h4><pre>
</pre><h4><b>CONFORMING</b> <b>TO</b></h4><pre>
</pre><h4><b>INPUT-FILE</b> <b>KEYWORDS</b></h4><pre>
   <b>GENERIC</b> <b>KEYWORDS</b>
   ABORT
       Catastrophically abort the execution and quit FeenoX.

              ABORT

       Whenever  the  instruction ABORT is executed, FeenoX quits with a non-zero error leve.  It does not close
       files nor unlock shared memory objects.  The objective of this instruction is  to  either  debug  complex
       input files by using only parts of them or to conditionally abort the execution using IF clauses.

   ALIAS
       Define a scalar alias of an already-defined identifier.

              ALIAS { &lt;new_var_name&gt; IS &lt;existing_object&gt; | &lt;existing_object&gt; AS &lt;new_name&gt; }

       The existing object can be a variable, a vector element or a matrix element.  In the first case, the name
       of  the variable should be given as the existing object.  In the second case, to alias the second element
       of vector v to the new name new, <a href="../man2/v.2.html">v</a>(2) should be given as the existing object.   In  the  third  case,  to
       alias  second  element  (2,3)  of  matrix  M  to the new name new, M(2,3) should be given as the existing
       object.

   CLOSE
       Explicitly close a file after input/output.

              CLOSE &lt;name&gt;

       The given &lt;name&gt; can be either a fixed-string path or an already-defined FILE.

   DEFAULT_ARGUMENT_VALUE
       Give a default value for an optional commandline argument.

              DEFAULT_ARGUMENT_VALUE &lt;constant&gt; &lt;string&gt;

       If a $n construction is found in the input file but the commandline argument was not given,  the  default
       behavior  is  to  fail  complaining that an extra argument has to be given in the commandline.  With this
       keyword, a default value can be assigned if no argument is given, thus avoiding the  failure  and  making
       the  argument  optional.   The  &lt;constant&gt;  should  be  1,  2,  3,  etc.   and  &lt;string&gt; will be expanded
       character-by-character where the  $n  construction  is.   Whether  the  resulting  expression  is  to  be
       interpreted as a string or as a numerical expression will depend on the context.

   FILE
       Define a file with a particularly formatted name to be used either as input or as output.

              &lt; FILE | OUTPUT_FILE | INPUT_FILE &gt; &lt;name&gt; PATH &lt;format&gt; expr_1 expr_2 ... expr_n [ INPUT | OUTPUT | APPEND | MODE &lt;fopen_mode&gt; ]

       For  reading  or writing into files with a fixed path, this instruction is usually not needed as the FILE
       keyword of other instructions (such as PRINT or MESH) can  take  a  fixed-string  path  as  an  argument.
       However,  if  the  file  name  changes as the execution progresses (say because one file for each step is
       needed), then an explicit FILE needs to be defined with this keyword and later referenced  by  the  given
       name.
       The  path  should  be  given  as  a printf-like format string followed by the expressions which should be
       evaluated in order to obtain the actual  file  path.   The  expressions  will  always  be  floating-point
       expressions,  but the particular integer specifier %d is allowed and internally transformed to %.0f.  The
       file can be explicitly defined and INPUT, OUTPUT or a certain fopen() mode can be given  (i.e. “a”).   If
       not  explicitly  given,  the  nature  of the file will be taken from context, i.e. FILEs in PRINT will be
       OUTPUT and FILEs in FUNCTION will be INPUT.  This keyword just defines the FILE, it  does  not  open  it.
       The  file  will  be  actually  opened  (and eventually closed) automatically.  In the rare case where the
       automated opening and closing does not fit the expected workflow, the file can be  explicitly  opened  or
       closed with the instructions FILE_OPEN and FILE_CLOSE.

   FIT
       Find parameters to fit an analytical function to a pointwise-defined function.

              FIT &lt;function_to_be_fitted&gt;  TO &lt;function_with_data&gt; VIA &lt;var_1&gt; &lt;var_2&gt; ... &lt;var_n&gt;
               [ GRADIENT &lt;expr_1&gt; &lt;expr_2&gt; ... &lt;expr_n&gt; ]
               [ RANGE_MIN &lt;expr_1&gt; &lt;expr_2&gt; ... &lt;expr_j&gt; ]
               [ RANGE_MAX &lt;expr_1&gt; &lt;expr_2&gt; ... &lt;expr_n&gt; ]
               [ TOL_REL &lt;expr&gt; ] [ TOL_ABS &lt;expr&gt; ] [ MAX_ITER &lt;expr&gt; ]
               [ VERBOSE ]

       The  function  with  the data has to be point-wise defined (i.e. a FUNCTION read from a file, with inline
       DATA or defined over a mesh).  The function to be fitted has to be parametrized with at least one of  the
       variables  provided  after  the  USING  keyword.   For  example  to  fit <u>f</u>(<u>x</u>, <u>y</u>) = <u>ax</u>^2^ + <u>bsqrt</u>(<u>y</u>)  to a
       pointwise-defined function <u>g</u>(<u>x</u>, <u>y</u>) one gives FIT f TO g VIA a b.  Only the names of the functions have to
       be given, not the arguments.  Both functions have to have the same  number  of  arguments.   The  initial
       guess  of  the solution is given by the initial value of the variables after the VIA keyword.  Analytical
       expressions for the gradient of the function to be fitted with respect to the parameters to be fitted can
       be optionally given with the GRADIENT keyword.  If none  is  provided,  the  gradient  will  be  computed
       numerically  using finite differences.  A range over which the residuals are to be minimized can be given
       with RANGE_MIN and RANGE_MAX.  The expressions give the range of the arguments of the functions,  not  of
       the  parameters.   For  multidimensional  fits, the range is an hypercube.  If no range is given, all the
       definition points of the function with the data are used for the fit.  Convergence can be  controlled  by
       giving  the  relative  and absolute tolreances with TOL_REL (default DEFAULT_NLIN_FIT_EPSREL) and TOL_ABS
       (default  DEFAULT_NLIN_FIT_EPSABS),  and  with  the  maximum  number  of  iterations  MAX_ITER   (default
       DEFAULT_NLIN_FIT_MAX_ITER).   If  the  optional  keyword  VERBOSE is given, some data of the intermediate
       steps is written in the standard output.

   FUNCTION
       Define a scalar function of one or more variables.

              FUNCTION &lt;function_name&gt;(&lt;var_1&gt;[,var2,...,var_n]) {
                 = &lt;expr&gt; |
                 FILE { &lt;file&gt; } |
                 VECTORS &lt;vector_1&gt; &lt;vector_2&gt; ... &lt;vector_n&gt; &lt;vector_data&gt; |
                 MESH &lt;mesh&gt; |
                 DATA &lt;num_1&gt; &lt;num_2&gt; ... &lt;num_N&gt;
               }
               [ COLUMNS &lt;expr_1&gt; &lt;expr_2&gt; ... &lt;expr_n&gt; &lt;expr_n+1&gt; ]
               [ INTERPOLATION { linear | polynomial | spline | spline_periodic | akima | akima_periodic | steffen |
               nearest | shepard | shepard_kd | bilinear } ]
               [ INTERPOLATION_THRESHOLD &lt;expr&gt; ] [ SHEPARD_RADIUS &lt;expr&gt; ] [ SHEPARD_EXPONENT &lt;expr&gt; ]

       The number of variables <u>n</u> is given by the  number  of  arguments  given  between  parenthesis  after  the
       function  name.   The  arguments  are  defined  as  new  variables  if  they had not been already defined
       explicitly as scalar variables.  If the function is given as  an  algebraic  expression,  the  short-hand
       operator  =  (or  :=  for compatibility with Maxima) can be used.  That is to say, FUNCTION f(x) = x^2 is
       equivalent to f(x) = x^2 (or f(x) := x^2).  If a FILE is given, an ASCII file containing at  least  <u>n</u> + 1
       columns is expected.  By default, the first <u>n</u> columns are the values of the arguments and the last column
       is  the  value of the function at those points.  The order of the columns can be changed with the keyword
       COLUMNS, which expects <u>n</u> + 1 expressions corresponding to the column numbers.  If VECTORS is given, a set
       of <u>n</u> + 1 vectors of the same size is expected.  The first <u>n</u> correspond to the arguments and the last  one
       to  the  function  values.   If MESH is given, the function is point-wise defined over the mesh topology.
       That is to say, the independent variables (i.e. the spatial coordinates) coincide with  the  mesh  nodes.
       The dependent variable (i.e. the function value) is set by “filling” a vector named vec_f (where f has to
       be replaced with the function name) of size equal to the number of nodes.
       The function can be pointwise-defined inline in the input using DATA.  This should be the last keyword of
       the  line,  followed by <u>N</u> = <u>k</u> ⋅ (<u>n</u> + 1) expressions giving <u>k</u> definition points: <u>n</u> arguments and the value
       of the function.  Multiline  continuation  using  brackets  {  and  }  can  be  used  for  a  clean  data
       organization.   Interpolation  schemes  can  be  given for either one or multi-dimensional functions with
       INTERPOLATION.  Available schemes for <u>n</u> = 1 are:

       • linear

       • polynomial, the grade is equal to the number of data minus one

       • spline, cubic (needs at least 3 points)

       • spline_periodic

       • akima (needs at least 5 points)

       • akima_periodic (needs at least 5 points)

       • steffen, always-monotonic splines-like interpolator

       Default interpolation scheme for one-dimensional functions is DEFAULT_INTERPOLATION.

       Available schemes for <u>n</u> &gt; 1 are:

       • nearest, <u>f</u>(<u>x⃗</u>) is equal to the value of the closest definition point

       • shepard, inverse distance weighted average definition points (might lead to inefficient evaluation)

       • shepard_kd, average  of  definition  points  within  a  kd-tree  (more  efficient  evaluation  provided
         SHEPARD_RADIUS is set to a proper value)

       • bilinear,  only  available  if  the  definition points configure an structured hypercube-like grid.  If
         <u>n</u> &gt; 3, SIZES should be given.

       For <u>n</u> &gt; 1, if the euclidean distance between the arguments and the  definition  points  is  smaller  than
       INTERPOLATION_THRESHOLD,  the  definition  point  is returned and no interpolation is performed.  Default
       value is square root of DEFAULT_MULTIDIM_INTERPOLATION_THRESHOLD.

       The initial radius of points to take into account in shepard_kd is given by SHEPARD_RADIUS.  If no points
       are found, the radius is double until at least one definition point is  found.   The  radius  is  doubled
       until  at  least  one  point  is  found.  Default is DEFAULT_SHEPARD_RADIUS.  The exponent of the shepard
       method is given by SHEPARD_EXPONENT.  Default is DEFAULT_SHEPARD_EXPONENT.

   IF
       Execute a set of instructions if a condition is met.

              IF expr
                &lt;block_of_instructions_if_expr_is_true&gt;
               [ ELSE
                &lt;block_of_instructions_if_expr_is_false&gt; ]
               ENDIF

   IMPLICIT
       Define whether implicit definition of variables is allowed or not.

              IMPLICIT { NONE | ALLOWED }

       By default, FeenoX allows variables (but not vectors nor matrices) to be implicitly declared.   To  avoid
       introducing errors due to typos, explicit declaration of variables can be forced by giving IMPLICIT NONE.
       Whether  implicit declaration is allowed or explicit declaration is required depends on the last IMPLICIT
       keyword given, which by default is ALLOWED.

   INCLUDE
       Include another FeenoX input file.

              INCLUDE &lt;file_path&gt; [ FROM &lt;num_expr&gt; ] [ TO &lt;num_expr&gt; ]

       Includes the input file located in the string file_path at the current location.  The effect is the  same
       as  copying  and  pasting  the contents of the included file at the location of the INCLUDE keyword.  The
       path can be relative or absolute.  Note, however,  that  when  including  files  inside  IF  blocks  that
       instructions  are conditionally-executed but all definitions (such as function definitions) are processed
       at parse-time independently from the evaluation of the conditional.  The  included  file  has  to  be  an
       actual  file  path (i.e. it cannot be a FeenoX FILE) because it needs to be resolved at parse time.  Yet,
       the name can contain a commandline replacement argument such as $1 so INCLUDE  $1.fee  will  include  the
       file  specified  after the main input file in the command line.  The optional FROM and TO keywords can be
       used to include only portions of a file.

   MATRIX
       Define a matrix.

              MATRIX &lt;name&gt; ROWS &lt;expr&gt; COLS &lt;expr&gt; [ DATA &lt;expr_1&gt; &lt;expr_2&gt; ... &lt;expr_n&gt; |

       A new matrix of the prescribed size is defined.  The number of rows and  columns  can  be  an  expression
       which  will  be  evaluated the very first time the matrix is used and then kept at those constant values.
       All elements will be initialized to zero unless DATA is given (which should be the last  keyword  of  the
       line),  in  which  case  the  expressions  will  be  evaluated the very first time the matrix is used and
       row-major-assigned to each of the elements.  If there  are  less  elements  than  the  matrix  size,  the
       remaining  values  will  be  zero.   If  there are more elements than the matrix size, the values will be
       ignored.

   OPEN
       Explicitly open a file for input/output.

              OPEN &lt;name&gt; [ MODE &lt;fopen_mode&gt; ]

       The given &lt;name&gt; can be either a fixed-string path or an already-defined FILE.  The mode  is  only  taken
       into account if the file is not already defined.  Default is write w.

   PRINT
       Write plain-text and/or formatted data to the standard output or into an output file.

              PRINT [ &lt;object_1&gt; &lt;object_2&gt; ... &lt;object_n&gt; ] [ TEXT &lt;string_1&gt; ... TEXT &lt;string_n&gt; ]
               [ FILE { &lt;file_path&gt; | &lt;file_id&gt; } ] [ HEADER ] [ NONEWLINE ] [ SEP &lt;string&gt; ]
               [ SKIP_STEP &lt;expr&gt; ] [ SKIP_STATIC_STEP &lt;expr&gt; ] [ SKIP_TIME &lt;expr&gt; ] [ SKIP_HEADER_STEP &lt;expr&gt; ]

       Each argument object which is not a keyword of the PRINT instruction will be part of the output.  Objects
       can be either a matrix, a vector or any valid scalar algebraic expression.  If the given object cannot be
       solved  into  a  valid  matrix,  vector  or  expression, it is treated as a string literal if IMPLICIT is
       ALLOWED, otherwise a parser error is raised.  To explicitly interpret an object as a literal string  even
       if it resolves to a valid numerical expression, it should be prefixed with the TEXT keyword such as PRINT
       TEXT  1+1  that  would print 1+1 instead of 2.  Objects and string literals can be mixed and given in any
       order.  Hashes # appearing literal in text strings have to be quoted to prevent the parser to treat  them
       as comments within the FeenoX input file and thus ignoring the rest of the line, like PRINT "\# this is a
       printed  comment".   Whenever  an  argument  starts  with  a  porcentage  sign  %,  it  is treated as a C
       printf-compatible format specifier and all the objects that follow it are printed using the given  format
       until  a  new  format  definition  is  found.  The objects are treated as double-precision floating point
       numbers, so only floating point formats should be given.  See the <a href="../man3/printf.3.html">printf</a>(3) man page for further details.
       The default format is DEFAULT_PRINT_FORMAT.  Matrices, vectors, scalar expressions, format modifiers  and
       string  literals  can  be  given in any desired order, and are processed from left to right.  Vectors are
       printed element-by-element in a single row.  See PRINT_VECTOR to print  one  or  more  vectors  with  one
       element  per  line  (i.e. vertically).   Matrices  are  printed element-by-element in a single line using
       row-major ordering if mixed with other objects but in the natural row and column fashion  if  it  is  the
       only  given object in the PRINT instruction.  If the FILE keyword is not provided, default is to write to
       stdout.  If the HEADER keyword is given, a single line containing the literal text given for each  object
       is printed at the very first time the PRINT instruction is processed, starting with a hash # character.
       If  the  NONEWLINE  keyword  is  not  provided,  default is to write a newline \n character after all the
       objects are processed.  Otherwise, if the last token to be printed is  a  numerical  value,  a  separator
       string  will  be  printed  but  not the newline \n character.  If the last token is a string, neither the
       separator nor the newline will be printed.  The SEP keyword expects a string  used  to  separate  printed
       objects.   To  print  objects  without  any  separation in between give an empty string like SEP "".  The
       default is a tabulator character `DEFAULT_PRINT_SEPARATOR' character.  To print an empty line write PRINT
       without arguments.  By default  the  PRINT  instruction  is  evaluated  every  step.   If  the  SKIP_STEP
       (SKIP_STATIC_STEP)  keyword  is  given,  the  instruction is processed only every the number of transient
       (static)  steps  that  results  in  evaluating  the  expression,  which  may  not   be   constant.    The
       SKIP_HEADER_STEP  keyword works similarly for the optional HEADER but by default it is only printed once.
       The SKIP_TIME keyword use time advancements to choose  how  to  skip  printing  and  may  be  useful  for
       non-constant time-step problems.

   PRINTF
       Instruction akin to C’s printf.  Instruction akin to C’s printf executed locally from all MPI ranks.

              PRINTF PRINTF_ALL format_string [ expr_1 [ expr_2 [ ... ] ] ]

       The  format_string  should  be  a  printf-like  string  containing double-precision format specifiers.  A
       matching number of expressions should be given.  No newline is written if not explicitly asked for in the
       format string with \n.
       Do not ask for string literals %s.
       As always, to get a literal % use %% in the format string.

   PRINT_FUNCTION
       Print one or more functions as a table of values of dependent and independent variables.

              PRINT_FUNCTION &lt;function_1&gt; [ { function | expr } ... { function | expr } ]
               [ FILE { &lt;file_path&gt; | &lt;file_id&gt; } ] [ HEADER ]
               [ MIN &lt;expr_1&gt; &lt;expr_2&gt; ... &lt;expr_k&gt; ] [ MAX &lt;expr_1&gt; &lt;expr_2&gt; ... &lt;expr_k&gt; ]
               [ STEP &lt;expr_1&gt; &lt;expr_2&gt; ... &lt;expr_k&gt; ] [ NSTEPs &lt;expr_1&gt; &lt;expr_2&gt; ... &lt;expr_k&gt; ]
               [ FORMAT &lt;print_format&gt; ] &lt;vector_1&gt; [ { vector | expr } ... { vector | expr } ]

       Each argument should be either a function or an expression.  The  output  of  this  instruction  consists
       of <u>n</u> + <u>k</u>  columns,  where <u>n</u>  is  the  number  of arguments of the first function of the list and <u>k</u> is the
       number of functions and expressions given.  The first <u>n</u> columns are the arguments (independent variables)
       and the last <u>k</u> one has the  evaluated  functions  and  expressions.   The  columns  are  separated  by  a
       tabulator,  which  is  the  format  that  most  plotting  tools  understand.  Only function names without
       arguments are expected.  All functions should have the same number of arguments.  Expressions can involve
       the arguments of the first function.  If the FILE keyword is not provided, default is to write to stdout.
       If HEADER is given, the output is prepended with a single line containing the names of the arguments  and
       the  names  of  the functions, separated by tabs.  The header starts with a hash # that usually acts as a
       comment and is ignored by most plotting tools.  If there is no  explicit  range  where  to  evaluate  the
       functions and the first function is point-wise defined, they are evalauted at the points of definition of
       the  first  one.  The range can be explicitly given as a product of <u>n</u> ranges [<u>x</u>~<u>i</u>, min ~, <u>x</u>~<u>i</u>, max ~] for
       <u>i</u> = 1, ..., <u>n</u>.
       The values <u>x</u>~<u>i</u>, min ~ and <u>x</u>~<u>i</u>, max ~ are given with the MIN <u>and</u> MAX keywords.  The  discretization  steps
       of  the  ranges  are given by either STEP that gives <u>δx</u> <u>or</u> NSTEPS that gives the number of steps.  If the
       first function is not point-wise defined, the ranges are mandatory.

   PRINT_VECTOR
       Print the elements of one or more vectors, one element per line.

              PRINT_VECTOR
               [ FILE { &lt;file_path&gt; | &lt;file_id&gt; } ] [ HEADER ]
               [ SEP &lt;string&gt; ]

       Each argument should be either a vector or an expression of the integer i.  If the FILE  keyword  is  not
       provided,  default is to write to stdout.  If HEADER is given, the output is prepended with a single line
       containing the names of the arguments and the names of the functions,  separated  by  tabs.   The  header
       starts  with  a  hash #  that  usually  acts as a comment and is ignored by most plotting tools.  The SEP
       keyword expects a string used to separate printed objects.  To print objects without  any  separation  in
       between give an empty string like SEP "".  The default is a tabulator character `DEFAULT_PRINT_SEPARATOR'
       character.

   SOLVE
       Solve a (small) system of non-linear equations.

              SOLVE FOR &lt;n&gt; UNKNOWNS &lt;var_1&gt; &lt;var_2&gt; ... &lt;var_n&gt; [ METHOD { dnewton | hybrid | hybrids | broyden } ]
               [ EPSABS &lt;expr&gt; ] [ EPSREL &lt;expr&gt; ] [ MAX_ITER &lt;expr&gt; ]

   SORT_VECTOR
       Sort the elements of a vector, optionally making the same rearrangement in another vector.

              SORT_VECTOR &lt;vector&gt; [ ASCENDING | DESCENDING ] [ &lt;other_vector&gt; ]

       This  instruction sorts the elements of &lt;vector&gt; into either ascending or descending numerical order.  If
       &lt;other_vector&gt; is given, the same rearrangement is made on it.  Default is ascending order.

   VAR
       Explicitly define one or more scalar variables.

              VAR &lt;name_1&gt; [ &lt;name_2&gt; ] ... [ &lt;name_n&gt; ]

       When implicit definition is allowed (see IMPLICIT), scalar variables need not to be defined before  being
       used  if from the context FeenoX can tell that an scalar variable is needed.  For instance, when defining
       a function like f(x) = x^2 it is not needed to declare x explicitly as a scalar  variable.   But  if  one
       wants  to  define  a  function  like  g(x)  =  integral(f(x'), x', 0, x) then the variable x' needs to be
       explicitly defined as VAR x' before the integral.

   VECTOR
       Define a vector.

              VECTOR &lt;name&gt; SIZE &lt;expr&gt; [ FUNCTION_DATA &lt;function&gt; ] [ DATA &lt;expr_1&gt; &lt;expr_2&gt; ... &lt;expr_n&gt; |

       A new vector of the prescribed size is defined.  The size can be an expression which  will  be  evaluated
       the  very  first  time  the  vector  is  used  and  then  kept  at  that  constant value.  If the keyword
       FUNCTION_DATA is given, the elements of the vector will be synchronized with the  inpedendent  values  of
       the  function,  which should be point-wise defined.  The sizes of both the function and the vector should
       match.  All elements will be initialized to zero unless DATA is given (which should be the  last  keyword
       of  the line), in which case the expressions will be evaluated the very first time the vector is used and
       assigned to each of the elements.  If there are less elements than the vector size, the remaining  values
       will be zero.  If there are more elements than the vector size, the values will be ignored.

   <b>DAE-RELATED</b> <b>KEYWORDS</b>
   INITIAL_CONDITIONS
       Define how initial conditions of DAE problems are computed.

              INITIAL_CONDITIONS { AS_PROVIDED | FROM_VARIABLES | FROM_DERIVATIVES }

       In DAE problems, initial conditions may be either:

       • equal to the provided expressions (AS_PROVIDED)

       • the derivatives computed from the provided phase-space variables (FROM_VARIABLES)

       • the phase-space variables computed from the provided derivatives (FROM_DERIVATIVES)

       In  the  first  case,  it is up to the user to fulfill the DAE system at <u>t</u> = 0.  If the residuals are not
       small enough, a convergence error will occur.  The FROM_VARIABLES option means  calling  IDA’s  IDACalcIC
       routine  with  the  parameter IDA_YA_YDP_INIT.  The FROM_DERIVATIVES option means calling IDA’s IDACalcIC
       routine with the parameter IDA_Y_INIT.  Wasora should be able to automatically detect which variables  in
       phase-space  are  differential  and which are purely algebraic.  However, the DIFFERENTIAL keyword may be
       used to explicitly define them.  See the SUNDIALS documentation for further information.

   PHASE_SPACE
       Ask FeenoX to solve a set of algebraic-differntial equations and define  the  variables,  vectors  and/or
       matrices that span the phase space.

              PHASE_SPACE PHASE_SPACE &lt;vars&gt; ... &lt;vectors&gt; ... &lt;matrices&gt; ...

   TIME_PATH
       Force time-dependent problems to pass through specific instants of time.

              TIME_PATH &lt;expr_1&gt; [ &lt;expr_2&gt;  [ ... &lt;expr_n&gt; ] ]

       The time step dt will be reduced whenever the distance between the current time t and the next expression
       in  the  list  is  greater  than dt so as to force t to coincide with the expressions given.  The list of
       expressions should evaluate to a sorted list of values for all times.

   <b>PDE-RELATED</b> <b>KEYWORDS</b>
   BC
       Define a boundary condition to be applied to faces, edges and/or vertices.

              BC &lt;name&gt; [ MESH &lt;name&gt; ] [ GROUP &lt;name_1&gt;  GROUP &lt;name_2&gt; ... ] [ &lt;bc_data1&gt; &lt;bc_data2&gt; ... ] [ GROUPS &lt;name_1&gt;  &lt;name_2&gt; ... ]

       If the name of the boundary condition matches a physical group in the mesh, and neither GROUP nor  GROUPS
       are  given,  it  is automatically linked to that physical group.  If there are many meshes, the mesh this
       keyword refers to has to be given with MESH.  If the boundary condition applies to more than one physical
       group in the mesh, they can be added using as many GROUP keywords as needed.  Each &lt;bc_data&gt; argument  is
       a  single string whose meaning depends on the type of problem being solved.  For instance T=150*sin(x/pi)
       prescribes the temperature to depend on space as the provided expression in a thermal problem  and  fixed
       fixes  the  displacements  in  all  the  directions in a mechanical or modal problem.  See the particular
       section on boundary conditions for further details.  If the keyword GROUPS is given, then the rest of the
       tokens are parsed as group names where the boundary condition is applied.  If either GROUP or GROUPS  are
       given  explicitly,  then  the BC name is not used to try to implicitly link it to a physical group in the
       mesh.

   COMPUTE_REACTION
       Compute the reaction (force, moment, power, etc.)  at selected face, edge or vertex.

              COMPUTE_REACTION &lt;physical_group&gt; [ MOMENT [ X0 &lt;expr&gt; ] [ Y0 &lt;expr&gt; ] [ Z0 &lt;expr&gt; ] ] RESULT { &lt;variable&gt; | &lt;vector&gt; }

       If the MOMENT keyword is not given, the zero-th order reaction is computed, i.e. force in elasticity  and
       power  in  thermal.  If the MOMENT keyword is given, then the coordinates of the center can be given with
       X0, Y0 and Z0.  If they are not, the moment is computed about the barycenter of the physical group.   The
       resulting  reaction  will  be  stored  in the variable (thermal) or vector (elasticity) provided.  If the
       variable or vector does not exist, it will be created.

   DUMP
       Dump raw PETSc objects used to solve PDEs into files.

              DUMP [ FORMAT { binary | ascii | octave } ] [ K |   K_bc |   b |   b_bc |   M |   M_bc |

   FIND_EXTREMA
       Find and/or compute the absolute extrema of a function or expression over a mesh (or a subset of it).

              FIND_EXTREMA { &lt;expression&gt; | &lt;function&gt; } [ OVER &lt;physical_group&gt; ] [ MESH &lt;mesh_identifier&gt; ] [ NODES | CELLS | GAUSS ]
               [ MIN &lt;variable&gt; ] [ MAX &lt;variable&gt; ] [ X_MIN &lt;variable&gt; ] [ X_MAX &lt;variable&gt; ] [ Y_MIN &lt;variable&gt; ] [ Y_MAX &lt;variable&gt; ] [ Z_MIN &lt;variable&gt; ] [ Z_MAX &lt;variable&gt; ] [ I_MIN &lt;variable&gt; ] [ I_MAX &lt;variable&gt; ]

       Either an expression or a function of space <u>x</u>, <u>y</u> and/or <u>z</u> should be given.   By  default  the  search  is
       performed  over  the highest-dimensional elements of the mesh, i.e. over the whole volume, area or length
       for three, two and one-dimensional meshes, respectively.  If the search is to be carried out over just  a
       physical group, it has to be given in OVER.  If there are more than one mesh defined, an explicit one has
       to  be  given with MESH.  If neither NODES, CELLS or GAUSS is given then the search is performed over the
       three of them.  With NODES only the function or expression is evalauted at the mesh  nodes.   With  CELLS
       only  the  function  or  expression is evalauted at the element centers.  With GAUSS only the function or
       expression is evalauted at the Gauss points.  The value of the absolute minimum (maximum)  is  stored  in
       the  variable  indicated  by MIN (MAX).  If the variable does not exist, it is created.  The value of the
       <u>x</u>-<u>y</u>-<u>z</u> coordinate  of  the  absolute  minimum  (maximum)  is  stored  in   the   variable   indicated   by
       X_MIN-Y_MIN-Z_MIN (X_MAX-Y_MAX-Z_MAX).  If the variable does not exist, it is created.  The index (either
       node  or cell) where the absolute minimum (maximum) is found is stored in the variable indicated by I_MIN
       (I_MAX).

   INTEGRATE
       Spatially integrate a function or expression over a mesh (or a subset of it).

              INTEGRATE { &lt;expression&gt; | &lt;function&gt; } [ OVER &lt;physical_group&gt; ] [ MESH &lt;mesh_identifier&gt; ] [ GAUSS | CELLS ]
               RESULT &lt;variable&gt;

       Either an expression or a function of space <u>x</u>, <u>y</u> and/or <u>z</u>  should  be  given.   If  the  integrand  is  a
       function, do not include the arguments, i.e. instead of f(x,y,z) just write f.  The results should be the
       same  but  efficiency  will  be  different  (faster  for  pure functions).  By default the integration is
       performed over the highest-dimensional elements of the mesh, i.e. over the whole volume, area  or  length
       for  three,  two  and one-dimensional meshes, respectively.  If the integration is to be carried out over
       just a physical group, it has to be given in OVER.  If there are more than one mesh defined, an  explicit
       one  has  to  be  given  with MESH.  Either GAUSS or CELLS define how the integration is to be performed.
       With GAUSS the integration is performed using the Gauss points and weights  associated  to  each  element
       type.   With  CELLS  the integral is computed as the sum of the product of the integrand at the center of
       each cell (element) and the cell’s volume.  Do expect differences in the results and  efficiency  between
       these  two  approaches depending on the nature of the integrand.  The scalar result of the integration is
       stored in the variable given by the mandatory keyword RESULT.  If the variable  does  not  exist,  it  is
       created.

   MATERIAL
       Define a material its and properties to be used in volumes.

              MATERIAL &lt;name&gt; [ MESH &lt;name&gt; ] [ LABEL &lt;name_1&gt;  [ LABEL &lt;name_2&gt; [ ... ] ] ]
               [ &lt;property_name_1&gt;=&lt;expr_1&gt; [ &lt;property_name_2&gt;=&lt;expr_2&gt; [ ... ] ] ]

       If  the  name  of  the  material matches a physical group in the mesh, it is automatically linked to that
       physical group.  If there are many meshes, the mesh this keyword refers to has to be given with MESH.  If
       the material applies to more than one physical group in the mesh, they can be added using as  many  LABEL
       keywords  as  needed.   The  names of the properties in principle can be arbitrary, but each problem type
       needs a minimum set of properties defined with  particular  names.   For  example,  steady-state  thermal
       problems  need  at  least the conductivity which should be named k.  If the problem is transient, it will
       also need heat capacity rhocp  or  diffusivity alpha.   Mechanical  problems  need  Young  modulus E  and
       Poisson’s  ratio nu.   Modal also needs density rho.  Check the particular documentation for each problem
       type.  Besides these mandatory properties, any other one can be defined.  For instance, if one  mandatory
       property depended on the concentration of boron in the material, a new per-material property can be added
       named  boron  and then the function boron(x,y,z) can be used in the expression that defines the mandatory
       property.

   PETSC_OPTIONS
       Pass verbatim options to PETSc.

              PETSC_OPTIONS "command-line options for PETSc"

       Options for PETSc can be passed either in at run time in the command line (run with -h  to  see  how)  or
       they  can  be  set in the input file with PETSC_OPTIONS.  This is handy when a particular problem is best
       suited to be solved using a particular set of  options  which  can  the  be  embedded  into  the  problem
       definition.  @
       The string is passed verbatim to PETSc as if the options were set in the command line.  Note that in this
       case,  the  string is passed verbatim to PETSc.  This means that they are non-POSIX options but they have
       to be in the native PETSc format.  That is to say, while in the command line one would  give  --ksp_view,
       here  one  has  to  give  -ksp_view.   Conversely,  instead  of  --mg_levels_pc_type=sor  one has to give
       -mg_levels_pc_type sor.

   PHYSICAL_GROUP
       Explicitly defines a physical group of elements on a mesh.

              PHYSICAL_GROUP &lt;name&gt; [ MESH &lt;name&gt; ] [ DIMENSION &lt;expr&gt; ] [ ID &lt;expr&gt; ]
               [ MATERIAL &lt;name&gt; | | BC &lt;name&gt; [ BC ... ] ]

       This keyword should seldom be needed.  Most of the times, a combination of MATERIAL and BC  ought  to  be
       enough  for  most purposes.  The name of the PHYSICAL_GROUP keyword should match the name of the physical
       group defined within the input file.  If there is no physical group with the provided name in  the  mesh,
       this  instruction  has  no  effect.   If  there are many meshes, an explicit mesh can be given with MESH.
       Otherwise, the physical group is defined on the main mesh.  An explicit dimension of the  physical  group
       can be provided with DIMENSION.  An explicit id can be given with ID.  Both dimension and id should match
       the  values  in  the  mesh.   For  volumetric  elements, physical groups can be linked to materials using
       MATERIAL.  Note that if a material is created with the same name as a physical group in  the  mesh,  they
       will be linked automatically, so there is no need to use PHYSCAL_GROUP for this.  The MATERIAL keyword in
       PHYSICAL_GROUP  is  used  to link a physical group in a mesh file and a material in the feenox input file
       with different names.

       Likewise, for non-volumetric elements, physical groups can be linked to boundary using  BC.   As  in  the
       preceding  case,  if  a boundary condition is created with the same name as a physical group in the mesh,
       they will be linked automatically, so there is no need to use PHYSCAL_GROUP for this.  The BC keyword  in
       PHYSICAL_GROUP  is  used  to  link a physical group in a mesh file and a boundary condition in the feenox
       input file with different names.  Note that while there can be only one MATERIAL associated to a physical
       group, there can be many BCs associated to a physical group.

   PROBLEM
       Ask FeenoX to solve a partial differential equation problem.

              PROBLEM { laplace | mechanical | modal | neutron_diffusion | neutron_sn | thermal }
               [ 1D | 2D | 3D | DIM &lt;expr&gt; ] [ AXISYMMETRIC { x | y } ]
               [ MESH &lt;identifier&gt; ] [ PROGRESS ] [ DO_NOT_DETECT_HANGING_NODES | DETECT_HANGING_NODES | HANDLE_HANGING_NODES ]
               [ DETECT_UNRESOLVED_BCS | ALLOW_UNRESOLVED_BCS ]
               [ PREALLOCATE ] [ ALLOW_NEW_NONZEROS ] [ CACHE_J ] [ CACHE_B ]
               [ TRANSIENT | QUASISTATIC ] [ LINEAR | NON_LINEAR ]
               [ MODES &lt;expr&gt; ]
               [ PRECONDITIONER { gamg | mumps | lu | hypre | sor | bjacobi | cholesky | ... } ]
               [ LINEAR_SOLVER { gmres | mumps | bcgs | bicg | richardson | chebyshev | ... } ]
               [ NONLINEAR_SOLVER { newtonls | newtontr | nrichardson | ngmres | qn | ngs | ... } ]
               [ TRANSIENT_SOLVER { bdf | beuler | arkimex | rosw | glee | ... } ]
               [ TIME_ADAPTATION { basic | none | dsp | cfl | glee | ... } ]
               [ EIGEN_SOLVER { krylovschur | lanczos | arnoldi | power | gd | ... } ]
               [ SPECTRAL_TRANSFORMATION { shift | sinvert | cayley | ... } ]
               [ EIGEN_FORMULATION { omega | lambda } ]
               [ DIRICHLET_SCALING { absolute &lt;expr&gt; | relative &lt;expr&gt; } ]

       Currently, FeenoX can solve the following types of PDE-casted problems:

       • neutron_diffusion multi-group core-level neutron diffusion with a FEM formulation

       • neutron_sn multi-group core-level neutron transport using

         • discrete ordinates <u>S</u>~<u>N</u>~ for angular discretization, and

         • isoparametric finite elements for spatial discretization.

         If you are a programmer and want to contribute with another problem type, please do so!  Check out  the
         programming guide in the FeenoX repository.

       The  number  of  spatial  dimensions  of  the problem needs to be given either as 1d, 2d, 3d or after the
       keyword DIM.  Alternatively, one can define a MESH with an explicit DIMENSIONS  keyword  before  PROBLEM.
       Default  is  3D.  If the AXISYMMETRIC keyword is given, the mesh is expected to be two-dimensional in the
       <u>x</u>-<u>y</u> plane and the problem is assumed to be axi-symmetric around the given axis.  If there are  more  than
       one  MESHes defined, the one over which the problem is to be solved can be defined by giving the explicit
       mesh name with MESH.  By default, the first mesh to be defined in the input file  with  READ_MESH  (which
       can  be  defined  after the PROBLEM keyword) is the one over which the problem is solved.  If the keyword
       PROGRESS is given, three ASCII lines will show in the terminal  the  progress  of  the  ensamble  of  the
       stiffness  matrix (or matrices), the solution of the system of equations and the computation of gradients
       (stresses, heat fluxes, etc.), if applicable.  If either DETECT_HANGING_NODES or HANDLE_HANGING_NODES are
       given, an intermediate  check  for  nodes  without  any  associated  elements  will  be  performed.   For
       well-behaved  meshes  this  check is redundant so by default it is not done (DO_NOT_DETEC_HANGING_NODES).
       With  DETECT_HANGING_NODES,  FeenoX  will  report  the  tag  of  the  hanging  nodes  and   stop.    With
       HANDLE_HANGING_NODES,  FeenoX  will  fix  those  nodes  and try to solve the problem anyway.  By default,
       FeenoX checks that all physical groups referred to in the BC keywords exists (DETECT_UNRESOLVED_BCS).  If
       ALLOW_UNRESOLVED_BCS is given, FeenoX will ignore unresolved boundary conditions instead of  complaining.
       This  is  handy  when  using  the  same input for different meshes which might have different groups, for
       example solving the same problem using a full geometry or a symmetric geometry.  The latter  should  have
       at  least  one  symmetry BC whilst the former does not.  If the special variable end_time is zero, FeenoX
       solves a static problem—although the variable static_steps is still honored.  If  end_time  is  non-zero,
       FeenoX  solves  a transient or quasi-static problem.  This can be controlled by TRANSIENT or QUASISTATIC.
       By default FeenoX tries to detect whether the computation should be linear or  non-linear.   An  explicit
       mode  can  be  set  with  either  LINEAR  on NON_LINEAR.  The number of modes to be computed when solving
       eigenvalue problems is given by MODES.  The default value is problem dependent.  The preconditioner (PC),
       linear (KSP), non-linear (SNES) and time-stepper (TS) solver types be any of  those  available  in  PETSc
       (first option is the default):

       • List of PRECONDITIONERs https://petsc.org/release/manualpages/PC/PCType/.

       • List of LINEAR_SOLVERs https://petsc.org/release/manualpages/KSP/KSPType/.

       • List of NONLINEAR_SOLVERs https://petsc.org/release/manualpages/SNES/SNESType/.

       • List of TRANSIENT_SOLVERs <a href="http://petsc.org/release/docs/manualpages/TS/TSType.html">http://petsc.org/release/docs/manualpages/TS/TSType.html</a>.

       • List of TIME_ADAPTATIONs https://petsc.org/release/manualpages/TS/TSType/.

       • List of EIGEN_SOLVERs https://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSType.html.

       • List                                     of                                    SPECTRAL_TRANSFORMATIONs
         https://slepc.upv.es/documentation/current/docs/manualpages/ST/STType.html.

       If the EIGEN_FORMULATION is omega then <u>Kϕ</u> = <u>ω</u>^2^<u>Mϕ</u> is solved, and <u>Mϕ</u> = <u>λKϕ</u> if it is lambda.   Default  is
       lambda,  although  some  particular PDEs might change it (for example free-free modal switches to omega).
       The EIGEN_DIRICHLET_ZERO keyword controls which of the matrices has a zero and which one has  a  non-zero
       in  the  diagonal when setting Dirichlet boundary conditions.  Default is M, i.e. matrix <u>K</u> has a non-zero
       and matrix <u>M</u> has a zero.  This setting, along with EIGEN_FORMULATION determines which spectral transforms
       can a cannot be used: you cannot invert the matrix with the zero in the diagonal.  The  DIRICHLET_SCALING
       keyword  controls the way Dirichlet boundary conditions are scaled when computing the residual.  Roughly,
       it defines how to compute the parameter <u>α</u>.  If absolute, then <u>α</u> is equal to  the  given  expression.   If
       relative,  then <u>α</u> is equal to the given fraction of the average diagonal entries in the stiffness matrix.
       Default is <u>α</u> = 1.

   READ_MESH
       Read an unstructured mesh and (optionally) functions of space-time from a file.

              READ_MESH { &lt;file_path&gt; | &lt;file_id&gt; } [ DIM &lt;num_expr&gt; ]
               [ SCALE &lt;expr&gt; ] [ OFFSET &lt;expr_x&gt; &lt;expr_y&gt; &lt;expr_z&gt; ]
               [ INTEGRATION { full | reduced } ]
               [ MAIN ] [ UPDATE_EACH_STEP ]
               [ READ_FIELD &lt;name_in_mesh&gt; AS &lt;function_name&gt; ] [ READ_FIELD ... ]
               [ READ_FUNCTION &lt;function_name&gt; ] [READ_FUNCTION ...]

       Either a file identifier (defined previously with a FILE keyword) or a file path should  be  given.   The
       format is read from the extension, which should be either

       • .msh, .msh2 or .msh4 Gmsh ASCII format, versions 2.2, 4.0 or 4.1

       • .vtk ASCII legacy VTK

       • .frd CalculiX’s FRD ASCII output

       Note  than  only  MSH  is suitable for defining PDE domains, as it is the only one that provides physical
       groups (a.k.a labels) which are needed in order to define materials and boundary conditions.   The  other
       formats  are  primarily  supported to read function data contained in the file and eventually, to operate
       over these functions (i.e. take differences with other functions contained  in  other  files  to  compare
       results).  The file path or file id can be used to refer to a particular mesh when reading more than one,
       for instance in a WRITE_MESH or INTEGRATE keyword.  If a file path is given such as cool_mesh.msh, it can
       be later referred to as either cool_mesh.msh or just cool_mesh.
       The  spatial  dimensions  can  be  given  with  DIM.   If  material properties are uniform and given with
       variables, the number of dimensions are not needed and will be read from the file  at  runtime.   But  if
       either  properties  are  given  by  spatial  functions  or if functions are to be read from the mesh with
       READ_DATA or READ_FUNCTION, then the number of dimensions ought to be  given  explicitly  because  FeenoX
       needs to know how many arguments these functions take.  If either OFFSET and/or SCALE are given, the node
       locations  are  first  shifted  and then scaled by the provided values.  When defining several meshes and
       solving a PDE problem, the mesh used as the PDE domain is the one marked  with  MAIN.   If  none  of  the
       meshes  is explicitly marked as main, the first one is used.  If UPDATE_EACH_STEP is given, then the mesh
       data is re-read from the file at each time step.  Default is to read the mesh once, except  if  the  file
       path changes with time.  For each READ_FIELD keyword, a point-wise defined scalar function of space named
       &lt;function_name&gt;  is  defined  and  filled with the scalar data named &lt;name_in_mesh&gt; contained in the mesh
       file.  The READ_FUNCTION keyword is a shortcut when the scalar name and the  to-be-defined  function  are
       the same.  If no mesh is marked as MAIN, the first one is the main one.

   SOLVE_PROBLEM
       Explicitly solve the PDE problem.

              SOLVE_PROBLEM

       Whenever  the instruction SOLVE_PROBLEM is executed, FeenoX solves the PDE problem.  For static problems,
       that means solving the equations and filling in the result  functions.   For  transient  or  quasisstatic
       problems, that means advancing one time step.

   WRITE_MESH
       Write a mesh and/or generic functions of space-time to a post-processing file.

              WRITE_MESH &lt;file&gt; [ MESH &lt;mesh_identifier&gt; ] [ FILE_FORMAT { gmsh | vtk } ] [ NO_MESH ] [ NO_PHYSICAL_NAMES ]
                [ NODE | CELL ] [ &lt;printf_specification&gt; ]
               [ &lt;scalar_field_1&gt; ] [ &lt;scalar_field_2&gt; ] [...]
               [ VECTOR [ NAME &lt;name&gt; ] &lt;field_x&gt; &lt;field_y&gt; &lt;field_z&gt; ] [...]
               [ SYMMETRIC_TENSOR [ NAME &lt;name&gt; ] &lt;field_xx&gt; &lt;field_yy&gt; &lt;field_zz&gt; &lt;field_xy&gt; &lt;field_yz&gt; &lt;field_zx&gt; ] [...]

       The  format  is automatically detected from the extension, which should be either msh (version 2.2 ASCII)
       or vtk (legacy ASCII).  Otherwise, the keyword FILE_FORMAT has to be given to set the format  explicitly.
       If there are several meshes defined by READ_MESH, the mesh used to write the data has be given explicitly
       with  MESH.   If  the NO_MESH keyword is given, only the results are written into the output file without
       any mesh data.  Depending on the output format, this can be used to avoid repeating data and/or  creating
       partial  output  files  which can the be latter assembled by post-processing scripts.  When targeting the
       .msh output format, if NO_PHYSICAL_NAMES is given then the section that sets  the  actual  names  of  the
       physical entities is not written.
       This  might  be  needed  in  some cases to avoid name clashes when dealing with multiple .msh files.  The
       output is node-based by default.  This can be controlled with both  the  NODE  and  CELL  keywords.   All
       fields  that come after a NODE (CELL) keyword will be written at the node (cells).  These keywords can be
       used several times and mixed with fields.  For example CELL k(x,y,z) NODE T sqrt(x^2+y^2) CELL  1+z  will
       write  the  conductivity  and  the  expression 1 + <u>z</u> as cell-based and the temperature <u>T</u>(<u>x</u>, <u>y</u>, <u>z</u>) and the
       expression $\sqrt{x^2+y^2}$ as a node-based fields.  If a printf-like format specifier starting with % is
       given, that format is used for the fields that follow.  Make sure the format reads  floating-point  data,
       i.e. do  not  use  %d.   Default  is  %g.   The  data  to be written has to be given as a list of fields,
       i.e. distributions (such as k or E),  functions  of  space  (such  as  T)  and/or  expressions  (such  as
       T(x,y,z)*sqrt(x^2+y^2+z^2)).   Each  field  is  written as a scalar, unless either the keywords VECTOR or
       SYMMETRIC_TENSOR are given.  In the first case, the next three fields following the  VECTOR  keyword  are
       taken  as the vector elements.  In the latter, the next six fields following the SYMMETRIC_TENSOR keyword
       are taken as the tensor elements.

   WRITE_RESULTS
       Write the problem mesh and problem results to a file for post-processing.

              WRITE_RESULTS [ FORMAT { gmsh | vtk } ] [ FILE &lt;file&gt; ]
               [ NO_PHYSICAL_NAMES ] [ &lt;printf_specification&gt; ]

       Default format is gmsh.  If no FILE is provided, the output file is the same as the input file  replacing
       the  .fee  extension  with the format extension, i.e. $0.msh.  If there are further optional command line
       arguments, they are added prepending a dash, i.e. $0-[$1-[$2...]].msh Otherwise the given FILE  is  used.
       If  no  explicit  FORMAT  is  given, the format is read from the FILE extension.  When targeting the .msh
       output format, if NO_PHYSICAL_NAMES is given then the section that sets the actual names of the  physical
       entities is not written.
       This  might  be  needed  in some cases to avoid name clashes when dealing with multiple .msh files.  If a
       printf-like format specifier starting with % is given, that format is used for the  fields  that  follow.
       Make sure the format reads floating-point data, i.e. do not use %d.  Default is %g.

</pre><h4><b>SPECIAL</b> <b>VARIABLES</b></h4><pre>
   done
       Flag that indicates whether the overall calculation is over.

       This  variable is set to true by FeenoX when the computation finished so it can be checked in an IF block
       to do something only in the last step.  But this variable can also be set to true from  the  input  file,
       indicating  that  the  current  step  should  also  be the last one.  For example, one can set end_time =
       infinite and then finish the computation at <u>t</u> = 10 by setting done = t &gt; 10.  This done variable can also
       come from (and sent to) other sources, like a shared memory object for coupled calculations.

   done_static
       Flag that indicates whether the static calculation is over or not.

       It is set to true (i.e.  ≠ 0) by feenox if step_static ≥ static_steps.  If the user sets it to true,  the
       current  step is marked as the last static step and the static calculation ends after finishing the step.
       It can be used in IF blocks to check if the static step is finished or not.

   done_transient
       Flag that indicates whether the transient calculation is over or not.

       It is set to true (i.e.  ≠ 0) by feenox if t ≥ end_time.  If the user sets it to true, the  current  step
       is marked as the last transient step and the transient calculation ends after finishing the step.  It can
       be used in IF blocks to check if the transient steps are finished or not.

   dt
       Actual value of the time step for transient calculations.

       When  solving  DAE systems, this variable is set by feenox.  It can be written by the user for example by
       importing it from another transient code by means of shared-memory objects.  Care should  be  taken  when
       solving DAE systems and overwriting t.  Default value is DEFAULT_DT, which is a power of two and roundoff
       errors are thus reduced.

   end_time
       Final time of the transient calculation, to be set by the user.

       The default value is zero, meaning no transient calculation.

   i
       Dummy index, used mainly in vector and matrix row subindex expressions.

   infinite
       A very big positive number.

       It  can  be used as end_time = infinite or to define improper integrals with infinite limits.  Default is
       2^50^ ≈ 1 × 10^15^.

   in_static
       Flag that indicates if FeenoX is solving the iterative static calculation.

       This is a read-only variable that is non zero if the static calculation.

   in_static_first
       Flag that indicates if feenox is in the first step of the iterative static calculation.

   in_static_last
       Flag that indicates if feenox is in the last step of the iterative static calculation.

   in_time_path
       Flag that indicates if feenox is in a time belonging to a TIME_PATH keyword.

   in_transient
       Flag that indicates if feenox is solving transient calculation.

   in_transient_first
       Flag that indicates if feenox is in the first step of the transient calculation.

   in_transient_last
       Flag that indicates if feenox is in the last step of the transient calculation.

   j
       Dummy index, used mainly in matrix column subindex expressions.

   max_dt
       Maximum bound for the time step that feenox should take when solving DAE systems.

   min_dt
       Minimum bound for the time step that feenox should take when solving DAE systems.

   mpi_rank
       The current rank in an MPI execution.  Mind the PRINTF_ALL instruction.

   mpi_size
       The number of total ranks in an MPI execution.

   on_gsl_error
       This should be set to a mask that indicates how to proceed if an error ir raised in any  routine  of  the
       GNU Scientific Library.

   on_ida_error
       This  should  be  set to a mask that indicates how to proceed if an error ir raised in any routine of the
       SUNDIALS Library.

   on_nan
       This should be set to a mask that indicates how to proceed if Not-A-Number signal (such as a division  by
       zero) is generated when evaluating any expression within feenox.

   pi
       A double-precision floating point representation of the number <u>π</u>

       It is equal to the M_PI constant in math.h .

   pid
       The Unix process id of the FeenoX instance.

   static_steps
       Number of steps that ought to be taken during the static calculation, to be set by the user.

       The default value is one, meaning only one static step.

   step_static
       Indicates the current step number of the iterative static calculation.

       This is a read-only variable that contains the current step of the static calculation.

   step_transient
       Indicates the current step number of the transient static calculation.

       This is a read-only variable that contains the current step of the transient calculation.

   t
       Actual value of the time for transient calculations.

       This  variable  is set by FeenoX, but can be written by the user for example by importing it from another
       transient code by means of shared-memory objects.  Care should be taken  when  solving  DAE  systems  and
       overwriting t.

   zero
       A very small positive number.

       It  is  taken to avoid roundoff errors when comparing floating point numbers such as replacing <u>a</u> ≤ <u>a</u>~max~
       with <u>a</u> &lt; <u>a</u>~max~+ zero.  Default is (1/2)^−50^ ≈ 9 × 10^−16^ .

</pre><h4><b>MATERIAL</b> <b>PROPERTIES</b></h4><pre>
       TBD.

</pre><h4><b>BOUNDARY</b> <b>CONDITIONS</b></h4><pre>
       TBD.

</pre><h4><b>RESULTING</b> <b>DISTRIBUTIONS</b></h4><pre>
       TBD.

</pre><h4><b>BUILT-IN</b> <b>FUNCTIONS</b></h4><pre>
   abs
       Returns the absolute value of the argument <u>x</u>.

              abs(x)

   acos
       Computes the arc in radians whose cosine is equal to the argument <u>x</u>.  A NaN error is raised if |<u>x</u>| &gt; 1.

              acos(x)

   asin
       Computes the arc in radians whose sine is equal to the argument <u>x</u>.  A NaN error is raised if |<u>x</u>| &gt; 1.

              asin(x)

   atan
       Computes, in radians, the arc tangent of the argument <u>x</u>.

              atan(x)

   atan2
       Computes, in radians, the arc tangent of quotient <u>y</u>/<u>x</u>, using the signs of the two arguments to  determine
       the quadrant of the result, which is in the range [−<u>π</u>, <u>π</u>].

              atan2(y,x)

   ceil
       Returns the smallest integral value not less than the argument <u>x</u>.

              ceil(x)

   clock
       Returns  the  value  of a certain clock in seconds measured from a certain (but specific) milestone.  The
       kind of clock and the initial milestone depend on the optional integer argument <u>f</u>.  It defaults  to  one,
       meaning CLOCK_MONOTONIC.  The list and the meanings of the other available values for <u>f</u> can be checked in
       the clock_gettime (2) system call manual page.

              clock([f])

   cos
       Computes  the cosine of the argument <u>x</u>, where <u>x</u> is in radians.  A cosine wave can be generated by passing
       as the argument <u>x</u> a linear function of time such as <u>ωt</u> + <u>ϕ</u>, where <u>ω</u> controls the frequency  of  the  wave
       and <u>ϕ</u> controls its phase.

              cos(x)

   cosh
       Computes the hyperbolic cosine of the argument <u>x</u>, where <u>x</u> is in radians.

              cosh(x)

   cpu_time
       Returns  the  CPU  time  used  by  the  local FeenoX rank, in seconds.  If the optional argument f is not
       provided or it is zero (default), the sum  of  times  for  both  user-space  and  kernel-space  usage  is
       returned.  For f=1 only user time is returned.  For f=2 only system time is returned.

              cpu_time([f])

   d_dt
       Computes  the  time derivative of the expression given in the argument <u>x</u> during a transient problem using
       the difference between the value of the signal in the previous time step and the actual value divided  by
       the  time  step <u>δt</u>  stored in dt.  The argument <u>x</u> does not need to be a variable, it can be an expression
       involving one or more variables that change in time.  For <u>t</u> = 0, the return value is  zero.   Unlike  the
       functional  derivative,  the  full  dependence  of  these  variables  with time does not need to be known
       beforehand, i.e. the expression x might involve variables read from a shared-memory object at  each  time
       step.

              d_dt(x)

   deadband
       Filters  the  first  argument <u>x</u>  with  a  deadband centered at zero with an amplitude given by the second
       argument <u>a</u>.

              deadband(x, a)

   equal
       Checks if the two first expressions <u>a</u> and <u>b</u> are equal, up to the tolerance given by  the  third  optional
       argument <u>ϵ</u>.  If either |<u>a</u>| &gt; 1 or |<u>b</u>| &gt; 1, the arguments are compared using GSL’s gsl_fcmp, otherwise the
       absolute  value  of  their difference is compared against <u>ϵ</u>.  This function returns zero if the arguments
       are not equal and one otherwise.  Default value for <u>ϵ</u> = 10^−9^.

              equal(a, b, [eps])

   exp
       Computes the exponential function the argument <u>x</u>, i.e. the base of  the  natural  logarithm <u>e</u>  raised  to
       the <u>x</u>-th power.

              exp(x)

   expint1
       Computes the first exponential integral function of the argument <u>x</u>.  If <u>x</u> is zero, a NaN error is issued.

              expint1(x)

   expint2
       Computes the second exponential integral function of the argument <u>x</u>.

              expint2(x)

   expint3
       Computes the third exponential integral function of the argument <u>x</u>.

              expint3(x)

   expintn
       Computes  the <u>n</u>-th exponential integral function of the argument <u>x</u>.  If <u>n</u> is zero or one and <u>x</u> is zero, a
       NaN error is issued.

              expintn(n,x)

   floor
       Returns the largest integral value not greater than the argument <u>x</u>.

              floor(x)

   gammaf
       Computes the Gamma function <u>Γ</u>(<u>x</u>).

              gammaf(x)

   heaviside
       Computes the zero-centered Heaviside step function of the argument <u>x</u>.  If the optional second argument  <u>δ</u>
       is  provided,  the  discontinuous  step  at <u>x</u> = 0  is  replaced by a ramp starting at <u>x</u> = 0 and finishing
       at <u>x</u> = <u>δ</u>.

              heaviside(x, [delta])

   if
       Performs a conditional testing of the first argument <u>a</u>, and returns either the second optional argument <u>b</u>
       if <u>a</u> is different from zero or the third optional argument <u>c</u> if <u>a</u> evaluates to zero.  The  comparison  of
       the  condition <u>a</u> with zero is performed within the precision given by the optional fourth argument <u>ϵ</u>.  If
       the second argument <u>c</u> is not given and <u>a</u> is not zero, the function returns one.  If the third argument  <u>c</u>
       is not given and <u>a</u> is zero, the function returns zero.  The default precision is <u>ϵ</u> = 10^−9^.  Even though
       if  is  a logical operation, all the arguments and the returned value are double-precision floating point
       numbers.

              if(a, [b], [c], [eps])

   integral_dt
       Computes the time integral of the expression given in the argument <u>x</u> during a transient problem with  the
       trapezoidal rule using the value of the signal in the previous time step and the current value.  At <u>t</u> = 0
       the  integral  is  initialized  to  zero.   Unlike  the functional integral, the full dependence of these
       variables with time does not need to be known beforehand, i.e. the expression x might  involve  variables
       read from a shared-memory object at each time step.

              integral_dt(x)

   integral_euler_dt
       Idem  as  integral_dt  but uses the backward Euler rule to update the instantaenous integral value.  This
       function is provided in case this particular way of approximating time integrals is needed, for  instance
       to compare FeenoX solutions with other computer codes.  In general, it is recommended to use integral_dt.

              integral_euler_dt(x)

   is_even
       Returns one if the argument <u>x</u> rounded to the nearest integer is even.

              is_even(x)

   is_in_interval
       Returns true if the argument <u>x</u> is in the interval [<u>a</u>, <u>b</u>), i.e. including <u>a</u> but excluding <u>b</u>.

              is_in_interval(x, a, b)

   is_odd
       Returns one if the argument <u>x</u> rounded to the nearest integer is odd.

              is_odd(x)

   j0
       Computes the regular cylindrical Bessel function of zeroth order evaluated at the argument <u>x</u>.

              j0(x)

   lag
       Filters  the  first  argument <u>x</u>(<u>t</u>)  with  a  first-order lag of characteristic time <u>τ</u>, i.e. this function
       applies the transfer function $G(s) = \frac{1}{1 + s\tau}$ to the time-dependent signal <u>x</u>(<u>t</u>) to obtain  a
       filtered  signal <u>y</u>(<u>t</u>), by assuming that it is constant during the time interval [<u>t</u> − <u>Δt</u>, <u>t</u>] and using the
       analytical  solution  of  the  differential  equation  for  that  case   at <u>t</u> = <u>Δt</u>   with   the   initial
       condition <u><a href="../man0/y.0.html">y</a></u>(0) = <u>y</u>(<u>t</u> − <u>Δt</u>).

              lag(x, tau)

   lag_bilinear
       Filters  the  first  argument <u>x</u>(<u>t</u>)  with a first-order lag of characteristic time <u>τ</u> to the time-dependent
       signal <u>x</u>(<u>t</u>) by using the bilinear transformation formula.

              lag_bilinear(x, tau)

   lag_euler
       Filters the first argument <u>x</u>(<u>t</u>) with a first-order lag of characteristic time  <u>τ</u>  to  the  time-dependent
       signal <u>x</u>(<u>t</u>) by using the Euler forward rule.

              lag_euler(x, tau)

   last
       Returns  the  value  the  variable <u>x</u>  had  in  the  previous  time  step.  This function is equivalent to
       the <u>Z</u>-transform operator “delay” denoted by <u>z</u>^−1^[<u>x</u>].  For <u>t</u> = 0 the function returns  the  actual  value
       of <u>x</u>.   The optional flag <u>p</u> should be set to one if the reference to last is done in an assignment over a
       variable that already appears inside expression <u>x</u> such as x = last(x).  See example number 2.

              last(x,[p])

   limit
       Limits the first argument <u>x</u> to the interval [<u>a</u>, <u>b</u>].  The second argument <u>a</u> should be less than the  third
       argument <u>b</u>.

              limit(x, a, b)

   limit_dt
       Limits  the  value  of  the first argument <u>x</u>(<u>t</u>) so to that its time derivative is bounded to the interval
       [<u>a</u>, <u>b</u>].  The second argument <u>a</u> should be less than the third argument <u>b</u>.

              limit_dt(x, a, b)

   log
       Computes the natural logarithm of the argument <u>x</u>.  If <u>x</u> is zero or negative, a NaN error is issued.

              log(x)

   mark_max
       Returns the integer index <u>i</u> of the maximum of the arguments <u>x</u>~<u>i</u>~ provided.  Currently only maximum of ten
       arguments can be provided.

              mark_max(x1, x2, [...], [x10])

   mark_min
       Returns the integer index <u>i</u> of the minimum of the arguments <u>x</u>~<u>i</u>~ provided.  Currently only maximum of ten
       arguments can be provided.

              mark_max(x1, x2, [...], [x10])

   max
       Returns the maximum of the arguments <u>x</u>~<u>i</u>~ provided.  Currently only  maximum  of  ten  arguments  can  be
       given.

              max(x1, x2, [...], [x10])

   memory
       Returns the maximum memory (resident set size) used by FeenoX, in Gigabytes.

              memory()

   min
       Returns  the  minimum  of  the  arguments <u>x</u>~<u>i</u>~  provided.  Currently only maximum of ten arguments can be
       given.

              min(x1, x2, [...], [x10])

   mod
       Returns the remainder of the division between the first argument <u>a</u> and the second one <u>b</u>.  Both  arguments
       may be non-integral.

              mod(a, b)

   mpi_memory_local
       Returns  the memory usage as reported by PETSc in the give rank, in Gigabytes.  If no rank is given, each
       rank returns a local value which should be printed with PRINTF_ALL.  Returns the memory global  usage  as
       reported by PETSc summing over all ranks, in Gigabytes.

              mpi_memory_local([rank]) mpi_memory_global()

   not
       Returns one if the first argument <u>x</u> is zero and zero otherwise.  The second optional argument <u>ϵ</u> gives the
       precision of the “zero” evaluation.  If not given, default is <u>ϵ</u> = 10^−9^.

              not(x, [eps])

   random
       Returns  a  random  real number uniformly distributed between the first real argument <u>x</u>~1~ and the second
       one <u>x</u>~2~.  If the third integer argument <u>s</u> is given, it is used as the seed and thus repetitive sequences
       can be obtained.  If no seed is provided, the current time (in seconds) plus the internal address of  the
       expression is used.  Therefore, two successive calls to the function without seed (hopefully) do not give
       the  same  result.   This function uses a second-order multiple recursive generator described by Knuth in
       Seminumerical Algorithms, 3rd Ed., Section 3.6.

              random(x1, x2, [s])

   random_gauss
       Returns a random real number with a Gaussian distribution with a mean equal to  the  first  argument <u>x</u>~1~
       and  a standard deviation equatl to the second one <u>x</u>~2~.  If the third integer argument <u>s</u> is given, it is
       used as the seed and thus repetitive sequences can be obtained.  If no seed is provided, the current time
       (in seconds) plus the internal address of the expression is used.  Therefore, two successive calls to the
       function without seed (hopefully) do not give  the  same  result.   This  function  uses  a  second-order
       multiple recursive generator described by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6.

              random_gauss(x1, x2, [s])

   round
       Rounds the argument <u>x</u> to the nearest integer.  Halfway cases are rounded away from zero.

              round(x)

   sawtooth_wave
       Computes  a  sawtooth  wave  between  zero  and one with a period equal to one.  As with the sine wave, a
       sawtooh wave can be generated by passing as the argument <u>x</u> a linear  function  of  time  such  as <u>ωt</u> + <u>ϕ</u>,
       where <u>ω</u> controls the frequency of the wave and <u>ϕ</u> controls its phase.

              sawtooth_wave(x)

   sech
       Computes the hyperbolic secant of the argument <u>x</u>, where <u>x</u> is in radians.

              sech(x)

   sgn
       Returns  minus  one, zero or plus one depending on the sign of the first argument <u>x</u>.  The second optional
       argument <u>ϵ</u> gives the precision of the “zero” evaluation.  If not given, default is <u>ϵ</u> = 10^−9^.

              sgn(x, [eps])

   sin
       Computes the sine of the argument <u>x</u>, where <u>x</u> is in radians.  A sine wave can be generated by  passing  as
       the argument <u>x</u> a linear function of time such as <u>ωt</u> + <u>ϕ</u>, where <u>ω</u> controls the frequency of the wave and <u>ϕ</u>
       controls its phase.

              sin(x)

   sinh
       Computes the hyperbolic sine of the argument <u>x</u>, where <u>x</u> is in radians.

              sinh(x)

   sqrt
       Computes the positive square root of the argument <u>x</u>.  If <u>x</u> is negative, a NaN error is issued.

              sqrt(x)

   square_wave
       Computes  a  square  function  between  zero  and  one with a period equal to one.  The output is one for
       0 &lt; <u>x</u> &lt; 1/2 and zero for 1/2 ≤ <u>x</u> &lt; 1.  As with the sine wave, a square wave can be generated  by  passing
       as  the  argument <u>x</u>  a linear function of time such as <u>ωt</u> + <u>ϕ</u>, where <u>ω</u> controls the frequency of the wave
       and <u>ϕ</u> controls its phase.

              square_wave(x)

   tan
       Computes the tangent of the argument <u>x</u>, where <u>x</u> is in radians.

              tan(x)

   tanh
       Computes the hyperbolic tangent of the argument <u>x</u>, where <u>x</u> is in radians.

              tanh(x)

   threshold_max
       Returns one if the first argument <u>x</u> is greater than the threshold given by the  second  argument  <u>a</u>,  and
       zero  otherwise.   If  the  optional  third argument <u>b</u> is provided, an hysteresis of width <u>b</u> is needed in
       order to reset the function value.  Default is no hysteresis, i.e. <u>b</u> = 0.

              threshold_max(x, a, [b])

   threshold_min
       Returns one if the first argument <u>x</u> is less than the threshold given by the second argument <u>a</u>, and   zero
       otherwise.   If the optional third argument <u>b</u> is provided, an hysteresis of width <u>b</u> is needed in order to
       reset the function value.  Default is no hysteresis, i.e. <u>b</u> = 0.

              threshold_min(x, a, [b])

   triangular_wave
       Computes a triangular wave between zero and one with a period equal to one.  As with  the  sine  wave,  a
       triangular  wave  can be generated by passing as the argument <u>x</u> a linear function of time such as <u>ωt</u> + <u>ϕ</u>,
       where <u>ω</u> controls the frequency of the wave and <u>ϕ</u> controls its phase.

              triangular_wave(x)

   wall_time
       Returns the time elapsed since the invocation of FeenoX, in seconds.

              wall_time()

</pre><h4><b>BUILT-IN</b> <b>FUNCTIONALS</b></h4><pre>
       TBD.

</pre><h4><b>BUILT-IN</b> <b>VECTOR</b> <b>FUNCTIONS</b></h4><pre>
       TBD.

</pre><h4><b>NOTES</b></h4><pre>
       TBD.

</pre><h4><b>BUGS</b></h4><pre>
       Report on GitHub https://github.com/seamplex/feenox or at <a href="mailto:jeremy@seamplex.com">jeremy@seamplex.com</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/gmsh.1.html">gmsh</a></b>(1), <b><a href="../man1/mpirun.1.html">mpirun</a></b>(1), <b><a href="../man1/paraview.1.html">paraview</a></b>(1)

       The FeenoX web page contains  links  to  the  full  source  code,  binary  versions,  updates,  examples,
       verification &amp; validation cases and full documentation: https://www.seamplex.com/feenox.

</pre><h4><b>AUTHORS</b></h4><pre>
       Jeremy Theler <a href="mailto:jeremy@seamplex.com">jeremy@seamplex.com</a>.

FeenoX                                             2025-02-07                                          <u><a href="../man1/FEENOX.1.html">FEENOX</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>