<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v.dissolve  - Dissolves adjacent or overlapping features sharing a common category number or attribute.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>v.dissolve</b>  - Dissolves adjacent or overlapping features sharing a common category number or attribute.

</pre><h4><b>KEYWORDS</b></h4><pre>
       vector, dissolve, area, line

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>v.dissolve</b>
       <b>v.dissolve</b> <b>--help</b>
       <b>v.dissolve</b>  <b>input</b>=<u>name</u>   [<b>layer</b>=<u>string</u>]   [<b>column</b>=<u>name</u>]  <b>output</b>=<u>name</u>  [<b>aggregate_columns</b>=<u>name</u>[,<u>name</u>,...]]
       [<b>aggregate_methods</b>=<u>string</u>[,<u>string</u>,...]]    [<b>result_columns</b>=<u>name</u>[,<u>name</u>,...]]    [<b>aggregate_backend</b>=<u>string</u>]
       [--<b>overwrite</b>]  [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>input</b>=<u>name</u> <b>[required]</b>
           Name of input vector map
           Or data source for direct OGR access

       <b>layer</b>=<u>string</u>
           Layer number or name.
           Vector  features  can have category values in different layers. This number determines which layer to
           use. When used with direct OGR access this is the layer name.
           Default: <u>1</u>

       <b>column</b>=<u>name</u>
           Name of attribute column used to dissolve features

       <b>output</b>=<u>name</u> <b>[required]</b>
           Name for output vector map

       <b>aggregate_columns</b>=<u>name[,name</u>,...]
           Names of attribute columns to get aggregate statistics for
           One column name or SQL expression per method if result columns are specified

       <b>aggregate_methods</b>=<u>string[,string</u>,...]
           Aggregate statistics method (e.g., sum)
           Default is all available basic statistics for a given backend (for sql backend: avg, count, max, min,
           sum)

       <b>result_columns</b>=<u>name[,name</u>,...]
           New attribute column names for aggregate statistics results
           Defaults to aggregate column name and statistics name and can contain type

       <b>aggregate_backend</b>=<u>string</u>
           Backend for attribute aggregation
           Default is sql unless the provided aggregate methods are for univar
           Options: <u>sql,</u> <u>univar</u>
           <b>sql</b>: Uses SQL attribute database
           <b>univar</b>: Uses v.db.univar

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>v.dissolve</u> module is used to merge adjacent or overlapping features in a vector map  that  share  the
       same category value. The resulting merged feature(s) retain this category value.

        <u>Figure:</u> <u>Areas</u> <u>with</u> <u>the</u> <u>same</u> <u>attribute</u> <u>value</u> <u>(first</u> <u>image)</u> <u>are</u> <u>merged</u> <u>into</u> <u>one</u> <u>(second</u> <u>image).</u>

       Instead  of  dissolving  features  based on the category values, the user can define an integer or string
       column using the <b>column</b> parameter. In that case, features that share the same value in  that  column  are
       dissolved. Note, the newly created layer does not retain the category (cat) values from the input layer.

       Note  that  multiple  areas  with the same category or the same attribute value that are not adjacent are
       merged into one entity, which consists of multiple features, i.e., a multipart feature.

   <b>Attribute</b> <b>aggregation</b>
       The attributes of merged areas can be aggregated using various aggregation methods. The specific  methods
       available  depend  on  the  backend  used  for  aggregation.  Two  aggregate backends (specified with the
       <b>aggregate_backend</b> parameter) are available, <u>univar</u> and <u>sql</u>. The backend is determined automatically based
       on the requested methods. When the function is one of the  <u>SQL</u>  build-in  aggregate  functions,  the  <u>sql</u>
       backend is used.  Otherwise, the <u>univar</u> backend is used.

       The  default  behavior  is  intended  for  interactive use and testing. For scripting and other automated
       usage, explicitly specifying the backend with the <b>aggregate_backend</b> parameter  is  strongly  recommended.
       When choosing, note that the <u>sql</u> aggregate backend, regardless of the underlying database, will typically
       perform significantly better than the <u>univar</u> backend.

   <b>Aggregation</b> <b>using</b> <b>univar</b> <b>backend</b>
       When  <u>univar</u> is used, the methods available are the ones which <u>v.db.univar</u> uses by default, i.e., <u>n</u>, <u>min</u>,
       <u>max</u>, <u>range</u>, <u>mean</u>, <u>mean_abs</u>, <u>variance</u>, <u>stddev</u>, <u>coef_var</u>, and <u>sum</u>.

   <b>Aggregation</b> <b>using</b> <b>sql</b> <b>backend</b>
       When the <u>sql</u> backend is used, the methods depend on the SQL database backend used for the attribute table
       of the input vector. For SQLite, there are at least the following built-in  aggregate  functions:  <u>count</u>,
       <u>min</u>,  <u>max</u>,  <u>avg</u>,  <u>sum</u>,  and  <u>total</u>.   For  PostgreSQL, the list of aggregate functions is much longer and
       includes, e.g., <u>count</u>, <u>min</u>, <u>max</u>, <u>avg</u>, <u>sum</u>, <u>stddev</u>, and <u>variance</u>.

   <b>Defining</b> <b>the</b> <b>aggregation</b> <b>method</b>
       If only the parameter <b>aggregate_columns</b>  is  provided,  all  the  following  aggregation  statistics  are
       calculated: <u>n</u>, <u>min</u>, <u>max</u>, <u>mean</u>, and <u>sum</u>. If the <u>univar</u> backend is specified, all the available methods for
       the <u>univar</u> backend are used.

       The  <b>aggregate_methods</b>  parameter can be used to specify which aggregation statistics should be computed.
       Alternatively, the parameter <b>aggregate_columns</b> can be used to specify the method using SQL  syntax.  This
       provides the highest flexibility, and it is suitable for scripting. The SQL statement should specify both
       the column and the functions applied, e.g.,
       aggregate_columns="sum(cows) / sum(animals)".

       Note  that when the <b>aggregate_columns</b> parameter is used, the <u>sql</u> backend should be used. In addition, the
       <b>aggregate_columns</b> and <b>aggregate_methods</b> cannot be used together.

       For convenience, certain methods, namely <u>n</u>, <u>count</u>, <u>mean</u>, and <u>avg</u>,  are  automatically  converted  to  the
       appropriate  name  for  the  selected  backend.  However, for scripting, it is recommended to specify the
       appropriate method (function) name for the backend, as the conversion is a heuristic that may  change  in
       the future.

       If   the   <b>result_columns</b>  is  not  provided,  each  method  is  applied  to  each  column  specified  by
       <b>aggregate_columns</b>. This results in a column for each of  the  combinations.  These  result  columns  have
       auto-generated  names  based  on  the  aggregate  column  and  method. For example, setting the following
       parameters:
       aggregate_columns=A,B
       aggregate_methods=sum,n

       results in the following columns: A_sum, A_n, B_sum, B_n. See the Examples section.

       If the <b>result_column</b> is provided, each method is  applied  only  once  to  the  matching  column  in  the
       aggregate  column  list,  and  the result will be available under the name of the matching result column.
       For example, setting the following parameter:
       aggregate_columns=A,B
       aggregate_methods=sum,max
       result_column=sum_a, n_b

       results in the column <u>sum_a</u> with the sum of the values of <u>A</u> and the column <u>n_b</u> with the max  of  <u>B</u>.  Note
       that  the  number  of  items  in <b>aggregate_columns</b>, <b>aggregate_methods</b> (unless omitted), and <b>result_column</b>
       needs to match, and no combinations are created on the fly. See the Examples section.

       For scripting, it is recommended to specify all  resulting  column  names,  while  for  interactive  use,
       automatically created combinations are expected to be beneficial, especially for exploratory analysis.

       The  type  of  the result column is determined based on the method selected. For <u>n</u> and <u>count</u>, the type is
       INTEGER and for all other methods, it is DOUBLE. Aggregate methods that produce other types  require  the
       type  to  be  specified as part of the <b>result_columns</b>. A type can be provided in <b>result_columns</b> using the
       SQL syntax name type, e.g., sum_of_values double precision. Type  specification  is  mandatory  when  SQL
       syntax is used in <b>aggregate_columns</b> (and <b>aggregate_methods</b> is omitted).

</pre><h4><b>NOTES</b></h4><pre>
       GRASS  defines  a  vector  area  as  a  composite  entity  consisting of a set of closed boundaries and a
       centroid. The centroids must contain a category number (see <u>v.centroids</u>), this number is linked  to  area
       attributes and database links.

       Multiple  attributes  may  be  linked  to  a  single vector entity through numbered fields referred to as
       layers. Refer to <u>v.category</u> for more details.

       Merging of areas can also be accomplished using v.extract -d which provides some additional  options.  In
       fact,  <u>v.dissolve</u>  is  simply  a front-end to that module. The use of the <u>column</u> parameter adds a call to
       <u>v.reclass</u> before.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Basic</b> <b>use</b>
       v.dissolve input=undissolved output=dissolved

   <b>Dissolving</b> <b>based</b> <b>on</b> <b>column</b> <b>attributes</b>
       North Carolina data set:
       g.copy vect=soils_general,mysoils_general
       v.dissolve mysoils_general output=mysoils_general_families column=GSL_NAME

   <b>Dissolving</b> <b>adjacent</b> <b>SHAPE</b> <b>files</b> <b>to</b> <b>remove</b> <b>tile</b> <b>boundaries</b>
       If tile boundaries of adjacent maps (e.g. CORINE Landcover SHAPE files) have to be removed, an extra step
       is required to remove duplicated boundaries:
       # patch tiles after import:
       v.patch -e `g.list type=vector pat="clc2000_*" separator=","` out=clc2000_patched
       # remove duplicated tile boundaries:
       v.clean clc2000_patched out=clc2000_clean tool=snap,break,rmdupl thresh=.01
       # dissolve based on column attributes:
       v.dissolve input=clc2000_clean output=clc2000_final col=CODE_00

   <b>Attribute</b> <b>aggregation</b>
       While dissolving, we can aggregate attribute values of the original features.  Let’s  aggregate  area  in
       acres  (ACRES)  of  all  municipal  boundaries  (boundary_municp) in the full NC dataset while dissolving
       common boundaries based on the name in the DOTURBAN_N column (long lines are split with backslash marking
       continued line as in Bash):
       v.dissolve input=boundary_municp column=DOTURBAN_N output=municipalities \
           aggregate_columns=ACRES

       To inspect the result, we will use <u>v.db.select</u> retrieving only one row for DOTURBAN_N == ’Wadesboro’:
       v.db.select municipalities where="DOTURBAN_N == ’Wadesboro’" separator=tab

       The resulting table may look like this:
       cat  DOTURBAN_N    ACRES_n    ACRES_min    ACRES_max    ACRES_mean    ACRES_sum
       66   Wadesboro     2          634.987      3935.325     2285.156      4570.312

       The above created multiple columns for each of the statistics computed  by  default.  We  can  limit  the
       number of statistics computed by specifying the method which should be used:
       v.dissolve input=boundary_municp column=DOTURBAN_N output=municipalities_2 \
           aggregate_columns=ACRES aggregate_methods=sum

       The  above  gives  a  single  column  with  the  sum for all values in the ACRES column for each group of
       original features which had the same value in the DOTURBAN_N column and are now dissolved  (merged)  into
       one.

   <b>Aggregating</b> <b>multiple</b> <b>attributes</b>
       Expanding  on  the  previous  example,  we can compute values for multiple columns at once by adding more
       columns to the <b>aggregate_columns</b> option.  We will compute average of values in the NEW_PERC_G column:
       v.dissolve input=boundary_municp column=DOTURBAN_N output=municipalities_3 \
           aggregate_columns=ACRES,NEW_PERC_G aggregate_methods=sum,avg

       By default, all methods specified in the <b>aggregate_methods</b> are applied to all columns, so result  of  the
       above is four columns. While this is convenient for getting multiple statistics for similar columns (e.g.
       averages  and standard deviations of multiple population statistics columns), in our case, each column is
       different and each aggregate method should be applied only to its corresponding column.

       The <u>v.dissolve</u> module will apply each aggregate method only to the corresponding column when column names
       for the results are specified manually with the <b>result_columns</b> option:
       v.dissolve input=boundary_municp column=DOTURBAN_N output=municipalities_4 \
           aggregate_columns=ACRES,NEW_PERC_G aggregate_methods=sum,avg \
           result_columns=acres,new_perc_g

       Now we have full control over what columns are created, but we also need to specify an  aggregate  method
       for each column even when the aggregate methods are the same:
       v.dissolve input=boundary_municp column=DOTURBAN_N output=municipalities_5 \
           aggregate_columns=ACRES,DOTURBAN_N,TEXT_NAME aggregate_methods=sum,count,count \
           result_columns=acres,number_of_parts,named_parts

       While  it  is  often  not  necessary  to  specify  aggregate methods or names for interactive exploratory
       analysis, specifying both <b>aggregate_methods</b> and <b>result_columns</b> manually is a best practice for  scripting
       (unless SQL syntax is used for <b>aggregate_columns</b>, see below).

   <b>Aggregating</b> <b>using</b> <b>SQL</b> <b>syntax</b>
       The aggregation can be done also using the full SQL syntax and set of aggregate functions available for a
       given  attribute  database  backend.   Here,  we  will  assume  the  default  SQLite database backend for
       attribute.

       Modifying the previous example, we will now specify the SQL aggregate function calls  explicitly  instead
       of  letting  <u>v.dissolve</u>  generate  them  for us. We will compute sum of the ACRES column using sum(ACRES)
       (alternatively, we could use SQLite specific total(ACRES) which returns zero even  when  all  values  are
       NULL).  Further,  we  will count number of aggregated (i.e., dissolved) parts using count(*) which counts
       all rows regardless of NULL values. Then, we will count all unique names of parts as distinguished by the
       MB_NAME column  using  count(distinct  MB_NAME).  Finally,  we  will  collect  all  these  names  into  a
       comma-separated list using group_concat(MB_NAME):
       v.dissolve input=boundary_municp column=DOTURBAN_N output=municipalities_6 \
           aggregate_columns="total(ACRES),count(*),count(distinct MB_NAME),group_concat(MB_NAME)" \
           result_columns="acres REAL,named_parts INTEGER,unique_names INTEGER,names TEXT"

       Here,  <u>v.dissolve</u>  doesn’t  make  any  assumptions about the resulting column types, so we specified both
       named and the type of each column.

       When working with general SQL syntax, <u>v.dissolve</u> turns off its checks for number of aggregate and  result
       columns  to  allow  for  all  SQL  syntax  to  be  used for aggregate columns. This allows us to use also
       functions with multiple parameters, for example specify separator to be used with <u>group_concat</u>:
       v.dissolve input=boundary_municp column=DOTURBAN_N output=municipalities_7 \
           aggregate_columns="group_concat(MB_NAME, ’;’)" \
           result_columns="names TEXT"

       To inspect the result, we will use <u>v.db.select</u> retrieving only one row for DOTURBAN_N == ’Wadesboro’:
       v.db.select municipalities_7 where="DOTURBAN_N == ’Wadesboro’" separator=tab

       The resulting table may look like this:
       cat  DOTURBAN_N     names
       66   Wadesboro Wadesboro;Lilesville

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>v.category,</u> <u>v.centroids,</u> <u>v.extract,</u> <u>v.reclass,</u> <u>v.db.univar,</u> <u>v.db.select</u>

</pre><h4><b>AUTHORS</b></h4><pre>
       M. Hamish Bowman, Department of Marine Science, Otago University, New Zealand (module)
       Markus Neteler (column support)
       Trevor Wiens (help page)
       Vaclav Petras, NC State University, Center for Geospatial Analytics, GeoForAll Lab (aggregate statistics)

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: v.dissolve source code (history)

       Accessed: Friday Apr 04 01:21:13 2025

       Main index | Vector index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                   <u><a href="../man1grass/v.dissolve.1grass.html">v.dissolve</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>