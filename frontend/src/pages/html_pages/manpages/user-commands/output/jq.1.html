<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jq - Command-line JSON processor</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/jq">jq_1.7.1-3ubuntu1.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>jq</b> - Command-line JSON processor

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>jq</b> [<u>options</u>...] <u>filter</u> [<u>files</u>...]

       <b>jq</b>  can  transform  JSON  in  various ways, by selecting, iterating, reducing and otherwise mangling JSON
       documents. For instance, running the command <b>jq</b> <b>´map(.price)</b> <b>|</b> <b>add´</b> will take an array of JSON objects as
       input and return the sum of their "price" fields.

       <b>jq</b> can accept text input as well, but by default, <b>jq</b> reads a stream of JSON entities  (including  numbers
       and  other literals) from <b>stdin</b>. Whitespace is only needed to separate entities such as 1 and 2, and true
       and false. One or more <u>files</u> may be specified, in which case <b>jq</b> will read input from those instead.

       The <u>options</u> are described in the [INVOKING JQ] section; they mostly concern input and output  formatting.
       The <u>filter</u> is written in the jq language and specifies how to transform the input file or document.

</pre><h4><b>FILTERS</b></h4><pre>
       A jq program is a "filter": it takes an input, and produces an output. There are a lot of builtin filters
       for  extracting  a  particular  field  of an object, or converting a number to a string, or various other
       standard tasks.

       Filters can be combined in various ways - you can pipe the output of one filter into another  filter,  or
       collect the output of a filter into an array.

       Some  filters  produce  multiple  results, for instance there´s one that produces all the elements of its
       input array. Piping that filter into a second runs the second filter  for  each  element  of  the  array.
       Generally,  things that would be done with loops and iteration in other languages are just done by gluing
       filters together in jq.

       It´s important to remember that every filter has an input and an output. Even literals like "hello" or 42
       are filters - they take an input but always produce the same literal as output. Operations  that  combine
       two  filters,  like  addition, generally feed the same input to both and combine the results. So, you can
       implement an averaging filter as <b>add</b> <b>/</b> <b>length</b> - feeding the input array both to the <b>add</b>  filter  and  the
       <b>length</b> filter and then performing the division.

       But that´s getting ahead of ourselves. :) Let´s start with something simpler:

</pre><h4><b>INVOKING</b> <b>JQ</b></h4><pre>
       jq  filters run on a stream of JSON data. The input to jq is parsed as a sequence of whitespace-separated
       JSON values which are passed through the provided filter one at a time. The output(s) of the  filter  are
       written to standard output, as a sequence of newline-separated JSON data.

       The  simplest  and  most  common filter (or jq program) is <b>.</b>, which is the identity operator, copying the
       inputs of the jq processor to the output stream. Because the default behavior of the jq processor  is  to
       read  JSON  texts  from  the  input  stream,  and to pretty-print outputs, the <b>.</b> program´s main use is to
       validate and pretty-print the inputs. The jq programming language is quite rich and allows for much  more
       than just validation and pretty-printing.

       Note:  it  is  important  to  mind the shell´s quoting rules. As a general rule it´s best to always quote
       (with single-quote characters on Unix shells) the jq program, as too many characters with special meaning
       to jq are also shell meta-characters. For example, <b>jq</b> <b>"foo"</b> will fail on most Unix  shells  because  that
       will  be the same as <b>jq</b> <b>foo</b>, which will generally fail because <b>foo</b> <b>is</b> <b>not</b> <b>defined</b>. When using the Windows
       command shell (cmd.exe) it´s best to use  double  quotes  around  your  jq  program  when  given  on  the
       command-line  (instead  of  the  <b>-f</b>  <b>program-file</b>  option), but then double-quotes in the jq program need
       backslash escaping. When using the Powershell (<b>powershell.exe</b>) or the  Powershell  Core  (<b>pwsh</b>/<b>pwsh.exe</b>),
       use  single-quote characters around the jq program and backslash-escaped double-quotes (<b>\"</b>) inside the jq
       program.

       •   Unix shells: <b>jq</b> <b>´.["foo"]´</b>

       •   Powershell: <b>jq</b> <b>´.[\"foo\"]´</b>

       •   Windows command shell: <b>jq</b> <b>".[\"foo\"]"</b>

       Note: jq allows user-defined functions, but every jq program must have a top-level expression.

       You can affect how jq reads and writes its input and output using some command-line options:

       <b>--null-input</b> / <b>-n</b>:

              Don´t read any input at all. Instead, the filter is run once using <b>null</b>  as  the  input.  This  is
              useful when using jq as a simple calculator or to construct JSON data from scratch.

       <b>--raw-input</b> / <b>-R</b>:

              Don´t  parse the input as JSON. Instead, each line of text is passed to the filter as a string. If
              combined with <b>--slurp</b>, then the entire input is passed to the filter as a single long string.

       <b>--slurp</b> / <b>-s</b>:

              Instead of running the filter for each JSON object in the input, read the entire input stream into
              a large array and run the filter just once.

       <b>--compact-output</b> / <b>-c</b>:

              By default, jq pretty-prints JSON output. Using this option will result in more compact output  by
              instead putting each JSON object on a single line.

       <b>--raw-output</b> / <b>-r</b>:

              With  this option, if the filter´s result is a string then it will be written directly to standard
              output rather than being formatted as a JSON string with quotes. This can be useful for making  jq
              filters talk to non-JSON-based systems.

       <b>--raw-output0</b>:

              Like  <b>-r</b>  but  jq will print NUL instead of newline after each output. This can be useful when the
              values being output can contain newlines. When the  output  value  contains  NUL,  jq  exits  with
              non-zero code.

       <b>--join-output</b> / <b>-j</b>:

              Like <b>-r</b> but jq won´t print a newline after each output.

       <b>--ascii-output</b> / <b>-a</b>:

              jq  usually  outputs  non-ASCII  Unicode  codepoints as UTF-8, even if the input specified them as
              escape sequences (like "\u03bc"). Using this option, you can force jq to produce pure ASCII output
              with every non-ASCII character replaced with the equivalent escape sequence.

       <b>--sort-keys</b> / <b>-S</b>:

              Output the fields of each object with the keys in sorted order.

       <b>--color-output</b> / <b>-C</b> and <b>--monochrome-output</b> / <b>-M</b>:

              By default, jq outputs colored JSON if writing to a terminal. You can force it  to  produce  color
              even  if  writing  to  a  pipe  or  a  file using <b>-C</b>, and disable color with <b>-M</b>. When the <b>NO_COLOR</b>
              environment variable is not empty, jq disables colored output by default, but you can enable it by
              <b>-C</b>.

              Colors can be configured with the <b>JQ_COLORS</b> environment variable (see below).

       <b>--tab</b>:

              Use a tab for each indentation level instead of two spaces.

       <b>--indent</b> <b>n</b>:

              Use the given number of spaces (no more than 7) for indentation.

       <b>--unbuffered</b>:

              Flush the output after each JSON object is printed (useful if you´re piping  a  slow  data  source
              into jq and piping jq´s output elsewhere).

       <b>--stream</b>:

              Parse the input in streaming fashion, outputting arrays of path and leaf values (scalars and empty
              arrays  or empty objects). For example, <b>"a"</b> becomes <b>[[],"a"]</b>, and <b>[[],"a",["b"]]</b> becomes <b>[[0],[]]</b>,
              <b>[[1],"a"]</b>, and <b>[[2,0],"b"]</b>.

              This is useful for processing very large inputs. Use this in conjunction with  filtering  and  the
              <b>reduce</b> and <b>foreach</b> syntax to reduce large inputs incrementally.

       <b>--stream-errors</b>:

              Like <b>--stream</b>, but invalid JSON inputs yield array values where the first element is the error and
              the second is a path. For example, <b>["a",n]</b> produces <b>["Invalid</b> <b>literal</b> <b>at</b> <b>line</b> <b>1,</b> <b>column</b> <b>7",[1]]</b>.

              Implies   <b>--stream</b>.   Invalid   JSON   inputs  produce  no  error  values  when  <b>--stream</b>  without
              <b>--stream-errors</b>.

       <b>--seq</b>:

              Use the <b>application/json-seq</b> MIME type scheme for separating JSON texts in jq´s input and  output.
              This  means  that  an ASCII RS (record separator) character is printed before each value on output
              and an ASCII LF (line feed) is printed after every output. Input JSON texts that fail to parse are
              ignored (but warned about), discarding all subsequent input until the  next  RS.  This  mode  also
              parses the output of jq without the <b>--seq</b> option.

       <b>-f</b> <b>filename</b> / <b>--from-file</b> <b>filename</b>:

              Read  filter from the file rather than from a command line, like awk´s -f option. You can also use
              ´#´ to make comments.

       <b>-L</b> <b>directory</b>:

              Prepend <b>directory</b> to the search list for modules. If this option is used then  no  builtin  search
              list is used. See the section on modules below.

       <b>--arg</b> <b>name</b> <b>value</b>:

              This  option  passes  a value to the jq program as a predefined variable. If you run jq with <b>--arg</b>
              <b>foo</b> <b>bar</b>, then <b>$foo</b> is available in the program and has the value <b>"bar"</b>. Note that  <b>value</b>  will  be
              treated as a string, so <b>--arg</b> <b>foo</b> <b>123</b> will bind <b>$foo</b> to <b>"123"</b>.

              Named arguments are also available to the jq program as <b>$ARGS.named</b>.

       <b>--argjson</b> <b>name</b> <b>JSON-text</b>:

              This  option passes a JSON-encoded value to the jq program as a predefined variable. If you run jq
              with <b>--argjson</b> <b>foo</b> <b>123</b>, then <b>$foo</b> is available in the program and has the value <b>123</b>.

       <b>--slurpfile</b> <b>variable-name</b> <b>filename</b>:

              This option reads all the JSON texts in the named file and binds  an  array  of  the  parsed  JSON
              values  to  the  given  global  variable.  If  you  run  jq with <b>--slurpfile</b> <b>foo</b> <b>bar</b>, then <b>$foo</b> is
              available in the program and has an array whose elements correspond to the texts in the file named
              <b>bar</b>.

       <b>--rawfile</b> <b>variable-name</b> <b>filename</b>:

              This option reads in the named file and binds its contents to the given global  variable.  If  you
              run  jq  with  <b>--rawfile</b>  <b>foo</b>  <b>bar</b>,  then  <b>$foo</b> is available in the program and has a string whose
              contents are to the texts in the file named <b>bar</b>.

       <b>--args</b>:

              Remaining arguments are positional string arguments. These are available  to  the  jq  program  as
              <b>$ARGS.positional[]</b>.

       <b>--jsonargs</b>:

              Remaining  arguments  are positional JSON text arguments. These are available to the jq program as
              <b>$ARGS.positional[]</b>.

       <b>--exit-status</b> / <b>-e</b>:

              Sets the exit status of jq to 0 if the last output value was neither <b>false</b> nor <b>null</b>, 1 if the last
              output value was either <b>false</b> or <b>null</b>, or 4 if no valid result  was  ever  produced.  Normally  jq
              exits  with  2 if there was any usage problem or system error, 3 if there was a jq program compile
              error, or 0 if the jq program ran.

              Another way to set the exit status is with the <b>halt_error</b> builtin function.

       <b>--binary</b> / <b>-b</b>:

              Windows users using WSL, MSYS2, or Cygwin, should use this option  when  using  a  native  jq.exe,
              otherwise jq will turn newlines (LFs) into carriage-return-then-newline (CRLF).

       <b>--version</b> / <b>-V</b>:

              Output the jq version and exit with zero.

       <b>--build-configuration</b>:

              Output  the  build  configuration of jq and exit with zero. This output has no supported format or
              structure and may change without notice in future releases.

       <b>--help</b> / <b>-h</b>:

              Output the jq help and exit with zero.

       <b>--</b>:

              Terminates argument processing. Remaining arguments are not interpreted as options.

       <b>--run-tests</b> <b>[filename]</b>:

              Runs the tests in the given file or standard input. This must be the last option  given  and  does
              not  honor  all  preceding  options. The input consists of comment lines, empty lines, and program
              lines followed by one input line, as many lines of output as are expected (one per output), and  a
              terminating empty line. Compilation failure tests start with a line containing only <b>%%FAIL</b>, then a
              line  containing the program to compile, then a line containing an error message to compare to the
              actual.

              Be warned that this option can change backwards-incompatibly.

</pre><h4><b>BASIC</b> <b>FILTERS</b></h4><pre>
   <b>Identity:</b> <b>.</b>
       The absolute simplest filter is <b>.</b> . This filter takes its input and produces the same  value  as  output.
       That is, this is the identity operator.

       Since  jq  by default pretty-prints all output, a trivial program consisting of nothing but <b>.</b> can be used
       to format JSON output from, say, <b>curl</b>.

       Although the identity filter never modifies the value of its input, jq processing can sometimes  make  it
       appear  as  though  it  does.  For example, using the current implementation of jq, we would see that the
       expression:

           1E1234567890 | .

       produces <b>1.7976931348623157e+308</b> on at least one platform. This is because, in the process of parsing the
       number, this particular version of jq has converted it to  an  IEEE754  double-precision  representation,
       losing precision.

       The  way  in  which  jq  handles  numbers has changed over time and further changes are likely within the
       parameters set by the relevant JSON standards. The following  remarks  are  therefore  offered  with  the
       understanding  that  they  are  intended to be descriptive of the current version of jq and should not be
       interpreted as being prescriptive:

       (1) Any arithmetic operation on a number that has  not  already  been  converted  to  an  IEEE754  double
       precision representation will trigger a conversion to the IEEE754 representation.

       (2)  jq  will  attempt  to maintain the original decimal precision of number literals, but in expressions
       such <b>1E1234567890</b>, precision will be lost if the exponent is too large.

       (3) In jq programs, a leading minus sign will  trigger  the  conversion  of  the  number  to  an  IEEE754
       representation.

       (4) Comparisons are carried out using the untruncated big decimal representation of numbers if available,
       as illustrated in one of the following examples.

           jq ´.´
              "Hello, world!"
           =&gt; "Hello, world!"

           jq ´.´
              0.12345678901234567890123456789
           =&gt; 0.12345678901234567890123456789

           jq ´[., tojson]´
              12345678909876543212345
           =&gt; [12345678909876543212345,"12345678909876543212345"]

           jq ´. &lt; 0.12345678901234567890123456788´
              0.12345678901234567890123456789
           =&gt; false

           jq ´map([., . == 1]) | tojson´
              [1, 1.000, 1.0, 100e-2]
           =&gt; "[[1,true],[1.000,true],[1.0,true],[1.00,true]]"

           jq ´. as $big | [$big, $big + 1] | map(. &gt; 10000000000000000000000000000000)´
              10000000000000000000000000000001
           =&gt; [true, false]

   <b>Object</b> <b>Identifier-Index:</b> <b>.foo,</b> <b>.foo.bar</b>
       The simplest <u>useful</u> filter has the form <b>.foo</b>. When given a JSON object (aka dictionary or hash) as input,
       <b>.foo</b> produces the value at the key "foo" if the key is present, or null otherwise.

       A filter of the form <b>.foo.bar</b> is equivalent to <b>.foo</b> <b>|</b> <b>.bar</b>.

       The  <b>.foo</b>  syntax  only  works  for  simple,  identifier-like  keys,  that  is, keys that are all made of
       alphanumeric characters and underscore, and which do not start with a digit.

       If the key contains special characters or starts with a digit, you need to surround it with double quotes
       like this: <b>."foo$"</b>, or else <b>.["foo$"]</b>.

       For example <b>.["foo::bar"]</b> and <b>.["foo.bar"]</b> work while <b>.foo::bar</b> does not.

           jq ´.foo´
              {"foo": 42, "bar": "less interesting data"}
           =&gt; 42

           jq ´.foo´
              {"notfoo": true, "alsonotfoo": false}
           =&gt; null

           jq ´.["foo"]´
              {"foo": 42}
           =&gt; 42

   <b>Optional</b> <b>Object</b> <b>Identifier-Index:</b> <b>.foo?</b>
       Just like <b>.foo</b>, but does not output an error when <b>.</b> is not an object.

           jq ´.foo?´
              {"foo": 42, "bar": "less interesting data"}
           =&gt; 42

           jq ´.foo?´
              {"notfoo": true, "alsonotfoo": false}
           =&gt; null

           jq ´.["foo"]?´
              {"foo": 42}
           =&gt; 42

           jq ´[.foo?]´
              [1,2]
           =&gt; []

   <b>Object</b> <b>Index:</b> <b>.[&lt;string&gt;]</b>
       You can also look up fields of an object using syntax like <b>.["foo"]</b> (<b>.foo</b> above is a shorthand version of
       this, but only for identifier-like strings).

   <b>Array</b> <b>Index:</b> <b>.[&lt;number&gt;]</b>
       When the index value is an integer, <b>.[&lt;number&gt;]</b> can index arrays. Arrays are zero-based, so <b>.[2]</b>  returns
       the third element.

       Negative  indices  are  allowed,  with -1 referring to the last element, -2 referring to the next to last
       element, and so on.

           jq ´.[0]´
              [{"name":"JSON", "good":true}, {"name":"XML", "good":false}]
           =&gt; {"name":"JSON", "good":true}

           jq ´.[2]´
              [{"name":"JSON", "good":true}, {"name":"XML", "good":false}]
           =&gt; null

           jq ´.[-2]´
              [1,2,3]
           =&gt; 2

   <b>Array/String</b> <b>Slice:</b> <b>.[&lt;number&gt;:&lt;number&gt;]</b>
       The <b>.[&lt;number&gt;:&lt;number&gt;]</b> syntax can be used to return a subarray of an array or substring  of  a  string.
       The  array returned by <b>.[10:15]</b> will be of length 5, containing the elements from index 10 (inclusive) to
       index 15 (exclusive). Either index may be negative (in which case it counts backwards from the end of the
       array), or omitted (in which case it refers to the start or end of the array). Indices are zero-based.

           jq ´.[2:4]´
              ["a","b","c","d","e"]
           =&gt; ["c", "d"]

           jq ´.[2:4]´
              "abcdefghi"
           =&gt; "cd"

           jq ´.[:3]´
              ["a","b","c","d","e"]
           =&gt; ["a", "b", "c"]

           jq ´.[-2:]´
              ["a","b","c","d","e"]
           =&gt; ["d", "e"]

   <b>Array/Object</b> <b>Value</b> <b>Iterator:</b> <b>.[]</b>
       If you use the <b>.[index]</b> syntax, but omit the index entirely, it will return <u>all</u> of  the  elements  of  an
       array. Running <b>.[]</b> with the input <b>[1,2,3]</b> will produce the numbers as three separate results, rather than
       as a single array. A filter of the form <b>.foo[]</b> is equivalent to <b>.foo</b> <b>|</b> <b>.[]</b>.

       You can also use this on an object, and it will return all the values of the object.

       Note that the iterator operator is a generator of values.

           jq ´.[]´
              [{"name":"JSON", "good":true}, {"name":"XML", "good":false}]
           =&gt; {"name":"JSON", "good":true}, {"name":"XML", "good":false}

           jq ´.[]´
              []
           =&gt;

           jq ´.foo[]´
              {"foo":[1,2,3]}
           =&gt; 1, 2, 3

           jq ´.[]´
              {"a": 1, "b": 1}
           =&gt; 1, 1

   <b>.[]?</b>
       Like  <b>.[]</b>,  but  no errors will be output if . is not an array or object. A filter of the form <b>.foo[]?</b> is
       equivalent to <b>.foo</b> <b>|</b> <b>.[]?</b>.

   <b>Comma:</b> <b>,</b>
       If two filters are separated by a comma, then the same input will be fed into both and the  two  filters´
       output  value  streams  will  be  concatenated  in  order: first, all of the outputs produced by the left
       expression, and then all of the outputs produced by the right. For instance, filter <b>.foo,</b> <b>.bar</b>,  produces
       both the "foo" fields and "bar" fields as separate outputs.

       The <b>,</b> operator is one way to contruct generators.

           jq ´.foo, .bar´
              {"foo": 42, "bar": "something else", "baz": true}
           =&gt; 42, "something else"

           jq ´.user, .projects[]´
              {"user":"stedolan", "projects": ["jq", "wikiflow"]}
           =&gt; "stedolan", "jq", "wikiflow"

           jq ´.[4,2]´
              ["a","b","c","d","e"]
           =&gt; "e", "c"

   <b>Pipe:</b> <b>|</b>
       The | operator combines two filters by feeding the output(s) of the one on the left into the input of the
       one on the right. It´s similar to the Unix shell´s pipe, if you´re used to that.

       If  the  one  on  the  left produces multiple results, the one on the right will be run for each of those
       results. So, the expression <b>.[]</b> <b>|</b> <b>.foo</b> retrieves the "foo" field of each element of the input array. This
       is a cartesian product, which can be surprising.

       Note that <b>.a.b.c</b> is the same as <b>.a</b> <b>|</b> <b>.b</b> <b>|</b> <b>.c</b>.

       Note too that <b>.</b> is the input value at the particular stage in a "pipeline",  specifically:  where  the  <b>.</b>
       expression appears. Thus <b>.a</b> <b>|</b> <b>.</b> <b>|</b> <b>.b</b> is the same as <b>.a.b</b>, as the <b>.</b> in the middle refers to whatever value
       <b>.a</b> produced.

           jq ´.[] | .name´
              [{"name":"JSON", "good":true}, {"name":"XML", "good":false}]
           =&gt; "JSON", "XML"

   <b>Parenthesis</b>
       Parenthesis work as a grouping operator just as in any typical programming language.

           jq ´(. + 2) * 5´
              1
           =&gt; 15

</pre><h4><b>TYPES</b> <b>AND</b> <b>VALUES</b></h4><pre>
       jq  supports  the  same  set of datatypes as JSON - numbers, strings, booleans, arrays, objects (which in
       JSON-speak are hashes with only string keys), and "null".

       Booleans, null, strings and numbers are written the same way as in JSON. Just like everything else in jq,
       these simple values take an input and produce an output - <b>42</b> is a  valid  jq  expression  that  takes  an
       input, ignores it, and returns 42 instead.

       Numbers  in jq are internally represented by their IEEE754 double precision approximation. Any arithmetic
       operation with numbers, whether they are literals or results of previous filters, will produce  a  double
       precision floating point result.

       However,  when  parsing a literal jq will store the original literal string. If no mutation is applied to
       this value then it will make to the output in its original form,  even  if  conversion  to  double  would
       result in a loss.

   <b>Array</b> <b>construction:</b> <b>[]</b>
       As  in  JSON,  <b>[]</b>  is  used  to construct arrays, as in <b>[1,2,3]</b>. The elements of the arrays can be any jq
       expression, including a pipeline. All of the results produced by all of  the  expressions  are  collected
       into  one big array. You can use it to construct an array out of a known quantity of values (as in <b>[.foo,</b>
       <b>.bar,</b> <b>.baz]</b>) or to "collect" all the results of a filter into an array (as in <b>[.items[].name]</b>)

       Once you understand the "," operator, you can look at  jq´s  array  syntax  in  a  different  light:  the
       expression <b>[1,2,3]</b> is not using a built-in syntax for comma-separated arrays, but is instead applying the
       <b>[]</b> operator (collect results) to the expression 1,2,3 (which produces three different results).

       If  you have a filter <b>X</b> that produces four results, then the expression <b>[X]</b> will produce a single result,
       an array of four elements.

           jq ´[.user, .projects[]]´
              {"user":"stedolan", "projects": ["jq", "wikiflow"]}
           =&gt; ["stedolan", "jq", "wikiflow"]

           jq ´[ .[] | . * 2]´
              [1, 2, 3]
           =&gt; [2, 4, 6]

   <b>Object</b> <b>Construction:</b> <b>{}</b>
       Like JSON, <b>{}</b> is for constructing objects (aka dictionaries or hashes), as in: <b>{"a":</b> <b>42,</b> <b>"b":</b> <b>17}</b>.

       If the keys are "identifier-like", then the quotes  can  be  left  off,  as  in  <b>{a:42,</b>  <b>b:17}</b>.  Variable
       references  as  key  expressions  use  the  value  of the variable as the key. Key expressions other than
       constant literals, identifiers, or variable references, need to be parenthesized, e.g., <b>{("a"+"b"):59}</b>.

       The value can be any expression (although you may need to wrap it in  parentheses  if,  for  example,  it
       contains  colons),  which  gets applied to the {} expression´s input (remember, all filters have an input
       and an output).

           {foo: .bar}

       will produce the JSON object <b>{"foo":</b> <b>42}</b> if given the JSON object <b>{"bar":42,</b> <b>"baz":43}</b> as its input.  You
       can  use  this  to select particular fields of an object: if the input is an object with "user", "title",
       "id", and "content" fields and you just want "user" and "title", you can write

           {user: .user, title: .title}

       Because that is so common, there´s a shortcut syntax for it: <b>{user,</b> <b>title}</b>.

       If one of the expressions produces multiple results, multiple  dictionaries  will  be  produced.  If  the
       input´s

           {"user":"stedolan","titles":["JQ Primer", "More JQ"]}

       then the expression

           {user, title: .titles[]}

       will produce two outputs:

           {"user":"stedolan", "title": "JQ Primer"}
           {"user":"stedolan", "title": "More JQ"}

       Putting  parentheses  around  the key means it will be evaluated as an expression. With the same input as
       above,

           {(.user): .titles}

       produces

           {"stedolan": ["JQ Primer", "More JQ"]}

       Variable references as keys use the value of the variable as the key. Without a value then the variable´s
       name becomes the key and its value becomes the value,

           "f o o" as $foo | "b a r" as $bar | {$foo, $bar:$foo}

       produces

           {"foo":"f o o","b a r":"f o o"}

           jq ´{user, title: .titles[]}´
              {"user":"stedolan","titles":["JQ Primer", "More JQ"]}
           =&gt; {"user":"stedolan", "title": "JQ Primer"}, {"user":"stedolan", "title": "More JQ"}

           jq ´{(.user): .titles}´
              {"user":"stedolan","titles":["JQ Primer", "More JQ"]}
           =&gt; {"stedolan": ["JQ Primer", "More JQ"]}

   <b>Recursive</b> <b>Descent:</b> <b>..</b>
       Recursively descends <b>.</b>, producing every value. This is the same as the zero-argument <b>recurse</b> builtin (see
       below). This is intended to resemble the XPath <b>//</b> operator. Note that <b>..a</b> does not  work;  use  <b>..</b>  <b>|</b>  <b>.a</b>
       instead.  In  the  example  below we use <b>..</b> <b>|</b> <b>.a?</b> to find all the values of object keys "a" in any object
       found "below" <b>.</b>.

       This is particularly useful in conjunction with <b>path(EXP)</b> (also see below) and the <b>?</b> operator.

           jq ´.. | .a?´
              [[{"a":1}]]
           =&gt; 1

</pre><h4><b>BUILTIN</b> <b>OPERATORS</b> <b>AND</b> <b>FUNCTIONS</b></h4><pre>
       Some jq operators (for instance, <b>+</b>) do different things depending on the type of their arguments (arrays,
       numbers, etc.). However, jq never does implicit type conversions. If you try to add a string to an object
       you´ll get an error message and no result.

       Please note that all numbers are converted to IEEE754 double  precision  floating  point  representation.
       Arithmetic and logical operators are working with these converted doubles. Results of all such operations
       are also limited to the double precision.

       The  only  exception  to this behaviour of number is a snapshot of original number literal. When a number
       which originally was provided as a literal is never mutated until the end  of  the  program  then  it  is
       printed  to  the  output in its original literal form. This also includes cases when the original literal
       would be truncated when converted to the IEEE754 double precision floating point number.

   <b>Addition:</b> <b>+</b>
       The operator <b>+</b> takes two filters, applies them both to the same input, and  adds  the  results  together.
       What "adding" means depends on the types involved:

       •   <b>Numbers</b> are added by normal arithmetic.

       •   <b>Arrays</b> are added by being concatenated into a larger array.

       •   <b>Strings</b> are added by being joined into a larger string.

       •   <b>Objects</b>  are  added  by  merging, that is, inserting all the key-value pairs from both objects into a
           single combined object. If both objects contain a value for the same key, the object on the right  of
           the <b>+</b> wins. (For recursive merge use the <b>*</b> operator.)

       <b>null</b> can be added to any value, and returns the other value unchanged.

           jq ´.a + 1´
              {"a": 7}
           =&gt; 8

           jq ´.a + .b´
              {"a": [1,2], "b": [3,4]}
           =&gt; [1,2,3,4]

           jq ´.a + null´
              {"a": 1}
           =&gt; 1

           jq ´.a + 1´
              {}
           =&gt; 1

           jq ´{a: 1} + {b: 2} + {c: 3} + {a: 42}´
              null
           =&gt; {"a": 42, "b": 2, "c": 3}

   <b>Subtraction:</b> <b>-</b>
       As  well  as normal arithmetic subtraction on numbers, the <b>-</b> operator can be used on arrays to remove all
       occurrences of the second array´s elements from the first array.

           jq ´4 - .a´
              {"a":3}
           =&gt; 1

           jq ´. - ["xml", "yaml"]´
              ["xml", "yaml", "json"]
           =&gt; ["json"]

   <b>Multiplication,</b> <b>division,</b> <b>modulo:</b> <b>*,</b> <b>/,</b> <b>%</b>
       These infix operators behave as expected when given two numbers. Division by zero raises an error. <b>x</b> <b>%</b>  <b>y</b>
       computes x modulo y.

       Multiplying  a  string  by  a  number  produces the concatenation of that string that many times. <b>"x"</b> <b>*</b> <b>0</b>
       produces <b>""</b>.

       Dividing a string by another splits the first using the second as separators.

       Multiplying two objects will merge them recursively: this works like addition but if both objects contain
       a value for the same key, and the values are objects, the two are merged with the same strategy.

           jq ´10 / . * 3´
              5
           =&gt; 6

           jq ´. / ", "´
              "a, b,c,d, e"
           =&gt; ["a","b,c,d","e"]

           jq ´{"k": {"a": 1, "b": 2}} * {"k": {"a": 0,"c": 3}}´
              null
           =&gt; {"k": {"a": 0, "b": 2, "c": 3}}

           jq ´.[] | (1 / .)?´
              [1,0,-1]
           =&gt; 1, -1

   <b>abs</b>
       The builtin function <b>abs</b> is defined naively as: <b>if</b> <b>.</b> <b>&lt;</b> <b>0</b> <b>then</b> <b>-</b> <b>.</b> <b>else</b> <b>.</b> <b>end</b>.

       For numeric input, this is  the  absolute  value.  See  the  section  on  the  identity  filter  for  the
       implications of this definition for numeric input.

       To compute the absolute value of a number as a floating point number, you may wish use <b>fabs</b>.

           jq ´map(abs)´
              [-10, -1.1, -1e-1]
           =&gt; [10,1.1,1e-1]

   <b>length</b>
       The builtin function <b>length</b> gets the length of various different types of value:

       •   The length of a <b>string</b> is the number of Unicode codepoints it contains (which will be the same as its
           JSON-encoded length in bytes if it´s pure ASCII).

       •   The length of a <b>number</b> is its absolute value.

       •   The length of an <b>array</b> is the number of elements.

       •   The length of an <b>object</b> is the number of key-value pairs.

       •   The length of <b>null</b> is zero.

       •   It is an error to use <b>length</b> on a <b>boolean</b>.

           jq ´.[] | length´
              [[1,2], "string", {"a":2}, null, -5]
           =&gt; 2, 6, 1, 0, 5

   <b>utf8bytelength</b>
       The builtin function <b>utf8bytelength</b> outputs the number of bytes used to encode a string in UTF-8.

           jq ´utf8bytelength´
              "\u03bc"
           =&gt; 2

   <b>keys,</b> <b>keys_unsorted</b>
       The builtin function <b>keys</b>, when given an object, returns its keys in an array.

       The  keys  are  sorted  "alphabetically",  by  unicode  codepoint  order. This is not an order that makes
       particular sense in any particular language, but you can count on it being the same for any  two  objects
       with the same set of keys, regardless of locale settings.

       When  <b>keys</b>  is  given  an  array,  it  returns  the  valid indices for that array: the integers from 0 to
       length-1.

       The <b>keys_unsorted</b> function is just like <b>keys</b>, but if the input is an object then the  keys  will  not  be
       sorted, instead the keys will roughly be in insertion order.

           jq ´keys´
              {"abc": 1, "abcd": 2, "Foo": 3}
           =&gt; ["Foo", "abc", "abcd"]

           jq ´keys´
              [42,3,35]
           =&gt; [0,1,2]

   <b>has(key)</b>
       The  builtin  function  <b>has</b> returns whether the input object has the given key, or the input array has an
       element at the given index.

       <b>has($key)</b> has the same effect as checking whether <b>$key</b> is  a  member  of  the  array  returned  by  <b>keys</b>,
       although <b>has</b> will be faster.

           jq ´map(has("foo"))´
              [{"foo": 42}, {}]
           =&gt; [true, false]

           jq ´map(<a href="../man2/has.2.html">has</a>(2))´
              [[0,1], ["a","b","c"]]
           =&gt; [false, true]

   <b>in</b>
       The  builtin  function <b>in</b> returns whether or not the input key is in the given object, or the input index
       corresponds to an element in the given array. It is, essentially, an inversed version of <b>has</b>.

           jq ´.[] | in({"foo": 42})´
              ["foo", "bar"]
           =&gt; true, false

           jq ´map(in([0,1]))´
              [2, 0]
           =&gt; [false, true]

   <b>map(f),</b> <b>map_values(f)</b>
       For any filter <b>f</b>, <b>map(f)</b> and <b>map_values(f)</b> apply <b>f</b> to each of the values in the input  array  or  object,
       that is, to the values of <b>.[]</b>.

       In  the absence of errors, <b>map(f)</b> always outputs an array whereas <b>map_values(f)</b> outputs an array if given
       an array, or an object if given an object.

       When the input to <b>map_values(f)</b> is an object, the output object has the same keys  as  the  input  object
       except for those keys whose values when piped to <b>f</b> produce no values at all.

       The key difference between <b>map(f)</b> and <b>map_values(f)</b> is that the former simply forms an array from all the
       values  of  <b>($x|f)</b>  for  each  value,  $x,  in  the  input  array  or object, but <b>map_values(f)</b> only uses
       <b>first($x|f)</b>.

       Specifically, for object inputs, <b>map_value(f)</b> constructs the output object by examining in turn the value
       of <b>first(.[$k]|f)</b> for each key, $k, of the input.  If  this  expression  produces  no  values,  then  the
       corresponding key will be dropped; otherwise, the output object will have that value at the key, $k.

       Here  are  some  examples  to  clarify  the  behavior of <b>map</b> and <b>map_values</b> when applied to arrays. These
       examples assume the input is <b>[1]</b> in all cases:

           map(.+1)          #=&gt;  [2]
           map(., .)         #=&gt;  [1,1]
           map(empty)        #=&gt;  []

           map_values(.+1)   #=&gt;  [2]
           map_values(., .)  #=&gt;  [1]
           map_values(empty) #=&gt;  []

       <b>map(f)</b> is equivalent to <b>[.[]</b> <b>|</b> <b>f]</b> and <b>map_values(f)</b> is equivalent to <b>.[]</b> <b>|=</b> <b>f</b>.

       In fact, these are their implementations.

           jq ´map(.+1)´
              [1,2,3]
           =&gt; [2,3,4]

           jq ´map_values(.+1)´
              {"a": 1, "b": 2, "c": 3}
           =&gt; {"a": 2, "b": 3, "c": 4}

           jq ´map(., .)´
              [1,2]
           =&gt; [1,1,2,2]

           jq ´map_values(. // empty)´
              {"a": null, "b": true, "c": false}
           =&gt; {"b":true}

   <b>pick(pathexps)</b>
       Emit the projection of the input object or array defined by the specified sequence of  path  expressions,
       such  that  if <b>p</b> is any one of these specifications, then <b>(.</b> <b>|</b> <b>p)</b> will evaluate to the same value as <b>(.</b> <b>|</b>
       <b>pick(pathexps)</b> <b>|</b> <b>p)</b>. For arrays, negative indices and <b>.[m:n]</b> specifications should not be used.

           jq ´pick(.a, .b.c, .x)´
              {"a": 1, "b": {"c": 2, "d": 3}, "e": 4}
           =&gt; {"a":1,"b":{"c":2},"x":null}

           jq ´pick(.[2], .[0], .[0])´
              [1,2,3,4]
           =&gt; [1,null,3]

   <b>path(path_expression)</b>
       Outputs array representations of the given path expression in  <b>.</b>.  The  outputs  are  arrays  of  strings
       (object keys) and/or numbers (array indices).

       Path  expressions are jq expressions like <b>.a</b>, but also <b>.[]</b>. There are two types of path expressions: ones
       that can match exactly, and ones that cannot. For example, <b>.a.b.c</b> is  an  exact  match  path  expression,
       while <b>.a[].b</b> is not.

       <b>path(exact_path_expression)</b>  will produce the array representation of the path expression even if it does
       not exist in <b>.</b>, if <b>.</b> is <b>null</b> or an array or an object.

       <b>path(pattern)</b> will produce array representations of the paths matching <b>pattern</b> if the paths exist in <b>.</b>.

       Note  that  the  path  expressions  are  not  different   from   normal   expressions.   The   expression
       <b>path(..|select(type=="boolean"))</b> outputs all the paths to boolean values in <b>.</b>, and only those paths.

           jq ´path(.a[0].b)´
              null
           =&gt; ["a",0,"b"]

           jq ´[path(..)]´
              {"a":[{"b":1}]}
           =&gt; [[],["a"],["a",0],["a",0,"b"]]

   <b>del(path_expression)</b>
       The builtin function <b>del</b> removes a key and its corresponding value from an object.

           jq ´del(.foo)´
              {"foo": 42, "bar": 9001, "baz": 42}
           =&gt; {"bar": 9001, "baz": 42}

           jq ´del(.[1, 2])´
              ["foo", "bar", "baz"]
           =&gt; ["foo"]

   <b>getpath(PATHS)</b>
       The builtin function <b>getpath</b> outputs the values in <b>.</b> found at each path in <b>PATHS</b>.

           jq ´getpath(["a","b"])´
              null
           =&gt; null

           jq ´[getpath(["a","b"], ["a","c"])]´
              {"a":{"b":0, "c":1}}
           =&gt; [0, 1]

   <b>setpath(PATHS;</b> <b>VALUE)</b>
       The builtin function <b>setpath</b> sets the <b>PATHS</b> in <b>.</b> to <b>VALUE</b>.

           jq ´setpath(["a","b"]; 1)´
              null
           =&gt; {"a": {"b": 1}}

           jq ´setpath(["a","b"]; 1)´
              {"a":{"b":0}}
           =&gt; {"a": {"b": 1}}

           jq ´setpath([0,"a"]; 1)´
              null
           =&gt; [{"a":1}]

   <b>delpaths(PATHS)</b>
       The builtin function <b>delpaths</b> deletes the <b>PATHS</b> in <b>.</b>. <b>PATHS</b> must be an array of paths, where each path is
       an array of strings and numbers.

           jq ´delpaths([["a","b"]])´
              {"a":{"b":1},"x":{"y":2}}
           =&gt; {"a":{},"x":{"y":2}}

   <b>to_entries,</b> <b>from_entries,</b> <b>with_entries(f)</b>
       These  functions  convert  between  an object and an array of key-value pairs. If <b>to_entries</b> is passed an
       object, then for each <b>k:</b> <b>v</b> entry in the input, the output array includes <b>{"key":</b> <b>k,</b> <b>"value":</b> <b>v}</b>.

       <b>from_entries</b> does the opposite conversion, and <b>with_entries(f)</b> is a shorthand for <b>to_entries</b> <b>|</b>  <b>map(f)</b>  <b>|</b>
       <b>from_entries</b>,  useful  for doing some operation to all keys and values of an object. <b>from_entries</b> accepts
       <b>"key"</b>, <b>"Key"</b>, <b>"name"</b>, <b>"Name"</b>, <b>"value"</b>, and <b>"Value"</b> as keys.

           jq ´to_entries´
              {"a": 1, "b": 2}
           =&gt; [{"key":"a", "value":1}, {"key":"b", "value":2}]

           jq ´from_entries´
              [{"key":"a", "value":1}, {"key":"b", "value":2}]
           =&gt; {"a": 1, "b": 2}

           jq ´with_entries(.key |= "KEY_" + .)´
              {"a": 1, "b": 2}
           =&gt; {"KEY_a": 1, "KEY_b": 2}

   <b>select(boolean_expression)</b>
       The function <b>select(f)</b> produces its input unchanged if <b>f</b> returns true for that  input,  and  produces  no
       output otherwise.

       It´s useful for filtering lists: <b>[1,2,3]</b> <b>|</b> <b>map(select(.</b> <b>&gt;=</b> <b>2))</b> will give you <b>[2,3]</b>.

           jq ´map(select(. &gt;= 2))´
              [1,5,3,0,7]
           =&gt; [5,3,7]

           jq ´.[] | select(.id == "second")´
              [{"id": "first", "val": 1}, {"id": "second", "val": 2}]
           =&gt; {"id": "second", "val": 2}

   <b>arrays,</b> <b>objects,</b> <b>iterables,</b> <b>booleans,</b> <b>numbers,</b> <b>normals,</b> <b>finites,</b> <b>strings,</b> <b>nulls,</b> <b>values,</b> <b>scalars</b>
       These  built-ins  select  only  inputs that are arrays, objects, iterables (arrays or objects), booleans,
       numbers, normal numbers, finite numbers, strings, null, non-null values, and non-iterables, respectively.

           jq ´.[]|numbers´
              [[],{},1,"foo",null,true,false]
           =&gt; 1

   <b>empty</b>
       <b>empty</b> returns no results. None at all. Not even <b>null</b>.

       It´s useful on occasion. You´ll know if you need it :)

           jq ´1, empty, 2´
              null
           =&gt; 1, 2

           jq ´[1,2,empty,3]´
              null
           =&gt; [1,2,3]

   <b>error,</b> <b><a href="../manmessage/error.message.html">error</a>(message)</b>
       Produces an error with the input value, or with the message given as the argument. Errors can  be  caught
       with try/catch; see below.

           jq ´try error catch .´
              "error message"
           =&gt; "error message"

           jq ´try error("invalid value: \(.)") catch .´
              42
           =&gt; "invalid value: 42"

   <b>halt</b>
       Stops the jq program with no further outputs. jq will exit with exit status <b>0</b>.

   <b>halt_error,</b> <b>halt_error(exit_code)</b>
       Stops  the  jq  program with no further outputs. The input will be printed on <b>stderr</b> as raw output (i.e.,
       strings will not have double quotes) with no decoration, not even a newline.

       The given <b>exit_code</b> (defaulting to <b>5</b>) will be jq´s exit status.

       For example, <b>"Error:</b> <b>something</b> <b>went</b> <b>wrong\n"|<a href="../man1/halt_error.1.html">halt_error</a>(1)</b>.

   <b>$__loc__</b>
       Produces an object with a "file" key and a "line" key, with the filename and line number  where  <b>$__loc__</b>
       occurs, as values.

           jq ´try error("\($__loc__)") catch .´
              null
           =&gt; "{\"file\":\"&lt;top-level&gt;\",\"line\":1}"

   <b>paths,</b> <b>paths(node_filter)</b>
       <b>paths</b>  outputs  the  paths  to  all  the elements in its input (except it does not output the empty list,
       representing . itself).

       <b>paths(f)</b> outputs the paths to any values for which <b>f</b> is <b>true</b>. That is, <b>paths(type</b>  <b>==</b>  <b>"number")</b>  outputs
       the paths to all numeric values.

           jq ´[paths]´
              [1,[[],{"a":2}]]
           =&gt; [[0],[1],[1,0],[1,1],[1,1,"a"]]

           jq ´[paths(type == "number")]´
              [1,[[],{"a":2}]]
           =&gt; [[0],[1,1,"a"]]

   <b>add</b>
       The  filter <b>add</b> takes as input an array, and produces as output the elements of the array added together.
       This might mean summed, concatenated or merged depending on the types of the elements of the input  array
       - the rules are the same as those for the <b>+</b> operator (described above).

       If the input is an empty array, <b>add</b> returns <b>null</b>.

           jq ´add´
              ["a","b","c"]
           =&gt; "abc"

           jq ´add´
              [1, 2, 3]
           =&gt; 6

           jq ´add´
              []
           =&gt; null

   <b>any,</b> <b>any(condition),</b> <b>any(generator;</b> <b>condition)</b>
       The  filter  <b>any</b>  takes  as  input  an array of boolean values, and produces <b>true</b> as output if any of the
       elements of the array are <b>true</b>.

       If the input is an empty array, <b>any</b> returns <b>false</b>.

       The <b>any(condition)</b> form applies the given condition to the elements of the input array.

       The <b>any(generator;</b> <b>condition)</b> form applies the given condition to all the outputs of the given generator.

           jq ´any´
              [true, false]
           =&gt; true

           jq ´any´
              [false, false]
           =&gt; false

           jq ´any´
              []
           =&gt; false

   <b>all,</b> <b>all(condition),</b> <b>all(generator;</b> <b>condition)</b>
       The filter <b>all</b> takes as input an array of boolean values, and produces <b>true</b>  as  output  if  all  of  the
       elements of the array are <b>true</b>.

       The <b>all(condition)</b> form applies the given condition to the elements of the input array.

       The <b>all(generator;</b> <b>condition)</b> form applies the given condition to all the outputs of the given generator.

       If the input is an empty array, <b>all</b> returns <b>true</b>.

           jq ´all´
              [true, false]
           =&gt; false

           jq ´all´
              [true, true]
           =&gt; true

           jq ´all´
              []
           =&gt; true

   <b>flatten,</b> <b>flatten(depth)</b>
       The  filter  <b>flatten</b>  takes  as  input  an array of nested arrays, and produces a flat array in which all
       arrays inside the original array have been recursively replaced by their values. You can pass an argument
       to it to specify how many levels of nesting to flatten.

       <b><a href="../man2/flatten.2.html">flatten</a>(2)</b> is like <b>flatten</b>, but going only up to two levels deep.

           jq ´flatten´
              [1, [2], [[3]]]
           =&gt; [1, 2, 3]

           jq ´<a href="../man1/flatten.1.html">flatten</a>(1)´
              [1, [2], [[3]]]
           =&gt; [1, 2, [3]]

           jq ´flatten´
              [[]]
           =&gt; []

           jq ´flatten´
              [{"foo": "bar"}, [{"foo": "baz"}]]
           =&gt; [{"foo": "bar"}, {"foo": "baz"}]

   <b>range(upto),</b> <b>range(from;</b> <b>upto),</b> <b>range(from;</b> <b>upto;</b> <b>by)</b>
       The <b>range</b> function produces a range of numbers. <b>range(4;</b> <b>10)</b> produces 6 numbers, from 4 (inclusive) to 10
       (exclusive). The numbers are produced as separate outputs. Use <b>[range(4;</b> <b>10)]</b> to get a range as an array.

       The one argument form generates numbers from 0 to the given number, with an increment of 1.

       The two argument form generates numbers from <b>from</b> to <b>upto</b> with an increment of 1.

       The three argument form generates numbers <b>from</b> to <b>upto</b> with an increment of <b>by</b>.

           jq ´range(2; 4)´
              null
           =&gt; 2, 3

           jq ´[range(2; 4)]´
              null
           =&gt; [2,3]

           jq ´[<a href="../man4/range.4.html">range</a>(4)]´
              null
           =&gt; [0,1,2,3]

           jq ´[range(0; 10; 3)]´
              null
           =&gt; [0,3,6,9]

           jq ´[range(0; 10; -1)]´
              null
           =&gt; []

           jq ´[range(0; -5; -1)]´
              null
           =&gt; [0,-1,-2,-3,-4]

   <b>floor</b>
       The <b>floor</b> function returns the floor of its numeric input.

           jq ´floor´
              3.14159
           =&gt; 3

   <b>sqrt</b>
       The <b>sqrt</b> function returns the square root of its numeric input.

           jq ´sqrt´
              9
           =&gt; 3

   <b>tonumber</b>
       The <b>tonumber</b> function parses its input as a number. It will convert correctly-formatted strings to  their
       numeric equivalent, leave numbers alone, and give an error on all other input.

           jq ´.[] | tonumber´
              [1, "1"]
           =&gt; 1, 1

   <b>tostring</b>
       The  <b>tostring</b> function prints its input as a string. Strings are left unchanged, and all other values are
       JSON-encoded.

           jq ´.[] | tostring´
              [1, "1", [1]]
           =&gt; "1", "1", "[1]"

   <b>type</b>
       The <b>type</b> function returns the type of its argument as a string, which is one of  null,  boolean,  number,
       string, array or object.

           jq ´map(type)´
              [0, false, [], {}, null, "hello"]
           =&gt; ["number", "boolean", "array", "object", "null", "string"]

   <b>infinite,</b> <b>nan,</b> <b>isinfinite,</b> <b>isnan,</b> <b>isfinite,</b> <b>isnormal</b>
       Some  arithmetic  operations can yield infinities and "not a number" (NaN) values. The <b>isinfinite</b> builtin
       returns <b>true</b> if its input is infinite. The <b>isnan</b> builtin returns <b>true</b> if its input is a NaN. The <b>infinite</b>
       builtin returns a positive infinite value. The <b>nan</b> builtin returns a NaN. The  <b>isnormal</b>  builtin  returns
       true if its input is a normal number.

       Note that division by zero raises an error.

       Currently most arithmetic operations operating on infinities, NaNs, and sub-normals do not raise errors.

           jq ´.[] | (infinite * .) &lt; 0´
              [-1, 1]
           =&gt; true, false

           jq ´infinite, nan | type´
              null
           =&gt; "number", "number"

   <b>sort,</b> <b>sort_by(path_expression)</b>
       The <b>sort</b> functions sorts its input, which must be an array. Values are sorted in the following order:

       •   <b>null</b>

       •   <b>false</b>

       •   <b>true</b>

       •   numbers

       •   strings, in alphabetical order (by unicode codepoint value)

       •   arrays, in lexical order

       •   objects

       The  ordering for objects is a little complex: first they´re compared by comparing their sets of keys (as
       arrays in sorted order), and if their keys are equal then the values are compared key by key.

       <b>sort_by</b> may be used to sort by a particular field of an object, or by applying any jq filter.  <b>sort_by(f)</b>
       compares  two  elements by comparing the result of <b>f</b> on each element. When <b>f</b> produces multiple values, it
       firstly compares the first values, and the second values if the first values are equal, and so on.

           jq ´sort´
              [8,3,null,6]
           =&gt; [null,3,6,8]

           jq ´sort_by(.foo)´
              [{"foo":4, "bar":10}, {"foo":3, "bar":10}, {"foo":2, "bar":1}]
           =&gt; [{"foo":2, "bar":1}, {"foo":3, "bar":10}, {"foo":4, "bar":10}]

           jq ´sort_by(.foo, .bar)´
              [{"foo":4, "bar":10}, {"foo":3, "bar":20}, {"foo":2, "bar":1}, {"foo":3, "bar":10}]
           =&gt; [{"foo":2, "bar":1}, {"foo":3, "bar":10}, {"foo":3, "bar":20}, {"foo":4, "bar":10}]

   <b>group_by(path_expression)</b>
       <b>group_by(.foo)</b> takes as input an array, groups the elements having the  same  <b>.foo</b>  field  into  separate
       arrays,  and  produces all of these arrays as elements of a larger array, sorted by the value of the <b>.foo</b>
       field.

       Any jq expression, not just a field access, may be used in place of <b>.foo</b>. The sorting order is  the  same
       as described in the <b>sort</b> function above.

           jq ´group_by(.foo)´
              [{"foo":1, "bar":10}, {"foo":3, "bar":100}, {"foo":1, "bar":1}]
           =&gt; [[{"foo":1, "bar":10}, {"foo":1, "bar":1}], [{"foo":3, "bar":100}]]

   <b>min,</b> <b>max,</b> <b>min_by(path_exp),</b> <b>max_by(path_exp)</b>
       Find the minimum or maximum element of the input array.

       The  <b>min_by(path_exp)</b>  and <b>max_by(path_exp)</b> functions allow you to specify a particular field or property
       to examine, e.g. <b>min_by(.foo)</b> finds the object with the smallest <b>foo</b> field.

           jq ´min´
              [5,4,2,7]
           =&gt; 2

           jq ´max_by(.foo)´
              [{"foo":1, "bar":14}, {"foo":2, "bar":3}]
           =&gt; {"foo":2, "bar":3}

   <b>unique,</b> <b>unique_by(path_exp)</b>
       The <b>unique</b> function takes as input an array and produces an array of the same elements, in sorted  order,
       with duplicates removed.

       The  <b>unique_by(path_exp)</b>  function  will  keep  only  one element for each value obtained by applying the
       argument. Think of it as making an array by taking one element out of every group produced by <b>group</b>.

           jq ´unique´
              [1,2,5,3,5,3,1,3]
           =&gt; [1,2,3,5]

           jq ´unique_by(.foo)´
              [{"foo": 1, "bar": 2}, {"foo": 1, "bar": 3}, {"foo": 4, "bar": 5}]
           =&gt; [{"foo": 1, "bar": 2}, {"foo": 4, "bar": 5}]

           jq ´unique_by(length)´
              ["chunky", "bacon", "kitten", "cicada", "asparagus"]
           =&gt; ["bacon", "chunky", "asparagus"]

   <b>reverse</b>
       This function reverses an array.

           jq ´reverse´
              [1,2,3,4]
           =&gt; [4,3,2,1]

   <b>contains(element)</b>
       The filter <b>contains(b)</b> will produce true if b is completely contained within the input.  A  string  B  is
       contained  in  a string A if B is a substring of A. An array B is contained in an array A if all elements
       in B are contained in any element in A. An object B is contained in object A if all of the  values  in  B
       are  contained  in  the value in A with the same key. All other types are assumed to be contained in each
       other if they are equal.

           jq ´contains("bar")´
              "foobar"
           =&gt; true

           jq ´contains(["baz", "bar"])´
              ["foobar", "foobaz", "blarp"]
           =&gt; true

           jq ´contains(["bazzzzz", "bar"])´
              ["foobar", "foobaz", "blarp"]
           =&gt; false

           jq ´contains({foo: 12, bar: [{barp: 12}]})´
              {"foo": 12, "bar":[1,2,{"barp":12, "blip":13}]}
           =&gt; true

           jq ´contains({foo: 12, bar: [{barp: 15}]})´
              {"foo": 12, "bar":[1,2,{"barp":12, "blip":13}]}
           =&gt; false

   <b>indices(s)</b>
       Outputs an array containing the indices in <b>.</b> where <b>s</b> occurs. The input may be an array, in which case  if
       <b>s</b> is an array then the indices output will be those where all elements in <b>.</b> match those of <b>s</b>.

           jq ´indices(", ")´
              "a,b, cd, efg, hijk"
           =&gt; [3,7,12]

           jq ´<a href="../man1/indices.1.html">indices</a>(1)´
              [0,1,2,1,3,1,4]
           =&gt; [1,3,5]

           jq ´indices([1,2])´
              [0,1,2,3,1,4,2,5,1,2,6,7]
           =&gt; [1,8]

   <b>index(s),</b> <b>rindex(s)</b>
       Outputs the index of the first (<b>index</b>) or last (<b>rindex</b>) occurrence of <b>s</b> in the input.

           jq ´index(", ")´
              "a,b, cd, efg, hijk"
           =&gt; 3

           jq ´<a href="../man1/index.1.html">index</a>(1)´
              [0,1,2,1,3,1,4]
           =&gt; 1

           jq ´index([1,2])´
              [0,1,2,3,1,4,2,5,1,2,6,7]
           =&gt; 1

           jq ´rindex(", ")´
              "a,b, cd, efg, hijk"
           =&gt; 12

           jq ´<a href="../man1/rindex.1.html">rindex</a>(1)´
              [0,1,2,1,3,1,4]
           =&gt; 5

           jq ´rindex([1,2])´
              [0,1,2,3,1,4,2,5,1,2,6,7]
           =&gt; 8

   <b>inside</b>
       The filter <b>inside(b)</b> will produce true if the input is completely contained within b. It is, essentially,
       an inversed version of <b>contains</b>.

           jq ´inside("foobar")´
              "bar"
           =&gt; true

           jq ´inside(["foobar", "foobaz", "blarp"])´
              ["baz", "bar"]
           =&gt; true

           jq ´inside(["foobar", "foobaz", "blarp"])´
              ["bazzzzz", "bar"]
           =&gt; false

           jq ´inside({"foo": 12, "bar":[1,2,{"barp":12, "blip":13}]})´
              {"foo": 12, "bar": [{"barp": 12}]}
           =&gt; true

           jq ´inside({"foo": 12, "bar":[1,2,{"barp":12, "blip":13}]})´
              {"foo": 12, "bar": [{"barp": 15}]}
           =&gt; false

   <b>startswith(str)</b>
       Outputs <b>true</b> if . starts with the given string argument.

           jq ´[.[]|startswith("foo")]´
              ["fo", "foo", "barfoo", "foobar", "barfoob"]
           =&gt; [false, true, false, true, false]

   <b>endswith(str)</b>
       Outputs <b>true</b> if . ends with the given string argument.

           jq ´[.[]|endswith("foo")]´
              ["foobar", "barfoo"]
           =&gt; [false, true]

   <b>combinations,</b> <b>combinations(n)</b>
       Outputs  all  combinations  of  the elements of the arrays in the input array. If given an argument <b>n</b>, it
       outputs all combinations of <b>n</b> repetitions of the input array.

           jq ´combinations´
              [[1,2], [3, 4]]
           =&gt; [1, 3], [1, 4], [2, 3], [2, 4]

           jq ´<a href="../man2/combinations.2.html">combinations</a>(2)´
              [0, 1]
           =&gt; [0, 0], [0, 1], [1, 0], [1, 1]

   <b>ltrimstr(str)</b>
       Outputs its input with the given prefix string removed, if it starts with it.

           jq ´[.[]|ltrimstr("foo")]´
              ["fo", "foo", "barfoo", "foobar", "afoo"]
           =&gt; ["fo","","barfoo","bar","afoo"]

   <b>rtrimstr(str)</b>
       Outputs its input with the given suffix string removed, if it ends with it.

           jq ´[.[]|rtrimstr("foo")]´
              ["fo", "foo", "barfoo", "foobar", "foob"]
           =&gt; ["fo","","bar","foobar","foob"]

   <b>explode</b>
       Converts an input string into an array of the string´s codepoint numbers.

           jq ´explode´
              "foobar"
           =&gt; [102,111,111,98,97,114]

   <b>implode</b>
       The inverse of explode.

           jq ´implode´
              [65, 66, 67]
           =&gt; "ABC"

   <b>split(str)</b>
       Splits an input string on the separator argument.

       <b>split</b> can also split on regex matches when called with two arguments (see the regular expressions section
       below).

           jq ´split(", ")´
              "a, b,c,d, e, "
           =&gt; ["a","b,c,d","e",""]

   <b>join(str)</b>
       Joins the array of elements given as input, using the argument as separator. It is the inverse of  <b>split</b>:
       that is, running <b>split("foo")</b> <b>|</b> <b>join("foo")</b> over any input string returns said input string.

       Numbers  and  booleans  in  the input are converted to strings. Null values are treated as empty strings.
       Arrays and objects in the input are not supported.

           jq ´join(", ")´
              ["a","b,c,d","e"]
           =&gt; "a, b,c,d, e"

           jq ´join(" ")´
              ["a",1,2.3,true,null,false]
           =&gt; "a 1 2.3 true  false"

   <b>ascii_downcase,</b> <b>ascii_upcase</b>
       Emit a copy of the input string with its alphabetic characters (a-z and A-Z) converted to  the  specified
       case.

           jq ´ascii_upcase´
              "useful but not for é"
           =&gt; "USEFUL BUT NOT FOR é"

   <b>while(cond;</b> <b>update)</b>
       The <b>while(cond;</b> <b>update)</b> function allows you to repeatedly apply an update to <b>.</b> until <b>cond</b> is false.

       Note  that  <b>while(cond;</b>  <b>update)</b> is internally defined as a recursive jq function. Recursive calls within
       <b>while</b> will not consume additional memory if <b>update</b> produces at  most  one  output  for  each  input.  See
       advanced topics below.

           jq ´[while(.&lt;100; .*2)]´
              1
           =&gt; [1,2,4,8,16,32,64]

   <b>repeat(exp)</b>
       The <b>repeat(exp)</b> function allows you to repeatedly apply expression <b>exp</b> to <b>.</b> until an error is raised.

       Note  that  <b>repeat(exp)</b>  is  internally defined as a recursive jq function. Recursive calls within <b>repeat</b>
       will not consume additional memory if <b>exp</b> produces at most one output for each input. See advanced topics
       below.

           jq ´[repeat(.*2, error)?]´
              1
           =&gt; [2]

   <b>until(cond;</b> <b>next)</b>
       The <b>until(cond;</b> <b>next)</b> function allows you to repeatedly apply the expression <b>next</b>, initially to <b>.</b> then to
       its own output, until <b>cond</b> is true. For example, this can be used to implement a factorial function  (see
       below).

       Note  that  <b>until(cond;</b>  <b>next)</b>  is  internally defined as a recursive jq function. Recursive calls within
       <b>until()</b> will not consume additional memory if <b>next</b> produces at  most  one  output  for  each  input.  See
       advanced topics below.

           jq ´[.,1]|until(.[0] &lt; 1; [.[0] - 1, .[1] * .[0]])|.[1]´
              4
           =&gt; 24

   <b>recurse(f),</b> <b>recurse,</b> <b>recurse(f;</b> <b>condition)</b>
       The  <b>recurse(f)</b> function allows you to search through a recursive structure, and extract interesting data
       from all levels. Suppose your input represents a filesystem:

           {"name": "/", "children": [
             {"name": "<a href="file:/bin">/bin</a>", "children": [
               {"name": "<a href="file:/bin/ls">/bin/ls</a>", "children": []},
               {"name": "<a href="file:/bin/sh">/bin/sh</a>", "children": []}]},
             {"name": "<a href="file:/home">/home</a>", "children": [
               {"name": "/home/stephen", "children": [
                 {"name": "/home/stephen/jq", "children": []}]}]}]}

       Now  suppose  you  want  to  extract  all  of  the  filenames  present.  You  need  to  retrieve   <b>.name</b>,
       <b>.children[].name</b>, <b>.children[].children[].name</b>, and so on. You can do this with:

           recurse(.children[]) | .name

       When called without an argument, <b>recurse</b> is equivalent to <b>recurse(.[]?)</b>.

       <b>recurse(f)</b> is identical to <b>recurse(f;</b> <b>true)</b> and can be used without concerns about recursion depth.

       <b>recurse(f;</b>  <b>condition)</b>  is  a  generator  which  begins  by emitting . and then emits in turn .|f, .|f|f,
       .|f|f|f, ... so long as the computed value satisfies the condition. For  example,  to  generate  all  the
       integers, at least in principle, one could write <b>recurse(.+1;</b> <b>true)</b>.

       The  recursive  calls  in <b>recurse</b> will not consume additional memory whenever <b>f</b> produces at most a single
       output for each input.

           jq ´recurse(.foo[])´
              {"foo":[{"foo": []}, {"foo":[{"foo":[]}]}]}
           =&gt; {"foo":[{"foo":[]},{"foo":[{"foo":[]}]}]}, {"foo":[]}, {"foo":[{"foo":[]}]}, {"foo":[]}

           jq ´recurse´
              {"a":0,"b":[1]}
           =&gt; {"a":0,"b":[1]}, 0, [1], 1

           jq ´recurse(. * .; . &lt; 20)´
              2
           =&gt; 2, 4, 16

   <b>walk(f)</b>
       The <b>walk(f)</b> function applies f recursively to every component of the  input  entity.  When  an  array  is
       encountered,  f  is  first  applied  to  its  elements  and  then  to the array itself; when an object is
       encountered, f is first applied to all the values and then to the object. In  practice,  f  will  usually
       test  the  type  of its input, as illustrated in the following examples. The first example highlights the
       usefulness of processing the elements of an array of arrays  before  processing  the  array  itself.  The
       second  example  shows  how  all  the  keys  of  all  the  objects within the input can be considered for
       alteration.

           jq ´walk(if type == "array" then sort else . end)´
              [[4, 1, 7], [8, 5, 2], [3, 6, 9]]
           =&gt; [[1,4,7],[2,5,8],[3,6,9]]

           jq ´walk( if type == "object" then with_entries( .key |= sub( "^_+"; "") ) else . end )´
              [ { "_a": { "__b": 2 } } ]
           =&gt; [{"a":{"b":2}}]

   <b>$JQ_BUILD_CONFIGURATION</b>
       This builtin binding shows the jq executable´s build configuration. Its value has no  particular  format,
       but  it can be expected to be at least the <b>./configure</b> command-line arguments, and may be enriched in the
       future to include the version strings for the build tooling used.

       Note that this can be overriden in the command-line with <b>--arg</b> and related options.

   <b>$ENV,</b> <b>env</b>
       <b>$ENV</b> is an object representing the environment variables as set when the jq program started.

       <b>env</b> outputs an object representing jq´s current environment.

       At the moment there is no builtin for setting environment variables.

           jq ´$ENV.PAGER´
              null
           =&gt; "less"

           jq ´env.PAGER´
              null
           =&gt; "less"

   <b>transpose</b>
       Transpose a possibly jagged matrix (an array of arrays). Rows are padded with  nulls  so  the  result  is
       always rectangular.

           jq ´transpose´
              [[1], [2,3]]
           =&gt; [[1,2],[null,3]]

   <b>bsearch(x)</b>
       <b>bsearch(x)</b> conducts a binary search for x in the input array. If the input is sorted and contains x, then
       <b>bsearch(x)</b>  will  return  its index in the array; otherwise, if the array is sorted, it will return (-1 -
       ix) where ix is an insertion point such that the array would still be sorted after the insertion of x  at
       ix. If the array is not sorted, <b>bsearch(x)</b> will return an integer that is probably of no interest.

           jq ´<a href="../man0/bsearch.0.html">bsearch</a>(0)´
              [0,1]
           =&gt; 0

           jq ´<a href="../man0/bsearch.0.html">bsearch</a>(0)´
              [1,2,3]
           =&gt; -1

           jq ´<a href="../man4/bsearch.4.html">bsearch</a>(4) as $ix | if $ix &lt; 0 then .[-(1+$ix)] = 4 else . end´
              [1,2,3]
           =&gt; [1,2,3,4]

   <b>String</b> <b>interpolation:</b> <b>\(exp)</b>
       Inside  a  string,  you  can  put  an expression inside parens after a backslash. Whatever the expression
       returns will be interpolated into the string.

           jq ´"The input was \(.), which is one less than \(.+1)"´
              42
           =&gt; "The input was 42, which is one less than 43"

   <b>Convert</b> <b>to/from</b> <b>JSON</b>
       The <b>tojson</b> and <b>fromjson</b> builtins dump values as JSON texts or parse JSON texts into values, respectively.
       The <b>tojson</b> builtin differs from <b>tostring</b> in  that  <b>tostring</b>  returns  strings  unmodified,  while  <b>tojson</b>
       encodes strings as JSON strings.

           jq ´[.[]|tostring]´
              [1, "foo", ["foo"]]
           =&gt; ["1","foo","[\"foo\"]"]

           jq ´[.[]|tojson]´
              [1, "foo", ["foo"]]
           =&gt; ["1","\"foo\"","[\"foo\"]"]

           jq ´[.[]|tojson|fromjson]´
              [1, "foo", ["foo"]]
           =&gt; [1,"foo",["foo"]]

   <b>Format</b> <b>strings</b> <b>and</b> <b>escaping</b>
       The  <b>@foo</b>  syntax is used to format and escape strings, which is useful for building URLs, documents in a
       language like HTML or XML, and so forth. <b>@foo</b> can be used as a filter on its own, the possible  escapings
       are:

       <b>@text</b>:

              Calls <b>tostring</b>, see that function for details.

       <b>@json</b>:

              Serializes the input as JSON.

       <b>@html</b>:

              Applies HTML/XML escaping, by mapping the characters <b>&lt;&gt;&amp;´"</b> to their entity equivalents <b>&amp;lt;</b>, <b>&amp;gt;</b>,
              <b>&amp;amp;</b>, <b>&amp;apos;</b>, <b>&amp;quot;</b>.

       <b>@uri</b>:

              Applies percent-encoding, by mapping all reserved URI characters to a <b>%XX</b> sequence.

       <b>@csv</b>:

              The  input  must be an array, and it is rendered as CSV with double quotes for strings, and quotes
              escaped by repetition.

       <b>@tsv</b>:

              The input must be an array, and it is rendered as TSV (tab-separated  values).  Each  input  array
              will  be  printed  as  a  single  line.  Fields  are separated by a single tab (ascii <b>0x09</b>). Input
              characters line-feed (ascii <b>0x0a</b>), carriage-return (ascii <b>0x0d</b>), tab (ascii  <b>0x09</b>)  and  backslash
              (ascii <b>0x5c</b>) will be output as escape sequences <b>\n</b>, <b>\r</b>, <b>\t</b>, <b>\\</b> respectively.

       <b>@sh</b>:

              The  input  is  escaped  suitable  for use in a command-line for a POSIX shell. If the input is an
              array, the output will be a series of space-separated strings.

       <b>@base64</b>:

              The input is converted to base64 as specified by RFC 4648.

       <b>@base64d</b>:

              The inverse of <b>@base64</b>, input is decoded as specified by RFC 4648. Note\: If the decoded string is
              not UTF-8, the results are undefined.

       This syntax can be combined with string interpolation in a useful way. You can follow a <b>@foo</b> token with a
       string literal. The contents of the string literal will <u>not</u> be escaped. However, all interpolations  made
       inside that string literal will be escaped. For instance,

           @uri "https://www.google.com/search?q=\(.search)"

       will produce the following output for the input <b>{"search":"what</b> <b>is</b> <b>jq?"}</b>:

           "https://www.google.com/search?q=what%20is%20jq%3F"

       Note  that  the  slashes, question mark, etc. in the URL are not escaped, as they were part of the string
       literal.

           jq ´@html´
              "This works if x &lt; y"
           =&gt; "This works if x &amp;lt; y"

           jq ´@sh "echo \(.)"´
              "O´Hara´s Ale"
           =&gt; "echo ´O´\\´´Hara´\\´´s Ale´"

           jq ´@base64´
              "This is a message"
           =&gt; "VGhpcyBpcyBhIG1lc3NhZ2U="

           jq ´@base64d´
              "VGhpcyBpcyBhIG1lc3NhZ2U="
           =&gt; "This is a message"

   <b>Dates</b>
       jq provides some basic date handling functionality, with some high-level and low-level builtins.  In  all
       cases these builtins deal exclusively with time in UTC.

       The <b>fromdateiso8601</b> builtin parses datetimes in the ISO 8601 format to a number of seconds since the Unix
       epoch (1970-01-01T00:00:00Z). The <b>todateiso8601</b> builtin does the inverse.

       The <b>fromdate</b> builtin parses datetime strings. Currently <b>fromdate</b> only supports ISO 8601 datetime strings,
       but in the future it will attempt to parse datetime strings in more formats.

       The <b>todate</b> builtin is an alias for <b>todateiso8601</b>.

       The <b>now</b> builtin outputs the current time, in seconds since the Unix epoch.

       Low-level  jq  interfaces  to  the  C-library  time  functions  are  also  provided:  <b>strptime</b>, <b>strftime</b>,
       <b>strflocaltime</b>, <b>mktime</b>, <b>gmtime</b>, and <b>localtime</b>. Refer to your host operating system´s documentation for the
       format strings used by <b>strptime</b> and <b>strftime</b>. Note: these are not necessarily stable  interfaces  in  jq,
       particularly as to their localization functionality.

       The  <b>gmtime</b>  builtin  consumes  a number of seconds since the Unix epoch and outputs a "broken down time"
       representation of Greenwich Mean Time as an array of numbers representing (in this order): the year,  the
       month  (zero-based),  the  day of the month (one-based), the hour of the day, the minute of the hour, the
       second of the minute, the day of the week, and the day of the year  --  all  one-based  unless  otherwise
       stated. The day of the week number may be wrong on some systems for dates before March 1st 1900, or after
       December 31 2099.

       The <b>localtime</b> builtin works like the <b>gmtime</b> builtin, but using the local timezone setting.

       The <b>mktime</b> builtin consumes "broken down time" representations of time output by <b>gmtime</b> and <b>strptime</b>.

       The  <b>strptime(fmt)</b>  builtin  parses input strings matching the <b>fmt</b> argument. The output is in the "broken
       down time" representation consumed by <b>gmtime</b> and output by <b>mktime</b>.

       The <b>strftime(fmt)</b> builtin formats a time (GMT) with the given format. The <b>strflocaltime</b>  does  the  same,
       but using the local timezone setting.

       The format strings for <b>strptime</b> and <b>strftime</b> are described in typical C library documentation. The format
       string for ISO 8601 datetime is <b>"%Y-%m-%dT%H:%M:%SZ"</b>.

       jq  may  not support some or all of this date functionality on some systems. In particular, the <b>%u</b> and <b>%j</b>
       specifiers for <b>strptime(fmt)</b> are not supported on macOS.

           jq ´fromdate´
              "2015-03-05T23:51:47Z"
           =&gt; 1425599507

           jq ´strptime("%Y-%m-%dT%H:%M:%SZ")´
              "2015-03-05T23:51:47Z"
           =&gt; [2015,2,5,23,51,47,4,63]

           jq ´strptime("%Y-%m-%dT%H:%M:%SZ")|mktime´
              "2015-03-05T23:51:47Z"
           =&gt; 1425599507

   <b>SQL-Style</b> <b>Operators</b>
       jq provides a few SQL-style operators.

       INDEX(stream; index_expression):

              This builtin produces an object whose keys are computed by the given index expression  applied  to
              each value from the given stream.

       JOIN($idx; stream; idx_expr; join_expr):

              This  builtin  joins  the  values  from  the given stream to the given index. The index´s keys are
              computed by applying the given index expression to each value from the given stream. An  array  of
              the  value  in  the  stream  and  the  corresponding value from the index is fed to the given join
              expression to produce each result.

       JOIN($idx; stream; idx_expr):

              Same as <b>JOIN($idx;</b> <b>stream;</b> <b>idx_expr;</b> <b>.)</b>.

       JOIN($idx; idx_expr):

              This builtin joins the input <b>.</b> to the given index, applying the given index  expression  to  <b>.</b>  to
              compute the index key. The join operation is as described above.

       IN(s):

              This builtin outputs <b>true</b> if <b>.</b> appears in the given stream, otherwise it outputs <b>false</b>.

       IN(source; s):

              This  builtin  outputs  <b>true</b>  if  any  value  in  the  source stream appears in the second stream,
              otherwise it outputs <b>false</b>.

   <b>builtins</b>
       Returns a list of all builtin functions in the format <b>name/arity</b>. Since functions with the same name  but
       different  arities are considered separate functions, <b>all/0</b>, <b>all/1</b>, and <b>all/2</b> would all be present in the
       list.

</pre><h4><b>CONDITIONALS</b> <b>AND</b> <b>COMPARISONS</b></h4><pre>
   <b>==,</b> <b>!=</b>
       The expression ´a == b´ will produce ´true´ if the results of evaluating a and b are equal (that  is,  if
       they represent equivalent JSON values) and ´false´ otherwise. In particular, strings are never considered
       equal  to  numbers.  In checking for the equality of JSON objects, the ordering of keys is irrelevant. If
       you´re coming from JavaScript, please note that jq´s <b>==</b> is like JavaScript´s <b>===</b>, the  "strict  equality"
       operator.

       != is "not equal", and ´a != b´ returns the opposite value of ´a == b´

           jq ´. == false´
              null
           =&gt; false

           jq ´. == {"b": {"d": (4 + 1e-20), "c": 3}, "a":1}´
              {"a":1, "b": {"c": 3, "d": 4}}
           =&gt; true

           jq ´.[] == 1´
              [1, 1.0, "1", "banana"]
           =&gt; true, true, false, false

   <b>if-then-else-end</b>
       <b>if</b> <b>A</b> <b>then</b> <b>B</b> <b>else</b> <b>C</b> <b>end</b> will act the same as <b>B</b> if <b>A</b> produces a value other than false or null, but act the
       same as <b>C</b> otherwise.

       <b>if</b>  <b>A</b>  <b>then</b>  <b>B</b>  <b>end</b>  is the same as <b>if</b> <b>A</b> <b>then</b> <b>B</b> <b>else</b> <b>.</b>  <b>end</b>. That is, the <b>else</b> branch is optional, and if
       absent is the same as <b>.</b>. This also applies to <b>elif</b> with absent ending <b>else</b> branch.

       Checking for false or null is a simpler notion of "truthiness" than is found in JavaScript or Python, but
       it means that you´ll sometimes have to be more explicit about the condition  you  want.  You  can´t  test
       whether,  e.g. a string is empty using <b>if</b> <b>.name</b> <b>then</b> <b>A</b> <b>else</b> <b>B</b> <b>end</b>; you´ll need something like <b>if</b> <b>.name</b> <b>==</b>
       <b>""</b> <b>then</b> <b>A</b> <b>else</b> <b>B</b> <b>end</b> instead.

       If the condition <b>A</b> produces multiple results, then <b>B</b> is evaluated once for each result that is not  false
       or null, and <b>C</b> is evaluated once for each false or null.

       More cases can be added to an if using <b>elif</b> <b>A</b> <b>then</b> <b>B</b> syntax.

           jq ´if . == 0 then
             "zero"
           elif . == 1 then
             "one"
           else
             "many"
           end´
              2
           =&gt; "many"

   <b>&gt;,</b> <b>&gt;=,</b> <b>&lt;=,</b> <b>&lt;</b>
       The comparison operators <b>&gt;</b>, <b>&gt;=</b>, <b>&lt;=</b>, <b>&lt;</b> return whether their left argument is greater than, greater than or
       equal to, less than or equal to or less than their right argument (respectively).

       The ordering is the same as that described for <b>sort</b>, above.

           jq ´. &lt; 5´
              2
           =&gt; true

   <b>and,</b> <b>or,</b> <b>not</b>
       jq  supports  the  normal  Boolean  operators  <b>and</b>,  <b>or</b>,  <b>not</b>. They have the same standard of truth as if
       expressions - <b>false</b> and <b>null</b> are considered "false values", and anything else is a "true value".

       If an operand of one of these operators produces multiple results, the operator  itself  will  produce  a
       result for each input.

       <b>not</b>  is  in  fact a builtin function rather than an operator, so it is called as a filter to which things
       can be piped rather than with special syntax, as in <b>.foo</b> <b>and</b> <b>.bar</b> <b>|</b> <b>not</b>.

       These three only produce the values  <b>true</b>  and  <b>false</b>,  and  so  are  only  useful  for  genuine  Boolean
       operations,  rather than the common Perl/Python/Ruby idiom of "value_that_may_be_null or default". If you
       want to use this form of "or", picking between two values rather than evaluating a condition, see the  <b>//</b>
       operator below.

           jq ´42 and "a string"´
              null
           =&gt; true

           jq ´(true, false) or false´
              null
           =&gt; true, false

           jq ´(true, true) and (true, false)´
              null
           =&gt; true, false, true, false

           jq ´[true, false | not]´
              null
           =&gt; [false, true]

   <b>Alternative</b> <b>operator:</b> <b>//</b>
       The  <b>//</b>  operator  produces  all the values of its left-hand side that are neither <b>false</b> nor <b>null</b>. If the
       left-hand side produces no values other than <b>false</b> or <b>null</b>, then  <b>//</b>  produces  all  the  values  of  its
       right-hand side.

       A  filter  of  the form <b>a</b> <b>//</b> <b>b</b> produces all the results of <b>a</b> that are not <b>false</b> or <b>null</b>. If <b>a</b> produces no
       results, or no results other than <b>false</b> or <b>null</b>, then <b>a</b> <b>//</b> <b>b</b> produces the results of <b>b</b>.

       This is useful for providing defaults: <b>.foo</b> <b>//</b> <b>1</b> will evaluate to <b>1</b> if there´s no  <b>.foo</b>  element  in  the
       input.  It´s  similar  to  how  <b>or</b> is sometimes used in Python (jq´s <b>or</b> operator is reserved for strictly
       Boolean operations).

       Note: <b>some_generator</b> <b>//</b> <b>defaults_here</b> is not the same as <b>some_generator</b> <b>|</b> <b>.</b> <b>//</b> <b>defaults_here</b>. The  latter
       will  produce  default  values for all non-<b>false</b>, non-<b>null</b> values of the left-hand side, while the former
       will not. Precedence rules can make this confusing. For example, in <b>false,</b> <b>1</b> <b>//</b> <b>2</b> the left-hand  side  of
       <b>//</b> is <b>1</b>, not <b>false,</b> <b>1</b> -- <b>false,</b> <b>1</b> <b>//</b> <b>2</b> parses the same way as <b>false,</b> <b>(1</b> <b>//</b> <b>2)</b>. In <b>(false,</b> <b>null,</b> <b>1)</b> <b>|</b> <b>.</b> <b>//</b>
       <b>42</b>  the  left-hand side of <b>//</b> is <b>.</b>, which always produces just one value, while in <b>(false,</b> <b>null,</b> <b>1)</b> <b>//</b> <b>42</b>
       the left-hand side is a generator of three values, and since it produces a value other  <b>false</b>  and  <b>null</b>,
       the default <b>42</b> is not produced.

           jq ´empty // 42´
              null
           =&gt; 42

           jq ´.foo // 42´
              {"foo": 19}
           =&gt; 19

           jq ´.foo // 42´
              {}
           =&gt; 42

           jq ´(false, null, 1) // 42´
              null
           =&gt; 1

           jq ´(false, null, 1) | . // 42´
              null
           =&gt; 42, 42, 1

   <b>try-catch</b>
       Errors  can  be caught by using <b>try</b> <b>EXP</b> <b>catch</b> <b>EXP</b>. The first expression is executed, and if it fails then
       the second is executed with the error message. The output of the handler, if any, is output as if it  had
       been the output of the expression to try.

       The <b>try</b> <b>EXP</b> form uses <b>empty</b> as the exception handler.

           jq ´try .a catch ". is not an object"´
              true
           =&gt; ". is not an object"

           jq ´[.[]|try .a]´
              [{}, true, {"a":1}]
           =&gt; [null, 1]

           jq ´try error("some exception") catch .´
              true
           =&gt; "some exception"

   <b>Breaking</b> <b>out</b> <b>of</b> <b>control</b> <b>structures</b>
       A  convenient  use of try/catch is to break out of control structures like <b>reduce</b>, <b>foreach</b>, <b>while</b>, and so
       on.

       For example:

           # Repeat an expression until it raises "break" as an
           # error, then stop repeating without re-raising the error.
           # But if the error caught is not "break" then re-raise it.
           try repeat(exp) catch if .=="break" then empty else error

       jq has a syntax for named lexical labels to "break" or "go (back) to":

           label $out | ... break $out ...

       The <b>break</b> <b>$label_name</b> expression will cause the program to to act as though the  nearest  (to  the  left)
       <b>label</b> <b>$label_name</b> produced <b>empty</b>.

       The relationship between the <b>break</b> and corresponding <b>label</b> is lexical: the label has to be "visible" from
       the break.

       To break out of a <b>reduce</b>, for example:

           label $out | reduce .[] as $item (null; if .==false then break $out else ... end)

       The following jq program produces a syntax error:

           break $out

       because no label <b>$out</b> is visible.

   <b>Error</b> <b>Suppression</b> <b>/</b> <b>Optional</b> <b>Operator:</b> <b>?</b>
       The <b>?</b> operator, used as <b>EXP?</b>, is shorthand for <b>try</b> <b>EXP</b>.

           jq ´[.[] | .a?]´
              [{}, true, {"a":1}]
           =&gt; [null, 1]

           jq ´[.[] | tonumber?]´
              ["1", "invalid", "3", 4]
           =&gt; [1, 3, 4]

</pre><h4><b>REGULAR</b> <b>EXPRESSIONS</b></h4><pre>
       jq  uses  the  Oniguruma  regular  expression  library,  as  do  PHP, TextMate, Sublime Text, etc, so the
       description here will focus on jq specifics.

       Oniguruma supports several flavors of regular expression, so it is important to know  that  jq  uses  the
       "Perl NG" (Perl with named groups) flavor.

       The jq regex filters are defined so that they can be used using one of these patterns:

           STRING | FILTER(REGEX)
           STRING | FILTER(REGEX; FLAGS)
           STRING | FILTER([REGEX])
           STRING | FILTER([REGEX, FLAGS])

       where:

       •   STRING, REGEX, and FLAGS are jq strings and subject to jq string interpolation;

       •   REGEX, after string interpolation, should be a valid regular expression;

       •   FILTER is one of <b>test</b>, <b>match</b>, or <b>capture</b>, as described below.

       Since  REGEX must evaluate to a JSON string, some characters that are needed to form a regular expression
       must be escaped. For example, the regular expression  <b>\s</b>  signifying  a  whitespace  character  would  be
       written as <b>"\\s"</b>.

       FLAGS is a string consisting of one of more of the supported flags:

       •   <b>g</b> - Global search (find all matches, not just the first)

       •   <b>i</b> - Case insensitive search

       •   <b>m</b> - Multi line mode (<b>.</b> will match newlines)

       •   <b>n</b> - Ignore empty matches

       •   <b>p</b> - Both s and m modes are enabled

       •   <b>s</b> - Single line mode (<b>^</b> -&gt; <b>\A</b>, <b>$</b> -&gt; <b>\Z</b>)

       •   <b>l</b> - Find longest possible matches

       •   <b>x</b> - Extended regex format (ignore whitespace and comments)

       To match a whitespace with the <b>x</b> flag, use <b>\s</b>, e.g.

           jq -n ´"a b" | test("a\\sb"; "x")´

       Note that certain flags may also be specified within REGEX, e.g.

           jq -n ´("test", "TEst", "teST", "TEST") | test("(?i)te(?-i)st")´

       evaluates to: <b>true</b>, <b>true</b>, <b>false</b>, <b>false</b>.

   <b>test(val),</b> <b>test(regex;</b> <b>flags)</b>
       Like  <b>match</b>,  but  does not return match objects, only <b>true</b> or <b>false</b> for whether or not the regex matches
       the input.

           jq ´test("foo")´
              "foo"
           =&gt; true

           jq ´.[] | test("a b c # spaces are ignored"; "ix")´
              ["xabcd", "ABC"]
           =&gt; true, true

   <b>match(val),</b> <b>match(regex;</b> <b>flags)</b>
       <b>match</b> outputs an object for each match it finds. Matches have the following fields:

       •   <b>offset</b> - offset in UTF-8 codepoints from the beginning of the input

       •   <b>length</b> - length in UTF-8 codepoints of the match

       •   <b>string</b> - the string that it matched

       •   <b>captures</b> - an array of objects representing capturing groups.

       Capturing group objects have the following fields:

       •   <b>offset</b> - offset in UTF-8 codepoints from the beginning of the input

       •   <b>length</b> - length in UTF-8 codepoints of this capturing group

       •   <b>string</b> - the string that was captured

       •   <b>name</b> - the name of the capturing group (or <b>null</b> if it was unnamed)

       Capturing groups that did not match anything return an offset of -1

           jq ´match("(abc)+"; "g")´
              "abc abc"
           =&gt; {"offset": 0, "length": 3, "string": "abc", "captures": [{"offset": 0, "length": 3, "string": "abc", "name": null}]}, {"offset": 4, "length": 3, "string": "abc", "captures": [{"offset": 4, "length": 3, "string": "abc", "name": null}]}

           jq ´match("foo")´
              "foo bar foo"
           =&gt; {"offset": 0, "length": 3, "string": "foo", "captures": []}

           jq ´match(["foo", "ig"])´
              "foo bar FOO"
           =&gt; {"offset": 0, "length": 3, "string": "foo", "captures": []}, {"offset": 8, "length": 3, "string": "FOO", "captures": []}

           jq ´match("foo (?&lt;bar123&gt;bar)? foo"; "ig")´
              "foo bar foo foo  foo"
           =&gt; {"offset": 0, "length": 11, "string": "foo bar foo", "captures": [{"offset": 4, "length": 3, "string": "bar", "name": "bar123"}]}, {"offset": 12, "length": 8, "string": "foo  foo", "captures": [{"offset": -1, "length": 0, "string": null, "name": "bar123"}]}

           jq ´[ match("."; "g")] | length´
              "abc"
           =&gt; 3

   <b>capture(val),</b> <b>capture(regex;</b> <b>flags)</b>
       Collects the named captures in a JSON object, with the name of each capture as the key, and  the  matched
       string as the corresponding value.

           jq ´capture("(?&lt;a&gt;[a-z]+)-(?&lt;n&gt;[0-9]+)")´
              "xyzzy-14"
           =&gt; { "a": "xyzzy", "n": "14" }

   <b>scan(regex),</b> <b>scan(regex;</b> <b>flags)</b>
       Emit  a stream of the non-overlapping substrings of the input that match the regex in accordance with the
       flags, if any have been specified. If there is no match, the stream is empty. To capture all the  matches
       for each input string, use the idiom <b>[</b> <b>expr</b> <b>]</b>, e.g. <b>[</b> <b>scan(regex)</b> <b>]</b>.

           jq ´scan("c")´
              "abcdefabc"
           =&gt; "c", "c"

   <b>split(regex;</b> <b>flags)</b>
       Splits an input string on each regex match.

       For backwards compatibility, when called with a single argument, <b>split</b> splits on a string, not a regex.

           jq ´split(", *"; null)´
              "ab,cd, ef"
           =&gt; ["ab","cd","ef"]

   <b>splits(regex),</b> <b>splits(regex;</b> <b>flags)</b>
       These provide the same results as their <b>split</b> counterparts, but as a stream instead of an array.

           jq ´splits(", *")´
              "ab,cd,   ef, gh"
           =&gt; "ab", "cd", "ef", "gh"

   <b>sub(regex;</b> <b>tostring),</b> <b>sub(regex;</b> <b>tostring;</b> <b>flags)</b>
       Emit  the  string obtained by replacing the first match of regex in the input string with <b>tostring</b>, after
       interpolation. <b>tostring</b> should be a jq string or a stream of such strings,  each  of  which  may  contain
       references  to  named  captures.  The  named  captures  are,  in  effect,  presented as a JSON object (as
       constructed by <b>capture</b>) to <b>tostring</b>, so a reference to a captured variable named "x" would take the form:
       <b>"\(.x)"</b>.

           jq ´sub("[^a-z]*(?&lt;x&gt;[a-z]+)"; "Z\(.x)"; "g")´
              "123abc456def"
           =&gt; "ZabcZdef"

           jq ´[sub("(?&lt;a&gt;.)"; "\(.a|ascii_upcase)", "\(.a|ascii_downcase)")]´
              "aB"
           =&gt; ["AB","aB"]

   <b>gsub(regex;</b> <b>tostring),</b> <b>gsub(regex;</b> <b>tostring;</b> <b>flags)</b>
       <b>gsub</b> is like <b>sub</b> but all the non-overlapping occurrences of the regex are  replaced  by  <b>tostring</b>,  after
       interpolation.  If  the second argument is a stream of jq strings, then <b>gsub</b> will produce a corresponding
       stream of JSON strings.

           jq ´gsub("(?&lt;x&gt;.)[^a]*"; "+\(.x)-")´
              "Abcabc"
           =&gt; "+A-+a-"

           jq ´[gsub("p"; "a", "b")]´
              "p"
           =&gt; ["a","b"]

</pre><h4><b>ADVANCED</b> <b>FEATURES</b></h4><pre>
       Variables are an absolute necessity in most programming languages, but they´re relegated to an  "advanced
       feature" in jq.

       In most languages, variables are the only means of passing around data. If you calculate a value, and you
       want  to use it more than once, you´ll need to store it in a variable. To pass a value to another part of
       the program, you´ll need that part of the program to define a variable (as a function  parameter,  object
       member, or whatever) in which to place the data.

       It  is  also  possible  to  define  functions  in  jq, although this is is a feature whose biggest use is
       defining jq´s standard library (many jq functions such as <b>map</b> and <b>select</b> are in fact written in jq).

       jq has reduction operators, which are very powerful but a  bit  tricky.  Again,  these  are  mostly  used
       internally, to define some useful bits of jq´s standard library.

       It  may not be obvious at first, but jq is all about generators (yes, as often found in other languages).
       Some utilities are provided to help deal with generators.

       Some minimal I/O support (besides reading JSON from standard input, and writing JSON to standard  output)
       is available.

       Finally, there is a module/library system.

   <b>Variable</b> <b>/</b> <b>Symbolic</b> <b>Binding</b> <b>Operator:</b> <b>...</b> <b>as</b> <b>$identifier</b> <b>|</b> <b>...</b>
       In  jq, all filters have an input and an output, so manual plumbing is not necessary to pass a value from
       one part of a program to the next. Many expressions, for instance <b>a</b> <b>+</b> <b>b</b>, pass their input to two distinct
       subexpressions (here <b>a</b> and <b>b</b> are both passed the same input), so variables aren´t  usually  necessary  in
       order to use a value twice.

       For  instance,  calculating  the  average  value  of an array of numbers requires a few variables in most
       languages - at least one to hold the array, perhaps one for each element or for a loop  counter.  In  jq,
       it´s  simply  <b>add</b>  <b>/</b>  <b>length</b> - the <b>add</b> expression is given the array and produces its sum, and the <b>length</b>
       expression is given the array and produces its length.

       So, there´s generally a cleaner way to  solve  most  problems  in  jq  than  defining  variables.  Still,
       sometimes  they do make things easier, so jq lets you define variables using <b>expression</b> <b>as</b> <b>$variable</b>. All
       variable names start with <b>$</b>. Here´s a slightly uglier version of the array-averaging example:

           length as $array_length | add / $array_length

       We´ll need a more complicated problem to find a situation where using variables actually makes our  lives
       easier.

       Suppose  we  have  an  array of blog posts, with "author" and "title" fields, and another object which is
       used to map author usernames to real names. Our input looks like:

           {"posts": [{"title": "First post", "author": "anon"},
                      {"title": "A well-written article", "author": "person1"}],
            "realnames": {"anon": "Anonymous Coward",
                          "person1": "Person McPherson"}}

       We want to produce the posts with the author field containing a real name, as in:

           {"title": "First post", "author": "Anonymous Coward"}
           {"title": "A well-written article", "author": "Person McPherson"}

       We use a variable, $names, to store the realnames object, so that we can refer to it later  when  looking
       up author usernames:

           .realnames as $names | .posts[] | {title, author: $names[.author]}

       The expression <b>exp</b> <b>as</b> <b>$x</b> <b>|</b> <b>...</b> means: for each value of expression <b>exp</b>, run the rest of the pipeline with
       the  entire  original  input,  and with <b>$x</b> set to that value. Thus <b>as</b> functions as something of a foreach
       loop.

       Just as <b>{foo}</b> is a handy way of writing <b>{foo:</b> <b>.foo}</b>, so <b>{$foo}</b> is a handy way of writing <b>{foo:</b> <b>$foo}</b>.

       Multiple variables may be declared using a single <b>as</b> expression by providing a pattern that  matches  the
       structure of the input (this is known as "destructuring"):

           . as {realnames: $names, posts: [$first, $second]} | ...

       The  variable  declarations  in array patterns (e.g., <b>.</b> <b>as</b> <b>[$first,</b> <b>$second]</b>) bind to the elements of the
       array in from the element at index zero on up, in order. When there is no value at the index for an array
       pattern element, <b>null</b> is bound to that variable.

       Variables are scoped over the rest of the expression that defines them, so

           .realnames as $names | (.posts[] | {title, author: $names[.author]})

       will work, but

           (.realnames as $names | .posts[]) | {title, author: $names[.author]}

       won´t.

       For programming language theorists, it´s more accurate to say  that  jq  variables  are  lexically-scoped
       bindings. In particular there´s no way to change the value of a binding; one can only setup a new binding
       with the same name, but which will not be visible where the old one was.

           jq ´.bar as $x | .foo | . + $x´
              {"foo":10, "bar":200}
           =&gt; 210

           jq ´. as $i|[(.*2|. as $i| $i), $i]´
              5
           =&gt; [10,5]

           jq ´. as [$a, $b, {c: $c}] | $a + $b + $c´
              [2, 3, {"c": 4, "d": 5}]
           =&gt; 9

           jq ´.[] as [$a, $b] | {a: $a, b: $b}´
              [[0], [0, 1], [2, 1, 0]]
           =&gt; {"a":0,"b":null}, {"a":0,"b":1}, {"a":2,"b":1}

   <b>Destructuring</b> <b>Alternative</b> <b>Operator:</b> <b>?//</b>
       The  destructuring  alternative operator provides a concise mechanism for destructuring an input that can
       take one of several forms.

       Suppose we have an API that returns a list of resources and events associated with them, and we  want  to
       get  the  user_id  and  timestamp  of  the  first  event for each resource. The API (having been clumsily
       converted from XML) will only wrap the events in an array if the resource has multiple events:

           {"resources": [{"id": 1, "kind": "widget", "events": {"action": "create", "user_id": 1, "ts": 13}},
                          {"id": 2, "kind": "widget", "events": [{"action": "create", "user_id": 1, "ts": 14}, {"action": "destroy", "user_id": 1, "ts": 15}]}]}

       We can use the destructuring alternative operator to handle this structural change simply:

           .resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$user_id, $ts}]} | {$user_id, $kind, $id, $ts}

       Or, if we aren´t sure if the input is an array of values or an object:

           .[] as [$id, $kind, $user_id, $ts] ?// {$id, $kind, $user_id, $ts} | ...

       Each alternative need not define all of the same variables, but all named variables will be available  to
       the subsequent expression. Variables not matched in the alternative that succeeded will be <b>null</b>:

           .resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$first_user_id, $first_ts}]} | {$user_id, $first_user_id, $kind, $id, $ts, $first_ts}

       Additionally, if the subsequent expression returns an error, the alternative operator will attempt to try
       the next binding. Errors that occur during the final alternative are passed through.

           [[3]] | .[] as [$a] ?// [$b] | if $a != null then error("err: \($a)") else {$a,$b} end

           jq ´.[] as {$a, $b, c: {$d, $e}} ?// {$a, $b, c: [{$d, $e}]} | {$a, $b, $d, $e}´
              [{"a": 1, "b": 2, "c": {"d": 3, "e": 4}}, {"a": 1, "b": 2, "c": [{"d": 3, "e": 4}]}]
           =&gt; {"a":1,"b":2,"d":3,"e":4}, {"a":1,"b":2,"d":3,"e":4}

           jq ´.[] as {$a, $b, c: {$d}} ?// {$a, $b, c: [{$e}]} | {$a, $b, $d, $e}´
              [{"a": 1, "b": 2, "c": {"d": 3, "e": 4}}, {"a": 1, "b": 2, "c": [{"d": 3, "e": 4}]}]
           =&gt; {"a":1,"b":2,"d":3,"e":null}, {"a":1,"b":2,"d":null,"e":4}

           jq ´.[] as [$a] ?// [$b] | if $a != null then error("err: \($a)") else {$a,$b} end´
              [[3]]
           =&gt; {"a":null,"b":3}

   <b>Defining</b> <b>Functions</b>
       You can give a filter a name using "def" syntax:

           def increment: . + 1;

       From  then on, <b>increment</b> is usable as a filter just like a builtin function (in fact, this is how many of
       the builtins are defined). A function may take arguments:

           def map(f): [.[] | f];

       Arguments are passed as <u>filters</u> (functions with no arguments), <u>not</u> as values. The same  argument  may  be
       referenced  multiple  times  with  different  inputs (here <b>f</b> is run for each element of the input array).
       Arguments to a function work more like  callbacks  than  like  value  arguments.  This  is  important  to
       understand. Consider:

           def foo(f): f|f;
           5|foo(.*2)

       The  result will be 20 because <b>f</b> is <b>.*2</b>, and during the first invocation of <b>f</b> <b>.</b> will be 5, and the second
       time it will be 10 (5 * 2), so the result will be 20. Function arguments are filters, and filters  expect
       an input when invoked.

       If you want the value-argument behaviour for defining simple functions, you can just use a variable:

           def addvalue(f): f as $f | map(. + $f);

       Or use the short-hand:

           def addvalue($f): ...;

       With  either  definition,  <b>addvalue(.foo)</b>  will add the current input´s <b>.foo</b> field to each element of the
       array. Do note that calling <b>addvalue(.[])</b> will cause the <b>map(.</b> <b>+</b> <b>$f)</b> part to be evaluated once per  value
       in the value of <b>.</b> at the call site.

       Multiple  definitions  using the same function name are allowed. Each re-definition replaces the previous
       one for the same number of function arguments, but only for references from functions (or  main  program)
       subsequent to the re-definition. See also the section below on scoping.

           jq ´def addvalue(f): . + [f]; map(addvalue(.[0]))´
              [[1,2],[10,20]]
           =&gt; [[1,2,1], [10,20,10]]

           jq ´def addvalue(f): f as $x | map(. + $x); addvalue(.[0])´
              [[1,2],[10,20]]
           =&gt; [[1,2,1,2], [10,20,1,2]]

   <b>Scoping</b>
       There  are  two  types  of  symbols  in jq: value bindings (a.k.a., "variables"), and functions. Both are
       scoped lexically, with expressions being able to refer only to symbols that have  been  defined  "to  the
       left" of them. The only exception to this rule is that functions can refer to themselves so as to be able
       to create recursive functions.

       For  example, in the following expression there is a binding which is visible "to the right" of it, <b>...</b> <b>|</b>
       <b>.*3</b> <b>as</b> <b>$times_three</b> <b>|</b> <b>[.</b> <b>+</b> <b>$times_three]</b> <b>|</b> <b>...</b>, but not "to the left". Consider this expression now,  <b>...</b>
       <b>|</b> <b>(.*3</b> <b>as</b> <b>$times_three</b> <b>|</b> <b>[.</b> <b>+</b> <b>$times_three])</b> <b>|</b> <b>...</b>: here the binding <b>$times_three</b> is <u>not</u> visible past the
       closing parenthesis.

   <b>isempty(exp)</b>
       Returns true if <b>exp</b> produces no outputs, false otherwise.

           jq ´isempty(empty)´
              null
           =&gt; true

           jq ´isempty(.[])´
              []
           =&gt; true

           jq ´isempty(.[])´
              [1,2,3]
           =&gt; false

   <b>limit(n;</b> <b>exp)</b>
       The <b>limit</b> function extracts up to <b>n</b> outputs from <b>exp</b>.

           jq ´[limit(3;.[])]´
              [0,1,2,3,4,5,6,7,8,9]
           =&gt; [0,1,2]

   <b>first(expr),</b> <b>last(expr),</b> <b>nth(n;</b> <b>expr)</b>
       The <b>first(expr)</b> and <b>last(expr)</b> functions extract the first and last values from <b>expr</b>, respectively.

       The  <b>nth(n;</b>  <b>expr)</b> function extracts the nth value output by <b>expr</b>. Note that <b>nth(n;</b> <b>expr)</b> doesn´t support
       negative values of <b>n</b>.

           jq ´[first(range(.)), last(range(.)), nth(./2; range(.))]´
              10
           =&gt; [0,9,5]

   <b>first,</b> <b>last,</b> <b>nth(n)</b>
       The <b>first</b> and <b>last</b> functions extract the first and last values from any array at <b>.</b>.

       The <b>nth(n)</b> function extracts the nth value of any array at <b>.</b>.

           jq ´[range(.)]|[first, last, <a href="../man5/nth.5.html">nth</a>(5)]´
              10
           =&gt; [0,9,5]

   <b>reduce</b>
       The <b>reduce</b> syntax allows you to combine all of the results of an expression by accumulating them  into  a
       single  answer.  The form is <b>reduce</b> <b>EXP</b> <b>as</b> <b>$var</b> <b>(INIT;</b> <b>UPDATE)</b>. As an example, we´ll pass <b>[1,2,3]</b> to this
       expression:

           reduce .[] as $item (0; . + $item)

       For each result that <b>.[]</b> produces, <b>.</b> <b>+</b> <b>$item</b> is run to accumulate a running total, starting from 0 as the
       input value. In this example, <b>.[]</b> produces the results <b>1</b>, <b>2</b>, and <b>3</b>, so the effect is similar  to  running
       something like this:

           0 | 1 as $item | . + $item |
               2 as $item | . + $item |
               3 as $item | . + $item

           jq ´reduce .[] as $item (0; . + $item)´
              [1,2,3,4,5]
           =&gt; 15

           jq ´reduce .[] as [$i,$j] (0; . + $i * $j)´
              [[1,2],[3,4],[5,6]]
           =&gt; 44

           jq ´reduce .[] as {$x,$y} (null; .x += $x | .y += [$y])´
              [{"x":"a","y":1},{"x":"b","y":2},{"x":"c","y":3}]
           =&gt; {"x":"abc","y":[1,2,3]}

   <b>foreach</b>
       The  <b>foreach</b>  syntax  is  similar to <b>reduce</b>, but intended to allow the construction of <b>limit</b> and reducers
       that produce intermediate results.

       The form is <b>foreach</b> <b>EXP</b> <b>as</b> <b>$var</b> <b>(INIT;</b> <b>UPDATE;</b> <b>EXTRACT)</b>. As  an  example,  we´ll  pass  <b>[1,2,3]</b>  to  this
       expression:

           foreach .[] as $item (0; . + $item; [$item, . * 2])

       Like the <b>reduce</b> syntax, <b>.</b> <b>+</b> <b>$item</b> is run for each result that <b>.[]</b> produces, but <b>[$item,</b> <b>.</b> <b>*</b> <b>2]</b> is run for
       each  intermediate  values.  In  this example, since the intermediate values are <b>1</b>, <b>3</b>, and <b>6</b>, the <b>foreach</b>
       expression produces <b>[1,2]</b>, <b>[2,6]</b>, and <b>[3,12]</b>. So the effect is similar to running something like this:

           0 | 1 as $item | . + $item | [$item, . * 2],
               2 as $item | . + $item | [$item, . * 2],
               3 as $item | . + $item | [$item, . * 2]

       When <b>EXTRACT</b> is omitted, the identity filter is used. That is, it outputs the intermediate values as they
       are.

           jq ´foreach .[] as $item (0; . + $item)´
              [1,2,3,4,5]
           =&gt; 1, 3, 6, 10, 15

           jq ´foreach .[] as $item (0; . + $item; [$item, . * 2])´
              [1,2,3,4,5]
           =&gt; [1,2], [2,6], [3,12], [4,20], [5,30]

           jq ´foreach .[] as $item (0; . + 1; {index: ., $item})´
              ["foo", "bar", "baz"]
           =&gt; {"index":1,"item":"foo"}, {"index":2,"item":"bar"}, {"index":3,"item":"baz"}

   <b>Recursion</b>
       As described above, <b>recurse</b> uses recursion, and any jq function can be recursive. The  <b>while</b>  builtin  is
       also implemented in terms of recursion.

       Tail  calls  are  optimized  whenever  the  expression to the left of the recursive call outputs its last
       value. In practice this means that the expression to the left of the recursive call  should  not  produce
       more than one output for each input.

       For example:

           def recurse(f): def r: ., (f | select(. != null) | r); r;

           def while(cond; update):
             def _while:
               if cond then ., (update | _while) else empty end;
             _while;

           def repeat(exp):
             def _repeat:
               exp, _repeat;
             _repeat;

   <b>Generators</b> <b>and</b> <b>iterators</b>
       Some  jq  operators  and  functions  are  actually generators in that they can produce zero, one, or more
       values for each input, just as one might expect in other programming languages that have generators.  For
       example,  <b>.[]</b>  generates  all the values in its input (which must be an array or an object), <b>range(0;</b> <b>10)</b>
       generates the integers between 0 and 10, and so on.

       Even the comma operator is a generator, generating first the values generated by the  expression  to  the
       left of the comma, then the values generated by the expression on the right of the comma.

       The  <b>empty</b>  builtin  is  the  generator  that  produces zero outputs. The <b>empty</b> builtin backtracks to the
       preceding generator expression.

       All jq functions can be generators just by using builtin generators. It is also possible to construct new
       generators using only recursion and the comma operator. If recursive calls are "in  tail  position"  then
       the  generator  will be efficient. In the example below the recursive call by <b>_range</b> to itself is in tail
       position. The example shows off three  advanced  topics:  tail  recursion,  generator  construction,  and
       sub-functions.

           jq ´def range(init; upto; by): def _range: if (by &gt; 0 and . &lt; upto) or (by &lt; 0 and . &gt; upto) then ., ((.+by)|_range) else . end; if by == 0 then init else init|_range end | select((by &gt; 0 and . &lt; upto) or (by &lt; 0 and . &gt; upto)); range(0; 10; 3)´
              null
           =&gt; 0, 3, 6, 9

           jq ´def while(cond; update): def _while: if cond then ., (update | _while) else empty end; _while; [while(.&lt;100; .*2)]´
              1
           =&gt; [1,2,4,8,16,32,64]

</pre><h4><b>MATH</b></h4><pre>
       jq currently only has IEEE754 double-precision (64-bit) floating point number support.

       Besides  simple  arithmetic operators such as <b>+</b>, jq also has most standard math functions from the C math
       library. C math functions that take a single input argument (e.g., <b>sin()</b>) are available as  zero-argument
       jq  functions. C math functions that take two input arguments (e.g., <b>pow()</b>) are available as two-argument
       jq functions that ignore  <b>.</b>.  C  math  functions  that  take  three  input  arguments  are  available  as
       three-argument jq functions that ignore <b>.</b>.

       Availability  of  standard math functions depends on the availability of the corresponding math functions
       in your operating system and C math library. Unavailable math functions will be defined but will raise an
       error.

       One-input C math functions: <b>acos</b> <b>acosh</b> <b>asin</b> <b>asinh</b> <b>atan</b> <b>atanh</b> <b>cbrt</b> <b>ceil</b> <b>cos</b> <b>cosh</b> <b>erf</b> <b>erfc</b> <b>exp</b>  <b>exp10</b>  <b>exp2</b>
       <b>expm1</b>  <b>fabs</b> <b>floor</b> <b>gamma</b> <b>j0</b> <b>j1</b> <b>lgamma</b> <b>log</b> <b>log10</b> <b>log1p</b> <b>log2</b> <b>logb</b> <b>nearbyint</b> <b>pow10</b> <b>rint</b> <b>round</b> <b>significand</b> <b>sin</b>
       <b>sinh</b> <b>sqrt</b> <b>tan</b> <b>tanh</b> <b>tgamma</b> <b>trunc</b> <b>y0</b> <b>y1</b>.

       Two-input C math functions: <b>atan2</b> <b>copysign</b> <b>drem</b> <b>fdim</b> <b>fmax</b> <b>fmin</b> <b>fmod</b> <b>frexp</b> <b>hypot</b> <b>jn</b> <b>ldexp</b>  <b>modf</b>  <b>nextafter</b>
       <b>nexttoward</b> <b>pow</b> <b>remainder</b> <b>scalb</b> <b>scalbln</b> <b>yn</b>.

       Three-input C math functions: <b>fma</b>.

       See your system´s manual for more information on each of these.

</pre><h4><b>I/O</b></h4><pre>
       At this time jq has minimal support for I/O, mostly in the form of control over when inputs are read. Two
       builtins functions are provided for this, <b>input</b> and <b>inputs</b>, that read from the same sources (e.g., <b>stdin</b>,
       files  named  on the command-line) as jq itself. These two builtins, and jq´s own reading actions, can be
       interleaved with each other. They are commonly used in combination with  the  null  input  option  <b>-n</b>  to
       prevent one input from being read implicitly.

       Two  builtins  provide minimal output capabilities, <b>debug</b>, and <b>stderr</b>. (Recall that a jq program´s output
       values are always output as JSON texts on  <b>stdout</b>.)  The  <b>debug</b>  builtin  can  have  application-specific
       behavior,  such  as  for  executables  that  use the libjq C API but aren´t the jq executable itself. The
       <b>stderr</b> builtin outputs its input in raw mode to stder with no additional decoration, not even a newline.

       Most jq builtins are referentially transparent, and yield constant  and  repeatable  value  streams  when
       applied to constant inputs. This is not true of I/O builtins.

   <b>input</b>
       Outputs one new input.

       Note  that  when  using  <b>input</b> it is generally be necessary to invoke jq with the <b>-n</b> command-line option,
       otherwise the first entity will be lost.

           echo 1 2 3 4 | jq ´[., input]´ # [1,2] [3,4]

   <b>inputs</b>
       Outputs all remaining inputs, one by one.

       This is primarily useful for reductions over a program´s inputs.  Note  that  when  using  <b>inputs</b>  it  is
       generally  necessary  to  invoke  jq  with the <b>-n</b> command-line option, otherwise the first entity will be
       lost.

           echo 1 2 3 | jq -n ´reduce inputs as $i (0; . + $i)´ # 6

   <b>debug,</b> <b><a href="../manmsgs/debug.msgs.html">debug</a>(msgs)</b>
       These two filters are like <b>.</b> but have as a side-effect the production of one or more messages on stderr.

       The message produced by the <b>debug</b> filter has the form

           ["DEBUG:",&lt;input-value&gt;]

       where <b>&lt;input-value&gt;</b> is a compact rendition of the input value. This format may change in the future.

       The <b><a href="../manmsgs/debug.msgs.html">debug</a>(msgs)</b> filter is defined as <b>(msgs</b> <b>|</b> <b>debug</b> <b>|</b> <b>empty),</b> <b>.</b> thus allowing  great  flexibility  in  the
       content of the message, while also allowing multi-line debugging statements to be created.

       For example, the expression:

           1 as $x | 2 | debug("Entering function foo with $x == \($x)", .) | (.+1)

       would produce the value 3 but with the following two lines being written to stderr:

           ["DEBUG:","Entering function foo with $x == 1"]
           ["DEBUG:",2]

   <b>stderr</b>
       Prints its input in raw and compact mode to stderr with no additional decoration, not even a newline.

   <b>input_filename</b>
       Returns  the  name of the file whose input is currently being filtered. Note that this will not work well
       unless jq is running in a UTF-8 locale.

   <b>input_line_number</b>
       Returns the line number of the input currently being filtered.

</pre><h4><b>STREAMING</b></h4><pre>
       With the <b>--stream</b> option jq can parse input texts in a streaming fashion, allowing jq programs  to  start
       processing  large JSON texts immediately rather than after the parse completes. If you have a single JSON
       text that is 1GB in size, streaming it will allow you to process it much more quickly.

       However, streaming isn´t easy to deal with as the jq program will have <b>[&lt;path&gt;,</b> <b>&lt;leaf-value&gt;]</b> (and a  few
       other forms) as inputs.

       Several builtins are provided to make handling streams easier.

       The examples below use the streamed form of <b>[0,[1]]</b>, which is <b>[[0],0],[[1,0],1],[[1,0]],[[1]]</b>.

       Streaming  forms  include  <b>[&lt;path&gt;,</b>  <b>&lt;leaf-value&gt;]</b>  (to  indicate any scalar value, empty array, or empty
       object), and <b>[&lt;path&gt;]</b> (to indicate the end of an array  or  object).  Future  versions  of  jq  run  with
       <b>--stream</b>  and  <b>--seq</b>  may  output  additional forms such as <b>["error</b> <b>message"]</b> when an input text fails to
       parse.

   <b>truncate_stream(stream_expression)</b>
       Consumes a number as input and truncates the corresponding number of path elements from the left  of  the
       outputs of the given streaming expression.

           jq ´truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]])´
              1
           =&gt; [[0],2], [[0]]

   <b>fromstream(stream_expression)</b>
       Outputs values corresponding to the stream expression´s outputs.

           jq ´fromstream(1|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]]))´
              null
           =&gt; [2]

   <b>tostream</b>
       The <b>tostream</b> builtin outputs the streamed form of its input.

           jq ´. as $dot|fromstream($dot|tostream)|.==$dot´
              [0,[1,{"a":1},{"b":2}]]
           =&gt; true

</pre><h4><b>ASSIGNMENT</b></h4><pre>
       Assignment  works  a  little differently in jq than in most programming languages. jq doesn´t distinguish
       between references to and copies of something - two objects or arrays are  either  equal  or  not  equal,
       without any further notion of being "the same object" or "not the same object".

       If  an object has two fields which are arrays, <b>.foo</b> and <b>.bar</b>, and you append something to <b>.foo</b>, then <b>.bar</b>
       will not get bigger, even if you´ve previously set  <b>.bar</b>  <b>=</b>  <b>.foo</b>.  If  you´re  used  to  programming  in
       languages  like  Python,  Java,  Ruby, JavaScript, etc. then you can think of it as though jq does a full
       deep copy of every object before it does the assignment (for performance it doesn´t actually do that, but
       that´s the general idea).

       This means that it´s impossible to build circular values in jq (such as an array whose first  element  is
       itself). This is quite intentional, and ensures that anything a jq program can produce can be represented
       in JSON.

       All the assignment operators in jq have path expressions on the left-hand side (LHS). The right-hand side
       (RHS) provides values to set to the paths named by the LHS path expressions.

       Values  in  jq  are  always  immutable. Internally, assignment works by using a reduction to compute new,
       replacement values for <b>.</b> that have had all the desired assignments applied  to  <b>.</b>,  then  outputting  the
       modified  value. This might be made clear by this example: <b>{a:{b:{c:1}}}</b> <b>|</b> <b>(.a.b|=3),</b> <b>.</b>. This will output
       <b>{"a":{"b":3}}</b> and <b>{"a":{"b":{"c":1}}}</b> because the last sub-expression, <b>.</b>, sees the  original  value,  not
       the modified value.

       Most users will want to use modification assignment operators, such as <b>|=</b> or <b>+=</b>, rather than <b>=</b>.

       Note  that  the  LHS  of  assignment  operators  refers  to a value in <b>.</b>. Thus <b>$var.foo</b> <b>=</b> <b>1</b> won´t work as
       expected (<b>$var.foo</b> is not a valid or useful path expression in <b>.</b>); use <b>$var</b> <b>|</b> <b>.foo</b> <b>=</b> <b>1</b> instead.

       Note too that <b>.a,.b=0</b> does not set <b>.a</b> and <b>.b</b>, but <b>(.a,.b)=0</b> sets both.

   <b>Update-assignment:</b> <b>|=</b>
       This is the "update" operator <b>|=</b>. It takes a filter on the right-hand side and works out  the  new  value
       for  the  property of <b>.</b> being assigned to by running the old value through this expression. For instance,
       <b>(.foo,</b> <b>.bar)</b> <b>|=</b> <b>.+1</b> will build an object with the <b>foo</b> field set to the input´s <b>foo</b> plus 1,  and  the  <b>bar</b>
       field set to the input´s <b>bar</b> plus 1.

       The left-hand side can be any general path expression; see <b>path()</b>.

       Note  that the left-hand side of <b>|=</b> refers to a value in <b>.</b>. Thus <b>$var.foo</b> <b>|=</b> <b>.</b> <b>+</b> <b>1</b> won´t work as expected
       (<b>$var.foo</b> is not a valid or useful path expression in <b>.</b>); use <b>$var</b> <b>|</b> <b>.foo</b> <b>|=</b> <b>.</b> <b>+</b> <b>1</b> instead.

       If the right-hand side outputs no values (i.e., <b>empty</b>), then the left-hand side path will be deleted,  as
       with <b>del(path)</b>.

       If  the  right-hand side outputs multiple values, only the first one will be used (COMPATIBILITY NOTE: in
       jq 1.5 and earlier releases, it used to be that only the last one was used).

           jq ´(..|select(type=="boolean")) |= if . then 1 else 0 end´
              [true,false,[5,true,[true,[false]],false]]
           =&gt; [1,0,[5,1,[1,[0]],0]]

   <b>Arithmetic</b> <b>update-assignment:</b> <b>+=,</b> <b>-=,</b> <b>*=,</b> <b>/=,</b> <b>%=,</b> <b>//=</b>
       jq has a few operators of the form <b>a</b> <b>op=</b> <b>b</b>, which are all equivalent to <b>a</b> <b>|=</b> <b>.</b> <b>op</b> <b>b</b>. So, <b>+=</b> <b>1</b> can be used
       to increment values, being the same as <b>|=</b> <b>.</b> <b>+</b> <b>1</b>.

           jq ´.foo += 1´
              {"foo": 42}
           =&gt; {"foo": 43}

   <b>Plain</b> <b>assignment:</b> <b>=</b>
       This is the plain assignment operator. Unlike the others, the input to the right-hand side (RHS)  is  the
       same  as  the  input  to  the  left-hand side (LHS) rather than the value at the LHS path, and all values
       output by the RHS will be used (as shown below).

       If the RHS of <b>=</b> produces multiple values, then for each such value jq will set the paths on the left-hand
       side to the value and then it will output the  modified  <b>.</b>.  For  example,  <b>(.a,.b)</b>  <b>=</b>  <b><a href="../man2/range.2.html">range</a>(2)</b>  outputs
       <b>{"a":0,"b":0}</b>, then <b>{"a":1,"b":1}</b>. The "update" assignment forms (see above) do not do this.

       This example should show the difference between <b>=</b> and <b>|=</b>:

       Provide input <b>{"a":</b> <b>{"b":</b> <b>10},</b> <b>"b":</b> <b>20}</b> to the programs

           .a = .b

       and

           .a |= .b

       The  former  will  set the <b>a</b> field of the input to the <b>b</b> field of the input, and produce the output <b>{"a":</b>
       <b>20,</b> <b>"b":</b> <b>20}</b>. The latter will set the <b>a</b> field of the input to the <b>a</b> field´s <b>b</b> field, producing <b>{"a":</b>  <b>10,</b>
       <b>"b":</b> <b>20}</b>.

           jq ´.a = .b´
              {"a": {"b": 10}, "b": 20}
           =&gt; {"a":20,"b":20}

           jq ´.a |= .b´
              {"a": {"b": 10}, "b": 20}
           =&gt; {"a":10,"b":20}

           jq ´(.a, .b) = <a href="../man3/range.3.html">range</a>(3)´
              null
           =&gt; {"a":0,"b":0}, {"a":1,"b":1}, {"a":2,"b":2}

           jq ´(.a, .b) |= <a href="../man3/range.3.html">range</a>(3)´
              null
           =&gt; {"a":0,"b":0}

   <b>Complex</b> <b>assignments</b>
       Lots  more  things  are  allowed  on  the left-hand side of a jq assignment than in most languages. We´ve
       already seen simple field accesses on the left hand side, and it´s no surprise that array  accesses  work
       just as well:

           .posts[0].title = "JQ Manual"

       What may come as a surprise is that the expression on the left may produce multiple results, referring to
       different points in the input document:

           .posts[].comments |= . + ["this is great"]

       That  example appends the string "this is great" to the "comments" array of each post in the input (where
       the input is an object with a field "posts" which is an array of posts).

       When jq encounters an assignment like ´a = b´, it records the "path" taken to select a part of the  input
       document  while  executing  a.  This  path  is  then used to find which part of the input to change while
       executing the assignment. Any filter may be used on the left-hand side of an equals - whichever paths  it
       selects from the input will be where the assignment is performed.

       This  is  a  very  powerful  operation.  Suppose we wanted to add a comment to blog posts, using the same
       "blog" input above. This time, we only want to comment on the posts written by "stedolan".  We  can  find
       those posts using the "select" function described earlier:

           .posts[] | select(.author == "stedolan")

       The paths provided by this operation point to each of the posts that "stedolan" wrote, and we can comment
       on each of them in the same way that we did before:

           (.posts[] | select(.author == "stedolan") | .comments) |=
               . + ["terrible."]

</pre><h4><b>MODULES</b></h4><pre>
       jq has a library/module system. Modules are files whose names end in <b>.jq</b>.

       Modules  imported  by  a  program  are  searched for in a default search path (see below). The <b>import</b> and
       <b>include</b> directives allow the importer to alter this path.

       Paths in the a search path are subject to various substitutions.

       For paths starting with <b>~/</b>, the user´s home directory is substituted for <b>~</b>.

       For paths starting with <b>$ORIGIN/</b>, the directory where the jq executable is  located  is  substituted  for
       <b>$ORIGIN</b>.

       For  paths starting with <b>./</b> or paths that are <b>.</b>, the path of the including file is substituted for <b>.</b>. For
       top-level programs given on the command-line, the current directory is used.

       Import directives can optionally specify a search path to which the default is appended.

       The default search path is  the  search  path  given  to  the  <b>-L</b>  command-line  option,  else  <b>["<a href="file:~/.jq">~/.jq</a>",</b>
       <b>"$ORIGIN/../lib/jq",</b> <b>"$ORIGIN/..<a href="file:/lib">/lib</a>"]</b>.

       Null and empty string path elements terminate search path processing.

       A  dependency  with  relative  path <b>foo/bar</b> would be searched for in <b>foo/bar.jq</b> and <b>foo/bar/bar.jq</b> in the
       given search path. This is intended to allow modules to be placed in a directory along with, for example,
       version control files, README files, and so on, but also to allow for single-file modules.

       Consecutive components with the same name are not allowed to avoid ambiguities (e.g., <b>foo/foo</b>).

       For example, with <b>-L$HOME/.jq</b> a module <b>foo</b> can be found in <b>$HOME/.jq/foo.jq</b> and <b>$HOME/.jq/foo/foo.jq</b>.

       If <b>$HOME/.jq</b> is a file, it is sourced into the main program.

   <b>import</b> <b>RelativePathString</b> <b>as</b> <b>NAME</b> <b>[&lt;metadata&gt;];</b>
       Imports a module found at the given path relative to a directory in a search path. A <b>.jq</b> suffix  will  be
       added to the relative path string. The module´s symbols are prefixed with <b>NAME::</b>.

       The  optional  metadata  must be a constant jq expression. It should be an object with keys like <b>homepage</b>
       and so on. At this time jq only uses the <b>search</b> key/value of the metadata.  The  metadata  is  also  made
       available to users via the <b>modulemeta</b> builtin.

       The  <b>search</b> key in the metadata, if present, should have a string or array value (array of strings); this
       is the search path to be prefixed to the top-level search path.

   <b>include</b> <b>RelativePathString</b> <b>[&lt;metadata&gt;];</b>
       Imports a module found at the given path relative to a directory in a search path as if it were  included
       in  place. A <b>.jq</b> suffix will be added to the relative path string. The module´s symbols are imported into
       the caller´s namespace as if the module´s content had been included directly.

       The optional metadata must be a constant jq expression. It should be an object with  keys  like  <b>homepage</b>
       and  so  on.  At  this  time jq only uses the <b>search</b> key/value of the metadata. The metadata is also made
       available to users via the <b>modulemeta</b> builtin.

   <b>import</b> <b>RelativePathString</b> <b>as</b> <b>$NAME</b> <b>[&lt;metadata&gt;];</b>
       Imports a JSON file found at the given path relative to a directory in a search path. A <b>.json</b> suffix will
       be added to the relative path string. The file´s data will be available as <b>$NAME::NAME</b>.

       The optional metadata must be a constant jq expression. It should be an object with  keys  like  <b>homepage</b>
       and  so  on.  At  this  time jq only uses the <b>search</b> key/value of the metadata. The metadata is also made
       available to users via the <b>modulemeta</b> builtin.

       The <b>search</b> key in the metadata, if present, should have a string or array value (array of strings);  this
       is the search path to be prefixed to the top-level search path.

   <b>module</b> <b>&lt;metadata&gt;;</b>
       This  directive  is entirely optional. It´s not required for proper operation. It serves only the purpose
       of providing metadata that can be read with the <b>modulemeta</b> builtin.

       The metadata must be a constant jq expression. It should be an object with keys like  <b>homepage</b>.  At  this
       time jq doesn´t use this metadata, but it is made available to users via the <b>modulemeta</b> builtin.

   <b>modulemeta</b>
       Takes  a  module  name as input and outputs the module´s metadata as an object, with the module´s imports
       (including metadata) as an array value for the <b>deps</b> key and the module´s defined functions  as  an  array
       value for the <b>defs</b> key.

       Programs  can  use  this  to query a module´s metadata, which they could then use to, for example, search
       for, download, and install missing dependencies.

</pre><h4><b>COLORS</b></h4><pre>
       To configure alternative colors just set the <b>JQ_COLORS</b> environment variable to  colon-delimited  list  of
       partial terminal escape sequences like <b>"1;31"</b>, in this order:

       •   color for <b>null</b>

       •   color for <b>false</b>

       •   color for <b>true</b>

       •   color for numbers

       •   color for strings

       •   color for arrays

       •   color for objects

       •   color for object keys

       The default color scheme is the same as setting <b>JQ_COLORS="0;90:0;39:0;39:0;39:0;32:1;39:1;39:1;34"</b>.

       This  is  not a manual for VT100/ANSI escapes. However, each of these color specifications should consist
       of two numbers separated by a semi-colon, where the first number is one of these:

       •   1 (bright)

       •   2 (dim)

       •   4 (underscore)

       •   5 (blink)

       •   7 (reverse)

       •   8 (hidden)

       and the second is one of these:

       •   30 (black)

       •   31 (red)

       •   32 (green)

       •   33 (yellow)

       •   34 (blue)

       •   35 (magenta)

       •   36 (cyan)

       •   37 (white)

</pre><h4><b>BUGS</b></h4><pre>
       Presumably. Report them or discuss them at:

           https://github.com/jqlang/jq/issues

</pre><h4><b>AUTHOR</b></h4><pre>
       Stephen Dolan <b>&lt;<a href="mailto:mu@netsoc.tcd.ie">mu@netsoc.tcd.ie</a>&gt;</b>

                                                  December 2023                                            <u><a href="../man1/JQ.1.html">JQ</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>