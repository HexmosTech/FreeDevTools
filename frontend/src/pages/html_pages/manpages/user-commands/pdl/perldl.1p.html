<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>perldl - Simple shell for PDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/pdl">pdl_2.099-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       perldl - Simple shell for PDL

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Use PDL interactively:

         bash$ perldl
         pdl&gt; $x = <a href="../man10/sequence.10.html">sequence</a>(10) # or any other perl or PDL command

         bash$ pdl
         pdl&gt; print "Hello, world!\n";

         pdl&gt; with_time { print +($A-&gt;matmult($B))-&gt;info, "\n" } for 1..5;
         pdl&gt; gv $A, 'output.png' # uses GraphViz2 to show connected transforms etc
         pdl&gt; 1+1 # no output
         pdl&gt; do_print 1 # or put this in your .perldlrc - as of 2.099
         pdl&gt; 1+1; # no output, like MATLAB
         pdl&gt; 1+1
         2

       Run a script:

         bash$ cat &gt; pdlscript
         #!/usr/bin/pdl
         print "Hello, world!\n";
         ...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The program <b>perldl</b> is a simple shell (written in perl) for interactive use of PDL.  It consists of a
       command-line interface that supports immediate interpretation of perl commands and expressions.  Perl
       expressions, including PDL constructs, can be entered directly at the keyboard and are compiled and
       executed immediately.  The syntax is not exactly identical to Perl, in that under most circumstances
       ending a line causes immediate execution of the command entered so far (no trailing ';' is required).

       The synonym <b>pdl</b> is a compiled executable that is useful as a script interpreter using UNIX shebang ("#!")
       syntax.  This is useful for generating and re-executing command-journal files from <b>perldl</b>.

       The <b>perldl</b> shell runs an initial startup file ("<a href="file:~/.perldlrc">~/.perldlrc</a>") that can be used to pre-load perl modules
       or configure the global perl environment.  It features a path mechanism for autoloading perl subroutines.
       There is a command-history mechanism, and several other useful features such as command preprocessing,
       shortcuts for commonly used commands such as "print", and the ability to execute arbitrary code whenever
       a prompt is printed.

       Depending on your configuration settings, <b>perldl</b> can be set to honor or ignore the ^D (end-of-file)
       character when sent from a terminal, or to attempt to do the Right Thing when a block construct spanning
       multiple lines is encountered.

       <b>perldl</b> and <b>pdl</b> support several command-line options, which are discussed near the end of this document.

   <b>Reference</b> <b>manual</b> <b>&amp;</b> <b>online</b> <b>help</b>
       The PDL reference manual and online help are available from within <b>perldl</b>, using the <b>help</b> and <b>apropos</b>
       commands (which may also be abbreviated <b>?</b> and <b>??</b>.)   The <b>help</b> command alone prints a summary of help
       syntax, and <b>help</b> <b>&lt;module-name&gt;</b> will print POD documentation from the module you mention (POD is the Perl
       format for embedding documentation in your perl code; see perlpod for details).

       If you include POD documentation in your autoload subroutines (see <b>path</b> <b>mechanism</b> below), then both <b>help</b>
       and <b>apropos</b> will find it and be able to format and display it on demand.

   <b>History</b> <b>mechanism</b>
       If you have the perl modules ReadLines and ReadKeys installed, then <b>perldl</b> supports a history and line-
       editing mechanism using editing keys similar to "emacs". The last 500 commands are always stored in the
       file <u>.perldl_hist</u> in your home directory between sessions.  Set $PERLDL::HISTFILESIZE to change the
       number of lines saved.  The command "l [number]" shows you the last "number" commands you typed where
       "number" defaults to 20.

       e.g.:

          bash$ perldl
          ReadLines enabled
          pdl&gt; $x = rfits "foo.fits"
          BITPIX =  -32  size = 88504 pixels
          Reading  354016 bytes
          BSCALE =  &amp;&amp;  BZERO =

          pdl&gt; imag log($x+400)
          Displaying 299 x 296 image from 4.6939525604248 to 9.67116928100586 ...

   <b>Command</b> <b>execution</b>
       If you enter a simple command at the <b>perldl</b> command line, it is immediately executed in a Perl eval().
       The environment is almost identical to that within a perl script, with some important exceptions:

       •  $_ is not preserved across lines

          $_  is used to hold the command line for initial processing, so at the beginning of processing of each
          command line, $_ contains the command itself.  Use variables other than  $_  to  store  values  across
          lines.

       •  Scope is not preserved across lines

          Each command line is executed in a separate "eval" block within perl, so scoping commands such as "my"
          and "local" may not perform exactly as expected -- in particular, if you declare a variable with "my",
          it  is  local  to the particular command line on which you typed the "my" command, which means that it
          will evaporate before the next prompt is printed.  (You can use "my" variables in a  multi-line  block
          or to isolate values within a single command line, of course).

       •  Execution is immediate

          Under  most  circumstances,  as soon as you end a line of input the line is parsed and executed.  This
          breaks Perl's normal dependence on semicolons  as  command  delimiters.   For  example,  the  two-line
          expression

            print "Hello ",
               "world";

          prints the phrase "Hello world" in Perl, but (under most circumstances) "Hello " in <b>perldl</b>.

       •  Multi-line execution

          In  multiline  mode  (which  is  enabled  by default, see <b>Shell</b> <b>variables</b>, below), <b>perldl</b> searches for
          searches for block-like constructs with curly braces, parentheses, quotes, and related delimiters.  If
          you leave such a construct open, <b>perldl</b> accepts more lines of input until you close the  construct  or
          explicitly end the multi-line expression with ^D.   Following the example above, the phrase

            { print "Hello ",
                 "world"; }

          will print "Hello world" from either Perl or (in multi-line mode) <b>perldl</b>.

          <b>Warning</b>:  The multi-line parsing uses Damian Conway's Text::Balanced module, which contains some flaws
          -- so it can be fooled by quote-like operators such as "q/.../", included  POD  documentation,  multi-
          line   "&lt;&lt;"  quotes,  and  some  particularly  bizarre-but-valid  "m/.../"  matches  and  "s/.../.../"
          substitutions.  In such cases, use ^D to close out the multi-line construct and force compilation-and-
          execution.

       If you want to preserve this behavior in a script (for example to replay  a  command  journal  file;  see
       below  on  how to create one), you can use <b>pdl</b> instead of <b>perl</b> as the interpreter in the script's initial
       shebang line.

   <b>Terminating</b> <b>"perldl"</b>
       A "perldl" session can be terminated with any of the commands "quit", "exit" or  the  shorthands  "x"  or
       "q".  If EOF handling is switched on (the default) you can also type ^D at the command prompt.

       If the command input is NOT a terminal (for example if you are running from a command journal file), then
       EOF will always terminate <b>perldl</b>.

   <b>Terminating</b> <b>commands</b> <b>(Ctrl-C</b> <b>handling)</b>
       Commands executed within "perldl" can be terminated prematurely using "Ctrl-C" (or whichever key sequence
       sends  an  INT  signal to the process on your terminal). Provided your PDL code does not ignore "sigint"s
       this should throw you back at the "perldl" command prompt:

         pdl&gt; $result = start_lengthy_computation()
          &lt;Ctrl-C&gt;
         Ctrl-C detected

         pdl&gt;

       As of 2.077, this requires Sys::SigAction to be installed (without that, and before 2.077, for Perl  &gt;5.8
       it didn't actually interrupt things).

   <b>Shortcuts</b> <b>and</b> <b>aliases</b>
       •   The shell aliases "p" to be a convenient short form of "print", e.g.

              pdl&gt; p ones 5,3

              [
               [1 1 1 1 1]
               [1 1 1 1 1]
               [1 1 1 1 1]
              ]

       •   "q" and "x" are short-hand for "quit".

       •   "l" lists the history buffer

             pdl&gt; l # list last 20 commands

             pdl&gt; l 40 # list last 40 commands

       •   "?" is an alias for help

             pdl&gt; ? vars    # show information about ndarrays in current namespace

       •   "??" is an alias for apropos

             pdl&gt; ?? PDL::Doc

       •   help,  apropos,  usage and sig: all words after these commands are used verbatim and not evaluated by
           perl. So you can write, e.g.,

             pdl&gt; help help

           instead of

             pdl&gt; help 'help'

       •   "with_time" runs the following code-block, and tells you how long it took, in milliseconds.  Requires
           Time::HiRes.

             pdl&gt; with_time { print +($A-&gt;matmult($B))-&gt;info, "\n" } for 1..5;

       •   "gv"  uses  "pdumpgraph"  in  PDL::Core  etc  to  visualise  the  given  ndarray,  with all connected
           transformations, etc, into the given file. Requires Graph and GraphViz2.

             pdl&gt; gv $A, 'output.png'

   <b>Command-line</b> <b>options</b>
       <b>perldl</b> and <b>pdl</b> support several command-line options to adjust the behavior of the session.  Most of  them
       are equivalent to commands that can be entered at the <b>pdl&gt;</b> prompt.  They are:

       -glut
           Load  OpenGL  when  starting  the shell (the perl OpenGL module, which is available from CPAN must be
           installed).  This enables readline event loop processing.  Don't use with -tk.

       -tk Load Tk when starting the shell (the perl Tk module, which is available from CPAN must be installed).
           This enables readline event loop processing.  Don't use with -glut.

       -f file
           Loads the file before processing any user input. Any errors during the  execution  of  the  file  are
           fatal.

       -w  Runs with warning messages (i.e. the normal perl "-w" warnings) turned-on.

       -M module
           Loads the module before processing any user input.  Compare corresponding "perl" switch.

       -m module
           Unloads the module before processing any user input.

       -I directory
           Adds directory to the include path. (i.e. the @INC array) Compare corresponding "perl" switch.

       -V  Prints  a summary of PDL config. This information should be included with any PDL bug report. Compare
           corresponding "perl" switch.

   <b>The</b> <b>startup</b> <b>file</b> <u><b><a href="file:~/.perldlrc">~/.perldlrc</a></b></u>
       If the file <u><a href="file:~/.perldlrc">~/.perldlrc</a></u> is found it is sourced at start-up to load default modules, set shell  variables,
       etc.  If  it  is NOT found the distribution file <u>PDL/default.perldlrc</u> is read instead. This loads various
       modules considered useful by default, and which ensure compatibility with v1.11. If you don't  like  this
       and  want  a  more streamlined set of your own favourite modules simple create your own <u><a href="file:~/.perldlrc">~/.perldlrc</a></u>.  You
       may wish to start from the existing <u>PDL/default.perldlrc</u> as a template since it will not be sourced  once
       you replace it with your own version.

       To  set even more local defaults the file  <u>local.perldlrc</u> (in the current directory) is sourced if found.
       This lets you load modules and define subroutines for the project in the current directory.

       The name is chosen specifically because it was found hidden files were NOT wanted in these circumstances.

       The startup file should normally include  "use  PDL::AutoLoader;",  as  many  of  the  nicer  interactive
       features won't work without it.

   <b>Shell</b> <b>variables</b>
       Shell variables: (<u>Note</u>: if you don't like the defaults change them in <u><a href="file:~/.perldlrc">~/.perldlrc</a></u>)

       •   $PERLDL::ESCAPE  - default value '#'

           Any  line  starting  with  this  character  is treated as a shell escape. The default value is chosen
           because it escapes the code from the standard perl interpreter.

       •   $PERLDL::HISTFILESIZE  - default value 500

           This is the number of lines of perldl shell command history to keep.

       •   $PERLDL::PAGER - default value "more"

           External program to filter the output of commands.  Using "more" prints output  one  screenful  at  a
           time.   On  Unix,  setting  <a href="../man1/page.1.html">page</a>(1)  and $PERLDL::PAGER to "tee -a outfile" will keep a record of the
           output generated by subsequent perldl commands (without paging).

       •   $PERLDL::PROMPT - default value 'pdl&gt; '

           Enough  said   But  can  also  be  set  to  a  subroutine  reference,  e.g.   $PERLDL::PROMPT  =  sub
           {join(':',(gmtime)[2,1,0]).'&gt; '} puts the current time into the prompt.

       •   $PERLDL::MULTI - default value 1

           If this is set to a true value, then perldl will parse multi-line perl blocks: your input will not be
           executed  until  you  finish  a  line  with  no  outstanding group operators (such as quotes, blocks,
           parenthesis, or brackets) still active.  Continuation lines have a different prompt  that  shows  you
           what delimiters are still active.

           Note  that  this  is  not (yet!) a complete perl parser.  In particular, Text::Balanced appears to be
           able to ignore quoting operatores like "q/ ... /" within a line, but not to be able  to  extend  them
           across lines.  Likewise, there is no support for the '&lt;&lt;' operator.

           Multiline conventional strings and {}, [], and () groupings are well supported.

       •   $PERLDL::NO_EOF - default value 0 / 1 on MSWin32

           Protects  against accidental use of "^D" from the terminal.  If this is set to a true value, then you
           can't accidentally exit perldl by typing "^D".  If  you  set  it  to  a  value  larger  than  1  (and
           PERLDL::MULTI  is  set), then you can't use "^D" to exit multiline commands either.  If you're piping
           commands in from a file or pipe, this variable has no effect.

       •   $HOME

           The user's home directory

       •   $PERLDL::TERM

           This is the Term::ReadLine object associated with the perldl shell. It can be used by routines called
           from perldl if your command is interactive.

       •   $PDL::toolongtoprint

           The maximal size pdls to print (defaults to 10,000 elements).  This is not just a  "perldl"  variable
           but it is something that is usually needed in an interactive debugging session.

   <b>Executing</b> <b>scripts</b> <b>from</b> <b>the</b> <b>"perldl"</b> <b>prompt</b>
       A useful idiom for developing perldl scripts or editing functions on-line is

         pdl&gt; # emacs script &amp;
           -- add perldl code to script and save the file

         pdl&gt; do 'script'

       -- substitute your favourite window-based editor for 'emacs' (you may also need to change the '&amp;' on non-
       Unix systems).

       Running  "do  'script'"  again updates any variables and function definitions from the current version of
       'script'.

   <b>Executing</b> <b>perldl</b> <b>scripts</b> <b>from</b> <b>the</b> <b>command</b> <b>line</b>
       PDL scripts are just perl scripts that happen to use PDL (and  possibly  PDL::NiceSlice).   But  for  the
       truly  lazy, perldl can be invokes as a script interpreter.  Because perldl is itself an interpreted perl
       script, most unices won't allow you to say "#!/usr/bin/perldl" at the top of your script.

       Instead, say "#!/usr/bin/pdl" and your script will be executed exactly as if you typed it,  line-by-line,
       into the perldl shell.

   <b>Command</b> <b>preprocessing</b>
       NOTE:  This  feature  is  used  by  default  by  PDL::NiceSlice.  See below for more about slicing at the
       "perldl" prompt

       In some cases, it is convenient to process commands before they are  sent  to  perl  for  execution.  For
       example,  this is the case where the shell is being presented to people unfamiliar with perl but who wish
       to take advantage of commands added locally (eg by automatically quoting arguments to certain commands).

       *<u>NOTE</u>*:  The  preprocessing  interface  has  changed  from  earlier   versions!   The   old   way   using
       $PERLDL::PREPROCESS will still work but is strongly deprecated and might go away in the future.

       You can enable preprocessing by registering a filter with the "preproc_add" function. "preproc_add" takes
       one  argument  which  is  the filter to be installed. A filter is a Perl code reference (usually set in a
       local configuration file) that will be called, with the current command string as argument, just prior to
       the string being executed by the shell. The modified string should be returned. Note that  you  can  make
       "perldl"  completely  unusable  if  you  fail  to  return the modified string; quitting is then your only
       option.

       Filters can be removed from the preprocessing pipeline by calling "preproc_del" with  the  filter  to  be
       removed  as  argument.   To find out if a filter is currently installed in the preprocessing pipeline use
       "preproc_registered":

         pdl&gt; preproc_add $myfilter unless preproc_registered $myfilter;

       Previous versions of "perldl" used the variable $PERLDL::PREPROCESS.  This will still work but should  be
       avoided. Please change your scripts to use the "preproc_add" etc functions.

       The following code would check for a call to function 'mysub' and bracket arguments with qw.

         $filter = preproc_add sub {
            my $str = shift;
            $str =~ s/^\s+//;  # Strip leading space
            if ($str =~ /^mysub/) {
               my ($command, $arguments) = split(/\s+/,$str, 2);
               $str = "$command qw( $arguments )"
               if (defined $arguments &amp;&amp; $arguments !~ /^qw/);
            };
            # Return the input string, modified as required
            return $str;
          };

       This would convert:

         pdl&gt; mysub arg1 arg2

       to

         pdl&gt; mysub qw( arg1 arg2 )

       which  Perl  will  understand  as a list.  Obviously, a little more effort is required to check for cases
       where the caller has supplied a normal list (and so does  not  require  automatic  quoting)  or  variable
       interpolation is required.

       You can remove this preprocessor using the "preproc_del" function which takes one argument (the filter to
       be removed, it must be the same coderef that was returned from a previous "preproc_add" call):

         pdl&gt; preproc_del $filter;

       An  example  of actual usage can be found in the "perldl" script. Look at the function "trans" to see how
       the niceslicing preprocessor is enabled/disabled.

   <b>"perldl"</b> <b>and</b> <b>PDL::NiceSlice</b>
       PDL::NiceSlice introduces a more convenient slicing syntax  for  ndarrays.  In  the  current  version  of
       "perldl" niceslicing is enabled by default (if the required CPAN modules are installed on your machine).

       At startup "perldl" will let you know if niceslicing is enabled. The startup message will contain info to
       this end, something like this:

          perlDL shell v1.XX
           PDL comes with ABSOLUTELY NO WARRANTY. For details, see the file
           'COPYING' in the PDL distribution. This is free software and you
           are welcome to redistribute it under certain conditions, see
           the same file for details.
          ReadLines, NiceSlice  enabled
          Reading /home/csoelle/.perldlrc...
          Type 'demo' for online demos
          Loaded PDL v2.XX

       When  you  get  such  a  message  that  indicates "NiceSlice" is enabled you can use the enhanced slicing
       syntax:

         pdl&gt; $x = sequence 10;
         pdl&gt; p $x(3:8:2)

       For details consult PDL::NiceSlice.

       PDL::NiceSlice installs a filter in the preprocessing pipeline (see above) to enable the enhanced slicing
       syntax. You can use a few commands in the "perldl" shell to switch this preprocessing on or off and  also
       explicitly check the substitutions that the NiceSlice filter makes.

       You can switch the PDL::NiceSlice filter on and off by typing

         pdl&gt; trans # switch niceslicing on

       and

         pdl&gt; notrans # switch niceslicing off

       respectively. The filter is on by default.

       To see how your commands are translated switch reporting on:

         pdl&gt; report 1;
         pdl&gt; p $x(3:8:2)
         processed p $x-&gt;slice([3,8,2])
         [3 5 7]

       Similarly, switch reporting off as needed

         pdl&gt; report 0;
         pdl&gt;  p $x(3:8:2)
         [3 5 7]

       Reporting is off by default.

   <b>Automatically</b> <b>execute</b> <b>your</b> <b>own</b> <b>hooks</b>
       The  variable  @PERLDL::AUTO  is  a simple list of perl code strings and/or code reference. It is used to
       define code to be executed automatically every time the user enters a new line.

       A simple example would be to print the time of each command:

         pdl&gt; push @PERLDL::AUTO,'print scalar(gmtime),"\n"'

         pdl&gt; print zeroes(3,3)
         Sun May  3 04:49:05 1998

         [
          [0 0 0]
          [0 0 0]
          [0 0 0]
         ]

         pdl&gt; print "Boo"
         Sun May  3 04:49:18 1998
         Boo
         pdl&gt;

       Or to make sure any changes in the file 'local.perldlrc' are always picked up :-

         pdl&gt; push @PERLDL::AUTO,"do 'local.perldlrc'"

       This code can of course be put *in* 'local.perldlrc', but be careful :-) [Hint: add "unless ($started++)"
       to above to ensure it only gets done once!]

       Another example application is as a hook for Autoloaders (e.g. PDL::AutoLoader) to  add  code  too  which
       allows  them  to  automatically  re-scan  their  files  for  changes. This is extremely convenient at the
       interactive command line. Since this hook is only in the shell it imposes no inefficiency on PDL scripts.

       Finally note this is a very powerful facility - which means it should be used with caution!

perl v5.40.0                                       2025-02-04                                         <u><a href="../man1p/PERLDL.1p.html">PERLDL</a></u>(1p)
</pre>
 </div>
</div></section>
</div>
</body>
</html>