<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mmake - generate a Java Makefile</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/mmake">mmake_2.3-10_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
        mmake - generate a Java Makefile

</pre><h4><b>SYNOPSIS</b></h4><pre>
        mmake [ -d ⎪ -v ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This program will generate a Makefile for Java source files. Use the <u>-d</u> option to accept all defaults.

       After  running mmake, you will obtain a Makefile in the directory from where you started the program. The
       Makefile will handle java files in the current directory and in any sub-directories.

       Use the generated Makefile with mmake as follows:

       To compile Java files just type <b>make</b>. It's also possible to run make with one of the  following  targets:
       <u>doc,</u>  <u>clean,</u> <u>help,</u> <u>jar,</u> <u>srcjar,</u> <u>bundle,</u> <u>install,</u> <u>uninstall,</u> <u>tags</u> <u>and</u> <u>depend</u> Where 'make doc' runs javadoc
       on the source files, it will only work for files in a package. The command  'make  clean'  removes  class
       files  and  other  temporary  files.  The command 'make jar' creates a jar file with all class files (and
       other files of your choice, see the JAR_OBJS variable in the Makefile). The command 'make srcjar' creates
       a jar file with all java files. The command 'make bundle' creates a Mac OS X Application Bundle with  all
       the  jar  file. The command 'make install' will install a jar file, app bundle, class files and any shell
       wrappers you have made. (A shell script  must  have  the  extension  .sh  to  be  installed).  Use  'make
       uninstall'  to remove installed files. The command 'make help', shows a help text with available targets.
       The command 'make tags' will generate a tag file for Emacs. And finally the command 'make depend' creates
       a dependency graph for the class files. (The dependency graph will be put in a file called  <u>makefile.dep</u>,
       which is included in the Makefile)

       You  don't  have  to run mmake each time you add a new java file to your project. You can add as many new
       java files as you like, the Makefile will find them. This is the case as long as  you  don't  add  a  new
       package.  In  that  case, you must either run mmake again or update the PACKAGE variable in the Makefile.
       This is because the Makefile uses this variable to find directories with java files.

       The program mmake is able to create a dependency graph for your java files. To  do  this,  it  needs  the
       <u>jikes</u>  compiler  from IBM. Get jikes from <b><a href="http://www.ibm.com/developerworks/oss/jikes/">http://www.ibm.com/developerworks/oss/jikes/</a></b>.You would probably
       be more content with jikes anyhow, since it is much faster than javac. To create a dependencies graph, do
       a <u>make</u> <u>clean</u> before running <u>make</u> <u>depend</u>.

</pre><h4><b>A</b> <b>NOTE</b> <b>ON</b> <b>INSTALLATION</b></h4><pre>
       The Makefile created with mmake will do a fair job installing the different  files  that  makes  up  your
       system. It uses the following Makefile variables when it conducts the install routine:

       •   PREFIX

       •   CLASS_DIR

       •   JAR_DIR

       •   BUNDLE_DIR

       •   DOC_DIR

       •   SCRIPT_DIR

       <b>PREFIX</b>

       This variable will be prepended to all other directory variables above. It is used for grouping the other
       directories  into one root directory. If you don't want that, you may simply set the variable to an empty
       string in the Makefile. If the variable is empty you could still use it on the command line when you  run
       make, for instance for a one-shoot installation like: <b>make</b> <b>PREFIX=/local/myproject/</b> <b>install</b>

       <b>CLASS_DIR</b>

       This  variable  denotes the top directory from where all class files will be installed. Its default value
       is <b>classes</b>, which I believe is a good value. <b>Note:</b> If you <u>don't</u> want to install any class files  (because
       you  are,  for  example, only going to use a jar file), set this variable to an empty string and no class
       files will be installed.

       Resource files will also be installed below this directory  if  such  files  are  present  in  a  package
       structure.  This  is  useful  if you are using e.g. ResourceBundles to Localize your application and have
       your property files in it's own directory in the package structure.

       <b>JAR_DIR</b>

       This variable tells the Makefile where to install the jar file. The default value is <b>lib</b>, which is also a
       good default value.

       <b>BUNDLE_DIR</b>

       This variable tells the Makefile where to install the app bundle. The default value is <b>lib</b>, which is also
       a good default value.

       <b>DOC_DIR</b>

       When you run javadoc, all the html  files  will  be  put  into  this  directory.  Its  default  value  is
       <b>doc/api-docs</b>. You should probably keep that name, but then again, you may change it as you like.

       <b>SCRIPT_DIR</b>

       The  Makefile uses this variable to install any shell wrapper-scripts that you have created. If you write
       an application, it is always nice  for  the  user  that  you  provide  a  wrapper  script  to  start  the
       application.  Its  default  value  is  <b>bin</b>.  (The  Makefile  will only install shell-scripts that has the
       extension .sh. The mmake script will tell the Makefile where to look for shell-scripts)

       <b>INSTALLATION</b> <b>SUMMARY</b>

       If you keep the default values you will get an installation tree that looks like this:

        `-- PREFIX
            ⎪-- bin
            ⎪-- classes
            ⎪   `-- package &lt;--- Example of a sub-directory
            ⎪       ⎪-- sub-package1
            ⎪       ⎪-- sub-package2
            ⎪       `-- sub-package3
            ⎪-- doc
            ⎪   `-- api-docs
            `-- lib

</pre><h4><b>USING</b> <b>THE</b> <b>C-PREPROCESSOR</b></h4><pre>
       This is a excellent tool for managing projects with several different versions. The idea behind using the
       C preprocessor with Java is to better manage different versions more easily. This is done  by  using  CPP
       conditional  statements  in  the source files. I would strongly advise you not to use CPP to redefine the
       Java language itself.

       To use the C preprocessor together with Java, you can change the name of the source files that  you  want
       to  preprocess -- from &lt;filename&gt;.java to &lt;filename&gt;.xjava. The Makefile has a rule to build .class files
       from .xjava files.

       It is <b>not</b> necessary to change every  file  from  .java  to  .xjava.  The  Makefile  will  work  well  and
       consistently  in an environment of both .java and .xjava files. (E.g. 'make clean' will only remove .java
       files that were created from a .xjava file. Other java files will, of course, <u>not</u> be removed.)

       You can now use cpp Conditionals in Your Java-code, for example, as follows:

           #ifdef JAVA1_1
              [code1]
           #else
              [code2]
           #endif

       The JAVA1_1 label in the above example is tested against the VERSION variable in the Makefile.  That  is,
       if  the  VERSION  variable  is JAVA1_1, then [code1] would be compiled and [code2] left out. Likewise, if
       VERSION is something else than JAVA1_1, then [code2] would be  compiled  and  [code1]  left  out  of  the
       resulting .class file.

</pre><h4><b>NOTES</b></h4><pre>
       mmake will give you <u>one</u> Makefile for managing your Java files.  Although it's easy to setup and use mmake
       in  a  recursive  makefile  context,  you  don't want to do that. To see why, read the excellent article:
       <b>Recursive</b> <b>Make</b> <b>Considered</b> <b>Harmful</b> at <u><a href="http://www.canb.auug.org.au/~millerp/rmch/recu-make-cons-harm.html">http://www.canb.auug.org.au/~millerp/rmch/recu-make-cons-harm.html</a></u>

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       mmake will need the following:

       •   Perl 5.x

       •   Gnu make

       •   Gnu xargs (recommended)

</pre><h4><b>AUTHOR</b></h4><pre>
       Jan-Henrik Haukeland &lt;<a href="mailto:hauk@tildeslash.com">hauk@tildeslash.com</a>&gt;

April 2. 2004                                  www.tildeslash.com                                       <u><a href="../man1/MMAKE.1.html">MMAKE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>