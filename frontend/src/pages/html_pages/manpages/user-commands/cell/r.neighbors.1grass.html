<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>r.neighbors   -  Makes  each  cell category value a function of the category values assigned to the cells</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>r.neighbors</b>   -  Makes  each  cell category value a function of the category values assigned to the cells
       around it, and stores new cell values in an output raster map layer.

</pre><h4><b>KEYWORDS</b></h4><pre>
       raster, algebra, statistics, aggregation, neighbor, focal statistics, filter, parallel

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>r.neighbors</b>
       <b>r.neighbors</b> <b>--help</b>
       <b>r.neighbors</b>    [-<b>ac</b>]     <b>input</b>=<u>name</u>      [<b>selection</b>=<u>name</u>]      <b>output</b>=<u>name</u>[,<u>name</u>,...]      [<b>size</b>=<u>integer</u>]
       [<b>method</b>=<u>string</u>[,<u>string</u>,...]]     [<b>weighting_function</b>=<u>string</u>]    [<b>weighting_factor</b>=<u>float</u>]    [<b>weight</b>=<u>name</u>]
       [<b>quantile</b>=<u>float</u>[,<u>float</u>,...]]   [<b>title</b>=<u>phrase</u>]   [<b>nprocs</b>=<u>integer</u>]   [<b>memory</b>=<u>memory</u> <u>in</u> <u>MB</u>]    [--<b>overwrite</b>]
       [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-a</b>
           Do not align output with the input

       <b>-c</b>
           Use circular neighborhood

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>input</b>=<u>name</u> <b>[required]</b>
           Name of input raster map

       <b>selection</b>=<u>name</u>
           Name of an input raster map to select the cells which should be processed

       <b>output</b>=<u>name[,name</u>,...] <b>[required]</b>
           Name for output raster map

       <b>size</b>=<u>integer</u>
           Neighborhood size
           Default: <u>3</u>

       <b>method</b>=<u>string[,string</u>,...]
           Neighborhood operation
           Options:  <u>average,</u>  <u>median,</u>  <u>mode,</u>  <u>minimum,</u> <u>maximum,</u> <u>range,</u> <u>stddev,</u> <u>sum,</u> <u>count,</u> <u>variance,</u> <u>diversity,</u>
           <u>interspersion,</u> <u>quart1,</u> <u>quart3,</u> <u>perc90,</u> <u>quantile</u>
           Default: <u>average</u>

       <b>weighting_function</b>=<u>string</u>
           Weighting function
           Options: <u>none,</u> <u>gaussian,</u> <u>exponential,</u> <u>file</u>
           Default: <u>none</u>
           <b>none</b>: No weighting
           <b>gaussian</b>: Gaussian weighting function
           <b>exponential</b>: Exponential weighting function
           <b>file</b>: File with a custom weighting matrix

       <b>weighting_factor</b>=<u>float</u>
           Factor used in the selected weighting function (ignored for none and file)

       <b>weight</b>=<u>name</u>
           Text file containing weights

       <b>quantile</b>=<u>float[,float</u>,...]
           Quantile to calculate for method=quantile
           Options: <u>0.0-1.0</u>

       <b>title</b>=<u>phrase</u>
           Title for output raster map

       <b>nprocs</b>=<u>integer</u>
           Number of threads for parallel computing
           Default: <u>1</u>

       <b>memory</b>=<u>memory</u> <u>in</u> <u>MB</u>
           Maximum memory to be used (in MB)
           Cache size for raster rows
           Default: <u>300</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>r.neighbors</b> looks at each cell in a raster input map, and examines the values assigned to  the  cells  in
       some  user-defined  "neighborhood"  around  it.  It  outputs a new raster map layer in which each cell is
       assigned a value that is some (user-specified) function of the values in that  cell’s  neighborhood.  For
       example,  each  cell  in  the  output  layer might be assigned a value equal to the average of the values
       appearing in its 3 x 3 cell "neighborhood" in the input layer. Note that the centre cell is also included
       in the calculation.

       <u>Figure:</u> <u>Illustration</u> <u>for</u> <u>an</u> <u>3x3</u> <u>average</u> <u>neighborhood</u>

   <b>OPTIONS</b>
       The user must specify the names of the raster map layers to be used for <b>input</b> and <b>output</b>, the <b>method</b> used
       to analyze neighborhood values (i.e., the neighborhood function or operation to be  performed),  and  the
       <b>size</b> of the neighborhood.

       The user can optionally specify a <b>selection</b> map, to compute new values only where the raster cells of the
       selection  map  are  not NULL. In case of a NULL cells, the values from the input map are copied into the
       output map.  This may useful to smooth only parts of an elevation map (pits, peaks, ...).

       <u>Example</u> <u>how</u> <u>to</u> <u>use</u> <u>a</u> <u>selection</u> <u>map</u> <u>with</u> <u>method=average:</u>
       input map:
       1 1  1 1 1
       1 1  1 1 1
       1 1 10 1 1
       1 1  1 1 1
       1 1  1 1 1
       selection map, NULL values are marked as *:
       * * * * *
       * * 1 * *
       * 1 1 1 *
       * * 1 * *
       * * * * *
       The output map:
       1 1 1 1 1
       1 1 2 1 1
       1 2 2 2 1
       1 1 2 1 1
       1 1 1 1 1
       Without using the selection map, the output map would look like this:
       1 1 1 1 1
       1 2 2 2 1
       1 2 2 2 1
       1 2 2 2 1
       1 1 1 1 1

       It is also possible to weigh cells within the neighborhood. This can be either done with a custom weights
       matrix or by specifying a weighting function.

       In order to use a custom weights matrix, <u>file</u> needs to be specified as a <b>weighting_function</b> and a path to
       a text file containing the weights needs to be given in the <b>weight</b> option.

       Alternatively, <u>gaussian</u> and <u>exponential</u> weighting functions can be selected as weighting function.

       For the <u>gaussian</u> weighting function, the user specifies the sigma value (σ) for the gauss filter  in  the
       <b>weighting_factor</b>  option. The sigma value represents the standard deviation of the gaussian distribution,
       where the weighting formula for the gaussian filter is defined as follows:

       exp(-(x*x+y*y)/(2*σ^2))/(2*π*σ^2)

       Lower values for sigma result in a steeper curve, so that more weight is put on cells close to the center
       of the moving window with a steeper decrease in weights with distance from the center.

       For the <u>exponential</u> weighting function, the user specifies a factor for  an  exponential  kernel  in  the
       <b>weighting_factor</b>.   Negative  factors  result in negative exponential decrease in weights from the center
       cell. The weighting formula for the exponential kernel is defined as follows:

       exp(factor*sqrt(x*x+y*y))

       Stronger negative values for the factor result in a steeper curve, so that more weight is  put  on  cells
       close  to  the  center  of  the  moving  window with a steeper decrease in weights with distance from the
       center.

       Optionally, the user can also run <b>r.neighbors</b> specify the <b>TITLE</b> to be assigned to the  raster  map  layer
       <b>output</b>,  select  to not align the resolution of the output with that of the input (the <b>-a</b> option).  These
       options are described further below.

       <u>Neighborhood</u> <u>Operation</u> <u>Methods:</u> The <b>neighborhood</b> operators determine what new value a center  cell  in  a
       neighborhood  will  have  after examining values inside its neighboring cells.  Each cell in a raster map
       layer becomes the center cell of a neighborhood as the  neighborhood  window  moves  from  cell  to  cell
       throughout the map layer.  <b>r.neighbors</b> can perform the following operations:

       <b>average</b>
           The average value within the neighborhood.  In the following example, the result would be:
           (7*4 + 6 + 5 + 4*3)/9 = 5.6667
           The result is rounded to the nearest integer (in this case 6).
              Raw Data     Operation     New Data
              +---+---+---+          +---+---+---+
              | 7 | 7 | 5 |          |   |   |   |
              +---+---+---+ average  +---+---+---+
              | 4 | 7 | 4 |---------&gt;|   | 6 |   |
              +---+---+---+          +---+---+---+
              | 7 | 6 | 4 |          |   |   |   |
              +---+---+---+          +---+---+---+

       <b>median</b>
           The  value  found  half-way  through  a  list  of the neighborhood’s values, when these are ranged in
           numerical order.

       <b>mode</b>
           The most frequently occurring value in the neighborhood.

       <b>minimum</b>
           The minimum value within the neighborhood.

       <b>maximum</b>
           The maximum value within the neighborhood.

       <b>range</b>
           The range value within the neighborhood.

       <b>stddev</b>
           The statistical standard deviation  of  values  within  the  neighborhood  (rounded  to  the  nearest
           integer).

       <b>sum</b>
           The sum of values within the neighborhood.

       <b>count</b>
           The count of filled (not NULL) cells.

       <b>variance</b>
           The statistical variance of values within the neighborhood (rounded to the nearest integer).

       <b>diversity</b>
           The number of different values within the neighborhood.  In the above example, the diversity is 4.

       <b>interspersion</b>
           The percentage of cells containing values which differ from the values assigned to the center cell in
           the neighborhood, plus 1.  In the above example, the interspersion is:
           5/8 * 100 + 1 = 63.5
           The result is rounded to the nearest integer (in this case 64).

       <b>quart1,</b> <b>quart3</b>
           The result will be the first or the third quartile (equal of 25th and 75th percentiles).

       <b>perc90</b>
           The result will be the 90th percentile of neighborhood.

       <b>quantile</b>
           Any quantile as specified by "quantile" input parameter.

       <u>Neighborhood</u>  <u>Size:</u>  The neighborhood <b>size</b> specifies which cells surrounding any given cell fall into the
       neighborhood for that cell.  The <b>size</b> must be an odd integer and represent the length of  one  of  moving
       window edges in cells.  For example, a size value of 3 will result in
                                     _ _ _
                                    |_|_|_|
           3 x 3 neighborhood ---&gt;  |_|_|_|
                                    |_|_|_|

       <u>Matrix</u>  <u>weights:</u>  A custom matrix can be used if none of the neighborhood operation methods are desirable
       by using the <b>weight</b>. This option must be used in conjunction with the <b>size</b> option to specify  the  matrix
       size  and  <u>file</u> needs to be specified as <b>weighting_function</b>. The weights desired are to be entered into a
       text file. For example, to calculate the focal mean with a matrix <b>size</b> of 3,
       r.neigbors in=input.map out=output.map size=3 weighting_function=file \
       weight=weights.txt
       The contents of the weight.txt file:
       3 3 3
       1 4 8
       9 5 3
       This corresponds to the following 3x3 matrix:
       +-+-+-+
       |3|3|3|
       +-+-+-+
       |1|4|8|
       +-+-+-+
       |9|5|3|
       +-+-+-+
       To calculate an annulus shaped neighborhood the contents of weight.txt file may be e.g. for size=5:
        0 1 1 1 0
        1 0 0 0 1
        1 0 0 0 1
        1 0 0 0 1
        0 1 1 1 0
       The way that weights are used depends upon the specific aggregate (<b>method</b>) being used.  However, most  of
       the  aggregates have the property that multiplying all of the weights by the same factor won’t change the
       final result (an exception is <b>method=count</b>).  Also, most (if not all) of them have the properties that an
       integer weight of N is equivalent to N occurrences of the cell value, and having all weights equal to one
       produces the same result as when weights are not used.   When  weights  are  used,  the  calculation  for
       <b>method=average</b> is:
         sum(w[i]*x[i]) / sum(w[i])
       In the case where all weights are zero, this will end up with both the numerator and denominator to zero,
       which produces a NULL result.

   <b>FLAGS</b>
       <b>-a</b>
           If  specified,  <b>r.neighbors</b>  will not align the output raster map layer with that of the input raster
           map layer.  The <b>r.neighbors</b> program works in the current geographic region.  It is  recommended,  but
           not  required,  that  the  resolution  of the geographic region be the same as that of the raster map
           layer.  By default, if unspecified, <b>r.neighbors</b> will align these geographic region settings.

       <b>-c</b>
           This flag will use a circular neighborhood for the moving analysis window, centered  on  the  current
           cell.

       The exact masks for the first few neighborhood sizes are as follows:
       3x3     . X .        5x5    . . X . .    7x7    . . . X . . .
               X O X               . X X X .           . X X X X X .
               . X .               X X O X X           . X X X X X .
                                   . X X X .           X X X O X X X
                                   . . X . .           . X X X X X .
                                                       . X X X X X .
                                                       . . . X . . .
       9x9    . . . . X . . . .        11x11   . . . . . X . . . . .
              . . X X X X X . .                . . X X X X X X X . .
              . X X X X X X X .                . X X X X X X X X X .
              . X X X X X X X .                . X X X X X X X X X .
              X X X X O X X X X                . X X X X X X X X X .
              . X X X X X X X .                X X X X X O X X X X X
              . X X X X X X X .                . X X X X X X X X X .
              . . X X X X X . .                . X X X X X X X X X .
              . . . . X . . . .                . X X X X X X X X X .
                                               . . X X X X X X X . .
                                               . . . . . X . . . . .

</pre><h4><b>NOTES</b></h4><pre>
       The  <b>r.neighbors</b>  program  works  in  the current geographic region with the current mask, if any.  It is
       recommended, but not required, that the resolution of the geographic region be the same as  that  of  the
       raster  map  layer.   By  default, <b>r.neighbors</b> will align these geographic region settings.  However, the
       user can select to keep original input and output resolutions which are not aligned  by  specifying  this
       (e.g., using the <b>-a</b> option).

       <b>r.neighbors</b>  doesn’t  propagate  NULLs,  but  computes  the  aggregate  over  the  non-NULL  cells in the
       neighborhood.

       The <b>-c</b> flag and the <b>weights</b> parameter are mutually exclusive.  Any use of the two together  will  produce
       an error. Differently-shaped neighborhood analysis windows may be achieved by using the <b>weight=</b> parameter
       to  specify  a weights file where all values are equal. The user can also vary the weights at the edge of
       the neighborhood according to the proportion of the  cell  that  lies  inside  the  neighborhood  circle,
       effectively anti-aliasing the analysis mask.

       For  aggregates  where a weighted calculation isn’t meaningful (specifically: minimum, maximum, diversity
       and interspersion), the weights are used to create a binary mask,  where  zero  causes  the  cell  to  be
       ignored and any non-zero value causes the cell to be used.

       <b>r.neighbors</b>  copies the GRASS <u>color</u> files associated with the input raster map layer for those output map
       layers that are based on the neighborhood average, median, mode, minimum, and maximum.  Because  standard
       deviation, variance, diversity, and interspersion are indices, rather than direct correspondents to input
       values,  no  <u>color</u>  files are copied for these map layers.  (The user should note that although the <u>color</u>
       file is copied for <u>average</u> neighborhood function output, whether or not the color file  makes  sense  for
       the output will be dependent on the input data values.)

   <b>Propagation</b> <b>of</b> <b>output</b> <b>precision</b>
       The  following  logic has been implemented: For any aggregate, there are two factors affecting the output
       type:

       <b>1</b>      Whether the input map is integer or floating-point.

       <b>2</b>      Whether the weighted or unweighted version of the aggregate is used.

       These combine to create four possibilities:

       input type/weight                                            integer                                                      float

       no                                                           yes                                                          no                                                           yes

       average                                                      float                                                        float                                                        float                                                        float

       median                                                       [1]                                                          [1]                                                          float                                                        float

       mode                                                         integer                                                      integer                                                      [2]                                                          [2]

       minimum                                                      integer                                                      integer                                                      float                                                        float

       maximum                                                      integer                                                      integer                                                      float                                                        float

       range                                                        integer                                                      integer                                                      float                                                        float

       stddev                                                       float                                                        float                                                        float                                                        float

       sum                                                          integer                                                      float                                                        float                                                        float

       count                                                        integer                                                      float                                                        integer                                                      float

       variance                                                     float                                                        float                                                        float                                                        float

       diversity                                                    integer                                                      integer                                                      integer                                                      integer

       interspersion                                                integer                                                      integer                                                      integer                                                      integer

       quart1                                                       [1]                                                          [1]                                                          float                                                        float

       quart3                                                       [1]                                                          [1]                                                          float                                                        float

       perc90                                                       [1]                                                          [1]                                                          float                                                        float

       quantile                                                     [1]                                                          [1]                                                          float                                                        float

       [1] For integer input, quantiles may produce float results from interpolating between adjacent values.
       [2] Calculating the mode of floating-point data is essentially meaningless.

       With the current aggregates, there are 5 cases:

       <b>1</b>      Output is always float: average, variance, stddev, quantiles (with interpolation).

       <b>2</b>      Output is always integer: diversity, interspersion.

       <b>3</b>      Output is integer if unweighted, float if weighted: count.

       <b>4</b>      Output matches input: minimum, maximum, range, mode (subject to note 2 above), quantiles  (without
              interpolation).

       <b>5</b>      Output is integer for integer input and unweighted aggregate, otherwise float: sum.

   <b>Performance</b>
       To  enable  parallel  processing,  the  user can specify the number of threads to be used with the <b>nprocs</b>
       parameter (default 1). The <b>memory</b> parameter (default 300) can also be provided to determine the  size  of
       the buffer for computation.
       <u>Figure:</u> <u>Benchmark</u> <u>on</u> <u>the</u> <u>left</u> <u>shows</u> <u>execution</u> <u>time</u> <u>for</u> <u>different</u> <u>number</u> <u>of</u> <u>cells,</u> <u>benchmark</u> <u>in</u> <u>the</u> <u>middle</u>
       <u>shows</u>  <u>execution</u>  <u>time</u>  <u>for</u> <u>different</u> <u>sizes</u> <u>of</u> <u>neighborhood</u> <u>for</u> <u>a</u> <u>10000x10000</u> <u>raster</u> <u>and</u> <u>benchmark</u> <u>on</u> <u>the</u>
       <u>right</u> <u>shows</u> <u>execution</u> <u>time</u> <u>for</u> <u>different</u> <u>memory</u> <u>size</u> <u>for</u> <u>a</u> <u>10000x10000</u> <u>raster.</u> <u>See</u> <u>benchmark</u>  <u>scripts</u>  <u>in</u>
       <u>source</u> <u>code.</u>  <u>(Intel</u> <u>Core</u> <u>i9-10940X</u> <u>CPU</u> <u>@</u> <u>3.30GHz</u> <u>x</u> <u>28)</u>

       To  reduce  the  memory  requirements  to  minimum,  set option <b>memory</b> to zero.  To take advantage of the
       parallelization, GRASS GIS needs to be compiled with OpenMP enabled.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Measure</b> <b>occupancy</b> <b>of</b> <b>neighborhood</b>
       Set up 10x10 computational region to aid visual inspection of results
       g.region rows=10 cols=10
       Fill 50% of computational region with randomly located cells.  "distance=0" will allow  filling  adjacent
       cells.
       r.random.cells output=random_cells distance=0 ncells=50
       Count non-empty (not NULL) cells in 3x3 neighborhood
       r.neighbors input=random_cells output=counts method=count
       Optionally - exclude centre cell from the count (= only look around)
       r.mapcalc "count_around = if( isnull(random_cells), counts, counts - 1)"

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>g.region,</u> <u>r.clump,</u> <u>r.mapcalc,</u> <u>r.mfilter,</u> <u>r.statistics,</u> <u>r.support</u>

</pre><h4><b>AUTHORS</b></h4><pre>
       Original version: Michael Shapiro, U.S.Army Construction Engineering Research Laboratory
       Updates for GRASS GIS 7 by Glynn Clements and others

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: r.neighbors source code (history)

       Accessed: Friday Apr 04 01:19:16 2025

       Main index | Raster index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                  <u><a href="../man1grass/r.neighbors.1grass.html">r.neighbors</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>