<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tesh -- testing shell</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libsimgrid-dev">libsimgrid-dev_4.0-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tesh -- testing shell

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>tesh</b> [<u>options</u>]... <u>testsuite</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Tesh is the testing shell, a specialized shell for running tests. It provides the specified input to the
       tested commands, and check that they produce the expected output and return the expected value.

</pre><h4><b>OPTIONS</b></h4><pre>
         --help              : display help
         --cd some/directory : ask tesh to switch the working directory before
                               launching the tests
         --setenv var=value  : set a specific environment variable
         --cfg arg           : add parameter --cfg=arg to each command line
         --log arg           : add parameter --log=arg to each command line
         --ignore-jenkins    : ignore all cruft generated on SimGrid
                               continuous integration servers

</pre><h4><b>TEST</b> <b>SUITE</b> <b>FILE</b> <b>SYTAX</b></h4><pre>
       A test suite is composed of one or several <u>command</u> <u>blocks</u> separated by empty lines, each of them being
       composed of a command to run, its input text and the expected output.

       The first char of each line specifies the type of line according to the following list. The second char
       of each line is ignored.

        `$' command to run in foreground
        `&amp;' command to run in background

        `&lt;' input to pass to the command
        `&gt;' output expected from the command

        `!' metacommand, which can be one of:
            `timeout' &lt;integer&gt;|no
            `expect signal' &lt;signal name&gt;[|&lt;signal name&gt;]*
            `expect return' &lt;integer&gt;
            `output' &lt;ignore|display&gt;
            `output sort' [integer]
            `setenv &lt;key&gt;=&lt;val&gt;'
            `ignore' &lt;regexp&gt;

        `p' an informative message to print
        `#' a comment

       If the expected output do not match the produced output, or if the command did not end as expected, Tesh
       provides an error message (see the OUTPUT section below) and stops.

   <b>Command</b> <b>blocks</b> <b>examples</b>
       In a given command block, you can declare the command, its input and its expected output in the order
       that you see fit.

           $ cat
           &lt; TOTO
           &gt; TOTO

           &gt; TOTO
           $ cat
           &lt; TOTO

           &gt; TOTO
           &lt; TOTO
           $ cat

       You can group several commands together, provided that they don't have any input nor output.

           $ mkdir testdir
           $ cd testdir

   <b>Enforcing</b> <b>the</b> <b>command</b> <b>return</b> <b>code</b>
       By default, Tesh enforces that the tested command returns 0. If not, it fails with an appropriate message
       and returns <u>code+40</u> itself.

       You specify that a given command block is expected to return another code as follows:

           # This command MUST return 42
           ! expect return 42
           $ sh -e "exit 42"

       The <u>expect</u> <u>return</u> construct applies only to the next command block.

   <b>Commands</b> <b>that</b> <b>are</b> <b>expected</b> <b>to</b> <b>raise</b> <b>signals</b>
       By default, Tesh detects when the command is killed by a signal (such as SEGV on segfaults). This is
       usually unexpected and unfortunate. But if not, you can specify that a given command block is expected to
       fail with a signal as follows:

           # This command MUST raise a segfault
           ! expect signal SIGSEGV
           $ ./some_failing_code

       The <u>expect</u> <u>signal</u> construct applies only to the next command block.

   <b>Timeouts</b>
       By default, no command is allowed to run more than 10 seconds. You can change this value as follows:

           # Allow some more time to the command
           ! timeout 60
           $ ./some_longer_command

       You can also disable the timeout completely by passing "no" as a value:

           # This command will never timeout
           ! timeout no
           $ ./some_very_long_but_safe_command

   <b>Setting</b> <b>environment</b> <b>variables</b>
       You can modify the environment of the tested commands as follows:

           ! setenv PATH=<a href="file:/bin">/bin</a>
           $ my_command

       You can also set an envirmnent variable from the command line:

           tesh --setenv bindir=/opt/bin/

       And then use it within the tesh file:

           $ ${bindir}/myprogram

       Tesh also supports perl default value for undefined variables:

           $ ${bindir:=<a href="file:/usr/bin">/usr/bin</a>}/myprogram

   <b>Not</b> <b>enforcing</b> <b>the</b> <b>expected</b> <b>output</b>
       By default, the commands output is matched against the one expected, and an error is raised on
       discrepancy. Metacommands to change this:

       output ignore
           The output is completely discarded.

       output display
           The output is displayed, but no error is issued if it differs from the expected output.

       output sort
           The output and the expected output are sorted before comparison (see next section).

   <b>Sorting</b> <b>output</b>
       If  the order of the command output changes between runs, you want to sort it before enforcing that it is
       exactly what you expect. In SimGrid for example, this happens when parallel execution is activated:  User
       processes  are  run  in parallel at each timestamp, and the output is not reproducible anymore. Until you
       sort the lines.

       You can sort the command output as follows:

           ! output sort
           $ ./some_multithreaded_command

       Sorting lines this ways often makes the tesh output very intricate, complicating the error analysis:  the
       process logical order is defeated by the lexicographical sort.

       The solution is to prefix each line of your output with temporal information so that lines can be grouped
       by  timestamps.  The lexicographical sort then only applies to lines that occurred at the same timestamp.
       Here is a SimGrid example:

           # Sort only lines depending on the first 19 chars
           ! output sort 19
           $ ./some_simgrid_simulator --log=root.fmt:[%10.6r]%e(%i:%a@%h)%e%m%n

       This approach may seem surprising at the first glance but it does its job:

       Every timestamps remain separated, as it should;
       In each timestamp, the output order of processes become reproducible: that's the lexicographical order of
       their name;
       For each process, the order of its execution is preserved: its messages within a given timestamp are not
       reordered.

       That way, tesh can do its job (no false positive, no false negative) despite the unpredictable  order  of
       executions  of  processes  within a timestamp, and reported errors remain easy to analyze (execution of a
       given process preserved).

       This example is very SimGrid oriented, but the feature could even be usable by others, who knows?

   <b>Ignoring</b> <b>some</b> <b>output</b>
       Some outputted lines can be ignored by setting the ignore command followed by a regular expression:

           ! ignore .*0x[0-9A-F]+\.
           $  printf 'word\nMemory address: 0x42AA42.\nanotherword\n'
           &gt; word
           &gt; anotherword

   <b>Colored</b> <b>and</b> <b>formatted</b> <b>text</b>
       Tesh removes ANSI/VT100 control sequences from outputted text to make easier the writing of tests.

           $ printf "I \033[0;31mlove\033[0m tesh\n"
           &gt; I love tesh

</pre><h4><b>BUILTIN</b> <b>COMMANDS</b></h4><pre>
   <b>mkfile:</b> <b>creating</b> <b>a</b> <b>file</b>
       This command creates a file of the name provided as argument, and adds the content it gets as input.

         $ mkfile myFile
         &gt; some content
         &gt; to the file

       It is not possible to use the cat command, as one would expect, because stream redirections are currently
       not implemented in Tesh.

</pre><h4><b>BUGS,</b> <b>LIMITATIONS</b> <b>AND</b> <b>POSSIBLE</b> <b>IMPROVEMENTS</b></h4><pre>
       The main limitation is the lack of stream redirections in the commands ("&gt;", "&lt;" and "|" shell constructs
       and friends). The <b>mkfile</b> builtin command makes this situation bearable.

       It would be nice if we could replace the tesh file completely with command line flags when the output  is
       not to be verified.

perl v5.40.1                                       2025-03-12                                            <u><a href="../man1/TESH.1.html">TESH</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>