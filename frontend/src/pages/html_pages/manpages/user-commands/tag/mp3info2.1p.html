<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mp3info2 - get/set MP3 tags; uses MP3::Tag to get default values.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libmp3-tag-perl">libmp3-tag-perl_1.16-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mp3info2 - get/set MP3 tags; uses MP3::Tag to get default values.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # Print the information in tags and autodeduced info
         mp3info2 *.mp3

         # In addition, set the year field to 1981
         mp3info2 -y 1981 *.mp3

         # Same without printout of info, recursively in the current directory
         mp3info2 -R -p "" -y 1981 .

         # Do not deduce any field, print (normalized) info from the tags only
         mp3info2 -C autoinfo=ID3v2,ID3v1 *.mp3

         # As above, but without normalization/autofill, the raw information in tags
         mp3info2 -N *.mp3

         # As above, but only with ID2v1 tag read
         mp3info2 -NC autoinfo=ID3v1 *.mp3

         # Get artist from CDDB_File, autodeduce other info, write it to tags
         mp3info2 -C artist=CDDB_File -u *.mp3

         # For title, prefer information from .inf file; autodeduce rest, update
         mp3info2 -C title=Inf,ID3v2,ID3v1,filename -u *.mp3

         # Same, and get the artist from CDDB file
         mp3info2 -C title=Inf,ID3v2,ID3v1,filename -C artist=CDDB_File -u *.mp3

         # Write a script for conversion of .wav to .mp3, autodeducing tags
         mp3info2 -p "lame -h --vbr-new --tt '%t' --tn %n --ta '%a' --tc '%c' --tl '%l' --ty '%y' '%f'\n" *.wav &gt;xxx.sh

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The program prints a message summarizing tag info (obtained via MP3::Tag module) for specified files.

       It may also update the information in ID3 tags.  This happens in three different cases.

       •   If  the  information supplied in command-line options "t a l y g c n" differs from the content of the
           corresponding ID3 tags (or there is no corresponding ID3 tags).

       •   If options "-d" or "-F" were given.

       •   if "MP3::Tag" obtains the info from other means than MP3 tags, and "-u" forces the update of the  ID3
           tags.

       (All  these  ways  are  disabled  by  "-D" option.)  ID3v2 tag is written if needed, or if "-2" option is
       given.  (Automatic fill-in of deduceable fields (via the  method  <b>id3v2_frames_autofill()</b>)  is  performed
       unless "-d" or "-N" options are given.)

       The  option  "-u" writes ("u"pdates) the fetched information to the MP3 ID3 tags.  This option is assumed
       if there are command-line options which explicitly set tag elements ("-a", "-t" etc.,  and  "-F",  "-d").
       (Effects  of  this option may be overridden by giving "-D" option.)  If "-2" option is also given, forces
       write of ID3v2 tag even if the info fits the ID3v1 tag (in addition, this option enables  auto-update  of
       "personal   name"   fields,   and   corresponding  titles  according  to  values  of  "translate_person",
       "person_frames" etc.  configuration settings; see "Normalization of fields").  This option is ignored  if
       no  change  to tags is detected; however, one can force an update by repeating this option (useful if you
       expect the change the "format" of the tag, as opposed to its "content").

       The option "-p" prints a message using the next argument as format  (by  default  "\\",  "\t",  "\n"  are
       replaced  by  backslash,  tab  and  newline;  governed by the value of "-E" option); see "interpolate" in
       MP3::Tag for details of the format of <b>sprintf()</b>-like escapes.  If no option "-p"  is  given,  message  in
       default  format  will  be  emitted.  The value of option "-e" is the encoding used for the output; if the
       value is a number, system-specific encoding is guessed (and used for the output if the bit 0x1  is  set);
       if  the  bit  0x2 is set, then command line options are assumed to be in the guessed encoding; if the bit
       0x4 is set, then command line arguments are assumed to be in the guessed encoding.  If  the  bit  0x8  is
       set,  the  encoding/decoding  configuration  of  file  input/output  of "MP3::Tag" is redone with the the
       detected encoding.  Use the value "binary" to do binary output.

       In presence of "-U" option the default for "-e" is 15, and the decoding/encoding processing happens as if
       LANG is set for "UTF-8" encoding.  (For example, for "-Ue 1" the "STDOUT"  the  output  message  of  this
       script happens in UTF-8 mode, which makes it easier to detect decoding/encoding errors in tags.)

       With  option  "-D"  (dry  run)  no  update is performed, no matter what the other options are.  With this
       option, no parsing of tags is performed unless needed.

       Use options

         t a l y g c n

       to overwrite the information (title artist album year genre comment track-number) obtained via "MP3::Tag"
       heuristics ("-u" switch is implied if any one of  these  arguments  differs  from  what  would  be  found
       otherwise;  use  "-D"  switch  to  disable auto-update).  By default, the values of these options are not
       "%"-interpolated; this may be changed by "-E" option.

       The option "-d" should contain the comma-separated list of ID3v2 frames to delete.  A frame specification
       is the same as what might be given to "%{...}"  frame  interpolation  command,  e.g.,  "TIT3",  "COMM03",
       "COMM(fra)[short  title]";  the difference with modify-access is that <b>ALL</b> (and not the <b>first</b> of) matching
       frames are deleted.  (Option -d may be repeated.)

       For example, "-d APIC" would remove all picture frames.  In addition, if the  list  contains  "ID3v1"  or
       "ID3v2", whole tags will be deleted.

       Likewise,  the option "-F" allows setting of arbitrary "ID3v2" frames: if one needs to set one frame, use
       the directive "FRAME_spec=VALUE":

         -F TIT2=The_new_Title

       Again, on modify, <b>ALL</b> matching frames are deleted first, so be carefull with

         -F COMM=MyComment

       Option "-F" may be repeated to set more than one frame.  If configuration variable  "empty-F-deletes"  is
       TRUE (default), empty arguments will delete the frame.

       One can replace "FRAME_spec=VALUE" by "FRAME_spec &lt; FILE"; in this case the value to set is read from the
       file  named  <u>FILE</u>;  if  the frame is text-only (meaning: at most "[encoded]Text URL Language Description"
       fields are present), the file is read in text mode  (and  with  starting/trailing  whitespace  stripped),
       otherwise  it  is read in binary mode.  (Whitespace is required about the "&lt;" signs.)  If "&lt;" is replaced
       by "?&lt;", the value is set only if frame is not yet present, and if the file exists; if replaced  by  "&gt;",
       the  value  (if  present)  is  written  to  <u>FILE</u>  (creation  of intermediate directories is controlled by
       configuration option "frames_write_creates_dirs", the default is FALSE).

       Additionally, "FRAME_spec" may be one of "ID3v1" or "ID3v2" or "TAGS";  in  this  case,  whole  tags  are
       written  or  read.  For example, for "TAGS &lt; FILE", "title artist album year genre comment track" info is
       calculated from <u>FILE</u>,  which  may  be  raw  tags,  as  produced  with  "&gt;",  or  a  valid  MP3  file;  if
       Image::ExifTool  is present, the data may be read from arbitrary multimedia file.  (Likewise,  for "ID3v1
       &lt; FILE", the same info is extracted from "ID3v1" tag only.) After this, in case  of  "ID3v2"  or  "TAGS",
       "ID3v2" frames are copied from the "ID3v2" tag one-by-one.  (With suitable modifications for "?&lt;".)

       By  default,  the  "VALUE"  for  "-F"  is "%"-interpolated; this can be changed by option "-E".  For user
       convenience, human-friendlier forms "composer, text_by, orchestra, conductor, track, disk_n" can be  used
       instead of "TCOM, TEXT, TPE2, TPE3, TRCK, TPOS".

       The  option  "-P RECIPE" is a very powerful generalization of what can be done by options "-F", "-d", and
       "-t -a -l -y -g -c -n".  It may be repeated; the values should contain the parse  recipes.   They  become
       the  configuration  item  "parse_data"  of  "MP3::Tag";  eventually  this  information  is  processed  by
       MP3::Tag::ParseData module (if the latter is present in the chain of heuristics; see option  "-C").   The
       "RECIPE" is split into "$flags, $string, @patterns" on its first non-alphanumeric character; the first of
       @patterns  which  matches  $string is going to be executed (for side effects).  (See examples: "EXAMPLES:
       parse rules".)

       If option "-G" is specified, the file names on the command line are considered as  glob  patterns.   This
       may  be  useful  if  the  maximal  command-line length is too low.  With the option "-R" arguments can be
       directories, which are searched recursively for audio (default <u>*.mp3</u>) files to process; use  option  "-r"
       to reset the regular expression to look for (the default is "(?i:\.mp3$)").

       The  option  "-E" controls expansion of escape characters.  It should contain the letters of the command-
       line options where "\\, \n, \t" are interpolated; one can append the letters of "t a l y g c n F" options
       requiring "%"-interpolation after the separator "/i:" (for "-F", only the values are interpolated).   The
       default  value  is  "p/i:Fp":  only  "-p"  is  "\"-interpolated,  and  only  "-F" and "-p" are subject to
       "%"-interpolation.  If all one wants is to <u>add</u> to the defaults, preceed the  value  of  "-E"  (containing
       added  options)  by  "+".   (Some  parts of the value of option "-P" are interpolated, but this should be
       governed by flags, not "-E"; do <u>NOT</u> put "P" into the "%"-interpolated part of "-E".)

       If the option "-@" is given, all characters "@" in  the  options  are  replaced  by  "%".   This  may  be
       convenient if the shell treats "%" specially (e.g., DOSISH shells).

       If option "-I" is given, no guessworking for <u>artist</u> field is performed on typeout.

       The  option  "-C  CONFIG_OPT=VALUE1,VALUE2..."  sets  "MP3::Tag"  configuration  data  the  same  way  as
       "MP3::Tag-"<b>config()</b>&gt; would do (recall that the value is an array; separate elements  by  commas  if  more
       than  one).   The option may be repeated to set more than one value.  Note that since "ParseData" is used
       to process "-P" parse recipes, it should be better be kept in the "autoinfo" configuration  (and  related
       fields "author" etc) in presence of "-P".

       If  the  option  "-x"  is  given,  the  technical information about the audio file is printed (MP3 level,
       duration, number of frames, padding, copyright, and the list of ID3v2 frame names in format  suitable  to
       "%{...}"  escapes).  If "-x" is repeated, content of frames is also printed out (may output non-printable
       chars, if it is repeated more than twice).

       If option "-N" is given, all the "smarts" are disabled - no normalization  of  fields  happens,  and  (by
       default)  no  attempt  to  deduce  the values of fields from non-ID3 information is done.  This option is
       (currently) equivalent to having "-C autoinfo=ParseData,ID3v2,ID3v1" as the first directive, to having no
       <u>Normalize::Text::Music_Fields.pm</u> present on @INC path, and not calling <b>autofill()</b> method.

</pre><h4><b>Normalization</b> <b>of</b> <b>fields</b></h4><pre>
       (The loading of normalization module and all subsequent operations may be disabled by the option "-N", or
       by setting the environment variable "MP3TAG_NORMALIZE_FIELDS" to be FALSE.  If not prohibited, the module
       is attempted to be loaded if directory <u><a href="file:~/.music_fields">~/.music_fields</a></u> is present, or  "MP3TAG_NORMALIZE_FIELDS"  is  set
       and TRUE.)

       If loading of the module "Normalize::Text::Music_Fields" is successful, the following is applicable:

       If  the value of "MP3TAG_NORMALIZE_FIELDS" is defined and not 1, this value is broken into directories as
       a PATH, and load path of "Normalize::Text::Music_Fields" is set to be this  list  of  directories.   Then
       MP3::Tag  is  instructed  (via  corresponding  configuration  settings)  to use "normalize_artist" (etc.)
       methods defined by this module.  These methods may normalize  certain  tag  data.   The  current  version
       defines  methods  for  "normalization"  of  personal  names,  and  titles  (based on the composer).  This
       normalization is driven through user-editable configuration tables.

       In addition to automatical normalization of MP3 tag data, one can use "fake MP3 files" to manually access
       some features of this module.  For this, use an empty file name, and "-D" option.  E.g,

         mp3info2 -D -a beethoven                       -p "%a\n"         ""
         mp3info2 -D -a beethoven                       -p "%{shP[%a]}\n" ""
         mp3info2 -D -a beethoven -t "sonata #28"       -p "%t\n"         ""
         mp3info2 -D -a beethoven -t "allegretto, Bes" -@p "@t\n"         ""
         mp3info2 -D -a beethoven -t "op93"            -@p "@t\n"         ""

       will print the normalized person-name for "beethoven", the corresponding  normalized  short  person-name,
       and  the normalized title for "sonata #28" of composer "beethoven".  E.g., with the shipped normalization
       tables, it will print

         Ludwig van Beethoven (1770-1827)
         L. van Beethoven
         Piano Sonata No. 28 in A major; Op. 101 (1816)
         Allegretto for Piano Trio in B flat major; WoO 39 (1812)
         Symphony No. 8 in F major; Op. 93 (comp. 1812, f.p. Vienna, 1814-02-27, cond. Beethoven; pubd. 1816)

</pre><h4><b>The</b> <b>order</b> <b>of</b> <b>operation</b></h4><pre>
       Currently, the operations are done in the following order

       • Deletion of ID3v1 or ID3v2 as a whole via "-d" option;

       • Recipies of "-P" option are set up (to be triggered by interpolation);

       • The setting done via "-a/-t/-l/-y/-g/-c/-n" options;

       • The settings done via "-F" option;

       • Deletion of individual frames via "-d" option;

       • autofill of ID3v2 (id) frames;

       • Emit info based on "-p" and "-x" options;

       • Trigger recipies of "-P" (if not triggered by interpolation);

       • Update tags if needed.

</pre><h4><b>Usage</b> <b>strategy:</b> <b>escalation</b> <b>of</b> <b>complexity</b></h4><pre>
       The purpose of this script is to to make handling of ID3 tags as simple <u>as</u> <u>possible</u>.

       On one end of the scale, one can perform arbitrarily complex manipulations  with  tags  using  "MP3::Tag"
       Perl module.

       On  the  other  end,  it  is  much  more convenient to handle simplest manipulations with tags using this
       script's options "-t -a -l -y -g -c -n" and "-p -F -d".  For slightly more  complicated  tasks,  one  may
       need  to  use  the  more elaborate method of <u>parse</u> <u>rules</u>, provided to this script by the option "-P"; the
       rules depend heavily  on  <u>interpolation</u>,  see  "interpolate"  in  MP3::Tag,  "interpolate_with_flags"  in
       MP3::Tag.

       To  simplify upgrade from "simplest manipulations" to "more elaborate ones", here we provide "parse rule"
       <u>synonyms</u> to the simplest options.  So if you start with "-t -a -l -y -g -c -n" and  "-p  -F  -d"  options
       which "almost work" for you, you have a good chance to be able to fully achieve your aim by modifying the
       synonyms described below.

       (Below  we  assume  that  "-E" option is set to its default value, so "-F -p" are "%"-interpolated, other
       options are not.  Note also that if your TTY's encoding is recognized by Perl, it is  highly  recommended
       to set "-e 3" option; on DOSISH shells, better use "-@", and replace "%"'s by "@"'s below.)

       "-t VALUE"
                       -P "mz/VALUE/%t"

       "-a -l -y -g -c -n"
                     Likewise.

       "-F" "TIT2=VALUE"
                       -P "mzi/VALUE/%{TIT2}"

       "-F" "APIC[myDescr] &lt; FILE"
                       -F "APIC[myDescr]=%{I(fimbB)FILE}"

                     or

                       -P "mzi/%{I(fimbB)FILE}/%{APIC[myDescr]}"

                     (remove "bB" for text-only frames).

       "-F" "APIC[myDescr] &gt; FILE"
                       -P "bOi,%{APIC[myDescr]},FILE"

                     (remove  "b"  for  text-only  frames);  or  use  "-e  binary  -p  "%{APIC[myDescr]}""  with
                     redirection, see "EXAMPLES: parse rules".

       "-d" TIT2
                       -P "m//%{TIT2}"

       "-F" "TIT2 ?&lt; FILE"
                     Very tricky.  This won't set distinguish empty file and non-existing one:

                       -P "mzi/%{TIT2:1}0%{I(fFim)FILE}/10/10%{TIT2}/0%{U1}"

                     (add "bB" to "fFim" for non-text-only frames); the last part may be omitted  if  one  omits
                     the flag "m" - it is present to catch misprints only.

       For details on "parse rules", see "EXAMPLES: parse rules" and "DESCRIPTION" in MP3::Tag::ParseData.

</pre><h4><b>EXAMPLES:</b> <b>parse</b> <b>rules</b></h4><pre>
       Only  the  "-P" option is complicated enough to deserve comments...  For full details on <u>parse</u> <u>rules</u>, see
       "DESCRIPTION" in MP3::Tag::ParseData; for full details on interpolation, see "interpolate"  in  MP3::Tag,
       "interpolate_with_flags" in MP3::Tag.

       For a (silly) example, one can replace "-a Homer -t Iliad" by

         -P mz=Homer=%a -P mz=Iliad=%t

       A less silly example is forcing a particular way of parsing a file name via

         -P "im=%{d0}/%f=%a/%n %t.%e"

       It is broken into

        flags          string          pattern1
        "im"           "%{d0}/%f"      "%a/%n %t.%e"

       The  flag  letters stand for <u>interpolate</u>, <u>must_match</u>.  This interpolates the string "%{d0}/%f" and parses
       the result (which is the file name with one level of  the  directory  part  preserved)  using  the  given
       pattern; thus the directory name becomes the artist, the leading numeric part - the track number, and the
       rest  of  the  file name (without extension) - the title.  Note that since multiple patterns are allowed,
       one can similarly allow for multiple formats of the names, e.g.

         -P "im=%{d0}/%f=%a/%n %t.%e=%a/%t (%y).%e"

       allows for the file basename to be also of the form "TITLE (YEAR)".  An alternative  way  to  obtain  the
       same results is

         -P "im=%{d0}=%a" -P "im=%f=%n %t.%e=%t (%y).%e"

       which corresponds to two recipies:

        flags          string          pattern1        pattern2
        "im"           "%{d0}"         "%a"
        "im"           "%f"            "%n %t.%e"      "%t (%y).%e"

       Of course, one could use

        "im"           "%B"            "%n %t"         "%t (%y)"

       as a replacement for the second one.

       Note  that  it  may  be  more  readable to set <u>artist</u> to "%{d0}" by an explicit asignment, with arguments
       similar to

         -E "p/i:Fpa" -a "%{d0}"

       (this value  of  "-E"  requests  "%"-interpolation  of  the  option  "-a"  in  addition  to  the  default
       "\"-interpolation of "-p", and "%"-interpolation of "-F" and "-p"; one can shortcut it with "-E +/i:a").

       To give more examples,

         -P "if=%D/.comment=%c"

       will read comment from the file <u>.comment</u> in the directory of the audio file;

         -P "ifn=%D/.comment=%c"

       has  similar effect if the file <u>.comment</u> has one-line comments, one per track (this assumes the the track
       number can be found by other means).

       Suppose that a file <u>Parts</u> in a directory of MP3 files has the following format: it has a  preamble,  then
       has a short paragraph of information per audio file, preceded by the track number and dot:

          ...

          12. Rezitativ.
          (Pizarro, Rocco)

          13. Duett: jetzt, Alter, jetzt hat es Eile, (Pizarro, Rocco)

          ...

       The  following  command  puts  this info into the title of the ID3 tag (provided the audio file names are
       informative enough so that MP3::Tag can deduce the track number):

        mp3info2 -u -C parse_split='\n(?=\d+\.)' -P 'fl;Parts;%=n. %t'

       If this paragraph of information has the form "TITLE (COMMENT)" with the "COMMENT" part  being  optional,
       then use

        mp3info2 -u -C parse_split='\n(?=\d+\.)' -P 'fl;Parts;%=n. %t (%c);%=n. %t'

       If you want to remove a dot or a comma got into the end of the title, use

        mp3info2 -u -C parse_split='\n(?=\d+\.)' \
          -P 'fl;Parts;%=n. %t (%c);%=n. %t' -P 'iR;%t;%t[.,]$'

       The second pattern of this invocation is converted to

         ['iR', '%t' =&gt; '%t[.,]$']

       which essentially applies the substitution "s/(.*)[.,]$/$1/s" to the title.

       Now  suppose  that in addition to <u>Parts</u>, we have a text file <u>Comment</u> with additional info; we want to put
       this info into the comment field <u>after</u> what is extracted from "TITLE (COMMENT)"; separate these two parts
       of the comment by an empty line:

        mp3info2 -E C -C 'parse_split=\n(?=\d+\.)' -C 'parse_join=\n\n' \
         -P 'f;Comment;%c'           -P 'fl;Parts;%=n. %t'              \
         -P 'i;%t///%c;%t (%c)///%c' -P 'iR;%t;%t[.,]$'

       This assumes that the title and the comment do not contain '///' as a substring.  Explanation: the  first
       pattern of "-P",

         ['f', 'Comment' =&gt; '%c'],

       reads comment from the file "Comment" into the comment field; the second,

         ['fl', 'Parts'  =&gt; '%=n. %t'],

       reads a chunk of "Parts" into the title field.  The third one

         ['i', '%t///%c' =&gt; '%t (%c)///%c']

       rearranges the title and comment <u>provided</u> the title is of the form "TITLE (COMMENT)".  (The configuration
       option  "parse_join" takes care of separating two chunks of comment corresponding to two occurences of %c
       on the right hand side.)

       Finally, the fourth pattern is the same as in the preceding example; it removes spurious  punctuation  at
       the end of the title.

       More  examples:  removing  string  "with  violin"  from  the start of the comment field (removing comment
       altogether if nothing remains):

         mp3info2 -u -P 'iz;%c;with violin%c' *.mp3

       setting the artist field without letting auto-update feature deduce other fields from other sources;

         mp3info2 -C autoinfo=ParseData -a "A. U. Thor" *.mp3

       setting a comment field unless it it already present:

         mp3info2 -u -P 'i;%c///with piano;///%c' *.mp3

       The last example shows how to actually write "programs" in the language of the "-P" option:  the  example
       gives  a  conditional assignment.  With user variables (as in "%{U8}") for temporaries, and a possibility
       to use regular expressions, one could provide arbitrary programmatic logic.  Of course, at some level  of
       complexity  one  should  better switch to direct interfacing with "MP3::Tag" Perl module (use the code of
       this Perl script as an example!).

       Here is a typical task setting "advanced" id3v2 frames: composer ("TCOM"), orchestra ("TPE2"),  conductor
       ("TPE3").   We  assume  a  directory tree which contains MP3 files tagged with the following conventions:
       "artist" is actually a composer; "comment" is of one of two forms:

         Performers; Orchestra; Conductor
         Orchestra; Conductor

       To set the specific MP3 frames via "-P" rules, use

         mp3info2 -@P "mi/@a/@{TCOM}" \
           -P "mi/@c/@{U1}; @{TPE2}; @{TPE3}/@{TPE2}; @{TPE3}" -R .

       With "-F" options, this can be simplified as

         mp3info2 -@F "TCOM=@a" -P "mi/@c/@{U1}; @{TPE2}; @{TPE3}/@{TPE2}; @{TPE3}" -R .

       or

         mp3info2 -@F "composer=@a" -P "mi/@c/@{U1}; @{TPE2}; @{TPE3}/@{TPE2}; @{TPE3}" -R .

       To copy ID3 tags of MP3 files in the current directory to files in directory <u>/tmp/mp3</u> with the  extension
       <u>.tag</u> (and print "progress report"), use

         mp3info2 -p "@N@E\n" -@P "bODi,@{ID3v2}@{ID3v1},/tmp/mp3/@N.tag" -DNR .

       Since we did not use "z" flag, MP3 files without tags are skipped.

       Now  suppose  that there are two parallel file hierarchies of audio files, and of lyrics: audio files are
       in <u>audio/dir_name/audio_name.mp3</u> with corresponding  lyrics  file  in  <u>text/dir_name/audio_name.mp3</u>.   To
       attach  lyrics to MP3 files (in "COMM" frame with description "lyrics" in language "eng" - <u>this</u> <u>is</u> <u>a</u> <u>non-</u>
       <u>standard</u> <u>location,</u> <u>see</u> <u>below!</u>), call

         mp3info2 -@P "fim;../text/@{d0}/@B.txt;@{COMM(eng)[lyrics]}" -Ru .

       inside the directory  <u>audio</u>.   (Change  "fim"  to  "Ffim"  to  ignore  the  audio  files  for  which  the
       corresponding  text file does not exist.)  (Of course, to follow the specifications, one should have used
       the field "%{USLT(eng)[]}" instead of "%{COMM(eng)[lyrics]}"; see below for variations).

       Finish by a very simple example: all what the pattern

         -P 'i;%t;%t'

       does is removal of trailing and leading blanks from the title (which is deduced by other means).

</pre><h4><b>More</b> <b>examples</b></h4><pre>
       With "-F" option, one could set the "USLT" frame as

         mp3info2 -@F "USLT(eng)[] &lt; ../text/@{d0}/@B.txt" -Ru .

       Print out such a frame (in any language) with

         mp3info2 -@p "@{USLT[]}\n" file.mp3

       Similarly, to print out the APIC frame with empty description, use

         mp3info2 -e binary -@p "@{APIC[]}" file.mp3 &gt; output_picture_file

       or (with description "cover")

         mp3info2 -@P "bOi,@{APIC[cover]},output_picture_file.jpg" audio_07.mp3

       To set such a frame from file <u>xxx.gif</u> (with the  default  "Picture  Type",  "Cover  (front)",  and  empty
       description), do one of

         mp3info2 -F  "APIC  &lt;          xxx.gif"  file.mp3
         mp3info2 -@F "APIC[]=@{I(fimbB)xxx.gif}" file.mp3

       The  difference  of "APIC" and "APIC[]" is that the first removes all "APIC" frames first, and the second
       removes only all "APIC" frames with empty description - but arbitrary image type.   So  it  may  be  more
       suitable to use the full specification, as in "APIC(Cover (front))[]".

       To remove "APIC" frames with empty descriptions, arbitrary "Picture Type"s (and "MIME type"s which may be
       correctly calculated by <u>mp3info2</u>, e.g., "TIFF/JPEG/GIF/PNG"), use

         mp3info2 -d "APIC[]" file.mp3

       (note  that  this wouldn't free disk space, unless "shrink" is forced by configuration variables).  To do
       the same with the "Conductor" picture type only, do

         mp3info2 -d "APIC(Conductor)[]" file.mp3

       To scan through subdirectories, and add file <u>cover.jpg</u> from the directory of  the  file  as  a  "default"
       "APIC" frame, but only if there is no "APIC" frame, and a file exists, do

         mp3info2 -@F "APIC ?&lt; @D/cover.jpg" -R .

       This  deletes  empty  frames  for date, "TCOP, TENC, WXXX[], COMM(eng)[]", and removes the leading 0 from
       track number from MP3 file in current directory:

         mp3info2 -@ -E +/i:y -F "TCOP=@{TCOP}" -F "TENC=@{TENC}"
           -F "WXXX[]=@{WXXX[]}" -F "COMM(eng)[]=@{COMM(eng)[]}"
           -y "@y" -P "mi/@n/0@n/@n" *.mp3

</pre><h4><b>Examples</b> <b>on</b> <b>dealing</b> <b>with</b> <b>broken</b> <b>encodings</b></h4><pre>
       One of principal weaknesses of ID3 specification was that it required that data is provided in  "latin-1"
       encoding.   Since  most languages in the world are not expressible in "latin-1", this lead to (majority?)
       of ID3 tags being not standard-conforming.  Newer versions of the specs fixed this shortcoming,  but  the
       damage  was  already done.  Fortunately, this script can use abilities of "MP3::Tag" to convert from non-
       conforming content to a conforming one.

       The following example converts ID3v2  tags  which  were  written  in  (non-standard-conforming)  encoding
       "cp1251"  to be in standard-conforming encoding.  For the purpose of this example, assume that ID3v1 tags
       are in the same encoding (and that one wants to leave them  in  the  encoding  "cp1251");  the  files  to
       process  are  found  in  the  current directory and (recursively) in its subdirectories ("set" syntax for
       DOSISH shells):

         set MP3TAG_DECODE_V1_DEFAULT=cp1251
         set MP3TAG_DECODE_V2_DEFAULT=cp1251
         mp3info2 -C id3v2_fix_encoding_on_write=1 -u2R .

       For more information, see "ENVIRONMENT"  in  MP3::Tag,  "config"  in  MP3::Tag,  and  "CUSTOMIZATION"  in
       MP3::Tag.

<b>INCOMPATIBILITIES</b> <b>with</b> <u><b>mp3info</b></u>
       This  tool is loosely modeled on the program <u>mp3info</u>; it is "mostly" backward compatible (especially when
       in "naive" mode via "-N"), and allows a very  significant  superset  of  functionality.   Known  backward
       incompatibilities are:

         -G -h -r -d -x

       Missing functionality:

         -f -F -i

       Incompatible "%"-<u>escapes</u>:

         %e %E         - absolutely different semantic
         %v            - has no trailing 0s
         %q            - has fractional part
         %r            - is a number, not a word "Variable" for VBR
         %u            - is one less (in presence of descriptor frame only?)

       Missing "%"-<u>escapes</u>:

         %b %G

       Backslash escapes: only "\\", "\n", "\t" supported.

       "-x" prints data in a different format, not all fields are present, and ID3v2 tag names are output.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       With  "-e"  above 0, this script may consult environment variables "LC_CTYPE, LC_ALL, LANG" to deduce the
       current encoding.  Moreover, we try to auto-detect the "UTF-8" encoding via "LANG"  environment  variable
       (disabled  if "${^UNICODE}" sets translation of the command-line arguments).  (This auto-detection may be
       switched  off  by  the  variable  "MP3INFO_DECODE_ARGV_DEFAULT_RESET".)   The  effects  of  the  variable
       "MP3TAG_NORMALIZE_FIELDS"  is  described  in the section "Normalization of fields".  No other environment
       variables are directly read by this script.

       Note however, that MP3::Tag module has  a  rich  set  of  defaults  for  encoding  settings  settable  by
       environment  variables;  see  "ENVIRONMENT" in MP3::Tag.  So these variables affect (indirectly) how this
       script works.  In particular, starting with v1.14, there is an autodetection of encoding of  setup  files
       (which this script uses for the "-P" option).  (However, this autodetection may be switched off.)

</pre><h4><b>OBSOLETE</b> <b>INTERFACE</b></h4><pre>
       If you do not understand what it is about, it is safe to ignore this announcement:

       The  old, pre-version=1.05 way (by triplication of a separator, without repetition of options) to provide
       multiple commands to "-F" and &lt;-P&gt; options is still supported, but is strongly discouraged.  (It does not
       conflict with the current interface.)

</pre><h4><b>AUTHOR</b></h4><pre>
       Ilya Zakharevich &lt;<a href="mailto:cpan@ilyaz.org">cpan@ilyaz.org</a>&gt;.

</pre><h4><b>Utilities</b> <b>to</b> <b>create</b> <b>CDDB</b> <b>file</b></h4><pre>
       Good CD reapers (e.g., <u>cdda2wav</u> with option "cddb=0") create a CDDB file with fetched  information  -  as
       far as an Internet connection is present.  However, if not available, other options exist.

       The scripts (supplied with the distribution in <u>./examples</u>) can create a "stub" CDDB file basing on:

       <u>fulltoc2fake_cddb.pl</u>   a dump of a full TOC of a CD; create one, e.g., by

                                readcd -fulltoc dev=0,1,0 -f=audiocd

       <u>inf2fake_cddb.pl</u>       directory of <u>*.inf</u> files (e.g., created by <u>cdda2wav</u> without Internet connection);

       <u>dir_mp3_2fake_cddb.pl</u>  a directory of MP3 files ripped from a CD (via some guesswork).

       Passing  this  stub  to  the  script  <u>cddb2cddb.pl</u>,  it  can be transformed to a "filled" CDDB file via a
       connection to some online database.  Use "-r" option if multiple records in the  database  match  the  CD
       signature.

         fulltoc2fake_cddb audiocd.toc | cddb2cddb     &gt; audio.cddb
         inf_2fake_cddb                | cddb2cddb     &gt; audio.cddb
         dir_mp3_2fake_cddb            | cddb2cddb -r3 &gt; audio.cddb # 3rd record

       When  such  a CDDB file is present, it will be used by MP3::Tag module to deduce the information about an
       audio file.  This information is (by default, transparently) used by this script.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       MP3::Tag, MP3::Tag::ParseData, audio_rename, typeset_audio_dir

perl v5.36.0                                       2022-12-30                                       <u><a href="../man1p/MP3INFO2.1p.html">MP3INFO2</a></u>(1p)
</pre>
 </div>
</div></section>
</div>
</body>
</html>