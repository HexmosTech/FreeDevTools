<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scm - a Scheme Language Interpreter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/scm">scm_5f4-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       scm - a Scheme Language Interpreter

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>scm</b> [-a <u>kbytes</u> ] [-muvqib] [--version] [--help]
       [[-]-no-init-file] [--no-symbol-case-fold]
       [-p <u>int</u> ] [-r <u>feature</u> ] [-h <u>feature</u> ]
       [-d <u>filename</u> ] [-f <u>filename</u> ] [-l <u>filename</u> ]
       [-c <u>expression</u> ] [-e <u>expression</u> ] [-o <u>dumpname</u> ]
       [-- | - | -s] [ <u>filename</u> ] [ <u>arguments</u> <u>...</u>  ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Scm</u> is a Scheme interpreter.

       Upon  startup  <u>scm</u>  loads  the  file  specified  by  by  the environment variable SCM_INIT_PATH or by the
       parameter IMPLINIT in the makefile (or scmfig.h) if SCM_INIT_PATH is not defined.  The makefiles  attempt
       to set IMPLINIT to "Init.scm" in the source directory.

       Unless  the  option <u>-no-init-file</u> or <u>--no-init-file</u> occurs in the command line or if <u>scm</u> is being invoked
       as a script, "Init.scm" checks to see if there is  file  "ScmInit.scm"  in  the  path  specified  by  the
       environment  variable  HOME (or in the current directory if HOME is undefined).  If it finds such a file,
       then it is loaded.

       "Init.scm" then looks for command input from one of three sources: From an option on  the  command  line,
       from a file named on the command line, or from standard input.

</pre><h4><b>OPTIONS</b></h4><pre>
       The options are processed in the order specified on the command line.

       <b>-a</b><u>kbytes</u>
            specifies  that <u>scm</u> should allocate an initial heapsize of <u>kbytes.</u>  This option, if present, must be
            the first on the command line.

       <b>--no-init-file</b>
            Inhibits the loading of "ScmInit.scm" as described above.

       <b>--no-symbol-case-fold</b>
            Symbol (and identifier) names are case-sensitive.

       <b>-e</b><u>expression</u>

       <b>-c</b><u>expression</u>
            specifies that the scheme expression <u>expression</u> is to be evaluated.  These options are  inspired  by
            <u>perl</u>  and  <u>sh</u>  respectively.  On Amiga systems the entire option and argument need to be enclosed in
            quotes.  For instance "-e(newline)".

       <b>-r</b><u>feature</u>
            requires <u>feature.</u>  This will load a file from SLIB if that <u>feature</u> is  not  already  supported.   If
            <u>feature</u>  is  2,  3,  4, or 5 <u>scm</u> will require the features necessary to support R2RS, R3RS, R4RS, or
            R5RS, respectively.

       <b>-h</b><u>feature</u>
            provides <u>feature.</u>

       <b>-l</b><u>filename</u>

       <b>-f</b><u>filename</u>
            loads <u>filename.</u>  <u>Scm</u> will load the first (unoptioned) file named on the command line if no  -c,  -e,
            -f, -l, or -s option precedes it.

       <b>-d</b><u>filename</u>
            opens  (read-only)  the  extended relational database <u>filename.</u>  If <u>filename</u> contains initialization
            code, it will be run when the database is opened.

       <b>-o</b><u>dumpname</u>
            saves the current SCM session as the executable program <u>dumpname.</u>  This option  works  only  in  SCM
            builds supporting <b>dump.</b>

            If  options  appear on the command line after <u>-o</u> <u>dumpname,</u> then the saved session will continue with
            processing those options when it is invoked.  Otherwise the (new) command line is processed as usual
            when the saved image is invoked.

       <b>-p</b><u>level</u>
            sets the prolixity (verboseness) to <u>level.</u>  This is the same as the <u>scm</u> command (verbose <u>level</u> ).

       <b>-v</b>   (verbose mode) specifies that <u>scm</u> will print prompts, evaluation times, notice of loading files, and
            garbage collection statistics.  This is the same as <u>-p3.</u>

       <b>-q</b>   (quiet mode) specifies that <u>scm</u> will print no extra information.  This is the same as <u>-p0.</u>

       <b>-m</b>   specifies that subsequent loads,  evaluations,  and  user  interactions  will  be  with  R4RS  macro
            capability.   To  use a specific R4RS macro implementation from SLIB (instead of SLIB's default) put
            <u>-r</u> <u>macropackage</u> before <u>-m</u> on the command line.

       <b>-u</b>   specifies that subsequent loads, evaluations, and user  interactions  will  be  without  R4RS  macro
            capability.   R4RS  macro  capability can be restored by a subsequent <u>-m</u> on the command line or from
            Scheme code.

       <b>-i</b>   specifies that <u>scm</u> should run interactively.  That means that  <u>scm</u>  will  not  terminate  until  the
            <u>(quit)</u>  or <u>(exit)</u> command is given, even if there are errors.  It also sets the prolixity level to 2
            if it is less than 2.  This will print prompts, evaluation times, and notice of loading files.   The
            prolixity level can be set by subsequent options.  If <u>scm</u> is started from a tty, it will assume that
            it should be interactive unless given a subsequent <u>-b</u> option.

       <b>-b</b>   specifies  that  <u>scm</u>  should  run  non-interactively.   That  means  that  <u>scm</u>  will terminate after
            processing the command line or if there are errors.

       <b>-s</b>   specifies, by analogy with <u>sh,</u> that further options are to be treated as program arguments.

       <b>-</b>    <b>--</b> specifies that there are no more options on the command line.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       <b>SCM_INIT_PATH</b>
            is the pathname where <u>scm</u> will look for its initialization code.  The default is the file "Init.scm"
            in the source directory.

       <b>SCHEME_LIBRARY_PATH</b>
            is the SLIB Scheme library directory.

       <b>HOME</b> is the directory where "Init.scm" will look for the user initialization file "ScmInit.scm".

</pre><h4><b>SCHEME</b> <b>VARIABLES</b></h4><pre>
       <b>*argv*</b>
            contains the list of arguments to the program.  <u>*argv*</u> can change during argument processing.   This
            list is suitable for use as an argument to SLIB <u>getopt.</u>

       <b>*R4RS-macro*</b>
            controls whether loading and interaction support R4RS macros.  Define this in "ScmInit.scm" or files
            specified on the command line.  This can be overridden by subsequent -m and -u options.

       <b>*interactive*</b>
            controls  interactivity  as  explained  for  the -i and -b options.  Define this in "ScmInit.scm" or
            files specified on the command line.  This can be overridden by subsequent -i and -b options.

</pre><h4><b>EXAMPLES</b></h4><pre>
       % scm foo.scm arg1 arg2 arg3
            Load and execute the contents of foo.scm.  Parameters arg1 arg2 and arg3 are stored  in  the  global
            list *argv*.

       % scm -f foo.scm arg1 arg2 arg3
            The same.

       % scm -s foo.scm arg1 arg2
            Set *argv* to ("foo.scm" "arg1" "arg2") and enter interactive session.

       % scm -e '(display (list-ref *argv* *optind*))' bar
            Print ``bar''

       % scm -rpretty-print -r format -i
            Load pretty-print and format and enter interactive mode.

       % scm -r5
            Load dynamic-wind, values, and R4RS macros and enter interactive (with macros) mode.

       % scm -r5 -r4
            Like above but rev4-optional-procedures are also loaded.

</pre><h4><b>FEATURES</b></h4><pre>
       Runs  under Amiga, Atari-ST, MacOS, MS-DOS, OS/2, NOS/VE, Unicos, VMS, Unix and similar systems.  Support
       for ASCII and EBCDIC character sets.

       Conforms to Revised^5 Report on the Algorithmic Language Scheme and the IEEE P1178 specification.

       Support for SICP, R2RS, R3RS, and R4RS scheme code.

       Many Common Lisp functions: logand, logor, logxor, lognot, ash,  logcount,  integer-length,  bit-extract,
       defmacro, macroexpand, macroexpand1, gentemp, defvar, force-output, software-type, get-decoded-time, get-
       internal-run-time, get-internal-real-time, delete-file, rename-file, copy-tree, acons, and eval.

       Char-code-limit,    most-positive-fixnum,    most-negative-fixnum,   and   internal-time-units-per-second
       constants.  *Features* and *load-pathname* variables.

       Arrays and bit-vectors.  String ports and software emulation ports.  I/O  extensions  providing  most  of
       ANSI C and POSIX.1 facilities.

       User  definable  responses  to  interrupts and errors, Process-synchronization primitives, String regular
       expression matching, and the CURSES screen management package.

       Available add-on packages including an interactive debugger, database, X-window graphics,  BGI  graphics,
       Motif, and Open-Windows packages.

       A compiler (HOBBIT, available separately) and dynamic linking of compiled modules.

       Setable  levels  of  monitoring  and  timing  information printed interactively (the `verbose' function).
       Restart, quit, and exec.

</pre><h4><b>FILES</b></h4><pre>
       scm.texi
              Texinfo documentation of <u>scm</u> enhancements, internal representations, and how to extend or  include
              <u>scm</u> in other programs.

</pre><h4><b>AUTHORS</b></h4><pre>
       Aubrey Jaffer (<a href="mailto:agj@alum.mit.edu">agj@alum.mit.edu</a>)
       Radey Shouman

</pre><h4><b>BUGS</b></h4><pre>
</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The SCM home-page:
       <a href="http://people.csail.mit.edu/jaffer/SCM.html">http://people.csail.mit.edu/jaffer/SCM.html</a>

       The        Scheme        specifications        for       details       on       specific       procedures
       (<a href="http://groups.csail.mit.edu/mac/ftpdir/scheme-reports">http://groups.csail.mit.edu/mac/ftpdir/scheme-reports</a>) or

       IEEE Std 1178-1990,
       IEEE Standard for the Scheme Programming Language,
       Institute of Electrical and Electronic Engineers, Inc.,
       New York, NY, 1991

       Brian Harvey and Matthew Wright
       Simply Scheme: Introducing Computer Science_
       MIT Press, 1994 ISBN 0-262-08226-8

       R. Kent Dybvig, The Scheme Programming Language,
       Prentice-Hall Inc, Englewood Cliffs, New Jersey 07632, USA

       H. Abelson, G. J. Sussman, and J. Sussman,
       Structure and Interpretation of Computer Programs,
       The MIT Press, Cambridge, Massachusetts, USA

4th Berkeley Distribution                         February 2008                                           <u><a href="../man1/SCM.1.html">SCM</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>