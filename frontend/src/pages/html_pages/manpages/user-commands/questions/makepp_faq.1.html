<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>makepp_faq -- Frequently asked questions about makepp</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/makepp">makepp_2.0.98.5-2.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       makepp_faq -- Frequently asked questions about makepp

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Here you may find installation instructions and some points which are not obvious from the rest of the
       documentation.  This shows stumbling blocks, whereas howto type questions will be found in the cookbook.

   <b>Getting</b> <b>Started</b>
       <u>Where</u> <u>to</u> <u>download?</u>

       Makepp is hosted on SourceForge and can be downloaded as a source code tarball or as installation package
       for Debian <u>.deb</u> based Linuxes or <u>.rpm</u> based Linuxes from <a href="http://sourceforge.net/projects/makepp/files/">http://sourceforge.net/projects/makepp/files/</a>

       Like tons of Perl software, makepp can also be downloaded from CPAN by clicking the Download link on
       <a href="http://search.cpan.org/dist/makepp/">http://search.cpan.org/dist/makepp/</a>

       Makepp is part of Debian GNU/Linux unstable and testing.  This means you can install it directly via
       "apt-get install makepp" or by choosing it from your preferred package tool like synaptic.

       Makepp is part of archlinux and of Gentoo Linux.  Note that distro-specific suffixes like 2.0-1 or 2.0-r1
       is not the release candidate 1, but the final released version 2.0.

       <u>Can</u> <u>I</u> <u>try</u> <u>it</u> <u>without</u> <u>installing?</u>

       Yes, if you want to try makepp on your own makefiles, either put the directory where you unpacked it into
       your path, or else run it explicitly like this, with an absolute or relative path to makepp:

           perl /where/you/unpacked/it/makepp

       <u>How</u> <u>to</u> <u>choose</u> <u>perl</u> <u>version?</u>

       You must have Perl 5.8 or newer somewhere on your system.  By default all uninstalled scripts will use
       the "perl" in your path.  But you can run them with an explicit instance of perl.  The test runner and
       installation will run everything with this same instance.

           /path/to/perl /where/you/unpacked/it/makepp

       In case some script doesn't properly recognize which "perl" it is being run with, you can help it by
       telling it the path to the same instance of perl via the "PERL" variable:

           PERL=/path/to/perl /path/to/perl /where/you/unpacked/it/makepp

       This can also be an instance to be searched in your path, if it doesn't contain a directory separator:

           PERL=perl5.16.2 perl5.16.2 /where/you/unpacked/it/makepp

       <u>How</u> <u>to</u> <u>install?</u>

       There are two ways to install, which lead to the same result:

       configure (alias config.pl)
           This allows for traditional style installation:

               ./configure &amp;&amp; make test &amp;&amp; make install

           The  only  difference  between  these  two is that "configure" is not a Perl script, so you can't say
           "perl configure", whereas you can use all the above variants like "perl  config.pl".   Valid  options
           are:

           -b, --bindir=<u>/path/to/installation/bin</u>
               Where the binaries go (default: <u>prefix</u><a href="file:/bin">/bin</a>).  Makepp's binaries are just Perl scripts so they are
               architecture  independent.   If  you  give  this option, but no "--prefix", it will strip <u><a href="file:/bin">/bin</a></u> to
               deduce a <u>prefix</u> for the other default values.

           -d, --datadir=<u>/path/to/installation/share/makepp</u>
               Where to install makepp's library files (default: <u>prefix</u>/share/makepp).

           -f, --findbin=<u>relative/path/to/datadir/from/bindir</u>
               Where to find libraries relative to executables, or 'none' (the default) to find them in <u>datadir</u>.

           -h, --htmldir=<u>/path/to/installation/share/html</u>
               Where the  HTML  documentation  goes  (default:  <u>prefix</u>/doc/makepp  if  <u>prefix</u>/doc  exists,  else
               <u>datadir</u>/html), or 'none' if you do not want it installed.

           -m, --mandir=/<u>path/to/man</u>
               Where  the  manual pages should reside (default: <u>prefix</u>/share/man if it exists, else <u>prefix</u>/man),
               or 'none' if you do not want them installed.

           --makefile=<u>/path/to/Makefile</u>
               Specify location where you can write the Makefile (default: .).  Unlike the other options,  which
               are remembered for the following install step, this file is created immediately.

           -p, --prefix=<u>/path/to/installation</u>
               Specify location where you want to install everything (default: <a href="file:/usr/local">/usr/local</a>).  All other paths are
               by default relative to this one.

           -V
           --version
               Print out the version number.

           If  you want to do a mockup installation to some destdir for packaging your own distribution, you can
           give an extra parameter to the last command:

               make DESTDIR=/temporary/destdir install

       install.pl
           This is the backend that performs the actual installation.  You can call it directly:

               ./install.pl bindir datadir mandir htmldir findbin destdir

           The parameters are optional and correspond to  the  options  from  the  previous  section.   You  are
           prompted for those you don't supply, except for the last one, which is not normally needed.

       <u>Makefile.PL</u>
           The customary file <u>Makefile.PL</u> is currently only present for technical reasons.  It will <b>not</b> help you
           to install.  Therefore, alas, you can't use tools like "cpanm" to install in one go.

       On  some  systems  whichever  "perl"  you  end  up calling may be a symbolic link to some precise version
       "perl5.m.n".  In this case perl sees only that one, and will thus use it  to  install  against.   If  you
       don't  want  that,  use  the "PERL" variable as described above.  If you install with the second variant,
       i.e. just the name of the executable without slashes, the installed scripts will always search  for  that
       one via "<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?env">/usr/bin/env</a>".  This makes them a tiny bit slower to start, for a greater flexibility.

       <u>Why</u> <u>does</u> <u>installation</u> <u>say</u> <u>permission</u> <u>denied?</u>

       If  you  want to install to a system directory like <u><a href="file:/usr">/usr</a></u>, <u><a href="file:/usr/local">/usr/local</a></u> or <u><a href="file:/opt">/opt</a></u>, you can only do that if you
       run the installation as user root.  On many Unices you can run a command as root, by prepending "sudo" to
       it, and depending on the system entering the either the root password, or yours, as prompted for.

       This is not necessary for the preparatory "configure" or "config.pl" step which only writes a <u>Makefile</u> in
       the current directory.

   <b>Build</b> <b>Questions</b>
       <u>What</u> <u>are</u> <u>unimportant</u> <u>targets?</u>

       Makepp remembers the dependencies of every file.  If any of them need to be rebuilt, that  will  be  done
       before  rescanning.   But  if the build failed, yet the scan succeeds, because the file isn't even needed
       anymore, then at the end the failure  will  be  reported  as  unimportant.   (The  build  should  not  be
       attempted,  instead  letting  the  rescan do those builds it finds to be necessary, but that happens in a
       different place, so this would be difficult.)

       <u>Why</u> <u>does</u> <u>it</u> <u>run</u> <u>this</u> <u>rule</u> <u>3</u> <u>times?</u>

       GNU make has no makepp style multi target rules.  Instead it interprets this  as  a  shortcut  for  three
       separate rules:

           a b c:
               echo $@
               touch a b c

       However,  it doesn't check why a file is there.  If a file exists (and is newer than any dependencies) it
       is happy.  Whichever of the three files gets built  first,  provides  the  other  two,  so  this  behaves
       somewhat like a multitarget rule -- but can cause race conditions in parallel builds.

       A similar rule might have been:

           a b c:
               touch $@

       Gmake  indeed runs this one once per required file.  Without knowing what the command does (it might be a
       script which internally creates some files), the two cases can't easily be told apart by makepp.

       So as a special compatibility fallback, if a multi target rule action mentions  only  old  style  $@  and
       neither  new  style  "$(output)" nor "$(target)" nor their plural forms, it is treated as separate rules.
       This however means running it repeatedly, as makepp ignores randomly appearing files for which it has  no
       metadata.

       <u>Why</u> <u>does</u> <u>it</u> <u>complain</u> <u>that</u> <u>a</u> <u>created</u> <u>file</u> <u>is</u> <u>phony?</u>

       If  you  have  a  command that continues working asynchronously, after it came back with a success return
       code, makepp will notice the promised file as missing and complain.  This can also  typically  happen  on
       some network file systems, which may physically write only several seconds later.

       If  you  cannot  evite such an unsatisfactory situation, you can ask makepp to be sloppy about this check
       with the "--gullible" option.  But then the next command which depends on the produced file  might  still
       fail.

       <u>Why</u> <u>does</u> <u>it</u> <u>recreate</u> <u>files</u> <u>unnecessarily?</u>

       I  have  observed this on NFS, where due to file attribute caching the timestamp of the produced file was
       not yet the one the it finally had.  On the next run makepp noticed the  difference  and  considered  the
       file  unduly  modified.  This got resolved with a mount option of "acregmin=0", making attributes visible
       immediately.

       This can also happen with repositories, e.g. if someone else has built in the repository with "umask 066"
       or using a compiler that bars others from reading the produced file.  This will also happen if either the
       repository or your build tree shares a common path prefix with some  dependencies  (e.g.  <u>/opt/repository</u>
       and  <u>/opt/sometool</u>,  in  which case makepp will remember the path once as relative, and once as absolute,
       looking like changed dependencies.

       <u>Does</u> <u>the</u> <u>C</u> <u>source</u> <u>file</u> <u>or</u> <u>the</u> <u>object</u> <u>file</u> <u>depend</u> <u>on</u> <u>headers?</u>

       It depends on your viewpoint.  If a prototype in a header changes, the programmer may have to  adapt  the
       source code.  So from that viewpoint there is a dependency.

       But  for  the  build  this is completely irrelevant.  Here the outputs depend on the inputs.  If a header
       file changes this may affect the object file (e.g. addition of parameters with default values, which  the
       programmer  may  ignore, but not the compiler).  So from makepp's viewpoint only the produced object file
       depends on the headers, i.e. must be rebuilt when these change.

   <b>Miscellaneous</b>
       <u>Why</u> <u>does</u> <u>makepp</u> <u>selectively</u> <u>detect</u> <u>dependencies?</u>

       In this rule why does makepp make <u>output</u> depend on <u>input1</u>, but not on <u>input2</u>?

           output:
               zcat &lt;input1 &gt;output
               zcat input2 &gt;&gt;output

       There are three levels to scanning.  The first is the lexer, which tries to understand the Shell part  of
       the execution.  I.e. which commands get called and what I/O redirections take place.  This notices <u>input1</u>
       and <u>output</u> (even if it had not been declared a target of this rule).

       The  next  step are the command parsers.  Makepp has a few for typical compilation commands.  These check
       the command line options to  understand  what  the  command  will  do.   In  the  process  they  pick  up
       dependencies  like  libraries  ("cc  -llib"),  include paths ("cc -Idir") and input files.  The task of a
       "zcat" parser would be to know that "-S" takes an argument, but all other non option words are  filenames
       (optionally suffixed by <u>.gz</u>), and that "--" ends options.  Alas there is no such parser, no more than for
       hundreds of other commands.

       The  third  step  for  some  languages  is  the  scanning  of  input files, to detect includes as further
       dependencies.  This does not apply to this example.

       <u>How</u> <u>can</u> <u>I</u> <u>debug</u> <u>makepp?</u>

       You can put "$(print )" around a suspicious expression.  This returns  the  unchanged  expression,  while
       printing it as a side effect.

       You   can   dump   the  current  directory's  (multiply  after  "-C"  if  you  want)  makefile  with  the
       "--dump-makefile=file" option, to see how makepp sees it.

       Makepp writes a log of everything it does and why.   You  can  look  at  that  with  makepplog,  mppl  or
       makeppgraph, mppg.  You can make it more verbose by setting the environment variable "MAKEPP_DEBUG".

       Makepp  records all it knows about a file, for reuse on the next run.  Though it takes some understanding
       of makepp's internals, dumping it with makeppinfo, mppi for one or more files, usually gives a clue  what
       is wrong.  "MAKEPP_DEBUG" additionally provides the "RULE_SOURCE".

       If  you  are  feeling adventurous, use makepp from cvs.  This includes extra modules that hook into "perl
       -d" to better display makepp's internals.

       <u>Is</u> <u>it</u> <u>safe</u> <u>to</u> <u>use?</u>

       <b>Yes</b>, it will do exactly what your makefiles say (which many programmers find hard  to  understand,  since
       rule based inference is very different from most programming paradigms).

       <b>And</b>  <b>no</b>, if you don't trust the makefiles you got, definitely not!  A makefile is a funny kind of script,
       the purpose of which is to run commands that are expected to modify your  file  system.   Makepp  has  no
       means of checking what harm they will do.

       Worse,  there  are execute always syntaxes, which are performed even with "--dry-run" (which does not run
       the rules, but evaluates everything else).  That might be something like this:

           bad_boy := $(shell rm *)

   <b>External</b> <b>tools</b>
       <u>Can</u> <u>I</u> <u>use</u> <u>cc</u> <u>-M</u> <u>or</u> <u>gcc</u> <u>-MM?</u>

       The short answer is yes.  The long answer is that they have the advantage of knowing the effect  of  even
       the last weird compiler option, and sub-includes hidden in some compiler internal directory, where makepp
       only  comes pretty close.  The disadvantage is that they have no idea of the build rules, so they can not
       reliably depend on yet to-be-built files, which includes files to be fetched from a repository.  And they
       are not extensible to other languages, as makepp's scanner is.  Usually you are at least as well off, not
       resorting to these tools.

       Nonetheless, some compilers can produce this as a by-product.  If you'd rather use this see :include.

       <u>Can</u> <u>I</u> <u>use</u> <u>CCache,</u> <u>Compilercache</u> <u>or</u> <u>cachecc1?</u>

       The short answer is yes.  The long answer is that these programs need to repeat the work makepp does,  to
       get a reliable fingerprint of files.  With traditional makes this even comes too late, because those miss
       many  situations  calling  for  a recompilation.  With makepp it is just easier to use the built in build
       cache, which has the added advantage that it can handle all kinds of files.

       Note that ccache direct mode has a bug https://bugzilla.samba.org/show_bug.cgi?id=8728 that  will  ignore
       change  in  include  pathes.   This  makes  <u>t/makeppreplay.test</u>  fail  with  "wrong  file:  out".  Export
       "CCACHE_NODIRECT=1" to avoid that.

</pre><h4><b>AUTHOR</b></h4><pre>
       Daniel Pfeiffer (<a href="mailto:occitan@esperanto.org">occitan@esperanto.org</a>)

perl v5.32.0                                       2021-01-06                                      <u><a href="../man1/MAKEPP_FAQ.1.html">MAKEPP_FAQ</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>