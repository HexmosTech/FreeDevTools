<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scrub - write patterns on disk/file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/scrub">scrub_2.6.1+git20240819.9b4267e-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       scrub - write patterns on disk/file

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>scrub</b> <u>[OPTIONS]</u> <u>special-file</u> <u>[special-file</u> <u>...]</u>
       <b>scrub</b> <u>[OPTIONS]</u> <u>file</u> <u>[file</u> <u>...]</u>
       <b>scrub</b> <u>-X</u> <u>[OPTIONS]</u> <u>directory</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Scrub</b>  iteratively  writes  patterns on files or disk devices to make retrieving the data more difficult.
       <b>Scrub</b> operates in one of three modes:

       1) The special file corresponding to an entire disk is scrubbed and all data on it  is  destroyed.   This
       mode is selected if <u>file</u> is a character or block special file.  This is the most effective method.

       2)  A  regular  file  is scrubbed and only the data in the file (and optionally its name in the directory
       entry) is destroyed.  The file size is rounded up to fill out the last file system block.  This  mode  is
       selected if <u>file</u> is a regular file.  See CAVEATS below.

       3) A temporary directory is created under <u>directory</u> (which must exist) and is filled with files until the
       file  system  is  full.   Then the files are scrubbed as in 2). This mode is selected with the <u>-X</u> option.
       See CAVEATS below.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>Scrub</b> accepts the following options:

       <u>-v</u>, <u>--version</u>
              Print scrub version and exit.

       <u>-r</u>, <u>--remove</u>
              Remove the file after scrubbing.

       <u>-p</u>, <u>--pattern</u> <u>PATTERN</u>
              Select the patterns to write.  See SCRUB METHODS below.  The  default,  <u>nnsa</u>,  is  reasonable  for
              sanitizing modern PRML/EPRML encoded disk devices.

       <u>-b</u>, <u>--blocksize</u> <u>blocksize</u>
              Perform  <a href="../man2/read.2.html">read</a>(2)  and  <a href="../man2/write.2.html">write</a>(2) calls using the specified blocksize (in bytes).  <u>K,</u> <u>M,</u> or <u>G</u> may be
              appended to the number to  change  the  units  to  KiBytes,  MiBytes,  or  GiBytes,  respectively.
              Default: 4M.

       <u>-f</u>, <u>--force</u>
              Scrub even if target contains signature indicating it has already been scrubbed.

       <u>-S</u>, <u>--no-signature</u>
              Do  not write scrub signature.  Later, <b>scrub</b> will not be able to ascertain if the disk has already
              been scrubbed.

       <u>-X</u>, <u>--freespace</u>
              Create specified directory and fill it with files until write returns ENOSPC (file  system  full),
              then scrub the files as usual.  The size of each file can be set with <u>-s</u>, otherwise it will be the
              maximum file size creatable given the user's file size limit or 1g if unlimited.

       <u>-D</u>, <u>--dirent</u> <u>newname</u>
              After  scrubbing  the file, scrub its name in the directory entry, then rename it to the new name.
              The scrub patterns used on the directory entry are constrained by the operating  system  and  thus
              are not compliant with cited standards.  This option only works with a single target.

       <u>-s</u>, <u>--device-size</u> <u>size</u>
              Override  the  device  size (in bytes). Without this option, <b>scrub</b> determines media capacity using
              OS-specific <a href="../man2/ioctl.2.html">ioctl</a>(2) calls.  <u>K,</u> <u>M,</u> or <u>G</u> may be appended to the  number  to  change  the  units  to
              KiBytes, MiBytes, or GiBytes, respectively.

       <u>-L</u>, <u>--no-link</u>
              If  <u>file</u>  is a symbolic link, do not scrub the link target.  Do remove it, however, if <u>--remove</u> is
              specified.

       <u>-R</u>, <u>--no-hwrand</u>
              Don't use a hardware random number generator even if one is available.

       <u>-t</u>, <u>--no-threads</u>
              Don't generate random data in parallel with I/O.

       <u>-n</u>, <u>--dry-run</u>
              Do everything but write to targets.

       <u>-h</u>, <u>--help</u>
              Print a summary of command line options on stderr.

</pre><h4><b>SCRUB</b> <b>METHODS</b></h4><pre>
       <u>nnsa</u>   4-pass NNSA Policy Letter NAP-14.1-C (XVI-8)  for  sanitizing  removable  and  non-removable  hard
              disks,  which requires overwriting all locations with a pseudorandom pattern twice and then with a
              known pattern: <b>random(x2),</b> <b>0x00,</b> <b>verify</b>.

       <u>dod</u>    4-pass DoD 5220.22-M section 8-306 procedure (d) for sanitizing removable and non-removable  rigid
              disks  which  requires  overwriting  all addressable locations with a character, its complement, a
              random character, then verify.  NOTE: <b>scrub</b> performs the random pass first  to  make  verification
              easier: <b>random,</b> <b>0x00,</b> <b>0xff,</b> <b>verify</b>.

       <u>bsi</u>    9-pass   method  recommended  by  the  German  Center  of  Security  in  Information  Technologies
              (<a href="http://www.bsi.bund.de">http://www.bsi.bund.de</a>): <b>0xff,</b> <b>0xfe,</b> <b>0xfd,</b> <b>0xfb,</b> <b>0xf7,</b> <b>0xef,</b> <b>0xdf,</b> <b>0xbf,</b> <b>0x7f</b>.

       <u>gutmann</u>
              The canonical 35-pass sequence described in Gutmann's paper cited below.

       <u>schneier</u>
              7-pass method described by Bruce Schneier in "Applied Cryptography" (1996): <b>0x00,</b> <b>0xff,</b> <b>random(x5)</b>

       <u>pfitzner7</u>
              Roy Pfitzner's 7-random-pass method: <b>random(x7)</b>.

       <u>pfitzner33</u>
              Roy Pfitzner's 33-random-pass method: <b>random(x33)</b>.

       <u>usarmy</u> US Army AR380-19 method: <b>0x00,</b> <b>0xff,</b> <b>random</b>.  (Note:  identical  to  DoD  522.22-M  section  8-306
              procedure (e) for sanitizing magnetic core memory).

       <u>fillzero</u>
              1-pass pattern: <b>0x00</b>.

       <u>fillff</u> 1-pass pattern: <b>0xff</b>.

       <u>random</u> 1-pass pattern: <b>random(x1)</b>.

       <u>random2</u>
              2-pass pattern: <b>random(x2)</b>.

       <u>old</u>    6-pass pre-version 1.7 scrub method: <b>0x00,</b> <b>0xff,</b> <b>0xaa,</b> <b>0x00,</b> <b>0x55,</b> <b>verify</b>.

       <u>fastold</u>
              5-pass pattern: <b>0x00,</b> <b>0xff,</b> <b>0xaa,</b> <b>0x55,</b> <b>verify</b>.

       <u>custom=string</u>
              1-pass custom pattern.  String may contain C-style numerical escapes: \nnn (octal) or \xnn (hex).

</pre><h4><b>CAVEATS</b></h4><pre>
       <b>Scrub</b>  may be insufficient to thwart heroic efforts to recover data in an appropriately equipped lab.  If
       you need this level of protection, physical destruction is your best bet.

       The effectiveness of scrubbing regular files through a file system will be limited by  the  OS  and  file
       system.   File  systems  that  are  known to be problematic are journaled, log structured, copy-on-write,
       versioned, and network file systems.  If in doubt, scrub the raw disk device.

       Scrubbing free blocks in a file system with the <u>-X</u> method is subject to the  same  caveats  as  scrubbing
       regular files, and in addition, is only useful to the extent the file system allows you to reallocate the
       target blocks as data blocks in a new file.  If in doubt, scrub the raw disk device.

       On  MacOS  X  HFS file system, <b>scrub</b> attempts to overwrite a file's resource fork if it exists.  Although
       MacOS X claims it will support additional named  forks  in  the  future,  <b>scrub</b>  is  only  aware  of  the
       traditional data and resource forks.

       <b>scrub</b>  cannot access disk blocks that have been spared out by the disk controller.  For SATA/PATA drives,
       the ATA "security erase" command built into the  drive  controller  can  do  this.   Similarly,  the  ATA
       "enhanced  security  erase"  can  erase data on track edges and between tracks.  The DOS utility HDDERASE
       from the UCSD Center for Magnetic Recording Research can issue these commands, as can modern versions  of
       Linux  <b>hdparm</b>.   Unfortunately,  the analogous SCSI command is optional according to T-10, and not widely
       implemented.

</pre><h4><b>EXAMPLES</b></h4><pre>
       To scrub a raw device <u>/dev/sdf1</u> with default NNSA patterns:

              # scrub /dev/sdf1
              scrub: using NNSA NAP-14.1-C patterns
              scrub: please verify that device size below is correct!
              scrub: scrubbing /dev/sdf1 1995650048 bytes (~1GB)
              scrub: random  |................................................|
              scrub: random  |................................................|
              scrub: 0x00    |................................................|
              scrub: verify  |................................................|

       To scrub the file <u>/tmp/scrubme</u> with a sequence of 0xff 0xaa bytes:

              # scrub -p custom="\xff\xaa" /tmp/scrubme
              scrub: using Custom single-pass patterns
              scrub: scrubbing /tmp/scrubme 78319616 bytes (~74MB)
              scrub: 0xffaa  |................................................|

</pre><h4><b>AUTHOR</b></h4><pre>
       Jim Garlick &lt;<a href="mailto:garlick@llnl.gov">garlick@llnl.gov</a>&gt;

       This work was produced at the University of California,  Lawrence  Livermore  National  Laboratory  under
       Contract No. W-7405-ENG-48 with the DOE.  Designated UCRL-CODE-2003-006, scrub is licensed under terms of
       the GNU General Public License.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       DoD 5220.22-M, "National Industrial Security Program Operating Manual", Chapter 8, 01/1995.

       NNSA  Policy  Letter: NAP-14.1-C, "Clearing, Sanitizing, and Destroying Information System Storage Media,
       Memory Devices, and other Related Hardware", 05-02-08, page XVI-8.

       "Secure Deletion of Data from Magnetic and Solid-State Memory", by Peter Gutmann, Sixth  USENIX  Security
       Symposium, San Jose, CA, July 22-25, 1996.

       "Gutmann Method", Wikipedia, <a href="http://en.wikipedia.org/wiki/Gutmann_method">http://en.wikipedia.org/wiki/Gutmann_method</a>.

       Darik's boot and Nuke FAQ: <a href="http://dban.sourceforge.net/faq/index.html">http://dban.sourceforge.net/faq/index.html</a>

       "Tutorial on Disk Drive Data Sanitization", by Gordon Hugues and Tom Coughlin,
       <a href="http://cmrr.ucsd.edu/people/Hughes/DataSanitizationTutorial.pdf">http://cmrr.ucsd.edu/people/Hughes/DataSanitizationTutorial.pdf</a>.

       "Guidelines for Media Sanitization", NIST special publication 800-88, Kissel et al, September, 2006.

       <a href="../man1/shred.1.html">shred</a>(1), <a href="../man8/hdparm.8.html">hdparm</a>(8)

scrub-2.6.1+git20240819.9b4267e                                                                         <u><a href="../man1/scrub.1.html">scrub</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>