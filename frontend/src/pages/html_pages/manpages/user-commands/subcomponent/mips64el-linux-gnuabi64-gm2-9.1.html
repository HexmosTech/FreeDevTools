<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gm2 - The GNU Modula-2 compiler.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/noble/+package/gm2-9-mips64el-linux-gnuabi64">gm2-9-mips64el-linux-gnuabi64_9.5.0-6ubuntu2cross1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gm2 - The GNU Modula-2 compiler.
       gm2l - GNU Modula-2 linker subcomponent.
       gm2lcc - GNU Modula-2 linker subcomponent.
       gm2lgen - GNU Modula-2 linker subcomponent.
       gm2lsub - GNU Modula-2 linker subcomponent.
       gm2m - GNU Modula-2 makefile generator.
       h2def - Transform a 'C' header file into a Modula-2 definition file.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>NOTE:</b> This document manual page may be out of date, check the texinfo file.

       <u>GNU</u>  <u>Modula-2</u>  is  a front end ⟨<a href="http://gcc.gnu.org/frontends.html">http://gcc.gnu.org/frontends.html</a>⟩ for GCC (the GNU Compiler Collection).
       GCC contains a retargetable C compiler which has been ported to  a  large  number  of  architectures  and
       operating  systems.  <u>GNU</u> <u>Modula-2</u> utilizes the back end of GCC and replaces the C language front end with
       a Modula-2 one.

       The <u>GNU</u> <u>Modula-2</u> front end can perform a substantial amount of static analysis of the  source  code  (see
       `<u>-Wpedantic</u>', `<u>-Wpedantic-param-names</u>', `<u>-Wstudents</u>', and `<u>-Wpedantic-cast</u>').

       Finally  runtime  checking  has  been  implemented  and can check: bounds of subranges and array indexes,
       functions execute a '<b>RETURN</b>' statement, a pointer does not dereference a '<b>NIL</b>' pointer  value,  and  that
       the expression within a '<b>CASE</b>' statement is correctly matched.

       There  are currently three sets of libraries. The '<u>Programming</u> <u>in</u> <u>Modula-2</u>' libraries, the '<u>University</u> <u>of</u>
       <u>ULM</u> <u>libraries</u>' and the <u>ISO</u> libraries.  The ISO libraries are still being written, however all  definition
       modules for the three library sets are contained within this document.

       <u>GNU</u> <u>Modula-2</u> also has the advantage of being closely tied to <u>GCC</u> (the GNU Compiler Collection.)  Not only
       does  this  produce excellent code and excellent architectural and operating system coverage, but it also
       utilizes many of the <u>GCC</u> features.  For example, <u>GNU</u> <u>Modula-2</u> can invoke the  C  preprocessor  to  manage
       conditional  compilation;  inlining  of `<b>SYSTEM</b>' procedures, intrinsic functions, memory copying routines
       are also exploited; access to assembly language using GCC syntax is also  provided.   <u>GNU</u>  <u>Modula-2</u>  also
       supports sets of any ordinal type (memory permitting).

       <u>GNU</u>  <u>Modula-2</u>  Reads source code from files containing either: (1) definition modules, (2) implementation
       modules, (3) main body module.  Definition modules usually use the standard extension  <u>'.def'</u>.   Whereas,
       implementation  and  main  body  modules use the standard extension <u>'.mod'</u>.  When using legacy code which
       worked with a different compiler, other extensions may have been used.   <u>GNU</u>  <u>Modula-2</u>  can  be  told  to
       search  for  those  extension first , before defaulting to the standard extensions.  For example, use the
       command line options: '<u>-fdef=.d2</u> <u>-fmod=.m2</u>'.

       <u>GNU</u> <u>Modula-2</u> imports definition modules by reading the definition module file every time  (similar  to  C
       including  .h  header  files).   Traditional  Modula-2  compilers  would require the compilation of every
       definition module into a symbol file before any import of symbols from that definition module.

   <b>Purpose</b>
       It is expected that the primary purpose of <u>GNU</u> <u>Modula-2</u> will be to compile legacy code.  Currently  there
       are  only  a  few commercial Modula-2 compilers being actively maintained.  Code which was written ten or
       fifteen years ago may still be compiled by older commercial (possibly unmaintained) compilers.

       While the 32 bit x86 remains these compilers presumably can be run in compatibility mode (some  compilers
       only  produced  16  bit  code).   Time  is  running  out  as  the  computing  industry is switching to 64
       microprocessors. While x86 emulation or 16 bit backwards compatibility is always  possible  it  has  some
       serious drawbacks.

       In  order  for  the  older  source to run natively the source code will either have to be translated into
       another high level language or alternatively a Modula-2 compiler which can target these new generation of
       microprocessors will have to be acquired.

   <b>Current</b> <b>State</b>
       Currently <u>GNU</u> <u>Modula-2</u> (0.49) implements all PIM dialects of the language, eventually <u>GNU</u>  <u>Modula-2</u>  will
       be  fully  compliant with ISO Modula-2.  It has been built on i[3456]86 GNU/Linux, i[3456]86 BSD, Opteron
       LP64 GNU/Linux and sparc GNU/Linux systems.  It has also been built as a cross  compiler  for  MinGW  and
       StrongARM GNU/Linux.

       <u>GNU</u>  <u>Modula-2</u>  builds  and  passes all its regression tests on Debian Pure 64 (LP64 architecture), 64 bit
       Solaris, 32 bit x86 GNU/Linux (Suse 9.1, Debian, stable and unstable) and 32 bit x86 FreeBSD.

       Work is underway to build and test it on DARWIN/i386, and DARWIN/powerpc.

       There is even a project to extend <u>GNU</u> <u>Modula-2</u> with object oriented  constructs  similar  to  <b>Objective-C</b>
       called '<u>Objective</u> <u>Modula-2</u>' , or <u>objM2</u> for short.

</pre><h4><b>OPTIONS</b></h4><pre>
       This section describes the compiler's command line options specific to <u>GNU</u> <u>Modula-2</u>, although many of the
       standard  options  are  documented here.  For details on generic options see the manual page for <u>gcc</u> (The
       GNU C Compiler), and other members of the GNU Compiler Collection.

   <b>Overall</b> <b>Options</b>
       <u>--help</u> Print (on the standard output) a description of the command line options understood by <b>gm2</b> If  the
              -v option is also specified then --help will also be passed on to the various processes invoked by
              <b>gm2</b>,  so  that  they  can  display the command line options they accept.  If the <u>-f</u> option is also
              specified then command line options which have no documentation associated with them will also  be
              displayed.

       <u>--target-help</u>
              Print  (on  the  standard  output)  a description of target specific command line options for each
              tool.

       <u>--version</u>
              Display the version number and copyrights of the invoked GCC.

       <u>-c</u>     Compile and assemble the source files, but do not link.  The linking stage  simply  is  not  done.
              The ultimate output is in the form of an object file for each source file.

       <u>-E</u>     Stop  after the preprocessing stage; do not run the compiler proper.  The output is in the form of
              preprocessed source code, which is sent to the standard output.

       <u>-g</u>     Insert debugging symbols into the object files, and executable.  <b>NOTE:</b> When using the debugger, it
              may be useful to not optimize at a high level.

       <u>-I</u>path Adds an include path.  The <u>GNU</u> <u>Modula-2</u> compiler needs to import symbols  from  definition  module
              files.  It include's the definition file, rather than reading a symbol file.

       <u>-On</u>    Set  the  optimization  level  and  kind.   <u>-Os</u>  optimizes  for size (desiring small executables).
              <u>-O</u>,<u>-O1</u>,<u>-O2</u>, ..., <u>-O6</u> optimize for speed, with  increasingly  powerful  techniques,  such  as  loop
              unrolling and reordering of code.  When debugging, only use <u>-O</u> or at the most <u>-O1</u>.

       <u>-o</u> <u>file</u>
              Place  output in file <u>file</u>.  This applies regardless to whatever sort of output is being produced,
              whether it be an executable file, an object file, an assembler file, or preprocessed C code.

              Since only one output file can be specified, it does not make sense to use <u>-o</u> when compiling  more
              than one input file, unless you are producing an executable file as output.

              If  <u>-o</u>  is  not  specified, the default is to put an executable file in a.out, the object file for
              source.suffix in source.o, its assembly language file in <u>source.s</u>, and all preprocessed  C  source
              on standard output.

       <u>-S</u>     Preprocess and compile the source code, but to not assemble.  Do not delete the temporary assembly
              language file.  Stop after the stage of compilation proper; do not assemble.  The output is in the
              form of an assembly language code file for each non-assembler input file specified.

       <u>-v</u>     Verbosely  display  all calls to subsidiary programs, such as the C preprocessor, the <u>GNU</u> <u>Modula-2</u>
              compiler and linker.  Also print the version of the compiler, and which <u>specs</u> file it is using.

       <u>-fcpp</u>  Preprocess the source with `<u>cpp</u> <u>-lang-asm</u>  <u>-traditional-cpp</u>'.   If  <u>-fcpp</u>  is  supplied  then  all
              definition modules and implementation modules which are parsed will be preprocessed by `<u>cpp</u>'.

       <u>-fdef=</u> Recognize  the  specified  suffix  as a definition module filename.  The default definition module
              filename suffix is `.def'.  If this option is used <u>GNU</u> <u>Modula-2</u>  will  still  fall  back  to  this
              default if a requested definition module is not found.

       <u>-fmod=</u> Recognize the specified suffix as implementation and module filenames.  The default implementation
              and module filename suffix is `.mod'.  If this option is used <u>GNU</u> <u>Modula-2</u> will still fall back to
              this default if it needs to read an implementation module and the specified suffixed filename does
              not exist.  Both this option and <u>-fdef=</u> also work with the <u>-fmakeall</u> option.

       <u>-fextended-opaque</u>
              Allows  opaque  types  to  be  implemented  as  any  type. This is a <u>GNU</u> <u>Modula-2</u> extension and it
              requires that the implementation module defining the opaque type is available so that  it  can  be
              resolved when compiling the module which imports the opaque type.

       <u>-fmakeall</u>
              Generate a temporary makefile and build all dependent modules and link.

       <u>-fmakelist</u>
              This  option  is  only  applicable  when  linking  a program module.  The compiler will generate a
              `modulename.lst' file which contains a list indicating the initialization  order  of  all  modules
              which  are  to  be  linked.  The  actual  link  does not occur.  The <u>GNU</u> <u>Modula-2</u> linker scans all
              <b>IMPORT</b>'s , generates a list of dependencies and produces an ordered list  for  initialization.  It
              will  probably get the order wrong if your project has cyclic dependencies, but the `.lst' file is
              plain text and can be modified if required.  Once the `.lst' file is created it can be used by the
              compiler to link your project via the `<u>-fuselist</u>' option. It has no effect if the `<u>-c</u>'  option  is
              present.

       <u>-fsources</u>
              Displays the path to the source of each module.

       <u>-fstatistics</u>
              Generates  quadruple  information:  number of quadruples generated, number of quadruples remaining
              after optimization.  Quadruples are the intermediate language used internally by the <u>GNU</u>  <u>Modula-2</u>
              compiler.

       <u>-fuselist</u>
              Providing   `<u>gm2</u>'   has  been  told  to  link  the  program  module  this  option  uses  the  file
              `<u>modulename.lst</u>' for the initialization order of modules.

       <u>-Wverbose-unbounded</u>
              Inform the user which non `<b>VAR</b>' unbounded parameters will  be  passed  by  reference.   This  only
              produces output if the option <u>-funbounded-by-reference</u> is also supplied on the command line.

       <u>-funbounded-by-reference</u>
              Enable  optimization  of unbounded parameters by attempting to pass non `<b>VAR</b>' unbounded parameters
              by reference.  This optimization avoids the  implicit  copy  inside  the  callee  procedure.   <u>GNU</u>
              <u>Modula-2</u>  will  only  allow  unbounded  parameters to be passed by reference if, inside the callee
              procedure, they are not written to, no address is calculated on the array and it is not passed  as
              a `<b>VAR</b>' parameter.

              <b>NOTE:</b>  That  it is possible to write code to break this optimization, therefore this option should
              be used carefully.  For example, it would be possible to take the address of an  array,  pass  the
              address  and  the  array  to  a  procedure,  read from the array in the procedure and write to the
              location using the address parameter.

              Due to the dangerous nature of this option it is not enabled when the <u>-O</u> option is specified.

   <b>Runtime</b> <b>Checking</b> <b>Options</b>
       <u>-fbounds</u>
              Generate code to check the bounds of subranges and array indexes.

       <u>-freturn</u>
              Generate code to check that functions always exit with a '<b>RETURN</b>' and do not fall out at the end.

       <u>-fnil</u>  Generate code to detect at runtime any attempt to access data through a '<b>NIL</b>' value pointer.

       <u>-fcase</u> Generate code to detect at runtime whether a '<b>CASE</b>' statement requires an '<b>ELSE</b>' clause  when  one
              was  not  specified.   This generates an implicit '<b>ELSE</b>' for '<b>CASE</b>' statements which do not define
              one.  It simply prints an error message, and exits with an error code.

       <u>-fsoft-check-all</u>
              Turns on all runtime checks. This is the same as invoking <u>GNU</u> <u>Modula-2</u> using the  command  options
              <u>-fbounds</u>, <u>-freturn</u>, <u>-fnil</u>, <u>-fcase</u>, <u>-frange</u>, <u>,</u>-findex<u>,</u> -fwholediv

   <b>Style</b> <b>Checking</b> <b>Options</b>
       <u>-Wstudents</u>
              Checks  for bad programming style. This option is aimed at new users of Modula-2 in that it checks
              for situations which might cause confusion and thus mistakes.  It checks whether variables of  the
              same  name are declared in different scopes and whether variables look like keywords.  Experienced
              users might find this option too aggressive.

       <u>-Wpedantic</u>
              Forces the compiler to reject nested '<b>WITH</b>' statements referencing the same record type.  Does not
              allow multiple imports of the same item from a module.  It also checks that:  procedure  variables
              are  written  to before being read; variables are not only written to but read from; variables are
              declared and used.  If the compiler encounters a  variable  being  read  before  written  it  will
              terminate  with  a message.  It will check that '<b>FOR</b>' loop indices are not used outside the end of
              this loop without being reset.

       <u>-Wpedantic-param-names</u>
              Procedure parameter names are checked in the definition module against their implementation module
              counterpart.  This is not necessary in <u>ISO</u> or <u>PIM</u> versions of Modula-2, but it  can  be  extremely
              useful, as long as code is intentionally written in this way.

       <u>-Wpedantic-cast</u>
              Warns if the ISO system function is used and if the size of the variable is different from that of
              the type. This is legal in <u>ISO</u> <u>Modula-2</u>, however it can be dangerous. Some users may prefer to use
              '<b>VAL</b>'  instead in these situations and use '<b>CAST</b>' exclusively for changes in type on objects which
              have the same size.

   <b>Language</b> <b>Dialect</b> <b>Options</b>
       <u>-fiso</u>  Turn on ISO standard features. Currently this enables the <u>ISO</u> <b>SYSTEM</b> module and alters the default
              library search path so that the ISO libraries are searched before  the  PIM  libraries.   It  also
              effects the behavior of '<b>DIV</b>' and '<b>MOD</b>' operators.

       <u>-fpim</u>  Turn  on  <u>PIM</u> standard features. Currently this enables the <u>PIM</u> <b>SYSTEM</b> module and determines which
              identifiers are pervasive (declared in the base module). If no other  <u>-fpim[234]</u>  switch  is  used
              then division and modulus operators behave as defined in PIM4.  (See <b>LANGUAGE</b> <b>DIALECTS</b>.)

       <u>-fpim2</u> Turn  on  <u>PIM-2</u>  standard  features. Currently this removes <b>SIZE</b> from being a pervasive identifier
              (declared in the base module).  It places <b>SIZE</b> in the <b>SYSTEM</b> module.  It also effects the behavior
              of '<b>DIV</b>' and '<b>MOD</b>' operators.

       <u>-fpim3</u> Turn on <u>PIM-3</u> standard features. Currently this only effects  the  behavior  of  `<b>DIV</b>'  and  `<b>MOD</b>'
              operators.

       <u>-fpim4</u> Turn  on  <u>PIM-4</u>  standard  features.  Currently  this only effects the behavior of `<b>DIV</b>' and `<b>MOD</b>'
              operators.

       <u>-fpositive-mod-floor-div</u>
              Forces the `<b>DIV</b>' and `<b>MOD</b>' operators to behave as  defined  by  <u>PIM4</u>.   All  modulus  results  are
              positive and the results from the division are rounded to the floor.
              <b>NOTE:</b> See the section <b>LANGUAGE</b> <b>DIALECTS</b> for a table describing these results.

   <b>Library</b> <b>Search</b> <b>Path</b> <b>Options</b>
       <u>-flibs=ulm</u>
              Modifies  the  default  library  search  path so that the University of Ulm libraries are searched
              before the other PIM libraries.

       <u>-flibs=pim</u>
              Modifies the default library search path so that the PIM libraries are searched before any  others
              (the default).

       <u>-flibs=pim-coroutine</u>
              Modifies  the  default  libraries  search path so that the <u>PIM</u> `<b>SYSTEM</b>' module providing coroutine
              support is searched before the base PIM libraries.  This directory also  includes  many  coroutine
              related libraries.

       <u>-flibs=iso</u>
              Modifies  the default library search path so that the ISO libraries are searched before any others
              (not needed if `<u>-fiso</u>' was specified).

       <u>-flibs=logitech</u>
              Modifies the default library search path so that the Logitech compatible  libraries  are  searched
              before the base PIM libraries.

       <u>-flibs=min</u>
              Modifies the default library search path so that the minimal set of runtime libraries are searched
              before any others.  Useful if targetting a small memory embedded device.

</pre><h4><b>LANGUAGE</b> <b>DIALECTS</b></h4><pre>
       This  section  describes  the  dialects  understood  by  <u>GNU</u> <u>Modula-2</u>.  It also describes the differences
       between the dialects and any command line switches which determine dialect behavior.

       The <u>GNU</u> <u>Modula-2</u> compiler is based on the language as defined in:

       <u>PIM2</u>   ´Programming in Modula-2´, 2nd Edition,
               Springer Verlag, 1982, 1983 by Niklaus Wirth,

       <u>PIM3</u>   ´Programming in Modula-2´, 3rd Corrected Edition,
               Springer Verlag, 1985 by Niklaus Wirth, and

       <u>PIM4</u>   ´Programming in Modula-2´, 4th Edition,
               Springer Verlag, 1988, by Niklaus Wirth.

       <u>ISO</u>    The  International  Standards  Organization's  <u>ISO/IEC</u>  <u>10514-1:1996</u>  Information  Technology   --
              Programming Languages -- Part-1: Modula-2, Base Language

       It  also  includes  ISO M2 features and <u>GNU</u> <u>Modula-2</u> extensions. Currently <u>GNU</u> <u>Modula-2</u> (0.49) implements
       all PIM dialects of the language, eventually <u>GNU</u> <u>Modula-2</u> will be fully compliant with ISO Modula-2  Base
       Language.  It supports neither ISO Modula-2 Generics, nor ISO Object Oriented Modula-2.

       The  command  line  switches  <u>-fpim2</u>,  <u>-fpim3</u>,  <u>-fpim4</u>, and <u>-fiso</u> can be used to force mutually exclusive
       features. However by default the compiler will not aggressively fail if a non mutually exclusive  feature
       is  used  from another dialect. For example it is possible to specify <u>-fpim2</u> and still utilize <b>DEFINITION</b>
       <b>MODULES</b> which have no export list.

       Some dialect differences will force a compile time error, for example in <u>PIM2</u> the user must  <b>IMPORT</b>  <b>SIZE</b>
       from  the  module  <b>SYSTEM</b>  ,  whereas  in <u>PIM3</u> and <u>PIM4</u> <b>SIZE</b> is a pervasive function. Thus compiling <u>PIM4</u>
       source code with the <u>-fpim2</u> switch will cause a compile time error.  This can be fixed  quickly  with  an
       additional <b>IMPORT</b> or alternatively by compiling with the <u>-fpim4</u> switch.

       However  there  are some very important differences between the dialects which are mutually exclusive and
       therefore it is vital that users choose the dialects with care when these language features are used.

   <b>Integer</b> <b>Division,</b> <b>Remainder</b> <b>and</b> <b>Modulus</b>
       The most dangerous set of mutually exclusive features  found  in  the  four  dialects  supported  by  <u>GNU</u>
       <u>Modula-2</u> are the `<b>INTEGER</b>' division, remainder and modulus arithmetic operators.  It is important to note
       that  the  same  source  code  can  be  compiled  to  give different runtime results depending upon these
       switches!  The reference manual for the various dialects of Modula-2 are quite clear about this  behavior
       and sadly there are three distinct definitions.

       The table below illustrates the problem when a negative operand is used.

                             Pim2/3          Pim4                ISO
                          -----------    -----------    ----------------------
           lval    rval   DIV     MOD    DIV     MOD    DIV    MOD    /    REM
           31      10      3       1      3       1      3      1     3     1
          -31      10     -3      -1     -4       9     -4      9    -3    -1
           31     -10     -3       1     -3       1     Exception    -3     1
          -31     -10      3      -1      4       9     Exception     3    -1

       See  also  pg24  of  <u>PIM2</u>,  pg27  of  <u>PIM3</u>, pg29 of <u>PIM4</u>,  and pg201 of the <u>ISO</u> Standard.  At present all
       dialect division, remainder and modulus are implemented as above, apart from the exception calling in the
       <u>ISO</u> dialect. Instead of exception handling the results are the same  as  the  <u>PIM4</u>  dialect.  This  is  a
       temporary implementation situation.

   <b>The</b> <b>PIM</b> <b>SYSTEM</b> <b>Module</b>
       The  different  dialects  of Modula-2 PIM-[234] and ISO Modula-2 declare the function `SIZE' in different
       places.  PIM-[34] and ISO Modula-2 declare `SIZE' as a pervasive function (declared in the base  module).
       PIM-2 defined `SIZE' in the `SYSTEM' module.

            DEFINITION MODULE SYSTEM ;

            EXPORT QUALIFIED (* the following are built into the compiler: *)
                             ADDRESS, WORD, BYTE, BITSET, ADR, TSIZE, SIZE ;

            END SYSTEM.

   <b>The</b> <b>ISO</b> <b>SYSTEM</b> <b>Module</b>
            DEFINITION MODULE SYSTEM;

              (* Gives access to system programming facilities that
                 are probably non portable. *)

              (* The constants and types define underlying properties
                 of storage *)

            EXPORT QUALIFIED BITSPERLOC, LOCSPERWORD,
                             LOC, BYTE, WORD, BITSET, ADDRESS,
                             ADDADR, SUBADR, DIFADR, MAKEADR, ADR, ROTATE,
                             SHIFT, CAST, TSIZE,

                             (* Internal GM2 compiler functions *)
                             ShiftVal, ShiftLeft, ShiftRight,
                             RotateVal, RotateLeft, RotateRight ;

            CONST
                              (* &lt;implementation-defined constant&gt; ; *)
              BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
                              (* &lt;implementation-defined constant&gt; ; *)
              LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;
                              (* &lt;implementation-defined constant&gt; ; *)
              LOCSPERBYTE = 8 DIV BITSPERLOC ;
            (*
               all the objects below are declared internally to gm2
               ====================================================

            TYPE
              LOC; (* A system basic type. Values are the uninterpreted
                      contents of the smallest addressable unit of storage *)
              ADDRESS = POINTER TO LOC;
              WORD = ARRAY [0 .. LOCSPERWORD-1] OF LOC;

              (* BYTE and LOCSPERBYTE are provided if appropriate for machine *)

            TYPE
              BYTE = ARRAY [0 .. LOCSPERBYTE-1] OF LOC;

            PROCEDURE ADDADR (addr: ADDRESS; offset: CARDINAL): ADDRESS;
              (* Returns address given by (addr + offset), or may raise
                 an exception if this address is not valid.
              *)

            PROCEDURE SUBADR (addr: ADDRESS; offset: CARDINAL): ADDRESS;
              (* Returns address given by (addr - offset), or may raise an
                 exception if this address is not valid.
              *)

            PROCEDURE DIFADR (addr1, addr2: ADDRESS): INTEGER;
              (* Returns the difference between addresses (addr1 - addr2),
                 or may raise an exception if the arguments are invalid
                 or address space is non-contiguous.
              *)

            PROCEDURE MAKEADR (high: &lt;some type&gt;; ...): ADDRESS;
              (* Returns an address constructed from a list of values whose
                 types are implementation-defined, or may raise an
                 exception if this address is not valid.

                 In GNU Modula-2, MAKEADR can take any number of arguments
                 which are mapped onto the type ADDRESS. The first parameter
                 maps onto the high address bits and subsequent parameters map
                 onto lower address bits. For example:
                 a := MAKEADR(<a href="../man0FEH/BYTE.0FEH.html">BYTE</a>(0FEH), <a href="../man0DCH/BYTE.0DCH.html">BYTE</a>(0DCH), <a href="../man0BAH/BYTE.0BAH.html">BYTE</a>(0BAH), <a href="../man098H/BYTE.098H.html">BYTE</a>(098H),
                              <a href="../man076H/BYTE.076H.html">BYTE</a>(076H), <a href="../man054H/BYTE.054H.html">BYTE</a>(054H), <a href="../man032H/BYTE.032H.html">BYTE</a>(032H), <a href="../man010H/BYTE.010H.html">BYTE</a>(010H)) ;

                 then the value of, a, on a 64 bit machine is:
                 0FEDCBA9876543210H

                 The parameters do not have to have the same type,
                 but constants _must_ be typed.
              *)

            PROCEDURE ADR (VAR v: &lt;anytype&gt;): ADDRESS;
              (* Returns the address of variable v. *)

            PROCEDURE ROTATE (val: &lt;a packedset type&gt;;
                              num: INTEGER): &lt;type of first parameter&gt;;
              (* Returns a bit sequence obtained from val by rotating up or
                 down (left or right) by the absolute value of num.
                 The direction is down if the sign of num is negative,
                 otherwise the direction is up.
              *)

            PROCEDURE SHIFT (val: &lt;a packedset type&gt;;
                             num: INTEGER): &lt;type of first parameter&gt;;
              (* Returns a bit sequence obtained from val by shifting up
                 or down (left or right) by the absolute value of num,
                 introducing zeros as necessary.  The direction is down
                 if the sign of num is negative, otherwise the direction
                 is up.
              *)

            PROCEDURE CAST (&lt;targettype&gt;; val: &lt;anytype&gt;): &lt;targettype&gt;;
              (* CAST is a type transfer function.  Given the expression
                 denoted by val, it returns a value of the type &lt;targettype&gt;.
                 An invalid value for the target value or a
                 physical address alignment problem may raise an exception.
              *)

            PROCEDURE TSIZE (&lt;type&gt;; ... ): CARDINAL;
              (* Returns the number of LOCS used to store a value of the
                 specified &lt;type&gt;.   The extra parameters, if present,
                 are used to distinguish variants in a variant record.
              *)
            *)

            (* The following procedures are invoked by GNU Modula-2 to
               shift non word set types. They are not part of ISO Modula-2
               but are used by GNU Modula-2 to implement the SHIFT procedure
               defined above. *)

            (*
               ShiftVal - is a runtime procedure whose job is to implement
                          the SHIFT procedure of ISO SYSTEM. GNU Modula-2 will
                          inline a SHIFT of a single WORD sized set and will
                          only call this routine for larger sets.
            *)

            PROCEDURE ShiftVal (VAR s, d: ARRAY OF BITSET;
                                SetSizeInBits: CARDINAL;
                                ShiftCount: INTEGER) ;

            (*
               ShiftLeft - performs the shift left for a multi word set.
                           This procedure might be called by the back end of
                           GNU Modula-2 depending whether amount is known at
                           compile time.
            *)

            PROCEDURE ShiftLeft (VAR s, d: ARRAY OF BITSET;
                                 SetSizeInBits: CARDINAL;
                                 ShiftCount: INTEGER) ;

            (*
               ShiftRight - performs the shift left for a multi word set.
                            This procedure might be called by the back end of
                            GNU Modula-2 depending whether amount is known at
                            compile time.
            *)

            PROCEDURE ShiftRight (VAR s, d: ARRAY OF BITSET;
                                 SetSizeInBits: CARDINAL;
                                 ShiftCount: INTEGER) ;

            (*
               RotateVal - is a runtime procedure whose job is to implement
                           the ROTATE procedure of ISO SYSTEM. GNU Modula-2
                           will inline a ROTATE of a single WORD (or less)
                           sized set and will only call this routine for
                           larger sets.
            *)

            PROCEDURE RotateVal (VAR s, d: ARRAY OF BITSET;
                                 SetSizeInBits: CARDINAL;
                                 RotateCount: INTEGER) ;

            (*
               RotateLeft - performs the rotate left for a multi word set.
                            This procedure might be called by the back end of
                            GNU Modula-2 depending whether amount is known at
                            compile time.
            *)
            PROCEDURE RotateLeft (VAR s, d: ARRAY OF BITSET;
                                  SetSizeInBits: CARDINAL;
                                  RotateCount: INTEGER) ;

            (*
               RotateRight - performs the rotate right for a multi word set.
                             This procedure might be called by the back end of
                             GNU Modula-2 depending whether amount is known
                             at compile time.
            *)

            PROCEDURE RotateRight (VAR s, d: ARRAY OF BITSET;
                                   SetSizeInBits: CARDINAL;
                                   RotateCount: INTEGER) ;

            END SYSTEM.

</pre><h4><b>GM2</b> <b>LANGUAGE</b> <b>EXTENSIONS</b></h4><pre>
       This section introduces the GNU Modula-2 language extensions.

   <b>Abstract</b> <b>Types</b>
       The  <u>GNU</u>  <u>Modula-2</u>  compiler  allows abstract data types to be any type, not just restricted to a pointer
       type providing the <u>-fextended-opaque</u> command line option is supplied.

   <b>Declaration</b> <b>Order</b>
       Declarations can be made in any order, whether they are types, constants, procedures, nested  modules  or
       variables.

   <b>Interfacing</b> <b>to</b> <b>C</b>
       <u>GNU</u> <u>Modula-2</u> also allows programmers to interface to `C' and assembly language.

       The <u>GNU</u> <u>Modula-2</u> compiler tries to use the C calling convention wherever possible however some parameters
       have no C equivalent and thus a language specific method is used. For example unbounded arrays are passed
       as  a  `<b>struct</b>  <b>void</b>  <b>*address,</b>  <b>unsigned</b> <b>int</b> <b>high</b>' and the contents of these arrays are copied by callee
       functions when they are  declared  as  non  `<b>VAR</b>'  parameters.   The  `<b>VAR</b>'  equivalent  unbounded  array
       parameters need no copy, but still use the `<b>struct</b>' representation.

       The  recommended  method  of  interfacing  <u>GNU</u> <u>Modula-2</u> to C is by telling the definition module that the
       implementation is in the C language.  This is achieved by using the tokens `<b>DEFINITION</b> <b>MODULE</b> <b>FOR</b> <b>“C”</b>'.

            DEFINITION MODULE FOR "C" libprintf ;

            EXPORT UNQUALIFIED printf ;

            PROCEDURE printf (a: ARRAY OF CHAR; ...) ;

            END libprintf.

       The `<b>UNQUALIFIED</b>' keyword in the definition module informs <u>GNU</u> <u>Modula-2</u> not to prefix the module name  to
       exported references in the object file.

       The  `<u>printf</u>'  declaration states that the first parameter semantically matches `<b>ARRAY</b> <b>OF</b> <b>CHAR</b>' but since
       the module is for the C language it will be mapped onto '<u>char</u> <u>*</u>'<u>.</u>  The token `<b>...</b>'  indicates a  variable
       number  of arguments (varargs) and all parameters passed here are mapped onto their C equivalents. Arrays
       and constant strings are passed as pointers.

       The hello world program can be rewritten as:

            MODULE hello ;

            FROM libprintf IMPORT printf ;

            BEGIN
               printf("hello world0)
            END hello.

       and it can be compiled by: <u>gm2</u> <u>-fmakeall</u> <u>-g</u> <u>-I.</u> <u>hello.mod</u> <u>-lc</u>.

       In reality the `-lc' is redundant as libc is always included in the linking process. It is shown here  to
       emphasize that the C library or object file containing `<u>printf</u>' must be present.

   <b>Interfacing</b> <b>to</b> <b>Assembly</b> <b>Language</b>
       The  interface  for <u>GNU</u> <u>Modula-2</u> to assembly language is almost identical to <u>GNU</u> <u>C</u>.  The only alterations
       are that the keywords `<b>asm</b>' and `<b>volatile</b>' are in capitals, following the Modula-2 convention.

       A simple, but highly non-optimal, example is given below. Here we want to add the two  `CARDINAL's  `foo'
       and `bar' together and return the result.

            PROCEDURE Example (foo, bar: CARDINAL) : CARDINAL;
            VAR
               myout: CARDINAL;
            BEGIN
               ASM VOLATILE ("movl %1,%%eax; addl %2,%%eax; movl %%eax,%0"
                  : "=g" (myout)           (* outputs *)
                  : "g" (foo), "g" (bar)   (* inputs  *)
                  : "eax");                (* we trash *)
               RETURN( myout );
            END Example;

   <b>Special</b> <b>Tokens</b>
       <u>GNU</u>  <u>Modula-2</u>  provides  support  for the special tokens <b>__</b><u>LINE</u><b>__</b>, <b>__</b><u>FILE</u><b>__</b>,  <b>__</b><u>FUNCTION</u><b>__</b>, and <b>__</b><u>DATE</u><b>__</b>.
       Support for these tokens will occur even  if  the  <u>-fcpp</u>  option  is  not  supplied.  A  table  of  these
       identifiers and their data type and values is given below:

         Scope       GNU Modula-2 token      Data type and example value

         anywhere    __LINE__                Constant Literal compatible
                                             with CARDINAL, INTEGER and WORD.
                                             Example 1234

         anywhere    __FILE__                Constant string compatible
                                             with parameter ARRAY OF CHAR or
                                             an ARRAY whose SIZE is &gt;= string
                                             length. Example "hello.mod"

         procedure   __FUNCTION__            Constant string compatible
                                             with parameter ARRAY OF CHAR or
                                             an ARRAY whose SIZE is &gt;= string
                                             length. Example
                                             "calc"

         module      __FUNCTION__            Example
                                             "module hello initialization"

         anywhere    __DATE__                Constant string compatible
                                             with parameter ARRAY OF CHAR or
                                             an ARRAY whose SIZE is &gt;= string
                                             length. Example
                                             "Thu Apr 29 10:07:16 BST 2004"

   <b>Preprocessor</b>
       The  preprocessor <u>cpp</u> can be invoked via the <u>-fcpp</u> command line option. This in turn invokes <u>cpp</u> with the
       following arguments <u>-traditional</u> <u>-lang-asm</u>.  These options preserve comments  and  all  quotations.   <u>gm2</u>
       treats a `#' character in the first column as a preprocessor directive.

       For example here is a module which calls `FatalError' via the macro `ERROR'.

            MODULE cpp ;

            FROM SYSTEM IMPORT ADR, SIZE ;
            FROM libc IMPORT exit, printf, malloc ;

            PROCEDURE FatalError (a, file: ARRAY OF CHAR;
                                     line: CARDINAL;
                                     func: ARRAY OF CHAR) ;
            VAR
               r: INTEGER ;
            BEGIN
               r := printf("%s:%d:fatal error, %s, in %s0,
                           ADR(file), line, ADR(a), ADR(func)) ;
               <a href="../man1/exit.1.html">exit</a>(1)
            END FatalError ;

            #define ERROR(X)  FatalError(X, __FILE__, __LINE__, __FUNCTION__)

            VAR
               pc: POINTER TO CARDINAL;
            BEGIN
               pc := malloc(SIZE(CARDINAL)) ;
               IF pc=NIL
               THEN
                  ERROR('out of memory')
               END
            END cpp.

   <b>Optional</b> <b>procedure</b> <b>parameter</b>
       <u>GNU</u>  <u>Modula-2</u>  allows  the  last  parameter to a procedure or function parameter to be optional.  This is
       achieved by enclosing the last formal parameter within square brackets, and providing an  initializer  (a
       constant assignment).

       For  example  in  the  <u>ISO</u>  library  <u>'COROUTINES.def'</u>  <u>the</u> <u>procedure</u> <u>NEWCOROUTINE</u> is defined as having an
       optional fifth argument (`<u>initProtection</u>') which, if absent, is automatically replaced by <b>`NIL'</b>.

            PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS;
                                    size: CARDINAL; VAR cr: COROUTINE;
                                    [initProtection: PROTECTION = NIL]);

       The implementation module <u>`COROUTINES.mod'</u> implements this procedure using the following syntax:

            PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS;
                                    size: CARDINAL; VAR cr: COROUTINE;
                                    [initProtection: PROTECTION]);
            BEGIN

            END NEWCOROUTINE ;

       <b>Note</b> that it is illegal for this declaration  to  contain  an  initializer  value  for  `initProtection'.
       However  it  is necessary to surround this parameter with the brackets `[' and `]'. This serves to remind
       the programmer that the last parameter was declared as optional in the definition module.

       Local procedures can be declared to have an optional final parameter in which  case  the  initializer  is
       mandatory in the implementation or program module.

   <b>Builtins</b>
       This  section  describes  the  built-in  constants  and functions defined in <u>GNU</u> <u>Modula-2</u>.  The following
       compiler constants can be accessed using the `<b>__</b><u>ATTRIBUTE</u><b>__</b>', `<b>__</b><u>BUILTIN</u><b>__</b>' keywords. These are not  part
       of  the  Modula-2  language and they may differ depending upon the target architecture but they provide a
       method whereby common libraries can interface to a different underlying architecture.

       The built-in constants are: `<u>BITS_PER_UNIT</u>',  `<u>BITS_PER_WORD</u>',  '<u>BITS_PER_CHAR</u>  '  and  `<u>UNITS_PER_WORD'</u>.
       They are integrated into <u>GNU</u> <u>Modula-2</u> by an extension to the `ConstFactor' rule:

            ConstFactor := ConstQualidentOrSet | Number | ConstString |
                           "(" ConstExpression ")" | "NOT" ConstFactor |
                           ConstAttribute =:

            ConstAttribute := "__ATTRIBUTE__" "__BUILTIN__" "(" "(" Ident ")" ")" =:

       Here is an example taken from the ISO library `SYSTEM.def':

            CONST
               BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
               LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;

       Built-in  functions  are  transparent to the end user. All built-in functions are declared in `<b>DEFINITION</b>
       <b>MODULE</b>'s and are imported as and when required.  Built-in functions are declared in definition modules by
       using the `<b>__BUILTIN__</b>' keyword. Here is a section of the ISO library `<u>LongMath.def</u>'  which  demonstrates
       this feature.

           PROCEDURE __BUILTIN__ sqrt (x: LONGREAL): LONGREAL;
              (* Returns the square root of x *)

       This  indicates  that the function `<u>sqrt</u>' will be implemented using the gcc built-in math library. If gcc
       cannot utilize the built-in function (for example if the programmer requested the address of `<u>sqrt</u>') then
       code is generated to call the alternative function implemented in the `<b>IMPLEMENTATION</b> <b>MODULE</b>'.

       Sometimes a function exported from the `<b>DEFINITION</b> <b>MODULE</b>' will have a different name from  the  built-in
       function  within  gcc.  In such cases the mapping between the GNU Modula-2 function name and the gcc name
       is expressed using the keywords `<b>__</b><u>ATTRIBUTE</u><b>__</b> <b>__</b><u>BUILTIN</u><b>__</b> <u>((Ident))</u>'.  For example the  function  `sqrt'
       in `LongMath.def' maps onto the gcc built-in function `sqrtl' and this is expressed as:

            PROCEDURE __ATTRIBUTE__ __BUILTIN__ ((sqrtl)) sqrt
                                                (x: LONGREAL) : LONGREAL;
              (* Returns the positive square root of x *)

       The  following  module  `<u>Builtins.def</u>' enumerates the list of built-in functions which can be accessed in
       <u>GNU</u> <u>Modula-2</u>.  It also serves to define the parameter and return value for each function:

            DEFINITION MODULE Builtins ;

            FROM SYSTEM IMPORT ADDRESS ;

            PROCEDURE __BUILTIN__ sinf (x: SHORTREAL) : SHORTREAL ;
            PROCEDURE __BUILTIN__ sin (x: REAL) : REAL ;
            PROCEDURE __BUILTIN__ sinl (x: LONGREAL) : LONGREAL ;

            PROCEDURE __BUILTIN__ cosf (x: SHORTREAL) : SHORTREAL ;
            PROCEDURE __BUILTIN__ cos (x: REAL) : REAL ;
            PROCEDURE __BUILTIN__ cosl (x: LONGREAL) : LONGREAL ;

            PROCEDURE __BUILTIN__ sqrtf (x: SHORTREAL) : SHORTREAL ;
            PROCEDURE __BUILTIN__ sqrt (x: REAL) : REAL ;
            PROCEDURE __BUILTIN__ sqrtl (x: LONGREAL) : LONGREAL ;

            PROCEDURE __BUILTIN__ fabsf (x: SHORTREAL) : SHORTREAL ;
            PROCEDURE __BUILTIN__ fabs (x: REAL) : REAL ;
            PROCEDURE __BUILTIN__ fabsl (x: LONGREAL) : LONGREAL ;

            PROCEDURE __BUILTIN__ alloca (i: CARDINAL) : ADDRESS ;
            PROCEDURE __BUILTIN__ memcpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
            PROCEDURE __BUILTIN__ index (s: ADDRESS; c: INTEGER) : ADDRESS ;
            PROCEDURE __BUILTIN__ rindex (s: ADDRESS; c: INTEGER) : ADDRESS ;
            PROCEDURE __BUILTIN__ memcmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
            PROCEDURE __BUILTIN__ memset (s: ADDRESS; c: INTEGER; n: CARDINAL) : ADDRESS ;
            PROCEDURE __BUILTIN__ strcat (dest, src: ADDRESS) : ADDRESS ;
            PROCEDURE __BUILTIN__ strncat (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
            PROCEDURE __BUILTIN__ strcpy (dest, src: ADDRESS) : ADDRESS ;
            PROCEDURE __BUILTIN__ strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
            PROCEDURE __BUILTIN__ strcmp (s1, s2: ADDRESS) : INTEGER ;
            PROCEDURE __BUILTIN__ strncmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
            PROCEDURE __BUILTIN__ strlen (s: ADDRESS) : INTEGER ;
            PROCEDURE __BUILTIN__ strstr (haystack, needle: ADDRESS) : ADDRESS ;
            PROCEDURE __BUILTIN__ strpbrk (s, accept: ADDRESS) : ADDRESS ;
            PROCEDURE __BUILTIN__ strspn (s, accept: ADDRESS) : CARDINAL ;
            PROCEDURE __BUILTIN__ strcspn (s, accept: ADDRESS) : CARDINAL ;
            PROCEDURE __BUILTIN__ strchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
            PROCEDURE __BUILTIN__ strrchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
            PROCEDURE __BUILTIN__ huge_val (r: REAL) : REAL ;
            PROCEDURE __BUILTIN__ huge_valf (s: SHORTREAL) : SHORTREAL ;
            PROCEDURE __BUILTIN__ huge_vall (l: LONGREAL) : LONGREAL ;

            END Builtins.

       Although this module exists and will result in the generation of inline code if  optimization  flags  are
       passed to GNU Modula-2, users are advised to utilize the same functions from more generic libraries.  The
       built-in  mechanism  will  be  applied  to  these  generic  libraries  where  appropriate.  <b>NOTE:</b> for the
       mathematical routines to be inlined you need to specify the `<u>-ffast-math</u> <u>-O</u>' options.

</pre><h4><b>LIBRARIES</b></h4><pre>
</pre><h4><b>EXAMPLES</b></h4><pre>
       This section describes how to compile and link a  simple  'hello  world'  program.   It  provides  a  few
       examples of using the different options mentioned above.

       Assume the file "hello.mod" contains the code:
            MODULE Hello;

            FROM StrIO IMPORT WriteString, WriteLn;

            BEGIN
               WriteString('hello world');
               WriteLn;
            END Hello.

       You should be able to compile it by: <b>gm2</b> <b>-c</b> <b>hello.mod</b>
        and link via: <b>gm2</b> <b>hello.mod</b>.  The result should be an `a.out' file created in your directory.

       Alternatively it may be compiled by: <b>gm2</b> <b>-g</b> <b>-I.</b> <b>-fmakeall</b> <b>hello.mod</b>.

</pre><h4><b>FILES</b></h4><pre>
</pre><h4><b>ENVIRONMENT</b></h4><pre>
</pre><h4><b>CONFORMING</b> <b>TO</b></h4><pre>
       The <u>GNU</u> <u>Modula-2</u> compiler is based on the language as defined in:

              <u>'Programming</u> <u>in</u> <u>Modula-2'</u> 2nd Edition, Springer Verlag, 1982, 1983 by Niklaus Wirth (PIM2),

              <u>'Programming</u> <u>in</u> <u>Modula-2',</u> 3rd Corrected Edition, Springer Verlag, 1985 (PIM3) and

              <u>'Programming</u> <u>in</u> <u>Modula-2',</u> 4th Edition, Springer Verlag, 1988 (PIM4).

              It also includes ISO M2 features and GNU Modula-2 extensions.

</pre><h4><b>BUGS</b></h4><pre>
</pre><h4><b>COPYRIGHT</b></h4><pre>
</pre><h4><b>LICENCE</b></h4><pre>
       The  <u>GNU</u>  <u>Modula-2</u>  compiler and associated software is released under the <u>GNU</u> <u>PUBLIC</u> <u>LICENCE</u> <u>(GPL)</u> which
       should be available in a file named <u>COPYING</u>.

       The runtime libraries (pim, iso, and Logitech Compatable)  are  released  under  the  <u>LESSER</u>  <u>GNU</u>  <u>PUBLIC</u>
       <u>LICENCE</u>  <u>(LGPL)</u>  which  allows  any  user  to link against the runtime libraries without invoking all the
       clauses of the full GPL.

       The Ulm library is released under the GPL.

</pre><h4><b>AUTHOR</b></h4><pre>
       This manual page was written (using the documentation from  the  texinfo  files)  by  Peter  P.  Eiserloh
       ⟨<a href="mailto:peter@eiserloh.org">peter@eiserloh.org</a>⟩

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The many fine books about Modula-2.

       The <u>GNU</u> <u>Modula-2</u> web site at ⟨<a href="http://www.nongnu.org/gm2">http://www.nongnu.org/gm2</a>⟩

GM2                                                27-Nov-2005                                            <u><a href="../man1/gm2.1.html">gm2</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>