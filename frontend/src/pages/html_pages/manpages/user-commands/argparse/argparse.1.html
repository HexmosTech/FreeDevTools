<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>argparse - argparse tutorial</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/lua-argparse">lua-argparse_0.7.1-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       argparse - argparse tutorial

       Contents:

</pre><h4><b>CREATING</b> <b>AND</b> <b>USING</b> <b>PARSERS</b></h4><pre>
       The <b>argparse</b> module is a function which, when called, creates an instance of the Parser class.

          -- script.lua
          local argparse = require "argparse"
          local parser = argparse()

       <b>parser</b> is now an empty parser which does not recognize any command line arguments or options.

   <b>Parsing</b> <b>command</b> <b>line</b> <b>arguments</b>
       <b>:parse([argv])</b>  method  of  the Parser class returns a table with processed data from the command line or
       <b>argv</b> array.

          local args = parser:parse()

       After this is executed with <b>lua</b> <b>script.lua</b>, <b>args</b> is an empty table because the parser  is  empty  and  no
       command line arguments were supplied.

   <b>Error</b> <b>handling</b>
       If  the  provided command line arguments are not recognized by the parser, it will print an error message
       and call <b><a href="../man1/os.exit.1.html">os.exit</a>(1)</b>.

          $ lua script.lua foo

          Usage: script.lua [-h]

          Error: too many arguments

       If halting the program is undesirable, <b>:pparse([args])</b> method should be used.  It  returns  boolean  flag
       indicating success of parsing and result or error message.

       An error can raised manually using <b>:error()</b> method.

          parser:error("manual argument validation failed")

          Usage: script.lua [-h]

          Error: manual argument validation failed

   <b>Help</b> <b>option</b>
       As  the  automatically  generated  usage message states, there is a help option <b>-h</b> added to any parser by
       default.

       When a help option is used, parser will print a help message and call <b><a href="../man0/os.exit.0.html">os.exit</a>(0)</b>.

          $ lua script.lua -h

          Usage: script.lua [-h]

          Options:
             -h, --help            Show this help message and exit.

   <b>Typo</b> <b>autocorrection</b>
       When an option is not recognized by the parser, but there is an option with a similar name, a  suggestion
       is automatically added to the error message.

          $ lua script.lua --hepl

          Usage: script.lua [-h]

          Error: unknown option '--hepl'
          Did you mean '--help'?

   <b>Configuring</b> <b>parsers</b>
       Parsers  have several properties affecting their behavior. For example, <b>description</b> and <b>epilog</b> properties
       set the text to be displayed in the help message after the  usage  message  and  after  the  listings  of
       options  and  arguments, respectively. Another is <b>name</b>, which overwrites the name of the program which is
       used in the usage message (default value is inferred from command line arguments).

       There are several ways to set properties. The first is to chain setter methods of Parser object.

          local parser = argparse()
             :name "script"
             :description "A testing script."
             :epilog "For more info, see <a href="http://example.com">http://example.com</a>"

       The second is to call a parser with a table containing some properties.

          local parser = argparse() {
             name = "script",
             description = "A testing script.",
             epilog "For more info, see <a href="http://example.com">http://example.com</a>."
          }

       Finally, <b>name</b>. <b>description</b> and <b>epilog</b> properties can be passed as arguments when calling a parser.

          local parser = argparse("script", "A testing script.", "For more info, see <a href="http://example.com">http://example.com</a>.")

</pre><h4><b>ADDING</b> <b>AND</b> <b>CONFIGURING</b> <b>ARGUMENTS</b></h4><pre>
       Positional arguments can be added using <b>:argument(name,</b> <b>description,</b> <b>default,</b> <b>convert,</b> <b>args)</b>  method.  It
       returns  an  Argument  instance, which can be configured in the same way as Parsers. The <b>name</b> property is
       required.

       This and the following examples show contents of the result table returned  by  <u>parser:parse()</u>  when  the
       script is executed with given command-line arguments.

          parser:argument "input"

          $ lua script.lua foo

          {
             input = "foo"
          }

       The data passed to the argument is stored in the result table at index <b>input</b> because it is the argument's
       name. The index can be changed using <b>target</b> property.

   <b>Setting</b> <b>number</b> <b>of</b> <b>consumed</b> <b>arguments</b>
       <b>args</b>  property  sets  how  many command line arguments the argument consumes. Its value is interpreted as
       follows:
                         ┌───────────────────────────────────────┬─────────────────────────┐
                         │ Value                                 │ Interpretation          │
                         ├───────────────────────────────────────┼─────────────────────────┤
                         │ Number <b>N</b>                              │ Exactly <b>N</b> arguments     │
                         ├───────────────────────────────────────┼─────────────────────────┤
                         │ String <b>A-B</b>, where <b>A</b> and <b>B</b> are numbers │ From <b>A</b> to <b>B</b> arguments   │
                         ├───────────────────────────────────────┼─────────────────────────┤
                         │ String <b>N+</b>, where <b>N</b> is a number        │ <b>N</b> or more arguments     │
                         ├───────────────────────────────────────┼─────────────────────────┤
                         │ String <b>?</b>                              │ An optional argument    │
                         ├───────────────────────────────────────┼─────────────────────────┤
                         │ String <b>*</b>                              │ Any number of arguments │
                         ├───────────────────────────────────────┼─────────────────────────┤
                         │ String <b>+</b>                              │ At least one argument   │
                         └───────────────────────────────────────┴─────────────────────────┘

       If more than one argument can be consumed, a table is used to store the data.

          parser:argument("pair", "A pair of arguments.")
             :<a href="../man2/args.2.html">args</a>(2)
          parser:argument("optional", "An optional argument.")
             :args "?"

          $ lua script.lua foo bar

          {
             pair = {"foo", "bar"}
          }

          $ lua script.lua foo bar baz

          {
             pair = {"foo", "bar"},
             optional = "baz"
          }

   <b>Setting</b> <b>argument</b> <b>choices</b>
       The <b>choices</b> property can be used to restrict an argument to a set of choices. Its value is  an  array  of
       string choices.

          parser:argument "direction"
             :choices {"north", "south", "east", "west"}

          $ lua script.lua foo

          Usage: script.lua [-h] {north,south,east,west}

          Error: argument 'direction' must be one of 'north', 'south', 'east', 'west'

</pre><h4><b>ADDING</b> <b>AND</b> <b>CONFIGURING</b> <b>OPTIONS</b></h4><pre>
       Options  can  be added using <b>:option(name,</b> <b>description,</b> <b>default,</b> <b>convert,</b> <b>args,</b> <b>count)</b> method. It returns
       an Option instance, which can be configured in the same way as Parsers. The <b>name</b> property is required. An
       option can have several aliases, which can be set as  space  separated  substrings  in  its  name  or  by
       continuously setting <b>name</b> property.

          -- These lines are equivalent:
          parser:option "-f" "--from"
          parser:option "-f --from"

          $ lua script.lua --from there
          $ lua script.lua --from=there
          $ lua script.lua -f there
          $ lua script.lua -fthere

          {
             from = "there"
          }

       For  an  option,  default  index used to store arguments passed to it is the first "long" alias (an alias
       starting with two control characters, typically  hyphens)  or  just  the  first  alias,  without  control
       characters.  Hyphens  in  the  default  index are replaced with underscores. In the following table it is
       assumed that <b>local</b> <b>args</b> <b>=</b> <b>parser:parse()</b> has been executed.
                                ┌──────────────────┬────────────────────────────────┐
                                │ Option's aliases │ Location of option's arguments │
                                ├──────────────────┼────────────────────────────────┤
                                │ <b>-o</b>               │ <b>args.o</b>                         │
                                ├──────────────────┼────────────────────────────────┤
                                │ <b>-o</b> <b>--output</b>      │ <b>args.output</b>                    │
                                ├──────────────────┼────────────────────────────────┤
                                │ <b>-s</b> <b>--from-server</b> │ <b>args.from_server</b>               │
                                └──────────────────┴────────────────────────────────┘

       As with arguments, the index can be explicitly set using <b>target</b> property.

   <b>Flags</b>
       Flags are almost identical to options, except that they don't take an argument by default.

          parser:flag("-q --quiet")

          $ lua script.lua -q

          {
             quiet = true
          }

   <b>Control</b> <b>characters</b>
       The first characters of all aliases of all options of a parser form the set of control  characters,  used
       to distinguish options from arguments. Typically the set only consists of a hyphen.

   <b>Setting</b> <b>number</b> <b>of</b> <b>consumed</b> <b>arguments</b>
       Just as arguments, options can be configured to take several command line arguments.

          parser:option "--pair"
             :<a href="../man2/args.2.html">args</a>(2)
          parser:option "--optional"
             :args "?"

          $ lua script.lua --pair foo bar

          {
             pair = {"foo", "bar"}
          }

          $ lua script.lua --pair foo bar --optional

          {
             pair = {"foo", "bar"},
             optional = {}
          }

          $ lua script.lua --optional=baz

          {
             optional = {"baz"}
          }

       Note  that  the  data  passed  to <b>optional</b> option is stored in an array. That is necessary to distinguish
       whether the option was invoked without an argument or it was not invoked at all.

   <b>Setting</b> <b>argument</b> <b>choices</b>
       The <b>choices</b> property can be used to specify a list of choices for an option argument in the same  way  as
       for arguments.

          parser:option "--format"
             :choices {"short", "medium", "full"}

          $ lua script.lua --format foo

          Usage: script.lua [-h] [--format {short,medium,full}]

          Error: argument for option '--format' must be one of 'short', 'medium', 'full'

   <b>Setting</b> <b>number</b> <b>of</b> <b>invocations</b>
       For  options,  it is possible to control how many times they can be used. argparse uses <b>count</b> property to
       set how many times an option can be invoked. The value of the property is interpreted  in  the  same  way
       <b>args</b> is.

          parser:option("-e --exclude")
             :count "*"

          $ lua script.lua -eFOO -eBAR

          {
             exclude = {"FOO", "BAR"}
          }

       If  an option can be used more than once and it can consume more than one argument, the data is stored as
       an array of invocations, each being an array of arguments.

       As a special case, if an option can be used more than once and it consumes  no  arguments  (e.g.  it's  a
       flag), than the number of invocations is stored in the associated field of the result table.

          parser:flag("-v --verbose", "Sets verbosity level.")
             :count "0-2"
             :target "verbosity"

          $ lua script.lua -vv

          {
             verbosity = 2
          }

</pre><h4><b>MUTUALLY</b> <b>EXCLUSIVE</b> <b>GROUPS</b></h4><pre>
       A  group  of  arguments  and options can be marked as mutually exclusive using <b>:mutex(argument_or_option,</b>
       <b>...)</b> method of the Parser class.

          parser:mutex(
             parser:argument "input"
                :args "?",
             parser:flag "--process-stdin"
          )

          parser:mutex(
             parser:flag "-q --quiet",
             parser:flag "-v --verbose"
          )

       If more than one element of a mutually exclusive group is used, an error is raised.

          $ lua script.lua -qv

          Usage: script.lua ([-q] | [-v]) [-h] ([&lt;input&gt;] | [--process-stdin])

          Error: option '-v' can not be used together with option '-q'

          $ lua script.lua file --process-stdin

          Usage: script.lua ([-q] | [-v]) [-h] ([&lt;input&gt;] | [--process-stdin])

          Error: option '--process-stdin' can not be used together with argument 'input'

</pre><h4><b>ADDING</b> <b>AND</b> <b>CONFIGURING</b> <b>COMMANDS</b></h4><pre>
       A command is a subparser invoked when its name is passed as an argument. For example,  in  <u>git</u>  CLI  <b>add</b>,
       <b>commit</b>,  <b>push</b>,  etc.  are  commands.  Each command has its own set of arguments and options, but inherits
       options of its parent.

       Commands can be added using <b>:command(name,</b> <b>description,</b> <b>epilog)</b> method. Just  as  options,  commands  can
       have several aliases.

          parser:command "install i"

       If a command it used, <b>true</b> is stored in the corresponding field of the result table.

          $ lua script.lua install

          {
             install = true
          }

       A typo will result in an appropriate error message.

          $ lua script.lua instal

          Usage: script.lua [-h] &lt;command&gt; ...

          Error: unknown command 'instal'
          Did you mean 'install'?

   <b>Getting</b> <b>name</b> <b>of</b> <b>selected</b> <b>command</b>
       Use  <b>command_target</b>  property  of  the  parser to store the name of used command in a field of the result
       table.

          parser:command_target("command")
          parser:command("install")
          parser:command("remove")

          $ lua script.lua install

          {
             install = true,
             command = "install"
          }

   <b>Adding</b> <b>elements</b> <b>to</b> <b>commands</b>
       The Command class is a subclass of the Parser class, so all the Parser's methods for adding elements work
       on commands, too.

          local install = parser:command "install"
          install:argument "rock"
          install:option "-f --from"

          $ lua script.lua install foo --from=bar

          {
             install = true,
             rock = "foo",
             from = "bar"
          }

       Commands have their own usage and help messages.

          $ lua script.lua install

          Usage: script.lua install [-h] [-f &lt;from&gt;] &lt;rock&gt;

          Error: too few arguments

          $ lua script.lua install --help

          Usage: script.lua install [-h] [-f &lt;from&gt;] &lt;rock&gt;

          Arguments:
             rock

          Options:
             -h, --help            Show this help message and exit.
             -f &lt;from&gt;, --from &lt;from&gt;

   <b>Making</b> <b>a</b> <b>command</b> <b>optional</b>
       By default, if a parser has commands, using one of them is obligatory.

          local parser = argparse()
          parser:command "install"

          $ lua script.lua

          Usage: script.lua [-h] &lt;command&gt; ...

          Error: a command is required

       This can be changed using <b>require_command</b> property.

          local parser = argparse()
             :require_command(false)
          parser:command "install"

   <b>Command</b> <b>summaries</b>
       The description for commands shown in the parent  parser  help  message  can  be  set  with  the  <b>summary</b>
       property.

          parser:command "install"
             :summary "Install a rock."
             :description "A long description for the install command."

          $ lua script.lua --help

          Usage: script.lua [-h] &lt;command&gt; ...

          Options:
             -h, --help            Show this help message and exit.

          Commands:
             install               Install a rock.

          $ lua script.lua install --help

          Usage: script.lua install [-h]

          A long description for the install command.

          Options:
             -h, --help            Show this help message and exit.

</pre><h4><b>DEFAULT</b> <b>VALUES</b></h4><pre>
       For  elements  such as arguments and options, if <b>default</b> property is set to a string, its value is stored
       in case the element was not used (if it's not a string, it'll be  used  as  <b>init</b>  property  instead,  see
       <u>Argument</u> <u>and</u> <u>option</u> <u>actions</u>).

          parser:option("-o --output", "Output file.", "a.out")
          -- Equivalent:
          parser:option "-o" "--output"
             :description "Output file."
             :default "a.out"

          $ lua script.lua

          {
             output = "a.out"
          }

       The  existence  of  a  default value is reflected in help message, unless <b>show_default</b> property is set to
       <b>false</b>.

          $ lua script.lua --help

          Usage: script.lua [-h] [-o &lt;output&gt;]

          Options:
             -h, --help            Show this help message and exit.
             -o &lt;output&gt;, --output &lt;output&gt;
                                   Output file. (default: a.out)

       Note that invocation without required arguments is still an error.

          $ lua script.lua -o

          Usage: script.lua [-h] [-o &lt;output&gt;]

          Error: too few arguments

   <b>Default</b> <b>mode</b>
       <b>defmode</b> property regulates how argparse should use the default value of an element.

       By default, or if <b>defmode</b> contains <b>u</b> (for unused), the default value will be automatically passed to  the
       element  if  it  was  not  invoked  at  all.  It will be passed minimal required of times, so that if the
       element is allowed to consume no arguments (e.g. using <b>:args</b> <b>"?"</b>), the default value is ignored.

       If <b>defmode</b> contains <b>a</b> (for argument), the default value will be automatically passed to  the  element  if
       not enough arguments were passed, or not enough invocations were made.

       Consider the difference:

          parser:option "-o"
             :default "a.out"
          parser:option "-p"
             :default "password"
             :defmode "arg"

          $ lua script.lua -h

          Usage: script.lua [-h] [-o &lt;o&gt;] [-p [&lt;p&gt;]]

          Options:
             -h, --help            Show this help message and exit.
             -o &lt;o&gt;                default: a.out
             -p [&lt;p&gt;]              default: password

          $ lua script.lua

          {
             o = "a.out"
          }

          $ lua script.lua -p

          {
             o = "a.out",
             p = "password"
          }

          $ lua script.lua -o

          Usage: script.lua [-h] [-o &lt;o&gt;] [-p [&lt;p&gt;]]

          Error: too few arguments

</pre><h4><b>CALLBACKS</b></h4><pre>
   <b>Converters</b>
       argparse  can perform automatic validation and conversion on arguments. If <b>convert</b> property of an element
       is a function, it will be applied to all the arguments passed to it. The function should return <b>nil</b>  and,
       optionally,  an  error message if conversion failed. Standard <b>tonumber</b> and <b>io.open</b> functions work exactly
       like that.

          parser:argument "input"
             :convert(io.open)
          parser:option "-t --times"
             :convert(tonumber)

          $ lua script.lua foo.txt -t5

          {
             input = file_object,
             times = 5
          }

          $ lua script.lua nonexistent.txt

          Usage: script.lua [-h] [-t &lt;times&gt;] &lt;input&gt;

          Error: nonexistent.txt: No such file or directory

          $ lua script.lua foo.txt --times=many

          Usage: script.lua [-h] [-t &lt;times&gt;] &lt;input&gt;

          Error: malformed argument 'many'

       If <b>convert</b> property of an element is an  array  of  functions,  they  will  be  used  as  converters  for
       corresponding arguments in case the element accepts multiple arguments.

          parser:option "--line-style"
             :<a href="../man2/args.2.html">args</a>(2)
             :convert {string.lower, tonumber}

          $ lua script.lua --line-style DASHED 1.5

          {
             line_style = {"dashed", 1.5}
          }

   <b>Table</b> <b>converters</b>
       If  convert  property of an element is a table and doesn't have functions in array part, arguments passed
       to it will be used as keys. If a key is missing, an error is raised.

          parser:argument "choice"
             :convert {
                foo = "Something foo-related",
                bar = "Something bar-related"
             }

          $ lua script.lua bar

          {
             choice = "Something bar-related"
          }

          $ lua script.lua baz

          Usage: script.lua [-h] &lt;choice&gt;

          Error: malformed argument 'baz'

   <b>Actions</b>
   <b>Argument</b> <b>and</b> <b>option</b> <b>actions</b>
       argparse uses action callbacks to process invocations of arguments and options.  Default  actions  simply
       put  passed arguments into the result table as a single value or insert into an array depending on number
       of arguments the option can take and how many times it can be used.

       A custom action can be set using <b>action</b> property. An action must be a function. and will be called  after
       each invocation of the option or the argument it is assigned to. Four arguments are passed: result table,
       target  index in that table, an argument or an array of arguments passed by user, and overwrite flag used
       when an option is invoked too many times.

       Converters are applied before actions.

       Initial value to be stored at target index in the result table can be set using <b>init</b>  property,  or  also
       using <b>default</b> property if the value is not a string.

          parser:option("--exceptions"):args("*"):action(function(args, _, exceptions)
             for _, exception in ipairs(exceptions) do
                table.insert(args.exceptions, exception)
             end
          end):init({"foo", "bar"})

          parser:flag("--no-exceptions"):action(function(args)
             args.exceptions = {}
          end)

          $ lua script.lua --exceptions x y --exceptions z t

          {
             exceptions = {
                "foo",
                "bar",
                "x",
                "y",
                "z",
                "t"
             }
          }

          $ lua script.lua --exceptions x y --no-exceptions

          {
             exceptions = {}
          }

       Actions  can  also  be  used  when  a flag needs to print some message and exit without parsing remaining
       arguments.

          parser:flag("-v --version"):action(function()
             print("script v1.0.0")
             <a href="../man0/os.exit.0.html">os.exit</a>(0)
          end)

          $ lua script.lua -v

          script v1.0.0

   <b>Built-in</b> <b>actions</b>
       These actions can be referred to by their string names when setting <b>action</b> property:
                               ┌─────────────┬───────────────────────────────────────┐
                               │ Name        │ Description                           │
                               ├─────────────┼───────────────────────────────────────┤
                               │ store       │ Stores  argument  or   arguments   at │
                               │             │ target index.                         │
                               ├─────────────┼───────────────────────────────────────┤
                               │ store_true  │ Stores <b>true</b> at target index.          │
                               ├─────────────┼───────────────────────────────────────┤
                               │ store_false │ Stores <b>false</b> at target index.         │
                               ├─────────────┼───────────────────────────────────────┤
                               │ count       │ Increments number at target index.    │
                               ├─────────────┼───────────────────────────────────────┤
                               │ append      │ Appends   argument  or  arguments  to │
                               │             │ table at target index.                │
                               ├─────────────┼───────────────────────────────────────┤
                               │ concat      │ Appends arguments one by one to table │
                               │             │ at target index.                      │
                               └─────────────┴───────────────────────────────────────┘

       Examples using <b>store_false</b> and <b>concat</b> actions:

          parser:flag("--candy")
          parser:flag("--no-candy"):target("candy"):action("store_false")
          parser:flag("--rain", "Enable rain", false)
          parser:option("--exceptions"):args("*"):action("concat"):init({"foo", "bar"})

          $ lua script.lua

          {
             rain = false
          }

          $ lua script.lua --candy

          {
             candy = true,
             rain = false
          }

          $ lua script.lua --no-candy --rain

          {
             candy = false,
             rain = true
          }

          $ lua script.lua --exceptions x y --exceptions z t

          {
             exceptions = {
                "foo",
                "bar",
                "x",
                "y",
                "z",
                "t"
             },
             rain = false
          }

   <b>Command</b> <b>actions</b>
       Actions for parsers and commands are simply callbacks  invoked  after  parsing,  with  result  table  and
       command name as the arguments. Actions for nested commands are called first.

          local install = parser:command("install"):action(function(args, name)
             print("Running " .. name)
             -- Use args here
          )

          parser:action(function(args)
             print("Callbacks are fun!")
          end)

          $ lua script.lua install

          Running install
          Callbacks are fun!

</pre><h4><b>CONFIGURING</b> <b>HELP</b> <b>AND</b> <b>USAGE</b> <b>MESSAGES</b></h4><pre>
       The  usage  and  help  messages of parsers and commands can be generated on demand using <b>:get_usage()</b> and
       <b>:get_help()</b> methods, and overridden using <b>help</b> and <b>usage</b> properties.  When using the autogenerated  usage
       and help messages, there are several ways to adjust them.

   <b>Hiding</b> <b>arguments,</b> <b>options,</b> <b>and</b> <b>commands</b> <b>from</b> <b>messages</b>
       If  <b>hidden</b>  property for an argument, an option or a command is set to <b>true</b>, it is not included into help
       and usage messages, but otherwise works normally.

          parser:option "--normal-option"
          parser:option "--deprecated-option"
             :hidden(true)

          $ lua script.lua --help

          Usage: script.lua [-h] [--normal-option &lt;normal_option&gt;]

          Options:
             -h, --help            Show this help message and exit.
             --normal-option &lt;normal_option&gt;

          $ lua script.lua --deprecated-option value

          {
             deprecated_option = "value"
          }

   <b>Hiding</b> <b>option</b> <b>and</b> <b>command</b> <b>aliases</b>
       Hidden aliases can be added to an option or command by setting the <b>hidden_name</b>  property.  Its  value  is
       interpreted in the same way as the <b>name</b> property.

          parser:option "--server"
             :hidden_name "--from"

          $ lua script.lua --help

          Usage: script.lua [-h] [--server &lt;server&gt;]

          Options:
             -h, --help            Show this help message and exit.
             --server &lt;server&gt;

          $ lua script.lua --server foo
          $ lua script.lua --from foo

          {
             server = "foo"
          }

   <b>Setting</b> <b>argument</b> <b>placeholder</b>
       For  options  and  arguments,  <b>argname</b>  property  controls  the placeholder for the argument in the usage
       message.

          parser:option "-f" "--from"
             :argname "&lt;server&gt;"

          $ lua script.lua --help

          Usage: script.lua [-h] [-f &lt;server&gt;]

          Options:
             -h, --help            Show this help message and exit.
             -f &lt;server&gt;, --from &lt;server&gt;

       <b>argname</b> can be an array of placeholders.

          parser:option "--pair"
             :<a href="../man2/args.2.html">args</a>(2)
             :argname {"&lt;key&gt;", "&lt;value&gt;"}

          $ lua script.lua --help

          Usage: script.lua [-h] [--pair &lt;key&gt; &lt;value&gt;]

          Options:
             -h, --help            Show this help message and exit.
             --pair &lt;key&gt; &lt;value&gt;

   <b>Grouping</b> <b>elements</b>
       <b>:group(name,</b> <b>...)</b> method of parsers and commands puts passed arguments,  options,  and  commands  into  a
       named  group with its own section in the help message. Elements outside any groups are put into a default
       section.

          parser:group("Configuring output format",
             parser:flag "-v --verbose",
             parser:flag "--use-colors",
             parser:option "--encoding"
          )

          parser:group("Configuring processing",
             parser:option "--compression-level",
             parser:flag "--skip-broken-chunks"
          )

          parser:flag "--version"
             :action(function() print("script.lua 1.0.0") <a href="../man0/os.exit.0.html">os.exit</a>(0) end)

          $ lua script.lua --help

          Usage: script.lua [-h] [-v] [--use-colors] [--encoding &lt;encoding&gt;]
                 [--compression-level &lt;compression_level&gt;]
                 [--skip-broken-chunks] [--version]

          Configuring output format:
             -v, --verbose
             --use-colors
             --encoding &lt;encoding&gt;

          Configuring processing:
             --compression-level &lt;compression_level&gt;
             --skip-broken-chunks

          Other options:
             -h, --help            Show this help message and exit.
             --version

   <b>Help</b> <b>message</b> <b>line</b> <b>wrapping</b>
       If <b>help_max_width</b> property of a parser or a command is set, when generating its  help  message,  argparse
       will  automatically  wrap  lines,  attempting to fit into given number of columns. This includes wrapping
       lines in parser description and epilog and descriptions of arguments, options, and commands.

       Line wrapping preserves existing line endings and only splits overly long input lines.  When  breaking  a
       long  line,  it replicates indentation of the line in the continuation lines.  Additionally, if the first
       non-space token in a line is <b>*</b>, <b>+</b>, or <b>-</b>, the line is considered a list item, and the  continuation  lines
       are aligned with the first word after the list item marker.

          parser:<a href="../man80/help_max_width.80.html">help_max_width</a>(80)

          parser:option "-f --foo"
             :description("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor " ..
                "incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation " ..
                "ullamco laboris nisi ut aliquip ex ea commodo consequat.\n" ..
                "The next paragraph is indented:\n" ..
                "  Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. " ..
                "Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.")

          parser:option "-b --bar"
             :description("Here is a list:\n"..
                "* Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor...\n" ..
                "* Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip...\n" ..
                "* Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.")

          $ lua script.lua --help

          Usage: script.lua [-h] [-f &lt;foo&gt;] [-b &lt;bar&gt;]

          Options:
             -h, --help            Show this help message and exit.
                -f &lt;foo&gt;,          Lorem ipsum dolor sit amet, consectetur adipiscing
             --foo &lt;foo&gt;           elit, sed do eiusmod tempor incididunt ut labore et
                                   dolore magna aliqua. Ut enim ad minim veniam, quis
                                   nostrud exercitation ullamco laboris nisi ut aliquip ex
                                   ea commodo consequat.
                                   The next paragraph is indented:
                                     Duis aute irure dolor in reprehenderit in voluptate
                                     velit esse cillum dolore eu fugiat nulla pariatur.
                                     Excepteur sint occaecat cupidatat non proident, sunt
                                     in culpa qui officia deserunt mollit anim id est
                                     laborum.
                -b &lt;bar&gt;,          Here is a list:
             --bar &lt;bar&gt;           * Lorem ipsum dolor sit amet, consectetur adipiscing
                                     elit, sed do eiusmod tempor...
                                   * Ut enim ad minim veniam, quis nostrud exercitation
                                     ullamco laboris nisi ut aliquip...
                                   * Duis aute irure dolor in reprehenderit in voluptate
                                     velit esse cillum dolore eu fugiat nulla pariatur.

       <b>help_max_width</b> property is inherited by commands.

   <b>Configuring</b> <b>help</b> <b>and</b> <b>usage</b> <b>message</b> <b>layout</b>
       Several  other  parser  and  command properties can be used to tweak help and usage message format.  Like
       <b>help_max_width</b>, all of them are inherited by commands when set on the parser or a parent command.

       <b>usage_max_width</b> property sets maximum width of the usage string. Default is <b>70</b>.

       <b>usage_margin</b> property sets margin width used when line wrapping long usage strings. Default is <b>7</b>.

          parser:<a href="../man50/usage_max_width.50.html">usage_max_width</a>(50)
             :usage_margin(#"Usage: script.lua ")

          parser:option "--foo"
          parser:option "--bar"
          parser:option "--baz"
          parser:option "--qux"

          print(parser:get_usage())

          $ lua script.lua

          Usage: script.lua [-h] [--foo &lt;foo&gt;] [--bar &lt;bar&gt;]
                            [--baz &lt;baz&gt;] [--qux &lt;qux&gt;]

       Help message for a group of arguments, options, or commands is organized into  two  columns,  with  usage
       template on the left side and descriptions on the right side.  <b>help_usage_margin</b> property sets horizontal
       offset  for the first column (<b>3</b> by default).  <b>help_description_margin</b> property sets horizontal offset for
       the second column (<b>25</b> by default).

       <b>help_vertical_space</b> property sets number of extra empty lines to put between descriptions  for  different
       elements within a group (<b>0</b> by default).

          parser:<a href="../man2/help_usage_margin.2.html">help_usage_margin</a>(2)
             :<a href="../man17/help_description_margin.17.html">help_description_margin</a>(17)
             :<a href="../man1/help_vertical_space.1.html">help_vertical_space</a>(1)

          parser:option("--foo", "Set foo.")
          parser:option("--bar", "Set bar.")
          parser:option("--baz", "Set baz.")
          parser:option("--qux", "Set qux.")

          $ lua script.lua --help

          Usage: script.lua [-h] [--foo &lt;foo&gt;] [--bar &lt;bar&gt;] [--baz &lt;baz&gt;]
                 [--qux &lt;qux&gt;]

          Options:

            -h, --help     Show this help message and exit.

            --foo &lt;foo&gt;    Set foo.

            --bar &lt;bar&gt;    Set bar.

            --baz &lt;baz&gt;    Set baz.

            --qux &lt;qux&gt;    Set qux.

</pre><h4><b>SHELL</b> <b>COMPLETIONS</b></h4><pre>
       Argparse  can  generate shell completion scripts for <u>Bash</u>, <u>Zsh</u>, and <u>Fish</u>.  The completion scripts support
       completing options, commands, and argument choices.

       The Parser methods <b>:get_bash_complete()</b>, <b>:get_zsh_complete()</b>, and <b>:get_fish_complete()</b> return  completion
       scripts as a string.

   <b>Adding</b> <b>a</b> <b>completion</b> <b>option</b> <b>or</b> <b>command</b>
       A  <b>--completion</b>  option  can  be  added to a parser using the <b>:add_complete([value])</b> method. The optional
       <b>value</b> argument is a string or table used to configure the option (by calling the option with <b>value</b>).

          local parser = argparse()
             :add_complete()

          $ lua script.lua -h

          Usage: script.lua [-h] [--completion {bash,zsh,fish}]

          Options:
             -h, --help            Show this help message and exit.
             --completion {bash,zsh,fish}
                                   Output a shell completion script for the specified shell.

       A similar <b>completion</b> command can be added to a parser using the <b>:add_complete_command([value])</b> method.

   <b>Using</b> <b>completions</b>
   <b>Bash</b>
       Save  the   generated   completion   script   at   <b>/usr/share/bash-completion/completions/script.lua</b>   or
       <b><a href="file:~/.local/share/bash-completion/completions/script.lua">~/.local/share/bash-completion/completions/script.lua</a></b>.

       Alternatively, add the following line to the <b><a href="file:~/.bashrc">~/.bashrc</a></b>:

          source &lt;(script.lua --completion bash)

   <b>Zsh</b>
       Save  the  completion  script  in  the  <b><a href="file:/usr/share/zsh/site-functions/">/usr/share/zsh/site-functions/</a></b>  directory or any directory in the
       <b>$fpath</b>. The file name should be an underscore followed by the program name. A new directory can be  added
       to to the <b>$fpath</b> by adding e.g. <b>fpath=(<a href="file:~/.zfunc">~/.zfunc</a></b> <b>$fpath)</b> in the <b><a href="file:~/.zshrc">~/.zshrc</a></b> before <b>compinit</b>.

   <b>Fish</b>
       Save     the     completion    script    at    <b>/usr/share/fish/vendor_completions.d/script.lua.fish</b>    or
       <b><a href="file:~/.config/fish/completions/script.lua.fish">~/.config/fish/completions/script.lua.fish</a></b>.

       Alternatively, add the following line to the file <b><a href="file:~/.config/fish/config.fish">~/.config/fish/config.fish</a></b>:

          script.lua --completion fish | source

</pre><h4><b>MISCELLANEOUS</b></h4><pre>
   <b>Argparse</b> <b>version</b>
       <b>argparse</b> module is a table with <b>__call</b> metamethod. <b>argparse.version</b>  is  a  string  in  <b>MAJOR.MINOR.PATCH</b>
       format specifying argparse version.

   <b>Overwriting</b> <b>default</b> <b>help</b> <b>option</b>
       If  the property <b>add_help</b> of a parser is set to <b>false</b>, no help option will be added to it. Otherwise, the
       value of the field will be used to configure it.

          local parser = argparse()
             :add_help "/?"

          $ lua script.lua /?

          Usage: script.lua [/?]

          Options:
             /?                    Show this help message and exit.

   <b>Help</b> <b>command</b>
       A help command can be added to the parser using the  <b>:add_help_command([value])</b>  method.  It  accepts  an
       optional string or table value which is used to configure the command.

          local parser = argparse()
             :add_help_command()
          parser:command "install"
             :description "Install a rock."

          $ lua script.lua help

          Usage: script.lua [-h] &lt;command&gt; ...

          Options:
             -h, --help            Show this help message and exit.

          Commands:
             help                  Show help for commands.
             install               Install a rock.

          $ lua script.lua help install

          Usage: script.lua install [-h]

          Install a rock.

          Options:
             -h, --help            Show this help message and exit.

   <b>Disabling</b> <b>option</b> <b>handling</b>
       When  <b>handle_options</b>  property  of  a  parser  or  a  command is set to <b>false</b>, all options will be passed
       verbatim to the argument list, as if the input included double-hyphens.

          parser:handle_options(false)
          parser:argument "input"
             :args "*"
          parser:option "-f" "--foo"
             :args "*"

          $ lua script.lua bar -f --foo bar

          {
             input = {"bar", "-f", "--foo", "bar"}
          }

   <b>Prohibiting</b> <b>overuse</b> <b>of</b> <b>options</b>
       By default, if an option is invoked too many times, latest invocations overwrite the data passed earlier.

          parser:option "-o --output"

          $ lua script.lua -oFOO -oBAR

          {
             output = "BAR"
          }

       Set <b>overwrite</b> property to <b>false</b> to prohibit this behavior.

          parser:option "-o --output"
             :overwrite(false)

          $ lua script.lua -oFOO -oBAR

          Usage: script.lua [-h] [-o &lt;output&gt;]

          Error: option '-o' must be used at most 1 time

   <b>Parsing</b> <b>algorithm</b>
       argparse interprets command line arguments in the following way:
                                ─────────────────────────────────────────────────────
                                  Argument    Interpretation
                                ─────────────────────────────────────────────────────
                                  <b>foo</b>         An  argument  of  an  option   or   a
                                              positional argument.
                                ─────────────────────────────────────────────────────
                                  <b>--foo</b>       An option.
                                ─────────────────────────────────────────────────────
                                  <b>--foo=bar</b>   An   option  and  its  argument.  The
                                              option   must   be   able   to   take
                                              arguments.
                                ─────────────────────────────────────────────────────
                                  <b>-f</b>          An option.
                                ─────────────────────────────────────────────────────
                                  <b>-abcdef</b>     Letters  are  interpreted as options.
                                              If one of them can take an  argument,
                                              the  rest  of the string is passed to
                                              it.
                                ─────────────────────────────────────────────────────
                                  <b>--</b>          The  rest   of   the   command   line
                                              arguments   will  be  interpreted  as
                                              positional arguments.
                                ┌───────────┬───────────────────────────────────────┐
                                │           │                                       │
   <b>Property</b> <b>lists</b>               │           │                                       │
   <b>Parser</b> <b>properties</b>            │           │                                       │
--
<b>AUTHOR</b>                                  │              │                    │
       Peter Melnichenko, Paul Ouellette│              │                    │
                                        │              │                    │
<b>COPYRIGHT</b>                               │              │                    │
       2013-2022 Peter Melnichenko; 2019│Paul Ouellette│                    │

0.7.1                                             Dec 09, 2022                                       <u><a href="../man1/ARGPARSE.1.html">ARGPARSE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>