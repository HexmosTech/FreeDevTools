<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>perlfaq9 - Web, Email and Networking</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/perl-doc">perl-doc_5.40.1-2ubuntu0.2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       perlfaq9 - Web, Email and Networking

</pre><h4><b>VERSION</b></h4><pre>
       version 5.20240218

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This section deals with questions related to running web sites, sending and receiving email as well as
       general networking.

   <b>Should</b> <b>I</b> <b>use</b> <b>a</b> <b>web</b> <b>framework?</b>
       Yes. If you are building a web site with any level of interactivity (forms / users / databases), you will
       want to use a framework to make handling requests and responses easier.

       If there is no interactivity then you may still want to look at using something like Template Toolkit
       &lt;https://metacpan.org/module/Template&gt; or Plack::Middleware::TemplateToolkit so maintenance of your HTML
       files (and other assets) is easier.

   <b>Which</b> <b>web</b> <b>framework</b> <b>should</b> <b>I</b> <b>use?</b>
       There is no simple answer to this question. Perl frameworks can run everything from basic file servers
       and small scale intranets to massive multinational multilingual websites that are the core to
       international businesses.

       Below is a list of a few frameworks with comments which might help you in making a decision, depending on
       your specific requirements. Start by reading the docs, then ask questions on the relevant mailing list or
       IRC channel.

       Catalyst
           Strongly object-oriented and fully-featured with a long development history and a large community and
           addon ecosystem. It is excellent for large and complex applications, where you have full control over
           the server.

       Dancer2
           Free of legacy weight, providing a lightweight and easy to learn API.  Has a growing addon ecosystem.
           It is best used for smaller projects and very easy to learn for beginners.

       Mojolicious
           Self-contained  and  powerful for both small and larger projects, with a focus on HTML5 and real-time
           web technologies such as WebSockets.

       Web::Simple
           Strongly object-oriented and minimal, built for speed and intended as a toolkit  for  building  micro
           web  apps,  custom  frameworks or for tieing together existing Plack-compatible web applications with
           one central dispatcher.

       All of these interact with or use Plack which is worth  understanding  the  basics  of  when  building  a
       website       in      Perl      (there      is      a      lot      of      useful      Plack::Middleware
       &lt;https://metacpan.org/search?q=plack%3A%3Amiddleware&gt;).

   <b>What</b> <b>is</b> <b>Plack</b> <b>and</b> <b>PSGI?</b>
       PSGI is the Perl Web Server Gateway Interface  Specification,  it  is  a  standard  that  many  Perl  web
       frameworks  use, you should not need to understand it to build a web site, the part you might want to use
       is Plack.

       Plack   is   a   set   of   tools   for    using    the    PSGI    stack.    It    contains    middleware
       &lt;https://metacpan.org/search?q=plack%3A%3Amiddleware&gt;  components,  a  reference server and utilities for
       Web application frameworks.  Plack is like Ruby's Rack or Python's Paste for WSGI.

       You could build a web site using Plack and your own code, but for anything other than a  very  basic  web
       site, using a web framework (that uses &lt;https://plackperl.org&gt;) is a better option.

   <b>How</b> <b>do</b> <b>I</b> <b>remove</b> <b>HTML</b> <b>from</b> <b>a</b> <b>string?</b>
       Use  HTML::Strip, or HTML::FormatText which not only removes HTML but also attempts to do a little simple
       formatting of the resulting plain text.

   <b>How</b> <b>do</b> <b>I</b> <b>extract</b> <b>URLs?</b>
       HTML::SimpleLinkExtor will extract URLs from HTML, it handles anchors, images, objects, frames, and  many
       other  tags  that can contain a URL.  If you need anything more complex, you can create your own subclass
       of HTML::LinkExtor or HTML::Parser. You might even use HTML::SimpleLinkExtor as an example for  something
       specifically suited to your needs.

       You can use URI::Find or URL::Search to extract URLs from an arbitrary text document.

   <b>How</b> <b>do</b> <b>I</b> <b>fetch</b> <b>an</b> <b>HTML</b> <b>file?</b>
       (contributed by brian d foy)

       The core HTTP::Tiny module can fetch web resources and give their content back to you as a string:

           use HTTP::Tiny;

           my $ua = HTTP::Tiny-&gt;new;
           my $html = $ua-&gt;get( "<a href="http://www.example.com/index.html">http://www.example.com/index.html</a>" )-&gt;{content};

       It can also store the resource directly in a file:

           $ua-&gt;mirror( "<a href="http://www.example.com/index.html">http://www.example.com/index.html</a>", "foo.html" );

       If  you  need  to  do  something  more  complicated,  the  HTTP::Tiny object can be customized by setting
       attributes, or you can use LWP::UserAgent from the libwww-perl distribution or Mojo::UserAgent  from  the
       Mojolicious distribution to make common tasks easier. If you want to simulate an interactive web browser,
       you can use the WWW::Mechanize module.

   <b>How</b> <b>do</b> <b>I</b> <b>automate</b> <b>an</b> <b>HTML</b> <b>form</b> <b>submission?</b>
       If  you  are  doing something complex, such as moving through many pages and forms or a web site, you can
       use WWW::Mechanize. See its documentation for all the details.

       If you're submitting values  using  the  GET  method,  create  a  URL  and  encode  the  form  using  the
       "www_form_urlencode" method from HTTP::Tiny:

           use HTTP::Tiny;

           my $ua = HTTP::Tiny-&gt;new;

           my $query = $ua-&gt;www_form_urlencode([ q =&gt; 'DB_File', lucky =&gt; 1 ]);
           my $url = "https://metacpan.org/search?$query";
           my $content = $ua-&gt;get($url)-&gt;{content};

       If you're using the POST method, the "post_form" method will encode the content appropriately.

           use HTTP::Tiny;

           my $ua = HTTP::Tiny-&gt;new;

           my $url = 'https://metacpan.org/search';
           my $form = [ q =&gt; 'DB_File', lucky =&gt; 1 ];
           my $content = $ua-&gt;post_form($url, $form)-&gt;{content};

   <b>How</b> <b>do</b> <b>I</b> <b>decode</b> <b>or</b> <b>create</b> <b>those</b> <b>%-encodings</b> <b>on</b> <b>the</b> <b>web?</b>
       Most  of  the  time you should not need to do this as your web framework, or if you are making a request,
       the LWP or other module would handle it for you.

       To encode a string yourself, use the URI::Escape module. The "uri_escape" function  returns  the  escaped
       string:

           my $original = "Colon : Hash # Percent %";

           my $escaped = uri_escape( $original );

           print "$escaped\n"; # 'Colon%20%3A%20Hash%20%23%20Percent%20%25'

       To decode the string, use the "uri_unescape" function:

           my $unescaped = uri_unescape( $escaped );

           print $unescaped; # back to original

       Remember  not  to  encode  a  full  URI,  you need to escape each component separately and then join them
       together.

   <b>How</b> <b>do</b> <b>I</b> <b>redirect</b> <b>to</b> <b>another</b> <b>page?</b>
       Most Perl Web Frameworks will have a mechanism for doing this, using the Catalyst framework it would be:

           $c-&gt;res-&gt;redirect($url);
           $c-&gt;detach();

       If you are using Plack (which most frameworks do), then Plack::Middleware::Rewrite is worth looking at if
       you are migrating from Apache or have URL's you want to always redirect.

   <b>How</b> <b>do</b> <b>I</b> <b>put</b> <b>a</b> <b>password</b> <b>on</b> <b>my</b> <b>web</b> <b>pages?</b>
       See if the web framework you are using has an authentication system and if that fits your needs.

       Alternativly  look  at  Plack::Middleware::Auth::Basic,  or  one  of  the  other   Plack   authentication
       &lt;https://metacpan.org/search?q=plack+auth&gt; options.

   <b>How</b> <b>do</b> <b>I</b> <b>make</b> <b>sure</b> <b>users</b> <b>can't</b> <b>enter</b> <b>values</b> <b>into</b> <b>a</b> <b>form</b> <b>that</b> <b>causes</b> <b>my</b> <b>CGI</b> <b>script</b> <b>to</b> <b>do</b> <b>bad</b> <b>things?</b>
       (contributed by brian d foy)

       You  can't  prevent  people  from  sending your script bad data. Even if you add some client-side checks,
       people may disable them or bypass them completely. For instance, someone might use a module such  as  LWP
       to  submit  to your web site. If you want to prevent data that try to use SQL injection or other sorts of
       attacks (and you should want to), you have to not trust any data that enter your program.

       The perlsec documentation has general advice about data security.  If you are using the DBI  module,  use
       placeholder  to fill in data.  If you are running external programs with "system" or "exec", use the list
       forms. There are many other precautions that you should take, too many to list here,  and  most  of  them
       fall under the category of not using any data that you don't intend to use. Trust no one.

   <b>How</b> <b>do</b> <b>I</b> <b>parse</b> <b>a</b> <b>mail</b> <b>header?</b>
       Use  the  Email::MIME module. It's well-tested and supports all the craziness that you'll see in the real
       world (comment-folding whitespace, encodings, comments, etc.).

         use Email::MIME;

         my $message = Email::MIME-&gt;new($rfc2822);
         my $subject = $message-&gt;header('Subject');
         my $from    = $message-&gt;header('From');

       If you've already got some other kind of email object, consider passing it to  Email::Abstract  and  then
       using its cast method to get an Email::MIME object:

         my $abstract = Email::Abstract-&gt;new($mail_message_object);
         my $email_mime_object = $abstract-&gt;cast('Email::MIME');

   <b>How</b> <b>do</b> <b>I</b> <b>check</b> <b>a</b> <b>valid</b> <b>mail</b> <b>address?</b>
       (partly contributed by Aaron Sherman)

       This isn't as simple a question as it sounds. There are two parts:

       a) How do I verify that an email address is correctly formatted?

       b) How do I verify that an email address targets a valid recipient?

       Without  sending  mail  to the address and seeing whether there's a human on the other end to answer you,
       you cannot fully answer part <u>b</u>, but the Email::Valid module will do both part <u>a</u> and part <u>b</u> as far as  you
       can in real-time.

       Our  best advice for verifying a person's mail address is to have them enter their address twice, just as
       you normally do to change a password. This usually weeds out typos. If both versions match, send mail  to
       that  address  with a personal message. If you get the message back and they've followed your directions,
       you can be reasonably assured that it's real.

       A related strategy that's less open to forgery is to give them a PIN (personal  ID  number).  Record  the
       address and PIN (best that it be a random one) for later processing. In the mail you send, include a link
       to  your site with the PIN included. If the mail bounces, you know it's not valid. If they don't click on
       the link, either they forged the address or (assuming they got  the  message)  following  through  wasn't
       important so you don't need to worry about it.

   <b>How</b> <b>do</b> <b>I</b> <b>decode</b> <b>a</b> <b>MIME/BASE64</b> <b>string?</b>
       The  MIME::Base64  package  handles  this  as  well as the MIME/QP encoding.  Decoding base 64 becomes as
       simple as:

           use MIME::Base64;
           my $decoded = decode_base64($encoded);

       The Email::MIME module can decode base 64-encoded email message  parts  transparently  so  the  developer
       doesn't need to worry about it.

   <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>the</b> <b>user's</b> <b>mail</b> <b>address?</b>
       Ask  them for it. There are so many email providers available that it's unlikely the local system has any
       idea how to determine a user's email address.

       The exception is for organization-specific email (e.g. <a href="mailto:foo@yourcompany.com">foo@yourcompany.com</a>) where policy can be  codified
       in  your  program.  In that case, you could look at $ENV{USER}, $ENV{LOGNAME}, and getpwuid($&lt;) in scalar
       context, like so:

         my $user_name = getpwuid($&lt;)

       But you still cannot make assumptions about whether this is correct, unless your policy says it  is.  You
       really are best off asking the user.

   <b>How</b> <b>do</b> <b>I</b> <b>send</b> <b>email?</b>
       Use the Email::Stuffer module, like so:

         # first, create your message
         my $message = Email::Stuffer-&gt;from('<a href="mailto:you@example.com">you@example.com</a>')
                                     -&gt;to('<a href="mailto:friend@example.com">friend@example.com</a>')
                                     -&gt;subject('Happy birthday!')
                                     -&gt;text_body("Happy birthday to you!\n");

         $message-&gt;send_or_die;

       By default, Email::Sender::Simple (the "send" and "send_or_die" methods use this under the hood) will try
       "sendmail"  first,  if  it  exists in your $PATH. This generally isn't the case. If there's a remote mail
       server you use to send mail, consider investigating one of the Transport classes. At time of writing, the
       available transports include:

       Email::Sender::Transport::Sendmail
           This is the default. If you can use the <b><a href="../man1/mail.1.html">mail</a></b>(1) or <b><a href="../man1/mailx.1.html">mailx</a></b>(1) program to send  mail  from  the  machine
           where your code runs, you should be able to use this.

       Email::Sender::Transport::SMTP
           This  transport  contacts  a  remote  SMTP  server  over  TCP.  It optionally uses TLS or SSL and can
           authenticate to the server via SASL.

       Telling Email::Stuffer to use your transport is straightforward.

         $message-&gt;transport($email_sender_transport_object)-&gt;send_or_die;

   <b>How</b> <b>do</b> <b>I</b> <b>use</b> <b>MIME</b> <b>to</b> <b>make</b> <b>an</b> <b>attachment</b> <b>to</b> <b>a</b> <b>mail</b> <b>message?</b>
       Email::MIME directly supports multipart messages. Email::MIME objects themselves are  parts  and  can  be
       attached  to  other  Email::MIME  objects.  Consult  the  Email::MIME documentation for more information,
       including all of the supported methods and examples of their use.

       Email::Stuffer uses Email::MIME under  the  hood  to  construct  messages,  and  wraps  the  most  common
       attachment tasks with the simple "attach" and "attach_file" methods.

         Email::Stuffer-&gt;to('<a href="mailto:friend@example.com">friend@example.com</a>')
                       -&gt;subject('The file')
                       -&gt;attach_file('stuff.csv')
                       -&gt;send_or_die;

   <b>How</b> <b>do</b> <b>I</b> <b>read</b> <b>email?</b>
       Use the Email::Folder module, like so:

         use Email::Folder;

         my $folder = Email::Folder-&gt;new('/path/to/email/folder');
         while(my $message = $folder-&gt;next_message) {
           # next_message returns Email::Simple objects, but we want
           # Email::MIME objects as they're more robust
           my $mime = Email::MIME-&gt;new($message-&gt;as_string);
         }

       There  are  different  classes  in the Email::Folder namespace for supporting various mailbox types. Note
       that these modules are generally rather limited and only support <b>reading</b> rather than writing.

   <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>out</b> <b>my</b> <b>hostname,</b> <b>domainname,</b> <b>or</b> <b>IP</b> <b>address?</b>
       (contributed by brian d foy)

       The Net::Domain module, which is part of the Standard Library starting in Perl 5.7.3,  can  get  you  the
       fully qualified domain name (FQDN), the host name, or the domain name.

           use Net::Domain qw(hostname hostfqdn hostdomain);

           my $host = hostfqdn();

       The Sys::Hostname module, part of the Standard Library, can also get the hostname:

           use Sys::Hostname;

           $host = hostname();

       The  Sys::Hostname::Long module takes a different approach and tries harder to return the fully qualified
       hostname:

         use Sys::Hostname::Long 'hostname_long';

         my $hostname = hostname_long();

       To get the IP address, you can use the "gethostbyname" built-in function to turn the name into a  number.
       To  turn  that  number  into the dotted octet form (a.b.c.d) that most people expect, use the "inet_ntoa"
       function from the Socket module, which also comes with perl.

           use Socket;

           my $address = inet_ntoa(
               scalar gethostbyname( $host || 'localhost' )
           );

   <b>How</b> <b>do</b> <b>I</b> <b>fetch/put</b> <b>an</b> <b>(S)FTP</b> <b>file?</b>
       Net::FTP, and Net::SFTP allow you to interact with FTP and SFTP (Secure FTP) servers.

   <b>How</b> <b>can</b> <b>I</b> <b>do</b> <b>RPC</b> <b>in</b> <b>Perl?</b>
       Use one of the RPC modules( &lt;https://metacpan.org/search?q=RPC&gt; ).

</pre><h4><b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and  other  authors  as  noted.  All  rights
       reserved.

       This documentation is free; you can redistribute it and/or modify it under the same terms as Perl itself.

       Irrespective  of  its  distribution,  all  code  examples  in this file are hereby placed into the public
       domain. You are permitted and encouraged to use this code in your own programs for fun or for  profit  as
       you see fit. A simple comment in the code giving credit would be courteous but is not required.

perl v5.40.1                                       2025-07-25                                        <u><a href="../man1/PERLFAQ9.1.html">PERLFAQ9</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>