<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>r.in.xyz  - Creates a raster map from an assemblage of many coordinates using univariate statistics.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>r.in.xyz</b>  - Creates a raster map from an assemblage of many coordinates using univariate statistics.

</pre><h4><b>KEYWORDS</b></h4><pre>
       raster, import, statistics, conversion, aggregation, binning, ASCII, LIDAR

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>r.in.xyz</b>
       <b>r.in.xyz</b> <b>--help</b>
       <b>r.in.xyz</b>   [-<b>sgi</b>]   <b>input</b>=<u>name</u>   <b>output</b>=<u>name</u>    [<b>method</b>=<u>string</u>]     [<b>separator</b>=<u>character</u>]     [<b>x</b>=<u>integer</u>]
       [<b>y</b>=<u>integer</u>]   [<b>z</b>=<u>integer</u>]   [<b>skip</b>=<u>integer</u>]   [<b>zrange</b>=<u>min,max</u>]    [<b>zscale</b>=<u>float</u>]    [<b>value_column</b>=<u>integer</u>]
       [<b>vrange</b>=<u>min,max</u>]    [<b>vscale</b>=<u>float</u>]    [<b>type</b>=<u>string</u>]    [<b>percent</b>=<u>integer</u>]    [<b>pth</b>=<u>integer</u>]    [<b>trim</b>=<u>float</u>]
       [--<b>overwrite</b>]  [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-s</b>
           Scan data file for extent then exit

       <b>-g</b>
           In scan mode, print using shell script style

       <b>-i</b>
           Ignore broken lines

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>input</b>=<u>name</u> <b>[required]</b>
           ASCII file containing input data (or "-" to read from stdin)

       <b>output</b>=<u>name</u> <b>[required]</b>
           Name for output raster map

       <b>method</b>=<u>string</u>
           Statistic to use for raster values
           Options: <u>n,</u> <u>min,</u> <u>max,</u> <u>range,</u> <u>sum,</u> <u>mean,</u> <u>stddev,</u> <u>variance,</u> <u>coeff_var,</u>  <u>median,</u>  <u>percentile,</u>  <u>skewness,</u>
           <u>trimmean</u>
           Default: <u>mean</u>
           <b>n</b>: Number of points in cell
           <b>min</b>: Minimum value of point values in cell
           <b>max</b>: Maximum value of point values in cell
           <b>range</b>: Range of point values in cell
           <b>sum</b>: Sum of point values in cell
           <b>mean</b>: Mean (average) value of point values in cell
           <b>stddev</b>: Standard deviation of point values in cell
           <b>variance</b>: Variance of point values in cell
           <b>coeff_var</b>: Coefficient of variance of point values in cell
           <b>median</b>: Median value of point values in cell
           <b>percentile</b>: Pth (nth) percentile of point values in cell
           <b>skewness</b>: Skewness of point values in cell
           <b>trimmean</b>: Trimmed mean of point values in cell

       <b>separator</b>=<u>character</u>
           Field separator
           Special characters: pipe, comma, space, tab, newline
           Default: <u>pipe</u>

       <b>x</b>=<u>integer</u>
           Column number of x coordinates in input file (first column is 1)
           Default: <u>1</u>

       <b>y</b>=<u>integer</u>
           Column number of y coordinates in input file
           Default: <u>2</u>

       <b>z</b>=<u>integer</u>
           Column number of data values in input file
           If  a separate value column is given, this option refers to the z-coordinate column to be filtered by
           the zrange option
           Default: <u>3</u>

       <b>skip</b>=<u>integer</u>
           Number of header lines to skip at top of input file
           Default: <u>0</u>

       <b>zrange</b>=<u>min,max</u>
           Filter range for z data (min,max)

       <b>zscale</b>=<u>float</u>
           Scale to apply to z data
           Default: <u>1.0</u>

       <b>value_column</b>=<u>integer</u>
           Alternate column number of data values in input file
           If not given (or set to 0) the z-column data is used
           Default: <u>0</u>

       <b>vrange</b>=<u>min,max</u>
           Filter range for alternate value column data (min,max)

       <b>vscale</b>=<u>float</u>
           Scale to apply to alternate value column data
           Default: <u>1.0</u>

       <b>type</b>=<u>string</u>
           Type of raster map to be created
           Storage type for resultant raster map
           Options: <u>CELL,</u> <u>FCELL,</u> <u>DCELL</u>
           Default: <u>FCELL</u>
           <b>CELL</b>: Integer
           <b>FCELL</b>: Single precision floating point
           <b>DCELL</b>: Double precision floating point

       <b>percent</b>=<u>integer</u>
           Percent of map to keep in memory
           Options: <u>1-100</u>
           Default: <u>100</u>

       <b>pth</b>=<u>integer</u>
           Pth percentile of the values
           Options: <u>1-100</u>

       <b>trim</b>=<u>float</u>
           Discard &lt;trim&gt; percent of the smallest and &lt;trim&gt; percent of the largest observations
           Options: <u>0-50</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>r.in.xyz</u> module will load and bin ungridded x,y,z ASCII data into a new  raster  map.  The  user  may
       choose  from  a  variety  of  statistical  methods in creating the new raster. Gridded data provided as a
       stream of x,y,z points may also be imported.

       Please note that the current region extents and resolution are used  for  the  import.  It  is  therefore
       recommended  to  first use the <b>-s</b> flag to get the extents of the input points to be imported, then adjust
       the current region accordingly, and only then proceed with the actual import.

       <u>r.in.xyz</u> is designed for processing massive point cloud datasets, for example raw LIDAR or sidescan sonar
       swath data. It has been tested with datasets as large as tens of billion of points  (705GB  in  a  single
       file).

       Available statistics for populating the raster are (<b>method</b>):

       <u>n</u>                                                            number of points in cell

       <u>min</u>                                                          minimum value of points in cell

       <u>max</u>                                                          maximum value of points in cell

       <u>range</u>                                                        range of points in cell

       <u>sum</u>                                                          sum of points in cell

       <u>mean</u>                                                         average value of points in cell

       <u>stddev</u>                                                       standard deviation of points in cell

       <u>variance</u>                                                     variance of points in cell

       <u>coeff_var</u>                                                    coefficient of variance of points in cell

       <u>median</u>                                                       median value of points in cell

       <u>percentile</u>                                                   p<u>th</u> percentile of points in cell

       <u>skewness</u>                                                     skewness of points in cell

       <u>trimmean</u>                                                     trimmed mean of points in cell

           •   <u>Variance</u> and derivatives use the biased estimator (n). [subject to change]

           •   <u>Coefficient</u> <u>of</u> <u>variance</u> is given in percentage and defined as (stddev/mean)*100.

       It  is  also  possible  to  bin  and  store  another  data column (e.g. backscatter) while simultaneously
       filtering and scaling both the data column values and the z range.

</pre><h4><b>NOTES</b></h4><pre>
   <b>Gridded</b> <b>data</b>
       If data is known to be on a regular grid <u>r.in.xyz</u> can reconstruct the map perfectly as long as some  care
       is  taken  to  set  up  the region correctly and that the data’s native map projection is used. A typical
       method would  involve  determining  the  grid  resolution  either  by  examining  the  data’s  associated
       documentation  or  by  studying the text file. Next scan the data with <u>r.in.xyz</u>’s <b>-s</b> (or <b>-g</b>) flag to find
       the input data’s bounds. GRASS uses the cell-center raster convention where data points fall  within  the
       center  of a cell, as opposed to the grid-node convention. Therefore you will need to grow the region out
       by half a cell in all directions beyond what the scan found in the file.  After  the  region  bounds  and
       resolution  are  set  correctly with <u>g.region</u>, run <u>r.in.xyz</u> using the <u>n</u> method and verify that n=1 at all
       places.  <u>r.univar</u> can help. Once you are confident that the region exactly matches the  data  proceed  to
       run  <u>r.in.xyz</u>  using one of the <u>mean,</u> <u>min,</u> <u>max</u>, or <u>median</u> methods. With n=1 throughout, the result should
       be identical regardless of which of those methods are used.

   <b>Memory</b> <b>use</b>
       While the <b>input</b> file can be arbitrarily large, <u>r.in.xyz</u> will use a large  amount  of  system  memory  for
       large  raster  regions (10000x10000).  If the module refuses to start complaining that there isn’t enough
       memory, use the <b>percent</b> parameter to run the module in several passes.  In addition using a less  precise
       map format (CELL [integer] or FCELL [floating point]) will use less memory than a DCELL [double precision
       floating  point]  <b>output</b>  map.  Methods such as <u>n,</u> <u>min,</u> <u>max,</u> <u>sum</u> will also use less memory, while <u>stddev,</u>
       <u>variance,</u> <u>and</u> <u>coeff_var</u> will use more.  The aggregate functions <u>median,</u> <u>percentile,</u> <u>skewness</u> and  <u>trimmed</u>
       <u>mean</u> will use even more memory and may not be appropriate for use with arbitrarily large input files.

       The  default  map  <b>type</b>=FCELL  is  intended  as compromise between preserving data precision and limiting
       system resource consumption.  If reading data from a stdin stream, the  program  can  only  run  using  a
       single pass.

   <b>Setting</b> <b>region</b> <b>bounds</b> <b>and</b> <b>resolution</b>
       You  can  use  the  <b>-s</b>  scan  flag  to  find the extent of the input data (and thus point density) before
       performing the full import. Use <u>g.region</u> to adjust the region bounds to match. The <b>-g</b>  shell  style  flag
       prints  the  extent  suitable as parameters for <u>g.region</u>.  A suitable resolution can be found by dividing
       the number of input points by the area covered. e.g.
       wc -l inputfile.txt
       g.region -p
       # points_per_cell = n_points / (rows * cols)
       g.region -e
       # UTM project:
       # points_per_sq_m = n_points / (ns_extent * ew_extent)
       # Lat/Lon project:
       # points_per_sq_m = n_points / (ns_extent * ew_extent*cos(lat) * (1852*60)^2)

       If you only intend to interpolate the data with <u>r.to.vect</u> and <u>v.surf.rst</u>, then there is little  point  to
       setting  the  region  resolution so fine that you only catch one data point per cell -- you might as well
       use "v.in.ascii -zbt" directly.

   <b>Filtering</b>
       Points falling outside the current region will be skipped. This includes points falling  <u>exactly</u>  on  the
       southern region bound.  (to capture those adjust the region with "g.region s=s-0.000001"; see <u>g.region</u>)

       Blank lines and comment lines starting with the hash symbol (#) will be skipped.

       The  <b>zrange</b>  parameter  may  be  used for filtering the input data by vertical extent. Example uses might
       include preparing multiple raster sections to be combined into a 3D raster array with <u>r.to.rast3</u>, or  for
       filtering outliers on relatively flat terrain.

       In  varied  terrain  the  user may find that <u>min</u> maps make for a good noise filter as most LIDAR noise is
       from premature hits. The <u>min</u> map may also be useful to find the underlying topography in  a  forested  or
       urban environment if the cells are over sampled.

       The  user  can  use a combination of <u>r.in.xyz</u> <b>output</b> maps to create custom filters. e.g. use <u>r.mapcalc</u> to
       create a mean-(2*stddev) map. [In this example the user may want to  include  a  lower  bound  filter  in
       <u>r.mapcalc</u>  to  remove highly variable points (small <u>n</u>) or run <u>r.neighbors</u> to smooth the stddev map before
       further use.]

   <b>Alternate</b> <b>value</b> <b>column</b>
       The <b>value_column</b> parameter can be used in specialized cases when you want to filter by  z-range  but  bin
       and store another column’s data. For example if you wanted to look at backscatter values between 1000 and
       1500  meters  elevation. This is particularly useful when using <u>r.in.xyz</u> to prepare depth slices for a 3D
       raster — the <b>zrange</b> option defines the depth slice but the data values stored in the voxels  describe  an
       additional dimension. As with the z column, a filtering range and scaling factor may be applied.

   <b>Reprojection</b>
       If  the  raster  map  is to be reprojected, it may be more appropriate to reproject the input points with
       <u>m.proj</u> or <u>cs2cs</u> before running <u>r.in.xyz</u>.

   <b>Interpolation</b> <b>into</b> <b>a</b> <b>DEM</b>
       The vector engine’s topographic abilities introduce a finite memory overhead per vector point which  will
       typically  limit  a  vector map to approximately 3 million points (~ 1750^2 cells). If you want more, use
       the <u>r.to.vect</u> <b>-b</b> flag to skip building topology. Without topology, however, all you’ll be able to do with
       the vector map is display with <u>d.vect</u> and interpolate with <u>v.surf.rst</u>.  Run <u>r.univar</u> on your  raster  map
       to check the number of non-NULL cells and adjust bounds and/or resolution as needed before proceeding.

       Typical commands to create a DEM using a regularized spline fit:
       r.univar lidar_min
       r.to.vect -z type=point in=lidar_min out=lidar_min_pt
       v.surf.rst in=lidar_min_pt elev=lidar_min.rst

   <b>Import</b> <b>of</b> <b>x,y,string</b> <b>data</b>
       <u>r.in.xyz</u>  is  expecting numeric values as z column. In order to perform a occurrence count operation even
       on x,y data with non-numeric attribute(s), the data can be imported using either the x or y coordinate as
       a fake z column for <b>method</b>=n (count number of points per grid cell), the z values are ignored anyway.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Import</b> <b>of</b> <b>x,y,z</b> <b>ASCII</b> <b>into</b> <b>DEM</b>
       Sometimes elevation data are delivered as x,y,z ASCII files  instead  of  a  raster  matrix.  The  import
       procedure  consists  of  a  few steps: calculation of the map extent, setting of the computational region
       accordingly with an additional extension into all directions by half a raster cell in order  to  register
       the elevation points at raster cell centers.

       Note: if the z column is separated by several spaces from the coordinate columns, it may be sufficient to
       adapt the <b>z</b> position value.
       # Important: observe the raster spacing from the ASCII file:
       # ASCII file format (example):
       # 630007.5 228492.5 141.99614
       # 630022.5 228492.5 141.37904
       # 630037.5 228492.5 142.29822
       # 630052.5 228492.5 143.97987
       # ...
       # In this example the distance is 15m in x and y direction.
       # detect extent, print result as g.region parameters
       r.in.xyz input=elevation.xyz separator=space -s -g
       # ... n=228492.5 s=215007.5 e=644992.5 w=630007.5 b=55.578793 t=156.32986
       # set computational region, along with the actual raster resolution
       # as defined by the point spacing in the ASCII file:
       g.region n=228492.5 s=215007.5 e=644992.5 w=630007.5 res=15 -p
       # now enlarge computational region by half a raster cell (here 7.5m) to
       # store the points as cell centers:
       g.region n=n+7.5 s=s-7.5 w=w-7.5 e=e+7.5 -p
       # import XYZ ASCII file, with z values as raster cell values
       r.in.xyz input=elevation.xyz separator=space method=mean output=myelev
       # univariate statistics for verification of raster values
       r.univar myelev

   <b>Import</b> <b>of</b> <b>LiDAR</b> <b>data</b> <b>and</b> <b>DEM</b> <b>creation</b>
       Import  the Jockey’s Ridge, NC, LIDAR dataset (compressed file "lidaratm2.txt.gz"), and process it into a
       clean DEM:
       # scan and set region bounds
       r.in.xyz -s -g separator="," in=lidaratm2.txt
       g.region n=35.969493 s=35.949693 e=-75.620999 w=-75.639999
       g.region res=0:00:00.075 -a
       # create "n" map containing count of points per cell for checking density
       r.in.xyz in=lidaratm2.txt out=lidar_n separator="," method=n zrange=-2,50
       # check point density [rho = n_sum / (rows*cols)]
       r.univar lidar_n
       # create "min" map (elevation filtered for premature hits)
       r.in.xyz in=lidaratm2.txt out=lidar_min separator="," method=min zrange=-2,50
       # set computational region to area of interest
       g.region n=35:57:56.25N s=35:57:13.575N w=75:38:23.7W e=75:37:15.675W
       # check number of non-null cells (try and keep under a few million)
       r.univar lidar_min
       # convert to points
       r.to.vect -z type=point in=lidar_min out=lidar_min_pt
       # interpolate using a regularized spline fit
       v.surf.rst in=lidar_min_pt elev=lidar_min.rst
       # set color scale to something interesting
       r.colors lidar_min.rst rule=bcyr -n -e
       # prepare a 1:1:1 scaled version for NVIZ visualization (for lat/lon input)
       r.mapcalc "lidar_min.rst_scaled = lidar_min.rst / (1852*60)"
       r.colors lidar_min.rst_scaled rule=bcyr -n -e

</pre><h4><b>TODO</b></h4><pre>
           •   Support for multiple map output from a single run.
               method=string[,string,...] output=name[,name,...]
               This can be easily handled by a wrapper script, with the added benefit of it being very simple to
               parallelize that way.

</pre><h4><b>KNOWN</b> <b>ISSUES</b></h4><pre>
           •   "nan" can leak into <u>coeff_var</u> maps.
               Cause unknown. Possible work-around: "r.null setnull=nan"
       If you encounter any problems (or solutions!) please contact the GRASS Development Team.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>g.region,</u> <u>m.proj,</u> <u>r.fillnulls,</u> <u>r.in.ascii,</u>  <u>r.in.pdal,</u>  <u>r3.in.xyz,</u>  <u>r.mapcalc,</u>  <u>r.neighbors,</u>  <u>r.out.xyz,</u>
       <u>r.to.rast3,</u> <u>r.to.vect,</u> <u>r.univar,</u> <u>v.in.ascii,</u> <u>v.surf.rst</u>

        <u>v.lidar.correction,</u> <u>v.lidar.edgedetection,</u> <u>v.lidar.growing,</u> <u>v.outlier,</u> <u>v.surf.bspline</u>

       <u>pv</u> - The UNIX pipe viewer utility

       Overview: Interpolation and Resampling in GRASS GIS

</pre><h4><b>AUTHORS</b></h4><pre>
       Hamish Bowman, Department of Marine Science, University of Otagom New Zealand
       Extended  by  Volker Wichmann to support the aggregate functions <u>median,</u> <u>percentile,</u> <u>skewness</u> and <u>trimmed</u>
       <u>mean</u>.

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: r.in.xyz source code (history)

       Accessed: Friday Apr 04 01:19:14 2025

       Main index | Raster index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                     <u><a href="../man1grass/r.in.xyz.1grass.html">r.in.xyz</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>