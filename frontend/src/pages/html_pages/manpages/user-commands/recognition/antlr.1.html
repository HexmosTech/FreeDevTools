<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>antlr - ANother Tool for Language Recognition</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/pccts">pccts_1.33MR33-6.4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       antlr - ANother Tool for Language Recognition

</pre><h4><b>SYNTAX</b></h4><pre>
       <b>antlr</b> [<u>options</u>] <u>grammar_files</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Antlr</u>  converts  an  extended  form  of  context-free  grammar  into  a set of C functions which directly
       implement an efficient form of deterministic recursive-descent LL(k) parser.  Context-free  grammars  may
       be  augmented  with  predicates  to  allow semantics to influence parsing; this allows a form of context-
       sensitive parsing.  Selective backtracking is also available to handle  non-LL(k)  and  even  non-LALR(k)
       constructs.  <u>Antlr</u> also produces a definition of a lexer which can be automatically converted into C code
       for  a  DFA-based  lexer  by  <u>dlg</u>.  Hence, <u>antlr</u> serves a function much like that of <u>yacc</u>, however, it is
       notably more flexible and is more integrated with a lexer generator (<u>antlr</u> directly generates  <u>dlg</u>  code,
       whereas  <u>yacc</u>  and  <u>lex</u> are given independent descriptions).  Unlike <u>yacc</u> which accepts <a href="../man1/LALR.1.html">LALR</a>(1) grammars,
       <u>antlr</u> accepts LL(k) grammars in an extended BNF notation —  which  eliminates  the  need  for  precedence
       rules.

       Like <u>yacc</u> grammars, <u>antlr</u> grammars can use automatically-maintained symbol attribute values referenced as
       dollar  variables.   Further, because <u>antlr</u> generates top-down parsers, arbitrary values may be inherited
       from parent rules (passed like function parameters).   <u>Antlr</u>  also  has  a  mechanism  for  creating  and
       manipulating abstract-syntax-trees.

       There  are  various  other  niceties  in <u>antlr</u>, including the ability to spread one grammar over multiple
       files or even multiple grammars in a single file, the ability to generate a version of the  grammar  with
       actions stripped out (for documentation purposes), and lots more.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-ck</b> <u>n</u>  Use  up  to  <u>n</u>  symbols of lookahead when using compressed (linear approximation) lookahead.  This
              type of lookahead is very cheap to compute and is attempted before full LL(k) lookahead, which  is
              of  exponential  complexity  in  the worst case.  In general, the compressed lookahead can be much
              deeper (e.g, -ck 10) than the full lookahead (which usually must be less than 4).

       <b>-CC</b>    Generate C++ output from both ANTLR and DLG.

       <b>-cr</b>    Generate a cross-reference for all rules.  For each rule, print a list of  all  other  rules  that
              reference it.

       <b>-e1</b>    Ambiguities/errors shown in low detail (default).

       <b>-e2</b>    Ambiguities/errors shown in more detail.

       <b>-e3</b>    Ambiguities/errors shown in excruciating detail.

       <b>-fe</b> file
              Rename <b>err.c</b> to file.

       <b>-fh</b> file
              Rename <b>stdpccts.h</b> header (turns on <b>-gh</b>) to file.

       <b>-fl</b> file
              Rename lexical output, <b>parser.dlg</b>, to file.

       <b>-fm</b> file
              Rename file with lexical mode definitions, <b>mode.h</b>, to file.

       <b>-fr</b> file
              Rename file which remaps globally visible symbols, <b>remap.h</b>, to file.

       <b>-ft</b> file
              Rename <b>tokens.h</b> to file.

       <b>-ga</b>    Generate ANSI-compatible code (default case).  This has not been rigorously tested to be ANSI XJ11
              C  compliant, but it is close.  The normal output of <u>antlr</u> is currently compilable under both K&amp;R,
              ANSI C, and C++—this option does nothing because <u>antlr</u> generates a bunch of  #ifdef's  to  do  the
              right thing depending on the language.

       <b>-gc</b>    Indicates that <u>antlr</u> should generate no C code, i.e., only perform analysis on the grammar.

       <b>-gd</b>    C  code  is  inserted in each of the <u>antlr</u> generated parsing functions to provide for user-defined
              handling of a detailed parse trace.  The inserted code consists  of  calls  to  the  user-supplied
              macros  or functions called <b>zzTRACEIN</b> and <b>zzTRACEOUT</b>.  The only argument is a <u>char</u> <u>*</u> pointing to a
              C-style string which is the grammar rule recognized  by  the  current  parsing  function.   If  no
              definition  is  given for the trace functions, upon rule entry and exit, a message will be printed
              indicating that a particular rule as been entered or exited.

       <b>-ge</b>    Generate an error class for each non-terminal.

       <b>-gh</b>    Generate <b>stdpccts.h</b> for non-ANTLR-generated files to include.   This  file  contains  all  defines
              needed  to  describe  the  type  of parser generated by <u>antlr</u> (e.g. how much lookahead is used and
              whether or not trees are constructed) and contains the <b>header</b> action specified by the user.

       <b>-gk</b>    Generate parsers that delay lookahead fetches until needed.  Without this option, <u>antlr</u>  generates
              parsers which always have <u>k</u> tokens of lookahead available.

       <b>-gl</b>    Generate  line  info about grammar actions in C parser of the form <b>#</b> <u>line</u> <b>"</b><u>file</u><b>"</b> which makes error
              messages from the C/C++ compiler make more sense as they will point into the grammar file not  the
              resulting  C  file.   Debugging is easier as well, because you will step through the grammar not C
              file.

       <b>-gs</b>    Do not generate sets for token expression lists;  instead  generate  a  <b>||</b>-separated  sequence  of
              <b><a href="../man1/LA.1.html">LA</a>(1)==</b><u>token_number</u>.  The default is to generate sets.

       <b>-gt</b>    Generate code for Abstract-Syntax Trees.

       <b>-gx</b>    Do not create the lexical analyzer files (dlg-related).  This option should be given when the user
              wishes  to  provide  a  customized lexical analyzer.  It may also be used in <u>make</u> scripts to cause
              only the parser to be rebuilt when a change not affecting the lexical structure  is  made  to  the
              input grammars.

       <b>-k</b> <u>n</u>   Set k of LL(k) to <u>n</u>; i.e. set tokens of look-ahead (default==1).

       <b>-o</b> dir Directory  where  output  files should go (default=".").  This is very nice for keeping the source
              directory clear of ANTLR and DLG spawn.

       <b>-p</b>     The complete grammar, collected from all input grammar files and  stripped  of  all  comments  and
              embedded actions, is listed to <b>stdout</b>.  This is intended to aid in viewing the entire grammar as a
              whole  and to eliminate the need to keep actions concisely stated so that the grammar is easier to
              read.  Hence, it is preferable to embed even complex actions directly in the grammar, rather  than
              to call them as subroutines, since the subroutine call overhead will be saved.

       <b>-pa</b>    This  option  is the same as <b>-p</b> except that the output is annotated with the first sets determined
              from grammar analysis.

       <b>-prc</b> <b>on</b>
              Turn on the computation and hoisting of predicate context.

       <b>-prc</b> <b>off</b>
              Turn off the computation and hoisting of predicate context.  This option makes  1.10  behave  like
              the 1.06 release with option <b>-pr</b> on.  Context computation is off by default.

       <b>-rl</b> <u>n</u>  Limit  the  maximum  number  of  tree nodes used by grammar analysis to <u>n</u>.  Occasionally, <u>antlr</u> is
              unable to analyze a grammar submitted by the user.  This rare situation can only  occur  when  the
              grammar  is large and the amount of lookahead is greater than one.  A nonlinear analysis algorithm
              is used by PCCTS to handle the general case of LL(k) parsing.  The average complexity of analysis,
              however, is near linear due to some fancy footwork in the implementation which reduces the  number
              of  calls  to  the  full  LL(k)  algorithm.   An error message will be displayed, if this limit is
              reached, which indicates the grammar construct being analyzed when <u>antlr</u> hit a non-linearity.  Use
              this option if <u>antlr</u> seems to go out to lunch and your disk start thrashing; try <u>n</u>=10000 to start.
              Once the offending construct has been identified, try to  remove  the  ambiguity  that  <u>antlr</u>  was
              trying  to overcome with large lookahead analysis.  The introduction of (...)? backtracking blocks
              eliminates some of these problems — <u>antlr</u> does not analyze alternatives that begin with (...)? (it
              simply backtracks, if necessary, at run time).

       <b>-w1</b>    Set low warning level.  Do not warn if semantic predicates and/or (...)?  blocks  are  assumed  to
              cover ambiguous alternatives.

       <b>-w2</b>    Ambiguous  parsing decisions yield warnings even if semantic predicates or (...)? blocks are used.
              Warn if predicate context computed and semantic predicates incompletely  disambiguate  alternative
              productions.

       <b>-</b>      Read grammar from standard input and generate <b>stdin.c</b> as the parser file.

</pre><h4><b>SPECIAL</b> <b>CONSIDERATIONS</b></h4><pre>
       <u>Antlr</u> works...  we think.  There is no implicit guarantee of anything.  We reserve no <b>legal</b> rights to the
       software  known as the Purdue Compiler Construction Tool Set (PCCTS) — PCCTS is in the public domain.  An
       individual or company may do whatever they wish with source code  distributed  with  PCCTS  or  the  code
       generated  by  PCCTS,  including the incorporation of PCCTS, or its output, into commercial software.  We
       encourage users to develop software with PCCTS.  However, we do ask  that  credit  is  given  to  us  for
       developing PCCTS.  By "credit", we mean that if you incorporate our source code into one of your programs
       (commercial  product,  research  project,  or  otherwise) that you acknowledge this fact somewhere in the
       documentation, research report, etc...  If you like PCCTS and have developed a nice tool with the output,
       please mention that you developed it using PCCTS.  As long as these guidelines are followed, we expect to
       continue enhancing this system and expect to make other tools available as they are completed.

</pre><h4><b>FILES</b></h4><pre>
       *.c    output C parser.

       *.cpp  output C++ parser when C++ mode is used.

       <b>parser.dlg</b>
              output <u>dlg</u> lexical analyzer.

       <b>err.c</b>  token string array, error sets and error support routines.  Not used in C++ mode.

       <b>remap.h</b>
              file that redefines all globally visible parser symbols.  The use of the #parser directive creates
              this file.  Not used in C++ mode.

       <b>stdpccts.h</b>
              list of definitions needed by C files, not generated by PCCTS, that reference PCCTS objects.  This
              is not generated by default.  Not used in C++ mode.

       <b>tokens.h</b>
              output <u>#defines</u> for tokens used and function prototypes for functions generated for rules.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/dlg.1.html">dlg</a>(1), <a href="../man1/pccts.1.html">pccts</a>(1)

ANTLR                                            September 1995                                         <u><a href="../man1/ANTLR.1.html">ANTLR</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>