<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>podman-create - Create a new container</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/podman">podman_5.4.1+ds1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       podman-create - Create a new container

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>podman</b> <b>create</b> [<u>options</u>] <u>image</u> [<u>command</u> [<u>arg</u> ...]]

       <b>podman</b> <b>container</b> <b>create</b> [<u>options</u>] <u>image</u> [<u>command</u> [<u>arg</u> ...]]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Creates  a  writable  container  layer over the specified image and prepares it for running the specified
       command. The container ID is then printed to STDOUT.  This  is  similar  to  <b>podman</b>  <b>run</b>  <b>-d</b>  except  the
       container is never started. Use the <b>podman</b> <b>start</b> <u>container</u> command to start the container at any point.

       The initial status of the container created with <b>podman</b> <b>create</b> is 'created'.

       Default  settings  for flags are defined in <b>containers.conf</b>. Most settings for remote connections use the
       server's containers.conf, except when documented in man pages.

</pre><h4><b>IMAGE</b></h4><pre>
       The image is specified using transport:path format. If no transport is specified, the  <b>docker</b>  (container
       registry)  transport  is  used  by default. For remote Podman, including Mac and Windows (excluding WSL2)
       machines, <b>docker</b> is the only allowed transport.

       <b>dir:</b><u>path</u>
         An existing local directory <u>path</u> storing the manifest, layer  tarballs  and  signatures  as  individual
       files.  This  is  a  non-standardized  format,  primarily  useful  for debugging or noninvasive container
       inspection.

       $ podman save --format docker-dir fedora -o /tmp/fedora
       $ podman create dir:/tmp/fedora echo hello

       <b>docker://</b><u>docker-reference</u> (Default)
         An    image    reference    stored    in     a    remote    container    image    registry.    Example:
       "quay.io/podman/stable:latest".  The reference can include a path to a specific registry; if it does not,
       the  registries  listed  in registries.conf is queried to find a matching image.  By default, credentials
       from <b>podman</b> <b>login</b> (stored at $XDG_RUNTIME_DIR/containers/auth.json by default) is used  to  authenticate;
       otherwise it falls back to using credentials in $HOME/.docker/config.json.

       $ podman create registry.fedoraproject.org/fedora:latest echo hello

       <b>docker-archive:</b><u>path</u>[<b>:</b><u>docker-reference</u>]  An  image  stored  in  the  <b>docker</b>  <b>save</b>  formatted file. <u>docker-</u>
       <u>reference</u> is only used when creating such a file, and it must not contain a digest.

       $ podman save --format docker-archive fedora -o /tmp/fedora
       $ podman create docker-archive:/tmp/fedora echo hello

       <b>docker-daemon:</b><u>docker-reference</u>
         An image in <u>docker-reference</u> format stored in the docker daemon internal storage. The  <u>docker-reference</u>
       can also be an image ID (docker-daemon:algo:digest).

       $ sudo docker pull fedora
       $ sudo podman create docker-daemon:docker.io/library/fedora echo hello

       <b>oci-archive:</b><u>path</u><b>:</b><u>tag</u>
         An image in a directory compliant with the "Open Container Image Layout Specification" at the specified
       <u>path</u> and specified with a <u>tag</u>.

       $ podman save --format oci-archive fedora -o /tmp/fedora
       $ podman create oci-archive:/tmp/fedora echo hello

</pre><h4><b>OPTIONS</b></h4><pre>
   <b>--add-host=</b><u><b>hostname[;hostname[;...]]</b></u><b>:</b><u><b>ip</b></u>
       Add a custom host-to-IP mapping to the container's <b><a href="file:/etc/hosts">/etc/hosts</a></b> file.

       The  option  takes  one  or  multiple semicolon-separated hostnames to be mapped to a single IPv4 or IPv6
       address, separated by a colon. It can also be used to overwrite the IP addresses of hostnames Podman adds
       to <b><a href="file:/etc/hosts">/etc/hosts</a></b> by default (also see the <b>--name</b> and <b>--hostname</b>  options).  This  option  can  be  specified
       multiple  times  to  add  additional  mappings to <b><a href="file:/etc/hosts">/etc/hosts</a></b>. It conflicts with the <b>--no-hosts</b> option and
       conflicts with <u>no_hosts=true</u> in <b>containers.conf</b>.

       Instead of an IP address, the special flag <u>host-gateway</u> can be given. This resolves to an IP address  the
       container  can  use  to  connect  to  the host. The IP address chosen depends on your network setup, thus
       there's no guarantee that Podman can determine the <u>host-gateway</u> address automatically,  which  will  then
       cause   Podman   to   fail  with  an  error  message.  You  can  overwrite  this  IP  address  using  the
       <u>host_containers_internal_ip</u> option in <u>containers.conf</u>.

       The <u>host-gateway</u> address is also used by Podman to automatically  add  the  <b>host.containers.internal</b>  and
       <b>host.docker.internal</b>  hostnames  to  <b><a href="file:/etc/hosts">/etc/hosts</a></b>.   You  can  prevent that by either giving the <b>--no-hosts</b>
       option, or by setting <u>host_containers_internal_ip="none"</u> in <u>containers.conf</u>. If no  <u>host-gateway</u>  address
       was  configured manually and Podman fails to determine the IP address automatically, Podman will silently
       skip adding these internal hostnames to <b><a href="file:/etc/hosts">/etc/hosts</a></b>. If Podman is  running  in  a  virtual  machine  using
       <b>podman</b>  <b>machine</b>  (this  includes  Mac  and  Windows hosts), Podman will silently skip adding the internal
       hostnames to <b><a href="file:/etc/hosts">/etc/hosts</a></b>, unless an IP  address  was  configured  manually;  the  internal  hostnames  are
       resolved by the gvproxy DNS resolver instead.

       Podman will use the <b><a href="file:/etc/hosts">/etc/hosts</a></b> file of the host as a basis by default, i.e.  any hostname present in this
       file  will  also  be  present  in  the  <b><a href="file:/etc/hosts">/etc/hosts</a></b>  file  of  the container. A different base file can be
       configured using the <u>base_hosts_file</u> config in <b>containers.conf</b>.

   <b>--annotation=</b><u><b>key=value</b></u>
       Add an annotation to the container. This option can be set multiple times.

   <b>--arch=</b><u><b>ARCH</b></u>
       Override the architecture, defaults to hosts, of the image  to  be  pulled.  For  example,  <b>arm</b>.   Unless
       overridden,  subsequent  lookups  of  the  same  image  in  the  local storage matches this architecture,
       regardless of the host.

   <b>--attach,</b> <b>-a=</b><u><b>stdin</b></u> <b>|</b> <u><b>stdout</b></u> <b>|</b> <u><b>stderr</b></u>
       Attach to STDIN, STDOUT or STDERR.

       In foreground mode (the default when <b>-d</b> is not specified), <b>podman</b>  <b>run</b>  can  start  the  process  in  the
       container  and attach the console to the process's standard input, output, and error. It can even pretend
       to be a TTY (this is what most command-line executables expect) and pass along signals. The <b>-a</b> option can
       be set for each of <b>stdin</b>, <b>stdout</b>, and <b>stderr</b>.

   <b>--authfile=</b><u><b>path</b></u>
       Path of the  authentication  file.  Default  is  <b>${XDG_RUNTIME_DIR}/containers/auth.json</b>  on  Linux,  and
       <b>$HOME/.config/containers/auth.json</b>  on  Windows/macOS.   The  file  is  created  by  <b>podman</b> <b>login</b>. If the
       authorization state is not found there, <b>$HOME/.docker/config.json</b> is checked, which is set  using  <b>docker</b>
       <b>login</b>.

       Note:  There  is  also  the option to override the default path of the authentication file by setting the
       <b>REGISTRY_AUTH_FILE</b> environment variable. This can be done with <b>export</b> <b>REGISTRY_AUTH_FILE=</b><u>path.</u>

   <b>--blkio-weight=</b><u><b>weight</b></u>
       Block IO relative weight. The <u>weight</u> is a value between <b>10</b> and <b>1000</b>.

       This option is not supported on cgroups V1 rootless systems.

   <b>--blkio-weight-device=</b><u><b>device:weight</b></u>
       Block IO relative device weight.

   <b>--cap-add=</b><u><b>capability</b></u>
       Add Linux capabilities.

   <b>--cap-drop=</b><u><b>capability</b></u>
       Drop Linux capabilities.

   <b>--cgroup-conf=</b><u><b>KEY=VALUE</b></u>
       When running on cgroup v2, specify the cgroup file to write to  and  its  value.  For  example  <b>--cgroup-</b>
       <b>conf=memory.high=1073741824</b> sets the memory.high limit to 1GB.

   <b>--cgroup-parent=</b><u><b>path</b></u>
       Path  to  cgroups  under  which the cgroup for the container is created. If the path is not absolute, the
       path is considered to be relative to the cgroups path of the init process. Cgroups are created if they do
       not already exist.

   <b>--cgroupns=</b><u><b>mode</b></u>
       Set the cgroup namespace mode for the container.

              • <b>host</b>: use the host's cgroup namespace inside the container.

              • <b>container:</b><u>id</u>: join the namespace of the specified container.

              • <b>private</b>: create a new cgroup namespace.

              • <b>ns:</b><u>path</u>: join the namespace at the specified path.

       If the host uses cgroups v1, the default is set to <b>host</b>. On cgroups v2, the default is <b>private</b>.

   <b>--cgroups=</b><u><b>how</b></u>
       Determines whether the container creates CGroups.

       Default is <b>enabled</b>.

       The <b>enabled</b> option creates a new  cgroup  under  the  cgroup-parent.   The  <b>disabled</b>  option  forces  the
       container to not create CGroups, and thus conflicts with CGroup options (<b>--cgroupns</b> and <b>--cgroup-parent</b>).
       The  <b>no-conmon</b>  option  disables  a  new CGroup only for the <b>conmon</b> process.  The <b>split</b> option splits the
       current CGroup in two sub-cgroups: one for conmon and one for the container payload. It is  not  possible
       to set <b>--cgroup-parent</b> with <b>split</b>.

   <b>--chrootdirs=</b><u><b>path</b></u>
       Path  to a directory inside the container that is treated as a <b>chroot</b> directory.  Any Podman managed file
       (e.g., <a href="file:/etc/resolv.conf">/etc/resolv.conf</a>, <a href="file:/etc/hosts">/etc/hosts</a>, etc/hostname) that is mounted into the  root  directory  is  mounted
       into that location as well.  Multiple directories are separated with a comma.

   <b>--cidfile=</b><u><b>file</b></u>
       Write  the  container  ID  to  <u>file</u>.  The file is removed along with the container, except when used with
       podman --remote run on detached containers.

   <b>--conmon-pidfile=</b><u><b>file</b></u>
       Write the pid of the <b>conmon</b> process to a file. As <b>conmon</b> runs in a separate process than Podman, this  is
       necessary when using systemd to restart Podman containers.  (This option is not available with the remote
       Podman client, including Mac and Windows (excluding WSL2) machines)

   <b>--cpu-period=</b><u><b>limit</b></u>
       Set the CPU period for the Completely Fair Scheduler (CFS), which is a duration in microseconds. Once the
       container's CPU quota is used up, it will not be scheduled to run until the current period ends. Defaults
       to 100000 microseconds.

       On  some  systems,  changing the resource limits may not be allowed for non-root users. For more details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--cpu-quota=</b><u><b>limit</b></u>
       Limit the CPU Completely Fair Scheduler (CFS) quota.

       Limit  the  container's  CPU usage. By default, containers run with the full CPU resource. The limit is a
       number in microseconds. If a number is provided, the container is allowed to use that much CPU time until
       the CPU period ends (controllable via <b>--cpu-period</b>).

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--cpu-rt-period=</b><u><b>microseconds</b></u>
       Limit the CPU real-time period in microseconds.

       Limit the container's Real Time CPU usage. This option tells the kernel to restrict the container's  Real
       Time CPU usage to the period specified.

       This option is only supported on cgroups V1 rootful systems.

   <b>--cpu-rt-runtime=</b><u><b>microseconds</b></u>
       Limit the CPU real-time runtime in microseconds.

       Limit  the  containers Real Time CPU usage. This option tells the kernel to limit the amount of time in a
       given CPU period Real Time tasks may consume. Ex: Period of 1,000,000us and Runtime  of  950,000us  means
       that this container can consume 95% of available CPU and leave the remaining 5% to normal priority tasks.

       The sum of all runtimes across containers cannot exceed the amount allotted to the parent cgroup.

       This option is only supported on cgroups V1 rootful systems.

   <b>--cpu-shares,</b> <b>-c=</b><u><b>shares</b></u>
       CPU shares (relative weight).

       By  default,  all  containers  get  the same proportion of CPU cycles. This proportion can be modified by
       changing the container's CPU share  weighting  relative  to  the  combined  weight  of  all  the  running
       containers.  Default weight is <b>1024</b>.

       The  proportion  only  applies when CPU-intensive processes are running.  When tasks in one container are
       idle, other containers can use the left-over CPU time. The actual amount of CPU time varies depending  on
       the number of containers running on the system.

       For  example,  consider  three  containers,  one  has a cpu-share of 1024 and two others have a cpu-share
       setting of 512. When processes in all three containers attempt to use 100% of CPU,  the  first  container
       receives  50%  of  the total CPU time. If a fourth container is added with a cpu-share of 1024, the first
       container only gets 33% of the CPU. The remaining containers receive 16.5%, 16.5% and 33% of the CPU.

       On a multi-core system, the shares of CPU time are distributed over all CPU cores. Even if a container is
       limited to less than 100% of CPU time, it can use 100% of each individual CPU core.

       For example, consider a system with more than three cores.  If the container <u>C0</u> is  started  with  <b>--cpu-</b>
       <b>shares=512</b>  running  one  process, and another container <u>C1</u> with <b>--cpu-shares=1024</b> running two processes,
       this can result in the following division of CPU shares:

       ┌─────┬───────────┬─────┬──────────────┐
       │ <b>PID</b> │ <b>container</b> │ <b>CPU</b> │ <b>CPU</b> <b>share</b>    │
       ├─────┼───────────┼─────┼──────────────┤
       │ 100 │ C0        │ 0   │ 100% of CPU0 │
       ├─────┼───────────┼─────┼──────────────┤
       │ 101 │ C1        │ 1   │ 100% of CPU1 │
       ├─────┼───────────┼─────┼──────────────┤
       │ 102 │ C1        │ 2   │ 100% of CPU2 │
       └─────┴───────────┴─────┴──────────────┘

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--cpus=</b><u><b>number</b></u>
       Number of CPUs. The default is <u>0.0</u> which means no limit. This is shorthand for  <b>--cpu-period</b>  and  <b>--cpu-</b>
       <b>quota</b>, therefore the option cannot be specified with <b>--cpu-period</b> or <b>--cpu-quota</b>.

       On  some  systems,  changing  the CPU limits may not be allowed for non-root users. For more details, see
       https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-
       limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--cpuset-cpus=</b><u><b>number</b></u>
       CPUs in which to allow execution. Can be specified as a comma-separated list (e.g. <b>0,1</b>), as a range (e.g.
       <b>0-3</b>), or any combination thereof (e.g. <b>0-3,7,11-15</b>).

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--cpuset-mems=</b><u><b>nodes</b></u>
       Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.

       If there are four memory nodes on the system (0-3), use <b>--cpuset-mems=0,1</b> then processes in the container
       only uses memory from the first two memory nodes.

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--decryption-key=</b><u><b>key[:passphrase]</b></u>
       The [key[:passphrase]] to be used for decryption of images. Key can point to  keys  and/or  certificates.
       Decryption  is  tried with all keys. If the key is protected by a passphrase, it is required to be passed
       in the argument and omitted otherwise.

   <b>--device=</b><u><b>host-device[:container-device][:permissions]</b></u>
       Add a host device to the container.  Optional  <u>permissions</u>  parameter  can  be  used  to  specify  device
       permissions by combining <b>r</b> for read, <b>w</b> for write, and <b>m</b> for <b><a href="../man2/mknod.2.html">mknod</a></b>(2).

       Example: <b>--device=/dev/sdc:/dev/xvdc:rwm</b>.

       Note:  if  <u>host-device</u> is a symbolic link then it is resolved first.  The container only stores the major
       and minor numbers of the host device.

       Podman may load kernel modules required for using the specified device. The  devices  that  Podman  loads
       modules for when necessary are: /dev/fuse.

       In  rootless  mode,  the  new  device  is  bind mounted in the container from the host rather than Podman
       creating it within the container space. Because the bind mount  retains  its  SELinux  label  on  SELinux
       systems,  the  container  can  get  permission  denied  when accessing the mounted device. Modify SELinux
       settings to allow containers to use all device labels via the following command:

       $ sudo setsebool -P  container_use_devices=true

       Note: if the user only has access rights via a  group,  accessing  the  device  from  inside  a  rootless
       container  fails. Use the <b>--group-add</b> <b>keep-groups</b> flag to pass the user's supplementary group access into
       the container.

   <b>--device-cgroup-rule=</b><u><b>"type</b></u> <u><b>major:minor</b></u> <u><b>mode"</b></u>
       Add a rule to the cgroup allowed devices list. The rule is expected to be in the format specified in  the
       Linux  kernel  documentation  admin-guide/cgroup-v1/devices:  -  <u>type</u>: <b>a</b> (all), <b>c</b> (char), or <b>b</b> (block); -
       <u>major</u> and <u>minor</u>: either a number, or <b>*</b> for all; - <u>mode</u>: a composition of  <b>r</b>  (read),  <b>w</b>  (write),  and  <b>m</b>
       (<a href="../man2/mknod.2.html">mknod</a>(2)).

   <b>--device-read-bps=</b><u><b>path:rate</b></u>
       Limit read rate (in bytes per second) from a device (e.g. <b>--device-read-bps=/dev/sda:1mb</b>).

       On  some  systems,  changing the resource limits may not be allowed for non-root users. For more details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--device-read-iops=</b><u><b>path:rate</b></u>
       Limit read rate (in IO operations per second) from a device (e.g. <b>--device-read-iops=/dev/sda:1000</b>).

       On  some  systems,  changing the resource limits may not be allowed for non-root users. For more details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--device-write-bps=</b><u><b>path:rate</b></u>
       Limit write rate (in bytes per second) to a device (e.g. <b>--device-write-bps=/dev/sda:1mb</b>).

       On  some  systems,  changing the resource limits may not be allowed for non-root users. For more details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--device-write-iops=</b><u><b>path:rate</b></u>
       Limit write rate (in IO operations per second) to a device (e.g. <b>--device-write-iops=/dev/sda:1000</b>).

       On  some  systems,  changing the resource limits may not be allowed for non-root users. For more details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--disable-content-trust</b>
       This  is  a  Docker-specific  option  to  disable  image  verification to a container registry and is not
       supported by Podman. This option is a NOOP and provided solely for scripting compatibility.

   <b>--dns=</b><u><b>ipaddr</b></u>
       Set custom DNS servers.

       This option can be used to override the DNS configuration passed to  the  container.  Typically  this  is
       necessary  when  the  host DNS configuration is invalid for the container (e.g., <b>127.0.0.1</b>). When this is
       the case the <b>--dns</b> flag is necessary for every run.

       The special value <b>none</b> can be specified to disable creation  of  <u><a href="file:/etc/resolv.conf">/etc/resolv.conf</a></u>  in  the  container  by
       Podman.  The <u><a href="file:/etc/resolv.conf">/etc/resolv.conf</a></u> file in the image is used without changes.

       This option cannot be combined with <b>--network</b> that is set to <b>none</b> or <b>container:</b><u>id</u>.

   <b>--dns-option=</b><u><b>option</b></u>
       Set custom DNS options. Invalid if using <b>--dns-option</b> with <b>--network</b> that is set to <b>none</b> or <b>container:</b><u>id</u>.

   <b>--dns-search=</b><u><b>domain</b></u>
       Set  custom  DNS  search  domains.  Invalid  if  using <b>--dns-search</b> with <b>--network</b> that is set to <b>none</b> or
       <b>container:</b><u>id</u>.  Use <b>--dns-search=.</b> to remove the search domain.

   <b>--entrypoint=</b><u><b>"command"</b></u> <b>|</b> <u><b>'["command",</b></u> <u><b>arg1</b></u> <u><b>,</b></u> <u><b>...]'</b></u>
       Override the default ENTRYPOINT from the image.

       The ENTRYPOINT of an image is similar to a COMMAND because it specifies what executable to run  when  the
       container  starts, but it is (purposely) more difficult to override. The ENTRYPOINT gives a container its
       default nature or behavior. When the ENTRYPOINT is set, the container runs as if  it  were  that  binary,
       complete with default options. More options can be passed in via the COMMAND. But, if a user wants to run
       something else inside the container, the <b>--entrypoint</b> option allows a new ENTRYPOINT to be specified.

       Specify multi option commands in the form of a json string.

   <b>--env,</b> <b>-e=</b><u><b>env</b></u>
       Set environment variables.

       This  option  allows  arbitrary  environment  variables that are available for the process to be launched
       inside of the container. If an environment variable is specified without a value, Podman checks the  host
       environment  for  a  value  and  set the variable only if it is set on the host. As a special case, if an
       environment variable ending in <b>*</b> is specified without a value, Podman searches the host  environment  for
       variables starting with the prefix and adds those variables to the container.

       See ⟨#environment⟩ note below for precedence and examples.

   <b>--env-file=</b><u><b>file</b></u>
       Read in a line-delimited file of environment variables.

       See ⟨#environment⟩ note below for precedence and examples.

   <b>--env-host</b>
       Use  host environment inside of the container. See <b>Environment</b> note below for precedence. (This option is
       not available with the remote Podman client, including Mac and Windows (excluding WSL2) machines)

   <b>--env-merge=</b><u><b>env</b></u>
       Preprocess default environment variables for the containers. For example if  image  contains  environment
       variable  <b>hello=world</b>  user  can  preprocess  it  using  <b>--env-merge</b>  <b>hello=${hello}-some</b> so new value is
       <b>hello=world-some</b>.

       Please note that if the environment variable <b>hello</b> is not present in the image, then it'll be replaced by
       an empty string  and  so  using  <b>--env-merge</b>  <b>hello=${hello}-some</b>  would  result  in  the  new  value  of
       <b>hello=-some</b>, notice the leading <b>-</b> delimiter.

   <b>--expose=</b><u><b>port[/protocol]</b></u>
       Expose a port or a range of ports (e.g. <b>--expose=3300-3310</b>).  The protocol can be <b>tcp</b>, <b>udp</b> or <b>sctp</b> and if
       not  given <b>tcp</b> is assumed.  This option matches the EXPOSE instruction for image builds and has no effect
       on the actual networking rules unless <b>-P/--publish-all</b> is used to  forward  to  all  exposed  ports  from
       random host ports. To forward specific ports from the host into the container use the <b>-p/--publish</b> option
       instead.

   <b>--gidmap=</b><u><b>[flags]container_uid:from_uid[:amount]</b></u>
       Run  the container in a new user namespace using the supplied GID mapping. This option conflicts with the
       <b>--userns</b> and <b>--subgidname</b> options. This option provides a way to map host GIDs to container GIDs  in  the
       same way as <b>--uidmap</b> maps host UIDs to container UIDs. For details see <b>--uidmap</b>.

       Note: the <b>--gidmap</b> option cannot be called in conjunction with the <b>--pod</b> option as a gidmap cannot be set
       on the container level when in a pod.

   <b>--gpus=</b><u><b>ENTRY</b></u>
       GPU devices to add to the container ('all' to pass all GPUs) Currently only Nvidia devices are supported.

   <b>--group-add=</b><u><b>group</b></u> <b>|</b> <u><b>keep-groups</b></u>
       Assign additional groups to the primary user running within the container process.

              • <b>keep-groups</b> is a special flag that tells Podman to keep the supplementary group access.

       Allows  container  to  use  the  user's  supplementary  group access. If file systems or devices are only
       accessible by the rootless user's group, this flag tells the OCI runtime to pass the  group  access  into
       the  container. Currently only available with the <b>crun</b> OCI runtime. Note: <b>keep-groups</b> is exclusive, other
       groups cannot be specified with this flag. (Not available for remote commands, including Mac and  Windows
       (excluding WSL2) machines)

   <b>--group-entry=</b><u><b>ENTRY</b></u>
       Customize the entry that is written to the <b><a href="file:/etc/group">/etc/group</a></b> file within the container when <b>--user</b> is used.

       The  variables  $GROUPNAME, $GID, and $USERLIST are automatically replaced with their value at runtime if
       present.

   <b>--health-cmd=</b><u><b>"command"</b></u> <b>|</b> <u><b>'["command",</b></u> <u><b>arg1</b></u> <u><b>,</b></u> <u><b>...]'</b></u>
       Set or alter a healthcheck command for a container. The command is a command to be  executed  inside  the
       container  that determines the container health. The command is required for other healthcheck options to
       be applied. A value of <b>none</b> disables existing healthchecks.

       Multiple options can be passed in the form of a JSON array; otherwise, the command is interpreted  as  an
       argument to <b><a href="file:/bin/sh">/bin/sh</a></b> <b>-c</b>.

   <b>--health-interval=</b><u><b>interval</b></u>
       Set  an  interval  for  the healthchecks. An <u>interval</u> of <b>disable</b> results in no automatic timer setup. The
       default is <b>30s</b>.

   <b>--health-log-destination=</b><u><b>directory_path</b></u>
       Set the destination of the HealthCheck log. Directory path, local or events_logger (local  use  container
       state file) (Default: local)

              • <b>local</b>:   (default)   HealthCheck   logs   are   stored  in  overlay  containers.  (For  example:
                <b>$runroot/healthcheck.log</b>)

              • <b>directory</b>: creates a log file named <b>&lt;container-ID&gt;-healthcheck.log</b> with HealthCheck logs in  the
                specified directory.

              • <b>events_logger</b>:  The  log  will  be  written with logging mechanism set by events_logger. It also
                saves the log to a default directory, for performance on a system with a large number of logs.

   <b>--health-max-log-count=</b><u><b>number</b></u> <u><b>of</b></u> <u><b>stored</b></u> <u><b>logs</b></u>
       Set maximum number of attempts in the HealthCheck log file.  ('0'  value  means  an  infinite  number  of
       attempts in the log file) (Default: 5 attempts)

   <b>--health-max-log-size=</b><u><b>size</b></u> <u><b>of</b></u> <u><b>stored</b></u> <u><b>logs</b></u>
       Set  maximum  length  in  characters  of stored HealthCheck log. ("0" value means an infinite log length)
       (Default: 500 characters)

   <b>--health-on-failure=</b><u><b>action</b></u>
       Action to take once the container transitions to an unhealthy state.  The default is <b>none</b>.

              • <b>none</b>: Take no action.

              • <b>kill</b>: Kill the container.

              • <b>restart</b>: Restart the container.  Do not combine the <b>restart</b>  action  with  the  <b>--restart</b>  flag.
                When  running  inside  of a systemd unit, consider using the <b>kill</b> or <b>stop</b> action instead to make
                use of systemd's restart policy.

              • <b>stop</b>: Stop the container.

   <b>--health-retries=</b><u><b>retries</b></u>
       The number of retries allowed before a healthcheck is considered to be unhealthy. The default value is <b>3</b>.

   <b>--health-start-period=</b><u><b>period</b></u>
       The initialization time needed for a container to bootstrap. The value can be expressed  in  time  format
       like <b>2m3s</b>. The default value is <b>0s</b>.

       Note:  The  health  check  command  is executed as soon as a container is started, if the health check is
       successful the container's health state will be updated to <b>healthy</b>. However, if the health  check  fails,
       the health state will stay as <b>starting</b> until either the health check is successful or until the <b>--health-</b>
       <b>start-period</b>  time  is  over.  If  the health check command fails after the <b>--health-start-period</b> time is
       over, the health state will be updated to <b>unhealthy</b>.  The health check command is  executed  periodically
       based on the value of <b>--health-interval</b>.

   <b>--health-startup-cmd=</b><u><b>"command"</b></u> <b>|</b> <u><b>'["command",</b></u> <u><b>arg1</b></u> <u><b>,</b></u> <u><b>...]'</b></u>
       Set  a  startup healthcheck command for a container. This command is executed inside the container and is
       used to gate the regular healthcheck. When the startup command succeeds, the regular  healthcheck  begins
       and  the  startup  healthcheck ceases. Optionally, if the command fails for a set number of attempts, the
       container is restarted. A startup healthcheck can be used to ensure  that  containers  with  an  extended
       startup period are not marked as unhealthy until they are fully started. Startup healthchecks can only be
       used when a regular healthcheck (from the container's image or the <b>--health-cmd</b> option) is also set.

   <b>--health-startup-interval=</b><u><b>interval</b></u>
       Set  an interval for the startup healthcheck. An <u>interval</u> of <b>disable</b> results in no automatic timer setup.
       The default is <b>30s</b>.

   <b>--health-startup-retries=</b><u><b>retries</b></u>
       The number of attempts allowed before the startup healthcheck restarts the container. If set  to  <b>0</b>,  the
       container is never restarted. The default is <b>0</b>.

   <b>--health-startup-success=</b><u><b>retries</b></u>
       The  number  of  successful  runs  required  before  the  startup  healthcheck  succeeds  and the regular
       healthcheck begins. A value of <b>0</b> means that any success begins the regular healthcheck. The default is <b>0</b>.

   <b>--health-startup-timeout=</b><u><b>timeout</b></u>
       The maximum time a startup healthcheck command has to complete before it is marked as failed.  The  value
       can be expressed in a time format like <b>2m3s</b>. The default value is <b>30s</b>.

   <b>--health-timeout=</b><u><b>timeout</b></u>
       The maximum time allowed to complete the healthcheck before an interval is considered failed. Like start-
       period, the value can be expressed in a time format such as <b>1m22s</b>. The default value is <b>30s</b>.

   <b>--help</b>
       Print usage statement

   <b>--hostname,</b> <b>-h=</b><u><b>name</b></u>
       Set the container's hostname inside the container.

       This  option can only be used with a private UTS namespace <b>--uts=private</b> (default). If <b>--pod</b> is given and
       the pod shares the same UTS namespace (default), the pod's hostname is used. The given hostname  is  also
       added to the <b><a href="file:/etc/hosts">/etc/hosts</a></b> file using the container's primary IP address (also see the <b>--add-host</b> option).

   <b>--hosts-file=</b><u><b>path</b></u> <b>|</b> <u><b>none</b></u> <b>|</b> <u><b>image</b></u>
       Base  file  to create the <b><a href="file:/etc/hosts">/etc/hosts</a></b> file inside the container. This must either be an absolute path to a
       file on the host system, or one of the following special flags:
         ""      Follow the <b>base_hosts_file</b> configuration in <u>containers.conf</u> (the default)
         <b>none</b>  Do not use a base file (i.e. start with an empty file)
         <b>image</b> Use the container image's <b><a href="file:/etc/hosts">/etc/hosts</a></b> file as base file

   <b>--hostuser=</b><u><b>name</b></u>
       Add a user account to <a href="file:/etc/passwd">/etc/passwd</a> from the host to the container. The Username or UID must exist  on  the
       host system.

   <b>--http-proxy</b>
       By  default proxy environment variables are passed into the container if set for the Podman process. This
       can be disabled by setting the value to <b>false</b>.  The environment variables passed in  include  <b>http_proxy</b>,
       <b>https_proxy</b>,  <b>ftp_proxy</b>,  <b>no_proxy</b>, and also the upper case versions of those. This option is only needed
       when the host system must use a proxy but the  container  does  not  use  any  proxy.  Proxy  environment
       variables specified for the container in any other way overrides the values that have been passed through
       from  the  host.  (Other  ways to specify the proxy for the container include passing the values with the
       <b>--env</b> flag, or hard coding the proxy environment at container build time.)  When  used  with  the  remote
       client it uses the proxy environment variables that are set on the server process.

       Defaults to <b>true</b>.

   <b>--image-volume=bind</b> <b>|</b> <u><b>tmpfs</b></u> <b>|</b> <u><b>ignore</b></u>
       Tells Podman how to handle the builtin image volumes. Default is <b>bind</b>.

              • <b>bind</b>: An anonymous named volume is created and mounted into the container.

              • <b>tmpfs</b>:  The  volume  is  mounted onto the container as a tmpfs, which allows the users to create
                content that disappears when the container is stopped.

              • <b>ignore</b>: All volumes are just ignored and no action is taken.

   <b>--init</b>
       Run an init inside the container that forwards signals and reaps processes.  The container-init binary is
       mounted at <b>/run/podman-init</b>.  Mounting over <b><a href="file:/run">/run</a></b> breaks container execution.

   <b>--init-ctr=</b><u><b>type</b></u>
       (Pods only).  When using pods, create an init style container, which is run after the infra container  is
       started  but  before  regular  pod  containers are started.  Init containers are useful for running setup
       operations for the pod's applications.

       Valid values for <b>init-ctr</b> type are <u>always</u> or <u>once</u>.  The <u>always</u> value means the container runs  with  each
       and  every  <b>pod</b>  <b>start</b>, whereas the <u>once</u> value means the container only runs once when the pod is started
       and then the container is removed.

       Init containers are only run on pod <b>start</b>.  Restarting a  pod  does  not  execute  any  init  containers.
       Furthermore, init containers can only be created in a pod when that pod is not running.

   <b>--init-path=</b><u><b>path</b></u>
       Path to the container-init binary.

   <b>--interactive,</b> <b>-i</b>
       When  set  to  <b>true</b>,  make stdin available to the contained process. If <b>false</b>, the stdin of the contained
       process is empty and immediately closed.

       If attached, stdin is piped to the contained process. If detached, reading stdin will block  until  later
       attached.

       <b>Caveat:</b>  Podman  will  consume  input  from  stdin as soon as it becomes available, even if the contained
       process doesn't request it.

   <b>--ip=</b><u><b>ipv4</b></u>
       Specify a static IPv4 address for the container, for example <b>10.88.64.128</b>.  This option can only be  used
       if the container is joined to only a single network - i.e., <b>--network=network-name</b> is used at most once -
       and  if  the  container  is not joining another container's network namespace via <b>--network=container:</b><u>id.</u>
       <u>The</u> <u>address</u> <u>must</u> <u>be</u> <u>within</u> <u>the</u> <u>network's</u> <u>IP</u> <u>address</u> <u>pool</u> <u>(default</u> <b>10.88.0.0/16</b><u>).</u>

       To specify multiple static IP addresses per container, set multiple networks using the  <b>--network</b>  option
       with a static IP address specified for each using the <b>ip</b> mode for that option.

   <b>--ip6=</b><u><b>ipv6</b></u>
       Specify  a  static  IPv6 address for the container, for example <b>fd46:db93:aa76:ac37::10</b>.  This option can
       only be used if the container is joined to only a single network - i.e., <b>--network=network-name</b>  is  used
       at  most  once  -  and  if  the  container  is  not  joining  another  container's  network namespace via
       <b>--network=container:</b><u>id.</u>  <u>The</u> <u>address</u> <u>must</u> <u>be</u> <u>within</u> <u>the</u> <u>network's</u> <u>IPv6</u> <u>address</u> <u>pool.</u>

       To specify multiple static IPv6 addresses per container, set multiple networks using the <b>--network</b> option
       with a static IPv6 address specified for each using the <b>ip6</b> mode for that option.

   <b>--ipc=</b><u><b>ipc</b></u>
       Set the IPC namespace mode for a container. The default is to create a private IPC namespace.

              • "": Use Podman's default, defined in containers.conf.

              • <b>container:</b><u>id</u>: reuses another container's shared memory, semaphores, and message queues

              • <b>host</b>: use the host's shared memory, semaphores, and message queues inside the  container.  Note:
                the host mode gives the container full access to local shared memory and is therefore considered
                insecure.

              • <b>none</b>:  private IPC namespace, with <a href="file:/dev/shm">/dev/shm</a> not mounted.

              • <b>ns:</b><u>path</u>: path to an IPC namespace to join.

              • <b>private</b>: private IPC namespace.

              • <b>shareable</b>: private IPC namespace with a possibility to share it with other containers.

   <b>--label,</b> <b>-l=</b><u><b>key=value</b></u>
       Add metadata to a container.

   <b>--label-file=</b><u><b>file</b></u>
       Read in a line-delimited file of labels.

   <b>--link-local-ip=</b><u><b>ip</b></u>
       Not implemented.

   <b>--log-driver=</b><u><b>driver</b></u>
       Logging  driver  for the container. Currently available options are <b>k8s-file</b>, <b>journald</b>, <b>none</b>, <b>passthrough</b>
       and <b>passthrough-tty</b>, with <b>json-file</b> aliased to <b>k8s-file</b> for scripting compatibility. (Default <b>journald</b>).

       The podman info command below displays the default log-driver for the system.

       $ podman info --format '{{ .Host.LogDriver }}'
       journald

       The <b>passthrough</b> driver passes down the standard streams (stdin, stdout, stderr) to the container.  It  is
       not  allowed with the remote Podman client, including Mac and Windows (excluding WSL2) machines, and on a
       tty, since it is vulnerable to attacks via TIOCSTI.

       The <b>passthrough-tty</b> driver is the same as <b>passthrough</b> except that it also allows it to be used on  a  TTY
       if the user really wants it.

   <b>--log-opt=</b><u><b>name=value</b></u>
       Logging driver specific options.

       Set custom logging configuration. The following *name*s are supported:

       <b>path</b>: specify a path to the log file
           (e.g. <b>--log-opt</b> <b>path=/var/log/container/mycontainer.json</b>);

       <b>max-size</b>: specify a max size of the log file
           (e.g. <b>--log-opt</b> <b>max-size=10mb</b>);

       <b>tag</b>: specify a custom log tag for the container
           (e.g.  <b>--log-opt</b>  <b>tag="{{.ImageName}}"</b>.   It supports the same keys as <b>podman</b> <b>inspect</b> <b>--format</b>.  This
       option is currently supported only by the <b>journald</b> log driver.

   <b>--mac-address=</b><u><b>address</b></u>
       Container network interface MAC address (e.g. 92:d0:c6:0a:29:33) This option can  only  be  used  if  the
       container is joined to only a single network - i.e., <b>--network=</b><u>network-name</u> <u>is</u> <u>used</u> <u>at</u> <u>most</u> <u>once</u> <u>-</u> <u>and</u> <u>if</u>
       <u>the</u> <u>container</u> <u>is</u> <u>not</u> <u>joining</u> <u>another</u> <u>container's</u> <u>network</u> <u>namespace</u> <u>via</u> <b>--network=container:</b><u>id.</u>

       Remember  that  the  MAC  address  in an Ethernet network must be unique.  The IPv6 link-local address is
       based on the device's MAC address according to RFC4862.

       To specify multiple static MAC addresses per container, set multiple networks using the <b>--network</b>  option
       with a static MAC address specified for each using the <b>mac</b> mode for that option.

   <b>--memory,</b> <b>-m=</b><u><b>number[unit]</b></u>
       Memory limit. A <u>unit</u> can be <b>b</b> (bytes), <b>k</b> (kibibytes), <b>m</b> (mebibytes), or <b>g</b> (gibibytes).

       Allows  the memory available to a container to be constrained. If the host supports swap memory, then the
       <b>-m</b> memory setting can be larger than physical RAM. If a limit of 0  is  specified  (not  using  <b>-m</b>),  the
       container's  memory  is  not  limited.  The actual limit may be rounded up to a multiple of the operating
       system's page size (the value is very large, that's millions of trillions).

       This option is not supported on cgroups V1 rootless systems.

   <b>--memory-reservation=</b><u><b>number[unit]</b></u>
       Memory soft limit. A <u>unit</u> can be <b>b</b> (bytes), <b>k</b> (kibibytes), <b>m</b> (mebibytes), or <b>g</b> (gibibytes).

       After setting memory reservation, when the system detects memory contention or low memory, containers are
       forced to restrict their consumption to their reservation.  So  always  set  the  value  below  <b>--memory</b>,
       otherwise the hard limit takes precedence. By default, memory reservation is the same as memory limit.

       This option is not supported on cgroups V1 rootless systems.

   <b>--memory-swap=</b><u><b>number[unit]</b></u>
       A  limit  value  equal  to memory plus swap.  A <u>unit</u> can be <b>b</b> (bytes), <b>k</b> (kibibytes), <b>m</b> (mebibytes), or <b>g</b>
       (gibibytes).

       Must be used with the <b>-m</b> (<b>--memory</b>) flag.  The argument value must be larger than that of
        <b>-m</b> (<b>--memory</b>) By default, it is set to double the value of <b>--memory</b>.

       Set <u>number</u> to <b>-1</b> to enable unlimited swap.

       This option is not supported on cgroups V1 rootless systems.

   <b>--memory-swappiness=</b><u><b>number</b></u>
       Tune a container's memory swappiness behavior. Accepts an integer between <u>0</u> and <u>100</u>.

       This flag is only supported on cgroups V1 rootful systems.

   <b>--mount=</b><u><b>type=TYPE,TYPE-SPECIFIC-OPTION[,...]</b></u>
       Attach a filesystem mount to the container

       Current supported mount TYPEs are <b>bind</b>, <b>devpts</b>, <b>glob</b>, <b>image</b>, <b>ramfs</b>, <b>tmpfs</b> and <b>volume</b>.

       Options common to all mount types:

              • <u>src</u>, <u>source</u>: mount source spec for <b>bind</b>, <b>glob</b>, and <b>volume</b>.  Mandatory for <b>bind</b> and <b>glob</b>.

              • <u>dst</u>, <u>destination</u>, <u>target</u>: mount destination spec.

       When source globs are specified without the destination directory, the files and directories are  mounted
       with  their  complete  path  within  the  container.  When  the  destination  is specified, the files and
       directories matching the glob on the base file name on the destination directory are mounted. The  option
       <b>type=glob,src=/foo*,destination=/tmp/bar</b>  tells  container  engines to mount host files matching /foo* to
       the /tmp/bar/ directory in the container.

       Options specific to type=<b>volume</b>:

              • <u>ro</u>, <u>readonly</u>: <u>true</u> or <u>false</u> (default if unspecified: <u>false</u>).

              • <u>U</u>, <u>chown</u>: <u>true</u> or <u>false</u> (default if unspecified: <u>false</u>). Recursively change the owner and  group
                of the source volume based on the UID and GID of the container.

              • <u>idmap</u>:  If  specified,  create  an idmapped mount to the target user namespace in the container.
                The idmap option is only supported by Podman in rootful mode. The Linux kernel  does  not  allow
                the  use  of  idmaped  file  systems for unprivileged users.  The idmap option supports a custom
                mapping that can be different than the user namespace used by the container.  The mapping can be
                specified after the  idmap  option  like:  <b>idmap=uids=0-1-10#10-11-10;gids=0-100-10</b>.   For  each
                triplet,  the  first  value  is  the start of the backing file system IDs that are mapped to the
                second value on the host.  The length of this mapping is given in  the  third  value.   Multiple
                ranges  are separated with #.  If the specified mapping is prepended with a '@' then the mapping
                is considered relative to the container user namespace. The host ID for the mapping  is  changed
                to account for the relative position of the container user in the container user namespace.

       Options specific to type=<b>image</b>:

              • <u>rw</u>, <u>readwrite</u>: <u>true</u> or <u>false</u> (default if unspecified: <u>false</u>).

              • <u>subpath</u>: Mount only a specific path within the image, instead of the whole image.

       Options specific to <b>bind</b> and <b>glob</b>:

              • <u>ro</u>, <u>readonly</u>: <u>true</u> or <u>false</u> (default if unspecified: <u>false</u>).

              • <u>bind-propagation</u>:  <u>shared</u>, <u>slave</u>, <u>private</u>, <u>unbindable</u>, <u>rshared</u>, <u>rslave</u>, <u>runbindable</u>, or <b>rprivate</b>
                (default).[1] ⟨#Footnote1⟩ See also <a href="../man2/mount.2.html">mount</a>(2).

              • <u>bind-nonrecursive</u>: do not set up a recursive bind mount. By default it is recursive.

              • <u>relabel</u>: <u>shared</u>, <u>private</u>.

              • <u>idmap</u>: <u>true</u> or <u>false</u> (default if unspecified: <u>false</u>).  If true, create an idmapped mount to  the
                target  user namespace in the container. The idmap option is only supported by Podman in rootful
                mode.

              • <u>U</u>, <u>chown</u>: <u>true</u> or <u>false</u> (default if unspecified: <u>false</u>). Recursively change the owner and  group
                of the source volume based on the UID and GID of the container.

              • <u>no-dereference</u>: do not dereference symlinks but copy the link source into the mount destination.

       Options specific to type=<b>tmpfs</b> and <b>ramfs</b>:

              • <u>ro</u>, <u>readonly</u>: <u>true</u> or <u>false</u> (default if unspecified: <u>false</u>).

              • <u>tmpfs-size</u>: Size of the tmpfs/ramfs mount, in bytes. Unlimited by default in Linux.

              • <u>tmpfs-mode</u>: Octal file mode of the tmpfs/ramfs (e.g. 700 or 0700.).

              • <u>tmpcopyup</u>:  Enable copyup from the image directory at the same location to the tmpfs/ramfs. Used
                by default.

              • <u>notmpcopyup</u>: Disable copying files from the image to the tmpfs/ramfs.

              • <u>U</u>, <u>chown</u>: <u>true</u> or <u>false</u> (default if unspecified: <u>false</u>). Recursively change the owner and  group
                of the source volume based on the UID and GID of the container.

       Options specific to type=<b>devpts</b>:

              • <u>uid</u>: numeric UID of the file owner (default: 0).

              • <u>gid</u>: numeric GID of the file owner (default: 0).

              • <u>mode</u>: octal permission mask for the file (default: 600).

              • <u>max</u>: maximum number of PTYs (default: 1048576).

       Examples:

              • <b>type=bind,source=/path/on/host,destination=/path/in/container</b>

              • <b>type=bind,src=/path/on/host,dst=/path/in/container,relabel=shared</b>

              • <b>type=bind,src=/path/on/host,dst=/path/in/container,relabel=shared,U=true</b>

              • <b>type=devpts,destination=<a href="file:/dev/pts">/dev/pts</a></b>

              • <b>type=glob,src=/usr/lib/libfoo*,destination=<a href="file:/usr/lib">/usr/lib</a>,ro=true</b>

              • <b>type=image,source=fedora,destination=/fedora-image,rw=true</b>

              • <b>type=ramfs,tmpfs-size=512M,destination=/path/in/container</b>

              • <b>type=tmpfs,tmpfs-size=512M,destination=/path/in/container</b>

              • <b>type=tmpfs,destination=/path/in/container,noswap</b>

              • <b>type=volume,source=vol1,destination=/path/in/container,ro=true</b>

   <b>--name=</b><u><b>name</b></u>
       Assign a name to the container.

       The operator can identify a container in three ways:

              • UUID long identifier (“f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778”);

              • UUID short identifier (“f78375b1c487”);

              • Name (“jonah”).

       Podman  generates  a  UUID  for each container, and if no name is assigned to the container using <b>--name</b>,
       Podman generates a random string name. The name can be useful as a more human-friendly  way  to  identify
       containers.  This works for both background and foreground containers. The container's name is also added
       to the <b><a href="file:/etc/hosts">/etc/hosts</a></b> file using the container's primary IP address (also see the <b>--add-host</b> option).

   <b>--network=</b><u><b>mode</b></u><b>,</b> <b>--net</b>
       Set the network mode for the container.

       Valid <u>mode</u> values are:

              • <b>bridge[:OPTIONS,...]</b>: Create a network stack on the default bridge.  This  is  the  default  for
                rootful containers. It is possible to specify these additional options:

                • <b>alias=</b><u>name</u>: Add network-scoped alias for the container.

                • <b>ip=</b><u>IPv4</u>: Specify a static IPv4 address for this container.

                • <b>ip6=</b><u>IPv6</u>: Specify a static IPv6 address for this container.

                • <b>mac=</b><u>MAC</u>: Specify a static MAC address for this container.

                • <b>interface_name=</b><u>name</u>: Specify a name for the created network interface inside the container.

                • <b>host_interface_name=</b><u>name</u>:  Specify  a  name  for  the  created  network  interface outside the
                  container.

              Any other options will be passed through to netavark without validation. This  can  be  useful  to
              pass  arguments  to  netavark  plugins.For  example, to set a static ipv4 address and a static mac
              address, use <b>--network</b> <b>bridge:ip=10.88.0.10,mac=44:33:22:11:00:99</b>.

              • <u>&lt;network</u> <u>name</u> <u>or</u> <u>ID&gt;</u><b>[:OPTIONS,...]</b>: Connect to a user-defined network; this is the network  name
                or  ID  from  a  network  created  by  <b>podman</b> <b>network</b> <b>create</b>. It is possible to specify the same
                options described under the bridge mode above.  Use  the  <b>--network</b>  option  multiple  times  to
                specify additional networks.
                For backwards compatibility it is also possible to specify comma-separated networks on the first
                <b>--network</b>  argument, however this prevents you from using the options described under the bridge
                section above.

              • <b>none</b>: Create a network namespace for the container but do not configure network  interfaces  for
                it, thus the container has no network connectivity.

              • <b>container:</b><u>id</u>: Reuse another container's network stack.

              • <b>host</b>:  Do  not create a network namespace, the container uses the host's network. Note: The host
                mode gives the container full access to local system services such as  D-bus  and  is  therefore
                considered insecure.

              • <b>ns:</b><u>path</u>: Path to a network namespace to join.

              • <b>private</b>:  Create  a  new  namespace  for  the  container.  This uses the <b>bridge</b> mode for rootful
                containers and <b>slirp4netns</b> for rootless ones.

              • <b>slirp4netns[:OPTIONS,...]</b>: use <b><a href="../man1/slirp4netns.1.html">slirp4netns</a></b>(1) to create a user network stack. It is possible  to
                specify   these   additional   options,  they  can  also  be  set  with  <b>network_cmd_options</b>  in
                containers.conf:

                • <b>allow_host_loopback=true|false</b>: Allow slirp4netns to reach the host loopback  IP  (default  is
                  10.0.2.2  or  the  second  IP  from  slirp4netns cidr subnet when changed, see the cidr option
                  below). The default is false.

                • <b>mtu=</b><u>MTU</u>: Specify the MTU to use for this network. (Default is <b>65520</b>).

                • <b>cidr=</b><u>CIDR</u>: Specify ip range to use for this network. (Default is <b>10.0.2.0/24</b>).

                • <b>enable_ipv6=true|false</b>: Enable IPv6. Default is true. (Required for <b>outbound_addr6</b>).

                • <b>outbound_addr=</b><u>INTERFACE</u>: Specify the outbound interface slirp binds to (ipv4 traffic only).

                • <b>outbound_addr=</b><u>IPv4</u>: Specify the outbound ipv4 address slirp binds to.

                • <b>outbound_addr6=</b><u>INTERFACE</u>: Specify the outbound interface slirp binds to (ipv6 traffic only).

                • <b>outbound_addr6=</b><u>IPv6</u>: Specify the outbound ipv6 address slirp binds to.

                • <b>port_handler=rootlesskit</b>: Use rootlesskit for port forwarding. Default.
                  Note: Rootlesskit changes the source IP address of incoming packets to an IP  address  in  the
                  container  network  namespace, usually <b>10.0.2.100</b>. If the application requires the real source
                  IP address, e.g. web server logs, use the  slirp4netns  port  handler.  The  rootlesskit  port
                  handler is also used for rootless containers when connected to user-defined networks.

                • <b>port_handler=slirp4netns</b>:  Use  the slirp4netns port forwarding, it is slower than rootlesskit
                  but preserves the correct source IP address. This port handler cannot be used for user-defined
                  networks.

              • <b>pasta[:OPTIONS,...]</b>: use <b><a href="../man1/pasta.1.html">pasta</a></b>(1) to create a user-mode networking stack.
                This is the default for rootless containers and only supported in rootless mode.
                By default, IPv4 and IPv6 addresses and routes, as well as the pod interface  name,  are  copied
                from  the host. If port forwarding isn't configured, ports are forwarded dynamically as services
                are bound on either side (init namespace or container namespace). Port forwarding preserves  the
                original  source  IP  address. Options described in <a href="../man1/pasta.1.html">pasta</a>(1) can be specified as comma-separated
                arguments.
                In terms of <a href="../man1/pasta.1.html">pasta</a>(1) options, <b>--config-net</b> is given by default, in order to configure networking
                when the container is started, and <b>--no-map-gw</b> is also  assumed  by  default,  to  avoid  direct
                access from container to host using the gateway address. The latter can be overridden by passing
                <b>--map-gw</b> in the pasta-specific options (despite not being an actual <a href="../man1/pasta.1.html">pasta</a>(1) option).
                Also,  <b>-t</b>  <b>none</b> and <b>-u</b> <b>none</b> are passed if, respectively, no TCP or UDP port forwarding from host
                to container is  configured,  to  disable  automatic  port  forwarding  based  on  bound  ports.
                Similarly,  <b>-T</b>  <b>none</b>  and  <b>-U</b> <b>none</b> are given to disable the same functionality from container to
                host.
                Some examples:

                • <b>pasta:--map-gw</b>: Allow the container to directly reach the host using the gateway address.

                • <b>pasta:--mtu,1500</b>: Specify a 1500 bytes MTU for the <u>tap</u> interface in the container.

                • <b>pasta:--ipv4-only,-a,10.0.2.0,-n,24,-g,10.0.2.2,--dns-forward,10.0.2.3,-m,1500,--no-ndp,--no-</b>
                  <b>dhcpv6,--no-dhcp</b>,  equivalent  to  default  <a href="../man1/slirp4netns.1.html">slirp4netns</a>(1)  options:  disable   IPv6,   assign
                  <b>10.0.2.0/24</b>  to  the  <b>tap0</b>  interface  in  the  container,  with  gateway <b>10.0.2.3</b>, enable DNS
                  forwarder reachable at <b>10.0.2.3</b>, set MTU to 1500 bytes, disable NDP, DHCPv6 and DHCP support.

                • <b>pasta:-I,tap0,--ipv4-only,-a,10.0.2.0,-n,24,-g,10.0.2.2,--dns-forward,10.0.2.3,--no-ndp,--no-</b>
                  <b>dhcpv6,--no-dhcp</b>, equivalent to default <a href="../man1/slirp4netns.1.html">slirp4netns</a>(1) options with Podman overrides: same  as
                  above, but leave the MTU to 65520 bytes

                • <b>pasta:-t,auto,-u,auto,-T,auto,-U,auto</b>:  enable  automatic  port  forwarding  based on observed
                  bound ports from both host and container sides

                • <b>pasta:-T,5201</b>: enable forwarding of TCP port 5201 from container to host, using  the  loopback
                  interface instead of the tap interface for improved performance

       Invalid if using <b>--dns</b>, <b>--dns-option</b>, or <b>--dns-search</b> with <b>--network</b> set to <b>none</b> or <b>container:</b><u>id</u>.

       If used together with <b>--pod</b>, the container does not join the pod's network namespace.

   <b>--network-alias=</b><u><b>alias</b></u>
       Add  a  network-scoped  alias  for  the  container, setting the alias for all networks that the container
       joins. To set a name only for a specific network, use the alias option as described under  the  <b>--network</b>
       option.  If the network has DNS enabled (<b>podman</b> <b>network</b> <b>inspect</b> <b>-f</b> <b>{{.DNSEnabled}}</b> <b>&lt;name&gt;</b>), these aliases
       can be used for name resolution on the given network. This option can be specified multiple times.  NOTE:
       When using CNI a container only has access to aliases on the first network that it joins. This limitation
       does not exist with netavark/aardvark-dns.

   <b>--no-healthcheck</b>
       Disable any defined healthchecks for container.

   <b>--no-hostname</b>
       Do not create the <u><a href="file:/etc/hostname">/etc/hostname</a></u> file in the containers.

       By  default,  Podman manages the <u><a href="file:/etc/hostname">/etc/hostname</a></u> file, adding the container's own hostname.  When the <b>--no-</b>
       <b>hostname</b> option is set, the image's <u><a href="file:/etc/hostname">/etc/hostname</a></u> will be preserved unmodified if it exists.

   <b>--no-hosts</b>
       Do not modify the <b><a href="file:/etc/hosts">/etc/hosts</a></b> file in the container.

       Podman assumes control over the  container's  <b><a href="file:/etc/hosts">/etc/hosts</a></b>  file  by  default  and  adds  entries  for  the
       container's   name   (see   <b>--name</b>   option)   and   hostname   (see  <b>--hostname</b>  option),  the  internal
       <b>host.containers.internal</b> and <b>host.docker.internal</b> hosts, as well as any hostname added using  the  <b>--add-</b>
       <b>host</b>  option.  Refer  to the <b>--add-host</b> option for details. Passing <b>--no-hosts</b> disables this, so that the
       image's <b><a href="file:/etc/hosts">/etc/hosts</a></b> file is kept unmodified. The same can be achieved globally by setting <u>no_hosts=true</u> in
       <b>containers.conf</b>.

       This option conflicts with <b>--add-host</b>.

   <b>--oom-kill-disable</b>
       Whether to disable OOM Killer for the container or not.

       This flag is not supported on cgroups V2 systems.

   <b>--oom-score-adj=</b><u><b>num</b></u>
       Tune the host's OOM preferences for containers (accepts values from <b>-1000</b> to <b>1000</b>).

       When running in rootless mode, the specified value can't be lower than the oom_score_adj for the  current
       process. In this case, the oom-score-adj is clamped to the current process value.

   <b>--os=</b><u><b>OS</b></u>
       Override  the OS, defaults to hosts, of the image to be pulled. For example, <b>windows</b>.  Unless overridden,
       subsequent lookups of the same image in the local storage matches this OS, regardless of the host.

   <b>--passwd-entry=</b><u><b>ENTRY</b></u>
       Customize the entry that is written to the <b><a href="file:/etc/passwd">/etc/passwd</a></b> file within the container when <b>--passwd</b> is used.

       The variables $USERNAME, $UID, $GID, $NAME, $HOME are automatically replaced with their value at runtime.

   <b>--personality=</b><u><b>persona</b></u>
       Personality sets the execution domain via Linux <a href="../man2/personality.2.html">personality</a>(2).

   <b>--pid=</b><u><b>mode</b></u>
       Set the PID namespace mode for the container.  The default is to create a private PID namespace  for  the
       container.

              • <b>container:</b><u>id</u>: join another container's PID namespace;

              • <b>host</b>:  use  the  host's  PID namespace for the container. Note the host mode gives the container
                full access to local PID and is therefore considered insecure;

              • <b>ns:</b><u>path</u>: join the specified PID namespace;

              • <b>private</b>: create a new namespace for the container (default).

   <b>--pidfile=</b><u><b>path</b></u>
       When the pidfile location is specified, the container process' PID  is  written  to  the  pidfile.  (This
       option  is  not  available  with  the  remote  Podman  client, including Mac and Windows (excluding WSL2)
       machines)  If  the  pidfile  option  is  not  specified,  the  container  process'  PID  is  written   to
       /run/containers/storage/${storage-driver}-containers/$CID/userdata/pidfile.

       After  the container is started, the location for the pidfile can be discovered with the following <b>podman</b>
       <b>inspect</b> command:

       $ podman inspect --format '{{ .PidFile }}' $CID
       /run/containers/storage/${storage-driver}-containers/$CID/userdata/pidfile

   <b>--pids-limit=</b><u><b>limit</b></u>
       Tune the container's pids limit. Set to <b>-1</b> to have unlimited pids for the container. The default is  <b>2048</b>
       on systems that support "pids" cgroup controller.

   <b>--platform=</b><u><b>OS/ARCH</b></u>
       Specify the platform for selecting the image.  (Conflicts with --arch and --os) The <b>--platform</b> option can
       be used to override the current architecture and operating system.  Unless overridden, subsequent lookups
       of the same image in the local storage matches this platform, regardless of the host.

   <b>--pod=</b><u><b>name</b></u>
       Run  container  in  an  existing pod. Podman makes the pod automatically if the pod name is prefixed with
       <b>new:</b>.  To make a pod with more granular options, use the <b>podman</b> <b>pod</b>  <b>create</b>  command  before  creating  a
       container.   When  a  container is run with a pod with an infra-container, the infra-container is started
       first.

   <b>--pod-id-file=</b><u><b>file</b></u>
       Run container in an existing pod and read the pod's ID from the specified <u>file</u>.  When a container is  run
       within a pod which has an infra-container, the infra-container starts first.

   <b>--privileged</b>
       Give extended privileges to this container. The default is <b>false</b>.

       By  default,  Podman  containers  are  unprivileged (<b>=false</b>) and cannot, for example, modify parts of the
       operating system. This is because by default a container is only allowed limited  access  to  devices.  A
       "privileged"  container is given the same access to devices as the user launching the container, with the
       exception of virtual consoles (<u>/dev/tty\d+</u>) when running in systemd mode (<b>--systemd=always</b>).

       A privileged container turns off the security features that isolate the container from the host.  Dropped
       Capabilities,  limited  devices, read-only mount points, Apparmor/SELinux separation, and Seccomp filters
       are all disabled.  Due to the disabled security features, the privileged field should almost never be set
       as containers can easily break out of confinement.

       Containers running in a user namespace (e.g., rootless containers) cannot have more privileges  than  the
       user that launched them.

   <b>--publish,</b> <b>-p=</b><u><b>[[ip:][hostPort]:]containerPort[/protocol]</b></u>
       Publish a container's port, or range of ports, to the host.

       Both  <u>hostPort</u>  and <u>containerPort</u> can be specified as a range of ports.  When specifying ranges for both,
       the number of container ports in the range must match the number of host ports in the range.

       If host IP is set to 0.0.0.0 or not set at all, the port is bound on all IPs on the host.

       By default, Podman publishes TCP ports. To publish a UDP port instead, give <b>udp</b> as protocol.  To  publish
       both  TCP  and  UDP  ports,  set  <b>--publish</b>  twice,  with <b>tcp</b>, and <b>udp</b> as protocols respectively. Rootful
       containers can also publish ports using the <b>sctp</b> protocol.

       Host port does not have to be specified (e.g. <b>podman</b> <b>run</b> <b>-p</b> <b>127.0.0.1::80</b>).  If it is not, the  container
       port is randomly assigned a port on the host.

       Use <b>podman</b> <b>port</b> to see the actual mapping: <b>podman</b> <b>port</b> <b>$CONTAINER</b> <b>$CONTAINERPORT</b>.

       Note  that  the network drivers <b>macvlan</b> and <b>ipvlan</b> do not support port forwarding, it will have no effect
       on these networks.

       <b>Note:</b> If a container runs within a pod, it is not necessary to publish the port for the containers in the
       pod. The port must only be published by the pod itself. Pod network stacks act like the network stack  on
       the  host - when there are a variety of containers in the pod, and programs in the container, all sharing
       a single interface and IP address, and associated ports. If one container  binds  to  a  port,  no  other
       container can use that port within the pod while it is in use. Containers in the pod can also communicate
       over localhost by having one container bind to localhost in the pod, and another connect to that port.

   <b>--publish-all,</b> <b>-P</b>
       Publish all exposed ports to random ports on the host interfaces. The default is <b>false</b>.

       When set to <b>true</b>, publish all exposed ports to the host interfaces.  If the operator uses <b>-P</b> (or <b>-p</b>) then
       Podman  makes  the exposed port accessible on the host and the ports are available to any client that can
       reach the host.

       When using this option, Podman binds any exposed port to a random port on the host  within  an  ephemeral
       port range defined by <u><a href="file:/proc/sys/net/ipv4/ip_local_port_range">/proc/sys/net/ipv4/ip_local_port_range</a></u>.  To find the mapping between the host ports
       and the exposed ports, use <b>podman</b> <b>port</b>.

   <b>--pull=</b><u><b>policy</b></u>
       Pull image policy. The default is <b>missing</b>.

              • <b>always</b>: Always pull the image and throw an error if the pull fails.

              • <b>missing</b>:  Pull  the  image only when the image is not in the local containers storage.  Throw an
                error if no image is found and the pull fails.

              • <b>never</b>: Never pull the image but use the one from the local containers storage.  Throw  an  error
                if no image is found.

              • <b>newer</b>:  Pull if the image on the registry is newer than the one in the local containers storage.
                An image is considered to be newer when the digests are different.  Comparing the time stamps is
                prone to errors.  Pull errors are suppressed if a local image was found.

   <b>--quiet,</b> <b>-q</b>
       Suppress output information when pulling images

   <b>--rdt-class=</b><u><b>intel-rdt-class-of-service</b></u>
       Rdt-class sets the class of service (CLOS or COS) for the  container  to  run  in.  Based  on  the  Cache
       Allocation  Technology  (CAT)  feature that is part of Intel's Resource Director Technology (RDT) feature
       set, all container processes will run within the pre-configured COS, representing a part  of  the  cache.
       The  COS has to be created and configured using a pseudo file system (usually mounted at <b>/sys/fs/resctrl</b>)
       that the resctrl kernel driver provides. Assigning the container to a COS requires  root  privileges  and
       thus  doesn't  work  in  a rootless environment. Currently, the feature is only supported using <b>runc</b> as a
       runtime. See ⟨https://docs.kernel.org/arch/x86/resctrl.html⟩ for more details on creating a COS before  a
       container can be assigned to it.

   <b>--read-only</b>
       Mount the container's root filesystem as read-only.

       By  default,  container  root  filesystems  are  writable, allowing processes to write files anywhere. By
       specifying the <b>--read-only</b> flag, the containers root filesystem are  mounted  read-only  prohibiting  any
       writes.

   <b>--read-only-tmpfs</b>
       When  running  --read-only  containers,  mount  a  read-write  tmpfs  on  <u><a href="file:/dev">/dev</a></u>, <u><a href="file:/dev/shm">/dev/shm</a></u>, <u><a href="file:/run">/run</a></u>, <u><a href="file:/tmp">/tmp</a></u>, and
       <u><a href="file:/var/tmp">/var/tmp</a></u>. The default is <b>true</b>.

       ┌─────────────┬───────────────────┬─────┬──────────────────────┐
       │ <b>--read-only</b> │ <b>--read-only-tmpfs</b> │ <b>/</b>   │ <b><a href="file:/run">/run</a>,</b> <b><a href="file:/tmp">/tmp</a>,</b> <b><a href="file:/var/tmp">/var/tmp</a></b> │
       ├─────────────┼───────────────────┼─────┼──────────────────────┤
       │ true        │ true              │ r/o │ r/w                  │
       ├─────────────┼───────────────────┼─────┼──────────────────────┤
       │ true        │ false             │ r/o │ r/o                  │
       ├─────────────┼───────────────────┼─────┼──────────────────────┤
       │ false       │ false             │ r/w │ r/w                  │
       ├─────────────┼───────────────────┼─────┼──────────────────────┤
       │ false       │ true              │ r/w │ r/w                  │
       └─────────────┴───────────────────┴─────┴──────────────────────┘

       When <b>--read-only=true</b> and <b>--read-only-tmpfs=true</b> additional tmpfs are mounted  on  the  <a href="file:/tmp">/tmp</a>,  <a href="file:/run">/run</a>,  and
       <a href="file:/var/tmp">/var/tmp</a> directories.

       When <b>--read-only=true</b> and <b>--read-only-tmpfs=false</b> <a href="file:/dev">/dev</a> and <a href="file:/dev/shm">/dev/shm</a> are marked Read/Only and no tmpfs are
       mounted  on  <a href="file:/tmp">/tmp</a>, <a href="file:/run">/run</a> and /var/tmp. The directories are exposed from the underlying image, meaning they
       are read-only by default.  This makes the container totally  read-only.  No  writable  directories  exist
       within the container. In this mode writable directories need to be added via external volumes or mounts.

       By  default,  when  <b>--read-only=false</b>,  the  <a href="file:/dev">/dev</a>  and  <a href="file:/dev/shm">/dev/shm</a>  are read/write, and the <a href="file:/tmp">/tmp</a>, <a href="file:/run">/run</a>, and
       <a href="file:/var/tmp">/var/tmp</a> are read/write directories from the container image.

   <b>--replace</b>
       If another container with the same name already exists, replace and remove it. The default is <b>false</b>.

   <b>--requires=</b><u><b>container</b></u>
       Specify one or more requirements.  A requirement is a dependency container that is  started  before  this
       container.   Containers  can  be  specified  by  name  or ID, with multiple containers being separated by
       commas.

   <b>--restart=</b><u><b>policy</b></u>
       Restart policy to follow when containers exit.  Restart policy does not take effect  if  a  container  is
       stopped via the <b>podman</b> <b>kill</b> or <b>podman</b> <b>stop</b> commands.

       Valid <u>policy</u> values are:

              • <b>no</b>                       : Do not restart containers on exit

              • <b>never</b>                    : Synonym for <b>no</b>; do not restart containers on exit

              • <b>on-failure[:max_retries]</b> : Restart containers when they exit with a non-zero exit code, retrying
                indefinitely or until the optional <u>max_retries</u> count is hit

              • <b>always</b>                    :  Restart  containers  when they exit, regardless of status, retrying
                indefinitely

              • <b>unless-stopped</b>           : Identical to <b>always</b>

       Podman provides a systemd unit file, podman-restart.service, which restarts  containers  after  a  system
       reboot.

       When running containers in systemd services, use the restart functionality provided by systemd.  In other
       words,  do  not  use  this  option in a container unit, instead set the <b>Restart=</b> systemd directive in the
       <b>[Service]</b> section.  See <b><a href="../man5/podman-systemd.unit.5.html">podman-systemd.unit</a></b>(5) and <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5).

   <b>--retry=</b><u><b>attempts</b></u>
       Number of times to retry pulling or pushing images between the registry and  local  storage  in  case  of
       failure. Default is <b>3</b>.

   <b>--retry-delay=</b><u><b>duration</b></u>
       Duration  of  delay  between retry attempts when pulling or pushing images between the registry and local
       storage in case of failure. The default is to start at two seconds and then exponentially back  off.  The
       delay is used when this value is set, and no exponential back off occurs.

   <b>--rm</b>
       Automatically remove the container and any anonymous unnamed volume associated with the container when it
       exits. The default is <b>false</b>.

   <b>--rootfs</b>
       If specified, the first argument refers to an exploded container on the file system.

       This  is useful to run a container without requiring any image management, the rootfs of the container is
       assumed to be managed externally.

       <b>Overlay</b> <b>Rootfs</b> <b>Mounts</b>

       The <b>:O</b> flag tells Podman to mount the directory from the rootfs path as storage using  the  <b>overlay</b>  <b>file</b>
       <b>system</b>.  The  container  processes  can  modify  content  within  the  mount point which is stored in the
       container storage in a separate directory. In overlay terms, the source directory is the lower,  and  the
       container  storage  directory  is  the  upper.  Modifications  to  the mount point are destroyed when the
       container finishes executing, similar to a tmpfs mount point being unmounted.

       Note:  On  <b>SELinux</b>   systems,   the   rootfs   needs   the   correct   label,   which   is   by   default
       <b>unconfined_u:object_r:container_file_t:s0</b>.

       <b>idmap</b>

       If <b>idmap</b> is specified, create an idmapped mount to the target user namespace in the container.  The idmap
       option  supports  a  custom  mapping that can be different than the user namespace used by the container.
       The mapping can be specified after the idmap option like: <b>idmap=uids=0-1-10#10-11-10;gids=0-100-10</b>.   For
       each  triplet,  the first value is the start of the backing file system IDs that are mapped to the second
       value on the host.  The length of this mapping  is  given  in  the  third  value.   Multiple  ranges  are
       separated with #.

   <b>--sdnotify=container</b> <b>|</b> <u><b>conmon</b></u> <b>|</b> <u><b>healthy</b></u> <b>|</b> <u><b>ignore</b></u>
       Determines how to use the NOTIFY_SOCKET, as passed with systemd and Type=notify.

       Default is <b>container</b>, which means allow the OCI runtime to proxy the socket into the container to receive
       ready  notification. Podman sets the MAINPID to conmon's pid.  The <b>conmon</b> option sets MAINPID to conmon's
       pid, and sends READY when the container has started. The socket is never passed to  the  runtime  or  the
       container.   The  <b>healthy</b>  option  sets  MAINPID  to conmon's pid, and sends READY when the container has
       turned healthy; requires a healthcheck to be set. The socket is  never  passed  to  the  runtime  or  the
       container.   The <b>ignore</b> option removes NOTIFY_SOCKET from the environment for itself and child processes,
       for the case where some other process above Podman uses NOTIFY_SOCKET and Podman does not use it.

   <b>--seccomp-policy=</b><u><b>policy</b></u>
       Specify  the  policy  to  select  the  seccomp  profile.  If  set  to   <u>image</u>,   Podman   looks   for   a
       "io.containers.seccomp.profile"  label  in  the  container-image  config  and  use its value as a seccomp
       profile. Otherwise, Podman follows the <u>default</u> policy by applying the default  profile  unless  specified
       otherwise via <u>--security-opt</u> <u>seccomp</u> as described below.

       Note that this feature is experimental and may change in the future.

   <b>--secret=</b><u><b>secret[,opt=opt</b></u> <u><b>...]</b></u>
       Give the container access to a secret. Can be specified multiple times.

       A secret is a blob of sensitive data which a container needs at runtime but is not stored in the image or
       in  source  control,  such  as  usernames  and  passwords,  TLS  certificates and keys, SSH keys or other
       important generic strings or binary content (up to 500 kb in size).

       When secrets are specified as type <b>mount</b>, the secrets are copied and mounted into the  container  when  a
       container  is  created.   When  secrets  are  specified  as type <b>env</b>, the secret is set as an environment
       variable within the container.  Secrets are written in the container at the time of  container  creation,
       and  modifying  the secret using <b>podman</b> <b>secret</b> commands after the container is created affects the secret
       inside the container.

       Secrets and its storage are managed using the <b>podman</b> <b>secret</b> command.

       Secret Options

              • <b>type=mount|env</b>    : How the secret is exposed to the container.
                                    <b>mount</b> mounts the secret into the container as a file.
                                    <b>env</b> exposes the secret as an environment variable.
                                    Defaults to <b>mount</b>.

              • <b>target=target</b>     : Target of secret.
                                    For mounted secrets, this is the path to the secret inside the container.
                                    If a fully qualified path  is  provided,  the  secret  is  mounted  at  that
                location.
                                    Otherwise, the secret is mounted to
                                    <b>/run/secrets/target</b> for linux containers or
                                    <b>/var/run/secrets/target</b> for freebsd containers.
                                    If  the  target is not set, the secret is mounted to <b>/run/secrets/secretname</b>
                by default.
                                    For  env  secrets,  this  is  the  environment  variable  key.  Defaults  to
                <b>secretname</b>.

              • <b>uid=0</b>             : UID of secret. Defaults to 0. Mount secret type only.

              • <b>gid=0</b>             : GID of secret. Defaults to 0. Mount secret type only.

              • <b>mode=0</b>            : Mode of secret. Defaults to 0444. Mount secret type only.

       Examples

       Mount at <b>/my/location/mysecret</b> with UID 1:

       --secret mysecret,target=/my/location/mysecret,uid=1

       Mount at <b>/run/secrets/customtarget</b> with mode 0777:

       --secret mysecret,target=customtarget,mode=0777

       Create a secret environment variable called <b>ENVSEC</b>:

       --secret mysecret,type=env,target=ENVSEC

   <b>--security-opt=</b><u><b>option</b></u>
       Security Options

              • <b>apparmor=unconfined</b> : Turn off apparmor confinement for the container

              • <b>apparmor</b>=<u>alternate-profile</u> : Set the apparmor confinement profile for the container

              • <b>label=user:</b><u>USER</u>: Set the label user for the container processes

              • <b>label=role:</b><u>ROLE</u>: Set the label role for the container processes

              • <b>label=type:</b><u>TYPE</u>: Set the label process type for the container processes

              • <b>label=level:</b><u>LEVEL</u>: Set the label level for the container processes

              • <b>label=filetype:</b><u>TYPE</u>: Set the label file type for the container files

              • <b>label=disable</b>: Turn off label separation for the container

       Note:  Labeling  can  be  disabled  for  all  containers  by  setting  label=false in the <b>containers.conf</b>
       (<b>/etc/containers/containers.conf</b> or <b>$HOME/.config/containers/containers.conf</b>) file.

              • <b>label=nested</b>: Allows SELinux modifications within  the  container.  Containers  are  allowed  to
                modify  SELinux labels on files and processes, as long as SELinux policy allows. Without <b>nested</b>,
                containers view SELinux as disabled, even when  it  is  enabled  on  the  host.  Containers  are
                prevented from setting any labels.

              • <b>mask</b>=<u>/path/1:/path/2</u>:  The  paths to mask separated by a colon. A masked path cannot be accessed
                inside the container.

              • <b>no-new-privileges</b>: Disable container processes from gaining additional privileges.

              • <b>seccomp=unconfined</b>: Turn off seccomp confinement for the container.

              • <b>seccomp=profile.json</b>:  JSON  file  to  be  used   as   a   seccomp   filter.   Note   that   the
                <b>io.podman.annotations.seccomp</b>  annotation  is  set  with  the specified value as shown in <b>podman</b>
                <b>inspect</b>.

              • <b>proc-opts</b>=<u>OPTIONS</u> : Comma-separated list of options to use for the <a href="file:/proc">/proc</a> mount. More details for
                the possible mount options are specified in the <b><a href="../man5/proc.5.html">proc</a>(5)</b> man page.

              • <b>unmask</b>=<u>ALL</u> or <u>/path/1:/path/2</u>, or shell expanded paths (<a href="file:/proc/">/proc/</a>*): Paths to unmask separated by a
                colon. If set to <b>ALL</b>, it unmasks all the paths that are masked or  made  read-only  by  default.
                The   default   masked  paths  are  <b><a href="file:/proc/acpi">/proc/acpi</a>,</b>  <b><a href="file:/proc/kcore">/proc/kcore</a>,</b>  <b><a href="file:/proc/keys">/proc/keys</a>,</b>  <b><a href="file:/proc/latency_stats">/proc/latency_stats</a>,</b>
                <b>/proc/sched_debug,</b>   <b><a href="file:/proc/scsi">/proc/scsi</a>,</b>   <b><a href="file:/proc/timer_list">/proc/timer_list</a>,</b>   <b>/proc/timer_stats,</b>   <b><a href="file:/sys/firmware">/sys/firmware</a>,</b>   <b>and</b>
                <b>/sys/fs/selinux</b>,  <b>/sys/devices/virtual/powercap</b>.   The  default  paths  that  are  read-only are
                <b>/proc/asound</b>, <b><a href="file:/proc/bus">/proc/bus</a></b>, <b><a href="file:/proc/fs">/proc/fs</a></b>, <b><a href="file:/proc/irq">/proc/irq</a></b>, <b><a href="file:/proc/sys">/proc/sys</a></b>, <b><a href="file:/proc/sysrq-trigger">/proc/sysrq-trigger</a></b>, <b><a href="file:/sys/fs/cgroup">/sys/fs/cgroup</a></b>.

       Note: Labeling can be disabled for all containers by setting <b>label=false</b> in the <b><a href="../man5/containers.conf.5.html">containers.conf</a></b>(5) file.

   <b>--shm-size=</b><u><b>number[unit]</b></u>
       Size of <u><a href="file:/dev/shm">/dev/shm</a></u>. A <u>unit</u> can be <b>b</b> (bytes), <b>k</b> (kibibytes), <b>m</b> (mebibytes), or <b>g</b> (gibibytes).  If  the  unit
       is  omitted, the system uses bytes. If the size is omitted, the default is <b>64m</b>.  When <u>size</u> is <b>0</b>, there is
       no limit on the amount of memory used for IPC by the container.  This option conflicts with <b>--ipc=host</b>.

   <b>--shm-size-systemd=</b><u><b>number[unit]</b></u>
       Size of systemd-specific tmpfs mounts such as <a href="file:/run">/run</a>, <a href="file:/run/lock">/run/lock</a>, <a href="file:/var/log/journal">/var/log/journal</a> and /tmp.  A <u>unit</u> can  be
       <b>b</b>  (bytes),  <b>k</b>  (kibibytes),  <b>m</b>  (mebibytes),  or <b>g</b> (gibibytes).  If the unit is omitted, the system uses
       bytes. If the size is omitted, the default is <b>64m</b>.  When <u>size</u> is <b>0</b>, the usage is limited to  50%  of  the
       host's available memory.

   <b>--stop-signal=</b><u><b>signal</b></u>
       Signal to stop a container. Default is <b>SIGTERM</b>.

   <b>--stop-timeout=</b><u><b>seconds</b></u>
       Timeout to stop a container. Default is <b>10</b>.  Remote connections use local containers.conf for defaults.

   <b>--subgidname=</b><u><b>name</b></u>
       Run  the  container  in a new user namespace using the map with <u>name</u> in the <u><a href="file:/etc/subgid">/etc/subgid</a></u> file.  If running
       rootless, the user needs to have the right to use the mapping. See <b><a href="../man5/subgid.5.html">subgid</a></b>(5).  This flag  conflicts  with
       <b>--userns</b> and <b>--gidmap</b>.

   <b>--subuidname=</b><u><b>name</b></u>
       Run  the  container  in a new user namespace using the map with <u>name</u> in the <u><a href="file:/etc/subuid">/etc/subuid</a></u> file.  If running
       rootless, the user needs to have the right to use the mapping. See <b><a href="../man5/subuid.5.html">subuid</a></b>(5).  This flag  conflicts  with
       <b>--userns</b> and <b>--uidmap</b>.

   <b>--sysctl=</b><u><b>name=value</b></u>
       Configure namespaced kernel parameters at runtime.

       For the IPC namespace, the following sysctls are allowed:

              • kernel.msgmax

              • kernel.msgmnb

              • kernel.msgmni

              • kernel.sem

              • kernel.shmall

              • kernel.shmmax

              • kernel.shmmni

              • kernel.shm_rmid_forced

              • Sysctls beginning with fs.mqueue.*

       Note: if using the <b>--ipc=host</b> option, the above sysctls are not allowed.

       For the network namespace, only sysctls beginning with net.* are allowed.

       Note: if using the <b>--network=host</b> option, the above sysctls are not allowed.

   <b>--systemd=</b><u><b>true</b></u> <b>|</b> <u><b>false</b></u> <b>|</b> <u><b>always</b></u>
       Run container in systemd mode. The default is <b>true</b>.

              • <b>true</b>  enables  systemd  mode  only  when  the  command executed inside the container is <u>systemd</u>,
                <u><a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?init">/usr/sbin/init</a></u>, <u><a href="file:/sbin/init">/sbin/init</a></u> or <u>/usr/local/sbin/init</u>.

              • <b>false</b> disables systemd mode.

              • <b>always</b> enforces the systemd mode to be enabled.

       Running the container in systemd mode causes the following changes:

              • Podman mounts tmpfs file systems on the following directories

                • <u><a href="file:/run">/run</a></u>

                • <u><a href="file:/run/lock">/run/lock</a></u>

                • <u><a href="file:/tmp">/tmp</a></u>

                • <u>/sys/fs/cgroup/systemd</u> (on a cgroup v1 system)

                • <u>/var/lib/journal</u>

              • Podman sets the default stop signal to <b>SIGRTMIN+3</b>.

              • Podman sets <b>container_uuid</b> environment variable in the container to the first 32  characters  of
                the container ID.

              • Podman does not mount virtual consoles (<u>/dev/tty\d+</u>) when running with <b>--privileged</b>.

              • On cgroup v2, <u><a href="file:/sys/fs/cgroup">/sys/fs/cgroup</a></u> is mounted writeable.

       This allows systemd to run in a confined container without any modifications.

       Note  that on <b>SELinux</b> systems, systemd attempts to write to the cgroup file system. Containers writing to
       the cgroup file system are denied by default.  The <b>container_manage_cgroup</b> boolean must  be  enabled  for
       this to be allowed on an SELinux separated system.

       setsebool -P container_manage_cgroup true

   <b>--timeout=</b><u><b>seconds</b></u>
       Maximum time a container is allowed to run before conmon sends it the kill signal.  By default containers
       run until they exit or are stopped by <b>podman</b> <b>stop</b>.

   <b>--tls-verify</b>
       Require  HTTPS  and verify certificates when contacting registries (default: <b>true</b>).  If explicitly set to
       <b>true</b>, TLS verification is used.  If set to <b>false</b>, TLS verification is not used.  If  not  specified,  TLS
       verification  is  used  unless  the  target  registry  is  listed  as an insecure registry in <b><a href="../man5/containersregistries.conf.5.html">containers-</a></b>
       <b><a href="../man5/containersregistries.conf.5.html">registries.conf</a>(5)</b>

   <b>--tmpfs=</b><u><b>fs</b></u>
       Create a tmpfs mount.

       Mount a temporary filesystem (<b>tmpfs</b>) mount into a container, for example:

       $ podman create -d --tmpfs <a href="file:/tmp">/tmp</a>:rw,size=787448k,mode=1777 my_image

       This command mounts a <b>tmpfs</b> at <u><a href="file:/tmp">/tmp</a></u> within the container. The supported mount options are the same as the
       Linux default mount flags.  If  no  options  are  specified,  the  system  uses  the  following  options:
       <b>rw,noexec,nosuid,nodev</b>.

   <b>--tty,</b> <b>-t</b>
       Allocate a pseudo-TTY. The default is <b>false</b>.

       When  set  to <b>true</b>, Podman allocates a pseudo-tty and attach to the standard input of the container. This
       can be used, for example, to run a throwaway interactive shell.

       <b>NOTE</b>: The --tty flag prevents redirection of standard output.  It combines  STDOUT  and  STDERR,  it  can
       insert  control  characters,  and it can hang pipes. This option is only used when run interactively in a
       terminal. When feeding input to Podman, use -i only, not -it.

   <b>--tz=</b><u><b>timezone</b></u>
       Set timezone in container. This flag takes area-based timezones, GMT time, as well as <b>local</b>,  which  sets
       the  timezone  in  the container to match the host machine. See <b><a href="file:/usr/share/zoneinfo/">/usr/share/zoneinfo/</a></b> for valid timezones.
       Remote connections use local containers.conf for defaults

   <b>--uidmap=</b><u><b>[flags]container_uid:from_uid[:amount]</b></u>
       Run the container in a new user namespace using the supplied UID mapping. This option conflicts with  the
       <b>--userns</b>  and <b>--subuidname</b> options. This option provides a way to map host UIDs to container UIDs. It can
       be passed several times to map different ranges.

       The possible values of the optional <u>flags</u> are discussed further down on this page.  The <u>amount</u>  value  is
       optional and assumed to be <b>1</b> if not given.

       The <u>from_uid</u> value is based upon the user running the command, either rootful or rootless users.

              • rootful user:  [<u>flags</u>]<u>container_uid</u>:<u>host_uid</u>[:<u>amount</u>]

              • rootless user: [<u>flags</u>]<u>container_uid</u>:<u>intermediate_uid</u>[:<u>amount</u>]

       <b>Rootful</b> <b>mappings</b>

       When  <b>podman</b> <b>create</b> is called by a privileged user, the option <b>--uidmap</b> works as a direct mapping between
       host UIDs and container UIDs.

       host UID -&gt; container UID

       The <u>amount</u> specifies the number of consecutive UIDs that is mapped.  If  for  example  <u>amount</u>  is  <b>4</b>  the
       mapping looks like:

       ┌──────────────┬───────────────────┐
       │ <b>host</b> <b>UID</b>     │ <b>container</b> <b>UID</b>     │
       ├──────────────┼───────────────────┤
       │ <u>from_uid</u>     │ <u>container_uid</u>     │
       ├──────────────┼───────────────────┤
       │ <u>from_uid</u> + 1 │ <u>container_uid</u> + 1 │
       ├──────────────┼───────────────────┤
       │ <u>from_uid</u> + 2 │ <u>container_uid</u> + 2 │
       ├──────────────┼───────────────────┤
       │ <u>from_uid</u> + 3 │ <u>container_uid</u> + 3 │
       └──────────────┴───────────────────┘

       <b>Rootless</b> <b>mappings</b>

       When  <b>podman</b>  <b>create</b>  is  called  by  an unprivileged user (i.e. running rootless), the value <u>from_uid</u> is
       interpreted as an "intermediate UID". In the  rootless  case,  host  UIDs  are  not  mapped  directly  to
       container UIDs. Instead the mapping happens over two mapping steps:

       host UID -&gt; intermediate UID -&gt; container UID

       The <b>--uidmap</b> option only influences the second mapping step.

       The  first mapping step is derived by Podman from the contents of the file <u><a href="file:/etc/subuid">/etc/subuid</a></u> and the UID of the
       user calling Podman.

       First mapping step:

       ┌─────────────────────┬──────────────────┐
       │ <b>host</b> <b>UID</b>            │ <b>intermediate</b> <b>UID</b> │
       ├─────────────────────┼──────────────────┤
       │ UID for Podman user │ 0                │
       ├─────────────────────┼──────────────────┤
       │ 1st subordinate UID │ 1                │
       ├─────────────────────┼──────────────────┤
       │ 2nd subordinate UID │ 2                │
       ├─────────────────────┼──────────────────┤
       │ 3rd subordinate UID │ 3                │
       ├─────────────────────┼──────────────────┤
       │ nth subordinate UID │ n                │
       └─────────────────────┴──────────────────┘

       To be able to use intermediate UIDs greater than zero, the user needs to have subordinate UIDs configured
       in <u><a href="file:/etc/subuid">/etc/subuid</a></u>. See <b><a href="../man5/subuid.5.html">subuid</a></b>(5).

       The second mapping step is configured with <b>--uidmap</b>.

       If for example <u>amount</u> is <b>5</b> the second mapping step looks like:

       ┌──────────────────┬───────────────────┐
       │ <b>intermediate</b> <b>UID</b> │ <b>container</b> <b>UID</b>     │
       ├──────────────────┼───────────────────┤
       │ <u>from_uid</u>         │ <u>container_uid</u>     │
       ├──────────────────┼───────────────────┤
       │ <u>from_uid</u> + 1     │ <u>container_uid</u> + 1 │
       ├──────────────────┼───────────────────┤
       │ <u>from_uid</u> + 2     │ <u>container_uid</u> + 2 │
       ├──────────────────┼───────────────────┤
       │ <u>from_uid</u> + 3     │ <u>container_uid</u> + 3 │
       ├──────────────────┼───────────────────┤
       │ <u>from_uid</u> + 4     │ <u>container_uid</u> + 4 │
       └──────────────────┴───────────────────┘

       When running as rootless, Podman uses all the ranges configured in the <u><a href="file:/etc/subuid">/etc/subuid</a></u> file.

       The current user ID is mapped to UID=0 in the rootless user namespace.  Every additional range  is  added
       sequentially afterward:

       ┌───────────────────────┬─────────────────────────┬──────────────────────┐
       │ <b>host</b>                  │ <b>rootless</b> <b>user</b> <b>namespace</b> │ <b>length</b>               │
       ├───────────────────────┼─────────────────────────┼──────────────────────┤
       │ $UID                  │ 0                       │ 1                    │
       ├───────────────────────┼─────────────────────────┼──────────────────────┤
       │ 1                     │ $FIRST_RANGE_ID         │ $FIRST_RANGE_LENGTH  │
       ├───────────────────────┼─────────────────────────┼──────────────────────┤
       │ 1+$FIRST_RANGE_LENGTH │ $SECOND_RANGE_ID        │ $SECOND_RANGE_LENGTH │
       └───────────────────────┴─────────────────────────┴──────────────────────┘

       <b>Referencing</b> <b>a</b> <b>host</b> <b>ID</b> <b>from</b> <b>the</b> <b>parent</b> <b>namespace</b>

       As  a  rootless user, the given host ID in <b>--uidmap</b> or <b>--gidmap</b> is mapped from the <u>intermediate</u> <u>namespace</u>
       generated by Podman. Sometimes it is desirable to refer directly at the <u>host</u> <u>namespace</u>. It is possible to
       manually do so, by running <b>podman</b> <b>unshare</b> <b>cat</b> <b><a href="file:/proc/self/gid_map">/proc/self/gid_map</a></b>, finding the  desired  host  id  at  the
       second column of the output, and getting the corresponding intermediate id from the first column.

       Podman  can  perform all that by preceding the host id in the mapping with the <b>@</b> symbol. For instance, by
       specifying <b>--gidmap</b> <b>100000:@2000:1</b>, podman will look up the intermediate id corresponding to host id <b>2000</b>
       and it will map the found intermediate id to the container id <b>100000</b>. The given host id  must  have  been
       subordinated (otherwise it would not be mapped into the intermediate space in the first place).

       If  the  length  is greater than one, for instance with <b>--gidmap</b> <b>100000:@2000:2</b>, Podman will map host ids
       <b>2000</b> and <b>2001</b> to <b>100000</b> and <b>100001</b>, respectively, regardless of how the intermediate mapping is defined.

       <b>Extending</b> <b>previous</b> <b>mappings</b>

       Some mapping modifications may be cumbersome. For  instance,  a  user  starts  with  a  mapping  such  as
       <b>--gidmap="0:0:65000"</b>,  that  needs  to  be  changed  such as the parent id <b>1000</b> is mapped to container id
       <b>100000</b> instead, leaving container id <b>1</b> unassigned. The corresponding  <b>--gidmap</b>  becomes  <b>--gidmap="0:0:1"</b>
       <b>--gidmap="2:2:65534"</b> <b>--gidmap="100000:1:1"</b>.

       This  notation can be simplified using the <b>+</b> flag, that takes care of breaking previous mappings removing
       any conflicting assignment with the given mapping. The flag is given before the container id as  follows:
       <b>--gidmap="0:0:65000"</b> <b>--gidmap="+100000:1:1"</b>

       ┌──────┬─────────────┬─────────────────────────────┐
       │ <b>Flag</b> │ <b>Example</b>     │ <b>Description</b>                 │
       ├──────┼─────────────┼─────────────────────────────┤
       │ <b>+</b>    │ <b>+100000:1:1</b> │ Extend the previous mapping │
       └──────┴─────────────┴─────────────────────────────┘

       This  notation  leads  to  gaps in the assignment, so it may be convenient to fill those gaps afterwards:
       <b>--gidmap="0:0:65000"</b> <b>--gidmap="+100000:1:1"</b> <b>--gidmap="1:65001:1"</b>

       One specific use case for this flag is in the context of rootless users.  A  rootless  user  may  specify
       mappings  with  the  <b>+</b>  flag as in <b>--gidmap="+100000:1:1"</b>. Podman will then "fill the gaps" starting from
       zero with all the remaining intermediate ids. This is convenient when a user  wants  to  map  a  specific
       intermediate id to a container id, leaving the rest of subordinate ids to be mapped by Podman at will.

       <b>Passing</b> <b>only</b> <b>one</b> <b>of</b> <b>--uidmap</b> <b>or</b> <b>--gidmap</b>

       Usually,  subordinated  user and group ids are assigned simultaneously, and for any user the subordinated
       user ids match the subordinated group ids.  For convenience, if only  one  of  <b>--uidmap</b>  or  <b>--gidmap</b>  is
       given,  podman assumes the mapping refers to both UIDs and GIDs and applies the given mapping to both. If
       only one value of the two needs to be changed, the mappings should include  the  <b>u</b>  or  the  <b>g</b>  flags  to
       specify that they only apply to UIDs or GIDs and should not be copied over.

       ┌──────┬───────────────┬──────────────────────────────┐
       │ <b>flag</b> │ <b>Example</b>       │ <b>Description</b>                  │
       ├──────┼───────────────┼──────────────────────────────┤
       │ <b>u</b>    │ <b>u20000:2000:1</b> │ The  mapping only applies to │
       │      │               │ UIDs                         │
       ├──────┼───────────────┼──────────────────────────────┤
       │ <b>g</b>    │ <b>g10000:1000:1</b> │ The mapping only applies  to │
       │      │               │ GIDs                         │
       └──────┴───────────────┴──────────────────────────────┘

       For instance given the command

       podman create --gidmap "0:0:1000" --gidmap "g2000:2000:1"

       Since no <b>--uidmap</b> is given, the <b>--gidmap</b> is copied to <b>--uidmap</b>, giving a command equivalent to

       podman create --gidmap "0:0:1000" --gidmap "2000:2000:1" --uidmap "0:0:1000"

       The <b>--gidmap</b> <b>"g2000:2000:1"</b> used the <b>g</b> flag and therefore it was not copied to <b>--uidmap</b>.

       <b>Rootless</b> <b>mapping</b> <b>of</b> <b>additional</b> <b>host</b> <b>GIDs</b>

       A  rootless  user  may  desire  to  map  a  specific host group that has already been subordinated within
       <u><a href="file:/etc/subgid">/etc/subgid</a></u> without specifying the rest of the mapping.

       This can be done with <b>--gidmap</b> <b>"+g</b><u>container_gid</u><b>:@</b><u>host_gid</u><b>"</b>

       Where:

              • The host GID is given through the <b>@</b> symbol

              • The mapping of this GID is not copied over to <b>--usermap</b> thanks to the <b>g</b> flag.

              • The rest of the container IDs will be mapped starting from  0  to  n,  with  all  the  remaining
                subordinated GIDs, thanks to the <b>+</b> flag.

       For  instance,  if  a  user  belongs  to the group <b>2000</b> and that group is subordinated to that user (with
       <b>usermod</b>  <b>--add-subgids</b>  <b>2000-2000</b>  <b>$USER</b>),  the  user  can  map  the  group  into  the  container   with:
       <b>--gidmap=+g100000:@2000</b>.

       If  this  mapping is combined with the option, <b>--group-add=keep-groups</b>, the process in the container will
       belong to group <b>100000</b>, and files belonging to group <b>2000</b> in the host will appear as being owned by group
       <b>100000</b> inside the container.

       podman run --group-add=keep-groups --gidmap="+g100000:@2000" ...

       <b>No</b> <b>subordinate</b> <b>UIDs</b>

       Even if a user does not have any subordinate UIDs in  <u><a href="file:/etc/subuid">/etc/subuid</a></u>, <b>--uidmap</b> can be used to map the normal
       UID of the user  to  a  container  UID  by  running  <b>podman</b>  <b>create</b>  <b>--uidmap</b>  <b>$container_uid:0:1</b>  <b>--user</b>
       <b>$container_uid</b> <b>...</b>.

       <b>Pods</b>

       The  <b>--uidmap</b>  option  cannot be called in conjunction with the <b>--pod</b> option as a uidmap cannot be set on
       the container level when in a pod.

   <b>--ulimit=</b><u><b>option</b></u>
       Ulimit options. Sets the ulimits values inside of the container.

       --ulimit with a soft and hard limit in the format =[:]. For example:

       $ podman run --ulimit nofile=1024:1024 --rm ubi9 ulimit -n 1024

       Set -1 for the soft or hard limit to set the limit to the  maximum  limit  of  the  current  process.  In
       rootful mode this is often unlimited.

       If  nofile  and  nproc  are  unset,  a  default  value  of  1048576  will  be  used, unless overridden in
       <a href="../man5/containers.conf.5.html">containers.conf</a>(5).  However, if the default value exceeds the hard limit for the current rootless  user,
       the current hard limit will be applied instead.

       Use <b>host</b> to copy the current configuration from the host.

       Don't use nproc with the ulimit flag as Linux uses nproc to set the maximum number of processes available
       to a user, not to a container.

       Use  the  --pids-limit  option  to  modify  the  cgroup control to limit the number of processes within a
       container.

   <b>--umask=</b><u><b>umask</b></u>
       Set the umask inside the container. Defaults to <b>0022</b>.  Remote connections use local  containers.conf  for
       defaults

   <b>--unsetenv=</b><u><b>env</b></u>
       Unset  default  environment  variables for the container. Default environment variables include variables
       provided natively by Podman, environment variables configured by the  image,  and  environment  variables
       from containers.conf.

   <b>--unsetenv-all</b>
       Unset  all  default  environment  variables  for  the  container.  Default  environment variables include
       variables provided natively by Podman, environment variables configured by  the  image,  and  environment
       variables from containers.conf.

   <b>--user,</b> <b>-u=</b><u><b>user[:group]</b></u>
       Sets  the username or UID used and, optionally, the groupname or GID for the specified command. Both <u>user</u>
       and <u>group</u> may be symbolic or numeric.

       Without this argument, the command runs as the user specified in the container image.  Unless  overridden
       by  a <b>USER</b> command in the Containerfile or by a value passed to this option, this user generally defaults
       to root.

       When a user namespace is not in use, the UID and GID used within the container and  on  the  host  match.
       When  user namespaces are in use, however, the UID and GID in the container may correspond to another UID
       and GID on the host. In rootless containers, for example, a user namespace is always used,  and  root  in
       the container by default corresponds to the UID and GID of the user invoking Podman.

   <b>--userns=</b><u><b>mode</b></u>
       Set the user namespace mode for the container.

       If  <b>--userns</b>  is  not  set,  the  default value is determined as follows.  - If <b>--pod</b> is set, <b>--userns</b> is
       ignored and the user namespace of the pod is used.  - If the environment variable  <b>PODMAN_USERNS</b>  is  set
       its  value  is  used.   -  If  <b>userns</b>  is  specified in <b>containers.conf</b> this value is used.  - Otherwise,
       <b>--userns=host</b> is assumed.

       <b>--userns=""</b> (i.e., an empty string) is an alias for <b>--userns=host</b>.

       This option is incompatible with <b>--gidmap</b>, <b>--uidmap</b>, <b>--subuidname</b> and <b>--subgidname</b>.

       Rootless user --userns=Key mappings:

       ┌─────────────────────────┬───────────┬──────────────────────────────┐
       │ <b>Key</b>                     │ <b>Host</b> <b>User</b> │ <b>Container</b> <b>User</b>               │
       ├─────────────────────────┼───────────┼──────────────────────────────┤
       │ auto                    │ $UID      │ nil (Host User  UID  is  not │
       │                         │           │ mapped into container.)      │
       ├─────────────────────────┼───────────┼──────────────────────────────┤
       │ host                    │ $UID      │ 0   (Default   User  account │
       │                         │           │ mapped  to  root   user   in │
       │                         │           │ container.)                  │
       ├─────────────────────────┼───────────┼──────────────────────────────┤
       │ keep-id                 │ $UID      │ $UID  (Map  user  account to │
       │                         │           │ same UID within container.)  │
       ├─────────────────────────┼───────────┼──────────────────────────────┤
       │ keep-id:uid=200,gid=210 │ $UID      │ 200:210 (Map user account to │
       │                         │           │ specified  UID,  GID   value │
       │                         │           │ within container.)           │
       ├─────────────────────────┼───────────┼──────────────────────────────┤
       │ nomap                   │ $UID      │ nil  (Host  User  UID is not │
       │                         │           │ mapped into container.)      │
       └─────────────────────────┴───────────┴──────────────────────────────┘

       Valid <u>mode</u> values are:

       <b>auto</b>[:<u>OPTIONS,...</u>]: automatically create a unique user namespace.

              • <b>rootful</b> <b>mode</b>: The <b>--userns=auto</b> flag requires that the user name <b>containers</b> be specified in  the
                <a href="file:/etc/subuid">/etc/subuid</a>  and  <a href="file:/etc/subgid">/etc/subgid</a>  files,  with  an unused range of subordinate user IDs that Podman
                containers are allowed to allocate.

               Example: <b>containers:2147483647:2147483648</b>.

              • <b>rootless</b> <b>mode</b>: The users range from the <a href="file:/etc/subuid">/etc/subuid</a> and <a href="file:/etc/subgid">/etc/subgid</a> files  will  be  used.  Note
                running a single container without using --userns=auto will use the entire range of UIDs and not
                allow further subdividing. See <a href="../man5/subuid.5.html">subuid</a>(5).

       Podman allocates unique ranges of UIDs and GIDs from the <b>containers</b> subordinate user IDs. The size of the
       ranges  is  based  on  the  number  of  UIDs  required  in  the image. The number of UIDs and GIDs can be
       overridden with the <b>size</b> option.

       The option <b>--userns=keep-id</b> uses all the subuids and subgids of the user.  The option <b>--userns=nomap</b> uses
       all the subuids and subgids of the user except the user's own ID.  Using <b>--userns=auto</b> when starting  new
       containers  does  not  work  as  long  as  any  containers exist that were started with <b>--userns=nomap</b> or
       <b>--userns=keep-id</b> without limiting the user namespace size.

       Valid <b>auto</b> options:

              • <u>gidmapping</u>=<u>CONTAINER_GID:HOST_GID:SIZE</u>: to force a  GID  mapping  to  be  present  in  the  user
                namespace.

              • <u>size</u>=<u>SIZE</u>:   to   specify   an   explicit   size   for   the   automatic  user  namespace.  e.g.
                <b>--userns=auto:size=8192</b>. If <b>size</b> is not specified, <b>auto</b> estimates a size for the user namespace.

              • <u>uidmapping</u>=<u>CONTAINER_UID:HOST_UID:SIZE</u>: to force a  UID  mapping  to  be  present  in  the  user
                namespace.

       The  host UID and GID in <u>gidmapping</u> and <u>uidmapping</u> can optionally be prefixed with the <b>@</b> symbol.  In this
       case, podman will look up the intermediate ID corresponding  to  host  ID  and  it  will  map  the  found
       intermediate ID to the container id.  For details see <b>--uidmap</b>.

       <b>container:</b><u>id</u>: join the user namespace of the specified container.

       <b>host</b>  or  <b>""</b>  (empty  string):  run  in  the  user  namespace of the caller. The processes running in the
       container have the same privileges on the host as any other process launched by the calling user.

       <b>keep-id</b>: creates a user namespace where the current user's UID:GID are mapped to the same values  in  the
       container. For containers created by root, the current mapping is created into a new user namespace.

       Valid <b>keep-id</b> options:

              • <u>uid</u>=UID: override the UID inside the container that is used to map the current user to.

              • <u>gid</u>=GID: override the GID inside the container that is used to map the current user to.

              • <u>size</u>=SIZE: override the size of the configured user namespace.  It is useful to not saturate all
                the available IDs.  Not supported when running as root.

       <b>nomap</b>:  creates  a  user  namespace  where  the  current  rootless user's UID:GID are not mapped into the
       container. This option is not allowed for containers created by the root user.

       <b>ns:</b><u>namespace</u>: run the container in the given existing user namespace.

   <b>--uts=</b><u><b>mode</b></u>
       Set the UTS namespace mode for the container. The following values are supported:

              • <b>host</b>: use the host's UTS namespace inside the container.

              • <b>private</b>: create a new namespace for the container (default).

              • <b>ns:[path]</b>: run the container in the given existing UTS namespace.

              • <b>container:[container]</b>: join the UTS namespace of the specified container.

   <b>--variant=</b><u><b>VARIANT</b></u>
       Use <u>VARIANT</u> instead of the default architecture variant of the  container  image.  Some  images  can  use
       multiple variants of the arm architectures, such as arm/v5 and arm/v7.

   <b>--volume,</b> <b>-v=</b><u><b>[[SOURCE-VOLUME|HOST-DIR:]CONTAINER-DIR[:OPTIONS]]</b></u>
       Create  a  bind mount. If <b>-v</b> <b>/HOST-DIR:/CONTAINER-DIR</b> is specified, Podman bind mounts <b>/HOST-DIR</b> from the
       host into <b>/CONTAINER-DIR</b> in the Podman container. Similarly, <b>-v</b> <b>SOURCE-VOLUME:/CONTAINER-DIR</b>  mounts  the
       named  volume from the host into the container. If no such named volume exists, Podman creates one. If no
       source is given, the volume is created as an anonymously named volume with a randomly generated name, and
       is removed when the container is removed via the <b>--rm</b> flag or the <b>podman</b> <b>rm</b> <b>--volumes</b> command.

       (Note when using the remote client, including Mac and Windows (excluding WSL2) machines, the volumes  are
       mounted from the remote server, not necessarily the client machine.)

       The <u>OPTIONS</u> is a comma-separated list and can be one or more of:

              • <b>rw</b>|<b>ro</b>

              • <b>z</b>|<b>Z</b>

              • [<b>O</b>]

              • [<b>U</b>]

              • [<b>no</b>]<b>copy</b>

              • [<b>no</b>]<b>dev</b>

              • [<b>no</b>]<b>exec</b>

              • [<b>no</b>]<b>suid</b>

              • [<b>r</b>]<b>bind</b>

              • [<b>r</b>]<b>shared</b>|[<b>r</b>]<b>slave</b>|[<b>r</b>]<b>private</b>[<b>r</b>]<b>unbindable</b> [1] ⟨#Footnote1⟩

              • <b>idmap</b>[=<b>options</b>]

       The <b>CONTAINER-DIR</b> must be an absolute path such as <b>/src/docs</b>. The volume is mounted into the container at
       this directory.

       If  a volume source is specified, it must be a path on the host or the name of a named volume. Host paths
       are allowed to be absolute or relative; relative paths are resolved relative to the directory  Podman  is
       run  in. If the source does not exist, Podman returns an error. Users must pre-create the source files or
       directories.

       Any source that does not begin with a <b>.</b> or <b>/</b> is treated as the name of a named volume. If a  volume  with
       that  name does not exist, it is created.  Volumes created with names are not anonymous, and they are not
       removed by the <b>--rm</b> option and the <b>podman</b> <b>rm</b> <b>--volumes</b> command.

       Specify multiple <b>-v</b> options to mount one or more volumes into a container.

       <b>Write</b> <b>Protected</b> <b>Volume</b> <b>Mounts</b>

       Add <b>:ro</b> or <b>:rw</b> option to mount a volume in read-only or read-write mode, respectively.  By  default,  the
       volumes are mounted read-write.  See examples.

       <b>Chowning</b> <b>Volume</b> <b>Mounts</b>

       By  default,  Podman  does  not  change  the  owner  and  group of source volume directories mounted into
       containers. If a container is created in a new user namespace, the UID  and  GID  in  the  container  may
       correspond to another UID and GID on the host.

       The  <b>:U</b>  suffix  tells  Podman  to  use  the correct host UID and GID based on the UID and GID within the
       container, to change recursively the owner and group of the source volume. Chowning walks the file system
       under the volume and changes the UID/GID on each file. If  the  volume  has  thousands  of  inodes,  this
       process takes a long time, delaying the start of the container.

       <b>Warning</b> use with caution since this modifies the host filesystem.

       <b>Labeling</b> <b>Volume</b> <b>Mounts</b>

       Labeling  systems  like  SELinux  require  that proper labels are placed on volume content mounted into a
       container. Without a label, the security system might prevent the processes running inside the  container
       from using the content. By default, Podman does not change the labels set by the OS.

       To  change  a  label  in  the container context, add either of two suffixes <b>:z</b> or <b>:Z</b> to the volume mount.
       These suffixes tell Podman to relabel file objects on the shared volumes. The <b>z</b> option tells Podman  that
       two  or  more  containers  share the volume content. As a result, Podman labels the content with a shared
       content label. Shared volume labels allow all containers to read/write content. The <b>Z</b> option tells Podman
       to label the content with a private unshared label Only the current container can use a  private  volume.
       Note: all containers within a <b>pod</b> share the same SELinux label. This means all containers within said pod
       can  read/write  volumes  shared  into  the  container  created with the <b>:Z</b> on any of one the containers.
       Relabeling walks the file system under the volume and changes the label on each file, if the  volume  has
       thousands  of  inodes, this process takes a long time, delaying the start of the container. If the volume
       was previously relabeled with the <b>z</b> option, Podman is optimized to not relabel a second  time.  If  files
       are  moved  into  the  volume, then the labels can be manually change with the <b>chcon</b> <b>-Rt</b> <b>container_file_t</b>
       <b>PATH</b> command.

       Note: Do not relabel system files and directories. Relabeling system content might cause  other  confined
       services  on  the  machine  to  fail.   For  these  types  of  containers  we recommend disabling SELinux
       separation.  The option <b>--security-opt</b> <b>label=disable</b> disables SELinux separation for the container.   For
       example  if  a  user  wanted  to  volume mount their entire home directory into a container, they need to
       disable SELinux separation.

       $ podman create --security-opt label=disable -v $HOME:/home/user fedora touch /home/user/file

       <b>Overlay</b> <b>Volume</b> <b>Mounts</b>

       The <b>:O</b> flag tells Podman to mount the directory from the host as a temporary storage  using  the  <b>overlay</b>
       <b>file</b>  <b>system</b>.  The  container  processes  can modify content within the mountpoint which is stored in the
       container storage in a separate directory. In overlay terms, the source directory is the lower,  and  the
       container  storage  directory  is  the  upper.  Modifications  to  the mount point are destroyed when the
       container finishes executing, similar to a tmpfs mount point being unmounted.

       For advanced users, the <b>overlay</b> option also supports custom non-volatile <b>upperdir</b>  and  <b>workdir</b>  for  the
       overlay  mount. Custom <b>upperdir</b> and <b>workdir</b> can be fully managed by the users themselves, and Podman does
       not remove it on lifecycle completion.  Example <b>:O,upperdir=/some/upper,workdir=/some/work</b>

       Subsequent executions of the container sees the original  source  directory  content,  any  changes  from
       previous container executions no longer exist.

       One  use case of the overlay mount is sharing the package cache from the host into the container to allow
       speeding up builds.

       Note: The <b>O</b> flag conflicts with other options listed above.

       Content mounted into the container is labeled with the private label.  On SELinux systems, labels in  the
       source  directory  must  be  readable  by  the   container  label.  Usually  containers  can read/execute
       <b>container_share_t</b> and can read/write <b>container_file_t</b>. If unable to change the labels on a source volume,
       SELinux container separation must be disabled for the  container to work.

       Do not modify the source directory mounted into the  container  with  an  overlay  mount,  it  can  cause
       unexpected failures. Only modify the directory after the container finishes running.

       <b>Mounts</b> <b>propagation</b>

       By  default,  bind-mounted  volumes  are <b>private</b>. That means any mounts done inside the container are not
       visible on the host and vice  versa.   One  can  change  this  behavior  by  specifying  a  volume  mount
       propagation  property.   When  a volume is <b>shared</b>, mounts done under that volume inside the container are
       visible on host and vice versa.  Making  a  volume  <b>slave</b>[1]  ⟨#Footnote1⟩  enables  only  one-way  mount
       propagation: mounts done on the host under that volume are visible inside the container but not the other
       way around.

       To  control mount propagation property of a volume one can use the [<b>r</b>]<b>shared</b>, [<b>r</b>]<b>slave</b>, [<b>r</b>]<b>private</b> or the
       [<b>r</b>]<b>unbindable</b> propagation flag.  Propagation property can be specified only for bind mounted volumes  and
       not  for  internal  volumes  or  named volumes. For mount propagation to work the source mount point (the
       mount point where source dir is mounted on) has to have the  right  propagation  properties.  For  shared
       volumes, the source mount point has to be shared. And for slave volumes, the source mount point has to be
       either shared or slave.  [1] ⟨#Footnote1⟩

       To recursively mount a volume and all of its submounts into a container, use the <b>rbind</b> option. By default
       the bind option is used, and submounts of the source directory is not mounted into the container.

       Mounting  the  volume  with  a  <b>copy</b>  option tells podman to copy content from the underlying destination
       directory onto newly created internal volumes. The <b>copy</b> only happens  on  the  initial  creation  of  the
       volume.  Content  is not copied up when the volume is subsequently used on different containers. The <b>copy</b>
       option is ignored on bind mounts and has no effect.

       Mounting volumes with the <b>nosuid</b> options means that SUID executables on the volume can  not  be  used  by
       applications to change their privilege. By default volumes are mounted with <b>nosuid</b>.

       Mounting the volume with the <b>noexec</b> option means that no executables on the volume can be executed within
       the container.

       Mounting  the  volume  with the <b>nodev</b> option means that no devices on the volume can be used by processes
       within the container. By default volumes are mounted with <b>nodev</b>.

       If the <u>HOST-DIR</u> is a mount point, then <b>dev</b>, <b>suid</b>, and <b>exec</b> options are ignored by the kernel.

       Use <b>df</b> <b>HOST-DIR</b> to figure out the source mount, then use <b>findmnt</b> <b>-o</b>  <b>TARGET,PROPAGATION</b>  <u>source-mount-dir</u>
       <u>to</u>  <u>figure</u>  <u>out</u>  <u>propagation</u> <u>properties</u> <u>of</u> <u>source</u> <u>mount.</u> <u>If</u> <b>findmnt</b><u>(1)</u> <u>utility</u> <u>is</u> <u>not</u> <u>available,</u> <u>then</u> <u>one</u>
       <u>can</u> <u>look</u> <u>at</u> <u>the</u> <u>mount</u> <u>entry</u> <u>for</u> <u>the</u> <u>source</u> <u>mount</u> <u>point</u> <u>in</u> <u>/proc/self/mountinfo.</u>  <u>Look</u>  <u>at</u>  <u>the</u>  <u>"optional</u>
       <u>fields"</u>  <u>and</u>  <u>see</u>  <u>if</u>  <u>any</u>  <u>propagation</u>  <u>properties</u> <u>are</u> <u>specified.</u>  <u>In</u> <u>there,</u> <b>shared:N</b> <u>means</u> <u>the</u> <u>mount</u> <u>is</u>
       <u>shared,</u> <b>master:N</b> <u>means</u> <u>mount</u> <u>is</u> <u>slave,</u> <u>and</u> <u>if</u> <u>nothing</u> <u>is</u> <u>there,</u> <u>the</u> <u>mount</u> <u>is</u> <u>private.</u> <u>[1]</u> <u>⟨#Footnote1⟩</u>

       To change propagation properties of a mount point, use <b><a href="../man8/mount.8.html">mount</a></b>(8) command. For example,  if  one  wants  to
       bind  mount  source  directory  <u>/foo</u>,  one can do <b>mount</b> <b>--bind</b> <b>/foo</b> <b>/foo</b> and <b>mount</b> <b>--make-private</b> <b>--make-</b>
       <b>shared</b> <b>/foo</b>. This converts /foo into a  shared  mount  point.  Alternatively,  one  can  directly  change
       propagation properties of source mount. Say <u>/</u> is source mount for <u>/foo</u>, then use <b>mount</b> <b>--make-shared</b> <b>/</b> to
       convert <u>/</u> into a shared mount.

       Note:  if  the  user  only  has  access  rights  via a group, accessing the volume from inside a rootless
       container fails.

       <b>Idmapped</b> <b>mount</b>

       If <b>idmap</b> is specified, create an idmapped mount to the target user namespace in the container. The  idmap
       option supports a custom mapping that can be different than the user namespace used by the container. The
       mapping can be specified after the idmap option like: <b>idmap=uids=0-1-10#10-11-10;gids=0-100-10</b>.  For each
       triplet,  the first value is the start of the backing file system IDs that are mapped to the second value
       on the host.  The length of this mapping is given in the third value.  Multiple ranges are separated with
       #.

       Use the <b>--group-add</b> <b>keep-groups</b> option to pass the user's supplementary group access into the container.

   <b>--volumes-from=</b><u><b>CONTAINER[:OPTIONS]</b></u>
       Mount volumes from the specified container(s). Used to share volumes between containers. The <u>options</u> is a
       comma-separated list with the following available elements:

              • <b>rw</b>|<b>ro</b>

              • <b>z</b>

       Mounts already mounted volumes from a source container onto another container. <u>CONTAINER</u> may be a name or
       ID.  To share a volume, use the --volumes-from option when running the target container. Volumes  can  be
       shared even if the source container is not running.

       By  default, Podman mounts the volumes in the same mode (read-write or read-only) as it is mounted in the
       source container.  This can be changed by adding a <b>ro</b> or <b>rw</b> <u>option</u>.

       Labeling systems like SELinux require that proper labels are placed on  volume  content  mounted  into  a
       container.  Without a label, the security system might prevent the processes running inside the container
       from using the content. By default, Podman does not change the labels set by the OS.

       To change a label in the container context, add <b>z</b> to the volume  mount.   This  suffix  tells  Podman  to
       relabel  file objects on the shared volumes. The <b>z</b> option tells Podman that two entities share the volume
       content. As a result, Podman labels the content with a shared content label. Shared volume  labels  allow
       all containers to read/write content.

       If  the  location  of  the  volume  from  the  source  container  overlaps with data residing on a target
       container, then the volume hides that data on the target.

   <b>--workdir,</b> <b>-w=</b><u><b>dir</b></u>
       Working directory inside the container.

       The default working directory for running binaries within a container is the  root  directory  (<b>/</b>).   The
       image  developer  can set a different default with the WORKDIR instruction. The operator can override the
       working directory by using the <b>-w</b> option.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Create a container using a local image:

       $ podman create alpine ls

       Create a container using a local image and annotate it:

       $ podman create --annotation HELLO=WORLD alpine ls

       Create a container using a local image, allocating a pseudo-TTY, keeping stdin open and name it myctr:

         podman create -t -i --name myctr alpine ls

       Running a container in a new user namespace requires a mapping of the UIDs and GIDs from the host:

       $ podman create --uidmap 0:30000:7000 --gidmap 0:30000:7000 fedora echo hello

       Setting automatic user-namespace separated containers:

       # podman create --userns=auto:size=65536 ubi8-init

       Configure the timezone in a container:

       $ podman create --tz=local alpine date
       $ podman create --tz=Asia/Shanghai alpine date
       $ podman create --tz=US/Eastern alpine date

       Ensure the first container (container1) is running before the second container (container2) is started:

       $ podman create --name container1 -t -i fedora bash
       $ podman create --name container2 --requires container1 -t -i fedora bash
       $ podman start --attach container2

       Create a container which requires multiple containers:

       $ podman create --name container1 -t -i fedora bash
       $ podman create --name container2 -t -i fedora bash
       $ podman create --name container3 --requires container1,container2 -t -i fedora bash
       $ podman start --attach container3

       Expose shared libraries inside of container as read-only using a glob:

       $ podman create --mount type=glob,src=/usr/lib64/libnvidia\*,ro -i -t fedora <a href="file:/bin/bash">/bin/bash</a>

       Create a container allowing supplemental groups to have access to the volume:

       $ podman create -v /var/lib/design:/var/lib/design --group-add keep-groups ubi8

       Configure execution domain for containers using the personality option:

       $ podman create --name container1 --personality=LINUX32 fedora bash

       Create a container with external rootfs mounted as an overlay:

       $ podman create --name container1 --rootfs /path/to/rootfs:O bash

       Create a container connected to two networks (called net1 and net2) with a static ip:

       $ podman create --network net1:ip=10.89.1.5 --network net2:ip=10.89.10.10 alpine ip addr

   <b>Rootless</b> <b>Containers</b>
       Podman runs as a non-root user on most systems. This feature  requires  that  a  new  enough  version  of
       shadow-utils be installed. The shadow-utils package must include the newuidmap and newgidmap executables.

       In  order  for  users  to  run  rootless,  there  must  be an entry for their username in <a href="file:/etc/subuid">/etc/subuid</a> and
       <a href="file:/etc/subgid">/etc/subgid</a> which lists the UIDs for their user namespace.

       Rootless Podman works better if the fuse-overlayfs and slirp4netns packages  are  installed.   The  fuse-
       overlayfs  package  provides  a  userspace  overlay  storage  driver, otherwise users need to use the vfs
       storage driver, which can be disk space expensive and less performant than other drivers.

       To enable VPN on the container, slirp4netns or pasta needs to be specified;  without  either,  containers
       need to be run with the --network=host flag.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       Environment  variables  within  containers  can  be  set  using multiple different options:  This section
       describes the precedence.

       Precedence order (later entries override earlier entries):

              • <b>--env-host</b> : Host environment of the process executing Podman is added.

              • <b>--http-proxy</b>: By default, several environment variables are passed in from  the  host,  such  as
                <b>http_proxy</b> and <b>no_proxy</b>. See <b>--http-proxy</b> for details.

              • Container image : Any environment variables specified in the container image.

              • <b>--env-file</b>  :  Any  environment  variables specified via env-files. If multiple files specified,
                then they override each other in order of entry.

              • <b>--env</b> : Any environment variables specified overrides previous settings.

       Create containers and set the environment ending with a <b>*</b>.  The trailing <b>*</b>  glob  functionality  is  only
       active when no value is specified:

       $ export ENV1=a
       $ podman create --name ctr1 --env 'ENV*' alpine env
       $ podman start --attach ctr1 | grep ENV
       ENV1=a
       $ podman create --name ctr2 --env 'ENV*=b' alpine env
       $ podman start --attach ctr2 | grep ENV
       ENV*=b

</pre><h4><b>CONMON</b></h4><pre>
       When  Podman  starts  a  container  it  actually executes the conmon program, which then executes the OCI
       Runtime.  Conmon is the container monitor.  It is a small program whose  job  is  to  watch  the  primary
       process  of  the container, and if the container dies, save the exit code.  It also holds open the tty of
       the container, so that it can be attached to later. This is what allows Podman to run  in  detached  mode
       (backgrounded), so Podman can exit but conmon continues to run.  Each container has their own instance of
       conmon.  Conmon  waits  for  the  container to exit, gathers and saves the exit code, and then launches a
       Podman process to complete the container cleanup, by shutting down the network and  storage.    For  more
       information about conmon, see the <a href="../man8/conmon.8.html">conmon</a>(8) man page.

</pre><h4><b>FILES</b></h4><pre>
       <b><a href="file:/etc/subuid">/etc/subuid</a></b> <b><a href="file:/etc/subgid">/etc/subgid</a></b>

       NOTE:  Use  the  environment  variable  <b>TMPDIR</b>  to  change  the  temporary storage location of downloaded
       container images. Podman defaults to use <b><a href="file:/var/tmp">/var/tmp</a></b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/podman.1.html">podman</a>(1)</b>, <b><a href="../man1/podman-save.1.html">podman-save</a>(1)</b>, <b><a href="../man1/podman-ps.1.html">podman-ps</a>(1)</b>, <b><a href="../man1/podman-attach.1.html">podman-attach</a>(1)</b>, <b><a href="../man1/podman-pod-create.1.html">podman-pod-create</a>(1)</b>, <b><a href="../man1/podman-port.1.html">podman-port</a>(1)</b>,  <b><a href="../man1/podmanstart.1.html">podman-</a></b>
       <b><a href="../man1/podmanstart.1.html">start</a>(1)</b>, <b><a href="../man1/podman-kill.1.html">podman-kill</a>(1)</b>, <b><a href="../man1/podman-stop.1.html">podman-stop</a>(1)</b>, <b><a href="../man1/podman-generate-systemd.1.html">podman-generate-systemd</a>(1)</b>, <b><a href="../man1/podman-rm.1.html">podman-rm</a>(1)</b>, <b><a href="../man5/subgid.5.html">subgid</a>(5)</b>, <b><a href="../man5/subuid.5.html">subuid</a>(5)</b>,
       <b><a href="../man5/containers.conf.5.html">containers.conf</a>(5)</b>,  <b><a href="../man5/systemd.unit.5.html">systemd.unit</a>(5)</b>, <b><a href="../man8/setsebool.8.html">setsebool</a>(8)</b>, <b><a href="../man1/slirp4netns.1.html">slirp4netns</a>(1)</b>, <b><a href="../man1/pasta.1.html">pasta</a>(1)</b>, <b><a href="../man1/fuse-overlayfs.1.html">fuse-overlayfs</a>(1)</b>, <b><a href="../man5/proc.5.html">proc</a>(5)</b>,
       <b><a href="../man8/conmon.8.html">conmon</a>(8)</b>, <b><a href="../man2/personality.2.html">personality</a>(2)</b>

   <b>Troubleshooting</b>
       See <a href="../man7/podman-troubleshooting.7.html">podman-troubleshooting</a>(7) for solutions to common issues.

       See <a href="../man7/podman-rootless.7.html">podman-rootless</a>(7) for rootless issues.

</pre><h4><b>HISTORY</b></h4><pre>
       October 2017, converted from Docker documentation to Podman by Dan Walsh for Podman <b>&lt;<a href="mailto:dwalsh@redhat.com">dwalsh@redhat.com</a>&gt;</b>

       November 2014, updated by Sven Dowideit <b>&lt;<a href="mailto:SvenDowideit@home.org.au">SvenDowideit@home.org.au</a>&gt;</b>

       September 2014, updated by Sven Dowideit <b>&lt;<a href="mailto:SvenDowideit@home.org.au">SvenDowideit@home.org.au</a>&gt;</b>

       August 2014, updated by Sven Dowideit <b>&lt;<a href="mailto:SvenDowideit@home.org.au">SvenDowideit@home.org.au</a>&gt;</b>

</pre><h4><b>FOOTNOTES</b></h4><pre>
       1: The Podman project is committed to inclusivity, a core value of open  source.  The  <b>master</b>  and  <b>slave</b>
       mount  propagation  terminology  used here is problematic and divisive, and needs to be changed. However,
       these terms are currently used within the Linux kernel and must be used as-is  at  this  time.  When  the
       kernel maintainers rectify this usage, Podman will follow suit immediately.

                                                                                                <u><a href="../man1/podman-create.1.html">podman-create</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>