<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>srun - Run parallel jobs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/slurm-client">slurm-client_24.11.3-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       srun - Run parallel jobs

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>srun</b> [<u><a href="../man0/OPTIONS.0.html">OPTIONS</a>(0)</u>... [<u><a href="../man0/executable.0.html">executable</a>(0)</u> [<u><a href="../man0/args.0.html">args</a>(0)</u>...]]] [ : [<u>OPTIONS(N)</u>...]] <u>executable(N)</u> [<u>args(N)</u>...]

       Option(s) define multiple jobs in a co-scheduled heterogeneous job.  For more details about heterogeneous
       jobs see the document
       https://slurm.schedmd.com/heterogeneous_jobs.html

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Run  a  parallel  job  on  cluster  managed  by  Slurm.  If  necessary, srun will first create a resource
       allocation in which to run the parallel job.

       The following document describes the influence of various options on the allocation of cpus to  jobs  and
       tasks.
       https://slurm.schedmd.com/cpu_management.html

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       srun  will  return  the highest exit code of all tasks run or the highest signal (with the high-order bit
       set in an 8-bit integer -- e.g. 128 + signal) of any task that exited with a signal.
       The value 253 is reserved for out-of-memory errors.

</pre><h4><b>EXECUTABLE</b> <b>PATH</b> <b>RESOLUTION</b></h4><pre>
       The executable is resolved in the following order:

       1. If executable starts with ".", then path is constructed as: current working directory / executable
       2. If executable starts with a "/", then path is considered absolute.
       3. If executable can be resolved through PATH. See <b><a href="../man7/path_resolution.7.html">path_resolution</a></b>(7).
       4. If executable is in current working directory.

       Current working directory is the calling process working directory unless the <b>--chdir</b> argument is passed,
       which will override the current working directory.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-A</b>, <b>--account</b>=&lt;<u>account</u>&gt;
              Charge resources used by this job to specified account.  The <u>account</u> is an arbitrary  string.  The
              account  name  may be changed after job submission using the <b>scontrol</b> command. This option applies
              to job allocations.

       <b>--acctg-freq</b>=&lt;<u>datatype</u>&gt;=&lt;<u>interval</u>&gt;[,&lt;<u>datatype</u>&gt;=&lt;<u>interval</u>&gt;...]
              Define the job accounting and profiling sampling intervals  in  seconds.   This  can  be  used  to
              override  the  <u>JobAcctGatherFrequency</u>  parameter  in  the  slurm.conf  file. &lt;<u>datatype</u>&gt;=&lt;<u>interval</u>&gt;
              specifies the task sampling interval for the jobacct_gather plugin or a sampling  interval  for  a
              profiling  type  by the acct_gather_profile plugin. Multiple comma-separated &lt;<u>datatype</u>&gt;=&lt;<u>interval</u>&gt;
              pairs may be specified. Supported <u>datatype</u> values are:

              <b>task</b>        Sampling interval for the  jobacct_gather  plugins  and  for  task  profiling  by  the
                          acct_gather_profile plugin.
                          <b>NOTE</b>:  This  frequency  is used to monitor memory usage. If memory limits are enforced
                          the highest frequency a user can request is what is configured in the slurm.conf file.
                          It can not be disabled.

              <b>energy</b>      Sampling interval for energy profiling using the acct_gather_energy plugin.

              <b>network</b>     Sampling interval for infiniband profiling using the acct_gather_interconnect plugin.

              <b>filesystem</b>  Sampling interval for filesystem profiling using the acct_gather_filesystem plugin.

              The default value for the task sampling interval is 30 seconds.  The default value for  all  other
              intervals  is  0.  An interval of 0 disables sampling of the specified type.  If the task sampling
              interval is 0, accounting information  is  collected  only  at  job  termination  (reducing  Slurm
              interference with the job).
              Smaller (non-zero) values have a greater impact upon job performance, but a value of 30 seconds is
              not likely to be noticeable for applications having less than 10,000 tasks. This option applies to
              job allocations.

       <b>--bb</b>=&lt;<u>spec</u>&gt;
              Burst  buffer  specification.  The form of the specification is system dependent.  Also see <b>--bbf</b>.
              This option applies to job allocations.  When the <b>--bb</b> option is used, Slurm  parses  this  option
              and  creates  a  temporary  burst  buffer  script file that is used internally by the burst buffer
              plugins. See Slurm's burst buffer guide for more information and examples:
              https://slurm.schedmd.com/burst_buffer.html

       <b>--bbf</b>=&lt;<u>file_name</u>&gt;
              Path of file containing burst buffer specification.  The  form  of  the  specification  is  system
              dependent.  Also see <b>--bb</b>. This option applies to job allocations.  See Slurm's burst buffer guide
              for more information and examples:
              https://slurm.schedmd.com/burst_buffer.html

       <b>--bcast</b>[=&lt;<u>dest_path</u>&gt;]
              Copy executable file to allocated compute nodes.  If a file name is specified, copy the executable
              to  the  specified  destination file path.  If the path specified ends with '/' it is treated as a
              target directory, and the destination file name will be slurm_bcast_&lt;job_id&gt;.&lt;step_id&gt;_&lt;nodename&gt;.
              If no dest_path is specified and the slurm.conf <b>BcastParameters</b> <b>DestDir</b> is configured then  it  is
              used,  and  the  filename  follows  the  above pattern. If none of the previous is specified, then
              <b>--chdir</b>  is  used,  and  the  filename  follows  the  above  pattern  too.   For  example,   "srun
              --bcast=/tmp/mine  -N3  a.out"  will copy the file "a.out" from your current directory to the file
              "/tmp/mine" on each of the three allocated compute  nodes  and  execute  that  file.  This  option
              applies to step allocations.

       <b>--bcast-exclude</b>={NONE|&lt;<u>exclude_path</u>&gt;[,&lt;<u>exclude_path</u>&gt;...]}
              Comma-separated   list  of  absolute  directory  paths  to  be  excluded  when  autodetecting  and
              broadcasting executable shared object dependencies through  <b>--bcast</b>.  If  the  keyword  "<u>NONE</u>"  is
              configured,  no  directory  paths  will  be  excluded.  The  default  value  is that of slurm.conf
              <b>BcastExclude</b> and this option overrides it. See also <b>--bcast</b> and <b>--send-libs</b>.

       <b>-b</b>, <b>--begin</b>=&lt;<u>time</u>&gt;
              Defer initiation of this job until the specified time.  It accepts times of the form  <u>HH:MM:SS</u>  to
              run  a  job  at a specific time of day (seconds are optional).  (If that time is already past, the
              next day is assumed.)  You may also specify <u>midnight</u>, <u>noon</u>, <u>elevenses</u> (11  AM),  <u>fika</u>  (3  PM)  or
              <u>teatime</u> (4 PM) and you can have a time-of-day suffixed with <u>AM</u> or <u>PM</u> for running in the morning or
              the  evening.   You  can  also  say what day the job will be run, by specifying a date of the form
              <u>MMDDYY</u>  or  <u>MM/DD/YY</u>  <u>YYYY-MM-DD</u>.   Combine   date   and   time   using   the   following   format
              <u>YYYY-MM-DD[THH:MM[:SS]]</u>. You can also give times like <u>now</u> <u>+</u> <u>count</u> <u>time-units</u>, where the time-units
              can  be  <u>seconds</u>  (default),  <u>minutes</u>, <u>hours</u>, <u>days</u>, or <u>weeks</u> and you can tell Slurm to run the job
              today with the keyword <u>today</u> and to run the job tomorrow with the keyword <u>tomorrow</u>.  The value may
              be changed after job submission using the <b>scontrol</b> command.  For example:

                 --begin=16:00
                 --begin=now+1hour
                 --begin=now+60           (seconds by default)
                 --begin=2010-01-20T12:34:00

              Notes on date/time specifications:
               - Although the 'seconds' field of the HH:MM:SS time specification is allowed by  the  code,  note
              that  the  poll time of the Slurm scheduler is not precise enough to guarantee dispatch of the job
              on the exact second. The job will be eligible to start on the next poll  following  the  specified
              time.  The  exact  poll interval depends on the Slurm scheduler (e.g., 60 seconds with the default
              sched/builtin).
               - If no time (HH:MM:SS) is specified, the default is (00:00:00).
               - If a date is specified without a year (e.g., MM/DD) then the current year  is  assumed,  unless
              the  combination  of  MM/DD  and HH:MM:SS has already passed for that year, in which case the next
              year is used.
              This option applies to job allocations.

       <b>-D</b>, <b>--chdir</b>=&lt;<u>path</u>&gt;
              Have the remote processes do a chdir to <u>path</u> before beginning execution. The default is  to  chdir
              to  the  current  working directory of the <b>srun</b> process. The path can be specified as full path or
              relative path to the directory  where  the  command  is  executed.  This  option  applies  to  job
              allocations.

       <b>--cluster-constraint</b>=&lt;<u>list</u>&gt;
              Specifies features that a federated cluster must have to have a sibling job submitted to it. Slurm
              will  attempt  to  submit  a  sibling  job  to  a  cluster if it has at least one of the specified
              features.

       <b>-M</b>, <b>--clusters</b>=&lt;<u>string</u>&gt;
              Clusters to issue commands to. Multiple cluster names may be comma separated.   The  job  will  be
              submitted  to  the  one  cluster  providing the earliest expected job initiation time. The default
              value is the current cluster. A value of '<u>all</u>' will  query  to  run  on  all  clusters.  Note  the
              <b>--export</b>  option  to control environment variables exported between clusters.  This option applies
              only to job allocations.  Note that the <b>slurmdbd</b> must be up for  this  option  to  work  properly,
              unless running in a federation with <b>FederationParameters=fed_display</b> configured.

       <b>--comment</b>=&lt;<u>string</u>&gt;
              An arbitrary comment. This option applies to job allocations.

       <b>--compress</b>[=<u>type</u>]
              Compress  file  before  sending  it  to  compute  hosts.  The optional argument specifies the data
              compression library to be used.  The default is  <b>BcastParameters</b>  <b>Compression=</b>  if  set  or  "lz4"
              otherwise.   Supported  values  are  "lz4".  Some compression libraries may be unavailable on some
              systems.  For use with the <b>--bcast</b> option. This option applies to step allocations.

       <b>-C</b>, <b>--constraint</b>=&lt;<u>list</u>&gt;
              Nodes can have <b>features</b> assigned to them by the Slurm administrator.  Users can specify  which  of
              these  <b>features</b>  are  required  by  their  job using the constraint option. If you are looking for
              'soft' constraints please see <b>--prefer</b> for more information.  Only nodes having features  matching
              the  job  constraints  will be used to satisfy the request.  Multiple constraints may be specified
              with AND, OR, matching OR, resource counts, etc. (some operators are not supported on  all  system
              types).

              <b>NOTE</b>: Changeable features are features defined by a NodeFeatures plugin.

              Supported <b>--constraint</b> options include:

              <b>Single</b> <b>Name</b>
                     Only   nodes   which   have   the   specified   feature   will   be   used.   For  example,
                     <b>--constraint="intel"</b>

              <b>Node</b> <b>Count</b>
                     A request can specify the number of nodes needed with some feature by appending an asterisk
                     and count after  the  feature  name.   For  example,  <b>--nodes=16</b>  <b>--constraint="graphics*4"</b>
                     indicates  that  the  job requires 16 nodes and that at least four of those nodes must have
                     the feature "graphics."  If requesting more than one feature and  using  node  counts,  the
                     request must have square brackets surrounding it.

                     <b>NOTE</b>:  This option is not supported by the helpers NodeFeatures plugin.  Heterogeneous jobs
                     can be used instead.

              <b>AND</b>    Only nodes with all of specified features will be used.  The ampersand is used for  an  AND
                     operator.  For example, <b>--constraint="intel&amp;gpu"</b>

              <b>OR</b>     Only  nodes with at least one of specified features will be used.  The vertical bar is used
                     for an OR operator. If changeable features are not requested, nodes in the  allocation  can
                     have  different  features. For example, <b>salloc</b> <b>-N2</b> <b>--constraint="intel|amd"</b> can result in a
                     job allocation where one node has the intel feature and the other node has the amd feature.
                     However, if the expression contains  a  changeable  feature,  then  all  OR  operators  are
                     automatically  treated as Matching OR so that all nodes in the job allocation have the same
                     set of features. For example, <b>salloc</b> <b>-N2</b> <b>--constraint="foo|bar&amp;baz"</b> The  job  is  allocated
                     two nodes where both nodes have foo, or bar and baz (one or both nodes could have foo, bar,
                     and  baz).  The  helpers  NodeFeatures plugin will find the first set of node features that
                     matches all nodes in the job allocation; these features are set as active features  on  the
                     node   and  passed  to  RebootProgram  (see  <b><a href="../man5/slurm.conf.5.html">slurm.conf</a></b>(5))  and  the  helper  script  (see
                     <b><a href="../man5/helpers.conf.5.html">helpers.conf</a></b>(5)). In this case, the helpers plugin uses the first  of  "foo"  or  "bar,baz"
                     that match the two nodes in the job allocation.

              <b>Matching</b> <b>OR</b>
                     If  only  one of a set of possible options should be used for all allocated nodes, then use
                     the  OR  operator  and  enclose  the  options  within  square   brackets.    For   example,
                     <b>--constraint="[rack1|rack2|rack3|rack4]"</b>  might  be  used to specify that all nodes must be
                     allocated on a single rack of the cluster, but any of those four racks can be used.

              <b>Multiple</b> <b>Counts</b>
                     Specific counts of multiple resources may be  specified  by  using  the  AND  operator  and
                     enclosing      the      options      within      square     brackets.      For     example,
                     <b>--constraint="[rack1*2&amp;rack2*4]"</b> might be used to specify that two nodes must be  allocated
                     from nodes with the feature of "rack1" and four nodes must be allocated from nodes with the
                     feature "rack2".

                     <b>NOTE</b>: This construct does not support multiple Intel KNL NUMA or MCDRAM modes. For example,
                     while        <b>--constraint="[(knl&amp;quad)*2&amp;(knl&amp;hemi)*4]"</b>       is       not       supported,
                     <b>--constraint="[haswell*2&amp;(knl&amp;hemi)*4]"</b> is supported.  Specification of multiple KNL  modes
                     requires the use of a heterogeneous job.

                     <b>NOTE</b>: This option is not supported by the helpers NodeFeatures plugin.

                     <b>NOTE</b>: Multiple Counts can cause jobs to be allocated with a non-optimal network layout.

              <b>Brackets</b>
                     Brackets can be used to indicate that you are looking for a set of nodes with the different
                     requirements       contained       within       the       brackets.       For      example,
                     <b>--constraint="[(rack1|rack2)*1&amp;(rack3)*2]"</b> will get you one node with either the "rack1" or
                     "rack2" features and two nodes with the "rack3"  feature.   If  requesting  more  than  one
                     feature and using node counts, the request must have square brackets surrounding it.

                     <b>NOTE</b>: Brackets are only reserved for <b>Multiple</b> <b>Counts</b> and <b>Matching</b> <b>OR</b> syntax.  AND operators
                     require  a  count  for  each feature inside square brackets (i.e. "[quad*2&amp;hemi*1]"). Slurm
                     will only allow a single set of bracketed constraints per job.

                     <b>NOTE</b>: Square brackets are not supported by the helpers NodeFeatures plugin. Matching OR can
                     be requested without square brackets by using the vertical bar character with at least  one
                     changeable feature.

              <b>Parentheses</b>
                     Parentheses   can   be   used   to   group   like  node  features  together.  For  example,
                     <b>--constraint="[(knl&amp;snc4&amp;flat)*4&amp;haswell*1]"</b> might be used to specify that four nodes  with
                     the  features  "knl",  "snc4"  and  "flat"  plus  one  node  with the feature "haswell" are
                     required.  Parentheses can also be used to  group  operations.  Without  parentheses,  node
                     features  are  parsed strictly from left to right.  For example, <b>--constraint="foo&amp;bar|baz"</b>
                     requests nodes with foo and bar, or baz.  <b>--constraint="foo|bar&amp;baz"</b>  requests  nodes  with
                     foo   and   baz,   or   bar   and   baz   (note   how   baz  was  AND'd  with  everything).
                     <b>--constraint="foo&amp;(bar|baz)"</b> requests nodes with foo and at least one of bar or baz.  <b>NOTE</b>:
                     OR within parentheses should not be used with a KNL NodeFeatures plugin but is supported by
                     the helpers NodeFeatures plugin.

              <b>WARNING</b>: When srun is executed from within salloc or sbatch, the constraint value can only contain
              a single feature name. None of the other operators are currently supported for job steps.
              This option applies to job and step allocations.

       <b>--container</b>=&lt;<u>path_to_container</u>&gt;
              Absolute path to OCI container bundle.

       <b>--container-id</b>=&lt;<u>container_id</u>&gt;
              Unique name for OCI container.

       <b>--contiguous</b>
              If set, then the allocated nodes must form a contiguous set.

              <b>NOTE</b>: If the SelectType is cons_tres this option  won't  be  honored  with  the  <b>topology/tree</b>  or
              <b>topology/3d_torus</b>  plugins, both of which can modify the node ordering. This option applies to job
              allocations.

       <b>-S</b>, <b>--core-spec</b>=&lt;<u>num</u>&gt;
              Count of Specialized Cores per node reserved by the job for system operations and not used by  the
              application.   If  AllowSpecResourcesUsage  is enabled a job can override the CoreSpecCount of all
              its allocated nodes with this option.  The overridden Specialized Cores will still be reserved for
              system processes.  The job will get an implicit <b>--exclusive</b> allocation for the rest of  the  Cores
              on  the  nodes, resulting in the job's processes being able to use (and being charged for) all the
              Cores on the nodes except for the overridden Specialized Cores.  This option can not be used  with
              the <b>--thread-spec</b> option.

              <b>NOTE</b>: Explicitly setting a job's specialized core value implicitly sets the --exclusive option.

              <b>NOTE</b>: This option may implicitly impact the number of tasks if <b>-n</b> was not specified.

              This option applies to job allocations.

       <b>--cores-per-socket</b>=&lt;<u>cores</u>&gt;
              Restrict  node  selection  to  nodes  with  at least the specified number of cores per socket. See
              additional information under <b>-B</b> option above when task/affinity plugin  is  enabled.  This  option
              applies to job allocations.

       <b>--cpu-bind</b>=[{quiet|verbose},]&lt;<u>type</u>&gt;
              Bind  tasks  to  CPUs.   Used  only when the task/affinity plugin is enabled.  <b>NOTE</b>: To have Slurm
              always report on the selected CPU binding for all commands executed in a  shell,  you  can  enable
              verbose mode by setting the SLURM_CPU_BIND environment variable value to "verbose".

              The following informational environment variables are set when <b>--cpu-bind</b> is in use:

                   SLURM_CPU_BIND_VERBOSE
                   SLURM_CPU_BIND_TYPE
                   SLURM_CPU_BIND_LIST

              See  the  <b>ENVIRONMENT</b>  <b>VARIABLES</b>  section  for  a  more  detailed  description  of  the individual
              SLURM_CPU_BIND variables. These variables are  available  only  if  the  task/affinity  plugin  is
              configured.

              When using <b>--cpus-per-task</b> to run multithreaded tasks, be aware that CPU binding is inherited from
              the  parent  of the process. This means that the multithreaded task should either specify or clear
              the CPU binding itself to avoid having all threads of the multithreaded task use the same mask/CPU
              as the parent. Alternatively, fat masks (masks which specify more than one allowed CPU)  could  be
              used for the tasks in order to provide multiple CPUs for the multithreaded tasks.

              Note  that a job step can be allocated different numbers of CPUs on each node or be allocated CPUs
              not starting at location zero. Therefore one of the options which automatically generate the  task
              binding is recommended.  Explicitly specified masks or bindings are only honored when the job step
              has been allocated every available CPU on the node.

              Binding  a task to a NUMA locality domain means to bind the task to the set of CPUs that belong to
              the NUMA locality domain or "NUMA node".  If NUMA locality domain options are used on systems with
              no NUMA support, then each socket is considered a locality domain.

              If the <b>--cpu-bind</b> option  is  not  used,  the  default  binding  mode  will  depend  upon  Slurm's
              configuration and the step's resource allocation.  If all allocated nodes have the same configured
              CpuBind  mode, that will be used.  Otherwise if the job's Partition has a configured CpuBind mode,
              that will be used.  Otherwise if Slurm has a configured TaskPluginParam value, that mode  will  be
              used.  Otherwise automatic binding will be performed as described below.

              <b>Auto</b> <b>Binding</b>
                     Applies  only  when  task/affinity  is  enabled.  If  the  job  step allocation includes an
                     allocation with a number of sockets, cores, or threads equal to the number of  tasks  times
                     cpus-per-task,  then  the tasks will by default be bound to the appropriate resources (auto
                     binding). Disable this mode of  operation  by  explicitly  setting  "--cpu-bind=none".  Use
                     TaskPluginParam=autobind=[threads|cores|sockets] to set a default cpu binding in case "auto
                     binding" doesn't find a match.

              Supported options include:

                     <b>q[uiet]</b>
                            Quietly bind before task runs (default)

                     <b>v[erbose]</b>
                            Verbosely report binding before task runs

                     <b>no[ne]</b> Do not bind tasks to CPUs (default unless auto binding is applied)

                     <b>map_cpu:&lt;list&gt;</b>
                            Bind  by  setting  CPU  masks  on  tasks  (or  ranks)  as  specified where &lt;list&gt; is
                            &lt;cpu_id_for_task_0&gt;,&lt;cpu_id_for_task_1&gt;,...  If  the  number  of  tasks  (or  ranks)
                            exceeds  the number of elements in this list, elements in the list will be reused as
                            needed starting from the beginning of the list.  To simplify support for large  task
                            counts,  the  lists  may  follow  a  map with an asterisk and repetition count.  For
                            example "map_cpu:0*4,3*4".

                     <b>mask_cpu:&lt;list&gt;</b>
                            Bind by setting CPU  masks  on  tasks  (or  ranks)  as  specified  where  &lt;list&gt;  is
                            &lt;cpu_mask_for_task_0&gt;,&lt;cpu_mask_for_task_1&gt;,...  The mapping is specified for a node
                            and identical mapping is applied to the tasks on every node (i.e. the lowest task ID
                            on  each  node  is mapped to the first mask specified in the list, etc.).  CPU masks
                            are <b>always</b> interpreted as hexadecimal values but can be preceded  with  an  optional
                            '0x'.   If  the  number  of  tasks (or ranks) exceeds the number of elements in this
                            list, elements in the list will be reused as needed starting from the  beginning  of
                            the  list.   To  simplify  support for large task counts, the lists may follow a map
                            with an asterisk and repetition count.  For example "mask_cpu:0x0f*4,0xf0*4".

                     <b>rank_ldom</b>
                            Bind to a NUMA locality domain by rank. Not supported  unless  the  entire  node  is
                            allocated to the job.

                     <b>map_ldom:&lt;list&gt;</b>
                            Bind  by  mapping  NUMA  locality  domain  IDs to tasks as specified where &lt;list&gt; is
                            &lt;ldom1&gt;,&lt;ldom2&gt;,...&lt;ldomN&gt;.  The locality domain  IDs  are  interpreted  as  decimal
                            values  unless  they  are  preceded  with '0x' in which case they are interpreted as
                            hexadecimal values.  Not supported unless the entire node is allocated to the job.

                     <b>mask_ldom:&lt;list&gt;</b>
                            Bind by setting NUMA locality domain masks on tasks as  specified  where  &lt;list&gt;  is
                            &lt;mask1&gt;,&lt;mask2&gt;,...&lt;maskN&gt;.   NUMA  locality  domain masks are <b>always</b> interpreted as
                            hexadecimal values but can be preceded with an optional '0x'.  Not supported  unless
                            the entire node is allocated to the job.

                     <b>sockets</b>
                            Automatically  generate masks binding tasks to sockets.  Only the CPUs on the socket
                            which have been allocated to the job will be used.  If the number of  tasks  differs
                            from the number of allocated sockets this can result in sub-optimal binding.

                     <b>cores</b>  Automatically generate masks binding tasks to cores.  If the number of tasks differs
                            from the number of allocated cores this can result in sub-optimal binding.

                     <b>threads</b>
                            Automatically  generate  masks  binding  tasks  to  threads.  If the number of tasks
                            differs from the number of allocated threads this can result in sub-optimal binding.

                     <b>ldoms</b>  Automatically generate masks binding tasks to NUMA locality domains.  If the  number
                            of  tasks  differs  from the number of allocated locality domains this can result in
                            sub-optimal binding.

                     <b>help</b>   Show help message for cpu-bind

              This option applies to job and step allocations.

       <b>--cpu-freq</b>=&lt;<u>p1</u>&gt;[-<u>p2</u>][:<u>p3</u>]

              Request that the job step initiated by this srun command be run at  some  requested  frequency  if
              possible, on the CPUs selected for the step on the compute node(s).

              <b>p1</b>  can be [#### | low | medium | high | highm1] which will set the frequency scaling_speed to the
              corresponding value, and set the frequency scaling_governor to UserSpace. See below for definition
              of the values.

              <b>p1</b> can be [Conservative | OnDemand | Performance | PowerSave] which will set the  scaling_governor
              to  the  corresponding  value.  The  governor  has  to be in the list set by the slurm.conf option
              CpuFreqGovernors.

              When <b>p2</b> is present, <b>p1</b> will be the minimum scaling frequency and <b>p2</b> will be  the  maximum  scaling
              frequency. In that case the governor <b>p3</b> or CpuFreqDef cannot be UserSpace since it doesn't support
              a range.

              <b>p2</b>  can  be  [####  | medium | high | highm1]. p2 must be greater than p1 and is incompatible with
              UserSpace governor.

              <b>p3</b> can be [Conservative | OnDemand | Performance | PowerSave | SchedUtil | UserSpace]  which  will
              set the governor to the corresponding value.

              If  <b>p3</b>  is  UserSpace,  the frequency scaling_speed, scaling_max_freq and scaling_min_freq will be
              statically set to the value defined by <b>p1</b>.

              Any requested frequency below the minimum available frequency  will  be  rounded  to  the  minimum
              available  frequency.  In  the  same  way,  any  requested  frequency  above the maximum available
              frequency will be rounded to the maximum available frequency.

              The <b>CpuFreqDef</b> parameter in slurm.conf will be used to set the  governor  in  absence  of  <b>p3</b>.  If
              there's no <b>CpuFreqDef</b>, the default governor will be to use the system current governor set in each
              cpu. Specifying a range without <b>CpuFreqDef</b> or a specific governor is therefore not allowed.

              Acceptable values at present include:

              <b>####</b>          frequency in kilohertz

              <b>Low</b>           the lowest available frequency

              <b>High</b>          the highest available frequency

              <b>HighM1</b>        (high minus one) will select the next highest available frequency

              <b>Medium</b>        attempts to set a frequency in the middle of the available range

              <b>Conservative</b>  attempts to use the Conservative CPU governor

              <b>OnDemand</b>      attempts to use the OnDemand CPU governor (the default value)

              <b>Performance</b>   attempts to use the Performance CPU governor

              <b>PowerSave</b>     attempts to use the PowerSave CPU governor

              <b>UserSpace</b>     attempts to use the UserSpace CPU governor

              The following informational environment variable is set in the job
              step when <b>--cpu-freq</b> option is requested.
                      SLURM_CPU_FREQ_REQ

              This environment variable can also be used to supply the value for the CPU frequency request if it
              is  set  when  the 'srun' command is issued.  The <b>--cpu-freq</b> on the command line will override the
              environment variable value. The form on the environment variable is the same as the command  line.
              See the <b>ENVIRONMENT</b> <b>VARIABLES</b> section for a description of the SLURM_CPU_FREQ_REQ variable.

              <b>NOTE</b>:  This parameter is treated as a request, not a requirement.  If the job step's node does not
              support setting the CPU frequency, or the requested value is  outside  the  bounds  of  the  legal
              frequencies, an error is logged, but the job step is allowed to continue.

              <b>NOTE</b>:  Setting the frequency for just the CPUs of the job step implies that the tasks are confined
              to those CPUs. If  task  confinement  (i.e.  the  task/affinity  TaskPlugin  is  enabled,  or  the
              task/cgroup TaskPlugin is enabled with "ConstrainCores=yes" set in cgroup.conf) is not configured,
              this parameter is ignored.

              <b>NOTE</b>:  When  the  step  completes, the frequency and governor of each selected CPU is reset to the
              previous values.

              <b>NOTE</b>: When submitting jobs with the <b>--cpu-freq</b> option with  linuxproc  as  the  ProctrackType  can
              cause  jobs  to run too quickly before Accounting is able to poll for job information. As a result
              not all of accounting information will be present.

              This option applies to job and step allocations.

       <b>--cpus-per-gpu</b>=&lt;<u>ncpus</u>&gt;
              Request that <u>ncpus</u> processors be allocated per allocated GPU.  This option implies  --exact.   Not
              compatible with the <b>--cpus-per-task</b> option.

              This option applies to job and step allocations.

       <b>-c</b>, <b>--cpus-per-task</b>=&lt;<u>ncpus</u>&gt;
              Request  that  <u>ncpus</u>  be allocated <b>per</b> <b>process</b>. This may be useful if the job is multithreaded and
              requires more than one CPU per task for optimal performance.  Explicitly  requesting  this  option
              implies  <b>--exact</b>.  The  default  is  one  CPU  per  process  and does not imply <b>--exact</b>.  If <b>-c</b> is
              specified without <b>-n</b>, as many tasks will be allocated per node as possible while satisfying the <b>-c</b>
              restriction. For instance on a cluster with 8 CPUs per node, a job request for 4 nodes and 3  CPUs
              per  task  may  be  allocated 3 or 6 CPUs per node (1 or 2 tasks per node) depending upon resource
              consumption by other jobs. Such a job may be unable to execute more than a total of 4 tasks.

              <b>WARNING</b>: There are configurations and options interpreted differently by job and job step requests
              which can result in inconsistencies for this option.  For example  <u>srun</u>  <u>-c2</u>  <u>--threads-per-core=1</u>
              <u>prog</u>  may allocate two cores for the job, but if each of those cores contains two threads, the job
              allocation will include four CPUs. The job step allocation will then launch two  threads  per  CPU
              for a total of two tasks.

              <b>WARNING</b>:  When srun is executed from within salloc or sbatch, there are configurations and options
              which can result in inconsistent allocations when -c has a value greater  than  -c  on  salloc  or
              sbatch.

              <b>NOTE</b>:  If  <b>--mem-per-cpu</b>  is  also  specified,  the  number  of allocated cpus can be increased if
              <b>MaxMemPerCPU</b> is exceeded. In the case <b>-n</b> is not specified, the number of tasks can be higher  than
              expected.

              This option applies to job and step allocations.

       <b>--deadline</b>=&lt;<u>OPT</u>&gt;
              Remove  the  job  if no ending is possible before this deadline (start &gt; (deadline - time[-min])).
              Default is no deadline. Note that if  neither  <b>DefaultTime</b>  nor  <b>MaxTime</b>  are  configured  on  the
              partition  the job is in, the job will need to specify some form of time limit (--time[-min]) if a
              deadline is to be used.

              Valid time formats are:
              HH:MM[:SS] [AM|PM]
              MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]
              MM/DD[/YY]-HH:MM[:SS]
              YYYY-MM-DD[THH:MM[:SS]]]
              now[+<u>count</u>[seconds(default)|minutes|hours|days|weeks]]

              This option applies only to job allocations.

       <b>--delay-boot</b>=&lt;<u>minutes</u>&gt;
              Do not reboot nodes in order to satisfied this job's feature specification if  the  job  has  been
              eligible to run for less than this time period.  If the job has waited for less than the specified
              period,  it  will  use  only  nodes which already have the specified features.  The argument is in
              units of minutes.  A default value may be set by  a  system  administrator  using  the  <b>delay_boot</b>
              option  of  the  <b>SchedulerParameters</b> configuration parameter in the slurm.conf file, otherwise the
              default value is zero (no delay).

              This option applies only to job allocations.

       <b>-d</b>, <b>--dependency</b>=&lt;<u>dependency_list</u>&gt;
              Defer the start of this  job  until  the  specified  dependencies  have  been  satisfied.  Once  a
              dependency  is  satisfied,  it  is  removed from the job.  This option does not apply to job steps
              (executions of srun within an existing salloc or  sbatch  allocation)  only  to  job  allocations.
              &lt;<u>dependency_list</u>&gt;    is    of    the    form    &lt;<u>type:job_id[:job_id][,type:job_id[:job_id]]</u>&gt;   or
              &lt;<u>type:job_id[:job_id][?type:job_id[:job_id]]</u>&gt;.  All dependencies must  be  satisfied  if  the  ","
              separator  is  used.   Any  dependency  may  be  satisfied if the "?" separator is used.  Only one
              separator may be used. For instance:
              -d afterok:20:21,afterany:23
              means that the job can run only after a 0 return code of jobs 20 and 21 AND the completion of  job
              23. However:
              -d afterok:20:21?afterany:23
              means  that  any  of  the  conditions  (afterok:20 OR afterok:21 OR afterany:23) will be enough to
              release the job.  Many jobs can share the same dependency  and  these  jobs  may  even  belong  to
              different  users.  The  value  may  be  changed  after  job submission using the scontrol command.
              Dependencies on remote jobs are allowed in a federation.  Once a job dependency fails due  to  the
              termination  state  of a preceding job, the dependent job will never be run, even if the preceding
              job is requeued and has a different termination state  in  a  subsequent  execution.  This  option
              applies to job allocations.

              <b>after:job_id[[+time][:jobid[+time]...]]</b>
                     After  the  specified  jobs  start or are cancelled and 'time' in minutes from job start or
                     cancellation happens, this job can begin execution. If no 'time' is given then there is  no
                     delay after start or cancellation.

              <b>afterany:job_id[:jobid...]</b>
                     This job can begin execution after the specified jobs have terminated.  This is the default
                     dependency type.

              <b>afterburstbuffer:job_id[:jobid...]</b>
                     This  job  can  begin execution after the specified jobs have terminated and any associated
                     burst buffer stage out operations have completed.

              <b>aftercorr:job_id[:jobid...]</b>
                     A task of this job array can begin  execution  after  the  corresponding  task  ID  in  the
                     specified job has completed successfully (ran to completion with an exit code of zero).

              <b>afternotok:job_id[:jobid...]</b>
                     This  job can begin execution after the specified jobs have terminated in some failed state
                     (non-zero exit code, node failure, timed out, etc).  This job must be submitted  while  the
                     specified  job  is  still  active  or  within <b>MinJobAge</b> seconds after the specified job has
                     ended.

              <b>afterok:job_id[:jobid...]</b>
                     This job can begin execution after the specified jobs have successfully  executed  (ran  to
                     completion  with an exit code of zero).  This job must be submitted while the specified job
                     is still active or within <b>MinJobAge</b> seconds after the specified job has ended.

              <b>singleton</b>
                     This job can begin execution after any previously launched jobs sharing the same  job  name
                     and user have terminated.  In other words, only one job by that name and owned by that user
                     can  be running or suspended at any point in time.  In a federation, a singleton dependency
                     must be fulfilled on all clusters unless  DependencyParameters=disable_remote_singleton  is
                     used in slurm.conf.

       <b>-X</b>, <b>--disable-status</b>
              Disable  the  display  of  task  status  when  srun  receives  a  single  SIGINT (Ctrl-C). Instead
              immediately forward the SIGINT to the running job.  Without this option a  second  Ctrl-C  in  one
              second  is  required to forcibly terminate the job and <b>srun</b> will immediately exit. May also be set
              via the environment variable SLURM_DISABLE_STATUS. This option applies to job allocations.

       <b>-m</b>,
       <b>--distribution</b>={*|block|cyclic|arbitrary|plane=&lt;<u>size</u>&gt;}[:{*|block|cyclic|fcyclic}[:{*|block|cyclic|fcyclic}]][,{Pack|NoPack}]

              Specify alternate distribution methods for  remote  processes.   For  job  allocation,  this  sets
              environment variables that will be used by subsequent srun requests. Task distribution affects job
              allocation  at  the  last  stage of the evaluation of available resources by the cons_tres plugin.
              Consequently,  other  options  (e.g.  --ntasks-per-node,  --cpus-per-task)  may  affect   resource
              selection  prior  to  task distribution.  To ensure a specific task distribution, jobs should have
              access to entire nodes, which can be accomplished by using the <b>--exclusive</b> flag or  by  requesting
              all the resources on the node(s).

              This  option  controls  the  distribution  of  tasks  to  the  nodes  on which resources have been
              allocated, and the distribution of those resources to tasks for binding (task affinity). The first
              distribution method (before the first ":") controls the  distribution  of  tasks  to  nodes.   The
              second  distribution  method  (after  the  first  ":") controls the distribution of allocated CPUs
              across sockets for binding to tasks. The third distribution method (after the second ":") controls
              the distribution of allocated CPUs across cores for  binding  to  tasks.   The  second  and  third
              distributions apply only if task affinity is enabled.  The third distribution is supported only if
              the task/cgroup plugin is configured. The default value for each distribution type is specified by
              *.

              Note  that  with  select/cons_tres,  the  number  of CPUs allocated to each socket and node may be
              different. Refer to https://slurm.schedmd.com/mc_support.html for  more  information  on  resource
              allocation, distribution of tasks to nodes, and binding of tasks to CPUs.
              First distribution method (distribution of tasks across nodes):

              <b>*</b>      Use the default method for distributing tasks to nodes (block).

              <b>block</b>  The  block  distribution method will distribute tasks to a node such that consecutive tasks
                     share a node. For example, consider an allocation of three nodes  each  with  two  cpus.  A
                     four-task  block  distribution  request will distribute those tasks to the nodes with tasks
                     one and two on the first node, task three on the second node, and task four  on  the  third
                     node.  Block distribution is the default behavior if the number of tasks exceeds the number
                     of allocated nodes.

              <b>cyclic</b> The cyclic distribution method will distribute tasks to a node such that consecutive  tasks
                     are distributed over consecutive nodes (in a round-robin fashion). For example, consider an
                     allocation  of three nodes each with two cpus. A four-task cyclic distribution request will
                     distribute those tasks to the nodes with tasks one and four on the first node, task two  on
                     the  second  node,  and  task  three  on  the  third  node.   Note  that when SelectType is
                     select/cons_tres, the same number  of  CPUs  may  not  be  allocated  on  each  node.  Task
                     distribution will be round-robin among all the nodes with CPUs yet to be assigned to tasks.
                     Cyclic  distribution  is  the default behavior if the number of tasks is no larger than the
                     number of allocated nodes.

              <b>plane</b>  The  tasks  are  distributed  in  blocks  of  size  &lt;<u>size</u>&gt;.  The  size  must  be  given  or
                     SLURM_DIST_PLANESIZE  must be set. The number of tasks distributed to each node is the same
                     as for cyclic distribution, but the taskids assigned to each node depend on the plane size.
                     Additional distribution specifications cannot be  combined  with  this  option.   For  more
                     details        (including        examples       and       diagrams),       please       see
                     https://slurm.schedmd.com/mc_support.html and https://slurm.schedmd.com/dist_plane.html

              <b>arbitrary</b>
                     The arbitrary method of distribution will allocate processes in-order  as  listed  in  file
                     designated  by  the environment variable SLURM_HOSTFILE. If this variable is listed it will
                     override any other method specified. If not set the method will default to  block.   Inside
                     the  hostfile  must contain at minimum the number of hosts requested and be one per line or
                     comma separated. If specifying a task count (<b>-n</b>, <b>--ntasks</b>=&lt;<u>number</u>&gt;),  your  tasks  will  be
                     laid out on the nodes in the order of the file.
                     <b>NOTE</b>:  The  arbitrary distribution option on a job allocation only controls the nodes to be
                     allocated to the job and not the allocation of CPUs on those nodes. This  option  is  meant
                     primarily  to  control  a job step's task layout in an existing job allocation for the srun
                     command.
                     <b>NOTE</b>: If the number of tasks is given and a list of requested  nodes  is  also  given,  the
                     number of nodes used from that list will be reduced to match that of the number of tasks if
                     the number of nodes in the list is greater than the number of tasks.

              Second distribution method (distribution of CPUs across sockets for binding):

              <b>*</b>      Use the default method for distributing CPUs across sockets (cyclic).

              <b>block</b>  The  block  distribution  method will distribute allocated CPUs consecutively from the same
                     socket for binding to tasks, before using the next consecutive socket.

              <b>cyclic</b> The cyclic distribution method will distribute allocated CPUs for binding to a  given  task
                     consecutively from the same socket, and from the next consecutive socket for the next task,
                     in  a  round-robin fashion across sockets.  Tasks requiring more than one CPU will have all
                     of those CPUs allocated on a single socket if possible.
                     <b>NOTE</b>: In nodes with hyper-threading enabled, a  task  not  requesting  full  cores  may  be
                     distributed  across  sockets.  This can be avoided by specifying <b>--ntasks-per-core=1</b>, which
                     forces tasks to allocate full cores.

              <b>fcyclic</b>
                     The fcyclic distribution method will distribute allocated CPUs for binding  to  tasks  from
                     consecutive sockets in a round-robin fashion across the sockets.  Tasks requiring more than
                     one CPU will have each CPUs allocated in a cyclic fashion across sockets.

              Third distribution method (distribution of CPUs across cores for binding):

              <b>*</b>      Use  the  default  method  for  distributing  CPUs  across  cores  (inherited  from  second
                     distribution method).

              <b>block</b>  The block distribution method will distribute allocated CPUs consecutively  from  the  same
                     core for binding to tasks, before using the next consecutive core.

              <b>cyclic</b> The  cyclic  distribution method will distribute allocated CPUs for binding to a given task
                     consecutively from the same core, and from the next consecutive core for the next task,  in
                     a round-robin fashion across cores.

              <b>fcyclic</b>
                     The  fcyclic  distribution  method will distribute allocated CPUs for binding to tasks from
                     consecutive cores in a round-robin fashion across the cores.

              Optional control for task distribution over nodes:

              <b>Pack</b>   Rather than evenly distributing a job step's tasks evenly across its allocated nodes,  pack
                     them  as  tightly  as  possible  on  the  nodes.   This  only applies when the "block" task
                     distribution method is used.

              <b>NoPack</b> Rather than packing a job step's tasks as tightly as possible on the nodes, distribute them
                     evenly.   This  user  option  will   supersede   the   SelectTypeParameters   CR_Pack_Nodes
                     configuration parameter.

              This option applies to job and step allocations.

       <b>--epilog</b>={none|&lt;<u>executable</u>&gt;}
              <b>srun</b>  will  run  <u>executable</u>  just  after  the  job step completes.  The command line arguments for
              <u>executable</u> will be the command and arguments of the job step. If <u>none</u> is specified, then  no  srun
              epilog  will  be  run.  This  parameter  overrides  the  SrunEpilog  parameter in slurm.conf. This
              parameter is completely independent from the Epilog parameter in slurm.conf. This  option  applies
              to job allocations.

       <b>-e</b>, <b>--error</b>=&lt;<u>filename_pattern</u>&gt;
              Specify  how  stderr is to be redirected. By default in interactive mode, <b>srun</b> redirects stderr to
              the same file as stdout, if one is specified. The <b>--error</b> option is provided to allow  stdout  and
              stderr  to  be  redirected to different locations.  See <b>IO</b> <b>Redirection</b> below for more options.  If
              the specified file already exists, it will be overwritten. This option applies  to  job  and  step
              allocations.

       <b>--exact</b>
              Allow  a  step  access  to  only  the  resources requested for the step.  By default, all non-GRES
              resources on each node in the step allocation will be used.  This  option  only  applies  to  step
              allocations.
              <b>NOTE</b>:  Parallel  steps  will  either  be  blocked  or  rejected until requested step resources are
              available unless <b>--overlap</b> is specified. Job resources can be held after the completion of an srun
              command while Slurm does job cleanup. Step epilogs and/or SPANK  plugins  can  further  delay  the
              release of step resources.

       <b>-x</b>, <b>--exclude</b>={&lt;<u>host1</u>[,&lt;<u>host2</u>&gt;...]|&lt;<u>filename</u>&gt;}
              Request  that a specific list of hosts not be included in the resources allocated to this job. The
              host list will be assumed to be a filename if it contains a "/" character. This option applies  to
              job and step allocations.

       <b>--exclusive</b>[={user|mcs|topo}]
              This  option  applies to job and job step allocations, and has two slightly different meanings for
              each one.

              When used to initiate a <b>job</b>, the job allocation can not share nodes (or topology segment with  the
              "=topo")  with  other running jobs (or just other users with the "=user" option or "=mcs" option).
              If user/mcs/topo are not specified (i.e. the job allocation can not share nodes with other running
              jobs), the job allocation is allocated all CPUs and GRES on all nodes in the  allocation,  but  is
              only  allocated  as  much  memory  as  it requested. This is by design to support gang scheduling,
              because suspended jobs still reside in memory. To request all the memory on a node,  use  <b>--mem=0</b>.
              The  default  shared/exclusive  behavior  depends  on  system  configuration  and  the partition's
              <b>OverSubscribe</b> option takes precedence over the job's option.  <b>NOTE</b>: Since shared GRES (MPS) cannot
              be allocated at the same time as a sharing GRES (GPU) this option only allocates all sharing  GRES
              and no underlying shared GRES.

              This  option  can  also be used when initiating more than one <b>job</b> <b>step</b> within an existing resource
              allocation (default), where you want separate processors to be dedicated to each job step. The job
              step is only allocated as much GRES as is requested. If sufficient processors are not available to
              initiate the job step, it will be deferred. This can be thought of as providing  a  mechanism  for
              resource  management to the job within its allocation (<b>--exact</b> implied).  The exclusive allocation
              of CPUs applies to job steps by default, but --exact is <b>NOT</b>  the  default.  In  other  words,  the
              default  behavior is this: job steps will not share CPUs, but job steps will be allocated all CPUs
              available to the job on all nodes allocated to the steps.

              In order to share the resources use the <b>--overlap</b> option.

              <b>NOTE</b>: This option is mutually exclusive with <b>--oversubscribe</b>.

              See <b>EXAMPLE</b> below.

       <b>--export</b>={[ALL,]&lt;<u>environment_variables</u>&gt;|ALL|NONE}
              Identify which environment variables  from  the  submission  environment  are  propagated  to  the
              launched application.

              <b>--export</b>=ALL
                        Default  mode if <b>--export</b> is not specified. All of the user's environment will be loaded
                        from the caller's environment.

              <b>--export</b>=NONE
                        None of the user environment will be defined. User must use absolute path to the  binary
                        to  be  executed  that  will  define  the  environment.  User  can  not specify explicit
                        environment variables with "NONE".

                        This option is particularly important for jobs that are submitted  on  one  cluster  and
                        execute  on  a different cluster (e.g. with different paths).  To avoid steps inheriting
                        environment export settings (e.g. "NONE") from sbatch command, either  set  <b>--export</b>=ALL
                        or the environment variable SLURM_EXPORT_ENV should be set to "ALL".

              <b>--export</b>=[ALL,]&lt;<u>environment_variables</u>&gt;
                        Exports  all  SLURM*  environment  variables  along  with  explicitly defined variables.
                        Multiple environment variable names should be  comma  separated.   Environment  variable
                        names  may  be  specified  to  propagate  the  current value (e.g. "--export=EDITOR") or
                        specific values  may  be  exported  (e.g.  "--export=EDITOR=/bin/emacs").  If  "ALL"  is
                        specified,  then  all user environment variables will be loaded and will take precedence
                        over any explicitly given environment variables.

                   Example: <b>--export</b>=EDITOR,ARG1=test
                        In this example, the propagated environment will only contain the variable  <u>EDITOR</u>  from
                        the user's environment, <u>SLURM_*</u> environment variables, and <u>ARG1</u>=test.

                   Example: <b>--export</b>=ALL,EDITOR=/bin/emacs
                        There  are  two  possible  outcomes  for  this  example.  If  the  caller has the <u>EDITOR</u>
                        environment variable defined, then the job's environment will inherit the variable  from
                        the caller's environment. If the caller doesn't have an environment variable defined for
                        <u>EDITOR</u>, then the job's environment will use the value given by <b>--export</b>.

       <b>--external-launcher</b>
              Create  a  special step on one or more allocated nodes which won't consume any resources, but will
              have access to all of the job's allocated resources on the nodes.

              Options like --ntasks-per-*, --mem*, --cpus*, --tres*, --gres*, will be ignored.

              This is meant for use MPI implementations that require their own launcher.  This launches  a  step
              with  access  to  all  the  resources and which will later spawn any number of user processes with
              access to all these resources.

              The resource usage within this special step will still be accounted for if the accounting  plugins
              are enabled. This special step can be overlapped with any other step.

              <b>NOTE</b>: This option is not intended to be used directly.

       <b>--extra</b>=&lt;<u>string</u>&gt;
              An  arbitrary  string  enclosed  in  single  or  double  quotes  if  using  spaces or some special
              characters.

              If <b>SchedulerParameters=extra_constraints</b> is enabled, this string is used for node filtering  based
              on the <u>Extra</u> field in each node.

       <b>-B</b>, <b>--extra-node-info</b>=&lt;<u>sockets</u>&gt;[:<u>cores</u>[:<u>threads</u>]]
              Restrict  node  selection to nodes with at least the specified number of sockets, cores per socket
              and/or threads per core.
              <b>NOTE</b>: These options do not  specify  the  resource  allocation  size.   Each  value  specified  is
              considered  a minimum.  An asterisk (*) can be used as a placeholder indicating that all available
              resources of that type are to be utilized. Values can also be specified as min-max. The individual
              levels can also be specified in separate options if desired:

                  <b>--sockets-per-node</b>=&lt;<u>sockets</u>&gt;
                  <b>--cores-per-socket</b>=&lt;<u>cores</u>&gt;
                  <b>--threads-per-core</b>=&lt;<u>threads</u>&gt;
              If task/affinity plugin is enabled, then specifying an allocation  in  this  manner  also  sets  a
              default  <b>--cpu-bind</b>  option  of  <u>threads</u>  if  the <b>-B</b> option specifies a thread count, otherwise an
              option of <u>cores</u> if a core count is specified, otherwise an option of <u>sockets</u>.   If  SelectType  is
              configured to select/cons_tres, it must have a parameter of CR_Core, CR_Core_Memory, CR_Socket, or
              CR_Socket_Memory  for  this  option  to  be honored.  If not specified, the scontrol show job will
              display 'ReqS:C:T=*:*:*'. This option applies to job allocations.
              <b>NOTE</b>: This option is mutually exclusive with <b>--hint</b>, <b>--threads-per-core</b> and <b>--ntasks-per-core</b>.
              <b>NOTE</b>: If the number of sockets, cores and threads were all specified,  the  number  of  nodes  was
              specified  (as  a  fixed number, not a range) and the number of tasks was NOT specified, srun will
              implicitly calculate the number of tasks as one task per thread.

       <b>--gpu-bind</b>=[verbose,]&lt;<u>type</u>&gt;
              Equivalent  to  --tres-bind=gres/gpu:[verbose,]&lt;<u>type</u>&gt;  See  <b>--tres-bind</b>  for   all   options   and
              documentation.

       <b>--gpu-freq</b>=[&lt;<u>type</u>]=<u>value</u>&gt;[,&lt;<u>type</u>=<u>value</u>&gt;][,verbose]
              Request that GPUs allocated to the job are configured with specific frequency values.  This option
              can  be  used  to  independently  configure  the GPU and its memory frequencies.  After the job is
              completed, the frequencies of all affected GPUs will be reset to the highest possible values.   In
              some  cases, system power caps may override the requested values.  The field <u>type</u> can be "memory".
              If <u>type</u> is not specified, the GPU frequency is implied.  The <u>value</u>  field  can  either  be  "low",
              "medium",  "high", "highm1" or a numeric value in megahertz (MHz).  If the specified numeric value
              is not possible, a value as close as possible will be  used.  See  below  for  definition  of  the
              values.   The  <u>verbose</u>  option causes current GPU frequency information to be logged.  Examples of
              use include "--gpu-freq=medium,memory=high" and "--gpu-freq=450".

              Supported <u>value</u> definitions:

              <b>low</b>       the lowest available frequency.

              <b>medium</b>    attempts to set a frequency in the middle of the available range.

              <b>high</b>      the highest available frequency.

              <b>highm1</b>    (high minus one) will select the next highest available frequency.

       <b>-G</b>, <b>--gpus</b>=[<u>type</u>:]&lt;<u>number</u>&gt;
              Specify the total number of GPUs required for the job.  An optional GPU type specification can  be
              supplied.  See also the <b>--gpus-per-node</b>, <b>--gpus-per-socket</b> and <b>--gpus-per-task</b> options.
              <b>NOTE</b>: The allocation has to contain at least one GPU per node, or one of each GPU type per node if
              types are used. Use heterogeneous jobs if different nodes need different GPU types.

       <b>--gpus-per-node</b>=[<u>type</u>:]&lt;<u>number</u>&gt;
              Specify  the  number  of  GPUs  required  for  the job on each node included in the job's resource
              allocation.    An   optional   GPU   type   specification   can   be   supplied.    For    example
              "--gpus-per-node=volta:3".   Multiple  options  can  be  requested  in a comma separated list, for
              example:  "--gpus-per-node=volta:3,kepler:1".   See  also  the   <b>--gpus</b>,   <b>--gpus-per-socket</b>   and
              <b>--gpus-per-task</b> options.

       <b>--gpus-per-socket</b>=[<u>type</u>:]&lt;<u>number</u>&gt;
              Specify  the  number  of  GPUs  required for the job on each socket included in the job's resource
              allocation.    An   optional   GPU   type   specification   can   be   supplied.    For    example
              "--gpus-per-socket=volta:3".   Multiple  options  can  be requested in a comma separated list, for
              example: "--gpus-per-socket=volta:3,kepler:1".  Requires job to specify a sockets per node count (
              --sockets-per-node).  See also the <b>--gpus</b>,  <b>--gpus-per-node</b>  and  <b>--gpus-per-task</b>  options.   This
              option applies to job allocations.

       <b>--gpus-per-task</b>=[<u>type</u>:]&lt;<u>number</u>&gt;
              Specify  the  number of GPUs required for the job on each task to be spawned in the job's resource
              allocation.    An   optional   GPU   type   specification   can   be   supplied.    For    example
              "--gpus-per-task=volta:1".  Multiple  options  can  be  requested  in  a comma separated list, for
              example:  "--gpus-per-task=volta:3,kepler:1".  See  also   the   <b>--gpus</b>,   <b>--gpus-per-socket</b>   and
              <b>--gpus-per-node</b>  options.   This  option  requires  an  explicit  task count, e.g. -n, --ntasks or
              "--gpus=X --gpus-per-task=Y" rather than an ambiguous range  of  nodes  with  -N,  --nodes.   This
              option   will  implicitly  set  --tres-bind=gres/gpu:per_task:&lt;gpus_per_task&gt;,  but  that  can  be
              overridden with an explicit --tres-bind=gres/gpu specification.

       <b>--gres</b>=&lt;<u>list</u>&gt;
              Specifies a comma-delimited list of generic consumable resources.  The format for  each  entry  in
              the  list  is "name[[:type]:count]".  The <u>name</u> is the type of consumable resource (e.g. gpu).  The
              <u>type</u> is an optional classification for the resource (e.g. a100).  The <u>count</u> is the number of those
              resources with a default value of 1.  The count can have a suffix  of  "k"  or  "K"  (multiple  of
              1024),  "m"  or "M" (multiple of 1024 x 1024), "g" or "G" (multiple of 1024 x 1024 x 1024), "t" or
              "T" (multiple of 1024 x 1024 x 1024 x 1024), "p" or "P" (multiple of 1024 x 1024 x 1024 x  1024  x
              1024).   The specified resources will be allocated to the job on each node.  The available generic
              consumable resources is configurable by the system administrator.  A  list  of  available  generic
              consumable  resources  will be printed and the command will exit if the option argument is "help".
              Examples of use include "--gres=gpu:2",  "--gres=gpu:kepler:2",  and  "--gres=help".   <b>NOTE</b>:  This
              option applies to job and step allocations. By default, a job step is allocated all of the generic
              resources  that  have  been  requested by the job, except those implicitly requested when a job is
              exclusive.  To change the behavior so that each  job  step  is  allocated  no  generic  resources,
              explicitly  set  the  value  of  --gres  to  specify  zero counts for each generic resource OR set
              "--gres=none" OR set the SLURM_STEP_GRES environment variable to "none".

       <b>--gres-flags</b>=&lt;<u>type</u>&gt;
              Specify generic resource task binding options.

              <b>allow-task-sharing</b>
                     Allow tasks access to each GPU within the job's allocation that is on the same node as  the
                     task. This is useful when using --gpu-bind or --tres-bind=gres/gpu to bind GPUs to specific
                     tasks, but GPU communication between tasks is also desired.
                     <b>NOTE</b>: This option is specific to srun.

              <b>multiple-tasks-per-sharing</b>
                     Negate   <b>one-task-per-sharing</b>.   This   is   useful   if   it   is   set   by   default  in
                     <b>SelectTypeParameters</b>.

              <b>disable-binding</b>
                     Negate <b>enforce-binding</b>. This is useful if it is set by default in <b>SelectTypeParameters</b>.

              <b>enforce-binding</b>
                     The only CPUs available to the job will be those bound to the selected GRES (i.e. the  CPUs
                     identified  in  the  gres.conf  file  will be strictly enforced). This option may result in
                     delayed initiation of a job.  For example a job requiring two GPUs  and  one  CPU  will  be
                     delayed  until  both  GPUs on a single socket are available rather than using GPUs bound to
                     separate sockets, however, the application performance may  be  improved  due  to  improved
                     communication  speed.   Requires  the  node  to be configured with more than one socket and
                     resource filtering will be performed on a per-socket basis.
                     <b>NOTE</b>: This option can be set by default in <b>SelectTypeParameters</b>.
                     <b>NOTE</b>: This option is specific to <b>SelectType=cons_tres</b> for job allocations.

              <b>one-task-per-sharing</b>
                     Do not allow different tasks in to be allocated shared gres from the same sharing gres.
                     <b>NOTE</b>: This flag is only enforced if shared gres are requested with --tres-per-task.
                     <b>NOTE</b>:      This       option       can       be       set       by       default       with
                     <b>SelectTypeParameters=ONE_TASK_PER_SHARING_GRES</b>.
                     <b>NOTE</b>: This option is specific to <b>SelectTypeParameters=MULTIPLE_SHARING_GRES_PJ</b>

       <b>-h</b>, <b>--help</b>
              Display help information and exit.

       <b>--het-group</b>=&lt;<u>expr</u>&gt;
              Identify  each  component  in  a  heterogeneous  job allocation for which a step is to be created.
              Applies only to srun commands issued inside a salloc allocation or sbatch script.  &lt;<u>expr</u>&gt; is a set
              of integers corresponding to one or more options offsets on the salloc  or  sbatch  command  line.
              Examples:   "--het-group=2",   "--het-group=0,4",   "--het-group=1,3-5".   The  default  value  is
              --het-group=0.

       <b>--hint</b>=&lt;<u>type</u>&gt;
              Bind tasks according to application hints.
              <b>NOTE</b>: This option implies specific values for certain related options, which prevents its use with
              any user-specified  values  for  <b>--ntasks-per-core</b>,  <b>--threads-per-core</b>,  <b>--cpu-bind</b>  (other  than
              <b>--cpu-bind=verbose</b>)  or  <b>-B</b>.   These  conflicting  options  will override <b>--hint</b> when specified as
              command line arguments. If a conflicting option is specified as an environment variable, --hint as
              a command line argument will take precedence.

              <b>compute_bound</b>
                     Select settings for compute bound applications: use all cores in each  socket,  one  thread
                     per core.

              <b>memory_bound</b>
                     Select settings for memory bound applications: use only one core in each socket, one thread
                     per core.

              <b>multithread</b>
                     Use  extra  threads  with in-core multi-threading which can benefit communication intensive
                     applications.  Only supported with the task/affinity plugin.

              <b>nomultithread</b>
                     Don't use extra threads with in-core multi-threading; restricts tasks  to  one  thread  per
                     core.  Only supported with the task/affinity plugin.

              <b>help</b>   show this help message

              This option applies to job allocations.

       <b>-H,</b> <b>--hold</b>
              Specify  the  job  is  to  be submitted in a held state (priority of zero).  A held job can now be
              released using scontrol to reset its priority (e.g.  "<u>scontrol</u>  <u>release</u>  <u>&lt;job_id&gt;</u>").  This  option
              applies to job allocations.

       <b>-I</b>, <b>--immediate</b>[=&lt;<u>seconds</u>&gt;]
              exit  if  resources  are  not available within the time period specified.  If no argument is given
              (seconds defaults to 1), resources must be available immediately for the request  to  succeed.  If
              <b>defer</b>  is  configured  in  <b>SchedulerParameters</b>  and  seconds=1  the  allocation  request will fail
              immediately; <b>defer</b> conflicts and takes precedence over this option.  By  default,  <b>--immediate</b>  is
              off,  and the command will block until resources become available. Since this option's argument is
              optional, for proper parsing the single letter option must be followed immediately with the  value
              and  not  include a space between them. For example "-I60" and not "-I 60". This option applies to
              job and step allocations.

       <b>-i</b>, <b>--input</b>=&lt;<u>mode</u>&gt;
              Specify how stdin is to be redirected. By default, <b>srun</b> redirects stdin from the terminal  to  all
              tasks.  See <b>IO</b> <b>Redirection</b> below for more options.  For OS X, the poll() function does not support
              stdin, so input from a terminal is not possible. This option applies to job and step allocations.

       <b>-J</b>, <b>--job-name</b>=&lt;<u>jobname</u>&gt;
              Specify a name for the job. The specified name will appear along  with  the  job  id  number  when
              querying  running jobs on the system. The default is the supplied <b>executable</b> program's name. <b>NOTE</b>:
              This information may be written to the slurm_jobacct.log file. This file is space delimited so  if
              a  space is used in the <u>jobname</u> name it will cause problems in properly displaying the contents of
              the slurm_jobacct.log file when the <b>sacct</b> command is used. This option applies  to  job  and  step
              allocations.

       <b>--jobid</b>=&lt;<u>jobid</u>&gt;
              Initiate  a  job step under an already allocated job with job id <u>id</u>.  Using this option will cause
              <b>srun</b> to behave exactly as if the SLURM_JOB_ID environment variable was set. This option applies to
              step allocations.

       <b>-K</b>, <b>--kill-on-bad-exit</b>[=0|1]
              Controls whether or not to terminate a step if any task exits with a non-zero exit code.  If  this
              option  is  not specified, the default action will be based upon the Slurm configuration parameter
              of <b>KillOnBadExit</b>. If this option is specified, it will  take  precedence  over  <b>KillOnBadExit</b>.  An
              option  argument  of  zero  will  not  terminate  the job. A non-zero argument or no argument will
              terminate the job.  Note: This option takes precedence over the <b>-W</b>, <b>--wait</b> option to terminate the
              job immediately if a task exits with a non-zero  exit  code.   Since  this  option's  argument  is
              optional,  for proper parsing the single letter option must be followed immediately with the value
              and not include a space between them. For example "-K1" and not "-K 1".

       <b>-l</b>, <b>--label</b>
              Prepend task number to lines of stdout/err.  The <b>--label</b> option will prepend lines of output  with
              the remote task id. This option applies to step allocations.

       <b>-L</b>, <b>--licenses</b>=&lt;<u>license</u>&gt;[@<u>db</u>][:<u>count</u>][,<u>license</u>[@<u>db</u>][:<u>count</u>]...]
              Specification of licenses (or other resources available on all nodes of the cluster) which must be
              allocated  to  this job.  License names can be followed by a colon and count (the default count is
              one).  Multiple license names should  be  comma  separated  (e.g.   "--licenses=foo:4,bar").  This
              option applies to job allocations.

              <b>NOTE</b>: When submitting heterogeneous jobs, license requests may only be made on the first component
              job.  For example "srun -L ansys:2 : myexecutable".

       <b>--mail-type</b>=&lt;<u>type</u>&gt;
              Notify  user  by  email  when  certain event types occur.  Valid <u>type</u> values are NONE, BEGIN, END,
              FAIL, REQUEUE, ALL (equivalent to BEGIN,  END,  FAIL,  INVALID_DEPEND,  REQUEUE,  and  STAGE_OUT),
              INVALID_DEPEND  (dependency  never  satisfied),  STAGE_OUT  (burst  buffer  stage out and teardown
              completed), TIME_LIMIT, TIME_LIMIT_90 (reached 90 percent of time limit),  TIME_LIMIT_80  (reached
              80  percent  of  time limit), and TIME_LIMIT_50 (reached 50 percent of time limit).  Multiple <u>type</u>
              values may be specified in a comma separated list.  NONE will suppress  all  event  notifications,
              ignoring  any other values specified.  By default no email notifications are sent.  The user to be
              notified is indicated with <b>--mail-user</b>. This option applies to job allocations.

       <b>--mail-user</b>=&lt;<u>user</u>&gt;
              User to receive email notification of state changes as defined by <b>--mail-type</b>. This may be a  full
              email  address  or a username. If a username is specified, the value from <b>MailDomain</b> in slurm.conf
              will be appended to create an email address.  The default  value  is  the  submitting  user.  This
              option applies to job allocations.

       <b>--mcs-label</b>=&lt;<u>mcs</u>&gt;
              Used only when the mcs/group plugin is enabled.  This parameter is a group among the groups of the
              user.   Default  value is calculated by the Plugin mcs if it's enabled. This option applies to job
              allocations.

       <b>--mem</b>=&lt;<u>size</u>&gt;[<u>units</u>]
              Specify the real memory required per node.  Default units are megabytes.  Different units  can  be
              specified  using  the  suffix  [K|M|G|T].  Default value is <b>DefMemPerNode</b> and the maximum value is
              <b>MaxMemPerNode</b>. If configured, both of parameters can  be  seen  using  the  <b>scontrol</b>  <b>show</b>  <b>config</b>
              command.   This  parameter  would  generally  be  used  if  whole  nodes  are  allocated  to  jobs
              (<b>SelectType=select/linear</b>).  Specifying a memory limit of zero for a job step  will  restrict  the
              job  step  to  the  amount  of memory allocated to the job, but not remove any of the job's memory
              allocation from being available to other job steps.  Also  see  <b>--mem-per-cpu</b>  and  <b>--mem-per-gpu</b>.
              The <b>--mem</b>, <b>--mem-per-cpu</b> and <b>--mem-per-gpu</b> options are mutually exclusive. If <b>--mem</b>, <b>--mem-per-cpu</b>
              or  <b>--mem-per-gpu</b> are specified as command line arguments, then they will take precedence over the
              environment (potentially inherited from <b>salloc</b> or <b>sbatch</b>).

              <b>NOTE</b>: A memory size specification of zero is treated as a special case and grants the  job  access
              to all of the memory on each node for newly submitted jobs and all available job memory to new job
              steps.

              <b>NOTE</b>:  Memory  requests  will  not  be  strictly  enforced  unless  Slurm  is configured to use an
              enforcement mechanism. See <b>ConstrainRAMSpace</b> in the <b><a href="../man5/cgroup.conf.5.html">cgroup.conf</a></b>(5) man page and <b>OverMemoryKill</b>  in
              the <b><a href="../man5/slurm.conf.5.html">slurm.conf</a></b>(5) man page for more details.

              This option applies to job and step allocations.

       <b>--mem-bind</b>=[{quiet|verbose},]&lt;<u>type</u>&gt;
              Bind  tasks  to  memory.  Used  only  when the task/affinity plugin is enabled and the NUMA memory
              functions are available.  <b>Note</b> <b>that</b> <b>the</b> <b>resolution</b> <b>of</b> <b>CPU</b> <b>and</b> <b>memory</b> <b>binding</b> <b>may</b>  <b>differ</b>  <b>on</b>  <b>some</b>
              <b>architectures.</b>  For  example,  CPU  binding  may  be  performed at the level of the cores within a
              processor while memory binding will be performed at the level of nodes, where  the  definition  of
              "nodes"  may  differ  from  system to system.  By default no memory binding is performed; any task
              using any CPU can use any memory. This option is typically used to ensure that each task is  bound
              to the memory closest to its assigned CPU. <b>The</b> <b>use</b> <b>of</b> <b>any</b> <b>type</b> <b>other</b> <b>than</b> <b>"none"</b> <b>or</b> <b>"local"</b> <b>is</b> <b>not</b>
              <b>recommended.</b>   If  you  want  greater  control,  try  running  a simple test code with the options
              "--cpu-bind=verbose,none --mem-bind=verbose,none" to determine the specific configuration.

              <b>NOTE</b>: To have Slurm always report on the selected memory binding for all commands  executed  in  a
              shell,  you  can  enable  verbose mode by setting the SLURM_MEM_BIND environment variable value to
              "verbose".

              The following informational environment variables are set when <b>--mem-bind</b> is in use:

                   SLURM_MEM_BIND_LIST
                   SLURM_MEM_BIND_PREFER
                   SLURM_MEM_BIND_SORT
                   SLURM_MEM_BIND_TYPE
                   SLURM_MEM_BIND_VERBOSE

              See the  <b>ENVIRONMENT</b>  <b>VARIABLES</b>  section  for  a  more  detailed  description  of  the  individual
              SLURM_MEM_BIND* variables.

              Supported options include:

              <b>help</b>   show this help message

              <b>local</b>  Use memory local to the processor in use

              <b>map_mem:&lt;list&gt;</b>
                     Bind   by  setting  memory  masks  on  tasks  (or  ranks)  as  specified  where  &lt;list&gt;  is
                     &lt;numa_id_for_task_0&gt;,&lt;numa_id_for_task_1&gt;,...  The mapping is  specified  for  a  node  and
                     identical  mapping  is  applied to the tasks on every node (i.e. the lowest task ID on each
                     node is mapped to the first ID specified in the list, etc.).  NUMA IDs are  interpreted  as
                     decimal  values  unless  they  are  preceded  with  '0x'  in which case they interpreted as
                     hexadecimal values.  If the number of tasks (or ranks) exceeds the number  of  elements  in
                     this list, elements in the list will be reused as needed starting from the beginning of the
                     list.   To  simplify  support  for  large  task  counts, the lists may follow a map with an
                     asterisk and repetition  count.   For  example  "map_mem:0x0f*4,0xf0*4".   For  predictable
                     binding results, all CPUs for each node in the job should be allocated to the job.

              <b>mask_mem:&lt;list&gt;</b>
                     Bind   by  setting  memory  masks  on  tasks  (or  ranks)  as  specified  where  &lt;list&gt;  is
                     &lt;numa_mask_for_task_0&gt;,&lt;numa_mask_for_task_1&gt;,...  The mapping is specified for a node  and
                     identical  mapping  is  applied to the tasks on every node (i.e. the lowest task ID on each
                     node is mapped to the first mask specified in the  list,  etc.).   NUMA  masks  are  <b>always</b>
                     interpreted  as  hexadecimal  values.  Note that masks must be preceded with a '0x' if they
                     don't begin with [0-9] so they are seen as numerical values.  If the number  of  tasks  (or
                     ranks)  exceeds the number of elements in this list, elements in the list will be reused as
                     needed starting from the beginning of the list.  To simplify support for large task counts,
                     the lists  may  follow  a  mask  with  an  asterisk  and  repetition  count.   For  example
                     "mask_mem:0*4,1*4".   For  predictable  binding  results, all CPUs for each node in the job
                     should be allocated to the job.

              <b>no[ne]</b> don't bind tasks to memory (default)

              <b>nosort</b> avoid sorting free cache  pages  (default,  LaunchParameters  configuration  parameter  can
                     override this default)

              <b>p[refer]</b>
                     Prefer use of first specified NUMA node, but permit
                      use of other available NUMA nodes.

              <b>q[uiet]</b>
                     quietly bind before task runs (default)

              <b>rank</b>   bind by task rank (not recommended)

              <b>sort</b>   sort free cache pages (run zonesort on Intel KNL nodes)

              <b>v[erbose]</b>
                     verbosely report binding before task runs

              This option applies to job and step allocations.

       <b>--mem-per-cpu</b>=&lt;<u>size</u>&gt;[<u>units</u>]
              Minimum  memory  required per usable allocated CPU.  Default units are megabytes.  Different units
              can be specified using the suffix [K|M|G|T].  The default value is <b>DefMemPerCPU</b>  and  the  maximum
              value  is <b>MaxMemPerCPU</b> (see exception below). If configured, both parameters can be seen using the
              <b>scontrol</b> <b>show</b> <b>config</b> command.  Note that if the job's <b>--mem-per-cpu</b> value exceeds  the  configured
              <b>MaxMemPerCPU</b>, then the user's limit will be treated as a memory limit per task; <b>--mem-per-cpu</b> will
              be  reduced  to  a value no larger than <b>MaxMemPerCPU</b>; <b>--cpus-per-task</b> will be set and the value of
              <b>--cpus-per-task</b> multiplied by the new <b>--mem-per-cpu</b> value will equal  the  original  <b>--mem-per-cpu</b>
              value  specified by the user.  This parameter would generally be used if individual processors are
              allocated to jobs (<b>SelectType=select/cons_tres</b>).  If resources are allocated by core,  socket,  or
              whole  nodes, then the number of CPUs allocated to a job may be higher than the task count and the
              value of <b>--mem-per-cpu</b> should be adjusted accordingly.  Specifying a memory limit of  zero  for  a
              job  step  will restrict the job step to the amount of memory allocated to the job, but not remove
              any of the job's memory allocation from being available to other job steps.  Also  see  <b>--mem</b>  and
              <b>--mem-per-gpu</b>.  The <b>--mem</b>, <b>--mem-per-cpu</b> and <b>--mem-per-gpu</b> options are mutually exclusive.

              <b>NOTE</b>:  If  the  final  amount  of memory requested by a job can't be satisfied by any of the nodes
              configured in the partition, the job will be rejected.  This could happen if <b>--mem-per-cpu</b> is used
              with the <b>--exclusive</b> option for a job allocation and <b>--mem-per-cpu</b> times the number of CPUs  on  a
              node is greater than the total memory of that node.

              <b>NOTE</b>: This applies to <b>usable</b> allocated CPUs in a job allocation.  This is important when more than
              one  thread  per core is configured.  If a job requests --threads-per-core with fewer threads on a
              core than exist on the core (or --hint=nomultithread which implies --threads-per-core=1), the  job
              will  be  unable  to use those extra threads on the core and those threads will not be included in
              the memory per CPU calculation. But if the job has access  to  all  threads  on  the  core,  those
              threads  will  be  included  in  the memory per CPU calculation even if the job did not explicitly
              request those threads.

              In the following examples, each core has two threads.

              In this first example, two tasks can run  on  separate  hyperthreads  in  the  same  core  because
              --threads-per-core is not used. The third task uses both threads of the second core. The allocated
              memory per cpu includes all threads:

              <b>$</b> <b>salloc</b> <b>-n3</b> <b>--mem-per-cpu=100</b>
              <b>salloc:</b> <b>Granted</b> <b>job</b> <b>allocation</b> <b>17199</b>
              <b>$</b> <b>sacct</b> <b>-j</b> <b>$SLURM_JOB_ID</b> <b>-X</b> <b>-o</b> <b>jobid%7,reqtres%35,alloctres%35</b>
                <b>JobID</b>                             <b>ReqTRES</b>                           <b>AllocTRES</b>
              <b>-------</b> <b>-----------------------------------</b> <b>-----------------------------------</b>
                <b>17199</b>     <b>billing=3,cpu=3,mem=300M,node=1</b>     <b>billing=4,cpu=4,mem=400M,node=1</b>

              In this second example, because of --threads-per-core=1, each task is allocated an entire core but
              is  only  able  to  use  one  thread  per  core. Allocated CPUs includes all threads on each core.
              However, allocated memory per cpu includes only the usable thread in each core.

              <b>$</b> <b>salloc</b> <b>-n3</b> <b>--mem-per-cpu=100</b> <b>--threads-per-core=1</b>
              <b>salloc:</b> <b>Granted</b> <b>job</b> <b>allocation</b> <b>17200</b>
              <b>$</b> <b>sacct</b> <b>-j</b> <b>$SLURM_JOB_ID</b> <b>-X</b> <b>-o</b> <b>jobid%7,reqtres%35,alloctres%35</b>
                <b>JobID</b>                             <b>ReqTRES</b>                           <b>AllocTRES</b>
              <b>-------</b> <b>-----------------------------------</b> <b>-----------------------------------</b>
                <b>17200</b>     <b>billing=3,cpu=3,mem=300M,node=1</b>     <b>billing=6,cpu=6,mem=300M,node=1</b>

       <b>--mem-per-gpu</b>=&lt;<u>size</u>&gt;[<u>units</u>]
              Minimum memory required per allocated GPU.  Default units are megabytes.  Different units  can  be
              specified  using  the  suffix [K|M|G|T].  Default value is <b>DefMemPerGPU</b> and is available on both a
              global and per partition basis.  If configured, the parameters can be seen using the <b>scontrol</b> <b>show</b>
              <b>config</b> and <b>scontrol</b> <b>show</b> <b>partition</b> commands.   Also  see  <b>--mem</b>.   The  <b>--mem</b>,  <b>--mem-per-cpu</b>  and
              <b>--mem-per-gpu</b> options are mutually exclusive.

       <b>--mincpus</b>=&lt;<u>n</u>&gt;
              Specify  a  minimum  number  of  logical  cpus/processors  per  node.  This  option applies to job
              allocations.

       <b>--mpi</b>=&lt;<u>mpi_type</u>&gt;
              Identify the type of MPI to be used. May result in unique initiation procedures.

              <b>cray_shasta</b>
                     To enable Cray PMI support. This is  for  applications  built  with  the  Cray  Programming
                     Environment. The PMI Control Port can be specified with the <b>--resv-ports</b> option or with the
                     <b>MpiParams</b>=<b>ports</b>=&lt;<u>port</u>  <u>range</u>&gt;  parameter  in  your  slurm.conf.   This plugin does not have
                     support for heterogeneous jobs.  Support for cray_shasta is included by default.

              <b>list</b>   Lists available mpi types to choose from.

              <b>pmi2</b>   To enable PMI2 support. The PMI2 support in Slurm works  only  if  the  MPI  implementation
                     supports  it,  in other words if the MPI has the PMI2 interface implemented. The --mpi=pmi2
                     will load the library lib/slurm/mpi_pmi2.so which provides the  server  side  functionality
                     but the client side must implement PMI2_Init() and the other interface calls.

              <b>pmix</b>   To  enable  PMIx support (https://pmix.github.io). The PMIx support in Slurm can be used to
                     launch parallel applications (e.g. MPI) if it supports PMIx, PMI2 or PMI1.  Slurm  must  be
                     configured  with  pmix  support by passing "--with-pmix=&lt;PMIx installation path&gt;" option to
                     its "./configure" script.

                     At the time of writing PMIx is supported in Open MPI starting from version 2.0.  PMIx  also
                     supports  backward  compatibility  with PMI1 and PMI2 and can be used if MPI was configured
                     with PMI2/PMI1 support pointing to the PMIx library ("libpmix").  If MPI supports PMI1/PMI2
                     but doesn't provide the way to point to a  specific  implementation,  a  hack'ish  solution
                     leveraging LD_PRELOAD can be used to force "libpmix" usage.

              <b>none</b>   No special MPI processing. This is the default and works with many other versions of MPI.

              This option applies to step allocations.

       <b>--msg-timeout</b>=&lt;<u>seconds</u>&gt;
              Modify  the  job  launch  message  timeout.   The  default  value  is  <b>MessageTimeout</b> in the Slurm
              configuration file slurm.conf.  Changes to this are typically not recommended, but could be useful
              to diagnose problems.  This option applies to job allocations.

       <b>--multi-prog</b>
              Run a job with different programs and different  arguments  for  each  task.  In  this  case,  the
              executable  program  specified  is  actually  a  configuration  file specifying the executable and
              arguments for each task. See <b>MULTIPLE</b> <b>PROGRAM</b> <b>CONFIGURATION</b> below for details on the configuration
              file contents. This option applies to step allocations.

       <b>--network</b>=&lt;<u>type</u>&gt;
              Specify information pertaining to the switch or network.  The interpretation  of  <u>type</u>  is  system
              dependent.   This option is supported when running Slurm on a Cray natively. It is used to request
              using Network Performance Counters.  Only one value per request is valid.  All  options  are  case
              in-sensitive.  In this configuration supported values include:

              <b>system</b>
                    Use the system-wide network performance counters. Only nodes requested will be marked in use
                    for  the job allocation. If the job does not fill up the entire system the rest of the nodes
                    are not able to be used by other jobs  using  NPC,  if  idle  their  state  will  appear  as
                    PerfCnts. These nodes are still available for other jobs not using NPC.

              <b>blade</b> Use  the  blade network performance counters. Only nodes requested will be marked in use for
                    the job allocation. If the job does not fill up the entire blade(s)  allocated  to  the  job
                    those  blade(s)  are  not  able to be used by other jobs using NPC, if idle their state will
                    appear as PerfCnts. These nodes are still available for other jobs not using NPC.

              In all cases the job allocation request <b>must</b> <b>specify</b> <b>the</b> <b>--exclusive</b> <b>option</b> and  the  step  cannot
              specify the <b>--overlap</b> option. Otherwise the request will be denied.

              Also  with  any  of these options steps are not allowed to share blades, so resources would remain
              idle inside an allocation if the step running on a blade does not take up all  the  nodes  on  the
              blade.

              The  <b>network</b>  option  is  also available on systems with HPE Slingshot networks. It can be used to
              request a job VNI (to be used for communication between job steps in a job). It also can  be  used
              to  override  the  default  network  resources  allocated for the job step. Multiple values may be
              specified in a comma-separated list.

              <b>tcs</b>=&lt;<u>class1</u>&gt;[:&lt;<u>class2</u>&gt;]...
                    Set of traffic classes  to  configure  for  applications.   Supported  traffic  classes  are
                    DEDICATED_ACCESS,  LOW_LATENCY,  BULK_DATA, and BEST_EFFORT. The traffic classes may also be
                    specified as TC_DEDICATED_ACCESS, TC_LOW_LATENCY, TC_BULK_DATA,  and  TC_BEST_EFFORT.   This
                    option applies to the job allocation, but not to step allocations.

              <b>no_vni</b>
                    Don't allocate any VNIs for this job (even if multi-node).

              <b>job_vni</b>
                    Allocate a job VNI for this job.

              <b>single_node_vni</b>
                    Allocate a job VNI for this job, even if it is a single-node job.

              <b>adjust_limits</b>
                    If  set,  slurmd will set an upper bound on network resource reservations by taking the per-
                    NIC maximum resource quantity and subtracting the reserved  or  used  values  (whichever  is
                    higher) for any system network services; this is the default.

              <b>no_adjust_limits</b>
                    If set, slurmd will calculate network resource reservations based only upon the per-resource
                    configuration default and number of tasks in the application; it will not set an upper bound
                    on  those  reservation  requests  based on resource usage of already-existing system network
                    services.  Setting this will mean more application launches  could  fail  based  on  network
                    resource  exhaustion,  but if the application absolutely needs a certain amount of resources
                    to function, this option will ensure that.

              <b>disable_rdzv_get</b>
                    Disable rendezvous gets in  Slingshot  NICs,  which  can  improve  performance  for  certain
                    applications.

              <b>def_&lt;rsrc&gt;</b>=&lt;<u>val</u>&gt;
                    Per-CPU reserved allocation for this resource.

              <b>res_&lt;rsrc&gt;</b>=&lt;<u>val</u>&gt;
                    Per-node reserved allocation for this resource.  If set, overrides the per-CPU allocation.

              <b>max_&lt;rsrc&gt;</b>=&lt;<u>val</u>&gt;
                    Maximum per-node limit for this resource.

              <b>depth</b>=&lt;<u>depth</u>&gt;
                    Multiplier  for  per-CPU resource allocation.  Default is the number of reserved CPUs on the
                    node.

              The resources that may be requested are:

              <b>txqs</b>  Transmit command queues. The default is 2 per-CPU, maximum 1024 per-node.

              <b>tgqs</b>  Target command queues. The default is 1 per-CPU, maximum 512 per-node.

              <b>eqs</b>   Event queues. The default is 2 per-CPU, maximum 2047 per-node.

              <b>cts</b>   Counters. The default is 1 per-CPU, maximum 2047 per-node.

              <b>tles</b>  Trigger list entries. The default is 1 per-CPU, maximum 2048 per-node.

              <b>ptes</b>  Portable table entries. The default is 6 per-CPU, maximum 2048 per-node.

              <b>les</b>   List entries. The default is 16 per-CPU, maximum 16384 per-node.

              <b>acs</b>   Addressing contexts. The default is 4 per-CPU, maximum 1022 per-node.

              This option applies to job and step allocations.

       <b>--nice</b>[=<u>adjustment</u>]
              Run the job with an adjusted scheduling priority  within  Slurm.  With  no  adjustment  value  the
              scheduling  priority  is decreased by 100. A negative nice value increases the priority, otherwise
              decreases it. The adjustment range is +/- 2147483645. Only privileged users can specify a negative
              adjustment.

       <b>-Z</b>, <b>--no-allocate</b>
              Run the specified tasks on a set of nodes without creating  a  Slurm  "job"  in  the  Slurm  queue
              structure, bypassing the normal resource allocation step. The list of nodes must be specified with
              the  <b>-w</b>,  <b>--nodelist</b>  option. This is a privileged option only available for the users "SlurmUser"
              and "root". This option applies to job allocations.  If  user  namespaces  are  active,  then  the
              mapping  of  users  in  the namespace must match the same namespace as MUNGE. If not, then the job
              will be rejected by slurmd.

       <b>-k</b>, <b>--no-kill</b>[=off]
              Do not automatically terminate a job if one of the nodes it has been allocated fails. This  option
              applies   to   job   and   step  allocations.   The  job  will  assume  all  responsibilities  for
              fault-tolerance.  Tasks launched using this option will not be  considered  terminated  (e.g.  <b>-K</b>,
              <b>--kill-on-bad-exit</b>  and <b>-W</b>, <b>--wait</b> options will have no effect upon the job step).  The active job
              step (MPI job) will likely suffer a fatal error, but subsequent job  steps  may  be  run  if  this
              option is specified.

              Specify  an  optional  argument  of  "off"  disable  the  effect  of the <b>SLURM_NO_KILL</b> environment
              variable.

              The default action is to terminate the job upon node failure.

       <b>-F</b>, <b>--nodefile</b>=&lt;<u>node_file</u>&gt;
              Much like <b>--nodelist</b>, but the list is contained in a file of name <u>node</u> <u>file</u>. The node names of the
              list may also span multiple lines in the file. Duplicate node names in the file will  be  ignored.
              The order of the node names in the list is not important; the node names will be sorted by Slurm.

       <b>-w</b>, <b>--nodelist</b>={&lt;<u>node_name_list</u>&gt;|&lt;<u>filename</u>&gt;}
              Request a specific list of hosts.  The job will contain <u>all</u> of these hosts and possibly additional
              hosts  as needed to satisfy resource requirements.  The list may be specified as a comma-separated
              list of hosts, a range of hosts (host[1-5,7,...] for example), or a filename.  The host list  will
              be  assumed  to  be  a  filename if it contains a "/" character.  If you specify a minimum node or
              processor count larger than can be satisfied by the supplied host list, additional resources  will
              be  allocated  on  other  nodes  as  needed.  Rather than repeating a host name multiple times, an
              asterisk and a repetition count may be appended to a host  name.  For  example  "host1,host1"  and
              "host1*2"  are  equivalent.  If the number of tasks is given and a list of requested nodes is also
              given, the number of nodes used from that list will be reduced to match  that  of  the  number  of
              tasks  if the number of nodes in the list is greater than the number of tasks. This option applies
              to job and step allocations.

       <b>-N</b>, <b>--nodes</b>=&lt;<u>minnodes</u>&gt;[-<u>maxnodes</u>]|&lt;<u>size_string</u>&gt;
              Request that a minimum of <u>minnodes</u> nodes be allocated to this job.  A maximum node count may  also
              be specified with <u>maxnodes</u>.  If only one number is specified, this is used as both the minimum and
              maximum   node  count.  Node  count  can  be  also  specified  as  size_string.   The  size_string
              specification identifies what nodes values should be used.  Multiple values may be specified using
              a comma separated list or with a step function by suffix containing a colon and number values with
              a "-"  separator.   For  example,  "--nodes=1-15:4"  is  equivalent  to  "--nodes=1,5,9,13".   The
              partition's  node  limits  supersede  those of the job.  If a job's node limits are outside of the
              range permitted for its associated partition, the job will be  left  in  a  PENDING  state.   This
              permits  possible  execution  at a later time, when the partition limit is changed.  If a job node
              limit exceeds the number of nodes configured in the partition, the job  will  be  rejected.   Note
              that  the  environment variable <b>SLURM_JOB_NUM_NODES</b> (and <b>SLURM_NNODES</b> for backwards compatibility)
              will be set to the count of nodes actually allocated to the job.  See  the  <b>ENVIRONMENT</b>  <b>VARIABLES</b>
              section  for  more information. If <b>-N</b> is not specified, the default behavior is to allocate enough
              nodes to satisfy the requested resources as expressed by per-job specification options,  e.g.  <b>-n</b>,
              <b>-c</b> and <b>--gpus</b>.  The job will be allocated as many nodes as possible within the range specified and
              without  delaying  the  initiation  of  the  job.  If the number of tasks is given and a number of
              requested nodes is also given, the number of nodes used from that request will be reduced to match
              that of the number of tasks if the number of nodes in the request is greater than  the  number  of
              tasks.   The  node  count  specification  may  include a numeric value followed by a suffix of "k"
              (multiplies numeric value by 1,024) or "m" (multiplies numeric value by  1,048,576).  This  option
              applies to job and step allocations.

              <b>NOTE</b>: This option cannot be used in with arbitrary distribution.

       <b>-n</b>, <b>--ntasks</b>=&lt;<u>number</u>&gt;
              Specify  the  number  of tasks to run. Request that <b>srun</b> allocate resources for <u>ntasks</u> tasks.  The
              default is one task per node, but note that the <b>--cpus-per-task</b> option will change  this  default.
              This option applies to job and step allocations.

       <b>--ntasks-per-core</b>=&lt;<u>ntasks</u>&gt;
              Request  the  maximum  <u>ntasks</u>  be  invoked  on  each  core.   This  option applies to job and step
              allocations.  Meant to be used with the <b>--ntasks</b> option.  Related to <b>--ntasks-per-node</b>  except  at
              the core level instead of the node level. If set to 1, it will imply <b>--cpu-bind=cores</b>.  Otherwise,
              if set to a value greater than 1, it will imply <b>--cpu-bind=threads</b>. Automatic binding behavior can
              be  avoided  by  also  specifying  <b>--cpu-bind=none</b>.   Slurm  may  allocate more cpus than what was
              requested in order to respect this option.
              <b>NOTE</b>: This option is not supported when using <u>SelectType=select/linear</u>.  This  value  can  not  be
              greater than <b>--threads-per-core</b>.

       <b>--ntasks-per-gpu</b>=&lt;<u>ntasks</u>&gt;
              Request  that  there are <u>ntasks</u> tasks invoked for every GPU.  This option can work in two ways: 1)
              either specify <b>--ntasks</b> in  addition,  in  which  case  a  type-less  GPU  specification  will  be
              automatically  determined  to  satisfy  <b>--ntasks-per-gpu</b>,  or 2) specify the GPUs wanted (e.g. via
              <b>--gpus</b> or <b>--gres</b>) without specifying <b>--ntasks</b>, and the total  task  count  will  be  automatically
              determined.   The  number of CPUs needed will be automatically increased if necessary to allow for
              any calculated task count.  This option will implicitly set  <b>--tres-bind=gres/gpu:single:&lt;ntasks&gt;</b>,
              but  that  can  be overridden with an explicit <b>--tres-bind=gres/gpu</b> specification.  This option is
              not compatible with a node range (i.e. -N&lt;<u>minnodes</u>-<u>maxnodes</u>&gt;).  This option is not compatible with
              <b>--gpus-per-task</b>, <b>--gpus-per-socket</b>, or <b>--ntasks-per-node</b>.  This option  is  not  supported  unless
              <u>SelectType=cons_tres</u> is configured (either directly or indirectly on Cray systems).

       <b>--ntasks-per-node</b>=&lt;<u>ntasks</u>&gt;
              Request  that  <u>ntasks</u>  be  invoked  on  each node.  If used with the <b>--ntasks</b> option, the <b>--ntasks</b>
              option will take precedence and the <b>--ntasks-per-node</b> will be treated as a <u>maximum</u> count of  tasks
              per  node.   Meant  to be used with the <b>--nodes</b> option.  This is related to <b>--cpus-per-task</b>=<u>ncpus</u>,
              but does not require knowledge of the actual number of cpus on each node. In  some  cases,  it  is
              more  convenient  to be able to request that no more than a specific number of tasks be invoked on
              each node. Examples of this include  submitting  a  hybrid  MPI/OpenMP  app  where  only  one  MPI
              "task/rank"  should  be  assigned to each node while allowing the OpenMP portion to utilize all of
              the parallelism present in the node, or submitting a single setup/cleanup/monitoring job  to  each
              node  of  a pre-existing allocation as one step in a larger job script. This option applies to job
              allocations.

       <b>--ntasks-per-socket</b>=&lt;<u>ntasks</u>&gt;
              Request the maximum <u>ntasks</u> be invoked on each socket.  This option applies to the job  allocation,
              but  not  to  step  allocations.   Meant  to  be  used  with  the  <b>--ntasks</b>  option.   Related  to
              <b>--ntasks-per-node</b> except at the socket level instead of the node level. Masks  will  automatically
              be  generated  to  bind  the tasks to specific sockets unless <b>--cpu-bind=none</b> is specified.  <b>NOTE</b>:
              This option is not supported when using <u>SelectType=select/linear</u>.

       <b>--oom-kill-step</b>[={0|1}]
              Whether to kill the entire step if an OOM event  is  detected  in  any  task  of  the  step.  This
              overwrites  the  "OOMKillStep"  setting  in  TaskPluginParam  from  slurm.conf  and the allocation
              settings. When unset it will use the setting in slurm.conf. When set, a value of "0" will  disable
              killing  the  entire step, while a value of "1" will enable it.  Default is "1" (enabled) when the
              option is found with no value.

       <b>--open-mode</b>={append|truncate}
              Open the output and error files using append or truncate mode as specified.  For heterogeneous job
              steps the default value is "append".  Otherwise the default  value  is  specified  by  the  system
              configuration parameter <u>JobFileAppend</u>. This option applies to job and step allocations.

              See <b>EXAMPLE</b> below.

       <b>-o</b>, <b>--output</b>=&lt;<u>filename_pattern</u>&gt;
              Specify  the  "<u>filename</u>  <u>pattern</u>"  for  stdout  redirection.  By default in interactive mode, <b>srun</b>
              collects stdout from all tasks and sends this output via TCP/IP to  the  attached  terminal.  With
              <b>--output</b> stdout may be redirected to a file, to one file per task, or to /dev/null. See section <b>IO</b>
              <b>Redirection</b>  below  for  the  various  forms  of  <u>filename</u> <u>pattern</u>.  If the specified file already
              exists, it will be overwritten.

              If <b>--error</b> is not also specified on the command line, both stdout and stderr will directed to  the
              file specified by <b>--output</b>. This option applies to job and step allocations.

       <b>-O</b>, <b>--overcommit</b>
              Overcommit resources. This option applies to job and step allocations.

              When applied to a job allocation (not including jobs requesting exclusive access to the nodes) the
              resources  are  allocated as if only one task per node is requested. This means that the requested
              number of cpus per task (<b>-c</b>, <b>--cpus-per-task</b>) are allocated per node rather than being  multiplied
              by  the  number of tasks. Options used to specify the number of tasks per node, socket, core, etc.
              are ignored.

              When applied to job step allocations (the <b>srun</b>  command  when  executed  within  an  existing  job
              allocation),  this  option  can be used to launch more than one task per CPU.  Normally, <b>srun</b> will
              not allocate more than one process  per  CPU.   By  specifying  <b>--overcommit</b>  you  are  explicitly
              allowing  more  than  one  process  per  CPU.  However  no  more than <b>MAX_TASKS_PER_NODE</b> tasks are
              permitted to execute per node. <b>NOTE</b>: <b>MAX_TASKS_PER_NODE</b> is defined in the file <u>slurm.h</u> and is  not
              a variable, it is set at Slurm build time.

       <b>--overlap</b>
              Specifying  --overlap  allows steps to share all resources (CPUs, memory, and GRES) with all other
              steps. A step using this option will overlap all other steps, even  those  that  did  not  specify
              --overlap.

              By  default  steps  do not share resources with other parallel steps.  This option applies to step
              allocations.

       <b>-s</b>, <b>--oversubscribe</b>
              The job allocation can over-subscribe resources with other running  jobs.   The  resources  to  be
              over-subscribed  can  be  nodes, sockets, cores, and/or hyperthreads depending upon configuration.
              The  default  over-subscribe  behavior  depends  on  system  configuration  and  the   partition's
              <b>OverSubscribe</b>  option  takes  precedence  over  the  job's  option.  This option may result in the
              allocation being granted sooner than if the --oversubscribe option was not set  and  allow  higher
              system  utilization,  but  application  performance  will  likely  suffer  due  to competition for
              resources.  This option applies to job allocations.

              <b>NOTE</b>: This option is mutually exclusive with <b>--exclusive</b>.

       <b>-p</b>, <b>--partition</b>=&lt;<u>partition_names</u>&gt;
              Request a specific partition for the resource allocation. If not specified, the  default  behavior
              is  to  allow  the  slurm  controller  to select the default partition as designated by the system
              administrator. If the job can use more than one partition, specify their names in a comma separate
              list and the one offering earliest initiation will be used with no regard given to  the  partition
              name  ordering  (although  higher  priority partitions will be considered first).  When the job is
              initiated, the name of the partition used will be placed first in the job record partition string.
              This option applies to job allocations.

       <b>--prefer</b>=&lt;<u>list</u>&gt;
              Nodes can have <b>features</b> assigned to them by the Slurm administrator.  Users can specify  which  of
              these  <b>features</b>  are  desired  but not required by their job using the prefer option.  This option
              operates independently from <b>--constraint</b> and will override whatever  is  set  there  if  possible.
              When  scheduling,  the  features  in  <b>--prefer</b> are tried first. If a node set isn't available with
              those features then <b>--constraint</b> is attempted.  See <b>--constraint</b> for more information, this option
              behaves the same way.

       <b>-E</b>, <b>--preserve-env</b>
              Pass the current values of environment variables SLURM_JOB_NUM_NODES and SLURM_NTASKS  through  to
              the  <u>executable</u>,  rather  than computing them from command line parameters. This option applies to
              job allocations.

       <b>--priority</b>=&lt;<u>value</u>&gt;
              Request a specific job priority.  May be subject to  configuration  specific  constraints.   <u>value</u>
              should  either be a numeric value or "TOP" (for highest possible value).  Only Slurm operators and
              administrators can set the priority of a job.  This option applies to job allocations only.

       <b>--profile</b>={all|none|&lt;<u>type</u>&gt;[,&lt;<u>type</u>&gt;...]}
              Enables detailed data collection by the acct_gather_profile plugin.  Detailed data  are  typically
              time-series  that  are stored in an HDF5 file for the job or an InfluxDB database depending on the
              configured plugin.  This option applies to job and step allocations.

              <b>All</b>       All data types are collected. (Cannot be combined with other values.)

              <b>None</b>      No data types are collected. This is the default.
                         (Cannot be combined with other values.)

       Valid <u>type</u> values are:

              <b>Energy</b> Energy data is collected.

              <b>Task</b>   Task (I/O, Memory, ...) data is collected.

              <b>Filesystem</b>
                     Filesystem data is collected.

              <b>Network</b>
                     Network (InfiniBand) data is collected.

       <b>--prolog</b>=&lt;<u>executable</u>&gt;
              <b>srun</b> will run <u>executable</u> just before launching the job  step.   The  command  line  arguments  for
              <u>executable</u>  will  be  the  command and arguments of the job step. If <u>executable</u> is "none", then no
              srun prolog will be run. This parameter overrides the SrunProlog  parameter  in  slurm.conf.  This
              parameter  is  completely independent from the Prolog parameter in slurm.conf. This option applies
              to job allocations.

       <b>--propagate</b>[=<u>rlimit</u>[,<u>rlimit</u>...]]
              Allows users to specify which of the modifiable (soft) resource limits to propagate to the compute
              nodes and apply to their jobs. If no <u>rlimit</u>  is  specified,  then  all  resource  limits  will  be
              propagated.   The  following rlimit names are supported by Slurm (although some options may not be
              supported on some systems):

              <b>ALL</b>       All limits listed below (default)

              <b>NONE</b>      No limits listed below

              <b>AS</b>        The maximum address space (virtual memory) for a process.

              <b>CORE</b>      The maximum size of core file

              <b>CPU</b>       The maximum amount of CPU time

              <b>DATA</b>      The maximum size of a process's data segment

              <b>FSIZE</b>     The maximum size of files created. Note that if the user sets FSIZE  to  less  than  the
                        current size of the slurmd.log, job launches will fail with a 'File size limit exceeded'
                        error.

              <b>MEMLOCK</b>   The maximum size that may be locked into memory

              <b>NOFILE</b>    The maximum number of open files

              <b>NPROC</b>     The maximum number of processes available

              <b>RSS</b>       The  maximum resident set size. Note that this only has effect with Linux kernels 2.4.30
                        or older or BSD.

              <b>STACK</b>     The maximum stack size

              This option applies to job allocations.

       <b>--pty</b>, <b>--pty</b>=&lt;<u>File</u> <u>Descriptor</u>&gt;
              Execute task zero  with  pseudo  terminal  mode  or  using  pseudo  terminal  specified  by  &lt;<u>File</u>
              <u>Descriptor</u>&gt;.  Implicitly sets <b>--unbuffered</b>.  Implicitly sets <b>--error</b> and <b>--output</b> to /dev/null for
              all  tasks  except  task  zero,  which may cause those tasks to exit immediately (e.g. shells will
              typically exit immediately in that situation).  This option applies to step allocations.

       <b>-q</b>, <b>--qos</b>=&lt;<u>qos</u>&gt;
              Request a quality of service for the job, or comma separated list of QOS.  If requesting a list it
              will be ordered based on the priority of the QOS given with the first being the highest  priority.
              QOS  values can be defined for each user/cluster/account association in the Slurm database.  Users
              will be limited to  their  association's  defined  set  of  qos's  when  the  Slurm  configuration
              parameter,  AccountingStorageEnforce, includes "qos" in its definition. This option applies to job
              allocations.

       <b>-Q</b>, <b>--quiet</b>
              Suppress informational messages from srun. Errors will still be displayed. This option applies  to
              job and step allocations.

       <b>--quit-on-interrupt</b>
              Quit  immediately  on  single  SIGINT  (Ctrl-C).  Use  of  this option disables the status feature
              normally available when <b>srun</b> receives a single Ctrl-C  and  causes  <b>srun</b>  to  instead  immediately
              terminate the running job. This option applies to step allocations.

       <b>--reboot</b>
              Force  the  allocated  nodes  to reboot before starting the job.  This is only supported with some
              system configurations and will otherwise be silently ignored. Only root, <u>SlurmUser</u> or  admins  can
              reboot nodes. This option applies to job allocations.

       <b>-r</b>, <b>--relative</b>=&lt;<u>n</u>&gt;
              Run  a  job  step relative to node <u>n</u> of the current allocation.  This option may be used to spread
              several job steps out among the nodes of the current job. If <b>-r</b> is used, the current job step will
              begin at node <u>n</u> of the allocated nodelist, where the first node  is  considered  node  0.  The  <b>-r</b>
              option  is  not  permitted  with <b>-w</b> or <b>-x</b> option and will result in a fatal error when not running
              within a prior allocation (i.e. when SLURM_JOB_ID is not set). The default for  <u>n</u>  is  0.  If  the
              value  of  <b>--nodes</b>  exceeds  the  number of nodes identified with the <b>--relative</b> option, a warning
              message will be printed and the <b>--relative</b> option will take precedence.  This  option  applies  to
              step allocations.

       <b>--reservation</b>=&lt;<u>reservation_names</u>&gt;
              Allocate  resources  for  the  job  from  the  named reservation. If the job can use more than one
              reservation, specify their  names  in  a  comma  separate  list  and  the  one  offering  earliest
              initiation.  Each  reservation will be considered in the order it was requested.  All reservations
              will be listed in  scontrol/squeue  through  the  life  of  the  job.   In  accounting  the  first
              reservation will be seen and after the job starts the reservation used will replace it.

       <b>--resv-ports</b>[=<u>count</u>]
              Reserve  communication  ports  for  this  job.  Users  can specify the number of port they want to
              reserve. The parameter MpiParams=ports=12000-12999 must be specified in <u>slurm.conf</u>. If the  number
              of  reserved  ports  is  zero  then  no ports are reserved. Used for native Cray's PMI only.  This
              option applies to job and step allocations.

       <b>--segment</b>=&lt;<u>segment_size</u>&gt;
              When a block topology is used, this defines the size of the segments that will be used  to  create
              the job allocation.  No requirement would be placed on all segments for a job needing to be placed
              within the same higher-level block.

              <b>NOTE</b>: The segment size must always be evenly divisible by the requested node count.

              <b>NOTE</b>:  The  segment  size  must be less than or equal to the planning base block size. E.g., for a
              system with 30 nodes as the planning base block size, "--segment 40" would be invalid

       <b>--send-libs</b>[=yes|no]
              If set to  <u>yes</u>  (or  no  argument),  autodetect  and  broadcast  the  executable's  shared  object
              dependencies  to  allocated  compute  nodes.  The  files  are  placed in a directory alongside the
              executable. The <b>LD_LIBRARY_PATH</b> is automatically updated to include this cache directory as  well.
              This  overrides  the  default  behavior  configured in slurm.conf <b>SbcastParameters</b> <b>send_libs</b>. This
              option only works in conjunction with <b>--bcast</b>. See also <b>--bcast-exclude</b>.

       <b>--signal</b>=[R:]&lt;<u>sig_num</u>&gt;[@<u>sig_time</u>]
              When a job is within <u>sig_time</u> seconds of its end time, send it the signal  <u>sig_num</u>.   Due  to  the
              resolution  of  event  handling  by  Slurm,  the  signal may be sent up to 60 seconds earlier than
              specified.  <u>sig_num</u> may either be a signal number or name (e.g. "10" or  "USR1").   <u>sig_time</u>  must
              have  an  integer  value  between 0 and 65535.  By default, no signal is sent before the job's end
              time.  If a <u>sig_num</u> is specified without any <u>sig_time</u>, the default time will be 60  seconds.  This
              option  applies  to  job  allocations.   Use  the  "R:" option to allow this job to overlap with a
              reservation with MaxStartDelay set. If the "R:" option is used, preemption must be enabled on  the
              system,  and  if  the  job  is  preempted it will be requeued if allowed otherwise the job will be
              canceled.  To have the signal sent at preemption time see the <b>send_user_signal</b> <b>PreemptParameter</b>.

       <b>--slurmd-debug</b>=&lt;<u>level</u>&gt;
              Specify a debug level for this step. The <u>level</u> may be specified either as an integer value between
              2 [error] and 6 [debug2], or as one of the <u>SlurmdDebug</u> tags.

              <b>error</b>     Log only errors

              <b>info</b>      Log errors and general informational messages

              <b>verbose</b>   Log errors and verbose informational messages

              <b>debug</b>     Log errors and verbose informational messages and debugging messages

              <b>debug2</b>    Log errors and verbose informational messages and more debugging messages

              The slurmd debug information is copied onto the stderr of the job.  By  default  only  errors  are
              displayed. This option applies to job and step allocations.

       <b>--sockets-per-node</b>=&lt;<u>sockets</u>&gt;
              Restrict  node  selection  to  nodes with at least the specified number of sockets. See additional
              information under <b>-B</b> option above when task/affinity plugin is enabled. This option applies to job
              allocations.
              <b>NOTE</b>: This option may implicitly impact the number of tasks if <b>-n</b> was not specified.

       <b>--spread-job</b>
              Spread the job allocation over as many nodes as possible and attempt to  evenly  distribute  tasks
              across  the  allocated nodes.  This option disables the topology/tree plugin.  This option applies
              to job allocations.

       <b>--stepmgr</b>
              Enable slurmstepd step management per-job if it isn't enabled system wide.  This enables job steps
              to be managed by a single extern slurmstepd associated with the  job  to  manage  steps.  This  is
              beneficial  for  jobs that submit many steps inside their allocations. <b>PrologFlags=contain</b> must be
              set.  This option applies to job allocations.

       <b>--switches</b>=&lt;<u>count</u>&gt;[@<u>max-time</u>]
              When a tree topology is used, this defines the maximum count of leaf switches desired for the  job
              allocation  and optionally the maximum time to wait for that number of switches. If Slurm finds an
              allocation containing more switches than the count specified, the job  remains  pending  until  it
              either  finds  an  allocation with desired switch count or the time limit expires.  It there is no
              switch count limit, there is no delay in  starting  the  job.   Acceptable  time  formats  include
              "minutes",  "minutes:seconds",  "hours:minutes:seconds",  "days-hours",  "days-hours:minutes"  and
              "days-hours:minutes:seconds".  The  job's  maximum  time  delay  may  be  limited  by  the  system
              administrator  using  the  <b>SchedulerParameters</b>  configuration  parameter  with the <b>max_switch_wait</b>
              parameter option.  On a dragonfly network the only switch count supported is 1 since communication
              performance will be highest when a job is allocate resources on one leaf switch  or  more  than  2
              leaf  switches.   The  default  max-time  is  the max_switch_wait SchedulerParameters. This option
              applies to job allocations.

       <b>--task-epilog</b>=&lt;<u>executable</u>&gt;
              The <b>slurmstepd</b> daemon will run <u>executable</u> just after each task terminates. This will  be  executed
              before  any TaskEpilog parameter in slurm.conf is executed. This is meant to be a very short-lived
              program. If it fails to terminate within  a  few  seconds,  it  will  be  killed  along  with  any
              descendant processes. This option applies to step allocations.

       <b>--task-prolog</b>=&lt;<u>executable</u>&gt;
              The  <b>slurmstepd</b>  daemon will run <u>executable</u> just before launching each task. This will be executed
              after any TaskProlog  parameter  in  slurm.conf  is  executed.   Besides  the  normal  environment
              variables, this has SLURM_TASK_PID available to identify the process ID of the task being started.
              Standard  output from this program of the form "export NAME=value" will be used to set environment
              variables for the task being spawned. This option applies to step allocations.

       <b>--test-only</b>
              Returns an estimate of when a job would be scheduled to run given the current job  queue  and  all
              the  other  <b>srun</b>  arguments  specifying  the  job.  This  limits  <b>srun's</b>  behavior  to just return
              information; no job is actually submitted.  The program will be executed directly  by  the  slurmd
              daemon. This option applies to job allocations.

       <b>--thread-spec</b>=&lt;<u>num</u>&gt;
              Count  of  specialized  threads per node reserved by the job for system operations and not used by
              the application. The application will not use  these  threads,  but  will  be  charged  for  their
              allocation.   This  option can not be used with the <b>--core-spec</b> option. This option applies to job
              allocations.

              <b>NOTE</b>: Explicitly setting a job's specialized thread value implicitly sets its --exclusive  option,
              reserving entire nodes for the job.

       <b>-T</b>, <b>--threads</b>=&lt;<u>nthreads</u>&gt;
              Allows  limiting  the  number  of  concurrent  threads  used to send the job request from the srun
              process to the slurmd processes on the allocated nodes. Default is to use one thread per allocated
              node up to a maximum of 60 concurrent  threads.  Specifying  this  option  limits  the  number  of
              concurrent  threads to <u>nthreads</u> (less than or equal to 60).  This should only be used to set a low
              thread count for testing on very small memory computers.

       <b>--threads-per-core</b>=&lt;<u>threads</u>&gt;
              Restrict node selection to nodes with at least the specified number of threads per core.  In  task
              layout,  use  the  specified maximum number of threads per core. Implies <b>--cpu-bind=threads</b> unless
              overridden by command line or environment options.   <b>NOTE</b>:  "Threads"  refers  to  the  number  of
              processing units on each core rather than the number of application tasks to be launched per core.
              See additional information under <b>-B</b> option above when task/affinity plugin is enabled. This option
              applies to job and step allocations.
              <b>NOTE</b>: This option may implicitly impact the number of tasks if <b>-n</b> was not specified.

       <b>-t</b>, <b>--time</b>=&lt;<u>time</u>&gt;
              Set  a  limit on the total run time of the job allocation. If the requested time limit exceeds the
              partition's time limit, the job will be left in  a  PENDING  state  (possibly  indefinitely).  The
              default  time  limit  is  the partition's default time limit. When the time limit is reached, each
              task in each job step is sent SIGTERM  followed  by  SIGKILL.  The  interval  between  signals  is
              specified by the Slurm configuration parameter <b>KillWait</b>. The <b>OverTimeLimit</b> configuration parameter
              may  permit  the job to run longer than scheduled. Time resolution is one minute and second values
              are rounded up to the next minute.

              A time limit of zero requests that no time limit  be  imposed.  Acceptable  time  formats  include
              "minutes",  "minutes:seconds",  "hours:minutes:seconds",  "days-hours",  "days-hours:minutes"  and
              "days-hours:minutes:seconds". This option applies to job and step allocations.

       <b>--time-min</b>=&lt;<u>time</u>&gt;
              Set a minimum time limit on the job allocation.  If specified, the job may have its  <b>--time</b>  limit
              lowered to a value no lower than <b>--time-min</b> if doing so permits the job to begin execution earlier
              than  otherwise  possible.   The  job's  time limit will not be changed after the job is allocated
              resources.  This is performed by a backfill scheduling algorithm to allocate  resources  otherwise
              reserved  for higher priority jobs.  Acceptable time formats include "minutes", "minutes:seconds",
              "hours:minutes:seconds", "days-hours", "days-hours:minutes" and "days-hours:minutes:seconds". This
              option applies to job allocations.

       <b>--tmp</b>=&lt;<u>size</u>&gt;[<u>units</u>]
              Specify a minimum amount  of  temporary  disk  space  per  node.   Default  units  are  megabytes.
              Different  units  can  be  specified  using  the  suffix  [K|M|G|T].   This  option applies to job
              allocations.

       <b>--treewidth</b>=&lt;<u>size</u>&gt;
              Specify the width of the fanout. Default is the <u>TreeWidth</u> specified in the <b>slurm.conf</b>.  The  value
              may not exceed 65533. A value of "off" disables the fanout.

       <b>--tres-bind</b>=&lt;<u>tres</u>&gt;:[verbose,]&lt;<u>type</u>&gt;[+&lt;<u>tres</u>&gt;:
              [verbose,]&lt;<u>type</u>&gt;...]   Specify  a list of tres with their task binding options. Currently gres are
              the only supported tres for this options. Specify gres as "gres/&lt;gres_name&gt;" (e.g. gres/gpu)

              Example: --tres-bind=gres/gpu:verbose,map:0,1,2,3+gres/nic:closest

              By default, most tres are not bound to individual tasks

              Supported binding <u>type</u> options for <b>gres</b>:

              <b>closest</b>   Bind each task to the gres(s) which are closest.  In a NUMA environment, each  task  may
                        be bound to more than one gres (i.e.  all gres in that NUMA environment).

              <b>map:&lt;list&gt;</b>
                        Bind  by  setting  gres  masks  on  tasks  (or  ranks)  as  specified  where  &lt;list&gt;  is
                        &lt;gres_id_for_task_0&gt;,&lt;gres_id_for_task_1&gt;,...  gres  IDs  are  interpreted  as   decimal
                        values.  If  the number of tasks (or ranks) exceeds the number of elements in this list,
                        elements in the list will be reused as needed starting from the beginning of  the  list.
                        To  simplify  support for large task counts, the lists may follow a map with an asterisk
                        and repetition count. For example "map:0*4,1*4".  If the task/cgroup plugin is used  and
                        ConstrainDevices  is  set  in  cgroup.conf,  then  the  gres  IDs are zero-based indexes
                        relative to the gress allocated to the job (e.g. the first gres is 0, even if the global
                        ID is 3). Otherwise, the gres IDs are global IDs, and all gres on each node in  the  job
                        should be allocated for predictable binding results.

              <b>mask:&lt;list&gt;</b>
                        Bind  by  setting  gres  masks  on  tasks  (or  ranks)  as  specified  where  &lt;list&gt;  is
                        &lt;gres_mask_for_task_0&gt;,&lt;gres_mask_for_task_1&gt;,... The mapping is specified  for  a  node
                        and  identical mapping is applied to the tasks on every node (i.e. the lowest task ID on
                        each node is mapped to the first mask specified in  the  list,  etc.).  gres  masks  are
                        always  interpreted  as hexadecimal values but can be preceded with an optional '0x'. To
                        simplify support for large task counts, the lists may follow a map with an asterisk  and
                        repetition  count.  For example "mask:0x0f*4,0xf0*4".  If the task/cgroup plugin is used
                        and ConstrainDevices is set in cgroup.conf, then the gres  IDs  are  zero-based  indexes
                        relative  to the gres allocated to the job (e.g. the first gres is 0, even if the global
                        ID is 3). Otherwise, the gres IDs are global IDs, and all gres on each node in  the  job
                        should be allocated for predictable binding results.

              <b>none</b>      Do  not  bind  tasks  to  this gres (turns off implicit binding from --tres-per-task and
                        --gpus-per-task).

              <b>per_task:&lt;gres_per_task&gt;</b>
                        Each task will be bound to the number of gres specified in  <u>&lt;gres_per_task&gt;</u>.  Tasks  are
                        preferentially assigned gres with affinity to cores in their allocation like in <u>closest</u>,
                        though they will take any gres if they are unavailable. If no affinity exists, the first
                        task  will  be  assigned  the  first x number of gres on the node etc.  Shared gres will
                        prefer to bind one sharing device per task if possible.

              <b>single:&lt;tasks_per_gres&gt;</b>
                        Like <u>closest</u>, except that each task can only be bound to a single gres, even when it can
                        be bound to multiple gres that are equally close.  The gres to bind to is determined  by
                        <u>&lt;tasks_per_gres&gt;</u>,  where  the  first  <u>&lt;tasks_per_gres&gt;</u> tasks are bound to the first gres
                        available, the second <u>&lt;tasks_per_gres&gt;</u> tasks are bound to  the  second  gres  available,
                        etc.   This  is  basically  a block distribution of tasks onto available gres, where the
                        available gres are determined by the socket affinity of the task and the socket affinity
                        of the gres as specified in gres.conf's <u>Cores</u> parameter.

                        <b>NOTE</b>: Shared gres binding is currently limited to per_task or none

       <b>--tres-per-task</b>=&lt;<u>list</u>&gt;
              Specifies a comma-delimited list of trackable resources required for the job on each  task  to  be
              spawned   in  the  job's  resource  allocation.   The  format  for  each  entry  in  the  list  is
              "trestype[/tresname]=count".  The <u>trestype</u> is the type of trackable resource requested (e.g.  cpu,
              gres,  license,  etc).   The  <u>tresname</u>  is the name of the trackable resource, as can be seen with
              <u>sacctmgr</u> <u>show</u> <u>tres</u>. This is required when it exists for tres types such  as  gres,  license,  etc.
              (e.g.  gpu,  gpu:a100).   In  order  to request a license with this option, the license(s) must be
              defined in the <b>AccountingStorageTRES</b> parameter of slurm.conf.  The <u>count</u> is the  number  of  those
              resources.
              The count can have a suffix of
              "k" or "K" (multiple of 1024),
              "m" or "M" (multiple of 1024 x 1024),
              "g" or "G" (multiple of 1024 x 1024 x 1024),
              "t" or "T" (multiple of 1024 x 1024 x 1024 x 1024),
              "p" or "P" (multiple of 1024 x 1024 x 1024 x 1024 x 1024).
              Examples:
              --tres-per-task=cpu=4
              --tres-per-task=cpu=8,license/ansys=1
              --tres-per-task=gres/gpu=1
              --tres-per-task=gres/gpu:a100=2
              The  specified  resources  will  be  allocated  to  the job on each node.  The available trackable
              resources are configurable by the system administrator.
              <b>NOTE</b>: This option with gres/gpu or gres/shard will  implicitly  set  --tres-bind=per_task:(gpu  or
              shard)&lt;tres_per_task&gt;; this can be overridden with an explicit --tres-bind specification.
              <b>NOTE</b>: Invalid TRES for --tres-per-task include bb,billing,energy,fs,mem,node,pages,vmem.

       <b>-u</b>, <b>--unbuffered</b>
              By  default,  the  connection between slurmstepd and the user-launched application is over a pipe.
              The stdio output written by the application is buffered by the glibc until it is  flushed  or  the
              output  is  set  as unbuffered.  See <a href="../man3/setbuf.3.html">setbuf</a>(3). If this option is specified the tasks are executed
              with a pseudo terminal so that the application output is unbuffered. This option applies  to  step
              allocations.

       <b>--usage</b>
              Display brief help message and exit.

       <b>--use-min-nodes</b>
              If a range of node counts is given, prefer the smaller count.

       <b>-v</b>, <b>--verbose</b>
              Increase  the  verbosity of srun's informational messages. Multiple errors will be displayed. This
              option applies to job and step allocations.

       <b>-V</b>, <b>--version</b>
              Display version information and exit.

       <b>-W</b>, <b>--wait</b>=&lt;<u>seconds</u>&gt;
              Specify how long to wait after the first task terminates before terminating all remaining tasks. A
              value of 0 indicates an unlimited wait (a warning will be issued after 60  seconds).  The  default
              value  is  set by the WaitTime parameter in the slurm configuration file (see <b><a href="../man5/slurm.conf.5.html">slurm.conf</a>(5)</b>). This
              option can be useful to ensure that a job is terminated in a timely fashion in the event that  one
              or  more  tasks  terminate  prematurely.  Note: The <b>-K</b>, <b>--kill-on-bad-exit</b> option takes precedence
              over <b>-W</b>, <b>--wait</b> to terminate the job immediately if a task exits with a non-zero exit  code.  This
              option applies to job allocations.

       <b>--wckey</b>=&lt;<u>wckey</u>&gt;
              Specify  wckey  to  be  used  with job. If TrackWCKey=no (default) in the slurm.conf this value is
              ignored. This option applies to job allocations.

       <b>--x11</b>[={all|first|last}]
              Sets up X11 forwarding on "all", "first" or "last" node(s) of the allocation.  This option is only
              enabled if Slurm was compiled with X11 support and PrologFlags=x11 is defined in  the  slurm.conf.
              Default is "all".

       <b>srun</b>  will  submit the job request to the slurm job controller, then initiate all processes on the remote
       nodes. If the request cannot be met immediately, <b>srun</b> will block until the resources are free to run  the
       job.  If  the  <b>-I</b>  (<b>--immediate</b>) option is specified <b>srun</b> will terminate if resources are not immediately
       available.

       When initiating remote processes <b>srun</b> will propagate the current working directory, unless <b>--chdir</b>=&lt;<u>path</u>&gt;
       is specified, in which case <u>path</u> will become the working directory for the remote processes.

       The <b>-n,</b> <b>-c</b>, and <b>-N</b> options control how CPUs and nodes will be allocated to the job. When specifying  only
       the  number of processes to run with <b>-n</b>, a default of one CPU per process is allocated. By specifying the
       number of CPUs required per task (<b>-c</b>), more than one CPU may be allocated per process. If the  number  of
       nodes is specified with <b>-N</b>, <b>srun</b> will attempt to allocate <u>at</u> <u>least</u> the number of nodes specified.

       Combinations  of the above three options may be used to change how processes are distributed across nodes
       and cpus. For instance, by specifying both the number of processes and number of nodes on which  to  run,
       the number of processes per node is implied. However, if the number of CPUs per process is more important
       then number of processes (<b>-n</b>) and the number of CPUs per process (<b>-c</b>) should be specified.

       <b>srun</b> will refuse to allocate more than one process per CPU unless <b>--overcommit</b> (<b>-O</b>) is also specified.

       <b>srun</b> will attempt to meet the above specifications "at a minimum." That is, if 16 nodes are requested for
       32  processes,  and  some nodes do not have 2 CPUs, the allocation of nodes will be increased in order to
       meet the demand for CPUs. In other words, a <u>minimum</u> of 16 nodes are being requested. However, if 16 nodes
       are requested for 15 processes, <b>srun</b> will consider this an error, as 15 processes cannot  run  across  16
       nodes.

       <b>IO</b> <b>Redirection</b>

       By  default,  stdout  and  stderr will be redirected from all tasks to the stdout and stderr of <b>srun</b>, and
       stdin will be redirected from the standard input of <b>srun</b> to all remote tasks.  If stdin  is  only  to  be
       read  by  a subset of the spawned tasks, specifying a file to read from rather than forwarding stdin from
       the <b>srun</b> command may be preferable as it avoids moving and storing data that will never be read.

       For OS X, the poll() function does not support stdin, so input from a terminal is not possible.

       This behavior may be changed with the <b>--output</b>, <b>--error</b>, and <b>--input</b> (<b>-o</b>, <b>-e</b>,  <b>-i</b>)  options.   Note  that
       <b>--error</b>  won't  redirect  the  stderr  of  srun  itself,  only  the  stderr from the tasks.  Valid format
       specifications for these options are

       <b>all</b>       stdout stderr is redirected from all tasks to srun.  stdin is broadcast to  all  remote  tasks.
                 (This is the default behavior)

       <b>none</b>      stdout  and  stderr  is  not  received  from any task.  stdin is not sent to any task (stdin is
                 closed).

       <b>taskid</b>    stdout and/or stderr are redirected from only the task with relative id equal to <u>taskid</u>,  where
                 0  &lt;=  <u>taskid</u>  &lt;=  <u>ntasks</u>,  where  <u>ntasks</u> is the total number of tasks in the current job step.
                 stdin is redirected from the stdin of <b>srun</b> to this same task.  This file will be written on the
                 node executing the task.

       <b>filename</b>  <b>srun</b> will redirect stdout and/or stderr to the named  file  from  all  tasks.   stdin  will  be
                 redirected from the named file and broadcast to all tasks in the job. <u>filename</u> refers to a path
                 on  the  host that runs <b>srun</b>. Depending on the cluster's file system layout, this may result in
                 the output appearing in different places depending on whether the job is run in batch mode.

       <b>filename</b> <b>pattern</b>
                 <b>srun</b> allows for a filename pattern to be used to generate the named IO  file  described  above.
                 The following list of format specifiers may be used in the format string to generate a filename
                 that  will  be  unique  to  a given jobid, stepid, node, or task. In each case, the appropriate
                 number of files are opened and associated with the corresponding tasks. Note  that  any  format
                 string  containing %t, %n, and/or %N will be written on the node executing the task rather than
                 the node where <b>srun</b> executes, these format specifiers are not supported on a BGQ system.

                 <b>\\</b>     Do not process any of the replacement symbols.

                 <b>%%</b>     The character "%".

                 <b>%A</b>     Job array's master job allocation number.

                 <b>%a</b>     Job array ID (index) number.

                 <b>%J</b>     jobid.stepid of the running job. (e.g. "128.0")

                 <b>%j</b>     jobid of the running job.

                 <b>%s</b>     stepid of the running job.

                 <b>%N</b>     short hostname. This will create a separate IO file per node.

                 <b>%n</b>     Node identifier relative to current job (e.g. "0" is the first node of the running  job)
                        This will create a separate IO file per node.

                 <b>%t</b>     task  identifier (rank) relative to current job. This will create a separate IO file per
                        task.

                 <b>%u</b>     User name.

                 <b>%x</b>     Job name.

                 A number placed between the percent character and format specifier may be used to zero-pad  the
                 result  in  the  IO  filename to at minimum of specified numbers. This number is ignored if the
                 format specifier corresponds to non-numeric data (%N for example). The maximal number is 10, if
                 a value greater than 10 is used the result is padding up to 10 characters.   Some  examples  of
                 how  the  format  string may be used for a 4 task job step with a JobID of 128 and step id of 0
                 are included below:

                 job%J.out      job128.0.out

                 job%4j.out     job0128.out

                 job%2j-%2t.out job128-00.out, job128-01.out, ...

</pre><h4><b>PERFORMANCE</b></h4><pre>
       Executing <b>srun</b> sends a remote procedure call to <b>slurmctld</b>. If enough  calls  from  <b>srun</b>  or  other  Slurm
       client  commands  that send remote procedure calls to the <b>slurmctld</b> daemon come in at once, it can result
       in a degradation of performance of the <b>slurmctld</b> daemon, possibly resulting in a denial of service.

       Do not run <b>srun</b> or other Slurm client commands that send remote procedure calls to <b>slurmctld</b>  from  loops
       in shell scripts or other programs. Ensure that programs limit calls to <b>srun</b> to the minimum necessary for
       the information you are trying to gather.

</pre><h4><b>INPUT</b> <b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       Upon  startup,  srun  will  read  and  handle the options set in the following environment variables. The
       majority of these variables are set the same way the options are set, as defined above. For flag  options
       that  are  defined  to  expect no argument, the option can be enabled by setting the environment variable
       without a value (empty or NULL string), the string 'yes', or a non-zero number. Any other value  for  the
       environment  variable  will  result  in the option not being set.  There are a couple exceptions to these
       rules that are noted below.
       <b>NOTE</b>: Command line options always override environment variable settings.

       <b>PMI_FANOUT</b>            This is used exclusively with PMI (MPICH2 and MVAPICH2) and controls the fanout  of
                             data  communications.  The srun command sends messages to application programs (via
                             the PMI library) and those applications may be called upon to forward that data  to
                             up  to  this  number  of additional tasks. Higher values offload work from the srun
                             command to the applications and likely increase the vulnerability to failures.  The
                             default value is 32.

       <b>PMI_FANOUT_OFF_HOST</b>   This is used exclusively with PMI (MPICH2 and MVAPICH2) and controls the fanout  of
                             data  communications.  The srun command sends messages to application programs (via
                             the PMI library) and those applications may be called upon to forward that data  to
                             additional  tasks. By default, srun sends one message per host and one task on that
                             host forwards the  data  to  other  tasks  on  that  host  up  to  <b>PMI_FANOUT</b>.   If
                             <b>PMI_FANOUT_OFF_HOST</b>  is  defined, the user task may be required to forward the data
                             to tasks on other hosts.  Setting  <b>PMI_FANOUT_OFF_HOST</b>  may  increase  performance.
                             Since  more  work  is  performed by the PMI library loaded by the user application,
                             failures also can be  more  common  and  more  difficult  to  diagnose.  Should  be
                             disabled/enabled by setting to 0 or 1.

       <b>PMI_TIME</b>              This  is  used exclusively with PMI (MPICH2 and MVAPICH2) and controls how much the
                             communications from the tasks to the srun are spread out in time in order to  avoid
                             overwhelming  the  srun  command with work. The default value is 500 (microseconds)
                             per task. On relatively slow processors or systems with very large processor counts
                             (and large PMI data sets), higher values may be required.

       <b>SLURM_ACCOUNT</b>         Same as <b>-A,</b> <b>--account</b>

       <b>SLURM_ACCTG_FREQ</b>      Same as <b>--acctg-freq</b>

       <b>SLURM_BCAST</b>           Same as <b>--bcast</b>

       <b>SLURM_BCAST_EXCLUDE</b>   Same as <b>--bcast-exclude</b>

       <b>SLURM_BURST_BUFFER</b>    Same as <b>--bb</b>

       <b>SLURM_CLUSTERS</b>        Same as <b>-M</b>, <b>--clusters</b>

       <b>SLURM_COMPRESS</b>        Same as <b>--compress</b>

       <b>SLURM_CONF</b>            The location of the Slurm configuration file.

       <b>SLURM_CONSTRAINT</b>      Same as <b>-C</b>, <b>--constraint</b>

       <b>SLURM_CORE_SPEC</b>       Same as <b>--core-spec</b>

       <b>SLURM_CPU_BIND</b>        Same as <b>--cpu-bind</b>

       <b>SLURM_CPU_FREQ_REQ</b>    Same as <b>--cpu-freq</b>.

       <b>SLURM_CPUS_PER_GPU</b>    Same as <b>--cpus-per-gpu</b>

       <b>SLURM_CPUS_PER_TASK</b>   Same as <b>-c,</b> <b>--cpus-per-task</b> or <b>--tres-per-task=cpu=#</b>

       <b>SLURM_DEBUG</b>           Same as <b>-v,</b> <b>--verbose</b>, when set to 1, when set to 2 gives -vv, etc.

       <b>SLURM_DEBUG_FLAGS</b>     Specify debug flags for srun to use. See DebugFlags in the <b><a href="../man5/slurm.conf.5.html">slurm.conf</a></b>(5)  man  page
                             for  a  full  list  of  flags.  The  environment variable takes precedence over the
                             setting in the slurm.conf.

       <b>SLURM_DELAY_BOOT</b>      Same as <b>--delay-boot</b>

       <b>SLURM_DEPENDENCY</b>      Same as <b>-d,</b> <b>--dependency</b>=&lt;<u>jobid</u>&gt;

       <b>SLURM_DISABLE_STATUS</b>  Same as <b>-X,</b> <b>--disable-status</b>

       <b>SLURM_DIST_PLANESIZE</b>  Plane distribution size. Only used if  <b>--distribution=plane</b>,  without  <u>=&lt;size&gt;</u>,  is
                             set.

       <b>SLURM_DISTRIBUTION</b>    Same as <b>-m,</b> <b>--distribution</b>

       <b>SLURM_EPILOG</b>          Same as <b>--epilog</b>

       <b>SLURM_EXACT</b>           Same as <b>--exact</b>

       <b>SLURM_EXCLUSIVE</b>       Same as <b>--exclusive</b>

       <b>SLURM_EXIT_ERROR</b>      Specifies the exit code generated when a Slurm error occurs (e.g. invalid options).
                             This  can  be  used  by a script to distinguish application exit codes from various
                             Slurm error conditions.  Also see <b>SLURM_EXIT_IMMEDIATE</b>.

       <b>SLURM_EXIT_IMMEDIATE</b>  Specifies the exit code generated when the <b>--immediate</b> option is used and resources
                             are not currently  available.   This  can  be  used  by  a  script  to  distinguish
                             application   exit   codes   from   various   Slurm  error  conditions.   Also  see
                             <b>SLURM_EXIT_ERROR</b>.

       <b>SLURM_EXPORT_ENV</b>      Same as <b>--export</b>

       <b>SLURM_GPU_BIND</b>        Same as <b>--gpu-bind</b>

       <b>SLURM_GPU_FREQ</b>        Same as <b>--gpu-freq</b>

       <b>SLURM_GPUS</b>            Same as <b>-G,</b> <b>--gpus</b>

       <b>SLURM_GPUS_PER_NODE</b>   Same as <b>--gpus-per-node</b> except within an existing allocation, in which case it will
                             be ignored if <b>--gpus</b> is specified.

       <b>SLURM_GPUS_PER_TASK</b>   Same as <b>--gpus-per-task</b>

       <b>SLURM_GRES</b>            Same as <b>--gres</b>. Also see <b>SLURM_STEP_GRES</b>

       <b>SLURM_GRES_FLAGS</b>      Same as <b>--gres-flags</b>

       <b>SLURM_HINT</b>            Same as <b>--hint</b>

       <b>SLURM_IMMEDIATE</b>       Same as <b>-I,</b> <b>--immediate</b>

       <b>SLURM_JOB_ID</b>          Same as <b>--jobid</b>

       <b>SLURM_JOB_NAME</b>        Same as <b>-J,</b> <b>--job-name</b> except within an existing allocation, in which  case  it  is
                             ignored to avoid using the batch job's name as the name of each job step.

       <b>SLURM_JOB_NUM_NODES</b>   Same as <b>-N,</b> <b>--nodes</b>.  Total number of nodes in the job's resource allocation.

       <b>SLURM_KILL_BAD_EXIT</b>   Same  as  <b>-K,</b>  <b>--kill-on-bad-exit</b>.  Must  be set to 0 or 1 to disable or enable the
                             option.

       <b>SLURM_LABELIO</b>         Same as <b>-l,</b> <b>--label</b>

       <b>SLURM_MEM_BIND</b>        Same as <b>--mem-bind</b>

       <b>SLURM_MEM_PER_CPU</b>     Same as <b>--mem-per-cpu</b>

       <b>SLURM_MEM_PER_GPU</b>     Same as <b>--mem-per-gpu</b>

       <b>SLURM_MEM_PER_NODE</b>    Same as <b>--mem</b>

       <b>SLURM_MPI_TYPE</b>        Same as <b>--mpi</b>

       <b>SLURM_NETWORK</b>         Same as <b>--network</b>

       <b>SLURM_NNODES</b>          Same as <b>-N,</b> <b>--nodes</b>. Total number of nodes in the job's  resource  allocation.  See
                             <b>SLURM_JOB_NUM_NODES</b>. Included for backwards compatibility.

       <b>SLURM_NO_KILL</b>         Same as <b>-k</b>, <b>--no-kill</b>

       <b>SLURM_NPROCS</b>          Same as <b>-n,</b> <b>--ntasks</b>. See <b>SLURM_NTASKS</b>. Included for backwards compatibility.

       <b>SLURM_NTASKS</b>          Same as <b>-n,</b> <b>--ntasks</b>

       <b>SLURM_NTASKS_PER_CORE</b> Same as <b>--ntasks-per-core</b>

       <b>SLURM_NTASKS_PER_GPU</b>  Same as <b>--ntasks-per-gpu</b>

       <b>SLURM_NTASKS_PER_NODE</b> Same as <b>--ntasks-per-node</b>

       <b>SLURM_NTASKS_PER_SOCKET</b>
                             Same as <b>--ntasks-per-socket</b>

       <b>SLURM_OOMKILLSTEP</b>     Same as <b>--oom-kill-step</b>

       <b>SLURM_OPEN_MODE</b>       Same as <b>--open-mode</b>

       <b>SLURM_OVERCOMMIT</b>      Same as <b>-O,</b> <b>--overcommit</b>

       <b>SLURM_OVERLAP</b>         Same as <b>--overlap</b>

       <b>SLURM_PARTITION</b>       Same as <b>-p,</b> <b>--partition</b>

       <b>SLURM_PMI_KVS_NO_DUP_KEYS</b>
                             If  set,  then  PMI  key-pairs  will  contain  no  duplicate keys. MPI can use this
                             variable to inform the PMI library that it will not use duplicate keys so  PMI  can
                             skip  the  check  for  duplicate  keys.   This  is  the case for MPICH2 and reduces
                             overhead in testing for duplicates for improved performance

       <b>SLURM_POWER</b>           Same as <b>--power</b>

       <b>SLURM_PROFILE</b>         Same as <b>--profile</b>

       <b>SLURM_PROLOG</b>          Same as <b>--prolog</b>

       <b>SLURM_QOS</b>             Same as <b>--qos</b>

       <b>SLURM_REMOTE_CWD</b>      Same as <b>-D,</b> <b>--chdir=</b>

       <b>SLURM_REQ_SWITCH</b>      When a tree topology is used, this defines the maximum count  of  switches  desired
                             for  the  job allocation and optionally the maximum time to wait for that number of
                             switches. See <b>--switches</b>

       <b>SLURM_RESERVATION</b>     Same as <b>--reservation</b>

       <b>SLURM_RESV_PORTS</b>      Same as <b>--resv-ports</b>

       <b>SLURM_SEND_LIBS</b>       Same as <b>--send-libs</b>

       <b>SLURM_SIGNAL</b>          Same as <b>--signal</b>

       <b>SLURM_SPREAD_JOB</b>      Same as <b>--spread-job</b>

       <b>SLURM_SRUN_REDUCE_TASK_EXIT_MSG</b>
                             if set and non-zero, successive task exit messages with the same exit code will  be
                             printed only once.

       <b>SRUN_ERROR</b>            Same as <b>-e,</b> <b>--error</b>

       <b>SRUN_INPUT</b>            Same as <b>-i,</b> <b>--input</b>

       <b>SRUN_OUTPUT</b>           Same as <b>-o,</b> <b>--output</b>

       <b>SLURM_STEP_GRES</b>       Same  as  <b>--gres</b>  (only  applies  to  job steps, not to job allocations).  Also see
                             <b>SLURM_GRES</b>

       <b>SLURM_STEP_KILLED_MSG_NODE_ID</b>=ID
                             If set, only the specified node will log when the job  or  step  are  killed  by  a
                             signal.

       <b>SLURM_TASK_EPILOG</b>     Same as <b>--task-epilog</b>

       <b>SLURM_TASK_PROLOG</b>     Same as <b>--task-prolog</b>

       <b>SLURM_TEST_EXEC</b>       If  defined,  srun  will verify existence of the executable program along with user
                             execute permission on the node where srun was called before attempting to launch it
                             on nodes in the step.

       <b>SLURM_THREAD_SPEC</b>     Same as <b>--thread-spec</b>

       <b>SLURM_THREADS</b>         Same as <b>-T,</b> <b>--threads</b>

       <b>SLURM_THREADS_PER_CORE</b>
                             Same as <b>--threads-per-core</b>

       <b>SLURM_TIMELIMIT</b>       Same as <b>-t,</b> <b>--time</b>

       <b>SLURM_TRES_BIND</b>       Same as <b>--tres-bind</b> If <b>--gpu-bind</b> is specified, it is also set  in  <b>SLURM_TRES_BIND</b>
                             as if it were specified in <b>--tres-bind</b>.

       <b>SLURM_TRES_PER_TASK</b>   Same as <b>--tres-per-task</b>.

       <b>SLURM_UMASK</b>           If  defined,  Slurm will use the defined <u>umask</u> to set permissions when creating the
                             output/error files for the job.

       <b>SLURM_UNBUFFEREDIO</b>    Same as <b>-u,</b> <b>--unbuffered</b>

       <b>SLURM_USE_MIN_NODES</b>   Same as <b>--use-min-nodes</b>

       <b>SLURM_WAIT</b>            Same as <b>-W,</b> <b>--wait</b>

       <b>SLURM_WAIT4SWITCH</b>     Max time waiting for requested switches. See <b>--switches</b>

       <b>SLURM_WCKEY</b>           Same as <b>-W,</b> <b>--wckey</b>

       <b>SLURM_WORKING_DIR</b>     <b>-D,</b> <b>--chdir</b>

       <b>SLURMD_DEBUG</b>          Same as <b>--slurmd-debug</b>.

       <b>SRUN_CONTAINER</b>        Same as <b>--container</b>.

       <b>SRUN_CONTAINER_ID</b>     Same as <b>--container-id</b>.

       <b>SRUN_EXPORT_ENV</b>       Same as <b>--export</b>, and will override any setting for <b>SLURM_EXPORT_ENV</b>.

</pre><h4><b>OUTPUT</b> <b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       srun will set some environment variables in the environment of the executing tasks on the remote  compute
       nodes.  These environment variables are:

       <b>SLURM_*_HET_GROUP_#</b>   For  a  heterogeneous  job allocation, the environment variables are set separately
                             for each component.

       <b>SLURM_CLUSTER_NAME</b>    Name of the cluster on which the job is executing.

       <b>SLURM_CPU_BIND_LIST</b>   <b>--cpu-bind</b> map or mask list (list of Slurm CPU IDs or masks for this node, CPU_ID =
                             Board_ID  x  threads_per_board  +  Socket_ID  x  threads_per_socket  +  Core_ID   x
                             threads_per_core + Thread_ID).

       <b>SLURM_CPU_BIND_TYPE</b>   <b>--cpu-bind</b> type (none,rank,map_cpu:,mask_cpu:).

       <b>SLURM_CPU_BIND_VERBOSE</b>
                             <b>--cpu-bind</b> verbosity (quiet,verbose).

       <b>SLURM_CPU_FREQ_REQ</b>    Contains  the  value requested for cpu frequency on the srun command as a numerical
                             frequency in kilohertz, or a coded value for a request  of  <u>low</u>,  <u>medium</u>,<u>highm1</u>  or
                             <u>high</u>  for  the  frequency.   See  the  description  of the <b>--cpu-freq</b> option or the
                             <b>SLURM_CPU_FREQ_REQ</b> input environment variable.

       <b>SLURM_CPUS_ON_NODE</b>    Number of CPUs available to the step on this node.  <b>NOTE</b>: The <b>select/linear</b>  plugin
                             allocates  entire  nodes to jobs, so the value indicates the total count of CPUs on
                             the node.  For the <b>cons/tres</b> plugin, this number indicates the number  of  CPUs  on
                             this node allocated to the step.

       <b>SLURM_CPUS_PER_TASK</b>   Number  of  cpus requested per task.  Only set if either the <b>--cpus-per-task</b> option
                             or the <b>--tres-per-task=cpu=#</b> option is specified.

       <b>SLURM_DISTRIBUTION</b>    Distribution  type  for  the  allocated  jobs.  Set  the  distribution   with   <b>-m</b>,
                             <b>--distribution</b>.

       <b>SLURM_GPUS_ON_NODE</b>    Number of GPUs available to the step on this node.

       <b>SLURM_GTIDS</b>           Global task IDs running on this node.  Zero origin and comma separated.  It is read
                             internally by pmi if Slurm was built with pmi support. Leaving the variable set may
                             cause  problems  when using external packages from within the job (Abaqus and Ansys
                             have been known to  have  problems  when  it  is  set  -  consult  the  appropriate
                             documentation for 3rd party software).

       <b>SLURM_HET_SIZE</b>        Set to count of components in heterogeneous job.

       <b>SLURM_JOB_ACCOUNT</b>     Account name associated of the job allocation.

       <b>SLURM_JOB_CPUS_PER_NODE</b>
                             Count of CPUs available to the job on the nodes in the allocation, using the format
                             <u>CPU_count</u>[(x<u>number_of_nodes</u>)][,<u>CPU_count</u>  [(x<u>number_of_nodes</u>)]  ...].  For example:
                             SLURM_JOB_CPUS_PER_NODE='72(x2),36' indicates that on the first  and  second  nodes
                             (as  listed by SLURM_JOB_NODELIST) the allocation has 72 CPUs, while the third node
                             has 36 CPUs.  <b>NOTE</b>: The <b>select/linear</b> plugin allocates entire nodes to jobs, so the
                             value indicates the total count of CPUs on allocated  nodes.  The  <b>select/cons_tres</b>
                             plugin  allocates  individual  CPUs to jobs, so this number indicates the number of
                             CPUs allocated to the job.

       <b>SLURM_JOB_DEPENDENCY</b>  Set to value of the <b>--dependency</b> option.

       <b>SLURM_JOB_END_TIME</b>    The UNIX timestamp for a job's projected end time.

       <b>SLURM_JOB_GPUS</b>        The global GPU IDs of the GPUs allocated to this job. The GPU IDs are not  relative
                             to  any  device cgroup, even if devices are constrained with task/cgroup.  Only set
                             in batch and interactive jobs.

       <b>SLURM_JOB_ID</b>          Job id of the executing job.

       <b>SLURM_JOB_LICENSES</b>    Name and count of any license(s) requested.

       <b>SLURM_JOB_NAME</b>        Set to the value of the <b>--job-name</b> option or the command name when srun is used  to
                             create  a  new  job allocation. Not set when srun is used only to create a job step
                             (i.e. within an existing job allocation).

       <b>SLURM_JOB_NODELIST</b>    List of nodes allocated to the job.

       <b>SLURM_JOB_NODES</b>       Total number of nodes in the job's resource allocation.

       <b>SLURM_JOB_PARTITION</b>   Name of the partition in which the job is running.

       <b>SLURM_JOB_QOS</b>         Quality Of Service (QOS) of the job allocation.

       <b>SLURM_JOB_RESERVATION</b> Advanced reservation containing the job allocation, if any.

       <b>SLURM_JOB_START_TIME</b>  The UNIX timestamp for a job's start time.

       <b>SLURM_JOBID</b>           Job  id  of  the  executing  job.  See   <b>SLURM_JOB_ID</b>.   Included   for   backwards
                             compatibility.

       <b>SLURM_LAUNCH_NODE_IPADDR</b>
                             IP  address  of  the  node from which the task launch was initiated (where the srun
                             command ran from).

       <b>SLURM_LOCALID</b>         Node local task ID for the process within a job.

       <b>SLURM_MEM_BIND_LIST</b>   <b>--mem-bind</b> map or mask list (&lt;list of IDs or masks for this node&gt;).

       <b>SLURM_MEM_BIND_PREFER</b> <b>--mem-bind</b> prefer (prefer).

       <b>SLURM_MEM_BIND_SORT</b>   Sort free cache pages (run zonesort on Intel KNL nodes).

       <b>SLURM_MEM_BIND_TYPE</b>   <b>--mem-bind</b> type (none,rank,map_mem:,mask_mem:).

       <b>SLURM_MEM_BIND_VERBOSE</b>
                             <b>--mem-bind</b> verbosity (quiet,verbose).

       <b>SLURM_NODEID</b>          The relative node ID of the current node.

       <b>SLURM_NPROCS</b>          Total number of processes in  the  current  job  or  job  step.  See  <b>SLURM_NTASKS</b>.
                             Included for backwards compatibility.

       <b>SLURM_NTASKS</b>          Total number of processes in the current job or job step.

       <b>SLURM_OVERCOMMIT</b>      Set to <b>1</b> if <b>--overcommit</b> was specified.

       <b>SLURM_PRIO_PROCESS</b>    The  scheduling priority (nice value) at the time of job submission.  This value is
                             propagated to the spawned processes.

       <b>SLURM_PROCID</b>          The MPI rank (or relative process ID) of the current process.

       <b>SLURM_SRUN_COMM_HOST</b>  IP address of srun communication host.

       <b>SLURM_SRUN_COMM_PORT</b>  srun communication port.

       <b>SLURM_CONTAINER</b>       OCI Bundle for job.  Only set if <b>--container</b> is specified.

       <b>SLURM_CONTAINER_ID</b>    OCI id for job.  Only set if <b>--container_id</b> is specified.

       <b>SLURM_SHARDS_ON_NODE</b>  Number of GPU Shards available to the step on this node.

       <b>SLURM_STEP_GPUS</b>       The global GPU IDs of  the  GPUs  allocated  to  this  step  (excluding  batch  and
                             interactive  steps).  The  GPU  IDs  are not relative to any device cgroup, even if
                             devices are constrained with task/cgroup.

       <b>SLURM_STEP_ID</b>         The step ID of the current job.

       <b>SLURM_STEP_LAUNCHER_PORT</b>
                             Step launcher port.

       <b>SLURM_STEP_NODELIST</b>   List of nodes allocated to the step.

       <b>SLURM_STEP_NUM_NODES</b>  Number of nodes allocated to the step.

       <b>SLURM_STEP_NUM_TASKS</b>  Number of processes in the job step or whole heterogeneous job step.

       <b>SLURM_STEP_TASKS_PER_NODE</b>
                             Number of processes per node within the step.

       <b>SLURM_STEPID</b>          The step  ID  of  the  current  job.  See  <b>SLURM_STEP_ID</b>.  Included  for  backwards
                             compatibility.

       <b>SLURM_SUBMIT_DIR</b>      The directory from which the allocation was invoked from.

       <b>SLURM_SUBMIT_HOST</b>     The hostname of the computer from which the allocation was invoked from.

       <b>SLURM_TASK_PID</b>        The process ID of the task being started.

       <b>SLURM_TASKS_PER_NODE</b>  Number of tasks to be initiated on each node. Values are comma separated and in the
                             same order as SLURM_JOB_NODELIST.  If two or more consecutive nodes are to have the
                             same  task  count,  that  count  is  followed by "(x#)" where "#" is the repetition
                             count. For example, "SLURM_TASKS_PER_NODE=2(x3),1" indicates that the  first  three
                             nodes will each execute two tasks and the fourth node will execute one task.

       <b>SLURM_TOPOLOGY_ADDR</b>   This  is set only if the system has the topology/tree plugin configured.  The value
                             will be set to the names network switches  which  may  be  involved  in  the  job's
                             communications  from  the  system's  top  level  switch down to the leaf switch and
                             ending with node name. A period is used to separate each hardware component name.

       <b>SLURM_TOPOLOGY_ADDR_PATTERN</b>
                             This is set only if the system has the topology/tree plugin configured.  The  value
                             will  be set component types listed in <b>SLURM_TOPOLOGY_ADDR</b>.  Each component will be
                             identified as either "switch" or  "node".   A  period  is  used  to  separate  each
                             hardware component type.

       <b>SLURM_TRES_PER_TASK</b>   Set  to  the  value  of  <b>--tres-per-task</b>.  If <b>--cpus-per-task</b> or <b>--gpus-per-task</b> is
                             specified, it is also set  in  <b>SLURM_TRES_PER_TASK</b>  as  if  it  were  specified  in
                             <b>--tres-per-task</b>.

       <b>SLURM_UMASK</b>           The <u>umask</u> in effect when the job was submitted.

       <b>SLURMD_NODENAME</b>       Name  of  the  node  running  the  task. In the case of a parallel job executing on
                             multiple compute nodes, the various tasks will have this environment  variable  set
                             to different values on each compute node.

       <b>SRUN_DEBUG</b>            Set  to  the  logging  level of the <b>srun</b> command.  Default value is 3 (info level).
                             The value is incremented or  decremented  based  upon  the  <b>--verbose</b>  and  <b>--quiet</b>
                             options.

</pre><h4><b>SIGNALS</b> <b>AND</b> <b>ESCAPE</b> <b>SEQUENCES</b></h4><pre>
       Signals  sent  to  the <b>srun</b> command are automatically forwarded to the tasks it is controlling with a few
       exceptions. The escape sequence <b>&lt;control-c&gt;</b> will report the state of all tasks associated with  the  <b>srun</b>
       command.  If  <b>&lt;control-c&gt;</b>  is  entered twice within one second, then the associated SIGINT signal will be
       sent to all tasks and a termination sequence will be entered sending SIGCONT, SIGTERM, and SIGKILL to all
       spawned tasks.  If a third <b>&lt;control-c&gt;</b> is received, the srun program will be terminated  without  waiting
       for remote tasks to exit or their I/O to complete.

       The escape sequence <b>&lt;control-z&gt;</b> is presently ignored.

</pre><h4><b>MPI</b> <b>SUPPORT</b></h4><pre>
       MPI  use  depends  upon  the  type  of  MPI being used.  There are three fundamentally different modes of
       operation used by these various MPI implementations.

       1. Slurm directly launches the tasks and performs initialization of communications through  the  PMI2  or
       PMIx APIs.  For example: "srun -n16 a.out".

       2.  Slurm  creates  a  resource  allocation  for  the  job  and  then mpirun launches tasks using Slurm's
       infrastructure (OpenMPI).

       3. Slurm creates a resource allocation for the job and then mpirun launches tasks  using  some  mechanism
       other  than  Slurm,  such  as  SSH  or  RSH.   These tasks are initiated outside of Slurm's monitoring or
       control. Slurm's epilog should  be  configured  to  purge  these  tasks  when  the  job's  allocation  is
       relinquished, or the use of pam_slurm_adopt is highly recommended.

       See   <u>https://slurm.schedmd.com/mpi_guide.html</u>   for  more  information  on  use  of  these  various  MPI
       implementations with Slurm.

</pre><h4><b>MULTIPLE</b> <b>PROGRAM</b> <b>CONFIGURATION</b></h4><pre>
       Comments in the configuration file must have a "#" in column one.  The configuration  file  contains  the
       following fields separated by white space:

       Task rank
              One or more task ranks to use this configuration.  Multiple values may be comma separated.  Ranges
              may  be  indicated with two numbers separated with a '-' with the smaller number first (e.g. "0-4"
              and not "4-0").  To indicate all tasks not otherwise specified, specify a rank of '*' as the  last
              line  of  the  file.   If an attempt is made to initiate a task for which no executable program is
              defined, the following error message will be produced "No executable program  specified  for  this
              task".

       Executable
              The name of the program to execute.  May be fully qualified pathname if desired.

       Arguments
              Program  arguments.   The expression "%t" will be replaced with the task's number.  The expression
              "%o" will be replaced with the task's offset within this range (e.g. a configured task rank  value
              of  "1-5"  would  have  offset  values  of  "0-4").  Single quotes may be used to avoid having the
              enclosed values interpreted.  This field is optional.  Any arguments for the  program  entered  on
              the command line will be added to the arguments specified in the configuration file.

       For example:

       $ cat silly.conf
       ###################################################################
       # srun multiple program configuration file
       #
       # srun -n8 -l --multi-prog silly.conf
       ###################################################################
       4-6       hostname
       1,7       echo  task:%t
       0,2-3     echo  offset:%o

       $ srun -n8 -l --multi-prog silly.conf
       0: offset:0
       1: task:1
       2: offset:1
       3: offset:2
       4: linux15.llnl.gov
       5: linux16.llnl.gov
       6: linux17.llnl.gov
       7: task:7

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>Example</b> <b>1:</b>
              This  simple  example  demonstrates the execution of the command <b>hostname</b> in eight tasks. At least
              eight processors will be allocated to the job (the same as the task count) on however  many  nodes
              are  required  to  satisfy  the  request.  The output of each task will be proceeded with its task
              number.  (The machine "dev" in the example below has a total of two CPUs per node)

              $ srun -n8 -l hostname
              0: dev0
              1: dev0
              2: dev1
              3: dev1
              4: dev2
              5: dev2
              6: dev3
              7: dev3

       <b>Example</b> <b>2:</b>
              The srun <b>-r</b> option is used within a job script to run two job  steps  on  disjoint  nodes  in  the
              following example. The script is run using allocate mode instead of as a batch job in this case.

              $ cat test.sh
              #!<a href="file:/bin/sh">/bin/sh</a>
              echo $SLURM_JOB_NODELIST
              srun -lN2 -r2 hostname
              srun -lN2 hostname

              $ salloc -N4 test.sh
              dev[7-10]
              0: dev9
              1: dev10
              0: dev7
              1: dev8

       <b>Example</b> <b>3:</b>
              The following script runs two job steps in parallel within an allocated set of nodes.

              $ cat test.sh
              #!<a href="file:/bin/bash">/bin/bash</a>
              srun -lN2 -n4 -r 2 sleep 60 &amp;
              srun -lN2 -r 0 sleep 60 &amp;
              sleep 1
              squeue
              squeue -s
              wait

              $ salloc -N4 test.sh
                JOBID PARTITION     NAME     USER  ST      TIME  NODES NODELIST
                65641     batch  test.sh   grondo   R      0:01      4 dev[7-10]

              STEPID     PARTITION     USER      TIME NODELIST
              65641.0        batch   grondo      0:01 dev[7-8]
              65641.1        batch   grondo      0:01 dev[9-10]

       <b>Example</b> <b>4:</b>
              This  example  demonstrates  how  one  executes  a simple MPI job.  We use <b>srun</b> to build a list of
              machines (nodes) to be used by <b>mpirun</b> in its required format. A sample command line and the script
              to be executed follow.

              $ cat test.sh
              #!<a href="file:/bin/sh">/bin/sh</a>
              MACHINEFILE="nodes.$SLURM_JOB_ID"

              # Generate Machinefile for mpi such that hosts are in the same
              #  order as if run via srun
              #
              srun -l <a href="file:/bin/hostname">/bin/hostname</a> | sort -n | awk '{print $2}' &gt; $MACHINEFILE

              # Run using generated Machine file:
              mpirun -np $SLURM_NTASKS -machinefile $MACHINEFILE mpi-app

              rm $MACHINEFILE

              $ salloc -N2 -n4 test.sh

       <b>Example</b> <b>5:</b>
              This simple example demonstrates the execution of different jobs on different nodes  in  the  same
              srun. You can do this for any number of nodes or any number of jobs. The executables are placed on
              the  nodes  sited  by the SLURM_NODEID env var. Starting at 0 and going to the number specified on
              the srun command line.

              $ cat test.sh
              case $SLURM_NODEID in
                  0) echo "I am running on "
                     hostname ;;
                  1) hostname
                     echo "is where I am running" ;;
              esac

              $ srun -N2 test.sh
              dev0
              is where I am running
              I am running on
              dev1

       <b>Example</b> <b>6:</b>
              This example demonstrates use of multi-core options to control layout of tasks.  We  request  that
              four sockets per node and two cores per socket be dedicated to the job.

              $ srun -N2 -B 4-4:2-2 a.out

       <b>Example</b> <b>7:</b>
              This  example  shows  a  script in which Slurm is used to provide resource management for a job by
              executing the various job steps as processors become available for their dedicated use.

              $ cat my.script
              #!<a href="file:/bin/bash">/bin/bash</a>
              srun -n4 prog1 &amp;
              srun -n3 prog2 &amp;
              srun -n1 prog3 &amp;
              srun -n1 prog4 &amp;
              wait

       <b>Example</b> <b>8:</b>
              This example shows how to launch an application called "server" with one task, 8 CPUs and 16 GB of
              memory (2 GB per CPU) plus another application called "client" with 16 tasks, 1 CPU per task  (the
              default) and 1 GB of memory per task.

              $ srun -n1 -c8 --mem-per-cpu=2gb server : -n16 --mem-per-cpu=1gb client

       <b>Example</b> <b>9:</b>
              This  example  highlights  the  difference in behavior with srun's <b>--exclusive</b> and <b>--overlap</b> flags
              when run from inside a job allocation. The <b>--overlap</b> flag allows both steps to start at  the  same
              time. The <b>--exclusive</b> flag makes the second step wait until the first has finished.

              $ salloc  -n1
              salloc: Granted job allocation 9553
              salloc: Waiting for resource configuration
              salloc: Nodes node01 are ready for job

              $ date +%T; srun -n1 --overlap -l sleep 3 &amp;
              $ srun -n1 --overlap -l date +%T &amp;
              14:36:04
              [1] 144341
              [2] 144342
              0: 14:36:04
              [2]+  Done                    srun -n1 --overlap -l date +%T
              [1]+  Done                    srun -n1 --overlap -l sleep 3

              $ date +%T; srun -n1 --exclusive -l sleep 3 &amp;
              $ srun -n1 --exclusive -l date +%T &amp;
              14:36:17
              [1] 144429
              [2] 144430
              srun: Job 9553 step creation temporarily disabled, retrying (Requested nodes are busy)
              srun: Step created for job 9553
              0: 14:36:20
              [1]-  Done                    srun -n1 --exclusive -l sleep 3
              [2]+  Done                    srun -n1 --exclusive -l date +%T

       <b>Example</b> <b>10:</b>
              This  example  demonstrates  how  jobs that are not evenly split among multiple nodes can run into
              problems of tasks not being able to start when there are enough CPUs free to run that  task  on  a
              single  node.  This  example  shows a job that was allocated 2 CPUs on one node and 24 CPUs on the
              other node.

              $ echo $SLURM_NODELIST; echo $SLURM_JOB_CPUS_PER_NODE
              node[01-02]
              2,24

              If a task is started that occupies the CPUs on the node with fewer CPUs, then  a  subsequent  task
              that  should be able to start on the other node will not start because it inherits the requirement
              for the number of nodes from the job allocation. The job step will stay pending  until  the  first
              job step completes or until it is cancelled.

              $ srun -n4 --exact sleep 1800 &amp;
              [1] 151837

              $ srun -n2 --exact hostname
              ^Csrun: Cancelled pending job step with signal 2
              srun: error: Unable to create step for job 2677: Job/step already completing or completed

              If the job step is started, explicitly requesting a single node, then the step is able to run.

              $ srun -n2 -N1 --exact hostname
              node02
              node02

              This  behavior can be changed by adding <b>SelectTypeParameters=CR_Pack_Nodes</b> to your slurm.conf. The
              logic to pack nodes will allow job steps to start on a single node without  having  to  explicitly
              request a single node.

       <b>Example</b> <b>11:</b>
              This  example  demonstrates  that  adding the <b>--exclusive</b> flag to job allocation requests can give
              different results based on whether you also request a certain number of tasks.

              Requesting exclusive access with no additional requirements will allow the process to  access  all
              the CPUs on the allocated node.
              $ srun -l --exclusive  bash -c 'grep Cpus_allowed_list <a href="file:/proc/self/status">/proc/self/status</a>'
              0: Cpus_allowed_list:   0-23

              Adding  a  request  for  a  certain  number of tasks will cause each task to only have access to a
              single CPU.
              $ srun -l --exclusive -n2 bash -c 'grep Cpus_allowed_list <a href="file:/proc/self/status">/proc/self/status</a>'
              0: Cpus_allowed_list:   0
              1: Cpus_allowed_list:   12

              You can define the number of CPUs per task if you want to give them access to more than one CPU.
              $ srun -l --exclusive -n2 --cpus-per-task=12 bash -c 'grep Cpus_allowed_list <a href="file:/proc/self/status">/proc/self/status</a>'
              0: Cpus_allowed_list:   0-5,12-17
              1: Cpus_allowed_list:   6-11,18-23

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2006-2007 The Regents of the University of  California.   Produced  at  Lawrence  Livermore
       National Laboratory (cf, DISCLAIMER).
       Copyright (C) 2008-2010 Lawrence Livermore National Security.
       Copyright (C) 2010-2022 SchedMD LLC.

       This    file    is    part    of    Slurm,   a   resource   management   program.    For   details,   see
       &lt;https://slurm.schedmd.com/&gt;.

       Slurm is free software; you can redistribute it and/or modify it under  the  terms  of  the  GNU  General
       Public License as published by the Free Software Foundation; either version 2 of the License, or (at your
       option) any later version.

       Slurm  is  distributed  in  the  hope  that it will be useful, but WITHOUT ANY WARRANTY; without even the
       implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE.  See  the  GNU  General  Public
       License for more details.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/salloc.1.html">salloc</a></b>(1),   <b><a href="../man1/sattach.1.html">sattach</a></b>(1),   <b><a href="../man1/sbatch.1.html">sbatch</a></b>(1),   <b><a href="../man1/sbcast.1.html">sbcast</a></b>(1),  <b><a href="../man1/scancel.1.html">scancel</a></b>(1),  <b><a href="../man1/scontrol.1.html">scontrol</a></b>(1),  <b><a href="../man1/squeue.1.html">squeue</a></b>(1),  <b><a href="../man5/slurm.conf.5.html">slurm.conf</a></b>(5),
       <b>sched_setaffinity</b> (2), <b>numa</b> (3) <b>getrlimit</b> (2)

December 2024                                    Slurm Commands                                          <u><a href="../man1/srun.1.html">srun</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>