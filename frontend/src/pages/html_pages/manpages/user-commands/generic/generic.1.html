<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>generic - generic preprocessor for IRAF</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/iraf-dev">iraf-dev_2.18.1~rc1-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       generic - generic preprocessor for IRAF

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>generic</b> [<u>options</u>] <u>files</u>...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The generic preprocessor is used to translate generic source code (code written to work for any datatype)
       into  type  dependent  source  code,  suitable for compilation and insertion into a library.  The generic
       source is translated for each datatype, producing a type dependent copy  of  the  source  code  for  each
       datatype.  There are two primary modes of operation:

       <b>[1]</b>    The  generic source is embedded in a normal file, bracketed by <u>$for</u> and <u>$endfor</u> directives.  There
              is one input file and one somewhat larger output file, with the generic code  in  the  input  file
              being replaced in the output file by several copies of the enclosed source, one for each datatype.
              This  mode  is  most commonly used for modules to be linked in their entirety into an applications
              package.  The <b>-o</b> parameter is used to specify the output filename.

       <b>[2]</b>    The entire input file is generic.  There may be multiple input files, and for each  input  file  N
              output  files  are  generated,  one for each datatype specified with the <b>-t</b> parameter.  The output
              filenames are automatically generated by appending the type character to the root filename of  the
              input file.  This mode is most commonly used for object libraries.

       The  generic  preprocessor  operates  by token replacement (currently using a UNIX <u>Lex</u> lexical analyzer).
       The input stream is broken up into a stream of tokens.  Each token is examined to see if  it  is  in  the
       following  list,  and  the  indicated  action is taken if the token is matched.  The generic preprocessor
       directives have the form "$NAME", where $ marks a <b>generic</b> directive, and where NAME is the  name  of  the
       directive.

       <b>PIXEL</b>  Replaced by the current type name, e.g., "int", "real", etc.

       <b>XPIXEL</b> Replaced  by  the  current  type name in upper case, preceded by an X, e.g., "XINT", "XREAL", etc.
              This is used for generic C procedures meant to be called from SPP or Fortran.

       <b>INDEF</b>  Replaced by the numeric constant denoting indefinite for the current datatype.

       <b>INDEF[SILRDX]</b>
              These strings are <u>not</u> replaced, since the "INDEF" in this case is not generic.

       <b>SZ_PIXEL</b>
              Replaced by "SZ_INT", "SZ_REAL", etc.

       <b>TY_PIXEL</b>
              Replaced by "TY_INT", "TY_REAL", etc.

       <b>$PIXEL</b> Replaced by the string "PIXEL".  This is used in doubly generic  sources,  where  the  first  pass
              translates $PIXEL to PIXEL, and the second to the actual type string.

       <b>$INDEF</b> Replaced by the string "INDEF".

       <b>$t</b>     Replaced by one of the characters [ubcsilrdx].

       <b>$T</b>     Replaced by one of the characters [UBCSILRDX].

       <b>$/.../</b> Replaced by the string "...", i.e., whatever is within the // delimiters.  Used to disable generic
              preprocessing of arbitrary text.

       <b>[0-9]+("$f"|"$F")</b>
              Replaced by the corresponding real or double constant.  For example, "1$f" translates as "1.0" for
              type real, but as "1.0D0" for type double.

       <b>$if</b> <b>(expression)</b>
              The  conditional preprocessing facility.  If the $IF tests false the code which follows is skipped
              over, and is not copied to the output file.  Control transfers to the matching  $ELSE  or  $ENDIF.
              The following may be used in the boolean expression:

              "datatype"      denotes the current type
              ubcsilrdx       any subset of these characters
                                denotes the corresponding datatype
              sizeof()        the size of the specified type,
                                e.g., for comparisons
              != ==           the relational operators
               &gt;  &lt;  &gt;= &lt;=

              Examples:

                      $if (datatype != dx)
                          (code to be compiled if type not d or x)

                      $if (sizeof(i) &lt;= sizeof(r))
                          (code to be compiled if size int &lt;= real)

              $IF constructs may be nested.  The directive may appear anywhere on a line.

       <b>$else</b>  Marks the else clause of a $IF.

       <b>$endif</b> Marks the end of a $IF.  One is required for every $IF.

       <b>$for</b> <b>(types)</b>
              For  each  of  the  listed  types,  output  a translated copy of the code between the $FOR and the
              matching $ENDFOR.  Nesting is permitted.

              Example:
                      $for (silrd)
                      (any amount of generic code)
                      $endfor

       <b>$endfor</b>
              Marks the end of a $FOR statement.

       <b>$$</b>     Replaced by a single $.

       <b>/*...*/</b>
              C comments are not preprocessed.

       <b>...</b>    Quoted strings are not preprocessed.

       <b>#...(EOL)</b>
              SPP comments are not preprocessed.

       <b>%...(EOL)</b>
              SPP Fortran escapes are not preprocessed.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-k</b>     Allow the output files generated by <b>generic</b> to clobber any existing files.

       <b>-o</b> <b>ofile</b>
              The name of the output file.  If this option is selected, only a single file can be processed.

       <b>-p</b> <b>prefix</b>
              A prefix to be prepended to the output filenames.  This is useful when the output files are to  be
              placed in a different directory.

       <b>-t</b> <b>types</b>
              The  datatypes  for  which  output  is  desired.   One output file will be generated for each type
              specified, with <b>generic</b> automatically  generating  the  output  filename  by  appending  the  type
              character to the root filename of the input file.  The <u>types</u> string is some subset of [ubscilrdx],
              where the type characters are as follows:

              u - C unsigned short
              b - C byte (char)
              c - SPP character
              s - SPP short
              i - SPP int
              l - SPP long
              r - SPP real
              d - SPP double
              x - SPP complex

              This  option cannot be used in combination with the <b>-o</b> option, and should not be used when generic
              code is expanded inline, rather than written into multiple output files.

       <u>files</u>  The input file or files to be processed.  Generic input files should have the extension  ".gx"  or
              ".gc",  although  this is not required.  Only a single input file can be given if the <b>-o</b> option is
              specified.

</pre><h4><b>EXAMPLES</b></h4><pre>
       1. Translate the generic source "aadd.gx" to produce the six output files "aadds.x", "aaddi.x", etc.,  in
       the  subdirectory  "ak",  clobbering any existing files therein.  The <b>generic</b> task is a bootstrap utility
       written in C and is implemented as a CL foreign task, hence the UNIX command syntax.

               cl&gt; generic -k -p ak/ -t silrdx aadd.gx

       2. Perform an inline transformation ($FOR directive) of the source file "imsum.gx", producing the  single
       file "imsum.x" as output.

               cl&gt; generic -k -o imsum.x imsum.gx

       3.  The following is a simple example of a typical generic source file.  For additional examples, see the
       ".gx" sources in the VOPS, IMIO, IMAGES and other directories.

       # ALIM -- Compute the limits (minimum and maximum values)
       #         of a vector.
       # (this is a copy of the file vops$alim.gx).

       procedure alim$t (a, npix, minval, maxval)

       PIXEL   a[ARB], minval, maxval, value
       int     npix, i

       begin
               minval = a[1]
               maxval = a[1]

               do i = 1, npix {
                   value = a[i]
                   $if (datatype == x)
                       if (abs(value) &lt; <a href="../manminval/abs.minval.html">abs</a>(minval))
                           minval = value
                       else if (abs(value) &gt; <a href="../manmaxval/abs.maxval.html">abs</a>(maxval))
                           maxval = value
                   $else
                       if (value &lt; minval)
                           minval = value
                       else if (value &gt; maxval)
                           maxval = value
                   $endif
               }
       end

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/xc.1.html">xc</a></b>(1), <b><a href="../man1/xyacc.1.html">xyacc</a></b>(1).

</pre><h4><b>AUTHOR</b></h4><pre>
       This manual page was taken from the IRAF generic.hlp help file.

IRAF 2.17                                           June 2021                                         <u><a href="../man1/GENERIC.1.html">GENERIC</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>