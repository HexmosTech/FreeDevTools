<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>irsim - An event-driven logic-level simulator for MOS circuits</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/irsim">irsim_9.7.104-1.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       irsim - An event-driven logic-level simulator for MOS circuits

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>irsim</b> <u>[-s]</u> <u>prm_file</u> <u>sim_file</u> <u>...</u> <u>[+hist_file]</u> <u>[-cmd_file</u> <u>...]</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       IRSIM  is  an  event-driven  logic-level  simulator  for  MOS  (both  N  and P) transistor circuits.  Two
       simulation models are available:

       <b>switch</b> Each transistor is modeled as a voltage-controlled switch.  Useful for initializing or determining
              the functionality of the network.

       <b>linear</b> Each transistor is modeled as a resistor in series with a voltage-controlled switch; each node has
              a capacitance.  Node values and transition times are computed from the resulting RC network, using
              Chorng-Yeoung Chu's model.  Chris Terman's original model is not supported any more.

       If the <b>-s</b> switch is specified, 2 or more transistors of the same type connected in series, with no  other
       connections to their common source/drain will be <u>stacked</u> into a compound transistor with multiple gates.

       The  <b>prm_file</b>  is  the electrical parameters file that configure the devices to be simulated.  It defines
       the  capacitance  of  the  various  layers,  transistor  resistances,  threshold  voltages,  etc...  (see
       <a href="../man1/presim.1.html">presim</a>(1)).
       If <u>prm_file</u> does not specify an absolute path then IRSIM will search for the <u>prm_file</u> as follows (in that
       order):

            1) <u>./&lt;prm_file&gt;</u> (in the current directory).
            2) <b>${CAD_ROOT}/irsim/</b><u>&lt;prm_file&gt;</u>
            3) <b>${CAD_ROOT}/irsim/</b><u>&lt;prm_file&gt;</u><b>.prm</b>

       The  default  search  directory  (nominally  <a href="file:/usr/local/lib">/usr/local/lib</a>) can be overridden by setting the environment
       variable CAD_ROOT to the appropriate directory prior to running IRSIM (i.e. setenv CAD_ROOT /cad/lib).

       IRSIM first processes the files named on the command line, then (assuming the exit command has  not  been
       processed) accepts commands from the user, executing each command before reading the next.

       File names NOT beginning with a '-' are assumed to be sim files (see <a href="../man5/sim.5.html">sim</a>(5)), note that this version does
       not require to run the sim files through presim.  These files are read and added to the network database.
       There  is  only  a  single name space for nodes, so references to node "A" in different network files all
       refer to the same node.  While this feature allows one to modularize a large circuit into several network
       files, care must be taken to ensure that no unwanted node merges happen due to an  unfortunate  clash  in
       names.

       File names prefaced with a '-' are assumed to be command files: text files which contain command lines to
       be  processed  in  the  normal  fashion.   These files are processed line by line; when an end-of-file is
       encountered, processing continues with the next file. After all the command files  have  been  processed,
       and  if  an "exit" command has not terminated the simulation run, IRSIM will accept further commands from
       the user, prompting for each one like so:

       <b>irsim&gt;</b>

       The <b>hist_file</b> is the name of a file created with the <u>dumph</u> command (see below).  If it is present,  IRSIM
       will  initialize  the  network  to  the  state  saved in that file.  This file is different from the ones
       created with the "&gt;" command since it saves the state of every node for all times, including any  pending
       events.

       This  version  supports  changes  to  the  network  through  the <b>update</b> command.  Also, the capability to
       incrementally re-simulate the network up to the current time is provided by the <b>isim</b> command.

</pre><h4><b>COMMAND</b> <b>SUMMARY</b></h4><pre>
          <b>@</b> <u>filename</u>            take commands from command file
          <b>?</b> <u>wnode...</u>            print info about node's source/drain connections
          <b>!</b> <u>wnode...</u>            print info about node's gate connections
          <b>&lt;</b> <u>filename</u>            restore network state from file
          <b>&gt;</b> <u>filename</u>            write current network state to file
          <b>&lt;&lt;</b> <u>filename</u>           same as "&lt;" but restores inputs too
          <b>|</b> <u>comment...</u>          comment line
          <b>activity</b> <u>from</u> <u>[to]</u>    graph circuit activity in time interval
          <b>ana</b> <u>wnode...</u>          display nodes in analyzer window
          <b>analyzer</b> <u>wnode...</u>     display nodes in analyzer window
          <b>assert</b> <u>wnode</u> <u>[m]</u> <u>val</u>  assert that <u>wnode</u> equals <u>value</u>
          <b>assertWhen</b> <b>nodeT</b> <b>valT</b> <b>node</b> <b>val</b>
                                assert when a condition is met
          <b>back</b> <u>[time]</u>           move back to <u>time</u>
          <b>c</b> <u>[n]</u>                 simulate for <u>n</u> clock cycles (default:1)
          <b>changes</b> <u>from</u> <u>[to]</u>     print nodes that changed in time interval
          <b>clock</b> <u>[node</u> <u>[val]]</u>    define value sequence for clock node
          <b>clear</b>                 clear analyzer window (remove signals)
          <b>d</b> <u>[wnode]...</u>          print display list or specified node(s)
          <b>debug</b> <u>[debug_level...]</u>
                                set debug level (default: off)
          <b>decay</b> <u>[n]</u>             set charge decay time (0 =&gt; no decay)
          <b>display</b> <u>[arg]...</u>      control what gets displayed when
          <b>dumph</b> <u>filename...</u>     write net history to file
          <b>hist</b> <b>[on|off]</b>         turn history on or off
          <b>exit</b> <u>[status]</u>         return to system
          <b>flush</b> <u>[time]</u>          flush out history up to <u>time</u> (default: now)
          <b>h</b> <u>wnode...</u>            make node logic high (1) input
          <b>has_coords</b>            print YES if transistor coordinates are available
          <b>inputs</b>                print current list of input nodes
          <b>ires</b> <u>[n]</u>              set incremental resolution to <u>n</u> ns
          <b>isim</b> <u>[filename]</u>       incrementally resimulate changes form <u>filename</u>
          <b>l</b> <u>wnode...</u>            make node logic low (0) input
          <b>logfile</b> <u>[filename]</u>    start/stop log file
          <b>model</b> <u>[name]</u>          set simulation model to <u>name</u>
          <b>p</b>                     step clock one simulation step (phase)
          <b>path</b> <u>wnode...</u>         display critical path for last transition of a node
          <b>powlogfile</b> <u>[filename]</u> start/stop power logfile
          <b>powtrace</b> <u>-[node]...</u>   start/stop power tracing  of specified node(s)/vector(s)
          <b>powstep</b>               toggle the display of power estimate for each timestep
          <b>print</b> <u>comment...</u>      print specified text
          <b>printp</b>                print a list of all pending events
          <b>printx</b>                print all undefined (X) nodes
          <b>q</b>                     terminate input from current stream
          <b>R</b> <u>[n]</u>                 simulate for <u>n</u> cycles (default:longest sequence)
          <b>readh</b> <u>filename</u>        read history from <u>filename</u>
          <b>report</b><u>[level]</u>         set/reset reporting of decay events
          <b>s</b> <u>[n]</u>                 simulate for <u>n</u> ns. (default: stepsize)
          <b>stepsize</b> <u>[n]</u>          set simulation step size to <u>n</u> ns.
          <b>set</b> <u>vector</u> <u>value</u>      assign <u>value</u> to <u>vector</u>
          <b>setlog</b><u>[file|off]</u>      log net changes to file (<u>off</u> -&gt; no log)
          <b>setpath</b> <u>[path...]</u>     set search path for cmd files
          <b>stats</b>                 print event statistics
          <b>sumcap</b>                print out the sum of the capacitance of all nodes
          <b>t</b> <u>[-]wnode...</u>         start/stop tracing of specified nodes
          <b>tcap</b>                  print list of shorted transistors
          <b>time</b> <u>[command]</u>        print resource utilization summary
          <b>until</b> <b>wnode</b> <b>[mask]</b> <b>value</b> <b>count</b>
                                delayed assert based on the clock count.
          <b>u</b> <u>wnode...</u>            make node undefined (X) input
          <b>unitdelay</b> <u>[n]</u>         force transitions to take <u>n</u> ns. (0 disables)
          <b>update</b> <u>filename</u>       read net changes from file
          <b>V</b> <u>[node</u> <u>[value...]]</u>   define sequence of inputs for a node
          <b>vector</b> <u>label</u> <u>node...</u>  define bit vector
          <b>vsupply</b> <u>voltage</u>       set supply voltage for calculating power (default 5V)
          <b>w</b> <u>[-]wnode...</u>         add/delete nodes from display list
          <b>wnet</b> <u>[filename]</u>       write network to file
          <b>x</b> <u>wnode...</u>            remove node from input lists
          <b>Xdisplay</b> <u>[host:n]</u>     set/show X display (for analyzer)

       COMMAND DESCRIPTIONS

       Commands have the following simple syntax:

       <b>cmd</b> <u>arg1</u> <u>arg2</u> <u>...</u> <u>argn</u> <b>&lt;newline&gt;</b>

       where <b>cmd</b> specifies the command to be performed  and  the  <u>argi</u>  are  arguments  to  that  command.   The
       arguments are separated by spaces (or tabs) and the command is terminated by a <b>&lt;newline&gt;.</b>

       If <b>cmd</b> is not one of the built-in commands documented below, IRSIM appends ".cmd" to the command name and
       tries  to open that file as a command file (see "<b>@</b>" command).  Thus the command "foo" has the same effect
       as "<b>@</b> foo.cmd".

       Notation:

       <b>...</b>    indicates zero or more repetitions

       <b>[</b> <b>]</b>    enclosed arguments are optional

       <b>node</b>   name of node or vector in network

       <b>wnode</b>  name of node or vector in network, can include <b>'*'</b> wildcard which matches any sequence of zero  or
              more  characters.  The pair of characters <b>'{'</b> and <b>'}'</b> denote iteration over the limits enclosed by
              it, for example: <b>name{1:10}</b> will expand into <u>name1,</u> <u>name2</u> <u>...</u> <u>name10.</u>   A  3rd  optional  argument
              sets the stride, for example: <b>name{1:10:2}</b> will expand into <u>name1,</u> <u>name3,</u> <u>...</u> <u>name7,</u> <u>name9.</u>

       <b>|</b> <b>comment...</b>
              Lines  beginning  with  vertical bar are treated as comments and ignored -- useful for comments or
              temporarily disabling certain commands in a command file.

       Most commands take one or more node names as arguments.  Whenever a node name is acceptable in a  command
       line,  one can also use the name of a bit vector.  In this case, the command will be applied to each node
       of the vector (the "<b>t</b>" and "<b>d</b>" treat vectors specially, see below).

       <b>vector</b> <u>label</u> <u>node...</u>
              Define a bit vector named "label" which includes the specified  nodes.   If  you  redefine  a  bit
              vector,  any  special  attributes of the old vector (e.g., being on the display or trace list) are
              lost.  Wild cards are not accepted in the list of node names since you would have no control  over
              the order in which matching nodes would appear in the vector.

       The  simulator  performs  most  commands  silently.   To  find out what's happened you can use one of the
       following commands to examine the state of the network and/or the simulator.

       <b>set</b> <u>vector</u> <u>value</u>
              Assign <u>value</u> to <u>vector.</u>  For example, the following sequence of commands:

                   <b>vector</b> BUS bit.1 bit.2 bit.3
                   <b>set</b> BUS 01x

              The first command will define <u>BUS</u> to be a vector composed of nodes <u>bit.1,</u> <u>bit.2,</u> and  <u>bit.3.</u>   The
              second command will assign the following values:

                 bit.1 = 0
                 bit.2 = 1
                 bit.3 = X

              Value  can  be any sequence of [0,1,h,H,l,L,x,X], and must be of the same length as the bit vector
              itself.

       <b>d</b> <u>[wnode]...</u>
              Display.  Without arguments displays the values all nodes and bit vectors currently on the display
              list (see <b>w</b> command).  With arguments, only displays the nodes or bit vectors specified.  See also
              the "display" command if you wish to have the display list printed out automatically at the end of
              certain simulation commands.

       <b>w</b> <u>[-]wnode...</u>
              Watch/unwatch one or more nodes.  Whenever  a  "<b>d</b>"  command  is  given,  each  watched  node  will
              displayed like so:

              <b>node1=0</b> <b>node2=X</b> <b>...</b>

              To  remove  a  node from the watched list, preface its name with a '-'.  If <u>wnode</u> is the name of a
              bit vector, the values of the nodes which make up the vector will be displayed as follows:

              <b>label=010100</b>

              where the first 0 is the value of first node in the list, the first 1  the  value  of  the  second
              node, etc.

       <b>assert</b> <u>wnode</u> <u>[mask]</u> <u>value</u>
              Assert  that  the boolean value of the node or vector <u>wnode</u> is <u>value</u>.  If the comparison fails, an
              error message is printed.  If <u>mask</u> is given then only those bits corresponding  to  zero  bits  in
              <u>mask</u>  take  part  in the comparison, any character other than 0 will skip that bit.  The format of
              the error message is the following:

                 (tty, 3): assertion failed on 'name' 10X10 (1010X)

              Where <u>name</u> is the name of the vector, followed by the actual value and the expected value enclosed
              in parenthesis.  If a <u>mask</u> is specified, then bits that were not compared are printed as '-'.

       <b>until</b> <b>wnode</b> <b>[mask]</b> <b>value</b> <b>count</b>
              Acts just like the assert command except it requires an additional argument &lt;count&gt; which  is  the
              max  number  of clock cycles to run. Instead of just testing the current state, like assert, until
              tests for true and if false it runs clock cycles until condition becomes true or count runs out.

       <b>ana</b> <u>wnode...</u>
              This is a shorthand for the <b>analyzer</b> command (described below).

       <b>analyzer</b> <u>wnode...</u>
              Add the specified node(s)/vector(s) to the analyzer display  list  (see  <a href="../man3/irsim-analyzer.3.html">irsim-analyzer</a>(3)  for  a
              detailed  explanation).   If  the  analyzer  window  does  not  exist,  it will be created.  If no
              arguments are given and the analyzer window already exists, nothing happens.

       <b>Xdisplay</b> <u>[host:display]</u>
              You must be able to connect to an X-server to start the analyzer.   If  you  haven't  set  up  the
              <b>DISPLAY</b>  environment variable properly, the analyzer command may fail. If this is the case you can
              use the <b>Xdisplay</b> command to set it from within the simulator.  With no arguments, the name of  the
              current X-server will be printed.

       <b>clear</b>  Removes  all  nodes  and vectors from the analyzer window.  This command is most useful in command
              scripts for switching between different signals being displayed on the analyzer.

       "<b>?</b>" and "<b>!</b>" allow the user to go both backwards and forwards through  the  network.   This  is  a  useful
       debugging aid.

       <b>?</b> <u>wnode...</u>
              Prints  a  synopsis  of  the  named  nodes  including  their  current  values and the state of all
              transistors that affect the value of these nodes.  This  is  the  most  common  way  of  wandering
              through the network in search of what went wrong.
              The output from the command <u>?</u> <u>out</u> looks like

              out=0 (vl=0.3 vh=0.8) (0.100 pf) is computed from:
              n-channel phi2=0 out=0 in=0 [1.0e+04, 1.3e+04, 8.7e+03]
              pulled down by (a=1 b=1)  [1.0e+04, 1.3e+04, 8.8e+03]
              pulled up [4.0e+04, 7.4e+04, 4.0e+04]

              The  first  line gives the node's name and current value, its low and high logic thresholds, user-
              specifed low-to-high and high-to-low  propagation  delays  if  present,  and  its  capacitance  if
              nonzero.   Succeeding  lines list the transistor whose sources or drains connect to this node: the
              transistor type ("pulled down" is an n-channel transistor connected  to  gnd,  "pulled  up"  is  a
              depletion  pullup  or  p-channel transistor connected to vdd), the values of the gate, source, and
              drain nodes, and the modeling resistances.  Simple chains of transistors  with  the  same  implant
              type  are  collapsed  by  the  <u>-s</u> option into a single transistor with a "compound" gate; compound
              gates appear as a parenthesized list of  nodes  (e.g.,  the  pulldown  shown  above).   The  three
              resistance values -- static, dynamic high, dynamic low -- are given in Kilo-ohms.

              Finally, any pending events for a node are listed after the electrical information.

       <b>!</b> <u>wnode...</u>
              For each node in the argument list, print a list of transistors controlled by that node.

       <b>tcap</b>
              Prints  a  list  of all transistors with their source/drain shorted together or whose source/drain
              are connected to the power supplies.  These transistors will have  no  effect  on  the  simulation
              other  than their gate capacitance load.  Although transistors connected across the power supplies
              are real design errors, the simulator does not complain about them.

       Any node can be made an input -- the simulator will  not  change  an  input  node's  value  until  it  is
       released.   Usually  on  specific  nodes  --  inputs to the circuit -- are manipulated using the commands
       below, but you can fool with a subcircuit by forcing values on internal nodes just as easily.

       <b>h</b> <u>wnode...</u>
              Force each node on the argument list to be a high (1) input.  Overrides previous input commands if
              necessary.

       <b>l</b> <u>wnode...</u>
              Like "<b>h</b>" except forces nodes to be a low (0) input.

       <b>u</b> <u>wnode...</u>
              Like "<b>h</b>" except forces nodes to be a undefined (X) input.

       <b>x</b> <u>wnode...</u>
              Removes nodes from whatever input list they happen to  be  on.   The  next  simulation  step  will
              determine  the correct node value from the surrounding circuit.  This is the default state of most
              nodes.  Note that this does not force nodes to have an "X" value -- it simply  removes  them  from
              the input lists.

       <b>inputs</b> prints the high, low, and undefined input lists.

       It  is  possible  to  define a sequence of values for a node, and then cycle the circuit as many times as
       necessary to input each value and simulate the network.  A  similar  mechanism  is  used  to  define  the
       sequence of values each clock node goes through during a single cycle.

       Each value is a list of characters (with no intervening blanks) chosen from the following:

              1, h, H     logic high (1)
              0, l, L     logic low (0)
              u, U        undefined (X)
              x, X        remove node from input lists

       Presumably  the  length of the character list is the same as the size of the node/vector to which it will
       be assigned.  Blanks (spaces and tabs) are used to separate values in a sequence.  The sequence  is  used
       one  value at a time, left to right.  If more values are needed than supplied by the sequence, IRSIM just
       restarts the sequence again.

       <b>V</b> <u>[node</u> <u>[value...]]</u>
              Define a vector of inputs for a node.  After each cycle of an "R" command, the node is set to  the
              next value specified in the sequence.

              With no arguments, clears all input sequences (does not affect clock sequences however).  With one
              argument, "node", clears any input sequences for that node/vector.

       <b>clock</b> <u>[node</u> <u>[value...]]</u>
              Define  a phase of the clock.  Each cycle, each node specified by a clock command must run through
              its respective values.  For example,

                 clock phi1 1 0 0 0
                 clock phi2 0 0 1 0

              defines a simple 4-phase clock using nodes <u>phi1</u> and <u>phi2.</u>  Alternatively one could have issued the
              following commands:

                        vector clk phi1 phi2
                        clock clk 10 00 01 00

              With no arguments, clears all clock sequences.   With  one  argument,  "node",  clears  any  clock
              sequences for that node/vector.

       After  input  values  have  been established, their effect can be propagated through the network with the
       following commands.  The basic simulated time unit is 0.1ns; all event times  are  quantized  into  basic
       time  units.   A  simulation step continues until <u>stepsize</u> ns. have elapsed, and any events scheduled for
       that interval are processed.  It is possible to build circuits  which  oscillate  --  if  the  period  of
       oscillation  is  zero, the simulation command will not return.  If this seems to be the case, you can hit
       <b>&lt;ctrl-C&gt;</b> to return to the command interpreter.  Note that if you do this while input is being taken  from
       a  file,  the  simulator will bring you to the top level interpreter, aborting all pending input from any
       command files.

       When using the linear model (see the "<b>model</b>" command) transition times are estimated  using  an  RC  time
       constant calculated from the surrounding circuit.  When using the switch model, transitions are scheduled
       with unit delay.  These calculations can be overridden for a node by setting its tplh and tphl parameters
       which will then be used to determine the time for a transition.

       <b>s</b> <u>[n]</u>  Simulation  step.   Propagates  new  values  for  the  inputs  through the network, returns when <u>n</u>
              (default: <u>stepsize</u>) ns. have passed.  If <u>n</u> is specified, it will temporarily override the <u>stepsize</u>
              value.  Unlike previous versions, this value is NOT  remembered  as  the  default  value  for  the
              <u>stepsize</u>  parameter.   If the display mode is "automatic", the current display list is printed out
              on the completion of this command (see "display" command).

       <b>c</b> <u>[n]</u>  Cycle <u>n</u> times (default: 1) through the clock, as defined by the "<b>clock</b>" command.   Each  phase  of
              the  clock  lasts  <u>stepsize</u>  ns.   If the display mode is "<u>automatic</u>", the current display list is
              printed out on the completion of this command (see "<b>display</b>" command).

       <b>p</b>      Step the clock through one phase (or simulation step).  For example, if the clock  is  defined  as
              above

                 clock phi1   1 0 0 0
                 clock phi2   0 0 1 0

              then "<b>p</b>" will set phi1 to 1 and phi2 to 0, and then propagate the effects for one simulation step.
              The  next time "<b>p</b>" is issued, phi1 and phi2 will both be set to 0, and the effects propagated, and
              so on.  If the "<b>c</b>" command is issued after "<b>p</b>" has been used, the effect will be to  step  through
              the next 4 phases from where the "<b>p</b>" command left off.

       <b>R</b> <u>[n]</u>  Run  the  simulator  through  <u>n</u> cycles (see the "<b>c</b>" command).  If <u>n</u> is not present make the run as
              long as the longest sequence.  If display mode is automatic (see "<b>display</b>" command) the display is
              printed at the end of each cycle.  Each "<b>R</b>" command starts over at the beginning of  the  sequence
              defined for each node.

       <b>back</b> <u>time</u>
              Move  back  to  the  specified  time.  This command restores circuit state as of <u>time</u>, effectively
              undoing any changes in between.  Note that you can  not  move  past  any  previously  flushed  out
              history  (see  <b>flush</b> command below) as the history mechanism is used to restore the network state.
              This command can be useful to undo a mistake in the input vectors or to  re-simulate  the  circuit
              with a different debug level.

       <b>path</b> <u>wnode...</u>
              display  critical  path(s)  for  last  transition  of  the  specified  node(s).  The critical path
              transitions are reported using the following format:

                 <u>node</u> <b>-&gt;</b> <u>value</u> <b>@</b> <u>time</u> <b>(</b><u>delta</u><b>)</b>

              where <u>node</u> is the name of the node, <u>value</u> is the value to which the node transitioned, <u>time</u> is the
              time at which the transition occurred, and <u>delta</u> is the delay through  the  node  since  the  last
              transition.  For example:

                 critical path for last transition of Hit_v1:
                      phi1-&gt; 1 @ 2900.0ns , node was an input
                      PC_driver-&gt; 0 @ 2900.4ns    (0.4ns)
                      PC_b_q1-&gt; 1 @ 2904.0ns    (3.6ns)
                      tagDone_b_v1-&gt; 0 @ 2912.8ns    (8.8ns)
                      tagDone1_v1-&gt; 1 @ 2915.3ns    (2.5ns)
                      tagDone1_b_v1-&gt; 0 @ 2916.0ns    (0.7ns)
                      tagDone_v1-&gt; 1 @ 2918.4ns    (2.4ns)
                      tagCmp_b_v1-&gt; 0 @ 2922.1ns    (3.7ns)
                      tagCmp_v1-&gt; 1 @ 2923.0ns    (0.9ns)
                      Vbit_b_v1-&gt; 0 @ 2923.2ns    (0.2ns)
                      Hit_v1-&gt; 1 @ 2923.5ns    (0.3ns)

       <b>activity</b> <u>from_time</u> <u>[to_time]</u>
              print  histogram  showing amount of circuit activity in the specified time inteval.  Actually only
              shows number of nodes which had their most recent transition in the interval.

       <b>changes</b> <u>from_time</u> <u>[to_time]</u>
              print list of nodes which last changed value in the specified time interval.

       <b>printp</b> print list of all pending events sorted in time.  The node associated  with  each  event  and  the
              scheduled time is printed.

       <b>printx</b> print a list of all nodes with undefined (X) values.

       Using  the  trace command, it is possible to get more detail about what's happening to a particular node.
       Much of what is said below is described in much more detail in "Logic-level Simulation for VLSI Circuits"
       by Chris Terman, available from Kluwer Academic Press.  When a node is traced, the simulator reports each
       change in the node's value:

                   [event #100] node out.1: 0 -&gt; 1 @ 407.6ns

       The event index is incremented for each event that is processed.  The transition is reported as

            <u>old</u> <u>value</u> <b>-&gt;</b> <u>new</u> <u>value</u> <b>@</b> <u>report</u> <u>time</u>

       Note that since the time the event is processed may differ from the event's report time, the report  time
       for successive events may not be strictly increasing.

       Depending  on  the  debug  level  (see  the "<b>debug</b>" command) each calculation of a traced node's value is
       reported:

            [event #99] node clk: 0 -&gt; 1 @ 400.2ns
            final_value( Load )  V=[0.00, 0.04]  =&gt; 0
            ..compute_tau( Load )
            {Rmin=2.2K  Rdom=2.2K  Rmax=2.2K}  {Ca=0.06  Cd=0.17}
            tauA=0.1  tauD=0.4 ns
            [event #99: clk-&gt;1] transition for Load: 1 -&gt; 0 (tau=0.5ns, delay=0.6ns)

       In this example, a calculation for node <u>Load</u> is reported.  The calculation was  caused  by  event  99  in
       which node clk went to 1.  When using the linear model (as in this example) the report shows

            <u>current</u> <u>value</u> <b>-&gt;</b> <u>final</u> <u>value</u>

       The  second  line  displays  information  regarding the final value (or dc) analysis for node "Load"; the
       minimum and maximum voltages as well as the final logical value (0 in this case).

       The next three lines display timing analysis information used to estimate the delays.  The meaning of the
       variables displayed can be found Chu's thesis: "Improved Models for Switch-Level Simulation".

       When the <u>final</u> <u>value</u> is reported as "D", the node is not connected to an input and may  be  scheduled  to
       decay from its current value to X at some later time (see the "<b>decay</b><u>"</u> <u>command).</u>

       "tau"  is  the calculated transition time constant, "delta" is when any consequences of the event will be
       computed; the difference in the two times is how IRSIM accounts for the shape of the transition  waveform
       on  subsequent  stages  (see  reference  given  above  for more details).  The middle lines of the report
       indicate the Thevenin and capacitance parameters of the surrounding networks,  i.e.,  the  parameters  on
       which the transition calculations are based.

       <b>debug</b> <u>[ev</u> <u>dc</u> <u>tau</u> <u>taup</u> <u>tw</u> <u>spk][off][all]</u>
              Set  debugging  level.   Useful  for  debugging  simulator and/or circuit at various levels of the
              computation.  The meaning of the various debug levels is as follows:

              <b>ev</b>      display event enqueueing and dequeueing.

              <b>dc</b>      display dc calculation information.

              <b>tau</b>     display time constant (timing) calculation.

              <b>taup</b>    display second time constant (timing) calculation.

              <b>tw</b>      display network parameters for each stage of the tree walk, this applies to <b>dc,</b>  <b>tau</b>,  and
                      <b>taup</b>.  This level of debugging detail is usually needed only when debugging the simulator.

              <b>spk</b>     displays spike analysis information.

              <b>all</b>     This is a shorthand for specifying all of the above.

              <b>off</b>     This turns off all debugging information.

              If  a  debug  switch is on then during a simulation step, each time a watched node is encounted in
              some event, that fact is indicated to the user along with  some  event  info.   If  a  node  keeps
              appearing in this prinout, chances are that its value is oscillating.  Vice versa, if your circuit
              never  settles (ie., it oscillates) , you can use the "<b>debug</b>" and "<b>t</b>" commands to find the node(s)
              that are causing the problem.

              Without any arguments, the debug command prints the current debug level.

       <b>t</b> <u>[-]wnode...</u>
              set trace flag for node.  Enables the various printouts described above.  Prefacing the node  name
              with  '-'  clear  its  trace  flag.  If "wnode" is the name of a vector, whenever any node of that
              vector changes value, the current time and the values of all  traced  vectors  is  printed.   This
              feature is useful for watching the relative arrival times of values at nodes in an output vector.

       System interface commands:

       <b>&gt;</b> <u>filename</u>
              Write  current  state  of  each  node into specified file.  Useful for making a breakpoint in your
              simulation run.  Only stores values so isn't really useful to "dump" a run for  later  use,  i.e.,
              the current input lists, pending events, etc. are NOT saved in the state file.

       <b>&lt;</b> <u>filename</u>
              Read  from  specified  file, reinitializing the value of each node as directed.  Note that network
              must already exist and be identical to the network used to create  the  dump  file  with  the  "&gt;"
              command.   These  state  saving  commands  are  really  provided  so that complicated initializing
              sequences need only be simulated once.

       <b>&lt;&lt;</b> <u>filename</u>
              Same as "<b>&lt;</b>" command, except that this command will restore the <u>input</u> status of the nodes as  well.
              It does not, however, restore pending events.

       <b>dumph</b> <u>[filename]</u>
              Write  the  history of the simulation to the specified file, that is; all transitions since time =
              0.  The resulting file is a  machine-independent  binary  file,  and  contains  all  the  required
              information  to  continue  simulation  at  the  time  the dump takes place.  If the filename isn't
              specified, it will be constructed by taking the name of the sim_file (from the command  line)  and
              appending ".hist" to it.

       <b>readh</b> <u>filename</u>
              Read  the  specified  history-dump  file  into the current network.  This command will restore the
              state of the circuit to that of the dump file, overwriting the current state.

       <b>flush</b> <u>[time]</u>
              If memory consumption due to history maintanance becomes prohibitive, this command can be used  to
              free  the memory consumed by the history up to the time specified.  With no arguments, all history
              up to the current point in the simulation is freed.  Flushing out the history  may  invalidate  an
              incremental simulation and the portions flushed will no longer appear in the analyzer window.

       <b>setpath</b> <u>[path...]</u>
              Set  the  search-path  for command files.  <u>Path</u> should be a sequence of directories to be searched
              for ".cmd" files, "." meaning the current directory.  For eaxmple:

            <b>setpath</b> . /usr/me/rsim/cmds /cad/lib/cmds

              With no arguments, it will print the current search-path.  Initially this is just ".".

       <b>print</b> <u>text...</u>
              Simply prints the text on the user's console.  Useful for keeping user posted of progress  through
              a long command file.

       <b>logfile</b> <u>[filename]</u>
              Create  a  logfile  with the specified name, closing current log file if any; if no argument, just
              close current logfile.  All output which appears on user's console will  also  be  placed  in  the
              logfile.   Output  to  the  logfile is cleverly formatted so that logfiles themselves can serve as
              command files.

       <b>setlog</b> <u>[filename</u> <u>|</u> <u>off]</u>
              Record all net changes, as well as resulting error messages, to the specified file  (see  "<b>update</b>"
              command).   Net changes are always appended to the log-file, preceding each sequence of changes by
              the current date.  If the argument is <u>off</u> then net-changes will not be logged.  With no arguments,
              the name of the current log-file is printed.

              The default is to always record net changes; if no  filename  is  specified  (using  the  "<b>setlog</b>"
              command) the default filename <u>irsim_changes.log</u> will be used.  The log-files are formatted so that
              log-files may themselves be used as net-change files.

       <b>wnet</b> <u>[filename]</u>
              Write  the  current  network  to  the specified file.  If the filename isn't specified, it will be
              constructed by taking the name of the sim_file (from the command line) and  appending  ".inet"  to
              it.   The  resulting  file  can be used in a future simulation run, as if it were a sim file.  The
              file produced is a machine independent binary file, which is typically about 1/3 the size  of  the
              sim file and about 8 times faster to load.

       <b>time</b> <u>[command]</u>
              With  no argument, a summary of time used by the simulator is printed.  If arguments are given the
              specified command is timed and a time summary is printed when the command completes.   The  format
              of the time summary is <u>U</u><b>u</b> <u>S</u><b>s</b> <u>E</u> <u>P</u><b>%</b> <u>M</u><b>,</b> <b>where:</b>

            <u>U</u> =&gt; User time in seconds
            <u>S</u> =&gt; System time in seconds
            <u>E</u> =&gt; Elapsed time, minutes:seconds
            <u>P</u> =&gt; Percentage of CPU time (((U + S)/E) * 100)
            <u>M</u> =&gt; Median text, data, and stack size use

       <b>q</b>
              Terminate  current  input  stream.  If this is typed at top level, the simulator will exit back to
              the system; otherwise, input reverts to the previous input stream.

       <b>exit</b> <u>[n]</u>
              Exit to system, <u>n</u> is the reported status (default: 0).

       Simulator parameters are set with the following commands.  With no arguments, each of the commands simply
       prints the current value of the parameter.

       <b>decay</b> <u>[n]</u>
              Set decay parameter to <u>n</u> ns. (default: 0).  If non-zero, it tells the number of ns. it  takes  for
              charge  on  a  node to decay to X.  A value of 0 implies no decay at all.  You cannot specify this
              parameters separately for each node, but this turns  out  not  to  be  a  problem.   See  "<b>report</b>"
              command.

       <b>display</b> <u>[-][cmdfile][automatic]</u>
              set/reset the display modes, which are

              <b>cmdfile</b>     commands  executed  from  command  files  are displayed to user before executing.  The
                          default is <u>cmdfile</u> <u>=</u> <u>OFF.</u>

              <b>automatic</b>   print out current display list (see "<b>d</b>"  command)  after  completion  of  "<b>s</b>"  or  "<b>c</b>"
                          command.  The default is <u>automatic</u> <u>=</u> <u>ON.</u>

              Prefacing the previous commands with a "-" turns off that display option.

       <b>model</b> <u>[name]</u>
              Set simulation model to one of the following:

              <b>switch</b> Model  transistors  as voltage controlled switches.  This model uses interval logic levels,
                     without accounting for transistor resistances, so circuits with  fighting  transistors  may
                     not be accuratelly modelled.  Delays may not reflect the <u>true</u> speed of the circuit as well.

              <b>linear</b> Model  transistors  as  a  resistor in series with a voltage controlled switch.  This model
                     uses a single-time-constant computed from the resulting RC network  and  uses  a  two-time-
                     constant model to analyze charge sharing and spikes.

              The  default  is  the  <b>linear</b> model.  You can change the simulation model at any time -- even with
              events pending -- as only new calculations are affected.  Without arguments, this  command  prints
              the current model name.

       <b>report</b> <u>[level]</u>
              When  level is nonzero, report all nodes which are set to X because of charge decay, regardless on
              whether they are being traced.  Setting level to zero disables reporting, but not the decay itself
              (see "<b>decay</b>" command).

       <b>stepsize</b> <u>[n]</u>
              Specify duration of simulation step  or  clock  phase.   <u>n</u>  <u>is</u>  <u>specified</u>  in  ns.  (nanoseconds).
              Floating  point  numbers  with up to 1 digit past the decimal point are allowed.  Further decimals
              are truncated (i.e. 10.299 == 10.2).

       <b>unitdelay</b> <u>[n]</u>
              When nonzero, force all transitions to take <u>n</u> ns.  Setting the parameter  to  zero  disables  this
              feature.  The resolution is the same as for the "<b>stepsize</b>" command.

       <b>stats</b>  Print event statitistics, as follows:

                 changes = 26077
                 punts (cns) = 208 (34)
                 punts = 0.79%, cons_punted = 16.35%
                 nevents = 28012; evaluations = 27972

              Where  <u>changes</u>  is the total number of transitions recorded, <u>punts</u> is the number of punted events,
              <u>(cns)</u> is the number of consecutive punted events (a punted event that punted another event).   The
              penultimate line shows the percentage of punted events with respect to the total number of events,
              and  the percentage of consecutive punted events with respect to the number of punted events.  The
              last line shows the total number of events (nevents) and the number of net evaluations.

       Incremental simulation commands:

       <b>Irsim</b> supports incremental changes to the network and resimulation of the  resulting  network.   This  is
       done incrementally so that only the nodes affected by the changes, either directly or indirectly, are re-
       evaluated.

       <b>update</b> <u>filename</u>
              Read net-change tokens from the specified file.  The following net-change commands are available:

              <b>a</b>dd     type gate source drain length width [area]
              <b>d</b>elete  type gate source drain length width [area]
              <b>m</b>ove    type gate source drain length width [area] g s d
              <b>c</b>ap     node value
              <b>N</b>       node metal-area poly-area diff-area diff-perim
              <b>M</b>       node M2A M2P MA MP PA PP DA DP PDA PDP
              <b>t</b>hresh  node low high
              <b>D</b>elay   node tplh tphl

              For  a  detailed  dscription  of  this  file  see <a href="../man5/netchange.5.html">netchange</a>(5).  Note that this is an experimental
              interface and is likely to change in the future.

              Note that this command doesn't resimulate the circuit so that it  may  leave  the  network  in  an
              inconsistent state.  Usually this command will be followed by an <b>isim</b> command (see below), if that
              is  not  the  case  then it's up to the user to initialize the state of the circuit.  This command
              exists only for historical reasons and will  probably  disappear  in  the  future.   It's  use  is
              discouraged.

       <b>isim</b> <u>[filename]</u>
              Read net-change tokens from the specified file (see <a href="../man5/netchange.5.html">netchange</a>(5)) and incrementally resimulate the
              circuit up to the current simulation time (not supported yet).

       <b>ires</b> <u>n</u> The  incremental  algorithm keeps track of nodes deviating from their past behavior as recorded in
              the network history.  During resimulation, a node is considered to deviate  from  its  history  if
              it's  new  state  is found to be different within <u>n</u> ns of its previous state.  This command allows
              for changing the incremental resolution.  With no arguments, it will print the current resolution.
              The default resolution is 0 ns.

       <b>powlogfile</b> <u>[filename]</u>
              Opens <u>filename</u> for writing nodal transition reports. The format of the report is the same you  get
              when  you  trace a node normally.  With no arguments powlogfile just closes the opened logfile and
              prints out a power dissipation summary. Nodal transitions  in  inputs  are  <b>not</b>  included  in  the
              transition count.

       <b>powtrace</b> <u>[[-]node...]</u>
              The  syntax of this command is the same as the normal <b>t</b> (trace) command.  If you want to trace and
              report power dissipation for all the nodes just use powtrace *. Use powtrace <b>-node</b> if you want  to
              exclude some nodes.

       <b>powstep</b>
              Toggles  whether  dynamic  power  estimation  is  displayed  after each timestep. The ynamic power
              displayed will only be for the nodes that have been selected using the <b>powtrace</b> command.

       <b>vsupply</b> <u>voltage</u>
              Sets the <b>V</b> variable for use in the <b>P=CV^2/(2t)</b> expression where <b>C</b> is capacitance switched,  and  <b>t</b>
              is the timestep.  The default value for vsupply is 5.0 Volts.

       <b>sumcap</b> Gives a sum of <b>all</b> nodal capcitances, <b>not</b> just those selected with the <b>powtrace</b> command.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/presim.1.html">presim</a>(1) (now obsolete)
       <a href="../man1/rsim.1.html">rsim</a>(1)
       <a href="../man3/irsim-analyzer.3.html">irsim-analyzer</a>(3)
       <a href="../man5/sim.5.html">sim</a>(5)
       <a href="../man5/netchange.5.html">netchange</a>(5)

3rd Berkeley Distribution                                                                               <u><a href="../man1/IRSIM.1.html">IRSIM</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>