<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>podman-pod-clone - Create a copy of an existing pod</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/podman">podman_5.4.1+ds1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       podman-pod-clone - Create a copy of an existing pod

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>podman</b> <b>pod</b> <b>clone</b> [<u>options</u>] <u>pod</u> <u>name</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>podman</b>  <b>pod</b> <b>clone</b> creates a copy of a pod, recreating the identical config for the pod and for all of its
       containers. Users can modify the pods new name and select pod details within the infra container

</pre><h4><b>OPTIONS</b></h4><pre>
   <b>--blkio-weight=</b><u><b>weight</b></u>
       Block IO relative weight. The <u>weight</u> is a value between <b>10</b> and <b>1000</b>.

       This option is not supported on cgroups V1 rootless systems.

   <b>--blkio-weight-device=</b><u><b>device:weight</b></u>
       Block IO relative device weight.

   <b>--cgroup-parent=</b><u><b>path</b></u>
       Path to cgroups under which the cgroup for the pod is created. If the path is not absolute, the  path  is
       considered  to  be  relative  to the cgroups path of the init process. Cgroups are created if they do not
       already exist.

   <b>--cpu-shares,</b> <b>-c=</b><u><b>shares</b></u>
       CPU shares (relative weight).

       By default, all containers get the same proportion of CPU cycles. This  proportion  can  be  modified  by
       changing  the  container's  CPU  share  weighting  relative  to  the  combined  weight of all the running
       containers.  Default weight is <b>1024</b>.

       The proportion only applies when CPU-intensive processes are running.  When tasks in  one  container  are
       idle,  other containers can use the left-over CPU time. The actual amount of CPU time varies depending on
       the number of containers running on the system.

       For example, consider three containers, one has a cpu-share of 1024  and  two  others  have  a  cpu-share
       setting  of  512.  When processes in all three containers attempt to use 100% of CPU, the first container
       receives 50% of the total CPU time. If a fourth container is added with a cpu-share of  1024,  the  first
       container only gets 33% of the CPU. The remaining containers receive 16.5%, 16.5% and 33% of the CPU.

       On a multi-core system, the shares of CPU time are distributed over all CPU cores. Even if a container is
       limited to less than 100% of CPU time, it can use 100% of each individual CPU core.

       For  example,  consider  a system with more than three cores.  If the container <u>C0</u> is started with <b>--cpu-</b>
       <b>shares=512</b> running one process, and another container <u>C1</u> with <b>--cpu-shares=1024</b>  running  two  processes,
       this can result in the following division of CPU shares:

       ┌─────┬───────────┬─────┬──────────────┐
       │ <b>PID</b> │ <b>container</b> │ <b>CPU</b> │ <b>CPU</b> <b>share</b>    │
       ├─────┼───────────┼─────┼──────────────┤
       │ 100 │ C0        │ 0   │ 100% of CPU0 │
       ├─────┼───────────┼─────┼──────────────┤
       │ 101 │ C1        │ 1   │ 100% of CPU1 │
       ├─────┼───────────┼─────┼──────────────┤
       │ 102 │ C1        │ 2   │ 100% of CPU2 │
       └─────┴───────────┴─────┴──────────────┘

       On  some  systems,  changing the resource limits may not be allowed for non-root users. For more details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--cpus</b>
       Set  a number of CPUs for the pod that overrides the original pods CPU limits. If none are specified, the
       original pod's Nano CPUs are used.

   <b>--cpuset-cpus=</b><u><b>number</b></u>
       CPUs in which to allow execution. Can be specified as a comma-separated list (e.g. <b>0,1</b>), as a range (e.g.
       <b>0-3</b>), or any combination thereof (e.g. <b>0-3,7,11-15</b>).

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

       If none are specified, the original pod's CPUset is used.

   <b>--cpuset-mems=</b><u><b>nodes</b></u>
       Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.

       If there are four memory nodes on the system (0-3), use <b>--cpuset-mems=0,1</b> then processes in the container
       only uses memory from the first two memory nodes.

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--destroy</b>
       Remove the original pod that we are cloning once used to mimic the configuration.

   <b>--device=</b><u><b>host-device[:container-device][:permissions]</b></u>
       Add a host device to the pod. Optional <u>permissions</u> parameter can be used to specify device permissions by
       combining <b>r</b> for read, <b>w</b> for write, and <b>m</b> for <b><a href="../man2/mknod.2.html">mknod</a></b>(2).

       Example: <b>--device=/dev/sdc:/dev/xvdc:rwm</b>.

       Note: if <u>host-device</u> is a symbolic link then it is resolved first.  The pod only  stores  the  major  and
       minor numbers of the host device.

       Podman  may  load  kernel  modules required for using the specified device. The devices that Podman loads
       modules for when necessary are: /dev/fuse.

       In rootless mode, the new device is bind mounted in the  container  from  the  host  rather  than  Podman
       creating  it  within  the  container  space.  Because the bind mount retains its SELinux label on SELinux
       systems, the container can get permission denied  when  accessing  the  mounted  device.  Modify  SELinux
       settings to allow containers to use all device labels via the following command:

       $ sudo setsebool -P  container_use_devices=true

       Note:  the  pod implements devices by storing the initial configuration passed by the user and recreating
       the device on each container added to the pod.

   <b>--device-read-bps=</b><u><b>path:rate</b></u>
       Limit read rate (in bytes per second) from a device (e.g. <b>--device-read-bps=/dev/sda:1mb</b>).

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--device-write-bps=</b><u><b>path:rate</b></u>
       Limit write rate (in bytes per second) to a device (e.g. <b>--device-write-bps=/dev/sda:1mb</b>).

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--gidmap=</b><u><b>pod_gid:host_gid:amount</b></u>
       GID map for the user namespace. Using this flag runs all  containers  in  the  pod  with  user  namespace
       enabled.  It conflicts with the <b>--userns</b> and <b>--subgidname</b> flags.

   <b>--gpus=</b><u><b>ENTRY</b></u>
       GPU devices to add to the container ('all' to pass all GPUs) Currently only Nvidia devices are supported.

   <b>--help,</b> <b>-h</b>
       Print usage statement.

   <b>--hostname=</b><u><b>name</b></u>
       Set the pod's hostname inside all containers.

       The  given  hostname  is also added to the <b><a href="file:/etc/hosts">/etc/hosts</a></b> file using the container's primary IP address (also
       see the <b>--add-host</b> option).

   <b>--infra-command=</b><u><b>command</b></u>
       The command that is run to start the infra container. Default: "/pause".

   <b>--infra-conmon-pidfile=</b><u><b>file</b></u>
       Write the pid of the infra container's <b>conmon</b> process to a file. As <b>conmon</b> runs  in  a  separate  process
       than Podman, this is necessary when using systemd to manage Podman containers and pods.

   <b>--infra-name=</b><u><b>name</b></u>
       The name that is used for the pod's infra container.

   <b>--label,</b> <b>-l=</b><u><b>key=value</b></u>
       Add metadata to a pod.

   <b>--label-file=</b><u><b>file</b></u>
       Read in a line-delimited file of labels.

   <b>--memory,</b> <b>-m=</b><u><b>number[unit]</b></u>
       Memory limit. A <u>unit</u> can be <b>b</b> (bytes), <b>k</b> (kibibytes), <b>m</b> (mebibytes), or <b>g</b> (gibibytes).

       Allows  the memory available to a container to be constrained. If the host supports swap memory, then the
       <b>-m</b> memory setting can be larger than physical RAM. If a limit of 0  is  specified  (not  using  <b>-m</b>),  the
       container's  memory  is  not  limited.  The actual limit may be rounded up to a multiple of the operating
       system's page size (the value is very large, that's millions of trillions).

       This option is not supported on cgroups V1 rootless systems.

   <b>--memory-swap=</b><u><b>number[unit]</b></u>
       A limit value equal to memory plus swap.  A <u>unit</u> can be <b>b</b> (bytes), <b>k</b> (kibibytes),  <b>m</b>  (mebibytes),  or  <b>g</b>
       (gibibytes).

       Must be used with the <b>-m</b> (<b>--memory</b>) flag.  The argument value must be larger than that of
        <b>-m</b> (<b>--memory</b>) By default, it is set to double the value of <b>--memory</b>.

       Set <u>number</u> to <b>-1</b> to enable unlimited swap.

       This option is not supported on cgroups V1 rootless systems.

   <b>--name,</b> <b>-n</b>
       Set   a   custom   name   for   the  cloned  pod.  The  default  if  not  specified  is  of  the  syntax:
       <b>&lt;ORIGINAL_NAME&gt;-clone</b>

   <b>--pid=</b><u><b>pid</b></u>
       Set the PID mode for the pod. The default is to create a private PID namespace for the pod. Requires  the
       PID namespace to be shared via --share.

       host: use the host’s PID namespace for the pod
       ns: join the specified PID namespace
       private: create a new namespace for the pod (default)

   <b>--restart=</b><u><b>policy</b></u>
       Restart  policy  to  follow  when containers exit.  Restart policy does not take effect if a container is
       stopped via the <b>podman</b> <b>kill</b> or <b>podman</b> <b>stop</b> commands.

       Valid <u>policy</u> values are:

              • <b>no</b>                       : Do not restart containers on exit

              • <b>never</b>                    : Synonym for <b>no</b>; do not restart containers on exit

              • <b>on-failure[:max_retries]</b> : Restart containers when they exit with a non-zero exit code, retrying
                indefinitely or until the optional <u>max_retries</u> count is hit

              • <b>always</b>                   : Restart containers when they exit,  regardless  of  status,  retrying
                indefinitely

              • <b>unless-stopped</b>           : Identical to <b>always</b>

       Podman  provides  a  systemd  unit file, podman-restart.service, which restarts containers after a system
       reboot.

       When running containers in systemd services, use the restart functionality provided by systemd.  In other
       words, do not use this option in a container unit, instead set the  <b>Restart=</b>  systemd  directive  in  the
       <b>[Service]</b> section.  See <b><a href="../man5/podman-systemd.unit.5.html">podman-systemd.unit</a></b>(5) and <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5).

       Default restart policy for all the containers in a pod.

   <b>--security-opt=</b><u><b>option</b></u>
       Security Options

              • <b>apparmor=unconfined</b> : Turn off apparmor confinement for the pod

              • <b>apparmor</b>=<u>alternate-profile</u> : Set the apparmor confinement profile for the pod

              • <b>label=user:</b><u>USER</u>: Set the label user for the pod processes

              • <b>label=role:</b><u>ROLE</u>: Set the label role for the pod processes

              • <b>label=type:</b><u>TYPE</u>: Set the label process type for the pod processes

              • <b>label=level:</b><u>LEVEL</u>: Set the label level for the pod processes

              • <b>label=filetype:</b><u>TYPE</u>: Set the label file type for the pod files

              • <b>label=disable</b>: Turn off label separation for the pod

       Note:  Labeling  can  be  disabled  for all pods/containers by setting label=false in the <b>containers.conf</b>
       (<b>/etc/containers/containers.conf</b> or <b>$HOME/.config/containers/containers.conf</b>) file.

              • <b>label=nested</b>: Allows SELinux modifications within  the  container.  Containers  are  allowed  to
                modify  SELinux labels on files and processes, as long as SELinux policy allows. Without <b>nested</b>,
                containers view SELinux as disabled, even when  it  is  enabled  on  the  host.  Containers  are
                prevented from setting any labels.

              • <b>mask</b>=<u>/path/1:/path/2</u>:  The  paths to mask separated by a colon. A masked path cannot be accessed
                inside the containers within the pod.

              • <b>no-new-privileges</b>: Disable container processes from gaining additional privileges.

              • <b>seccomp=unconfined</b>: Turn off seccomp confinement for the pod.

              • <b>seccomp=profile.json</b>:  JSON  file  to  be  used   as   a   seccomp   filter.   Note   that   the
                <b>io.podman.annotations.seccomp</b>  annotation  is  set  with  the specified value as shown in <b>podman</b>
                <b>inspect</b>.

              • <b>proc-opts</b>=<u>OPTIONS</u> : Comma-separated list of options to use for the <a href="file:/proc">/proc</a> mount. More details for
                the possible mount options are specified in the <b><a href="../man5/proc.5.html">proc</a>(5)</b> man page.

              • <b>unmask</b>=<u>ALL</u> or <u>/path/1:/path/2</u>, or shell expanded paths (<a href="file:/proc/">/proc/</a>*): Paths to unmask separated by a
                colon. If set to <b>ALL</b>, it unmasks all the paths that are masked or  made  read-only  by  default.
                The   default   masked  paths  are  <b><a href="file:/proc/acpi">/proc/acpi</a>,</b>  <b><a href="file:/proc/kcore">/proc/kcore</a>,</b>  <b><a href="file:/proc/keys">/proc/keys</a>,</b>  <b><a href="file:/proc/latency_stats">/proc/latency_stats</a>,</b>
                <b>/proc/sched_debug,</b>   <b><a href="file:/proc/scsi">/proc/scsi</a>,</b>   <b><a href="file:/proc/timer_list">/proc/timer_list</a>,</b>   <b>/proc/timer_stats,</b>   <b><a href="file:/sys/firmware">/sys/firmware</a>,</b>   <b>and</b>
                <b>/sys/fs/selinux</b>,  <b>/sys/devices/virtual/powercap</b>.   The  default  paths  that  are  read-only are
                <b>/proc/asound</b>, <b><a href="file:/proc/bus">/proc/bus</a></b>, <b><a href="file:/proc/fs">/proc/fs</a></b>, <b><a href="file:/proc/irq">/proc/irq</a></b>, <b><a href="file:/proc/sys">/proc/sys</a></b>, <b><a href="file:/proc/sysrq-trigger">/proc/sysrq-trigger</a></b>, <b><a href="file:/sys/fs/cgroup">/sys/fs/cgroup</a></b>.

       Note: Labeling can be disabled for all containers by setting <b>label=false</b> in the <b><a href="../man5/containers.conf.5.html">containers.conf</a></b>(5) file.

   <b>--shm-size=</b><u><b>number[unit]</b></u>
       Size of <u><a href="file:/dev/shm">/dev/shm</a></u>. A <u>unit</u> can be <b>b</b> (bytes), <b>k</b> (kibibytes), <b>m</b> (mebibytes), or <b>g</b> (gibibytes).  If  the  unit
       is  omitted, the system uses bytes. If the size is omitted, the default is <b>64m</b>.  When <u>size</u> is <b>0</b>, there is
       no limit on the amount of memory used for IPC by the pod.  This option conflicts with <b>--ipc=host</b>.

   <b>--shm-size-systemd=</b><u><b>number[unit]</b></u>
       Size of systemd-specific tmpfs mounts such as <a href="file:/run">/run</a>, <a href="file:/run/lock">/run/lock</a>, <a href="file:/var/log/journal">/var/log/journal</a> and /tmp.  A <u>unit</u> can  be
       <b>b</b>  (bytes),  <b>k</b>  (kibibytes),  <b>m</b>  (mebibytes),  or <b>g</b> (gibibytes).  If the unit is omitted, the system uses
       bytes. If the size is omitted, the default is <b>64m</b>.  When <u>size</u> is <b>0</b>, the usage is limited to  50%  of  the
       host's available memory.

   <b>--start</b>
       When  set  to  true,  this  flag  starts the newly created pod after the clone process has completed. All
       containers within the pod are started.

   <b>--subgidname=</b><u><b>name</b></u>
       Run the container in a new user namespace using the map with <u>name</u> in the <u><a href="file:/etc/subgid">/etc/subgid</a></u>  file.   If  running
       rootless,  the  user needs to have the right to use the mapping. See <b><a href="../man5/subgid.5.html">subgid</a></b>(5).  This flag conflicts with
       <b>--userns</b> and <b>--gidmap</b>.

   <b>--subuidname=</b><u><b>name</b></u>
       Run the container in a new user namespace using the map with <u>name</u> in the <u><a href="file:/etc/subuid">/etc/subuid</a></u>  file.   If  running
       rootless,  the  user needs to have the right to use the mapping. See <b><a href="../man5/subuid.5.html">subuid</a></b>(5).  This flag conflicts with
       <b>--userns</b> and <b>--uidmap</b>.

   <b>--sysctl=</b><u><b>name=value</b></u>
       Configure namespaced kernel parameters for all containers in the pod.

       For the IPC namespace, the following sysctls are allowed:

              • kernel.msgmax

              • kernel.msgmnb

              • kernel.msgmni

              • kernel.sem

              • kernel.shmall

              • kernel.shmmax

              • kernel.shmmni

              • kernel.shm_rmid_forced

              • Sysctls beginning with fs.mqueue.*

       Note: if the ipc namespace is not shared within the pod, the above sysctls are not allowed.

       For the network namespace, only sysctls beginning with net.* are allowed.

       Note: if the network namespace is not shared within the pod, the above sysctls are not allowed.

   <b>--uidmap=</b><u><b>container_uid:from_uid:amount</b></u>
       Run all containers in the pod in a new user namespace using the supplied mapping. This  option  conflicts
       with  the  <b>--userns</b>  and  <b>--subuidname</b>  options. This option provides a way to map host UIDs to container
       UIDs. It can be passed several times to map different ranges.

   <b>--userns=</b><u><b>mode</b></u>
       Set the user namespace mode for all the containers in a pod. It defaults to the <b>PODMAN_USERNS</b> environment
       variable. An empty value ("") means user namespaces are disabled.

       Rootless user --userns=Key mappings:

       ┌─────────┬───────────┬──────────────────────────────┐
       │ <b>Key</b>     │ <b>Host</b> <b>User</b> │ <b>Container</b> <b>User</b>               │
       ├─────────┼───────────┼──────────────────────────────┤
       │ ""      │ $UID      │ 0  (Default   User   account │
       │         │           │ mapped   to   root  user  in │
       │         │           │ container.)                  │
       ├─────────┼───────────┼──────────────────────────────┤
       │ host    │ $UID      │ 0  (Default   User   account │
       │         │           │ mapped   to   root  user  in │
       │         │           │ container.)                  │
       ├─────────┼───────────┼──────────────────────────────┤
       │ keep-id │ $UID      │ $UID (Map  user  account  to │
       │         │           │ same UID within container.)  │
       ├─────────┼───────────┼──────────────────────────────┤
       │ auto    │ $UID      │ nil  (Host  User  UID is not │
       │         │           │ mapped into container.)      │
       ├─────────┼───────────┼──────────────────────────────┤
       │ nomap   │ $UID      │ nil (Host User  UID  is  not │
       │         │           │ mapped into container.)      │
       └─────────┴───────────┴──────────────────────────────┘

       Valid <u>mode</u> values are:

              • <u>auto[:OPTIONS,...]</u>: automatically create a namespace. It is possible to specify these options to
                <b>auto</b>:

                • <u>gidmapping=CONTAINER_GID:HOST_GID:SIZE</u>  to  force  a  GID  mapping  to  be present in the user
                  namespace.

                • <u>size=SIZE</u>:  to  specify  an  explicit  size   for   the   automatic   user   namespace.   e.g.
                  <b>--userns=auto:size=8192</b>.  If  <b>size</b>  is  not  specified,  <b>auto</b>  estimates the size for the user
                  namespace.

                • <u>uidmapping=CONTAINER_UID:HOST_UID:SIZE</u> to force a UID  mapping  to  be  present  in  the  user
                  namespace.

              • <u>host</u>:  run  in the user namespace of the caller. The processes running in the container have the
                same privileges on the host as any other process launched by the calling user (default).

              • <u>keep-id</u>: creates a user namespace where the current rootless user's UID:GID are  mapped  to  the
                same  values  in  the  container.  This option is not allowed for containers created by the root
                user.

              • <u>nomap</u>: creates a user namespace where the current rootless user's UID:GID are  not  mapped  into
                the container. This option is not allowed for containers created by the root user.

   <b>--uts=</b><u><b>mode</b></u>
       Set the UTS namespace mode for the pod. The following values are supported:

              • <b>host</b>: use the host's UTS namespace inside the pod.

              • <b>private</b>: create a new namespace for the pod (default).

              • <b>ns:[path]</b>: run the pod in the given existing UTS namespace.

   <b>--volume,</b> <b>-v=</b><u><b>[[SOURCE-VOLUME|HOST-DIR:]CONTAINER-DIR[:OPTIONS]]</b></u>
       Create  a  bind mount. If <b>-v</b> <b>/HOST-DIR:/CONTAINER-DIR</b> is specified, Podman bind mounts <b>/HOST-DIR</b> from the
       host into <b>/CONTAINER-DIR</b> in the Podman container. Similarly, <b>-v</b> <b>SOURCE-VOLUME:/CONTAINER-DIR</b>  mounts  the
       named  volume from the host into the container. If no such named volume exists, Podman creates one. If no
       source is given, the volume is created as an anonymously named volume with a randomly generated name, and
       is removed when the pod is removed via the <b>--rm</b> flag or the <b>podman</b> <b>rm</b> <b>--volumes</b> command.

       (Note when using the remote client, including Mac and Windows (excluding WSL2) machines, the volumes  are
       mounted from the remote server, not necessarily the client machine.)

       The <u>OPTIONS</u> is a comma-separated list and can be one or more of:

              • <b>rw</b>|<b>ro</b>

              • <b>z</b>|<b>Z</b>

              • [<b>O</b>]

              • [<b>U</b>]

              • [<b>no</b>]<b>copy</b>

              • [<b>no</b>]<b>dev</b>

              • [<b>no</b>]<b>exec</b>

              • [<b>no</b>]<b>suid</b>

              • [<b>r</b>]<b>bind</b>

              • [<b>r</b>]<b>shared</b>|[<b>r</b>]<b>slave</b>|[<b>r</b>]<b>private</b>[<b>r</b>]<b>unbindable</b> [1] ⟨#Footnote1⟩

              • <b>idmap</b>[=<b>options</b>]

       The <b>CONTAINER-DIR</b> must be an absolute path such as <b>/src/docs</b>. The volume is mounted into the container at
       this directory.

       If  a volume source is specified, it must be a path on the host or the name of a named volume. Host paths
       are allowed to be absolute or relative; relative paths are resolved relative to the directory  Podman  is
       run  in. If the source does not exist, Podman returns an error. Users must pre-create the source files or
       directories.

       Any source that does not begin with a <b>.</b> or <b>/</b> is treated as the name of a named volume. If a  volume  with
       that  name does not exist, it is created.  Volumes created with names are not anonymous, and they are not
       removed by the <b>--rm</b> option and the <b>podman</b> <b>rm</b> <b>--volumes</b> command.

       Specify multiple <b>-v</b> options to mount one or more volumes into a pod.

       <b>Write</b> <b>Protected</b> <b>Volume</b> <b>Mounts</b>

       Add <b>:ro</b> or <b>:rw</b> option to mount a volume in read-only or read-write mode, respectively.  By  default,  the
       volumes are mounted read-write.  See examples.

       <b>Chowning</b> <b>Volume</b> <b>Mounts</b>

       By  default,  Podman  does  not  change  the  owner  and  group of source volume directories mounted into
       containers. If a pod is created in a new user namespace, the UID and GID in the container may  correspond
       to another UID and GID on the host.

       The  <b>:U</b>  suffix tells Podman to use the correct host UID and GID based on the UID and GID within the pod,
       to change recursively the owner and group of the source volume. Chowning walks the file system under  the
       volume  and changes the UID/GID on each file. If the volume has thousands of inodes, this process takes a
       long time, delaying the start of the pod.

       <b>Warning</b> use with caution since this modifies the host filesystem.

       <b>Labeling</b> <b>Volume</b> <b>Mounts</b>

       Labeling systems like SELinux require that proper labels are placed on volume content mounted into a pod.
       Without a label, the security system might prevent the processes running inside the pod  from  using  the
       content. By default, Podman does not change the labels set by the OS.

       To  change  a  label  in  the pod context, add either of two suffixes <b>:z</b> or <b>:Z</b> to the volume mount. These
       suffixes tell Podman to relabel file objects on the shared volumes. The <b>z</b> option tells Podman that two or
       more pods share the volume content. As a result, Podman labels the content with a shared  content  label.
       Shared  volume  labels allow all containers to read/write content. The <b>Z</b> option tells Podman to label the
       content with a private unshared label Only the current pod can use a private volume. Note: all containers
       within a <b>pod</b> share the same SELinux label. This means all  containers  within  said  pod  can  read/write
       volumes  shared into the container created with the <b>:Z</b> on any of one the containers. Relabeling walks the
       file system under the volume and changes the label on each file, if the volume has thousands  of  inodes,
       this  process  takes  a  long time, delaying the start of the pod. If the volume was previously relabeled
       with the <b>z</b> option, Podman is optimized to not relabel a second time. If files are moved into the  volume,
       then the labels can be manually change with the <b>chcon</b> <b>-Rt</b> <b>container_file_t</b> <b>PATH</b> command.

       Note:  Do  not relabel system files and directories. Relabeling system content might cause other confined
       services on the machine  to  fail.   For  these  types  of  containers  we  recommend  disabling  SELinux
       separation.   The  option  <b>--security-opt</b>  <b>label=disable</b>  disables  SELinux  separation for the pod.  For
       example if a user wanted to volume mount their entire home directory into a pod,  they  need  to  disable
       SELinux separation.

       $ podman pod clone --security-opt label=disable -v $HOME:/home/user fedora touch /home/user/file

       <b>Overlay</b> <b>Volume</b> <b>Mounts</b>

       The  <b>:O</b>  flag  tells Podman to mount the directory from the host as a temporary storage using the <b>overlay</b>
       <b>file</b> <b>system</b>. The pod processes can modify content within the mountpoint which is stored in the  container
       storage  in  a separate directory. In overlay terms, the source directory is the lower, and the container
       storage directory is the upper. Modifications to the mount point are  destroyed  when  the  pod  finishes
       executing, similar to a tmpfs mount point being unmounted.

       For  advanced  users,  the  <b>overlay</b> option also supports custom non-volatile <b>upperdir</b> and <b>workdir</b> for the
       overlay mount. Custom <b>upperdir</b> and <b>workdir</b> can be fully managed by the users themselves, and Podman  does
       not remove it on lifecycle completion.  Example <b>:O,upperdir=/some/upper,workdir=/some/work</b>

       Subsequent  executions  of  the  container  sees  the original source directory content, any changes from
       previous pod executions no longer exist.

       One use case of the overlay mount is sharing the package cache from the host into the container to  allow
       speeding up builds.

       Note: The <b>O</b> flag conflicts with other options listed above.

       Content  mounted into the container is labeled with the private label.  On SELinux systems, labels in the
       source directory must be readable by the pod infra container label. Usually containers  can  read/execute
       <b>container_share_t</b> and can read/write <b>container_file_t</b>. If unable to change the labels on a source volume,
       SELinux container separation must be disabled for the pod or infra container to work.

       Do  not  modify  the source directory mounted into the pod with an overlay mount, it can cause unexpected
       failures. Only modify the directory after the container finishes running.

       <b>Mounts</b> <b>propagation</b>

       By default, bind-mounted volumes are <b>private</b>. That means any mounts done inside the pod are  not  visible
       on  the  host  and  vice  versa.   One  can change this behavior by specifying a volume mount propagation
       property.  When a volume is <b>shared</b>, mounts done under that volume inside the pod are visible on host  and
       vice  versa. Making a volume <b>slave</b>[1] ⟨#Footnote1⟩ enables only one-way mount propagation: mounts done on
       the host under that volume are visible inside the container but not the other way around.

       To control mount propagation property of a volume one can use the [<b>r</b>]<b>shared</b>, [<b>r</b>]<b>slave</b>, [<b>r</b>]<b>private</b> or  the
       [<b>r</b>]<b>unbindable</b>  propagation flag.  Propagation property can be specified only for bind mounted volumes and
       not for internal volumes or named volumes. For mount propagation to work  the  source  mount  point  (the
       mount  point  where  source  dir  is mounted on) has to have the right propagation properties. For shared
       volumes, the source mount point has to be shared. And for slave volumes, the source mount point has to be
       either shared or slave.  [1] ⟨#Footnote1⟩

       To recursively mount a volume and all of its submounts into a pod, use the <b>rbind</b> option. By  default  the
       bind option is used, and submounts of the source directory is not mounted into the pod.

       Mounting  the  volume  with  a  <b>copy</b>  option tells podman to copy content from the underlying destination
       directory onto newly created internal volumes. The <b>copy</b> only happens  on  the  initial  creation  of  the
       volume.  Content  is not copied up when the volume is subsequently used on different containers. The <b>copy</b>
       option is ignored on bind mounts and has no effect.

       Mounting volumes with the <b>nosuid</b> options means that SUID executables on the volume can  not  be  used  by
       applications to change their privilege. By default volumes are mounted with <b>nosuid</b>.

       Mounting the volume with the <b>noexec</b> option means that no executables on the volume can be executed within
       the pod.

       Mounting  the  volume  with the <b>nodev</b> option means that no devices on the volume can be used by processes
       within the pod. By default volumes are mounted with <b>nodev</b>.

       If the <u>HOST-DIR</u> is a mount point, then <b>dev</b>, <b>suid</b>, and <b>exec</b> options are ignored by the kernel.

       Use <b>df</b> <b>HOST-DIR</b> to figure out the source mount, then use <b>findmnt</b> <b>-o</b>  <b>TARGET,PROPAGATION</b>  <u>source-mount-dir</u>
       <u>to</u>  <u>figure</u>  <u>out</u>  <u>propagation</u> <u>properties</u> <u>of</u> <u>source</u> <u>mount.</u> <u>If</u> <b>findmnt</b><u>(1)</u> <u>utility</u> <u>is</u> <u>not</u> <u>available,</u> <u>then</u> <u>one</u>
       <u>can</u> <u>look</u> <u>at</u> <u>the</u> <u>mount</u> <u>entry</u> <u>for</u> <u>the</u> <u>source</u> <u>mount</u> <u>point</u> <u>in</u> <u>/proc/self/mountinfo.</u>  <u>Look</u>  <u>at</u>  <u>the</u>  <u>"optional</u>
       <u>fields"</u>  <u>and</u>  <u>see</u>  <u>if</u>  <u>any</u>  <u>propagation</u>  <u>properties</u> <u>are</u> <u>specified.</u>  <u>In</u> <u>there,</u> <b>shared:N</b> <u>means</u> <u>the</u> <u>mount</u> <u>is</u>
       <u>shared,</u> <b>master:N</b> <u>means</u> <u>mount</u> <u>is</u> <u>slave,</u> <u>and</u> <u>if</u> <u>nothing</u> <u>is</u> <u>there,</u> <u>the</u> <u>mount</u> <u>is</u> <u>private.</u> <u>[1]</u> <u>⟨#Footnote1⟩</u>

       To change propagation properties of a mount point, use <b><a href="../man8/mount.8.html">mount</a></b>(8) command. For example,  if  one  wants  to
       bind  mount  source  directory  <u>/foo</u>,  one can do <b>mount</b> <b>--bind</b> <b>/foo</b> <b>/foo</b> and <b>mount</b> <b>--make-private</b> <b>--make-</b>
       <b>shared</b> <b>/foo</b>. This converts /foo into a  shared  mount  point.  Alternatively,  one  can  directly  change
       propagation properties of source mount. Say <u>/</u> is source mount for <u>/foo</u>, then use <b>mount</b> <b>--make-shared</b> <b>/</b> to
       convert <u>/</u> into a shared mount.

       Note:  if  the  user  only has access rights via a group, accessing the volume from inside a rootless pod
       fails.

       <b>Idmapped</b> <b>mount</b>

       If <b>idmap</b> is specified, create an idmapped mount to the target user namespace in the container. The  idmap
       option supports a custom mapping that can be different than the user namespace used by the container. The
       mapping can be specified after the idmap option like: <b>idmap=uids=0-1-10#10-11-10;gids=0-100-10</b>.  For each
       triplet,  the first value is the start of the backing file system IDs that are mapped to the second value
       on the host.  The length of this mapping is given in the third value.  Multiple ranges are separated with
       #.

   <b>--volumes-from=</b><u><b>CONTAINER[:OPTIONS]</b></u>
       Mount volumes from the specified container(s). Used to share volumes between  containers  and  pods.  The
       <u>options</u> is a comma-separated list with the following available elements:

              • <b>rw</b>|<b>ro</b>

              • <b>z</b>

       Mounts  already  mounted volumes from a source container onto another pod. <u>CONTAINER</u> may be a name or ID.
       To share a volume, use the --volumes-from option when running the target container. Volumes can be shared
       even if the source container is not running.

       By default, Podman mounts the volumes in the same mode (read-write or read-only) as it is mounted in  the
       source container.  This can be changed by adding a <b>ro</b> or <b>rw</b> <u>option</u>.

       Labeling systems like SELinux require that proper labels are placed on volume content mounted into a pod.
       Without  a label, the security system might prevent the processes running inside the container from using
       the content. By default, Podman does not change the labels set by the OS.

       To change a label in the pod context, add <b>z</b> to the volume mount.  This suffix  tells  Podman  to  relabel
       file objects on the shared volumes. The <b>z</b> option tells Podman that two entities share the volume content.
       As  a  result,  Podman  labels  the  content  with a shared content label. Shared volume labels allow all
       containers to read/write content.

       If the location of the volume from the source container overlaps with data residing on a target pod, then
       the volume hides that data on the target.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Clone the specified pod to a new pod.

       # podman pod clone pod-name
       6b2c73ff8a1982828c9ae2092954bcd59836a131960f7e05221af9df5939c584

       Clone the specified pod to a new pod with a new name.

       # podman pod clone pod-name --name=cloned-pod
       d0cf1f782e2ed67e8c0050ff92df865a039186237a4df24d7acba5b1fa8cc6e7
       6b2c73ff8a1982828c9ae2092954bcd59836a131960f7e05221af9df5939c584

       Clone and remove the specified pod to a new pod, modifying its cpus.

       # podman pod clone --destroy --cpus=5 d0cf1
       6b2c73ff8a1982828c9ae2092954bcd59836a131960f7e05221af9df5939c584

       Clone the specified pod to a new named pod.

       # podman pod clone 2d4d4fca7219b4437e0d74fcdc272c4f031426a6eacd207372691207079551de new_name
       5a9b7851013d326aa4ac4565726765901b3ecc01fcbc0f237bc7fd95588a24f9

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/podman-pod-create.1.html">podman-pod-create</a>(1)</b>

</pre><h4><b>HISTORY</b></h4><pre>
       May 2022, Originally written by Charlie Doern <a href="mailto:cdoern@redhat.com">cdoern@redhat.com</a> ⟨<a href="mailto:cdoern@redhat.com">mailto:cdoern@redhat.com</a>⟩

</pre><h4><b>FOOTNOTES</b></h4><pre>
       1: The Podman project is committed to inclusivity, a core value of open  source.  The  <b>master</b>  and  <b>slave</b>
       mount  propagation  terminology  used here is problematic and divisive, and needs to be changed. However,
       these terms are currently used within the Linux kernel and must be used as-is  at  this  time.  When  the
       kernel maintainers rectify this usage, Podman will follow suit immediately.

                                                                                             <u><a href="../man1/podman-pod-clone.1.html">podman-pod-clone</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>