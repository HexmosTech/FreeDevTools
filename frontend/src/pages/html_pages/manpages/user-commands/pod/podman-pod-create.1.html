<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>podman-pod-create - Create a new pod</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/podman">podman_5.4.1+ds1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       podman-pod-create - Create a new pod

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>podman</b> <b>pod</b> <b>create</b> [<u>options</u>] [<u>name</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Creates an empty pod, or unit of multiple containers, and prepares it to have containers added to it. The
       pod can be created with a specific name. If a name is not given a random name is generated. The pod ID is
       printed  to  STDOUT.  You can then use <b>podman</b> <b>create</b> <b>--pod</b> <b>&lt;pod_id|pod_name&gt;</b> ... <b>to</b> <b>add</b> <b>containers</b> <b>to</b> <b>the</b>
       <b>pod,</b> <b>and</b> <b>podman</b> <b>pod</b> <b>start</b> <b>&lt;pod_id|pod_name&gt;</b> <b>to</b> <b>start</b> <b>the</b> <b>pod.</b>

       The    operator    can    identify    a    pod    in     three     ways:     UUID     long     identifier
       (“f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778”)      UUID      short      identifier
       (“f78375b1c487”) Name (“jonah”)

       podman generates a UUID for each pod, and if a name is not assigned to the container with <b>--name</b>  then  a
       random string name is generated for it. This name is useful to identify a pod.

       Note:  resource  limit related flags work by setting the limits explicitly in the pod's cgroup parent for
       all containers joining the pod. A container can override the resource limits when  joining  a  pod.   For
       example,  if  a  pod  was  created  via  <b>podman</b>  <b>pod</b>  <b>create</b> <b>--cpus=5</b>, specifying <b>podman</b> <b>container</b> <b>create</b>
       <b>--pod=&lt;pod_id|pod_name&gt;</b> --cpus=4 <b>causes</b> <b>the</b> <b>container</b> <b>to</b> <b>use</b> <b>the</b> <b>smaller</b> <b>limit.</b>  <b>Also,</b>  <b>containers</b>  <b>which</b>
       <b>specify</b> <b>their</b> <b>own</b> <b>cgroup,</b> <b>such</b> <b>as</b> <b>--cgroupns=host,</b> <b>do</b> <b>NOT</b> <b>get</b> <b>the</b> <b>assigned</b> <b>pod</b> <b>level</b> <b>cgroup</b> <b>resources.</b>

</pre><h4><b>OPTIONS</b></h4><pre>
   <b>--add-host=</b><u><b>hostname[;hostname[;...]]</b></u><b>:</b><u><b>ip</b></u>
       Add a custom host-to-IP mapping to the pod's <b><a href="file:/etc/hosts">/etc/hosts</a></b> file.

       The  option  takes  one  or  multiple semicolon-separated hostnames to be mapped to a single IPv4 or IPv6
       address, separated by a colon. It can also be used to overwrite the IP addresses of hostnames Podman adds
       to <b><a href="file:/etc/hosts">/etc/hosts</a></b> by default (also see the <b>--name</b> and <b>--hostname</b>  options).  This  option  can  be  specified
       multiple  times  to  add  additional  mappings to <b><a href="file:/etc/hosts">/etc/hosts</a></b>. It conflicts with the <b>--no-hosts</b> option and
       conflicts with <u>no_hosts=true</u> in <b>containers.conf</b>.

       Instead of an IP address, the special flag <u>host-gateway</u> can be given. This resolves to an IP address  the
       container  can  use  to  connect  to  the host. The IP address chosen depends on your network setup, thus
       there's no guarantee that Podman can determine the <u>host-gateway</u> address automatically,  which  will  then
       cause   Podman   to   fail  with  an  error  message.  You  can  overwrite  this  IP  address  using  the
       <u>host_containers_internal_ip</u> option in <u>containers.conf</u>.

       The <u>host-gateway</u> address is also used by Podman to automatically  add  the  <b>host.containers.internal</b>  and
       <b>host.docker.internal</b>  hostnames  to  <b><a href="file:/etc/hosts">/etc/hosts</a></b>.   You  can  prevent that by either giving the <b>--no-hosts</b>
       option, or by setting <u>host_containers_internal_ip="none"</u> in <u>containers.conf</u>. If no  <u>host-gateway</u>  address
       was  configured manually and Podman fails to determine the IP address automatically, Podman will silently
       skip adding these internal hostnames to <b><a href="file:/etc/hosts">/etc/hosts</a></b>. If Podman is  running  in  a  virtual  machine  using
       <b>podman</b>  <b>machine</b>  (this  includes  Mac  and  Windows hosts), Podman will silently skip adding the internal
       hostnames to <b><a href="file:/etc/hosts">/etc/hosts</a></b>, unless an IP  address  was  configured  manually;  the  internal  hostnames  are
       resolved by the gvproxy DNS resolver instead.

       Podman will use the <b><a href="file:/etc/hosts">/etc/hosts</a></b> file of the host as a basis by default, i.e.  any hostname present in this
       file  will  also  be  present  in  the  <b><a href="file:/etc/hosts">/etc/hosts</a></b>  file  of  the container. A different base file can be
       configured using the <u>base_hosts_file</u> config in <b>containers.conf</b>.

       The <a href="file:/etc/hosts">/etc/hosts</a> file is shared between all containers in the pod.

   <b>--blkio-weight=</b><u><b>weight</b></u>
       Block IO relative weight. The <u>weight</u> is a value between <b>10</b> and <b>1000</b>.

       This option is not supported on cgroups V1 rootless systems.

   <b>--blkio-weight-device=</b><u><b>device:weight</b></u>
       Block IO relative device weight.

   <b>--cgroup-parent=</b><u><b>path</b></u>
       Path to cgroups under which the cgroup for the pod is created. If the path is not absolute, the  path  is
       considered  to  be  relative  to the cgroups path of the init process. Cgroups are created if they do not
       already exist.

   <b>--cpu-shares,</b> <b>-c=</b><u><b>shares</b></u>
       CPU shares (relative weight).

       By default, all containers get the same proportion of CPU cycles. This  proportion  can  be  modified  by
       changing  the  container's  CPU  share  weighting  relative  to  the  combined  weight of all the running
       containers.  Default weight is <b>1024</b>.

       The proportion only applies when CPU-intensive processes are running.  When tasks in  one  container  are
       idle,  other containers can use the left-over CPU time. The actual amount of CPU time varies depending on
       the number of containers running on the system.

       For example, consider three containers, one has a cpu-share of 1024  and  two  others  have  a  cpu-share
       setting  of  512.  When processes in all three containers attempt to use 100% of CPU, the first container
       receives 50% of the total CPU time. If a fourth container is added with a cpu-share of  1024,  the  first
       container only gets 33% of the CPU. The remaining containers receive 16.5%, 16.5% and 33% of the CPU.

       On a multi-core system, the shares of CPU time are distributed over all CPU cores. Even if a container is
       limited to less than 100% of CPU time, it can use 100% of each individual CPU core.

       For  example,  consider  a system with more than three cores.  If the container <u>C0</u> is started with <b>--cpu-</b>
       <b>shares=512</b> running one process, and another container <u>C1</u> with <b>--cpu-shares=1024</b>  running  two  processes,
       this can result in the following division of CPU shares:

       ┌─────┬───────────┬─────┬──────────────┐
       │ <b>PID</b> │ <b>container</b> │ <b>CPU</b> │ <b>CPU</b> <b>share</b>    │
       ├─────┼───────────┼─────┼──────────────┤
       │ 100 │ C0        │ 0   │ 100% of CPU0 │
       ├─────┼───────────┼─────┼──────────────┤
       │ 101 │ C1        │ 1   │ 100% of CPU1 │
       ├─────┼───────────┼─────┼──────────────┤
       │ 102 │ C1        │ 2   │ 100% of CPU2 │
       └─────┴───────────┴─────┴──────────────┘

       On  some  systems,  changing the resource limits may not be allowed for non-root users. For more details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--cpus=</b><u><b>amount</b></u>
       Set  the  total  number  of  CPUs delegated to the pod. Default is 0.000 which indicates that there is no
       limit on computation power.

   <b>--cpuset-cpus=</b><u><b>number</b></u>
       CPUs in which to allow execution. Can be specified as a comma-separated list (e.g. <b>0,1</b>), as a range (e.g.
       <b>0-3</b>), or any combination thereof (e.g. <b>0-3,7,11-15</b>).

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--cpuset-mems=</b><u><b>nodes</b></u>
       Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.

       If there are four memory nodes on the system (0-3), use <b>--cpuset-mems=0,1</b> then processes in the container
       only uses memory from the first two memory nodes.

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--device=</b><u><b>host-device[:container-device][:permissions]</b></u>
       Add a host device to the pod. Optional <u>permissions</u> parameter can be used to specify device permissions by
       combining <b>r</b> for read, <b>w</b> for write, and <b>m</b> for <b><a href="../man2/mknod.2.html">mknod</a></b>(2).

       Example: <b>--device=/dev/sdc:/dev/xvdc:rwm</b>.

       Note: if <u>host-device</u> is a symbolic link then it is resolved first.  The pod only  stores  the  major  and
       minor numbers of the host device.

       Podman  may  load  kernel  modules required for using the specified device. The devices that Podman loads
       modules for when necessary are: /dev/fuse.

       In rootless mode, the new device is bind mounted in the  container  from  the  host  rather  than  Podman
       creating  it  within  the  container  space.  Because the bind mount retains its SELinux label on SELinux
       systems, the container can get permission denied  when  accessing  the  mounted  device.  Modify  SELinux
       settings to allow containers to use all device labels via the following command:

       $ sudo setsebool -P  container_use_devices=true

       Note:  the  pod implements devices by storing the initial configuration passed by the user and recreating
       the device on each container added to the pod.

   <b>--device-read-bps=</b><u><b>path:rate</b></u>
       Limit read rate (in bytes per second) from a device (e.g. <b>--device-read-bps=/dev/sda:1mb</b>).

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--device-write-bps=</b><u><b>path:rate</b></u>
       Limit write rate (in bytes per second) to a device (e.g. <b>--device-write-bps=/dev/sda:1mb</b>).

       On some systems, changing the resource limits may not be allowed for non-root users.  For  more  details,
       see         https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-
       resource-limits-fails-with-a-permissions-error

       This option is not supported on cgroups V1 rootless systems.

   <b>--dns=</b><u><b>ipaddr</b></u>
       Set custom DNS servers in the <a href="file:/etc/resolv.conf">/etc/resolv.conf</a> file that is shared between all containers in the  pod.  A
       special option, "none" is allowed which disables creation of <a href="file:/etc/resolv.conf">/etc/resolv.conf</a> for the pod.

   <b>--dns-option=</b><u><b>option</b></u>
       Set custom DNS options in the <a href="file:/etc/resolv.conf">/etc/resolv.conf</a> file that is shared between all containers in the pod.

   <b>--dns-search=</b><u><b>domain</b></u>
       Set  custom  DNS search domains in the <a href="file:/etc/resolv.conf">/etc/resolv.conf</a> file that is shared between all containers in the
       pod.

   <b>--exit-policy=continue</b> <b>|</b> <u><b>stop</b></u>
       Set the exit policy of the pod when the last container exits.  Supported policies are:

       ┌─────────────┬───────────────────────────────────────┐
       │ <b>Exit</b> <b>Policy</b> │ <b>Description</b>                           │
       ├─────────────┼───────────────────────────────────────┤
       │ <u>continue</u>    │ The pod continues running, by keeping │
       │             │ its infra container alive,  when  the │
       │             │ last   container   exits.   Used   by │
       │             │ default.                              │
       ├─────────────┼───────────────────────────────────────┤
       │ <u>stop</u>        │ The   pod   (including   its    infra │
       │             │ container)  is  stopped when the last │
       │             │ container exits. Used in <b>kube</b> <b>play</b>.   │
       └─────────────┴───────────────────────────────────────┘

   <b>--gidmap=</b><u><b>pod_gid:host_gid:amount</b></u>
       GID map for the user namespace. Using this flag runs all  containers  in  the  pod  with  user  namespace
       enabled.  It conflicts with the <b>--userns</b> and <b>--subgidname</b> flags.

   <b>--gpus=</b><u><b>ENTRY</b></u>
       GPU devices to add to the container ('all' to pass all GPUs) Currently only Nvidia devices are supported.

   <b>--help,</b> <b>-h</b>
       Print usage statement.

   <b>--hostname=</b><u><b>name</b></u>
       Set the pod's hostname inside all containers.

       The  given  hostname  is also added to the <b><a href="file:/etc/hosts">/etc/hosts</a></b> file using the container's primary IP address (also
       see the <b>--add-host</b> option).

   <b>--hosts-file=</b><u><b>path</b></u> <b>|</b> <u><b>none</b></u> <b>|</b> <u><b>image</b></u>
       Base file to create the <b><a href="file:/etc/hosts">/etc/hosts</a></b> file inside the container. This must either be an absolute path  to  a
       file on the host system, or one of the following special flags:
         ""      Follow the <b>base_hosts_file</b> configuration in <u>containers.conf</u> (the default)
         <b>none</b>  Do not use a base file (i.e. start with an empty file)
         <b>image</b> Use the container image's <b><a href="file:/etc/hosts">/etc/hosts</a></b> file as base file

   <b>--infra</b>
       Create  an  infra  container and associate it with the pod. An infra container is a lightweight container
       used to coordinate the shared kernel namespace of a pod. Default: true.

   <b>--infra-command=</b><u><b>command</b></u>
       The command that is run to start the infra container. Default: "/pause".

   <b>--infra-conmon-pidfile=</b><u><b>file</b></u>
       Write the pid of the infra container's <b>conmon</b> process to a file. As <b>conmon</b> runs  in  a  separate  process
       than Podman, this is necessary when using systemd to manage Podman containers and pods.

   <b>--infra-image=</b><u><b>image</b></u>
       The  custom  image  that is used for the infra container.  Unless specified, Podman builds a custom local
       image which does not require pulling down an image.

   <b>--infra-name=</b><u><b>name</b></u>
       The name that is used for the pod's infra container.

   <b>--ip=</b><u><b>ipv4</b></u>
       Specify a static IPv4 address for the pod, for example <b>10.88.64.128</b>.  This option can only be used if the
       pod is joined to only a single network - i.e., <b>--network=network-name</b> is used at most once - and  if  the
       pod is not joining another container's network namespace via <b>--network=container:</b><u>id.</u>  <u>The</u> <u>address</u> <u>must</u> <u>be</u>
       <u>within</u> <u>the</u> <u>network's</u> <u>IP</u> <u>address</u> <u>pool</u> <u>(default</u> <b>10.88.0.0/16</b><u>).</u>

       To  specify multiple static IP addresses per pod, set multiple networks using the <b>--network</b> option with a
       static IP address specified for each using the <b>ip</b> mode for that option.

   <b>--ip6=</b><u><b>ipv6</b></u>
       Specify a static IPv6 address for the pod, for example <b>fd46:db93:aa76:ac37::10</b>.  This option can only  be
       used  if the pod is joined to only a single network - i.e., <b>--network=network-name</b> is used at most once -
       and if the pod is not joining another container's  network  namespace  via  <b>--network=container:</b><u>id.</u>   <u>The</u>
       <u>address</u> <u>must</u> <u>be</u> <u>within</u> <u>the</u> <u>network's</u> <u>IPv6</u> <u>address</u> <u>pool.</u>

       To  specify multiple static IPv6 addresses per pod, set multiple networks using the <b>--network</b> option with
       a static IPv6 address specified for each using the <b>ip6</b> mode for that option.

   <b>--label,</b> <b>-l=</b><u><b>key=value</b></u>
       Add metadata to a pod.

   <b>--label-file=</b><u><b>file</b></u>
       Read in a line-delimited file of labels.

   <b>--mac-address=</b><u><b>address</b></u>
       Pod network interface MAC address (e.g. 92:d0:c6:0a:29:33) This option can only be used  if  the  pod  is
       joined  to  only a single network - i.e., <b>--network=</b><u>network-name</u> <u>is</u> <u>used</u> <u>at</u> <u>most</u> <u>once</u> <u>-</u> <u>and</u> <u>if</u> <u>the</u> <u>pod</u> <u>is</u>
       <u>not</u> <u>joining</u> <u>another</u> <u>container's</u> <u>network</u> <u>namespace</u> <u>via</u> <b>--network=container:</b><u>id.</u>

       Remember that the MAC address in an Ethernet network must be unique.   The  IPv6  link-local  address  is
       based on the device's MAC address according to RFC4862.

       To specify multiple static MAC addresses per pod, set multiple networks using the <b>--network</b> option with a
       static MAC address specified for each using the <b>mac</b> mode for that option.

   <b>--memory,</b> <b>-m=</b><u><b>number[unit]</b></u>
       Memory limit. A <u>unit</u> can be <b>b</b> (bytes), <b>k</b> (kibibytes), <b>m</b> (mebibytes), or <b>g</b> (gibibytes).

       Allows  the memory available to a container to be constrained. If the host supports swap memory, then the
       <b>-m</b> memory setting can be larger than physical RAM. If a limit of 0  is  specified  (not  using  <b>-m</b>),  the
       container's  memory  is  not  limited.  The actual limit may be rounded up to a multiple of the operating
       system's page size (the value is very large, that's millions of trillions).

       This option is not supported on cgroups V1 rootless systems.

   <b>--memory-swap=</b><u><b>number[unit]</b></u>
       A limit value equal to memory plus swap.  A <u>unit</u> can be <b>b</b> (bytes), <b>k</b> (kibibytes),  <b>m</b>  (mebibytes),  or  <b>g</b>
       (gibibytes).

       Must be used with the <b>-m</b> (<b>--memory</b>) flag.  The argument value must be larger than that of
        <b>-m</b> (<b>--memory</b>) By default, it is set to double the value of <b>--memory</b>.

       Set <u>number</u> to <b>-1</b> to enable unlimited swap.

       This option is not supported on cgroups V1 rootless systems.

   <b>--name,</b> <b>-n=</b><u><b>name</b></u>
       Assign a name to the pod.

   <b>--network=</b><u><b>mode</b></u><b>,</b> <b>--net</b>
       Set the network mode for the pod.

       Valid <u>mode</u> values are:

              • <b>bridge[:OPTIONS,...]</b>:  Create  a  network  stack  on the default bridge. This is the default for
                rootful containers. It is possible to specify these additional options:

                • <b>alias=</b><u>name</u>: Add network-scoped alias for the container.

                • <b>ip=</b><u>IPv4</u>: Specify a static IPv4 address for this container.

                • <b>ip6=</b><u>IPv6</u>: Specify a static IPv6 address for this container.

                • <b>mac=</b><u>MAC</u>: Specify a static MAC address for this container.

                • <b>interface_name=</b><u>name</u>: Specify a name for the created network interface inside the container.

                • <b>host_interface_name=</b><u>name</u>: Specify a  name  for  the  created  network  interface  outside  the
                  container.

              Any  other  options  will  be passed through to netavark without validation. This can be useful to
              pass arguments to netavark plugins.For example, to set a static ipv4  address  and  a  static  mac
              address, use <b>--network</b> <b>bridge:ip=10.88.0.10,mac=44:33:22:11:00:99</b>.

              • <u>&lt;network</u>  <u>name</u> <u>or</u> <u>ID&gt;</u><b>[:OPTIONS,...]</b>: Connect to a user-defined network; this is the network name
                or ID from a network created by <b>podman</b> <b>network</b> <b>create</b>.  It  is  possible  to  specify  the  same
                options  described  under  the  bridge  mode  above.  Use the <b>--network</b> option multiple times to
                specify additional networks.
                For backwards compatibility it is also possible to specify comma-separated networks on the first
                <b>--network</b> argument, however this prevents you from using the options described under the  bridge
                section above.

              • <b>none</b>:  Create  a network namespace for the container but do not configure network interfaces for
                it, thus the container has no network connectivity.

              • <b>container:</b><u>id</u>: Reuse another container's network stack.

              • <b>host</b>: Do not create a network namespace, the container uses the host's network. Note:  The  host
                mode  gives  the  container  full access to local system services such as D-bus and is therefore
                considered insecure.

              • <b>ns:</b><u>path</u>: Path to a network namespace to join.

              • <b>private</b>: Create a new namespace for the  container.  This  uses  the  <b>bridge</b>  mode  for  rootful
                containers and <b>slirp4netns</b> for rootless ones.

              • <b>slirp4netns[:OPTIONS,...]</b>:  use <b><a href="../man1/slirp4netns.1.html">slirp4netns</a></b>(1) to create a user network stack. It is possible to
                specify  these  additional  options,  they  can  also  be  set   with   <b>network_cmd_options</b>   in
                containers.conf:

                • <b>allow_host_loopback=true|false</b>:  Allow  slirp4netns  to reach the host loopback IP (default is
                  10.0.2.2 or the second IP from slirp4netns cidr subnet  when  changed,  see  the  cidr  option
                  below). The default is false.

                • <b>mtu=</b><u>MTU</u>: Specify the MTU to use for this network. (Default is <b>65520</b>).

                • <b>cidr=</b><u>CIDR</u>: Specify ip range to use for this network. (Default is <b>10.0.2.0/24</b>).

                • <b>enable_ipv6=true|false</b>: Enable IPv6. Default is true. (Required for <b>outbound_addr6</b>).

                • <b>outbound_addr=</b><u>INTERFACE</u>: Specify the outbound interface slirp binds to (ipv4 traffic only).

                • <b>outbound_addr=</b><u>IPv4</u>: Specify the outbound ipv4 address slirp binds to.

                • <b>outbound_addr6=</b><u>INTERFACE</u>: Specify the outbound interface slirp binds to (ipv6 traffic only).

                • <b>outbound_addr6=</b><u>IPv6</u>: Specify the outbound ipv6 address slirp binds to.

                • <b>port_handler=rootlesskit</b>: Use rootlesskit for port forwarding. Default.
                  Note:  Rootlesskit  changes  the source IP address of incoming packets to an IP address in the
                  container network namespace, usually <b>10.0.2.100</b>. If the application requires the  real  source
                  IP  address,  e.g.  web  server  logs,  use the slirp4netns port handler. The rootlesskit port
                  handler is also used for rootless containers when connected to user-defined networks.

                • <b>port_handler=slirp4netns</b>: Use the slirp4netns port forwarding, it is slower  than  rootlesskit
                  but preserves the correct source IP address. This port handler cannot be used for user-defined
                  networks.

              • <b>pasta[:OPTIONS,...]</b>: use <b><a href="../man1/pasta.1.html">pasta</a></b>(1) to create a user-mode networking stack.
                This is the default for rootless containers and only supported in rootless mode.
                By  default,  IPv4  and IPv6 addresses and routes, as well as the pod interface name, are copied
                from the host. If port forwarding isn't configured, ports are forwarded dynamically as  services
                are  bound on either side (init namespace or container namespace). Port forwarding preserves the
                original source IP address. Options described in <a href="../man1/pasta.1.html">pasta</a>(1) can be  specified  as  comma-separated
                arguments.
                In terms of <a href="../man1/pasta.1.html">pasta</a>(1) options, <b>--config-net</b> is given by default, in order to configure networking
                when  the  container  is  started,  and  <b>--no-map-gw</b> is also assumed by default, to avoid direct
                access from container to host using the gateway address. The latter can be overridden by passing
                <b>--map-gw</b> in the pasta-specific options (despite not being an actual <a href="../man1/pasta.1.html">pasta</a>(1) option).
                Also, <b>-t</b> <b>none</b> and <b>-u</b> <b>none</b> are passed if, respectively, no TCP or UDP port forwarding  from  host
                to  container  is  configured,  to  disable  automatic  port  forwarding  based  on bound ports.
                Similarly, <b>-T</b> <b>none</b> and <b>-U</b> <b>none</b> are given to disable the same  functionality  from  container  to
                host.
                Some examples:

                • <b>pasta:--map-gw</b>: Allow the container to directly reach the host using the gateway address.

                • <b>pasta:--mtu,1500</b>: Specify a 1500 bytes MTU for the <u>tap</u> interface in the container.

                • <b>pasta:--ipv4-only,-a,10.0.2.0,-n,24,-g,10.0.2.2,--dns-forward,10.0.2.3,-m,1500,--no-ndp,--no-</b>
                  <b>dhcpv6,--no-dhcp</b>,   equivalent   to  default  <a href="../man1/slirp4netns.1.html">slirp4netns</a>(1)  options:  disable  IPv6,  assign
                  <b>10.0.2.0/24</b> to the <b>tap0</b>  interface  in  the  container,  with  gateway  <b>10.0.2.3</b>,  enable  DNS
                  forwarder reachable at <b>10.0.2.3</b>, set MTU to 1500 bytes, disable NDP, DHCPv6 and DHCP support.

                • <b>pasta:-I,tap0,--ipv4-only,-a,10.0.2.0,-n,24,-g,10.0.2.2,--dns-forward,10.0.2.3,--no-ndp,--no-</b>
                  <b>dhcpv6,--no-dhcp</b>,  equivalent to default <a href="../man1/slirp4netns.1.html">slirp4netns</a>(1) options with Podman overrides: same as
                  above, but leave the MTU to 65520 bytes

                • <b>pasta:-t,auto,-u,auto,-T,auto,-U,auto</b>: enable automatic  port  forwarding  based  on  observed
                  bound ports from both host and container sides

                • <b>pasta:-T,5201</b>:  enable  forwarding of TCP port 5201 from container to host, using the loopback
                  interface instead of the tap interface for improved performance

       Invalid if using <b>--dns</b>, <b>--dns-option</b>, or <b>--dns-search</b> with <b>--network</b> set to <b>none</b> or <b>container:</b><u>id</u>.

   <b>--network-alias=</b><u><b>alias</b></u>
       Add a network-scoped alias for the pod, setting the alias for all networks that the container  joins.  To
       set a name only for a specific network, use the alias option as described under the <b>--network</b> option.  If
       the network has DNS enabled (<b>podman</b> <b>network</b> <b>inspect</b> <b>-f</b> <b>{{.DNSEnabled}}</b> <b>&lt;name&gt;</b>), these aliases can be used
       for  name resolution on the given network. This option can be specified multiple times.  NOTE: When using
       CNI a pod only has access to aliases on the first network that it joins. This limitation does  not  exist
       with netavark/aardvark-dns.

   <b>--no-hostname</b>
       Do not create the <u><a href="file:/etc/hostname">/etc/hostname</a></u> file in the containers.

       By  default,  Podman manages the <u><a href="file:/etc/hostname">/etc/hostname</a></u> file, adding the container's own hostname.  When the <b>--no-</b>
       <b>hostname</b> option is set, the image's <u><a href="file:/etc/hostname">/etc/hostname</a></u> will be preserved unmodified if it exists.

   <b>--no-hosts</b>
       Do not modify the <b><a href="file:/etc/hosts">/etc/hosts</a></b> file in the pod.

       Podman assumes control over the pod's <b><a href="file:/etc/hosts">/etc/hosts</a></b> file by default and adds  entries  for  the  container's
       name  (see <b>--name</b> option) and hostname (see <b>--hostname</b> option), the internal <b>host.containers.internal</b> and
       <b>host.docker.internal</b> hosts, as well as any hostname added using  the  <b>--add-host</b>  option.  Refer  to  the
       <b>--add-host</b>  option  for details. Passing <b>--no-hosts</b> disables this, so that the image's <b><a href="file:/etc/hosts">/etc/hosts</a></b> file is
       kept unmodified. The same can be achieved globally by setting <u>no_hosts=true</u> in <b>containers.conf</b>.

       This option conflicts with <b>--add-host</b>.

   <b>--pid=</b><u><b>pid</b></u>
       Set the PID mode for the pod. The default is to create a private PID namespace for the pod. Requires  the
       PID namespace to be shared via --share.

       host: use the host’s PID namespace for the pod
       ns: join the specified PID namespace
       private: create a new namespace for the pod (default)

   <b>--pod-id-file=</b><u><b>path</b></u>
       Write the pod ID to the file.

   <b>--publish,</b> <b>-p=</b><u><b>[[ip:][hostPort]:]containerPort[/protocol]</b></u>
       Publish a container's port, or range of ports, within this pod to the host.

       Both  <u>hostPort</u>  and <u>containerPort</u> can be specified as a range of ports.  When specifying ranges for both,
       the number of container ports in the range must match the number of host ports in the range.

       If host IP is set to 0.0.0.0 or not set at all, the port is bound on all IPs on the host.

       By default, Podman publishes TCP ports. To publish a UDP port instead, give <b>udp</b> as protocol.  To  publish
       both  TCP  and  UDP  ports,  set  <b>--publish</b>  twice,  with <b>tcp</b>, and <b>udp</b> as protocols respectively. Rootful
       containers can also publish ports using the <b>sctp</b> protocol.

       Host port does not have to be specified (e.g. <b>podman</b> <b>run</b> <b>-p</b> <b>127.0.0.1::80</b>).  If it is not, the  container
       port is randomly assigned a port on the host.

       Use <b>podman</b> <b>port</b> to see the actual mapping: <b>podman</b> <b>port</b> <b>$CONTAINER</b> <b>$CONTAINERPORT</b>.

       Note  that  the network drivers <b>macvlan</b> and <b>ipvlan</b> do not support port forwarding, it will have no effect
       on these networks.

       <b>Note:</b> You must not publish ports of containers in the pod individually, but only by the pod itself.

       <b>Note:</b> This cannot be modified once the pod is created.

   <b>--replace</b>
       If another pod with the same name already exists, replace and remove it. The default is <b>false</b>.

   <b>--restart=</b><u><b>policy</b></u>
       Restart policy to follow when containers exit.  Restart policy does not take effect  if  a  container  is
       stopped via the <b>podman</b> <b>kill</b> or <b>podman</b> <b>stop</b> commands.

       Valid <u>policy</u> values are:

              • <b>no</b>                       : Do not restart containers on exit

              • <b>never</b>                    : Synonym for <b>no</b>; do not restart containers on exit

              • <b>on-failure[:max_retries]</b> : Restart containers when they exit with a non-zero exit code, retrying
                indefinitely or until the optional <u>max_retries</u> count is hit

              • <b>always</b>                    :  Restart  containers  when they exit, regardless of status, retrying
                indefinitely

              • <b>unless-stopped</b>           : Identical to <b>always</b>

       Podman provides a systemd unit file, podman-restart.service, which restarts  containers  after  a  system
       reboot.

       When running containers in systemd services, use the restart functionality provided by systemd.  In other
       words,  do  not  use  this  option in a container unit, instead set the <b>Restart=</b> systemd directive in the
       <b>[Service]</b> section.  See <b><a href="../man5/podman-systemd.unit.5.html">podman-systemd.unit</a></b>(5) and <b><a href="../man5/systemd.service.5.html">systemd.service</a></b>(5).

       Default restart policy for all the containers in a pod.

   <b>--security-opt=</b><u><b>option</b></u>
       Security Options

              • <b>apparmor=unconfined</b> : Turn off apparmor confinement for the pod

              • <b>apparmor</b>=<u>alternate-profile</u> : Set the apparmor confinement profile for the pod

              • <b>label=user:</b><u>USER</u>: Set the label user for the pod processes

              • <b>label=role:</b><u>ROLE</u>: Set the label role for the pod processes

              • <b>label=type:</b><u>TYPE</u>: Set the label process type for the pod processes

              • <b>label=level:</b><u>LEVEL</u>: Set the label level for the pod processes

              • <b>label=filetype:</b><u>TYPE</u>: Set the label file type for the pod files

              • <b>label=disable</b>: Turn off label separation for the pod

       Note: Labeling can be disabled for all pods/containers by  setting  label=false  in  the  <b>containers.conf</b>
       (<b>/etc/containers/containers.conf</b> or <b>$HOME/.config/containers/containers.conf</b>) file.

              • <b>label=nested</b>:  Allows  SELinux  modifications  within  the  container. Containers are allowed to
                modify SELinux labels on files and processes, as long as SELinux policy allows. Without  <b>nested</b>,
                containers  view  SELinux  as  disabled,  even  when  it  is enabled on the host. Containers are
                prevented from setting any labels.

              • <b>mask</b>=<u>/path/1:/path/2</u>: The paths to mask separated by a colon. A masked path cannot  be  accessed
                inside the containers within the pod.

              • <b>no-new-privileges</b>: Disable container processes from gaining additional privileges.

              • <b>seccomp=unconfined</b>: Turn off seccomp confinement for the pod.

              • <b>seccomp=profile.json</b>:   JSON   file   to   be   used   as   a  seccomp  filter.  Note  that  the
                <b>io.podman.annotations.seccomp</b> annotation is set with the specified  value  as  shown  in  <b>podman</b>
                <b>inspect</b>.

              • <b>proc-opts</b>=<u>OPTIONS</u> : Comma-separated list of options to use for the <a href="file:/proc">/proc</a> mount. More details for
                the possible mount options are specified in the <b><a href="../man5/proc.5.html">proc</a>(5)</b> man page.

              • <b>unmask</b>=<u>ALL</u> or <u>/path/1:/path/2</u>, or shell expanded paths (<a href="file:/proc/">/proc/</a>*): Paths to unmask separated by a
                colon.  If  set  to  <b>ALL</b>, it unmasks all the paths that are masked or made read-only by default.
                The  default  masked  paths  are  <b><a href="file:/proc/acpi">/proc/acpi</a>,</b>  <b><a href="file:/proc/kcore">/proc/kcore</a>,</b>   <b><a href="file:/proc/keys">/proc/keys</a>,</b>   <b><a href="file:/proc/latency_stats">/proc/latency_stats</a>,</b>
                <b>/proc/sched_debug,</b>   <b><a href="file:/proc/scsi">/proc/scsi</a>,</b>   <b><a href="file:/proc/timer_list">/proc/timer_list</a>,</b>   <b>/proc/timer_stats,</b>   <b><a href="file:/sys/firmware">/sys/firmware</a>,</b>   <b>and</b>
                <b>/sys/fs/selinux</b>, <b>/sys/devices/virtual/powercap</b>.   The  default  paths  that  are  read-only  are
                <b>/proc/asound</b>, <b><a href="file:/proc/bus">/proc/bus</a></b>, <b><a href="file:/proc/fs">/proc/fs</a></b>, <b><a href="file:/proc/irq">/proc/irq</a></b>, <b><a href="file:/proc/sys">/proc/sys</a></b>, <b><a href="file:/proc/sysrq-trigger">/proc/sysrq-trigger</a></b>, <b><a href="file:/sys/fs/cgroup">/sys/fs/cgroup</a></b>.

       Note: Labeling can be disabled for all containers by setting <b>label=false</b> in the <b><a href="../man5/containers.conf.5.html">containers.conf</a></b>(5) file.

   <b>--share=</b><u><b>namespace</b></u>
       A  comma-separated  list  of  kernel  namespaces  to share. If none or "" is specified, no namespaces are
       shared, and the infra container  is  not  created  unless  explicitly  specified  via  <b>--infra=true</b>.  The
       namespaces  to  choose  from  are  cgroup,  ipc, net, pid, uts. If the option is prefixed with a "+", the
       namespace is appended to the default list. Otherwise,  it  replaces  the  default  list.  Defaults  match
       Kubernetes default (ipc, net, uts)

   <b>--share-parent</b>
       This  boolean  determines  whether  or  not  all  containers entering the pod use the pod as their cgroup
       parent. The default value of this option is true. Use the <b>--share</b> option to share  the  cgroup  namespace
       rather than a cgroup parent in a pod.

       Note:  This  option conflicts with the <b>--share=cgroup</b> option since that option sets the pod as the cgroup
       parent but enters the container into the same cgroupNS as the infra container.

   <b>--shm-size=</b><u><b>number[unit]</b></u>
       Size of <u><a href="file:/dev/shm">/dev/shm</a></u>. A <u>unit</u> can be <b>b</b> (bytes), <b>k</b> (kibibytes), <b>m</b> (mebibytes), or <b>g</b> (gibibytes).  If  the  unit
       is  omitted, the system uses bytes. If the size is omitted, the default is <b>64m</b>.  When <u>size</u> is <b>0</b>, there is
       no limit on the amount of memory used for IPC by the pod.  This option conflicts with <b>--ipc=host</b>.

   <b>--shm-size-systemd=</b><u><b>number[unit]</b></u>
       Size of systemd-specific tmpfs mounts such as <a href="file:/run">/run</a>, <a href="file:/run/lock">/run/lock</a>, <a href="file:/var/log/journal">/var/log/journal</a> and /tmp.  A <u>unit</u> can  be
       <b>b</b>  (bytes),  <b>k</b>  (kibibytes),  <b>m</b>  (mebibytes),  or <b>g</b> (gibibytes).  If the unit is omitted, the system uses
       bytes. If the size is omitted, the default is <b>64m</b>.  When <u>size</u> is <b>0</b>, the usage is limited to  50%  of  the
       host's available memory.

   <b>--subgidname=</b><u><b>name</b></u>
       Run  the  container  in a new user namespace using the map with <u>name</u> in the <u><a href="file:/etc/subgid">/etc/subgid</a></u> file.  If running
       rootless, the user needs to have the right to use the mapping. See <b><a href="../man5/subgid.5.html">subgid</a></b>(5).  This flag  conflicts  with
       <b>--userns</b> and <b>--gidmap</b>.

   <b>--subuidname=</b><u><b>name</b></u>
       Run  the  container  in a new user namespace using the map with <u>name</u> in the <u><a href="file:/etc/subuid">/etc/subuid</a></u> file.  If running
       rootless, the user needs to have the right to use the mapping. See <b><a href="../man5/subuid.5.html">subuid</a></b>(5).  This flag  conflicts  with
       <b>--userns</b> and <b>--uidmap</b>.

   <b>--sysctl=</b><u><b>name=value</b></u>
       Configure namespaced kernel parameters for all containers in the pod.

       For the IPC namespace, the following sysctls are allowed:

              • kernel.msgmax

              • kernel.msgmnb

              • kernel.msgmni

              • kernel.sem

              • kernel.shmall

              • kernel.shmmax

              • kernel.shmmni

              • kernel.shm_rmid_forced

              • Sysctls beginning with fs.mqueue.*

       Note: if the ipc namespace is not shared within the pod, the above sysctls are not allowed.

       For the network namespace, only sysctls beginning with net.* are allowed.

       Note: if the network namespace is not shared within the pod, the above sysctls are not allowed.

   <b>--uidmap=</b><u><b>container_uid:from_uid:amount</b></u>
       Run  all  containers in the pod in a new user namespace using the supplied mapping. This option conflicts
       with the <b>--userns</b> and <b>--subuidname</b> options. This option provides a way to  map  host  UIDs  to  container
       UIDs. It can be passed several times to map different ranges.

   <b>--userns=</b><u><b>mode</b></u>
       Set the user namespace mode for all the containers in a pod. It defaults to the <b>PODMAN_USERNS</b> environment
       variable. An empty value ("") means user namespaces are disabled.

       Rootless user --userns=Key mappings:

       ┌─────────┬───────────┬──────────────────────────────┐
       │ <b>Key</b>     │ <b>Host</b> <b>User</b> │ <b>Container</b> <b>User</b>               │
       ├─────────┼───────────┼──────────────────────────────┤
       │ ""      │ $UID      │ 0   (Default   User  account │
       │         │           │ mapped  to  root   user   in │
       │         │           │ container.)                  │
       ├─────────┼───────────┼──────────────────────────────┤
       │ host    │ $UID      │ 0   (Default   User  account │
       │         │           │ mapped  to  root   user   in │
       │         │           │ container.)                  │
       ├─────────┼───────────┼──────────────────────────────┤
       │ keep-id │ $UID      │ $UID  (Map  user  account to │
       │         │           │ same UID within container.)  │
       ├─────────┼───────────┼──────────────────────────────┤
       │ auto    │ $UID      │ nil (Host User  UID  is  not │
       │         │           │ mapped into container.)      │
       ├─────────┼───────────┼──────────────────────────────┤
       │ nomap   │ $UID      │ nil  (Host  User  UID is not │
       │         │           │ mapped into container.)      │
       └─────────┴───────────┴──────────────────────────────┘

       Valid <u>mode</u> values are:

              • <u>auto[:OPTIONS,...]</u>: automatically create a namespace. It is possible to specify these options to
                <b>auto</b>:

                • <u>gidmapping=CONTAINER_GID:HOST_GID:SIZE</u> to force a GID  mapping  to  be  present  in  the  user
                  namespace.

                • <u>size=SIZE</u>:   to   specify   an   explicit   size   for  the  automatic  user  namespace.  e.g.
                  <b>--userns=auto:size=8192</b>. If <b>size</b> is not specified,  <b>auto</b>  estimates  the  size  for  the  user
                  namespace.

                • <u>uidmapping=CONTAINER_UID:HOST_UID:SIZE</u>  to  force  a  UID  mapping  to  be present in the user
                  namespace.

              • <u>host</u>: run in the user namespace of the caller. The processes running in the container  have  the
                same privileges on the host as any other process launched by the calling user (default).

              • <u>keep-id</u>:  creates  a  user namespace where the current rootless user's UID:GID are mapped to the
                same values in the container. This option is not allowed for  containers  created  by  the  root
                user.

              • <u>nomap</u>:  creates  a  user namespace where the current rootless user's UID:GID are not mapped into
                the container. This option is not allowed for containers created by the root user.

   <b>--uts=</b><u><b>mode</b></u>
       Set the UTS namespace mode for the pod. The following values are supported:

              • <b>host</b>: use the host's UTS namespace inside the pod.

              • <b>private</b>: create a new namespace for the pod (default).

              • <b>ns:[path]</b>: run the pod in the given existing UTS namespace.

   <b>--volume,</b> <b>-v=</b><u><b>[[SOURCE-VOLUME|HOST-DIR:]CONTAINER-DIR[:OPTIONS]]</b></u>
       Create a bind mount. If <b>-v</b> <b>/HOST-DIR:/CONTAINER-DIR</b> is specified, Podman bind mounts <b>/HOST-DIR</b>  from  the
       host  into  <b>/CONTAINER-DIR</b> in the Podman container. Similarly, <b>-v</b> <b>SOURCE-VOLUME:/CONTAINER-DIR</b> mounts the
       named volume from the host into the container. If no such named volume exists, Podman creates one. If  no
       source is given, the volume is created as an anonymously named volume with a randomly generated name, and
       is removed when the pod is removed via the <b>--rm</b> flag or the <b>podman</b> <b>rm</b> <b>--volumes</b> command.

       (Note  when using the remote client, including Mac and Windows (excluding WSL2) machines, the volumes are
       mounted from the remote server, not necessarily the client machine.)

       The <u>OPTIONS</u> is a comma-separated list and can be one or more of:

              • <b>rw</b>|<b>ro</b>

              • <b>z</b>|<b>Z</b>

              • [<b>O</b>]

              • [<b>U</b>]

              • [<b>no</b>]<b>copy</b>

              • [<b>no</b>]<b>dev</b>

              • [<b>no</b>]<b>exec</b>

              • [<b>no</b>]<b>suid</b>

              • [<b>r</b>]<b>bind</b>

              • [<b>r</b>]<b>shared</b>|[<b>r</b>]<b>slave</b>|[<b>r</b>]<b>private</b>[<b>r</b>]<b>unbindable</b> [1] ⟨#Footnote1⟩

              • <b>idmap</b>[=<b>options</b>]

       The <b>CONTAINER-DIR</b> must be an absolute path such as <b>/src/docs</b>. The volume is mounted into the container at
       this directory.

       If a volume source is specified, it must be a path on the host or the name of a named volume. Host  paths
       are  allowed  to be absolute or relative; relative paths are resolved relative to the directory Podman is
       run in. If the source does not exist, Podman returns an error. Users must pre-create the source files  or
       directories.

       Any  source  that does not begin with a <b>.</b> or <b>/</b> is treated as the name of a named volume. If a volume with
       that name does not exist, it is created.  Volumes created with names are not anonymous, and they are  not
       removed by the <b>--rm</b> option and the <b>podman</b> <b>rm</b> <b>--volumes</b> command.

       Specify multiple <b>-v</b> options to mount one or more volumes into a pod.

       <b>Write</b> <b>Protected</b> <b>Volume</b> <b>Mounts</b>

       Add  <b>:ro</b>  or  <b>:rw</b> option to mount a volume in read-only or read-write mode, respectively. By default, the
       volumes are mounted read-write.  See examples.

       <b>Chowning</b> <b>Volume</b> <b>Mounts</b>

       By default, Podman does not change the  owner  and  group  of  source  volume  directories  mounted  into
       containers.  If a pod is created in a new user namespace, the UID and GID in the container may correspond
       to another UID and GID on the host.

       The <b>:U</b> suffix tells Podman to use the correct host UID and GID based on the UID and GID within  the  pod,
       to  change recursively the owner and group of the source volume. Chowning walks the file system under the
       volume and changes the UID/GID on each file. If the volume has thousands of inodes, this process takes  a
       long time, delaying the start of the pod.

       <b>Warning</b> use with caution since this modifies the host filesystem.

       <b>Labeling</b> <b>Volume</b> <b>Mounts</b>

       Labeling systems like SELinux require that proper labels are placed on volume content mounted into a pod.
       Without  a  label,  the security system might prevent the processes running inside the pod from using the
       content. By default, Podman does not change the labels set by the OS.

       To change a label in the pod context, add either of two suffixes <b>:z</b> or <b>:Z</b>  to  the  volume  mount.  These
       suffixes tell Podman to relabel file objects on the shared volumes. The <b>z</b> option tells Podman that two or
       more  pods  share the volume content. As a result, Podman labels the content with a shared content label.
       Shared volume labels allow all containers to read/write content. The <b>Z</b> option tells Podman to  label  the
       content with a private unshared label Only the current pod can use a private volume. Note: all containers
       within  a  <b>pod</b>  share  the  same  SELinux label. This means all containers within said pod can read/write
       volumes shared into the container created with the <b>:Z</b> on any of one the containers. Relabeling walks  the
       file  system  under the volume and changes the label on each file, if the volume has thousands of inodes,
       this process takes a long time, delaying the start of the pod. If the  volume  was  previously  relabeled
       with  the <b>z</b> option, Podman is optimized to not relabel a second time. If files are moved into the volume,
       then the labels can be manually change with the <b>chcon</b> <b>-Rt</b> <b>container_file_t</b> <b>PATH</b> command.

       Note: Do not relabel system files and directories. Relabeling system content might cause  other  confined
       services  on  the  machine  to  fail.   For  these  types  of  containers  we recommend disabling SELinux
       separation.  The option <b>--security-opt</b> <b>label=disable</b>  disables  SELinux  separation  for  the  pod.   For
       example  if  a  user  wanted to volume mount their entire home directory into a pod, they need to disable
       SELinux separation.

       $ podman pod create --security-opt label=disable -v $HOME:/home/user fedora touch /home/user/file

       <b>Overlay</b> <b>Volume</b> <b>Mounts</b>

       The <b>:O</b> flag tells Podman to mount the directory from the host as a temporary storage  using  the  <b>overlay</b>
       <b>file</b>  <b>system</b>. The pod processes can modify content within the mountpoint which is stored in the container
       storage in a separate directory. In overlay terms, the source directory is the lower, and  the  container
       storage  directory  is  the  upper.  Modifications to the mount point are destroyed when the pod finishes
       executing, similar to a tmpfs mount point being unmounted.

       For advanced users, the <b>overlay</b> option also supports custom non-volatile <b>upperdir</b>  and  <b>workdir</b>  for  the
       overlay  mount. Custom <b>upperdir</b> and <b>workdir</b> can be fully managed by the users themselves, and Podman does
       not remove it on lifecycle completion.  Example <b>:O,upperdir=/some/upper,workdir=/some/work</b>

       Subsequent executions of the container sees the original  source  directory  content,  any  changes  from
       previous pod executions no longer exist.

       One  use case of the overlay mount is sharing the package cache from the host into the container to allow
       speeding up builds.

       Note: The <b>O</b> flag conflicts with other options listed above.

       Content mounted into the container is labeled with the private label.  On SELinux systems, labels in  the
       source  directory  must be readable by the pod infra container label. Usually containers can read/execute
       <b>container_share_t</b> and can read/write <b>container_file_t</b>. If unable to change the labels on a source volume,
       SELinux container separation must be disabled for the pod or infra container to work.

       Do not modify the source directory mounted into the pod with an overlay mount, it  can  cause  unexpected
       failures. Only modify the directory after the container finishes running.

       <b>Mounts</b> <b>propagation</b>

       By  default,  bind-mounted volumes are <b>private</b>. That means any mounts done inside the pod are not visible
       on the host and vice versa.  One can change this  behavior  by  specifying  a  volume  mount  propagation
       property.   When a volume is <b>shared</b>, mounts done under that volume inside the pod are visible on host and
       vice versa. Making a volume <b>slave</b>[1] ⟨#Footnote1⟩ enables only one-way mount propagation: mounts done  on
       the host under that volume are visible inside the container but not the other way around.

       To  control mount propagation property of a volume one can use the [<b>r</b>]<b>shared</b>, [<b>r</b>]<b>slave</b>, [<b>r</b>]<b>private</b> or the
       [<b>r</b>]<b>unbindable</b> propagation flag.  Propagation property can be specified only for bind mounted volumes  and
       not  for  internal  volumes  or  named volumes. For mount propagation to work the source mount point (the
       mount point where source dir is mounted on) has to have the  right  propagation  properties.  For  shared
       volumes, the source mount point has to be shared. And for slave volumes, the source mount point has to be
       either shared or slave.  [1] ⟨#Footnote1⟩

       To  recursively  mount a volume and all of its submounts into a pod, use the <b>rbind</b> option. By default the
       bind option is used, and submounts of the source directory is not mounted into the pod.

       Mounting the volume with a <b>copy</b> option tells podman to  copy  content  from  the  underlying  destination
       directory  onto  newly  created  internal  volumes.  The <b>copy</b> only happens on the initial creation of the
       volume. Content is not copied up when the volume is subsequently used on different containers.  The  <b>copy</b>
       option is ignored on bind mounts and has no effect.

       Mounting  volumes  with  the  <b>nosuid</b> options means that SUID executables on the volume can not be used by
       applications to change their privilege. By default volumes are mounted with <b>nosuid</b>.

       Mounting the volume with the <b>noexec</b> option means that no executables on the volume can be executed within
       the pod.

       Mounting the volume with the <b>nodev</b> option means that no devices on the volume can be  used  by  processes
       within the pod. By default volumes are mounted with <b>nodev</b>.

       If the <u>HOST-DIR</u> is a mount point, then <b>dev</b>, <b>suid</b>, and <b>exec</b> options are ignored by the kernel.

       Use  <b>df</b>  <b>HOST-DIR</b> to figure out the source mount, then use <b>findmnt</b> <b>-o</b> <b>TARGET,PROPAGATION</b> <u>source-mount-dir</u>
       <u>to</u> <u>figure</u> <u>out</u> <u>propagation</u> <u>properties</u> <u>of</u> <u>source</u> <u>mount.</u> <u>If</u> <b>findmnt</b><u>(1)</u> <u>utility</u> <u>is</u> <u>not</u>  <u>available,</u>  <u>then</u>  <u>one</u>
       <u>can</u>  <u>look</u>  <u>at</u>  <u>the</u>  <u>mount</u> <u>entry</u> <u>for</u> <u>the</u> <u>source</u> <u>mount</u> <u>point</u> <u>in</u> <u>/proc/self/mountinfo.</u> <u>Look</u> <u>at</u> <u>the</u> <u>"optional</u>
       <u>fields"</u> <u>and</u> <u>see</u> <u>if</u> <u>any</u> <u>propagation</u> <u>properties</u> <u>are</u> <u>specified.</u>  <u>In</u>  <u>there,</u>  <b>shared:N</b>  <u>means</u>  <u>the</u>  <u>mount</u>  <u>is</u>
       <u>shared,</u> <b>master:N</b> <u>means</u> <u>mount</u> <u>is</u> <u>slave,</u> <u>and</u> <u>if</u> <u>nothing</u> <u>is</u> <u>there,</u> <u>the</u> <u>mount</u> <u>is</u> <u>private.</u> <u>[1]</u> <u>⟨#Footnote1⟩</u>

       To  change  propagation  properties  of a mount point, use <b><a href="../man8/mount.8.html">mount</a></b>(8) command. For example, if one wants to
       bind mount source directory <u>/foo</u>, one can do <b>mount</b> <b>--bind</b> <b>/foo</b>  <b>/foo</b>  and  <b>mount</b>  <b>--make-private</b>  <b>--make-</b>
       <b>shared</b>  <b>/foo</b>.  This  converts  /foo  into  a  shared  mount point. Alternatively, one can directly change
       propagation properties of source mount. Say <u>/</u> is source mount for <u>/foo</u>, then use <b>mount</b> <b>--make-shared</b> <b>/</b> to
       convert <u>/</u> into a shared mount.

       Note: if the user only has access rights via a group, accessing the volume from  inside  a  rootless  pod
       fails.

       <b>Idmapped</b> <b>mount</b>

       If  <b>idmap</b> is specified, create an idmapped mount to the target user namespace in the container. The idmap
       option supports a custom mapping that can be different than the user namespace used by the container. The
       mapping can be specified after the idmap option like: <b>idmap=uids=0-1-10#10-11-10;gids=0-100-10</b>.  For each
       triplet, the first value is the start of the backing file system IDs that are mapped to the second  value
       on the host.  The length of this mapping is given in the third value.  Multiple ranges are separated with
       #.

   <b>--volumes-from=</b><u><b>CONTAINER[:OPTIONS]</b></u>
       Mount  volumes  from  the  specified container(s). Used to share volumes between containers and pods. The
       <u>options</u> is a comma-separated list with the following available elements:

              • <b>rw</b>|<b>ro</b>

              • <b>z</b>

       Mounts already mounted volumes from a source container onto another pod. <u>CONTAINER</u> may be a name  or  ID.
       To share a volume, use the --volumes-from option when running the target container. Volumes can be shared
       even if the source container is not running.

       By  default, Podman mounts the volumes in the same mode (read-write or read-only) as it is mounted in the
       source container.  This can be changed by adding a <b>ro</b> or <b>rw</b> <u>option</u>.

       Labeling systems like SELinux require that proper labels are placed on volume content mounted into a pod.
       Without a label, the security system might prevent the processes running inside the container from  using
       the content. By default, Podman does not change the labels set by the OS.

       To  change  a  label  in the pod context, add <b>z</b> to the volume mount.  This suffix tells Podman to relabel
       file objects on the shared volumes. The <b>z</b> option tells Podman that two entities share the volume content.
       As a result, Podman labels the content with a shared  content  label.  Shared  volume  labels  allow  all
       containers to read/write content.

       If the location of the volume from the source container overlaps with data residing on a target pod, then
       the volume hides that data on the target.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Create a named pod.

       $ podman pod create --name test

       Create a named pod.

       $ podman pod create mypod

       Create a pod without an infra container.

       $ podman pod create --infra=false

       Create a named pod with infra container command to run.

       $ podman pod create --infra-command /top toppod

       Create a pod with published ports on the host.

       $ podman pod create --publish 8443:443

       Create a pod with the specified network configuration.

       $ podman pod create --network slirp4netns:outbound_addr=127.0.0.1,allow_host_loopback=true

       Create a pod with the specified network.

       $ podman pod create --network pasta

       Create a pod on two networks.

       $ podman pod create --network net1:ip=10.89.1.5 --network net2:ip=10.89.10.10

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/podman.1.html">podman</a>(1)</b>, <b><a href="../man1/podman-pod.1.html">podman-pod</a>(1)</b>, <b><a href="../man1/podman-kube-play.1.html">podman-kube-play</a>(1)</b>, <b><a href="../man1/containers.conf.1.html">containers.conf</a>(1)</b>, <b><a href="../man7/cgroups.7.html">cgroups</a>(7)</b>

   <b>Troubleshooting</b>
       See <a href="../man7/podman-troubleshooting.7.html">podman-troubleshooting</a>(7) for solutions to common issues.

</pre><h4><b>HISTORY</b></h4><pre>
       July 2018, Originally compiled by Peter Hunt <a href="mailto:pehunt@redhat.com">pehunt@redhat.com</a> ⟨<a href="mailto:pehunt@redhat.com">mailto:pehunt@redhat.com</a>⟩

</pre><h4><b>FOOTNOTES</b></h4><pre>
       1:  The  Podman  project  is  committed to inclusivity, a core value of open source. The <b>master</b> and <b>slave</b>
       mount propagation terminology used here is problematic and divisive, and needs to  be  changed.  However,
       these  terms  are  currently  used  within the Linux kernel and must be used as-is at this time. When the
       kernel maintainers rectify this usage, Podman will follow suit immediately.

                                                                                            <u><a href="../man1/podman-pod-create.1.html">podman-pod-create</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>