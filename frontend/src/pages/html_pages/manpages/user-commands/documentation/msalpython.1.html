<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>msalpython - MSAL Python Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python3-msal">python3-msal_1.32.0-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       msalpython - MSAL Python Documentation

       You can find high level conceptual documentations in the project <u>README</u>.

</pre><h4><b>SCENARIOS</b></h4><pre>
       There  are  many  <u>different</u>  <u>application</u>  <u>scenarios</u>.   MSAL  Python supports some of them.  <b>The</b> <b>following</b>
       <b>diagram</b> <b>serves</b> <b>as</b> <b>a</b> <b>map.</b> <b>Locate</b> <b>your</b> <b>application</b> <b>scenario</b> <b>on</b> <b>the</b>  <b>map.</b>   <b>If</b>  <b>the</b>  <b>corresponding</b>  <b>icon</b>  <b>is</b>
       <b>clickable,</b> <b>it</b> <b>will</b> <b>bring</b> <b>you</b> <b>to</b> <b>an</b> <b>MSAL</b> <b>Python</b> <b>sample</b> <b>for</b> <b>that</b> <b>scenario.</b>

       • Most authentication scenarios acquire tokens representing the signed-in user.

       • There are also daemon apps, who acquire tokens representing themselves, not a user.

       • There are other less common samples, such for ADAL-to-MSAL migration, <u>available</u> <u>inside</u> <u>the</u> <u>project</u> <u>code</u>
         <u>base</u>.

</pre><h4><b>API</b> <b>REFERENCE</b></h4><pre>
       <b>NOTE:</b>
          Only  the  contents  inside  <u>this</u> <u>source</u> <u>file</u> and their documented methods (unless otherwise marked as
          deprecated) are MSAL Python public API, which are guaranteed to be backward-compatible until the  next
          major version.

          Everything  else,  regardless of their naming, are all internal helpers, which could change at anytime
          in the future, without prior notice.

       The following section is the API Reference of MSAL Python.  The API Reference is like a dictionary, which
       is useful when:

       • You already followed our sample(s) above and have your app up and running, but want to know more on how
         you could tweak the authentication experience by using other optional parameters (there are  plenty  of
         them!)

       • Some important features have their in-depth documentations in the API Reference.

       MSAL proposes a clean separation between <u>public</u> <u>client</u> <u>applications</u> <u>and</u> <u>confidential</u> <u>client</u> <u>applications</u>.

       They  are  implemented  as  two  separated  classes,  with different methods for different authentication
       scenarios.

   <b>ClientApplication</b>
       <b>class</b> <b>msal.ClientApplication(client_id,</b> <b>client_credential=None,</b> <b>authority=None,</b> <b>validate_authority=True,</b>
       <b>token_cache=None,</b> <b>http_client=None,</b> <b>verify=True,</b> <b>proxies=None,</b> <b>timeout=None,</b> <b>client_claims=None,</b>
       <b>app_name=None,</b> <b>app_version=None,</b> <b>client_capabilities=None,</b> <b>azure_region=None,</b> <b>exclude_scopes=None,</b>
       <b>http_cache=None,</b> <b>instance_discovery=None,</b> <b>allow_broker=None,</b> <b>enable_pii_log=None,</b> <b>oidc_authority=None)</b>
              You do not usually directly use this class. Use its  subclasses  instead:  <u>PublicClientApplication</u>
              and <u>ConfidentialClientApplication</u>.

              <b>__init__(client_id,</b> <b>client_credential=None,</b> <b>authority=None,</b> <b>validate_authority=True,</b>
              <b>token_cache=None,</b> <b>http_client=None,</b> <b>verify=True,</b> <b>proxies=None,</b> <b>timeout=None,</b> <b>client_claims=None,</b>
              <b>app_name=None,</b> <b>app_version=None,</b> <b>client_capabilities=None,</b> <b>azure_region=None,</b> <b>exclude_scopes=None,</b>
              <b>http_cache=None,</b> <b>instance_discovery=None,</b> <b>allow_broker=None,</b> <b>enable_pii_log=None,</b>
              <b>oidc_authority=None)</b>
                     Create an instance of application.

                     <b>Parameters</b>

                            • <b>client_id</b>  (<u>str</u>)  --  Your  app has a client_id after you register it on Microsoft
                              Entra admin center.

                            • <b>client_credential</b> (<u>Union[dict,</u> <u>str,</u> <u>None]</u>) --

                              For <u>PublicClientApplication</u>, you use <u>None</u> here.

                              For <u>ConfidentialClientApplication</u>, it supports many different  input  formats  for
                              different scenarios.

                                 Support using a client secret.

                                        Just feed in a string, such as <b>"your</b> <b>client</b> <b>secret"</b>.

                                 Support using a certificate in X.509 (.pem) format

                                        Feed in a dict in this form:

                                     {
                                         "private_key": "...-----BEGIN PRIVATE KEY-----... in PEM format",
                                         "thumbprint": "A1B2C3D4E5F6...",
                                         "passphrase": "Passphrase if the private_key is encrypted (Optional. Added in version 1.6.0)",
                                     }

                                 MSAL  Python requires a "private_key" in PEM format.  If your cert is in PKCS12
                                 (.pfx) format, you can convert it to X.509 (.pem) format, by <b>openssl</b> <b>pkcs12</b> <b>-in</b>
                                 <b>file.pfx</b> <b>-out</b> <b>file.pem</b> <b>-nodes</b>.

                                 The thumbprint is  available  in  your  app's  registration  in  Azure  Portal.
                                 Alternatively, you can <u>calculate</u> <u>the</u> <u>thumbprint</u>.

                                 Support Subject Name/Issuer Auth with a cert in .pem

                                        <u>Subject</u>  <u>Name/Issuer</u>  <u>Auth</u>  is  an  approach to allow easier certificate
                                        rotation.

                                        <u>Added</u> <u>in</u> <u>version</u> <u>0.5.0</u>:

                                     {
                                         "private_key": "...-----BEGIN PRIVATE KEY-----... in PEM format",
                                         "thumbprint": "A1B2C3D4E5F6...",
                                         "public_certificate": "...-----BEGIN CERTIFICATE-----...",
                                         "passphrase": "Passphrase if the private_key is encrypted (Optional. Added in version 1.6.0)",
                                     }

                                 <b>public_certificate</b> (optional) is public key  certificate  which  will  be  sent
                                 through  'x5c'  JWT  header  only for subject name and issuer authentication to
                                 support cert auto rolls.

                                 Per <u>specs</u>, "the certificate containing the public key corresponding to the  key
                                 used  to  digitally  sign  the  JWS MUST be the first certificate.  This MAY be
                                 followed by additional certificates, with each subsequent certificate being the
                                 one used to certify the previous one." However, your certificate's  issuer  may
                                 use  a different order.  So, if your attempt ends up with an error AADSTS700027
                                 - "The provided signature value did not match the  expected  signature  value",
                                 you may try use only the leaf cert (in PEM/str format) instead.

                                 Supporting raw assertion obtained from elsewhere

                                        <u>Added</u>  <u>in</u>  <u>version</u>  <u>1.13.0</u>:  It  can  also  be  a  completely pre-signed
                                        assertion that you've  assembled  yourself.   Simply  pass  a  container
                                        containing only the key "client_assertion", like this:

                                     {
                                         "client_assertion": "...a JWT with claims aud, exp, iss, jti, nbf, and sub..."
                                     }

                                 Supporting reading client cerficates from PFX files

                                        <u>Added</u>  <u>in</u>  <u>version</u> <u>1.29.0</u>: Feed in a dictionary containing the path to a
                                        PFX file:

                                     {
                                         "private_key_pfx_path": "/path/to/your.pfx",
                                         "passphrase": "Passphrase if the private_key is encrypted (Optional)",
                                     }

                                 The following command will generate a .pfx file from your .key and .pem file:

                                     openssl pkcs12 -export -out certificate.pfx -inkey privateKey.key -in certificate.pem

                                 Support Subject Name/Issuer Auth with a cert in .pfx

                                        <u>Added</u> <u>in</u> <u>version</u> <u>1.30.0</u>: If your .pfx file contains both the private key
                                        and public cert, you can opt in for Subject Name/Issuer Auth like this:

                                     {
                                         "private_key_pfx_path": "/path/to/your.pfx",
                                         "public_certificate": True,
                                         "passphrase": "Passphrase if the private_key is encrypted (Optional)",
                                     }

                            • <b>client_claims</b> (<u>dict</u>) --

                              <u>Added</u> <u>in</u> <u>version</u> <u>0.5.0</u>: It is a dictionary of extra claims that would be signed by
                              by this <u>ConfidentialClientApplication</u> 's private key.  For example,  you  can  use
                              {"client_ip":  "x.x.x.x"}.   You  may  also  override any of the following default
                              claims:

                                 {
                                     "aud": the_token_endpoint,
                                     "iss": self.client_id,
                                     "sub": same_as_issuer,
                                     "exp": now + 10_min,
                                     "iat": now,
                                     "jti": a_random_uuid
                                 }

                            • <b>authority</b> (<u>str</u>) --

                              A  URL  that  identifies  a  token  authority.  It  should  be   of   the   format
                              <b>https://login.microsoftonline.com/your_tenant</b>    By    default,    we   will   use
                              <b>https://login.microsoftonline.com/common</b>

                              <u>Changed</u> <u>in</u> <u>version</u> <u>1.17</u>: you can also use predefined constant and a  builder  like
                              this:

                                 from msal.authority import (
                                     AuthorityBuilder,
                                     AZURE_US_GOVERNMENT, AZURE_CHINA, AZURE_PUBLIC)
                                 my_authority = AuthorityBuilder(AZURE_PUBLIC, "contoso.onmicrosoft.com")
                                 # Now you get an equivalent of
                                 # "https://login.microsoftonline.com/contoso.onmicrosoft.com"

                                 # You can feed such an authority to msal's ClientApplication
                                 from msal import PublicClientApplication
                                 app = PublicClientApplication("my_client_id", authority=my_authority, ...)

                            • <b>validate_authority</b> (<u>bool</u>) -- (optional) Turns authority validation on or off. This
                              parameter default to true.

                            • <b>token_cache</b>  (<u>TokenCache</u>)  --  Sets the token cache used by this ClientApplication
                              instance.  By default, an in-memory cache will be created and used.

                            • <b>http_client</b>  --  (optional)  Your  implementation  of  abstract  class  HttpClient
                              &lt;msal.oauth2cli.http.http_client&gt;  Defaults to a requests session instance.  Since
                              MSAL 1.11.0, the default session would be  configured  to  attempt  one  retry  on
                              connection  error.   If  you  are  providing your own http_client, it will be your
                              http_client's duty to decide whether to perform retry.

                            • <b>verify</b> -- (optional) It will be passed to the <u>verify</u> <u>parameter</u> <u>in</u>  <u>the</u>  <u>underlying</u>
                              <u>requests</u>  <u>library</u>  This  does  not  apply if you have chosen to pass your own Http
                              client

                            • <b>proxies</b> -- (optional) It will be passed to the <u>proxies</u> <u>parameter</u> <u>in</u> <u>the</u> <u>underlying</u>
                              <u>requests</u> <u>library</u> This does not apply if you have chosen  to  pass  your  own  Http
                              client

                            • <b>timeout</b> -- (optional) It will be passed to the <u>timeout</u> <u>parameter</u> <u>in</u> <u>the</u> <u>underlying</u>
                              <u>requests</u>  <u>library</u>  This  does  not  apply if you have chosen to pass your own Http
                              client

                            • <b>app_name</b> -- (optional)  You  can  provide  your  application  name  for  Microsoft
                              telemetry  purposes.   Default  value  is  None,  means  it  will not be passed to
                              Microsoft.

                            • <b>app_version</b> -- (optional) You can provide your application version  for  Microsoft
                              telemetry  purposes.   Default  value  is  None,  means  it  will not be passed to
                              Microsoft.

                            • <b>client_capabilities</b> (<u>list[str]</u>) --

                              (optional) Allows configuration of one or more client capabilities, e.g. ["CP1"].

                              Client capability is meant to inform the Microsoft identity  platform  (STS)  what
                              this  client  is  capable for, so STS can decide to turn on certain features.  For
                              example, if client is capable to handle <u>claims</u> <u>challenge</u>, STS may issue <u>Continuous</u>
                              <u>Access</u> <u>Evaluation</u> <u>(CAE)</u> access tokens to resources, knowing that when the resource
                              emits a <u>claims</u> <u>challenge</u> the client will be able to handle those challenges.

                              Implementation details: Client capability is implemented using "claims"  parameter
                              on the wire, for now.  MSAL will combine them into <u>claims</u> <u>parameter</u> which you will
                              later provide via one of the acquire-token request.

                            • <b>azure_region</b> (<u>str</u>) --

                              (optional)  Instructs  MSAL  to  use the Entra regional token service. This legacy
                              feature    is    only    available    to    first-party     applications.     Only
                              <b>acquire_token_for_client()</b> is supported.

                              Supports 4 values:

                              1. <b>azure_region=None</b>  -  This  default  value means no region is configured.  MSAL
                                 will use the region defined in env var <b>MSAL_FORCE_REGION</b>.

                              2. <b>azure_region="some_region"</b> - meaning the specified region is used.

                              3. <b>azure_region=True</b> - meaning MSAL will try to auto-detect the  region.  This  is
                                 not recommended.

                              4. <b>azure_region=False</b> - meaning MSAL will use no region.

                              <b>NOTE:</b>
                                 Region  auto-discovery  has  been  tested  on VMs and on Azure Functions. It is
                                 unreliable.  Applications using this option should configure a short timeout.

                                 <b>For</b> <b>more</b> <b>details</b> <b>and</b> <b>for</b> <b>the</b> <b>values</b> <b>of</b> <b>the</b> <b>region</b> <b>string</b>
                                        see                                                                    ‐
                                        <u>https://learn.microsoft.com/entra/msal/dotnet/resources/region-discovery-troubleshooting</u>

                              New in version 1.12.0.

                            • <b>exclude_scopes</b>    (<u>list[str]</u>)    --   (optional)   Historically   MSAL   hardcodes
                              <u>offline_access</u> scope, which would allow your  app  to  have  prolonged  access  to
                              user's  data.  If that is unnecessary or undesirable for your app, now you can use
                              this parameter to supply an exclusion list of scopes,  such  as  <b>exclude_scopes</b>  <b>=</b>
                              <b>["offline_access"]</b>.

                            • <b>http_cache</b> (<u>dict</u>) --

                              MSAL  has  long  been  caching  tokens  in  the  <b>token_cache</b>.  Recently, MSAL also
                              introduced a concept of <b>http_cache</b>, by automatically caching some finite amount of
                              non-token  http  responses,  so  that   <u>long-lived</u>   <b>PublicClientApplication</b>   and
                              <b>ConfidentialClientApplication</b>  would  be  more  performant  and responsive in some
                              situations.

                              This <b>http_cache</b> parameter accepts any dict-like object.   If  not  provided,  MSAL
                              will use an in-memory dict.

                              If your app is a command-line app (CLI), you would want to persist your http_cache
                              across different CLI runs.  The following recipe shows a way to do so:

                                 # Just add the following lines at the beginning of your CLI script
                                 import sys, atexit, pickle
                                 http_cache_filename = sys.argv[0] + ".http_cache"
                                 try:
                                     with open(http_cache_filename, "rb") as f:
                                         persisted_http_cache = pickle.load(f)  # Take a snapshot
                                 except (
                                         FileNotFoundError,  # Or IOError in Python 2
                                         pickle.UnpicklingError,  # A corrupted http cache file
                                         ):
                                     persisted_http_cache = {}  # Recover by starting afresh
                                 atexit.register(lambda: pickle.dump(
                                     # When exit, flush it back to the file.
                                     # It may occasionally overwrite another process's concurrent write,
                                     # but that is fine. Subsequent runs will reach eventual consistency.
                                     persisted_http_cache, open(http_cache_file, "wb")))

                                 # And then you can implement your app as you normally would
                                 app = msal.PublicClientApplication(
                                     "your_client_id",
                                     ...,
                                     http_cache=persisted_http_cache,  # Utilize persisted_http_cache
                                     ...,
                                     #token_cache=...,  # You may combine the old token_cache trick
                                         # Please refer to token_cache recipe at
                                         # https://msal-python.readthedocs.io/en/latest/#msal.SerializableTokenCache
                                     )
                                 app.acquire_token_interactive(["your", "scope"], ...)

                              Content  inside  <b>http_cache</b>  are  cheap to obtain.  There is no need to share them
                              among different apps.

                              Content inside <b>http_cache</b> will  contain  no  tokens  nor  Personally  Identifiable
                              Information (PII). Encryption is unnecessary.

                              New in version 1.16.0.

                            • <b>instance_discovery</b> (<u>boolean</u>) --

                              Historically,   MSAL   would   connect   to   a   central   endpoint   located  at
                              <b>https://login.microsoftonline.com</b> to acquire some metadata, especially when  using
                              an unfamiliar authority.  This behavior is known as Instance Discovery.

                              This parameter defaults to None, which enables the Instance Discovery.

                              If  you  know some authorities which you allow MSAL to operate with as-is, without
                              involving any Instance Discovery, the recommended pattern is:

                                 known_authorities = frozenset([  # Treat your known authorities as const
                                     "https://contoso.com/adfs", "https://login.azs/foo"])
                                 ...
                                 authority = "https://contoso.com/adfs"  # Assuming your app will use this
                                 app1 = PublicClientApplication(
                                     "client_id",
                                     authority=authority,
                                     # Conditionally disable Instance Discovery for known authorities
                                     instance_discovery=authority not in known_authorities,
                                     )

                              If you do not know some authorities beforehand, yet still want MSAL to accept  any
                              authority  that  you  will provide, you can use a <b>False</b> to unconditionally disable
                              Instance Discovery.

                              New in version 1.19.0.

                            • <b>allow_broker</b> (<u>boolean</u>) -- Deprecated. Please use <b>enable_broker_on_windows</b> instead.

                            • <b>enable_pii_log</b> (<u>boolean</u>) --

                              When enabled, logs may include PII (Personal Identifiable Information).  This  can
                              be useful in troubleshooting broker behaviors.  The default behavior is False.

                              New in version 1.24.0.

                            • <b>oidc_authority</b> (<u>str</u>) --

                              <u>Added</u>  <u>in</u>  <u>version</u>  <u>1.28.0</u>:  It  is a URL that identifies an OpenID Connect (OIDC)
                              authority  of   the   format   <b>https://contoso.com/tenant</b>.    MSAL   will   append
                              ".well-known/openid-configuration" to the authority and retrieve the OIDC metadata
                              from there, to figure out the endpoints.

                              Note: Broker will NOT be used for OIDC authority.

              <b>acquire_token_by_auth_code_flow(auth_code_flow,</b> <b>auth_response,</b> <b>scopes=None,</b> <b>**kwargs)</b>
                     Validate the auth response being redirected back, and obtain tokens.

                     It automatically provides nonce protection.

                     <b>Parameters</b>

                            • <b>auth_code_flow</b> (<u>dict</u>) -- The same dict returned by <u>initiate_auth_code_flow()</u>.

                            • <b>auth_response</b> (<u>dict</u>) -- A dict of the query string received from auth server.

                            • <b>scopes</b> (<u>list[str]</u>) --

                              Scopes requested to access a protected API (a resource).

                              Most of the time, you can leave it empty.

                              If  you  requested  user  consent  for  multiple  resources, here you will need to
                              provide a subset of what you required in <u>initiate_auth_code_flow()</u>.

                              OAuth2 was designed mostly for singleton services, where tokens are  always  meant
                              for the same resource and the only changes are in the scopes.  In Microsoft Entra,
                              tokens  can be issued for multiple 3rd party resources.  You can ask authorization
                              code for multiple resources, but when you redeem it, the token  is  for  only  one
                              intended  recipient, called audience.  So the developer need to specify a scope so
                              that we can restrict the token to be issued for the corresponding audience.

                     <b>Returns</b>

                            • A dict containing "access_token" and/or "id_token", among others, depends on  what
                              scope was used.  (See <u>https://tools.ietf.org/html/rfc6749#section-5.1</u>)

                            • A  dict  containing  "error", optionally "error_description", "error_uri".  (It is
                              either <u>this</u> or <u>that</u>)

                            • Most client-side data error would result in ValueError exception.   So  the  usage
                              pattern could be without any protocol details:

                                 def authorize():  # A controller in a web app
                                     try:
                                         result = msal_app.acquire_token_by_auth_code_flow(
                                             session.get("flow", {}), request.args)
                                         if "error" in result:
                                             return render_template("error.html", result)
                                         use(result)  # Token(s) are available in result and cache
                                     except ValueError:  # Usually caused by CSRF
                                         pass  # Simply ignore them
                                     return redirect(url_for("index"))

              <b>acquire_token_by_authorization_code(code,</b> <b>scopes,</b> <b>redirect_uri=None,</b> <b>nonce=None,</b>
              <b>claims_challenge=None,</b> <b>**kwargs)</b>
                     The second half of the Authorization Code Grant.

                     <b>Parameters</b>

                            • <b>code</b> -- The authorization code returned from Authorization Server.

                            • <b>scopes</b> (<u>list[str]</u>) --

                              (Required) Scopes requested to access a protected API (a resource).

                              If you requested user consent for multiple resources, here you will typically want
                              to provide a subset of what you required in AuthCode.

                              OAuth2  was  designed mostly for singleton services, where tokens are always meant
                              for the same resource and the only changes are in the scopes.  In Microsoft Entra,
                              tokens can be issued for multiple 3rd party resources.  You can ask  authorization
                              code  for  multiple  resources,  but when you redeem it, the token is for only one
                              intended recipient, called audience.  So the developer need to specify a scope  so
                              that we can restrict the token to be issued for the corresponding audience.

                            • <b>nonce</b>  --  If  you  provided a nonce when calling <u>get_authorization_request_url()</u>,
                              same nonce should also be provided here, so that we'll validate it.  An  exception
                              will be raised if the nonce in id token mismatches.

                            • <b>claims_challenge</b>  --  The  claims_challenge  parameter  requests  specific  claims
                              requested by the resource provider in the form of a claims_challenge directive  in
                              the  www-authenticate  header  to be returned from the UserInfo Endpoint and/or in
                              the ID Token and/or Access Token.  It is a string of a JSON object which  contains
                              lists of claims being requested from these locations.

                     <b>Returns</b>
                            A dict representing the json response from Microsoft Entra:

                            • A successful response would contain "access_token" key,

                            • an error response would contain "error" and usually "error_description".

              <b>acquire_token_by_refresh_token(refresh_token,</b> <b>scopes,</b> <b>**kwargs)</b>
                     Acquire token(s) based on a refresh token (RT) obtained from elsewhere.

                     You  use this method only when you have old RTs from elsewhere, and now you want to migrate
                     them into MSAL.  Calling this method results in new tokens automatically storing into MSAL.

                     You do NOT need to use this method if you  are  already  using  MSAL.   MSAL  maintains  RT
                     automatically  inside  its  token cache, and an access token can be retrieved when you call
                     <u>acquire_token_silent()</u>.

                     <b>Parameters</b>

                            • <b>refresh_token</b> (<u>str</u>) -- The old refresh token, as a string.

                            • <b>scopes</b> (<u>list</u>) -- The scopes associate with this old RT.  Each scope needs to be in
                              the Microsoft identity platform (v2) format.  See <u>Scopes</u> <u>not</u> <u>resources</u>.

                     <b>Returns</b>

                            • A dict contains "error" and some other keys, when error happened.

                            • A dict contains no "error" key means migration was successful.

              <b>acquire_token_by_username_password(username,</b> <b>password,</b> <b>scopes,</b> <b>claims_challenge=None,</b>
              <b>auth_scheme=None,</b> <b>**kwargs)</b>
                     Gets a token for a given resource via user credentials.

                     See    this    page    for    constraints     of     Username     Password     Flow.      ‐
                     <u>https://github.com/AzureAD/microsoft-authentication-library-for-python/wiki/Username-Password-Authentication</u>

                     <b>Parameters</b>

                            • <b>username</b> (<u>str</u>) -- Typically a UPN in the form of an email address.

                            • <b>password</b> (<u>str</u>) -- The password.

                            • <b>scopes</b> (<u>list[str]</u>) -- Scopes requested to access a protected API (a resource).

                            • <b>claims_challenge</b>  --  The  claims_challenge  parameter  requests  specific  claims
                              requested by the resource provider in the form of a claims_challenge directive  in
                              the  www-authenticate  header  to be returned from the UserInfo Endpoint and/or in
                              the ID Token and/or Access Token.  It is a string of a JSON object which  contains
                              lists of claims being requested from these locations.

                            • <b>auth_scheme</b> (<u>object</u>) --

                              You  can  provide an <b>msal.auth_scheme.PopAuthScheme</b> object so that MSAL will get a
                              Proof-of-Possession (POP) token for you.

                              New in version 1.26.0.

                     <b>Returns</b>
                            A dict representing the json response from Microsoft Entra:

                            • A successful response would contain "access_token" key,

                            • an error response would contain "error" and usually "error_description".

              <b>acquire_token_silent(scopes,</b> <b>account,</b> <b>authority=None,</b> <b>force_refresh=False,</b> <b>claims_challenge=None,</b>
              <b>auth_scheme=None,</b> <b>**kwargs)</b>
                     Acquire an access token for given account, without user interaction.

                     It has same parameters as the <u>acquire_token_silent_with_error()</u>.   The  difference  is  the
                     behavior  of  the return value.  This method will combine the cache empty and refresh error
                     into one return value, <u>None</u>.  If your app does not care about the exact token refresh error
                     during token cache look-up, then this method is easier and recommended.

                     <b>Returns</b>

                            • A dict containing no "error" key, and typically contains an "access_token" key, if
                              cache lookup succeeded.

                            • None when cache lookup does not yield a token.

              <b>acquire_token_silent_with_error(scopes,</b> <b>account,</b> <b>authority=None,</b> <b>force_refresh=False,</b>
              <b>claims_challenge=None,</b> <b>auth_scheme=None,</b> <b>**kwargs)</b>
                     Acquire an access token for given account, without user interaction.

                     It is done either by finding a valid access token from cache, or by finding a valid refresh
                     token from cache and then automatically use it to redeem a new access token.

                     This method will differentiate cache empty from token refresh error.  If your app cares the
                     exact token refresh error during  token  cache  look-up,  then  this  method  is  suitable.
                     Otherwise, the other method <u>acquire_token_silent()</u> is recommended.

                     <b>Parameters</b>

                            • <b>scopes</b>  (<u>list[str]</u>)  --  (Required)  Scopes requested to access a protected API (a
                              resource).

                            • <b>account</b> -- (Required) One  of  the  account  object  returned  by  <u>get_accounts()</u>.
                              Starting from MSAL Python 1.23, a <b>None</b> input will become a NO-OP and always return
                              <b>None</b>.

                            • <b>force_refresh</b>  --  If  True,  it will skip Access Token look-up, and try to find a
                              Refresh Token to obtain a new Access Token.

                            • <b>claims_challenge</b>  --  The  claims_challenge  parameter  requests  specific  claims
                              requested  by the resource provider in the form of a claims_challenge directive in
                              the www-authenticate header to be returned from the UserInfo  Endpoint  and/or  in
                              the  ID Token and/or Access Token.  It is a string of a JSON object which contains
                              lists of claims being requested from these locations.

                            • <b>auth_scheme</b> (<u>object</u>) --

                              You can provide an <b>msal.auth_scheme.PopAuthScheme</b> object so that MSAL will  get  a
                              Proof-of-Possession (POP) token for you.

                              New in version 1.26.0.

                     <b>Returns</b>

                            • A dict containing no "error" key, and typically contains an "access_token" key, if
                              cache lookup succeeded.

                            • None when there is simply no token in the cache.

                            • A dict containing an "error" key, when token refresh failed.

              <b>get_accounts(username=None)</b>
                     Get a list of accounts which previously signed in, i.e. exists in cache.

                     An account can later be used in <u>acquire_token_silent()</u> to find its tokens.

                     <b>Parameters</b>
                            <b>username</b> -- Filter accounts with this username only. Case insensitive.

                     <b>Returns</b>
                            A  list  of  account objects.  Each account is a dict. For now, we only document its
                            "username" field.  Your app can choose to display those information to end user, and
                            allow user to choose one of his/her accounts to proceed.

              <b>get_authorization_request_url(scopes,</b> <b>login_hint=None,</b> <b>state=None,</b> <b>redirect_uri=None,</b>
              <b>response_type='code',</b> <b>prompt=None,</b> <b>nonce=None,</b> <b>domain_hint=None,</b> <b>claims_challenge=None,</b> <b>**kwargs)</b>
                     Constructs a URL for you to start a Authorization Code Grant.

                     <b>Parameters</b>

                            • <b>scopes</b> (<u>list[str]</u>) -- (Required) Scopes requested to access  a  protected  API  (a
                              resource).

                            • <b>state</b> (<u>str</u>) -- Recommended by OAuth2 for CSRF protection.

                            • <b>login_hint</b> (<u>str</u>) -- Identifier of the user. Generally a User Principal Name (UPN).

                            • <b>redirect_uri</b>  (<u>str</u>)  --  Address  to  return to upon receiving a response from the
                              authority.

                            • <b>response_type</b> (<u>str</u>) --

                              Default value is "code" for an OAuth2 Authorization Code grant.

                              You could use other content such as "id_token" or "token", which would trigger  an
                              Implicit Grant, but that is <u>not</u> <u>recommended</u>.

                            • <b>prompt</b>  (<u>str</u>) -- By default, no prompt value will be sent, not even string <b>"none"</b>.
                              You will have to specify a value explicitly.  Its valid values are  the  constants
                              defined in <u>Prompt</u>.

                            • <b>nonce</b>  --  A  cryptographically  random value used to mitigate replay attacks. See
                              also <u>OIDC</u> <u>specs</u>.

                            • <b>domain_hint</b> -- Can be one of "consumers" or "organizations" or your tenant  domain
                              "contoso.com".   If  included, it will skip the email-based discovery process that
                              user goes through on the sign-in page, leading to a slightly more streamlined user
                              experience.  More information on possible values available in <u>Auth</u> <u>Code</u>  <u>Flow</u>  <u>doc</u>
                              and <u>domain_hint</u> <u>doc</u>.

                            • <b>claims_challenge</b>  --  The  claims_challenge  parameter  requests  specific  claims
                              requested by the resource provider in the form of a claims_challenge directive  in
                              the  www-authenticate  header  to be returned from the UserInfo Endpoint and/or in
                              the ID Token and/or Access Token.  It is a string of a JSON object which  contains
                              lists of claims being requested from these locations.

                     <b>Returns</b>
                            The authorization url as a string.

              <b>initiate_auth_code_flow(scopes,</b> <b>redirect_uri=None,</b> <b>state=None,</b> <b>prompt=None,</b> <b>login_hint=None,</b>
              <b>domain_hint=None,</b> <b>claims_challenge=None,</b> <b>max_age=None,</b> <b>response_mode=None)</b>
                     Initiate an auth code flow.

                     Later     when     the    response    reaches    your    redirect_uri,    you    can    use
                     <u>acquire_token_by_auth_code_flow()</u> to complete the authentication/authorization.

                     <b>Parameters</b>

                            • <b>scopes</b> (<u>list</u>) -- It is a list of case-sensitive strings.

                            • <b>redirect_uri</b>  (<u>str</u>)  --  Optional.  If  not  specified,  server   will   use   the
                              pre-registered one.

                            • <b>state</b>  (<u>str</u>)  --  An opaque value used by the client to maintain state between the
                              request and callback.  If absent, this library  will  automatically  generate  one
                              internally.

                            • <b>prompt</b>  (<u>str</u>) -- By default, no prompt value will be sent, not even string <b>"none"</b>.
                              You will have to specify a value explicitly.  Its valid values are  the  constants
                              defined in <u>Prompt</u>.

                            • <b>login_hint</b>  (<u>str</u>)  -- Optional. Identifier of the user. Generally a User Principal
                              Name (UPN).

                            • <b>domain_hint</b> --

                              Can be one of "consumers" or "organizations" or your tenant domain  "contoso.com".
                              If included, it will skip the email-based discovery process that user goes through
                              on the sign-in page, leading to a slightly more streamlined user experience.  More
                              information  on  possible  values  available in <u>Auth</u> <u>Code</u> <u>Flow</u> <u>doc</u> and <u>domain_hint</u>
                              <u>doc</u>.

                            • <b>max_age</b> (<u>int</u>) --

                              OPTIONAL. Maximum Authentication Age.  Specifies the  allowable  elapsed  time  in
                              seconds  since  the  last  time  the  End-User was actively authenticated.  If the
                              elapsed time is greater than this value, Microsoft identity platform will actively
                              re-authenticate the End-User.

                              MSAL Python will also automatically validate the auth_time in ID token.

                              New in version 1.15.

                            • <b>response_mode</b>  (<u>str</u>)  --  OPTIONAL.  Specifies  the  method  with  which  response
                              parameters should be returned.  The default value is equivalent to <b>query</b>, which is
                              still  secure  enough in MSAL Python (because MSAL Python does not transfer tokens
                              via query parameter in the first place).  For even better security,  we  recommend
                              using  the  value  <b>form_post</b>.   In  "form_post"  mode, response parameters will be
                              encoded as HTML form values that are transmitted via  the  HTTP  POST  method  and
                              encoded  in  the  body  using the application/x-www-form-urlencoded format.  Valid
                              values can be either "form_post" for HTTP POST to callback  URI  or  "query"  (the
                              default)  for  HTTP GET with parameters encoded in query string.  More information
                              on                    possible                     values                     <u>here</u>
                              <u>&lt;https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes&gt;</u>
                              and                                                                           <u>here</u>
                              <u>&lt;https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html#FormPostResponseMode&gt;</u>

                     <b>Returns</b>
                            The auth code flow. It is a dict in this form:

                               {
                                   "auth_uri": "https://...",  // Guide user to visit this
                                   "state": "...",  // You may choose to verify it by yourself,
                                                    // or just let acquire_token_by_auth_code_flow()
                                                    // do that for you.
                                   "...": "...",  // Everything else are reserved and internal
                               }

                            The caller is expected to:

                            1. somehow store this content, typically inside the current session,

                            2. guide the end user (i.e. resource owner) to visit that auth_uri,

                            3. and   then   relay    this    dict    and    subsequent    auth    response    to
                               <u>acquire_token_by_auth_code_flow()</u>.

              <b>is_pop_supported()</b>
                     Returns True if this client supports Proof-of-Possession Access Token.

              <b>remove_account(account)</b>
                     Sign me out and forget me from token cache

   <b>PublicClientApplication</b>
       <b>class</b> <b>msal.PublicClientApplication(client_id,</b> <b>client_credential=None,</b> <b>*,</b> <b>enable_broker_on_windows=None,</b>
       <b>enable_broker_on_mac=None,</b> <b>**kwargs)</b>

              <b>CONSOLE_WINDOW_HANDLE</b> <b>=</b> <b>&lt;object</b> <b>object&gt;</b>

              <b>__init__(client_id,</b> <b>client_credential=None,</b> <b>*,</b> <b>enable_broker_on_windows=None,</b>
              <b>enable_broker_on_mac=None,</b> <b>**kwargs)</b>
                     Same  as <u>ClientApplication.</u><b>__</b><u>init</u><b>__</b><u>()</u>, except that <b>client_credential</b> parameter shall remain
                     <b>None</b>.

                     <b>NOTE:</b>
                        You may set enable_broker_on_windows and/or enable_broker_on_mac to True.

                        <b>What</b> <b>is</b> <b>a</b> <b>broker,</b> <b>and</b> <b>why</b> <b>use</b> <b>it?</b>

                        A broker is a component installed on your device.  Broker implicitly gives  your  device
                        an  identity.  By  using  a  broker,  your  device becomes a factor that can satisfy MFA
                        (Multi-factor authentication).  This factor would become mandatory if a  tenant's  admin
                        enables  a  corresponding  Conditional Access (CA) policy.  The broker's presence allows
                        Microsoft identity platform to have higher confidence that the tokens are  being  issued
                        to your device, and that is more secure.

                        An  additional  benefit of broker is, it runs as a long-lived process with your device's
                        OS, and maintains its own cache, so that your broker-enabled apps  (even  a  CLI)  could
                        automatically SSO from a previously established signed-in session.

                        <b>You</b> <b>shall</b> <b>only</b> <b>enable</b> <b>broker</b> <b>when</b> <b>your</b> <b>app:</b>

                        1. is  running  on  supported  platforms,  and  already  registered  their corresponding
                           redirect_uri

                           • <b>ms-appx-web://Microsoft.AAD.BrokerPlugin/your_client_id</b> if your app is expected  to
                             run on Windows 10+

                           • <b>msauth.com.msauth.unsignedapp://auth</b> if your app is expected to run on Mac

                        2. installed broker dependency, e.g. <b>pip</b> <b>install</b> <b>msal[broker]&gt;=1.31,&lt;2</b>.

                        3. tested with <b>acquire_token_interactive()</b> and <b>acquire_token_silent()</b>.

                        <b>The</b> <b>fallback</b> <b>behaviors</b> <b>of</b> <b>MSAL</b> <b>Python's</b> <b>broker</b> <b>support</b>

                        MSAL will either error out, or silently fallback to non-broker flows.

                        1. MSAL will ignore the <u>enable_broker_...</u> and bypass broker on those auth flows that are
                           known  to  be  NOT  supported  by  broker.  This includes ADFS, B2C, etc..  For other
                           "could-use-broker" scenarios, please see below.

                        2. MSAL errors out when app developer opted-in to use broker  but  a  direct  dependency
                           "mid-tier"  package  is not installed.  Error message guides app developer to declare
                           the correct dependency  <b>msal[broker]</b>.   We  error  out  here  because  the  error  is
                           actionable to app developers.

                        3. MSAL  silently  "deactivates"  the  broker and fallback to non-broker, when opted-in,
                           dependency installed yet failed to initialize.  We anticipate this would happen on  a
                           device whose OS is too old or the underlying broker component is somehow unavailable.
                           There  is  not  much  an  app developer or the end user can do here.  Eventually, the
                           conditional access policy shall force the user to switch to a different device.

                        4. MSAL errors out when broker is opted in, installed, initialized, but subsequent token
                           request(s) failed.

                     <b>Parameters</b>

                            • <b>enable_broker_on_windows</b> (<u>boolean</u>) --

                              This setting is only effective if your  app  is  running  on  Windows  10+.   This
                              parameter defaults to None, which means MSAL will not utilize a broker.

                              New in MSAL Python 1.25.0.

                            • <b>enable_broker_on_mac</b> (<u>boolean</u>) --

                              This  setting  is  only  effective  if your app is running on Mac.  This parameter
                              defaults to None, which means MSAL will not utilize a broker.

                              New in MSAL Python 1.31.0.

              <b>acquire_token_by_device_flow(flow,</b> <b>claims_challenge=None,</b> <b>**kwargs)</b>
                     Obtain token by a device flow object, with customizable polling effect.

                     <b>Parameters</b>

                            • <b>flow</b> (<u>dict</u>) -- A dict previously generated by <u>initiate_device_flow()</u>.  By default,
                              this method's polling effect  will  block  current  thread.   You  can  abort  the
                              polling  loop at any time, by changing the value of the flow's "expires_at" key to
                              0.

                            • <b>claims_challenge</b>  --  The  claims_challenge  parameter  requests  specific  claims
                              requested  by the resource provider in the form of a claims_challenge directive in
                              the www-authenticate header to be returned from the UserInfo  Endpoint  and/or  in
                              the  ID Token and/or Access Token.  It is a string of a JSON object which contains
                              lists of claims being requested from these locations.

                     <b>Returns</b>
                            A dict representing the json response from Microsoft Entra:

                            • A successful response would contain "access_token" key,

                            • an error response would contain "error" and usually "error_description".

              <b>acquire_token_interactive(scopes,</b> <b>prompt=None,</b> <b>login_hint=None,</b> <b>domain_hint=None,</b>
              <b>claims_challenge=None,</b> <b>timeout=None,</b> <b>port=None,</b> <b>extra_scopes_to_consent=None,</b> <b>max_age=None,</b>
              <b>parent_window_handle=None,</b> <b>on_before_launching_ui=None,</b> <b>auth_scheme=None,</b> <b>**kwargs)</b>
                     Acquire token interactively i.e. via a local browser.

                     Prerequisite: In Azure Portal, configure the Redirect  URI  of  your  "Mobile  and  Desktop
                     application"    as   <b><a href="http://localhost">http://localhost</a></b>.    If   you   opts   in   to   use   broker   during
                     <b>PublicClientApplication</b>   creation,   your   app   also    need    this    Redirect    URI:
                     <b>ms-appx-web://Microsoft.AAD.BrokerPlugin/YOUR_CLIENT_ID</b>

                     <b>Parameters</b>

                            • <b>scopes</b> (<u>list</u>) -- It is a list of case-sensitive strings.

                            • <b>prompt</b>  (<u>str</u>) -- By default, no prompt value will be sent, not even string <b>"none"</b>.
                              You will have to specify a value explicitly.  Its valid values are  the  constants
                              defined in <u>Prompt</u>.

                            • <b>login_hint</b>  (<u>str</u>)  -- Optional. Identifier of the user. Generally a User Principal
                              Name (UPN).

                            • <b>domain_hint</b> --

                              Can be one of "consumers" or "organizations" or your tenant domain  "contoso.com".
                              If included, it will skip the email-based discovery process that user goes through
                              on the sign-in page, leading to a slightly more streamlined user experience.  More
                              information  on  possible  values  available in <u>Auth</u> <u>Code</u> <u>Flow</u> <u>doc</u> and <u>domain_hint</u>
                              <u>doc</u>.

                            • <b>claims_challenge</b>  --  The  claims_challenge  parameter  requests  specific  claims
                              requested  by the resource provider in the form of a claims_challenge directive in
                              the www-authenticate header to be returned from the UserInfo  Endpoint  and/or  in
                              the  ID Token and/or Access Token.  It is a string of a JSON object which contains
                              lists of claims being requested from these locations.

                            • <b>timeout</b> (<u>int</u>) -- This method  will  block  the  current  thread.   This  parameter
                              specifies   the   timeout  value  in  seconds.   Default  value  <b>None</b>  means  wait
                              indefinitely.

                            • <b>port</b> (<u>int</u>) -- The port to be used to listen to  an  incoming  auth  response.   By
                              default  we  will  use  a system-allocated port.  (The rest of the redirect_uri is
                              hard coded as <b><a href="http://localhost">http://localhost</a></b>.)

                            • <b>extra_scopes_to_consent</b> (<u>list</u>) -- "Extra scopes to  consent"  is  a  concept  only
                              available  in  Microsoft  Entra.   It  refers to other resources you might want to
                              prompt to consent for, in the same interaction, but for which you won't get back a
                              token for in this particular operation.

                            • <b>max_age</b> (<u>int</u>) --

                              OPTIONAL. Maximum Authentication Age.  Specifies the  allowable  elapsed  time  in
                              seconds  since  the  last  time  the  End-User was actively authenticated.  If the
                              elapsed time is greater than this value, Microsoft identity platform will actively
                              re-authenticate the End-User.

                              MSAL Python will also automatically validate the auth_time in ID token.

                              New in version 1.15.

                            • <b>parent_window_handle</b> (<u>int</u>) --

                              OPTIONAL.

                              • If your app does not opt in to  use  broker,  you  do  not  need  to  provide  a
                                <b>parent_window_handle</b> here.

                              • If your app opts in to use broker, <b>parent_window_handle</b> is required.

                                • If your app is a GUI app running on Windows or Mac system, you are required to
                                  also  provide its window handle, so that the sign-in window will pop up on top
                                  of your window.

                                • If your app is a console app running on Windows or Mac system, you can  use  a
                                  placeholder <b>PublicClientApplication.CONSOLE_WINDOW_HANDLE</b>.

                              Most Python scripts are console apps.

                              New in version 1.20.0.

                            • <b>on_before_launching_ui</b> (<u>function</u>) --

                              A  callback  with  the  form  of  <b>lambda</b>  <b>ui="xyz",</b>  <b>**kwargs:</b> <b>print("A</b> <b>{}</b> <b>will</b> <b>be</b>
                              <b>launched".format(ui))</b>, where <b>ui</b> will be either "browser" or "broker".  You can use
                              it to inform your end user to expect a pop-up window.

                              New in version 1.20.0.

                            • <b>auth_scheme</b> (<u>object</u>) --

                              You can provide an <b>msal.auth_scheme.PopAuthScheme</b> object so that MSAL will  get  a
                              Proof-of-Possession (POP) token for you.

                              New in version 1.26.0.

                     <b>Returns</b>

                            • A dict containing no "error" key, and typically contains an "access_token" key.

                            • A dict containing an "error" key, when token refresh failed.

              <b>initiate_device_flow(scopes=None,</b> <b>**kwargs)</b>
                     Initiate a Device Flow instance, which will be used in <u>acquire_token_by_device_flow()</u>.

                     <b>Parameters</b>
                            <b>scopes</b> (<u>list[str]</u>) -- Scopes requested to access a protected API (a resource).

                     <b>Returns</b>
                            A dict representing a newly created Device Flow object.

                            • A successful response would contain "user_code" key, among others

                            • an error response would contain some other readable key/value pairs.

   <b>ConfidentialClientApplication</b>
       <b>class</b> <b>msal.ConfidentialClientApplication(client_id,</b> <b>client_credential=None,</b> <b>authority=None,</b>
       <b>validate_authority=True,</b> <b>token_cache=None,</b> <b>http_client=None,</b> <b>verify=True,</b> <b>proxies=None,</b> <b>timeout=None,</b>
       <b>client_claims=None,</b> <b>app_name=None,</b> <b>app_version=None,</b> <b>client_capabilities=None,</b> <b>azure_region=None,</b>
       <b>exclude_scopes=None,</b> <b>http_cache=None,</b> <b>instance_discovery=None,</b> <b>allow_broker=None,</b> <b>enable_pii_log=None,</b>
       <b>oidc_authority=None)</b>
              Same as <u>ClientApplication.</u><b>__</b><u>init</u><b>__</b><u>()</u>, except that <b>allow_broker</b> parameter shall remain <b>None</b>.

              <b>acquire_token_for_client(scopes,</b> <b>claims_challenge=None,</b> <b>**kwargs)</b>
                     Acquires token for the current confidential client, not for an end user.

                     Since  MSAL  Python  1.23,  it  will automatically look for token from cache, and only send
                     request to Identity Provider when cache misses.

                     <b>Parameters</b>

                            • <b>scopes</b> (<u>list[str]</u>) -- (Required) Scopes requested to access  a  protected  API  (a
                              resource).

                            • <b>claims_challenge</b>  --  The  claims_challenge  parameter  requests  specific  claims
                              requested by the resource provider in the form of a claims_challenge directive  in
                              the  www-authenticate  header  to be returned from the UserInfo Endpoint and/or in
                              the ID Token and/or Access Token.  It is a string of a JSON object which  contains
                              lists of claims being requested from these locations.

                     <b>Returns</b>
                            A dict representing the json response from Microsoft Entra:

                            • A successful response would contain "access_token" key,

                            • an error response would contain "error" and usually "error_description".

              <b>acquire_token_on_behalf_of(user_assertion,</b> <b>scopes,</b> <b>claims_challenge=None,</b> <b>**kwargs)</b>
                     Acquires token using on-behalf-of (OBO) flow.

                     The  current app is a middle-tier service which was called with a token representing an end
                     user.  The current app can use such token (a.k.a. a  user  assertion)  to  request  another
                     token to access downstream web API, on behalf of that user.  See <u>detail</u> <u>docs</u> <u>here</u> .

                     The  current  middle-tier  app  has no user interaction to obtain consent.  See how to gain
                     consent    upfront    for    your    middle-tier    app    from    this     article.      ‐
                     <u>https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application</u>

                     <b>Parameters</b>

                            • <b>user_assertion</b> (<u>str</u>) -- The incoming token already received by this app

                            • <b>scopes</b> (<u>list[str]</u>) -- Scopes required by downstream API (a resource).

                            • <b>claims_challenge</b>  --  The  claims_challenge  parameter  requests  specific  claims
                              requested by the resource provider in the form of a claims_challenge directive  in
                              the  www-authenticate  header  to be returned from the UserInfo Endpoint and/or in
                              the ID Token and/or Access Token.  It is a string of a JSON object which  contains
                              lists of claims being requested from these locations.

                     <b>Returns</b>
                            A dict representing the json response from Microsoft Entra:

                            • A successful response would contain "access_token" key,

                            • an error response would contain "error" and usually "error_description".

              <b>remove_tokens_for_client()</b>
                     Remove  all  tokens  that  were  previously acquired via <u>acquire_token_for_client()</u> for the
                     current client.

   <b>TokenCache</b>
       One of the parameters accepted by both <u>PublicClientApplication</u> and <u>ConfidentialClientApplication</u>  is  the
       <u>TokenCache</u>.

       <b>class</b> <b>msal.TokenCache</b>
              This is considered as a base class containing minimal cache behavior.

              Although  it  maintains tokens using unified schema across all MSAL libraries, this class does not
              serialize/persist them.  See subclass <u>SerializableTokenCache</u> for details on serialization.

              <b>add(event,</b> <b>now=None)</b>
                     Handle a token obtaining event, and add tokens into cache.

              <b>find(credential_type,</b> <b>target=None,</b> <b>query=None,</b> <b>*,</b> <b>now=None)</b>
                     Equivalent to list(search(...)).

              <b>search(credential_type,</b> <b>target=None,</b> <b>query=None,</b> <b>*,</b> <b>now=None)</b>
                     Returns a generator of matching entries.

                     It is <a href="../man1/O.1.html">O</a>(1) for AT hits, and O(n) for other types.  Note that it holds  a  lock  during  the
                     entire search.

       You  can  subclass  it to add new behavior, such as, token serialization.  See <u>SerializableTokenCache</u> for
       example.

       <b>class</b> <b>msal.SerializableTokenCache</b>
              This serialization can be a starting point to implement your own persistence.

              This class does NOT actually persist the cache on  disk/db/etc..   Depending  on  your  need,  the
              following simple recipe for file-based, unencrypted persistence may be sufficient:

                 import os, atexit, msal
                 cache_filename = os.path.join(  # Persist cache into this file
                     os.getenv(
                         # Automatically wipe out the cache from Linux when user's ssh session ends.
                         # See also https://github.com/AzureAD/microsoft-authentication-library-for-python/issues/690
                         "XDG_RUNTIME_DIR", ""),
                     "my_cache.bin")
                 cache = msal.SerializableTokenCache()
                 if os.path.exists(cache_filename):
                     cache.deserialize(open(cache_filename, "r").read())
                 atexit.register(lambda:
                     open(cache_filename, "w").write(cache.serialize())
                     # Hint: The following optional line persists only when state changed
                     if cache.has_state_changed else None
                     )
                 app = msal.ClientApplication(..., token_cache=cache)
                 ...

              Alternatively,  you may use a more sophisticated cache persistence library, <u>MSAL</u> <u>Extensions</u>, which
              provides token cache persistence with encryption, and more.

              <b>Variables</b>
                     <b>has_state_changed</b> (<u>bool</u>) -- Indicates whether the cache state in  the  memory  has  changed
                     since last <u>serialize()</u> or <u>deserialize()</u> call.

              <b>add(event,</b> <b>**kwargs)</b>
                     Handle a token obtaining event, and add tokens into cache.

              <b>deserialize(state:</b> <b>str</b> <b>|</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Deserialize the cache from a state previously obtained by serialize()

              <b>serialize()</b> <b>-&gt;</b> <b>str</b>
                     Serialize the current cache state into a string.

   <b>Prompt</b>
       <b>class</b> <b>msal.Prompt</b>
              This class defines the constant strings for prompt parameter.

              The values are based on <u>https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest</u>

              <b>SELECT_ACCOUNT</b> <b>=</b> <b>'select_account'</b>

              <b>NONE</b> <b>=</b> <b>'none'</b>

              <b>CONSENT</b> <b>=</b> <b>'consent'</b>

              <b>LOGIN</b> <b>=</b> <b>'login'</b>

   <b>PopAuthScheme</b>
       This  is  used  as the <u>auth_scheme</u> parameter in many of the acquire token methods to support for Proof of
       Possession (PoP) tokens.

       New in MSAL Python 1.26

       <b>class</b> <b>msal.PopAuthScheme(http_method=None,</b> <b>url=None,</b> <b>nonce=None)</b>

              <b>HTTP_GET</b> <b>=</b> <b>'GET'</b>

              <b>HTTP_POST</b> <b>=</b> <b>'POST'</b>

              <b>HTTP_PUT</b> <b>=</b> <b>'PUT'</b>

              <b>HTTP_DELETE</b> <b>=</b> <b>'DELETE'</b>

              <b>HTTP_PATCH</b> <b>=</b> <b>'PATCH'</b>

              <b>__init__(http_method=None,</b> <b>url=None,</b> <b>nonce=None)</b>
                     Create an auth scheme which is needed to obtain a Proof-of-Possession token.

                     <b>Parameters</b>

                            • <b>http_method</b> (<u>str</u>) -- Its value is an  uppercase  http  verb,  such  as  "GET"  and
                              "POST".

                            • <b>url</b> (<u>str</u>) -- The url to be signed.

                            • <b>nonce</b> (<u>str</u>) -- The nonce came from resource's challenge.

   <b>Exceptions</b>
       These  are  exceptions that MSAL Python may raise.  You should not need to create them directly.  You may
       want to catch them to provide a better error message to your end users.

       <b>class</b> <b>msal.IdTokenError(reason,</b> <b>now,</b> <b>claims)</b>
              In unlikely event of an ID token is malformed, this exception will be raised.

</pre><h4><b>MANAGED</b> <b>IDENTITY</b></h4><pre>
       MSAL supports <u>Managed</u> <u>Identity</u>.

       You can create one of these two kinds of managed identity configuration objects:

       <b>class</b> <b>msal.SystemAssignedManagedIdentity</b>
              Represent a system-assigned managed identity.

              It is equivalent to a Python dict of:

                 {"ManagedIdentityIdType": "SystemAssigned", "Id": None}

              or a JSON blob of:

                 {"ManagedIdentityIdType": "SystemAssigned", "Id": null}

       <b>class</b> <b>msal.UserAssignedManagedIdentity(*,</b> <b>client_id=None,</b> <b>resource_id=None,</b> <b>object_id=None)</b>
              Represent a user-assigned managed identity.

              Depends on the id you provided, the outcome is equivalent to one of the below:

                 {"ManagedIdentityIdType": "ClientId", "Id": "foo"}
                 {"ManagedIdentityIdType": "ResourceId", "Id": "foo"}
                 {"ManagedIdentityIdType": "ObjectId", "Id": "foo"}

       And then feed the configuration object into a <b>ManagedIdentityClient</b> object.

       <b>class</b> <b>msal.ManagedIdentityClient(managed_identity:</b> <b>dict</b> <b>|</b> <u>ManagedIdentity</u> <b>|</b> <u>SystemAssignedManagedIdentity</u>
       <b>|</b> <u>UserAssignedManagedIdentity</u><b>,</b> <b>*,</b> <b>http_client,</b> <b>token_cache=None,</b> <b>http_cache=None)</b>
              This API encapsulates multiple managed identity  back-ends:  VM,  App  Service,  Azure  Automation
              (Runbooks), Azure Function, Service Fabric, and Azure Arc.

              It also provides token cache support.

              <b>NOTE:</b>
                 Cloud  Shell  support is NOT implemented in this class.  Since MSAL Python 1.18 in May 2022, it
                 has been implemented in <u>PublicClientApplication.acquire_token_interactive()</u> via calling pattern
                 <b>PublicClientApplication(...).acquire_token_interactive(scopes=[...],</b> <b>prompt="none")</b>.   That  is
                 appropriate, because Cloud Shell yields a token with delegated permissions for the end user who
                 has  signed in to the Azure Portal (like what a <b>PublicClientApplication</b> does), not a token with
                 application permissions for an app.

              <b>__init__(managed_identity:</b> <b>dict</b> <b>|</b> <u>ManagedIdentity</u> <b>|</b> <u>SystemAssignedManagedIdentity</u> <b>|</b>
              <u>UserAssignedManagedIdentity</u><b>,</b> <b>*,</b> <b>http_client,</b> <b>token_cache=None,</b> <b>http_cache=None)</b>
                     Create a managed identity client.

                     <b>Parameters</b>

                            • <b>managed_identity</b> -- It accepts an  instance  of  <u>SystemAssignedManagedIdentity</u>  or
                              <u>UserAssignedManagedIdentity</u>.   They are equivalent to a dict with a certain shape,
                              which may be loaded from a JSON configuration file or an env var.

                            • <b>http_client</b> --

                              An http client object. For example, you  can  use  <b>requests.Session()</b>,  optionally
                              with exponential backoff behavior demonstrated in this recipe:

                                 import msal, requests
                                 from requests.adapters import HTTPAdapter, Retry
                                 s = requests.Session()
                                 retries = Retry(total=3, backoff_factor=0.1, status_forcelist=[
                                     429, 500, 501, 502, 503, 504])
                                 s.mount('https://', HTTPAdapter(max_retries=retries))
                                 managed_identity = ...
                                 client = msal.ManagedIdentityClient(managed_identity, http_client=s)

                            • <b>token_cache</b>  --  Optional.  It accepts a <u>msal.TokenCache</u> instance to store tokens.
                              It will use an in-memory token cache by default.

                            • <b>http_cache</b>   --   Optional.   It   has   the   same   characteristics    as    the
                              <u>msal.ClientApplication.http_cache</u>.

                     Recipe 1: Hard code a managed identity for your app:

                        import msal, requests
                        client = msal.ManagedIdentityClient(
                            msal.UserAssignedManagedIdentity(client_id="foo"),
                            http_client=requests.Session(),
                            )
                        token = client.acquire_token_for_client("resource")

                     Recipe  2:  Write once, run everywhere.  If you use different managed identity on different
                     deployment, you may use an environment variable  (such  as  MY_MANAGED_IDENTITY_CONFIG)  to
                     store   a   json   blob   like   <b>{"ManagedIdentityIdType":</b>   <b>"ClientId",</b>  <b>"Id":</b>  <b>"foo"}</b>  or
                     <b>{"ManagedIdentityIdType":</b> <b>"SystemAssigned",</b>  <b>"Id":</b>  <b>null}</b>.   The  following  app  can  load
                     managed identity configuration dynamically:

                        import json, os, msal, requests
                        config = os.getenv("MY_MANAGED_IDENTITY_CONFIG")
                        assert config, "An ENV VAR with value should exist"
                        client = msal.ManagedIdentityClient(
                            json.loads(config),
                            http_client=requests.Session(),
                            )
                        token = client.acquire_token_for_client("resource")

              <b>acquire_token_for_client(*,</b> <b>resource:</b> <b>str,</b> <b>claims_challenge:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b>
                     Acquire token for the managed identity.

                     The  result  will be automatically cached.  Subsequent calls will automatically search from
                     cache first.

                     <b>Parameters</b>

                            • <b>resource</b> -- The resource for which the token is acquired.

                            • <b>claims_challenge</b> --

                              Optional.  It is a string representation of a JSON object (which contains lists of
                              claims being requested).

                              The tenant admin may choose to revoke all Managed  Identity  tokens,  and  then  a
                              <u>claims</u>  <u>challenge</u>  will  be returned by the target resource, as a <u>claims_challenge</u>
                              directive in the <u>www-authenticate</u> header, even if the app developer did not opt in
                              for the "CP1" client capability.  Upon receiving  a  <u>claims_challenge</u>,  MSAL  will
                              skip a token cache read, and will attempt to acquire a new token.

                     <b>NOTE:</b>
                        Known  issue: When an Azure VM has only one user-assigned managed identity, and your app
                        specifies to use system-assigned managed identity, Azure VM may still return a token for
                        your user-assigned identity.

                        This is a service-side behavior that cannot be changed by this library.  <u>Azure</u> <u>VM</u> <u>docs</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Microsoft

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2025, Microsoft

1.32.0                                            Mar 14, 2025                                     <u><a href="../man1/MSALPYTHON.1.html">MSALPYTHON</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>