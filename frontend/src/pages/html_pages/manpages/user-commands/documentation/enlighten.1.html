<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>enlighten - Enlighten Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python3-enlighten">python3-enlighten_1.11.2-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       enlighten - Enlighten Documentation

</pre><h4><b>PIP</b></h4><pre>
          $ pip install enlighten

</pre><h4><b>RPM</b></h4><pre>
   <b>Fedora</b> <b>and</b> <b>EL8</b> <b>(RHEL/CentOS)</b>
       (<u>EPEL</u> repositories must be <u>configured</u> for EL8)

          $ dnf install python3-enlighten

   <b>EL7</b> <b>(RHEL/CentOS)</b>
       (<u>EPEL</u> repositories must be <u>configured</u>)

          $ yum install python2-enlighten
          $ yum install python36-enlighten

</pre><h4><b>PKG</b></h4><pre>
   <b>Arch</b> <b>Linux</b>
          $ pacman -S python-enlighten

</pre><h4><b>DEB</b></h4><pre>
   <b>Debian</b> <b>and</b> <b>Ubuntu</b>
          $ apt-get install python3-enlighten

</pre><h4><b>CONDA</b></h4><pre>
          $ conda install -c conda-forge enlighten

</pre><h4><b>BASIC</b></h4><pre>
       For a basic status bar, invoke the <u>Counter</u> class directly.

          import time
          import enlighten

          pbar = enlighten.Counter(total=100, desc='Basic', unit='ticks')
          for num in <a href="../man100/range.100.html">range</a>(100):
              time.sleep(0.1)  # Simulate work
              pbar.update()

</pre><h4><b>ADVANCED</b></h4><pre>
       To maintain multiple progress bars simultaneously or write to the console, a manager is required.

       Advanced  output  will only work when the output stream, <b>sys.__stdout__</b> by default, is attached to a TTY.
       <u>get_manager()</u> can be used to get a manager instance.  It will return a disabled <u>Manager</u> instance  if  the
       stream is not attached to a TTY and an enabled instance if it is.

          import time
          import enlighten

          manager = enlighten.get_manager()
          ticks = manager.counter(total=100, desc='Ticks', unit='ticks')
          tocks = manager.counter(total=20, desc='Tocks', unit='tocks')

          for num in <a href="../man100/range.100.html">range</a>(100):
              time.sleep(0.1)  # Simulate work
              print(num)
              ticks.update()
              if not num % 5:
                  tocks.update()

          manager.stop()

</pre><h4><b>COUNTERS</b></h4><pre>
       The <u>Counter</u> class has two output formats, progress bar and counter.

       The progress bar format is used when a total is not <b>None</b> and the count is less than the total. If neither
       of these conditions are met, the counter format is used:

          import time
          import enlighten

          counter = enlighten.Counter(desc='Basic', unit='ticks')
          for num in <a href="../man100/range.100.html">range</a>(100):
              time.sleep(0.1)  # Simulate work
              counter.update()

</pre><h4><b>STATUS</b> <b>BARS</b></h4><pre>
       Status bars are bars that work similarly to progress similarly to progress bars and counters, but present
       relatively static information.  Status bars are created with <u>Manager.status_bar</u>.

          import enlighten
          import time

          manager = enlighten.get_manager()
          status_bar = manager.status_bar('Static Message',
                                          color='white_on_red',
                                          justify=enlighten.Justify.CENTER)
          <a href="../man1/time.sleep.1.html">time.sleep</a>(1)
          status_bar.update('Updated static message')
          <a href="../man1/time.sleep.1.html">time.sleep</a>(1)

       Status bars can also use formatting with dynamic variables.

          import enlighten
          import time

          manager = enlighten.get_manager()
          status_format = '{program}{fill}Stage: {stage}{fill} Status {status}'
          status_bar = manager.status_bar(status_format=status_format,
                                          color='bold_slategray',
                                          program='Demo',
                                          stage='Loading',
                                          status='OKAY')
          <a href="../man1/time.sleep.1.html">time.sleep</a>(1)
          status_bar.update(stage='Initializing', status='OKAY')
          <a href="../man1/time.sleep.1.html">time.sleep</a>(1)
          status_bar.update(status='FAIL')

       Status  bars, like other bars can be pinned. To pin a status bar to the top of all other bars, initialize
       it before any other bars. To pin a bar to the bottom of the screen, use <b>position=1</b> when initializing.

       See <u>StatusBar</u> for more details.

</pre><h4><b>COLOR</b></h4><pre>
       Status bars and the bar component of a progress bar can be colored by setting the <b>color</b> keyword argument.
       See <u>Series</u> <u>Color</u> for more information about valid colors.

          import time
          import enlighten

          counter = enlighten.Counter(total=100, desc='Colorized', unit='ticks', color='red')
          for num in <a href="../man100/range.100.html">range</a>(100):
              time.sleep(0.1)  # Simulate work
          counter.update()

       Additionally, any part of the progress bar  can  be  colored  using  counter  <u>formatting</u>  and  the  <u>color</u>
       <u>capabilities</u> of the underlying <u>Blessed</u> <u>Terminal</u>.

          import enlighten

          manager = enlighten.get_manager()

          # Standard bar format
          std_bar_format = u'{desc}{desc_pad}{percentage:3.0f}%|{bar}| ' + \
                           u'{count:{len_total}d}/{total:d} ' + \
                           u'[{elapsed}&lt;{eta}, {rate:.2f}{unit_pad}{unit}/s]'

          # Red text
          bar_format = manager.term.red(std_bar_format)

          # Red on white background
          bar_format = manager.term.red_on_white(std_bar_format)

          # X11 colors
          bar_format = manager.term.peru_on_seagreen(std_bar_format)

          # RBG text
          bar_format = manager.term.color_rgb(2, 5, 128)(std_bar_format)

          # RBG background
          bar_format = manager.term.on_color_rgb(255, 190, 195)(std_bar_format)

          # RGB text and background
          bar_format = manager.term.on_color_rgb(255, 190, 195)(std_bar_format)
          bar_format = manager.term.color_rgb(2, 5, 128)(bar_format)

          # Apply color to select parts
          bar_format = manager.term.red(u'{desc}') + u'{desc_pad}' + \
                       manager.term.blue(u'{percentage:3.0f}%') + u'|{bar}|'

          # Apply to counter
          ticks = manager.counter(total=100, desc='Ticks', unit='ticks', bar_format=bar_format)

       If the <b>color</b> option is applied to a <u>Counter</u>, it will override any foreground color applied.

</pre><h4><b>MULTICOLORED</b></h4><pre>
       The bar component of a progress bar can be multicolored to track multiple categories in a single progress
       bar.

       The colors are drawn from right to left in the order they were added.

       By default, when multicolored progress bars are used, additional fields are available for <b>bar_format</b>:

          • count_n (<b>int</b>) - Current value of <b>count</b>

          • count_0(<b>int</b>) - Remaining count after deducting counts for all subcounters

          • count_00 (<b>int</b>) - Sum of counts from all subcounters

          • percentage_n (<b>float</b>) - Percentage complete

          • percentage_0(<b>float</b>) - Remaining percentage after deducting percentages for all subcounters

          • percentage_00 (<b>float</b>) - Total of percentages from all subcounters

       When  <b>add_subcounter()</b>  is  called  with  <b>all_fields</b> set to <b>True</b>, the subcounter will have the additional
       fields:

          • eta_n (<b>str</b>) - Estimated time to completion

          • rate_n (<b>float</b>) - Average increments per second since parent was created

       More information about <b>bar_format</b> can be found in the <u>Format</u> section of the API.

       One use case for multicolored progress bars is recording the status  of  a  series  of  tests.   In  this
       example,  Failures are red, errors are white, and successes are green. The count of each is listed in the
       progress bar.

          import random
          import time
          import enlighten

          bar_format = u'{desc}{desc_pad}{percentage:3.0f}%|{bar}| ' + \
                      u'S:{count_0:{len_total}d} ' + \
                      u'F:{count_2:{len_total}d} ' + \
                      u'E:{count_1:{len_total}d} ' + \
                      u'[{elapsed}&lt;{eta}, {rate:.2f}{unit_pad}{unit}/s]'

          success = enlighten.Counter(total=100, desc='Testing', unit='tests',
                                      color='green', bar_format=bar_format)
          errors = success.add_subcounter('white')
          failures = success.add_subcounter('red')

          while success.count &lt; 100:
              time.sleep(random.uniform(0.1, 0.3))  # Random processing time
              result = random.randint(0, 10)

              if result == 7:
                  errors.update()
              if result in (5, 6):
                  failures.update()
              else:
                  success.update()

       A more complicated example is recording process start-up.  In  this  case,  all  items  will  start  red,
       transition  to  yellow, and eventually all will be green. The count, percentage, rate, and eta fields are
       all derived from the second subcounter added.

          import random
          import time
          import enlighten

          services = 100
          bar_format = u'{desc}{desc_pad}{percentage_2:3.0f}%|{bar}|' + \
                      u' {count_2:{len_total}d}/{total:d} ' + \
                      u'[{elapsed}&lt;{eta_2}, {rate_2:.2f}{unit_pad}{unit}/s]'

          initializing = enlighten.Counter(total=services, desc='Starting', unit='services',
                                          color='red', bar_format=bar_format)
          starting = initializing.add_subcounter('yellow')
          started = initializing.add_subcounter('green', all_fields=True)

          while started.count &lt; services:
              remaining = services - initializing.count
              if remaining:
                  num = random.randint(0, min(4, remaining))
                  initializing.update(num)

              ready = initializing.count - initializing.subcount
              if ready:
                  num = random.randint(0, min(3, ready))
                  starting.update_from(initializing, num)

              if starting.count:
                  num = random.randint(0, min(2, starting.count))
                  started.update_from(starting, num)

              time.sleep(random.uniform(0.1, 0.5))  # Random processing time

</pre><h4><b>ADDITIONAL</b> <b>EXAMPLES</b></h4><pre>
       • <b>Basic</b> - Basic progress bar

       • <b>Binary</b> <b>prefixes</b> - Automatic binary prefixes

       • <b>Context</b> <b>manager</b> - Managers and counters as context managers

       • <b>FTP</b> <b>downloader</b> - Show progress downloading files from FTP

       • <b>Floats</b> - Support totals and counts that are <b>floats</b>

       • <b>Multicolored</b> - Multicolored progress bars

       • <b>Multiple</b> <b>with</b> <b>logging</b> - Nested progress bars and logging

       • <b>Multiprocessing</b> <b>queues</b> - Progress bars with queues for IPC

</pre><h4><b>CUSTOMIZATION</b></h4><pre>
       Enlighten is highly configurable. For information on modifying the output,  see  the  <u>Series</u>  and  <u>Format</u>
       sections of the <u>Counter</u> documentation.

</pre><h4><b>ENABLE</b> <b>/</b> <b>DISABLE</b></h4><pre>
       A  program  may  want  to  disable  progress  bars  based on a configuration setting as well as if output
       redirection occurs.

          import sys
          import enlighten

          # Example configuration object
          config = {'stream': sys.stdout,
                    'useCounter': False}

          enableCounter = config['useCounter'] and stream.isatty()
          manager = enlighten.Manager(stream=config['stream'], enabled=enableCounter)

       The <u>get_manager()</u> function slightly simplifies this

          import enlighten

          # Example configuration object
          config = {'stream': None,  # Defaults to sys.__stdout__
                    'useCounter': False}

          manager = enlighten.get_manager(stream=config['stream'], enabled=config['useCounter'])

</pre><h4><b>CONTEXT</b> <b>MANAGERS</b></h4><pre>
       Both <u>Counter</u> and <u>Manager</u> can be used as context managers.

          import enlighten

          SPLINES = 100

          with enlighten.Manager() as manager:
              with manager.counter(total=SPLINES, desc='Reticulating:', unit='splines') as retic:
                  for num in range(SPLINES + 1):
                      retic.update()

</pre><h4><b>AUTOMATIC</b> <b>UPDATING</b></h4><pre>
       Both <u>Counter</u> and <u>SubCounter</u> instances can be called as functions on one or more iterators. A generator is
       returned which yields each element of the iterables and then updates the count by 1.

       <b>NOTE:</b>
          When a <u>Counter</u> instance is called as a function, type checking is lazy and won't validate an  iterable
          was passed until iteration begins.

          import time
          import enlighten

          flock1 = ['Harry', 'Sally', 'Randy', 'Mandy', 'Danny', 'Joe']
          flock2 = ['Punchy', 'Kicky', 'Spotty', 'Touchy', 'Brenda']
          total = len(flock1) + len(flock2)

          manager = enlighten.Manager()
          pbar = manager.counter(total=total, desc='Counting Sheep', unit='sheep')

          for sheep in pbar(flock1, flock2):
              time.sleep(0.2)
              print('%s: Baaa' % sheep)

</pre><h4><b>USER-DEFINED</b> <b>FIELDS</b></h4><pre>
       Both  <u>Counter</u>  and <u>StatusBar</u> accept user defined fields as keyword arguments at initialization and during
       an update.  These fields are persistent and only need to be specified when they change.

       In the following example, <b>source</b> is a user-defined field that is periodically updated.

          import enlighten
          import random
          import time

          bar_format = u'{desc}{desc_pad}{source} {percentage:3.0f}%|{bar}| ' + \
                       u'{count:{len_total}d}/{total:d} ' + \
                       u'[{elapsed}&lt;{eta}, {rate:.2f}{unit_pad}{unit}/s]'
          manager = enlighten.get_manager(bar_format=bar_format)

          bar = manager.counter(total=100, desc='Loading', unit='files', source='server.a')
          for num in <a href="../man100/range.100.html">range</a>(100):
              time.sleep(0.1)  # Simulate work
              if not num % 5:
                  bar.update(source=random.choice(['server.a', 'server.b', 'server.c']))
              else:
                  bar.update()

       For more information, see the <u>Counter</u> <u>Format</u> and <u>StatusBar</u> <u>Format</u> sections.

</pre><h4><b>HUMAN-READABLE</b> <b>NUMERIC</b> <b>PREFIXES</b></h4><pre>
       Enlighten supports automatic <u>SI</u> <u>(metric)</u> and <u>IEC</u> <u>(binary)</u> prefixes using the <u>Prefixed</u> library.

       All <b>rate</b> and <b>interval</b> formatting fields are of the type  <b>prefixed.Float</b>.   <b>total</b>  and  all  <b>count</b>  fields
       default  to  <b>int</b>.   If  <b>total</b>  or  or <b>count</b> are set to a <b>float</b>, or a <b>float</b> is provided to <b>update()</b>, these
       fields will be <b>prefixed.Float</b> instead.

          import time
          import random
          import enlighten

          size = random.uniform(1.0, 10.0) * 2 ** 20  # 1-10 MiB (float)
          chunk_size = 64 * 1024  # 64 KiB

          bar_format = '{desc}{desc_pad}{percentage:3.0f}%|{bar}| ' \
                       '{count:!.2j}{unit} / {total:!.2j}{unit} ' \
                       '[{elapsed}&lt;{eta}, {rate:!.2j}{unit}/s]'

          manager = enlighten.get_manager()
          pbar = manager.counter(total=size, desc='Downloading', unit='B', bar_format=bar_format)

          bytes_left = size
          while bytes_left:
              time.sleep(random.uniform(0.05, 0.15))
              next_chunk = min(chunk_size, bytes_left)
              pbar.update(next_chunk)
              bytes_left -= next_chunk

          import enlighten

          counter_format = 'Trying to get to sleep: {count:.2h} sheep'

          counter = enlighten.Counter(counter_format=counter_format)
          counter.count = 0.0
          for num in <a href="../man10000000/range.10000000.html">range</a>(10000000):
              counter.update()

       For more information, see the <u>Counter</u> <u>Format</u> and the <u>Prefixed</u> documentation.

</pre><h4><b>WHY</b> <b>IS</b> <b>ENLIGHTEN</b> <b>CALLED</b> <b>ENLIGHTEN?</b></h4><pre>
       A progress bar's purpose is to inform the user about an ongoing process.  Enlighten, meaning "to inform",
       seems a fitting name.  (Plus any names related to progress were already taken)

</pre><h4><b>IS</b> <b>WINDOWS</b> <b>SUPPORTED?</b></h4><pre>
       Enlighten has supported Windows since version 1.3.0.

       Windows does not currently support resizing.

       Enlighten also works relatively well in Linux-like subsystems for  Windows  such  as  <u>Cygwin</u>  or  <u>Windows</u>
       <u>Subsystem</u> <u>for</u> <u>Linux</u>.

</pre><h4><b>IS</b> <b>JUPYTER</b> <b>NOTEBOOKS</b> <b>SUPPORTED?</b></h4><pre>
       Experimental support for Jupyter notebooks was added in version 1.10.0.

       Jupyter  Notebook support is provide by the <u>NotebookManager</u> class.  If running inside a Jupyter Notebook,
       <u>get_manager()</u> will return a <u>NotebookManager</u> instance.

       There is currently no support for detecting the width of a Jupyter notebook so output width has been  set
       statically  to  100  characters.  This  can  be  overridden  by  passing  the  <b>width</b>  keyword argument to
       <u>get_manager()</u>.

</pre><h4><b>IS</b> <b>PYCHARM</b> <b>SUPPORTED?</b></h4><pre>
       PyCharm uses multiple consoles and the behavior differs depending on how the code is called.

       Enlighten works natively in the PyCharm command terminal.

       To use Enlighten with Run or Debug, terminal  emulation  must  be  enabled.   Navigate  to  <u>Run</u>  <u>-&gt;</u>  <u>Edit</u>
       <u>Configurations</u> <u>-&gt;</u> <u>Templates</u> <u>-&gt;</u> <u>Python</u> and select <u>Emulate</u> <u>terminal</u> <u>in</u> <u>output</u> <u>console</u>.

       The PyCharm Python console is currently not supported because <b>sys.stdout</b> does not reference a valid TTY.

</pre><h4><b>CAN</b> <b>YOU</b> <b>ADD</b> <b>SUPPORT</b> <b>FOR</b> <b>_______</b> <b>TERMINAL?</b></h4><pre>
       We  are  happy  to  add  support  for  as  many  terminals  as we can.  However, not all terminals can be
       supported. There a few requirements.

          1. The terminal must be detectable programmatically
                 We need to be able to identify the terminal in some reasonable way and  differentiate  it  from
                 other  terminals.  This  could  be  through environment variables, the <b>platform</b> module, or some
                 other method.

          2. A subset of terminal codes must be supported
                 While these codes may vary among terminals, the capability must be provided  and  activated  by
                 printing a terminal sequence.  The required codes are listed below.

                    • move / CUP - Cursor Position

                    • hide_cursor / DECTCEM - Text Cursor Enable Mode

                    • show_cursor / DECTCEM - Text Cursor Enable Mode

                    • csr / DECSTBM - Set Top and Bottom Margins

                    • clear_eos / ED - Erase in Display

                    • clear_eol / EL - Erase in Line

                    • feed / CUD - Cursor Down (Or scroll with linefeed)

          3. Terminal dimensions must be detectable
                 The height and width of the terminal must be available to the running process.

</pre><h4><b>WHY</b> <b>DOES</b> <b>RUNTIMEERROR:</b> <b>REENTRANT</b> <b>CALL</b> <b>GET</b> <b>RAISED</b> <b>SOMETIMES</b> <b>DURING</b> <b>A</b> <b>RESIZE?</b></h4><pre>
       This  is  caused  when  another thread or process is writing to a standard stream (STDOUT, STDERR) at the
       same time the resize signal handler is writing to the stream.

       Enlighten tries to detect when a program is threaded or  running  multiple  processes  and  defer  resize
       handling  until the next normal write event. However, this condition is evaluated when the scroll area is
       set, typically when the first counter is added. If no threads or processes are detected at that time, and
       the value of threaded was not set explicitly, resize events will not be deferred.

       In order to guarantee resize handling is deferred, it is best  to  pass  <b>threaded=True</b>  when  creating  a
       manager instance.

</pre><h4><b>WHY</b> <b>DOES</b> <b>THE</b> <b>OUTPUT</b> <b>DISAPPEAR</b> <b>AT</b> <b>THE</b> <b>END</b> <b>OF</b> <b>A</b> <b>NOTEBOOK</b> <b>CELL</b> <b>IN</b> <b>VSCODE?</b></h4><pre>
       This  is  caused  by  a  <u>bug</u> in the VSCode Jupyter extension that reverts display updates at the end of a
       cell.  This issue has been confirmed by the maintainers, but a fix has not been released yet.

       As a temporary workaround, <b>manager._primed</b> <b>=</b> <b>False</b> at the end of the cell before  calling  <u>stop()</u>.  Note,
       this  will result in double output in other environments so should only be used if the display is cleared
       first or the code is limited to running in this extension.

</pre><h4><b>CLASSES</b></h4><pre>
       <b>class</b> <b>enlighten.Manager(stream=None,</b> <b>counter_class=Counter,</b> <b>**kwargs)</b>

              <b>Parameters</b>

                     • <b>stream</b> (file object) -- Output stream. If <b>None</b>, defaults to <b>sys.__stdout__</b>

                     • <b>status_bar_class</b> (class) -- Status bar class (Default: <u>StatusBar</u>)

                     • <b>counter_class</b> (class) -- Progress bar class (Default: <u>Counter</u>)

                     • <b>set_scroll</b> (<u>bool</u>) -- Enable scroll area redefinition (Default: <b>True</b>)

                     • <b>companion_stream</b> (file object) -- See <u>companion_stream</u> below. (Default: <b>None</b>)

                     • <b>enabled</b> (<u>bool</u>) -- Status (Default: True)

                     • <b>no_resize</b> (<u>bool</u>) -- Disable resizing support

                     • <b>threaded</b> (<u>bool</u>) -- When True resize handling is deferred until next write (Default: False
                       unless multiple threads or multiple processes are detected)

                     • <b>width</b> (<u>int</u>) -- Static output width. If unset, terminal width is determined dynamically

                     • <b>kwargs</b> (<u>Dict[str,</u> <u>Any]</u>) -- Any additional keyword  arguments  will  be  used  as  default
                       values when <u>counter()</u> is called.

              Manager class for outputting progress bars to streams attached to TTYs

              Progress bars are displayed at the bottom of the screen with standard output displayed above.

              <b>companion_stream</b>
                 A  companion  stream  is  a  file  object that shares a TTY with the primary output stream. The
                 cursor position in the companion stream will be moved in coordination with the primary stream.

                 If the value is <b>None</b>, the companion stream will be dynamically determined.   Unless  explicitly
                 specified,  a  stream which is not attached to a TTY (the case when redirected to a file), will
                 not be used as a companion stream.

              <b>counter(position=None,</b> <b>**kwargs)</b>

                     <b>Parameters</b>

                            • <b>position</b> (<u>int</u>) -- Line number counting from the bottom of the screen

                            • <b>autorefresh</b> (<u>bool</u>) -- Refresh this counter when other bars are drawn

                            • <b>replace</b> (<b>PrintableCounter</b>) -- Replace given counter with new. Position ignored.

                            • <b>kwargs</b> (<u>Dict[str,</u> <u>Any]</u>) -- Any additional keyword arguments are passed to <u>Counter</u>

                     <b>Returns</b>
                            Instance of counter class

                     <b>Return</b> <b>type</b>
                            <u>Counter</u>

                     Get a new progress bar instance

                     If <b>position</b> is specified, the counter's position will be  pinned.   A  <b>ValueError</b>  will  be
                     raised if <b>position</b> exceeds the screen height or has already been pinned by another counter.

                     If  <b>autorefresh</b> is <b>True</b>, this bar will be redrawn whenever another bar is drawn assuming it
                     had been <b>min_delta</b> seconds since the last update. This is usually unnecessary.

                     <b>NOTE:</b>
                        Counters are not automatically drawn when created  because  fields  may  be  missing  if
                        subcounters are used. To force the counter to draw before updating, call <u>refresh()</u>.

              <b>status_bar(*args,</b> <b>**kwargs)</b>

                     <b>Parameters</b>

                            • <b>position</b> (<u>int</u>) -- Line number counting from the bottom of the screen

                            • <b>autorefresh</b> (<u>bool</u>) -- Refresh this counter when other bars are drawn

                            • <b>replace</b> (<b>PrintableCounter</b>) -- Replace given counter with new. Position ignored.

                            • <b>kwargs</b>  (<u>Dict[str,</u>  <u>Any]</u>)  --  Any  additional  keyword  arguments  are  passed to
                              <u>StatusBar</u>

                     <b>Returns</b>
                            Instance of status bar class

                     <b>Return</b> <b>type</b>
                            <u>StatusBar</u>

                     Get a new status bar instance

                     If <b>position</b> is specified, the counter's  position  can  change  dynamically  if  additional
                     counters are called without a <b>position</b> argument.

                     If  <b>autorefresh</b> is <b>True</b>, this bar will be redrawn whenever another bar is drawn assuming it
                     had been <b>min_delta</b> seconds since the last update. Generally, only need when <b>elapsed</b> is used
                     in <u>status_format</u>.

              <b>stop()</b> Clean up and reset terminal

                     This method should be called when the manager and counters will no longer be needed.

                     Any progress bars that have <b>leave</b> set to <b>True</b> or have not been closed will  remain  on  the
                     console. All others will be cleared.

                     Manager and all counters will be disabled.

       <b>class</b> <b>enlighten.NotebookManager(stream=None,</b> <b>counter_class=Counter,</b> <b>**kwargs)</b>

              <b>Parameters</b>

                     • <b>counter_class</b> (class) -- Progress bar class (Default: <u>Counter</u>)

                     • <b>status_bar_class</b> (class) -- Status bar class (Default: <u>StatusBar</u>)

                     • <b>enabled</b> (<u>bool</u>) -- Status (Default: True)

                     • <b>width</b> (<u>int</u>) -- Static output width (Default: 100)

                     • <b>kwargs</b>  (<u>Dict[str,</u>  <u>Any]</u>)  --  Any  additional  keyword arguments will be used as default
                       values when <u>counter()</u> is called.

              Manager class for outputting progress bars to Jupyter notebooks

              The following keyword arguments are set if provided, but ignored:

                 • <u>stream</u>

                 • <u>set_scroll</u>

                 • <u>companion_stream</u>

                 • <u>no_resize</u>

                 • <u>threaded</u>

              <b>counter(position=None,</b> <b>**kwargs)</b>

                     <b>Parameters</b>

                            • <b>position</b> (<u>int</u>) -- Line number counting from the bottom of the screen

                            • <b>autorefresh</b> (<u>bool</u>) -- Refresh this counter when other bars are drawn

                            • <b>replace</b> (<b>PrintableCounter</b>) -- Replace given counter with new. Position ignored.

                            • <b>kwargs</b> (<u>Dict[str,</u> <u>Any]</u>) -- Any additional keyword arguments are passed to <u>Counter</u>

                     <b>Returns</b>
                            Instance of counter class

                     <b>Return</b> <b>type</b>
                            <u>Counter</u>

                     Get a new progress bar instance

                     If <b>position</b> is specified, the counter's position will be  pinned.   A  <b>ValueError</b>  will  be
                     raised if <b>position</b> exceeds the screen height or has already been pinned by another counter.

                     If  <b>autorefresh</b> is <b>True</b>, this bar will be redrawn whenever another bar is drawn assuming it
                     had been <b>min_delta</b> seconds since the last update. This is usually unnecessary.

                     <b>NOTE:</b>
                        Counters are not automatically drawn when created  because  fields  may  be  missing  if
                        subcounters are used. To force the counter to draw before updating, call <u>refresh()</u>.

              <b>status_bar(*args,</b> <b>**kwargs)</b>

                     <b>Parameters</b>

                            • <b>position</b> (<u>int</u>) -- Line number counting from the bottom of the screen

                            • <b>autorefresh</b> (<u>bool</u>) -- Refresh this counter when other bars are drawn

                            • <b>replace</b> (<b>PrintableCounter</b>) -- Replace given counter with new. Position ignored.

                            • <b>kwargs</b>  (<u>Dict[str,</u>  <u>Any]</u>)  --  Any  additional  keyword  arguments  are  passed to
                              <u>StatusBar</u>

                     <b>Returns</b>
                            Instance of status bar class

                     <b>Return</b> <b>type</b>
                            <u>StatusBar</u>

                     Get a new status bar instance

                     If <b>position</b> is specified, the counter's  position  can  change  dynamically  if  additional
                     counters are called without a <b>position</b> argument.

                     If  <b>autorefresh</b> is <b>True</b>, this bar will be redrawn whenever another bar is drawn assuming it
                     had been <b>min_delta</b> seconds since the last update. Generally, only need when <b>elapsed</b> is used
                     in <u>status_format</u>.

              <b>stop()</b> Clean up and reset terminal

                     This method should be called when the manager and counters will no longer be needed.

                     Any progress bars that have <b>leave</b> set to <b>True</b> or have not been closed will  remain  on  the
                     console. All others will be cleared.

                     Manager and all counters will be disabled.

       <b>class</b> <b>enlighten.Counter(**kwargs)</b>

              <b>Parameters</b>

                     • <b>all_fields</b> (<u>bool</u>) -- Populate <b>rate</b>, <b>interval</b>, and <b>eta</b> formatting fields in subcounters

                     • <b>bar_format</b> (<u>str</u>) -- Progress bar format, see <u>Format</u> below

                     • <b>count</b> (<u>int</u>) -- Initial count (Default: 0)

                     • <b>counter_format</b> (<u>str</u>) -- Counter format, see <u>Format</u> below

                     • <b>color</b> (<u>str</u>) -- Series color as a string or RGB tuple see <u>Series</u> <u>Color</u>

                     • <b>desc</b> (<u>str</u>) -- Description

                     • <b>enabled</b> (<u>bool</u>) -- Status (Default: <b>True</b>)

                     • <b>fill</b> (<u>str</u>) -- Fill character used for <b>counter_format</b> (Default: ' ')

                     • <b>fields</b> (<u>dict</u>) -- Additional fields used for <u>formatting</u>

                     • <b>leave</b> (<u>True</u>) -- Leave progress bar after closing (Default: <b>True</b>)

                     • <b>manager</b> (<u>Manager</u>) -- Manager instance. Creates instance if not specified.

                     • <b>min_delta</b> (<u>float</u>) -- Minimum time, in seconds, between refreshes (Default: 0.1)

                     • <b>offset</b> (<u>int</u>) -- Number of non-printable characters to account for when formatting

                     • <b>series</b> (sequence) -- Progression series, see <u>Series</u> below

                     • <b>stream</b> (file object) -- Output stream. Not used when instantiated through a manager

                     • <b>total</b> (<u>int</u>) -- Total count when complete

                     • <b>unit</b> (<u>str</u>) -- Unit label

              Progress bar and counter class

              A <u>Counter</u> instance can be created with the <u>Manager.counter()</u> method or, when a standalone progress
              bar  for  simple  applications  is  required, the <u>Counter</u> class can be called directly. The output
              stream will default to <b>sys.__stdout__</b> unless <b>stream</b> is set.

              <b>NOTE:</b>
                 With the default values for <b>bar_format</b> and <b>counter_format</b>, <b>floats</b> can not be  used  for  <b>total</b>,
                 <b>count</b>,  or  provided  to <u>update()</u>. In order to use <b>floats</b>, provide custom formats to <b>bar_format</b>
                 and <b>counter_format</b>. See <u>Format</u> below.

              <b>Series</b>
                 The progress bar is constructed from the characters in <b>series</b>. <b>series</b> must be a sequence  (<b>str</b>,
                 <b>list</b>, <b>tuple</b>) containing single characters.

                 Default progress series (<b>series</b>):

                     ' ▏▎▍▌▋▊▉█'

                 The first character is the fill character. When the <b>count</b> is 0, the bar will be made up of only
                 this character.  In the example below, characters 5 through 9 are fill characters.

                 The  last  character  is  the full character. When the <b>count</b> is equal to <b>total</b>, the bar will be
                 made up of only this character.  In  the  example  below,  characters  0  through  3  are  full
                 characters.

                 The  remaining  characters  are  fractional  characters  used  to more accurately represent the
                 transition between the full and fill characters.  In  the  example  below,  character  4  is  a
                 fractional character.

                     '45% |████▋     |'
                          '0123456789'

              <b>Series</b> <b>Color</b>
                 The  characters  specified  by  <b>series</b>  will  be displayed in the terminal's current foreground
                 color. This can be overwritten with the <b>color</b> argument.

                 <b>color</b> can be specified as <b>None</b>, a <b>string</b> or, an iterable of three integers, 0 - 255, describing
                 an RGB color.

                 For backward compatibility, a color can be expressed as  an  integer  0  -  255,  but  this  is
                 deprecated in favor of named or RGB colors.

                 Compound  colors,  such  as  'white_on_seagreen',  'bold_red',  or 'underline_on_peru' are also
                 supported.

                 If a terminal is not capable of 24-bit color, and is given a color outside of  its  range,  the
                 color will be downconverted to a supported color.

                 Valid colors for 8 color terminals:

                     • black

                     • blue

                     • cyan

                     • green

                     • magenta

                     • red

                     • white

                     • yellow

                 Additional colors for 16 color terminals:

                     • bright_black

                     • bright_blue

                     • bright_cyan

                     • bright_green

                     • bright_magenta

                     • bright_red

                     • bright_white

                     • bright_yellow

                 See this <u>chart</u> for a complete list of supported color strings.

                 <b>NOTE:</b>
                     If an invalid color is specified, an <b>AttributeError</b> will be raised

              <b>Format</b>
                 If <b>total</b> is <b>None</b> or <b>count</b> becomes higher than <b>total</b>, the counter format will be used instead of
                 the progress bar format.

                 Default counter format (<b>counter_format</b>):

                     '{desc}{desc_pad}{count:d} {unit}{unit_pad}{elapsed}, {rate:.2f}{unit_pad}{unit}/s]{fill}'

                     # Example output
                     'Loaded 30042 Files [00:01, 21446.45 Files/s]                                    '

                 Default progress bar format (<b>bar_format</b>):

                     '{desc}{desc_pad}{percentage:3.0f}%|{bar}| {count:{len_total}d}/{total:d} [{elapsed}&lt;{eta}, {rate:.2f}{unit_pad}{unit}/s]'

                     # Example output
                     'Processing    22%|█████▊                   |  23/101 [00:27&lt;01:32, 0.84 Files/s]'

                 Available fields:

                 • count(<b>int</b>) - Current value of <b>count</b>

                 • desc(<b>str</b>) - Value of <b>desc</b>

                 • desc_pad(<b>str</b>) - A single space if <b>desc</b> is set, otherwise empty

                 • elapsed(<b>str</b>) - Time elapsed since instance was created

                 • interval(<b>prefixed.Float</b>) - Average seconds per iteration (inverse of rate)

                 • rate(<b>prefixed.Float</b>) - Average iterations per second since instance was created

                 • total(<b>int</b>) - Value of <b>total</b>

                 • unit(<b>str</b>) - Value of <b>unit</b>

                 • unit_pad(<b>str</b>) - A single space if <b>unit</b> is set, otherwise empty

                 Additional fields for <b>bar_format</b> only:

                 • bar(<b>str</b>) - Progress bar draw with characters from <b>series</b>

                 • eta(<b>str</b>) - Estimated time to completion

                 • len_total(<b>int</b>) - Length of <b>total</b> when converted to a string

                 • percentage(<b>float</b>) - Percentage complete

                 Additional fields for <b>counter_format</b> only:

                 • fill(<b>str</b>)  -  Filled  with <u>fill</u> until line is width of terminal.  May be used multiple times.
                   Minimum width is 3.

                 Additional fields when subcounters are used:

                 • count_n(<b>int</b>) - Current value of <b>count</b>

                 • count_0(<b>int</b>) - Remaining count after deducting counts for all subcounters

                 • count_00(<b>int</b>) - Sum of counts from all subcounters

                 • interval_0(<b>prefixed.Float</b>) - Average seconds per non-subcounter iteration (inverse of rate_0)

                 • interval_00(<b>prefixed.Float</b>) - Average seconds per iteration for all subcounters  (inverse  of
                   rate_00)

                 • percentage_n(<b>float</b>) - Percentage complete (<b>bar_format</b> only)

                 • percentage_0(<b>float</b>)  -  Remaining  percentage after deducting percentages for all subcounters
                   (<b>bar_format</b> only)

                 • percentage_00(<b>float</b>) - Total of percentages from all subcounters

                 • rate_0(<b>prefixed.Float</b>) - Average iterations per second excluding subcounters  since  instance
                   was created

                 • rate_00(<b>prefixed.Float</b>) - Average iterations per second of all subcounters since instance was
                   created

                 <b>NOTE:</b>
                     <b>n</b>  denotes  the  order the subcounter was added starting at 1.  For example, <b>count_1</b> is the
                     count for the first subcounter added and <b>count_2</b> is the count  for  the  second  subcounter
                     added.

                 Additional fields when <u>add_subcounter()</u> is called with <b>all_fields</b> set to <b>True</b>:

                 • eta_n (<b>str</b>) - Estimated time to completion (<b>bar_format</b> only)

                 • interval_n(<b>prefixed.Float</b>) - Average seconds per iteration (inverse of rate)

                 • rate_n (<b>prefixed.Float</b>) - Average iterations per second since parent was created

                 <b>NOTE:</b>
                     <b>count</b>  and <b>total</b> fields, including <b>count_0</b>, <b>count_00</b>, and <b>count_n</b>, default to <b>int</b>. If <u>total</u>
                     or or <u>count</u> are set to a <b>float</b>, or a <b>float</b> is provided to <u>update()</u>, these  fields  will  be
                     <b>prefixed.Float</b> instead.

                     This  allows  additional <u>format</u> <u>specifiers</u> using <u>SI</u> <u>(metric)</u> and <u>IEC</u> <u>(binary)</u> prefixes. See
                     the <u>Prefixed</u> <u>documentation</u> for more details.

                     This will also require a custom format and affect the accuracy of the <b>len_total</b> field.

                 User-defined fields:
                     Users can define fields in two ways, the <b>fields</b> parameter and by passing keyword  arguments
                     to <u>Manager.counter()</u> or <u>Counter.update()</u>

                     The  <b>fields</b>  parameter  can be used to pass a dictionary of additional user-defined fields.
                     The dictionary values can be updated after initialization to allow for dynamic fields.  Any
                     fields that share names with built-in fields are ignored.

                     If  fields  are  passed as keyword arguments to <u>Manager.counter()</u> or <u>Counter.update()</u>, they
                     take precedent over the <b>fields</b> parameter.

              <b>Offset</b>
                 When <b>offset</b> is <b>None</b>, the width of the bar portion of the progress bar and  the  fill  size  for
                 counter  will  be  automatically determined, taking into account terminal escape sequences that
                 may be included in the string.

                 Under special circumstances, and to permit backward compatibility, <b>offset</b> may be explicitly set
                 to an <b>int</b> value. When explicitly set, automatic detection of escape sequences is disabled.

              <b>Instance</b> <b>Attributes</b>

                 <b>count</b>  <b>int</b> - Current count

                 <b>desc</b>   <b>str</b> - Description

                 <b>elapsed</b>
                        <b>float</b> - Time since start (since last update if <b>count`equals</b> <b>:py:attr:`total</b>)

                 <b>enabled</b>
                        <b>bool</b> - Current status

                 <b>manager</b>
                        <u>Manager</u> - Manager Instance

                 <b>position</b>
                        <b>int</b> - Current position

                 <b>total</b>  <b>int</b> - Total count when complete

                 <b>unit</b>   <b>str</b> - Unit label

              <b>add_subcounter(color,</b> <b>count=0,</b> <b>all_fields=None)</b>

                     <b>Parameters</b>

                            • <b>color</b> (<u>str</u>) -- Series color as a string or RGB tuple see <u>Series</u> <u>Color</u>

                            • <b>count</b> (<u>int</u>) -- Initial count (Default: 0)

                            • <b>all_fields</b> (<u>bool</u>) -- Populate <b>rate</b>, <b>interval</b>, and <b>eta</b> formatting fields  (Default:
                              False unless specified in parent)

                     <b>Returns</b>
                            Subcounter instance

                     <b>Return</b> <b>type</b>
                            <u>SubCounter</u>

                     Add a subcounter for multicolored progress bars

              <b>clear(flush=True)</b>

                     <b>Parameters</b>
                            <b>flush</b> (<u>bool</u>) -- Flush stream after clearing bar (Default:True)

                     Clear bar

              <b>close(clear=False)</b>
                     Do final refresh and remove from manager

                     If <b>leave</b> is True, the default, the effect is the same as <u>refresh()</u>.

              <b>property</b> <b>color</b>
                     Color property

                     Preferred  to  be a string or iterable of three integers for RGB.  Single integer supported
                     for backwards compatibility

              <b>property</b> <b>fill</b>
                     Fill character used in formatting

              <b>format(width=None,</b> <b>elapsed=None)</b>

                     <b>Parameters</b>

                            • <b>width</b> (<u>int</u>) -- Width in columns to make progress bar

                            • <b>elapsed</b> (<u>float</u>) -- Time since started. Automatically determined if <b>None</b>

                     <b>Returns</b>
                            Formatted progress bar or counter

                     <b>Return</b> <b>type</b>
                            <b>str</b>

                     Format progress bar or counter

              <b>refresh(flush=True,</b> <b>elapsed=None)</b>

                     <b>Parameters</b>

                            • <b>flush</b> (<u>bool</u>) -- Flush stream after writing bar (Default:True)

                            • <b>elapsed</b> (<u>float</u>) -- Time since started. Automatically determined if <b>None</b>

                     Redraw bar

              <b>property</b> <b>subcount</b>
                     Sum of counts from all subcounters

              <b>update(incr=1,</b> <b>force=False,</b> <b>**fields)</b>

                     <b>Parameters</b>

                            • <b>incr</b> (<u>int</u>) -- Amount to increment <b>count</b> (Default: 1)

                            • <b>force</b> (<u>bool</u>) -- Force refresh even if <b>min_delta</b> has not been reached

                            • <b>fields</b> (<u>dict</u>) -- Fields for for <u>formatting</u>

                     Increment progress bar and redraw

                     Progress bar is only redrawn if <b>min_delta</b> seconds past since the last update

       <b>class</b> <b>enlighten.StatusBar(*args,</b> <b>**kwargs)</b>

              <b>Parameters</b>

                     • <b>enabled</b> (<u>bool</u>) -- Status (Default: <b>True</b>)

                     • <b>color</b> (<u>str</u>) -- Color as a string or RGB tuple see <u>Status</u> <u>Color</u>

                     • <b>fields</b> (<u>dict</u>) -- Additional fields used for <u>formating</u>

                     • <b>fill</b> (<u>str</u>) -- Fill character used in formatting and justifying text (Default: ' ')

                     • <b>justify</b> (<u>str</u>) -- One of <u>Justify.CENTER</u>, <u>Justify.LEFT</u>, <u>Justify.RIGHT</u>

                     • <b>leave</b> (<u>True</u>) -- Leave status bar after closing (Default: <b>True</b>)

                     • <b>min_delta</b> (<u>float</u>) -- Minimum time, in seconds, between refreshes (Default: 0.1)

                     • <b>status_format</b> (<u>str</u>) -- Status bar format, see <u>Format</u>

              Status bar class

              A <u>StatusBar</u> instance should be created with the <u>Manager.status_bar()</u> method.

              <b>Status</b> <b>Color</b>

              Color works similarly to color on <u>Counter</u>, except it affects the entire status  bar.   See  <u>Series</u>
              <u>Color</u> for more information.

              <b>Format</b>

              There  are two ways to populate the status bar, direct and formatted. Direct takes precedence over
              formatted.

              <b>Direct</b> <b>Status</b>

              Direct status is used when arguments are passed to <u>Manager.status_bar()</u> or <u>StatusBar.update()</u>. Any
              arguments are coerced to strings and joined with a space.  For example:

                 status_bar.update('Hello', 'World!')
                 # Example output: Hello World!

                 status_bar.update('Hello World!')
                 # Example output: Hello World!

                 count = [1, 2, 3, 4]
                 status_bar.update(*count)
                  # Example output: 1 2 3 4

              <b>Formatted</b> <b>Status</b>
                 Formatted status uses the format specified in  the  <b>status_format</b>  parameter  to  populate  the
                 status bar.

                     'Current Stage: {stage}'

                     # Example output
                     'Current Stage: Testing'

                 Available fields:

                     • elapsed(<b>str</b>) - Time elapsed since instance was created

                     • fill(<b>str</b>)  -  Filled  with  <u>fill</u>  until  line is width of terminal.  May be used multiple
                       times. Minimum width is 3.

                 <b>NOTE:</b>
                     The status bar is only updated when <u>StatusBar.update()</u> or <u>StatusBar.refresh()</u> is called, so
                     fields like <b>elapsed</b> will need additional calls to appear dynamic.

                 User-defined fields:
                     Users can define fields in two ways, the <b>fields</b> parameter and by passing keyword  arguments
                     to <u>Manager.status_bar()</u> or <u>StatusBar.update()</u>

                     The  <b>fields</b>  parameter  can be used to pass a dictionary of additional user-defined fields.
                     The dictionary values can be updated after initialization to allow for dynamic fields.  Any
                     fields that share names with available fields are ignored.

                     If  fields  are  passed as keyword arguments to <u>Manager.status_bar()</u> or <u>StatusBar.update()</u>,
                     they take precedent over the <b>fields</b> parameter.

              <b>Instance</b> <b>Attributes</b>

                 <b>elapsed</b>
                        <b>float</b> - Time since start

                 <b>enabled</b>
                        <b>bool</b> - Current status

                 <b>manager</b>
                        <u>Manager</u> - Manager Instance

                 <b>position</b>
                        <b>int</b> - Current position

              <b>clear(flush=True)</b>

                     <b>Parameters</b>
                            <b>flush</b> (<u>bool</u>) -- Flush stream after clearing bar (Default:True)

                     Clear bar

              <b>close(clear=False)</b>
                     Do final refresh and remove from manager

                     If <b>leave</b> is True, the default, the effect is the same as <u>refresh()</u>.

              <b>property</b> <b>color</b>
                     Color property

                     Preferred to be a string or iterable of three integers for RGB.  Single  integer  supported
                     for backwards compatibility

              <b>property</b> <b>fill</b>
                     Fill character used in formatting

              <b>format(width=None,</b> <b>elapsed=None)</b>

                     <b>Parameters</b>

                            • <b>width</b> (<u>int</u>) -- Width in columns to make progress bar

                            • <b>elapsed</b> (<u>float</u>) -- Time since started. Automatically determined if <b>None</b>

                     <b>Returns</b>
                            Formatted status bar

                     <b>Return</b> <b>type</b>
                            <b>str</b>

                     Format status bar

              <b>property</b> <b>justify</b>
                     Maps to justify method determined by <b>justify</b> parameter

              <b>refresh(flush=True,</b> <b>elapsed=None)</b>

                     <b>Parameters</b>

                            • <b>flush</b> (<u>bool</u>) -- Flush stream after writing bar (Default:True)

                            • <b>elapsed</b> (<u>float</u>) -- Time since started. Automatically determined if <b>None</b>

                     Redraw bar

              <b>update(*objects,</b> <b>**fields)</b>

                     <b>Parameters</b>

                            • <b>objects</b> (<u>list</u>) -- Values for <u>Direct</u> <u>Status</u>

                            • <b>force</b> (<u>bool</u>) -- Force refresh even if <b>min_delta</b> has not been reached

                            • <b>fields</b> (<u>dict</u>) -- Fields for for <u>Formatted</u> <u>Status</u>

                     Update status and redraw

                     Status bar is only redrawn if <b>min_delta</b> seconds past since the last update

       <b>class</b> <b>enlighten.SubCounter(parent,</b> <b>color=None,</b> <b>count=0,</b> <b>all_fields=False)</b>
              A child counter for multicolored progress bars.

              This  class  tracks  a  portion  of  multicolored  progress  bar and should be initialized through
              <u>Counter.add_subcounter()</u>

              <b>Instance</b> <b>Attributes</b>

                 <b>count</b>  <b>int</b> - Current count

                 <b>parent</b> <u>Counter</u> - Parent counter

              <b>update(incr=1,</b> <b>force=False)</b>

                     <b>Parameters</b>

                            • <b>incr</b> (<u>int</u>) -- Amount to increment <b>count</b> (Default: 1)

                            • <b>force</b> (<u>bool</u>) -- Force refresh even if <b>min_delta</b> has not been reached

                     Increment progress bar and redraw

                     Both this counter and the parent are incremented.

                     Progress bar is only redrawn if min_delta seconds past since the last update on the parent.

              <b>update_from(source,</b> <b>incr=1,</b> <b>force=False)</b>

                     <b>Parameters</b>

                            • <b>source</b> (<u>SubCounter</u>) -- <u>SubCounter</u> or <u>Counter</u> to increment from

                            • <b>incr</b> (<u>int</u>) -- Amount to increment <b>count</b> (Default: 1)

                            • <b>force</b> (<u>bool</u>) -- Force refresh even if <b>min_delta</b> has not been reached

                     Move a value to this counter from another counter.

                     <b>source</b> must be the parent <u>Counter</u> instance or a <u>SubCounter</u> with the same parent

</pre><h4><b>FUNCTIONS</b></h4><pre>
       <b>enlighten.get_manager(stream=None,</b> <b>counter_class=Counter,</b> <b>**kwargs)</b>

              <b>Parameters</b>

                     • <b>stream</b> (file object) -- Output stream. If <b>None</b>, defaults to <b>sys.__stdout__</b>

                     • <b>counter_class</b> (class) -- Progress bar class (Default: <u>Counter</u>)

                     • <b>kwargs</b> (<u>Dict[str,</u> <u>Any]</u>) -- Any additional keyword arguments will passed  to  the  manager
                       class.

              <b>Returns</b>
                     Manager instance

              <b>Return</b> <b>type</b>
                     <u>Manager</u>

              Convenience function to get a manager instance

              If running inside a notebook, a <u>NotebookManager</u> instance is returned. otherwise a standard <u>Manager</u>
              instance is returned.

              If a a standard <u>Manager</u> instance is used and <b>stream</b> is not attached to a TTY, the <u>Manager</u> instance
              is disabled.

</pre><h4><b>CONSTANTS</b></h4><pre>
       <b>class</b> <b>enlighten.Justify</b>
              Enumerated type for justification options

              <b>CENTER</b> Justify center

              <b>LEFT</b>   Justify left

              <b>RIGHT</b>  Justify right

       Enlighten Progress Bar is a console progress bar library for Python.

       The  main  advantage  of  Enlighten  is it allows writing to stdout and stderr without any redirection or
       additional code. Just print or log as you normally would.

       Enlighten also includes experimental support for Jupyter Notebooks.

       The code for this animation can be found in <u>demo.py</u> in <u>examples</u>.

</pre><h4><b>AUTHOR</b></h4><pre>
       Avram Lubkin

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2023 - 2022, Avram Lubkin

1.11.2                                            Feb 26, 2023                                      <u><a href="../man1/ENLIGHTEN.1.html">ENLIGHTEN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>