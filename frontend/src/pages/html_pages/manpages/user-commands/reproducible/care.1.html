<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CARE - Comprehensive Archiver for Reproducible Execution</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/care">care_2.2.1-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CARE - Comprehensive Archiver for Reproducible Execution

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>care</b> [<u>option</u>] ... <u>command</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       CARE  monitors the execution of the specified command to create an <u>archive</u> that contains all the material
       required to <u>re-execute</u> it in the same context.  That way, the command will  be  reproducible  everywhere,
       even  on  Linux  systems  that are supposed to be not compatible with the original Linux system.  CARE is
       typically useful to get reliable bug reports, demonstrations, <u>artifact</u>  <u>evaluation</u>,  tutorials,  portable
       applications, minimal rootfs, file-system coverage, ...

       By  design,  CARE does not record events at all.  Instead, it archives environment variables and accessed
       file-system components -- before modification --  during  the  so-called  <u>initial</u>  execution.   Then,  to
       reproduce  this  execution,  the  <b>re-execute.sh</b> script embedded into the archive restores the environment
       variables and relaunches the command confined into the saved file-system.  That  way,  both  <u>initial</u>  and
       <u>reproduced</u>  executions should produce the same results as they use the same context, assuming they do not
       rely on external events -- like key strokes or network packets --  or  that  these  external  events  are
       replayed  manually  or  automatically,  using  <u>umockdev</u> for instance.  That means it is possible to alter
       explicitly the reproduced executions by changing content  of  the  saved  file-system,  or  by  replaying
       different external events.

   <b>Privacy</b>
       To  ensure  that  no  sensitive  file  can  possibly leak into the archive, CARE <u>conceals</u> recursively the
       content of <b>$HOME</b> and <b><a href="file:/tmp">/tmp</a></b>, that is, they appear empty  during  the  original  execution.   Although,  for
       consistency reasons, the content of <b>$PWD</b> is <u>revealed</u> even if it is nested into the two previous paths.

       As  a  consequence,  a program executed under CARE may behave unexpectedly because a required path is not
       accessible anymore.  In this case, such a path has to be  revealed  explicitly.   For  details,  see  the
       options <b>--concealed-path</b> and <b>--revealed-path</b>, and the file <b>concealed-accesses.txt</b> as well.

       It is advised to inspect the archived content before sharing it.

</pre><h4><b>OPTIONS</b></h4><pre>
       The  command-line  interface  is composed of two parts: first CARE's options, then the command to launch.
       This section describes the options supported by CARE,  that  is,  the  first  part  of  its  command-line
       interface.

       <b>-o</b> <u>path</u><b>,</b> <b>--output=</b><u>path</u>
              Archive in <u>path</u>, its suffix specifies the format.

              The suffix of <u>path</u> is used to select the archive format, it can be one of the following:
                                     ───────────────────────────────────────────────────
                                       suffix    comment
                                     ───────────────────────────────────────────────────
                                       /         don't    archive,   copy   into   the
                                                 specified directory instead
                                     ───────────────────────────────────────────────────
                                       .tar      most common archive format
                                     ───────────────────────────────────────────────────
                                       .cpio     most portable archive format, it  can
                                                 archive sockets too
                                     ───────────────────────────────────────────────────
                                       ?.gz      most  common  compression format, but
                                                 slow
                                     ───────────────────────────────────────────────────
                                       ?.lzo     fast compression format, but uncommon
                                     ───────────────────────────────────────────────────
                                       ?.bin     see <b>Self-extracting</b> <b>format</b> section
                                     ───────────────────────────────────────────────────
                                       ?.?.bin   see <b>Self-extracting</b> <b>format</b> section
                                     ───────────────────────────────────────────────────
                                       .bin      see <b>Self-extracting</b> <b>format</b> section
                                     ───────────────────────────────────────────────────
                                       .raw      recommended archive format, use  <u>care</u>
                                                 <u>-x</u> to extract
                                     ┌─────────┬───────────────────────────────────────┐
                                     │         │                                       │
--
</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       If an internal error occurs, <b>care</b> returns a non-zero exit status, otherwise it returns the exit status of
       the  last terminated program.  When an error has occurred, the only way to know if it comes from the last
       terminated program or from <b>care</b> itself is to have a look at the error message.

</pre><h4><b>FILES</b></h4><pre>
       The output archive contains the following files:

       <b>re-execute.sh</b>
              start the re-execution of the initial command as originally specified.  It  is  also  possible  to
              specify  an  alternate  command.   For  example,  assuming  <b>gcc</b> was archived, it can be re-invoked
              differently:
                 $ ./re-execute.sh gcc --version gcc (Ubuntu/Linaro 4.5.2-8ubuntu4) 4.5.2

                 $ echo 'int main(void) { return puts("OK"); }'  &gt;  rootfs/foo.c  $  ./re-execute.sh  gcc  -Wall
                 /foo.c  $  foo.c:  In  function  "main": $ foo.c:1:1: warning: implicit declaration of function
                 "puts"

       <b>rootfs/</b>
              directory where all the files used during the original  execution  were  archived,  they  will  be
              required for the reproduced execution.

       <b>proot</b>  virtualization  tool invoked by re-execute.sh to confine the reproduced execution into the rootfs.
              It also emulates the missing kernel features if needed.

       <b>concealed-accesses.txt</b>
              list of accessed paths that were concealed during the original execution.  Its main purpose is  to
              know  what  are  the  paths  that  should  be  revealed if the the original execution didn't go as
              expected.  It is absolutely useless for the reproduced execution.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       It's not possible to use GDB, strace, or any programs based on <u>ptrace</u> under CARE  yet.   This  latter  is
       also based on this syscall, but the Linux kernel allows only one <u>ptracer</u> per process.  This will be fixed
       in a future version of CARE thanks to a ptrace emulator.

</pre><h4><b>EXAMPLE</b></h4><pre>
       In  this  example,  Alice  wants to report to Bob that the compilation of PRoot v2.4 raises an unexpected
       warning:

          alice$ make -C PRoot-2.4/src/

          make: Entering directory `PRoot-2.4/src'
          [...]
          CC    path/proc.o
          ./path/proc.c: In function 'readlink_proc':
          ./path/proc.c:132:3: warning: ignoring return value of 'strtol'
          [...]

       Technically, Alice uses Ubuntu 11.04 for x86, whereas Bob uses Slackware 13.37 on x86_64.   Both  distros
       are supposed to be shipped with GCC 4.5.2, however Bob is not able to reproduce this issue on his system:

          bob$ make -C PRoot-2.4/src/

          make: Entering directory `PRoot-2.4/src'
          [...]
          CC    path/proc.o
          [...]

       Since they don't have much time to investigate this issue by iterating between each other, they decide to
       use CARE.  First, Alice prepends <b>care</b> to her command:

          alice$ care make -C PRoot-2.4/src/

          care info: concealed path: $HOME
          care info: concealed path: <a href="file:/tmp">/tmp</a>
          care info: revealed path: $PWD
          care info: ----------------------------------------------------------------------
          make: Entering directory `PRoot-2.4/src'
          [...]
          CC    path/proc.o
          ./path/proc.c: In function 'readlink_proc':
          ./path/proc.c:132:3: warning: ignoring return value of 'strtol'
          [...]
          care info: ----------------------------------------------------------------------
          care info: Hints:
          care info:   - search for "conceal" in `care -h` if the execution didn't go as expected.
          care info:   - use `./care-130213072430.bin` to extract the output archive.

       Then  she  sends the <b>care-130213072430.bin</b> file to Bob.  Now, he should be able to reproduce her issue on
       his system:

          bob$ ./care-130213072430.bin
          [...]
          bob$ ./care-130213072430/re-execute.sh

          make: Entering directory `PRoot-2.4/src'
          [...]
          CC    path/proc.o
          ./path/proc.c: In function 'readlink_proc':
          ./path/proc.c:132:3: warning: ignoring return value of 'strtol'
          [...]

       So far so good!  This compiler warning doesn't make sense to Bob since <b>strtol</b> is used there  to  check  a
       string  format;  the  return  value is useless, only the <b>errno</b> value matters.  Further investigations are
       required, so Bob re-execute Alice's GCC differently to get more details:

          bob$ ./care-130213072430/re-execute.sh gcc --version

          gcc (Ubuntu/Linaro 4.5.2-8ubuntu4) 4.5.2
          Copyright (C) 2010 Free Software Foundation, Inc.
          This is free software; see the source for copying conditions.  There is NO
          warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

       The same invocation on his system returns something slightly different:

          bob$ gcc --version

          gcc (GCC) 4.5.2
          Copyright (C) 2010 Free Software Foundation, Inc.
          This is free software; see the source for copying conditions.  There is NO
          warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

       This confirms that both GCC versions are the same, however Alice's one seems to  have  been  modified  by
       Ubuntu.   Although,  according  to  the web page related to this Ubuntu package [1], no changes regarding
       <b>strtol</b> were made.  So Bob decides to search into the files coming  from  Alice's  system,  that  is,  the
       <b>rootfs</b> directory in the archive:

          bob$ grep -wIrl strtol ./care-130213072430/rootfs

          care-130213072430/rootfs/usr/include/inttypes.h
          care-130213072430/rootfs/usr/include/stdlib.h
          [...]

       Here,  the  file  <b>usr/include/stdlib.h</b>  contains  a  declaration  of <b>strtol</b> with the "warn unused result"
       attribute.  On Ubuntu, this file belongs to the EGLIBC package, and its related web page [2]  shows  that
       this  attribute was actually wrongly introduced by the official EGLIBC developers.  Ultimately Bob should
       notify them in this regard.

       Thanks to CARE, Bob was able to reproduce the issue reported by Alice without effort.  For investigations
       purpose, he was able to re-execute programs differently and to search into the relevant files.

       [1]  <u>https://launchpad.net/ubuntu/oneiric/+source/gcc-4.5/4.5.2-8ubuntu4</u>

       [2]  <u>https://launchpad.net/ubuntu/+source/eglibc/2.13-0ubuntu13.2</u>

</pre><h4><b>SELF-EXTRACTING</b> <b>FORMAT</b></h4><pre>
       The self-extracting format used by CARE starts with an extracting program, followed by a regular archive,
       and it ends with a special footer.  This latter contains the signature  "I_LOVE_PIZZA"  followed  by  the
       size of the embedded archive:

          +------------------------+
          |   extracting program   |
          +------------------------+
          |                        |
          |    embedded archive    |
          |                        |
          +------------------------+
          | uint8_t  signature[13] |
          | uint64_t archive_size  |  # big-endian
          +------------------------+

       The  command  <b>care</b>  <b>-x</b> can be used against a self-extracting archive, even if they were not build for the
       same architecture.  For instance, a self-extracting archive produced for ARM can be extracted with a <b>care</b>
       program built for x86_64, and vice versa.  It is also possible to  use  external  tools  to  extract  the
       embedded archive, for example:

          $ care -o foo.tar.gz.bin <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?echo">/usr/bin/echo</a> OK
          [...]
          OK
          [...]

          $ hexdump -C foo.tar.gz.bin | tail -3
          0015b5b0  00 b0 2e 00 49 5f 4c 4f  56 45 5f 50 49 5a 5a 41  |....I_LOVE_PIZZA|
          0015b5c0  00 00 00 00 00 00 12 b4  13                       |.........|
          0015b5c9

          $ file_size=`stat -c %s foo.tar.gz.bin`
          $ archive_size=$((16#12b413))
          $ footer_size=21
          $ skip=$(($file_size - $archive_size - $footer_size))

          $ dd if=foo.tar.gz.bin of=foo.tar.gz bs=1 skip=$skip count=$archive_size
          1225747+0 records in
          1225747+0 records out
          1225747 bytes (1.2 MB) copied, 2.99546 s, 409 kB/s

          $ file foo.tar.gz
          foo.tar.gz: gzip compressed data, from Unix

          $ tar -tzf foo.tar.gz
          foo/rootfs/usr/
          [...]
          foo/re-execute.sh
          foo/README.txt
          foo/proot

</pre><h4><b>DOWNLOADS</b></h4><pre>
       CARE   is   heavily   based  on  <u>PRoot</u>,  that's  why  they  are  both  hosted  in  the  same  repository:
       <u><a href="http://github.proot.me">http://github.proot.me</a></u>.  Since CARE is supposed to work on any Linux systems, it is  recommended  to  use
       following highly compatible static binaries:

       • for x86_64: <u><a href="http://static.reproducible.io/care-x86_64">http://static.reproducible.io/care-x86_64</a></u>

       • for x86: <u><a href="http://static.reproducible.io/care-x86">http://static.reproducible.io/care-x86</a></u>

       • for ARM: <u><a href="http://static.reproducible.io/care-arm">http://static.reproducible.io/care-arm</a></u>

       • other architectures: on demand.

</pre><h4><b>COLOPHON</b></h4><pre>
       Visit  <u><a href="http://reproducible.io">http://reproducible.io</a></u>  for  help,  bug  reports,  suggestions,  patches,  ...  Copyright (C) 2014
       STMicroelectronics, licensed under GPL v2 or later.

            _____ ____ _____ ____
           /   __/ __ |  __ \  __|
          /   /_/     |     /  __|
          \_____|__|__|__|__\____|

2.2.1                                              2014-11-12                                            <u><a href="../man1/CARE.1.html">CARE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>