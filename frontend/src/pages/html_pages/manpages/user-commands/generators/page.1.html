<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>page - Parser Generator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/tcllib">tcllib_2.0+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       page - Parser Generator

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>page</b> ?<u>options</u>...? ?<u>input</u> ?<u>output</u>??

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  application  described  by this document, <b>page</b>, is actually not just a parser generator, as the name
       implies, but a generic tool for the execution of arbitrary transformations on texts.

       Its genericity comes through the use of <u>plugins</u> for reading, transforming,  and  writing  data,  and  the
       predefined set of plugins provided by Tcllib is for the generation of memoizing recursive descent parsers
       (aka <u>packrat</u> <u>parsers</u>) from grammar specifications (<u>Parsing</u> <u>Expression</u> <u>Grammars</u>).

       <b>page</b>  is  written  on  top of the package <b>page::pluginmgr</b>, wrapping its functionality into a command line
       based application. All the  other  <b>page::*</b>  packages  are  plugin  and/or  supporting  packages  for  the
       generation   of   parsers.   The   parsers   themselves   are   based   on   the  packages  <b>grammar::peg</b>,
       <b>grammar::peg::interp</b>, and <b>grammar::mengine</b>.

   <b>COMMAND</b> <b>LINE</b>
       <b>page</b> ?<u>options</u>...? ?<u>input</u> ?<u>output</u>??
              This is general form for calling <b>page</b>. The application will read the contents of the  file  <u>input</u>,
              process  them  under  the  control of the specified <u>options</u>, and then write the result to the file
              <u>output</u>.

              If <u>input</u> is the string <b>-</b> the data  to  process  will  be  read  from  <b>stdin</b>  instead  of  a  file.
              Analogously  the  result  will be written to <b>stdout</b> instead of a file if <u>output</u> is the string <b>-</b>. A
              missing output or input specification causes the application to assume <b>-</b>.

              The detailed specifications of the recognized <u>options</u> are provided in section <b>OPTIONS</b>.

              path <u>input</u> (in)
                     This argument specifies the path to the file to be processed by the application, or <b>-</b>.  The
                     last  value  causes the application to read the text from <b>stdin</b>. Otherwise it has to exist,
                     and be readable. If the argument is missing <b>-</b> is assumed.

              path <u>output</u> (in)
                     This argument specifies where to write the generated text. It can be the path to a file, or
                     <b>-</b>. The last value causes the application to write the generated documented to <b>stdout</b>.

                     If the file <u>output</u> does not exist then [file dirname $output] has to exist and  must  be  a
                     writable directory, as the application will create the fileto write to.

                     If the argument is missing <b>-</b> is assumed.

   <b>OPERATION</b>
       ... reading ... transforming ... writing - plugins - pipeline ...

   <b>OPTIONS</b>
       This  section  describes  all  the  options  available to the user of the application. Options are always
       processed in order. I.e. of both <b>--help</b> and <b>--version</b> are specified  the  option  encountered  first  has
       precedence.

       Unknown  options specified before any of the options <b>-rd</b>, <b>-wr</b>, or <b>-tr</b> will cause processing to abort with
       an error. Unknown options coming in between these options, or after the  last  of  them  are  assumed  to
       always  take  a  single  argument and are associated with the last plugin option coming before them. They
       will be checked after all the relevant plugins, and thus the options they  understand,  are  known.  I.e.
       such  unknown  options  cause  error  if  and only if the plugin option they are associated with does not
       understand them, and was not superceded by a plugin option coming after.

       Default options are used if and only if the command line did not contain any options at  all.  They  will
       set the application up as a PEG-based parser generator. The exact list of options is

              -c peg

       And now the recognized options and their arguments, if they have any:

       <b>--help</b>

       <b>-h</b>

       <b>-?</b>     When  one  of  these options is found on the command line all arguments coming before or after are
              ignored. The application will print a short description of the recognized options and exit.

       <b>--version</b>

       <b>-V</b>     When one of these options is found on the command line all arguments coming before  or  after  are
              ignored. The application will print its own revision and exit.

       <b>-P</b>     This option signals the application to activate visual feedback while reading the input.

       <b>-T</b>     This  option  signals  the  application to collect statistics while reading the input and to print
              them after reading has completed, before processing started.

       <b>-D</b>     This option signals the application to activate logging in the Safe base,  for  the  debugging  of
              problems with plugins.

       <b>-r</b> parser

       <b>-rd</b> parser

       <b>--reader</b> parser
              These  options specify the plugin the application has to use for reading the <u>input</u>. If the options
              are used multiple times the last one will be used.

       <b>-w</b> generator

       <b>-wr</b> generator

       <b>--writer</b> generator
              These options specify the plugin the application has to use for generating and writing  the  final
              <u>output</u>. If the options are used multiple times the last one will be used.

       <b>-t</b> process

       <b>-tr</b> process

       <b>--transform</b> process
              These  options  specify  a plugin to run on the input. In contrast to readers and writers each use
              will <u>not</u> supersede previous uses, but add each chosen plugin to a list of transformations,  either
              at  the front, or the end, per the last seen use of either option <b>-p</b> or <b>-a</b>. The initial default is
              to append the new transformations.

       <b>-a</b>

       <b>--append</b>
              These options signal the application that all following transformations should be added at the end
              of the list of transformations.

       <b>-p</b>

       <b>--prepend</b>
              These options signal the application that all following transformations should  be  added  at  the
              beginning of the list of transformations.

       <b>--reset</b>
              This  option  signals  the  application to clear the list of transformations. This is necessary to
              wipe out the default transformations used.

       <b>-c</b> file

       <b>--configuration</b> file
              This option causes the application to load a configuration file and/or plugin. This  is  a  plugin
              which  in essence provides a pre-defined set of commandline options. They are processed exactly as
              if they have been specified in place of the option and its  arguments.  This  means  that  unknown
              options found at the beginning of the configuration file are associated with the last plugin, even
              if  that  plugin  was  specified before the configuration file itself. Conversely, unknown options
              coming after the configuration file can be associated with a plugin specified in the file.

              If the argument is a file which cannot be loaded as a plugin the application will assume that  its
              contents  are  a  list  of  options  and  their arguments, separated by space, tabs, and newlines.
              Options and argumentes containing spaces can be quoted via double-quotes (") and quotes  (').  The
              quote  character  can  be specified within in a quoted string by doubling it. Newlines in a quoted
              string are accepted as is.

   <b>PLUGINS</b>
       <b>page</b> makes use of four different  types  of  plugins,  namely:  readers,  writers,  transformations,  and
       configurations.  Here  we  provide only a basic introduction on how to use them from <b>page</b>. The exact APIs
       provided to and expected from the plugins can be found in  the  documentation  for  <b>page::pluginmgr</b>,  for
       those who wish to write their own plugins.

       Plugins  are specified as arguments to the options <b>-r</b>, <b>-w</b>, <b>-t</b>, <b>-c</b>, and their equivalent longer forms. See
       the section <b>OPTIONS</b> for reference.

       Each such argument will be first treated as the name of a file and this file is loaded as the plugin.  If
       however  there is no file with that name, then it will be translated into the name of a package, and this
       package is then loaded. For each type of plugins the package management searches  not  only  the  regular
       paths,  but  a  set application- and type-specific paths as well. Please see the section <b>PLUGIN</b> <b>LOCATIONS</b>
       for a listing of all paths and their sources.

       <b>-c</b> <u>name</u>
              Configurations. The name of the package for the plugin <u>name</u> is "page::config::<u>name</u>".

              We have one predefined plugin:

              <u>peg</u>    It sets the application up as a parser generator accepting parsing expression grammars  and
                     writing a packrat parser in Tcl. The actual arguments it specifies are:

                       --reset
                       --append
                       --reader    peg
                       --transform reach
                       --transform use
                       --writer    me

       <b>-r</b> <u>name</u>
              Readers. The name of the package for the plugin <u>name</u> is "page::reader::<u>name</u>".

              We have five predefined plugins:

              <u>peg</u>    Interprets  the  input  as  a  parsing  expression  grammar  (<u>PEG</u>)  and  generates  a  tree
                     representation for it. Both the syntax of PEGs and the structure of the tree representation
                     are explained in their own manpages.

              <u>hb</u>     Interprets the input as Tcl code as generated by the writer plugin  <u>hb</u>  and  generates  its
                     tree representation.

              <u>ser</u>    Interprets  the input as the serialization of a PEG, as generated by the writer plugin <u>ser</u>,
                     using the package <b>grammar::peg</b>.

              <u>lemon</u>  Interprets the input as a grammar specification  as  understood  by  Richard  Hipp's  <u>LEMON</u>
                     parser  generator and generates a tree representation for it. Both the input syntax and the
                     structure of the tree representation are explained in their own manpages.

              <u>treeser</u>
                     Interprets the input as the serialization of a <b>struct::tree</b>. It is validated as  such,  but
                     nothing else. It is <u>not</u> assumed to be the tree representation of a grammar.

       <b>-w</b> <u>name</u>
              Writers. The name of the package for the plugin <u>name</u> is "page::writer::<u>name</u>".

              We have eight predefined plugins:

              <u>identity</u>
                     Simply  writes  the  incoming  data  as it is, without making any changes. This is good for
                     inspecting the raw result of a reader or transformation.

              <u>null</u>   Generates nothing, and ignores the incoming data structure.

              <u>tree</u>   Assumes that the incoming data structure  is  a  <b>struct::tree</b>  and  generates  an  indented
                     textual  representation  of  all  nodes,  their parental relationships, and their attribute
                     information.

              <u>peg</u>    Assumes that the incoming data structure is a tree representation of a <u>PEG</u> or  other  other
                     grammar and writes it out as a PEG. The result is nicely formatted and partially simplified
                     (strings  as sequences of characters). A pretty printer in essence, but can also be used to
                     obtain a canonical representation of the input grammar.

              <u>tpc</u>    Assumes that the incoming data structure is a tree representation of a <u>PEG</u> or  other  other
                     grammar  and  writes  out  Tcl  code defining a package which defines a <b>grammar::peg</b> object
                     containing the grammar when it is loaded into an interpreter.

              <u>hb</u>     This is like the writer plugin <u>tpc</u>, but it writes only the  statements  which  define  stat
                     expression and grammar rules. The code making the result a package is left out.

              <u>ser</u>    Assumes  that  the incoming data structure is a tree representation of a <u>PEG</u> or other other
                     grammar,  transforms  it  internally  into  a  <b>grammar::peg</b>  object  and  writes  out   its
                     serialization.

              <u>me</u>     Assumes  that  the incoming data structure is a tree representation of a <u>PEG</u> or other other
                     grammar and writes out Tcl code defining a package which implements a  memoizing  recursive
                     descent parser based on the match engine (ME) provided by the package <b>grammar::mengine</b>.

       <b>-t</b> <u>name</u>
              Transformers. The name of the package for the plugin <u>name</u> is "page::transform::<u>name</u>".

              We have two predefined plugins:

              <u>reach</u>  Assumes  that  the incoming data structure is a tree representation of a <u>PEG</u> or other other
                     grammar. It determines which nonterminal  symbols  and  rules  are  reachable  from  start-
                     symbol/expression. All nonterminal symbols which were not reached are removed.

              <u>use</u>    Assumes  that  the incoming data structure is a tree representation of a <u>PEG</u> or other other
                     grammar. It determines which nonterminal symbols and rules are able to  generate  a  <u>finite</u>
                     sequences  of  terminal  symbols (in the sense for a Context Free Grammar). All nonterminal
                     symbols which were not deemed useful in this sense are removed.

   <b>PLUGIN</b> <b>LOCATIONS</b>
       The application-specific paths searched by <b>page</b> either are, or come from:

       [1]    The directory            "<u><a href="file:~/.page/plugin">~/.page/plugin</a></u>"

       [2]    The environment variable <u>PAGE_PLUGINS</u>

       [3]    The registry entry       <u>HKEY_LOCAL_MACHINE\SOFTWARE\PAGE\PLUGINS</u>

       [4]    The registry entry       <u>HKEY_CURRENT_USER\SOFTWARE\PAGE\PLUGINS</u>

       The type-specific paths searched by <b>page</b> either are, or come from:

       [1]    The directory            "<u><a href="file:~/.page/plugin/">~/.page/plugin/</a>&lt;TYPE&gt;</u>"

       [2]    The environment variable <u>PAGE_&lt;TYPE&gt;_PLUGINS</u>

       [3]    The registry entry       <u>HKEY_LOCAL_MACHINE\SOFTWARE\PAGE\&lt;TYPE&gt;\PLUGINS</u>

       [4]    The registry entry       <u>HKEY_CURRENT_USER\SOFTWARE\PAGE\&lt;TYPE&gt;\PLUGINS</u>

       Where the placeholder <u>&lt;TYPE&gt;</u> is always one of the values below, properly capitalized.

       [1]    reader

       [2]    writer

       [3]    transform

       [4]    config

       The registry entries are specific to the Windows(tm) platform, all other platforms will ignore them.

       The contents of both environment variables and registry entries are interpreted as a list of paths,  with
       the elements separated by either colon (Unix), or semicolon (Windows).

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>page</u> of the <u>Tcllib</u> <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       page::pluginmgr

</pre><h4><b>KEYWORDS</b></h4><pre>
       parser generator, text processing

</pre><h4><b>CATEGORY</b></h4><pre>
       Page Parser Generator

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.0                                               <u><a href="../man1/page.1.html">page</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>