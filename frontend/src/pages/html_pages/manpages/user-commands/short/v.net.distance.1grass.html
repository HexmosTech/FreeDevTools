<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v.net.distance  - Computes shortest distance via the network between the given sets of features.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>v.net.distance</b>  - Computes shortest distance via the network between the given sets of features.
       Finds the shortest paths from each ’from’ point to the nearest ’to’ feature and various information about
       this relation are uploaded to the attribute table.

</pre><h4><b>KEYWORDS</b></h4><pre>
       vector, network, shortest path

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>v.net.distance</b>
       <b>v.net.distance</b> <b>--help</b>
       <b>v.net.distance</b>   [-<b>gl</b>]   <b>input</b>=<u>name</u>   <b>output</b>=<u>name</u>    [<b>arc_layer</b>=<u>string</u>]    [<b>arc_type</b>=<u>string</u>[,<u>string</u>,...]]
       [<b>node_layer</b>=<u>string</u>]         [<b>from_layer</b>=<u>string</u>]         [<b>from_cats</b>=<u>range</u>]          [<b>from_where</b>=<u>sql_query</u>]
       [<b>to_layer</b>=<u>string</u>]        [<b>to_type</b>=<u>string</u>[,<u>string</u>,...]]        [<b>to_cats</b>=<u>range</u>]        [<b>to_where</b>=<u>sql_query</u>]
       [<b>arc_column</b>=<u>name</u>]      [<b>arc_backward_column</b>=<u>name</u>]      [<b>node_column</b>=<u>name</u>]      [--<b>overwrite</b>]     [--<b>help</b>]
       [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-g</b>
           Use geodesic calculation for longitude-latitude projects

       <b>-l</b>
           Write each output path as one line, not as original input segments.

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>input</b>=<u>name</u> <b>[required]</b>
           Name of input vector map
           Or data source for direct OGR access

       <b>output</b>=<u>name</u> <b>[required]</b>
           Name for output vector map

       <b>arc_layer</b>=<u>string</u>
           Arc layer
           Vector  features  can have category values in different layers. This number determines which layer to
           use. When used with direct OGR access this is the layer name.
           Default: <u>1</u>

       <b>arc_type</b>=<u>string[,string</u>,...]
           Arc type
           Input feature type
           Options: <u>line,</u> <u>boundary</u>
           Default: <u>line,boundary</u>

       <b>node_layer</b>=<u>string</u>
           Node layer
           Vector features can have category values in different layers. This number determines which  layer  to
           use. When used with direct OGR access this is the layer name.
           Default: <u>2</u>

       <b>from_layer</b>=<u>string</u>
           From layer number or name
           Vector  features  can have category values in different layers. This number determines which layer to
           use. When used with direct OGR access this is the layer name.
           Default: <u>1</u>

       <b>from_cats</b>=<u>range</u>
           From category values
           Example: 1,3,7-9,13

       <b>from_where</b>=<u>sql_query</u>
           From WHERE conditions of SQL statement without ’where’ keyword
           Example: income &lt; 1000 and population &gt;= 10000

       <b>to_layer</b>=<u>string</u>
           Layer number or name
           To layer number or name
           Default: <u>1</u>

       <b>to_type</b>=<u>string[,string</u>,...]
           To feature type
           Options: <u>point,</u> <u>line,</u> <u>boundary</u>
           Default: <u>point</u>

       <b>to_cats</b>=<u>range</u>
           To category values
           Example: 1,3,7-9,13

       <b>to_where</b>=<u>sql_query</u>
           To WHERE conditions of SQL statement without ’where’ keyword
           Example: income &lt; 1000 and population &gt;= 10000

       <b>arc_column</b>=<u>name</u>
           Arc forward/both direction(s) cost column (number)

       <b>arc_backward_column</b>=<u>name</u>
           Arc backward direction cost column (number)

       <b>node_column</b>=<u>name</u>
           Node cost column (number)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>v.net.distance</u> finds the nearest element in set <u>to</u> for every point in set <u>from</u>.

</pre><h4><b>NOTES</b></h4><pre>
       These two sets are given by the respective <b>layer</b>, <b>where</b> and <b>cats</b> parameters. The type of <u>to</u>  features  is
       specified  by <b>to_type</b> parameter. All <u>from</u> features are <u>points</u>. A table is linked to <b>output</b> map containing
       various information about the relation. More specifically, the table has three  columns:  <u>cat</u>,  <u>tcat</u>  and
       <u>dist</u>  storing  category of each <u>from</u> feature, category of the nearest <u>to</u> feature and the distance between
       them respectively.

       Furthermore, the <b>output</b> map contains the shortest path between each <u>cat</u>, <u>tcat</u> pair. Each path consists of
       several lines. If a line is on the shortest path from a point then the category of this point is assigned
       to the line. Note that every line may contain more than one category value since a single line may be  on
       the  shortest  path  for  more than one <u>from</u> feature. And so the shortest paths can be easily obtained by
       querying lines with corresponding category number. Alternatively, unique paths can be created with the <u>-l</u>
       flag where each path will be a separate single line in the output.

       The costs of arcs in forward and backward direction are specified by <b>arc_column</b>  and  <b>arc_backward_column</b>
       columns respectively.  If <b>arc_backward_column</b> is not given, the same cost is used in both directions.

       <u>v.net.distance</u>  will  not  work  if you are trying to find the nearest neighbors within a group of nodes,
       i.e. where <u>to</u> and <u>from</u> are the same set of nodes, as the closest node will be the  node  itself  and  the
       result  will  be  zero-length  paths. In order to find nearest neighbors within a group of nodes, you can
       either loop through each node as <u>to</u> and all other nodes as <u>from</u> or create a complete distance matrix with
       v.net.allpairs and select the lowest non-zero distance for each node.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Shortest</b> <b>path</b> <b>and</b> <b>distance</b> <b>between</b> <b>school</b> <b>and</b> <b>nearest</b> <b>hospital</b>
       Find shortest path and distance from every school to the nearest hospital and show all paths.

       Streets are grey lines, schools are green circles, hospitals are red crosses,  shortest  paths  are  blue
       lines:

       # connect schools to streets as layer 2
       v.net input=streets_wake points=schools_wake output=streets_net1 \
             operation=connect thresh=400 arc_layer=1 node_layer=2
       # connect hospitals to streets as layer 3
       v.net input=streets_net1 points=hospitals output=streets_net2 \
             operation=connect thresh=400 arc_layer=1 node_layer=3
       # inspect the result
       v.category in=streets_net2 op=report
       # shortest paths from schools (points in layer 2) to nearest hospitals (points in layer 3)
       v.net.distance in=streets_net2 out=schools_to_hospitals flayer=2 to_layer=3
       # visualization
       g.region vector=streets_wake
       d.mon wx0
       d.vect streets_wake color=220:220:220
       d.vect schools_wake color=green size=10
       d.vect map=hospitals icon=basic/cross3 size=15 color=black fcolor=red
       d.vect schools_to_hospitals

   <b>Distance</b> <b>between</b> <b>point</b> <b>source</b> <b>of</b> <b>pollution</b> <b>and</b> <b>sample</b> <b>points</b> <b>along</b> <b>streams</b>
       Example with streams of the NC sample data set.

       # add coordinates of pollution point source of pollution as vector
       pollution.txt:
       634731.563206905|216390.501834892
       v.in.ascii input=pollution.txt output=pollution
       # add table to vector
       v.db.addtable map=pollution
       # add coordinates of sample points as vector
       samples.txt:
       634813.332814905|216333.590706166
       634893.462007813|216273.763350851
       634918.660011082|216254.949609689
       v.in.ascii input=samples.txt output=samples
       # add table to vector
       v.db.addtable map=samples
       # connect samples and pollution to streams
       v.net -c input=streams points=samples output=streams_samples \
                operation=connect node_layer=3 threshold=10 \
       v.net -c input=streams_samples points=pollution
                output=streams_samples_pollution operation=connect \
                node_layer=4 threshold=10
       # check vector layers
       v.category input=streams_samples_pollution option=report
       Layer/table: 1/streams_samples_pollution
       type       count        min        max
       point          0          0          0
       line        8562      40102     101351
       boundary       0          0          0
       centroid       0          0          0
       area           0          0          0
       face           0          0          0
       kernel         0          0          0
       all         8562      40102     101351
       Layer: 3
       type       count        min        max
       point          3          1          3
       line           0          0          0
       boundary       0          0          0
       centroid       0          0          0
       area           0          0          0
       face           0          0          0
       kernel         0          0          0
       all            3          1          3
       Layer: 4
       type       count        min        max
       point          1          1          1
       line           0          0          0
       boundary       0          0          0
       centroid       0          0          0
       area           0          0          0
       face           0          0          0
       kernel         0          0          0
       all            1          1          1
       # calculate distance between sample points and pollution point source
       v.net.distance input=streams_samples_pollution \
             output=distance_samples_to_pollution from_layer=3 to_layer=4
       # check results
       v.report map=distance_samples_to_pollution@vnettest option=length
       cat|tcat|dist|length
       1|1|100.0|100.0
       2|1|200.0|200.0
       3|1|231.446|231.446

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>v.net.path,</u> <u>v.net.allpairs,</u> <u>v.net.distance,</u> <u>v.net.alloc</u>

</pre><h4><b>AUTHORS</b></h4><pre>
       Daniel Bundala, Google Summer of Code 2009, Student
       Wolf Bergenheim, Mentor
       Markus Metz

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: v.net.distance source code (history)

       Accessed: Friday Apr 04 01:20:26 2025

       Main index | Vector index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                               <u><a href="../man1grass/v.net.distance.1grass.html">v.net.distance</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>