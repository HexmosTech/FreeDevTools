<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pycocci - Coccinelle wrapper for SmPL patch development</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/coccinelle">coccinelle_1.3.0.deb-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pycocci - Coccinelle wrapper for SmPL patch development

       <b>pycocci</b>  <b>[-h</b>  <b>|</b>  <b>--help]</b>  <b>[-p</b>  <b>|</b>  <b>--profile-cocci]</b>  <b>[-j</b>  <b>|</b>  <b>--jobs</b>  <b>&lt;job-digit&gt;</b>  <b>]</b> <b>[-v</b> <b>|</b> <b>--verbose]</b> <b>[-s</b> <b>|</b>
       <b>--show-proof]</b> <u>&lt;SmPL-patch.cocci&gt;</u> <u>&lt;target&gt;</u> <b>]</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>pycocci</b> is wrapper around <b>spatch</b>, it enables a set of default arguments and also uses a bit of heuristics
       to infers which arguments you likely want enabled. It takes two  arguments,  the  &lt;SmPL-patch.cocci&gt;  and
       your  &lt;target&gt;  which  can  either  be a directory or file. The actual command run is always displayed on
       standard output.

       Coccinelle <b>spatch</b> is a very rich tool, it provides a large set of features for use  with  the  Coccinelle
       engine.  Typical day to day SmPL patch development may only require a base set of features though, we can
       also infer a set of features depending on your target. <b>pycocci</b> enables a set of  flags  which  over  time
       have  been  determined  to  be  required  for day to day Linux kernel development, for instance through a
       cronjob, it also uses a set of heuristics to infer a set of arguments to use depending on your release of
       Coccinelle. <b>pycocci</b> also checks to see which version of Coccinelle you have installed and looks to enable
       arguments depending on what version of Coccinelle you have installed.

       <b>pycocci</b> can also be used to help write and verify SmPL patches when replacing  a  regular  patch  series.
       <b>pycocci</b> checks the version of <b>spatch</b> installed and based on this enables a set of features. This man page
       will  document  what options it always enables by default, why it has done this and it will also document
       the heuristics used and logic behind them.

</pre><h4><b>DEFAULT</b> <b>ARGUMENTS</b></h4><pre>
       By default <b>pycocci</b> will always enable when running <b>spatch</b>:

       <b>--in-place</b>

       <b>--recursive-includes</b>

       <b>--relax-include-path</b>

       <b>--timeout</b> <b>120</b>

       <b>--dir</b> <b>&lt;target&gt;</b>

       The <b>--in-place</b> option is enabled by default as most development these days  happens  on  version  control
       systems and built-in version control systems can typically display differences better.

       <b>--relax-include-path</b> and <b>--relax-include-path</b> are enabled by default given that at least for Linux kernel
       development  some  C files tend to include headers in paths only specified by a target's Makefile through
       utilities such as subdir-ccflags or ccflags-y making it difficult to ensure all required header files are
       read by Coccinelle. We are aggressive with headers search and inclusion.

       A default timeout of 120 seconds is used by default. Not using a timeout is typically not  a  good  idea.
       The  value  of  120  is used by default and is considered significantly large enough to support most SmPL
       patches.

       We make use of <b>--dir</b> to enable use of a target directory and its subdirectories recursively.

</pre><h4><b>MULTITHREAD</b> <b>ARGUMENT</b> <b>HEURISTICS</b></h4><pre>
       Coccinelle <b>spatch</b> prior to release 1.0.0 provided support for multithreading but required  the  developer
       to  spawn  each  thread  on  their  own,  and  provide an index reference number identifying each thread.
       Coccinelle would divide the amount of work required to be done and based on the index grant the thread  a
       specific  set of work.  Some shell scripts could be used to help split the work out for you.  <b>pycocci</b> was
       originally written to supersede these scripts and use Python's multithreaded support, while also enabling
       some sensible arguments by default.

       If you have a version of <b>spatch</b> older than 1.0.2 <b>pycocci</b> will  provide  its  own  built-in  multithreaded
       batched  solution,  the <b>spatch</b> --jobs argument is enabled on <b>spatch</b> &gt;= 1.0.2. The <b>spatch</b> --jobs arguments
       takes advantage of Coccinelle's built-in paramap support, and performance-wise yields better results than
       <b>pycocci</b>'s multithreaded solution. The number of threads used will always default to the number of  number
       of  CPUs  on  your  system,  this  is taken from what Python multiprocessing.cpu_count() returns. You can
       override the number of threads <b>pycocci</b> will use with the --jobs argument.

</pre><h4><b>INDEXING</b> <b>ARGUMENT</b> <b>HEURISTICS</b></h4><pre>
       Coccinelle <b>pycocci</b> supports using a series of indexing alternatives:

       <b>--use-glimpse</b>

       <b>--use-gitgrep</b>

       <b>--use-coccigrep</b>

       Coccinelle puts the onus of which indexing feature to enable  on  the  developer.   <b>pycocci</b>  will  figure
       things  out  for you and make sure that only supported options are used in specific supported releases of
       coccinelle. So for instance, although --use-gitgrep has been available on 1.0.1 <b>pycocci</b> will only  it  on
       1.0.2.  The order of preference for what indexing option to uses the following heuristics: If your target
       directory has a .glimpse_index file we assume you will want to use --use-glimpse. Glimpse is now released
       under the ISC license and performance-wise is known to work as the best indexing alternative, this is why
       we always check for a glimpse index first. This heuristic is however limited, you need the target path to
       be the base directory where the .glimpse_index file exists, otherwise <b>pycocci</b> will not recurse  below  on
       sub-directories. If we determine glimpse cannot be used then <b>pycocci</b> will use <b>git</b> <b>rev-parse</b> <b>--toplevel</b> on
       the  specified path to determine if the provided path is part of a git directory to enable --use-gitgrep.
       Although coccinelle provides a fail-safe mechanism to enable use of  --use-gitgrep  and  fall  back  onto
       --use-coccigrep if a git tree is not used, we avoid the failure case ahead of time. <b>pycocci</b> will be tuned
       through each release to infer the best indexing option known to use on your target path.

       Further information about spatch is available at <b>https://coccinelle.gitlabpages.inria.fr/website/</b>.

</pre><h4><b>OPTIONS</b></h4><pre>
       Here is a summary of the options available on <b>pycocci</b>:

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>pycocci</b>  <b>[-h</b>  <b>|</b>  <b>--help]</b>  <b>[-p</b> <b>|</b> <b>--profile-cocci]</b> <b>[-j</b> <b>|</b> <b>--jobs]</b> <b>[-v</b> <b>|</b> <b>--verbose]</b> <b>[-s</b> <b>|</b> <b>--show-proof]</b> <u>&lt;SmPL</u>
       <u>patch&gt;</u> <u>&lt;target&gt;</u> <b>]</b>

       <b>-h</b> <b>|</b> <b>--help</b>
              print short help menu

       <b>-p</b> <b>|</b> <b>--profile-cocci</b>
              Profile the &lt;SmPL patch&gt; when run against &lt;target&gt;

       <b>-j</b> <b>|</b> <b>--jobs</b> <b>&lt;job-digit&gt;</b>
              Override the default number of jobs to use with &lt;job-digit&gt;. You really  only  need  this  if  the
              heuristics for the default number of jobs is determined to be incorrect.

       <b>-v</b> <b>|</b> <b>--verbose</b>
              Output  all  possible  information  when  run. By default <b>pycocci</b> will provide no output unless an
              error is found.

       <b>-s</b> <b>|</b> <b>--show-proof</b>
              Show that the &lt;SmPL-patch.cocci&gt; can replace a series of patches. The &lt;SmPL-patch.cocci&gt; must have
              a .cocci postfix. A series of patches are expected to exist  in  the  directory  named  after  the
              &lt;SmPL-patch.cocci&gt; with the .cocci postfix removed.  <b>pycocci</b> will use git in order to show a proof
              of  equivalence  between the two. A new git branch will be created and used to apply the series of
              patches ("pycocci-patch-8-random-chars") onto the &lt;target&gt;, another git branch will be created and
              used to apply the &lt;SmPL-patch.cocci&gt; ("pycocci-smpl-8-random-chars"). <b>pycocci</b> will display name of
              the newly  created  branches  and  finally  provide  the  output  of  <b>git</b>  <b>diff</b>  <b>--stat</b>  <b>&lt;pycocci-</b>
              <b>patch-8-random-chars&gt;..&lt;pycocci-smpl-8-random-chars&gt;</b>.  You  should see no changes, and therefore a
              <b>perfect</b> <b>SmPL</b> <b>patch</b> <b>equivalence</b>, when the diffstat on the output  shows  no  changes.  The  way  to
              interpret  a positive diffstat is that the &lt;SmPL-patch.cocci&gt; is introducing more changes than the
              patch series. The way to interpret a negative diffstat is that the &lt;SmPL-patch.cocci&gt;  is  lacking
              some  changes  in place on the patch series. <b>pycocci</b> will use <b>git</b> <b>rev-parse</b> <b>--toplevel</b> against the
              &lt;target&gt; to see if the &lt;target&gt; is part of a git tree. If the &lt;target&gt; is not part of a git tree a
              git tree is created for you on &lt;target&gt; if &lt;target&gt; is a directory or on  the  base  directory  of
              &lt;target&gt;  if  &lt;target&gt;  is  a  file.   <b>pycocci</b> will return you to the branch previously set on the
              &lt;target&gt; if one was previously set, otherwise if a new git tree was created for you  <b>pycocci</b>  will
              set  the  tree back to the master branch. Each run of <b>pycocci</b> <b>--show-proof</b> will create two new git
              branches. 8 random characters are postixed to each new git branch created to avoid conflicts  with
              previous runs.

              You  must  run  this option with a clean git tree, if you have any pending changes you must commit
              them or discard them.

              <b>c</b> <b>|</b> <b>--clean-proof</b> This does what --show-proof does but this is completely silent unless  an  error
              occurs.  It  will  also  remove the git branches used to test for the equivalence proof, unless an
              error is found. If an error is found you can inspect the two branches  used  to  test  for  proof,
              refer to the documentation on --show-proof for details about these branches. This option is useful
              if you want to automate tests with proofs.

              Note  that  using  this  method  will  have created and subsequently if successful deleted two git
              branches on your git tree. As a consequence of using git branches your git reflog will show  these
              branches,  if  you push your tree out these branches will not be pushed as they were deleted, your
              reflog however will keep these references locally until git expires them, by default  this  is  30
              days. If this is too chatty for you, you can run:

                   git reflog expire --all --expire=now

              This will immediately clear old entries from your reflog.

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>pycocci</b> and this man page was written by Luis R. Rodriguez &lt;<a href="mailto:mcgrof@kernel.org">mcgrof@kernel.org</a>&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Send a mail to &lt;<a href="mailto:cocci@inria.fr">cocci@inria.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  2015,  Luis  R.  Rodriguez  pycocci is free software: you can redistribute it and/or modify it
       under the terms of the GNU General Public License as published by the Free Software Foundation, according
       to version 2 of the License.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/spatch.1.html">spatch</a></u>(1), <u><a href="../man1/pycocci.1.html">pycocci</a></u>(1), <u><a href="../man1/diff.1.html">diff</a></u>(1)

                                                  July 20, 2015                                       <u><a href="../man1/pycocci.1.html">pycocci</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>