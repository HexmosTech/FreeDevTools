<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rxgen - Stub generator for the Rx remote procedure call package</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libopenafs-dev">libopenafs-dev_1.8.13.2-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rxgen - Stub generator for the Rx remote procedure call package

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>rxgen</b> [<b>-h</b> | <b>-c</b> | <b>-C</b> | <b>-S</b> | <b>-r</b>] [<b>-dkp</b>]
           [<b>-I</b> <u>dir</u>] [<b>-P</b> <u>prefix</u>] [<b>-o</b> <u>outfile</u>] [<u>infile</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>rxgen</b> is a tool that generates C code to implement the Rx RPC protocol; it takes as input a description
       of an application interface similar to C and produces a number of server and/or client stub routines to
       be linked with RPC-based programs.  These stubs allow programs to invoke remote procedures through local
       procedure calls.  <b>rxgen</b> is based on Sun's <b>rpcgen</b> (version 3.9) but does not maintain compatibility with
       rpcgen RPC descriptions.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>rxgen</b> operates in several different modes.  The generated output files can be produced individually
       (using one of <b>-h</b>, <b>-c</b>, <b>-C</b>, or <b>-S</b>) or collectively.  All output files are created when the default is used
       (i.e., no options), or the output is limited to the server stubs (<b>-C</b> and <b>-S</b>) when the <b>-r</b> flag is used.
       The following describes the types of generated output files (for simplicity, <u>filename</u> refers to the main
       output filename):

       <b>-h</b>  Generate  C  data  definitions  (a  header  file)  from standard RPCL definitions (default extension:
           <u>filename</u>.h).

       <b>-c</b>  Compile the XDR routines required to serialize the protocol described by RPCL.  Generate XDR routines
           for all declarations (default extension: <u>filename</u>.xdr.c).

       <b>-C</b>  Generate all the client-side stub routines (default extension: <u>filename</u>.cs.c).  Calling a routine  in
           this file will cause the arguments to be packed up and sent via Rx (or R).

       <b>-S</b>  Generate  all  the  server-side  stub  routines  (default  extension:  <u>filename</u>.ss.c).  Arguments are
           unpacked, and the corresponding server routine is called.

       <b>-r</b>  Generate the two default extension files produced by the <b>-C</b> and <b>-S</b> options.

       The following options can be used on any combination of <b>rxgen</b> calls:

       <b>-k</b>  Must be specified when the generated code is intended to be used by the  kernel;  special  "includes"
           and other specifics are produced when the target output is for the kernel.

       <b>-p</b>  Package  combination  flag: when multiple packages are included within a single specification file, a
           single Execute Request routine will be used for all of them as a result of this flag.  The default is
           to generate individual Execute Request stubs for each package.

       <b>-I</b> <u>dir</u>
           Similar to the <b>-I</b> flag in the C compiler (<b>cc</b>). This flag is passed to the pre-processor (<b>cpp</b>) so that
           directory <u>dir</u> is searched before the standard lookup list for #include files.  As expected,  multiple
           <b>-I</b> flags can be used simultaneously.

       <b>-P</b> <u>prefix</u>
           The  <u>prefix</u>  string  following  this  switch  is prepended to all generated output files; useful when
           multiple runs want to produce different versions of the same interface (say,  kernel  and  non-kernel
           versions).

       <b>-d</b>  Debugging mode; only needed when <b>rxgen</b> is to be debugged (say, via <b>dbx</b>).

       <b>-o</b> <u>outfile</u>
           Specify  the name of the output file.  If none is specified, the standard output is used (<b>-c</b>, <b>-h</b>, <b>-C</b>,
           and <b>-S</b> modes only).  Note that if an output file is specified in a multi-output file option (such  as
           the  default,  or  with option <b>-r</b>), then the <u>outfile</u> replaces the name generated by default (which is
           based on the configuration's main file name).

</pre><h4><b>rxgen</b> <b>SYNTAX</b> <b>SUMMARY</b></h4><pre>
           Specification file:

               &lt;Package description option&gt; |
               &lt;Prefix description option&gt; |
               &lt;StartingOpcode description option&gt; |
               &lt;SplitPrefix description option&gt; |
               &lt;Procedure description option&gt; |
               &lt;RPCL language description option&gt;

           &lt;Package description option&gt;:

               "package" &lt;Package_ident&gt;

           &lt;Prefix description option&gt;:

               "prefix" &lt;Prefix_ident&gt;

           &lt;StartingOpcode description option&gt;:

               "startingopcode" &lt;constant&gt;

           &lt;SplitPrefix description option&gt;:

               "splitprefix" &lt;split options&gt; ";"

           &lt;Split options&gt;:

               "IN =" &lt;Start_prefix_ident&gt; "|"
               "OUT =" &lt;End_prefix_ident&gt; "|"
               &lt;Split options&gt;

           &lt;Procedure description option&gt;:

               ["proc"] [&lt;Procedure_ident&gt;] [&lt;ServerStub_ident&gt;]
                   &lt;Argument list&gt; ["split" | "multi"]
                   ["=" &lt;Opcode_ident&gt;] ";"

           &lt;Argument list&gt;:

               "(" &lt;Argument definition&gt; &lt;Comma_joined argument&gt; ")"

           &lt;Argument definition&gt;:

               &lt;Direction option&gt; &lt;Standard RPCL type decl&gt; &lt;Arg_ident&gt;
                   ["&lt;" &lt;Max_size&gt; "&gt;" | "[" &lt;Max_size&gt; "]"] | NULL

           &lt;Comma_joined argument&gt;:

               "," &lt;Argument definition&gt; | NULL

           &lt;Direction option&gt;:

               "IN" | "OUT" | "INOUT" | NULL

           &lt;Max_size&gt;:

               &lt;constant&gt; | NULL

           &lt;Package_ident&gt;:
           &lt;Prefix_ident&gt;:
           &lt;String_ident&gt;:
           &lt;Start_prefix_ident&gt;:
           &lt;End_prefix_ident&gt;:
           &lt;Procedure_ident&gt;:
           &lt;ServerStub_ident&gt;:
           &lt;Arg_ident&gt;:
           &lt;Opcode_ident&gt;:

               &lt;identifier&gt;

           &lt;RPCL language description option&gt;:
           &lt;Standard RPCL type decl&gt;:

               Sun's RPCL language syntax (see <a href="../man1/rpcgen.1.html">rpcgen</a>(1))

</pre><h4><b>rxgen</b> <b>COMMANDS</b></h4><pre>
   <b>Comments</b> <b>and</b> <b>Preprocessing</b>
       The input interface may contain preprocessor directives which are passed through the C preprocessor (i.e.
       "cpp").  Since the preprocessor runs on all input files before they are actually  interpreted  by  <b>rxgen</b>,
       all <b>cpp</b> directives (#include, #ifdefs, #defines, etc.) are legal and welcomed within an <b>rxgen</b> input file.
       Of  course,  none  of  these  preprocessor directives will be included in any of the generated files.  To
       facilitate distinctions between the different types of output files, <b>rxgen</b> defines  certain  special  <b>cpp</b>
       symbols  for  use  by  the  <b>rxgen</b>  programmer.   These  are  RPC_HDR (defined when compiling into header,
       <u>filename</u>.h, files), RPC_XDR (defined when compiling into xdr, <u>filename</u>.xdr.c, files), RPC_CLIENT (defined
       when compiling into client stubs, <u>filename</u>.cs.c, files), and  RPC_SERVER  (defined  when  compiling  into
       server stubs, <u>filename</u>.ss.c, files).

       In  addition,  <b>rxgen</b>  does  a  little  preprocessing  of  its own.  Any line beginning with "%" is passed
       directly into the  output  file,  uninterpreted  by  <b>rxgen</b>.   For  a  more  heavy  en  masse  dumping  of
       uninterpreted  code,  it  would  be advised to include all such code in an "#include" file and pass it in
       preceded by "%".  The input interface may also  contain  any  C-style  comments  which  are,  of  course,
       ignored.  Interpretation  is  token-based,  thus  special  line-orientation of separate statements is not
       necessary.  <b>rxgen</b> also provides a quite rich and helpful set of error reports, identifying them by  exact
       line  location  and  error  type.   Also,  <b>rxgen</b>  will automatically generate #include lines for standard
       include files, such as <u>rx/xdr.h</u> and <u>rx/rx.h</u>, along with the generated header file from this interface.

   <b>Prefixing</b> <b>stub</b> <b>procedures</b>
       The <u>package</u> statement tells <b>rxgen</b> the name of the interface package.  It is used for prefixing the naming
       of all generated stub routines and the execute request procedure.  For example:

           package AFS_

       causes the execute request procedure to be named AFS_ExecuteRequest (Warning: in  the  older  version  an
       additional  "_"  was appended after the package name to the ExecuteRequest name; thus make sure you don't
       have an ExecuteRequest interface routine) and a given stub routine,  say  Fetch,  to  be  actually  named
       AFS_Fetch.   Multiple package statements (current maximum size is 10) per configuration are permitted and
       are useful when multiple sets of interfaces are implemented (see the example at the end).  Note  that  in
       such  cases,  use  of  the  <b>-p</b>  flag results in the generation of just one ExecuteRequest procedure which
       recognizes the multiple interfaces and whose name is prefixed by the first  package  statement.   In  the
       default  case,  independent  ExecuteRequest  procedures will be created for each packaged group of remote
       procedure calls.

       The <u>prefix</u> statement supplies a  name  to  prepend  to  all  calls  to  remote  procedure  names  in  the
       ExecuteRequest  stub  routine.   It  is useful when the server makes RPC calls to other servers (say, for
       debugging purposes).  For example:

           prefix S

       causes the name "S" to be prepended to the name of all routines called from the server stubs.  The server
       can then call the original name and get the client stubs.

   <b>rxgen</b> <b>procedure</b> <b>declaration</b>
       The <u>proc</u> statement is the most common (and meaningful) in the <b>rxgen</b> interface.   Its  syntax  description
       is:

               [proc] [&lt;proc_name&gt;] [&lt;server_stub&gt;] (&lt;arg&gt;, ..., &lt;arg&gt;)
                   [split | multi] [= &lt;opcode&gt;] ;

       where:

       • "proc"  is  an  optional  prefix  of  the  procedure statement. This is just a stylistic item and not a
         required procedure delimiter.

       • &lt;proc_name&gt; is the name of the procedure.  Note that even the name of the procedure is optional.   This
         only  makes  sense  when  the  name of the given procedure is identical to the name of the last <u>package</u>
         statement (i.e., "package RCallBack" and the declaration of the "RCallBack" procedure).

       • &lt;server_stub&gt;, if present, causes the ExecuteRequest  procedure  to  call  that  stub  instead  of  the
         automatically generated stub when a call with that opcode is decoded.

       • &lt;opcode&gt; is a constant or symbol that is the opcode for that procedure.  One might use the preprocessor
         features  (i.e.,  #define),  the <u>const</u> RPC-language feature, or the old good constants as opcodes. Some
         further evaluation/processing of opcodes is done.  Particularly, checks for duplicate and  non-existent
         opcodes  are performed, along with checks for "holes" (i.e., gaps in consecutive opcodes) in the opcode
         sequences.  For example, we use the fact  that  when  "holes"  in  opcodes  exist,  the  ExecuteRequest
         procedure uses the <u>case</u> statement rather than the faster (and smaller, codewise) indexed array method.

         Also,  <b>rxgen</b>  defines  (i.e., appends to the header file) three valuable macros for each package group:
         &lt;package-name&gt;LOWEST_OPCODE, &lt;package-name&gt;HIGHEST_OPCODE, and &lt;package-name&gt;NUMBER_OPCODES.  These may
         be useful to the <b>rxgen</b> programmer.  Also, notice that the <u>opcode</u> statement is an optional feature,  and
         can be omitted.  In such cases, automatic opcode numbers are generated sequentially, starting from 0.

         One  can change the initial opcode number by using the <u>startingopcode</u> (for lack of a better name) <b>rxgen</b>
         command.  Its syntax is:

             startingopcode &lt;constant&gt;

         where &lt;constant&gt; must be reasonable!  Note that one can not mix procedures, some with opcodes and  some
         without,  nor  allow  opcodes  after  the  specification  of  the <u>startingopcode</u> statement.  <b>rxgen</b> will
         complain in all such cases.

       • The <u>argument</u> entry represents a given parameter of the procedure.  Its syntax is:

             [IN | INOUT | OUT | &lt;null&gt;] &lt;type_decl&gt; &lt;arg_name&gt;
                 [&lt;max&gt;|&lt;&gt;|[max]|[]]

         If the type is an indirect type (i.e., is followed by *), it is assumed  that  the  pointer  should  be
         followed  one  level and the data pointed to is to be transmitted. This should normally be used for all
         structures/arrays and out parameters.  A noticeable exception is when explicit array/structure  maximum
         size  is  given;  since no array-of-pointer declarations are allowed one should use typedefs to achieve
         the similar effect.  The parameters could be input  parameters  (preceded  by  IN),  output  parameters
         (preceded  by  OUT),  or  input/output  parameters  (preceded  by  INOUT).   If not specified, then the
         direction of the previous parameter in the procedure is used.   (Note:  the  first  parameter  must  be
         preceded by the directional primitive!)

       • "split"  is a hack to handle stub routines that do things such as file transfers or any other operation
         that has to exchange information  (e.g.,  length  of  a  file)  before  the  call  returns  its  output
         parameters.   Because  of the particular handshake that is involved when doing remote file transfer, we
         currently break all such calls into two client-side stub routines.  The first (with the default  prefix
         of  "Begin")  is  used  to  pass  all IN and INOUT parameters to the server side.  The second (with the
         default prefix of "End") is used to get back the INOUT and OUT parameters from the server.  Between the
         two calls, the user is supposed to do the appropriate calls for the file  transfer.  For  example,  the
         following procedure declaration in package AFS_

             Fetch (IN a, b,INOUT c, OUT d) split = FETCHOPCODE;

         will roughly generate the two independent client stub routines:

             BeginAFS_Fetch (IN a, b, c)

         and

             EndAFS_Fetch(OUT c, d)

         The  <u>splitprefix</u>  statement is used to change the default prefix names used by the two client-side stub
         generated routines when dealing with file transfer-related procedure calls.  For example:

             splitprefix IN=Before_ OUT=After_

         will cause the naming of the two client stubs for a file transfer-related routine, say <b>Fetch()</b>,  to  be
         <b>Before_AFS_Fetch()</b> and <b>After_AFS_Fetch()</b>, respectively.

       • The  "multi"  option  is nearly identical to the "split" feature described above.  The only significant
         visible difference is that along with the two client stubs, the standard client stub is also generated.
         Since the intention is to handle the multi-Rx calls, we need the whole standard procedure stub  in  the
         cases where no multi-Rx call of the procedure is performed.  A side effect of the "multi" option is the
         generation  of  a  special  macro  (i.e.,  "multi_&lt;Procedure-name&gt;"  which passes back as arguments the
         "Begin" and "End" stubs in the header output file. This macro is used directly by the Rx  code  when  a
         multi-Rx call of this procedure is performed.

   <b>OBSOLETE</b> <b>rxgen</b> <b>FEATURES</b>
       Although  the  following  rxgen  commands  are still in effect, they will soon be removed since there are
       better alternatives. DO NOT USE THEM!

       The <u>special</u> statement is a temporary hack used to handle certain inefficiencies of standard xdr  routines
       to  handle  some user-customized declarations.  In particular, this applies to a string pointer specified
       as part of a declaration.  For example,

           special struct BBS SeqBody;

       tells <b>rxgen</b> that the entry "SeqBody" in the user-defined BBS xdr routine is a string (note that more than
       one string can be "special" per structure -- multiple  ones  are  separated  by  commas);  it  will  thus
       allocate  and  de-allocate space properly in the server-generated stubs that contain this structure as an
       IN or INOUT parameter.

       A better alternative to <u>special</u> is the <u>customized</u> statement,  which  is  simply  the  "customized"  token
       followed  by  the  regular declaration of a struct based on the RPCL rules. In this case, the declaration
       will be included in the generated header file (<b>-h</b> option) but no xdr routine will be generated  for  this
       structure -- the user will supply this.  All pointer entries in this structure will be remembered so when
       the  structure  is  used  as  an  IN or INOUT in the server stub, no core leaks will occur.  For example,
       consider

           customized struct CBS {
               long Seqlen;
               char *SeqBody;
           }

       The "xdr_CBS" routine would be provided by the user where during the DECODE xdr opcode, appropriate space
       for the "SeqBody" string is allocated.  Similarly, that space is freed during the FREE xdr opcode.

       Note: Old style "Array parameter specifications" are not supported any more.

</pre><h4><b>EXAMPLES</b></h4><pre>
       In case there are some requirements not available by the current RPC language, one can customize some XDR
       routines by leaving those data types undefined. For every data type that is undefined, it will be assumed
       that a routine exists with the name "xdr_" prepended  to  it.   A  selected  set  of  <b>rxgen</b>  features  is
       presented  below,  but  for  a more comprehensive one (unions, complex examples, etc) please refer to the
       <u>rpcgen</u> <u>Programming</u> <u>Guide</u> and <u>eXternal</u> <u>Data</u> <u>Representation:</u> <u>Sun</u> <u>Technical</u> <u>Notes</u>.

   <b>Typedefs</b>
       The RPC typedef statement is identical to the C typedef (i.e. "typedef &lt;declaration&gt;").  By default, most
       user declarations (i.e. structs, unions, etc) are automatically typedef'ed  by  <b>rxgen</b>.   Since  it  makes
       parsing simpler, its usage is recommended by <b>rxgen</b> scripts.

   <b>Strings</b>
       The  C  "char  *"  string  convention  is kind of ambiguous, since it is usually intended to mean a null-
       terminated string of characters, but it could also represent a pointer to a single character,  a  pointer
       to  an array of characters, etc.  In the RPC language, a null-terminated string is unambiguously called a
       "string".  Examples,

           string bigname&lt;&gt;;
           string name&lt;MAXNAMELEN&gt;;
           typedef string volname&lt;MAXVOLNAME&gt;;

       Notice that the maximum size of string can  be  arbitrary  (like  "bigname"  above)  or,  preferably,  or
       specified  in  angle brackets (i.e. "name" and "volname" above).  In practice, one should always use only
       bounded strings in interfaces.  A sample calling proc using the declarations above would be:

           GetEntryByName (IN volname name,
               OUT struct vldbentry *entry) = VL_GETENTRYBYNAME;

       or, of course,

           GetEntryByName (IN string volname&lt;MAXVOLNAME&gt;,
               OUT struct vldbentry *entry) = VL_GETENTRYBYNAME;

       It is very important for the user to understand when the string parameters  should  be  allocated  and/or
       freed  by  the  his/her  client  and/or  server  programs. A short analysis on string parameters handling
       follows (note that a similar method is used for the handling of variable length  arrays  as  it  will  be
       shown later on):

       • In  the  client  side: IN and INOUT string parameters are the programmer's responsibility and should be
         allocated (static or via malloc) before calling the rpc and freed (if malloc was used) after the  rpc's
         return  in  the  user's  client  program; of course, for INOUT parameters, the returned string can't be
         bigger than the malloced input string.

         OUT string parameters are automatically malloced (based on the length of the returned  string  and  not
         the  maxsize)  by  the  <b>rxgen</b>  client stubs (in <u>filename</u>.cs.c) and must be freed by the client program;
         admittedly, this could be somewhat confusing since the user needs to free something that he/she  didn't
         allocate.}

       • In  the  server  side:  IN and INOUT string parameters are automatically malloced (based on the size of
         incoming strings) by the rxgen server stubs (in <u>filename</u>.ss.c) before they are  passed  to  the  user's
         server  procedure;  that  space  is  automatically  freed  just  before  the rxgen server stub returns;
         therefore the user need not do anything special for IN and INOUT string parameters.

         OUT string parameters must be malloced by the user's server procedure (i.e. null pointer is  passed  to
         it  by  the rxgen server stub) and it is automatically freed at the end of the <b>rxgen</b> server stub.  Like
         in the client side, the OUT parameters are somewhat unorthodox (i.e. the server routine must  malloc  a
         string without ever freeing it itself; this is done by the <b>rxgen</b> server stub).

       Note  that  for INOUT and OUT string parameters, in both the client and server sides their arguments must
       be char of pointers (i.e. char **).

   <b>Pointers</b>
       Pointer declarations  in  RPC  are  also  exactly  as  they  are  in  C  (i.e.  "struct  single_vldbentry
       *vldblist;").   Of  course,  one  can't  send pointers over the network, but one can use XDR pointers for
       sending recursive data types such as lists and trees (an example of a linked list  will  be  demonstrated
       shortly).

   <b>Arrays</b>
       Fixed  arrays are just like standard C array declarations (i.e. "struct UpdateEntry entries[20]") without
       any side effect problems in <b>rxgen</b>. Since variable-length arrays have no explicit syntax in C, the  angle-
       brackets  are  used  for it and the array declarations are actually compiled into "struct"s. For example,
       declarations such as:

           const   MAXBULKSIZE     = 10000;
           const   MAXENTRIES      = 100;
           opaque  bulk&lt;MAXBULKSIZE&gt;;           /* At most 10000 items */
           int     hosts&lt;&gt;;                     /* any number of items */
           typedef vldbentry blkentries&lt;100&gt;;   /* Preferable array decl */

       are compiled into the following structs:

           struct {
               u_int   bulk_len;       /* no of items */
               char    *bulk_val;      /* pointer to array */
           } bulk;

       for the "bulk" array, and similarly for the "blkentries&lt;100&gt;" array,

           struct {
               u_int      blkentries_len;   /* no of items in array */
               vldbentry  *blkentries_val;  /* pointer to array */
           } blkentries;

       Therefore the user should be aware of the "magically" generated structure entries such as the  number  of
       items  in  the array (&lt;array_name&gt;_len) and the pointer to the array (&lt;array_name&gt;_val) since some of the
       entries will have to be filled in from the client/server programs.  A sample proc would be:

           typedef vldbentry blkentries&lt;MAXENTRIES&gt;;
           proc GetBlk (OUT blkentries *vlentries) = VL_GETBLK;

       or, more directly,

           GetBlk(OUT vldbentry vlentries&lt;MAXENTRIES&gt;) = VL_GETBLK;

       Note that although the latest method is preferable since one does not  have  to  first  use  the  typedef
       statement  (and admittedly, programmers prefer avoiding typedefs), one should realize that <b>rxgen</b> does the
       structure expansion and the  xdr  creation  implicitly;  therefore  the  user  should  be  aware  of  the
       "vldbentries_val" and "vldbentries_len" fields as before (see following examples).

       <u>Array</u> <u>example</u> <u>I</u> <u>(least</u> <u>desirable)</u>

       Procedure declaration in the interface configuration:

           proc ListAttributes (IN vldblistbyattributes *attributes,
                        INOUT blkentries *vldbentries) = VL_LISTATTRIBUTES;

       Sample CLIENT code:

           blkentries entries, *pnt;
           entries.blkentries_len = 10;   /* max # returned entries */
           entries.blkentries_val = (vldbentry *)malloc(LEN);
                                          /* It must be set */

           code = VL_ListAttributes(&amp;attributes, &amp;entries);
           if (!code) {
               pnt = entries.blkentries_val;
               for (i=0; i &lt; entries.blkentries_len; i++, pnt++)
                       display_vldbentry(pnt);
               /* Make sure you free the allocated space */
               free((char *)entries.blkentries_val);
           }

       Sample SERVER code:

           VL_ListAttributes(attributes, entries)
           {
               vldbentry *singleentry = entries-&gt;blkentries_val;
               entries-&gt;blkentries_len = 0;

               while (copy_to_vldbentry(&amp;vlentry, singleentry))
                   singleentry++, vldbentries-&gt;entries_len++;
           }

       Although  this  method  for  variable-size  arrays works fine, there are some major drawbacks.  The array
       parameter (i.e. vldbentries above) must be declared as INOUT since we need to pass the max length of  the
       expected returned array; more importantly, a big (depending on the value of "_len") chunk of junk code is
       going  to  be  transferred to the server as result of the IN(out) side-effect of the array.  It's an easy
       and convenient method if the returned array size can be predicted from the start and  when  the  size  is
       quite  high.   This method is included as an example of erroneous use (and abuse) of <b>rxgen</b> and should not
       be used.

       <u>Array</u> <u>example</u> <u>II</u> <u>(Desirable</u> <u>method)</u>

       Procedure declaration in the interface configuration (using Example I above):

           proc ListAttributes (IN vldblistbyattributes *attributes,
               OUT blkentries *vldbentries) = VL_LISTATTRIBUTES;

       Sample CLIENT code:

           blkentries entries, *pnt;

           code = VL_ListAttributes(&amp;attributes, &amp;entries);
           if (!code) {
               pnt = entries.blkentries_val;
               for (i=0; i &lt; entries.blkentries_len; i++, pnt++)
                       display_vldbentry(pnt);
               /* Make sure you free the allocated space (by rxgen) */
               free((char *)entries.blkentries_val);
           }

       Sample SERVER code:

           VL_ListAttributes(attributes, entries)
           {
               vldbentry *singleentry;
               entries-&gt;blkentries_len = 0;
               singleentry = entries-&gt;blkentries_val
                   = (vldbentry *)malloc(MAXENTRIES * sizeof(vldbentry));

               while (copy_to_vldbentry(&amp;vlentry, singleentry))
                       singleentry++, vldbentries-&gt;entries_len++;
           }

       This is the best (and simplest) way of using variable-size arrays as an  output  parameter.   It  is  the
       responsibility of the server-side stub to <b>malloc()</b> the adequate space which is automatically freed by the
       <b>rxgen</b> stub; the client side should free the space allocated by the <b>rxgen</b>-calling stub.

       <u>Array</u> <u>example</u> <u>III</u> <u>(Linked</u> <u>Lists)</u>

       Considering  the  following  3  declarations (could have applied some optimizations) in the configuration
       file:

           typedef struct single_vldbentry *vldblist;
           struct single_vldbentry {
               vldbentry vlentry;
               vldblist  next_vldb;
           };

           struct vldb_list {
               vldblist node;
           };

       and the rxgen procedure declaration:

           LinkedList (IN vldblistbyattributes *attributes,
               OUT vldb_list *linkedentries) = VL_LINKEDLIST;

       Sample CLIENT code:

           vldb_list       linkedvldbs;
           vldblist        vllist, vllist1;

           bzero(&amp;linkedvldbs, sizeof(vldb_list));
           code = VL_LinkedList(&amp;attributes, &amp;nentries, &amp;linkedvldbs);
           if (!code) {
               printf("We got %d vldb entries\n", nentries);
               for (vllist = linkedvldbs.node; vllist; vllist = vllist1) {
                   vllist1 = vllist-&gt;next_vldb;
                   display_entry(&amp;vllist-&gt;vlentry);
                   free((char *)vllist);
               }
           }

       Sample SERVER code:

           VL_LinkedList(rxcall, attributes, nentries, linkedvldbs);
           {
               vldblist vllist, *vllistptr = &amp;linkedvldbs-&gt;node;
               while (...) {
                   vllist = *vllistptr
                       = (single_vldbentry *)malloc (sizeof (single_vldbentry));
                   copy_to_vldbentry(&amp;tentry, &amp;vllist-&gt;vlentry);
                   nentries++;
                   vllistptr = &amp;vllist-&gt;next_vldb;
               };
               *vllistptr = NULL;
           }

       Using a linked list offers many advantages: Nothing is passed to the server (the parameter  is  OUT),  no
       additional  overhead  is  involved,  and  the  caller doesn't have to explicitly prepare for an arbitrary
       return size.  A drawback is that the caller has the responsibility of <b>malloc()</b> (on the server)  and  free
       (on  the  client)  of  each  entry (to avoid unwanted core-leaks).  Another drawback is that since it's a
       recursive call, the C stack will grow linearly with respect to the number of nodes in the list  (so  it's
       wise to increase the Rx LWP stack if huge amounts of data are expected back -- default stack size is 4K).
       The advantages should outweigh the disadvantages here.

       It's  important  to  pay  attention  to  the comments of the three array examples above particularly when
       they're references to when the user should allocate/free space  for  the  variable  length  arrays.   The
       mechanism  is  very  similar to the handling of strings thus you might need to review the strings section
       above; note that the linked lists are handled somewhat differently...

   <b>Miscellaneous</b> <b>examples</b>
       Below is an abbreviated version of a random interface file which shows some of the common cases.

           /* Declaration of all structures used by the R.xg script interface */

           struct AFSFid {
               unsigned long Volume;
               unsigned long Vnode;
               unsigned long Unique;
           };

           typedef long ViceDataType;

           /* Note that TEST would be equivalent to "HEADER" only during the
              processing of the header, *.h, file */

           #ifdef RPC_HDR
           #define TEST "HEADER"
           #else
           #define TEST "REST"
           #endif

           /* This is the standard *.xg specification file */

           package AFS_
           splitprefix IN=BEFORE_ OUT=AFTER_;
           Prefix Test

           proc Remove(IN struct AFSFid *Did, IN string volname&lt;64&gt;,
               OUT struct AFSStatus *Status) = AFS_REMOVE;

           DisconnectFS AUX_disconnectFS() = AFS_DISCONNECTFS;

           proc GetVolumeInfo(IN string Vid,
               OUT struct VolumeInfo *Info) = AFS_GETVOLUMEINFO;

           /* You could have more than an interface per configuration */

           package VOTE_

           /* Using the "multi" feature; thus VOTE_Beacon can be called as an
              multi-Rx call or as a regular call */

           Beacon (IN long state, long voteStart,
               net_version *version, net_tid *tid)
               multi = VOTE_BEACON;

           package DISK_

           /* Using the "split" feature */

           SendFile (IN long file, long offset,
               long length, net_version *version)
               split = DISK_SENDFILE;

   <b>Output</b> <b>of</b> <b>an</b> <b>actual</b> <b>interface</b> <b>configuration</b>
       We'll demonstrate some of the actual output  generated  by  <b>rxgen</b>  by  following  an  abbreviated  actual
       interface configuration.

       <u>Configuration</u> <u>file</u>

       Contents of the interface configuration file (<u>vldbint.xg</u>):

           package VL_
           #include "vl_opcodes.h"   /* The opcodes are included here */
           %#include "vl_opcodes.h"  /* directly to other places */

           /* Current limitations on parameters that affect other packages
              (i.e. volume) */

           const   MAXNAMELEN      =       65;
           const   MAXNSERVERS     =       8;
           const   MAXTYPES        =       3;

           /* External (visible) representation of an individual vldb entry */

           struct vldbentry {
               char    name[MAXNAMELEN];
               long    volumeType;
               long    nServers;
               long    serverNumber[MAXNSERVERS];
               long    serverPartition[MAXNSERVERS];
               long    serverFlags[MAXNSERVERS];
               u_long  volumeId[MAXTYPES];
               long    flags;
           };

           typedef struct single_vldbentry  *vldblist;
           struct single_vldbentry {
               vldbentry VldbEntry;
               vldblist next_vldb;
           };

           struct vldb_list {
               vldblist node;
           };

           /* vldb interface calls */

           CreateEntry     (IN long Volid,
                           vldbentry *newentry) = VLCREATEENTRY;

           GetEntryByName  (IN string volumename&lt;MAXNAMELEN&gt;,
                           OUT vldbentry *entry) = VLGETENTRYBYNAME;

           GetNewVolumeId  (IN long bumpcount,
                           OUT long *newvolumid) = VLGETNEWVOLUMEID;

           ReplaceEntry    (IN long Volid,
                           long voltype,
                           vldbentry *newentry,
                           long ReleaseType) multi = VLREPLACEENTRY;

           ListAttributes  (IN VldbListByAttributes *attributes,
                           OUT long *nentries,
                           OUT vldbentry bulkentries&lt;MAXVLDBLEN&gt;)
                           = VLLISTATTRIBUTES;

           LinkedList      (IN VldbListByAttributes *attributes,
                           OUT long *nentries,
                           OUT vldb_list *linkedentries) = VLLINKEDLIST;

       For  a  detailed  description  on  the  Rx-related  calls inside the generated stubs (i.e., <b>rx_NewCall()</b>,
       <b>rx_EndCall()</b>), along with details on what happens inside certain calls (like <b>xdrrx_create()</b>) please refer
       to the Rx documentation. Typing "rxgen vldbint.xg" will result in the creation of four files:  <u>vldbint.h</u>,
       <u>vldbint.xdr.c</u>, <u>vldbint.cs.c</u> and <u>vldbint.ss.c</u>.  A closer look at these files follows.

       <u>Header</u> <u>file</u> <u>(vldbint.h)</u>

           /* Machine generated file -- Do NOT edit */

           #include "vl_opcodes.h"  /* directly to other places */
           #define MAXNAMELEN 65
           #define MAXNSERVERS 8
           #define MAXTYPES 3

           struct vldbentry {
               char name[MAXNAMELEN];
               long volumeType;
               long nServers;
               long serverNumber[MAXNSERVERS];
               long serverPartition[MAXNSERVERS];
               long serverFlags[MAXNSERVERS];
               u_long volumeId[MAXTYPES];
               long flags;
           };
           typedef struct vldbentry vldbentry;
           bool_t xdr_vldbentry();

           typedef struct single_vldbentry *vldblist;
           bool_t xdr_vldblist();

           struct single_vldbentry {
               vldbentry VldbEntry;
               vldblist next_vldb;
           };
           typedef struct single_vldbentry single_vldbentry;
           bool_t xdr_single_vldbentry();

           struct vldb_list {
               vldblist node;
           };
           typedef struct vldb_list vldb_list;
           bool_t xdr_vldb_list();

           #include &lt;rx/rx_multi.h&gt;
           #define multi_VL_ReplaceEntry(Volid, voltype, newentry, ReleaseType) \
               multi_Body(StartVL_ReplaceEntry(multi_call, Volid, voltype,
                          newentry, ReleaseType), <a href="../manmulti_call/EndVL_ReplaceEntry.multi_call.html">EndVL_ReplaceEntry</a>(multi_call))

           typedef struct bulkentries {
               u_int bulkentries_len;
               vldbentry *bulkentries_val;
           } bulkentries;
           bool_t xdr_bulkentries();

           /* Opcode-related useful stats for package: VL_ */
           #define VL_LOWEST_OPCODE        501
           #define VL_HIGHEST_OPCODE       506
           #define VL_NUMBER_OPCODES       6

       Notice  that  all  structures  are automatically typedef'ed and all "const"s are converted to "#define"s.
       Some data structures, such as bulkentries, are taken from procedure params  (from  ListAttributes  proc).
       Thus,  this  should be kept in mind when creating stubs piecemeal with <b>rxgen</b> (i.e., using the <b>-c</b>, <b>-h</b>, <b>-C</b>,
       or <b>-S</b> flags).  Also, one of the side effects of the  "multi"  option  (in  "ReplaceEntry"  proc)  is  the
       generation of the "multi_VL_ReplaceEntry" above.

       <u>XDR</u> <u>routines</u> <u>for</u> <u>structures</u> <u>(vldbint.xdr.c)</u>

           /* Machine generated file -- Do NOT edit */

           #include &lt;rx/xdr.h&gt;
           #include "vldbint.h"

           #include "vl_opcodes.h"  /* directly to other places */

           bool_t
           xdr_vldbentry(xdrs, objp)
               XDR *xdrs;
               vldbentry *objp;
           {
               if (!xdr_vector(xdrs, (char *)objp-&gt;name, MAXNAMELEN,
                               sizeof(char), xdr_char))
                   return (FALSE);
               if (!xdr_long(xdrs, &amp;objp-&gt;volumeType))
                   return (FALSE);
               if (!xdr_long(xdrs, &amp;objp-&gt;nServers))
                   return (FALSE);
               if (!xdr_vector(xdrs, (char *)objp-&gt;serverNumber, MAXNSERVERS,
                               sizeof(long), xdr_long))
                   return (FALSE);
               if (!xdr_vector(xdrs, (char *)objp-&gt;serverPartition,
                               MAXNSERVERS, sizeof(long), xdr_long))
                   return (FALSE);
               if (!xdr_vector(xdrs, (char *)objp-&gt;serverFlags, MAXNSERVERS,
                               sizeof(long), xdr_long))
                   return (FALSE);
               if (!xdr_vector(xdrs, (char *)objp-&gt;volumeId, MAXTYPES,
                               sizeof(u_long), xdr_u_long))
                   return (FALSE);
               if (!xdr_long(xdrs, &amp;objp-&gt;flags))
                   return (FALSE);
               return (TRUE);
           }

           bool_t
           xdr_vldblist(xdrs, objp)
               XDR *xdrs;
               vldblist *objp;
           {
               if (!xdr_pointer(xdrs, (char **)objp,
                                sizeof(struct single_vldbentry),
                                xdr_single_vldbentry))
                   return (FALSE);
               return (TRUE);
           }

           bool_t
           xdr_single_vldbentry(xdrs, objp)
               XDR *xdrs;
               single_vldbentry *objp;
           {
               if (!xdr_vldbentry(xdrs, &amp;objp-&gt;VldbEntry))
                   return (FALSE);
               if (!xdr_vldblist(xdrs, &amp;objp-&gt;next_vldb))
                   return (FALSE);
               return (TRUE);
           }

           bool_t
           xdr_vldb_list(xdrs, objp)
               XDR *xdrs;
               vldb_list *objp;
           {
               if (!xdr_vldblist(xdrs, &amp;objp-&gt;node))
                   return (FALSE);
               return (TRUE);
           }

           bool_t
           xdr_bulkentries(xdrs, objp)
               XDR *xdrs;
               bulkentries *objp;
           {
               if (!xdr_array(xdrs, (char **)&amp;objp-&gt;bulkentries_val,
                              (u_int *)&amp;objp-&gt;bulkentries_len, MAXVLDBLEN,
                              sizeof(vldbentry), xdr_vldbentry))
                   return (FALSE);
               return (TRUE);
           }

       Note  that  the  <b>xdr_bulkentries()</b>  is  automatically generated as a side effect of a procedure parameter
       declaration.  Thus, if identical multiple type parameter declarations  are  used,  then  multiply-defined
       xdr_*  stubs  will be created!  We felt this was a better alternative to having the <b>rxgen</b> programmer deal
       with types such as bulkentries_1, bulkentries_2...

       <u>Client-Side</u> <u>stub</u> <u>routines</u> <u>(vldbint.cs.c)</u>

           /* Machine generated file -- Do NOT edit */

           #include &lt;rx/xdr.h&gt;
           #include &lt;rx/rx.h&gt;
           #include &lt;afs/rxgen_consts.h&gt;
           #include "vldbint.h"

           #include "vl_opcodes.h"  /* directly to other places */

           int VL_CreateEntry(z_conn, Volid, newentry)
               register struct rx_connection *z_conn;
               long Volid;
               vldbentry * newentry;
           {
               struct rx_call *z_call = rx_NewCall(z_conn);
               static int z_op = 501;
               int z_result;
               XDR z_xdrs;

               xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);

               /* Marshal the arguments */
               if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
                    || (!xdr_long(&amp;z_xdrs, &amp;Volid))
                    || (!xdr_vldbentry(&amp;z_xdrs, newentry))) {
                       z_result = RXGEN_CC_MARSHAL;
                       goto fail;
               }

               z_result = RXGEN_SUCCESS;
           fail:
               return rx_EndCall(z_call, z_result);
           }

           int VL_GetEntryByName(z_conn, volumename, entry)
               register struct rx_connection *z_conn;
               char * volumename;
               vldbentry * entry;
           {
               struct rx_call *z_call = rx_NewCall(z_conn);
               static int z_op = 504;
               int z_result;
               XDR z_xdrs;

               xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);

               /* Marshal the arguments */
               if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
                    || (!xdr_string(&amp;z_xdrs, &amp;volumename, 65))) {
                       z_result = RXGEN_CC_MARSHAL;
                       goto fail;
               }

               /* Un-marshal the reply arguments */
               z_xdrs.x_op = XDR_DECODE;
               if ((!xdr_vldbentry(&amp;z_xdrs, entry))) {
                       z_result = RXGEN_CC_UNMARSHAL;
                       goto fail;
               }

               z_result = RXGEN_SUCCESS;
           fail:
               return rx_EndCall(z_call, z_result);
           }

           int VL_GetNewVolumeId(z_conn, bumpcount, newvolumid)
               register struct rx_connection *z_conn;
               long bumpcount;
               long * newvolumid;
           {
               struct rx_call *z_call = rx_NewCall(z_conn);
               static int z_op = 505;
               int z_result;
               XDR z_xdrs;

               xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);

               /* Marshal the arguments */
               if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
                    || (!xdr_long(&amp;z_xdrs, &amp;bumpcount))) {
                       z_result = RXGEN_CC_MARSHAL;
                       goto fail;
               }

               /* Un-marshal the reply arguments */
               z_xdrs.x_op = XDR_DECODE;
               if ((!xdr_long(&amp;z_xdrs, newvolumid))) {
                       z_result = RXGEN_CC_UNMARSHAL;
                       goto fail;
               }

               z_result = RXGEN_SUCCESS;
           fail:
               return rx_EndCall(z_call, z_result);
           }

           int VL_ReplaceEntry(z_conn, Volid, voltype, newentry, ReleaseType)
               register struct rx_connection *z_conn;
               long Volid, voltype, ReleaseType;
               vldbentry * newentry;
           {
               struct rx_call *z_call = rx_NewCall(z_conn);
               static int z_op = 506;
               int z_result;
               XDR z_xdrs;

               xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);

               /* Marshal the arguments */
               if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
                    || (!xdr_long(&amp;z_xdrs, &amp;Volid))
                    || (!xdr_long(&amp;z_xdrs, &amp;voltype))
                    || (!xdr_vldbentry(&amp;z_xdrs, newentry))
                    || (!xdr_long(&amp;z_xdrs, &amp;ReleaseType))) {
                       z_result = RXGEN_CC_MARSHAL;
                       goto fail;
               }

               z_result = RXGEN_SUCCESS;
           fail:
               return rx_EndCall(z_call, z_result);
           }

           int StartVL_ReplaceEntry(z_call, Volid, voltype, newentry, ReleaseType)
               register struct rx_call *z_call;
               long Volid, voltype, ReleaseType;
               vldbentry * newentry;
           {
               static int z_op = 506;
               int z_result;
               XDR z_xdrs;

               xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);

               /* Marshal the arguments */
               if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
                    || (!xdr_long(&amp;z_xdrs, &amp;Volid))
                    || (!xdr_long(&amp;z_xdrs, &amp;voltype))
                    || (!xdr_vldbentry(&amp;z_xdrs, newentry))
                    || (!xdr_long(&amp;z_xdrs, &amp;ReleaseType))) {
                       z_result = RXGEN_CC_MARSHAL;
                       goto fail;
               }

               z_result = RXGEN_SUCCESS;
           fail:
               return z_result;
           }

           int EndVL_ReplaceEntry(z_call)
               register struct rx_call *z_call;
           {
               int z_result;
               XDR z_xdrs;

               z_result = RXGEN_SUCCESS;
           fail:
               return z_result;
           }

           int VL_ListAttributes(z_conn, attributes, nentries, bulkentries_1)
               register struct rx_connection *z_conn;
               VldbListByAttributes * attributes;
               long * nentries;
               bulkentries * bulkentries_1;
           {
               struct rx_call *z_call = rx_NewCall(z_conn);
               static int z_op = 511;
               int z_result;
               XDR z_xdrs;

               xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);

               /* Marshal the arguments */
               if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
                    || (!xdr_VldbListByAttributes(&amp;z_xdrs, attributes))) {
                       z_result = RXGEN_CC_MARSHAL;
                       goto fail;
               }

               /* Un-marshal the reply arguments */
               z_xdrs.x_op = XDR_DECODE;
               if ((!xdr_long(&amp;z_xdrs, nentries))
                    || (!xdr_bulkentries(&amp;z_xdrs, bulkentries_1))) {
                       z_result = RXGEN_CC_UNMARSHAL;
                       goto fail;
               }

               z_result = RXGEN_SUCCESS;
           fail:
               return rx_EndCall(z_call, z_result);
           }

           int VL_LinkedList(z_conn, attributes, nentries, linkedentries)
               register struct rx_connection *z_conn;
               VldbListByAttributes * attributes;
               long * nentries;
               vldb_list * linkedentries;
           {
               struct rx_call *z_call = rx_NewCall(z_conn);
               static int z_op = 512;
               int z_result;
               XDR z_xdrs;

               xdrrx_create(&amp;z_xdrs, z_call, XDR_ENCODE);

               /* Marshal the arguments */
               if ((!xdr_int(&amp;z_xdrs, &amp;z_op))
                    || (!xdr_VldbListByAttributes(&amp;z_xdrs, attributes))) {
                       z_result = RXGEN_CC_MARSHAL;
                       goto fail;
               }

               /* Un-marshal the reply arguments */
               z_xdrs.x_op = XDR_DECODE;
               if ((!xdr_long(&amp;z_xdrs, nentries))
                    || (!xdr_vldb_list(&amp;z_xdrs, linkedentries))) {
                       z_result = RXGEN_CC_UNMARSHAL;
                       goto fail;
               }

               z_result = RXGEN_SUCCESS;
           fail:
               return rx_EndCall(z_call, z_result);
           }

       Notice the side effect of the "multi" feature (three different modules for "ReplaceEntry" proc).

       <u>Server-Side</u> <u>stub</u> <u>routines</u> <u>(vldbint.ss.c)</u>

           /* Machine generated file -- Do NOT edit */

           #include &lt;rx/xdr.h&gt;
           #include &lt;rx/rx.h&gt;
           #include &lt;afs/rxgen_consts.h&gt;
           #include "vldbint.h"

           #include "vl_opcodes.h"  /* directly to other places */

           long _VL_CreateEntry(z_call, z_xdrs)
               struct rx_call *z_call;
               XDR *z_xdrs;
           {
               long z_result;
               long Volid;
               vldbentry newentry;

               if ((!xdr_long(z_xdrs, &amp;Volid))
                    || (!xdr_vldbentry(z_xdrs, &amp;newentry))) {
                       z_result = RXGEN_SS_UNMARSHAL;
                       goto fail;
               }

               z_result = VL_CreateEntry(z_call, Volid, &amp;newentry);
           fail:
               return z_result;
           }

           long _VL_GetEntryByName(z_call, z_xdrs)
               struct rx_call *z_call;
               XDR *z_xdrs;
           {
               long z_result;
               char *volumename = (char *)0;
               vldbentry entry;

               if ((!xdr_string(z_xdrs, &amp;volumename, 65))) {
                       z_result = RXGEN_SS_UNMARSHAL;
                       goto fail;
               }

               z_result = VL_GetEntryByName(z_call, &amp;volumename, &amp;entry);
               z_xdrs-&gt;x_op = XDR_ENCODE;
               if ((!xdr_vldbentry(z_xdrs, &amp;entry)))
                       z_result = RXGEN_SS_MARSHAL;
           fail:
               z_xdrs-&gt;x_op = XDR_FREE;
               if (!xdr_string(z_xdrs, &amp;volumename, 65)) goto fail1;
               return z_result;
           fail1:
               return RXGEN_SS_XDRFREE;
           }

           long _VL_GetNewVolumeId(z_call, z_xdrs)
               struct rx_call *z_call;
               XDR *z_xdrs;
           {
               long z_result;
               long bumpcount;
               long newvolumid;

               if ((!xdr_long(z_xdrs, &amp;bumpcount))) {
                       z_result = RXGEN_SS_UNMARSHAL;
                       goto fail;
               }

               z_result = VL_GetNewVolumeId(z_call, bumpcount, &amp;newvolumid);
               z_xdrs-&gt;x_op = XDR_ENCODE;
               if ((!xdr_long(z_xdrs, &amp;newvolumid)))
                       z_result = RXGEN_SS_MARSHAL;
           fail:
               return z_result;
           }

           long _VL_ReplaceEntry(z_call, z_xdrs)
               struct rx_call *z_call;
               XDR *z_xdrs;
           {
               long z_result;
               long Volid, voltype, ReleaseType;
               vldbentry newentry;

               if ((!xdr_long(z_xdrs, &amp;Volid))
                    || (!xdr_long(z_xdrs, &amp;voltype))
                    || (!xdr_vldbentry(z_xdrs, &amp;newentry))
                    || (!xdr_long(z_xdrs, &amp;ReleaseType))) {
                       z_result = RXGEN_SS_UNMARSHAL;
                       goto fail;
               }

               z_result = VL_ReplaceEntry(z_call, Volid, voltype, &amp;newentry,
                                          ReleaseType);
           fail:
               return z_result;
           }

           long _VL_ListAttributes(z_call, z_xdrs)
               struct rx_call *z_call;
               XDR *z_xdrs;
           {
               long z_result;
               VldbListByAttributes attributes;
               long nentries;
               bulkentries bulkentries_1;

               if ((!xdr_VldbListByAttributes(z_xdrs, &amp;attributes))) {
                       z_result = RXGEN_SS_UNMARSHAL;
                       goto fail;
               }

               z_result = VL_ListAttributes(z_call, &amp;attributes, &amp;nentries,
                                            &amp;bulkentries_1);
               z_xdrs-&gt;x_op = XDR_ENCODE;
               if ((!xdr_long(z_xdrs, &amp;nentries))
                    || (!xdr_bulkentries(z_xdrs, &amp;bulkentries_1)))
                       z_result = RXGEN_SS_MARSHAL;
           fail:
               z_xdrs-&gt;x_op = XDR_FREE;
               if (!xdr_bulkentries(z_xdrs, &amp;bulkentries_1)) goto fail1;
               return z_result;
           fail1:
               return RXGEN_SS_XDRFREE;
           }

           long _VL_LinkedList(z_call, z_xdrs)
               struct rx_call *z_call;
               XDR *z_xdrs;
           {
               long z_result;
               VldbListByAttributes attributes;
               long nentries;
               vldb_list linkedentries;

               if ((!xdr_VldbListByAttributes(z_xdrs, &amp;attributes))) {
                       z_result = RXGEN_SS_UNMARSHAL;
                       goto fail;
               }

               z_result = VL_LinkedList(z_call, &amp;attributes, &amp;nentries,
                                        &amp;linkedentries);
               z_xdrs-&gt;x_op = XDR_ENCODE;
               if ((!xdr_long(z_xdrs, &amp;nentries))
                    || (!xdr_vldb_list(z_xdrs, &amp;linkedentries)))
                       z_result = RXGEN_SS_MARSHAL;
           fail:
               return z_result;
           }

           long _VL_CreateEntry();
           long _VL_GetEntryByName();
           long _VL_GetNewVolumeId();
           long _VL_ReplaceEntry();
           long _VL_ListAttributes();
           long _VL_LinkedList();

           static long (*StubProcsArray0[])() = {_VL_CreateEntry,
               _VL_GetEntryByName, _VL_GetNewVolumeId, _VL_ReplaceEntry,
               _VL_ListAttributes, _VL_LinkedList};

           VL_ExecuteRequest(z_call)
               register struct rx_call *z_call;
           {
               int op;
               XDR z_xdrs;
               long z_result;

               xdrrx_create(&amp;z_xdrs, z_call, XDR_DECODE);
               if (!xdr_int(&amp;z_xdrs, &amp;op))
                   z_result = RXGEN_DECODE;
               else if (op &lt; VL_LOWEST_OPCODE || op &gt; VL_HIGHEST_OPCODE)
                   z_result = RXGEN_OPCODE;
               else
                   z_result = (*StubProcsArray0[op - VL_LOWEST_OPCODE])
                       (z_call, &amp;z_xdrs);
               return z_result;
           }

       If there were gaps in the procedures' opcode sequence the code for <b>VL_ExecuteRequest()</b> routine  would  be
       have been drastically different (it would have been a case statement for each procedure).

</pre><h4><b>NOTES</b></h4><pre>
       <b>rxgen</b> is implemented from Sun's <b>rpcgen</b> utility.

       When  the  "%#include  &lt;include  file"&gt;  feature is used make sure that you don't have any <b>rxgen</b> language
       features (i.e. %#defines) since you'll get syntax errors during compilations..

       Since this is an ongoing project many of the above may change/disappear without a major warning.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Rxgen</u> <u>Syntax</u> <u>Summary</u>: Summary description of rxgen's grammar.

       <u>Rpcgen</u> <u>Programming</u> <u>Guide</u>: Sun's RPC protocol compiler.  <b>rxgen</b> was implemented as  an  extension  to  that
       compiler.

       <u>External</u> <u>Data</u> <u>Representation:</u> <u>Sun</u> <u>Technical</u> <u>Notes</u>: Detailed examples in using XDR.

       <u>RPCL</u> <u>Syntax</u> <u>Summary</u>: Summary of Sun's Remote Procedure Call Language.

       <u>Rx</u>: An extended Remote Procedure Call Protocol.

       <u>rgen</u>: An earlier version of a similar stub generator used for the R RPC protocol.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       IBM Corporation 2000. &lt;<a href="http://www.ibm.com/">http://www.ibm.com/</a>&gt; All Rights Reserved.

       This  documentation is covered by the IBM Public License Version 1.0.  It was converted from the original
       TeX <b>rxgen</b> manual to POD by Russ Allbery.

OpenAFS                                            2025-03-21                                           <u><a href="../man1/RXGEN.1.html">RXGEN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>