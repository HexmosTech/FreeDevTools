<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>likwid-bench - low-level benchmark suite and microbenchmarking framework</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/likwid">likwid_5.4.1+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       likwid-bench - low-level benchmark suite and microbenchmarking framework

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>likwid-bench</b>    [-hap]    [<b>-t</b>    <u>&lt;testname&gt;</u>]    [<b>-s</b>    <u>&lt;min_time&gt;</u>]    [<b>-w</b>   <u>&lt;workgroup_expression&gt;</u>]   [<b>-W</b>
       <u>&lt;workgroup_expression_short&gt;</u>] [<b>-l</b> <u>&lt;testname&gt;</u>] [<b>-d</b> <u>&lt;delimiter&gt;</u>] [<b>-i</b> <u>&lt;iterations&gt;</u>] [<b>-f</b> <u>&lt;filepath&gt;</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>likwid-bench</b> is a  benchmark  suite  for  low-level  (assembly)  benchmarks  to  measure  bandwidths  and
       instruction  throughput  for  specific  instruction code on x86 systems. The currently included benchmark
       codes include common data access patterns like load and store but also calculations like vector triad and
       sum.  <b>likwid-bench</b> includes architecture specific benchmarks for x86, x86_64 and x86 for Intel  Xeon  Phi
       coprocessors.  With  LIKWID  5  also  ARM  and POWER benchmarks are supported. The performance values can
       either be calculated by <b>likwid-bench</b> or measured using performance counters by using <b>likwid-perfctr</b> as  a
       wrapper  to <b>likwid-bench.</b>  This requires to build <b>likwid-bench</b> with instrumentation enabled in config.mk.
       Benchmarks   can   be   dynamically    added    when    a    proper    ptt    file    is    present    at
       $HOME/.likwid/bench/&lt;arch&gt;/&lt;testname&gt;.ptt . The files are compiled to a .S file and compiled using either
       gcc,  icc  or  pgcc (searched in $PATH). The default folder is <a href="file:/tmp/">/tmp/</a>&lt;PID&gt;. Possible values for &lt;arch&gt; are
       'x86', 'x86-64', 'phi', armv7', 'armv8' and 'power'.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-h</b>     prints a help message to standard output, then exits.

       <b>-a</b>     list available benchmark codes for the current system.

       <b>-p</b>     list available thread domains.

       <b>-s</b> <b>&lt;min_time&gt;</b>
              Run the benchmark for at least <b>&lt;min_time&gt;</b> <b>seconds.</b>  The amount of iterations is  determined  using
              this value. Default: 1 second.

       <b>-t</b> <b>&lt;testname&gt;</b>
              Name of the benchmark code to run (mandatory).

       <b>-w</b> <b>&lt;workgroup_expression&gt;</b>
              Specify  the  affinity domain, thread count and data set size for the current benchmarking run (-w
              or -W mandatory). First thread in thread domain initializes the stream.

       <b>-W</b> <b>&lt;workgroup_expression_short&gt;</b>
              Specify the affinity domain, thread count and data set size for the current benchmarking  run  (-w
              or -W mandatory). Each thread in the workgroup initializes its own chunk of the stream.

       <b>-l</b> <b>&lt;testname&gt;</b>
              list properties of a benchmark code.

       <b>-i</b> <b>&lt;iterations&gt;</b>
              Set the number of iterations per thread (optional)

       <b>-f</b> <b>&lt;filepath&gt;</b>
              Filepath for the dynamic generation of benchmarks. Default <a href="file:/tmp/.">/tmp/.</a> &lt;PID&gt; is always attached

</pre><h4><b>WORKGROUP</b> <b>SYNTAX</b></h4><pre>
       <b>&lt;thread_domain&gt;:&lt;size&gt;</b>  <b>[:&lt;num_threads&gt;[:&lt;chunk_size&gt;:&lt;stride&gt;]]</b>  <b>[-&lt;streamId&gt;:&lt;domain_id&gt;]</b>  with size in
       kB, MB or GB. The <b>&lt;thread_domain&gt;</b> defines where the threads are placed.  <b>&lt;size&gt;</b> is  the  total  data  set
       size for the benchmark, the allocated vectors in memory sum up to this size.  <b>&lt;num_threads&gt;</b> specifies how
       many  threads  are  used  in  the  <b>&lt;thread_domain&gt;.</b>   Threads are always placed using a compact policy in
       <b>likwid-bench.</b>  This means that per default all SMT threads are used. Optionally similar a the  expression
       based  syntax  in  <b>likwid-pin</b>  a  <b>&lt;chunk_size&gt;</b>  and <b>&lt;stride&gt;</b> can be provided. Optionally for every stream
       (array, vector) the placement can  be  controlled.  Per  default  all  arrays  are  placed  in  the  same
       <b>&lt;thread_domain&gt;</b> the threads are running in. To place the data in a different domain for every stream of a
       benchmark  case  (the  total  number of streams can be acquired by the <b>-l</b> option) the domain to place the
       data in can be specified. Multiple streams are comma separated. Either the placement is provided  or  all
       streams  have  to  be  explicitly  placed.  Please  refer  to  the Wiki pages on <b>https://github.com/RRZE-</b>
       <b>HPC/likwid/wiki/Likwid-Bench</b> for further details and examples on usage.  With -W each thread  initializes
       its own chunk of the streams but pleacement of the streams is deactivated.

</pre><h4><b>EXAMPLE</b></h4><pre>
       1.  Run the <b>copy</b> benchmark on socket 0 ( <b>S0</b> ) with a total data set size of <b>100kB.</b>

       <b>likwid-bench</b> <b>-t</b> <b>copy</b> <b>-w</b> <b>S0:100kB</b>

       Since  no  <b>&lt;num_threads&gt;</b>  is  given in the workload expression, each hardware thread of socket 0 gets one
       application thread. The workload is split up  between  all  threads  and  the  number  of  iterations  is
       determined automatically.

       2.  Run the <b>triad</b> benchmark code with explicitly <b>100</b> iterations per thread with <b>2</b> threads on the socket 0
           ( <b>S0</b> ) and a data size of <b>1GB.</b>

       <b>likwid-bench</b> <b>-t</b> <b>triad</b> <b>-i</b> <b>100</b> <b>-w</b> <b>S0:1GB:2:1:2</b>

       Assuming  socket  0  (  <b>S0</b>  ) has 2 physical hardware threads with SMT enabled, hence in total 4 hardware
       threads, one thread is assigned to each physical hardware thread of socket 0.

       3.  Run the <b>update</b> benchmark on socket 0 ( <b>S0</b> ) with a workload of <b>100kB</b> and on socket 1 ( <b>S1</b> ) with  the
           same workload.

       <b>likwid-bench</b> <b>-t</b> <b>update</b> <b>-w</b> <b>S0:100kB</b> <b>-w</b> <b>S1:100kB</b>

       The  results  of  both  workgroups  are  combinded  for  the output. Hence the workload in each workgroup
       expression should have the same size.

       4.  Run  the  <b>copy</b>  benchmark  but  measure  the  memory  traffic  with   <b>likwid-perfctr.</b>    The   option
           <b>INSTRUMENT_BENCH</b> in <b>config.mk</b> needs to be true at compile time to use that feature.

       <b>likwid-perfctr</b> <b>-c</b> <b>E:S0:4</b> <b>-g</b> <b>MEM</b> <b>-m</b> <b>likwid-bench</b> <b>-t</b> <b>update</b> <b>-w</b> <b>S0:100kB</b>

       <b>likwid-perfctr</b>  will configure and start the performance counters on socket 0 ( <b>S0</b> ) with 4 threads prior
       to the execution of <b>likwid-bench.</b>  The performance counters are read right before and after  running  the
       benchmarking code to minimize the interferences of the measurement.

       5.  Run the <b>copy</b> benchmark and place the data on another socket

       <b>likwid-bench</b> <b>-t</b> <b>copy</b> <b>-w</b> <b>S0:1GB:10:1:2-0:S1,1:S1</b>

       Stream  id  0  and  1  are  placed  in  thread domains <b>S1,</b> which is socket 1. This can be verified as the
       initialization threads output where they are running.

</pre><h4><b>WARNING</b></h4><pre>
       Since LIKWID 5.0, it is possible to have different numbers of threads in workgroups. Also different sizes
       are allowed. Both features seem promising, but they show a range of problems. If you have a  NUMA  system
       and  run  with  multiple  threads on NUMA node 0 but with less on NUMA node 1, the threads on NUMA node 1
       cause less preassure on the memory interface and consequently achieve higher throughput. They will finish
       early compared to the threads on NUMA node 0. The runtime used for caluclating the bandwidth and MFlops/s
       values use the maximal runtime of all threads, hence one of NUMA node 0.   Similar  problems  exist  with
       different  sizes.  One  workgroup  might  run  in  cache  while  the other waits for data from the memory
       interface.

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Thomas Gruber &lt;<a href="mailto:thomas.roehl@googlemail.com">thomas.roehl@googlemail.com</a>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       Report Bugs on &lt;https://github.com/RRZE-HPC/likwid/issues&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/likwid-perfctr.1.html">likwid-perfctr</a>(1), <a href="../man1/likwid-pin.1.html">likwid-pin</a>(1), <a href="../man1/likwid-topology.1.html">likwid-topology</a>(1), <a href="../man1/likwid-setFrequencies.1.html">likwid-setFrequencies</a>(1)

likwid-5                                           09.12.2024                                    <u><a href="../man1/LIKWID-BENCH.1.html">LIKWID-BENCH</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>