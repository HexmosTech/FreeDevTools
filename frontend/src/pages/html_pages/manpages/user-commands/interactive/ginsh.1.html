<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ginsh - GiNaC Interactive Shell</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/ginac-tools">ginac-tools_1.8.8-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ginsh - GiNaC Interactive Shell

</pre><h4><b>SYNPOSIS</b></h4><pre>
       <b>ginsh</b> [<u>file...</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>ginsh</b>  is an interactive frontend for the GiNaC symbolic computation framework.  It is intended as a tool
       for testing and experimenting with GiNaC's features, not as a  replacement  for  traditional  interactive
       computer algebra systems. Although it can do many things these traditional systems can do, ginsh provides
       no  programming  constructs like loops or conditional expressions. If you need this functionality you are
       advised to write your program in C++, using the "native" GiNaC class framework.

</pre><h4><b>USAGE</b></h4><pre>
   <b>INPUT</b> <b>FORMAT</b>
       After startup, ginsh displays a prompt ("&gt;  ")  signifying  that  it  is  ready  to  accept  your  input.
       Acceptable  input  are  numeric  or  symbolic  expressions consisting of numbers (e.g.  <b>42</b>, <b>2/3</b> or <b>0.17</b>),
       symbols (e.g.  <b>x</b> or <b>result</b>), mathematical operators like <b>+</b> and  <b>*</b>, and functions (e.g.  <b>sin</b>  or  <b>normal</b>).
       Every input expression must be terminated with either a semicolon (<b>;</b>) or a colon (<b>:</b>).  If terminated with
       a  semicolon,  ginsh  will  evaluate  the expression and print the result to stdout. If terminated with a
       colon, ginsh will only evaluate the expression but not print the result. It is possible to enter multiple
       expressions on one line. Whitespace (spaces, tabs, newlines) can be applied  freely  between  tokens.  To
       quit ginsh, enter <b>quit</b> or <b>exit</b>, or type an EOF (Ctrl-D) at the prompt.

   <b>COMMENTS</b>
       Anything following a double slash (<b>//</b>) up to the end of the line, and all lines starting with a hash mark
       (<b>#</b>) are treated as a comment and ignored.

   <b>NUMBERS</b>
       ginsh  accepts  numbers  in  the  usual decimal notations. This includes arbitrary precision integers and
       rationals as well as floating point numbers in  standard  or  scientific  notation  (e.g.   <b>1.2E6</b>).   The
       general  rule is that if a number contains a decimal point (<b>.</b>), it is an (inexact) floating point number;
       otherwise it is an (exact) integer or rational.  Integers can be specified in binary, octal,  hexadecimal
       or arbitrary (2-36) base by prefixing them with <b>#b</b>, <b>#o</b>, <b>#x</b>, or <b>#</b><u>n</u><b>R</b> , respectively.

   <b>SYMBOLS</b>
       Symbols  are  made  up  of  a  string  of  alphanumeric characters and the underscore (<b>_</b>), with the first
       character being non-numeric. E.g.  <b>a</b> and <b>mu_1</b> are acceptable symbol  names,  while  <b>2pi</b>  is  not.  It  is
       possible  to  use  symbols  with  the  same  names as functions (e.g.  <b>sin</b>); ginsh is able to distinguish
       between the two.

       Symbols can be assigned values by entering
              <u>symbol</u> <b>=</b> <u>expression</u><b>;</b>

       To unassign the value of an assigned symbol, type
              <b>unassign('</b><u>symbol</u><b>');</b>

       Assigned symbols are automatically evaluated (= replaced by their assigned value) when they are used.  To
       refer  to  the  unevaluated  symbol,  put  single  quotes  (<b>'</b>)  around  the name, as demonstrated for the
       "unassign" command above.

       Symbols are considered to be in the complex domain by default, i.e. they are treated as if they stand  in
       for  complex numbers. This behavior can be changed by using the keywords <b>real_symbols</b> and <b>complex_symbols</b>
       and affects all newly created symbols.

       The following symbols are pre-defined constants that cannot be assigned a value by the user:

              <b>Pi</b>      Archimedes' Constant

              <b>Catalan</b> Catalan's Constant

              <b>Euler</b>   Euler-Mascheroni Constant

              <b>I</b>       sqrt(-1)

              <b>FAIL</b>    an object of the GiNaC "fail" class

       There is also the special
              <b>Digits</b>
       symbol that controls the numeric precision of calculations with inexact numbers.   Assigning  an  integer
       value to digits will change the precision to the given number of decimal places.

   <b>WILDCARDS</b>
       The  has(),  find(), match() and subs() functions accept wildcards as placeholders for expressions. These
       have the syntax
              <b>$</b><u>number</u>
       for example $0, $1 etc.

   <b>LAST</b> <b>PRINTED</b> <b>EXPRESSIONS</b>
       ginsh provides the three special symbols
              %, %% and %%%
       that refer to the last, second last, and third last printed expression, respectively.  These are handy if
       you want to use the results of previous computations in a new expression.

   <b>OPERATORS</b>
       ginsh provides the following operators, listed in falling order of precedence:

              <b>!</b>       postfix factorial

              <b>^</b>       powering

              <b>+</b>       unary plus

              <b>-</b>       unary minus

              <b>*</b>       multiplication

              <b>/</b>       division

              <b>+</b>       addition

              <b>-</b>       subtraction

              <b>&lt;</b>       less than

              <b>&gt;</b>       greater than

              <b>&lt;=</b>      less or equal

              <b>&gt;=</b>      greater or equal

              <b>==</b>      equal

              <b>!=</b>      not equal

              <b>=</b>       symbol assignment

       All binary operators are left-associative, with the exception of <b>^</b> and <b>=</b> which are right-associative. The
       result of the assignment operator (<b>=</b>) is its right-hand side, so it's possible to assign multiple symbols
       in one expression (e.g.  <b>a</b> <b>=</b> <b>b</b> <b>=</b> <b>c</b> <b>=</b> <b>2;</b>).

   <b>LISTS</b>
       Lists are used by the <b>subs</b> and <b>lsolve</b> functions. A list  consists  of  an  opening  curly  brace  (<b>{</b>),  a
       (possibly empty) comma-separated sequence of expressions, and a closing curly brace (<b>}</b>).

   <b>MATRICES</b>
       A  matrix consists of an opening square bracket (<b>[</b>), a non-empty comma-separated sequence of matrix rows,
       and a closing square bracket (<b>]</b>).  Each matrix row consists of an opening square bracket (<b>[</b>), a non-empty
       comma-separated sequence of expressions, and a closing square bracket (<b>]</b>).  If the rows of a  matrix  are
       not  of  the  same  length,  the width of the matrix becomes that of the longest row and shorter rows are
       filled up at the end with elements of value zero.

   <b>FUNCTIONS</b>
       A function call in ginsh has the form
              <u>name</u><b>(</b><u>arguments</u><b>)</b>
       where <u>arguments</u> is a comma-separated sequence  of  expressions.  ginsh  provides  a  couple  of  built-in
       functions  and  also "imports" all symbolic functions defined by GiNaC and additional libraries. There is
       no way to define your own functions other than linking ginsh against  a  library  that  defines  symbolic
       GiNaC functions.

       ginsh  provides  Tab-completion on function names: if you type the first part of a function name, hitting
       Tab will complete the name if possible. If the part you typed is  not  unique,  hitting  Tab  again  will
       display  a  list  of  matching  functions.   Hitting Tab twice at the prompt will display the list of all
       available functions.

       A list of the built-in functions follows. They nearly all work as the respective  GiNaC  methods  of  the
       same name, so I will not describe them in detail here. Please refer to the GiNaC documentation.

              <b>charpoly(</b><u>matrix</u><b>,</b> <u>symbol</u><b>)</b> - characteristic polynomial of a matrix
              <b>coeff(</b><u>expression</u><b>,</b> <u>object</u><b>,</b> <u>number</u><b>)</b> - extracts coefficient of object^number from a polynomial
              <b>collect(</b><u>expression</u><b>,</b>  <u>object-or-list</u><b>)</b>  -  collects coefficients of like powers (result in recursive
              form)
              <b>collect_distributed(</b><u>expression</u><b>,</b>  <u>list</u><b>)</b>  -  collects  coefficients  of  like  powers   (result   in
              distributed form)
              <b>collect_common_factors(</b><u>expression</u><b>)</b> - collects common factors from the terms of sums
              <b>conjugate(</b><u>expression</u><b>)</b> - complex conjugation
              <b>content(</b><u>expression</u><b>,</b> <u>symbol</u><b>)</b> - content part of a polynomial
              <b>decomp_rational(</b><u>expression</u><b>,</b>  <u>symbol</u><b>)</b>  -  decompose  rational  function  into polynomial and proper
              rational function
              <b>degree(</b><u>expression</u><b>,</b> <u>object</u><b>)</b> - degree of a polynomial
              <b>denom(</b><u>expression</u><b>)</b> - denominator of a rational function
              <b>determinant(</b><u>matrix</u><b>)</b> - determinant of a matrix
              <b>diag(</b><u>expression...</u><b>)</b>  - constructs diagonal matrix
              <b>diff(</b><u>expression</u><b>,</b> <u>symbol</u> <u>[</u><b>,</b> <u>number]</u><b>)</b> - partial differentiation
              <b>divide(</b><u>expression</u><b>,</b> <u>expression</u><b>)</b> - exact polynomial division
              <b>evalf(</b><u>expression</u><b>)</b> - evaluates an expression to a floating point number
              <b>evalm(</b><u>expression</u><b>)</b> - evaluates sums, products and integer powers of matrices
              <b>expand(</b><u>expression</u><b>)</b> - expands an expression
              <b>factor(</b><u>expression</u><b>)</b> - factorizes an expression (univariate)
              <b>find(</b><u>expression</u><b>,</b> <u>pattern</u><b>)</b> - returns a list of all occurrences of a pattern in an expression
              <b>fsolve(</b><u>expression</u><b>,</b> <u>symbol</u><b>,</b> <u>number</u><b>,</b> <u>number</u><b>)</b> - numerically  find  root  of  a  real-valued  function
              within an interval
              <b>gcd(</b><u>expression</u><b>,</b> <u>expression</u><b>)</b> - greatest common divisor
              <b>has(</b><u>expression</u><b>,</b>  <u>pattern</u><b>)</b>  -  returns  "1"  if  the  first  expression  contains  the pattern as a
              subexpression, "0" otherwise
              <b>integer_content(</b><u>expression</u><b>)</b> - integer content of a polynomial
              <b>inverse(</b><u>matrix</u><b>)</b> - inverse of a matrix
              <b>is(</b><u>relation</u><b>)</b> - returns "1" if the relation is true, "0" otherwise (false or undecided)
              <b>lcm(</b><u>expression</u><b>,</b> <u>expression</u><b>)</b> - least common multiple
              <b>lcoeff(</b><u>expression</u><b>,</b> <u>object</u><b>)</b> - leading coefficient of a polynomial
              <b>ldegree(</b><u>expression</u><b>,</b> <u>object</u><b>)</b> - low degree of a polynomial
              <b>lsolve(</b><u>equation-list</u><b>,</b> <u>symbol-list</u><b>)</b> - solve system of linear equations
              <b>map(</b><u>expression</u><b>,</b> <u>pattern</u><b>)</b> - apply function to each operand; the function to be applied is specified
              as a pattern with the "$0" wildcard standing for the operands
              <b>match(</b><u>expression</u><b>,</b> <u>pattern</u><b>)</b> - check whether  expression  matches  a  pattern;  returns  a  list  of
              wildcard substitutions or "FAIL" if there is no match
              <b>nops(</b><u>expression</u><b>)</b> - number of operands in expression
              <b>normal(</b><u>expression</u><b>)</b> - rational function normalization
              <b>numer(</b><u>expression</u><b>)</b> - numerator of a rational function
              <b>numer_denom(</b><u>expression</u><b>)</b> - numerator and denumerator of a rational function as a list
              <b>op(</b><u>expression</u><b>,</b> <u>number</u><b>)</b> - extract operand from expression
              <b>power(</b><u>expr1</u><b>,</b> <u>expr2</u><b>)</b> - exponentiation (equivalent to writing expr1^expr2)
              <b>prem(</b><u>expression</u><b>,</b> <u>expression</u><b>,</b> <u>symbol</u><b>)</b> - pseudo-remainder of polynomials
              <b>primpart(</b><u>expression</u><b>,</b> <u>symbol</u><b>)</b> - primitive part of a polynomial
              <b>quo(</b><u>expression</u><b>,</b> <u>expression</u><b>,</b> <u>symbol</u><b>)</b> - quotient of polynomials
              <b>rank(</b><u>matrix</u><b>)</b> - rank of a matrix
              <b>rem(</b><u>expression</u><b>,</b> <u>expression</u><b>,</b> <u>symbol</u><b>)</b> - remainder of polynomials
              <b>resultant(</b><u>expression</u><b>,</b> <u>expression</u><b>,</b> <u>symbol</u><b>)</b> - resultant of two polynomials with respect to symbol s
              <b>series(</b><u>expression</u><b>,</b> <u>relation-or-symbol</u><b>,</b> <u>order</u><b>)</b> - series expansion
              <b>series_to_poly(</b><u>series</u><b>)</b> - convert a series into a polynomial by dropping the Order() term
              <b>sprem(</b><u>expression</u><b>,</b> <u>expression</u><b>,</b> <u>symbol</u><b>)</b> - sparse pseudo-remainder of polynomials
              <b>sqrfree(</b><u>expression</u> <u>[</u><b>,</b> <u>symbol-list]</u><b>)</b> - square-free factorization of a polynomial
              <b>sqrfree_parfrac(</b><u>expression</u><b>,</b>  <u>symbol</u><b>)</b>  -  square-free  partial  fraction  decomposition of rational
              function
              <b>sqrt(</b><u>expression</u><b>)</b> - square root
              <b>subs(</b><u>expression</u><b>,</b> <u>relation-or-list</u><b>)</b>
              <b>subs(</b><u>expression</u><b>,</b>  <u>look-for-list</u><b>,</b>  <u>replace-by-list</u><b>)</b>  -  substitute  subexpressions  (you  may   use
              wildcards)
              <b>tcoeff(</b><u>expression</u><b>,</b> <u>object</u><b>)</b> - trailing coefficient of a polynomial
              <b>time(</b><u>expression</u><b>)</b> - returns the time in seconds needed to evaluate the given expression
              <b>trace(</b><u>matrix</u><b>)</b> - trace of a matrix
              <b>transpose(</b><u>matrix</u><b>)</b> - transpose of a matrix
              <b>unassign(</b><u>'symbol'</u><b>)</b> - unassign an assigned symbol (mind the quotes, please!)
              <b>unit(</b><u>expression</u><b>,</b> <u>symbol</u><b>)</b> - unit part of a polynomial

   <b>SPECIAL</b> <b>COMMANDS</b>
       To exit ginsh, enter
              <b>quit</b>
       or
              <b>exit</b>

       ginsh can display a (short) help for a given topic (mostly about functions and operators) by entering
              <b>?</b><u>topic</u>
       Typing
              <b>??</b>
       will display a list of available help topics.

       The command
              <b>print(</b><u>expression</u><b>);</b>
       will  print  a  dump  of  GiNaC's  internal  representation for the given <u>expression</u>.  This is useful for
       debugging and for learning about GiNaC internals.

       The command
              <b>print_latex(</b><u>expression</u><b>);</b>
       prints a LaTeX representation of the given <u>expression</u>.

       The command
              <b>print_csrc(</b><u>expression</u><b>);</b>
       prints the given <u>expression</u> in a way that can be used in a C or C++ program.

       The command
              <b>iprint(</b><u>expression</u><b>);</b>
       prints the given <u>expression</u> (which must evaluate to  an  integer)  in  decimal,  octal,  and  hexadecimal
       representations.

       Finally, the shell escape
              <b>!</b>  [<u>command</u>  [<u>arguments</u>]]
       passes  the  given <u>command</u> and optionally <u>arguments</u> to the shell for execution. With this method, you can
       execute shell commands from within ginsh without having to quit.

</pre><h4><b>EXAMPLES</b></h4><pre>
       &gt; a = x^2-x-2;
       -2-x+x^2
       &gt; b = (x+1)^2;
       (x+1)^2
       &gt; s = a/b;
       (x+1)^(-2)*(-2-x+x^2)
       &gt; diff(s, x);
       (2*x-1)*(x+1)^(-2)-2*(x+1)^(-3)*(-x+x^2-2)
       &gt; normal(s);
       (x-2)*(x+1)^(-1)
       &gt; x = 3^50;
       717897987691852588770249
       &gt; s;
       717897987691852588770247/717897987691852588770250
       &gt; Digits = 40;
       40
       &gt; evalf(s);
       0.999999999999999999999995821133292704384960990679
       &gt; unassign('x');
       x
       &gt; s;
       (x+1)^(-2)*(-x+x^2-2)
       &gt; series(sin(x),x==0,6);
       1*x+(-1/6)*x^3+1/120*x^5+Order(x^6)
       &gt; lsolve({3*x+5*y == 7}, {x, y});
       {x==-5/3*y+7/3,y==y}
       &gt; lsolve({3*x+5*y == 7, -2*x+10*y == -5}, {x, y});
       {x==19/8,y==-1/40}
       &gt; M = [ [a, b], [c, d] ];
       [[-x+x^2-2,(x+1)^2],[c,d]]
       &gt; determinant(M);
       -2*d-2*x*c-x^2*c-x*d+x^2*d-c
       &gt; collect(%, x);
       (-d-2*c)*x+(d-c)*x^2-2*d-c
       &gt; solve quantum field theory;
       parse error at quantum
       &gt; quit

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       parse error at <u>foo</u>
              You entered something which ginsh was unable to parse. Please check the syntax of your  input  and
              try again.

       argument <u>num</u> to <u>function</u> must be a <u>type</u>
              The  argument  number  <u>num</u>  to  the  given <u>function</u> must be of a certain type (e.g. a symbol, or a
              list). The first argument has number 0, the second argument number 1, etc.

</pre><h4><b>AUTHOR</b></h4><pre>
       The GiNaC maintainers &lt;https://www.ginac.de/&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       GiNaC Tutorial - An open framework for symbolic computation within the C++ programming language

       CLN - A Class Library for Numbers, Bruno Haible

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 1999-2025 Johannes Gutenberg Universität Mainz, Germany

       This program is free software; you can redistribute it and/or modify  it  under  the  terms  of  the  GNU
       General  Public License as published by the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful, but WITHOUT ANY  WARRANTY;  without  even
       the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
       License for more details.

       You should have received a copy of the GNU General Public License along with this program; if not,  write
       to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

GiNaC 1.8.8                                       January, 2000                                         <u><a href="../man1/ginsh.1.html">ginsh</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>