<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v.cluster  - Performs cluster identification.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>v.cluster</b>  - Performs cluster identification.

</pre><h4><b>KEYWORDS</b></h4><pre>
       vector, point cloud, cluster, clump, level1

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>v.cluster</b>
       <b>v.cluster</b> <b>--help</b>
       <b>v.cluster</b>    [-<b>2bt</b>]    <b>input</b>=<u>name</u>    <b>output</b>=<u>name</u>    [<b>layer</b>=<u>string</u>]     [<b>distance</b>=<u>float</u>]     [<b>min</b>=<u>integer</u>]
       [<b>method</b>=<u>string</u>]   [--<b>overwrite</b>]  [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-2</b>
           Force 2D clustering

       <b>-b</b>
           Do not build topology
           Advantageous when handling a large number of points

       <b>-t</b>
           Do not create attribute table

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>input</b>=<u>name</u> <b>[required]</b>
           Name of input vector map
           Or data source for direct OGR access

       <b>output</b>=<u>name</u> <b>[required]</b>
           Name for output vector map

       <b>layer</b>=<u>string</u>
           Layer number or name for cluster ids
           Vector features can have category values in different layers. This number determines which  layer  to
           use. When used with direct OGR access this is the layer name.
           Default: <u>2</u>

       <b>distance</b>=<u>float</u>
           Maximum distance to neighbors

       <b>min</b>=<u>integer</u>
           Minimum number of points to create a cluster

       <b>method</b>=<u>string</u>
           Clustering method
           Options: <u>dbscan,</u> <u>dbscan2,</u> <u>density,</u> <u>optics,</u> <u>optics2</u>
           Default: <u>dbscan</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>v.cluster</u> partitions a point cloud into clusters or clumps.

       If  the  minimum  number  of points is not specified with the <b>min</b> option, the minimum number of points to
       constitute a cluster is <u>number</u> <u>of</u> <u>dimensions</u> <u>+</u> <u>1</u>, i.e. 3 for 2D points and 4 for 3D points.

       If the maximum distance is not specified with the <b>distance</b> option, the maximum distance is estimated from
       the observed distances to the neighbors using the upper 99% confidence interval.

       <u>v.cluster</u> supports different methods for clustering. The recommended methods  are  <b>method=dbscan</b>  if  all
       clusters  should  have  a  density  (maximum  distance  between  points)  not  larger  than  <b>distance</b>  or
       <b>method=density</b> if clusters should be created separately  for  each  observed  density  (distance  to  the
       farthest neighbor).

   <b>Clustering</b> <b>methods</b>
   <b>dbscan</b> <b>method</b>
       The  Density-Based Spatial Clustering of Applications with Noise is a commonly used clustering algorithm.
       A new cluster is started for a point with at least <u>min</u> - 1 neighbors within the maximum  distance.  These
       neighbors  are  added  to the cluster. The cluster is then expanded as long as at least <u>min</u> - 1 neighbors
       are within the maximum distance for each point already in the cluster.

   <b>dbscan2</b> <b>method</b>
       Similar to <u>dbscan</u>, but here it is sufficient if the resultant cluster consists of at  least  <b>min</b>  points,
       even if no point in the cluster has at least <u>min</u> <u>-</u> <u>1</u> neighbors within <b>distance</b>.

   <b>density</b> <b>method</b>
       This method creates clusters according to their point density. The maximum distance is not used. Instead,
       the  points  are  sorted ascending by the distance to their farthest neighbor (core distance), inspecting
       <u>min</u> <u>-</u> <u>1</u> neighbors. The densest cluster is created first, using as threshold the core distance of the seed
       point. The cluster is expanded as for DBSCAN, with the difference that each cluster has its  own  maximum
       distance. This method can identify clusters with different densities and can create nested clusters.

   <b>optics</b> <b>method</b>
       This  method  is  Ordering Points to Identify the Clustering Structure. It is controlled by the number of
       neighbor points (option <u>min</u> - 1). The core distance of a point is the distance to the farthest  neighbor.
       The  reachability  of  a  point  <u>q</u> is its distance from a point <u>p</u> (original optics: max(core-distance(p),
       distance(p, q))). The aim of the <u>optics</u> method  is  to  reduce  the  reachability  of  each  point.  Each
       unprocessed  point  is  the seed for a new cluster. Its neighbors are added to a queue sorted by smallest
       reachability if their reachability can be reduced.  The points in  the  queue  are  processed  and  their
       unprocessed  neighbors  are added to a queue sorted by smallest reachability if their reachability can be
       reduced.

       The <u>optics</u> method does not create clusters itself, but produces an ordered list of  the  points  together
       with their reachability. The output list is ordered according to the order of processing: the first point
       processed  is  the  first  in the list, the last point processed is the last in the list. Clusters can be
       extracted from this list by identifying valleys in the points’ reachability, e.g. by  using  a  threshold
       value.  If  a  maximum distance is specified, this is used to identify clusters, otherwise each separated
       network will constitute a cluster.

       The OPTICS algorithm uses each yet unprocessed point to start a new  cluster.  The  order  of  the  input
       points is arbitrary and can thus influence the resultant clusters.

   <b>optics2</b> <b>method</b>
       <b>EXPERIMENTAL</b>  This  method  is  similar  to OPTICS, minimizing the reachability of each point. Points are
       reconnected if their reachability can be reduced. Contrary to OPTICS, a cluster’s seed is not  fixed  but
       changed  if possible. Each point is connected to another point until the core of the cluster (seed point)
       is reached.  Effectively, the initial seed is updated in the process. Thus separated networks  of  points
       are created, with each network representing a cluster. The maximum distance is not used.

</pre><h4><b>NOTES</b></h4><pre>
       By default, cluster IDs are stored as category values of the points in layer 2.

</pre><h4><b>EXAMPLE</b></h4><pre>
       Analysis of random points for areas in areas of the vector <u>urbanarea</u> (North Carolina sample dataset).

       First generate 1000 random points within the areas the vector urbanarea and within the subregion, then do
       clustering and visualize the result:
       # pick a subregion of the vector urbanarea
       g.region -p n=272950 s=188330 w=574720 e=703090 res=10
       # create random points in areas
       v.random output=random_points npoints=1000 restrict=urbanarea
       # identify clusters
       v.cluster input=random_points output=clusters_optics method=optics
       # set random vector color table for the clusters
       v.colors map=clusters_optics layer=2 use=cat color=random
       # display in command line
       d.mon wx0
       # note the second layer and transparent (none) color of the circle border
       d.vect map=clusters_optics layer=2 icon=basic/point size=10 color=none

        <u>Figure:</u> <u>Four</u> <u>different</u> <u>methods</u> <u>with</u> <u>default</u> <u>settings</u> <u>applied</u> <u>to</u> <u>1000</u> <u>random</u> <u>points</u> <u>generated</u> <u>in</u> <u>the</u> <u>same</u>
       <u>way</u>  <u>as</u>  <u>in</u> <u>the</u> <u>example.</u>  Generate random points for analysis (100 points per area), use different method
       for clustering and visualize using color stored the attribute table.
       # pick a subregion of the vector urbanarea
       g.region -p n=272950 s=188330 w=574720 e=703090 res=10
       # create clustered points
       v.random output=rand_clust npoints=100 restrict=urbanarea -a
       # identify clusters
       v.cluster in=rand_clust out=rand_clusters method=dbscan
       # create colors for clusters
       v.db.addtable map=rand_clusters layer=2 columns="cat integer,grassrgb <a href="../man11/varchar.11.html">varchar</a>(11)"
       v.colors map=rand_clusters layer=2 use=cat color=random rgb_column=grassrgb
       # display with your preferred method
       # remember to use the second layer and RGB column
       # for example use
       d.vect map=rand_clusters layer=2 color=none rgb_column=grassrgb icon=basic/circle

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>r.clump,</u> <u>v.hull,</u> <u>v.distance</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Markus Metz

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: v.cluster source code (history)

       Accessed: Friday Apr 04 01:20:13 2025

       Main index | Vector index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                    <u><a href="../man1grass/v.cluster.1grass.html">v.cluster</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>