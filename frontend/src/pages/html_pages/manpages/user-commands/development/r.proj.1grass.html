<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>r.proj  - Re-projects a raster map from given project to the current project.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>r.proj</b>  - Re-projects a raster map from given project to the current project.

</pre><h4><b>KEYWORDS</b></h4><pre>
       raster, projection, transformation, import

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>r.proj</b>
       <b>r.proj</b> <b>--help</b>
       <b>r.proj</b>    [-<b>lnpg</b>]    <b>project</b>=<u>name</u>     [<b>mapset</b>=<u>name</u>]      [<b>input</b>=<u>name</u>]      [<b>dbase</b>=<u>path</u>]     [<b>output</b>=<u>name</u>]
       [<b>method</b>=<u>string</u>]    [<b>memory</b>=<u>memory</u>  <u>in</u>  <u>MB</u>]     [<b>resolution</b>=<u>float</u>]     [<b>pipeline</b>=<u>string</u>]     [--<b>overwrite</b>]
       [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-l</b>
           List raster maps in input mapset and exit

       <b>-n</b>
           Do  not  perform  region cropping optimization. See Notes if working with a global latitude-longitude
           projection

       <b>-p</b>
           Print input map’s bounds in the current projection and exit

       <b>-g</b>
           Print input map’s bounds in the current projection and exit (shell style)

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>project</b>=<u>name</u> <b>[required]</b>
           Project (location) containing input raster map
           Project name (not path to project)

       <b>mapset</b>=<u>name</u>
           Mapset containing input raster map
           Default: name of current mapset

       <b>input</b>=<u>name</u>
           Name of input raster map to re-project

       <b>dbase</b>=<u>path</u>
           Path to GRASS database of input project
           Default: path to the current GRASS GIS database

       <b>output</b>=<u>name</u>
           Name for output raster map (default: same as ’input’)

       <b>method</b>=<u>string</u>
           Interpolation method to use
           Options: <u>nearest,</u> <u>bilinear,</u> <u>bicubic,</u> <u>lanczos,</u> <u>bilinear_f,</u> <u>bicubic_f,</u> <u>lanczos_f</u>
           Default: <u>nearest</u>
           <b>nearest</b>: nearest neighbor
           <b>bilinear</b>: bilinear interpolation
           <b>bicubic</b>: bicubic interpolation
           <b>lanczos</b>: lanczos filter
           <b>bilinear_f</b>: bilinear interpolation with fallback
           <b>bicubic_f</b>: bicubic interpolation with fallback
           <b>lanczos_f</b>: lanczos filter with fallback

       <b>memory</b>=<u>memory</u> <u>in</u> <u>MB</u>
           Maximum memory to be used (in MB)
           Cache size for raster rows
           Default: <u>300</u>

       <b>resolution</b>=<u>float</u>
           Resolution of output raster map

       <b>pipeline</b>=<u>string</u>
           PROJ pipeline for coordinate transformation

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>r.proj</u> is used to reproject a raster map from the coordinate reference system (CRS) of the input  project
       into  a  CRS  of  a specified project (previously called location). The CRS information is taken from the
       current PROJ_INFO files, as set and viewed with <u>g.proj</u>.

   <b>Introduction</b>
   <b>Map</b> <b>projections</b>
       Map projections are a method of representing information from a curved surface (usually  a  spheroid)  in
       two  dimensions,  typically to allow indexing through cartesian coordinates.  There are a wide variety of
       projections,  with  common  ones  divided  into  a  number  of   classes,   including   cylindrical   and
       pseudo-cylindrical,  conic  and  pseudo-conic,  and  azimuthal  methods,  each of which may be conformal,
       equal-area, or neither.

       The particular projection chosen depends on the purpose of the project, and the size, shape and  location
       of  the  area  of  interest.   For example, normal cylindrical projections are good for maps which are of
       greater extent east-west than north-south and in equatorial regions, while conic projections  are  better
       in  mid-latitudes;  transverse  cylindrical  projections  are  used  for maps which are of greater extent
       north-south than east-west; azimuthal projections are used for polar regions.  Oblique versions of any of
       these may also be used.  Conformal  projections  preserve  angular  relationships,  and  better  preserve
       arc-length,  while  equal-area projections are more appropriate for statistical studies and work in which
       the amount of material is important.

       Projections are defined by precise mathematical relations, so the method of projecting coordinates from a
       geographic reference frame (latitude-longitude) into a projected cartesian reference frame (eg metres) is
       governed by these equations.  Inverse projections can also be achieved.  The public-domain Unix  software
       package  <u>PROJ</u>  [1]  has  been designed to perform these transformations, and the user’s manual contains a
       detailed description of over 100 useful projections.  This also includes a  programmers  library  of  the
       projection methods to support other software development.

       Thus,  converting a vector map - in which objects are located with arbitrary spatial precision - from one
       projection into another is usually accomplished by a simple two-step process: first the location  of  all
       the   points   in   the   map   are  converted  from  the  source  through  an  inverse  projection  into
       latitude-longitude, and then through a forward projection into the target.  (Of course the procedure will
       be one-step if either the source or target is in geographic coordinates.)

       Converting  a  raster  map,  or  image,  between  different  projections,  however,  involves  additional
       considerations.   A  raster  may be considered to represent a sampling of a process at a regular, ordered
       set of locations.  The set of locations that lie  at  the  intersections  of  a  cartesian  grid  in  one
       projection  will  not,  in  general,  coincide  with  the sample points in another projection.  Thus, the
       conversion of raster maps involves an interpolation step in which the values of  points  at  intermediate
       locations relative to the source grid are estimated.

   <b>Reprojecting</b> <b>vector</b> <b>maps</b> <b>within</b> <b>the</b> <b>GRASS</b> <b>GIS</b>
       GIS data capture, import and transfer often requires a reprojection step, since the source or client will
       frequently be in a different CRS to the working CRS.

       In some cases it is convenient to do the conversion outside the package, prior to import or after export,
       using software such as <u>PROJ</u>’s <u>cs2cs</u> [1]. This is an easy method for converting an ASCII file containing a
       list  of  coordinate  points, since there is no topology to be preserved and <u>cs2cs</u> can be used to process
       simple lists using a one-line command.  The <u>m.proj</u> module provides a handy front end to cs2cs.

       Vector maps is generally more complex, as parts of the data stored in the files will  describe  topology,
       and  not  just  coordinates.  In  GRASS  GIS  the  <u>v.proj</u>  module  is  provided to reproject vector maps,
       transferring topology and attributes as well as node coordinates.  This program uses the  CRS  definition
       and  parameters  which are stored in the PROJ_INFO and PROJ_UNITS files in the PERMANENT mapset directory
       for every GRASS project.

   <b>Design</b> <b>of</b> <b>r.proj</b>
       As discussed briefly above, the fundamental step in reprojecting a raster is resampling the  source  grid
       at  locations  corresponding  to  the  intersections of a grid in the target CRS. The basic procedure for
       accomplishing this, therefore, is as follows:

       <u>r.proj</u> converts a map to a new CRS. It reads a map from a different project, reprojects it and writes  it
       out to the current project. The reprojected data is resampled with one of four different methods: nearest
       neighbor, bilinear, bicubic interpolation or lanczos.

       The  <b>method=nearest</b>  method,  which  performs  a nearest neighbor assignment, is the fastest of the three
       resampling methods. It is primarily used for categorical data such as a land use classification, since it
       will not change the values of the data cells. The <b>method=bilinear</b> method determines the new value of  the
       cell based on a weighted distance average of the 4 surrounding cells in the input map. The <b>method=bicubic</b>
       method  determines  the  new value of the cell based on a weighted distance average of the 16 surrounding
       cells in the input map. The <b>method=lanczos</b> method determines the  new  value  of  the  cell  based  on  a
       weighted distance average of the 25 surrounding cells in the input map. Compared to bicubic, lanczos puts
       a  higher weight on cells close to the center and a lower weight on cells away from the center, resulting
       in slightly better contrast.

       The bilinear, bicubic and lanczos interpolation methods are most  appropriate  for  continuous  data  and
       cause  some  smoothing.  The  amount  of  smoothing  decreases from bilinear to bicubic to lanczos. These
       options should not be used with categorical data, since the cell values will be altered.

       In the bilinear, bicubic and lanczos methods, if any of the surrounding cells used to interpolate the new
       cell value are NULL, the resulting cell will be NULL, even if the nearest cell is  not  NULL.  This  will
       cause  some  thinning  along  NULL  borders,  such  as the coasts of land areas in a DEM. The <b>bilinear_f</b>,
       <b>bicubic_f</b> and <b>lanczos_f</b> interpolation methods can be used if thinning along NULL edges  is  not  desired.
       These  methods "fall back" to simpler interpolation methods along NULL borders.  That is, from lanczos to
       bicubic to bilinear to nearest.

       If nearest neighbor assignment is used, the output map has the same raster format as the  input  map.  If
       any of the interpolations is used, the output map is written as floating point.

       Note  that,  following normal GRASS conventions, the coverage and resolution of the resulting grid is set
       by the current region settings, which  may  be  adjusted  using  <u>g.region</u>.  The  target  raster  will  be
       relatively  unbiased  for  all  cases  if  its  grid  has a similar resolution to the source, so that the
       resampling/interpolation step is only a local operation.  If the  resolution  is  changed  significantly,
       then  the  behaviour  of  the  generalisation or refinement will depend on the model of the process being
       represented.  This will be very different for categorical versus numerical data.  Note that three methods
       for the local interpolation step are provided.

       <u>r.proj</u> supports general datum transformations, making use of  the  <u>PROJ</u>  co-ordinate  system  translation
       library.

</pre><h4><b>NOTES</b></h4><pre>
       If <b>output</b> is not specified it is set to be the same as input map name.
       If <b>mapset</b> is not specified, its name is assumed to be the same as the current mapset’s name.
       If <b>dbase</b> is not specified it is assumed to be the current database. The user only has to specify <b>dbase</b> if
       the source project is stored in another separate GRASS database.

       To  avoid  excessive  time  consumption  when  reprojecting a map the region and resolution of the target
       project should be set appropriately beforehand.

       A simple way to do this is to check the projected bounds of the input map in the  current  project’s  CRS
       using the <b>-p</b> flag. The <b>-g</b> flag reports the same thing, but in a form which can be directly cut and pasted
       into  a  <u>g.region</u>  command. After setting the region in that way you might check the cell resolution with
       "<u>g.region</u> <u>-p</u>" then snap it to a regular grid with <u>g.region</u>’s <b>-a</b> flag. E.g.  g.region -a  res=5  -p.  Note
       that this is just a rough guide.

       A more involved, but more accurate, way to do this is to generate a vector "box" map of the region in the
       source  project  using  <u>v.in.region</u>  <u>-d</u>.  This "box" map is then reprojected into the target project with
       <u>v.proj</u>. Next the region in the target project is set to the extent of the new vector  map  with  <u>g.region</u>
       along  with  the  desired  raster  resolution  (<u>g.region</u> <u>-m</u> can be used in Latitude/Longitude projects to
       measure the geodetic length of a pixel).  <u>r.proj</u> is then run  for  the  raster  map  the  user  wants  to
       reproject.  In this case a little preparation goes a long way.

       When reprojecting whole-world maps the user should disable map-trimming with the <b>-n</b> flag. Trimming is not
       useful  here  because the module has the whole map in memory anyway. Besides that, world "edges" are hard
       (or impossible) to find in CRSs other than latitude-longitude so results may be odd with trimming.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Inline</b> <b>method</b>
       With GRASS running in the destination project use the <b>-g</b>  flag  to  show  the  input  map’s  bounds  once
       reprojected  into  the  current working CRS, then use that to set the region bounds before performing the
       reprojection:
       # calculate where output map will be
       r.proj input=elevation project=ll_wgs84 mapset=user1 -p
       Source cols: 8162
       Source rows: 12277
       Local north: -4265502.30382993
       Local south: -4473453.15255565
       Local west: 14271663.19157564
       Local east: 14409956.2693866
       # same calculation, but in a form which can be cut and pasted into a g.region call
       r.proj input=elevation project=ll_wgs84 mapset=user1 -g
       n=-4265502.30382993 s=-4473453.15255565 w=14271663.19157564 e=14409956.2693866 rows=12277 cols=8162
       g.region n=-4265502.30382993 s=-4473453.15255565 \
         w=14271663.19157564 e=14409956.2693866 rows=12277 cols=8162 -p
       projection: 99 (Mercator)
       zone:       0
       datum:      wgs84
       ellipsoid:  wgs84
       north:      -4265502.30382993
       south:      -4473453.15255565
       west:       14271663.19157564
       east:       14409956.2693866
       nsres:      16.93824621
       ewres:      16.94352828
       rows:       12277
       cols:       8162
       cells:      100204874
       # round resolution to something cleaner
       g.region res=17 -a -p
       projection: 99 (Mercator)
       zone:       0
       datum:      wgs84
       ellipsoid:  wgs84
       north:      -4265487
       south:      -4473465
       west:       14271653
       east:       14409965
       nsres:      17
       ewres:      17
       rows:       12234
       cols:       8136
       cells:      99535824
       # finally, perform the reprojection
       r.proj input=elevation project=ll_wgs84 mapset=user1 memory=800

   <b>v.in.region</b> <b>method</b>
       # In the source project, use v.in.region to generate a bounding box around the
       # region of interest:
       v.in.region -d output=bounds type=area
       # Now switch to the target project and import the vector bounding box
       # (you can run v.proj -l to get a list of vector maps in the source project):
       v.proj input=bounds project=source_project_name output=bounds_reprojected
       # Set the region in the target project with that of the newly-imported vector
       # bounds map, and align the resolution to the desired cell resolution of the
       # final, reprojected raster map:
       g.region vector=bounds_reprojected res=5 -a
       # Now reproject the raster into the target project
       r.proj input=elevation.dem output=elevation.dem.reproj \
         project=source_project_name mapset=PERMANENT res=5 method=bicubic

</pre><h4><b>REFERENCES</b></h4><pre>
       <b>1</b>      Evenden, G.I. (1990) Cartographic projection procedures  for  the  UNIX  environment  -  a  user’s
              manual.   USGS  Open-File  Report  90-284  (OF90-284.pdf)  See  also there: Interim Report and 2nd
              Interim Report on Release 4, Evenden 1994).

       <b>2</b>      Richards, John A. (1993), Remote Sensing Digital  Image  Analysis,  Springer-Verlag,  Berlin,  2nd
              edition.

       PROJ: Projection/datum support library

       <b>Further</b> <b>reading</b>

           •   ASPRS Grids and Datum

           •   Projections Transform List (PROJ)

           •   Coordinate operations by PROJ (projections, conversions, transformations, pipeline operator)

           •   MapRef - The Collection of Map Projections and Reference Systems for Europe

           •   Information and Service System for European Coordinate Reference Systems - CRS

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>g.region,</u> <u>g.proj,</u> <u>i.rectify,</u> <u>m.proj,</u> <u>r.support,</u> <u>r.stats,</u> <u>v.proj,</u> <u>v.in.region</u>

       The ’gdalwarp’ and ’gdal_translate’ utilities are available from the GDAL project.

</pre><h4><b>AUTHORS</b></h4><pre>
       Martin Schroeder, University of Heidelberg, Germany
       Man page text from S.J.D. Cox, AGCRC, CSIRO Exploration &amp; Mining, Nedlands, WA
       Updated by Morten Hulden
       Datum transformation support and cleanup by Paul Kelly
       Support of PROJ5+ by Markus Metz, mundialis

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: r.proj source code (history)

       Accessed: Friday Apr 04 01:19:25 2025

       Main index | Raster index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                       <u><a href="../man1grass/r.proj.1grass.html">r.proj</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>