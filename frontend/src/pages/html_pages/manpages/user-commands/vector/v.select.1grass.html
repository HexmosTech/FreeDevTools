<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v.select  - Selects features from vector map (A) by features from other vector map (B).</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>v.select</b>  - Selects features from vector map (A) by features from other vector map (B).

</pre><h4><b>KEYWORDS</b></h4><pre>
       vector, geometry, spatial query

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>v.select</b>
       <b>v.select</b> <b>--help</b>
       <b>v.select</b>  [-<b>tcr</b>] <b>ainput</b>=<u>name</u>  [<b>alayer</b>=<u>string</u>]   [<b>atype</b>=<u>string</u>[,<u>string</u>,...]]  <b>binput</b>=<u>name</u>  [<b>blayer</b>=<u>string</u>]
       [<b>btype</b>=<u>string</u>[,<u>string</u>,...]]   <b>output</b>=<u>name</u>  <b>operator</b>=<u>string</u>   [<b>relate</b>=<u>string</u>]    [--<b>overwrite</b>]    [--<b>help</b>]
       [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-t</b>
           Do not create attribute table

       <b>-c</b>
           Do not skip features without category

       <b>-r</b>
           Reverse selection

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>ainput</b>=<u>name</u> <b>[required]</b>
           Name of input vector map
           Input vector map from which to select features (A)

       <b>alayer</b>=<u>string</u>
           Layer number (vector map A)
           Vector  features  can have category values in different layers. This number determines which layer to
           use. When used with direct OGR access this is the layer name.
           Default: <u>1</u>

       <b>atype</b>=<u>string[,string</u>,...]
           Feature type (vector map A)
           Input feature type
           Options: <u>point,</u> <u>line,</u> <u>boundary,</u> <u>centroid,</u> <u>area</u>
           Default: <u>point,line,area</u>

       <b>binput</b>=<u>name</u> <b>[required]</b>
           Name of input vector map
           Query vector map (B)

       <b>blayer</b>=<u>string</u>
           Layer number (vector map B)
           Vector features can have category values in different layers. This number determines which  layer  to
           use. When used with direct OGR access this is the layer name.
           Default: <u>1</u>

       <b>btype</b>=<u>string[,string</u>,...]
           Feature type (vector map B)
           Input feature type
           Options: <u>point,</u> <u>line,</u> <u>boundary,</u> <u>centroid,</u> <u>area</u>
           Default: <u>point,line,area</u>

       <b>output</b>=<u>name</u> <b>[required]</b>
           Name for output vector map

       <b>operator</b>=<u>string</u> <b>[required]</b>
           Operator defines required relation between features
           A  feature is written to output if the result of operation ’ainput operator binput’ is true. An input
           feature is considered to be true, if category of given layer is defined.
           Options: <u>overlap,</u> <u>equals,</u> <u>disjoint,</u> <u>intersects,</u> <u>touches,</u> <u>crosses,</u> <u>within,</u> <u>contains,</u> <u>overlaps,</u> <u>relate</u>
           Default: <u>overlap</u>
           <b>overlap</b>: features partially or completely overlap
           <b>equals</b>: features are spatially equals (using GEOS)
           <b>disjoint</b>: features do not spatially intersect (using GEOS)
           <b>intersects</b>: features spatially intersect (using GEOS)
           <b>touches</b>: features spatially touches (using GEOS)
           <b>crosses</b>: features spatially crosses (using GEOS)
           <b>within</b>: feature A is completely inside feature B (using GEOS)
           <b>contains</b>: feature B is completely inside feature A (using GEOS)
           <b>overlaps</b>: features spatially overlap (using GEOS)
           <b>relate</b>: feature A is spatially related to feature B (using GEOS, requires ’relate’ option)

       <b>relate</b>=<u>string</u>
           Intersection Matrix Pattern used for ’relate’ operator

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>v.select</u> allows the user to select features from a vector map by features from another one.

       Supported operators (without GEOS; using GRASS’ own algorithm):

           •   <b>overlap</b> - features partially or completely overlap (GEOS equivalent: intersects)
       Supported operators (internally using GEOS - Geometry Engine, Open Source):

           •   <b>equals</b> - features are spatially equals

           •   <b>disjoint</b> - features do not spatially intersect

           •   <b>intersects</b> - features spatially intersect (equivalent to native ’overlap’)

           •   <b>touches</b> - features spatially touches

           •   <b>crosses</b> - features spatially crosses

           •   <b>within</b> - feature A is completely inside feature B

           •   <b>contains</b> - feature B is completely inside feature A

           •   <b>overlaps</b> - features spatially overlap

           •   <b>relate</b> - feature A is spatially related to feature B

</pre><h4><b>NOTES</b></h4><pre>
       Only features with category numbers will be considered. If required the <u>v.category</u> module can be used  to
       add  them.  Typically  boundaries  do not need to be given a category number, as an area’s attributes are
       inherited from the centroid. Typically points, lines, and centroids  will  always  want  to  have  a  cat
       number. E.g. take a road which separates two farms. It is ambiguous as to which farm an attribute that is
       attached to the road belongs to. The boundary only needs a cat number if it will hold its own attributes,
       such  as  road  name  or  pavement form. A centroid in each paddock holds the information with respect to
       ownership, area, etc.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Preparation of example data (North Carolina sample dataset):
       # Create an grid for overlaying to ZIP code vector map
       v.mkgrid map=boxgrid grid=10,10 position=coor \
                coordinates=583600,201500 box=5000,5000
       # set region to ZIP codes and boxgrid vector maps
       g.region vector=zipcodes_wake,boxgrid -p res=100 -a
       # enlarge region a bit for "white border" around map in monitor
       g.region n=n+1000 s=s-1000 w=w-1000 e=e+1000 -p
       d.mon wx0

   <b>OVERLAP:</b> <b>features</b> <b>partially</b> <b>or</b> <b>completely</b> <b>overlap</b> <b>(using</b> <b>GRASS)</b>
       Select grid boxes (North Carolina sample dataset):
       d.vect map=zipcodes_wake fill_color=0:128:0
       d.vect map=boxgrid fill_color=85:130:176
       v.select ainput=boxgrid binput=zipcodes_wake output=v_select_OVERLAP operator=overlap
       d.vect map=v_select_OVERLAP
       d.vect map=zipcodes_wake type=boundary color=255:255:50
       v.select with OVERLAP operator: selected grid boxes shown in yellow (using GRASS method)

   <b>OVERLAPS</b> <b>features</b> <b>spatially</b> <b>overlap</b> <b>(using</b> <b>GEOS)</b>
       Select grid boxes (North Carolina sample dataset):
       d.vect map=zipcodes_wake fill_color=0:128:0
       d.vect map=boxgrid fill_color=85:130:176
       v.select ainput=boxgrid binput=zipcodes_wake output=v_select_OVERLAPS operator=overlaps
       d.vect map=v_select_OVERLAPS
       d.vect map=zipcodes_wake type=boundary color=255:255:50
       v.select with OVERLAPS operator: selected grid boxes shown in yellow (using GEOS method)

   <b>DISJOINT:</b> <b>features</b> <b>do</b> <b>not</b> <b>spatially</b> <b>intersect</b> <b>(using</b> <b>GEOS)</b>
       Select grid boxes (North Carolina sample dataset):
       d.vect map=zipcodes_wake fill_color=0:128:0
       d.vect map=boxgrid fill_color=85:130:176
       v.select ainput=boxgrid binput=zipcodes_wake output=v_select_DISJOINT operator=disjoint
       d.vect map=v_select_DISJOINT
       d.vect map=zipcodes_wake type=boundary color=255:255:50
       v.select with DISJOINT operator: selected grid boxes shown in yellow

   <b>EQUALS:</b> <b>features</b> <b>are</b> <b>spatially</b> <b>equals</b> <b>(using</b> <b>GEOS)</b>
       Select zipcode polygon (North Carolina sample dataset):
       d.vect map=zipcodes_wake fill_color=0:128:0
       v.extract input=zipcodes_wake where=ZIPCODE_ID=35 output=zipcodeID35
       v.select ainput=zipcodes_wake binput=zipcodeID35 output=v_select_EQUALS operator=equals
       d.vect map=v_select_EQUALS
       d.vect map=zipcodes_wake type=boundary color=255:255:50
       v.select with EQUALS operator: selected grid boxes shown in yellow

   <b>INTERSECTS:</b> <b>features</b> <b>spatially</b> <b>intersect</b> <b>(using</b> <b>GEOS)</b>
       Select zipcode polygons (North Carolina sample dataset):
       d.vect map=zipcodes_wake fill_color=0:128:0
       d.vect map=boxgrid fill_color=85:130:176
       v.select ainput=zipcodes_wake binput=boxgrid output=v_select_INTERSECTS operator=intersects
       d.vect map=v_select_INTERSECTS
       d.vect map=boxgrid type=boundary color=255:255:50
       v.select with INTERSECTS operator: selected grid boxes shown in yellow

   <b>TOUCHES:</b> <b>features</b> <b>spatially</b> <b>touches</b> <b>(using</b> <b>GEOS)</b>
       Select polygons (North Carolina sample dataset):
       d.vect map=zipcodes_wake fill_color=0:128:0
       d.vect map=zipcodeID35 fill_color=85:130:176
       v.select ainput=zipcodes_wake binput=zipcodeID35 output=v_select_TOUCHES operator=touches
       d.vect map=v_select_TOUCHES
       d.vect map=zipcodes_wake type=boundary color=255:255:50
       v.select with TOUCHES operator: selected polygons shown in yellow (blue: input polygon)

   <b>CROSSES:</b> <b>features</b> <b>spatially</b> <b>crosses</b> <b>(using</b> <b>GEOS)</b>
       Select zipcode polygons by lines (North Carolina sample dataset):
       d.vect map=zipcodes_wake fill_color=0:128:0
       d.vect map=busroute1 color=200:27:27 width=3
       v.select ainput=zipcodes_wake binput=busroute1 output=v_select_CROSSES operator=crosses
       d.vect map=v_select_CROSSES
       d.vect map=zipcodes_wake type=boundary color=255:255:50
       d.vect map=busroute1 color=200:27:27 width=3
       v.select with CROSSES operator: selected polygons shown in yellow (red: input lines)

   <b>WITHIN</b> <b>feature</b> <b>A</b> <b>is</b> <b>completely</b> <b>inside</b> <b>feature</b> <b>B</b> <b>(using</b> <b>GEOS)</b>
       Select zipcode polygons (North Carolina sample dataset):
       d.vect map=zipcodes_wake fill_color=0:128:0
       d.vect map=boundary_county fill_color=85:130:176
       v.select ainput=zipcodes_wake binput=boundary_county output=v_select_WITHIN operator=within
       d.vect map=v_select_WITHIN
       v.select with WITHIN operator: selected polygons shown in yellow (blue: input polygons)

   <b>CONTAINS</b> <b>feature</b> <b>B</b> <b>is</b> <b>completely</b> <b>inside</b> <b>feature</b> <b>A</b> <b>(using</b> <b>GEOS)</b>
       Select zipcode polygon (North Carolina sample dataset):

   <b>CONTAINS</b> <b>with</b> <b>polygons</b>
       d.vect map=zipcodes_wake fill_color=0:128:0
       d.vect map=zipcodeID35 fill_color=85:130:176
       v.select ainput=zipcodes_wake binput=zipcodeID35 \
                output=v_select_CONTAINS_pol operator=contains
       d.vect map=v_select_CONTAINS
       v.select with CONTAINS operator: selected polygon shown in yellow (blue: input polygon, not visible)

   <b>CONTAINS</b> <b>with</b> <b>points</b>
       d.vect map=zipcodes_wake fill_color=0:128:0
       d.vect map=hospitals fill_color=195:31:31 icon=basic/cross3 size=10
       v.select ainput=zipcodes_wake binput=hospitals \
                output=v_select_CONTAINS_pnts operator=contains
       d.vect map=v_select_CONTAINS_pnts
       d.vect map=hospitals fill_color=195:31:31 icon=basic/cross3 size=10
       v.select with CONTAINS operator: selected polygons shown in yellow (red: input points)

   <b>RELATE</b> <b>feature</b> <b>A</b> <b>is</b> <b>spatially</b> <b>related</b> <b>to</b> <b>feature</b> <b>B</b> <b>(using</b> <b>GEOS)</b>
       This operator additionally requires the  <b>relate</b>  parameter  (in  other  GIS  called  ’ST_Relate’).   This
       operator  allows  calculating  the  Dimensionally  Extended  nine-Intersection  Model  (DE-9IM).   In the
       following one example: Select polygon with ’TOUCHES’ operator (North Carolina sample dataset):
       d.vect map=zipcodes_wake fill_color=0:128:0
       d.vect map=zipcodeID35 fill_color=85:130:176
       v.select ainput=zipcodeID35 binput=zipcodes_wake \
                output=v_select_TOUCHES_relate operator=relate relate=’T********’
       d.vect map=v_select_TOUCHES
       The result of relate=’T********’ is the same as seen above in the example ’TOUCHES’.  See the DE-9IM page
       for related operators and their definition.

   <b>Extraction</b> <b>of</b> <b>points</b> <b>falling</b> <b>into</b> <b>a</b> <b>polygon</b>
       Extract fire stations (points) falling into urban area (polygon) - North  Carolina  data  set  (point  in
       polygon test):
       v.select ainput=firestations binput=urbanarea output=urban_firestations \
                operator=overlap

   <b>Extraction</b> <b>of</b> <b>lines</b> <b>overlapping</b> <b>with</b> <b>a</b> <b>polygon</b>
       Extract railroad lines from zip code map overlapping with the urban area (line in polygon test):
       v.select ainput=railroads binput=urbanarea \
                output=railroads_in_urbanarea operator=overlap

   <b>Extraction</b> <b>of</b> <b>areas</b> <b>overlapping</b> <b>with</b> <b>a</b> <b>line</b>
       Extract those areas from zip code map which overlap with railroads (polygon on line test):
       # first add a tiny buffer around railroad lines:
       v.buffer input=railroads output=railroads_buf20m \
         distance=20
       v.select ainput=zipcodes_wake binput=railroads_buf20m \
         output=zipcodes_wake_railroads operator=overlap

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>v.category,</u> <u>v.clip,</u> <u>v.overlay,</u> <u>v.extract</u>

       GRASS SQL interface
       GEOS - Geometry Engine, Open Source

</pre><h4><b>AUTHORS</b></h4><pre>
       Radim Blazek
       GEOS support by Martin Landa, Czech Technical University in Prague, Czech Republic
       ZIP code examples by Carol X. Garzon-Lopez, Trento, Italy

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: v.select source code (history)

       Accessed: Friday Apr 04 01:20:34 2025

       Main index | Vector index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                     <u><a href="../man1grass/v.select.1grass.html">v.select</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>