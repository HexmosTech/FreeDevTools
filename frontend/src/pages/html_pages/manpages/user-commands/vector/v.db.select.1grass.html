<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v.db.select  - Prints vector map attributes.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>v.db.select</b>  - Prints vector map attributes.

</pre><h4><b>KEYWORDS</b></h4><pre>
       vector, attribute table, database, SQL, export

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>v.db.select</b>
       <b>v.db.select</b> <b>--help</b>
       <b>v.db.select</b>    [-<b>rcef</b>]    <b>map</b>=<u>name</u>     [<b>layer</b>=<u>string</u>]     [<b>columns</b>=<u>name</u>[,<u>name</u>,...]]     [<b>where</b>=<u>sql_query</u>]
       [<b>group</b>=<u>string</u>]  <b>format</b>=<u>name</u>  [<b>separator</b>=<u>character</u>]   [<b>vertical_separator</b>=<u>character</u>]   [<b>null_value</b>=<u>string</u>]
       [<b>file</b>=<u>name</u>]   [--<b>overwrite</b>]  [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-r</b>
           Print minimal region extent of selected vector features instead of attributes

       <b>-c</b>
           Do not include column names in output

       <b>-e</b>
           Escape newline and backslash characters

       <b>-f</b>
           Exclude attributes not linked to features

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>map</b>=<u>name</u> <b>[required]</b>
           Name of vector map
           Or data source for direct OGR access

       <b>layer</b>=<u>string</u>
           Layer number or name
           Vector features can have category values in different layers. This number determines which  layer  to
           use. When used with direct OGR access this is the layer name.
           Default: <u>1</u>

       <b>columns</b>=<u>name[,name</u>,...]
           Name of attribute column(s)

       <b>where</b>=<u>sql_query</u>
           WHERE conditions of SQL statement without ’where’ keyword
           Example: income &lt; 1000 and population &gt;= 10000

       <b>group</b>=<u>string</u>
           GROUP BY conditions of SQL statement without ’group by’ keyword

       <b>format</b>=<u>name</u> <b>[required]</b>
           Output format
           Options: <u>plain,</u> <u>csv,</u> <u>json,</u> <u>vertical</u>
           Default: <u>plain</u>
           <b>plain</b>: Configurable plain text output
           <b>csv</b>: CSV (Comma Separated Values)
           <b>json</b>: JSON (JavaScript Object Notation)
           <b>vertical</b>: Plain text vertical output (instead of horizontal)

       <b>separator</b>=<u>character</u>
           Field separator
           Special characters: pipe, comma, space, tab, newline

       <b>vertical_separator</b>=<u>character</u>
           Output vertical record separator
           Special characters: pipe, comma, space, tab, newline

       <b>null_value</b>=<u>string</u>
           String representing NULL value

       <b>file</b>=<u>name</u>
           Name for output file (if omitted or "-" output to stdout)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>v.db.select</u> prints attributes of a vector map from one or several user selected attribute table columns.

   <b>Output</b> <b>formats</b>
       Four  different  formats  can be used depending on the circumstances using the <b>format</b> option: plain text,
       CSV, JSON, and vertical plain text.

   <b>Plain</b> <b>text</b>
       The plain text is the default output which is most suitable for reading by humans, e.g., when working  in
       the command line or obtaining specific values from the attribute table using the <u>v.db.select</u> GUI dialog.

       The  individual  fields  (attribute values) are separated by a pipe (|) which can be customized using the
       <b>separator</b> option.  The records (rows) are separated by newlines.

       Example with a pipe as a separator (the default):
       cat|road_name|multilane|year|length
       1|NC-50|no|2001|4825.369405
       2|NC-50|no|2002|14392.589058
       3|NC-98|no|2003|3212.981242
       4|NC-50|no|2004|13391.907552
       When escaping is enabled, the following characters in the fields are escaped:  backslash  (\\),  carriage
       return (\r), line feed (\n), tabulator (\t), form feed (\f), and backslash (\b).

       No  quoting or escaping is performed by default, so if these characters are in the output, they look just
       like the separators.  This is usually not a problem for humans looking at the output  to  get  a  general
       idea about query result or attribute table content.

       Consequently,  this  format  is not recommended for computers, e.g., for reading attribute data in Python
       scripts.  It works for further parsing in limited cases when the values don’t contain separators or  when
       the separators are set to one of the escaped characters.

   <b>CSV</b>
       CSV  (comma-separated  values) has many variations. This module by default produces CSV with comma (,) as
       the field separator (delimiter). All text fields (based on the  type)  are  quoted  with  double  quotes.
       Double  quotes  in  fields  are  represented  as  two double quotes. Newline characters in the fields are
       present as-is in the output. Header is included by default containing column names.

       All full CSV parsers such as the ones in LibreOffice or  Python  are  able  to  parse  this  format  when
       configured to the above specification.

       Example with default settings:
       cat,road_name,multilane,year,length
       1,"NC-50","no",2001,4825.369405
       2,"NC-50","no",2002,14392.589058
       3,"NC-98","no",2003,3212.981242
       4,"NC-50","no",2004,13391.907552

       If  desired,  the  separator can be customized and escaping can be enabled with the same characters being
       escaped as for the plain text.  Notably, newlines and tabs are escaped, double quotes are  not,  and  the
       separator  is  not  escaped  either (unless it is a tab).  However, the format is guaranteed only for the
       commonly used separators such as comma, semicolon, pipe, and tab.

       Note that using multi-character separator is  allowed,  but  not  recommended  as  it  is  not  generally
       supported by CSV readers.

       CSV is the recommended format for further use in another analytical applications, especially for use with
       spreadsheet  applications.  For  scripting,  it  is advantageous when tabular data is needed (rather than
       key-value pairs).

   <b>JSON</b>
       JSON (JavaScript Object Notation) format is produced according to the  specification  so  it  is  readily
       readable  by  JSON  parsers.   The  standard JSON escapes are performed (backslash, carriage return, line
       feed, tabulator, form feed, backslash, and double quote) for string values.  Numbers in the database such
       as integers and doubles are represented as numbers, while texts (TEXT, VARCHAR, etc.) and  dates  in  the
       database  are  represented  as  strings  in  JSON.  NULL values in database are represented as JSON null.
       Indentation and newlines in the output are minimal and not guaranteed.

       Records which are the result of the query are stored under key records as  an  array  (list)  of  objects
       (collections  of  key-value  pairs).  The keys for attributes are lowercase or uppercase depending on how
       the columns were defined in the database.

       The JSON also contains information about columns stored under key info. Column names and types are  under
       key  columns.   Each  column has SQL data type under sql_type in all caps.  A boolean is_number specifies
       whether the value is a number, i.e., integer or floating point number. The is_number value  is  aded  for
       convenience  and  it  is recommended to rely on the types derived from the JSON representation or the SQL
       types. The definition of is_number may change in the future.

       Example with added indentation:
       {
         "info": {
           "columns": [
             {
               "name": "road_name",
               "sql_type": "CHARACTER",
               "is_number": false
             },
             {
               "name": "year",
               "sql_type": "INTEGER",
               "is_number": true
             },
             {
               "name": "length",
               "sql_type": "DOUBLE PRECISION",
               "is_number": true
             }
           ]
         },
         "records": [
           {
             "road_name": "NC-50",
             "year": 2001,
             "length": 4825.369405
           },
           {
             "road_name": "NC-50",
             "year": 2001,
             "length": 14392.589058
           }
         ]
       }

       JSON is the recommended format for reading the data in Python and for any  uses  and  environments  where
       convenient access to individual values is desired and JSON parser is available.

   <b>Vertical</b> <b>plain</b> <b>text</b>
       In  the  vertical  plain  text  format, each value is on a single line and is preceded by the name of the
       attribute (column) which is separated by separator. The  individual  records  can  be  separated  by  the
       vertical separator (<b>vertical_separator</b> option).

       Example with (horizontal) separator = and vertical separator newline:
       cat=1
       road_name=NC-50
       multilane=no
       year=2001
       length=4825.369405
       cat=2
       road_name=NC-50
       multilane=no
       year=2002
       length=14392.589058
       Newline  is  automatically  added  after  a  vertical  separator  unless it is a newline which allows for
       separating the records, e.g., by multiple dashes.  The escaping (<b>-e</b>) need to should be  enabled  in  case
       the  output  is  meant for reading by a computer rather than just as a data overview for humans. Escaping
       will ensure that values with newlines will be contained to a single line.  This  format  is  for  special
       uses  in  scripting,  for example, in combination with <b>columns</b> option set to one column only and escaping
       (<b>-e</b>) and no column names flags (<b>-c</b>). It  is  also  advantageous  when  you  need  implement  the  parsing
       yourself.

</pre><h4><b>NOTES</b></h4><pre>
           •   CSV  and JSON were added in version 8.0 as new primary formats for further consumption by scripts
               and other applications.

           •   Escaping of plain and vertical formats was extended from  just  backslash  and  newlines  to  all
               escapes from JSON except for double quote character.

</pre><h4><b>EXAMPLES</b></h4><pre>
       All examples are based on the North Carolina sample dataset.

   <b>Select</b> <b>and</b> <b>show</b> <b>entire</b> <b>table</b>
       v.db.select map=roadsmajor
       cat|MAJORRDS_|ROAD_NAME|MULTILANE|PROPYEAR|OBJECTID|SHAPE_LEN
       1|1|NC-50|no|0|1|4825.369405
       2|2|NC-50|no|0|2|14392.589058
       3|3|NC-98|no|0|3|3212.981242
       4|4|NC-50|no|0|4|13391.907552
       ...

   <b>Select</b> <b>and</b> <b>show</b> <b>single</b> <b>column</b> <b>from</b> <b>table</b>
       Note: multiple columns can be specified as comma separated list.
       v.db.select map=roadsmajor column=ROAD_NAME
       NC-50
       NC-50
       NC-98
       NC-50
       NC-98
       ...

   <b>Print</b> <b>region</b> <b>extent</b> <b>of</b> <b>selected</b> <b>vector</b> <b>features</b>
       v.db.select -r map=roadsmajor where="ROAD_NAME = ’NC-98’"
       n=248425.389891
       s=245640.640081
       w=635906.517653
       e=661979.801880

   <b>Select</b> <b>empty</b> <b>vector</b> <b>features</b> <b>(no</b> <b>data</b> <b>entries)</b>
       v.db.select geonames_wake where="ALTERNATEN IS NULL"
       cat|GEONAMEID|NAME|ASCIINAME|ALTERNATEN|FEATURECLA|FEATURECOD|...
       8|4498303|West Raleigh|West Raleigh||P|PPL|US||NC|338759|123|...
       14|4459467|Cary|Cary||P|PPL|US||NC|103945|146|152|America/Iqaluit|...
       31|4452808|Apex|Apex||P|PPL|US||NC|30873|167|134|America/Iqaluit|...
       ...

   <b>Select</b> <b>not</b> <b>empty</b> <b>vector</b> <b>features</b> <b>(no</b> <b>data</b> <b>entries)</b>
       v.db.select geonames_wake where="ALTERNATEN IS NOT NULL"
       cat|GEONAMEID|NAME|ASCIINAME|ALTERNATEN|FEATURECLA|FEATURECOD|...
       9|4487042|Raleigh|Raleigh|Raleigh,...
       31299|4487056|Raleigh-Durham Airport|Raleigh-Durham Airport|...
       ...

   <b>Select</b> <b>features</b> <b>with</b> <b>distinct</b> <b>road</b> <b>names</b>
       v.db.select map=roadsmajor columns=ROAD_NAME group=ROAD_NAME
       ROAD_NAME
       I-40
       I-440
       I-540
       NC-231
       NC-39
       NC-42
       ...
       It is also possible to combine with <u>where</u> option
       v.db.select map=roadsmajor columns=ROAD_NAME,MULTILANE group=ROAD_NAME where=’ROAD_NAME is not null’
       ROAD_NAME|MULTILANE
       I-40|yes
       I-440|yes
       I-540|yes
       NC-231|no
       NC-39|no
       NC-42|no
       NC-50|no
       NC-54|no
       NC-55|no
       NC-96|no
       NC-97|no
       NC-98|no
       US-1|
       US-401|no
       US-64|yes
       US-70|yes
       It can also use more columns in <u>group</u> option
       v.db.select map=roadsmajor columns=ROAD_NAME,MULTILANE group=ROAD_NAME,MULTILANE where=’ROAD_NAME is not null’
       ROAD_NAME|MULTILANE
       I-40|yes
       I-440|yes
       I-540|yes
       NC-231|no
       NC-39|no
       NC-42|no
       NC-50|no
       NC-54|no
       NC-55|no
       NC-96|no
       NC-97|no
       NC-98|no
       US-1|
       US-1|yes
       US-401|no
       US-401|yes
       US-64|yes
       US-70|yes

   <b>Read</b> <b>results</b> <b>in</b> <b>Python</b>
       The  <u>json</u>  package  in  the  standard  Python  library can load a JSON string obtained as output from the
       <u>v.db.select</u> module through the <u>read_command</u> function:
       import json
       import grass.script as gs
       text = gs.read_command("v.db.select", map="roadsmajor", format="json")
       data = json.loads(text)
       for row in data["records"]:
           print(row["ROAD_NAME"])

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>db.select</u>

        <u>GRASS</u> <u>SQL</u> <u>interface</u>

</pre><h4><b>AUTHORS</b></h4><pre>
       Radim Blazek, ITC-Irst, Trento, Italy
       Minimal region extent added by Martin Landa, FBK-irst (formerly ITC-irst), Trento, Italy
       Group option added by Luca Delucchi, Fondazione Edmund Mach, Trento, Italy
       Huidae Cho (JSON output, escaping and features-only flags)
       Vaclav Petras (true CSV output, format option and documentation)

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: v.db.select source code (history)

       Accessed: Friday Apr 04 01:20:13 2025

       Main index | Vector index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                  <u><a href="../man1grass/v.db.select.1grass.html">v.db.select</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>