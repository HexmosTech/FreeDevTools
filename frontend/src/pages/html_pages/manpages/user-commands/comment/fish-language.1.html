<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shells  like  fish  are  used  by  giving them commands. A command is executed by writing the name of the</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/fish-common">fish-common_4.0.1-1_all</a> <br><br><pre>
</pre><h4><b>SYNTAX</b> <b>OVERVIEW</b></h4><pre>
       Shells  like  fish  are  used  by  giving them commands. A command is executed by writing the name of the
       command followed by any arguments. For example:

          echo hello world

       <u>echo</u> command writes its arguments to the screen. In this example the output is <b>hello</b> <b>world</b>.

       Everything in fish is done with commands. There are commands for repeating other commands,  commands  for
       assigning  variables,  commands  for  treating a group of commands as a single command, etc. All of these
       commands follow the same basic syntax.

       Every program on your computer can be used as a command in fish. If the program file is located in one of
       the <u>PATH</u> directories, you can just type the name of the program to use it. Otherwise the whole  filename,
       including the directory (like <b>/home/me/code/checkers/checkers</b> or <b>../checkers</b>) is required.

       Here is a list of some useful commands:

       • <u>cd</u>: Change the current directory

       • <b>ls</b>: List files and directories

       • <b>man</b>:  Display a manual page - try <b>man</b> <b>ls</b> to get help on your "ls" command, or <b>man</b> <b>mv</b> to get information
         about "mv".

       • <b>mv</b>: Move (rename) files

       • <b>cp</b>: Copy files

       • <u>open</u>: Open files with the default application associated with each filetype

       • <b>less</b>: Display the contents of files

       Commands and arguments are separated by the space character <b>'</b> <b>'</b>. Every command ends with either a newline
       (by pressing the return key) or a semicolon <b>;</b>. Multiple commands can be  written  on  the  same  line  by
       separating them with semicolons.

       A switch is a very common special type of argument. Switches almost always start with one or more hyphens
       <b>-</b>  and alter the way a command operates. For example, the <b>ls</b> command usually lists the names of all files
       and directories in the current working directory. By using the <b>-l</b> switch, the behavior of <b>ls</b>  is  changed
       to  not  only  display the filename, but also the size, permissions, owner, and modification time of each
       file.

       Switches differ between commands and are usually documented on a command's manual page.  There  are  some
       switches,  however,  that  are  common  to most commands. For example, <b>--help</b> will usually display a help
       text, <b>--version</b> will usually display the command version, and <b>-i</b> will often turn on interactive prompting
       before taking action. Try <b>man</b> <b>your-command-here</b> to get information on your command's switches.

       So the basic idea of fish is the same as with other unix shells: It gets a commandline, runs  <u>expansions</u>,
       and the result is then run as a command.

</pre><h4><b>TERMINOLOGY</b></h4><pre>
       Here we define some of the terms used on this page and throughout the rest of the fish documentation:

       • <b>Argument</b>: A parameter given to a command. In <b>echo</b> <b>foo</b>, the "foo" is an argument.

       • <b>Builtin</b>:  A  command that is implemented by the shell. Builtins are so closely tied to the operation of
         the shell that it is impossible to implement them as external commands. In <b>echo</b> <b>foo</b>, the  "echo"  is  a
         builtin.

       • <b>Command</b>: A program that the shell can run, or more specifically an external program that the shell runs
         in another process. External commands are provided on your system, as executable files. In <b>echo</b> <b>foo</b> the
         "echo"  is a builtin command, in <b>command</b> <b>echo</b> <b>foo</b> the "echo" is an external command, provided by a file
         like /bin/echo.

       • <b>Function</b>: A block of commands that can be called as if they were a single command. By using  functions,
         it is possible to string together multiple simple commands into one more advanced command.

       • <b>Job</b>: A running pipeline or command.

       • <b>Pipeline</b>:  A set of commands strung together so that the output of one command is the input of the next
         command. <b>echo</b> <b>foo</b> <b>|</b> <b>grep</b> <b>foo</b> is a pipeline.

       • <b>Redirection</b>: An operation that changes one of the input or output streams associated with a job.

       • <b>Switch</b> or <b>Option</b>: A special kind of argument that alters the behavior of a  command.  A  switch  almost
         always begins with one or two hyphens. In <b>echo</b> <b>-n</b> <b>foo</b> the "-n" is an option.

</pre><h4><b>QUOTES</b></h4><pre>
       Sometimes you want to give a command an argument that contains characters special to fish, like spaces or
       <b>$</b> or <b>*</b>. To do that, you can use quotes:

          rm "my file.txt"

       to remove a file called <b>my</b> <b>file.txt</b> instead of trying to remove two files, <b>my</b> and <b>file.txt</b>.

       Fish understands two kinds of quotes: Single (<b>'</b>) and double (<b>"</b>), and both work slightly differently.

       Between  single  quotes,  fish performs no expansions. Between double quotes, fish only performs <u>variable</u>
       <u>expansion</u> and <u>command</u> <u>substitution</u> in the  <b>$(command)</b>.  No  other  kind  of  expansion  (including  <u>brace</u>
       <u>expansion</u>  or  parameter  expansion)  is  performed,  and escape sequences (for example, <b>\n</b>) are ignored.
       Within quotes, whitespace is not used to separate arguments, allowing quoted arguments to contain spaces.

       The only meaningful escape sequences in single quotes are <b>\'</b>, which escapes a single quote and <b>\\</b>,  which
       escapes the backslash symbol. The only meaningful escapes in double quotes are <b>\"</b>, which escapes a double
       quote, <b>\$</b>, which escapes a dollar character, <b>\</b> followed by a newline, which deletes the backslash and the
       newline, and <b>\\</b>, which escapes the backslash symbol.

       Single quotes have no special meaning within double quotes and vice versa.

       More examples:

          grep 'enabled)$' foo.txt

       searches  for  lines  ending  in <b>enabled)</b> in <b>foo.txt</b> (the <b>$</b> is special to <b>grep</b>: it matches the end of the
       line).

          apt install "postgres-*"

       installs all packages with a name starting with "postgres-",  instead  of  looking  through  the  current
       directory for files named "postgres-something".

</pre><h4><b>ESCAPING</b> <b>CHARACTERS</b></h4><pre>
       Some  characters  cannot  be written directly on the command line. For these characters, so-called escape
       sequences are provided. These are:

       • <b>\a</b> represents the alert character.

       • <b>\e</b> represents the escape character.

       • <b>\f</b> represents the form feed character.

       • <b>\n</b> represents a newline character.

       • <b>\r</b> represents the carriage return character.

       • <b>\t</b> represents the tab character.

       • <b>\v</b> represents the vertical tab character.

       • <b>\xHH</b> or <b>\XHH</b>, where <b>HH</b> is a hexadecimal number, represents a byte of data with the specified value. For
         example, <b>\x9</b> is the tab character. If you are using a multibyte encoding, this can  be  used  to  enter
         invalid  strings.  Typically fish is run with the ASCII or UTF-8 encoding, so anything up to <b>\X7f</b> is an
         ASCII character.

       • <b>\ooo</b>, where <b>ooo</b> is an octal number, represents the  ASCII  character  with  the  specified  value.  For
         example, <b>\011</b> is the tab character. The highest allowed value is <b>\177</b>.

       • <b>\uXXXX</b>,  where <b>XXXX</b> is a hexadecimal number, represents the 16-bit Unicode character with the specified
         value. For example, <b>\u9</b> is the tab character.

       • <b>\UXXXXXXXX</b>, where <b>XXXXXXXX</b> is a hexadecimal number, represents the 32-bit Unicode  character  with  the
         specified value. For example, <b>\U9</b> is the tab character. The highest allowed value is U10FFFF.

       • <b>\cX</b>,  where  <b>X</b>  is  a letter of the alphabet, represents the control sequence generated by pressing the
         control key and the specified letter. For example, <b>\ci</b> is the tab character

       Some characters have special meaning to the shell. For example, an apostrophe <b>'</b> disables  expansion  (see
       <u>Quotes</u>).  To  tell  the  shell  to  treat  these  characters literally, escape them with a backslash. For
       example, the command:

          echo \'hello world\'

       outputs <b>'hello</b> <b>world'</b> (including the apostrophes), while the command:

          echo 'hello world'

       outputs <b>hello</b> <b>world</b> (without the apostrophes). In the former case the shell  treats  the  apostrophes  as
       literal <b>'</b> characters, while in the latter case it treats them as special expansion modifiers.

       The special characters and their escape sequences are:

       • <b>\</b>   (backslash space) escapes the space character. This keeps the shell from splitting arguments on the
         escaped space.

       • <b>\$</b> escapes the dollar character.

       • <b>\\</b> escapes the backslash character.

       • <b>\*</b> escapes the star character.

       • <b>\?</b> escapes the question mark character (this is not necessary  if  the  <b>qmark-noglob</b>  <u>feature</u>  <u>flag</u>  is
         enabled).

       • <b>\~</b> escapes the tilde character.

       • <b>\#</b> escapes the hash character.

       • <b>\(</b> escapes the left parenthesis character.

       • <b>\)</b> escapes the right parenthesis character.

       • <b>\{</b> escapes the left curly bracket character.

       • <b>\}</b> escapes the right curly bracket character.

       • <b>\[</b> escapes the left bracket character.

       • <b>\]</b> escapes the right bracket character.

       • <b>\&lt;</b> escapes the less than character.

       • <b>\&gt;</b> escapes the more than character.

       • <b>\&amp;</b> escapes the ampersand character.

       • <b>\|</b> escapes the vertical bar character.

       • <b>\;</b> escapes the semicolon character.

       • <b>\"</b> escapes the quote character.

       • <b>\'</b> escapes the apostrophe character.

       As  a  special  case,  <b>\</b> immediately followed by a literal new line is a "continuation" and tells fish to
       ignore the line break and resume input at the start of the next line (without introducing any  whitespace
       or terminating a token).

</pre><h4><b>INPUT/OUTPUT</b> <b>REDIRECTION</b></h4><pre>
       Most programs use three input/output (I/O) streams:

       • Standard input (stdin) for reading. Defaults to reading from the keyboard.

       • Standard output (stdout) for writing output. Defaults to writing to the screen.

       • Standard error (stderr) for writing errors and warnings. Defaults to writing to the screen.

       Each stream has a number called the file descriptor (FD): 0 for stdin, 1 for stdout, and 2 for stderr.

       The  destination of a stream can be changed using something called <u>redirection</u>. For example, <b>echo</b> <b>hello</b> <b>&gt;</b>
       <b>output.txt</b>, redirects the standard output of the <b>echo</b> command to a text file.

       • To read standard input from a file, use <b>&lt;SOURCE_FILE</b>.

       • To read standard input from a file or /dev/null if it can't be read, use <b>&lt;?SOURCE_FILE</b>.

       • To write standard output to a file, use <b>&gt;DESTINATION</b>.

       • To write standard error to a file, use <b>2&gt;DESTINATION</b>. [1]

       • To append standard output to a file, use <b>&gt;&gt;DESTINATION_FILE</b>.

       • To append standard error to a file, use <b>2&gt;&gt;DESTINATION_FILE</b>.

       • To not overwrite ("clobber") an existing file, use <b>&gt;?DESTINATION</b> or <b>2&gt;?DESTINATION</b>. This  is  known  as
         the "noclobber" redirection.

       <b>DESTINATION</b> can be one of the following:

       • A  filename  to  write  the  output to. Often <b>&gt;/dev/null</b> to silence output by writing it to the special
         "sinkhole" file.

       • An ampersand (<b>&amp;</b>) followed by the number of another file descriptor like  <b>&amp;2</b>  for  standard  error.  The
         output will be written to the destination descriptor.

       • An  ampersand  followed  by a minus sign (<b>&amp;-</b>). The file descriptor will be closed. Note: This may cause
         the program to fail because its writes will be unsuccessful.

       As a convenience, the redirection <b>&amp;&gt;</b>  can  be  used  to  direct  both  stdout  and  stderr  to  the  same
       destination.  For  example,  <b>echo</b>  <b>hello</b>  <b>&amp;&gt;</b>  <b>all_output.txt</b> redirects both stdout and stderr to the file
       <b>all_output.txt</b>. This is equivalent to <b>echo</b> <b>hello</b> <b>&gt;</b> <b>all_output.txt</b> <b>2&gt;&amp;1</b>.

       Any arbitrary file descriptor can be used in a redirection by  prefixing  the  redirection  with  the  FD
       number.

       • To redirect the input of descriptor N, use <b>N&lt;DESTINATION</b>.

       • To redirect the output of descriptor N, use <b>N&gt;DESTINATION</b>.

       • To append the output of descriptor N to a file, use <b>N&gt;&gt;DESTINATION_FILE</b>.

       File descriptors cannot be used with a <b>&lt;?</b> input redirection, only a regular <b>&lt;</b> one.

       For example:

          # Write `foo`'s standard error (file descriptor 2)
          # to a file called "output.stderr":
          foo 2&gt; output.stderr

          # if $num doesn't contain a number,
          # this test will be false and print an error,
          # so by ignoring the error we can be sure that we're dealing
          # with a number in the "if" block:
          if test "$num" -gt 2 2&gt;/dev/null
              # do things with $num as a number greater than 2
          else
              # do things if $num is &lt;= 2 or not a number
          end

          # Save `make`s output in a file:
          make &amp;&gt;/log

          # Redirections stack and can be used with blocks:
          begin
              echo stdout
              echo stderr &gt;&amp;2 # &lt;- this goes to stderr!
          end &gt;/dev/null # ignore stdout, so this prints "stderr"

          # print all lines that include "foo" from myfile, or nothing if it doesn't exist.
          string match '*foo*' &lt;?myfile

       It  is  an  error to redirect a builtin, function, or block to a file descriptor above 2. However this is
       supported for external commands.

       [1]  Previous versions of fish also allowed specifying  this  as  <b>^DESTINATION</b>,  but  that  made  another
            character special so it was deprecated and removed. See <u>feature</u> <u>flags</u>.

</pre><h4><b>PIPING</b></h4><pre>
       Another  way to redirect streams is a <u>pipe</u>. A pipe connects streams with each other. Usually the standard
       output of one command is connected with the standard  input  of  another.  This  is  done  by  separating
       commands with the pipe character <b>|</b>. For example:

          cat foo.txt | head

       The command <b>cat</b> <b>foo.txt</b> sends the contents of <b>foo.txt</b> to stdout. This output is provided as input for the
       <b>head</b> program, which prints the first 10 lines of its input.

       It  is  possible  to  pipe  a different output file descriptor by prepending its FD number and the output
       redirect symbol to the pipe. For example:

          make fish 2&gt;| less

       will attempt to build <b>fish</b>, and any errors will be shown using the <b>less</b> pager. [2]

       As a convenience, the pipe <b>&amp;|</b> redirects both stdout and stderr to the same  process.  This  is  different
       from bash, which uses <b>|&amp;</b>.

       [2]  A  "pager"  here  is  a program that takes output and "paginates" it. <b>less</b> doesn't just do pages, it
            allows arbitrary scrolling (even back!).

</pre><h4><b>COMBINING</b> <b>PIPES</b> <b>AND</b> <b>REDIRECTIONS</b></h4><pre>
       It is possible to use multiple redirections and a pipe at the same time. In that case, they are  read  in
       this order:

       1. First the pipe is set up.

       2. Then the redirections are evaluated from left-to-right.

       This is important when any redirections reference other file descriptors with the <b>&amp;N</b> syntax. When you say
       <b>&gt;&amp;2</b>, that will redirect stdout to where stderr is pointing to <u>at</u> <u>that</u> <u>time</u>.

       Consider this helper function:

          # Just make a function that prints something to stdout and stderr
          function print
              echo out
              echo err &gt;&amp;2
          end

       Now let's see a few cases:

          # Redirect both stderr and stdout to less
          print 2&gt;&amp;1 | less
          # or
          print &amp;| less

          # Show the "out" on stderr, silence the "err"
          print &gt;&amp;2 2&gt;/dev/null

          # Silence both
          print &gt;/dev/null 2&gt;&amp;1

</pre><h4><b>JOB</b> <b>CONTROL</b></h4><pre>
       When  you  start  a  job in fish, fish itself will pause, and give control of the terminal to the program
       just started. Sometimes, you want to continue using  the  commandline,  and  have  the  job  run  in  the
       background.  To  create a background job, append an <b>&amp;</b> (ampersand) to your command. This will tell fish to
       run the job in the background. Background jobs  are  very  useful  when  running  programs  that  have  a
       graphical user interface.

       Example:

          emacs &amp;

       will  start the emacs text editor in the background. <u>fg</u> can be used to bring it into the foreground again
       when needed.

       Most programs allow you to suspend the program's execution and return control to fish by pressing  <b>ctrl-z</b>
       (also referred to as <b>^Z</b>). Once back at the fish commandline, you can start other programs and do anything
       you want. If you then want you can go back to the suspended command by using the <u>fg</u> (foreground) command.

       If you instead want to put a suspended job into the background, use the <u>bg</u> command.

       To  get  a listing of all currently started jobs, use the <u>jobs</u> command.  These listed jobs can be removed
       with the <u>disown</u> command.

       At the moment, functions cannot be started in  the  background.  Functions  that  are  stopped  and  then
       restarted in the background using the <u>bg</u> command will not execute correctly.

       If  the  <b>&amp;</b>  character  is  followed  by  a  non-separating character, it is not interpreted as background
       operator. Separating characters are whitespace and the characters <b>;&lt;&gt;&amp;|</b>.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       Functions are programs written in the fish  syntax.  They  group  together  various  commands  and  their
       arguments using a single name.

       For example, here's a simple function to list directories:

          function ll
              ls -l $argv
          end

       The  first line tells fish to define a function by the name of <b>ll</b>, so it can be used by simply writing <b>ll</b>
       on the commandline. The second line tells fish that the command <b>ls</b> <b>-l</b> <b>$argv</b> should be called when  <b>ll</b>  is
       invoked.  <u>$argv</u>  is  a  <u>list</u>  <u>variable</u>,  which always contains all arguments sent to the function. In the
       example above, these are simply passed on to the  <b>ls</b>  command.  The  <b>end</b>  on  the  third  line  ends  the
       definition.

       Calling this as <b>ll</b> <b><a href="file:/tmp/">/tmp/</a></b> will end up running <b>ls</b> <b>-l</b> <b><a href="file:/tmp/">/tmp/</a></b>, which will list the contents of /tmp.

       This is a kind of function known as an <u>alias</u>.

       Fish's prompt is also defined in a function, called <u>fish_prompt</u>. It is run when the prompt is about to be
       displayed and its output forms the prompt:

          function fish_prompt
              # A simple prompt. Displays the current directory
              # (which fish stores in the $PWD variable)
              # and then a user symbol - a '►' for a normal user and a '#' for root.
              set -l user_char '►'
              if fish_is_root_user
                  set user_char '#'
              end

              echo (set_color yellow)$PWD (set_color purple)$user_char
          end

       To edit a function, you can use <u>funced</u>, and to save a function <u>funcsave</u>. This will store it in a function
       file that fish will <u>autoload</u> when needed.

       The  <u>functions</u>  builtin  can  show  a  function's  current  definition  (and <u>type</u> will also do if given a
       function).

       For more information on functions, see the documentation for the <u>function</u> builtin.

   <b>Defining</b> <b>aliases</b>
       One of the most common uses for functions is to slightly  alter  the  behavior  of  an  already  existing
       command. For example, one might want to redefine the <b>ls</b> command to display colors. The switch for turning
       on colors on GNU systems is <b>--color=auto</b>. An alias around <b>ls</b> might look like this:

          function ls
              command ls --color=auto $argv
          end

       There are a few important things that need to be noted about aliases:

       • Always take care to add the <u>$argv</u> variable to the list of parameters to the wrapped command. This makes
         sure  that  if  the user specifies any additional parameters to the function, they are passed on to the
         underlying command.

       • If the alias has the same name as the aliased command, you need to prefix the call to the program  with
         <b>command</b> to tell fish that the function should not call itself, but rather a command with the same name.
         If  you  forget  to  do so, the function would call itself until the end of time. Usually fish is smart
         enough to figure this out and will refrain from doing so (which is hopefully in your interest).

       To easily create a function of this form, you can use the <u>alias</u> command. Unlike other shells,  this  just
       makes  functions - fish has no separate concept of an "alias", we just use the word for a simple wrapping
       function like this. <u>alias</u> immediately creates a function. Consider using <b>alias</b> <b>--save</b> or <u>funcsave</u> to save
       the created function into an autoload file instead of recreating the alias each time.

       For an alternative, try <u>abbreviations</u>. These are words that are expanded while you type, instead of being
       actual functions inside the shell.

   <b>Autoloading</b> <b>functions</b>
       Functions can be defined  on  the  commandline  or  in  a  configuration  file,  but  they  can  also  be
       automatically loaded. This has some advantages:

       • An autoloaded function becomes available automatically to all running shells.

       • If  the  function  definition  is  changed,  all  running  shells will automatically reload the altered
         version, after a while.

       • Startup time and memory usage is improved, etc.

       When fish needs  to  load  a  function,  it  searches  through  any  directories  in  the  <u>list</u>  <u>variable</u>
       <b>$fish_function_path</b>  for  a file with a name consisting of the name of the function plus the suffix <b>.fish</b>
       and loads the first it finds.

       For example if you try to execute something called <b>banana</b>,  fish  will  go  through  all  directories  in
       $fish_function_path looking for a file called <b>banana.fish</b> and load the first one it finds.

       By default <b>$fish_function_path</b> contains the following:

       • A  directory for users to keep their own functions, usually <b><a href="file:~/.config/fish/functions">~/.config/fish/functions</a></b> (controlled by the
         <b>XDG_CONFIG_HOME</b> environment variable).

       • A  directory  for  functions  for  all  users  on  the  system,  usually  <b>/etc/fish/functions</b>   (really
         <b>$__fish_sysconfdir/functions</b>).

       • Directories  for  other  software  to  put  their  own  functions.  These  are in the directories under
         <b>$__fish_user_data_dir</b>  (usually  <b><a href="file:~/.local/share/fish">~/.local/share/fish</a></b>,  controlled  by  the  <b>XDG_DATA_HOME</b>   environment
         variable)    and    in   the   <b>XDG_DATA_DIRS</b>   environment   variable,   in   a   subdirectory   called
         <b>fish/vendor_functions.d</b>.     The     default     value      for      <b>XDG_DATA_DIRS</b>      is      usually
         <b>/usr/share/fish/vendor_functions.d</b> and <b>/usr/local/share/fish/vendor_functions.d</b>.

       • The   functions   shipped   with   fish,   usually   installed   in  <b>/usr/share/fish/functions</b>  (really
         <b>$__fish_data_dir/functions</b>).

       If you are unsure, your functions probably belong in <b><a href="file:~/.config/fish/functions">~/.config/fish/functions</a></b>.

       As we've explained, autoload files are loaded <u>by</u> <u>name</u>, so, while you can put multiple functions into  one
       file, the file will only be loaded automatically once you try to execute the one that shares the name.

       Autoloading  also won't work for <u>event</u> <u>handlers</u>, since fish cannot know that a function is supposed to be
       executed when an event occurs when it hasn't yet loaded the function. See the <u>event</u> <u>handlers</u> section  for
       more information.

       If a file of the right name doesn't define the function, fish will not read other autoload files, instead
       it  will  go  on  to  try  builtins and finally commands. This allows masking a function defined later in
       $fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you  want
       to skip.

       If  you  are  developing  another  program and want to install fish functions for it, install them to the
       "vendor" functions directory. As this path varies from  system  to  system,  you  can  use  <b>pkgconfig</b>  to
       discover  it  with the output of <b>pkg-config</b> <b>--variable</b> <b>functionsdir</b> <b>fish</b>. Your installation system should
       support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.

</pre><h4><b>COMMENTS</b></h4><pre>
       Anything after a <b>#</b> until the end of the line is a comment.  That  means  it's  purely  for  the  reader's
       benefit, fish ignores it.

       This is useful to explain what and why you are doing something:

          function ls
              # The function is called ls,
              # so we have to explicitly call `command ls` to avoid calling ourselves.
              command ls --color=auto $argv
          end

       There  are  no  multiline  comments. If you want to make a comment span multiple lines, simply start each
       line with a <b>#</b>.

       Comments can also appear after a line like so:

          set -gx EDITOR emacs # I don't like vim.

</pre><h4><b>CONDITIONS</b></h4><pre>
       Fish has some builtins that let you execute commands only if a specific criterion is met: <u>if</u>, <u>switch</u>, <u>and</u>
       and <u>or</u>, and also the familiar <u>&amp;&amp;/||</u> syntax.

   <b>The</b> <b>if</b> <b>statement</b>
       The <u>if</u> statement runs a block of commands if the condition was true.

       Like other shells, but unlike typical programming languages you might  know,  the  condition  here  is  a
       <u>command</u>. Fish runs it, and if it returns a true <u>exit</u> <u>status</u> (that's 0), the if-block is run. For example:

          if test -e <a href="file:/etc/os-release">/etc/os-release</a>
              cat <a href="file:/etc/os-release">/etc/os-release</a>
          end

       This  uses  the  <u>test</u>  command  to see if the file <a href="file:/etc/os-release">/etc/os-release</a> exists. If it does, it runs <b>cat</b>, which
       prints it on the screen.

       Unlike other shells, the condition command just ends  after  the  first  job,  there  is  no  <b>then</b>  here.
       Combiners like <b>and</b> and <b>or</b> extend the condition.

       A more complicated example with a <u>command</u> <u>substitution</u>:

          if test "$(uname)" = Linux
              echo I like penguins
          end

       Because  <b>test</b>  can  be  used  for  many  different  tests, it is important to quote variables and command
       substitutions. If the <b>$(uname)</b> was not quoted, and <b>uname</b> printed nothing it would run <b>test</b> <b>=</b> <b>Linux</b>, which
       is an error.

       <b>if</b> can also take <b>else</b> <b>if</b> clauses with additional conditions and an  <u>else</u> clause  that  is  executed  when
       everything else was false:

          if test "$number" -gt 10
             echo Your number was greater than 10
          else if test "$number" -gt 5
             echo Your number was greater than 5
          else if test "$number" -gt 1
             echo Your number was greater than 1
          else
             echo Your number was smaller or equal to 1
          end

       The <u>not</u> keyword can be used to invert the status:

          # Just see if the file contains the string "fish" anywhere.
          # This executes the `grep` command, which searches for a string,
          # and if it finds it returns a status of 0.
          # The `not` then turns 0 into 1 or anything else into 0.
          # The `-q` switch stops it from printing any matches.
          if not grep -q fish myanimals
              echo "You don't have fish!"
          else
              echo "You have fish!"
          end

       Other things commonly used in if-conditions:

       • <u>contains</u> - to see if a list contains a specific element (<b>if</b> <b>contains</b> <b>--</b> <b><a href="file:/usr/bin">/usr/bin</a></b> <b>$PATH</b>)

       • <u>string</u> - to e.g. match strings (<b>if</b> <b>string</b> <b>match</b> <b>-q</b> <b>--</b> <b>'*-'</b> <b>$arg</b>)

       • <u>path</u> - to check if paths of some criteria exist (<b>if</b> <b>path</b> <b>is</b> <b>-rf</b> <b>--</b> <b><a href="file:~/.config/fish/config.fish">~/.config/fish/config.fish</a></b>)

       • <u>type</u> - to see if a command, function or builtin exists (<b>if</b> <b>type</b> <b>-q</b> <b>git</b>)

   <b>The</b> <b>switch</b> <b>statement</b>
       The <u>switch</u> command is used to execute one of possibly many blocks of commands depending on the value of a
       string.  It  can  take  multiple  <u>case</u>  blocks  that  are executed when the string matches. They can take
       <u>wildcards</u>. For example:

          switch (uname)
          case Linux
              echo Hi Tux!
          case Darwin
              echo Hi Hexley!
          case DragonFly '*BSD'
              echo Hi Beastie! # this also works for FreeBSD and NetBSD
          case '*'
              echo Hi, stranger!
          end

       Unlike other shells or programming languages, there is no fallthrough - the first matching <b>case</b> block  is
       executed and then control jumps out of the <b>switch</b>.

   <b>Combiners</b> <b>(and</b> <b>/</b> <b>or</b> <b>/</b> <b>&amp;&amp;</b> <b>/</b> <b>||)</b>
       For  simple checks, you can use combiners. <u>and</u> or <b>&amp;&amp;</b> run the second command if the first succeeded, while
       <u>or</u> or <b>||</b> run it if the first failed. For example:

          # $XDG_CONFIG_HOME is a standard place to store configuration.
          # If it's not set applications should use <a href="file:~/.config.">~/.config.</a>
          set -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME
          or set -l configdir <a href="file:~/.config">~/.config</a>

       Note that combiners are <u>lazy</u> - only the part that is necessary to determine the final status is run.

       Compare:

          if sleep 2; and false
              echo 'How did I get here? This should be impossible'
          end

       and:

          if false; and sleep 2
              echo 'How did I get here? This should be impossible'
          end

       These do essentially the same thing, but the former takes 2 seconds longer because the <b>sleep</b> always needs
       to run.

       Or you can have a case where it is necessary to stop early:

          if command -sq foo; and foo

       If this went on after seeing that the command "foo" doesn't exist, it would try  to  run  <b>foo</b>  and  error
       because it wasn't found!

       Combiners  really  just  execute  step-by-step,  so  it  isn't recommended to build longer chains of them
       because they might do something you don't want. Consider:

          test -e /etc/my.config
          or echo "OH NO WE NEED A CONFIG FILE"
          and return 1

       This will execute <b>return</b> <b>1</b> also if the <b>test</b> succeeded. This is because fish runs <b>test</b> <b>-e</b>  <b>/etc/my.config</b>,
       sets  $status  to  0,  then  skips  the  <b>echo</b>, keeps $status at 0, and then executes the <b>return</b> <b>1</b> because
       $status is still 0.

       So if you have more complex conditions or want to run multiple things after  something  failed,  consider
       using an <u>if</u>. Here that would be:

          if not test -e /etc/my.config
              echo "OH NO WE NEED A CONFIG FILE"
              return 1
          end

</pre><h4><b>LOOPS</b> <b>AND</b> <b>BLOCKS</b></h4><pre>
       Like most programming language, fish also has the familiar <u>while</u> and <u>for</u> loops.

       <b>while</b> works like a repeated <u>if</u>:

          while true
              echo Still running
              sleep 1
          end

       will print "Still running" once a second. You can abort it with ctrl-c.

       <b>for</b> loops work like in other shells, which is more like python's for-loops than e.g. C's:

          for file in *
              echo file: $file
          end

       will  print each file in the current directory. The part after the <b>in</b> is just a list of arguments, so you
       can use any <u>expansions</u> there:

          set moreanimals bird fox
          for animal in {cat,}fish dog $moreanimals
             echo I like the $animal
          end

       If you need a list of numbers, you can use the <b>seq</b> command to create one:

          for i in (seq 1 5)
              echo $i
          end

       <u>break</u> is available to break out of a loop, and <u>continue</u> to jump to the next iteration.

       <u>Input</u> <u>and</u> <u>output</u> <u>redirections</u> (including <u>pipes</u>) can also be applied to loops:

          while read -l line
              echo line: $line
          end &lt; file

       In addition there's a <u>begin</u> block that just groups commands together so you can redirect to  a  block  or
       use a new <u>variable</u> <u>scope</u> without any repetition:

          begin
             set -l foo bar # this variable will only be available in this block!
          end

</pre><h4><b>PARAMETER</b> <b>EXPANSION</b></h4><pre>
       When fish is given a commandline, it expands the parameters before sending them to the command. There are
       multiple different kinds of expansions:

       • <u>Wildcards</u>, to create filenames from patterns - <b>*.jpg</b>

       • <u>Variable</u> <u>expansion</u>, to use the value of a variable - <b>$HOME</b>

       • <u>Command</u> <u>substitution</u>, to use the output of another command - <b>$(cat</b> <b>/path/to/file)</b>

       • <u>Brace</u> <u>expansion</u>, to write lists with common pre- or suffixes in a shorter way <b>{<a href="file:/usr">/usr</a>,}<a href="file:/bin">/bin</a></b>

       • <u>Tilde</u> <u>expansion</u>, to turn the <b>~</b> at the beginning of paths into the path to the home directory <b><a href="file:~/bin">~/bin</a></b>

       Parameter  expansion  is  limited  to  524288 items. There is a limit to how many arguments the operating
       system allows for any command, and 524288 is far above it. This is a  measure  to  stop  the  shell  from
       hanging doing useless computation.

   <b>Wildcards</b> <b>("Globbing")</b>
       When  a  parameter  includes  an  <u>unquoted</u> <b>*</b> star (or "asterisk") or a <b>?</b> question mark, fish uses it as a
       wildcard to match files.

       • <b>*</b> matches any number of characters (including zero) in a file name, not including <b>/</b>.

       • <b>**</b> matches any number of characters (including zero), and also descends into subdirectories. If <b>**</b> is a
         segment by itself, that segment may match zero times, for compatibility with other shells.

       • <b>?</b> can match any single character except <b>/</b>. This is deprecated and can be disabled via the  <b>qmark-noglob</b>
         <u>feature</u> <u>flag</u>, so <b>?</b> will just be an ordinary character.

       Wildcard  matches  are  sorted  case  insensitively.  When  sorting  matches containing numbers, they are
       naturally sorted, so that the strings '1' '5' and '12' would be sorted like 1, 5, 12.

       Hidden files (where the name begins with a dot) are not considered when wildcarding unless  the  wildcard
       string has a dot in that place.

       Examples:

       • <b>a*</b> matches any files beginning with an 'a' in the current directory.

       • <b>**</b> matches any files and directories in the current directory and all of its subdirectories.

       • <b><a href="file:~/.">~/.</a>*</b> matches all hidden files (also known as "dotfiles") and directories in your home directory.

       For  most  commands,  if  any  wildcard  fails  to expand, the command is not executed, <u>$status</u> is set to
       nonzero, and a warning is printed. This behavior is like what bash does with <b>shopt</b> <b>-s</b> <b>failglob</b>. There are
       exceptions, namely <u>set</u> and <u>path</u>, overriding variables in <u>overrides</u>,  <u>count</u>  and  <u>for</u>.  Their  globs  will
       instead  expand  to zero arguments (so the command won't see them at all), like with <b>shopt</b> <b>-s</b> <b>nullglob</b> in
       bash.

       Examples:

          # List the .foo files, or warns if there aren't any.
          ls *.foo

          # List the .foo files, if any.
          set foos *.foo
          if count $foos &gt;/dev/null
              ls $foos
          end

       Unlike bash (by default), fish will not pass on the literal glob character if no match was found, so  for
       a command like <b>apt</b> <b>install</b> that does the matching itself, you need to add quotes:

          apt install "ncurses-*"

   <b>Variable</b> <b>expansion</b>
       One  of  the  most  important  expansions in fish is the "variable expansion". This is the replacing of a
       dollar sign (<b>$</b>) followed by a variable name with the _value_ of that variable.

       In the simplest case, this is just something like:

          echo $HOME

       which will replace <b>$HOME</b> with the home directory of the current user, and pass it  to  <u>echo</u>,  which  will
       then print it.

       Some  variables  like  <b>$HOME</b>  are  already set because fish sets them by default or because fish's parent
       process passed them to fish when it started it. You can define your own variables by  setting  them  with
       <u>set</u>:

          set my_directory /home/cooluser/mystuff
          ls $my_directory
          # shows the contents of /home/cooluser/mystuff

       For more on how setting variables works, see <u>Shell</u> <u>variables</u> and the following sections.

       Sometimes a variable has no value because it is undefined or empty, and it expands to nothing:

          echo $nonexistentvariable
          # Prints no output.

       To separate a variable name from text you can encase the variable within double-quotes or braces:

          set WORD cat
          echo The plural of $WORD is "$WORD"s
          # Prints "The plural of cat is cats" because $WORD is set to "cat".
          echo The plural of $WORD is {$WORD}s
          # ditto

       Without the quotes or braces, fish will try to expand a variable called <b>$WORDs</b>, which may not exist.

       The latter syntax <b>{$WORD}</b> is a special case of <u>brace</u> <u>expansion</u>.

       If  $WORD  here is undefined or an empty list, the "s" is not printed. However, it is printed if $WORD is
       the empty string (like after <b>set</b> <b>WORD</b> <b>""</b>).

       For more on shell variables, read the <u>Shell</u> <u>variables</u> section.

   <b>Quoting</b> <b>variables</b>
       Variable expansion also happens in double quoted strings. Inside double quotes (<b>"these"</b>), variables  will
       always expand to exactly one argument. If they are empty or undefined, it will result in an empty string.
       If  they have one element, they'll expand to that element. If they have more than that, the elements will
       be joined with spaces, unless the variable is a <u>path</u> <u>variable</u> - in that case it  will  use  a  colon  (<b>:</b>)
       instead [3].

       Fish  variables  are  all  <u>lists</u>,  and  they are split into elements when they are <u>set</u> - that means it is
       important to decide whether to use quotes or not with <u>set</u>:

          set foo 1 2 3 # a variable with three elements
          rm $foo # runs the equivalent of `rm 1 2 3` - trying to delete three files: 1, 2 and 3.
          rm "$foo" # runs `rm '1 2 3'` - trying to delete one file called '1 2 3'

          set foo # an empty variable
          rm $foo # runs `rm` without arguments
          rm "$foo" # runs the equivalent of `rm ''`

          set foo "1 2 3"
          rm $foo # runs the equivalent of `rm '1 2 3'` - trying to delete one file
          rm "$foo" # same thing

       This is unlike other shells, which do what is known as "Word Splitting", where they  split  the  variable
       when it is <u>used</u> in an expansion. E.g. in bash:

          foo="1 2 3"
          rm $foo # runs the equivalent of `rm 1 2 3`
          rm "$foo" # runs the equivalent of `rm '1 2 3'`

       This is the cause of very common problems with filenames with spaces in bash scripts.

       In  fish,  unquoted variables will expand to as many arguments as they have elements. That means an empty
       list will expand to nothing, a variable with one element will expand to that element, and a variable with
       multiple elements will expand to each of those elements separately.

       If a variable expands to nothing, it will cancel out any other strings attached to it. See the  <u>Combining</u>
       <u>Lists</u> section for more information.

       Most  of  the  time, not quoting a variable is correct. The exception is when you need to ensure that the
       variable is passed as one element, even if it might be unset or  have  multiple  elements.  This  happens
       often with <u>test</u>:

          set -l foo one two three
          test -n $foo
          # prints an error that it got too many arguments, because it was executed like
          test -n one two three

          test -n "$foo"
          # works, because it was executed like
          test -n "one two three"

       [3]  Unlike bash or zsh, which will join with the first character of $IFS (which usually is space).

   <b>Dereferencing</b> <b>variables</b>
       The  <b>$</b>  symbol  can also be used multiple times, as a kind of "dereference" operator (the <b>*</b> in C or C++),
       like in the following code:

          set foo a b c
          set a 10; set b 20; set c 30
          for i in (seq (count $$foo))
              echo $$foo[$i]
          end

          # Output is:
          # 10
          # 20
          # 30

       <b>$$foo[$i]</b> is "the value of the variable named by <b>$foo[$i]</b>".

       This can also be used to give a variable name to a function:

          function print_var
              for arg in $argv
                  echo Variable $arg is $$arg
              end
          end

          set -g foo 1 2 3
          set -g bar a b c

          print_var foo bar
          # prints "Variable foo is 1 2 3" and "Variable bar is a b c"

       Of course the variable will have to be accessible from the function, so it needs to  be  <u>global/universal</u>
       or  <u>exported</u>.  It  also can't clash with a variable name used inside the function. So if we had made $foo
       there a local variable, or if we had named it "arg" instead, it would not have worked.

       When using this feature together with <u>slices</u>, the slices will be used from the inside out. <b>$$foo[5]</b>  will
       use  the  fifth  element  of  <b>$foo</b>  as  a  variable  name, instead of giving the fifth element of all the
       variables $foo refers to. That would instead be expressed as <b>$$foo[1..-1][5]</b> (take all elements of  <b>$foo</b>,
       use them as variable names, then give the fifth element of those).

       Some more examples:

          set listone 1 2 3
          set listtwo 4 5 6
          set var listone listtwo

          echo $$var
          # Output is 1 2 3 4 5 6

          echo $$var[1]
          # Output is 1 2 3

          echo $$var[2][3]
          # $var[1] is listtwo, third element of that is 6, output is 6

          echo $$var[..][2]
          # The second element of every variable, so output is
          # 2 5

   <b>Variables</b> <b>as</b> <b>command</b>
       Like other shells, you can run the value of a variable as a command.

          &gt; set -g EDITOR emacs
          &gt; $EDITOR foo # opens emacs, possibly the GUI version

       If you want to give the command an argument inside the variable it needs to be a separate element:

          &gt; set EDITOR emacs -nw
          &gt; $EDITOR foo # opens emacs in the terminal even if the GUI is installed
          &gt; set EDITOR "emacs -nw"
          &gt; $EDITOR foo # tries to find a command called "emacs -nw"

       Also  like  other  shells,  this only works with commands, builtins and functions - it will not work with
       keywords because they have syntactical importance.

       For instance <b>set</b> <b>if</b> <b>$if</b> won't allow you to make an if-block, and <b>set</b> <b>cmd</b> <b>command</b> won't allow you  to  use
       the <u>command</u> decorator, but only uses like <b>$cmd</b> <b>-q</b> <b>foo</b>.

   <b>Command</b> <b>substitution</b>
       A <b>command</b> <b>substitution</b> is an expansion that uses the <u>output</u> of a command as the arguments to another. For
       example:

          echo $(pwd)

       This  executes  the <u>pwd</u> command, takes its output (more specifically what it wrote to the standard output
       "stdout" stream) and uses it as arguments to <u>echo</u>. So the inner command (the <b>pwd</b>) is run first and has to
       complete before the outer command can even be started.

       If the inner command prints multiple lines, fish will use each separate line as a  separate  argument  to
       the outer command. Unlike other shells, the value of <b>$IFS</b> is not used [4], fish splits on newlines.

       Command substitutions can also be double-quoted:

          echo "$(pwd)"

       When using double quotes, the command output is not split up by lines, but trailing empty lines are still
       removed.

       If  the  output is piped to <u>string</u> <u>split</u> <u>or</u> <u>string</u> <u>split0</u> as the last step, those splits are used as they
       appear instead of splitting lines.

       Fish also allows spelling command substitutions without the dollar, like <b>echo</b> <b>(pwd)</b>.  This  variant  will
       not be expanded in double-quotes (<b>echo</b> <b>"(pwd)"</b> will print <b>(pwd)</b>).

       The  exit  status  of  the  last  run  command  substitution  is  available in the <u>status</u> variable if the
       substitution happens in the context of a <u>set</u> command (so  <b>if</b>  <b>set</b>  <b>-l</b>  <b>(something)</b>  checks  if  <b>something</b>
       returned true).

       To use only some lines of the output, refer to <u>slices</u>.

       Examples:

          # Outputs 'image.png'.
          echo (basename image.jpg .jpg).png

          # Convert all JPEG files in the current directory to the
          # PNG format using the 'convert' program.
          for i in *.jpg; convert $i (basename $i .jpg).png; end

          # Set the ``data`` variable to the contents of 'data.txt'
          # without splitting it into a list.
          set data "$(cat data.txt)"

          # Set ``$data`` to the contents of data, splitting on NUL-bytes.
          set data (cat data | string split0)

       Sometimes  you  want  to pass the output of a command to another command that only accepts files. If it's
       just one file, you can usually just pass it via a pipe, like:

          grep fish myanimallist1 | wc -l

       but if you need multiple or the command doesn't read  from  standard  input,  "process  substitution"  is
       useful. Other shells allow this via <b>foo</b> <b>&lt;(bar)</b> <b>&lt;(baz)</b>, and fish uses the <u>psub</u> command:

          # Compare just the lines containing "fish" in two files:
          diff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)

       This  creates a temporary file, stores the output of the command in that file and prints the filename, so
       it is given to the outer command.

       Fish has a default limit of 100 MiB on the data it will read in a command substitution. If that limit  is
       reached  the  command (all of it, not just the command substitution - the outer command won't be executed
       at all) fails and <b>$status</b> is set to 122. This is so command substitutions can't cause the  system  to  go
       out  of memory, because typically your operating system has a much lower limit, so reading more than that
       would be useless and harmful. This limit can be adjusted with the <b>fish_read_limit</b> variable (<u>0</u> meaning  no
       limit). This limit also affects the <u>read</u> command.

       [4]  One  exception:  Setting  <b>$IFS</b>  to empty will disable line splitting. This is deprecated, use <u>string</u>
            <u>split</u> instead.

   <b>Brace</b> <b>expansion</b>
       Curly braces can be used to write comma-separated lists. They will be expanded with each element becoming
       a new parameter, with the surrounding string attached. This is useful to save on typing, and to  separate
       a variable name from surrounding text.

       Examples:

          &gt; echo input.{c,h,txt}
          input.c input.h input.txt

          # Move all files with the suffix '.c' or '.h' to the subdirectory src.
          &gt; mv *.{c,h} src/

          # Make a copy of `file` at `file.bak`.
          &gt; cp file{,.bak}

          &gt; set -l dogs hot cool cute "good "
          &gt; echo {$dogs}dog
          hotdog cooldog cutedog good dog

       If there is no "," or variable expansion between the curly braces, they will not be expanded:

          # This {} isn't special
          &gt; echo foo-{}
          foo-{}
          # This passes "HEAD@{2}" to git
          &gt; git reset --hard HEAD@{2}
          &gt; echo {{a,b}}
          {a} {b} # because the inner brace pair is expanded, but the outer isn't.

       If  after  expansion there is nothing between the braces, the argument will be removed (see <u>the</u> <u>Combining</u>
       <u>Lists</u> section):

          &gt; echo foo-{$undefinedvar}
          # Output is an empty line, just like a bare `echo`.

       If there is nothing between a brace and a comma or two commas, it's interpreted as an empty element:

          &gt; echo {,,<a href="file:/usr">/usr</a>}<a href="file:/bin">/bin</a>
          <a href="file:/bin">/bin</a> <a href="file:/bin">/bin</a> <a href="file:/usr/bin">/usr/bin</a>

       To use a "," as an element, <u>quote</u> or <u>escape</u> it.

   <b>Combining</b> <b>lists</b>
       Fish expands lists like <u>brace</u> <u>expansions</u>:

          &gt;_ set -l foo x y z
          &gt;_ echo 1$foo
          # Any element of $foo is combined with the "1":
          1x 1y 1z

          &gt;_ echo {good,bad}" apples"
          # Any element of the {} is combined with the " apples":
          good apples bad apples

          # Or we can mix the two:
          &gt;_ echo {good,bad}" "$foo
          good x bad x good y bad y good z bad z

       Any string attached to a list will be concatenated to each element.

       Two lists will be expanded in all combinations  - every element of the first with every  element  of  the
       second:

          &gt;_ set -l a x y z; set -l b 1 2 3
          &gt;_ echo $a$b # same as {x,y,z}{1,2,3}
          x1 y1 z1 x2 y2 z2 x3 y3 z3

       A  result  of  this  is that, if a list has no elements, this combines the string with no elements, which
       means the entire token is removed!

          &gt;_ set -l c # &lt;- this list is empty!
          &gt;_ echo {$c}word
          # Output is an empty line - the "word" part is gone

       This can be quite useful. For example, if you want to go through all the files in all the directories  in
       <u>PATH</u>, use

          for file in $PATH/*

       Because  <u>PATH</u>  is a list, this expands to all the files in all the directories in it. And if there are no
       directories in <u>PATH</u>, the right answer here is to expand to no files.

       Sometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you
       should double-quote variables - <b>echo</b> <b>"$c"word</b>.

       This also happens after <u>command</u> <u>substitution</u>. To avoid tokens disappearing there, make the inner  command
       return a trailing newline, or double-quote it:

          &gt;_ set b 1 2 3
          &gt;_ echo (echo x)$b
          x1 x2 x3
          &gt;_ echo (printf '%s' '')banana
          # the printf prints nothing, so this is nothing times "banana",
          # which is nothing.
          &gt;_ echo (printf '%s\n' '')banana
          # the printf prints a newline,
          # so the command substitution expands to an empty string,
          # so this is `''banana`
          banana
          &gt;_ echo "$(printf '%s' '')"banana
          # quotes mean this is one argument, the banana stays

   <b>Slices</b>
       Sometimes it's necessary to access only some of the elements of a <u>list</u> (all fish variables are lists), or
       some  of  the lines a <u>command</u> <u>substitution</u> outputs. Both are possible in fish by writing a set of indices
       in brackets, like:

          # Make $var a list of four elements
          set var one two three four
          # Print the second:
          echo $var[2]
          # prints "two"
          # or print the first three:
          echo $var[1..3]
          # prints "one two three"

       In index brackets, fish understands ranges written like <b>a..b</b>  ('a'  and  'b'  being  indices).  They  are
       expanded  into  a sequence of indices from a to b (so <b>a</b> <b>a+1</b> <b>a+2</b> <b>...</b> <b>b</b>), going up if b is larger and going
       down if a is larger. Negative indices can also be used - they are taken from the end of the list,  so  <b>-1</b>
       is the last element, and <b>-2</b> the one before it. If an index doesn't exist the range is clamped to the next
       possible index.

       If  a  list has 5 elements the indices go from 1 to 5, so a range of <b>2..16</b> will only go from element 2 to
       element 5.

       If the end is negative the range always goes up, so <b>2..-2</b> will go from element 2 to 4, and  <b>2..-16</b>  won't
       go  anywhere because there is no way to go from the second element to one that doesn't exist, while going
       up.  If the start is negative the range always goes down, so <b>-2..1</b> will go  from  element  4  to  1,  and
       <b>-16..2</b>  won't  go anywhere because there is no way to go from an element that doesn't exist to the second
       element, while going down.

       A missing starting index in a range defaults to 1. This is allowed  if  the  range  is  the  first  index
       expression  of  the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last
       index in the sequence.

       Multiple ranges are also possible, separated with a space.

       Some examples:

          echo (seq 10)[1 2 3]
          # Prints: 1 2 3

          # Limit the command substitution output
          echo (seq 10)[2..5]
          # Uses elements from 2 to 5
          # Output is: 2 3 4 5

          echo (seq 10)[7..]
          # Prints: 7 8 9 10

          # Use overlapping ranges:
          echo (seq 10)[2..5 1..3]
          # Takes elements from 2 to 5 and then elements from 1 to 3
          # Output is: 2 3 4 5 1 2 3

          # Reverse output
          echo (seq 10)[-1..1]
          # Uses elements from the last output line to
          # the first one in reverse direction
          # Output is: 10 9 8 7 6 5 4 3 2 1

          # The command substitution has only one line,
          # so these will result in empty output:
          echo (echo one)[2..-1]
          echo (echo one)[-3..1]

       The same works when setting or expanding variables:

          # Reverse path variable
          set PATH $PATH[-1..1]
          # or
          set PATH[-1..1] $PATH

          # Use only n last items of the PATH
          set n -3
          echo $PATH[$n..-1]

       Variables can be used as indices for expansion of variables, like so:

          set index 2
          set letters a b c d
          echo $letters[$index] # returns 'b'

       However using variables as indices for command substitution is currently not supported, so:

          echo (seq 5)[$index] # This won't work

          set sequence (seq 5) # It needs to be written on two lines like this.
          echo $sequence[$index] # returns '2'

       When using indirect variable expansion with multiple <b>$</b> (<b>$$name</b>), you have to give all indices up  to  the
       variable you want to slice:

          &gt; set -l list 1 2 3 4 5
          &gt; set -l name list
          &gt; echo $$name[1]
          1 2 3 4 5
          &gt; echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.
          1 2 3

   <b>Home</b> <b>directory</b> <b>expansion</b>
       The  <b>~</b>  (tilde)  character  at the beginning of a parameter, followed by a username, is expanded into the
       home directory of the specified user. A lone <b>~</b>, or a <b>~</b> followed by a slash, is  expanded  into  the  home
       directory of the process owner:

          ls <a href="file:~/Music">~/Music</a> # lists my music directory

          echo ~root # prints root's home directory, probably "<a href="file:/root">/root</a>"

   <b>Combining</b> <b>different</b> <b>expansions</b>
       All of the above expansions can be combined. If several expansions result in more than one parameter, all
       possible combinations are created.

       When combining multiple parameter expansions, expansions are performed in the following order:

       • Command substitutions

       • Variable expansions

       • Bracket expansion

       • Wildcard expansion

       Expansions  are  performed  from  right  to left, nested bracket expansions and command substitutions are
       performed from the inside and out.

       Example:

       If the current directory contains the files 'foo' and 'bar', the command <b>echo</b>  <b>a(ls){1,2,3}</b>  will  output
       <b>abar1</b> <b>abar2</b> <b>abar3</b> <b>afoo1</b> <b>afoo2</b> <b>afoo3</b>.

</pre><h4><b>TABLE</b> <b>OF</b> <b>OPERATORS</b></h4><pre>
       Putting it together, here is a quick reference to fish's operators, all of the special symbols it uses:
                     ┌────────────┬──────────────────────────────┬──────────────────────────────┐
                     │ Symbol     │ Meaning                      │ Example                      │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>$</b>          │ <u>Variable</u> <u>expansion</u>           │ <b>echo</b> <b>$foo</b>                    │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>$()</b> and <b>()</b> │ <u>Command</u> <u>substitution</u>         │ <b>cat</b>  <b>(grep</b>  <b>foo</b>  <b>bar)</b> or <b>cat</b> │
                     │            │                              │ <b>$(grep</b> <b>foo</b> <b>bar)</b>              │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>&lt;</b> and <b>&gt;</b>    │ <u>Redirection</u>, like <b>command</b>  <b>&gt;</b> │ <b>git</b>   <b>shortlog</b>   <b>-nse</b>   <b>.</b>  <b>&gt;</b> │
                     │            │ <b>file</b>                         │ <b>authors</b>                      │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>|</b>          │ <u>Pipe</u>, connect  two  or  more │ <b>foo</b> <b>|</b> <b>grep</b> <b>bar</b> <b>|</b> <b>grep</b> <b>baz</b>    │
                     │            │ commands                     │                              │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>;</b>          │ End  of the command, instead │ <b>command1;</b> <b>command2</b>           │
                     │            │ of a newline                 │                              │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>&amp;</b>          │ <u>Backgrounding</u>                │ <b>sleep</b> <b>5m</b> <b>&amp;</b>                   │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>{}</b>         │ <u>Brace</u> <u>expansion</u>              │ <b>ls</b> <b>{<a href="file:/usr">/usr</a>,}<a href="file:/bin">/bin</a></b>               │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>&amp;&amp;</b> and <b>||</b>  │ <u>Combiners</u>                    │ <b>mkdir</b> <b>foo</b> <b>&amp;&amp;</b> <b>cd</b>  <b>foo</b>  or  <b>rm</b> │
                     │            │                              │ <b>foo</b> <b>||</b> <b>exit</b>                  │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>*</b> and <b>**</b>   │ <u>Wildcards</u>                    │ <b>cat</b> <b>*.fish</b> or <b>count</b> <b>**.jpg</b>   │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>\\</b>         │ <u>Escaping</u>                     │ <b>echo</b> <b>foo\nbar</b> or <b>echo</b> <b>\$foo</b>  │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>''</b> and <b>""</b>  │ <u>Quoting</u>                      │ <b>rm</b>  <b>"file</b>  <b>with</b>  <b>spaces"</b>  or │
                     │            │                              │ <b>echo</b> <b>'$foo'</b>                  │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>~</b>          │ <u>Home</u> <u>directory</u> <u>expansion</u>     │ <b>ls</b> <b>~/</b> or <b>ls</b> <b>~root/</b>           │
                     ├────────────┼──────────────────────────────┼──────────────────────────────┤
                     │ <b>#</b>          │ <u>Comments</u>                     │ <b>echo</b>  <b>Hello</b>  <b>#</b>  <b>this</b>   <b>isn't</b> │
                     │            │                              │ <b>printed</b>                      │
                     └────────────┴──────────────────────────────┴──────────────────────────────┘

</pre><h4><b>SHELL</b> <b>VARIABLES</b></h4><pre>
       Variables  are  a way to save data and pass it around. They can be used just by the shell, or they can be
       "<u>exported</u>", so that a copy of the variable is available to any external  command  the  shell  starts.  An
       exported variable is referred to as an "environment variable".

       To  set  a  variable  value,  use  the <u>set</u> command. A variable name can not be empty and can contain only
       letters, digits, and underscores. It may begin and end with any of those characters.

       Example:

       To set the variable <b>smurf_color</b> to the value <b>blue</b>, use the command <b>set</b> <b>smurf_color</b> <b>blue</b>.

       After a variable has been set, you can use the  value  of  a  variable  in  the  shell  through  <u>variable</u>
       <u>expansion</u>.

       Example:

          set smurf_color blue
          echo Smurfs are usually $smurf_color
          set pants_color red
          echo Papa smurf, who is $smurf_color, wears $pants_color pants

       So you set a variable with <b>set</b>, and use it with a <b>$</b> and the name.

   <b>Variable</b> <b>Scope</b>
       All variables in fish have a scope. For example they can be global or local to a function or block:

          # This variable is global, we can use it everywhere.
          set --global name Patrick
          # This variable is local, it will not be visible in a function we call from here.
          set --local place "at the Krusty Krab"

          function local
              # This can find $name, but not $place
              echo Hello this is $name $place

              # This variable is local, it will not be available
              # outside of this function
              set --local instrument mayonnaise
              echo My favorite instrument is $instrument
              # This creates a local $name, and won't touch the global one
              set --local name Spongebob
              echo My best friend is $name
          end

          local
          # Will print:
          # Hello this is Patrick
          # My favorite instrument is mayonnaise
          # My best friend is Spongebob

          echo $name, I am $place and my instrument is $instrument
          # Will print:
          # Patrick, I am at the Krusty Krab and my instrument is

       There are four kinds of variable scopes in fish: universal, global, function and local variables.

       • Universal  variables  are  shared between all fish sessions a user is running on one computer. They are
         stored on disk and persist even after reboot.

       • Global variables are specific to the current fish session. They can be erased by explicitly  requesting
         <b>set</b> <b>-e</b>.

       • Function  variables  are  specific  to  the  currently  executing function. They are erased ("go out of
         scope") when the current function ends. Outside of a function, they don't go out of scope.

       • Local variables are specific to the current block of commands, and automatically erased when a specific
         block goes out of scope. A block of commands is a series of  commands  that  begins  with  one  of  the
         commands <b>for</b>, <b>while</b> , <b>if</b>, <b>function</b>, <b>begin</b> or <b>switch</b>, and ends with the command <b>end</b>. Outside of a block,
         this is the same as the function scope.

       Variables  can  be  explicitly  set  to be universal with the <b>-U</b> or <b>--universal</b> switch, global with <b>-g</b> or
       <b>--global</b>, function-scoped with <b>-f</b> or <b>--function</b> and local to the current block with <b>-l</b> or  <b>--local</b>.   The
       scoping rules when creating or updating a variable are:

       • When a scope is explicitly given, it will be used. If a variable of the same name exists in a different
         scope, that variable will not be changed.

       • When  no scope is given, but a variable of that name exists, the variable of the smallest scope will be
         modified. The scope will not be changed.

       • When no scope is given and no variable of that name exists, the variable is created in  function  scope
         if inside a function, or global scope if no function is executing.

       There  can  be  many  variables  with  the  same name, but different scopes. When you <u>use</u> <u>a</u> <u>variable</u>, the
       smallest scoped variable of that name will be used. If a local variable exists, it will be  used  instead
       of the global or universal variable of the same name.

       Example:

       There are a few possible uses for different scopes.

       Typically inside functions you should use local scope:

          function something
              set -l file /path/to/my/file
              if not test -e "$file"
                  set file /path/to/my/otherfile
              end
          end

          # or

          function something
              if test -e /path/to/my/file
                  set -f file /path/to/my/file
              else
                  set -f file /path/to/my/otherfile
              end
          end

       If you want to set something in config.fish, or set something in a function and have it available for the
       rest of the session, global scope is a good choice:

          # Don't shorten the working directory in the prompt
          set -g fish_prompt_pwd_dir_length 0

          # Set my preferred cursor style:
          function setcursors
             set -g fish_cursor_default block
             set -g fish_cursor_insert line
             set -g fish_cursor_visual underscore
          end

          # Set my language
          set -gx LANG de_DE.UTF-8

       If you want to set some personal customization, universal variables are nice:

          # Typically you'd run this interactively, fish takes care of keeping it.
          set -U fish_color_autosuggestion 555

       Here is an example of local vs function-scoped variables:

          function test-scopes
              begin
                  # This is a nice local scope where all variables will die
                  set -l pirate 'There be treasure in them thar hills'
                  set -f captain Space, the final frontier
                  # If no variable of that name was defined, it is function-local.
                  set gnu "In the beginning there was nothing, which exploded"
              end

              # This will not output anything, since the pirate was local
              echo $pirate
              # This will output the good Captain's speech
              # since $captain had function-scope.
              echo $captain
              # This will output Sir Terry's wisdom.
              echo $gnu
          end

       When a function calls another, local variables aren't visible:

          function shiver
              set phrase 'Shiver me timbers'
          end

          function avast
              set --local phrase 'Avast, mateys'
              # Calling the shiver function here can not
              # change any variables in the local scope
              # so phrase remains as we set it here.
              shiver
              echo $phrase
          end
          avast

          # Outputs "Avast, mateys"

       When  in  doubt,  use  function-scoped variables. When you need to make a variable accessible everywhere,
       make it global. When you need to persistently store configuration, make it universal. When  you  want  to
       use a variable only in a short block, make it local.

   <b>Overriding</b> <b>variables</b> <b>for</b> <b>a</b> <b>single</b> <b>command</b>
       If  you  want  to  override  a variable for a single command, you can use "var=val" statements before the
       command:

          # Call git status on another directory
          # (can also be done via `git -C somerepo status`)
          GIT_DIR=somerepo git status

       Unlike other shells, fish will first set the variable and then perform other expansions on the line, so:

          set foo banana
          foo=gagaga echo $foo
          # prints gagaga, while in other shells it might print "banana"

       Multiple elements can be given in a <u>brace</u> <u>expansion</u>:

          # Call bash with a reasonable default path.
          PATH={<a href="file:/usr">/usr</a>,}/{s,}bin bash

       Or with a <u>glob</u>:

          # Run vlc on all mp3 files in the current directory
          # If no file exists it will still be run with no arguments
          mp3s=*.mp3 vlc $mp3s

       Unlike other shells, this does <u>not</u> inhibit any lookup (aliases  or  similar).  Calling  a  command  after
       setting a variable override will result in the exact same command being run.

       This syntax is supported since fish 3.1.

   <b>Universal</b> <b>Variables</b>
       Universal  variables  are variables that are shared between all the user's fish sessions on the computer.
       Fish stores many of its configuration options as universal variables. This means that in order to  change
       fish settings, all you have to do is change the variable value once, and it will be automatically updated
       for all sessions, and preserved across computer reboots and login/logout.

       To  see  universal  variables  in  action,  start two fish sessions side by side, and issue the following
       command in one of them <b>set</b> <b>fish_color_cwd</b> <b>blue</b>. Since <b>fish_color_cwd</b> is a universal variable,  the  color
       of the current working directory listing in the prompt will instantly change to blue on both terminals.

       <u>Universal</u>  <u>variables</u>  are stored in the file <b>.config/fish/fish_variables</b>. Do not edit this file directly,
       as your edits may be overwritten. Edit the variables through fish scripts or by using fish  interactively
       instead.

       Do  not  append  to universal variables in <u>config.fish</u>, because these variables will then get longer with
       each new shell instance. Instead, simply set them once at the command line.

   <b>Exporting</b> <b>variables</b>
       Variables in fish can be exported, so they will  be  inherited  by  any  commands  started  by  fish.  In
       particular, this is necessary for variables used to configure external commands like <b>PAGER</b> or <b>GOPATH</b>, but
       also  for  variables  that  contain general system settings like <b>PATH</b> or <b>LANGUAGE</b>. If an external command
       needs to know a variable, it needs to be exported. Exported variables are also often called  "environment
       variables".

       This also applies to fish - when it starts up, it receives environment variables from its parent (usually
       the terminal). These typically include system configuration like <u>PATH</u> and <u>locale</u> <u>variables</u>.

       Variables  can  be explicitly set to be exported with the <b>-x</b> or <b>--export</b> switch, or not exported with the
       <b>-u</b> or <b>--unexport</b> switch.  The exporting rules when setting a variable are similar to  the  scoping  rules
       for  variables  -  when  an  option is passed it is respected, otherwise the variable's existing state is
       used. If no option is passed and the variable didn't exist yet it is not exported.

       As a naming convention, exported variables are in uppercase and unexported variables are in lowercase.

       For example:

          set -gx ANDROID_HOME <a href="file:~/.android">~/.android</a> # /opt/android-sdk
          set -gx CDPATH . ~ (test -e <a href="file:~/Videos">~/Videos</a>; and echo <a href="file:~/Videos">~/Videos</a>)
          set -gx EDITOR emacs -nw
          set -gx GOPATH <a href="file:~/dev/go">~/dev/go</a>
          set -gx GTK2_RC_FILES "$XDG_CONFIG_HOME/gtk-2.0/gtkrc"
          set -gx LESSHISTFILE "-"

       Note: Exporting is not a <u>scope</u>, but an additional state.  It  typically  makes  sense  to  make  exported
       variables  global as well, but local-exported variables can be useful if you need something more specific
       than <u>Overrides</u>. They are <u>copied</u> to functions  so  the  function  can't  alter  them  outside,  and  still
       available to commands. Global variables are accessible to functions whether they are exported or not.

   <b>Lists</b>
       Fish can store a list (or an "array" if you wish) of multiple strings inside of a variable:

          &gt; set mylist first second third
          &gt; printf '%s\n' $mylist # prints each element on its own line
          first
          second
          third

       To access one element of a list, use the index of the element inside of square brackets, like this:

          echo $PATH[3]

       List  indices  start  at  1  in  fish,  not  0  like in other languages. This is because it requires less
       subtracting of 1 and many common Unix tools like <b>seq</b> work better with it (<b>seq</b> <b>5</b> prints 1 to 5, not  0  to
       5).  An  invalid  index  is  silently  ignored  resulting  in no value (not even an empty string, just no
       argument at all).

       If you don't use any brackets, all the elements of the list will be passed to  the  command  as  separate
       items. This means you can iterate over a list with <b>for</b>:

          for i in $PATH
              echo $i is in the path
          end

       This goes over every directory in <u>PATH</u> separately and prints a line saying it is in the path.

       To create a variable <b>smurf</b>, containing the items <b>blue</b> and <b>small</b>, simply write:

          set smurf blue small

       It is also possible to set or erase individual elements of a list:

          # Set smurf to be a list with the elements 'blue' and 'small'
          set smurf blue small

          # Change the second element of smurf to 'evil'
          set smurf[2] evil

          # Erase the first element
          set -e smurf[1]

          # Output 'evil'
          echo $smurf

       If  you  specify a negative index when expanding or assigning to a list variable, the index will be taken
       from the <u>end</u> of the list. For example, the index -1 is the last element of the list:

          &gt; set fruit apple orange banana
          &gt; echo $fruit[-1]
          banana

          &gt; echo $fruit[-2..-1]
          orange
          banana

          &gt; echo $fruit[-1..1] # reverses the list
          banana
          orange
          apple

       As you see, you can use a range of indices, see <u>slices</u> for details.

       All lists are one-dimensional and can't contain other lists, although it is possible to fake nested lists
       using dereferencing - see <u>variable</u> <u>expansion</u>.

       When a list is exported as an environment variable, it is either space or colon delimited,  depending  on
       whether it is a <u>path</u> <u>variable</u>:

          &gt; set -x smurf blue small
          &gt; set -x smurf_PATH forest mushroom
          &gt; env | grep smurf
          smurf=blue small
          smurf_PATH=forest:mushroom

       Fish  automatically  creates  lists  from  all  environment variables whose name ends in <b>PATH</b> (like <u>PATH</u>,
       <u>CDPATH</u> or <b>MANPATH</b>), by splitting them on colons. Other variables are not automatically split.

       Lists can be inspected with the <u>count</u> or the <u>contains</u> commands:

          &gt; count $smurf
          2

          &gt; contains blue $smurf
          # blue was found, so it exits with status 0
          # (without printing anything)

          &gt; echo $status
          0

          &gt; contains -i blue $smurf
          1

       A nice thing about lists is that they are passed to commands one element as one argument, so once  you've
       set your list, you can just pass it:

          set -l grep_args -r "my string"
          grep $grep_args . # will run the same as `grep -r "my string"` .

       Unlike  other  shells,  fish  does not do "word splitting" - elements in a list stay as they are, even if
       they contain spaces or tabs.

   <b>Argument</b> <b>Handling</b>
       An important list is <b>$argv</b>, which contains the arguments to a function or script. For example:

          function myfunction
              echo $argv[1]
              echo $argv[3]
          end

       This function takes whatever arguments it gets and prints the first and third:

          &gt; myfunction first second third
          first
          third

          &gt; myfunction apple cucumber banana
          apple
          banana

       That covers the positional arguments, but commandline tools often get  various  options  and  flags,  and
       $argv  would  contain  them  intermingled  with  the positional arguments. Typical unix argument handling
       allows short options (<b>-h</b>, also grouped like in <b>ls</b> <b>-lah</b>), long options (<b>--help</b>) and allows  those  options
       to take arguments (<b>--color=auto</b> or <b>--position</b> <b>anywhere</b> or <b>complete</b> <b>-C"git</b> <b>"</b>) as well as a <b>--</b> separator to
       signal the end of options. Handling all of these manually is tricky and error-prone.

       A  more  robust  approach  to option handling is <u>argparse</u>, which checks the defined options and puts them
       into various variables, leaving only the positional arguments in $argv. Here's a simple example:

          function mybetterfunction
              # We tell argparse about -h/--help and -s/--second
              # - these are short and long forms of the same option.
              # The "--" here is mandatory,
              # it tells it from where to read the arguments.
              argparse h/help s/second -- $argv
              # exit if argparse failed because
              # it found an option it didn't recognize
              # - it will print an error
              or return

              # If -h or --help is given, we print a little help text and return
              if set -ql _flag_help
                  echo "mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]"
                  return 0
              end

              # If -s or --second is given, we print the second argument,
              # not the first and third.
              # (this is also available as _flag_s because of the short version)
              if set -ql _flag_second
                  echo $argv[2]
              else
                  echo $argv[1]
                  echo $argv[3]
              end
          end

       The options will be <u>removed</u> from $argv, so $argv[2] is the second <u>positional</u> argument now:

          &gt; mybetterfunction first -s second third
          second

       For more information on argparse, like how to handle option arguments, see <u>the</u> <u>argparse</u> <u>documentation</u>.

   <b>PATH</b> <b>variables</b>
       Path variables are a special kind of variable used to support colon-delimited path lists including  <u>PATH</u>,
       <u>CDPATH</u>, <b>MANPATH</b>, <b>PYTHONPATH</b>, etc. All variables that end in "PATH" (case-sensitive) become PATH variables
       by default.

       PATH variables act as normal lists, except they are implicitly joined and split on colons.

          set MYPATH 1 2 3
          echo "$MYPATH"
          # 1:2:3
          set MYPATH "$MYPATH:4:5"
          echo $MYPATH
          # 1 2 3 4 5
          echo "$MYPATH"
          # 1:2:3:4:5

       Path  variables  will  also  be  exported  in  the  colon form, so <b>set</b> <b>-x</b> <b>MYPATH</b> <b>1</b> <b>2</b> <b>3</b> will have external
       commands see it as <b>1:2:3</b>.

          &gt; set -gx MYPATH <a href="file:/bin">/bin</a> <a href="file:/usr/bin">/usr/bin</a> <a href="file:/sbin">/sbin</a>
          &gt; env | grep MYPATH
          MYPATH=<a href="file:/bin">/bin</a>:<a href="file:/usr/bin">/usr/bin</a>:<a href="file:/sbin">/sbin</a>

       This is for compatibility with other tools. Unix doesn't  have  variables  with  multiple  elements,  the
       closest  thing  it has are colon-lists like <u>PATH</u>. For obvious reasons this means no element can contain a
       <b>:</b>.

       Variables can be marked or unmarked as PATH variables via the <b>--path</b> and <b>--unpath</b> options to <b>set</b>.

   <b>Special</b> <b>variables</b>
       You can change the settings of fish by changing the values of certain variables.

       <b>PATH</b>   A list of directories in which to search for commands. This is a common unix variable also used by
              other tools.

       <b>CDPATH</b> A list of directories in which the <u>cd</u> builtin looks for a new directory.

       <b>Locale</b> <b>Variables</b>
              The locale variables <u>LANG</u>, <u>LC_ALL</u>, <u>LC_COLLATE</u>, <u>LC_CTYPE</u>, <u>LC_MESSAGES</u>, <u>LC_MONETARY</u>, <u>LC_NUMERIC</u>, and
              <u>LANG</u> set the language option for the shell and subprograms. See the section <u>Locale</u>  <u>variables</u>  for
              more information.

       <b>Color</b> <b>variables</b>
              A number of variable starting with the prefixes <b>fish_color</b> and <b>fish_pager_color</b>. See <u>Variables</u> <u>for</u>
              <u>changing</u> <u>highlighting</u> <u>colors</u> for more information.

       <b>fish_term24bit</b>
              If  this  is  set  to 1, fish will assume the terminal understands 24-bit RGB color sequences, and
              won't translate them to the 256 or 16 color palette.  This is often detected automatically.

       <b>fish_term256</b>
              If this is set to 1, fish will assume the terminal understands 256  colors,  and  won't  translate
              matching colors down to the 16 color palette.  This is usually autodetected.

       <b>fish_ambiguous_width</b>
              controls  the  computed  width  of  ambiguous-width  characters.  This  should be set to 1 if your
              terminal renders these characters as single-width (typical), or 2 if double-width.

       <b>fish_emoji_width</b>
              controls whether fish assumes emoji render as 2 cells or 1 cell wide. This  is  necessary  because
              the  correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this
              if you see graphical glitching related to emoji (or other "special" characters). It should usually
              be auto-detected.

       <b>fish_autosuggestion_enabled</b>
              controls if <u>Autosuggestions</u> are enabled. Set it to 0 to  disable,  anything  else  to  enable.  By
              default they are on.

       <b>fish_handle_reflow</b>
              determines  whether  fish  should  try  to  repaint  the commandline when the terminal resizes. In
              terminals that reflow text this should be disabled. Set it  to  1  to  enable,  anything  else  to
              disable.

       <b>fish_key_bindings</b>
              the name of the function that sets up the keyboard shortcuts for the <u>command-line</u> <u>editor</u>.

       <b>fish_escape_delay_ms</b>
              sets  how  long  fish  waits  for  another key after seeing an escape, to distinguish pressing the
              escape key from the start of an escape sequence. The default is 30ms. Increasing it increases  the
              latency  but  allows  pressing  escape  instead  of  alt  for  alt+character  bindings.  For  more
              information, see <u>the</u> <u>chapter</u> <u>in</u> <u>the</u> <u>bind</u> <u>documentation</u>.

       <b>fish_sequence_key_delay_ms</b>
              sets how long fish waits for another key after seeing a key that is part of a longer sequence,  to
              disambiguate.  For  instance  if  you had bound <b>\cx\ce</b> to open an editor, fish would wait for this
              long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it  as  a
              ctrl-x  (by  default  this  would  copy  the  current  commandline to the clipboard). See also <u>Key</u>
              <u>sequences</u>.

       <b>fish_complete_path</b>
              determines where fish looks for completion. When trying to complete for a command, fish looks  for
              files in the directories in this variable.

       <b>fish_cursor_selection_mode</b>
              controls  whether  the  selection is inclusive or exclusive of the character under the cursor (see
              <u>Copy</u> <u>and</u> <u>Paste</u>).

       <b>fish_function_path</b>
              determines where fish looks for functions. When fish <u>autoloads</u> a function, it will look for  files
              in these directories.

       <b>fish_greeting</b>
              the  greeting  message printed on startup. This is printed by a function of the same name that can
              be overridden for more complicated changes (see <u>funced</u>)

       <b>fish_history</b>
              the current history session name. If set, all  subsequent  commands  within  an  interactive  fish
              session  will  be logged to a separate file identified by the value of the variable. If unset, the
              default session name "fish" is used. If set to an empty string, history is not saved to disk  (but
              is still available within the interactive session).

       <b>fish_trace</b>
              if  set and not empty, will cause fish to print commands before they execute, similar to <b>set</b> <b>-x</b> in
              bash. The trace is printed to the  path  given  by  the  <u>--debug-output</u>  option  to  fish  or  the
              <u>FISH_DEBUG_OUTPUT</u> variable. It goes to stderr by default.

       <b>FISH_DEBUG</b>
              Controls which debug categories <b>fish</b> enables for output, analogous to the <b>--debug</b> option.

       <b>FISH_DEBUG_OUTPUT</b>
              Specifies a file to direct debug output to.

       <b>fish_user_paths</b>
              a list of directories that are prepended to <u>PATH</u>. This can be a universal variable.

       <b>umask</b>  the  current  file  creation  mask.  The preferred way to change the umask variable is through the
              <u>umask</u> function. An attempt to set umask to an invalid value will always fail.

       <b>BROWSER</b>
              your preferred web browser. If this variable is set, fish will use the specified  browser  instead
              of the system default browser to display the fish documentation.

       Fish  also  provides  additional information through the values of certain environment variables. Most of
       these variables are read-only and their value can't be changed with <b>set</b>.

       <b>_</b>      the name of the currently running command (though this  is  deprecated,  and  the  use  of  <b>status</b>
              <b>current-command</b> is preferred).

       <b>argv</b>   a list of arguments to the shell or function. <b>argv</b> is only defined when inside a function call, or
              if  fish  was invoked with a list of arguments, like <b>fish</b> <b>myscript.fish</b> <b>foo</b> <b>bar</b>. This variable can
              be changed.

       <b>CMD_DURATION</b>
              the runtime of the last command in milliseconds.

       <b>COLUMNS</b> <b>and</b> <b>LINES</b>
              the current size of the terminal in height and width. These values are only used by  fish  if  the
              operating system does not report the size of the terminal. Both variables must be set in that case
              otherwise a default of 80x24 will be used. They are updated when the window size changes.

       <b>fish_kill_signal</b>
              the signal that terminated the last foreground job, or 0 if the job exited normally.

       <b>fish_killring</b>
              a list of entries in fish's <u>kill</u> <u>ring</u> of cut text.

       <b>fish_read_limit</b>
              how many bytes fish will process with <u>read</u> or in a <u>command</u> <u>substitution</u>.

       <b>fish_pid</b>
              the process ID (PID) of the shell.

       <b>history</b>
              a list containing the last commands that were entered.

       <b>HOME</b>   the user's home directory. This variable can be changed.

       <b>hostname</b>
              the machine's hostname.

       <b>IFS</b>    the  internal  field separator that is used for word splitting with the <u>read</u> builtin. Setting this
              to the empty string will also disable line splitting in <u>command</u> <u>substitution</u>. This variable can be
              changed.

       <b>last_pid</b>
              the process ID (PID) of the last background process.

       <b>PWD</b>    the current working directory.

       <b>pipestatus</b>
              a list of exit statuses of all processes that made up the last executed pipe. See <u>exit</u> <u>status</u>.

       <b>SHLVL</b>  the level of nesting of shells. Fish increments this in interactive shells,  otherwise  it  simply
              passes it along.

       <b>status</b> the  <u>exit</u>  <u>status</u>  of the last foreground job to exit. If the job was terminated through a signal,
              the exit status will be 128 plus the signal number.

       <b>status_generation</b>
              the "generation" count of <b>$status</b>. This  will  be  incremented  only  when  the  previous  command
              produced an explicit status. (For example, background jobs will not increment this).

       <b>TERM</b>   the  type  of the current terminal. When fish tries to determine how the terminal works - how many
              colors it supports, what sequences it sends for keys and other things - it looks at this  variable
              and the corresponding information in the terminfo database (see <b>man</b> <b>terminfo</b>).

              Note: Typically this should not be changed as the terminal sets it to the correct value.

       <b>USER</b>   the current username. This variable can be changed.

       <b>EUID</b>   the current effective user id, set by fish at startup. This variable can be changed.

       <b>version</b>
              the  version  of  the  currently  running  fish  (also  available  as  <b>FISH_VERSION</b>  for  backward
              compatibility).

       As a convention, an uppercase name is usually used for exported variables, while lowercase variables  are
       not  exported.  (<b>CMD_DURATION</b> is an exception for historical reasons). This rule is not enforced by fish,
       but it is good coding practice to use casing to distinguish between exported and unexported variables.

       Fish also uses some variables internally, their name usually starting with <b>__fish</b>. These are internal and
       should not typically be modified directly.

   <b>The</b> <b>status</b> <b>variable</b>
       Whenever a process exits, an exit status is returned to the program that started it (usually the  shell).
       This  exit  status  is  an  integer  number, which tells the calling application how the execution of the
       command went. In general, a zero exit status means that the  command  executed  without  problem,  but  a
       non-zero exit status means there was some form of problem.

       Fish stores the exit status of the last process in the last job to exit in the <b>status</b> variable.

       If fish encounters a problem while executing a command, the status variable may also be set to a specific
       value:

       • 0 is generally the exit status of commands if they successfully performed the requested operation.

       • 1 is generally the exit status of commands if they failed to perform the requested operation.

       • 121 is generally the exit status of commands if they were supplied with invalid arguments.

       • 123 means that the command was not executed because the command name contained invalid characters.

       • 124  means  that the command was not executed because none of the wildcards in the command produced any
         matches.

       • 125 means that while an executable with the specified name was located, the operating system could  not
         actually execute the command.

       • 126 means that while a file with the specified name was located, it was not executable.

       • 127 means that no function, builtin or command with the given name could be located.

       If a process exits through a signal, the exit status will be 128 plus the number of the signal.

       The  status can be negated with <u>not</u> (or <b>!</b>), which is useful in a <u>condition</u>. This turns a status of 0 into
       1 and any non-zero status into 0.

       There is also <b>$pipestatus</b>, which is a list of all <b>status</b> values of processes in a pipe. One difference is
       that <u>not</u> applies to <b>$status</b>, but not <b>$pipestatus</b>, because it loses information.

       For example:

          not cat file | grep -q fish
          echo status is: $status pipestatus is $pipestatus

       Here <b>$status</b> reflects the status of <b>grep</b>, which returns 0 if it found something, negated with <b>not</b>  (so  1
       if  it  found something, 0 otherwise). <b>$pipestatus</b> reflects the status of <b>cat</b> (which returns non-zero for
       example when it couldn't find the file) and <b>grep</b>, without the negation.

       So if both <b>cat</b> and <b>grep</b> succeeded, <b>$status</b> would be 1 because of the <b>not</b>, and <b>$pipestatus</b> would be 0  and
       0.

       It's  possible  for  the  first command to fail while the second succeeds. One common example is when the
       second program quits early.

       For example, if you have a pipeline like:

          cat file1 file2 | head -n 50

       This will tell <b>cat</b> to print two files, "file1" and "file2", one after the other, and the <b>head</b>  will  then
       only print the first 50 lines. In this case you might often see this constellation:

          &gt; cat file1 file2 | head -n 50
          # 50 lines of output
          &gt; echo $pipestatus
          141 0

       Here,  the "141" signifies that <b>cat</b> was killed by signal number 13 (128 + 13 == 141) - a <b>SIGPIPE</b>. You can
       also use <u>fish_kill_signal</u> to see the signal number. This happens because it was still working,  and  then
       <b>head</b> closed the pipe, so <b>cat</b> received a signal that it didn't ignore and so it died.

       Whether  <b>cat</b>  here  will see a SIGPIPE depends on how long the file is and how much it writes at once, so
       you might see a pipestatus of "0 0", depending on the implementation. This is a general  unix  issue  and
       not specific to fish. Some shells feature a "pipefail" feature that will call a pipeline failed if one of
       the processes in it failed, and this is a big problem with it.

   <b>Locale</b> <b>Variables</b>
       The  "locale"  of  a  program  is  its  set of language and regional settings that depend on language and
       cultural convention. In UNIX, these are made up of several categories. The categories are:

       <b>LANG</b>   This is the typical environment variable for specifying a locale. A user may set this variable  to
              express  the  language  they  speak, their region, and a character encoding. The actual values are
              specific to their platform, except for special values like <b>C</b> or <b>POSIX</b>.

              The value of LANG is used for each category unless the variable  for  that  category  was  set  or
              LC_ALL is set. So typically you only need to set LANG.

              An  example value might be <b>en_US.UTF-8</b> for the american version of english and the UTF-8 encoding,
              or <b>de_AT.UTF-8</b> for the austrian version of german and the UTF-8 encoding.  Your  operating  system
              might have a <b>locale</b> command that you can call as <b>locale</b> <b>-a</b> to see a list of defined locales.

              A UTF-8 encoding is recommended.

       <b>LC_ALL</b> Overrides  the  <u>LANG</u>  environment  variable and the values of the other <b>LC_*</b> variables. If this is
              set, none of the other variables are used for anything.

              Usually the other variables should be used instead. Use LC_ALL only  when  you  need  to  override
              something.

       <b>LC_COLLATE</b>
              This determines the rules about equivalence of cases and alphabetical ordering: collation.

       <b>LC_CTYPE</b>
              This determines classification rules, like if the type of character is an alpha, digit, and so on.
              Most  importantly, it defines the text <u>encoding</u> - which numbers map to which characters. On modern
              systems, this should typically be something ending in "UTF-8".

       <b>LC_MESSAGES</b>
              <b>LC_MESSAGES</b> determines the language in which messages are diisplayed.

       <b>LC_MONETARY</b>
              Determines currency, how it is formatted, and the symbols used.

       <b>LC_NUMERIC</b>
              Sets the locale for formatting numbers.

       <b>LC_TIME</b>
              Sets the locale for formatting dates and times.

</pre><h4><b>BUILTIN</b> <b>COMMANDS</b></h4><pre>
       Fish includes a number of commands in the shell directly. We call these "builtins". These include:

       • Builtins that manipulate the shell state - <u>cd</u> changes directory, <u>set</u> sets variables

       • Builtins for dealing with data, like <u>string</u> for strings and <u>math</u> for numbers, <u>count</u> for counting  lines
         or arguments, <u>path</u> for dealing with path

       • <u>status</u> for asking about the shell's status

       • <u>printf</u> and <u>echo</u> for creating output

       • <u>test</u> for checking conditions

       • <u>argparse</u> for parsing function arguments

       • <u>source</u>  to  read  a  script  in  the current shell (so changes to variables stay) and <u>eval</u> to execute a
         string as script

       • <u>random</u> to get random numbers or pick a random element from a list

       • <u>read</u> for reading from a pipe or the terminal

       For a list of all builtins, use <b>builtin</b> <b>-n</b>.

       For a list of all builtins, functions and commands shipped with fish,  see  the  <u>list</u>  <u>of</u>  <u>commands</u>.  The
       documentation is also available by using the <b>--help</b> switch.

</pre><h4><b>COMMAND</b> <b>LOOKUP</b></h4><pre>
       When fish is told to run something, it goes through multiple steps to find it.

       If it contains a <b>/</b>, fish tries to execute the given file, from the current directory on.

       If it doesn't contain a <b>/</b>, it could be a function, builtin, or external command, and so fish goes through
       the full lookup.

       In order:

       1. It tries to resolve it as a <u>function</u>.

          • If the function is already known, it uses that

          • If there is a file of the name with a ".fish" suffix in <u>fish_function_path</u>, it <u>loads</u> <u>that</u>. (If there
            is more than one file only the first is used)

          • If the function is now defined it uses that

       2. It tries to resolve it as a <u>builtin</u>.

       3. It tries to find an executable file in <u>PATH</u>.

          • If it finds a file, it tells the kernel to run it.

          • If  the  kernel  knows how to run the file (e.g. via a <b>#!</b> line - <b>#!<a href="file:/bin/sh">/bin/sh</a></b> or <b>#!/usr/bin/python</b>), it
            does it.

          • If the kernel reports that it couldn't run it because of a missing interpreter, and the file  passes
            a rudimentary check, fish tells <b><a href="file:/bin/sh">/bin/sh</a></b> to run it.

       If none of these work, fish runs the function <u>fish_command_not_found</u> and sets <u>status</u> to 127.

       You can use <u>type</u> to see how fish resolved something:

          &gt; type --short --all echo
          echo is a builtin
          echo is <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?echo">/usr/bin/echo</a>

</pre><h4><b>QUERYING</b> <b>FOR</b> <b>USER</b> <b>INPUT</b></h4><pre>
       Sometimes,  you  want to ask the user for input, for instance to confirm something. This can be done with
       the <u>read</u> builtin.

       Let's make up an example. This function will <u>glob</u> the files in all the directories it gets as  <u>arguments</u>,
       and  <u>if</u>  there  are <u>more</u> <u>than</u> <u>five</u> it will ask the user if it is supposed to show them, but only if it is
       connected to a terminal:

          function show_files
              # This will glob on all arguments. Any non-directories will be ignored.
              set -l files $argv/*

              # If there are more than 5 files
              if test (count $files) -gt 5
                  # and both stdin (for reading input)
                  # and stdout (for writing the prompt)
                  # are terminals
                  and isatty stdin
                  and isatty stdout
                  # Keep asking until we get a valid response
                  while read --nchars 1 -l response --prompt-str="Are you sure? (y/n)"
                        or return 1 # if the read was aborted with ctrl-c/ctrl-d
                      switch $response
                          case y Y
                              echo Okay
                              # We break out of the while and go on with the function
                              break
                          case n N
                              # We return from the function without printing
                              echo Not showing
                              return 1
                          case '*'
                              # We go through the while loop and ask again
                              echo Not valid input
                              continue
                      end
                  end
              end

              # And now we print the files
              printf '%s\n' $files
          end

       If you run this as <b>show_files</b> <b>/</b>, it will most likely ask you until you press Y/y or N/n. If you run  this
       as  <b>show_files</b> <b>/</b> <b>|</b> <b>cat</b>, it will print the files without asking. If you run this as <b>show_files</b> <b>.</b>, it might
       just print something without asking because there are fewer than five files.

</pre><h4><b>SHELL</b> <b>VARIABLE</b> <b>AND</b> <b>FUNCTION</b> <b>NAMES</b></h4><pre>
       The names given to variables and functions (so-called "identifiers") have to follow certain rules:

       • A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and
         end with any of those characters.

       • A function name cannot be empty. It may not begin with a hyphen ("-")  and  may  not  contain  a  slash
         ("/").  All other characters, including a space, are valid. A function name also can't be the same as a
         reserved keyword or essential builtin like <b>if</b> or <b>set</b>.

       • A bind mode name (e.g., <b>bind</b> <b>-m</b> <b>abc</b> <b>...</b>) must be a valid variable name.

       Other things have other restrictions. For instance what is allowed for file names depends on your system,
       but at the very least they cannot contain a "/" (because  that  is  the  path  separator)  or  NULL  byte
       (because that is how UNIX ends strings).

</pre><h4><b>CONFIGURATION</b> <b>FILES</b></h4><pre>
       When  fish  is  started,  it  reads  and  runs  its configuration files. Where these are depends on build
       configuration and environment variables.

       The main file is <b><a href="file:~/.config/fish/config.fish">~/.config/fish/config.fish</a></b> (or more precisely <b>$XDG_CONFIG_HOME/fish/config.fish</b>).

       Configuration files are run in the following order:

       • Configuration snippets (named <b>*.fish</b>) in the directories:

         • <b>$__fish_config_dir/conf.d</b> (by default, <b><a href="file:~/.config/fish/conf.d/">~/.config/fish/conf.d/</a></b>)

         • <b>$__fish_sysconf_dir/conf.d</b> (by default, <b>/etc/fish/conf.d/</b>)

         • Directories for others to ship configuration snippets for their software:

           • the  directories  under  <b>$__fish_user_data_dir</b>  (usually  <b><a href="file:~/.local/share/fish">~/.local/share/fish</a></b>,  controlled  by  the
             <b>XDG_DATA_HOME</b> environment variable)

           • a   <b>fish/vendor_conf.d</b>   directory   in   the   directories   listed   in  <b>$XDG_DATA_DIRS</b>  (default
             <b><a href="file:/usr/share/fish/vendor_conf.d">/usr/share/fish/vendor_conf.d</a></b> and <b>/usr/local/share/fish/vendor_conf.d</b>)

           These directories are also accessible in <b>$__fish_vendor_confdirs</b>.   Note  that  changing  that  in  a
           running fish won't do anything as by that point the directories have already been read.

         If  there  are multiple files with the same name in these directories, only the first will be executed.
         They are executed in order of their filename, sorted (like globs) in a natural order (i.e.  "01"  sorts
         before "2").

       • System-wide  configuration  files, where administrators can include initialization for all users on the
         system  -  similar  to  <b><a href="file:/etc/profile">/etc/profile</a></b>  for  POSIX-style  shells  -   in   <b>$__fish_sysconf_dir</b>   (usually
         <b>/etc/fish/config.fish</b>).

       • User   configuration,   usually   in  <b><a href="file:~/.config/fish/config.fish">~/.config/fish/config.fish</a></b>  (controlled  by  the  <b>XDG_CONFIG_HOME</b>
         environment variable, and accessible as <b>$__fish_config_dir</b>).

       <b><a href="file:~/.config/fish/config.fish">~/.config/fish/config.fish</a></b> is sourced <u>after</u> the snippets. This is so you can copy snippets  and  override
       some of their behavior.

       These files are all executed on the startup of every shell. If you want to run a command only on starting
       an  interactive  shell,  use  the  exit status of the command <b>status</b> <b>--is-interactive</b> to determine if the
       shell is interactive. If you want to run a command only when using a login shell, use  <b>status</b>  <b>--is-login</b>
       instead. This will speed up the starting of non-interactive or non-login shells.

       If  you  are  developing  another  program,  you may want to add configuration for all users of fish on a
       system. This is discouraged; if not carefully written, they may have side-effects or slow the startup  of
       the  shell.  Additionally,  users  of  other  shells  won't benefit from the fish-specific configuration.
       However, if they are required, you can install them to the "vendor" configuration directory. As this path
       may vary from system to system, <b>pkg-config</b> should be used to discover it: <b>pkg-config</b>  <b>--variable</b>  <b>confdir</b>
       <b>fish</b>.

       For  system  integration,  fish  also ships a file called <b>__fish_build_paths.fish</b>. This can be customized
       during build, for instance because your system requires special paths to be used.

</pre><h4><b>FUTURE</b> <b>FEATURE</b> <b>FLAGS</b></h4><pre>
       Feature flags are how fish stages changes that might break scripts. Breaking changes  are  introduced  as
       opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.

       You can see the current list of features via <b>status</b> <b>features</b>:

          &gt; status features
          stderr-nocaret          on  3.0 ^ no longer redirects stderr
          qmark-noglob            on  3.0 ? no longer globs
          regex-easyesc           on  3.1 string replace -r needs fewer \\'s
          ampersand-nobg-in-token on  3.4 &amp; only backgrounds if followed by a separating character
          remove-percent-self     off 4.0 %self is no longer expanded (use $fish_pid)
          test-require-arg        off 4.0 builtin test requires an argument
          keyboard-protocols      on  4.0 Use keyboard protocols (kitty, xterm's modifyotherkeys

       Here is what they mean:

       • <b>stderr-nocaret</b>  was  introduced  in  fish  3.0 and cannot be turned off since fish 3.5. It can still be
         tested for compatibility, but a <b>no-stderr-nocaret</b> value will simply be ignored.  The  flag  made  <b>^</b>  an
         ordinary character instead of denoting an stderr redirection. Use <b>2&gt;</b> instead.

       • <b>qmark-noglob</b>  was  also  introduced  in  fish 3.0 (and made the default in 4.0). It makes <b>?</b> an ordinary
         character instead of a single-character glob. Use a <b>*</b> instead (which will match multiple characters) or
         find other ways to match files like <b>find</b>.

       • <b>regex-easyesc</b> was introduced in 3.1 (and made the default in 3.5).  It  makes  it  so  the  replacement
         expression  in  <b>string</b>  <b>replace</b>  <b>-r</b> does one fewer round of escaping. Before, to escape a backslash you
         would have to use <b>string</b> <b>replace</b> <b>-ra</b> <b>'([ab])'</b> <b>'\\\\\\\\$1'</b>. After, just <b>'\\\\$1'</b> is enough. Check  your
         <b>string</b> <b>replace</b> calls if you use this anywhere.

       • <b>ampersand-nobg-in-token</b>  was introduced in fish 3.4 (and made the default in 3.5). It makes it so a <b>&amp;</b> i
         no longer interpreted as the backgrounding operator in the middle of a  token,  so  dealing  with  URLs
         becomes  easier.  Either  put spaces or a semicolon after the <b>&amp;</b>. This is recommended formatting anyway,
         and <b>fish_indent</b> will have done it for you already.

       • <b>remove-percent-self</b> turns off the special <b>%self</b> expansion. It was introduced in 4.0. To get fish's pid,
         you can use the <u>fish_pid</u> variable.

       • <b>test-require-arg</b> removes <u>builtin</u> <u>test</u>'s one-argument form (<b>test</b> <b>"string"</b>. It was introduced in 4.0.  To
         test  if  a  string is non-empty, use <b>test</b> <b>-n</b> <b>"string"</b>. If disabled, any call to <b>test</b> that would change
         sends a <u>debug</u> <u>message</u> of category "deprecated-test", so starting fish with <b>fish</b> <b>--debug=deprecated-test</b>
         can be used to find offending calls.

       • <b>keyboard-protocols</b> lets fish turn on various keyboard protocols including the kitty keyboard  protocol.
         It  was  introduced  in 4.0 and is on by default.  Disable it with <b>no-keyboard-protocols</b> to work around
         bugs in your terminal.

       These changes are introduced off by default. They can be enabled on a per session basis:

          &gt; fish --features qmark-noglob,regex-easyesc

       or opted into globally for a user:

          &gt; set -U fish_features regex-easyesc qmark-noglob

       Features will only be set on startup, so this variable will only  take  effect  if  it  is  universal  or
       exported.

       You  can  also  use  the version as a group, so <b>3.0</b> is equivalent to "stderr-nocaret" and "qmark-noglob".
       Instead of a version, the special group <b>all</b> enables all features.

       Prefixing a feature with <b>no-</b> turns it off instead. E.g. to reenable the <b>?</b> single-character glob:

          set -Ua fish_features no-qmark-noglob

</pre><h4><b>EVENT</b> <b>HANDLERS</b></h4><pre>
       When defining a new function in fish, it is possible to make it into an event handler,  i.e.  a  function
       that  is automatically run when a specific event takes place. Events that can trigger a handler currently
       are:

       • When a signal is delivered

       • When a job exits

       • When the value of a variable is updated

       • When the prompt is about to be shown

       Example:

       To specify a signal handler for the WINCH signal, write:

          function my_signal_handler --on-signal WINCH
              echo Got WINCH signal!
          end

       Fish already has the following named events for the <b>--on-event</b> switch:

       • <b>fish_prompt</b> is emitted whenever a new fish prompt is about to be displayed.

       • <b>fish_preexec</b> is emitted right before executing an interactive command. The commandline is passed as the
         first parameter. Not emitted if command is empty.

       • <b>fish_posterror</b> is emitted right after executing a command with syntax errors. The commandline is passed
         as the first parameter.

       • <b>fish_postexec</b> is emitted right after executing an interactive command. The commandline is passed as the
         first parameter. Not emitted if command is empty.

       • <b>fish_exit</b> is emitted right before fish exits.

       • <b>fish_cancel</b> is emitted when a commandline is cleared.

       • <b>fish_focus_in</b> is emitted when fish's terminal gains focus.

       • <b>fish_focus_out</b> is emitted when fish's terminal loses focus.

       Events can be fired with the <u>emit</u> command, and do not have to be defined before. The names just  need  to
       match. For example:

          function handler --on-event imdone
              echo generator is done $argv
          end

          function generator
              sleep 1
              # The "imdone" is the name of the event
              # the rest is the arguments to pass to the handler
              emit imdone with $argv
          end

       If  there  are  multiple  handlers for an event, they will all be run, but the order might change between
       fish releases, so you should not rely on it.

       Please note that event handlers only become active when a function is loaded, which  means  you  need  to
       otherwise  <u>source</u> or execute a function instead of relying on <u>autoloading</u>. One approach is to put it into
       your <u>configuration</u> <u>file</u>.

       For more information on how to define new event handlers, see the documentation for the <u>function</u> command.

</pre><h4><b>DEBUGGING</b> <b>FISH</b> <b>SCRIPTS</b></h4><pre>
       Fish includes basic built-in debugging facilities that allow you to stop execution  of  a  script  at  an
       arbitrary point. When this happens you are presented with an interactive prompt where you can execute any
       fish command to inspect or change state (there are no debug commands as such). For example, you can check
       or  change  the  value  of  any  variables  using  <u>printf</u> and <u>set</u>. As another example, you can run <u>status</u>
       <u>print-stack-trace</u> to see how the current breakpoint was  reached.  To  resume  normal  execution  of  the
       script, simply type <u>exit</u> or <b>ctrl-d</b>.

       To  start  a  debug  session  simply  insert the <u>builtin</u> <u>command</u> <b>breakpoint</b> at the point in a function or
       script where you wish to gain control, then run the function or script. Also, the default action  of  the
       <b>TRAP</b>  signal is to call this builtin, meaning a running script can be actively debugged by sending it the
       <b>TRAP</b> signal (<b>kill</b> <b>-s</b> <b>TRAP</b> <b>&lt;PID&gt;</b>). There  is  limited  support  for  interactively  setting  or  modifying
       breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from)
       other functions by using the <b>funced</b> function to edit the definition of a function, but it is not possible
       to add or remove a breakpoint from the function/script currently loaded and being executed.

       Another  way  to  debug script issues is to set the <u>fish_trace</u> variable, e.g. <b>fish_trace=1</b> <b>fish_prompt</b> to
       see which commands fish executes when running the <u>fish_prompt</u> function.

   <b>Profiling</b> <b>fish</b> <b>scripts</b>
       If  you  specifically  want  to  debug  performance  issues,  <b>fish</b>  can  be  run   with   the   <b>--profile</b>
       <b>/path/to/profile.log</b>  option  to  save  a  profile  to  the  specified  path. This profile log includes a
       breakdown of how long each step in the execution took.

       For example:

          &gt; fish --profile /tmp/sleep.prof -ic 'sleep 3s'
          &gt; cat /tmp/sleep.prof
          Time    Sum     Command
          3003419 3003419 &gt; sleep 3s

       This will show the time for each command itself in the first column, the time for the command  and  every
       subcommand  (like  any  commands  inside  of  a  <u>function</u> or <u>command</u> <u>substitutions</u>) in the second and the
       command itself in the third, separated with tabs.

       The time is given in microseconds.

       To see the slowest commands last, <b>sort</b> <b>-nk2</b> <b>/path/to/logfile</b> is useful.

       For profiling fish's startup there is also <b>--profile-startup</b> <b>/path/to/logfile</b>.

       See <u>fish</u> for more information.

</pre><h4><b>AUTHOR</b></h4><pre>
       fish-shell developers

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2024, fish-shell developers

4.0                                               Mar 13, 2025                                  <u><a href="../man1/FISH-LANGUAGE.1.html">FISH-LANGUAGE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>