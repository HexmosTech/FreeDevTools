<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tifftopnm - convert a TIFF file into a PNM image</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/netpbm">netpbm_11.09.02-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tifftopnm - convert a TIFF file into a PNM image

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>tifftopnm</b>

       [<b>-alphaout=</b>{<u>alpha-filename</u>,<b>-</b>}]  [<b>-headerdump</b>] [<b>-verbose</b>] [<b>-respectfillorder</b>] [<b>-byrow</b>] [<b>-orientraw</b>] [<u>tiff-</u>
       <u>filename</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This program is part of <b><a href="../man1/Netpbm.1.html">Netpbm</a></b>(1).

       <b>tifftopnm</b> reads a TIFF file as input and produces a PNM image as output.  The type  of  the  output  file
       depends  on the input file - if it's black and white, <b>tifftopnm</b> generates a PBM image; if it's grayscale,
       it generates a PGM image; otherwise, the output is PPM.  The program tells you which type it is writing.

       If the TIFF file contains multiple images (multiple "directories"), <b>tifftopnm</b> generates a multi-image PNM
       output stream.  Before Netpbm 10.27 (March 2005), however, it would just ignore all but the  first  input
       image.

       The  <u>tiff-filename</u>  argument  names  the  file that contains the Tiff image.  If you specify "-" or don't
       specify this argument, <b>tifftopnm</b> uses Standard Input.

       In either case, before Netpbm 10.70 (March 2015), the file must be seekable.  That means no pipe, but any
       regular file is fine.  In current Netpbm, the file need not be  seekable,  but  if  it  isn't,  <b>tifftopnm</b>
       creates a temporary regular file containing the entire image, so you must have resources for that (and it
       may defeat your reason for using a pipe).

   <b>TIFF</b> <b>Capability</b>
       <b>pamtotiff</b>  uses  the  Libtiff.org TIFF library (or whatever equivalent you provide) to interpret the TIFF
       input.  So the set of files it is able to interpret is determined mostly by that library.

       This program cannot read every possible TIFF file -- there are myriad  variations  of  the  TIFF  format.
       However,  it  does  understand  monochrome  and  gray  scale, RGB, RGBA (red/green/blue with transparency
       channel), CMYK (Cyan-Magenta-Yellow-Black ink color separation), and color palette TIFF  files.   An  RGB
       file  can  have  either single plane (interleaved) color or multiple plane format.  The program reads 1-8
       and 16 bit-per-sample input, the latter in either bigendian  or  littlendian  encoding.   Tiff  directory
       information may also be either bigendian or littlendian.

       There  are  many TIFF formats that <b>tifftopnm</b> can read only if the image is small enough to fit in memory.
       <b>tifftopnm</b> uses the TIFF library's TIFFRGBAImageGet() function to process the TIFF image  if  it  can  get
       enough  memory  for  TIFFRGBAImageGet()  to  store  the  whole  image  in  memory  at  once  (that's what
       TIFFRGBAImageGet() does).  If not, <b>tifftopnm</b> uses a more primitive row-by-row conversion  strategy  using
       the  raw  data returned by TIFFReadScanLine() and native intelligence.  That native intelligence does not
       know as many formats as TIFFRGBAImageGet() does.  And certain compressed formats simply  cannot  be  read
       with TIFFReadScanLine().

       Before  Netpbm  10.11  (October 2002), <b>tifftopnm</b> never used TIFFRGBAImageGet(), so it could not interpret
       many of the formats it can interpret today.

       There is no fundamental reason that this program could not read other kinds of TIFF files even when  they
       don't fit in memory all at once.  The existing limitations are mainly because no one has asked for more.

   <b>Output</b> <b>Image</b>
       The PNM output has the same maxval as the Tiff input, except that if the Tiff input is colormapped (which
       implies  a  maxval  of  65535)  the  PNM  output  has  a  maxval  of 255.  Though this may result in lost
       information, such input images hardly ever actually have more color  resolution  than  a  maxval  of  255
       provides  and  people  often  cannot  deal  with  PNM  files that have maxval &gt; 255.  By contrast, a non-
       colormapped Tiff image that doesn't need a maxval &gt; 255 doesn't <u>have</u> a maxval &gt; 255,  so  when  <b>tifftopnm</b>
       sees a non-colormapped maxval &gt; 255, it takes it seriously and produces a matching output maxval.

       Another  exception  is  where  the TIFF maxval is greater than 65535, which is the maximum allowed by the
       Netpbm formats.  In that case, <b>tifftopnm</b> uses a maxval of 65535, and you lose  some  information  in  the
       conversion.

</pre><h4><b>OPTIONS</b></h4><pre>
       In  addition  to  the options common to all programs based on libnetpbm (most notably <b>-quiet</b>, see  Common
       Options ), <b>tifftopnm</b> recognizes the following command line options:

       You may abbreviate any option to its shortest unique prefix.  You may use two hyphens instead of  one  in
       options.  You may separate an option and its value either by an equals sign or white space.

       <b>-alphaout=</b><u>alpha-filename</u>
              <b>tifftopnm</b> creates a PGM file containing the alpha channel values in the input image.  If the input
              image  doesn't  contain  a  transparency  channel,  the  <u>alpha-filename</u>  file  contains  all  zero
              (transparent) transparency values.  If you don't specify <b>-alphaout</b>,

              <b>tifftopnm</b> does not generate a transparency file, and  if  the  input  image  has  an  transparency
              channel, <b>tifftopnm</b> simply discards it.

              If  you specify <b>-</b> as the filename, <b>tifftopnm</b> writes the transparency output to Standard Output and
              discards the image.

              See <b><a href="../man1/pamcomp.1.html">pamcomp</a></b>(1) for one way to use the transparency output file.

       <b>-respectfillorder</b>
              By default, <b>tifftopnm</b>  ignores the  "fillorder"  tag  in  the  TIFF  input,  which  means  it  may
              incorrectly  interpret the image.  To make it follow the spec, use this option.  For a lengthy but
              engaging discussion of why <b>tifftopnm</b> works this way and how to use the  <b>-respectfillorder</b>  option,
              see the note on fillorder below.

       <b>-byrow</b> This option can make <b>tifftopnm</b> run faster.

              <b>tifftopnm</b> has two ways to do the conversion from Tiff to PNM, using respectively two facilities of
              the TIFF library:

       Whole Image
              Decode  the  entire  image  into memory at once, using <b>TIFFRGBAImageGet()</b>, then convert to PNM and
              output row by row.

       Row By Row
              Read, convert, and output one row at a time using <b>TIFFReadScanline()</b>

              Whole Image is preferable because the  Tiff  library  does  more  of  the  work,  which  means  it
              understands  more  of  the Tiff format possibilities now and in the future.  Also, some compressed
              TIFF formats don't allow you to extract an individual row.

              Row By Row uses far less memory, which means with large images, it can run in  environments  where
              Whole  Image  cannot and may also run faster.  And because Netpbm code does more of the work, it's
              possible that it can be more flexible or at least give better diagnostic  information  if  there's
              something wrong with the TIFF.

              The  Netpbm native code may do something correctly that the TIFF library does incorrectly, or vice
              versa.

              In Netpbm, we stress function over performance, so by default we try Whole Image first, and if  we
              can't  get enough memory for the decoded image or <b>TIFFRGBAImageGet()</b> fails, we fall back to Row By
              Row.  But if you specify the <b>-byrow</b> option, <b>tifftopnm</b> will not attempt Whole Image.  If Row By Row
              does not work, it simply fails.

              See Color Separation (CMYK) TIFFs  for a description of one way Row By  Row  makes  a  significant
              difference in your results.

              Whole  Image  costs  you  precision  when  your  TIFF  image  uses  more  than  8 bits per sample.
              <b>TIFFRGBAImageGet()</b> converts the samples to 8 bits.  <b>tifftopnm</b> then  scales  them  back  to  maxval
              65535, but the lower 8 bits of information is gone.

              In  many  versions of the TIFF library, <b>TIFFRGBAImageGet()</b> does not correctly interpret TIFF files
              in which the raster orientation is column-major (i.e. a row of the  raster  is  a  column  of  the
              image).  With such a TIFF library and file, you must use <b>-byrow</b> to get correct output.

              Before  Netpbm  10.11  (October 2002), <b>tifftopnm</b> always did Row By Row.  Netpbm 10.12 always tried
              Whole Image first.  <b>-byrow</b> came in with Netpbm 10.13 (January 2003).

       <b>-orientraw</b>
              A TIFF stream contains raster data which can  be  arranged  in  the  stream  various  ways.   Most
              commonly, it is arranged by rows, with the top row first, and the pixels left to right within each
              row, but many other orientations are possible.

              The  common orientation is the same one the Netpbm formats use, so <b>tifftopnm</b> can do its jobs quite
              efficiently when the TIFF raster is oriented that way.

              But if the TIFF raster is oriented any other way, it can take a considerable amount of  processing
              for <b>tifftopnm</b> to convert it to Netpbm format.

              <b>-orientraw</b>  says  to  produce  an  output  image that represents the raw raster in the TIFF stream
              rather than the image the TIFF stream is supposed to represent.   In  the  output,  the  top  left
              corner  corresponds to the start of the TIFF raster, the next pixel to the right is the next pixel
              in the TIFF raster, etc.  <b>tifftopnm</b> can do this easily, but you don't get  the  right  image  out.
              You  can  use  <b>pamflip</b> to turn the output into the image the TIFF stream represents (but if you do
              that, you pretty much lose the benefit of <b>-orientraw</b>).

              With this option, <b>tifftopnm</b> always uses the Row By Row method (see <b>-byrow</b>).

              This option was new in Netpbm 10.42 (March  2008).   Before  that,  <b>tifftopnm</b>  generally  produces
              arbitrary results with TIFF images that have an orientation other than the common one.

       <b>-verbose</b>
              Print extra messages to Standard Error about the conversion.

       <b>-headerdump</b>
              Also  dump TIFF file information to stderr.  This information may be useful in debugging TIFF file
              conversion problems.

</pre><h4><b>NOTES</b></h4><pre>
   <b>Fillorder</b>
       There is a piece of information in the header of a TIFF image called "fillorder." The TIFF  specification
       quite  clearly  states  that  this  value  tells  the  order  in which bits are arranged in a byte in the
       description of the image's pixels.  There are two options, assuming that the image  has  a  format  where
       more  than one pixel can be represented by a single byte: 1) the byte is filled from most significant bit
       to least significant bit going left to right in the image; and 2) the opposite.

       However, there is confusion in the world as to the meaning of fillorder.  Evidence shows that some people
       believe it has to do with byte order when a single value is represented by two bytes.

       These people cause TIFF images to be created  that,  while  they  use  a  MSB-to-LSB  fillorder,  have  a
       fillorder  tag  that says they used LSB-to-MSB.  A program that properly interprets a TIFF image will not
       end up with the image that the author intended in this case.

       For a long time, <b>tifftopnm</b> did not understand fillorder itself and assumed the fillorder  was  MSB-to-LSB
       regardless  of the fillorder tag in the TIFF header.  And as far as I know, there is no legitimate reason
       to use a fillorder other than MSB-to-LSB.  So users of <b>tifftopnm</b> were happily  using  those  TIFF  images
       that had incorrect fillorder tags.

       So  that  those  users  can  continue  to be happy, <b>tifftopnm</b> today continues to ignore the fillorder tag
       unless you tell it not to.  (It does, however, warn you when the fillorder tag does  not  say  MSB-to-LSB
       that the tag is being ignored).

       If  for  some  reason you have a TIFF image that actually has LSB-to-MSB fillorder, and its fillorder tag
       correctly indicates that, you must use the <b>-respectfillorder</b> option on <b>tifftopnm</b> to get proper results.

       Examples of incorrect TIFF images are at <a href="ftp://weather.noaa.gov">ftp://weather.noaa.gov</a>.    They  are  apparently  created  by  a
       program called <b>faxtotiff</b>.

       This note was written on January 1, 2002.

   <b>Color</b> <b>Separation</b> <b>(CMYK)</b> <b>TIFFs</b>
       Some  TIFF  images contain color information in CMYK form, whereas PNM images use RGB.  There are various
       formulas for converting between these two forms, and <b>tifftopnm</b> can use either of two.

       The TIFF library (Version 3.5.4 from libtiff.org) uses  Y=(1-K)*(1-B)  (similar  for  R  and  G)  in  its
       TIFFRGBAImageGet()  service.   When  <b>tifftopnm</b> works in Whole Image mode, it uses that service, so that's
       the conversion you get.

       But when <b>tifftopnm</b> runs in Row By Row mode, it does not use TIFFRGBAImageGet(), and you get what  appears
       to be more useful: Y=1-(B+K).  This is the inverse of what <b>pnmtotiffcmyk</b> does.

       See the <b>-byrow</b> option for more information on Whole Image versus Row By Row mode.

       Before Netpbm 10.21 (March 2004), <b>tifftopnm</b> used the Y=(1-K)*(1-B) formula always.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/pnmtotiff.1.html">pnmtotiff</a></b>(1), <b><a href="../man1/pnmtotiffcmyk.1.html">pnmtotiffcmyk</a></b>(1), <b><a href="../man1/pamcomp.1.html">pamcomp</a></b>(1), <b><a href="../man1/pnm.1.html">pnm</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       Derived  by  Jef Poskanzer from tif2ras.c, which is Copyright (c) 1990 by Sun Microsystems, Inc.  Author:
       Patrick J. Naughton (<u><a href="mailto:naughton@wind.sun.com">naughton@wind.sun.com</a></u>).

</pre><h4><b>DOCUMENT</b> <b>SOURCE</b></h4><pre>
       This manual page was generated by the Netpbm tool 'makeman' from HTML source.  The  master  documentation
       is at

              <b><a href="http://netpbm.sourceforge.net/doc/tifftopnm.html">http://netpbm.sourceforge.net/doc/tifftopnm.html</a></b>

netpbm documentation                             02 January 2015                        <u>Tifftopnm</u> <u>User</u> <u><a href="../man1/Manual.1.html">Manual</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>