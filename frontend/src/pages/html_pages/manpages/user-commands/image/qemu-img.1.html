<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>qemu-img - QEMU disk image utility</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/qemu-utils">qemu-utils_9.2.1+ds-1ubuntu5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       qemu-img - QEMU disk image utility

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>qemu-img</b> [<u>standard</u> <u>options</u>] <u>command</u> [<u>command</u> <u>options</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       qemu-img  allows  you  to  create,  convert  and  modify  images offline. It can handle all image formats
       supported by QEMU.

       <b>Warning:</b> Never use qemu-img to modify images in use by a running virtual machine or  any  other  process;
       this  may  destroy  the  image.  Also,  be aware that querying an image that is being modified by another
       process may encounter inconsistent state.

</pre><h4><b>OPTIONS</b></h4><pre>
       Standard options:

       <b>-h,</b> <b>--help</b>
              Display this help and exit

       <b>-V,</b> <b>--version</b>
              Display version information and exit

       <b>-T,</b> <b>--trace</b> <b>[[enable=]PATTERN][,events=FILE][,file=FILE]</b>
              Specify tracing options.

              <b>[enable=]PATTERN</b>
                 Immediately enable events matching <u>PATTERN</u> (either event name or  a  globbing  pattern).   This
                 option  is  only  available  if  QEMU  has been compiled with the <b>simple</b>, <b>log</b> or <b>ftrace</b> tracing
                 backend.  To specify multiple events or patterns, specify the <b>-trace</b> option multiple times.

                 Use <b>-trace</b> <b>help</b> to print a list of names of trace points.

              <b>events=FILE</b>
                 Immediately enable events listed in <u>FILE</u>.  The file must contain one event name (as  listed  in
                 the  <b>trace-events-all</b>  file) per line; globbing patterns are accepted too.  This option is only
                 available if QEMU has been compiled with the <b>simple</b>, <b>log</b> or <b>ftrace</b> tracing backend.

              <b>file=FILE</b>
                 Log output traces to <u>FILE</u>.  This option is only available if QEMU has been  compiled  with  the
                 <b>simple</b> tracing backend.

       The following commands are supported:

       <b>amend</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-p]</b> <b>[-q]</b> <b>[-f</b> <b>FMT]</b> <b>[-t</b> <b>CACHE]</b> <b>[--force]</b> <b>-o</b> <b>OPTIONS</b> <b>FILENAME</b>

       <b>bench</b> <b>[-c</b> <b>COUNT]</b> <b>[-d</b> <b>DEPTH]</b> <b>[-f</b> <b>FMT]</b> <b>[--flush-interval=FLUSH_INTERVAL]</b> <b>[-i</b> <b>AIO]</b> <b>[-n]</b> <b>[--no-drain]</b> <b>[-o</b>
       <b>OFFSET]</b> <b>[--pattern=PATTERN]</b> <b>[-q]</b> <b>[-s</b> <b>BUFFER_SIZE]</b> <b>[-S</b> <b>STEP_SIZE]</b> <b>[-t</b> <b>CACHE]</b> <b>[-w]</b> <b>[-U]</b> <b>FILENAME</b>

       <b>bitmap</b> <b>(--merge</b> <b>SOURCE</b> <b>|</b> <b>--add</b> <b>|</b> <b>--remove</b> <b>|</b> <b>--clear</b> <b>|</b> <b>--enable</b> <b>|</b> <b>--disable)...</b> <b>[-b</b> <b>SOURCE_FILE</b> <b>[-F</b>
       <b>SOURCE_FMT]]</b> <b>[-g</b> <b>GRANULARITY]</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts</b> <b>|</b> <b>-f</b> <b>FMT]</b> <b>FILENAME</b> <b>BITMAP</b>

       <b>check</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-q]</b> <b>[-f</b> <b>FMT]</b> <b>[--output=OFMT]</b> <b>[-r</b> <b>[leaks</b> <b>|</b> <b>all]]</b> <b>[-T</b> <b>SRC_CACHE]</b>
       <b>[-U]</b> <b>FILENAME</b>

       <b>commit</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-q]</b> <b>[-f</b> <b>FMT]</b> <b>[-t</b> <b>CACHE]</b> <b>[-b</b> <b>BASE]</b> <b>[-r</b> <b>RATE_LIMIT]</b> <b>[-d]</b> <b>[-p]</b>
       <b>FILENAME</b>

       <b>compare</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-f</b> <b>FMT]</b> <b>[-F</b> <b>FMT]</b> <b>[-T</b> <b>SRC_CACHE]</b> <b>[-p]</b> <b>[-q]</b> <b>[-s]</b> <b>[-U]</b>
       <b>FILENAME1</b> <b>FILENAME2</b>

       <b>convert</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[--target-image-opts]</b> <b>[--target-is-zero]</b> <b>[--bitmaps]</b> <b>[-U]</b>
       <b>[-C]</b> <b>[-c]</b> <b>[-p]</b> <b>[-q]</b> <b>[-n]</b> <b>[-f</b> <b>FMT]</b> <b>[-t</b> <b>CACHE]</b> <b>[-T</b> <b>SRC_CACHE]</b> <b>[-O</b> <b>OUTPUT_FMT]</b> <b>[-B</b> <b>BACKING_FILE</b> <b>[-F</b>
       <b>BACKING_FMT]]</b> <b>[-o</b> <b>OPTIONS]</b> <b>[-l</b> <b>SNAPSHOT_PARAM]</b> <b>[-S</b> <b>SPARSE_SIZE]</b> <b>[-r</b> <b>RATE_LIMIT]</b> <b>[-m</b> <b>NUM_COROUTINES]</b> <b>[-W]</b>
       <b>[--salvage]</b> <b>FILENAME</b> <b>[FILENAME2</b> <b>[...]]</b> <b>OUTPUT_FILENAME</b>

       <b>create</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[-q]</b> <b>[-f</b> <b>FMT]</b> <b>[-b</b> <b>BACKING_FILE</b> <b>[-F</b> <b>BACKING_FMT]]</b> <b>[-u]</b> <b>[-o</b> <b>OPTIONS]</b> <b>FILENAME</b>
       <b>[SIZE]</b>

       <b>dd</b> <b>[--image-opts]</b> <b>[-U]</b> <b>[-f</b> <b>FMT]</b> <b>[-O</b> <b>OUTPUT_FMT]</b> <b>[bs=BLOCK_SIZE]</b> <b>[count=BLOCKS]</b> <b>[skip=BLOCKS]</b> <b>if=INPUT</b>
       <b>of=OUTPUT</b>

       <b>info</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-f</b> <b>FMT]</b> <b>[--output=OFMT]</b> <b>[--backing-chain]</b> <b>[-U]</b> <b>FILENAME</b>

       <b>map</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-f</b> <b>FMT]</b> <b>[--start-offset=OFFSET]</b> <b>[--max-length=LEN]</b>
       <b>[--output=OFMT]</b> <b>[-U]</b> <b>FILENAME</b>

       <b>measure</b> <b>[--output=OFMT]</b> <b>[-O</b> <b>OUTPUT_FMT]</b> <b>[-o</b> <b>OPTIONS]</b> <b>[--size</b> <b>N</b> <b>|</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-f</b>
       <b>FMT]</b> <b>[-l</b> <b>SNAPSHOT_PARAM]</b> <b>FILENAME]</b>

       <b>snapshot</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[-f</b> <b>FMT</b> <b>|</b> <b>--image-opts]</b> <b>[-U]</b> <b>[-q]</b> <b>[-l</b> <b>|</b> <b>-a</b> <b>SNAPSHOT</b> <b>|</b> <b>-c</b> <b>SNAPSHOT</b> <b>|</b> <b>-d</b>
       <b>SNAPSHOT]</b> <b>FILENAME</b>

       <b>rebase</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-U]</b> <b>[-q]</b> <b>[-f</b> <b>FMT]</b> <b>[-t</b> <b>CACHE]</b> <b>[-T</b> <b>SRC_CACHE]</b> <b>[-p]</b> <b>[-u]</b> <b>[-c]</b> <b>-b</b>
       <b>BACKING_FILE</b> <b>[-F</b> <b>BACKING_FMT]</b> <b>FILENAME</b>

       <b>resize</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-f</b> <b>FMT]</b> <b>[--preallocation=PREALLOC]</b> <b>[-q]</b> <b>[--shrink]</b> <b>FILENAME</b>
       <b>[+</b> <b>|</b> <b>-]SIZE</b>

       Command parameters:

       <u>FILENAME</u> is a disk image filename.

       <u>FMT</u>  is  the disk image format. It is guessed automatically in most cases. See below for a description of
       the supported disk formats.

       <u>SIZE</u> is the disk image size in bytes. Optional suffixes <b>k</b> or <b>K</b> (kilobyte, 1024) <b>M</b> (megabyte, 1024k) and <b>G</b>
       (gigabyte, 1024M) and T (terabyte, 1024G) are supported.  <b>b</b> is ignored.

       <u>OUTPUT_FILENAME</u> is the destination disk image filename.

       <u>OUTPUT_FMT</u> is the destination format.

       <u>OPTIONS</u> is a comma separated list of format specific options in a name=value format. Use <b>-o</b> <b>help</b>  for  an
       overview of the options supported by the used format or see the format descriptions below for details.

       <u>SNAPSHOT_PARAM</u>  is param used for internal snapshot, format is 'snapshot.id=[ID],snapshot.name=[NAME]' or
       '[ID_OR_NAME]'.

       <b>--object</b> <b>OBJECTDEF</b>
              is a QEMU user creatable object definition. See the <b><a href="../man1/qemu.1.html">qemu</a>(1)</b> manual page for a description  of  the
              object  properties.  The  most  common  object type is a <b>secret</b>, which is used to supply passwords
              and/or encryption keys.

       <b>--image-opts</b>
              Indicates that the source <u>FILENAME</u> parameter is to be interpreted as a full option string,  not  a
              plain filename. This parameter is mutually exclusive with the <u>-f</u> parameter.

       <b>--target-image-opts</b>
              Indicates that the OUTPUT_FILENAME parameter(s) are to be interpreted as a full option string, not
              a  plain  filename.  This  parameter is mutually exclusive with the <u>-O</u> parameters. It is currently
              required to also use the <u>-n</u> parameter to skip image creation. This restriction may be relaxed in a
              future release.

       <b>--force-share</b> <b>(-U)</b>
              If specified, <b>qemu-img</b> will open the image in shared mode, allowing other QEMU processes  to  open
              it  in  write  mode.  For  example,  this  can  be  used to get the image information (with 'info'
              subcommand) when the image is used by a running guest.  Note that this could produce  inconsistent
              results  because  of  concurrent  metadata  changes, etc. This option is only allowed when opening
              images in read-only mode.

       <b>--backing-chain</b>
              Will enumerate information about backing files in a disk image  chain.  Refer  below  for  further
              description.

       <b>-c</b>     Indicates that target image must be compressed (qcow/qcow2 and vmdk with streamOptimized subformat
              only).

              For qcow2, the compression algorithm can be specified with the <b>-o</b> <b>compression_type=...</b> option (see
              below).

       <b>-h</b>     With or without a command, shows help and lists the supported formats.

       <b>-p</b>     Display  progress  bar  (compare, convert and rebase commands only).  If the <u>-p</u> option is not used
              for a command that supports it, the progress is reported when the process receives  a  <b>SIGUSR1</b>  or
              <b>SIGINFO</b> signal.

       <b>-q</b>     Quiet  mode - do not print any output (except errors). There's no progress bar in case both <u>-q</u> and
              <u>-p</u> options are used.

       <b>-S</b> <b>SIZE</b>
              Indicates the consecutive number of bytes that must contain only zeros for <b>qemu-img</b>  to  create  a
              sparse  image  during conversion. This value is rounded down to the nearest 512 bytes. You may use
              the common size suffixes like <b>k</b> for kilobytes.

       <b>-t</b> <b>CACHE</b>
              Specifies the cache mode that should be used with the (destination) file. See the documentation of
              the emulator's <b>-drive</b> <b>cache=...</b> option for allowed values.

       <b>-T</b> <b>SRC_CACHE</b>
              Specifies the cache mode that should be used with the source file(s). See the documentation of the
              emulator's <b>-drive</b> <b>cache=...</b> option for allowed values.

       Parameters to compare subcommand:

       <b>-f</b>     First image format

       <b>-F</b>     Second image format

       <b>-s</b>     Strict mode - fail on different image size or sector allocation

       Parameters to convert subcommand:

       <b>--bitmaps</b>
              Additionally copy all persistent bitmaps from the top layer of the source

       <b>-n</b>     Skip the creation of the target volume

       <b>-m</b>     Number of parallel coroutines for the convert process

       <b>-W</b>     Allow out-of-order writes to the destination.  This  option  improves  performance,  but  is  only
              recommended for preallocated devices like host devices or other raw block devices.

       <b>-C</b>     Try  to use copy offloading to move data from source image to target. This may improve performance
              if the data is remote, such as with NFS or iSCSI backends, but  will  not  automatically  sparsify
              zero  sectors,  and may result in a fully allocated target image depending on the host support for
              getting allocation information.

       <b>-r</b>     Rate limit for the convert process

       <b>--salvage</b>
              Try to ignore I/O errors when reading.  Unless in quiet mode (<b>-q</b>), errors will still  be  printed.
              Areas that cannot be read from the source will be treated as containing only zeroes.

       <b>--target-is-zero</b>
              Assume  that  reading  the  destination image will always return zeros. This parameter is mutually
              exclusive with a destination image that has a backing file. It is required  to  also  use  the  <b>-n</b>
              parameter to skip image creation.

       Parameters to dd subcommand:

       <b>bs=BLOCK_SIZE</b>
              Defines the block size

       <b>count=BLOCKS</b>
              Sets the number of input blocks to copy

       <b>if=INPUT</b>
              Sets the input file

       <b>of=OUTPUT</b>
              Sets the output file

       <b>skip=BLOCKS</b>
              Sets the number of input blocks to skip

       Parameters to snapshot subcommand:

       <b>snapshot</b>
              Is the name of the snapshot to create, apply or delete

       <b>-a</b>     Applies a snapshot (revert disk to saved state)

       <b>-c</b>     Creates a snapshot

       <b>-d</b>     Deletes a snapshot

       <b>-l</b>     Lists all snapshots in the given image (default action)

       Command description:

       <b>amend</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-p]</b> <b>[-q]</b> <b>[-f</b> <b>FMT]</b> <b>[-t</b> <b>CACHE]</b> <b>[--force]</b> <b>-o</b> <b>OPTIONS</b> <b>FILENAME</b>
              Amends the image format specific <u>OPTIONS</u> for the image file <u>FILENAME</u>. Not all file formats support
              this operation.

              The  set  of options that can be amended are dependent on the image format, but note that amending
              the backing chain relationship should instead be performed with <b>qemu-img</b> <b>rebase</b>.

              --force allows some unsafe operations. Currently  for  -f  luks,  it  allows  to  erase  the  last
              encryption key, and to overwrite an active encryption key.

       <b>bench</b> <b>[-c</b> <b>COUNT]</b> <b>[-d</b> <b>DEPTH]</b> <b>[-f</b> <b>FMT]</b> <b>[--flush-interval=FLUSH_INTERVAL]</b> <b>[-i</b> <b>AIO]</b> <b>[-n]</b> <b>[--no-drain]</b> <b>[-o</b>
       <b>OFFSET]</b> <b>[--pattern=PATTERN]</b> <b>[-q]</b> <b>[-s</b> <b>BUFFER_SIZE]</b> <b>[-S</b> <b>STEP_SIZE]</b> <b>[-t</b> <b>CACHE]</b> <b>[-w]</b> <b>[-U]</b> <b>FILENAME</b>
              Run  a simple sequential I/O benchmark on the specified image. If <b>-w</b> is specified, a write test is
              performed, otherwise a read test is performed.

              A total number of <u>COUNT</u> I/O requests is performed, each <u>BUFFER_SIZE</u> bytes in size, and with  <u>DEPTH</u>
              requests  in  parallel.  The  first request starts at the position given by <u>OFFSET</u>, each following
              request increases the current position by <u>STEP_SIZE</u>. If <u>STEP_SIZE</u> is  not  given,  <u>BUFFER_SIZE</u>  is
              used for its value.

              If  <u>FLUSH_INTERVAL</u>  is  specified  for  a  write test, the request queue is drained and a flush is
              issued before new writes are made whenever the number of  remaining  requests  is  a  multiple  of
              <u>FLUSH_INTERVAL</u>.  If  additionally  <b>--no-drain</b> is specified, a flush is issued without draining the
              request queue first.

              if <b>-i</b> is specified, <u>AIO</u> option can be used to specify different AIO backends: <b>threads</b>,  <b>native</b>  or
              <b>io_uring</b>.

              If  <b>-n</b>  is specified, the native AIO backend is used if possible. On Linux, this option only works
              if <b>-t</b> <b>none</b> or <b>-t</b> <b>directsync</b> is specified as well.

              For write tests, by default a buffer filled with zeros is written. This can be overridden  with  a
              pattern byte specified by <u>PATTERN</u>.

       <b>bitmap</b> <b>(--merge</b> <b>SOURCE</b> <b>|</b> <b>--add</b> <b>|</b> <b>--remove</b> <b>|</b> <b>--clear</b> <b>|</b> <b>--enable</b> <b>|</b> <b>--disable)...</b> <b>[-b</b> <b>SOURCE_FILE</b> <b>[-F</b>
       <b>SOURCE_FMT]]</b> <b>[-g</b> <b>GRANULARITY]</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts</b> <b>|</b> <b>-f</b> <b>FMT]</b> <b>FILENAME</b> <b>BITMAP</b>
              Perform one or more modifications of the persistent bitmap <u>BITMAP</u> in the disk image <u>FILENAME</u>.  The
              various modifications are:

              <b>--add</b> to create <u>BITMAP</u>, enabled to record future edits.

              <b>--remove</b> to remove <u>BITMAP</u>.

              <b>--clear</b> to clear <u>BITMAP</u>.

              <b>--enable</b> to change <u>BITMAP</u> to start recording future edits.

              <b>--disable</b> to change <u>BITMAP</u> to stop recording future edits.

              <b>--merge</b> to merge the contents of the <u>SOURCE</u> bitmap into <u>BITMAP</u>.

              Additional  options include <b>-g</b> which sets a non-default <u>GRANULARITY</u> for <b>--add</b>, and <b>-b</b> and <b>-F</b> which
              select an alternative source file for all <u>SOURCE</u> bitmaps used by <b>--merge</b>.

              To see what bitmaps are present in an image, use <b>qemu-img</b> <b>info</b>.

       <b>check</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-q]</b> <b>[-f</b> <b>FMT]</b> <b>[--output=OFMT]</b> <b>[-r</b> <b>[leaks</b> <b>|</b> <b>all]]</b> <b>[-T</b> <b>SRC_CACHE]</b>
       <b>[-U]</b> <b>FILENAME</b>
              Perform a consistency check on the disk image <u>FILENAME</u>. The command can output in the format  <u>OFMT</u>
              which is either <b>human</b> or <b>json</b>.  The JSON output is an object of QAPI type <b>ImageCheck</b>.

              If  <b>-r</b> is specified, qemu-img tries to repair any inconsistencies found during the check. <b>-r</b> <b>leaks</b>
              repairs only cluster leaks, whereas <b>-r</b> <b>all</b> fixes all kinds  of  errors,  with  a  higher  risk  of
              choosing the wrong fix or hiding corruption that has already occurred.

              Only the formats <b>qcow2</b>, <b>qed</b>, <b>parallels</b>, <b>vhdx</b>, <b>vmdk</b> and <b>vdi</b> support consistency checks.

              In  case  the  image  does  not  have  any  inconsistencies, check exits with <b>0</b>.  Other exit codes
              indicate the kind of inconsistency found  or  if  another  error  occurred.  The  following  table
              summarizes all exit codes of the check subcommand:

              <b>0</b>      Check completed, the image is (now) consistent

              <b>1</b>      Check not completed because of internal errors

              <b>2</b>      Check completed, image is corrupted

              <b>3</b>      Check completed, image has leaked clusters, but is not corrupted

              <b>63</b>     Checks are not supported by the image format

              If  <b>-r</b> is specified, exit codes representing the image state refer to the state after (the attempt
              at) repairing it. That is, a successful <b>-r</b> <b>all</b> will yield the exit code 0,  independently  of  the
              image state before.

       <b>commit</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-q]</b> <b>[-f</b> <b>FMT]</b> <b>[-t</b> <b>CACHE]</b> <b>[-b</b> <b>BASE]</b> <b>[-r</b> <b>RATE_LIMIT]</b> <b>[-d]</b> <b>[-p]</b>
       <b>FILENAME</b>
              Commit the changes recorded in <u>FILENAME</u> in its base image or backing file.  If the backing file is
              smaller  than  the  snapshot,  then  the  backing  file will be resized to be the same size as the
              snapshot.  If the snapshot is smaller than  the  backing  file,  the  backing  file  will  not  be
              truncated.  If you want the backing file to match the size of the smaller snapshot, you can safely
              truncate it yourself once the commit operation successfully completes.

              The  image  <u>FILENAME</u>  is  emptied  after  the operation has succeeded. If you do not need <u>FILENAME</u>
              afterwards and intend to drop it, you may skip emptying <u>FILENAME</u> by specifying the <b>-d</b> flag.

              If the backing chain of the given image file <u>FILENAME</u> has more than one layer,  the  backing  file
              into  which  the  changes  will  be  committed  may  be specified as <u>BASE</u> (which has to be part of
              <u>FILENAME</u>'s backing chain). If <u>BASE</u> is not specified, the immediate backing file of the  top  image
              (which  is  <u>FILENAME</u>) will be used. Note that after a commit operation all images between <u>BASE</u> and
              the top image will be invalid and may return garbage data when read. For this reason,  <b>-b</b>  implies
              <b>-d</b> (so that the top image stays valid).

              The rate limit for the commit process is specified by <b>-r</b>.

       <b>compare</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-f</b> <b>FMT]</b> <b>[-F</b> <b>FMT]</b> <b>[-T</b> <b>SRC_CACHE]</b> <b>[-p]</b> <b>[-q]</b> <b>[-s]</b> <b>[-U]</b>
       <b>FILENAME1</b> <b>FILENAME2</b>
              Check  if  two  images  have  the  same  content.  You can compare images with different format or
              settings.

              The format is probed unless you specify it  by  <b>-f</b>  (used  for  <u>FILENAME1</u>)  and/or  <b>-F</b>  (used  for
              <u>FILENAME2</u>) option.

              By  default, images with different size are considered identical if the larger image contains only
              unallocated and/or zeroed sectors in the area after the end of the other image.  In  addition,  if
              any  sector  is  not  allocated in one image and contains only zero bytes in the second one, it is
              evaluated as equal. You can use Strict mode by specifying the <b>-s</b>  option.  When  compare  runs  in
              Strict  mode, it fails in case image size differs or a sector is allocated in one image and is not
              allocated in the second one.

              By default, compare prints out a result message.  This  message  displays  information  that  both
              images  are  same  or  the  position  of the first different byte. In addition, result message can
              report different image size in case Strict mode is used.

              Compare exits with <b>0</b> in case the images are equal and with <b>1</b> in case the images differ. Other exit
              codes mean an error occurred during execution and standard error output should  contain  an  error
              message.  The following table summarizes all exit codes of the compare subcommand:

              <b>0</b>      Images are identical (or requested help was printed)

              <b>1</b>      Images differ

              <b>2</b>      Error on opening an image

              <b>3</b>      Error on checking a sector allocation

              <b>4</b>      Error on reading data

       <b>convert</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[--target-image-opts]</b> <b>[--target-is-zero]</b> <b>[--bitmaps</b>
       <b>[--skip-broken-bitmaps]]</b> <b>[-U]</b> <b>[-C]</b> <b>[-c]</b> <b>[-p]</b> <b>[-q]</b> <b>[-n]</b> <b>[-f</b> <b>FMT]</b> <b>[-t</b> <b>CACHE]</b> <b>[-T</b> <b>SRC_CACHE]</b> <b>[-O</b> <b>OUTPUT_FMT]</b>
       <b>[-B</b> <b>BACKING_FILE</b> <b>[-F</b> <b>BACKING_FMT]]</b> <b>[-o</b> <b>OPTIONS]</b> <b>[-l</b> <b>SNAPSHOT_PARAM]</b> <b>[-S</b> <b>SPARSE_SIZE]</b> <b>[-r</b> <b>RATE_LIMIT]</b> <b>[-m</b>
       <b>NUM_COROUTINES]</b> <b>[-W]</b> <b>FILENAME</b> <b>[FILENAME2</b> <b>[...]]</b> <b>OUTPUT_FILENAME</b>
              Convert  the  disk image <u>FILENAME</u> or a snapshot <u>SNAPSHOT_PARAM</u> to disk image <u>OUTPUT_FILENAME</u> using
              format <u>OUTPUT_FMT</u>. It can be optionally compressed (<b>-c</b> option) or use any format specific  options
              like encryption (<b>-o</b> option).

              Only  the  formats <b>qcow</b> and <b>qcow2</b> support compression. The compression is read-only. It means that
              if a compressed sector is rewritten, then it is rewritten as uncompressed data.

              Image conversion is also useful to get smaller image when using a growable format  such  as  <b>qcow</b>:
              the empty sectors are detected and suppressed from the destination image.

              <u>SPARSE_SIZE</u>  indicates  the  consecutive  number  of bytes (defaults to 4k) that must contain only
              zeros for <b>qemu-img</b> to create a sparse image during conversion. If <u>SPARSE_SIZE</u>  is  0,  the  source
              will  not  be  scanned  for  unallocated or zero sectors, and the destination image will always be
              fully allocated.

              You can use the <u>BACKING_FILE</u> option to force the output image to be created as  a  copy  on  write
              image  of  the  specified base image; the <u>BACKING_FILE</u> should have the same content as the input's
              base image, however the path, image format (as given by <u>BACKING_FMT</u>), etc may differ.

              If a relative path name is given, the  backing  file  is  looked  up  relative  to  the  directory
              containing <u>OUTPUT_FILENAME</u>.

              If  the  <b>-n</b>  option  is  specified, the target volume creation will be skipped. This is useful for
              formats such as <b>rbd</b> if the target volume has already been created with site specific options  that
              cannot be supplied through <b>qemu-img</b>.

              Out  of  order writes can be enabled with <b>-W</b> to improve performance.  This is only recommended for
              preallocated devices like host devices or other raw block devices. Out of  order  write  does  not
              work in combination with creating compressed images.

              <u>NUM_COROUTINES</u> specifies how many coroutines work in parallel during the convert process (defaults
              to 8).

              Use  of  <b>--bitmaps</b> requests that any persistent bitmaps present in the original are also copied to
              the destination.  If any bitmap is inconsistent in the source, the  conversion  will  fail  unless
              <b>--skip-broken-bitmaps</b> is also specified to copy only the consistent bitmaps.

       <b>create</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[-q]</b> <b>[-f</b> <b>FMT]</b> <b>[-b</b> <b>BACKING_FILE</b> <b>[-F</b> <b>BACKING_FMT]]</b> <b>[-u]</b> <b>[-o</b> <b>OPTIONS]</b> <b>FILENAME</b>
       <b>[SIZE]</b>
              Create  the new disk image <u>FILENAME</u> of size <u>SIZE</u> and format <u>FMT</u>. Depending on the file format, you
              can add one or more <u>OPTIONS</u> that enable additional features of this format.

              If the option <u>BACKING_FILE</u> is specified, then the image will  record  only  the  differences  from
              <u>BACKING_FILE</u>.  No  size  needs  to  be specified in this case. <u>BACKING_FILE</u> will never be modified
              unless you use the <b>commit</b> monitor command (or <b>qemu-img</b> <b>commit</b>).

              If a relative path name is given, the  backing  file  is  looked  up  relative  to  the  directory
              containing <u>FILENAME</u>.

              Note  that  a  given  backing  file will be opened to check that it is valid. Use the <b>-u</b> option to
              enable unsafe backing file mode, which means that the image will be created even if the associated
              backing file cannot be opened. A matching backing file must be created or  additional  options  be
              used to make the backing file specification valid when you want to use an image created this way.

              The  size  can  also  be  specified using the <u>SIZE</u> option with <b>-o</b>, it doesn't need to be specified
              separately in this case.

       <b>dd</b> <b>[--image-opts]</b> <b>[-U]</b> <b>[-f</b> <b>FMT]</b> <b>[-O</b> <b>OUTPUT_FMT]</b> <b>[bs=BLOCK_SIZE]</b> <b>[count=BLOCKS]</b> <b>[skip=BLOCKS]</b> <b>if=INPUT</b>
       <b>of=OUTPUT</b>
              dd copies from <u>INPUT</u> file to <u>OUTPUT</u> file converting it from <u>FMT</u> format to <u>OUTPUT_FMT</u> format.

              The data is by default read and written  using  blocks  of  512  bytes  but  can  be  modified  by
              specifying  <u>BLOCK_SIZE</u>.  If  count=<u>BLOCKS</u>  is  specified  dd will stop reading input after reading
              <u>BLOCKS</u> input blocks.

              The size syntax is similar to <b><a href="../man1/dd.1.html">dd</a>(1)</b>'s size syntax.

       <b>info</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-f</b> <b>FMT]</b> <b>[--output=OFMT]</b> <b>[--backing-chain]</b> <b>[-U]</b> <b>FILENAME</b>
              Give information about the disk image <u>FILENAME</u>. Use it in particular to know the size reserved  on
              disk which can be different from the displayed size. If VM snapshots are stored in the disk image,
              they are displayed too.

              If  a  disk  image has a backing file chain, information about each disk image in the chain can be
              recursively enumerated by using the option <b>--backing-chain</b>.

              For instance, if you have an image chain like:

                 base.qcow2 &lt;- snap1.qcow2 &lt;- snap2.qcow2

              To enumerate information about each disk image in the above chain, starting from top to base, do:

                 qemu-img info --backing-chain snap2.qcow2

              The command can output in the format <u>OFMT</u> which is either <b>human</b> or <b>json</b>.  The JSON  output  is  an
              object of QAPI type <b>ImageInfo</b>; with <b>--backing-chain</b>, it is an array of <b>ImageInfo</b> objects.

              <b>--output=human</b> reports the following information (for every image in the chain):

              <u>image</u>  The image file name

              <u>file</u> <u>format</u>
                     The image format

              <u>virtual</u> <u>size</u>
                     The size of the guest disk

              <u>disk</u> <u>size</u>
                     How  much  space the image file occupies on the host file system (may be shown as 0 if this
                     information is unavailable, e.g. because there is no file system)

              <u>cluster_size</u>
                     Cluster size of the image format, if applicable

              <u>encrypted</u>
                     Whether the image is encrypted (only present if so)

              <u>cleanly</u> <u>shut</u> <u>down</u>
                     This is shown as <b>no</b> if the image is dirty and will have to be auto-repaired the  next  time
                     it is opened in qemu.

              <u>backing</u> <u>file</u>
                     The backing file name, if present

              <u>backing</u> <u>file</u> <u>format</u>
                     The format of the backing file, if the image enforces it

              <u>Snapshot</u> <u>list</u>
                     A list of all internal snapshots

              <u>Format</u> <u>specific</u> <u>information</u>
                     Further information whose structure depends on the image format.  This section is a textual
                     representation     of    the    respective    <b>ImageInfoSpecific*</b>    QAPI    object    (e.g.
                     <b>ImageInfoSpecificQCow2</b> for qcow2 images).

       <b>map</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-f</b> <b>FMT]</b> <b>[--start-offset=OFFSET]</b> <b>[--max-length=LEN]</b>
       <b>[--output=OFMT]</b> <b>[-U]</b> <b>FILENAME</b>
              Dump the metadata of image <u>FILENAME</u> and its backing file  chain.   In  particular,  this  commands
              dumps  the  allocation  state  of  every  sector  of <u>FILENAME</u>, together with the topmost file that
              allocates it in the backing file chain.

              Two option formats are possible.  The default format (<b>human</b>) only dumps known-nonzero areas of the
              file.  Known-zero parts of the file are omitted altogether, and likewise for parts  that  are  not
              allocated  throughout  the chain.  <b>qemu-img</b> output will identify a file from where the data can be
              read, and the offset in the file.  Each line will include four fields, the first  three  of  which
              are hexadecimal numbers.  For example the first line of:

                 Offset          Length          Mapped to       File
                 0               0x20000         0x50000         /tmp/overlay.qcow2
                 0x100000        0x10000         0x95380000      /tmp/backing.qcow2

              means  that  0x20000  (131072)  bytes  starting  at  offset  0  in  the  image  are  available  in
              /tmp/overlay.qcow2 (opened in <b>raw</b> format) starting at  offset  0x50000  (327680).   Data  that  is
              compressed,  encrypted,  or  otherwise  not  available  in raw format will cause an error if <b>human</b>
              format is in use.  Note that file names can include newlines, thus it is not safe  to  parse  this
              output format in scripts.

              The  alternative format <b>json</b> will return an array of dictionaries in JSON format.  It will include
              similar information in the <b>start</b>, <b>length</b>, <b>offset</b> fields; it will also include other more  specific
              information:

              • boolean  field  <b>data</b>:  true  if the sectors contain actual data, false if the sectors are either
                unallocated or stored as optimized all-zero clusters

              • boolean field <b>zero</b>: true if the data is known to read as zero

              • boolean field <b>present</b>: true if the data belongs to the backing  chain,  false  if  rebasing  the
                backing chain onto a deeper file would pick up data from the deeper file;

              • integer  field  <b>depth</b>:  the  depth  within the backing chain at which the data was resolved; for
                example, a depth of 2 refers to the backing file of the backing file of <u>FILENAME</u>.

              In JSON format, the <b>offset</b> field is optional; it is absent in cases where <b>human</b> format would  omit
              the  entry  or  exit  with  an  error.   If  <b>data</b>  is  false  and the <b>offset</b> field is present, the
              corresponding sectors in the file are not yet in use, but they are preallocated.

              For more information, consult <b>include/block/block.h</b> in QEMU's source code.

       <b>measure</b> <b>[--output=OFMT]</b> <b>[-O</b> <b>OUTPUT_FMT]</b> <b>[-o</b> <b>OPTIONS]</b> <b>[--size</b> <b>N</b> <b>|</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-f</b>
       <b>FMT]</b> <b>[-l</b> <b>SNAPSHOT_PARAM]</b> <b>FILENAME]</b>
              Calculate the file size required for a new image.  This information can be used  to  size  logical
              volumes  or SAN LUNs appropriately for the image that will be placed in them.  The values reported
              are guaranteed to be large enough to fit the image.  The command can output  in  the  format  <u>OFMT</u>
              which is either <b>human</b> or <b>json</b>.  The JSON output is an object of QAPI type <b>BlockMeasureInfo</b>.

              If  the  size <u>N</u> is given then act as if creating a new empty image file using <b>qemu-img</b> <b>create</b>.  If
              <u>FILENAME</u> is given then act as if converting an existing image file using  <b>qemu-img</b>  <b>convert</b>.   The
              format  of  the  new  file is given by <u>OUTPUT_FMT</u> while the format of an existing file is given by
              <u>FMT</u>.

              A snapshot in an existing image can be specified using <u>SNAPSHOT_PARAM</u>.

              The following fields are reported:

                 required size: 524288
                 fully allocated size: 1074069504
                 bitmaps size: 0

              The <b>required</b> <b>size</b> is the file size of the new image.  It may be smaller than the virtual disk size
              if the image format supports compact representation.

              The <b>fully</b> <b>allocated</b> <b>size</b> is the file size of the new image once  data  has  been  written  to  all
              sectors.   This  is the maximum size that the image file can occupy with the exception of internal
              snapshots, dirty bitmaps, vmstate data, and other advanced image format features.

              The <b>bitmaps</b> <b>size</b> is the additional size required in order to copy bitmaps from a source  image  in
              addition  to  the  guest-visible  data;  the line is omitted if either source or destination lacks
              bitmap support, or 0 if bitmaps are supported but there is nothing to copy.

       <b>snapshot</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[-f</b> <b>FMT</b> <b>|</b> <b>--image-opts]</b> <b>[-U]</b> <b>[-q]</b> <b>[-l</b> <b>|</b> <b>-a</b> <b>SNAPSHOT</b> <b>|</b> <b>-c</b> <b>SNAPSHOT</b> <b>|</b> <b>-d</b>
       <b>SNAPSHOT]</b> <b>FILENAME</b>
              List, apply, create or delete snapshots in image <u>FILENAME</u>.

       <b>rebase</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-U]</b> <b>[-q]</b> <b>[-f</b> <b>FMT]</b> <b>[-t</b> <b>CACHE]</b> <b>[-T</b> <b>SRC_CACHE]</b> <b>[-p]</b> <b>[-u]</b> <b>[-c]</b> <b>-b</b>
       <b>BACKING_FILE</b> <b>[-F</b> <b>BACKING_FMT]</b> <b>FILENAME</b>
              Changes the backing file of an image. Only the formats <b>qcow2</b> and <b>qed</b> support changing the  backing
              file.

              The  backing  file  is changed to <u>BACKING_FILE</u> and (if the image format of <u>FILENAME</u> supports this)
              the backing file format is changed to <u>BACKING_FMT</u>. If <u>BACKING_FILE</u> is specified as ""  (the  empty
              string),  then  the image is rebased onto no backing file (i.e. it will exist independently of any
              backing file).

              If a relative path name is given, the  backing  file  is  looked  up  relative  to  the  directory
              containing <u>FILENAME</u>.

              <u>CACHE</u> specifies the cache mode to be used for <u>FILENAME</u>, whereas <u>SRC_CACHE</u> specifies the cache mode
              for reading backing files.

              There are two different modes in which <b>rebase</b> can operate:

              <b>Safe</b> <b>mode</b>
                     This  is  the  default  mode and performs a real rebase operation. The new backing file may
                     differ from the old one and <b>qemu-img</b> <b>rebase</b> will take care  of  keeping  the  guest-visible
                     content of <u>FILENAME</u> unchanged.

                     In order to achieve this, any clusters that differ between <u>BACKING_FILE</u> and the old backing
                     file  of  <u>FILENAME</u> are merged into <u>FILENAME</u> before actually changing the backing file. With
                     the <b>-c</b> option specified, the clusters which are being merged (but not the  entire  <u>FILENAME</u>
                     image) are compressed when written.

                     Note  that  the  safe mode is an expensive operation, comparable to converting an image. It
                     only works if the old backing file still exists.

              <b>Unsafe</b> <b>mode</b>
                     <b>qemu-img</b> uses the unsafe mode if <b>-u</b> is specified. In this mode, only the backing file  name
                     and  format  of  <u>FILENAME</u> is changed without any checks on the file contents. The user must
                     take care of specifying the correct new backing file, or the guest-visible content  of  the
                     image will be corrupted.

                     This  mode  is useful for renaming or moving the backing file to somewhere else.  It can be
                     used without an accessible old backing file, i.e. you can use it  to  fix  an  image  whose
                     backing file has already been moved/renamed.

              You  can use <b>rebase</b> to perform a "diff" operation on two disk images.  This can be useful when you
              have copied or cloned a guest, and you want to get back to a thin image on top of  a  template  or
              base image.

              Say  that  <b>base.img</b> has been cloned as <b>modified.img</b> by copying it, and that the <b>modified.img</b> guest
              has run so there are now some changes compared to <b>base.img</b>.  To  construct  a  thin  image  called
              <b>diff.qcow2</b> that contains just the differences, do:

                 qemu-img create -f qcow2 -b modified.img diff.qcow2
                 qemu-img rebase -b base.img diff.qcow2

              At  this  point,  <b>modified.img</b>  can  be  discarded,  since <b>base.img</b> <b>+</b> <b>diff.qcow2</b> contains the same
              information.

       <b>resize</b> <b>[--object</b> <b>OBJECTDEF]</b> <b>[--image-opts]</b> <b>[-f</b> <b>FMT]</b> <b>[--preallocation=PREALLOC]</b> <b>[-q]</b> <b>[--shrink]</b> <b>FILENAME</b>
       <b>[+</b> <b>|</b> <b>-]SIZE</b>
              Change the disk image as if it had been created with <u>SIZE</u>.

              Before using this command to shrink a disk image, you MUST use file system and partitioning  tools
              inside  the VM to reduce allocated file systems and partition sizes accordingly.  Failure to do so
              will result in data loss!

              When shrinking images, the <b>--shrink</b> option must be given. This  informs  <b>qemu-img</b>  that  the  user
              acknowledges all loss of data beyond the truncated image's end.

              After  using  this  command  to grow a disk image, you must use file system and partitioning tools
              inside the VM to actually begin using the new space on the device.

              When growing an image, the <b>--preallocation</b> option may be used to specify how the additional  image
              area  should  be  allocated  on  the  host.  See the format description in the <u>Notes</u> section which
              values are allowed.  Using this option may result in  slightly  more  data  being  allocated  than
              necessary.

</pre><h4><b>NOTES</b></h4><pre>
       Supported image file formats:

       <b>raw</b>
          Raw  disk  image format (default). This format has the advantage of being simple and easily exportable
          to all other emulators. If your file system supports <u>holes</u> (for example in ext2 or ext3  on  Linux  or
          NTFS on Windows), then only the written sectors will reserve space. Use <b>qemu-img</b> <b>info</b> to know the real
          size used by the image or <b>ls</b> <b>-ls</b> on Unix/Linux.

          Supported options:

          <b>preallocation</b>
                 Preallocation  mode  (allowed  values:  <b>off</b>, <b>falloc</b>, <b>full</b>).  <b>falloc</b> mode preallocates space for
                 image by calling <b>posix_fallocate()</b>.  <b>full</b> mode preallocates space for image by writing data  to
                 underlying storage.  This data may or may not be zero, depending on the storage location.

       <b>qcow2</b>
          QEMU image format, the most versatile format. Use it to have smaller images (useful if your filesystem
          does  not  supports  holes,  for  example  on  Windows),  optional  AES encryption, zlib or zstd based
          compression and support of multiple VM snapshots.

          Supported options:

          <b>compat</b> Determines the qcow2 version to use. <b>compat=0.10</b> uses the traditional image format that can  be
                 read by any QEMU since 0.10.  <b>compat=1.1</b> enables image format extensions that only QEMU 1.1 and
                 newer  understand  (this  is  the  default). Amongst others, this includes zero clusters, which
                 allow efficient copy-on-read for sparse images.

          <b>backing_file</b>
                 File name of a base image (see <b>create</b> subcommand)

          <b>backing_fmt</b>
                 Image format of the base image

          <b>compression_type</b>
                 This option configures which compression algorithm will be used for compressed clusters on  the
                 image. Note that setting this option doesn't yet cause the image to actually receive compressed
                 writes.  It  is most commonly used with the <b>-c</b> option of <b>qemu-img</b> <b>convert</b>, but can also be used
                 with the <b>compress</b> filter driver or backup block jobs with compression enabled.

                 Valid values are <b>zlib</b> and <b>zstd</b>. For images that  use  <b>compat=0.10</b>,  only  <b>zlib</b>  compression  is
                 available.

          <b>encryption</b>
                 If this option is set to <b>on</b>, the image is encrypted with 128-bit AES-CBC.

                 The  use  of  encryption  in  qcow  and  qcow2  images  is  considered  to  be flawed by modern
                 cryptography standards, suffering from a number of design problems:

                 • The AES-CBC cipher is used with  predictable  initialization  vectors  based  on  the  sector
                   number.  This  makes it vulnerable to chosen plaintext attacks which can reveal the existence
                   of encrypted data.

                 • The user passphrase is directly used  as  the  encryption  key.  A  poorly  chosen  or  short
                   passphrase will compromise the security of the encryption.

                 • In  the event of the passphrase being compromised there is no way to change the passphrase to
                   protect data in any qcow images. The files must  be  cloned,  using  a  different  encryption
                   passphrase  in  the  new file. The original file must then be securely erased using a program
                   like shred, though even this is ineffective with many modern storage technologies.

                 • Initialization vectors used to encrypt sectors are based on the guest virtual sector  number,
                   instead  of  the host physical sector. When a disk image has multiple internal snapshots this
                   means that data in multiple physical  sectors  is  encrypted  with  the  same  initialization
                   vector.  With  the CBC mode, this opens the possibility of watermarking attacks if the attack
                   can collect multiple sectors encrypted with the same IV and  some  predictable  data.  Having
                   multiple  qcow2  images  with  the  same  passphrase  also  exposes  this  weakness since the
                   passphrase is directly used as the key.

                 Use of qcow / qcow2 encryption is thus strongly discouraged. Users are recommended  to  use  an
                 alternative encryption technology such as the Linux dm-crypt / LUKS system.

          <b>cluster_size</b>
                 Changes  the qcow2 cluster size (must be between 512 and 2M). Smaller cluster sizes can improve
                 the image file size whereas larger cluster sizes generally provide better performance.

          <b>preallocation</b>
                 Preallocation mode (allowed values: <b>off</b>, <b>metadata</b>, <b>falloc</b>, <b>full</b>). An  image  with  preallocated
                 metadata  is  initially larger but can improve performance when the image needs to grow. <b>falloc</b>
                 and <b>full</b> preallocations are like the same options of <b>raw</b> format, but sets up metadata also.

          <b>lazy_refcounts</b>
                 If this option is set to <b>on</b>, reference count updates are postponed with the  goal  of  avoiding
                 metadata   I/O   and   improving   performance.   This   is   particularly   interesting   with
                 <b>cache=writethrough</b> which doesn't batch metadata updates. The tradeoff  is  that  after  a  host
                 crash,  the  reference  count  tables  must  be  rebuilt,  i.e. on the next open an (automatic)
                 <b>qemu-img</b> <b>check</b> <b>-r</b> <b>all</b> is required, which may take some time.

                 This option can only be enabled if <b>compat=1.1</b> is specified.

          <b>nocow</b>  If this option is set to <b>on</b>, it will turn off COW of the file. It's only  valid  on  btrfs,  no
                 effect on other file systems.

                 Btrfs has low performance when hosting a VM image file, even more when the guest on the VM also
                 using  btrfs  as  file  system.  Turning  off  COW  is  a way to mitigate this bad performance.
                 Generally there are two ways to turn off COW on btrfs:

                 • Disable it by mounting with nodatacow, then all newly created files will be NOCOW

                 • For an empty file, add the NOCOW file attribute. That's what this option does.

                 Note: this option is only valid to new or empty files. If there is an existing  file  which  is
                 COW  and  has data blocks already, it couldn't be changed to NOCOW by setting <b>nocow=on</b>. One can
                 issue <b>lsattr</b> <b>filename</b> to check if the NOCOW flag is set or not (Capital 'C' is NOCOW flag).

          <b>data_file</b>
                 Filename where all guest data will be stored. If this option is used, the qcow2 file will  only
                 contain the image's metadata.

                 Note:  Data  loss  will  occur if the given filename already exists when using this option with
                 <b>qemu-img</b> <b>create</b> since <b>qemu-img</b> will create the data file anew, overwriting the file's  original
                 contents.  To simply update the reference to point to the given pre-existing file, use <b>qemu-img</b>
                 <b>amend</b>.

          <b>data_file_raw</b>
                 If this option is set to <b>on</b>, QEMU will always keep the  external  data  file  consistent  as  a
                 standalone read-only raw image.

                 It  does  this by forwarding all write accesses to the qcow2 file through to the raw data file,
                 including their offsets. Therefore, data that is visible on the qcow2 node (i.e., to the guest)
                 at some offset is visible at the same offset in the raw data file. This results in a  read-only
                 raw  image.  Writes  that  bypass the qcow2 metadata may corrupt the qcow2 metadata because the
                 out-of-band writes may result in the metadata falling out of sync with the raw image.

                 If this option is <b>off</b>, QEMU will use the data file to store data in an  arbitrary  manner.  The
                 file’s  content  will  not  make  sense  without the accompanying qcow2 metadata. Where data is
                 written will have no relation to its offset as seen by the guest, and some writes (specifically
                 zero writes) may not be forwarded to the data  file  at  all,  but  will  only  be  handled  by
                 modifying qcow2 metadata.

                 This option can only be enabled if <b>data_file</b> is set.

       <b>Other</b>
          QEMU  also  supports  various  other  image file formats for compatibility with older QEMU versions or
          other hypervisors, including VMDK, VDI, VHD (vpc), VHDX, qcow1 and QED. For a full list  of  supported
          formats  see  <b>qemu-img</b>  <b>--help</b>.   For a more detailed description of these formats, see the QEMU block
          drivers reference documentation.

          The main purpose of the block drivers for these formats is image conversion.  For running VMs,  it  is
          recommended to convert the disk images to either raw or qcow2 in order to achieve good performance.

</pre><h4><b>AUTHOR</b></h4><pre>
       Fabrice Bellard

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2024, The QEMU Project Developers

9.2.1                                             Apr 09, 2025                                       <u><a href="../man1/QEMU-IMG.1.html">QEMU-IMG</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>