<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>timg - A terminal image and video viewer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/timg">timg_1.6.0-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       timg - A terminal image and video viewer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>timg</b> [&lt;<u>options</u>&gt;] &lt;<u>image/video</u>&gt; [&lt;<u>image/video</u>&gt;...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Show images, play animated gifs, scroll static images or play videos in the terminal.  Even show PDFs.

       View  images  without leaving the comfort of your shell.  Sometimes this is the only way if your terminal
       is connected remotely via ssh.

       The command line accepts any number of image/video filenames (or read a list of filenames  from  a  file)
       and  shows  these  in sequence one per page or in a grid in multiple columns, depending on your choice of
       <b>--grid</b>.  The output is emitted in-line with minimally messing with your terminal, so you  can  simply  go
       back in history using your terminals’ scroll-bar (Or redirecting the output to a file allows you to later
       simply <b>cat</b> that file to your terminal.  Even <b>less</b> <b>-R</b> seems to be happy with such output).

       The  special  filename “-” stands for standard input, so you can read an image from a pipe.  If the input
       from a pipe is a video, use the <b>-V</b> option (see below).

       Under the hood, timg uses various image libraries to open and decode a wide range of image  formats.   It
       uses threads to open and decode images in parallel for super-fast viewing experience for many images.  To
       play  videos,  it  uses libav from files and URLs.  With <b>-I</b> or <b>-V</b> you can choose to use only one of these
       file decoders ({GraphicsMagick, turbojpeg, qoi} or libav respectively).

</pre><h4><b>OPTIONS</b></h4><pre>
   <b>General</b> <b>Options</b>
       Most likely commonly needed options first.

       <b>-p</b> <u>&lt;[h|q|s|k|i]&gt;</u>, <b>--pixelation</b>=<u>[h|q|s|k|i]</u>
              Choice for pixelation of the content.

              Available values

              <b>half</b> (short `h')
                     Uses unicode half block characters, this is the lowest resolution.  Color is using a  lower
                     or  upper  half  block and chooses the foreground color and background color to make up two
                     vertical pixels per character cell.  Half blocks have a pixel aspect ratio of about 1:1 and
                     represent colors correctly, but they look more `blocky'.

              <b>quarter</b> (short `q')
                     This chooses a Unicdoe character with small sub-blocks for four pixels per characcter cell.
                     Quarter blocks will have a pixel aspect  ratio  of  1:2  (timg  will  stretch  the  picture
                     accordingly, no worries), and can only represent colors approximately, as the four quadrant
                     sub-pixels  can  only  be  foreground  or  background  color.   This  increases the spatial
                     resolution in x-direction at expense of slight less color accuracy.  It makes it look  less
                     `blocky' and usually better.

              <b>sixel</b> (short `s')
                     Sixel  output  allows a high resolution image output that dates back to DEC VT200 and VT340
                     terminals.  This image mode provides full resolution on  a  256  color  palette  that  timg
                     optimizes  for  each  image.  You find the sixel protocol implemented by xterm (invoke with
                     -ti vt340) and mlterm or konsole.  Recently, more  terminal  emulators  re-discovered  this
                     format  and  started implementing it.  This does not work in tmux, but there is a tmux fork
                     with sixel support around.

              <b>kitty</b> (short `k')
                     The Kitty terminal implements an image protocol that allows for full 24Bit RGB/32 Bit  RGBA
                     images  to  be displayed.  This is implemented in the kitty terminal but also e.g. konsole.
                     You can even use this in tmux:  This  is  the  only  protocol  that  can  work  around  the
                     reluctance  of  tmux  to  allow  graphics  protocols.   Some  creative workarounds (Unicode
                     placeholders) are used that are only implemented in kitty version &gt;= 0.28 right now.   Also
                     needs  tmux  version &gt;= 3.3.  You have to explicitly set the -pk option inside tmux as timg
                     would otherwise just use block-pixels there.

              <b>iterm2</b> (short `i')
                     The iterm2 graphics is another image protocol that allows for full 24 Bit RGB/32  Bit  RGBA
                     images.   It  originated  on  the  popular macOS OpenSource iTerm2 terminal but is now also
                     implemented by wezterm and konsole as well as in  the  VSCode-terminal  (enable  in  vscode
                     settings at checkbox `Terminal &gt; Integrated: Enable images').

              If no option is given, default is taken from environment variable <b>TIMG_PIXELATION</b>.  If that is not
              set,  timg  attempts  to  auto-detect  the  available  terminal  feature.  Not all full-resolution
              compatible terminals can be auto-detected so it will fall back to <b>quarter</b> in that case.   Consider
              passing the -p option or set the TIMG_PIXELATION environment variable in that case.

       <b>--grid</b>=&lt;<u>cols</u>&gt;[x&lt;<u>rows</u>&gt;]
              Arrange  images  in  a  grid.   If  only  one  parameter  is  given,  arranges  in  a  square grid
              (e.g. <b>--grid=3</b> makes a 3x3 grid).  Alternatively, you can choose columns and rows that should  fit
              on one terminal (e.g. <b>--grid=3x2</b>).  This is a very useful option if you want to browse images (see
              examples below).

       <b>-C</b>, <b>--center</b>
              Center image(s) and title(s) horizontally in their alotted space.

       <b>--title</b>[=&lt;<u>format-string</u>&gt;]
              Print  title  above  each image.  It is possible to customize the title by giving a format string.
              In this string, the following format specifiers are expanded:

              • %f = full filename

              • %b = basename (filename without path)

              • %w = image width

              • %h = image height

              • %D = internal decoder used (image, video, qoi, sta, openslide, ...)

              If no format string is given, this is just the filename (%f) or, if set, what is provided  in  the
              TIMG_DEFAULT_TITLE environment variable.

       <b>-f</b> &lt;<u>filelist-file</u>&gt;
              Read a list of image filenames to show from this file.  The list needs to be newline separated, so
              one filename per line.  This option can be supplied multiple times in which case it appends to the
              end  of  the  list  of images to show.  If there are also filenames on the command line, they will
              also be shown after the images from the file list have been shown.

              Absolute filenames in the list are used as-is, relative filenames are  resolved  relative  to  the
              <u>current</u> <u>directory</u>.

              (Note:  this  behavior changed between v1.5.0 and v1.5.1: previously, -f was resolving relative to
              the filelist; this changed to current directory.  Look-up relative to the file  list  is  provided
              with with uppercase <b>-F</b>).

       <b>-F</b> &lt;<u>filelist-file</u>&gt;
              Like  <b>-f</b>,  but relative filenames are resolved relative to the <u>directory</u> <u>the</u> <u>file</u> <u>list</u> <u>resides</u> <u>in</u>.
              This allows you to e.g. have a file list at  the  top  of  a  directory  hierarchy  with  relative
              filenames  but  are  not  required  to  change  into  that directory first for timg to resolve the
              relative paths.

       <b>-b</b> &lt;<u>background-color</u>&gt;
              Set the background color for transparent images.  Common HTML/SVG/X11 color strings are supported,
              such as <b>purple</b>, <b>#00ff00</b> or <b>rgb(0,</b> <b>0,</b> <b>255)</b>.

              The special value <b>none</b> switches off blending background  color  and  relies  on  the  terminal  to
              provide  alpha-blending.  This works well with kitty and iterm2 graphics, but might result in less
              blended edges for the text-block based pixelations.

              Another special value is <b>auto</b>:

              • For graphics modes, this behaves like none, sending RGBA images for alpha-blending  directly  in
                the terminal.

              • For text-block modes, this attempts to query the terminal for its background color (Best effort;
                not all terminals support that).  If detection fails, the fallback is `black'.

              Default is <b>auto</b>.

       <b>-B</b> &lt;<u>checkerboard-other-color</u>&gt;
              Show  the  background of a transparent image in a checkerboard pattern with the given color, which
              alternates with the <b>-b</b> color.  The allows for HTTML/SVG/X11 colors like <b>-b</b>.

              The checkerboard pattern has square blocks one character cell wide  and  half  a  cell  high  (see
              --pattern-size to change).

              A common combination would be to use -bgray -Bdarkgray for backgrounds known from image editors.

              Sometimes setting such background is the only way to see an image, e.g.  if you have an image with
              a transparent background showing content with the same color as your terminal background...

       <b>--pattern-size</b>=&lt;<u>size-factor</u>&gt;
              Scale background checkerboard pattern by this factor.

       <b>--auto-crop</b>[=&lt;<u>pre-crop</u>&gt;]
              Trim  same-color  pixels  around  the  border  of image before displaying.  Use this if there is a
              boring even-colored space aorund the image which uses too many of our available few pixels.

              The optional pre-crop is number of pixels to unconditionally trim all around the  original  image,
              for  instance to remove a thin border.  The link in the EXAMPLES section shows an example how this
              improves showing an xkcd comic with a border.

       <b>--rotate</b>=&lt;<u>exif</u>|<u>off</u>&gt;
              If `exif', rotate the image according to the exif data  stored  in  the  image.   With  `off',  no
              rotation is extracted or applied.

       <b>-W</b>, <b>--fit-width</b>
              Scale  to  fit  width  of  the  available space.  This means that the height can overflow, e.g. be
              longer than the terminal, so might require scrolling to see the full picture.  Default behavior is
              to fit within the allotted width <u>and</u> height.

       <b>-U</b>, <b>--upscale</b>[=i]
              Allow Upscaling.  If an image is smaller than the terminal size, scale it up to fit the terminal.

              By default, larger images are only scaled down and images smaller than the available pixels in the
              terminal are left at the original size (this helps assess small deliberately pixelated images such
              as icons in their intended appearance).  This option scales up smaller  images  to  fit  available
              space (e.g. icons).

              The  long  option  allows for an optional parameter <b>--upscale=i</b> that forces the upscaling to be in
              integer increments to keep the `blocky' appearance of an upscaled  image  without  bilinear  scale
              `fuzzing'.

       <b>--clear</b>[=every]
              Clear screen before <u>first</u> image.  This places the image at the top of the screen.

              There  is  an optional parameter `<u>every</u>' (<b>--clear=every</b>), which will clean the screen before every
              image.  This only makes sense if there is no <b>--grid</b> used and if you allow some time  to  show  the
              image of course, so good in combination with <b>-w</b>.

       <b>-V</b>     Tell  timg  that  this  is  a video, directly read the content as video and don’t attempt to probe
              image decoding first.

              Usually, timg will first attempt to interpret the data as  image,  but  if  it  that  fails,  will
              fall-back  to  try  interpret  the  file as video.  However, if the file is coming from stdin, the
              first bytes used to probe for the image have already been consumed so the fall-back would fail  in
              that case...  Arguably, this should be dealt with automatically but isn’t :)

              Long  story short: if you read a video from a pipe, use <b>-V</b>.  See link in EXAMPLES section for a an
              example.

       <b>-I</b>     This is an image, don’t attempt to fall back to video decoding.  Somewhat the opposite of <b>-V</b>.

       <b>-w</b>&lt;<u>seconds</u>&gt;
              Wait time in seconds  between  images  when  multiple  images  are  given  on  the  command  line.
              Fractional values such as -w0.3 are allowed.

       <b>-wr</b>&lt;<u>seconds</u>&gt;
              Similar  to -w, but wait time between <u>rows</u>.  If a --grid is chosen, this will wait at the end of a
              completed row.  If no grid is chosen, then this is equivalent to -w.  Both,  -w  and  -wr  can  be
              provided to show each image individually, but also have a wait time between rows.

       <b>-a</b>     Switch  off anti-aliasing.  The images are scaled down to show on the minimal amount of pixels, so
              some smoothing is applied for best visual effect.  This option switches off that smoothing.

       <b>-g</b> <u>&lt;width&gt;x&lt;height&gt;</u>
              Geometry.  Scale output to fit inside given number of character cells.  By default,  the  size  is
              determined  by  the  available  space in the terminal, so you typically won’t have to change this.
              The image is scaled to fit inside the available box to fill the screen; see <b>-W</b> if you want to fill
              the width.

              It is possible to only partially specify the size before or after the x-separator, like <b>-g&lt;width&gt;x</b>
              or <b>-gx&lt;height&gt;</b>.  The corresponding other value is then derived from the terminal size.

       <b>-o</b> &lt;<u>outfile</u>&gt;
              Write terminal image to given filename instead of stdout.

       <b>-E</b>     Don’t hide the cursor while showing images.

       <b>--compress</b>[=&lt;<u>level</u>&gt;]
              For the kitty and iterm2 graphics modes: this chooses the compression for the transmission to  the
              terminal.   This  uses  more  CPU  on  timg,  but is desirable when connected over a slow network.
              Default compression level is 1 which should  be  reasonable  default  in  almost  all  cases.   To
              disable, set to 0 (zero).  Use --verbose to see the amount of data timg sent to the terminal.

       <b>--threads</b>=&lt;<u>n</u>&gt;
              Run  image  decoding  in parallel with n threads.  By default, up to 3/4 of the reported CPU-cores
              are used.

       <b>--color8</b>
              For half and quarter block pixelation: Use 8 bit color mode for terminals that  don’t  support  24
              bit color (only shows 6x6x6 = 216 distinct colors instead of 256x256x256 = 16777216).

       <b>--version</b>
              Print version and exit.

       <b>--verbose</b>
              Print  some  useful  information  such  as observed terminal cells, chosen pixelation, or observed
              frame-rate.

       <b>-h</b>     Print command line option help and exit.

       <b>--help</b> Page through detailed manpage-like help and exit.

       <b>--debug-no-frame-delay</b>
              Don’t delay frames in videos or animations but emit as fast as possible.  This might be useful for
              developers of terminal emulations to do performace tests or simply if you  want  to  redirect  the
              output to a file and don’t want to wait.

   <b>For</b> <b>Animations,</b> <b>Scrolling,</b> <b>or</b> <b>Video</b>
       Usually, animations are shown in full in an infinite loop.  These options limit infinity.

       <b>-t</b>&lt;<u>seconds</u>&gt;
              Stop an animation after these number of seconds.  Fractional values are allowed.

       <b>--loops</b>=&lt;<u>num</u>&gt;
              Number  of  loops  through  a  fully  cycle  of  an  animation or video.  A value of <u>-1</u> stands for
              `forever'.

              If <u>not</u> set, videos loop once, animated images forever unless there is more than one file to  show.
              If there are multiple files on the command line, animated images are only shown once if <b>--loops</b> is
              not set to prevent the output get stuck on the first animation.

       <b>--frames</b>=&lt;<u>frame-count</u>&gt;
              Only  render  the  first <u>frame-count</u> frames in an animation or video.  If frame-count is set to 1,
              the output just is the first frame so behaves like a static image.  Typically you’d  use  it  when
              you show a bunch of images to quickly browse without waiting for animations to finish.

       <b>--frame-offset</b>=&lt;<u>offset</u>&gt;
              For animations or videos, start at this frame.

   <b>Scrolling</b>
       <b>--scroll</b>[=&lt;<u>ms</u>&gt;]
              Scroll  horizontally  with  an  optional  delay  between updates (default: 60ms).  In the EXAMPLES
              section is an example how to use ImageMagick to create a text that you then can scroll  with  <b>timg</b>
              over the terminal.

       <b>--delta-move</b>=&lt;<u>dx</u>&gt;:&lt;<u>dy</u>&gt;
              Scroll with delta x and delta y.  The default of 1:0 scrolls it horizontally, but with this option
              you can scroll vertically or even diagonally.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Exit code is

       <b>0</b>      On reading and displaying all images successfully.

       <b>1</b>      If any of the images could not be read or decoded or if there was no image provided.

       <b>2</b>      If an invalid option or parameter was provided.

       <b>3</b>      If  timg could not determine the size of terminal (not a tty?).  Provide <b>-g</b> option to provide size
              of the output to be generated.

       <b>4</b>      Could not write to output file provided with <b>-o</b>.

       <b>5</b>      Could not read file list file provided with <b>-f</b>.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>TIMG_DEFAULT_TITLE</b>
              The default format string used for --title.  If not given, the  default  title  format  string  is
              "%f".

       <b>TIMG_PIXELATION</b>
              The  default  pixelation  if  not  provided by the -p or --pixelation option (see choice of values
              there).  If neither the environment variable nor the option is given, timg attempts to auto-detect
              the best pixelation for the terminal.

       <b>TIMG_USE_UPPER_BLOCK</b>
              If this environment variable is set to the value <b>1</b>, timg will use the U+2580 - `Upper Half  Block'
              Unicode character.

              To  display  pixels,  timg  uses a Unicode half block and sets the foreground color and background
              color to get two vertical pixels.  By default, it uses the U+2584 - `Lower Half  Block'  character
              to  achieve  this  goal.   This  has  been  chosen  as it resulted in the best image in all tested
              terminals (konsole, gnome terminal and cool-retro-term).  So usually, there is no need  to  change
              that.   But  if the terminal or font result in a funny output, this might be worth a try.  This is
              an environment variable because if it turns out to yield a better result on your system,  you  can
              set it once in your profile and forget about it.

       <b>TIMG_FONT_WIDTH_CORRECT</b>
              A  floating  point stretch factor in width direction to correct for fonts that don’t produce quite
              square output.

              If you notice that the image displayed is not quite the right aspect ratio  because  of  the  font
              used,  you  can  modify  this  factor to make it look correct.  Increasing the visual width by 10%
              would be setting it to <u>TIMG_FONT_WIDTH_CORRECT=1.1</u> for instance.

              This is an environment variable, so that you can set it once to best fit your terminal emulator of
              choice.

       <b>TIMG_ALLOW_FRAME_SKIP</b>
              Set this environment variable to 1 if you like to allow timg to  drop  frames  when  play-back  is
              falling  behind.  This is particularly useful if you are on a very slow remote terminal connection
              that can’t keep up with playing videos.  Or if you have a very slow CPU.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Some example invocations including scrolling text or streaming  an  online  video  are  put  together  at
       https://timg.sh/#examples

       It might be useful to prepare some environment variables or aliases in the startup profile of your shell.
       The timg author typically has these set:

              # The default --title format
              export TIMG_DEFAULT_TITLE="%b (%wx%h)"

              # image list. An alias to quickly list images; invoke with ils images/*
              alias ils='timg --grid=3x1 --upscale=i --center --title --frames=1 -bgray -Bdarkgray'

</pre><h4><b>KNOWN</b> <b>ISSUES</b></h4><pre>
       This  requires a terminal that can deal with Unicode characters and 24 bit color escape codes.  This will
       be problematic on really old installations or if you want to display images on some limited text console.

       The option <b>-V</b> should not be necessary for streaming video from stdin; timg should internally buffer bytes
       it uses for probing.

</pre><h4><b>BUGS</b></h4><pre>
       Report bugs at <a href="http://github.com/hzeller/timg/issues">http://github.com/hzeller/timg/issues</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2016..2023 Henner Zeller.  This program is  free  software,  provided  under  the  GNU  GPL
       version 2.0.

       https://gnu.org/licenses/gpl-2.0.html

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       GraphicsMagick, <a href="../man1/ffmpeg.1.html">ffmpeg</a>(1), <a href="../man7/utf-8.7.html">utf-8</a>(7), <a href="../man7/unicode.7.html">unicode</a>(7), <a href="../man1/kitty.1.html">kitty</a>(1), https://en.wikipedia.org/wiki/Sixel

</pre><h4><b>AUTHORS</b></h4><pre>
       Henner Zeller.

                                                    Dec 2023                                             <u><a href="../man1/timg.1.html">timg</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>