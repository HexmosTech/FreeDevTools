<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xgterm - terminal emulator for X with graphics and imaging capability</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/xgterm">xgterm_2.2+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       xgterm - terminal emulator for X with graphics and imaging capability

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>xgterm</b> [-<u>toolkitoption</u> ...] [-<u>option</u> ...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>xgterm</u>  program  is  a  terminal  emulator for the X Window System based largely on <u>xterm</u> but with a
       completely new graphics and imaging widget. It provides DEC VT102 and Tektronix 4014 compatible terminals
       for programs that can't use the window system directly.  <u>XGterm</u> also serves as a prototype for the <u>Widget</u>
       <u>Server</u> being developed by the IRAF Project at NOAO.  The <u>Object</u> <u>Manager</u>  <u>Library</u>  it  uses  implements  a
       window  system  toolkit as an interpreted window-object language, allowing application GUIs to be defined
       and executed at runtime without compiling any code, and  with  minimal  dependence  upon  the  underlying
       window system toolkit library.  We will concentrate here, however, on it's use as a terminal emulator and
       a description of the new <u>Gterm</u> widget.

       The  Gterm  graphics  window  operates  almost  identically  to  the  <u>xterm</u> Tek window, however there are
       extensions for implementing full-screen cursors, imaging, area fills, colors, graphics erasure, a "status
       line" and so on.  Any graphics application capable of running under an <u>xterm</u> Tek window  should  also  be
       able  to  use  <u>xgterm</u>  as  well.   Client programs wishing to make use of the extended features, or those
       wishing to implement a GUI, are advised to use the OBM (<u>Object</u> <u>Manager</u>) library supplied with the  XGterm
       source  as part of the X11IRAF package.  This provides a much better programmatic interface to all of the
       features available; however, as of this writing it is not yet fully documented.  Users  are  referred  to
       the  <u>XImtool</u>  task as an example of a more complex application using the <u>OBM</u> <u>Library</u> and <u>Gterm</u> widget, as
       well as demo tasks in the <u>guidemo</u> directory of the X11IRAF sources.

       The VT102 text window is unchanged from the original <u>xterm</u> application.  All of it's resources,  command-
       line  options  and  operation are identical to that used by <u>xterm</u>.  The <u><a href="../man5/termcap.5.html">termcap</a>(5)</u> entry for <u>xterm</u> may be
       used for <u>xgterm</u> as well.  See the <u><a href="../man1/xterm.1.html">xterm</a>(1)</u> man page for details.

</pre><h4><b>OPTIONS</b></h4><pre>
       All <u><a href="../man1/xterm.1.html">xterm</a>(1)</u> and X Toolkit command line options are supported, there are no additional options.

</pre><h4><b>RESOURCES</b></h4><pre>
       The program understands all of the core X Toolkit resource names and classes, all text  window  resources
       known  to  <u><a href="../man1/xterm.1.html">xterm</a>(1)</u>, as well as the <u>Gterm</u> (graphics and imaging widget) resources.  The proper Class name
       for all resources described here is <u>Gterm</u>.  A table of available <u>Gterm</u> resources and their  defaults  may
       be found below, some of the more interesting resources are described here in detail:

       <u>basePixel</u>
            Base  cell  of  the custom colormap.  This essentially allows you to reserve <u>basePixel</u> colors in the
            global colormap for other applications.  The default is 38, if changed you'll need  to  also  enable
            the <u>cmapInitialize</u> resource to force the Gterm widget to update it's global colormap resource in the
            X server.

       <u>cmapInitialize</u>
            Initialize  the ximtool colormap at startup.  When resetting the <u>basePixel</u> resource or colormap this
            is required in order to force the Gterm widget to update it's global  colormap  resource  in  the  X
            server.  The default is False.

       <u>cmapInterpolate</u>
            Interpolate the colormap to the number of display colors.  The default is True.

       <u>cmapName</u>
            Name  used  for  private  colormap.   The default for all IRAF imaging applications is <u>image</u>.  Gterm
            widget based imaging applications which have  the  same  value  of  cmapName  will  share  the  same
            colormap,  minimizing  colormap  flashing  and  allowing multiple applications to be run at the same
            time.

       <u>color0</u>
            The widget background color.  The default is black.

       <u>color1</u>
            The widget foreground color.  The default is white.

       <u>color2</u>  thru  <u>color9</u>
            Optional drawing colors.  The line color used for graphics is set using an escape sequence to select
            the current color index.  See <u>Gterm</u> <u>I/O</u> <u>Escape</u> <u>Sequences</u> below for more details.

       <u>crosshairCursorColor</u>
            Color of the full screen crosshair cursor.

       <u>defaultMarker</u>
            Default marker type.  Options include <u>text</u>, <u>line</u>, <u>polyline</u>, <u>rectangle</u>,  <u>box</u>,  <u>circle</u>,  <u>ellipse</u>,  and
            <u>polygon</u>.  The default is <u>rectangle</u>.

       <u>deiconifyWindow</u>
            De-iconify the Gterm graphics window when activated.  The default is False.

       <u>dialogBgColor</u>
            Dialog  box  (i.e.  the  status line) background color.  Dialog text is text which is drawn into the
            dialog area at the bottom of the gterm window, it is transient and is not a permanent  part  of  the
            graphics being drawn.  Dialog text is normally used to interact with the user or to display messages
            during program operation, without affecting the graphics being drawn.

       <u>dialogFgColor</u>
            Dialog box (i.e. status line) foreground color.

       <u>ginmodeBlinkInterval</u>
            Graphics cursor blink interval, time is specified in milliseconds.  The default is 0.

       <u>ginmodeCursor</u>
            Graphics mode cursor type.  The default is a full screen cursor custom to the widget.

       <u>height</u>
            Height of the Gterm window.  The default is 480.

       <u>idleCursor</u>
            Cursor to use when not in graphics mode.  The default is a plus sign.

       <u>markerHighlightColor</u>
            Highlight  color for the active marker.  When the pointer moves into a marker is it marked "active",
            the highlight color and width change to which marker is active.  The default is green.

       <u>markerHighlightWidth</u>
            Highlight width for the active marker. The default is 2.

       <u>maxColors</u>
            The maximum number of colors to use in the private global colormap, the default is 216.  Out of this
            number 10 colors (the <u>color0</u> thru <u>color9</u> values) are reserved by the widget as  static  colors,  the
            remainder may be allocated for images.

       <u>raiseWindow</u>
            Raise the window when active.  The default is False.

       <u>warpCursor</u>
            Warp the cursor to the window when active.  The default is False.

       <u>width</u>
            Width of the Gterm window.  The default is 640.

</pre><h4><b>GTERM</b> <b>WIDGET</b> <b>RESOURCES</b></h4><pre>
   <b>Class</b> <b>Hierarchy</b>
       <b>Core</b> <b>-&gt;</b> <b>Gterm</b>

   <b>Resources</b>
       When  creating  a Gterm widget instance, the following resources are retrieved from the arguments list or
       from the resource database:

       <b>Name</b>                     <b>Class</b> <b>Type</b>    <b>Default</b>          <b>Description</b>
       ─────────────────────────────────────────────────────────────────────────────────────────────────────────
       alphaFont1               XFontStruct   nil2             Graphics fonts
       alphaFont2               XFontStruct   5x8                    "
       alphaFont3               XFontStruct   6x10                   "
       alphaFont4               XFontStruct   7x13                   "
       alphaFont5               XFontStruct   8x13                   "
       alphaFont6               XFontStruct   9x15                   "
       alphaFont7               XFontStruct   9x15                   "
       alphaFont8               XFontStruct   9x15                   "
       basePixel                Int           38               Base of private global colormap
       busyCursor               String        watch            Cursor to use when application is busy
       busyCursorBgColor        Foreground    white            Busy cursor background color
       busyCursorFgColor        Foreground    black            Busy cursor foreground color
       cacheRasters             String        whenNeeded       Save rasters as server pixmaps for faster access
       cmapInitialize           Boolean       False            Initialize colormap at startup
       cmapInterpolate          Boolean       True             Interpolate colormap
       cmapName                 String        default          Custom colormap name
       cmapShadow               Int           10               Colormap shadow interval
       cmapUpdate               Int           60               Colormap update interval
       color0                   Background    black            Default graphics background color
       color1                   Foreground    white            Default graphics foreground color
       color2                   Foreground    red              Optional drawing color
       color3                   Foreground    green                  "
       color4                   Foreground    blue                   "
       color5                   Foreground    cyan                   "
       color6                   Foreground    yellow                 "
       color7                   Foreground    magenta                "
       color8                   Foreground    purple                 "
       color9                   Foreground    darkslategray          "
       copyOnResize             Boolean       True             Copy raster when resized
       crosshairCursorColor     Foreground    red              Full-screen cursor color
       defaultMarker            String        rectangle        Default marker type
       deiconifyWindow          Boolean       False            Deiconify window when active
       dialogBgColor            Foreground    yellow           Status line background color
       dialogFgColor            Foreground    black            Status line foreground color
       dialogFont1              XFontStruct   nil2             Status line fonts
       dialogFont2              XFontStruct   5x8                    "
       dialogFont3              XFontStruct   6x10                   "
       dialogFont4              XFontStruct   7x13                   "
       dialogFont5              XFontStruct   8x13                   "
       dialogFont6              XFontStruct   9x15                   "
       dialogFont7              XFontStruct   9x15                   "
       dialogFont8              XFontStruct   9x15                   "
       ginmodeBlinkInterval     Int           0                Graphics cursor blink interval
       ginmodeCursor            String        full_crosshair   Graphics cursor type
       ginmodeCursorBgColor     Foreground    black            Graphics cursor background color
       ginmodeCursorFgColor     Foreground    white            Graphics cursor foreground color
       height                   Dimension     480              Height of graphics window
       idleCursor               String        Plus             Idle cursor type
       idleCursorBgColor        Foreground    white            Idle cursor background color
       idleCursorFgColor        Foreground    black            Idle cursor foreground color
       markerBoxKnotColor       Foreground    blue             Vertex knot color
       markerBoxKnotSize        Int           0                Vertex knot size
       markerBoxLineColor       Foreground    green            Marker border color
       markerCircleKnotColor    Foreground    blue             Vertex knot color
       markerCircleKnotSize     Int           0                Vertex knot size
       markerCircleLineColor    Foreground    green            Marker border color
       markerCursorBgColor      Foreground    black            Cursor background when in marker
       markerCursorFgColor      Foreground    yellow           Cursor foreground when in marker
       markerEllipseKnotColor   Foreground    blue             Vertex knot color
       markerEllipseKnotSize    Int           0                Vertex knot size
       markerEllipseLineColor   Foreground    green            Marker border color
       markerFill               Boolean       False            Flood fill marker area with <u>markerFillColor</u>
       markerFillBgColor        Foreground    black            Fill area background color
       markerFillColor          Foreground    slategray        Flood fill color
       markerFillStyle          Int           FillSolid        Fill area style
       markerHighlightColor     Foreground    green            Marker highlight color
       markerHighlightWidth     Int           2                Marker highlight line width
       markerLineKnotColor      Foreground    blue             Vertex knot color
       markerLineKnotSize       Int           5                Vertex knot size
       markerLineLineColor      Foreground    green            Line marker color
       markerLineStyle          Int           LineSolid        Line marker line style
       markerLineWidth          Int           1                Line marker width
       markerPgonKnotColor      Foreground    blue             Vertex knot color
       markerPgonKnotSize       Int           5                Vertex knot size
       markerPgonLineColor      Foreground    green            Marker border color
       markerRectKnotColor      Foreground    blue             Vertex knot color
       markerRectKnotSize       Int           0                Vertex knot size
       markerRectLineColor      Foreground    green            Marker border color
       markerTextBgColor        Foreground    slategray        Text marker background color
       markerTextBorder         Int           2                Text marker border width
       markerTextColor          Foreground    yellow           Text marker text color
       markerTextFont           XFontStruct   6x13             Text marker font
       markerTextLineColor      Foreground    green            Text marker line color
       markerTextString         String        NULL             Text string
       markerTranslations       String        default          Marker event-to-actions translations
       maxColors                Int           216              Max colors in custom colormap
       maxMappings              Int           32               Max image mappings
       maxRasters               Int           512              Max image rasters
       nearEdge                 Int           1                Distance, in pixels, between pointer and  marker
                                                               edge  required for translation actions for be in
                                                               effect.
       nearVertex               Int           4                Distance, in pixels between pointer  and  marker
                                                               vertex  (i.e.  <u>knot</u>)  required  for  translation
                                                               actions for be in effect.
       raiseWindow              Boolean       False            Raise window when active
       translations             String        default          Event-to-actions translations
       useTimers                Boolean       True             Ok to use timers
       warpCursor               Boolean       False            Enable warp cursor when active
       width                    Dimension     640              Height of graphics window
       xorFill                  Boolean       False            Fill with GXxor
       xorFillBgColor           Int           255              Xor-fill background color
       xorFillColor             Int           2                Xor-fill color

</pre><h4><b>GTERM</b> <b>WIDGET</b> <b>TRANSLATIONS</b> <b>AND</b> <b>ACTIONS</b></h4><pre>
       The default translations for a Gterm window are:
                                              &lt;Btn1Down&gt;:   m_create()
                                              &lt;Btn2Down&gt;:   crosshair(on)
                                            &lt;Btn2Motion&gt;:   crosshair(on)
                                                &lt;Btn2Up&gt;:   crosshair(off)
                                           &lt;EnterWindow&gt;:   enter-window()
                                           &lt;LeaveWindow&gt;:   leave-window()
                                              &lt;KeyPress&gt;:   graphics-input()
                                                &lt;Motion&gt;:   track-cursor()

       The available action procedures for a Gterm window are:

              <u>ignore()</u>            Ignore an event.

              <u>graphics-input()</u>    Handle a graphics input request.

              <u>crosshair(on|off)</u>   Display a crosshair cursor.

              <u>track-cursor()</u>      Track crosshair cursor position.

              <u>enter-window()</u>      Handle an EnterWindow event.

              <u>leave-window()</u>      Handle an LeaveWindow event.

              <u>reset()</u>             Do a soft reset of the Gterm widget.

              <u>m_create()</u>          Create a new marker.  Valid types include
                                                       <u>text</u>   <u>line</u>     <u>polyline</u>   <u>rectangle</u>
                                                       <u>box</u>    <u>circle</u>   <u>ellipse</u>    <u>polygon</u>
                                  The default is <u>rectangle</u>, if no type is given the default  type  specified  by
                                  the <u>markerType</u> resource will be used.

</pre><h4><b>GTERM</b> <b>MARKER</b> <b>TRANSLATIONS</b> <b>AND</b> <b>ACTIONS</b></h4><pre>
       The default translations for a marker are:

                                   !Shift &lt;Btn1Motion&gt;:   m_rotateResize()
                                          &lt;Btn1Motion&gt;:   m_moveResize()
                                     !Shift &lt;Btn1Down&gt;:   m_raise()  m_markpos()
                                            &lt;Btn1Down&gt;:   m_raise()  m_markposAdd()
                                              &lt;Btn1Up&gt;:   m_redraw() m_destroyNull()
                                            &lt;Btn2Down&gt;:   m_lower()
                                        &lt;Key&gt;BackSpace:   m_deleteDestroy()
                                           &lt;Key&gt;Delete:   m_deleteDestroy()
                                            &lt;KeyPress&gt;:   m_input()
                                              &lt;Motion&gt;:   track-cursor()

       Translations  affect  only  the  currently  active marker, the cursor must be within <u>nearEdge</u> pixels of a
       marker edge, or <u>nearVertex</u> pixels of a marker vertex to take effect.

       The available action procedures for a marker are

              <u>m_create(type)</u>    Create a new marker.  Valid types include
                                                      <u>text</u>   <u>line</u>     <u>polyline</u>   <u>rectangle</u>
                                                      <u>box</u>    <u>circle</u>   <u>ellipse</u>    <u>polygon</u>
                                The default is <u>rectangle</u>, if no type is given the default type specified by  the
                                <u>markerType</u> resource will be used.

              <u>m_destroy()</u>       Destroy the active marker.

              <u>m_destroyNull()</u>   Destroy the active marker if it is null sized.

              <u>m_set(attribute,</u> <u>value,</u> <u>....)</u>
                                Set a marker attribute.  Valid attributes include

                                             <u>activated</u>   <u>autoRedraw</u>       <u>fill</u>          <u>fillBgColor</u>
                                             <u>fillColor</u>   <u>fillPattern</u>      <u>fillStyle</u>     <u>font</u>
                                             <u>height</u>      <u>highlightColor</u>   <u>imageText</u>     <u>knotColor</u>
                                             <u>knotSize</u>    <u>lineColor</u>        <u>lineStyle</u>     <u>lineWidth</u>
                                             <u>rotangle</u>    <u>sensitive</u>        <u>textBgColor</u>   <u>textBorder</u>
                                             <u>textColor</u>   <u>translations</u>     <u>type</u>          <u>visible</u>
                                             <u>width</u>       <u>x</u>                <u>y</u>

              <u>m_raise()</u>         Raise the active marker to the top of the display list.

              <u>m_lower()</u>         Lower the active marker to the bottom of the display list.

              <u>m_notify(event,</u> <u>event,</u> <u>....)</u>
                                Notify  any  clients  that  have  registered callbacks for the specified type of
                                events.  Recognized events include
                                                       <u>notify</u>    <u>moveResize</u>   <u>modify</u>
                                                       <u>redraw</u>    <u>destroy</u>      <u>input</u>
                                                       <u>focusIn</u>   <u>focusOut</u>     <u>constraint</u>

              <u>m_input()</u>         Notify any clients that have registered a input callback that a input event  has
                                occurred.

              <u>m_markpos()</u>       Mark the current position of the marker, e.g., so that it can later be erased.

              <u>m_markposAdd()</u>    Execute  either  the markpos or add action, depending upon the pointer location.
                                If the pointer is over an active marker at a location where the add  action  can
                                be executed this is done, otherwise the markpos action is executed.

              <u>m_redraw()</u>        Redraw the active marker.

              <u>m_addPt()</u>         Add a point (i.e. vertex knot). <u>Polyline</u> and <u>polygon</u> markers only.

              <u>m_deletePt()</u>      Delete a point (i.e. vertex knot).

              <u>m_movePt()</u>        Move a point (i.e. vertex knot). <u>Polyline</u> and <u>polygon</u> markers only.

              <u>m_deleteDestroy()</u> Delete a point or destroy a marker, depending upon the pointer position.

              <u>m_move()</u>          Move a marker.

              <u>m_resize()</u>        Resize a marker.

              <u>m_moveResize()</u>    Move a point or marker, or resize a marker, depending upon the pointer position.

              <u>m_rotate()</u>        Rotate a marker.

              <u>m_rotateResize()</u>  Rotate  or  resize  a  marker.   A  marker  is rotated if near a vertex know, or
                                resized if near an edge.

</pre><h4><b>GTERM</b> <b>I/O</b> <b>ESCAPE</b> <b>SEQUENCES</b></h4><pre>
       XGterm uses escape sequences to provide graphics  emulation.   This  protocol  is  an  extension  of  the
       Tektronix  4012  graphics  protocol.   The  basic  extensions are patterned after the Retrographics VT640
       graphics terminal, using GS (octal \035, aka Ctrl-]) and CAN (octal \030, aka Ctrl-x) to  switch  between
       vt100  and graphics modes.  Additional extensions are defined to support advanced features such as color,
       area fills, graphics erasure, setting the cursor location under program control, interactive  dialog  via
       the "status line", and so on.

       While  these  escape  sequences  can  be used directly, the best programmatic interface is to use the OBM
       (<u>Object</u> <u>Manager</u>) library supplied with the XGterm source as part of the X11IRAF package.  Any  Tektronix-
       compatible  graphics  library will suffice for producing vector graphics, the added escape sequences used
       by the Gterm widget are required to make use of imaging, area fills, the status line, etc.

       All escape sequences begin with an <b>ESC</b> character  (octal  \033),  followed  by  up  to  three  characters
       defining  the action to be taken.  All strings in capital letters refer to the ASCII code (e.g. <u>LF</u> is the
       ASCII linefeed code), a three digit number preceded by a '´ refers to an octal code (e.g.  " 12" is octal
       12) , all others are characters in the escape code (e.g.  "/bc" are the three characters  '/',  'b',  and
       'c').

   <b>ESCAPE</b> <b>SEQUENCES</b>
              <b>US</b>

              <b>CR</b>             Switch to alpha mode.  Characters are drawn in the graphics window at the "current"
                             position  (normally  set beforehand with a GS/US vector move), using the alpha mode
                             font. Receipt of any control code causes alpha mode to be exited.

              <b>GS</b>             Switch to vector polyline mode.

              <b>FS</b>             Switch to vector polypoint mode.

              <b>RS</b>             Switch to vector mode, vertices are joined as a polygon.

                             With all three codes, vertices and points are accumulated in a buffer and displayed
                             when the buffer fills or when vector mode is terminated by receipt of  any  control
                             code.   A  workstation  open  will  be done if it hasn't already been opened, no-op
                             sequences GS-CAN are filtered out, since they would only cause a  pointless  switch
                             to  the  graphics frame and back without drawing.  The open workstation sequence is
                             GS,US, or by the <u>xterm</u> graphics start escape sequence "[?38h".

              <b>EM</b>             Enter message mode.  In message mode input text is  accumulated  in  a  buffer  and
                             eventually  passed  to  the  object  manager,  which  delivers  the  message to the
                             referenced object.  Messages are used to download the user interface to be executed
                             by the object manager.  During execution, messages are used to set  the  values  of
                             user  interface  parameters  to  allow  the  UI  to  track  the state of the client
                             application.

              <b>CAN</b>            Close workstation and enter command mode.

              <b>BEL</b>            Ring the screen bell.

              <b>ENQ</b>            Return terminal status.  Returned values  include  the  terminal  mode,  and  alpha
                             cursor x and y position.

              <b>SUB</b>            Initiate a cursor read, values are returned in window coordinates.

              <b>/SUB</b>           Return window cursor position in raster coordinates.

              <b>FF</b>             Clear the screen.

              <b>/f</b>             Set current cursor position.

              <b>0</b>              Set character size 0. (Currently ignored).

              <b>1</b>              Set character size 1. (Currently ignored).

              <b>2</b>              Set character size 2. (Currently ignored).

              <b>3</b>              Set character size 3. (Currently ignored).

              <b>/0d</b>            Set color index.

              <b>/1d</b>            Clear graphics screen.

              <b>/2d</b>            Invert graphics screen

              <b>`</b>              Select line style 0. (Solid)

              <b>a</b>              Select line style 1. (Dashed)

              <b>b</b>              Select line style 2. (Dotted)

              <b>c</b>              Select line style 3. (DashDot)

              <b>d</b>              Select line style 4. (Dash3Dot)

              <b>/0w</b>            Select line width 0.

              <b>/1w</b>            Select line width 1.

              <b>/2w</b>            Select line width 2.

              <b>/nw</b>            Select line width 3.

              <b>/0c</b>            Select line color 0.

              <b>/1c</b>            Select line color 1.

              <b>/2c</b>            Select line color 2.

              <b>/3c</b>            Select line color 3.

              <b>/4c</b>            Select line color 4.

              <b>/5c</b>            Select line color 5.

              <b>/6c</b>            Select line color 6.

              <b>/7c</b>            Select line color 7.

              <b>/8c</b>            Select line color 8.

              <b>/9c</b>            Select line color 9.

   <b>IMAGING</b> <b>ESCAPE</b> <b>SEQUENCES</b>
       These are encoded as follows:

                 <b>ESC</b> &lt;code&gt; [ <u>P</u> <u>;</u> <u>P</u> ; ... ] &lt;<u>data</u>&gt;

       where <u>code</u> is a character sequence and <u>P</u> is an ASCII encoded parameter described below.

              <b>/nc</b>            Select line color.  Parameter is the color number in the range 0-9.

              <b>sre</b>            <u>Reset</u>.  Parameters are "reset-str".

              <b>ssz</b>            <u>Resize</u>. Parameters are "resize-str".

              <b>rir</b>            <u>Initialize</u> <u>raster</u>.

              <b>rcr</b>            <u>Create</u>  <u>a</u>  <u>raster</u>.   Parameters  are raster number, type, width, height, and depth.
                             Type is 1 for a normal (client) raster, 2 for cached in server memory, or 0 if  you
                             don't care.  Depth may be 1, 8, 16, or 32.

              <b>rde</b>            <u>Destroy</u> <u>a</u> <u>raster</u>.  Parameter is raster number.

              <b>rqr</b>            <u>Query</u>  <u>a</u>  <u>raster</u>.  Parameter is raster number.  Output parameters are status, type,
                             width, height, and depth encoded in the string ""\033[5;%d;%d;%d;%d;%d]".

              <b>rsr</b>            <u>Select</u> <u>a</u> <u>raster</u>.  Parameter is raster number.

              <b>rwr</b>            <u>Write</u> <u>pixels</u> <u>to</u> <u>a</u> <u>rectangular</u> <u>region</u> <u>of</u> <u>a</u> <u>raster</u>.  Parameters  are  raster  number,
                             encoding  type  (not  used),  x1,  y1,  nx,  ny, and depth followed by (nx*ny) data
                             pixels.

              <b>rrd</b>            <u>Read</u> <u>from</u> <u>a</u> <u>rectangular</u> <u>region</u> <u>of</u> <u>a</u> <u>raster</u>.  Parameters are raster number, encoding
                             type (not used), x1, y1, nx, ny, and depth followed by (nx*ny) data pixels.

              <b>rrp</b>            <u>Refresh</u> <u>raster</u> <u>pixels</u>.  Parameters are raster number, coordinate type (0 for pixel,
                             1 for NDC), x1, y1, nx, ny.

              <b>rsp</b>            <u>Set</u> <u>all</u> <u>the</u> <u>raster</u> <u>pixels</u> <u>in</u> <u>a</u> <u>region</u> <u>to</u> <u>a</u> <u>single</u>  <u>color</u>.   Parameters  are  raster
                             number, coordinate type (0 for pixel, 1 for NDC), x1, y1, nx, ny, color, and raster
                             operand.   If  nx=ny=0  the entire raster will be written.  Raster operands include
                             transient (octal 020), refresh_all (octal 040), or refresh_none (octal 100).

              <b>rco</b>            <u>Copy</u> <u>a</u> <u>region</u> <u>of</u>  <u>the</u>  <u>source</u>  <u>raster</u>  <u>to</u>  <u>a</u>  <u>region</u>  <u>of</u>  <u>the</u>  <u>destination</u>  <u>raster</u>.
                             Parameters  are  raster operand, source raster number, source type, source x coord,
                             source y coord, source width, source height, destination raster number, destination
                             type, destination x coord, destination  y  coord,  destination  width,  destination
                             height,  If  the  input  and  output  regions are not the same size the subimage is
                             automatically scaled to fit the destination region.  If the destination extent  DNX
                             or DNY is negative, the image is flipped in that axis.  The type of spatial scaling
                             performed  is  determined  by the scale factors (zoom, dezoom, or no scaling).  The
                             rasterop argument is used  to  exercise  fine  control  over  how  the  mapping  is
                             performed,  e.g.  to force a refresh, implement a transient mapping, or in the case
                             of a dezoom (many-to-one) mapping, select the antialiasing technique to be used.

              <b>rwc</b>            <u>Write</u> <u>a</u> <u>colormap</u>.  Parameters are colormap number, first color and  the  number  of
                             colors followed by NC colors triples in the data.

              <b>rrc</b>            <u>Return</u>  <u>the</u>  <u>color</u>  <u>assignments</u> <u>for</u> <u>a</u> <u>region</u> <u>of</u> <u>the</u> <u>named</u> <u>colormap</u>.  Parameters are
                             colormap number, first color and the number of colors followed by NC colors triples
                             in the data.

              <b>rlc</b>            <u>Load</u> <u>a</u> <u>colormap</u> <u>into</u> <u>the</u> <u>display</u>, optionally scaling  the  colormap  via  a  linear
                             transformation  in  the  process.   Parameters  are the colormap number, the offset
                             value, and the cursor x and Y coordinates in NDC units.  The colormap is unaffected
                             if offset=0.5, scale=1.0.  A negative scale inverts the image.  If map=0 the linear
                             transformation is applied directly to the display colormap.

              <b>rfc</b>            <u>Free</u> <u>a</u> <u>colormap</u>.  Parameter is the colormap number.

              <b>rwo</b>            <u>Write</u> <u>the</u> <u>IOmap</u>. Parameters are the first color and the number of colors,  followed
                             by  NC  color  triples  in  the data.  An iomap is an optional lookup table used to
                             isolate the client application from the color model used within the  Gterm  widget.
                             To  simplify  color allocation the Gterm widget defines a logical color space where
                             color 0 is the background, 1 the foreground, 2-N are statically allocated  standard
                             colors,  and  colors  N+1  and  above  are  dynamically  allocated  by the graphics
                             application.  Less-demanding applications use only the statically allocated, shared
                             colors.  The widget internally maps these logical colors  to  whatever  the  window
                             system  requires,  but  providing  a  well-defined logical color space isolates the
                             client from the details of color allocation in the underlying window system.

                             An iomap can be used to define a mapping between the  color  model  of  the  client
                             application  and  the Gterm color model (when we say color model here we mean color
                             allocation schemes for 8 bit pseudocolor).  By default  the  iomap  is  one-to-one.
                             The  use  of  an  iomap  frees  the  client  from having to worry about color index
                             translations, and allows color tables to be combined  in  the  widget  for  greater
                             efficiency  when color tables are serially applied.  The iomap applies to all color
                             indices or pixel values passed in i/o operations between the client and  the  Gterm
                             widget.

              <b>rro</b>            <u>Read</u>  <u>the</u>  <u>IOmap</u>.   Return  values  are  the  first color and the number of colors,
                             followed by NC color triples in the data.

              <b>rim</b>            <u>Delete</u> <u>all</u> <u>mappings</u> and initialize the mapping subsystem.

              <b>rsm</b>            <u>Define</u> <u>a</u> <u>new</u> <u>mapping</u> <u>function</u>, or modify an old one.  If a new mapping  is  defined
                             it is merely enabled, and no refreshing of the screen takes place until either some
                             mapped  data  is written to or the mapping is explicitly refreshed.  If an existing
                             mapping is modified the old and new mappings are examined and only  those  portions
                             of  the  destination  rect for which the mapping changed are updated.  This permits
                             minor changes to a mapping (e.g. moving an  edge)  without  having  to  redraw  the
                             entire  region.   Regions of the destination drawable which were previously covered
                             by the mapping but which were exposed by modifying the mapping are redrawn.

              <b>rgm</b>            <u>Return</u> <u>the</u> <u>external</u> <u>parameters</u> <u>of</u> <u>a</u> <u>mapping</u>.   Parameter  is  the  mapping  number,
                             values returned (in the string "\033[6;%d;%d %d;%d;%d;%d;%d;%d %d;%d;%d;%d;%d;%d]")
                             are  the  mapping  number, rasterop, source mapping, type, x, y, width, height, and
                             destination mapping, type, x, y, width and height.

              <b>rem</b>            <u>Enable</u> <u>a</u> <u>mapping</u>. Parameters are the mapping number and an integer flag  indicating
                             whether to refresh the mapping.

              <b>rdm</b>            <u>Disable</u>  <u>a</u>  <u>mapping</u>.  Disabling  a  mapping does not affect the mapping definition,
                             hence a disabled mapping may later be reenabled. Parameters are the mapping  number
                             and an integer flag indicating whether to erase the mapping.

              <b>rrm</b>            <u>Refresh</u> <u>a</u> <u>mapping</u>. Parameter is the mapping number.

              <b>rfm</b>            <u>Free</u> <u>a</u> <u>mapping</u>. Parameter is the mapping number.

</pre><h4><b>MORE</b> <b>ON</b> <b>IMAGING</b></h4><pre>
       The  imaging model of the Gterm widget defines the following key object or data types: <u>rasters</u>, <u>mappings</u>,
       and <u>colors</u>.

       <b>raster</b>    A raster is a MxN array of pixels.  At present pixels are 8 bits deep but hooks are built  into
                 the  widget  to  expand  this  in  the future.  Pixel values are indices into the Gterm virtual
                 colormap, with values starting at zero.  A raster may be any size.  A raster is merely  a  two-
                 dimensional  array  in the graphics server; it is not displayed unless mapped.  An exception is
                 raster zero, which is the graphics window.  Rasters are referred to by  number,  starting  with
                 zero.  Initially only raster zero exists; new rasters are created with the create raster escape
                 code  <b>rcr</b>.   Space  for  rasters  may  be  allocated either in the graphics server, or in the X
                 server.  This has implications on performance but is otherwise transparent to the  client.   By
                 default rasters are allocated in the graphics server, i.e., in the X client.

       <b>mapping</b>   A  mapping  defines  a  projection  of a rectangle of the source raster onto a rectangle of the
                 destination raster.  Mappings may be either enabled (active) or disabled.  When  a  mapping  is
                 enabled,  any  change  to a pixel in the source rect will cause the corresponding pixels in the
                 destination rect to be updated.   Mappings  are  referred  to  by  number  starting  with  one.
                 Initially  no  mappings  are defined.  If the size of the input and output rect is not the same
                 the input rect will be scaled by pixel replication or subsampling to fill the output rect.   If
                 the  argument  DW  (destination  width)  or  DH (destination height) of the destination rect is
                 negative, the image  will  be  flipped  around  the  corresponding  axis  when  copied  to  the
                 destination;  the  region  of  the destination drawn into is the same in either case.  Multiple
                 mappings may reference the same source or destination raster.  Mappings are refreshed in  order
                 by  the mapping number.  Modifying a mapping causes the changed regions of the destination rect
                 to be refreshed.

       <b>color</b>     The <u>Gterm</u> widget provides a fixed number of preassigned colors corresponding to pixel values  0
                 through  9.  Zero  is the background color, one is the foreground color, and 2-9 (8 colors) are
                 arbitrary colors defined by Gterm widget resources.  These static colors are normally  used  to
                 draw  the background, frame, axes, titles, etc. of a plot, or to draw color graphics within the
                 drawing area.  The advantage of static colors is that they are shared with other X clients, and
                 the values of these colors may be assigned by the user to personalize the way plots look.

                 The <u>Gterm</u> widget also allows any number (up to about 200 or so) additional colors to be defined
                 at runtime by the client application.  These color values start at pixel value 10 and go up  to
                 the  maximum  pixel value assigned by the client.  The client application allocates colors with
                 the write colormap escape code <b>rwc</b>.  Attempts to overwrite the values of the static colors  are
                 ignored.   The  values  of already allocated colors may be changed dynamically at runtime using
                 write colormap code to write the desired range of color values.

                 Applications should not assume that there are 10  static  colors  and  200  or  so  allocatable
                 colors.   The  IRAF  graphcap  entry  for  the logical device in use, and resources set for the
                 widget, defines these parameters for the device.  Alternatively, the read colormap code may  be
                 used  to dynamically determine how many colors the server has preallocated when the application
                 starts up.

                 An image may use either static and dynamic pixel values or both types of values,  but  in  most
                 cases  imaging  applications  involve  smoothly  shaded surfaces hence will require dynamically
                 assigned private colors.

                 If for some reason the client application cannot use the <u>Gterm</u> widget color  model,  the  IOMAP
                 feature  can  be  used  to make the widget appear to have some externally defined (i.e., client
                 defined) color model.

       The maximum number of rasters and maximum number of mappings is defined by  the  Gterm  widget  resources
       <u>maxRaster</u>  and  <u>maxMappings</u>  (or  in  the GUI file) when the graphics application starts up.  The maximum
       values should be much larger than most applications require.   Applications  should  allocate  raster  or
       mapping  numbers  sequentially  starting  at  1  (more or less) to avoid running out of raster or mapping
       descriptors.

       The {read|write}pixels escape codes operate directly on raster pixels.  The mapping escape codes  support
       two  alternative  coordinate systems, raster pixels and NDC (normalized device coordinates), as indicated
       by the ST or DT argument (source or destination coordinate type).  Note that  the  origin  of  the  pixel
       coordinate system is the upper left corner of the display window (consistent with most graphics systems),
       whereas the origin of the NDC coordinate system is the lower left corner (consistent with IRAF).

       Pixel  coordinates  allow precise control of imaging but require the application to know the window size,
       and may result in complications e.g. if the window is resized.  NDC  coordinates  pretty  much  guarantee
       that  a  mapping  will involve sampling, hence are not the most efficient, but the graphics will be drawn
       correctly no matter how the window is resized and for most applications  the  performance  difference  is
       negligible.   Most  applications  should use NDC coordinates for raster 0 (the display window), and pixel
       coordinates for rasters 1-N.

       Although the size of rasters 1 and higher are defined by the client application, the size of raster zero,
       the actual gterm display window, is subject to the constraints of the  window  system.   The  client  can
       attempt to reset the size of the gterm window using create raster escape with raster=0, however the Gterm
       widget,  UI containing the <u>Gterm</u> widget, and the window manager are all free to deny such a request.  The
       query raster escape should be called to determine the actual size of the window one will be drawing into.

   <b>AN</b> <b>EXAMPLE</b> <b>IMAGING</b> <b>APPLICATION</b>
       An example of a simple imaging application might be one that downloads an image and displays  it  in  the
       gterm  window,  filling  the  window.  This could be done as follows (following a graphics open and other
       escape codes to prepare the drawing surface).

       <u>create</u> <u>raster</u>  Create raster 1 the size of the pixel array to be displayed. This need not be the same  as
                      the size of the gterm display window.

       <u>set</u> <u>mapping</u>    Define  a mapping between raster 1 and raster 0, the display window, using NDC coordinates
                      to define the region of the display window to be filled.  The mapping number is  arbitrary
                      but  mappings  should  normally be allocated starting with 1. The mapping is automatically
                      enabled when first defined.

       <u>write</u> <u>colormap</u> (Optional).  Define the pixel value to RGB color assignments for the image pixels.

       <u>write</u> <u>pixels</u>   This escape is called one or more times to write pixels into raster 1.  At most 32K pixels
                      can be written in each call.  As each write is made the affected  region  of  the  display
                      window will be updated.

       Alternatively,  one  could  write  the pixels and then define the mapping to cause the entire image to be
       displayed at once.

       Note that the imaging escape can be combined with normal graphics to draw text and graphics around or  on
       top of an image region.  The order in which drawing operations occur is important, e.g., to draw graphics
       or text on top of an image the image should be drawn first.

</pre><h4><b>MARKERS</b></h4><pre>
       Markers  are  a general feature of the <u>Gterm</u> widget and are used more extensively in other programs (e.g.
       the prototype IRAF science GUI applications), but they have no real use in <u>xgterm</u> when used as  simply  a
       graphics terminal. All markers share some of the same characteristics, so it is worthwhile learning basic
       marker  manipulation  keystrokes  (as  defined  using the default marker translations), especially how to
       delete an accidentally created marker:

              <b>o</b>  <u>Delete</u> or <u>Backspace</u> in a marker deletes it.

              <b>o</b>  MB1 anywhere inside a marker may be used to drag the marker.

              <b>o</b>  MB1 near a marker corner or edge, depending on the type of marker, resizes the marker.

              <b>o</b>  Shift-MB1 on the corner of most markers will rotate the marker.

              <b>o</b>  Markers stack, if you have several markers and you put one on top  of  the  other.  The  active
                 marker  is  highlighted  to  tell  you  which  of the stacked markers is active. If the markers
                 overlap, this will be marker "on top" in the stacking order.

              <b>o</b>  MB2 in the body of a marker "lowers" the marker, i.e. moves it to the bottom  of  the  stacking
                 order.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <u>XGterm</u>  sets  the  environment  variables  ``TERM'' and ``TERMCAP'' properly for the size window you have
       created.  It also uses and sets the environment variable ``DISPLAY'' to specify  which  bit  map  display
       terminal  to  use.   The environment variable ``WINDOWID'' is set to the X window id number of the <u>xgterm</u>
       window.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/xterm.1.html">xterm</a>(1), <a href="../man1/resize.1.html">resize</a>(1), <a href="../man1/X.1.html">X</a>(1), <a href="../man4/pty.4.html">pty</a>(4), <a href="../man4/tty.4.html">tty</a>(4)
       <u>Xterm</u> <u>Control</u> <u>Sequences</u> (in the <u>xterm</u> source directory)

</pre><h4><b>BUGS</b></h4><pre>
       Many of the same bugs affecting <u>xterm</u> also apply here.

       <u>Xgterm</u> is not normally installed with setuid permissions.  On some Linux systems, for example, where  the
       /dev/tty  and  /dev/pty  devices  have  root  ownership  and  permission  600  this  can  cause problems.
       Workarounds are to either install <u>XGterm</u> with setuid permissions or  modify  the  /dev/tty  and  /dev/pty
       devices to have permission 666.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright(c) 1986 Association of Universities for Research in Astronomy Inc.

X11IRAF Project                                    16 Dec 1996                                         <u><a href="../man1/XGTERM.1.html">XGTERM</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>