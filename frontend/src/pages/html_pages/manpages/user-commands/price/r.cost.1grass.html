<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>r.cost   -  Creates  a  raster  map  showing  the  cumulative cost of moving between different geographic</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>r.cost</b>   -  Creates  a  raster  map  showing  the  cumulative cost of moving between different geographic
       locations on an input raster map whose cell category values represent cost.

</pre><h4><b>KEYWORDS</b></h4><pre>
       raster, cost surface, cumulative costs, cost allocation

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>r.cost</b>
       <b>r.cost</b> <b>--help</b>
       <b>r.cost</b>    [-<b>knrib</b>]    <b>input</b>=<u>name</u>    <b>output</b>=<u>name</u>     [<b>solver</b>=<u>name</u>]      [<b>nearest</b>=<u>name</u>]       [<b>outdir</b>=<u>name</u>]
       [<b>start_points</b>=<u>name</u>]                         [<b>stop_points</b>=<u>name</u>]                        [<b>start_raster</b>=<u>name</u>]
       [<b>start_coordinates</b>=<u>east,north</u>[,<u>east,north</u>,...]]            [<b>stop_coordinates</b>=<u>east,north</u>[,<u>east,north</u>,...]]
       [<b>max_cost</b>=<u>value</u>]    [<b>null_cost</b>=<u>value</u>]    [<b>memory</b>=<u>memory</u>  <u>in</u>  <u>MB</u>]    [--<b>overwrite</b>]   [--<b>help</b>]  [--<b>verbose</b>]
       [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-k</b>
           Use the ’Knight’s move’; slower, but more accurate

       <b>-n</b>
           Keep null values in output raster map

       <b>-r</b>
           Start with values in raster map

       <b>-i</b>
           Print info about disk space and memory requirements and exit

       <b>-b</b>
           Create bitmask encoded directions

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>input</b>=<u>name</u> <b>[required]</b>
           Name of input raster map containing grid cell cost information

       <b>output</b>=<u>name</u> <b>[required]</b>
           Name for output raster map

       <b>solver</b>=<u>name</u>
           Name of input raster map solving equal costs
           Helper variable to pick a direction if two directions have equal cumulative costs (smaller is better)

       <b>nearest</b>=<u>name</u>
           Name for output raster map with nearest start point

       <b>outdir</b>=<u>name</u>
           Name for output raster map to contain movement directions

       <b>start_points</b>=<u>name</u>
           Name of starting vector points map
           Or data source for direct OGR access

       <b>stop_points</b>=<u>name</u>
           Name of stopping vector points map
           Or data source for direct OGR access

       <b>start_raster</b>=<u>name</u>
           Name of starting raster points map

       <b>start_coordinates</b>=<u>east,north[,east,north</u>,...]
           Coordinates of starting point(s) (E,N)

       <b>stop_coordinates</b>=<u>east,north[,east,north</u>,...]
           Coordinates of stopping point(s) (E,N)

       <b>max_cost</b>=<u>value</u>
           Maximum cumulative cost
           Default: <u>0</u>

       <b>null_cost</b>=<u>value</u>
           Cost assigned to null cells. By default, null cells are excluded

       <b>memory</b>=<u>memory</u> <u>in</u> <u>MB</u>
           Maximum memory to be used (in MB)
           Cache size for raster rows
           Default: <u>300</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>r.cost</u> determines the cumulative cost of moving to each cell on a <u>cost</u> <u>surface</u>  (the  <b>input</b>  raster  map)
       from  other  user-specified cell(s) whose locations are specified by their geographic coordinate(s). Each
       cell in the original cost surface map will  contain  a  category  value  which  represents  the  cost  of
       traversing  that cell. <u>r.cost</u> will produce 1) an <b>output</b> raster map in which each cell contains the lowest
       total cost of traversing the space between each cell and the user-specified points  (diagonal  costs  are
       multiplied  by  a  factor  that  depends  on the dimensions of the cell) and 2) a second raster map layer
       showing the movement direction to the next cell on the  path  back  to  the  start  point  (see  Movement
       Direction).  This  module uses the current geographic region settings. The <b>output</b> map will be of the same
       data format as the <b>input</b> map, integer or floating point.

</pre><h4><b>OPTIONS</b></h4><pre>
       The <b>input</b> <u>name</u> is the name of a raster map whose category values represent the surface cost.  The  <b>output</b>
       <u>name</u>  is  the  name  of  the  resultant raster map of cumulative cost. The <b>outdir</b> <u>name</u> is the name of the
       resultant raster map of movement directions (see Movement Direction).

       <u>r.cost</u> can be run with three different methods of identifying the starting point(s). One or  more  points
       (geographic  coordinate pairs) can be provided as specified <b>start_coordinates</b> on the command line, from a
       vector points file, or from a raster map.  All non-NULL cells are considered to be starting points.

       Each <u>x,y</u> <b>start_coordinates</b> pair gives the geographic location of a point from  which  the  transportation
       cost  should  be figured. As many points as desired can be entered by the user. These starting points can
       also be read from a vector points file through the <b>start_points</b> option or from a raster map  through  the
       <b>start_raster</b> option.

       <u>r.cost</u>  will  stop cumulating costs when either <b>max_cost</b> is reached, or one of the stop points given with
       <b>stop_coordinates</b> is reached.  Alternatively, the stop points can be read from a vector points  file  with
       the  <b>stop_points</b>  option.  During  execution,  once  the  cumulative cost to all stopping points has been
       determined, processing stops.
       Both sites read from a vector points file and those given on the command line will be processed.

       The null cells in the <b>input</b> map can be assigned a (positive  floating  point)  cost  with  the  <b>null_cost</b>
       option.
       When  input  map  null  cells  are given a cost with the <b>null_cost</b> option, the corresponding cells in the
       output map are no longer null cells. By using the <b>-n</b> flag, the null cells of the input map  are  retained
       as null cells in the output map.

       As <u>r.cost</u> can run for a very long time, it can be useful to use the <b>--v</b> verbose flag to track progress.

       The  Knight’s move (<b>-k</b> flag) may be used to improve the accuracy of the output. In the diagram below, the
       center location (O) represents a  grid  cell  from  which  cumulative  distances  are  calculated.  Those
       neighbors  marked  with  an  X are always considered for cumulative cost updates. With the <b>-k</b> option, the
       neighbors marked with a K are also considered.
        . . . . . . . . . . . . . . .
        .   .   . K .   . K .   .   .
        . . . . . . . . . . . . . . .
        .   . K . X . X . X . K .   .
        . . . . . . . . . . . . . . .
        .   .   . X . O . X .   .   .
        . . . . . . . . . . . . . . .
        .   . K . X . X . X . K .   .
        . . . . . . . . . . . . . . .
        .   .   . K .   . K .   .   .
        . . . . . . . . . . . . . . .

       Knight’s move example:
       <u>Flat</u> <u>cost</u> <u>surface</u> <u>without</u> <u>(left</u> <u>pane)</u> <u>and</u> <u>with</u> <u>the</u>  <u>knight’s</u>
       <u>move</u> <u>(right</u> <u>pane).</u>  <u>The</u> <u>default</u> <u>is</u> <u>to</u> <u>grow</u> <u>the</u> <u>cost</u> <u>outwards</u>
       <u>in</u>  <u>8</u> <u>directions.</u>  <u>Using</u> <u>the</u> <u>knight’s</u> <u>move</u> <u>grows</u> <u>it</u> <u>outwards</u>
       <u>in</u> <u>16</u> <u>directions.</u>

       If the <b>nearest</b> output parameter is specified, the  module  will  calculate  for  each  cell  its  nearest
       starting point based on the minimized accumulative cost while moving over the cost map.

       The <b>solver</b> option helps to select a particular direction in case of multiple directions with equal costs.
       Sometimes  fields with equal cumulative costs exist and multiple paths with equal costs would lead from a
       start point to a stop point. By default, a path along the edge of such  a  field  would  be  produced  or
       multiple  paths  of  equal costs with the <b>-b</b> flag. An additional variable can be supplied with the <b>solver</b>
       option to help the algorithm pick a particular direction.

       Example for solving multiple directions:
       <u>A</u> <u>field</u>  <u>of</u>  <u>equal</u>  <u>cumulative</u>  <u>costs</u>  <u>with</u>  <u>multiple</u>  <u>paths</u>
       <u>(black).</u>  <u>By</u>  <u>default</u> <u>a</u> <u>path</u> <u>along</u> <u>the</u> <u>edge</u> <u>will</u> <u>be</u> <u>selected</u>
       <u>(red).</u> <u>Path</u> <u>selection</u> <u>can</u>  <u>be</u>  <u>controlled</u>  <u>with</u>  <u>the</u>  <u>solver</u>
       <u>option</u> <u>(blue).</u>

       Multiple directions can be solved as in the above example with the following steps:

       <b>1</b>      Create multiple directions with <b>r.cost</b>/<b>r.walk</b> using the <b>-b</b> flag

       <b>2</b>      Extract paths using <b>r.path</b> <b>format=bitmask</b>

       <b>3</b>      Calculate the distance from NULL cells to paths using <b>r.grow.distance</b> <b>-n</b> <b>input=&lt;paths</b> <b>from</b> <b>r.path&gt;</b>

       <b>4</b>      Invert the sign of the distances with <b>r.mapcalc</b> because for the solver smaller is better, and here
              we want to get the center of an area with multiple directions

       <b>5</b>      Use these negative distances as solver for a second pass of <b>r.cost</b>

       <b>6</b>      Extract paths again with <b>r.path</b> to get a geometrically optimized solution

</pre><h4><b>NULL</b> <b>CELLS</b></h4><pre>
       By  default  null cells in the input raster map are excluded from the algorithm, and thus retained in the
       output map.

       If one wants <b>r.cost</b> to transparently cross any region of null cells, the <b>null_cost</b>=0.0 option  should  be
       used. Then null cells just propagate the adjacent costs. These cells can be retained as null cells in the
       output map by using the <b>-n</b> flag.

</pre><h4><b>NOTES</b></h4><pre>
       Paths  from  any  point to the nearest starting point of <u>r.cost</u> can be extracted with <u>r.path</u> by using the
       direction output map of <u>r.cost</u>.

   <b>Algorithm</b> <b>notes</b>
       The fundamental approach to calculating minimum travel cost is as follows:

       The user generates a raster map indicating the cost of  traversing  each  cell  in  the  north-south  and
       east-west  directions.   This  map,  along  with  a  set  of starting points are submitted to <u>r.cost</u>. The
       starting points are put into a heap of cells from which costs to the adjacent cells are to be calculated.
       The cell on the heap with the lowest cumulative cost is selected for computing costs to  the  neighboring
       cells. Costs are computed and those cells are put on the heap and the originating cell is finalized. This
       process  of  selecting  the  lowest  cumulative  cost cell, computing costs to the neighbors, putting the
       neighbors on the heap and removing the originating cell from the heap continues until the heap is empty.

       The most time consuming aspect of this algorithm is the  management  of  the  heap  of  cells  for  which
       cumulative  costs  have  been  at  least  initially  computed. <u>r.cost</u> uses a minimum heap for efficiently
       tracking the next cell with the lowest cumulative costs.

       <u>r.cost</u>, like most all GRASS raster programs, is also made to be run  on  maps  larger  that  can  fit  in
       available  computer  memory.  As the algorithm works through the dynamic heap of cells it can move almost
       randomly around the entire area. <u>r.cost</u> divides the entire area into a number of pieces and  swaps  these
       pieces  in  and  out  of  memory  (to  and  from disk) as needed. This provides a virtual memory approach
       optimally designed for 2-D raster maps. The amount of memory to be used by <u>r.cost</u> can be controlled  with
       the  <b>memory</b>  option,  default is 300 MB. For systems with less memory this value will have to be set to a
       lower value.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Consider the following example:
              Input:
                COST SURFACE
              . . . . . . . . . . . . . . .
              . 2 . 2 . 1 . 1 . 5 . 5 . 5 .
              . . . . . . . . . . . . . . .
              . 2 . 2 . 8 . 8 . 5 . 2 . 1 .
              . . . . . . . . . . . . . . .
              . 7 . 1 . 1 . 8 . 2 . 2 . 2 .
              . . . . . . . . . . . . . . .
              . 8 . 7 . 8 . 8 . 8 . 8 . 5 .
              . . . . . . . . . . _____ . .
              . 8 . 8 . 1 . 1 . 5 | <b>3</b> | 9 .
              . . . . . . . . . . |___| . .
              . 8 . 1 . 1 . 2 . 5 . 3 . 9 .
              . . . . . . . . . . . . . . .
       Output (using -k):                Output (not using -k):
          CUMULATIVE COST SURFACE           CUMULATIVE COST SURFACE
        . . . . . . . . . . . . . . .     . . . . <b>*</b> <b>*</b> <b>*</b> <b>*</b> <b>*</b> . . . . . .
        . 21. 21. 20. 19. 17. 15. 14.     . 22. 21<b>*</b> <b>21*</b> <b>20*</b> 17. 15. 14.
        . . . . . . . . . . . . . . .     . . . . <b>*</b> <b>*</b> <b>*</b> <b>*</b> <b>*</b> . . . . . .
        . 20. 19. 22. 19. 15. 12. 11.     . 20. 19. 22<b>*</b> <b>20*</b> 15. 12. 11.
        . . . . . . . . . . . . . . .     . . . . . . <b>*</b> <b>*</b> <b>*</b> <b>*</b> <b>*</b> . . . .
        . 22. 18. 17. 17. 12. 11.  9.     . 22. 18. 17<b>*</b> <b>18*</b> <b>13*</b> 11.  9.
        . . . . . . . . . . . . . . .     . . . . . . <b>*</b> <b>*</b> <b>*</b> <b>*</b> <b>*</b> . . . .
        . 21. 14. 13. 12.  8.  6.  6.     . 21. 14. 13. 12.  8.  6.  6.
        . . . . . . . . . .  _____. .     . . . . . . . . . . . . . . .
        . 16. 13.  8.  7.  4 | <b>0</b> | 6.     . 16. 13.  8. 7 .  4.  0.  6.
        . . . . . . . . . .  |___|. .     . . . . . . . . . . . . . . .
        . 14.  9.  8.  9.  6.  3.  8.     . 14.  9.  8. 9 .  6.  3.  8.
        . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . .

       The user-provided starting location in the above example is the boxed <b>3</b> in the above input map. The costs
       in the output map represent the total cost of moving from each box ("cell") to one or  more  (here,  only
       one)  starting location(s). Cells surrounded by asterisks are those that are different between operations
       using and not using the Knight’s move (<b>-k</b>) option.

   <b>Output</b> <b>analysis</b>
       The output map can be viewed, for example, as an elevation model in which the starting location(s) is/are
       the lowest point(s). Outputs from <u>r.cost</u> can be used as  inputs  to  <u>r.path</u>  ,  in  order  to  trace  the
       least-cost  path  given by this model between any given cell and the <u>r.cost</u> starting location(s). The two
       programs, when used together, generate least-cost paths  or  corridors  between  any  two  map  locations
       (cells).

   <b>Shortest</b> <b>distance</b> <b>surfaces</b>
       The  <u>r.cost</u>  module  allows  for computing the shortest distance of each pixel from raster lines, such as
       determining the shortest distances of households to the nearby road. For this  cost  surfaces  with  cost
       value 1 are used. The calculation is done with <u>r.cost</u> as follows (example for Spearfish region):
         g.region raster=roads -p
         r.mapcalc "area.one = 1"
         r.cost -k input=area.one output=distance start_raster=roads
         d.rast distance
         d.rast.num distance
         #transform to metric distance from cell distance using the raster resolution:
         r.mapcalc "dist_meters = distance * (ewres()+nsres())/2."
         d.rast dist_meters

</pre><h4><b>Movement</b> <b>Direction</b></h4><pre>
       The  movement  direction  surface  is  created  to record the sequence of movements that created the cost
       accumulation surface. This movement direction surface can be used by <u>r.path</u> to recover a path from an end
       point back to the start point.  The direction of each cell points towards the next cell.  The  directions
       are recorded as degrees CCW from East:
              112.5      67.5         i.e. a cell with the value 135
       157.5  135   90   45   22.5    means the next cell is to the north-west
              180   x   360
       202.5  225  270  315  337.5
              247.5     292.5

   <b>Cost</b> <b>allocation</b>
       Example:  calculation  of  the cost allocation map "costalloc" and the cumulative cost map "costsurf" for
       given starting points (map "sources") and given cost raster map "costs":
       r.cost input=costs start_raster=sources output=costsurf nearest=costalloc

   <b>Find</b> <b>the</b> <b>minimum</b> <b>cost</b> <b>path</b>
       Once <u>r.cost</u> computes the cumulative cost map and an associated movement direction map, <u>r.path</u> can be used
       to find the minimum cost path.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>r.walk,</u> <u>r.path,</u> <u>r.in.ascii,</u> <u>r.mapcalc,</u> <u>r.out.ascii</u>

</pre><h4><b>AUTHORS</b></h4><pre>
       Antony Awaida, Intelligent Engineering Systems Laboratory, M.I.T.
       James Westervelt, U.S.Army Construction Engineering Research Laboratory
       Updated for Grass 5 by Pierre de Mouveaux (<a href="mailto:pmx@audiovu.com">pmx@audiovu.com</a>)
       Markus Metz
       Multiple path directions sponsored by mundialis

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: r.cost source code (history)

       Accessed: Friday Apr 04 01:19:04 2025

       Main index | Raster index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                       <u><a href="../man1grass/r.cost.1grass.html">r.cost</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>