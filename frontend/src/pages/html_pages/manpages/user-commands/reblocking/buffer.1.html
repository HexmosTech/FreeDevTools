<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>buffer - very fast reblocking program</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/buffer">buffer_1.19-12.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       buffer - very fast reblocking program

</pre><h4><b>SYNTAX</b></h4><pre>
       <b>buffer</b>  [<b>-S</b>  <b>size</b>]  [<b>-b</b> <b>blocks</b>] [<b>-s</b> <b>size</b>] [<b>-z</b> <b>size</b>] [<b>-m</b> <b>size</b>] [<b>-p</b> <b>percentage</b>] [<b>-u</b> <b>microseconds</b>] [<b>-B</b>] [<b>-t</b>]
       [<b>-Z</b>] [<b>-i</b> <b>filename</b>] [<b>-o</b> <b>filename</b>] [<b>-d</b>]

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-i</b> <b>filename</b>
            Use the given file as the input file.  The default is stdin.

       <b>-o</b> <b>filename</b>
            Use the given file as the output file.  The default is stdout.

       <b>-S</b> <b>size</b>
            After every chunk of this size has been written, print out how much has been written  so  far.  Also
            prints the total throughput.  By default this is not set.

       <b>-s</b> <b>size</b>
            Size  in bytes of each block.  The default blocksize is 10k to match the normal output of the <u><a href="../man1/tar.1.html">tar</a>(1)</u>
            program.

       <b>-z</b> <b>size</b>
            Combines the <b>-S</b> and <b>-s</b> flags.

       <b>-b</b> <b>blocks</b>
            Number of blocks to allocate to shared memory circular buffer.  Defaults to the number  required  to
            fill up the shared memory requested.

       <b>-m</b> <b>size</b>
            Maximum  size  of  the  shared  memory  chunk  to  allocate  for the circular queue. Defaults to one
            megabyte.

       <b>-p</b> <b>percentage</b>
            Only start a write when the given percentage of the internal queue is full.  A percentage around  75
            often proves best. Defaults to zero.

       <b>-u</b> <b>microseconds</b>
            After every write pause for this many microseconds.  Defaults to zero.  (Surprisingly a small sleep,
            100 usecs, after each write can greatly enhance throughput on some drives.)

       <b>-B</b>   Force  each  block  written  to  be  padded  out  to the blocksize.  This is needed by some tape and
            cartridge drives.  Defaults to unpadded.  This only affects the last block written.

       <b>-t</b>   On exiting print to stderr a brief message showing the total number of bytes written.

       <b>-Z</b>   If reading/writing directly to a character device (like a  tape  drive)  then  after  each  gigabyte
            perform an lseek to the start of the file.  Use this flag with extreme care.  It can only be used on
            devices  where  an  lseek does not rewind the tape but does reset the kernels position flags.  It is
            used to allow more than 2 gigabytes to be written.

       <b>-d</b>   Print debug information to stderr during operation.

       Sizes are a number with an optional trailing character.   A 'b' multiplies the size by 512, a 'k' by 1024
       and an 'm' by a meg.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Buffer</u> reads from standard input reblocking to the given blocksize and  writes  each  block  to  standard
       output.

       Internally  <u>buffer</u> is a pair of processes communicating via a large circular queue held in shared memory.
       The reader process only has to block when the queue is full and the writer  process  when  the  queue  is
       empty.   <u>Buffer</u>  is designed to try and keep the writer side continuously busy so that it can stream when
       writing to tape drives.  When used to write tapes with an intervening network  <u>buffer</u>  can  result  in  a
       considerable increase in throughput.

       The  default settings for <u>buffer</u> are normally good enough.  If you are a heavy tape user then it is worth
       your while trying out various different combinations of options.  In particular running a <u>buffer</u> at  both
       ends of the pipe can provide a substantial increase (see last example below).

</pre><h4><b>EXAMPLES</b></h4><pre>
       $ <b>buffer</b> <b>&lt;</b> <b>/etc/termcap</b> <b>&gt;</b> <b>/dev/rst8</b>

       $ <b>tar</b> <b>cf</b> <b>-</b> <b>.</b> <b>|</b> <b>rsh</b> <b>somehost</b> <b>'buffer</b> <b>&gt;</b> <b>/dev/rst8'</b>

       $ <b>dump</b> <b>fu</b> <b>-</b> <b>|</b> <b>rsh</b> <b>somehost</b> <b>'buffer</b> <b>-s</b> <b>16k</b> <b>&gt;</b> <b>/dev/nrst8'</b>
       $ <b>tar</b> <b>cf</b> <b>-</b> <b>.</b> <b>|</b> <b>buffer</b> <b>|</b>
          <b>rsh</b> <b>somehost</b> <b>'buffer</b> <b>-S</b> <b>500K</b> <b>-p</b> <b>75</b> <b>&gt;</b> <b>/dev/rst0'</b>

</pre><h4><b>BUFFER</b> <b>LIMITS</b></h4><pre>
       There are 2 limits in <u>buffer</u> affecting the maximum total buffer size: The maximum number of blocks (2048)
       and the maximum size of a block (512kB). This results in a maximum total buffer size of 1GB.

       Note  that  there  is also a kernel limit for the maximum size of a shared memory segment (used by <u>buffer</u>
       internally) which is typically much lower than the limits in <u>buffer</u>.  So if <u>buffer</u>  complains  about  not
       being able to create a shared memory segment, this limit might have to be raised using the command <b>sysctl</b>
       <b>kernel.shmmax=</b><u>XXX</u> (see also <a href="../man1/sysctl.1.html">sysctl</a>(1) and <a href="../man5/proc.5.html">proc</a>(5)).

</pre><h4><b>BUGS</b></h4><pre>
       Internally,  for  printing  purposes,  buffer  counts in terms of the number of kilobytes output.  If the
       blocksize you use is not a whole number of kilobytes then the numbers printed will be inaccurate.

</pre><h4><b>THANKS</b></h4><pre>
       Thanks to Kevin Twidle &lt;<a href="mailto:kpt@doc.ic.ac.uk">kpt@doc.ic.ac.uk</a>&gt; for a lot of early suggestions and patches to make it work with
       non-tar/dump tapes to exabyte drives.

       Thanks to Andi  Karrer  &lt;<a href="mailto:karrer@bernina.ethz.ch">karrer@bernina.ethz.ch</a>&gt;,  Rumi  Zahir  &lt;<a href="mailto:rumi@iis.ethz.ch">rumi@iis.ethz.ch</a>&gt;  and  Christoph  Wicki
       &lt;<a href="mailto:wicki@iis.ethz.ch">wicki@iis.ethz.ch</a>&gt;  for  patches  to  make buffer work when trying to write single tape files of greater
       than 2 gigabytes.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 1990, 1991 by Lee McLoughlin.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/dd.1.html">dd</a>(1), <a href="../man1/tar.1.html">tar</a>(1), <a href="../man1/rsh.1.html">rsh</a>(1)

                                                   14 May 1990                                         <u><a href="../man1/BUFFER.1.html">BUFFER</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>