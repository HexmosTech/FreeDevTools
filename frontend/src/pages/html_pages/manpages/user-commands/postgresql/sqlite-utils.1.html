<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sqlite-utils - sqlite-utils documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/sqlite-utils">sqlite-utils_3.38-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sqlite-utils - sqlite-utils documentation

</pre><h4><b>CLI</b> <b>TOOL</b> <b>AND</b> <b>PYTHON</b> <b>LIBRARY</b> <b>FOR</b> <b>MANIPULATING</b> <b>SQLITE</b> <b>DATABASES</b></h4><pre>
       This library and command-line utility helps create SQLite databases from an existing collection of data.

       Most  of  the  functionality is available as either a Python API or through the <b>sqlite-utils</b> command-line
       tool.

       sqlite-utils is not intended to be a full ORM: the focus is utility helpers to make creating the  initial
       database and populating it with data as productive as possible.

       It is designed as a useful complement to <u>Datasette</u>.

       <u>Cleaning</u>  <u>data</u>  <u>with</u>  <u>sqlite-utils</u>  <u>and</u>  <u>Datasette</u> provides a tutorial introduction (and accompanying ten
       minute video) about using this tool.

   <b>Contents</b>
   <b>Installation</b>
       <b>sqlite-utils</b> is tested on Linux, macOS and Windows.

   <b>Using</b> <b>Homebrew</b>
       The <u>sqlite-utils</u> <u>command-line</u> <u>tool</u> can be installed on macOS using Homebrew:

          brew install sqlite-utils

       If you have it installed and want to upgrade to the most recent release, you can run:

          brew upgrade sqlite-utils

       Then run <b>sqlite-utils</b> <b>--version</b> to confirm the installed version.

   <b>Using</b> <b>pip</b>
       The <u>sqlite-utils</u> <u>package</u> on PyPI includes both the  <u>sqlite_utils</u>  <u>Python</u>  <u>library</u>  and  the  <b>sqlite-utils</b>
       command-line tool. You can install them using <b>pip</b> like so:

          pip install sqlite-utils

   <b>Using</b> <b>pipx</b>
       <u>pipx</u>  is  a  tool for installing Python command-line applications in their own isolated environments. You
       can use <b>pipx</b> to install the <b>sqlite-utils</b> command-line tool like this:

          pipx install sqlite-utils

   <b>Alternatives</b> <b>to</b> <b>sqlite3</b>
       By default, <b>sqlite-utils</b> uses the <b>sqlite3</b> package bundled with the Python standard library.

       Depending on your operating system, this may come with some limitations.

       On  some  platforms  the  ability  to  load  additional  extensions  (via   <b>conn.load_extension(...)</b>   or
       <b>--load-extension=/path/to/extension</b>) may be disabled.

       You  may also see the error <b>sqlite3.OperationalError:</b> <b>table</b> <b>sqlite_master</b> <b>may</b> <b>not</b> <b>be</b> <b>modified</b> when trying
       to alter an existing table.

       You can work around these limitations by  installing  either  the  <u>pysqlite3</u>  package  or  the  <u>sqlean.py</u>
       package,  both  of  which provide drop-in replacements for the standard library <b>sqlite3</b> module but with a
       recent version of SQLite and full support for loading extensions.

       To install <b>sqlean.py</b> (which has compiled binary  wheels  available  for  all  major  platforms)  run  the
       following:

          sqlite-utils install sqlean.py

       <b>pysqlite3</b> and <b>sqlean.py</b> do not provide implementations of the <b>.iterdump()</b> method. To use that method (see
       <u>Dumping</u>  <u>the</u>  <u>database</u>  <u>to</u>  <u>SQL</u>) or the <b>sqlite-utils</b> <b>dump</b> command you should also install the <b>sqlite-dump</b>
       package:

          sqlite-utils install sqlite-dump

   <b>Setting</b> <b>up</b> <b>shell</b> <b>completion</b>
       You can configure shell tab completion for the <b>sqlite-utils</b> command using these commands.

       For <b>bash</b>:

          eval "$(_SQLITE_UTILS_COMPLETE=bash_source sqlite-utils)"

       For <b>zsh</b>:

          eval "$(_SQLITE_UTILS_COMPLETE=zsh_source sqlite-utils)"

       Add this code to <b><a href="file:~/.zshrc">~/.zshrc</a></b> or <b><a href="file:~/.bashrc">~/.bashrc</a></b> to automatically run it when you start a new shell.

       See <u>the</u> <u>Click</u> <u>documentation</u> for more details.

   <b>sqlite-utils</b> <b>command-line</b> <b>tool</b>
       The <b>sqlite-utils</b> command-line tool can be used to manipulate SQLite databases in a  number  of  different
       ways.

       Once  <u>installed</u>  the  tool  should  be  available  as  <b>sqlite-utils</b>.  It  can also be run using <b>python</b> <b>-m</b>
       <b>sqlite_utils</b>.

       • <u>Running</u> <u>SQL</u> <u>queries</u>

         • <u>Returning</u> <u>JSON</u>

           • <u>Newline-delimited</u> <u>JSON</u>

           • <u>JSON</u> <u>arrays</u>

           • <u>Binary</u> <u>data</u> <u>in</u> <u>JSON</u>

           • <u>Nested</u> <u>JSON</u> <u>values</u>

         • <u>Returning</u> <u>CSV</u> <u>or</u> <u>TSV</u>

         • <u>Table-formatted</u> <u>output</u>

         • <u>Returning</u> <u>raw</u> <u>data,</u> <u>such</u> <u>as</u> <u>binary</u> <u>content</u>

         • <u>Using</u> <u>named</u> <u>parameters</u>

         • <u>UPDATE,</u> <u>INSERT</u> <u>and</u> <u>DELETE</u>

         • <u>Defining</u> <u>custom</u> <u>SQL</u> <u>functions</u>

         • <u>SQLite</u> <u>extensions</u>

         • <u>Attaching</u> <u>additional</u> <u>databases</u>

       • <u>Querying</u> <u>data</u> <u>directly</u> <u>using</u> <u>an</u> <u>in-memory</u> <u>database</u>

         • <u>Running</u> <u>queries</u> <u>directly</u> <u>against</u> <u>CSV</u> <u>or</u> <u>JSON</u>

         • <u>Explicitly</u> <u>specifying</u> <u>the</u> <u>format</u>

         • <u>Joining</u> <u>in-memory</u> <u>data</u> <u>against</u> <u>existing</u> <u>databases</u> <u>using</u> <u>--attach</u>

         • <u>--schema,</u> <u>--analyze,</u> <u>--dump</u> <u>and</u> <u>--save</u>

       • <u>Returning</u> <u>all</u> <u>rows</u> <u>in</u> <u>a</u> <u>table</u>

       • <u>Listing</u> <u>tables</u>

       • <u>Listing</u> <u>views</u>

       • <u>Listing</u> <u>indexes</u>

       • <u>Listing</u> <u>triggers</u>

       • <u>Showing</u> <u>the</u> <u>schema</u>

       • <u>Analyzing</u> <u>tables</u>

         • <u>Saving</u> <u>the</u> <u>analyzed</u> <u>table</u> <u>details</u>

       • <u>Creating</u> <u>an</u> <u>empty</u> <u>database</u>

       • <u>Inserting</u> <u>JSON</u> <u>data</u>

         • <u>Inserting</u> <u>binary</u> <u>data</u>

         • <u>Inserting</u> <u>newline-delimited</u> <u>JSON</u>

         • <u>Flattening</u> <u>nested</u> <u>JSON</u> <u>objects</u>

       • <u>Inserting</u> <u>CSV</u> <u>or</u> <u>TSV</u> <u>data</u>

         • <u>Alternative</u> <u>delimiters</u> <u>and</u> <u>quote</u> <u>characters</u>

         • <u>CSV</u> <u>files</u> <u>without</u> <u>a</u> <u>header</u> <u>row</u>

       • <u>Inserting</u> <u>unstructured</u> <u>data</u> <u>with</u> <u>--lines</u> <u>and</u> <u>--text</u>

       • <u>Applying</u> <u>conversions</u> <u>while</u> <u>inserting</u> <u>data</u>

         • <u>--convert</u> <u>with</u> <u>--lines</u>

         • <u>--convert</u> <u>with</u> <u>--text</u>

       • <u>Insert-replacing</u> <u>data</u>

       • <u>Upserting</u> <u>data</u>

       • <u>Executing</u> <u>SQL</u> <u>in</u> <u>bulk</u>

       • <u>Inserting</u> <u>data</u> <u>from</u> <u>files</u>

       • <u>Converting</u> <u>data</u> <u>in</u> <u>columns</u>

         • <u>Importing</u> <u>additional</u> <u>modules</u>

         • <u>Using</u> <u>the</u> <u>debugger</u>

         • <u>Defining</u> <u>a</u> <u>convert()</u> <u>function</u>

         • <u>sqlite-utils</u> <u>convert</u> <u>recipes</u>

         • <u>Saving</u> <u>the</u> <u>result</u> <u>to</u> <u>a</u> <u>different</u> <u>column</u>

         • <u>Converting</u> <u>a</u> <u>column</u> <u>into</u> <u>multiple</u> <u>columns</u>

       • <u>Creating</u> <u>tables</u>

       • <u>Renaming</u> <u>a</u> <u>table</u>

       • <u>Duplicating</u> <u>tables</u>

       • <u>Dropping</u> <u>tables</u>

       • <u>Transforming</u> <u>tables</u>

         • <u>Adding</u> <u>a</u> <u>primary</u> <u>key</u> <u>to</u> <u>a</u> <u>rowid</u> <u>table</u>

       • <u>Extracting</u> <u>columns</u> <u>into</u> <u>a</u> <u>separate</u> <u>table</u>

       • <u>Creating</u> <u>views</u>

       • <u>Dropping</u> <u>views</u>

       • <u>Adding</u> <u>columns</u>

       • <u>Adding</u> <u>columns</u> <u>automatically</u> <u>on</u> <u>insert/update</u>

       • <u>Adding</u> <u>foreign</u> <u>key</u> <u>constraints</u>

         • <u>Adding</u> <u>multiple</u> <u>foreign</u> <u>keys</u> <u>at</u> <u>once</u>

         • <u>Adding</u> <u>indexes</u> <u>for</u> <u>all</u> <u>foreign</u> <u>keys</u>

       • <u>Setting</u> <u>defaults</u> <u>and</u> <u>not</u> <u>null</u> <u>constraints</u>

       • <u>Creating</u> <u>indexes</u>

       • <u>Configuring</u> <u>full-text</u> <u>search</u>

       • <u>Executing</u> <u>searches</u>

       • <u>Enabling</u> <u>cached</u> <u>counts</u>

       • <u>Optimizing</u> <u>index</u> <u>usage</u> <u>with</u> <u>ANALYZE</u>

       • <u>Vacuum</u>

       • <u>Optimize</u>

       • <u>WAL</u> <u>mode</u>

       • <u>Dumping</u> <u>the</u> <u>database</u> <u>to</u> <u>SQL</u>

       • <u>Loading</u> <u>SQLite</u> <u>extensions</u>

       • <u>SpatiaLite</u> <u>helpers</u>

         • <u>Adding</u> <u>spatial</u> <u>indexes</u>

       • <u>Installing</u> <u>packages</u>

       • <u>Uninstalling</u> <u>packages</u>

       • <u>Experimental</u> <u>TUI</u>

   <b>Running</b> <b>SQL</b> <b>queries</b>
       The <b>sqlite-utils</b> <b>query</b> command lets you run queries directly against a SQLite database file. This is  the
       default subcommand, so the following two examples work the same way:

          sqlite-utils query dogs.db "select * from dogs"

          sqlite-utils dogs.db "select * from dogs"

       <b>NOTE:</b>
          In Python: <u>db.query()</u>  CLI reference: <u>sqlite-utils</u> <u>query</u>

   <b>Returning</b> <b>JSON</b>
       The default format returned for queries is JSON:

          sqlite-utils dogs.db "select * from dogs"

          [{"id": 1, "age": 4, "name": "Cleo"},
           {"id": 2, "age": 2, "name": "Pancakes"}]

   <b>Newline-delimited</b> <b>JSON</b>
       Use <b>--nl</b> to get back newline-delimited JSON objects:

          sqlite-utils dogs.db "select * from dogs" --nl

          {"id": 1, "age": 4, "name": "Cleo"}
          {"id": 2, "age": 2, "name": "Pancakes"}

   <b>JSON</b> <b>arrays</b>
       You can use <b>--arrays</b> to request arrays instead of objects:

          sqlite-utils dogs.db "select * from dogs" --arrays

          [[1, 4, "Cleo"],
           [2, 2, "Pancakes"]]

       You can also combine <b>--arrays</b> and <b>--nl</b>:

          sqlite-utils dogs.db "select * from dogs" --arrays --nl

          [1, 4, "Cleo"]
          [2, 2, "Pancakes"]

       If you want to pretty-print the output further, you can pipe it through <b>python</b> <b>-mjson.tool</b>:

          sqlite-utils dogs.db "select * from dogs" | python -mjson.tool

          [
              {
                  "id": 1,
                  "age": 4,
                  "name": "Cleo"
              },
              {
                  "id": 2,
                  "age": 2,
                  "name": "Pancakes"
              }
          ]

   <b>Binary</b> <b>data</b> <b>in</b> <b>JSON</b>
       Binary  strings  are  not  valid  JSON, so BLOB columns containing binary data will be returned as a JSON
       object containing base64 encoded data, that looks like this:

          sqlite-utils dogs.db "select name, content from images" | python -mjson.tool

          [
              {
                  "name": "transparent.gif",
                  "content": {
                      "$base64": true,
                      "encoded": "R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
                  }
              }
          ]

   <b>Nested</b> <b>JSON</b> <b>values</b>
       If one of your columns contains JSON, by default it will be returned as an escaped string:

          sqlite-utils dogs.db "select * from dogs" | python -mjson.tool

          [
              {
                  "id": 1,
                  "name": "Cleo",
                  "friends": "[{\"name\": \"Pancakes\"}, {\"name\": \"Bailey\"}]"
              }
          ]

       You can use the <b>--json-cols</b> option to automatically detect these JSON columns and output them  as  nested
       JSON data:

          sqlite-utils dogs.db "select * from dogs" --json-cols | python -mjson.tool

          [
              {
                  "id": 1,
                  "name": "Cleo",
                  "friends": [
                      {
                          "name": "Pancakes"
                      },
                      {
                          "name": "Bailey"
                      }
                  ]
              }
          ]

   <b>Returning</b> <b>CSV</b> <b>or</b> <b>TSV</b>
       You can use the <b>--csv</b> option to return results as CSV:

          sqlite-utils dogs.db "select * from dogs" --csv

          id,age,name
          1,4,Cleo
          2,2,Pancakes

       This  will  default  to  including  the  column  names  as  a  header  row.  To  exclude the headers, use
       <b>--no-headers</b>:

          sqlite-utils dogs.db "select * from dogs" --csv --no-headers

          1,4,Cleo
          2,2,Pancakes

       Use <b>--tsv</b> instead of <b>--csv</b> to get back tab-separated values:

          sqlite-utils dogs.db "select * from dogs" --tsv

          id  age     name
          1   4       Cleo
          2   2       Pancakes

   <b>Table-formatted</b> <b>output</b>
       You can use the <b>--table</b> option (or <b>-t</b> shortcut) to output query results as a table:

          sqlite-utils dogs.db "select * from dogs" --table

            id    age  name
          ----  -----  --------
             1      4  Cleo
             2      2  Pancakes

       You can use the <b>--fmt</b> option to specify different table formats, for example <b>rst</b> for reStructuredText:

          sqlite-utils dogs.db "select * from dogs" --fmt rst

          ====  =====  ========
            id    age  name
          ====  =====  ========
             1      4  Cleo
             2      2  Pancakes
          ====  =====  ========

       Available <b>--fmt</b> options are:

       • <b>asciidoc</b>

       • <b>double_grid</b>

       • <b>double_outline</b>

       • <b>fancy_grid</b>

       • <b>fancy_outline</b>

       • <b>github</b>

       • <b>grid</b>

       • <b>heavy_grid</b>

       • <b>heavy_outline</b>

       • <b>html</b>

       • <b>jira</b>

       • <b>latex</b>

       • <b>latex_booktabs</b>

       • <b>latex_longtable</b>

       • <b>latex_raw</b>

       • <b>mediawiki</b>

       • <b>mixed_grid</b>

       • <b>mixed_outline</b>

       • <b>moinmoin</b>

       • <b>orgtbl</b>

       • <b>outline</b>

       • <b>pipe</b>

       • <b>plain</b>

       • <b>presto</b>

       • <b>pretty</b>

       • <b>psql</b>

       • <b>rounded_grid</b>

       • <b>rounded_outline</b>

       • <b>rst</b>

       • <b>simple</b>

       • <b>simple_grid</b>

       • <b>simple_outline</b>

       • <b>textile</b>

       • <b>tsv</b>

       • <b>unsafehtml</b>

       • <b>youtrack</b>

       This list can also be found by running <b>sqlite-utils</b> <b>query</b> <b>--help</b>.

   <b>Returning</b> <b>raw</b> <b>data,</b> <b>such</b> <b>as</b> <b>binary</b> <b>content</b>
       If your table contains binary data in a <b>BLOB</b> you can use the <b>--raw</b>  option  to  output  specific  columns
       directly to standard out.

       For  example,  to  retrieve  a  binary  image  from  a <b>BLOB</b> column and store it in a file you can use the
       following:

          sqlite-utils photos.db "select contents from photos where id=1" --raw &gt; myphoto.jpg

       To return the first column of each result as raw data, separated by newlines, use <b>--raw-lines</b>:

          sqlite-utils photos.db "select caption from photos" --raw-lines &gt; captions.txt

   <b>Using</b> <b>named</b> <b>parameters</b>
       You can pass named parameters to the query using <b>-p</b>:

          sqlite-utils query dogs.db "select :num * :num2" -p num 5 -p num2 6

          [{":num * :num2": 30}]

       These will be correctly quoted and escaped in the SQL query, providing a safe way to combine other values
       with SQL.

   <b>UPDATE,</b> <b>INSERT</b> <b>and</b> <b>DELETE</b>
       If you execute an <b>UPDATE</b>, <b>INSERT</b> or <b>DELETE</b> query the command will return the number of affected rows:

          sqlite-utils dogs.db "update dogs set age = 5 where name = 'Cleo'"

          [{"rows_affected": 1}]

   <b>Defining</b> <b>custom</b> <b>SQL</b> <b>functions</b>
       You can use the <b>--functions</b> option to pass a block of Python code that defines additional functions which
       can then be called by your SQL query.

       This example defines a function which extracts the domain from a URL:

          sqlite-utils query sites.db "select url, domain(url) from urls" --functions '
          from urllib.parse import urlparse

          def domain(url):
              return urlparse(url).netloc
          '

       Every callable object defined in the block will be registered as a SQL function with the same name,  with
       the exception of functions with names that begin with an underscore.

   <b>SQLite</b> <b>extensions</b>
       You can load SQLite extension modules using the <b>--load-extension</b> option, see <u>Loading</u> <u>SQLite</u> <u>extensions</u>.

          sqlite-utils dogs.db "select spatialite_version()" --load-extension=spatialite

          [{"spatialite_version()": "4.3.0a"}]

   <b>Attaching</b> <b>additional</b> <b>databases</b>
       SQLite  supports  cross-database  SQL  queries, which can join data from tables in more than one database
       file.

       You can attach one or more additional databases using the <b>--attach</b> option, providing an alias to use  for
       that database and the path to the SQLite file on disk.

       This  example  attaches  the  <b>books.db</b> database under the alias <b>books</b> and then runs a query that combines
       data from that database with the default <b>dogs.db</b> database:

          sqlite-utils dogs.db --attach books books.db \
             'select * from sqlite_master union all select * from books.sqlite_master'

       <b>NOTE:</b>
          In Python: <u>db.attach()</u>

   <b>Querying</b> <b>data</b> <b>directly</b> <b>using</b> <b>an</b> <b>in-memory</b> <b>database</b>
       The <b>sqlite-utils</b> <b>memory</b> command works similar to <b>sqlite-utils</b> <b>query</b>, but allows you  to  execute  queries
       against an in-memory database.

       You  can  also pass this command CSV or JSON files which will be loaded into a temporary in-memory table,
       allowing you to execute SQL against that data without a separate step to first convert it to SQLite.

       Without any extra arguments, this command executes SQL against the in-memory database directly:

          sqlite-utils memory 'select sqlite_version()'

          [{"sqlite_version()": "3.35.5"}]

       It takes all of the same output formatting options as <u>sqlite-utils</u> <u>query</u>: <b>--csv</b> and <b>--csv</b> and <b>--table</b> and
       <b>--nl</b>:

          sqlite-utils memory 'select sqlite_version()' --csv

          sqlite_version()
          3.35.5

          sqlite-utils memory 'select sqlite_version()' --fmt grid

          +--------------------+
          | sqlite_version()   |
          +====================+
          | 3.35.5             |
          +--------------------+

   <b>Running</b> <b>queries</b> <b>directly</b> <b>against</b> <b>CSV</b> <b>or</b> <b>JSON</b>
       If you have data in CSV or JSON format you can load it into an in-memory SQLite database and run  queries
       against it directly in a single command using <b>sqlite-utils</b> <b>memory</b> like this:

          sqlite-utils memory data.csv "select * from data"

       You can pass multiple files to the command if you want to run joins between data from different files:

          sqlite-utils memory one.csv two.json \
            "select * from one join two on one.id = two.other_id"

       If  your  data  is  JSON  it  should be the same format supported by the <u>sqlite-utils</u> <u>insert</u> <u>command</u> - so
       either a single JSON object (treated as a single row) or a list of JSON objects.

       CSV data can be comma- or tab- delimited.

       The in-memory tables will be named after the files without  their  extensions.  The  tool  also  sets  up
       aliases  for  those  tables (using SQL views) as <b>t1</b>, <b>t2</b> and so on, or you can use the alias <b>t</b> to refer to
       the first table:

          sqlite-utils memory example.csv "select * from t"

       If two files have the same name they will be assigned a numeric suffix:

          sqlite-utils memory foo/data.csv bar/data.csv "select * from data_2"

       To read from standard input, use either <b>-</b> or <b>stdin</b> as the filename - then use <b>stdin</b> or <b>t</b>  or  <b>t1</b>  as  the
       table name:

          cat example.csv | sqlite-utils memory - "select * from stdin"

       Incoming  CSV data will be assumed to use <b>utf-8</b>. If your data uses a different character encoding you can
       specify that with <b>--encoding</b>:

          cat example.csv | sqlite-utils memory - "select * from stdin" --encoding=latin-1

       If you are joining across multiple CSV files they must all use the same encoding.

       Column types  will  be  automatically  detected  in  CSV  or  TSV  data,  using  the  same  mechanism  as
       <b>--detect-types</b>  described  in  <u>Inserting</u>  <u>CSV</u>  <u>or</u>  <u>TSV</u> <u>data</u>. You can pass the <b>--no-detect-types</b> option to
       disable this automatic type detection and treat all CSV and TSV columns as <b>TEXT</b>.

   <b>Explicitly</b> <b>specifying</b> <b>the</b> <b>format</b>
       By default, <b>sqlite-utils</b> <b>memory</b> will attempt to detect the  incoming  data  format  (JSON,  TSV  or  CSV)
       automatically.

       You  can  instead  specify an explicit format by adding a <b>:csv</b>, <b>:tsv</b>, <b>:json</b> or <b>:nl</b> (for newline-delimited
       JSON) suffix to the filename. For example:

          sqlite-utils memory one.dat:csv two.dat:nl \
            "select * from one union select * from two"

       Here the contents of <b>one.dat</b> will be treated as CSV and the  contents  of  <b>two.dat</b>  will  be  treated  as
       newline-delimited JSON.

       To  explicitly  specify the format for data piped into the tool on standard input, use <b>stdin:format</b> - for
       example:

          cat one.dat | sqlite-utils memory stdin:csv "select * from stdin"

   <b>Joining</b> <b>in-memory</b> <b>data</b> <b>against</b> <b>existing</b> <b>databases</b> <b>using</b> <b>--attach</b>
       The <u>attach</u> <u>option</u> can be used to attach database  files  to  the  in-memory  connection,  enabling  joins
       between in-memory data loaded from a file and tables in existing SQLite database files. An example:

          echo "id\n1\n3\n5" | sqlite-utils memory - --attach trees trees.db \
            "select * from trees.trees where rowid in (select id from stdin)"

       Here the <b>--attach</b> <b>trees</b> <b>trees.db</b> option makes the <b>trees.db</b> database available with an alias of <b>trees</b>.

       <b>select</b> <b>*</b> <b>from</b> <b>trees.trees</b> <b>where</b> <b>...</b> can then query the <b>trees</b> table in that database.

       The  CSV  data  that  was  piped  into the script is available in the <b>stdin</b> table, so  <b>...</b> <b>where</b> <b>rowid</b> <b>in</b>
       <b>(select</b> <b>id</b> <b>from</b> <b>stdin)</b> can be used to return rows from the <b>trees</b> table that match IDs that were piped  in
       as CSV content.

   <b>--schema,</b> <b>--analyze,</b> <b>--dump</b> <b>and</b> <b>--save</b>
       To see the in-memory database schema that would be used for a file or for multiple files, use <b>--schema</b>:

          sqlite-utils memory dogs.csv --schema

          CREATE TABLE [dogs] (
              [id] INTEGER,
              [age] INTEGER,
              [name] TEXT
          );
          CREATE VIEW t1 AS select * from [dogs];
          CREATE VIEW t AS select * from [dogs];

       You can run the equivalent of the <u>analyze-tables</u> command using <b>--analyze</b>:

          sqlite-utils memory dogs.csv --analyze

          dogs.id: (1/3)

            Total rows: 2
            Null rows: 0
            Blank rows: 0

            Distinct values: 2

          dogs.name: (2/3)

            Total rows: 2
            Null rows: 0
            Blank rows: 0

            Distinct values: 2

          dogs.age: (3/3)

            Total rows: 2
            Null rows: 0
            Blank rows: 0

            Distinct values: 2

       You  can  output  SQL  that  will  both  create  the tables and insert the full data used to populate the
       in-memory database using <b>--dump</b>:

          sqlite-utils memory dogs.csv --dump

          BEGIN TRANSACTION;
          CREATE TABLE [dogs] (
              [id] INTEGER,
              [age] INTEGER,
              [name] TEXT
          );
          INSERT INTO "dogs" VALUES('1','4','Cleo');
          INSERT INTO "dogs" VALUES('2','2','Pancakes');
          CREATE VIEW t1 AS select * from [dogs];
          CREATE VIEW t AS select * from [dogs];
          COMMIT;

       Passing <b>--save</b> <b>other.db</b> will instead use that SQL to populate a new database file:

          sqlite-utils memory dogs.csv --save dogs.db

       These features are mainly intended as debugging tools - for much more finely  grained  control  over  how
       data is inserted into a SQLite database file see <u>Inserting</u> <u>JSON</u> <u>data</u> and <u>Inserting</u> <u>CSV</u> <u>or</u> <u>TSV</u> <u>data</u>.

   <b>Returning</b> <b>all</b> <b>rows</b> <b>in</b> <b>a</b> <b>table</b>
       You can return every row in a specified table using the <b>rows</b> command:

          sqlite-utils rows dogs.db dogs

          [{"id": 1, "age": 4, "name": "Cleo"},
           {"id": 2, "age": 2, "name": "Pancakes"}]

       This command accepts the same output options as <b>query</b> - so you can pass <b>--nl</b>, <b>--csv</b>, <b>--tsv</b>, <b>--no-headers</b>,
       <b>--table</b> and <b>--fmt</b>.

       You can use the <b>-c</b> option to specify a subset of columns to return:

          sqlite-utils rows dogs.db dogs -c age -c name

          [{"age": 4, "name": "Cleo"},
           {"age": 2, "name": "Pancakes"}]

       You can filter rows using a where clause with the <b>--where</b> option:

          sqlite-utils rows dogs.db dogs -c name --where 'name = "Cleo"'

          [{"name": "Cleo"}]

       Or pass named parameters using <b>--where</b> in combination with <b>-p</b>:

          sqlite-utils rows dogs.db dogs -c name --where 'name = :name' -p name Cleo

          [{"name": "Cleo"}]

       You can define a sort order using <b>--order</b> <b>column</b> or <b>--order</b> <b>'column</b> <b>desc'</b>.

       Use  <b>--limit</b> <b>N</b> to only return the first <b>N</b> rows. Use <b>--offset</b> <b>N</b> to return rows starting from the specified
       offset.

       <b>NOTE:</b>
          In Python: <u>table.rows</u>  CLI reference: <u>sqlite-utils</u> <u>rows</u>

   <b>Listing</b> <b>tables</b>
       You can list the names of tables in a database using the <b>tables</b> command:

          sqlite-utils tables mydb.db

          [{"table": "dogs"},
           {"table": "cats"},
           {"table": "chickens"}]

       You can output this list in CSV using the <b>--csv</b> or <b>--tsv</b> options:

          sqlite-utils tables mydb.db --csv --no-headers

          dogs
          cats
          chickens

       If you just want to see the FTS4 tables, you can use <b>--fts4</b> (or <b>--fts5</b> for FTS5 tables):

          sqlite-utils tables docs.db --fts4

          [{"table": "docs_fts"}]

       Use <b>--counts</b> to include a count of the number of rows in each table:

          sqlite-utils tables mydb.db --counts

          [{"table": "dogs", "count": 12},
           {"table": "cats", "count": 332},
           {"table": "chickens", "count": 9}]

       Use <b>--columns</b> to include a list of columns in each table:

          sqlite-utils tables dogs.db --counts --columns

          [{"table": "Gosh", "count": 0, "columns": ["c1", "c2", "c3"]},
           {"table": "Gosh2", "count": 0, "columns": ["c1", "c2", "c3"]},
           {"table": "dogs", "count": 2, "columns": ["id", "age", "name"]}]

       Use <b>--schema</b> to include the schema of each table:

          sqlite-utils tables dogs.db --schema --table

          table    schema
          -------  -----------------------------------------------
          Gosh     CREATE TABLE Gosh (c1 text, c2 text, c3 text)
          Gosh2    CREATE TABLE Gosh2 (c1 text, c2 text, c3 text)
          dogs     CREATE TABLE [dogs] (
                     [id] INTEGER,
                     [age] INTEGER,
                     [name] TEXT)

       The <b>--nl</b>, <b>--csv</b>, <b>--tsv</b>, <b>--table</b> and <b>--fmt</b> options are also available.

       <b>NOTE:</b>
          In Python: <u>db.tables</u> <u>or</u> <u>db.table_names()</u>  CLI reference: <u>sqlite-utils</u> <u>tables</u>

   <b>Listing</b> <b>views</b>
       The <b>views</b> command shows any views defined in the database:

          sqlite-utils views sf-trees.db --table --counts --columns --schema

          view         count  columns               schema
          ---------  -------  --------------------  --------------------------------------------------------------
          demo_view   189144  ['qSpecies']          CREATE VIEW demo_view AS select qSpecies from Street_Tree_List
          hello            1  ['sqlite_version()']  CREATE VIEW hello as select sqlite_version()

       It takes the same options as the <b>tables</b> command:

       • <b>--columns</b>

       • <b>--schema</b>

       • <b>--counts</b>

       • <b>--nl</b>

       • <b>--csv</b>

       • <b>--tsv</b>

       • <b>--table</b>

       <b>NOTE:</b>
          In Python: <u>db.views</u> <u>or</u> <u>db.view_names()</u>  CLI reference: <u>sqlite-utils</u> <u>views</u>

   <b>Listing</b> <b>indexes</b>
       The <b>indexes</b> command lists any indexes configured for the database:

          sqlite-utils indexes covid.db --table

          table                             index_name                                                seqno    cid  name                 desc  coll      key
          --------------------------------  ------------------------------------------------------  -------  -----  -----------------  ------  ------  -----
          johns_hopkins_csse_daily_reports  idx_johns_hopkins_csse_daily_reports_combined_key             0     12  combined_key            0  BINARY      1
          johns_hopkins_csse_daily_reports  idx_johns_hopkins_csse_daily_reports_country_or_region        0      1  country_or_region       0  BINARY      1
          johns_hopkins_csse_daily_reports  idx_johns_hopkins_csse_daily_reports_province_or_state        0      2  province_or_state       0  BINARY      1
          johns_hopkins_csse_daily_reports  idx_johns_hopkins_csse_daily_reports_day                      0      0  day                     0  BINARY      1
          ny_times_us_counties              idx_ny_times_us_counties_date                                 0      0  date                    1  BINARY      1
          ny_times_us_counties              idx_ny_times_us_counties_fips                                 0      3  fips                    0  BINARY      1
          ny_times_us_counties              idx_ny_times_us_counties_county                               0      1  county                  0  BINARY      1
          ny_times_us_counties              idx_ny_times_us_counties_state                                0      2  state                   0  BINARY      1

       It shows indexes across all tables. To see indexes for specific tables, list those after the database:

          sqlite-utils indexes covid.db johns_hopkins_csse_daily_reports --table

       The command defaults to only showing the columns that are explicitly part of the index. To  also  include
       auxiliary columns use the <b>--aux</b> option - these columns will be listed with a <b>key</b> of <b>0</b>.

       The command takes the same format options as the <b>tables</b> and <b>views</b> commands.

       <b>NOTE:</b>
          In Python: <u>table.indexes</u>  CLI reference: <u>sqlite-utils</u> <u>indexes</u>

   <b>Listing</b> <b>triggers</b>
       The <b>triggers</b> command shows any triggers configured for the database:

          sqlite-utils triggers global-power-plants.db --table

          name             table      sql
          ---------------  ---------  -----------------------------------------------------------------
          plants_insert    plants     CREATE TRIGGER [plants_insert] AFTER INSERT ON [plants]
                                      BEGIN
                                          INSERT OR REPLACE INTO [_counts]
                                          VALUES (
                                            'plants',
                                            COALESCE(
                                              (SELECT count FROM [_counts] WHERE [table] = 'plants'),
                                            0
                                            ) + 1
                                          );
                                      END

       It  defaults  to  showing  triggers  for all tables. To see triggers for one or more specific tables pass
       their names as arguments:

          sqlite-utils triggers global-power-plants.db plants

       The command takes the same format options as the <b>tables</b> and <b>views</b> commands.

       <b>NOTE:</b>
          In Python: <u>table.triggers</u> <u>or</u> <u>db.triggers</u>  CLI reference: <u>sqlite-utils</u> <u>triggers</u>

   <b>Showing</b> <b>the</b> <b>schema</b>
       The <b>sqlite-utils</b> <b>schema</b> command shows the full SQL schema for the database:

          sqlite-utils schema dogs.db

          CREATE TABLE "dogs" (
              [id] INTEGER PRIMARY KEY,
              [name] TEXT
          );

       This will show the schema for every table and index in the database.  To  view  the  schema  just  for  a
       specified subset of tables pass those as additional arguments:

          sqlite-utils schema dogs.db dogs chickens

       <b>NOTE:</b>
          In Python: <u>table.schema</u> or <u>db.schema</u>  CLI reference: <u>sqlite-utils</u> <u>schema</u>

   <b>Analyzing</b> <b>tables</b>
       When  working  with  a  new  database  it  can  be  useful  to  get an idea of the shape of the data. The
       <b>sqlite-utils</b> <b>analyze-tables</b> command inspects specified tables (or all tables) and calculates some  useful
       details about each of the columns in those tables.

       To inspect the <b>tags</b> table in the <b>github.db</b> database, run the following:

          sqlite-utils analyze-tables github.db tags

          tags.repo: (1/3)

            Total rows: 261
            Null rows: 0
            Blank rows: 0

            Distinct values: 14

            Most common:
              88: 107914493
              75: 140912432
              27: 206156866

            Least common:
              1: 209590345
              2: 206649770
              2: 303218369

          tags.name: (2/3)

            Total rows: 261
            Null rows: 0
            Blank rows: 0

            Distinct values: 175

            Most common:
              10: 0.2
              9: 0.1
              7: 0.3

            Least common:
              1: 0.1.1
              1: 0.11.1
              1: 0.1a2

          tags.sha: (3/3)

            Total rows: 261
            Null rows: 0
            Blank rows: 0

            Distinct values: 261

       For  each  column this tool displays the number of null rows, the number of blank rows (rows that contain
       an empty string), the number of distinct values and, for columns that are not entirely distinct, the most
       common and least common values.

       If you do not specify any tables every table in the database will be analyzed:

          sqlite-utils analyze-tables github.db

       If you wish to analyze one or more specific columns, use the <b>-c</b> option:

          sqlite-utils analyze-tables github.db tags -c sha

       To show more than 10 common values, use <b>--common-limit</b> <b>20</b>.  To skip the most common or least common value
       analysis, use <b>--no-most</b> or <b>--no-least</b>:

          sqlite-utils analyze-tables github.db tags --common-limit 20 --no-least

   <b>Saving</b> <b>the</b> <b>analyzed</b> <b>table</b> <b>details</b>
       <b>analyze-tables</b> can take quite a while to run for large database files. You can save the  results  of  the
       analysis to a database table called <b>_analyze_tables_</b> using the <b>--save</b> option:

          sqlite-utils analyze-tables github.db --save

       The <b>_analyze_tables_</b> table has the following schema:

          CREATE TABLE [_analyze_tables_] (
              [table] TEXT,
              [column] TEXT,
              [total_rows] INTEGER,
              [num_null] INTEGER,
              [num_blank] INTEGER,
              [num_distinct] INTEGER,
              [most_common] TEXT,
              [least_common] TEXT,
              PRIMARY KEY ([table], [column])
          );

       The  <b>most_common</b>  and  <b>least_common</b>  columns will contain nested JSON arrays of the most common and least
       common values that look like this:

          [
              ["Del Libertador, Av", 5068],
              ["Alberdi Juan Bautista Av.", 4612],
              ["Directorio Av.", 4552],
              ["Rivadavia, Av", 4532],
              ["Yerbal", 4512],
              ["Cosquín", 4472],
              ["Estado Plurinacional de Bolivia", 4440],
              ["Gordillo Timoteo", 4424],
              ["Montiel", 4360],
              ["Condarco", 4288]
          ]

   <b>Creating</b> <b>an</b> <b>empty</b> <b>database</b>
       You can create a new empty database file using the <b>create-database</b> command:

          sqlite-utils create-database empty.db

       To enable <u>WAL</u> <u>mode</u> on the newly created database add the <b>--enable-wal</b> option:

          sqlite-utils create-database empty.db --enable-wal

       To enable SpatiaLite metadata on a newly created database, add the <b>--init-spatialite</b> flag:

          sqlite-utils create-database empty.db --init-spatialite

       That will look for SpatiaLite in a set of predictable locations. To load it from somewhere else, use  the
       <b>--load-extension</b> option:

          sqlite-utils create-database empty.db --init-spatialite --load-extension /path/to/spatialite.so

   <b>Inserting</b> <b>JSON</b> <b>data</b>
       If  you  have  data  as JSON, you can use <b>sqlite-utils</b> <b>insert</b> <b>tablename</b> to insert it into a database. The
       table will be created with the correct (automatically detected) columns if it does not already exist.

       You can pass in a single JSON object or a list of JSON objects, either as a filename or piped directly to
       standard-in (by using <b>-</b> as the filename).

       Here's the simplest possible example:

          echo '{"name": "Cleo", "age": 4}' | sqlite-utils insert dogs.db dogs -

       To specify a column as the primary key, use <b>--pk=column_name</b>.

       To create a compound primary key across more than one column, use <b>--pk</b> multiple times.

       If you feed it a JSON list it will insert multiple records. For example, if <b>dogs.json</b> looks like this:

          [
              {
                  "id": 1,
                  "name": "Cleo",
                  "age": 4
              },
              {
                  "id": 2,
                  "name": "Pancakes",
                  "age": 2
              },
              {
                  "id": 3,
                  "name": "Toby",
                  "age": 6
              }
          ]

       You can import all three records into an automatically created <b>dogs</b> table and set the <b>id</b>  column  as  the
       primary key like so:

          sqlite-utils insert dogs.db dogs dogs.json --pk=id

       Pass <b>--pk</b> multiple times to define a compound primary key.

       You can skip inserting any records that have a primary key that already exists using <b>--ignore</b>:

          sqlite-utils insert dogs.db dogs dogs.json --pk=id --ignore

       You can delete all the existing rows in the table before inserting the new records using <b>--truncate</b>:

          sqlite-utils insert dogs.db dogs dogs.json --truncate

       You can add the <b>--analyze</b> option to run <b>ANALYZE</b> against the table after the rows have been inserted.

   <b>Inserting</b> <b>binary</b> <b>data</b>
       You  can  insert binary data into a BLOB column by first encoding it using base64 and then structuring it
       like this:

          [
              {
                  "name": "transparent.gif",
                  "content": {
                      "$base64": true,
                      "encoded": "R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
                  }
              }
          ]

   <b>Inserting</b> <b>newline-delimited</b> <b>JSON</b>
       You can also import <u>newline-delimited</u> <u>JSON</u> using the <b>--nl</b> option:

          echo '{"id": 1, "name": "Cleo"}
          {"id": 2, "name": "Suna"}' | sqlite-utils insert creatures.db creatures - --nl

       Newline-delimited JSON consists of full JSON objects separated by newlines.

       If you are processing data using <b>jq</b> you can use the <b>jq</b> <b>-c</b> option to output valid newline-delimited JSON.

       Since <u>Datasette</u> can export newline-delimited JSON, you can combine the Datasette  and  <b>sqlite-utils</b>  like
       so:

          curl -L "https://latest.datasette.io/fixtures/facetable.json?_shape=array&amp;_nl=on" \
              | sqlite-utils insert nl-demo.db facetable - --pk=id --nl

       You  can also pipe <b>sqlite-utils</b> together to create a new SQLite database file containing the results of a
       SQL query against another database:

          sqlite-utils sf-trees.db \
              "select TreeID, qAddress, Latitude, Longitude from Street_Tree_List" --nl \
            | sqlite-utils insert saved.db trees - --nl

          sqlite-utils saved.db "select * from trees limit 5" --csv

          TreeID,qAddress,Latitude,Longitude
          141565,501X Baker St,37.7759676911831,-122.441396661871
          232565,940 Elizabeth St,37.7517102172731,-122.441498017841
          119263,495X Lakeshore Dr,,
          207368,920 Kirkham St,37.760210314285,-122.47073935813
          188702,1501 Evans Ave,37.7422086702947,-122.387293152263

   <b>Flattening</b> <b>nested</b> <b>JSON</b> <b>objects</b>
       <b>sqlite-utils</b> <b>insert</b> and <b>sqlite-utils</b> <b>memory</b> both expect incoming JSON data to consist of an array of JSON
       objects, where the top-level keys of each object will become columns in the created database table.

       If your data is nested you can use the <b>--flatten</b> option to create  columns  that  are  derived  from  the
       nested data.

       Consider this example document, in a file called <b>log.json</b>:

          {
              "httpRequest": {
                  "latency": "0.112114537s",
                  "requestMethod": "GET",
                  "requestSize": "534",
                  "status": 200
              },
              "insertId": "6111722f000b5b4c4d4071e2",
              "labels": {
                  "service": "datasette-io"
              }
          }

       Inserting  this into a table using <b>sqlite-utils</b> <b>insert</b> <b>logs.db</b> <b>logs</b> <b>log.json</b> will create a table with the
       following schema:

          CREATE TABLE [logs] (
             [httpRequest] TEXT,
             [insertId] TEXT,
             [labels] TEXT
          );

       With the <b>--flatten</b> option columns will  be  created  using  <b>topkey_nextkey</b>  column  names  -  so  running
       <b>sqlite-utils</b> <b>insert</b> <b>logs.db</b> <b>logs</b> <b>log.json</b> <b>--flatten</b> will create the following schema instead:

          CREATE TABLE [logs] (
             [httpRequest_latency] TEXT,
             [httpRequest_requestMethod] TEXT,
             [httpRequest_requestSize] TEXT,
             [httpRequest_status] INTEGER,
             [insertId] TEXT,
             [labels_service] TEXT
          );

   <b>Inserting</b> <b>CSV</b> <b>or</b> <b>TSV</b> <b>data</b>
       If your data is in CSV format, you can insert it using the <b>--csv</b> option:

          sqlite-utils insert dogs.db dogs dogs.csv --csv

       For tab-delimited data, use <b>--tsv</b>:

          sqlite-utils insert dogs.db dogs dogs.tsv --tsv

       Data  is  expected  to be encoded as Unicode UTF-8. If your data is an another character encoding you can
       specify it using the <b>--encoding</b> option:

          sqlite-utils insert dogs.db dogs dogs.tsv --tsv --encoding=latin-1

       To stop inserting after a specified number of records - useful for getting a faster preview  of  a  large
       file - use the <b>--stop-after</b> option:

          sqlite-utils insert dogs.db dogs dogs.csv --csv --stop-after=10

       A  progress  bar  is  displayed  when inserting data from a file. You can hide the progress bar using the
       <b>--silent</b> option.

       By default every column inserted from a CSV or TSV file will be of type  <b>TEXT</b>.  To  automatically  detect
       column  types  - resulting in a mix of <b>TEXT</b>, <b>INTEGER</b> and <b>FLOAT</b> columns, use the <b>--detect-types</b> option (or
       its shortcut <b>-d</b>).

       For example, given a <b>creatures.csv</b> file containing this:

          name,age,weight
          Cleo,6,45.5
          Dori,1,3.5

       The following command:

          sqlite-utils insert creatures.db creatures creatures.csv --csv --detect-types

       Will produce this schema:

          sqlite-utils schema creatures.db

          CREATE TABLE "creatures" (
             [name] TEXT,
             [age] INTEGER,
             [weight] FLOAT
          );

       You can set the <b>SQLITE_UTILS_DETECT_TYPES</b> environment variable if  you  want  <b>--detect-types</b>  to  be  the
       default behavior:

          export SQLITE_UTILS_DETECT_TYPES=1

       If a CSV or TSV file includes empty cells, like this one:

          name,age,weight
          Cleo,6,
          Dori,,3.5

       They will be imported into SQLite as empty string values, <b>""</b>.

       To import them as <b>NULL</b> values instead, use the <b>--empty-null</b> option:

          sqlite-utils insert creatures.db creatures creatures.csv --csv --empty-null

   <b>Alternative</b> <b>delimiters</b> <b>and</b> <b>quote</b> <b>characters</b>
       If  your  file  uses a delimiter other than <b>,</b> or a quote character other than <b>"</b> you can attempt to detect
       delimiters or you can specify them explicitly.

       The <b>--sniff</b> option can be used to attempt to detect the delimiters:

          sqlite-utils insert dogs.db dogs dogs.csv --sniff

       Alternatively, you can specify them using the <b>--delimiter</b> and <b>--quotechar</b> options.

       Here's a CSV file that uses <b>;</b> for delimiters and the <b>|</b> symbol for quote characters:

          name;description
          Cleo;|Very fine; a friendly dog|
          Pancakes;A local corgi

       You can import that using:

          sqlite-utils insert dogs.db dogs dogs.csv --delimiter=";" --quotechar="|"

       Passing <b>--delimiter</b>, <b>--quotechar</b> or <b>--sniff</b> implies <b>--csv</b>, so you can omit the <b>--csv</b> option.

   <b>CSV</b> <b>files</b> <b>without</b> <b>a</b> <b>header</b> <b>row</b>
       The first row of any CSV or TSV file is expected to contain the names of the columns in that file.

       If your file does not include this row, you can use the <b>--no-headers</b> option  to  specify  that  the  tool
       should not use that fist row as headers.

       If  you  do this, the table will be created with column names called <b>untitled_1</b> and <b>untitled_2</b> and so on.
       You can then rename them using the <b>sqlite-utils</b> <b>transform</b> <b>...</b> <b>--rename</b> command, see <u>Transforming</u> <u>tables</u>.

   <b>Inserting</b> <b>unstructured</b> <b>data</b> <b>with</b> <b>--lines</b> <b>and</b> <b>--text</b>
       If you have an unstructured file you can insert its contents into a  table  with  a  single  <b>line</b>  column
       containing  each  line  from  the file using <b>--lines</b>. This can be useful if you intend to further analyze
       those lines using SQL string functions or <u>sqlite-utils</u> <u>convert</u>:

          sqlite-utils insert logs.db loglines logfile.log --lines

       This will produce the following schema:

          CREATE TABLE [loglines] (
             [line] TEXT
          );

       You can also insert the entire contents of the file into a single column called <b>text</b> using <b>--text</b>:

          sqlite-utils insert content.db content file.txt --text

       The schema here will be:

          CREATE TABLE [content] (
             [text] TEXT
          );

   <b>Applying</b> <b>conversions</b> <b>while</b> <b>inserting</b> <b>data</b>
       The <b>--convert</b> option can be used to apply a Python conversion function to  imported  data  before  it  is
       inserted into the database. It works in a similar way to <u>sqlite-utils</u> <u>convert</u>.

       Your Python function will be passed a dictionary called <b>row</b> for each item that is being imported. You can
       modify  that  dictionary  and  return it - or return a fresh dictionary - to change the data that will be
       inserted.

       Given a JSON file called <b>dogs.json</b> containing this:

          [
              {"id": 1, "name": "Cleo"},
              {"id": 2, "name": "Pancakes"}
          ]

       The following command will insert that data and add an <b>is_good</b> column set to <b>1</b> for each dog:

          sqlite-utils insert dogs.db dogs dogs.json --convert 'row["is_good"] = 1'

       The <b>--convert</b> option also works with the <b>--csv</b>, <b>--tsv</b> and <b>--nl</b> insert options.

       As with <b>sqlite-utils</b> <b>convert</b> you can use <b>--import</b> to import  additional  Python  modules,  see  <u>Importing</u>
       <u>additional</u> <u>modules</u> for details.

       You  can  also  pass  code that runs some initialization steps and defines a <b>convert(value)</b> function, see
       <u>Defining</u> <u>a</u> <u>convert()</u> <u>function</u>.

   <b>--convert</b> <b>with</b> <b>--lines</b>
       Things work slightly differently when combined with the <b>--lines</b> or <b>--text</b> options.

       With <b>--lines</b>, instead of being passed a <b>row</b> dictionary  your  function  will  be  passed  a  <b>line</b>  string
       representing each line of the input. Given a file called <b>access.log</b> containing the following:

          INFO:     127.0.0.1:60581 - GET / HTTP/1.1 200 OK
          INFO:     127.0.0.1:60581 - GET /foo/-/static/app.css?cead5a HTTP/1.1 200 OK

       You could convert it into structured data like so:

          sqlite-utils insert logs.db loglines access.log --convert '
          type, source, _, verb, path, _, status, _ = line.split()
          return {
              "type": type,
              "source": source,
              "verb": verb,
              "path": path,
              "status": status,
          }' --lines

       The resulting table would look like this:
                      ┌───────┬─────────────────┬──────┬──────────────────────────────┬────────┐
                      │ type  │ source          │ verb │ path                         │ status │
                      ├───────┼─────────────────┼──────┼──────────────────────────────┼────────┤
                      │ INFO: │ 127.0.0.1:60581 │ GET  │ /                            │ 200    │
                      ├───────┼─────────────────┼──────┼──────────────────────────────┼────────┤
                      │ INFO: │ 127.0.0.1:60581 │ GET  │ /foo/-/static/app.css?cead5a │ 200    │
                      └───────┴─────────────────┴──────┴──────────────────────────────┴────────┘

   <b>--convert</b> <b>with</b> <b>--text</b>
       With  <b>--text</b>  the entire input to the command will be made available to the function as a variable called
       <b>text</b>.

       The function can return a single dictionary which will be inserted as a single row, or it  can  return  a
       list or iterator of dictionaries, each of which will be inserted.

       Here's how to use <b>--convert</b> and <b>--text</b> to insert one record per word in the input:

          echo 'A bunch of words' | sqlite-utils insert words.db words - \
              --text --convert '({"word": w} for w in text.split())'

       The result looks like this:

          sqlite-utils dump words.db

          BEGIN TRANSACTION;
          CREATE TABLE [words] (
             [word] TEXT
          );
          INSERT INTO "words" VALUES('A');
          INSERT INTO "words" VALUES('bunch');
          INSERT INTO "words" VALUES('of');
          INSERT INTO "words" VALUES('words');
          COMMIT;

   <b>Insert-replacing</b> <b>data</b>
       The  <b>--replace</b>  option  to  <b>insert</b>  causes  any existing records with the same primary key to be replaced
       entirely by the new records.

       To replace a dog with in ID of 2 with a new record, run the following:

          echo '{"id": 2, "name": "Pancakes", "age": 3}' | \
              sqlite-utils insert dogs.db dogs - --pk=id --replace

   <b>Upserting</b> <b>data</b>
       Upserting is update-or-insert. If a row exists with the specified primary key the provided  columns  will
       be updated. If no row exists that row will be created.

       Unlike  <b>insert</b>  <b>--replace</b>,  an upsert will ignore any column values that exist but are not present in the
       upsert document.

       For example:

          echo '{"id": 2, "age": 4}' | \
              sqlite-utils upsert dogs.db dogs - --pk=id

       This will update the dog with an ID of 2 to have an age of 4, creating a new record (with a null name) if
       one does not exist. If a row DOES exist the name will be left as-is.

       The command will fail if you reference columns that do not exist on the table.  To  automatically  create
       missing columns, use the <b>--alter</b> option.

       <b>NOTE:</b>
          <b>upsert</b>  in sqlite-utils 1.x worked like <b>insert</b> <b>...</b> <b>--replace</b> does in 2.x. See <u>issue</u> <u>#66</u> for details of
          this change.

   <b>Executing</b> <b>SQL</b> <b>in</b> <b>bulk</b>
       If you have a JSON, newline-delimited JSON, CSV or TSV file you can execute a bulk SQL query  using  each
       of the records in that file using the <b>sqlite-utils</b> <b>bulk</b> command.

       The  command  takes  the database file, the SQL to be executed and the file containing records to be used
       when evaluating the SQL query.

       The SQL query should include <b>:named</b> parameters that match the keys in the records.

       For example, given a <b>chickens.csv</b> CSV file containing the following:

          id,name
          1,Blue
          2,Snowy
          3,Azi
          4,Lila
          5,Suna
          6,Cardi

       You could insert those rows into a pre-created <b>chickens</b> table like so:

          sqlite-utils bulk chickens.db \
            'insert into chickens (id, name) values (:id, :name)' \
            chickens.csv --csv

       This command takes the same options as the <b>sqlite-utils</b> <b>insert</b> command - so it defaults to expecting JSON
       but can accept other formats using <b>--csv</b> or <b>--tsv</b> or <b>--nl</b> or other options described above.

       By default all of the SQL queries will be executed in a single transaction. To commit every  20  records,
       use <b>--batch-size</b> <b>20</b>.

   <b>Inserting</b> <b>data</b> <b>from</b> <b>files</b>
       The  <b>insert-files</b>  command  can be used to insert the content of files, along with their metadata, into a
       SQLite table.

       Here's an example that inserts all of the GIF files in the current directory  into  a  <b>gifs.db</b>  database,
       placing the file contents in an <b>images</b> table:

          sqlite-utils insert-files gifs.db images *.gif

       You  can  also  pass one or more directories, in which case every file in those directories will be added
       recursively:

          sqlite-utils insert-files gifs.db images path/to/my-gifs

       By default this command will create a table with the following schema:

          CREATE TABLE [images] (
              [path] TEXT PRIMARY KEY,
              [content] BLOB,
              [size] INTEGER
          );

       Content will be treated as binary by default and stored in a <b>BLOB</b> column. You can use the  <b>--text</b>  option
       to store that content in a <b>TEXT</b> column instead.

       You  can  customize  the  schema  using one or more <b>-c</b> options. For a table schema that includes just the
       path, MD5 hash and last modification time of the file, you would use this:

          sqlite-utils insert-files gifs.db images *.gif -c path -c md5 -c mtime --pk=path

       This will result in the following schema:

          CREATE TABLE [images] (
              [path] TEXT PRIMARY KEY,
              [md5] TEXT,
              [mtime] FLOAT
          );

       Note that there's no <b>content</b> column here at all - if you specify custom columns  using  <b>-c</b>  you  need  to
       include <b>-c</b> <b>content</b> to create that column.

       You  can change the name of one of these columns using a <b>-c</b> <b>colname:coldef</b> parameter. To rename the <b>mtime</b>
       column to <b>last_modified</b> you would use this:

          sqlite-utils insert-files gifs.db images *.gif \
              -c path -c md5 -c last_modified:mtime --pk=path

       You can pass <b>--replace</b> or <b>--upsert</b> to indicate what should happen if you try to insert  a  file  with  an
       existing primary key. Pass <b>--alter</b> to cause any missing columns to be added to the table.

       The full list of column definitions you can use is as follows:

       <b>name</b>   The name of the file, e.g. <b>cleo.jpg</b>

       <b>path</b>   The path to the file relative to the root folder, e.g. <b>pictures/cleo.jpg</b>

       <b>fullpath</b>
              The fully resolved path to the image, e.g. <b>/home/simonw/pictures/cleo.jpg</b>

       <b>sha256</b> The SHA256 hash of the file contents

       <b>md5</b>    The MD5 hash of the file contents

       <b>mode</b>   The permission bits of the file, as an integer - you may want to convert this to octal

       <b>content</b>
              The binary file contents, which will be stored as a BLOB

       <b>content_text</b>
              The text file contents, which will be stored as TEXT

       <b>mtime</b>  The modification time of the file, as floating point seconds since the Unix epoch

       <b>ctime</b>  The creation time of the file, as floating point seconds since the Unix epoch

       <b>mtime_int</b>
              The modification time as an integer rather than a float

       <b>ctime_int</b>
              The creation time as an integer rather than a float

       <b>mtime_iso</b>
              The modification time as an ISO timestamp, e.g. <b>2020-07-27T04:24:06.654246</b>

       <b>ctime_iso</b>
              The creation time is an ISO timestamp

       <b>size</b>   The integer size of the file in bytes

       <b>stem</b>   The filename without the extension - for <b>file.txt.gz</b> this would be <b>file.txt</b>

       <b>suffix</b> The file extension - for <b>file.txt.gz</b> this would be <b>.gz</b>

       You can insert data piped from standard input like this:

          cat dog.jpg | sqlite-utils insert-files dogs.db pics - --name=dog.jpg

       The  <b>-</b>  argument  indicates  data  should be read from standard input. The string passed using the <b>--name</b>
       option will be used for the file name and path values.

       When inserting data from standard input only the following column definitions are supported: <b>name</b>,  <b>path</b>,
       <b>content</b>, <b>content_text</b>, <b>sha256</b>, <b>md5</b> and <b>size</b>.

   <b>Converting</b> <b>data</b> <b>in</b> <b>columns</b>
       The <b>convert</b> command can be used to transform the data in a specified column - for example to parse a date
       string into an ISO timestamp, or to split a string of tags into a JSON array.

       The  command  accepts  a  database, table, one or more columns and a string of Python code to be executed
       against the values from those columns. The following example would replace the  values  in  the  <b>headline</b>
       column in the <b>articles</b> table with an upper-case version:

          sqlite-utils convert content.db articles headline 'value.upper()'

       The  Python  code  is passed as a string. Within that Python code the <b>value</b> variable will be the value of
       the current column.

       The code you provide will be compiled into a function that takes <b>value</b> as a single argument. If you break
       your function body into multiple lines the last line should be a <b>return</b> statement:

          sqlite-utils convert content.db articles headline '
          value = str(value)
          return value.upper()'

       Your code will be automatically wrapped in a  function,  but  you  can  also  define  a  function  called
       <b>convert(value)</b> which will be called, if available:

          sqlite-utils convert content.db articles headline '
          def convert(value):
              return value.upper()'

       Use a <b>CODE</b> value of <b>-</b> to read from standard input:

          cat mycode.py | sqlite-utils convert content.db articles headline -

       Where <b>mycode.py</b> contains a fragment of Python code that looks like this:

          def convert(value):
              return value.upper()

       The  conversion will be applied to every row in the specified table. You can limit that to just rows that
       match a <b>WHERE</b> clause using <b>--where</b>:

          sqlite-utils convert content.db articles headline 'value.upper()' \
              --where "headline like '%cat%'"

       You can include named parameters in your where clause  and  populate  them  using  one  or  more  <b>--param</b>
       options:

          sqlite-utils convert content.db articles headline 'value.upper()' \
              --where "headline like :query" \
              --param query '%cat%'

       The  <b>--dry-run</b>  option  will  output  a  preview  of  the  conversion against the first ten rows, without
       modifying the database.

       By default any rows with a falsey value for the column - such as <b>0</b> or <b>null</b> - will  be  skipped.  Use  the
       <b>--no-skip-false</b> option to disable this behaviour.

   <b>Importing</b> <b>additional</b> <b>modules</b>
       You  can specify Python modules that should be imported and made available to your code using one or more
       <b>--import</b> options. This example uses the <b>textwrap</b> module to wrap the <b>content</b> column at 100 characters:

          sqlite-utils convert content.db articles content \
              '"\n".join(textwrap.wrap(value, 100))' \
              --import=textwrap

       This supports nested imports as well, for example to use <u>ElementTree</u>:

          sqlite-utils convert content.db articles content \
              'xml.etree.ElementTree.fromstring(value).attrib["title"]' \
              --import=xml.etree.ElementTree

   <b>Using</b> <b>the</b> <b>debugger</b>
       If an error occurs while running your conversion operation you may see a message like this:

          user-defined function raised exception

       Add the <b>--pdb</b> option to catch the error and open the  Python  debugger  at  that  point.  The  conversion
       operation will exit after you type <b>q</b> in the debugger.

       Here's  an  example  debugging  session.  First,  create a <b>articles</b> table with invalid XML in the <b>content</b>
       column:

          echo '{"content": "This is not XML"}' | sqlite-utils insert content.db articles -

       Now run the conversion with the <b>--pdb</b> option:

          sqlite-utils convert content.db articles content \
              'xml.etree.ElementTree.fromstring(value).attrib["title"]' \
              --import=xml.etree.ElementTree \
              --pdb

       When the error occurs the debugger will open:

          Exception raised, dropping into pdb...: syntax error: line 1, column 0
          &gt; .../python3.11/xml/etree/<a href="../man1338/ElementTree.py.1338.html">ElementTree.py</a>(1338)XML()
          -&gt; parser.feed(text)
          (Pdb) args
          text = 'This is not XML'
          parser = &lt;xml.etree.ElementTree.XMLParser object at 0x102c405e0&gt;
          (Pdb) q

       <b>args</b> here shows the arguments to the current function in the stack. The Python <u>pdb</u> <u>documentation</u> has full
       details on the other available commands.

   <b>Defining</b> <b>a</b> <b>convert()</b> <b>function</b>
       Instead of providing a single line of code to be executed against each value, you can define  a  function
       called <b>convert(value)</b>.

       This  mechanism  can  be  used  to execute one-off initialization code that runs once at the start of the
       conversion run.

       The following example adds a new <b>score</b> column, then updates it to list a  random  number  -  after  first
       seeding the random number generator to ensure that multiple runs produce the same results:

          sqlite-utils add-column content.db articles score float --not-null-default 1.0
          sqlite-utils convert content.db articles score '
          import random
          <a href="../man10/random.seed.10.html">random.seed</a>(10)

          def convert(value):
              return random.random()
          '

   <b>sqlite-utils</b> <b>convert</b> <b>recipes</b>
       Various built-in recipe functions are available for common operations. These are:

       <b>r.jsonsplit(value,</b> <b>delimiter=',',</b> <b>type=&lt;class</b> <b>'str'&gt;)</b>
              Convert a string like <b>a,b,c</b> into a JSON array <b>["a",</b> <b>"b",</b> <b>"c"]</b>

              The <b>delimiter</b> parameter can be used to specify a different delimiter.

              The  <b>type</b>  parameter  can  be  set to <b>float</b> or <b>int</b> to produce a JSON array of different types, for
              example if the column's string value was <b>1.2,3,4.5</b> the following:

                 r.jsonsplit(value, type=float)

              Would produce an array like this: <b>[1.2,</b> <b>3.0,</b> <b>4.5]</b>

       <b>r.parsedate(value,</b> <b>dayfirst=False,</b> <b>yearfirst=False,</b> <b>errors=None)</b>
              Parse a date and convert it to ISO date format: <b>yyyy-mm-dd</b>

              In the case of dates such as <b>03/04/05</b> U.S. <b>MM/DD/YY</b> format is assumed - you can use  <b>dayfirst=True</b>
              or <b>yearfirst=True</b> to change how these ambiguous dates are interpreted.

              Use the <b>errors=</b> parameter to specify what should happen if a value cannot be parsed.

              By default, if any value cannot be parsed an error will be occurred and all values will be left as
              they were.

              Set <b>errors=r.IGNORE</b> to ignore any values that cannot be parsed, leaving them unchanged.

              Set <b>errors=r.SET_NULL</b> to set any values that cannot be parsed to <b>null</b>.

       <b>r.parsedatetime(value,</b> <b>dayfirst=False,</b> <b>yearfirst=False,</b> <b>errors=None)</b>
              Parse a datetime and convert it to ISO datetime format: <b>yyyy-mm-ddTHH:MM:SS</b>

       These recipes can be used in the code passed to <b>sqlite-utils</b> <b>convert</b> like this:

          sqlite-utils convert my.db mytable mycolumn \
            'r.jsonsplit(value)'

       To use any of the documented parameters, do this:

          sqlite-utils convert my.db mytable mycolumn \
            'r.jsonsplit(value, delimiter=":")'

   <b>Saving</b> <b>the</b> <b>result</b> <b>to</b> <b>a</b> <b>different</b> <b>column</b>
       The  <b>--output</b>  and  <b>--output-type</b>  options can be used to save the result of the conversion to a separate
       column, which will be created if that column does not already exist:

          sqlite-utils convert content.db articles headline 'value.upper()' \
            --output headline_upper

       The type of the created column defaults to <b>text</b>, but a different  column  type  can  be  specified  using
       <b>--output-type</b>.  This  example will create a new floating point column called <b>id_as_a_float</b> with a copy of
       each item's ID increased by 0.5:

          sqlite-utils convert content.db articles id 'float(value) + 0.5' \
            --output id_as_a_float \
            --output-type float

       You can drop the original column at the end of the operation by adding <b>--drop</b>.

   <b>Converting</b> <b>a</b> <b>column</b> <b>into</b> <b>multiple</b> <b>columns</b>
       Sometimes you may wish to convert a single column into multiple derived columns.  For  example,  you  may
       have  a  <b>location</b>  column  containing <b>latitude,longitude</b> values which you wish to split out into separate
       <b>latitude</b> and <b>longitude</b> columns.

       You can achieve this using the <b>--multi</b> option to <b>sqlite-utils</b> <b>convert</b>. This option  expects  your  Python
       code  to  return  a  Python dictionary: new columns well be created and populated for each of the keys in
       that dictionary.

       For the <b>latitude,longitude</b> example you would use the following:

          sqlite-utils convert demo.db places location \
          'bits = value.split(",")
          return {
            "latitude": float(bits[0]),
            "longitude": float(bits[1]),
          }' --multi

       The type of the returned values will be taken into  account  when  creating  the  new  columns.  In  this
       example, the resulting database schema will look like this:

          CREATE TABLE [places] (
              [location] TEXT,
              [latitude] FLOAT,
              [longitude] FLOAT
          );

       The  code  function  can  also  return  <b>None</b>,  in which case its output will be ignored. You can drop the
       original column at the end of the operation by adding <b>--drop</b>.

   <b>Creating</b> <b>tables</b>
       Most of the time creating tables by inserting example data is the  quickest  approach.  If  you  need  to
       create an empty table in advance of inserting data you can do so using the <b>create-table</b> command:

          sqlite-utils create-table mydb.db mytable id integer name text --pk=id

       This  will  create a table called <b>mytable</b> with two columns - an integer <b>id</b> column and a text <b>name</b> column.
       It will set the <b>id</b> column to be the primary key.

       You can pass as many column-name column-type pairs as you like. Valid types are <b>integer</b>, <b>text</b>, <b>float</b>  and
       <b>blob</b>.

       Pass <b>--pk</b> more than once for a compound primary key that covers multiple columns.

       You  can specify columns that should be NOT NULL using <b>--not-null</b> <b>colname</b>. You can specify default values
       for columns using <b>--default</b> <b>colname</b> <b>defaultvalue</b>.

          sqlite-utils create-table mydb.db mytable \
              id integer \
              name text \
              age integer \
              is_good integer \
              --not-null name \
              --not-null age \
              --default is_good 1 \
              --pk=id

          sqlite-utils tables mydb.db --schema -t

          table    schema
          -------  --------------------------------
          mytable  CREATE TABLE [mytable] (
                      [id] INTEGER PRIMARY KEY,
                      [name] TEXT NOT NULL,
                      [age] INTEGER NOT NULL,
                      [is_good] INTEGER DEFAULT '1'
                  )

       You can specify foreign key relationships  between  the  tables  you  are  creating  using  <b>--fk</b>  <b>colname</b>
       <b>othertable</b> <b>othercolumn</b>:

          sqlite-utils create-table books.db authors \
              id integer \
              name text \
              --pk=id

          sqlite-utils create-table books.db books \
              id integer \
              title text \
              author_id integer \
              --pk=id \
              --fk author_id authors id

          sqlite-utils tables books.db --schema -t

          table    schema
          -------  -------------------------------------------------
          authors  CREATE TABLE [authors] (
                      [id] INTEGER PRIMARY KEY,
                      [name] TEXT
                   )
          books    CREATE TABLE [books] (
                      [id] INTEGER PRIMARY KEY,
                      [title] TEXT,
                      [author_id] INTEGER REFERENCES [authors]([id])
                   )

       You can create a table in <u>SQLite</u> <u>STRICT</u> <u>mode</u> using <b>--strict</b>:

          sqlite-utils create-table mydb.db mytable id integer name text --strict

          sqlite-utils tables mydb.db --schema -t

          table    schema
          -------  ------------------------
          mytable  CREATE TABLE [mytable] (
                      [id] INTEGER,
                      [name] TEXT
                   ) STRICT

       If  a  table  with the same name already exists, you will get an error. You can choose to silently ignore
       this error with <b>--ignore</b>, or you can replace the existing table with a new, empty table using <b>--replace</b>.

       You can also pass <b>--transform</b> to transform the existing table to match the  new  schema.  See  <u>Explicitly</u>
       <u>creating</u> <u>a</u> <u>table</u> in the Python library documentation for details of how this option works.

   <b>Renaming</b> <b>a</b> <b>table</b>
       Yo ucan rename a table using the <b>rename-table</b> command:

          sqlite-utils rename-table mydb.db oldname newname

       Pass  <b>--ignore</b>  to  ignore  any errors caused by the table not existing, or the new name already being in
       use.

   <b>Duplicating</b> <b>tables</b>
       The <b>duplicate</b> command duplicates a table - creating a new table with the same schema and a copy of all of
       the rows:

          sqlite-utils duplicate books.db authors authors_copy

   <b>Dropping</b> <b>tables</b>
       You can drop a table using the <b>drop-table</b> command:

          sqlite-utils drop-table mydb.db mytable

       Use <b>--ignore</b> to ignore the error if the table does not exist.

   <b>Transforming</b> <b>tables</b>
       The <b>transform</b> command allows you to apply complex transformations to a table that cannot  be  implemented
       using  a  regular SQLite <b>ALTER</b> <b>TABLE</b> command. See <u>Transforming</u> <u>a</u> <u>table</u> for details of how this works. The
       <b>transform</b> command preserves a table's <b>STRICT</b> mode.

          sqlite-utils transform mydb.db mytable \
              --drop column1 \
              --rename column2 column_renamed

       Every option for this table (with the exception of  <b>--pk-none</b>)  can  be  specified  multiple  times.  The
       options are as follows:

       <b>--type</b> <b>column-name</b> <b>new-type</b>
              Change the type of the specified column. Valid types are <b>integer</b>, <b>text</b>, <b>float</b>, <b>blob</b>.

       <b>--drop</b> <b>column-name</b>
              Drop the specified column.

       <b>--rename</b> <b>column-name</b> <b>new-name</b>
              Rename this column to a new name.

       <b>--column-order</b> <b>column</b>
              Use this multiple times to specify a new order for your columns. <b>-o</b> shortcut is also available.

       <b>--not-null</b> <b>column-name</b>
              Set this column as <b>NOT</b> <b>NULL</b>.

       <b>--not-null-false</b> <b>column-name</b>
              For a column that is currently set as <b>NOT</b> <b>NULL</b>, remove the <b>NOT</b> <b>NULL</b>.

       <b>--pk</b> <b>column-name</b>
              Change  the  primary  key  column for this table. Pass <b>--pk</b> multiple times if you want to create a
              compound primary key.

       <b>--pk-none</b>
              Remove the primary key from this table, turning it into a <b>rowid</b> table.

       <b>--default</b> <b>column-name</b> <b>value</b>
              Set the default value of this column.

       <b>--default-none</b> <b>column</b>
              Remove the default value for this column.

       <b>--drop-foreign-key</b> <b>column</b>
              Drop the specified foreign key.

       <b>--add-foreign-key</b> <b>column</b> <b>other_table</b> <b>other_column</b>
              Add a foreign key constraint to <b>column</b> pointing to <b>other_table.other_column</b>.

       If you want to see the SQL that will be executed to make the change without actually  executing  it,  add
       the <b>--sql</b> flag. For example:

          sqlite-utils transform fixtures.db roadside_attractions \
              --rename pk id \
              --default name Untitled \
              --column-order id \
              --column-order longitude \
              --column-order latitude \
              --drop address \
              --sql

          CREATE TABLE [roadside_attractions_new_4033a60276b9] (
             [id] INTEGER PRIMARY KEY,
             [longitude] FLOAT,
             [latitude] FLOAT,
             [name] TEXT DEFAULT 'Untitled'
          );
          INSERT INTO [roadside_attractions_new_4033a60276b9] ([longitude], [latitude], [id], [name])
             SELECT [longitude], [latitude], [pk], [name] FROM [roadside_attractions];
          DROP TABLE [roadside_attractions];
          ALTER TABLE [roadside_attractions_new_4033a60276b9] RENAME TO [roadside_attractions];

   <b>Adding</b> <b>a</b> <b>primary</b> <b>key</b> <b>to</b> <b>a</b> <b>rowid</b> <b>table</b>
       SQLite  tables  that  are created without an explicit primary key are created as <u>rowid</u> <u>tables</u>. They still
       have a numeric primary key which is available in the <b>rowid</b> column, but that column is not included in the
       output of <b>select</b> <b>*</b>. Here's an example:

          echo '[{"name": "Azi"}, {"name": "Suna"}]' | \
              sqlite-utils insert chickens.db chickens -
          sqlite-utils schema chickens.db

          CREATE TABLE [chickens] (
             [name] TEXT
          );

          sqlite-utils chickens.db 'select * from chickens'

          [{"name": "Azi"},
           {"name": "Suna"}]

          sqlite-utils chickens.db 'select rowid, * from chickens'

          [{"rowid": 1, "name": "Azi"},
           {"rowid": 2, "name": "Suna"}]

       You can use <b>sqlite-utils</b> <b>transform</b> <b>...</b> <b>--pk</b> <b>id</b> to add a primary key column called <b>id</b> to  the  table.  The
       primary key will be created as an <b>INTEGER</b> <b>PRIMARY</b> <b>KEY</b> and the existing <b>rowid</b> values will be copied across
       to it. It will automatically increment as new rows are added to the table:

          sqlite-utils transform chickens.db chickens --pk id

          sqlite-utils schema chickens.db

          CREATE TABLE "chickens" (
             [id] INTEGER PRIMARY KEY,
             [name] TEXT
          );

          sqlite-utils chickens.db 'select * from chickens'

          [{"id": 1, "name": "Azi"},
           {"id": 2, "name": "Suna"}]

          echo '{"name": "Cardi"}' | sqlite-utils insert chickens.db chickens -

          sqlite-utils chickens.db 'select * from chickens'

          [{"id": 1, "name": "Azi"},
           {"id": 2, "name": "Suna"},
           {"id": 3, "name": "Cardi"}]

   <b>Extracting</b> <b>columns</b> <b>into</b> <b>a</b> <b>separate</b> <b>table</b>
       The <b>sqlite-utils</b> <b>extract</b> command can be used to extract specified columns into a separate table.

       Take  a  look at the Python API documentation for <u>Extracting</u> <u>columns</u> <u>into</u> <u>a</u> <u>separate</u> <u>table</u> for a detailed
       description of how this works, including examples of table schemas before and after running an extraction
       operation.

       The command takes a database, table and one or more columns that should  be  extracted.  To  extract  the
       <b>species</b> column from the <b>trees</b> table you would run:

          sqlite-utils extract my.db trees species

       This would produce the following schema:

          CREATE TABLE "trees" (
              [id] INTEGER PRIMARY KEY,
              [TreeAddress] TEXT,
              [species_id] INTEGER,
              FOREIGN KEY(species_id) REFERENCES species(id)
          );
          CREATE TABLE [species] (
              [id] INTEGER PRIMARY KEY,
              [species] TEXT
          );
          CREATE UNIQUE INDEX [idx_species_species]
              ON [species] ([species]);

       The command takes the following options:

       <b>--table</b> <b>TEXT</b>
              The  name of the lookup to extract columns to. This defaults to using the name of the columns that
              are being extracted.

       <b>--fk-column</b> <b>TEXT</b>
              The name of the foreign key column to add to the table. Defaults to <b>columnname_id</b>.

       <b>--rename</b> <b>&lt;TEXT</b> <b>TEXT&gt;</b>
              Use this option to rename the columns created in the new lookup table.

       <b>--silent</b>
              Don't display the progress bar.

       Here's a more complex example that makes use of these options. It converts <u>this</u> <u>CSV</u> <u>file</u> full  of  global
       power  plants  into  SQLite, then extracts the <b>country</b> and <b>country_long</b> columns into a separate <b>countries</b>
       table:

          wget 'https://github.com/wri/global-power-plant-database/blob/232a6666/output_database/global_power_plant_database.csv?raw=true'
          sqlite-utils insert global.db power_plants \
              'global_power_plant_database.csv?raw=true' --csv
          # Extract those columns:
          sqlite-utils extract global.db power_plants country country_long \
              --table countries \
              --fk-column country_id \
              --rename country_long name

       After running the above, the command <b>sqlite-utils</b> <b>schema</b> <b>global.db</b> reveals the following schema:

          CREATE TABLE [countries] (
             [id] INTEGER PRIMARY KEY,
             [country] TEXT,
             [name] TEXT
          );
          CREATE TABLE "power_plants" (
             [country_id] INTEGER,
             [name] TEXT,
             [gppd_idnr] TEXT,
             [capacity_mw] TEXT,
             [latitude] TEXT,
             [longitude] TEXT,
             [primary_fuel] TEXT,
             [other_fuel1] TEXT,
             [other_fuel2] TEXT,
             [other_fuel3] TEXT,
             [commissioning_year] TEXT,
             [owner] TEXT,
             [source] TEXT,
             [url] TEXT,
             [geolocation_source] TEXT,
             [wepp_id] TEXT,
             [year_of_capacity_data] TEXT,
             [generation_gwh_2013] TEXT,
             [generation_gwh_2014] TEXT,
             [generation_gwh_2015] TEXT,
             [generation_gwh_2016] TEXT,
             [generation_gwh_2017] TEXT,
             [generation_data_source] TEXT,
             [estimated_generation_gwh] TEXT,
             FOREIGN KEY([country_id]) REFERENCES [countries]([id])
          );
          CREATE UNIQUE INDEX [idx_countries_country_name]
              ON [countries] ([country], [name]);

   <b>Creating</b> <b>views</b>
       You can create a view using the <b>create-view</b> command:

          sqlite-utils create-view mydb.db version "select sqlite_version()"

          sqlite-utils mydb.db "select * from version"

          [{"sqlite_version()": "3.31.1"}]

       Use <b>--replace</b> to replace an existing view of the same name, and <b>--ignore</b> to do nothing if a view  already
       exists.

   <b>Dropping</b> <b>views</b>
       You can drop a view using the <b>drop-view</b> command:

          sqlite-utils drop-view myview

       Use <b>--ignore</b> to ignore the error if the view does not exist.

   <b>Adding</b> <b>columns</b>
       You can add a column using the <b>add-column</b> command:

          sqlite-utils add-column mydb.db mytable nameofcolumn text

       The last argument here is the type of the column to be created. This can be one of:

       • <b>text</b> or <b>str</b>

       • <b>integer</b> or <b>int</b>

       • <b>float</b>

       • <b>blob</b> or <b>bytes</b>

       This argument is optional and defaults to <b>text</b>.

       You can add a column that is a foreign key reference to another table using the <b>--fk</b> option:

          sqlite-utils add-column mydb.db dogs species_id --fk species

       This  will  automatically  detect  the name of the primary key on the species table and use that (and its
       type) for the new column.

       You can explicitly specify the column you wish to reference using <b>--fk-col</b>:

          sqlite-utils add-column mydb.db dogs species_id --fk species --fk-col ref

       You can set a <b>NOT</b> <b>NULL</b> <b>DEFAULT</b> <b>'x'</b> constraint on the new column using <b>--not-null-default</b>:

          sqlite-utils add-column mydb.db dogs friends_count integer --not-null-default 0

   <b>Adding</b> <b>columns</b> <b>automatically</b> <b>on</b> <b>insert/update</b>
       You can use the <b>--alter</b> option to automatically add  new  columns  if  the  data  you  are  inserting  or
       upserting is of a different shape:

          sqlite-utils insert dogs.db dogs new-dogs.json --pk=id --alter

   <b>Adding</b> <b>foreign</b> <b>key</b> <b>constraints</b>
       The  <b>add-foreign-key</b>  command  can  be  used  to  add  new  foreign key references to an existing table -
       something which SQLite's <b>ALTER</b> <b>TABLE</b> command does not support.

       To add a foreign key constraint pointing the <b>books.author_id</b> column to <b>authors.id</b> in  another  table,  do
       this:

          sqlite-utils add-foreign-key books.db books author_id authors id

       If  you omit the other table and other column references <b>sqlite-utils</b> will attempt to guess them - so the
       above example could instead look like this:

          sqlite-utils add-foreign-key books.db books author_id

       Add <b>--ignore</b> to ignore an existing foreign key (as opposed to returning an error):

          sqlite-utils add-foreign-key books.db books author_id --ignore

       See <u>Adding</u> <u>foreign</u> <u>key</u> <u>constraints</u> in the Python API documentation for further details, including how the
       automatic table guessing mechanism works.

   <b>Adding</b> <b>multiple</b> <b>foreign</b> <b>keys</b> <b>at</b> <b>once</b>
       Adding a foreign key requires a <b>VACUUM</b>. On large databases this can be an expensive operation, so if  you
       are  adding  multiple  foreign  keys you can combine them into one operation (and hence one <b>VACUUM</b>) using
       <b>add-foreign-keys</b>:

          sqlite-utils add-foreign-keys books.db \
              books author_id authors id \
              authors country_id countries id

       When you are using this command each foreign key needs to be defined in full, as  four  arguments  -  the
       table, column, other table and other column.

   <b>Adding</b> <b>indexes</b> <b>for</b> <b>all</b> <b>foreign</b> <b>keys</b>
       If  you  want to ensure that every foreign key column in your database has a corresponding index, you can
       do so like this:

          sqlite-utils index-foreign-keys books.db

   <b>Setting</b> <b>defaults</b> <b>and</b> <b>not</b> <b>null</b> <b>constraints</b>
       You can use the <b>--not-null</b> and <b>--default</b> options (to both <b>insert</b> and  <b>upsert</b>)  to  specify  columns  that
       should be <b>NOT</b> <b>NULL</b> or to set database defaults for one or more specific columns:

          sqlite-utils insert dogs.db dogs_with_scores dogs-with-scores.json \
              --not-null=age \
              --not-null=name \
              --default age 2 \
              --default score 5

   <b>Creating</b> <b>indexes</b>
       You can add an index to an existing table using the <b>create-index</b> command:

          sqlite-utils create-index mydb.db mytable col1 [col2...]

       This can be used to create indexes against a single column or multiple columns.

       The  name  of  the index will be automatically derived from the table and columns. To specify a different
       name, use <b>--name=name_of_index</b>.

       Use the <b>--unique</b> option to create a unique index.

       Use <b>--if-not-exists</b> to avoid attempting to create the index if one with that name already exists.

       To add an index on a column in descending order, prefix the column with  a  hyphen.  Since  this  can  be
       confused for a command-line option you need to construct that like this:

          sqlite-utils create-index mydb.db mytable -- col1 -col2 col3

       This will create an index on that table on <b>(col1,</b> <b>col2</b> <b>desc,</b> <b>col3)</b>.

       If  your  column  names are already prefixed with a hyphen you'll need to manually execute a <b>CREATE</b> <b>INDEX</b>
       SQL statement to add indexes to them rather than using this tool.

       Add the <b>--analyze</b> option to run <b>ANALYZE</b> against the index after it has been created.

   <b>Configuring</b> <b>full-text</b> <b>search</b>
       You can enable SQLite full-text search on a table and a set of columns like this:

          sqlite-utils enable-fts mydb.db documents title summary

       This will use SQLite's FTS5 module by default. Use <b>--fts4</b> if you want to use FTS4:

          sqlite-utils enable-fts mydb.db documents title summary --fts4

       The <b>enable-fts</b> command will populate the new index with all existing documents. If  you  later  add  more
       documents you will need to use <b>populate-fts</b> to cause them to be indexed as well:

          sqlite-utils populate-fts mydb.db documents title summary

       A  better  solution  here  is to use database triggers. You can set up database triggers to automatically
       update the full-text index using the <b>--create-triggers</b> option when you first run <b>enable-fts</b>:

          sqlite-utils enable-fts mydb.db documents title summary --create-triggers

       To set a custom FTS tokenizer, e.g. to enable Porter stemming, use <b>--tokenize=</b>:

          sqlite-utils populate-fts mydb.db documents title summary --tokenize=porter

       To remove the FTS tables and triggers you created, use <b>disable-fts</b>:

          sqlite-utils disable-fts mydb.db documents

       To rebuild one or more FTS tables (see <u>Rebuilding</u> <u>a</u> <u>full-text</u> <u>search</u> <u>table</u>), use <b>rebuild-fts</b>:

          sqlite-utils rebuild-fts mydb.db documents

       You can rebuild every FTS table by running <b>rebuild-fts</b> without passing any table names:

          sqlite-utils rebuild-fts mydb.db

   <b>Executing</b> <b>searches</b>
       Once you have configured full-text search for a table, you can search it using <b>sqlite-utils</b> <b>search</b>:

          sqlite-utils search mydb.db documents searchterm

       This command accepts the same output options as <b>sqlite-utils</b> <b>query</b>: <b>--table</b>, <b>--csv</b>, <b>--tsv</b>, <b>--nl</b> etc.

       By default it shows the most relevant matches first. You can specify a different sort order using the  <b>-o</b>
       option, which can take a column or a column followed by <b>desc</b>:

          # Sort by rowid
          sqlite-utils search mydb.db documents searchterm -o rowid
          # Sort by created in descending order
          sqlite-utils search mydb.db documents searchterm -o 'created desc'

       SQLite  <u>advanced</u>  <u>search</u>  <u>syntax</u> is enabled by default. To run a search with automatic quoting applied to
       the terms to avoid them being potentially interpreted as advanced search syntax use the <b>--quote</b> option.

       You can specify a subset of columns to be returned using the <b>-c</b> option one or more times:

          sqlite-utils search mydb.db documents searchterm -c title -c created

       By default all search results will be returned. You can use <b>--limit</b>  <b>20</b>  to  return  just  the  first  20
       results.

       Use the <b>--sql</b> option to output the SQL that would be executed, rather than running the query:

          sqlite-utils search mydb.db documents searchterm --sql

          with original as (
              select
                  rowid,
                  *
              from [documents]
          )
          select
              [original].*
          from
              [original]
              join [documents_fts] on [original].rowid = [documents_fts].rowid
          where
              [documents_fts] match :query
          order by
              [documents_fts].rank

   <b>Enabling</b> <b>cached</b> <b>counts</b>
       <b>select</b>  <b>count(*)</b>  queries  can  take a long time against large tables. <b>sqlite-utils</b> can speed these up by
       adding triggers to maintain a <b>_counts</b> table, see <u>Cached</u> <u>table</u> <u>counts</u> <u>using</u> <u>triggers</u> for details.

       The <b>sqlite-utils</b> <b>enable-counts</b> command can be used to configure these triggers, either for every table in
       the database or for specific tables.

          # Configure triggers for every table in the database
          sqlite-utils enable-counts mydb.db

          # Configure triggers just for specific tables
          sqlite-utils enable-counts mydb.db table1 table2

       If the <b>_counts</b> table ever becomes out-of-sync with the actual table counts you can repair  it  using  the
       <b>reset-counts</b> command:

          sqlite-utils reset-counts mydb.db

   <b>Optimizing</b> <b>index</b> <b>usage</b> <b>with</b> <b>ANALYZE</b>
       The  <u>SQLite</u>  <u>ANALYZE</u>  <u>command</u> builds a table of statistics which the query planner can use to make better
       decisions about which indexes to use for a given query.

       You should run <b>ANALYZE</b> if your database is large and you do not think your indexes are being  efficiently
       used.

       To run <b>ANALYZE</b> against every index in a database, use this:

          sqlite-utils analyze mydb.db

       You  can  run  it against specific tables, or against specific named indexes, by passing them as optional
       arguments:

          sqlite-utils analyze mydb.db mytable idx_mytable_name

       You can also run <b>ANALYZE</b> as part of another command using the <b>--analyze</b> option. This is supported by  the
       <b>create-index</b>, <b>insert</b> and <b>upsert</b> commands.

   <b>Vacuum</b>
       You can run VACUUM to optimize your database like so:

          sqlite-utils vacuum mydb.db

   <b>Optimize</b>
       The  optimize command can dramatically reduce the size of your database if you are using SQLite full-text
       search. It runs OPTIMIZE against all of your FTS4 and FTS5 tables, then runs VACUUM.

       If you just want to run OPTIMIZE without the VACUUM, use the <b>--no-vacuum</b> flag.

          # Optimize all FTS tables and then VACUUM
          sqlite-utils optimize mydb.db

          # Optimize but skip the VACUUM
          sqlite-utils optimize --no-vacuum mydb.db

       To optimize specific tables rather than every FTS table, pass those tables as extra arguments:

          sqlite-utils optimize mydb.db table_1 table_2

   <b>WAL</b> <b>mode</b>
       You can enable <u>Write-Ahead</u> <u>Logging</u> for a database file using the <b>enable-wal</b> command:

          sqlite-utils enable-wal mydb.db

       You can disable WAL mode using <b>disable-wal</b>:

          sqlite-utils disable-wal mydb.db

       Both of these commands accept one or more database files as arguments.

   <b>Dumping</b> <b>the</b> <b>database</b> <b>to</b> <b>SQL</b>
       The <b>dump</b> command outputs a SQL dump of the schema and full contents of the specified database file:

          sqlite-utils dump mydb.db
          BEGIN TRANSACTION;
          CREATE TABLE ...
          ...
          COMMIT;

   <b>Loading</b> <b>SQLite</b> <b>extensions</b>
       Many  of  these  commands  have  the  ability  to   load   additional   SQLite   extensions   using   the
       <b>--load-extension=/path/to/extension</b>  option  -  use  <b>--help</b>  to check for support, e.g. <b>sqlite-utils</b> <b>rows</b>
       <b>--help</b>.

       This option can be applied multiple times to load multiple extensions.

       Since <u>SpatiaLite</u> is commonly used with SQLite, the value  <b>spatialite</b>  is  special:  it  will  search  for
       SpatiaLite  in  the most common installation locations, saving you from needing to remember exactly where
       that module is located:

          sqlite-utils memory "select spatialite_version()" --load-extension=spatialite

          [{"spatialite_version()": "4.3.0a"}]

   <b>SpatiaLite</b> <b>helpers</b>
       <u>SpatiaLite</u> adds geographic capability to SQLite (similar to how PostGIS  builds  on  PostgreSQL).  The  ‐
       <u>SpatiaLite</u> <u>cookbook</u> is a good resource for learning what's possible with it.

       You can convert an existing table to a geographic table by adding a geometry column, use the <b>sqlite-utils</b>
       <b>add-geometry-column</b> command:

          sqlite-utils add-geometry-column spatial.db locations geometry --type POLYGON --srid 4326

       The  table  (<b>locations</b>  in  the  example  above)  must already exist before adding a geometry column. Use
       <b>sqlite-utils</b> <b>create-table</b> first, then <b>add-geometry-column</b>.

       Use the <b>--type</b> option to specify  a  geometry  type.  By  default,  <b>add-geometry-column</b>  uses  a  generic
       <b>GEOMETRY</b>, which will work with any type, though it may not be supported by some desktop GIS applications.

       Eight (case-insensitive) types are allowed:

       • POINT

       • LINESTRING

       • POLYGON

       • MULTIPOINT

       • MULTILINESTRING

       • MULTIPOLYGON

       • GEOMETRYCOLLECTION

       • GEOMETRY

   <b>Adding</b> <b>spatial</b> <b>indexes</b>
       Once you have a geometry column, you can speed up bounding box queries by adding a spatial index:

          sqlite-utils create-spatial-index spatial.db locations geometry

       See this <u>SpatiaLite</u> <u>Cookbook</u> <u>recipe</u> for examples of how to use a spatial index.

   <b>Installing</b> <b>packages</b>
       The  <u>convert</u>  <u>command</u>  and  the  <u>insert</u>  <u>-\-convert</u> and <u>query</u> <u>-\-functions</u> options can be provided with a
       Python script that imports additional modules from the <b>sqlite-utils</b> environment.

       You can install packages from PyPI directly into  the  correct  environment  using  <b>sqlite-utils</b>  <b>install</b>
       <b>&lt;package&gt;</b>. This is a wrapper around <b>pip</b> <b>install</b>.

          sqlite-utils install beautifulsoup4

       Use <b>-U</b> to upgrade an existing package.

   <b>Uninstalling</b> <b>packages</b>
       You  can  uninstall  packages  that were installed using <b>sqlite-utils</b> <b>install</b> with <b>sqlite-utils</b> <b>uninstall</b>
       <b>&lt;package&gt;</b>:

          sqlite-utils uninstall beautifulsoup4

       Use <b>-y</b> to skip the request for confirmation.

   <b>Experimental</b> <b>TUI</b>
       A TUI is a "text user interface" (or "terminal user interface") - a keyboard and mouse  driven  graphical
       interface running in your terminal.

       <b>sqlite-utils</b>  has  experimental  support for a TUI for building command-line invocations, built on top of
       the <u>Trogon</u> TUI library.

       To enable this feature you will need to install the <b>trogon</b> dependency. You can do that like so:

          sqlite-utils install trogon

       Once installed, running the <b>sqlite-utils</b> <b>tui</b> command will launch the TUI interface:

          sqlite-utils tui

       You can then construct a command by selecting options from  the  menus,  and  execute  it  using  <b>Ctrl+R</b>.
       [image:  A  TUI  interface  for  sqlite-utils - the left column shows a list of commands, while the right
       panel has a form for constructing arguments to the add-column command.]  [image]

   <b>sqlite_utils</b> <b>Python</b> <b>library</b>
       • <u>Getting</u> <u>started</u>

       • <u>Connecting</u> <u>to</u> <u>or</u> <u>creating</u> <u>a</u> <u>database</u>

         • <u>Attaching</u> <u>additional</u> <u>databases</u>

         • <u>Tracing</u> <u>queries</u>

       • <u>Executing</u> <u>queries</u>

         • <u>db.query(sql,</u> <u>params)</u>

         • <u>db.execute(sql,</u> <u>params)</u>

         • <u>Passing</u> <u>parameters</u>

       • <u>Accessing</u> <u>tables</u>

       • <u>Listing</u> <u>tables</u>

       • <u>Listing</u> <u>views</u>

       • <u>Listing</u> <u>rows</u>

         • <u>Counting</u> <u>rows</u>

       • <u>Listing</u> <u>rows</u> <u>with</u> <u>their</u> <u>primary</u> <u>keys</u>

       • <u>Retrieving</u> <u>a</u> <u>specific</u> <u>record</u>

       • <u>Showing</u> <u>the</u> <u>schema</u>

       • <u>Creating</u> <u>tables</u>

         • <u>Custom</u> <u>column</u> <u>order</u> <u>and</u> <u>column</u> <u>types</u>

         • <u>Explicitly</u> <u>creating</u> <u>a</u> <u>table</u>

         • <u>Compound</u> <u>primary</u> <u>keys</u>

         • <u>Specifying</u> <u>foreign</u> <u>keys</u>

         • <u>Table</u> <u>configuration</u> <u>options</u>

         • <u>Setting</u> <u>defaults</u> <u>and</u> <u>not</u> <u>null</u> <u>constraints</u>

       • <u>Renaming</u> <u>a</u> <u>table</u>

       • <u>Duplicating</u> <u>tables</u>

       • <u>Bulk</u> <u>inserts</u>

       • <u>Insert-replacing</u> <u>data</u>

       • <u>Updating</u> <u>a</u> <u>specific</u> <u>record</u>

       • <u>Deleting</u> <u>a</u> <u>specific</u> <u>record</u>

       • <u>Deleting</u> <u>multiple</u> <u>records</u>

       • <u>Upserting</u> <u>data</u>

       • <u>Converting</u> <u>data</u> <u>in</u> <u>columns</u>

       • <u>Working</u> <u>with</u> <u>lookup</u> <u>tables</u>

         • <u>Creating</u> <u>lookup</u> <u>tables</u> <u>explicitly</u>

         • <u>Populating</u> <u>lookup</u> <u>tables</u> <u>automatically</u> <u>during</u> <u>insert/upsert</u>

       • <u>Working</u> <u>with</u> <u>many-to-many</u> <u>relationships</u>

         • <u>Using</u> <u>m2m</u> <u>and</u> <u>lookup</u> <u>tables</u> <u>together</u>

       • <u>Analyzing</u> <u>a</u> <u>column</u>

       • <u>Adding</u> <u>columns</u>

       • <u>Adding</u> <u>columns</u> <u>automatically</u> <u>on</u> <u>insert/update</u>

       • <u>Adding</u> <u>foreign</u> <u>key</u> <u>constraints</u>

         • <u>Adding</u> <u>multiple</u> <u>foreign</u> <u>key</u> <u>constraints</u> <u>at</u> <u>once</u>

         • <u>Adding</u> <u>indexes</u> <u>for</u> <u>all</u> <u>foreign</u> <u>keys</u>

       • <u>Dropping</u> <u>a</u> <u>table</u> <u>or</u> <u>view</u>

       • <u>Transforming</u> <u>a</u> <u>table</u>

         • <u>Altering</u> <u>column</u> <u>types</u>

         • <u>Renaming</u> <u>columns</u>

         • <u>Dropping</u> <u>columns</u>

         • <u>Changing</u> <u>primary</u> <u>keys</u>

         • <u>Changing</u> <u>not</u> <u>null</u> <u>status</u>

         • <u>Altering</u> <u>column</u> <u>defaults</u>

         • <u>Changing</u> <u>column</u> <u>order</u>

         • <u>Adding</u> <u>foreign</u> <u>key</u> <u>constraints</u>

         • <u>Replacing</u> <u>foreign</u> <u>key</u> <u>constraints</u>

         • <u>Dropping</u> <u>foreign</u> <u>key</u> <u>constraints</u>

         • <u>Custom</u> <u>transformations</u> <u>with</u> <u>.transform_sql()</u>

       • <u>Extracting</u> <u>columns</u> <u>into</u> <u>a</u> <u>separate</u> <u>table</u>

       • <u>Setting</u> <u>an</u> <u>ID</u> <u>based</u> <u>on</u> <u>the</u> <u>hash</u> <u>of</u> <u>the</u> <u>row</u> <u>contents</u>

       • <u>Creating</u> <u>views</u>

       • <u>Storing</u> <u>JSON</u>

       • <u>Converting</u> <u>column</u> <u>values</u> <u>using</u> <u>SQL</u> <u>functions</u>

       • <u>Checking</u> <u>the</u> <u>SQLite</u> <u>version</u>

       • <u>Dumping</u> <u>the</u> <u>database</u> <u>to</u> <u>SQL</u>

       • <u>Introspecting</u> <u>tables</u> <u>and</u> <u>views</u>

         • <u>.exists()</u>

         • <u>.count</u>

         • <u>.columns</u>

         • <u>.columns_dict</u>

         • <u>.default_values</u>

         • <u>.pks</u>

         • <u>.use_rowid</u>

         • <u>.foreign_keys</u>

         • <u>.schema</u>

         • <u>.strict</u>

         • <u>.indexes</u>

         • <u>.xindexes</u>

         • <u>.triggers</u>

         • <u>.triggers_dict</u>

         • <u>.detect_fts()</u>

         • <u>.virtual_table_using</u>

         • <u>.has_counts_triggers</u>

         • <u>db.supports_strict</u>

       • <u>Full-text</u> <u>search</u>

         • <u>Enabling</u> <u>full-text</u> <u>search</u> <u>for</u> <u>a</u> <u>table</u>

         • <u>Quoting</u> <u>characters</u> <u>for</u> <u>use</u> <u>in</u> <u>search</u>

         • <u>Searching</u> <u>with</u> <u>table.search()</u>

         • <u>Building</u> <u>SQL</u> <u>queries</u> <u>with</u> <u>table.search_sql()</u>

       • <u>Rebuilding</u> <u>a</u> <u>full-text</u> <u>search</u> <u>table</u>

       • <u>Optimizing</u> <u>a</u> <u>full-text</u> <u>search</u> <u>table</u>

       • <u>Cached</u> <u>table</u> <u>counts</u> <u>using</u> <u>triggers</u>

       • <u>Creating</u> <u>indexes</u>

       • <u>Optimizing</u> <u>index</u> <u>usage</u> <u>with</u> <u>ANALYZE</u>

       • <u>Vacuum</u>

       • <u>WAL</u> <u>mode</u>

       • <u>Suggesting</u> <u>column</u> <u>types</u>

       • <u>Registering</u> <u>custom</u> <u>SQL</u> <u>functions</u>

       • <u>Quoting</u> <u>strings</u> <u>for</u> <u>use</u> <u>in</u> <u>SQL</u>

       • <u>Reading</u> <u>rows</u> <u>from</u> <u>a</u> <u>file</u>

       • <u>Setting</u> <u>the</u> <u>maximum</u> <u>CSV</u> <u>field</u> <u>size</u> <u>limit</u>

       • <u>Detecting</u> <u>column</u> <u>types</u> <u>using</u> <u>TypeTracker</u>

       • <u>SpatiaLite</u> <u>helpers</u>

         • <u>Initialize</u> <u>SpatiaLite</u>

         • <u>Finding</u> <u>SpatiaLite</u>

         • <u>Adding</u> <u>geometry</u> <u>columns</u>

         • <u>Creating</u> <u>a</u> <u>spatial</u> <u>index</u>

   <b>Getting</b> <b>started</b>
       Here's how to create a new SQLite database file containing a new  <b>chickens</b>  table,  populated  with  four
       records:

          from sqlite_utils import Database

          db = Database("chickens.db")
          db["chickens"].insert_all([{
              "name": "Azi",
              "color": "blue",
          }, {
              "name": "Lila",
              "color": "blue",
          }, {
              "name": "Suna",
              "color": "gold",
          }, {
              "name": "Cardi",
              "color": "black",
          }])

       You can loop through those rows like this:

          for row in db["chickens"].rows:
              print(row)

       Which outputs the following:

          {'name': 'Azi', 'color': 'blue'}
          {'name': 'Lila', 'color': 'blue'}
          {'name': 'Suna', 'color': 'gold'}
          {'name': 'Cardi', 'color': 'black'}

       To run a SQL query, use <u>db.query()</u>:

          for row in db.query("""
              select color, count(*)
              from chickens group by color
              order by count(*) desc
          """):
              print(row)

       Which outputs:

          {'color': 'blue', 'count(*)': 2}
          {'color': 'gold', 'count(*)': 1}
          {'color': 'black', 'count(*)': 1}

   <b>Connecting</b> <b>to</b> <b>or</b> <b>creating</b> <b>a</b> <b>database</b>
       Database  objects  are  constructed  by passing in either a path to a file on disk or an existing SQLite3
       database connection:

          from sqlite_utils import Database

          db = Database("my_database.db")

       This will create <b>my_database.db</b> if it does not already exist.

       If you want to recreate a database from scratch (first removing the existing file from disk if it already
       exists) you can use the <b>recreate=True</b> argument:

          db = Database("my_database.db", recreate=True)

       Instead of a file path you can pass in an existing SQLite connection:

          import sqlite3

          db = Database(sqlite3.connect("my_database.db"))

       If you want to create an in-memory database, you can do so like this:

          db = Database(memory=True)

       You can also create a named in-memory database. Unlike regular memory databases these can be accessed  by
       multiple  threads,  provided  at  least one reference to the database still exists. <u>del</u> <u>db</u> will clear the
       database from memory.

          db = Database(memory_name="my_shared_database")

       Connections use <b>PRAGMA</b> <b>recursive_triggers=on</b> by default. If you don't want to use <u>recursive</u> <u>triggers</u>  you
       can turn them off using:

          db = Database(memory=True, recursive_triggers=False)

       By  default,  any  <u>sqlite-utils</u> <u>plugins</u> that implement the <u>prepare_connection(conn)</u> hook will be executed
       against the connection when you create the <b>Database</b> object. You can opt out of  executing  plugins  using
       <b>execute_plugins=False</b> like this:

          db = Database(memory=True, execute_plugins=False)

       You can pass <b>strict=True</b> to enable <u>SQLite</u> <u>STRICT</u> <u>mode</u> for all tables created using this database object:

          db = Database("my_database.db", strict=True)

   <b>Attaching</b> <b>additional</b> <b>databases</b>
       SQLite  supports  cross-database  SQL  queries, which can join data from tables in more than one database
       file.

       You can attach an additional database using the <b>.attach()</b> method, providing an  alias  to  use  for  that
       database and the path to the SQLite file on disk.

          db = Database("first.db")
          db.attach("second", "second.db")
          # Now you can run queries like this one:
          print(db.query("""
          select * from table_in_first
              union all
          select * from second.table_in_second
          """))

       You  can  reference  tables in the attached database using the alias value you passed to <b>db.attach(alias,</b>
       <b>filepath)</b> as a prefix, for example the <b>second.table_in_second</b> reference in the SQL query above.

   <b>Tracing</b> <b>queries</b>
       You can use the <b>tracer</b> mechanism to see SQL queries that are being executed by  SQLite.  A  tracer  is  a
       function  that you provide which will be called with <b>sql</b> and <b>params</b> arguments every time SQL is executed,
       for example:

          def tracer(sql, params):
              print("SQL: {} - params: {}".format(sql, params))

       You can pass this function to the <b>Database()</b> constructor like so:

          db = Database(memory=True, tracer=tracer)

       You can also turn on a tracer function temporarily for a block of  code  using  the  <b>with</b>  <b>db.tracer(...)</b>
       context manager:

          db = Database(memory=True)
          # ... later
          with db.tracer(print):
              db["dogs"].insert({"name": "Cleo"})

       This example will print queries only for the duration of the <b>with</b> block.

   <b>Executing</b> <b>queries</b>
       The <b>Database</b> class offers several methods for directly executing SQL queries.

   <b>db.query(sql,</b> <b>params)</b>
       The  <b>db.query(sql)</b>  function  executes  a  SQL  query  and  returns  an iterator over Python dictionaries
       representing the resulting rows:

          db = Database(memory=True)
          db["dogs"].insert_all([{"name": "Cleo"}, {"name": "Pancakes"}])
          for row in db.query("select * from dogs"):
              print(row)
          # Outputs:
          # {'name': 'Cleo'}
          # {'name': 'Pancakes'}

   <b>db.execute(sql,</b> <b>params)</b>
       The <b>db.execute()</b> and <b>db.executescript()</b> methods provide wrappers around <b>.execute()</b>  and  <b>.executescript()</b>
       on  the  underlying  SQLite  connection.  These  wrappers  log  to  the  <u>tracer</u>  <u>function</u> if one has been
       registered.

       <b>db.execute(sql)</b> returns a <u>sqlite3.Cursor</u> that was used to execute the SQL.

          db = Database(memory=True)
          db["dogs"].insert({"name": "Cleo"})
          cursor = db.execute("update dogs set name = 'Cleopaws'")
          print(cursor.rowcount)
          # Outputs the number of rows affected by the update
          # In this case 2

       Other cursor methods such as <b>.fetchone()</b> and <b>.fetchall()</b> are also available,  see  the  <u>standard</u>  <u>library</u>
       <u>documentation</u>.

   <b>Passing</b> <b>parameters</b>
       Both  <b>db.query()</b>  and  <b>db.execute()</b> accept an optional second argument for parameters to be passed to the
       SQL query.

       This can take the form of either a tuple/list or a dictionary, depending on the type of  parameters  used
       in the query. Values passed in this way will be correctly quoted and escaped, helping avoid SQL injection
       vulnerabilities.

       <b>?</b> parameters in the SQL query can be filled in using a list:

          db.execute("update dogs set name = ?", ["Cleopaws"])
          # This will rename ALL dogs to be called "Cleopaws"

       Named parameters using <b>:name</b> can be filled using a dictionary:

          dog = next(db.query(
              "select rowid, name from dogs where name = :name",
              {"name": "Cleopaws"}
          ))
          # dog is now {'rowid': 1, 'name': 'Cleopaws'}

       In  this  example  <b>next()</b> is used to retrieve the first result in the iterator returned by the <b>db.query()</b>
       method.

   <b>Accessing</b> <b>tables</b>
       Tables are accessed using the indexing operator, like so:

          table = db["my_table"]

       If the table does not yet exist, it will be created the first time you attempt to insert or  upsert  data
       into it.

       You can also access tables using the <b>.table()</b> method like so:

          table = db.table("my_table")

       Using this factory function allows you to set <u>Table</u> <u>configuration</u> <u>options</u>.

   <b>Listing</b> <b>tables</b>
       You can list the names of tables in a database using the <b>.table_names()</b> method:

          &gt;&gt;&gt; db.table_names()
          ['dogs']

       To see just the FTS4 tables, use <b>.table_names(fts4=True)</b>. For FTS5, use <b>.table_names(fts5=True)</b>.

       You can also iterate through the table objects themselves using the <b>.tables</b> property:

          &gt;&gt;&gt; db.tables
          [&lt;Table dogs&gt;]

   <b>Listing</b> <b>views</b>
       <b>.view_names()</b> shows you a list of views in the database:

          &gt;&gt;&gt; db.view_names()
          ['good_dogs']

       You can iterate through view objects using the <b>.views</b> property:

          &gt;&gt;&gt; db.views
          [&lt;View good_dogs&gt;]

       View  objects  are similar to Table objects, except that any attempts to insert or update data will throw
       an error. The full list of methods and properties available on a view object is as follows:

       • <b>columns</b>

       • <b>columns_dict</b>

       • <b>count</b>

       • <b>schema</b>

       • <b>rows</b>

       • <b>rows_where(where,</b> <b>where_args,</b> <b>order_by,</b> <b>select)</b>

       • <b>drop()</b>

   <b>Listing</b> <b>rows</b>
       To iterate through dictionaries for each of the rows in a table, use <b>.rows</b>:

          &gt;&gt;&gt; db = sqlite_utils.Database("dogs.db")
          &gt;&gt;&gt; for row in db["dogs"].rows:
          ...     print(row)
          {'id': 1, 'age': 4, 'name': 'Cleo'}
          {'id': 2, 'age': 2, 'name': 'Pancakes'}

       You can filter rows by a WHERE clause using <b>.rows_where(where,</b> <b>where_args)</b>:

          &gt;&gt;&gt; db = sqlite_utils.Database("dogs.db")
          &gt;&gt;&gt; for row in db["dogs"].rows_where("age &gt; ?", [3]):
          ...     print(row)
          {'id': 1, 'age': 4, 'name': 'Cleo'}

       The first argument is a fragment of SQL. The second, optional argument is values to  be  passed  to  that
       fragment  -  you  can  use  <b>?</b> placeholders and pass an array, or you can use <b>:named</b> parameters and pass a
       dictionary, like this:

          &gt;&gt;&gt; for row in db["dogs"].rows_where("age &gt; :age", {"age": 3}):
          ...     print(row)
          {'id': 1, 'age': 4, 'name': 'Cleo'}

       To return custom columns (instead of the default that uses <b>select</b> <b>*</b>) pass <b>select="column1,</b> <b>column2"</b>:

          &gt;&gt;&gt; db = sqlite_utils.Database("dogs.db")
          &gt;&gt;&gt; for row in db["dogs"].rows_where(select='name, age'):
          ...     print(row)
          {'name': 'Cleo', 'age': 4}

       To specify an order, use the <b>order_by=</b> argument:

          &gt;&gt;&gt; for row in db["dogs"].rows_where("age &gt; 1", order_by="age"):
          ...     print(row)
          {'id': 2, 'age': 2, 'name': 'Pancakes'}
          {'id': 1, 'age': 4, 'name': 'Cleo'}

       You can use <b>order_by="age</b> <b>desc"</b> for descending order.

       You can order all records in the table by excluding the <b>where</b> argument:

          &gt;&gt;&gt; for row in db["dogs"].rows_where(order_by="age desc"):
          ...     print(row)
          {'id': 1, 'age': 4, 'name': 'Cleo'}
          {'id': 2, 'age': 2, 'name': 'Pancakes'}

       This method also accepts <b>offset=</b> and <b>limit=</b> arguments, for specifying an OFFSET and a LIMIT for  the  SQL
       query:

          &gt;&gt;&gt; for row in db["dogs"].rows_where(order_by="age desc", limit=1):
          ...     print(row)
          {'id': 1, 'age': 4, 'name': 'Cleo'}

   <b>Counting</b> <b>rows</b>
       To  count  the  number  of  rows  that  would  be  returned  by  a  where filter, use <b>.count_where(where,</b>
       <b>where_args)</b>:

       &gt;&gt;&gt; db["dogs"].count_where("age &gt; ?", [1])
       2

   <b>Listing</b> <b>rows</b> <b>with</b> <b>their</b> <b>primary</b> <b>keys</b>
       Sometimes it can be useful to retrieve the primary key along with each row, in order to pass that key (or
       primary key tuple) to the <b>.get()</b> or <b>.update()</b> methods.

       The <b>.pks_and_rows_where()</b> method takes the same signature as <b>.rows_where()</b> (with  the  exception  of  the
       <b>select=</b> parameter) but returns a generator that yields pairs of <b>(primary</b> <b>key,</b> <b>row</b> <b>dictionary)</b>.

       The  primary key value will usually be a single value but can also be a tuple if the table has a compound
       primary key.

       If the table is a <b>rowid</b> table (with no explicit primary key column) then that ID will be returned.

          &gt;&gt;&gt; db = sqlite_utils.Database(memory=True)
          &gt;&gt;&gt; db["dogs"].insert({"name": "Cleo"})
          &gt;&gt;&gt; for pk, row in db["dogs"].pks_and_rows_where():
          ...     print(pk, row)
          1 {'rowid': 1, 'name': 'Cleo'}

          &gt;&gt;&gt; db["dogs_with_pk"].insert({"id": 5, "name": "Cleo"}, pk="id")
          &gt;&gt;&gt; for pk, row in db["dogs_with_pk"].pks_and_rows_where():
          ...     print(pk, row)
          5 {'id': 5, 'name': 'Cleo'}

          &gt;&gt;&gt; db["dogs_with_compound_pk"].insert(
          ...     {"species": "dog", "id": 3, "name": "Cleo"},
          ...     pk=("species", "id")
          ... )
          &gt;&gt;&gt; for pk, row in db["dogs_with_compound_pk"].pks_and_rows_where():
          ...     print(pk, row)
          ('dog', 3) {'species': 'dog', 'id': 3, 'name': 'Cleo'}

   <b>Retrieving</b> <b>a</b> <b>specific</b> <b>record</b>
       You can retrieve a record by its primary key using <b>table.get()</b>:

          &gt;&gt;&gt; db = sqlite_utils.Database("dogs.db")
          &gt;&gt;&gt; print(db["dogs"].<a href="../man1/get.1.html">get</a>(1))
          {'id': 1, 'age': 4, 'name': 'Cleo'}

       If the table has a compound primary key you can pass in the primary key values as a tuple:

          &gt;&gt;&gt; db["compound_dogs"].get(("mixed", 3))

       If the record does not exist a <b>NotFoundError</b> will be raised:

          from sqlite_utils.db import NotFoundError

          try:
              row = db["dogs"].<a href="../man5/get.5.html">get</a>(5)
          except NotFoundError:
              print("Dog not found")

   <b>Showing</b> <b>the</b> <b>schema</b>
       The <b>db.schema</b> property returns the full SQL schema for the database as a string:

          &gt;&gt;&gt; db = sqlite_utils.Database("dogs.db")
          &gt;&gt;&gt; print(db.schema)
          CREATE TABLE "dogs" (
              [id] INTEGER PRIMARY KEY,
              [name] TEXT
          );

   <b>Creating</b> <b>tables</b>
       The easiest way to create a new table is to insert a record into it:

          from sqlite_utils import Database
          import sqlite3

          db = Database("dogs.db")
          dogs = db["dogs"]
          dogs.insert({
              "name": "Cleo",
              "twitter": "cleopaws",
              "age": 3,
              "is_good_dog": True,
          })

       This will automatically create a new table called "dogs" with the following schema:

          CREATE TABLE dogs (
              name TEXT,
              twitter TEXT,
              age INTEGER,
              is_good_dog INTEGER
          )

       You can also specify a primary key by passing the <b>pk=</b> parameter to the <b>.insert()</b> call. This will only  be
       obeyed if the record being inserted causes the table to be created:

          dogs.insert({
              "id": 1,
              "name": "Cleo",
              "twitter": "cleopaws",
              "age": 3,
              "is_good_dog": True,
          }, pk="id")

       After  inserting  a  row like this, the <b>dogs.last_rowid</b> property will return the SQLite <b>rowid</b> assigned to
       the most recently inserted record.

       The <b>dogs.last_pk</b> property will return the last inserted primary key value, if you specified one. This can
       be very useful when writing code that creates foreign keys or many-to-many relationships.

   <b>Custom</b> <b>column</b> <b>order</b> <b>and</b> <b>column</b> <b>types</b>
       The order of the columns in the table will be derived from the order  of  the  keys  in  the  dictionary,
       provided you are using Python 3.6 or later.

       If you want to explicitly set the order of the columns you can do so using the <b>column_order=</b> parameter:

          db["dogs"].insert({
              "id": 1,
              "name": "Cleo",
              "twitter": "cleopaws",
              "age": 3,
              "is_good_dog": True,
          }, pk="id", column_order=("id", "twitter", "name"))

       You don't need to pass all of the columns to the <b>column_order</b> parameter. If you only pass a subset of the
       columns the remaining columns will be ordered based on the key order of the dictionary.

       Column  types  are  detected  based  on  the  example  data  provided. Sometimes you may find you need to
       over-ride these detected types - to create an integer column for data that was provided as a  string  for
       example,  or to ensure that a table where the first example was <b>None</b> is created as an <b>INTEGER</b> rather than
       a <b>TEXT</b> column. You can do this using the <b>columns=</b> parameter:

          db["dogs"].insert({
              "id": 1,
              "name": "Cleo",
              "age": "5",
          }, pk="id", columns={"age": int, "weight": float})

       This will create a table with the following schema:

          CREATE TABLE [dogs] (
              [id] INTEGER PRIMARY KEY,
              [name] TEXT,
              [age] INTEGER,
              [weight] FLOAT
          )

   <b>Explicitly</b> <b>creating</b> <b>a</b> <b>table</b>
       You can directly create a new table without inserting any data into it using the <b>.create()</b> method:

          db["cats"].create({
              "id": int,
              "name": str,
              "weight": float,
          }, pk="id")

       The first argument here is a dictionary specifying the columns you would like to create. Each  column  is
       paired with a Python type indicating the type of column. See <u>Adding</u> <u>columns</u> for full details on how these
       types work.

       This   method   takes   optional   arguments   <b>pk=</b>,   <b>column_order=</b>,  <b>foreign_keys=</b>,  <b>not_null=set()</b>  and
       <b>defaults=dict()</b> - explained below.

       A <b>sqlite_utils.utils.sqlite3.OperationalError</b> will be raised if a table of that name already exists.

       You can pass <b>ignore=True</b> to ignore that error. You can also use <b>if_not_exists=True</b> to use the SQL  <b>CREATE</b>
       <b>TABLE</b> <b>IF</b> <b>NOT</b> <b>EXISTS</b> pattern to achieve the same effect:

          db["cats"].create({
              "id": int,
              "name": str,
          }, pk="id", if_not_exists=True)

       To  drop  and  replace  any existing table of that name, pass <b>replace=True</b>. This is a <b>dangerous</b> <b>operation</b>
       that will result in loss of existing data in the table.

       You can also pass <b>transform=True</b> to have  any  existing  tables  <u>transformed</u>  to  match  your  new  table
       specification.  This  is  a <b>dangerous</b> <b>operation</b> as it will drop columns that are no longer listed in your
       call to <b>.create()</b>, so be careful when running this.

          db["cats"].create({
              "id": int,
              "name": str,
              "weight": float,
          }, pk="id", transform=True)

       The <b>transform=True</b> option will update the table schema if any of the following have changed:

       • The specified columns or their types

       • The specified primary key

       • The order of the columns, defined using <b>column_order=</b>

       • The <b>not_null=</b> or <b>defaults=</b> arguments

       Changes to <b>foreign_keys=</b> are not currently detected and applied by <b>transform=True</b>.

       You can pass <b>strict=True</b> to create a table in <b>STRICT</b> mode:

          db["cats"].create({
              "id": int,
              "name": str,
          }, strict=True)

   <b>Compound</b> <b>primary</b> <b>keys</b>
       If you want to create a table with a compound primary key that spans multiple columns, you can do  so  by
       passing a tuple of column names to any of the methods that accept a <b>pk=</b> parameter. For example:

          db["cats"].create({
              "id": int,
              "breed": str,
              "name": str,
              "weight": float,
          }, pk=("breed", "id"))

       This also works for the <b>.insert()</b>, <b>.insert_all()</b>, <b>.upsert()</b> and <b>.upsert_all()</b> methods.

   <b>Specifying</b> <b>foreign</b> <b>keys</b>
       Any  operation that can create a table (<b>.create()</b>, <b>.insert()</b>, <b>.insert_all()</b>, <b>.upsert()</b> and <b>.upsert_all()</b>)
       accepts an optional <b>foreign_keys=</b> argument which can be used to set up foreign key  constraints  for  the
       table that is being created.

       If  you  are  using your database with <u>Datasette</u>, Datasette will detect these constraints and use them to
       generate hyperlinks to associated records.

       The <b>foreign_keys</b> argument takes a list that indicates which foreign keys should be created. The list  can
       take several forms. The simplest is a list of columns:

          foreign_keys=["author_id"]

       The  library  will  guess  which  tables  you wish to reference based on the column names using the rules
       described in <u>Adding</u> <u>foreign</u> <u>key</u> <u>constraints</u>.

       You can also be more explicit, by passing in a list of tuples:

          foreign_keys=[
              ("author_id", "authors", "id")
          ]

       This means that the <b>author_id</b> column should be a foreign key that references the <b>id</b> column in the <b>authors</b>
       table.

       You can leave off the third item in the tuple to have the referenced  column  automatically  set  to  the
       primary key of that table. A full example:

          db["authors"].insert_all([
              {"id": 1, "name": "Sally"},
              {"id": 2, "name": "Asheesh"}
          ], pk="id")
          db["books"].insert_all([
              {"title": "Hedgehogs of the world", "author_id": 1},
              {"title": "How to train your wolf", "author_id": 2},
          ], foreign_keys=[
              ("author_id", "authors")
          ])

   <b>Table</b> <b>configuration</b> <b>options</b>
       The  <b>.insert()</b>,  <b>.upsert()</b>,  <b>.insert_all()</b>  and  <b>.upsert_all()</b>  methods  each  take  a  number of keyword
       arguments, some of which influence what happens should they cause a table to be created and some of which
       affect the behavior of those methods.

       You can set default values for these methods by accessing the  table  through  the  <b>db.table(...)</b>  method
       (instead of using <b>db["table_name"]</b>), like so:

          table = db.table(
              "authors",
              pk="id",
              not_null={"name", "score"},
              column_order=("id", "name", "score", "url")
          )
          # Now you can call .insert() like so:
          table.insert({"id": 1, "name": "Tracy", "score": 5})

       The configuration options that can be specified in this way are <b>pk</b>, <b>foreign_keys</b>, <b>column_order</b>, <b>not_null</b>,
       <b>defaults</b>,  <b>batch_size</b>,  <b>hash_id</b>, <b>hash_id_columns</b>, <b>alter</b>, <b>ignore</b>, <b>replace</b>, <b>extracts</b>, <b>conversions</b>, <b>columns</b>,
       <b>strict</b>. These are all documented below.

   <b>Setting</b> <b>defaults</b> <b>and</b> <b>not</b> <b>null</b> <b>constraints</b>
       Each of the methods that can cause a table to be  created  take  optional  arguments  <b>not_null=set()</b>  and
       <b>defaults=dict()</b>. The methods that take these optional arguments are:

       • <b>db.create_table(...)</b>

       • <b>table.create(...)</b>

       • <b>table.insert(...)</b>

       • <b>table.insert_all(...)</b>

       • <b>table.upsert(...)</b>

       • <b>table.upsert_all(...)</b>

       You  can  use  <b>not_null=</b> to pass a set of column names that should have a <b>NOT</b> <b>NULL</b> constraint set on them
       when they are created.

       You can use <b>defaults=</b> to pass a dictionary mapping columns to the default value that should be  specified
       in the <b>CREATE</b> <b>TABLE</b> statement.

       Here's an example that uses these features:

          db["authors"].insert_all(
              [{"id": 1, "name": "Sally", "score": 2}],
              pk="id",
              not_null={"name", "score"},
              defaults={"score": 1},
          )
          db["authors"].insert({"name": "Dharma"})

          list(db["authors"].rows)
          # Outputs:
          # [{'id': 1, 'name': 'Sally', 'score': 2},
          #  {'id': 3, 'name': 'Dharma', 'score': 1}]
          print(db["authors"].schema)
          # Outputs:
          # CREATE TABLE [authors] (
          #     [id] INTEGER PRIMARY KEY,
          #     [name] TEXT NOT NULL,
          #     [score] INTEGER NOT NULL DEFAULT 1
          # )

   <b>Renaming</b> <b>a</b> <b>table</b>
       The <b>db.rename_table(old_name,</b> <b>new_name)</b> method can be used to rename a table:

          db.rename_table("my_table", "new_name_for_my_table")

       This executes the following SQL:

          ALTER TABLE [my_table] RENAME TO [new_name_for_my_table]

   <b>Duplicating</b> <b>tables</b>
       The  <b>table.duplicate()</b>  method  creates a copy of the table, copying both the table schema and all of the
       rows in that table:

          db["authors"].duplicate("authors_copy")

       The new <b>authors_copy</b> table will now contain a duplicate copy of the data from <b>authors</b>.

       This method raises <b>sqlite_utils.db.NoTable</b> if the table does not exist.

   <b>Bulk</b> <b>inserts</b>
       If you have more than one record to insert, the <b>insert_all()</b> method is  a  much  more  efficient  way  of
       inserting  them.  Just like <b>insert()</b> it will automatically detect the columns that should be created, but
       it will inspect the first batch of 100 items to help decide what those column types should be.

       Use it like this:

          db["dogs"].insert_all([{
              "id": 1,
              "name": "Cleo",
              "twitter": "cleopaws",
              "age": 3,
              "is_good_dog": True,
          }, {
              "id": 2,
              "name": "Marnie",
              "twitter": "MarnieTheDog",
              "age": 16,
              "is_good_dog": True,
          }], pk="id", column_order=("id", "twitter", "name"))

       The column types used in the <b>CREATE</b> <b>TABLE</b> statement are automatically derived from the types of  data  in
       that   first   batch   of   rows.   Any   additional   columns   in   subsequent  batches  will  cause  a
       <b>sqlite3.OperationalError</b> exception to be raised unless the <b>alter=True</b> argument is supplied, in which case
       the new columns will be created.

       The function can accept an iterator or generator of rows and will commit  them  according  to  the  batch
       size. The default batch size is 100, but you can specify a different size using the <b>batch_size</b> parameter:

          db["big_table"].insert_all(({
              "id": 1,
              "name": "Name {}".format(i),
          } for i in <a href="../man10000/range.10000.html">range</a>(10000)), batch_size=1000)

       You  can  skip  inserting any records that have a primary key that already exists using <b>ignore=True</b>. This
       works with both <b>.insert({...},</b> <b>ignore=True)</b> and <b>.insert_all([...],</b> <b>ignore=True)</b>.

       You can delete all the existing rows in the table before inserting the new records  using  <b>truncate=True</b>.
       This is useful if you want to replace the data in the table.

       Pass <b>analyze=True</b> to run <b>ANALYZE</b> against the table after inserting the new records.

   <b>Insert-replacing</b> <b>data</b>
       If  you try to insert data using a primary key that already exists, the <b>.insert()</b> or <b>.insert_all()</b> method
       will raise a <b>sqlite3.IntegrityError</b> exception.

       This example that catches that exception:

          from sqlite_utils.utils import sqlite3

          try:
              db["dogs"].insert({"id": 1, "name": "Cleo"}, pk="id")
          except sqlite3.IntegrityError:
              print("Record already exists with that primary key")

       Importing from <b>sqlite_utils.utils.sqlite3</b> ensures your code continues to work even if you are  using  the
       <b>pysqlite3</b> library instead of the Python standard library <b>sqlite3</b> module.

       Use the <b>ignore=True</b> parameter to ignore this error:

          # This fails silently if a record with id=1 already exists
          db["dogs"].insert({"id": 1, "name": "Cleo"}, pk="id", ignore=True)

       To  replace  any  existing  records  that  have a matching primary key, use the <b>replace=True</b> parameter to
       <b>.insert()</b> or <b>.insert_all()</b>:

          db["dogs"].insert_all([{
              "id": 1,
              "name": "Cleo",
              "twitter": "cleopaws",
              "age": 3,
              "is_good_dog": True,
          }, {
              "id": 2,
              "name": "Marnie",
              "twitter": "MarnieTheDog",
              "age": 16,
              "is_good_dog": True,
          }], pk="id", replace=True)

       <b>NOTE:</b>
          Prior  to  sqlite-utils  2.0  the  <b>.upsert()</b>  and  <b>.upsert_all()</b>  methods  worked  the  same  way   as
          <b>.insert(replace=True)</b> does today. See <u>Upserting</u> <u>data</u> for the new behaviour of those methods introduced
          in 2.0.

   <b>Updating</b> <b>a</b> <b>specific</b> <b>record</b>
       You can update a record by its primary key using <b>table.update()</b>:

          &gt;&gt;&gt; db = sqlite_utils.Database("dogs.db")
          &gt;&gt;&gt; print(db["dogs"].<a href="../man1/get.1.html">get</a>(1))
          {'id': 1, 'age': 4, 'name': 'Cleo'}
          &gt;&gt;&gt; db["dogs"].update(1, {"age": 5})
          &gt;&gt;&gt; print(db["dogs"].<a href="../man1/get.1.html">get</a>(1))
          {'id': 1, 'age': 5, 'name': 'Cleo'}

       The  first  argument to <b>update()</b> is the primary key. This can be a single value, or a tuple if that table
       has a compound primary key:

          &gt;&gt;&gt; db["compound_dogs"].update((5, 3), {"name": "Updated"})

       The second argument is a dictionary of columns that should be updated, along with their new values.

       You can cause any missing columns to be added automatically using <b>alter=True</b>:

          &gt;&gt;&gt; db["dogs"].update(1, {"breed": "Mutt"}, alter=True)

   <b>Deleting</b> <b>a</b> <b>specific</b> <b>record</b>
       You can delete a record using <b>table.delete()</b>:

          &gt;&gt;&gt; db = sqlite_utils.Database("dogs.db")
          &gt;&gt;&gt; db["dogs"].<a href="../man1/delete.1.html">delete</a>(1)

       The <b>delete()</b> method takes the primary key of the record. This can be a tuple of values if the row  has  a
       compound primary key:

          &gt;&gt;&gt; db["compound_dogs"].delete((5, 3))

   <b>Deleting</b> <b>multiple</b> <b>records</b>
       You can delete all records in a table that match a specific WHERE statement using <b>table.delete_where()</b>:

          &gt;&gt;&gt; db = sqlite_utils.Database("dogs.db")
          &gt;&gt;&gt; # Delete every dog with age less than 3
          &gt;&gt;&gt; with db.conn:
          &gt;&gt;&gt;     db["dogs"].delete_where("age &lt; ?", [3])

       Calling <b>table.delete_where()</b> with no other arguments will delete every row in the table.

       Pass <b>analyze=True</b> to run <b>ANALYZE</b> against the table after deleting the rows.

   <b>Upserting</b> <b>data</b>
       Upserting  allows  you  to insert records if they do not exist and update them if they DO exist, based on
       matching against their primary key.

       For example, given the dogs database you could upsert the record for Cleo like so:

          db["dogs"].upsert({
              "id": 1,
              "name": "Cleo",
              "twitter": "cleopaws",
              "age": 4,
              "is_good_dog": True,
          }, pk="id", column_order=("id", "twitter", "name"))

       If a record exists with id=1, it will be updated to match those fields. If it does not exist it  will  be
       created.

       Any  existing columns that are not referenced in the dictionary passed to <b>.upsert()</b> will be unchanged. If
       you want to replace a record entirely, use <b>.insert(doc,</b> <b>replace=True)</b> instead.

       Note that the <b>pk</b> and <b>column_order</b> parameters here are optional if you are  certain  that  the  table  has
       already  been  created.  You  should pass them if the table may not exist at the time the first upsert is
       performed.

       An <b>upsert_all()</b> method is also available, which behaves like <b>insert_all()</b> but performs upserts instead.

       <b>NOTE:</b>
          <b>.upsert()</b>  and  <b>.upsert_all()</b>  in  sqlite-utils  1.x  worked  like  <b>.insert(...,</b>   <b>replace=True)</b>   and
          <b>.insert_all(...,</b> <b>replace=True)</b> do in 2.x. See <u>issue</u> <u>#66</u> for details of this change.

   <b>Converting</b> <b>data</b> <b>in</b> <b>columns</b>
       The  <b>table.convert(...)</b>  method  can  be  used  to apply a conversion function to the values in a column,
       either to update that column or to populate new columns. It is  the  Python  library  equivalent  of  the
       <u>sqlite-utils</u> <u>convert</u> command.

       This  feature  works  by  registering a custom SQLite function that applies a Python transformation, then
       running a SQL query equivalent to <b>UPDATE</b> <b>table</b> <b>SET</b> <b>column</b> <b>=</b> <b>convert_value(column);</b>

       To transform a specific column to uppercase, you would use the following:

          db["dogs"].convert("name", lambda value: value.upper())

       You can pass a list of columns, in which case the transformation will be applied to each one:

          db["dogs"].convert(["name", "twitter"], lambda value: value.upper())

       To save the output to of the transformation to a different column, use the <b>output=</b> parameter:

          db["dogs"].convert("name", lambda value: value.upper(), output="name_upper")

       This will add the new column, if it does not already exist. You can pass <b>output_type=int</b>  or  some  other
       type to control the type of the new column - otherwise it will default to text.

       If  you  want  to  drop  the  original  column after saving the results in a separate output column, pass
       <b>drop=True</b>.

       By default any rows with a falsey value for the column - such as <b>0</b>  or  <b>None</b>  -  will  be  skipped.  Pass
       <b>skip_false=False</b> to disable this behaviour.

       You  can  create  multiple  new columns from a single input column by passing <b>multi=True</b> and a conversion
       function that returns a Python dictionary. This example creates new <b>upper</b>  and  <b>lower</b>  columns  populated
       from the single <b>title</b> column:

          table.convert(
              "title", lambda v: {"upper": v.upper(), "lower": v.lower()}, multi=True
          )

       The  <b>.convert()</b>  method accepts optional <b>where=</b> and <b>where_args=</b> parameters which can be used to apply the
       conversion to a subset of rows specified by a where clause. Here's how to apply the  conversion  only  to
       rows with an <b>id</b> that is higher than 20:

          table.convert("title", lambda v: v.upper(), where="id &gt; :id", where_args={"id": 20})

       These  behave  the  same  as  the  corresponding parameters to the <u>.rows_where()</u> method, so you can use <b>?</b>
       placeholders and a list of values instead of <b>:named</b> placeholders with a dictionary.

   <b>Working</b> <b>with</b> <b>lookup</b> <b>tables</b>
       A useful pattern when populating large tables in to break common values out into lookup tables.  Consider
       a table of <b>Trees</b>, where each tree has a species. Ideally these species would be split out into a separate
       <b>Species</b>  table, with each one assigned an integer primary key that can be referenced from the <b>Trees</b> table
       <b>species_id</b> column.

   <b>Creating</b> <b>lookup</b> <b>tables</b> <b>explicitly</b>
       Calling <b>db["Species"].lookup({"name":</b> <b>"Palm"})</b> creates a table called <b>Species</b> (if one  does  not  already
       exist)  with  two columns: <b>id</b> and <b>name</b>. It sets up a unique constraint on the <b>name</b> column to guarantee it
       will not contain duplicate rows. It then inserts a new row with the <b>name</b> set to <b>Palm</b> and returns the  new
       integer primary key value.

       If the <b>Species</b> table already exists, it will insert the new row and return the primary key. If a row with
       that <b>name</b> already exists, it will return the corresponding primary key value directly.

       If  you call <b>.lookup()</b> against an existing table without the unique constraint it will attempt to add the
       constraint, raising an <b>IntegrityError</b> if the constraint cannot be created.

       If you pass in a dictionary with multiple values, both values will be used  to  insert  or  retrieve  the
       corresponding ID and any unique constraint that is created will cover all of those columns, for example:

          db["Trees"].insert({
              "latitude": 49.1265976,
              "longitude": 2.5496218,
              "species": db["Species"].lookup({
                  "common_name": "Common Juniper",
                  "latin_name": "Juniperus communis"
              })
          })

       The  <b>.lookup()</b>  method has an optional second argument which can be used to populate other columns in the
       table but only if the row does not exist yet. These columns will not be included in the unique index.

       To create a species record with a note on when it was first seen, you can use this:

          db["Species"].lookup({"name": "Palm"}, {"first_seen": "2021-03-04"})

       The first time this is called the record will be created for <b>name="Palm"</b>. Any subsequent calls with  that
       name will ignore the second argument, even if it includes different values.

       <b>.lookup()</b> also accepts keyword arguments, which are passed through to the <u>insert()</u> <u>method</u> and can be used
       to influence the shape of the created table. Supported parameters are:

       • <b>pk</b> - which defaults to <b>id</b>

       • <b>foreign_keys</b>

       • <b>column_order</b>

       • <b>not_null</b>

       • <b>defaults</b>

       • <b>extracts</b>

       • <b>conversions</b>

       • <b>columns</b>

       • <b>strict</b>

   <b>Populating</b> <b>lookup</b> <b>tables</b> <b>automatically</b> <b>during</b> <b>insert/upsert</b>
       A more efficient way to work with lookup tables is to define them using the <b>extracts=</b> parameter, which is
       accepted by <b>.insert()</b>, <b>.upsert()</b>, <b>.insert_all()</b>, <b>.upsert_all()</b> and by the <b>.table(...)</b> factory function.

       <b>extracts=</b>  specifies columns which should be "extracted" out into a separate lookup table during the data
       insertion.

       It can be either a list of column names, in which case the extracted table names will  match  the  column
       names exactly, or it can be a dictionary mapping column names to the desired name of the extracted table.

       To extract the <b>species</b> column out to a separate <b>Species</b> table, you can do this:

          # Using the table factory
          trees = db.table("Trees", extracts={"species": "Species"})
          trees.insert({
              "latitude": 49.1265976,
              "longitude": 2.5496218,
              "species": "Common Juniper"
          })

          # If you want the table to be called 'species', you can do this:
          trees = db.table("Trees", extracts=["species"])

          # Using .insert() directly
          db["Trees"].insert({
              "latitude": 49.1265976,
              "longitude": 2.5496218,
              "species": "Common Juniper"
          }, extracts={"species": "Species"})

   <b>Working</b> <b>with</b> <b>many-to-many</b> <b>relationships</b>
       <b>sqlite-utils</b> includes a shortcut for creating records using many-to-many relationships in the form of the
       <b>table.m2m(...)</b> method.

       Here's how to create two new records and connect them via a many-to-many table in a single line of code:

          db["dogs"].insert({"id": 1, "name": "Cleo"}, pk="id").m2m(
              "humans", {"id": 1, "name": "Natalie"}, pk="id"
          )

       Running this example actually creates three tables: <b>dogs</b>, <b>humans</b> and a many-to-many <b>dogs_humans</b> table. It
       will insert a record into each of those tables.

       The  <b>.m2m()</b>  method  executes  against  the last record that was affected by <b>.insert()</b> or <b>.update()</b> - the
       record identified by the <b>table.last_pk</b> property. To execute <b>.m2m()</b> against  a  specific  record  you  can
       first select it by passing its primary key to <b>.update()</b>:

          db["dogs"].<a href="../man1/update.1.html">update</a>(1).m2m(
              "humans", {"id": 2, "name": "Simon"}, pk="id"
          )

       The  first argument to <b>.m2m()</b> can be either the name of a table as a string or it can be the table object
       itself.

       The second argument can be a single dictionary record or a list of dictionaries. These dictionaries  will
       be passed to <b>.upsert()</b> against the specified table.

       Here's alternative code that creates the dog record and adds two people to it:

          db = Database(memory=True)
          dogs = db.table("dogs", pk="id")
          humans = db.table("humans", pk="id")
          dogs.insert({"id": 1, "name": "Cleo"}).m2m(
              humans, [
                  {"id": 1, "name": "Natalie"},
                  {"id": 2, "name": "Simon"}
              ]
          )

       The  method  will  attempt to find an existing many-to-many table by looking for a table that has foreign
       key relationships against both of the tables in the relationship.

       If it cannot find such a table, it will create a new one using the names of the two tables -  <b>dogs_humans</b>
       in this example. You can customize the name of this table using the <b>m2m_table=</b> argument to <b>.m2m()</b>.

       It  it  finds multiple candidate tables with foreign keys to both of the specified tables it will raise a
       <b>sqlite_utils.db.NoObviousTable</b> exception. You can avoid this error by specifying the correct table  using
       <b>m2m_table=</b>.

       The  <b>.m2m()</b>  method also takes an optional <b>pk=</b> argument to specify the primary key that should be used if
       the table is created, and an optional <b>alter=True</b> argument to specify  that  any  missing  columns  of  an
       existing table should be added if they are needed.

   <b>Using</b> <b>m2m</b> <b>and</b> <b>lookup</b> <b>tables</b> <b>together</b>
       You can work with (or create) lookup tables as part of a call to <b>.m2m()</b> using the <b>lookup=</b> parameter. This
       accepts  the  same argument as <b>table.lookup()</b> does - a dictionary of values that should be used to lookup
       or create a row in the lookup table.

       This example creates a dogs table, populates it, creates a characteristics table, populates that and sets
       up a many-to-many relationship between  the  two.  It  chains  <b>.m2m()</b>  twice  to  create  two  associated
       characteristics:

          db = Database(memory=True)
          dogs = db.table("dogs", pk="id")
          dogs.insert({"id": 1, "name": "Cleo"}).m2m(
              "characteristics", lookup={
                  "name": "Playful"
              }
          ).m2m(
              "characteristics", lookup={
                  "name": "Opinionated"
              }
          )

       You can inspect the database to see the results like this:

          &gt;&gt;&gt; db.table_names()
          ['dogs', 'characteristics', 'characteristics_dogs']
          &gt;&gt;&gt; list(db["dogs"].rows)
          [{'id': 1, 'name': 'Cleo'}]
          &gt;&gt;&gt; list(db["characteristics"].rows)
          [{'id': 1, 'name': 'Playful'}, {'id': 2, 'name': 'Opinionated'}]
          &gt;&gt;&gt; list(db["characteristics_dogs"].rows)
          [{'characteristics_id': 1, 'dogs_id': 1}, {'characteristics_id': 2, 'dogs_id': 1}]
          &gt;&gt;&gt; print(db["characteristics_dogs"].schema)
          CREATE TABLE [characteristics_dogs] (
              [characteristics_id] INTEGER REFERENCES [characteristics]([id]),
              [dogs_id] INTEGER REFERENCES [dogs]([id]),
              PRIMARY KEY ([characteristics_id], [dogs_id])
          )

   <b>Analyzing</b> <b>a</b> <b>column</b>
       The <b>table.analyze_column(column)</b> method is used by the <u>analyze-tables</u> CLI command.

       It takes the following arguments and options:

       <b>column</b> <b>-</b> <b>required</b>
              The name of the column to analyze

       <b>common_limit</b>
              The number of most common values to return. Defaults to 10.

       <b>value_truncate</b>
              If set to an integer, values longer than this will be truncated to this length. Defaults to None.

       <b>most_common</b>
              If set to False, the <b>most_common</b> field of the returned <b>ColumnDetails</b> will be set to None. Defaults
              to True.

       <b>least_common</b>
              If  set  to  False,  the  <b>least_common</b>  field  of  the returned <b>ColumnDetails</b> will be set to None.
              Defaults to True.

       And returns a <b>ColumnDetails</b> named tuple with the following fields:

       <b>table</b>  The name of the table

       <b>column</b> The name of the column

       <b>total_rows</b>
              The total number of rows in the table

       <b>num_null</b>
              The number of rows for which this column is null

       <b>num_blank</b>
              The number of rows for which this column is blank (the empty string)

       <b>num_distinct</b>
              The number of distinct values in this column

       <b>most_common</b>
              The <b>N</b> most common values as a list of <b>(value,</b> <b>count)</b>  tuples`,  or  <b>None</b>  if  the  table  consists
              entirely of distinct values

       <b>least_common</b>
              The  <b>N</b>  least  common values as a list of <b>(value,</b> <b>count)</b> tuples`, or <b>None</b> if the table is entirely
              distinct or if the number of distinct values is less than N (since they  will  already  have  been
              returned in <b>most_common</b>)

   <b>Adding</b> <b>columns</b>
       You can add a new column to a table using the <b>.add_column(col_name,</b> <b>col_type)</b> method:

          db["dogs"].add_column("instagram", str)
          db["dogs"].add_column("weight", float)
          db["dogs"].add_column("dob", datetime.date)
          db["dogs"].add_column("image", "BLOB")
          db["dogs"].add_column("website") # str by default

       You  can  specify  the <b>col_type</b> argument either using a SQLite type as a string, or by directly passing a
       Python type e.g. <b>str</b> or <b>float</b>.

       The <b>col_type</b> is optional - if you omit it the type of <b>TEXT</b> will be used.

       SQLite types you can specify are <b>"TEXT"</b>, <b>"INTEGER"</b>, <b>"FLOAT"</b> or <b>"BLOB"</b>.

       If you pass a Python type, it will be mapped to SQLite types as shown here:

          float: "FLOAT"
          int: "INTEGER"
          bool: "INTEGER"
          str: "TEXT"
          bytes: "BLOB"
          datetime.datetime: "TEXT"
          datetime.date: "TEXT"
          datetime.time: "TEXT"
          datetime.timedelta: "TEXT"

          # If numpy is installed
          np.int8: "INTEGER"
          np.int16: "INTEGER"
          np.int32: "INTEGER"
          np.int64: "INTEGER"
          np.uint8: "INTEGER"
          np.uint16: "INTEGER"
          np.uint32: "INTEGER"
          np.uint64: "INTEGER"
          np.float16: "FLOAT"
          np.float32: "FLOAT"
          np.float64: "FLOAT"

       <b>NOTE:</b>
          In sqlite-utils 3.x <b>FLOAT</b> is used for floating point columns when the correct column type is  actually
          <b>REAL</b>.  If  you  specify  <b>strict=True</b> tables created in strict mode will use the correct column type of
          <b>REAL</b> instead. We plan to change this behavior in <b>sqlite-utils</b> 4.x to always use <b>REAL</b>,  but  this  will
          represent a minor breaking change and so is being held for the next major release, see issue <u>#645</u>.

       You can also add a column that is a foreign key reference to another table using the <b>fk</b> parameter:

          db["dogs"].add_column("species_id", fk="species")

       This  will  automatically  detect  the name of the primary key on the species table and use that (and its
       type) for the new column.

       You can explicitly specify the column you wish to reference using <b>fk_col</b>:

          db["dogs"].add_column("species_id", fk="species", fk_col="ref")

       You can set a <b>NOT</b> <b>NULL</b> <b>DEFAULT</b> <b>'x'</b> constraint on the new column using <b>not_null_default</b>:

          db["dogs"].add_column("friends_count", int, not_null_default=0)

   <b>Adding</b> <b>columns</b> <b>automatically</b> <b>on</b> <b>insert/update</b>
       You can insert or update data that includes new columns and have the table automatically altered  to  fit
       the  new  schema  using  the <b>alter=True</b> argument. This can be passed to all four of <b>.insert()</b>, <b>.upsert()</b>,
       <b>.insert_all()</b> and <b>.upsert_all()</b>, or it can be passed to <b>db.table(table_name,</b> <b>alter=True)</b> to enable it  by
       default for all method calls against that table instance.

          db["new_table"].insert({"name": "Gareth"})
          # This will throw an exception:
          db["new_table"].insert({"name": "Gareth", "age": 32})
          # This will succeed and add a new "age" integer column:
          db["new_table"].insert({"name": "Gareth", "age": 32}, alter=True)
          # You can see confirm the new column like so:
          print(db["new_table"].columns_dict)
          # Outputs this:
          # {'name': &lt;class 'str'&gt;, 'age': &lt;class 'int'&gt;}

          # This works too:
          new_table = db.table("new_table", alter=True)
          new_table.insert({"name": "Gareth", "age": 32, "shoe_size": 11})

   <b>Adding</b> <b>foreign</b> <b>key</b> <b>constraints</b>
       The  SQLite  <b>ALTER</b>  <b>TABLE</b> statement doesn't have the ability to add foreign key references to an existing
       column.

       The <b>add_foreign_key()</b> method here is a convenient wrapper around <u>table.transform()</u>.

       It's  also  possible  to  add  foreign  keys  by  directly  updating  the  <u>sqlite_master</u>  table.  The   ‐
       <u>sqlite-utils-fast-fks</u>  plugin  implements  this  pattern,  using code that was included with <b>sqlite-utils</b>
       prior to version 3.35.

       Here's an example of this mechanism in action:

          db["authors"].insert_all([
              {"id": 1, "name": "Sally"},
              {"id": 2, "name": "Asheesh"}
          ], pk="id")
          db["books"].insert_all([
              {"title": "Hedgehogs of the world", "author_id": 1},
              {"title": "How to train your wolf", "author_id": 2},
          ])
          db["books"].add_foreign_key("author_id", "authors", "id")

       The <b>table.add_foreign_key(column,</b> <b>other_table,</b> <b>other_column)</b> method takes the name  of  the  column,  the
       table  that  is being referenced and the key column within that other table. If you omit the <b>other_column</b>
       argument the primary key from that table will be used automatically. If you omit the <b>other_table</b> argument
       the table will be guessed based on some simple rules:

       • If the column is of format <b>author_id</b>, look for tables called <b>author</b> or <b>authors</b>

       • If the column does not end in <b>_id</b>, try looking for a table with the exact name of the  column  or  that
         name with an added <b>s</b>

       This method first checks that the specified foreign key references tables and columns that exist and does
       not  clash  with  an  existing foreign key. It will raise a <b>sqlite_utils.db.AlterError</b> exception if these
       checks fail.

       To ignore the case where the key already exists, use <b>ignore=True</b>:

          db["books"].add_foreign_key("author_id", "authors", "id", ignore=True)

   <b>Adding</b> <b>multiple</b> <b>foreign</b> <b>key</b> <b>constraints</b> <b>at</b> <b>once</b>
       You can use <b>db.add_foreign_keys(...)</b> to add multiple foreign keys in one go. This method takes a list  of
       four-tuples, each one specifying a <b>table</b>, <b>column</b>, <b>other_table</b> and <b>other_column</b>.

       Here's an example adding two foreign keys at once:

          db.add_foreign_keys([
              ("dogs", "breed_id", "breeds", "id"),
              ("dogs", "home_town_id", "towns", "id")
          ])

       This  method  runs  the  same  checks as <b>.add_foreign_keys()</b> and will raise <b>sqlite_utils.db.AlterError</b> if
       those checks fail.

   <b>Adding</b> <b>indexes</b> <b>for</b> <b>all</b> <b>foreign</b> <b>keys</b>
       If you want to ensure that every foreign key column in your database has a corresponding index,  you  can
       do so like this:

          db.index_foreign_keys()

   <b>Dropping</b> <b>a</b> <b>table</b> <b>or</b> <b>view</b>
       You can drop a table or view using the <b>.drop()</b> method:

          db["my_table"].drop()

       Pass <b>ignore=True</b> if you want to ignore the error caused by the table or view not existing.

          db["my_table"].drop(ignore=True)

   <b>Transforming</b> <b>a</b> <b>table</b>
       The SQLite <b>ALTER</b> <b>TABLE</b> statement is limited. It can add and drop columns and rename tables, but it cannot
       change column types, change <b>NOT</b> <b>NULL</b> status or change the primary key for a table.

       The  <b>table.transform()</b>  method can do all of these things, by implementing a multi-step pattern <u>described</u>
       <u>in</u> <u>the</u> <u>SQLite</u> <u>documentation</u>:

       1. Start a transaction

       2. <b>CREATE</b> <b>TABLE</b> <b>tablename_new_x123</b> with the required changes

       3. Copy the old data into the new table using <b>INSERT</b> <b>INTO</b> <b>tablename_new_x123</b> <b>SELECT</b> <b>*</b> <b>FROM</b> <b>tablename;</b>

       4. <b>DROP</b> <b>TABLE</b> <b>tablename;</b>

       5. <b>ALTER</b> <b>TABLE</b> <b>tablename_new_x123</b> <b>RENAME</b> <b>TO</b> <b>tablename;</b>

       6. Commit the transaction

       The <b>.transform()</b> method takes a number of parameters, all of which are optional.

       As a bonus, calling <b>.transform()</b> will reformat the schema for the table that is stored in SQLite to  make
       it more readable. This works even if you call it without any arguments.

       To  keep  the  original  table around instead of dropping it, pass the <b>keep_table=</b> option and specify the
       name of the table you would like it to be renamed to:

          table.transform(types={"age": int}, keep_table="original_table")

       This method raises a <b>sqlite_utils.db.TransformError</b> exception if the table cannot be transformed, usually
       because there are existing constraints or  indexes  that  are  incompatible  with  modifications  to  the
       columns.

   <b>Altering</b> <b>column</b> <b>types</b>
       To alter the type of a column, use the <b>types=</b> argument:

          # Convert the 'age' column to an integer, and 'weight' to a float
          table.transform(types={"age": int, "weight": float})

       See <u>Adding</u> <u>columns</u> for a list of available types.

   <b>Renaming</b> <b>columns</b>
       The <b>rename=</b> parameter can rename columns:

          # Rename 'age' to 'initial_age':
          table.transform(rename={"age": "initial_age"})

   <b>Dropping</b> <b>columns</b>
       To drop columns, pass them in the <b>drop=</b> set:

          # Drop the 'age' column:
          table.transform(drop={"age"})

   <b>Changing</b> <b>primary</b> <b>keys</b>
       To  change the primary key for a table, use <b>pk=</b>. This can be passed a single column for a regular primary
       key, or a tuple of columns to create a compound primary key. Passing <b>pk=None</b> will remove the primary  key
       and convert the table into a <b>rowid</b> table.

          # Make `user_id` the new primary key
          table.transform(pk="user_id")

   <b>Changing</b> <b>not</b> <b>null</b> <b>status</b>
       You  can  change the <b>NOT</b> <b>NULL</b> status of columns by using <b>not_null=</b>. You can pass this a set of columns to
       make those columns <b>NOT</b> <b>NULL</b>:

          # Make the 'age' and 'weight' columns NOT NULL
          table.transform(not_null={"age", "weight"})

       If you want to take existing <b>NOT</b> <b>NULL</b> columns and change them to allow null values,  you  can  do  so  by
       passing a dictionary of true/false values instead:

          # 'age' is NOT NULL but we want to allow NULL:
          table.transform(not_null={"age": False})

          # Make age allow NULL and switch weight to being NOT NULL:
          table.transform(not_null={"age": False, "weight": True})

   <b>Altering</b> <b>column</b> <b>defaults</b>
       The <b>defaults=</b> parameter can be used to set or change the defaults for different columns:

          # Set default age to 1:
          table.transform(defaults={"age": 1})

          # Now remove the default from that column:
          table.transform(defaults={"age": None})

   <b>Changing</b> <b>column</b> <b>order</b>
       The  <b>column_order=</b>  parameter  can be used to change the order of the columns. If you pass the names of a
       subset of the columns those will go first and columns you omitted will appear  in  their  existing  order
       after them.

          # Change column order
          table.transform(column_order=("name", "age", "id")

   <b>Adding</b> <b>foreign</b> <b>key</b> <b>constraints</b>
       You can add one or more foreign key constraints to a table using the <b>add_foreign_keys=</b> parameter:

          db["places"].transform(
              add_foreign_keys=(
                  ("country", "country", "id"),
                  ("continent", "continent", "id")
              )
          )

       This  accepts the same arguments described in <u>specifying</u> <u>foreign</u> <u>keys</u> - so you can specify them as a full
       tuple of <b>(column,</b> <b>other_table,</b> <b>other_column)</b>, or you can take a shortcut and pass just the  name  of  the
       column, provided the table can be automatically derived from the column name:

          db["places"].transform(
              add_foreign_keys=(("country", "continent"))
          )

   <b>Replacing</b> <b>foreign</b> <b>key</b> <b>constraints</b>
       The <b>foreign_keys=</b> parameter is similar to  to <b>add_foreign_keys=</b> but can be be used to replace all foreign
       key constraints on a table, dropping any that are not explicitly mentioned:

          db["places"].transform(
              foreign_keys=(
                  ("continent", "continent", "id"),
              )
          )

   <b>Dropping</b> <b>foreign</b> <b>key</b> <b>constraints</b>
       You can use <b>.transform()</b> to remove foreign key constraints from a table.

       This  example  drops  two  foreign  keys  -  the  one  from <b>places.country</b> to <b>country.id</b> and the one from
       <b>places.continent</b> to <b>continent.id</b>:

          db["places"].transform(
              drop_foreign_keys=("country", "continent")
          )

   <b>Custom</b> <b>transformations</b> <b>with</b> <b>.transform_sql()</b>
       The <b>.transform()</b> method can handle most cases, but it does not automatically upgrade  indexes,  views  or
       triggers associated with the table that is being transformed.

       If you want to do something more advanced, you can call the <b>table.transform_sql(...)</b> method with the same
       arguments that you would have passed to <b>table.transform(...)</b>.

       This method will return a list of SQL statements that should be executed to implement the change. You can
       then make modifications to that SQL - or add additional SQL statements - before executing it yourself.

   <b>Extracting</b> <b>columns</b> <b>into</b> <b>a</b> <b>separate</b> <b>table</b>
       The <b>table.extract()</b> method can be used to extract specified columns into a separate table.

       Imagine a <b>Trees</b> table that looks like this:
                                           ┌────┬──────────────┬─────────┐
                                           │ id │ TreeAddress  │ Species │
                                           ├────┼──────────────┼─────────┤
                                           │ 1  │ 52 Vine St   │ Palm    │
                                           ├────┼──────────────┼─────────┤
                                           │ 2  │ 12 Draft St  │ Oak     │
                                           ├────┼──────────────┼─────────┤
                                           │ 3  │ 51 Dark Ave  │ Palm    │
                                           ├────┼──────────────┼─────────┤
                                           │ 4  │ 1252 Left St │ Palm    │
                                           └────┴──────────────┴─────────┘

       The  <b>Species</b>  column contains duplicate values. This database could be improved by extracting that column
       out into a separate <b>Species</b> table and pointing to it using a foreign key column.

       The schema of the above table is:

          CREATE TABLE [Trees] (
              [id] INTEGER PRIMARY KEY,
              [TreeAddress] TEXT,
              [Species] TEXT
          )

       Here's how to extract the <b>Species</b> column using <b>.extract()</b>:

          db["Trees"].extract("Species")

       After running this code the table schema now looks like this:

          CREATE TABLE "Trees" (
              [id] INTEGER PRIMARY KEY,
              [TreeAddress] TEXT,
              [Species_id] INTEGER,
              FOREIGN KEY(Species_id) REFERENCES Species(id)
          )

       A new <b>Species</b> table will have been created with the following schema:

          CREATE TABLE [Species] (
              [id] INTEGER PRIMARY KEY,
              [Species] TEXT
          )

       The <b>.extract()</b> method defaults to creating a table with the same name as the column that  was  extracted,
       and adding a foreign key column called <b>tablename_id</b>.

       You  can  specify  a custom table name using <b>table=</b>, and a custom foreign key name using <b>fk_column=</b>. This
       example creates a table called <b>tree_species</b> and a foreign key column called <b>tree_species_id</b>:

          db["Trees"].extract("Species", table="tree_species", fk_column="tree_species_id")

       The resulting schema looks like this:

          CREATE TABLE "Trees" (
              [id] INTEGER PRIMARY KEY,
              [TreeAddress] TEXT,
              [tree_species_id] INTEGER,
              FOREIGN KEY(tree_species_id) REFERENCES tree_species(id)
          )

          CREATE TABLE [tree_species] (
              [id] INTEGER PRIMARY KEY,
              [Species] TEXT
          )

       You can also extract multiple columns into the same external table. Say for example you have a table like
       this:
                                    ┌────┬──────────────┬────────────┬───────────┐
                                    │ id │ TreeAddress  │ CommonName │ LatinName │
                                    ├────┼──────────────┼────────────┼───────────┤
                                    │ 1  │ 52 Vine St   │ Palm       │ Arecaceae │
                                    ├────┼──────────────┼────────────┼───────────┤
                                    │ 2  │ 12 Draft St  │ Oak        │ Quercus   │
                                    ├────┼──────────────┼────────────┼───────────┤
                                    │ 3  │ 51 Dark Ave  │ Palm       │ Arecaceae │
                                    ├────┼──────────────┼────────────┼───────────┤
                                    │ 4  │ 1252 Left St │ Palm       │ Arecaceae │
                                    └────┴──────────────┴────────────┴───────────┘

       You can pass <b>["CommonName",</b> <b>"LatinName"]</b> to <b>.extract()</b> to extract both of those columns:

          db["Trees"].extract(["CommonName", "LatinName"])

       This produces the following schema:

          CREATE TABLE "Trees" (
              [id] INTEGER PRIMARY KEY,
              [TreeAddress] TEXT,
              [CommonName_LatinName_id] INTEGER,
              FOREIGN KEY(CommonName_LatinName_id) REFERENCES CommonName_LatinName(id)
          )
          CREATE TABLE [CommonName_LatinName] (
              [id] INTEGER PRIMARY KEY,
              [CommonName] TEXT,
              [LatinName] TEXT
          )

       The table name <b>CommonName_LatinName</b> is  derived  from  the  extract  columns.  You  can  use  <b>table=</b>  and
       <b>fk_column=</b> to specify custom names like this:

          db["Trees"].extract(["CommonName", "LatinName"], table="Species", fk_column="species_id")

       This produces the following schema:

          CREATE TABLE "Trees" (
              [id] INTEGER PRIMARY KEY,
              [TreeAddress] TEXT,
              [species_id] INTEGER,
              FOREIGN KEY(species_id) REFERENCES Species(id)
          )
          CREATE TABLE [Species] (
              [id] INTEGER PRIMARY KEY,
              [CommonName] TEXT,
              [LatinName] TEXT
          )

       You  can  use  the <b>rename=</b> argument to rename columns in the lookup table. To create a <b>Species</b> table with
       columns called <b>name</b> and <b>latin</b> you can do this:

          db["Trees"].extract(
              ["CommonName", "LatinName"],
              table="Species",
              fk_column="species_id",
              rename={"CommonName": "name", "LatinName": "latin"}
          )

       This produces a lookup table like so:

          CREATE TABLE [Species] (
              [id] INTEGER PRIMARY KEY,
              [name] TEXT,
              [latin] TEXT
          )

   <b>Setting</b> <b>an</b> <b>ID</b> <b>based</b> <b>on</b> <b>the</b> <b>hash</b> <b>of</b> <b>the</b> <b>row</b> <b>contents</b>
       Sometimes you will find yourself working with a dataset that includes rows that do not  have  a  provided
       obvious  ID,  but where you would like to assign one so that you can later upsert into that table without
       creating duplicate records.

       In these cases, a useful technique is to create an ID that is derived from  the  sha1  hash  of  the  row
       contents.

       <b>sqlite-utils</b> can do this for you using the <b>hash_id=</b> option. For example:

          db = sqlite_utils.Database("dogs.db")
          db["dogs"].upsert({"name": "Cleo", "twitter": "cleopaws"}, hash_id="id")
          print(list(db["dogs]))

       Outputs:

          [{'id': 'f501265970505d9825d8d9f590bfab3519fb20b1', 'name': 'Cleo', 'twitter': 'cleopaws'}]

       If you are going to use that ID straight away, you can access it using <b>last_pk</b>:

          dog_id = db["dogs"].upsert({
              "name": "Cleo",
              "twitter": "cleopaws"
          }, hash_id="id").last_pk
          # dog_id is now "f501265970505d9825d8d9f590bfab3519fb20b1"

       The  hash will be created using all of the column values. To create a hash using a subset of the columns,
       pass the <b>hash_id_columns=</b> parameter:

          db["dogs"].upsert(
              {"name": "Cleo", "twitter": "cleopaws", "age": 7},
              hash_id_columns=("name", "twitter")
          )

       The <b>hash_id=</b> parameter is optional if you specify <b>hash_id_columns=</b> - it will default to putting the  hash
       in a column called <b>id</b>.

       You can manually calculate these hashes using the <u>hash_record(record,</u> <u>keys=...)</u> utility function.

   <b>Creating</b> <b>views</b>
       The <b>.create_view()</b> method on the database class can be used to create a view:

          db.create_view("good_dogs", """
              select * from dogs where is_good_dog = 1
          """)

       This will raise a <b>sqlite_utils.utils.OperationalError</b> if a view with that name already exists.

       You  can  pass <b>ignore=True</b> to silently ignore an existing view and do nothing, or <b>replace=True</b> to replace
       an existing view with a new definition if your select statement differs from the current view:

          db.create_view("good_dogs", """
              select * from dogs where is_good_dog = 1
          """, replace=True)

   <b>Storing</b> <b>JSON</b>
       SQLite has <u>excellent</u> <u>JSON</u> <u>support</u>, and <b>sqlite-utils</b> can help you take advantage of this: if  you  attempt
       to  insert  a  value  that can be represented as a JSON list or dictionary, <b>sqlite-utils</b> will create TEXT
       column and store your data as serialized JSON. This  means  you  can  quickly  store  even  complex  data
       structures in SQLite and query them using JSON features.

       For example:

          db["niche_museums"].insert({
              "name": "The Bigfoot Discovery Museum",
              "url": "<a href="http://bigfootdiscoveryproject.com/">http://bigfootdiscoveryproject.com/</a>"
              "hours": {
                  "Monday": [11, 18],
                  "Wednesday": [11, 18],
                  "Thursday": [11, 18],
                  "Friday": [11, 18],
                  "Saturday": [11, 18],
                  "Sunday": [11, 18]
              },
              "address": {
                  "streetAddress": "5497 Highway 9",
                  "addressLocality": "Felton, CA",
                  "postalCode": "95018"
              }
          })
          db.execute("""
              select json_extract(address, '$.addressLocality')
              from niche_museums
          """).fetchall()
          # Returns [('Felton, CA',)]

   <b>Converting</b> <b>column</b> <b>values</b> <b>using</b> <b>SQL</b> <b>functions</b>
       Sometimes it can be useful to run values through a SQL function prior to inserting them. A simple example
       might be converting a value to upper case while it is being inserted.

       The  <b>conversions={...}</b>  parameter  can  be  used  to specify custom SQL to be used as part of a <b>INSERT</b> or
       <b>UPDATE</b> SQL statement.

       You can specify an upper case conversion for a specific column like so:

          db["example"].insert({
              "name": "The Bigfoot Discovery Museum"
          }, conversions={"name": "upper(?)"})

          # list(db["example"].rows) now returns:
          # [{'name': 'THE BIGFOOT DISCOVERY MUSEUM'}]

       The dictionary key is the column name to be converted. The value is the SQL fragment to  use,  with  a  <b>?</b>
       placeholder for the original value.

       A  more  useful  example:  if  you  are  working  with <u>SpatiaLite</u> you may find yourself wanting to create
       geometry values from a WKT value. Code to do that could look like this:

          import sqlite3
          import sqlite_utils
          from shapely.geometry import shape
          import httpx

          db = sqlite_utils.Database("places.db")
          # Initialize SpatiaLite
          db.init_spatialite()
          # Use sqlite-utils to create a places table
          places = db["places"].create({"id": int, "name": str})

          # Add a SpatiaLite 'geometry' column
          places.add_geometry_column("geometry", "MULTIPOLYGON")

          # Fetch some GeoJSON from Who's On First:
          geojson = httpx.get(
              "https://raw.githubusercontent.com/whosonfirst-data/"
              "whosonfirst-data-admin-gb/master/data/404/227/475/404227475.geojson"
          ).json()

          # Convert to "Well Known Text" format using shapely
          wkt = shape(geojson["geometry"]).wkt

          # Insert the record, converting the WKT to a SpatiaLite geometry:
          db["places"].insert(
              {"name": "Wales", "geometry": wkt},
              conversions={"geometry": "GeomFromText(?, 4326)"},
          )

       This example uses gographical data from <u>Who's</u> <u>On</u> <u>First</u> and  depends  on  the  <u>Shapely</u>  and  <u>HTTPX</u>  Python
       libraries.

   <b>Checking</b> <b>the</b> <b>SQLite</b> <b>version</b>
       The  <b>db.sqlite_version</b>  property  returns a tuple of integers representing the version of SQLite used for
       that database object:

          &gt;&gt;&gt; db.sqlite_version
          (3, 36, 0)

   <b>Dumping</b> <b>the</b> <b>database</b> <b>to</b> <b>SQL</b>
       The <b>db.iterdump()</b> method returns a sequence of SQL strings representing a complete dump of the  database.
       Use it like this:

          full_sql = "".join(db.iterdump())

       This uses the <u>sqlite3.Connection.iterdump()</u> method.

       If  you  are  using  <b>pysqlite3</b>  or  <b>sqlean.py</b>  the underlying method may be missing. If you install the ‐
       <u>sqlite-dump</u> package then the <b>db.iterdump()</b> method will use that implementation instead:

          pip install sqlite-dump

   <b>Introspecting</b> <b>tables</b> <b>and</b> <b>views</b>
       If you have loaded an existing table or view, you can use introspection to find out more about it:

          &gt;&gt;&gt; db["PlantType"]
          &lt;Table PlantType (id, value)&gt;

   <b>.exists()</b>
       The <b>.exists()</b> method can be used to find out if a table exists or not:

          &gt;&gt;&gt; db["PlantType"].exists()
          True
          &gt;&gt;&gt; db["PlantType2"].exists()
          False

   <b>.count</b>
       The <b>.count</b> property shows the current number of rows (<b>select</b> <b>count(*)</b> <b>from</b> <b>table</b>):

          &gt;&gt;&gt; db["PlantType"].count
          3
          &gt;&gt;&gt; db["Street_Tree_List"].count
          189144

       This property will take advantage of <u>Cached</u> <u>table</u> <u>counts</u> <u>using</u> <u>triggers</u> if the <b>use_counts_table</b>  property
       is  set  on the database. You can avoid that optimization entirely by calling <b>table.count_where()</b> instead
       of accessing the property.

   <b>.columns</b>
       The <b>.columns</b> property shows the columns in the table or view. It returns  a  list  of  <b>Column(cid,</b>  <b>name,</b>
       <b>type,</b> <b>notnull,</b> <b>default_value,</b> <b>is_pk)</b> named tuples.

          &gt;&gt;&gt; db["PlantType"].columns
          [Column(cid=0, name='id', type='INTEGER', notnull=0, default_value=None, is_pk=1),
           Column(cid=1, name='value', type='TEXT', notnull=0, default_value=None, is_pk=0)]

   <b>.columns_dict</b>
       The  <b>.columns_dict</b>  property  returns  a dictionary version of the columns with just the names and Python
       types:

          &gt;&gt;&gt; db["PlantType"].columns_dict
          {'id': &lt;class 'int'&gt;, 'value': &lt;class 'str'&gt;}

   <b>.default_values</b>
       The <b>.default_values</b> property returns a dictionary of default values for each column that has a default:

          &gt;&gt;&gt; db["table_with_defaults"].default_values
          {'score': 5}

   <b>.pks</b>
       The <b>.pks</b> property returns a list of strings naming the primary key columns for the table:

          &gt;&gt;&gt; db["PlantType"].pks
          ['id']

       If a table has no primary keys but is a <u>rowid</u> <u>table</u>, this property will return <b>['rowid']</b>.

   <b>.use_rowid</b>
       Almost all SQLite tables have a <b>rowid</b> column, but a table with no explicitly defined  primary  keys  must
       use  that <b>rowid</b> as the primary key for identifying individual rows. The <b>.use_rowid</b> property checks to see
       if a table needs to use the <b>rowid</b> in this way - it returns <b>True</b> if the table has  no  explicitly  defined
       primary keys and <b>False</b> otherwise.

       &gt;&gt;&gt; db["PlantType"].use_rowid
       False

   <b>.foreign_keys</b>
       The  <b>.foreign_keys</b>  property  returns  any  foreign  key  relationships  for  the  table,  as  a  list of
       <b>ForeignKey(table,</b> <b>column,</b> <b>other_table,</b> <b>other_column)</b> named tuples. It is not available on views.

          &gt;&gt;&gt; db["Street_Tree_List"].foreign_keys
          [ForeignKey(table='Street_Tree_List', column='qLegalStatus', other_table='qLegalStatus', other_column='id'),
           ForeignKey(table='Street_Tree_List', column='qCareAssistant', other_table='qCareAssistant', other_column='id'),
           ForeignKey(table='Street_Tree_List', column='qSiteInfo', other_table='qSiteInfo', other_column='id'),
           ForeignKey(table='Street_Tree_List', column='qSpecies', other_table='qSpecies', other_column='id'),
           ForeignKey(table='Street_Tree_List', column='qCaretaker', other_table='qCaretaker', other_column='id'),
           ForeignKey(table='Street_Tree_List', column='PlantType', other_table='PlantType', other_column='id')]

   <b>.schema</b>
       The <b>.schema</b> property outputs the table's schema as a SQL string:

          &gt;&gt;&gt; print(db["Street_Tree_List"].schema)
          CREATE TABLE "Street_Tree_List" (
          "TreeID" INTEGER,
            "qLegalStatus" INTEGER,
            "qSpecies" INTEGER,
            "qAddress" TEXT,
            "SiteOrder" INTEGER,
            "qSiteInfo" INTEGER,
            "PlantType" INTEGER,
            "qCaretaker" INTEGER,
            "qCareAssistant" INTEGER,
            "PlantDate" TEXT,
            "DBH" INTEGER,
            "PlotSize" TEXT,
            "PermitNotes" TEXT,
            "XCoord" REAL,
            "YCoord" REAL,
            "Latitude" REAL,
            "Longitude" REAL,
            "Location" TEXT
          ,
          FOREIGN KEY ("PlantType") REFERENCES [PlantType](id),
              FOREIGN KEY ("qCaretaker") REFERENCES [qCaretaker](id),
              FOREIGN KEY ("qSpecies") REFERENCES [qSpecies](id),
              FOREIGN KEY ("qSiteInfo") REFERENCES [qSiteInfo](id),
              FOREIGN KEY ("qCareAssistant") REFERENCES [qCareAssistant](id),
              FOREIGN KEY ("qLegalStatus") REFERENCES [qLegalStatus](id))

   <b>.strict</b>
       The <b>.strict</b> property identifies if the table is a <u>SQLite</u> <u>STRICT</u> <u>table</u>.

          &gt;&gt;&gt; db["ny_times_us_counties"].strict
          False

   <b>.indexes</b>
       The <b>.indexes</b> property returns all indexes created for a table, as a  list  of  <b>Index(seq,</b>  <b>name,</b>  <b>unique,</b>
       <b>origin,</b> <b>partial,</b> <b>columns)</b> named tuples. It is not available on views.

          &gt;&gt;&gt; db["Street_Tree_List"].indexes
          [Index(seq=0, name='"Street_Tree_List_qLegalStatus"', unique=0, origin='c', partial=0, columns=['qLegalStatus']),
           Index(seq=1, name='"Street_Tree_List_qCareAssistant"', unique=0, origin='c', partial=0, columns=['qCareAssistant']),
           Index(seq=2, name='"Street_Tree_List_qSiteInfo"', unique=0, origin='c', partial=0, columns=['qSiteInfo']),
           Index(seq=3, name='"Street_Tree_List_qSpecies"', unique=0, origin='c', partial=0, columns=['qSpecies']),
           Index(seq=4, name='"Street_Tree_List_qCaretaker"', unique=0, origin='c', partial=0, columns=['qCaretaker']),
           Index(seq=5, name='"Street_Tree_List_PlantType"', unique=0, origin='c', partial=0, columns=['PlantType'])]

   <b>.xindexes</b>
       The <b>.xindexes</b> property returns more detailed information about the indexes on the table, using the SQLite
       <u>PRAGMA</u> <u>index_xinfo()</u> mechanism. It returns a list of <b>XIndex(name,</b> <b>columns)</b> named tuples, where <b>columns</b> is
       a list of <b>XIndexColumn(seqno,</b> <b>cid,</b> <b>name,</b> <b>desc,</b> <b>coll,</b> <b>key)</b> named tuples.

          &gt;&gt;&gt; db["ny_times_us_counties"].xindexes
          [
              XIndex(
                  name='idx_ny_times_us_counties_date',
                  columns=[
                      XIndexColumn(seqno=0, cid=0, name='date', desc=1, coll='BINARY', key=1),
                      XIndexColumn(seqno=1, cid=-1, name=None, desc=0, coll='BINARY', key=0)
                  ]
              ),
              XIndex(
                  name='idx_ny_times_us_counties_fips',
                  columns=[
                      XIndexColumn(seqno=0, cid=3, name='fips', desc=0, coll='BINARY', key=1),
                      XIndexColumn(seqno=1, cid=-1, name=None, desc=0, coll='BINARY', key=0)
                  ]
              )
          ]

   <b>.triggers</b>
       The  <b>.triggers</b>  property  lists  database triggers. It can be used on both database and table objects. It
       returns a list of <b>Trigger(name,</b> <b>table,</b> <b>sql)</b> named tuples.

          &gt;&gt;&gt; db["authors"].triggers
          [Trigger(name='authors_ai', table='authors', sql='CREATE TRIGGER [authors_ai] AFTER INSERT...'),
           Trigger(name='authors_ad', table='authors', sql="CREATE TRIGGER [authors_ad] AFTER DELETE..."),
           Trigger(name='authors_au', table='authors', sql="CREATE TRIGGER [authors_au] AFTER UPDATE")]
          &gt;&gt;&gt; db.triggers
          ... similar output to db["authors"].triggers

   <b>.triggers_dict</b>
       The <b>.triggers_dict</b> property returns the triggers for that table as a dictionary mapping  their  names  to
       their SQL definitions.

          &gt;&gt;&gt; db["authors"].triggers_dict
          {'authors_ai': 'CREATE TRIGGER [authors_ai] AFTER INSERT...',
           'authors_ad': 'CREATE TRIGGER [authors_ad] AFTER DELETE...',
           'authors_au': 'CREATE TRIGGER [authors_au] AFTER UPDATE'}

       The same property exists on the database, and will return all triggers across all tables:

          &gt;&gt;&gt; db.triggers_dict
          {'authors_ai': 'CREATE TRIGGER [authors_ai] AFTER INSERT...',
           'authors_ad': 'CREATE TRIGGER [authors_ad] AFTER DELETE...',
           'authors_au': 'CREATE TRIGGER [authors_au] AFTER UPDATE'}

   <b>.detect_fts()</b>
       The  <b>detect_fts()</b>  method  returns the associated SQLite FTS table name, if one exists for this table. If
       the table has not been configured for full-text search it returns <b>None</b>.

          &gt;&gt;&gt; db["authors"].detect_fts()
          "authors_fts"

   <b>.virtual_table_using</b>
       The <b>.virtual_table_using</b> property reveals if a table is a virtual table.  It  returns  <b>None</b>  for  regular
       tables and the upper case version of the type of virtual table otherwise. For example:

          &gt;&gt;&gt; db["authors"].enable_fts(["name"])
          &gt;&gt;&gt; db["authors_fts"].virtual_table_using
          "FTS5"

   <b>.has_counts_triggers</b>
       The  <b>.has_counts_triggers</b>  property  shows  if  a  table has been configured with triggers for updating a
       <b>_counts</b> table, as described in <u>Cached</u> <u>table</u> <u>counts</u> <u>using</u> <u>triggers</u>.

          &gt;&gt;&gt; db["authors"].has_counts_triggers
          False
          &gt;&gt;&gt; db["authors"].enable_counts()
          &gt;&gt;&gt; db["authors"].has_counts_triggers
          True

   <b>db.supports_strict</b>
       This property on the database object returns <b>True</b> if the available SQLite version supports  <u>STRICT</u>  <u>mode</u>,
       which was added in SQLite 3.37.0 (on 2021-11-27).

          &gt;&gt;&gt; db.supports_strict
          True

   <b>Full-text</b> <b>search</b>
       SQLite includes bundled extensions that implement <u>powerful</u> <u>full-text</u> <u>search</u>.

   <b>Enabling</b> <b>full-text</b> <b>search</b> <b>for</b> <b>a</b> <b>table</b>
       You can enable full-text search on a table using <b>.enable_fts(columns)</b>:

          db["dogs"].enable_fts(["name", "twitter"])

       You can then run searches using the <b>.search()</b> method:

          rows = list(db["dogs"].search("cleo"))

       This  method  returns  a  generator  that can be looped over to get dictionaries for each row, similar to
       <u>Listing</u> <u>rows</u>.

       If you insert additional records into the  table  you  will  need  to  refresh  the  search  index  using
       <b>populate_fts()</b>:

          db["dogs"].insert({
              "id": 2,
              "name": "Marnie",
              "twitter": "MarnieTheDog",
              "age": 16,
              "is_good_dog": True,
          }, pk="id")
          db["dogs"].populate_fts(["name", "twitter"])

       A  better  solution is to use database triggers. You can set up database triggers to automatically update
       the full-text index using <b>create_triggers=True</b>:

          db["dogs"].enable_fts(["name", "twitter"], create_triggers=True)

       <b>.enable_fts()</b> defaults to using <u>FTS5</u>. If you wish to use <u>FTS4</u> instead, use the following:

          db["dogs"].enable_fts(["name", "twitter"], fts_version="FTS4")

       You can customize the tokenizer configured for the table using the <b>tokenize=</b> parameter. For  example,  to
       enable Porter stemming, where English words like "running" will match stemmed alternatives such as "run",
       use <b>tokenize="porter"</b>:

          db["articles"].enable_fts(["headline", "body"], tokenize="porter")

       The  SQLite  documentation  has more on <u>FTS5</u> <u>tokenizers</u> and <u>FTS4</u> <u>tokenizers</u>. <b>porter</b> is a valid option for
       both.

       If you attempt to configure a FTS table where one already exists,  a  <b>sqlite3.OperationalError</b>  exception
       will be raised.

       You can replace the existing table with a new configuration using <b>replace=True</b>:

          db["articles"].enable_fts(["headline"], tokenize="porter", replace=True)

       This  will  have no effect if the FTS table already exists, otherwise it will drop and recreate the table
       with the new settings. This takes into consideration the columns, the tokenizer, the FTS version used and
       whether or not the table has triggers.

       To remove the FTS tables and triggers you created, use the <b>disable_fts()</b> table method:

          db["dogs"].disable_fts()

   <b>Quoting</b> <b>characters</b> <b>for</b> <b>use</b> <b>in</b> <b>search</b>
       SQLite supports <u>advanced</u> <u>search</u> <u>query</u> <u>syntax</u>. In some situations you may  wish  to  disable  this,  since
       characters  such  as <b>.</b> may have special meaning that causes errors when searching for strings provided by
       your users.

       The <b>db.quote_fts(query)</b> method returns the query with SQLite full-text search quoting applied  such  that
       the query should be safe to use in a search:

          db.quote_fts("Search term.")
          # Returns: '"Search" "term."'

   <b>Searching</b> <b>with</b> <b>table.search()</b>
       The  <b>table.search(q)</b> method returns a generator over Python dictionaries representing rows that match the
       search phrase <b>q</b>, ordered by relevance with the most relevant results first.

          for article in db["articles"].search("jquery"):
              print(article)

       The <b>.search()</b> method also accepts the following optional parameters:

       <b>order_by</b> <b>string</b>
              The column to sort by. Defaults to relevance score. Can optionally  include  a  <b>desc</b>,  e.g.  <b>rowid</b>
              <b>desc</b>.

       <b>columns</b> <b>array</b> <b>of</b> <b>strings</b>
              Columns to return. Defaults to all columns.

       <b>limit</b> <b>integer</b>
              Number of results to return. Defaults to all results.

       <b>offset</b> <b>integer</b>
              Offset to use along side the limit parameter.

       <b>where</b> <b>string</b>
              Extra SQL fragment for the WHERE clause

       <b>where_args</b> <b>dictionary</b>
              Arguments to use for <b>:param</b> placeholders in the extra WHERE clause

       <b>include_rank</b> <b>bool</b>
              If set a <b>rank</b> column will be included with the BM25 ranking score - for FTS5 tables only.

       <b>quote</b> <b>bool</b>
              Apply  <u>FTS</u> <u>quoting</u> <u>rules</u> to the search query, disabling advanced query syntax in a way that avoids
              surprising errors.

       To return just the title and published columns for three matches for <b>"dog"</b> where the <b>id</b> is  greater  than
       10 ordered by <b>published</b> with the most recent first, use the following:

          for article in db["articles"].search(
              "dog",
              order_by="published desc",
              limit=3,
              where="id &gt; :min_id",
              where_args={"min_id": 10},
              columns=["title", "published"]
          ):
              print(article)

   <b>Building</b> <b>SQL</b> <b>queries</b> <b>with</b> <b>table.search_sql()</b>
       You  can  generate  the SQL query that would be used for a search using the <b>table.search_sql()</b> method. It
       takes the same arguments as <b>table.search()</b>, with the exception of the search  query  and  the  <b>where_args</b>
       parameter, since those should be provided when the returned SQL is executed.

          print(db["articles"].search_sql(columns=["title", "author"]))

       Outputs:

          with original as (
              select
                  rowid,
                  [title],
                  [author]
              from [articles]
          )
          select
              [original].[title],
              [original].[author]
          from
              [original]
              join [articles_fts] on [original].rowid = [articles_fts].rowid
          where
              [articles_fts] match :query
          order by
              [articles_fts].rank

       This  method  detects  if  a  SQLite table uses FTS4 or FTS5, and outputs the correct SQL for ordering by
       relevance depending on the search type.

       The FTS4 output looks something like this:

          with original as (
              select
                  rowid,
                  [title],
                  [author]
              from [articles]
          )
          select
              [original].[title],
              [original].[author]
          from
              [original]
              join [articles_fts] on [original].rowid = [articles_fts].rowid
          where
              [articles_fts] match :query
          order by
              rank_bm25(matchinfo([articles_fts], 'pcnalx'))

       This uses the <b>rank_bm25()</b> custom SQL function from <u>sqlite-fts4</u>. You can  register  that  custom  function
       against a <b>Database</b> connection using this method:

          db.register_fts4_bm25()

   <b>Rebuilding</b> <b>a</b> <b>full-text</b> <b>search</b> <b>table</b>
       You  can  rebuild  a  table  using  the  <b>table.rebuild_fts()</b>  method.  This  is  useful  for if the table
       configuration changes or the indexed data has become corrupted in some way.

          db["dogs"].rebuild_fts()

       This method can be called on a table that has been  configured  for  full-text  search  -  <b>dogs</b>  in  this
       instance -  or directly on a <b>_fts</b> table:

          db["dogs_fts"].rebuild_fts()

       This runs the following SQL:

          INSERT INTO dogs_fts (dogs_fts) VALUES ("rebuild");

   <b>Optimizing</b> <b>a</b> <b>full-text</b> <b>search</b> <b>table</b>
       Once you have populated a FTS table you can optimize it to dramatically reduce its size like so:

          db["dogs"].optimize()

       This runs the following SQL:

          INSERT INTO dogs_fts (dogs_fts) VALUES ("optimize");

   <b>Cached</b> <b>table</b> <b>counts</b> <b>using</b> <b>triggers</b>
       The  <b>select</b>  <b>count(*)</b>  query  in  SQLite  requires  a full scan of the primary key index, and can take an
       increasingly long time as the table grows larger.

       The <b>table.enable_counts()</b> method can be used to configure triggers to continuously update a record  in  a
       <b>_counts</b> table. This value can then be used to quickly retrieve the count of rows in the associated table.

          db["dogs"].enable_counts()

       This will create the <b>_counts</b> table if it does not already exist, with the following schema:

          CREATE TABLE [_counts] (
             [table] TEXT PRIMARY KEY,
             [count] INTEGER DEFAULT 0
          )

       You  can  enable  cached  counts for every table in a database (except for virtual tables and the <b>_counts</b>
       table itself) using the database <b>enable_counts()</b> method:

          db.enable_counts()

       Once enabled, table counts will be stored in the <b>_counts</b> table. The count records will  be  automatically
       kept up-to-date by the triggers when rows are added or deleted to the table.

       To  access  these  counts  you can query the <b>_counts</b> table directly or you can use the <b>db.cached_counts()</b>
       method. This method returns a dictionary mapping tables to their counts:

          &gt;&gt;&gt; db.cached_counts()
          {'global-power-plants': 33643,
           'global-power-plants_fts_data': 136,
           'global-power-plants_fts_idx': 199,
           'global-power-plants_fts_docsize': 33643,
           'global-power-plants_fts_config': 1}

       You can pass a list of table names to this method to retrieve just those counts:

          &gt;&gt;&gt; db.cached_counts(["global-power-plants"])
          {'global-power-plants': 33643}

       The <b>table.count</b> property executes a <b>select</b> <b>count(*)</b> query  by  default,  unless  the  <b>db.use_counts_table</b>
       property is set to <b>True</b>.

       You can set <b>use_counts_table</b> to <b>True</b> when you instantiate the database object:

          db = Database("global-power-plants.db", use_counts_table=True)

       If the property is <b>True</b> any calls to the <b>table.count</b> property will first attempt to find the cached count
       in  the  <b>_counts</b>  table,  and fall back on a <b>count(*)</b> query if the value is not available or the table is
       missing.

       Calling the <b>.enable_counts()</b> method on a database or table object will set <b>use_counts_table</b> to  <b>True</b>  for
       the lifetime of that database object.

       If  the  <b>_counts</b>  table ever becomes out-of-sync with the actual table counts you can repair it using the
       <b>.reset_counts()</b> method:

          db.reset_counts()

   <b>Creating</b> <b>indexes</b>
       You can create an index on a table using the <b>.create_index(columns)</b> method. The method takes  a  list  of
       columns:

          db["dogs"].create_index(["is_good_dog"])

       By  default the index will be named <b>idx_{table-name}_{columns}</b>. If you pass <b>find_unique_name=True</b> and the
       automatically derived name already exists, an available name will  be  found  by  incrementing  a  suffix
       number, for example <b>idx_items_title_2</b>.

       You can customize the name of the created index by passing the <b>index_name</b> parameter:

          db["dogs"].create_index(
              ["is_good_dog", "age"],
              index_name="good_dogs_by_age"
          )

       To create an index in descending order for a column, wrap the column name in <b>db.DescIndex()</b> like this:

          from sqlite_utils.db import DescIndex

          db["dogs"].create_index(
              ["is_good_dog", DescIndex("age")],
              index_name="good_dogs_by_age"
          )

       You can create a unique index by passing <b>unique=True</b>:

          db["dogs"].create_index(["name"], unique=True)

       Use <b>if_not_exists=True</b> to do nothing if an index with that name already exists.

       Pass <b>analyze=True</b> to run <b>ANALYZE</b> against the new index after creating it.

   <b>Optimizing</b> <b>index</b> <b>usage</b> <b>with</b> <b>ANALYZE</b>
       The  <u>SQLite</u>  <u>ANALYZE</u>  <u>command</u> builds a table of statistics which the query planner can use to make better
       decisions about which indexes to use for a given query.

       You should run <b>ANALYZE</b> if your database is large and you do not think your indexes are being  efficiently
       used.

       To run <b>ANALYZE</b> against every index in a database, use this:

          db.analyze()

       To run it just against a specific named index, pass the name of the index to that method:

          db.analyze("idx_countries_country_name")

       To  run  against  all  indexes  attached  to  a  specific  table,  you  can either pass the table name to
       <b>db.analyze(...)</b> or you can call the method directly on the table, like this:

          db["dogs"].analyze()

   <b>Vacuum</b>
       You can optimize your database by running VACUUM against it like so:

          Database("my_database.db").vacuum()

   <b>WAL</b> <b>mode</b>
       You can enable <u>Write-Ahead</u> <u>Logging</u> for a database with <b>.enable_wal()</b>:

          Database("my_database.db").enable_wal()

       You can disable WAL mode using <b>.disable_wal()</b>:

          Database("my_database.db").disable_wal()

       You can check the current journal mode for a database using the <b>journal_mode</b> property:

          journal_mode = Database("my_database.db").journal_mode

       This will usually be <b>wal</b> or <b>delete</b> (meaning WAL is disabled), but can have other values - see the  <u>PRAGMA</u>
       <u>journal_mode</u> documentation.

   <b>Suggesting</b> <b>column</b> <b>types</b>
       When  you create a new table for a list of inserted or upserted Python dictionaries, those methods detect
       the correct types for the database columns based on the data you pass in.

       In some situations you may need to intervene in this process, to customize the  columns  that  are  being
       created in some way - see <u>Explicitly</u> <u>creating</u> <u>a</u> <u>table</u>.

       That table <b>.create()</b> method takes a dictionary mapping column names to the Python type they should store:

          db["cats"].create({
              "id": int,
              "name": str,
              "weight": float,
          })

       You  can  use the <b>suggest_column_types()</b> helper function to derive a dictionary of column names and types
       from a list of records, suitable to be passed to <b>table.create()</b>.

       For example:

          from sqlite_utils import Database, suggest_column_types

          cats = [{
              "id": 1,
              "name": "Snowflake"
          }, {
              "id": 2,
              "name": "Crabtree",
              "age": 4
          }]
          types = suggest_column_types(cats)
          # types now looks like this:
          # {"id": &lt;class 'int'&gt;,
          #  "name": &lt;class 'str'&gt;,
          #  "age": &lt;class 'int'&gt;}

          # Manually add an extra field:
          types["thumbnail"] = bytes
          # types now looks like this:
          # {"id": &lt;class 'int'&gt;,
          #  "name": &lt;class 'str'&gt;,
          #  "age": &lt;class 'int'&gt;,
          #  "thumbnail": &lt;class 'bytes'&gt;}

          # Create the table
          db = Database("cats.db")
          db["cats"].create(types, pk="id")
          # Insert the records
          db["cats"].insert_all(cats)

          # list(db["cats"].rows) now returns:
          # [{"id": 1, "name": "Snowflake", "age": None, "thumbnail": None}
          #  {"id": 2, "name": "Crabtree", "age": 4, "thumbnail": None}]

          # The table schema looks like this:
          # print(db["cats"].schema)
          # CREATE TABLE [cats] (
          #    [id] INTEGER PRIMARY KEY,
          #    [name] TEXT,
          #    [age] INTEGER,
          #    [thumbnail] BLOB
          # )

   <b>Registering</b> <b>custom</b> <b>SQL</b> <b>functions</b>
       SQLite supports registering custom SQL functions written in  Python.  The  <b>db.register_function()</b>  method
       lets you register these functions, and keeps track of functions that have already been registered.

       If  you  use  it  as a method it will automatically detect the name and number of arguments needed by the
       function:

          from sqlite_utils import Database

          db = Database(memory=True)

          def reverse_string(s):
              return "".join(reversed(list(s)))

          db.register_function(reverse_string)
          print(db.execute('select reverse_string("hello")').fetchone()[0])
          # This prints "olleh"

       You can also use the method as a function decorator like so:

          @db.register_function
          def reverse_string(s):
              return "".join(reversed(list(s)))

          print(db.execute('select reverse_string("hello")').fetchone()[0])

       By default, the name of the Python function will be used as  the  name  of  the  SQL  function.  You  can
       customize this with the <b>name=</b> keyword argument:

          @db.register_function(name="rev")
          def reverse_string(s):
              return "".join(reversed(list(s)))

          print(db.execute('select rev("hello")').fetchone()[0])

       Python  3.8 added the ability to register <u>deterministic</u> <u>SQLite</u> <u>functions</u>, allowing you to indicate that a
       function will return the exact same result for any given inputs and hence allowing SQLite to  apply  some
       performance optimizations. You can mark a function as deterministic using <b>deterministic=True</b>, like this:

          @db.register_function(deterministic=True)
          def reverse_string(s):
              return "".join(reversed(list(s)))

       If you run this on a version of Python prior to 3.8 your code will still work, but the <b>deterministic=True</b>
       parameter will be ignored.

       By  default  registering  a function with the same name and number of arguments will have no effect - the
       <b>Database</b> instance keeps track of functions that have already been registered and skips  registering  them
       if <b>@db.register_function</b> is called a second time.

       If  you  want  to  deliberately  replace  the  registered  function  with  a  new implementation, use the
       <b>replace=True</b> argument:

          @db.register_function(deterministic=True, replace=True)
          def reverse_string(s):
              return s[::-1]

       Exceptions that occur inside a user-defined function default to returning the following error:

          Unexpected error: user-defined function raised exception

       You can cause <b>sqlite3</b> to return more useful errors, including the traceback from the custom function,  by
       executing the following before your custom functions are executed:

          from sqlite_utils.utils import sqlite3

          sqlite3.enable_callback_tracebacks(True)

   <b>Quoting</b> <b>strings</b> <b>for</b> <b>use</b> <b>in</b> <b>SQL</b>
       In  almost all cases you should pass values to your SQL queries using the optional <b>parameters</b> argument to
       <b>db.query()</b>, as described in <u>Passing</u> <u>parameters</u>.

       If that option isn't relevant to your use-case you can to quote a string for use with  SQLite  using  the
       <b>db.quote()</b> method, like so:

          &gt;&gt;&gt; db = Database(memory=True)
          &gt;&gt;&gt; db.quote("hello")
          "'hello'"
          &gt;&gt;&gt; db.quote("hello'this'has'quotes")
          "'hello''this''has''quotes'"

   <b>Reading</b> <b>rows</b> <b>from</b> <b>a</b> <b>file</b>
       The  <b>sqlite_utils.utils.rows_from_file()</b>  helper function can read rows (a sequence of dictionaries) from
       CSV, TSV, JSON or newline-delimited JSON files.

   <b>Setting</b> <b>the</b> <b>maximum</b> <b>CSV</b> <b>field</b> <b>size</b> <b>limit</b>
       Sometimes when working with CSV files that include extremely long fields you may see an error that  looks
       like this:

          _csv.Error: field larger than field limit (131072)

       The Python standard library <b>csv</b> module enforces a field size limit. You can increase that limit using the
       <b>csv.field_size_limit(new_limit)</b>  method  (<u>documented</u>  <u>here</u>) but if you don't want to pick a new level you
       may instead want to increase it to the maximum possible.

       The maximum possible value for this is not documented, and varies between systems.

       Calling <b>sqlite_utils.utils.maximize_csv_field_size_limit()</b> will set the value to the highest possible for
       the current system:

          from sqlite_utils.utils import maximize_csv_field_size_limit

          maximize_csv_field_size_limit()

       If you need to reset to the original value after calling this function you can do so like this:

          from sqlite_utils.utils import ORIGINAL_CSV_FIELD_SIZE_LIMIT
          import csv

          csv.field_size_limit(ORIGINAL_CSV_FIELD_SIZE_LIMIT)

   <b>Detecting</b> <b>column</b> <b>types</b> <b>using</b> <b>TypeTracker</b>
       Sometimes you may find yourself working with data that lacks type information - data from a CSV file  for
       example.

       The <b>TypeTracker</b> class can be used to try to automatically identify the most likely types for data that is
       initially represented as strings.

       Consider this example:

          import csv, io

          csv_file = io.StringIO("id,name\n1,Cleo\n2,Cardi")
          rows = list(csv.DictReader(csv_file))

          # rows is now this:
          # [{'id': '1', 'name': 'Cleo'}, {'id': '2', 'name': 'Cardi'}]

       If we insert this data directly into a table we will get a schema that is entirely <b>TEXT</b> columns:

          from sqlite_utils import Database

          db = Database(memory=True)
          db["creatures"].insert_all(rows)
          print(db.schema)
          # Outputs:
          # CREATE TABLE [creatures] (
          #    [id] TEXT,
          #    [name] TEXT
          # );

       We can detect the best column types using a <b>TypeTracker</b> instance:

          from sqlite_utils.utils import TypeTracker

          tracker = TypeTracker()
          db["creatures2"].insert_all(tracker.wrap(rows))
          print(tracker.types)
          # Outputs {'id': 'integer', 'name': 'text'}

       We can then apply those types to our new table using the <u>table.transform()</u> method:

          db["creatures2"].transform(types=tracker.types)
          print(db["creatures2"].schema)
          # Outputs:
          # CREATE TABLE [creatures2] (
          #    [id] INTEGER,
          #    [name] TEXT
          # );

   <b>SpatiaLite</b> <b>helpers</b>
       <u>SpatiaLite</u> is a geographic extension to SQLite (similar to PostgreSQL + PostGIS). Using requires finding,
       loading  and  initializing  the  extension,  adding  geometry  columns  to existing tables and optionally
       creating spatial indexes. The utilities here help streamline that setup.

   <b>Initialize</b> <b>SpatiaLite</b>
   <b>Finding</b> <b>SpatiaLite</b>
   <b>Adding</b> <b>geometry</b> <b>columns</b>
   <b>Creating</b> <b>a</b> <b>spatial</b> <b>index</b>
   <b>Plugins</b>
       <b>sqlite-utils</b> supports plugins, which can be used to add extra features to the software.

       Plugins can add new commands, for example <b>sqlite-utils</b> <b>some-command</b> <b>...</b>

       Plugins can be installed using the <b>sqlite-utils</b> <b>install</b> command:

          sqlite-utils install sqlite-utils-name-of-plugin

       You can see a JSON list of plugins that have been installed by running this:

          sqlite-utils plugins

       Plugin hooks such as <u>prepare_connection(conn)</u> affect each instance of the <b>Database</b> class. You can opt-out
       of these plugins by creating that class instance like so:

          db = Database(memory=True, execute_plugins=False)

   <b>Building</b> <b>a</b> <b>plugin</b>
       Plugins are created in a directory named after the plugin. To create a "hello world" plugin, first create
       a <b>hello-world</b> directory:

          mkdir hello-world
          cd hello-world

       In that folder create two files. The first is a <b>pyproject.toml</b> file describing the plugin:

          [project]
          name = "sqlite-utils-hello-world"
          version = "0.1"

          [project.entry-points.sqlite_utils]
          hello_world = "sqlite_utils_hello_world"

       The <b>[project.entry-points.sqlite_utils]</b> section tells <b>sqlite-utils</b> which module to  load  when  executing
       the plugin.

       Then create <b>sqlite_utils_hello_world.py</b> with the following content:

          import click
          import sqlite_utils

          @sqlite_utils.hookimpl
          def register_commands(cli):
              @cli.command()
              def hello_world():
                  "Say hello world"
                  click.echo("Hello world!")

       Install  the  plugin  in  "editable"  mode  - so you can make changes to the code and have them picked up
       instantly by <b>sqlite-utils</b> - like this:

          sqlite-utils install -e .

       Or pass the path to your plugin directory:

          sqlite-utils install -e /dev/sqlite-utils-hello-world

       Now, running this should execute your new command:

          sqlite-utils hello-world

       Your command will also be listed in the output of <b>sqlite-utils</b> <b>--help</b>.

       See the <u>LLM</u> <u>plugin</u> <u>documentation</u> for tips on distributing your plugin.

   <b>Plugin</b> <b>hooks</b>
       Plugin hooks allow <b>sqlite-utils</b> to be customized.

   <b>register_commands(cli)</b>
       This hook can be used to register additional commands with the <b>sqlite-utils</b> CLI. It is  called  with  the
       <b>cli</b> object, which is a <b>click.Group</b> instance.

       Example implementation:

          import click
          import sqlite_utils

          @sqlite_utils.hookimpl
          def register_commands(cli):
              @cli.command()
              def hello_world():
                  "Say hello world"
                  click.echo("Hello world!")

       New commands implemented by plugins can invoke existing commands using the <u>context.invoke</u> mechanism.

       As  a  special niche feature, if your plugin needs to import some files and then act against an in-memory
       database containing those files  you  can  forward  to  the  <u>sqlite-utils</u>  <u>memory</u>  <u>command</u>  and  pass  it
       <b>return_db=True</b>:

          @cli.command()
          @click.pass_context
          @click.argument(
              "paths",
              type=click.Path(file_okay=True, dir_okay=False, allow_dash=True),
              required=False,
              nargs=-1,
          )
          def show_schema_for_files(ctx, paths):
              from sqlite_utils.cli import memory
              db = ctx.invoke(memory, paths=paths, return_db=True)
              # Now do something with that database
              click.echo(db.schema)

   <b>prepare_connection(conn)</b>
       This  hook  is called when a new SQLite database connection is created. You can use it to <u>register</u> <u>custom</u>
       <u>SQL</u> <u>functions</u>, aggregates and collations. For example:

          import sqlite_utils

          @sqlite_utils.hookimpl
          def prepare_connection(conn):
              conn.create_function(
                  "hello", 1, lambda name: f"Hello, {name}!"
              )

       This registers a SQL function called <b>hello</b> which takes a single argument and can be called like this:

          select hello("world"); -- "Hello, world!"

   <b>API</b> <b>reference</b>
       • <u>sqlite_utils.db.Database</u>

       • <u>sqlite_utils.db.Queryable</u>

       • <u>sqlite_utils.db.Table</u>

       • <u>sqlite_utils.db.View</u>

       • <u>Other</u>

         • <u>sqlite_utils.db.Column</u>

         • <u>sqlite_utils.db.ColumnDetails</u>

       • <u>sqlite_utils.utils</u>

         • <u>sqlite_utils.utils.hash_record</u>

         • <u>sqlite_utils.utils.rows_from_file</u>

         • <u>sqlite_utils.utils.TypeTracker</u>

         • <u>sqlite_utils.utils.chunks</u>

         • <u>sqlite_utils.utils.flatten</u>

   <b>sqlite_utils.db.Database</b>
   <b>sqlite_utils.db.Queryable</b>
       <u>Table</u> and <u>View</u> are  both subclasses of <b>Queryable</b>, providing access to the following methods:

   <b>sqlite_utils.db.Table</b>
   <b>sqlite_utils.db.View</b>
   <b>Other</b>
   <b>sqlite_utils.db.Column</b>
   <b>sqlite_utils.db.ColumnDetails</b>
   <b>sqlite_utils.utils</b>
   <b>sqlite_utils.utils.hash_record</b>
   <b>sqlite_utils.utils.rows_from_file</b>
   <b>sqlite_utils.utils.TypeTracker</b>
   <b>sqlite_utils.utils.chunks</b>
   <b>sqlite_utils.utils.flatten</b>
   <b>CLI</b> <b>reference</b>
       This page lists the <b>--help</b> for every <b>sqlite-utils</b> CLI sub-command.

       • <u>query</u>

       • <u>memory</u>

       • <u>insert</u>

       • <u>upsert</u>

       • <u>bulk</u>

       • <u>search</u>

       • <u>transform</u>

       • <u>extract</u>

       • <u>schema</u>

       • <u>insert-files</u>

       • <u>analyze-tables</u>

       • <u>convert</u>

       • <u>tables</u>

       • <u>views</u>

       • <u>rows</u>

       • <u>triggers</u>

       • <u>indexes</u>

       • <u>create-database</u>

       • <u>create-table</u>

       • <u>create-index</u>

       • <u>enable-fts</u>

       • <u>populate-fts</u>

       • <u>rebuild-fts</u>

       • <u>disable-fts</u>

       • <u>tui</u>

       • <u>optimize</u>

       • <u>analyze</u>

       • <u>vacuum</u>

       • <u>dump</u>

       • <u>add-column</u>

       • <u>add-foreign-key</u>

       • <u>add-foreign-keys</u>

       • <u>index-foreign-keys</u>

       • <u>enable-wal</u>

       • <u>disable-wal</u>

       • <u>enable-counts</u>

       • <u>reset-counts</u>

       • <u>duplicate</u>

       • <u>rename-table</u>

       • <u>drop-table</u>

       • <u>create-view</u>

       • <u>drop-view</u>

       • <u>install</u>

       • <u>uninstall</u>

       • <u>add-geometry-column</u>

       • <u>create-spatial-index</u>

       • <u>plugins</u>

   <b>query</b>
       See <u>Running</u> <u>SQL</u> <u>queries</u>.

          Usage: sqlite-utils query [OPTIONS] PATH SQL

            Execute SQL query and return the results as JSON

            Example:

                sqlite-utils data.db \
                    "select * from chickens where age &gt; :age" \
                    -p age 1

          Options:
            --attach &lt;TEXT FILE&gt;...     Additional databases to attach - specify alias and
                                        filepath
            --nl                        Output newline-delimited JSON
            --arrays                    Output rows as arrays instead of objects
            --csv                       Output CSV
            --tsv                       Output TSV
            --no-headers                Omit CSV headers
            -t, --table                 Output as a formatted table
            --fmt TEXT                  Table format - one of asciidoc, double_grid,
                                        double_outline, fancy_grid, fancy_outline, github,
                                        grid, heavy_grid, heavy_outline, html, jira,
                                        latex, latex_booktabs, latex_longtable, latex_raw,
                                        mediawiki, mixed_grid, mixed_outline, moinmoin,
                                        orgtbl, outline, pipe, plain, presto, pretty,
                                        psql, rounded_grid, rounded_outline, rst, simple,
                                        simple_grid, simple_outline, textile, tsv,
                                        unsafehtml, youtrack
            --json-cols                 Detect JSON cols and output them as JSON, not
                                        escaped strings
            -r, --raw                   Raw output, first column of first row
            --raw-lines                 Raw output, first column of each row
            -p, --param &lt;TEXT TEXT&gt;...  Named :parameters for SQL query
            --functions TEXT            Python code defining one or more custom SQL
                                        functions
            --load-extension TEXT       Path to SQLite extension, with optional
                                        :entrypoint
            -h, --help                  Show this message and exit.

   <b>memory</b>
       See <u>Querying</u> <u>data</u> <u>directly</u> <u>using</u> <u>an</u> <u>in-memory</u> <u>database</u>.

          Usage: sqlite-utils memory [OPTIONS] [PATHS]... SQL

            Execute SQL query against an in-memory database, optionally populated by
            imported data

            To import data from CSV, TSV or JSON files pass them on the command-line:

                sqlite-utils memory one.csv two.json \
                    "select * from one join two on one.two_id = two.id"

            For data piped into the tool from standard input, use "-" or "stdin":

                cat animals.csv | sqlite-utils memory - \
                    "select * from stdin where species = 'dog'"

            The format of the data will be automatically detected. You can specify the
            format explicitly using :json, :csv, :tsv or :nl (for newline-delimited JSON)
            - for example:

                cat animals.csv | sqlite-utils memory stdin:csv places.dat:nl \
                    "select * from stdin where place_id in (select id from places)"

            Use --schema to view the SQL schema of any imported files:

                sqlite-utils memory animals.csv --schema

          Options:
            --functions TEXT            Python code defining one or more custom SQL
                                        functions
            --attach &lt;TEXT FILE&gt;...     Additional databases to attach - specify alias and
                                        filepath
            --flatten                   Flatten nested JSON objects, so {"foo": {"bar":
                                        1}} becomes {"foo_bar": 1}
            --nl                        Output newline-delimited JSON
            --arrays                    Output rows as arrays instead of objects
            --csv                       Output CSV
            --tsv                       Output TSV
            --no-headers                Omit CSV headers
            -t, --table                 Output as a formatted table
            --fmt TEXT                  Table format - one of asciidoc, double_grid,
                                        double_outline, fancy_grid, fancy_outline, github,
                                        grid, heavy_grid, heavy_outline, html, jira,
                                        latex, latex_booktabs, latex_longtable, latex_raw,
                                        mediawiki, mixed_grid, mixed_outline, moinmoin,
                                        orgtbl, outline, pipe, plain, presto, pretty,
                                        psql, rounded_grid, rounded_outline, rst, simple,
                                        simple_grid, simple_outline, textile, tsv,
                                        unsafehtml, youtrack
            --json-cols                 Detect JSON cols and output them as JSON, not
                                        escaped strings
            -r, --raw                   Raw output, first column of first row
            --raw-lines                 Raw output, first column of each row
            -p, --param &lt;TEXT TEXT&gt;...  Named :parameters for SQL query
            --encoding TEXT             Character encoding for CSV input, defaults to
                                        utf-8
            -n, --no-detect-types       Treat all CSV/TSV columns as TEXT
            --schema                    Show SQL schema for in-memory database
            --dump                      Dump SQL for in-memory database
            --save FILE                 Save in-memory database to this file
            --analyze                   Analyze resulting tables and output results
            --load-extension TEXT       Path to SQLite extension, with optional
                                        :entrypoint
            -h, --help                  Show this message and exit.

   <b>insert</b>
       See <u>Inserting</u> <u>JSON</u> <u>data</u>, <u>Inserting</u> <u>CSV</u> <u>or</u> <u>TSV</u> <u>data</u>, <u>Inserting</u> <u>unstructured</u> <u>data</u> <u>with</u> <u>--lines</u> <u>and</u>  <u>--text</u>,
       <u>Applying</u> <u>conversions</u> <u>while</u> <u>inserting</u> <u>data</u>.

          Usage: sqlite-utils insert [OPTIONS] PATH TABLE FILE

            Insert records from FILE into a table, creating the table if it does not
            already exist.

            Example:

                echo '{"name": "Lila"}' | sqlite-utils insert data.db chickens -

            By default the input is expected to be a JSON object or array of objects.

            - Use --nl for newline-delimited JSON objects
            - Use --csv or --tsv for comma-separated or tab-separated input
            - Use --lines to write each incoming line to a column called "line"
            - Use --text to write the entire input to a column called "text"

            You can also use --convert to pass a fragment of Python code that will be used
            to convert each input.

            Your Python code will be passed a "row" variable representing the imported
            row, and can return a modified row.

            This example uses just the name, latitude and longitude columns from a CSV
            file, converting name to upper case and latitude and longitude to floating
            point numbers:

                sqlite-utils insert plants.db plants plants.csv --csv --convert '
                  return {
                    "name": row["name"].upper(),
                    "latitude": float(row["latitude"]),
                    "longitude": float(row["longitude"]),
                  }'

            If you are using --lines your code will be passed a "line" variable, and for
            --text a "text" variable.

            When using --text your function can return an iterator of rows to insert. This
            example inserts one record per word in the input:

                echo 'A bunch of words' | sqlite-utils insert words.db words - \
                  --text --convert '({"word": w} for w in text.split())'

          Options:
            --pk TEXT                 Columns to use as the primary key, e.g. id
            --flatten                 Flatten nested JSON objects, so {"a": {"b": 1}}
                                      becomes {"a_b": 1}
            --nl                      Expect newline-delimited JSON
            -c, --csv                 Expect CSV input
            --tsv                     Expect TSV input
            --empty-null              Treat empty strings as NULL
            --lines                   Treat each line as a single value called 'line'
            --text                    Treat input as a single value called 'text'
            --convert TEXT            Python code to convert each item
            --import TEXT             Python modules to import
            --delimiter TEXT          Delimiter to use for CSV files
            --quotechar TEXT          Quote character to use for CSV/TSV
            --sniff                   Detect delimiter and quote character
            --no-headers              CSV file has no header row
            --encoding TEXT           Character encoding for input, defaults to utf-8
            --batch-size INTEGER      Commit every X records
            --stop-after INTEGER      Stop after X records
            --alter                   Alter existing table to add any missing columns
            --not-null TEXT           Columns that should be created as NOT NULL
            --default &lt;TEXT TEXT&gt;...  Default value that should be set for a column
            -d, --detect-types        Detect types for columns in CSV/TSV data
            --analyze                 Run ANALYZE at the end of this operation
            --load-extension TEXT     Path to SQLite extension, with optional :entrypoint
            --silent                  Do not show progress bar
            --strict                  Apply STRICT mode to created table
            --ignore                  Ignore records if pk already exists
            --replace                 Replace records if pk already exists
            --truncate                Truncate table before inserting records, if table
                                      already exists
            -h, --help                Show this message and exit.

   <b>upsert</b>
       See <u>Upserting</u> <u>data</u>.

          Usage: sqlite-utils upsert [OPTIONS] PATH TABLE FILE

            Upsert records based on their primary key. Works like 'insert' but if an
            incoming record has a primary key that matches an existing record the existing
            record will be updated.

            Example:

                echo '[
                    {"id": 1, "name": "Lila"},
                    {"id": 2, "name": "Suna"}
                ]' | sqlite-utils upsert data.db chickens - --pk id

          Options:
            --pk TEXT                 Columns to use as the primary key, e.g. id
                                      [required]
            --flatten                 Flatten nested JSON objects, so {"a": {"b": 1}}
                                      becomes {"a_b": 1}
            --nl                      Expect newline-delimited JSON
            -c, --csv                 Expect CSV input
            --tsv                     Expect TSV input
            --empty-null              Treat empty strings as NULL
            --lines                   Treat each line as a single value called 'line'
            --text                    Treat input as a single value called 'text'
            --convert TEXT            Python code to convert each item
            --import TEXT             Python modules to import
            --delimiter TEXT          Delimiter to use for CSV files
            --quotechar TEXT          Quote character to use for CSV/TSV
            --sniff                   Detect delimiter and quote character
            --no-headers              CSV file has no header row
            --encoding TEXT           Character encoding for input, defaults to utf-8
            --batch-size INTEGER      Commit every X records
            --stop-after INTEGER      Stop after X records
            --alter                   Alter existing table to add any missing columns
            --not-null TEXT           Columns that should be created as NOT NULL
            --default &lt;TEXT TEXT&gt;...  Default value that should be set for a column
            -d, --detect-types        Detect types for columns in CSV/TSV data
            --analyze                 Run ANALYZE at the end of this operation
            --load-extension TEXT     Path to SQLite extension, with optional :entrypoint
            --silent                  Do not show progress bar
            --strict                  Apply STRICT mode to created table
            -h, --help                Show this message and exit.

   <b>bulk</b>
       See <u>Executing</u> <u>SQL</u> <u>in</u> <u>bulk</u>.

          Usage: sqlite-utils bulk [OPTIONS] PATH SQL FILE

            Execute parameterized SQL against the provided list of documents.

            Example:

                echo '[
                    {"id": 1, "name": "Lila2"},
                    {"id": 2, "name": "Suna2"}
                ]' | sqlite-utils bulk data.db '
                    update chickens set name = :name where id = :id
                ' -

          Options:
            --batch-size INTEGER   Commit every X records
            --functions TEXT       Python code defining one or more custom SQL functions
            --flatten              Flatten nested JSON objects, so {"a": {"b": 1}} becomes
                                   {"a_b": 1}
            --nl                   Expect newline-delimited JSON
            -c, --csv              Expect CSV input
            --tsv                  Expect TSV input
            --empty-null           Treat empty strings as NULL
            --lines                Treat each line as a single value called 'line'
            --text                 Treat input as a single value called 'text'
            --convert TEXT         Python code to convert each item
            --import TEXT          Python modules to import
            --delimiter TEXT       Delimiter to use for CSV files
            --quotechar TEXT       Quote character to use for CSV/TSV
            --sniff                Detect delimiter and quote character
            --no-headers           CSV file has no header row
            --encoding TEXT        Character encoding for input, defaults to utf-8
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>search</b>
       See <u>Executing</u> <u>searches</u>.

          Usage: sqlite-utils search [OPTIONS] PATH DBTABLE Q

            Execute a full-text search against this table

            Example:

                sqlite-utils search data.db chickens lila

          Options:
            -o, --order TEXT       Order by ('column' or 'column desc')
            -c, --column TEXT      Columns to return
            --limit INTEGER        Number of rows to return - defaults to everything
            --sql                  Show SQL query that would be run
            --quote                Apply FTS quoting rules to search term
            --nl                   Output newline-delimited JSON
            --arrays               Output rows as arrays instead of objects
            --csv                  Output CSV
            --tsv                  Output TSV
            --no-headers           Omit CSV headers
            -t, --table            Output as a formatted table
            --fmt TEXT             Table format - one of asciidoc, double_grid,
                                   double_outline, fancy_grid, fancy_outline, github,
                                   grid, heavy_grid, heavy_outline, html, jira, latex,
                                   latex_booktabs, latex_longtable, latex_raw, mediawiki,
                                   mixed_grid, mixed_outline, moinmoin, orgtbl, outline,
                                   pipe, plain, presto, pretty, psql, rounded_grid,
                                   rounded_outline, rst, simple, simple_grid,
                                   simple_outline, textile, tsv, unsafehtml, youtrack
            --json-cols            Detect JSON cols and output them as JSON, not escaped
                                   strings
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>transform</b>
       See <u>Transforming</u> <u>tables</u>.

          Usage: sqlite-utils transform [OPTIONS] PATH TABLE

            Transform a table beyond the capabilities of ALTER TABLE

            Example:

                sqlite-utils transform mydb.db mytable \
                    --drop column1 \
                    --rename column2 column_renamed

          Options:
            --type &lt;TEXT CHOICE&gt;...         Change column type to INTEGER, TEXT, FLOAT or
                                            BLOB
            --drop TEXT                     Drop this column
            --rename &lt;TEXT TEXT&gt;...         Rename this column to X
            -o, --column-order TEXT         Reorder columns
            --not-null TEXT                 Set this column to NOT NULL
            --not-null-false TEXT           Remove NOT NULL from this column
            --pk TEXT                       Make this column the primary key
            --pk-none                       Remove primary key (convert to rowid table)
            --default &lt;TEXT TEXT&gt;...        Set default value for this column
            --default-none TEXT             Remove default from this column
            --add-foreign-key &lt;TEXT TEXT TEXT&gt;...
                                            Add a foreign key constraint from a column to
                                            another table with another column
            --drop-foreign-key TEXT         Drop foreign key constraint for this column
            --sql                           Output SQL without executing it
            --load-extension TEXT           Path to SQLite extension, with optional
                                            :entrypoint
            -h, --help                      Show this message and exit.

   <b>extract</b>
       See <u>Extracting</u> <u>columns</u> <u>into</u> <u>a</u> <u>separate</u> <u>table</u>.

          Usage: sqlite-utils extract [OPTIONS] PATH TABLE COLUMNS...

            Extract one or more columns into a separate table

            Example:

                sqlite-utils extract trees.db Street_Trees species

          Options:
            --table TEXT             Name of the other table to extract columns to
            --fk-column TEXT         Name of the foreign key column to add to the table
            --rename &lt;TEXT TEXT&gt;...  Rename this column in extracted table
            --load-extension TEXT    Path to SQLite extension, with optional :entrypoint
            -h, --help               Show this message and exit.

   <b>schema</b>
       See <u>Showing</u> <u>the</u> <u>schema</u>.

          Usage: sqlite-utils schema [OPTIONS] PATH [TABLES]...

            Show full schema for this database or for specified tables

            Example:

                sqlite-utils schema trees.db

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>insert-files</b>
       See <u>Inserting</u> <u>data</u> <u>from</u> <u>files</u>.

          Usage: sqlite-utils insert-files [OPTIONS] PATH TABLE FILE_OR_DIR...

            Insert one or more files using BLOB columns in the specified table

            Example:

                sqlite-utils insert-files pics.db images *.gif \
                    -c name:name \
                    -c content:content \
                    -c content_hash:sha256 \
                    -c created:ctime_iso \
                    -c modified:mtime_iso \
                    -c size:size \
                    --pk name

          Options:
            -c, --column TEXT      Column definitions for the table
            --pk TEXT              Column to use as primary key
            --alter                Alter table to add missing columns
            --replace              Replace files with matching primary key
            --upsert               Upsert files with matching primary key
            --name TEXT            File name to use
            --text                 Store file content as TEXT, not BLOB
            --encoding TEXT        Character encoding for input, defaults to utf-8
            -s, --silent           Don't show a progress bar
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>analyze-tables</b>
       See <u>Analyzing</u> <u>tables</u>.

          Usage: sqlite-utils analyze-tables [OPTIONS] PATH [TABLES]...

            Analyze the columns in one or more tables

            Example:

                sqlite-utils analyze-tables data.db trees

          Options:
            -c, --column TEXT       Specific columns to analyze
            --save                  Save results to _analyze_tables table
            --common-limit INTEGER  How many common values
            --no-most               Skip most common values
            --no-least              Skip least common values
            --load-extension TEXT   Path to SQLite extension, with optional :entrypoint
            -h, --help              Show this message and exit.

   <b>convert</b>
       See <u>Converting</u> <u>data</u> <u>in</u> <u>columns</u>.

          Usage: sqlite-utils convert [OPTIONS] DB_PATH TABLE COLUMNS... CODE

            Convert columns using Python code you supply. For example:

            sqlite-utils convert my.db mytable mycolumn \
                '"\n".join(textwrap.wrap(value, 10))' \
                --import=textwrap

            "value" is a variable with the column value to be converted.

            Use "-" for CODE to read Python code from standard input.

            The following common operations are available as recipe functions:

            r.jsonsplit(value, delimiter=',', type=&lt;class 'str'&gt;)

            Convert a string like a,b,c into a JSON array ["a", "b", "c"]

            r.parsedate(value, dayfirst=False, yearfirst=False, errors=None)

            Parse a date and convert it to ISO date format: yyyy-mm-dd

            - dayfirst=True: treat xx as the day in xx/yy/zz
            - yearfirst=True: treat xx as the year in xx/yy/zz
            - errors=r.IGNORE to ignore values that cannot be parsed
            - errors=r.SET_NULL to set values that cannot be parsed to null

            r.parsedatetime(value, dayfirst=False, yearfirst=False, errors=None)

            Parse a datetime and convert it to ISO datetime format: yyyy-mm-ddTHH:MM:SS

            - dayfirst=True: treat xx as the day in xx/yy/zz
            - yearfirst=True: treat xx as the year in xx/yy/zz
            - errors=r.IGNORE to ignore values that cannot be parsed
            - errors=r.SET_NULL to set values that cannot be parsed to null

            You can use these recipes like so:

            sqlite-utils convert my.db mytable mycolumn \
                'r.jsonsplit(value, delimiter=":")'

          Options:
            --import TEXT                   Python modules to import
            --dry-run                       Show results of running this against first 10
                                            rows
            --multi                         Populate columns for keys in returned
                                            dictionary
            --where TEXT                    Optional where clause
            -p, --param &lt;TEXT TEXT&gt;...      Named :parameters for where clause
            --output TEXT                   Optional separate column to populate with the
                                            output
            --output-type [integer|float|blob|text]
                                            Column type to use for the output column
            --drop                          Drop original column afterwards
            --no-skip-false                 Don't skip falsey values
            -s, --silent                    Don't show a progress bar
            --pdb                           Open pdb debugger on first error
            -h, --help                      Show this message and exit.

   <b>tables</b>
       See <u>Listing</u> <u>tables</u>.

          Usage: sqlite-utils tables [OPTIONS] PATH

            List the tables in the database

            Example:

                sqlite-utils tables trees.db

          Options:
            --fts4                 Just show FTS4 enabled tables
            --fts5                 Just show FTS5 enabled tables
            --counts               Include row counts per table
            --nl                   Output newline-delimited JSON
            --arrays               Output rows as arrays instead of objects
            --csv                  Output CSV
            --tsv                  Output TSV
            --no-headers           Omit CSV headers
            -t, --table            Output as a formatted table
            --fmt TEXT             Table format - one of asciidoc, double_grid,
                                   double_outline, fancy_grid, fancy_outline, github,
                                   grid, heavy_grid, heavy_outline, html, jira, latex,
                                   latex_booktabs, latex_longtable, latex_raw, mediawiki,
                                   mixed_grid, mixed_outline, moinmoin, orgtbl, outline,
                                   pipe, plain, presto, pretty, psql, rounded_grid,
                                   rounded_outline, rst, simple, simple_grid,
                                   simple_outline, textile, tsv, unsafehtml, youtrack
            --json-cols            Detect JSON cols and output them as JSON, not escaped
                                   strings
            --columns              Include list of columns for each table
            --schema               Include schema for each table
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>views</b>
       See <u>Listing</u> <u>views</u>.

          Usage: sqlite-utils views [OPTIONS] PATH

            List the views in the database

            Example:

                sqlite-utils views trees.db

          Options:
            --counts               Include row counts per view
            --nl                   Output newline-delimited JSON
            --arrays               Output rows as arrays instead of objects
            --csv                  Output CSV
            --tsv                  Output TSV
            --no-headers           Omit CSV headers
            -t, --table            Output as a formatted table
            --fmt TEXT             Table format - one of asciidoc, double_grid,
                                   double_outline, fancy_grid, fancy_outline, github,
                                   grid, heavy_grid, heavy_outline, html, jira, latex,
                                   latex_booktabs, latex_longtable, latex_raw, mediawiki,
                                   mixed_grid, mixed_outline, moinmoin, orgtbl, outline,
                                   pipe, plain, presto, pretty, psql, rounded_grid,
                                   rounded_outline, rst, simple, simple_grid,
                                   simple_outline, textile, tsv, unsafehtml, youtrack
            --json-cols            Detect JSON cols and output them as JSON, not escaped
                                   strings
            --columns              Include list of columns for each view
            --schema               Include schema for each view
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>rows</b>
       See <u>Returning</u> <u>all</u> <u>rows</u> <u>in</u> <u>a</u> <u>table</u>.

          Usage: sqlite-utils rows [OPTIONS] PATH DBTABLE

            Output all rows in the specified table

            Example:

                sqlite-utils rows trees.db Trees

          Options:
            -c, --column TEXT           Columns to return
            --where TEXT                Optional where clause
            -o, --order TEXT            Order by ('column' or 'column desc')
            -p, --param &lt;TEXT TEXT&gt;...  Named :parameters for where clause
            --limit INTEGER             Number of rows to return - defaults to everything
            --offset INTEGER            SQL offset to use
            --nl                        Output newline-delimited JSON
            --arrays                    Output rows as arrays instead of objects
            --csv                       Output CSV
            --tsv                       Output TSV
            --no-headers                Omit CSV headers
            -t, --table                 Output as a formatted table
            --fmt TEXT                  Table format - one of asciidoc, double_grid,
                                        double_outline, fancy_grid, fancy_outline, github,
                                        grid, heavy_grid, heavy_outline, html, jira,
                                        latex, latex_booktabs, latex_longtable, latex_raw,
                                        mediawiki, mixed_grid, mixed_outline, moinmoin,
                                        orgtbl, outline, pipe, plain, presto, pretty,
                                        psql, rounded_grid, rounded_outline, rst, simple,
                                        simple_grid, simple_outline, textile, tsv,
                                        unsafehtml, youtrack
            --json-cols                 Detect JSON cols and output them as JSON, not
                                        escaped strings
            --load-extension TEXT       Path to SQLite extension, with optional
                                        :entrypoint
            -h, --help                  Show this message and exit.

   <b>triggers</b>
       See <u>Listing</u> <u>triggers</u>.

          Usage: sqlite-utils triggers [OPTIONS] PATH [TABLES]...

            Show triggers configured in this database

            Example:

                sqlite-utils triggers trees.db

          Options:
            --nl                   Output newline-delimited JSON
            --arrays               Output rows as arrays instead of objects
            --csv                  Output CSV
            --tsv                  Output TSV
            --no-headers           Omit CSV headers
            -t, --table            Output as a formatted table
            --fmt TEXT             Table format - one of asciidoc, double_grid,
                                   double_outline, fancy_grid, fancy_outline, github,
                                   grid, heavy_grid, heavy_outline, html, jira, latex,
                                   latex_booktabs, latex_longtable, latex_raw, mediawiki,
                                   mixed_grid, mixed_outline, moinmoin, orgtbl, outline,
                                   pipe, plain, presto, pretty, psql, rounded_grid,
                                   rounded_outline, rst, simple, simple_grid,
                                   simple_outline, textile, tsv, unsafehtml, youtrack
            --json-cols            Detect JSON cols and output them as JSON, not escaped
                                   strings
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>indexes</b>
       See <u>Listing</u> <u>indexes</u>.

          Usage: sqlite-utils indexes [OPTIONS] PATH [TABLES]...

            Show indexes for the whole database or specific tables

            Example:

                sqlite-utils indexes trees.db Trees

          Options:
            --aux                  Include auxiliary columns
            --nl                   Output newline-delimited JSON
            --arrays               Output rows as arrays instead of objects
            --csv                  Output CSV
            --tsv                  Output TSV
            --no-headers           Omit CSV headers
            -t, --table            Output as a formatted table
            --fmt TEXT             Table format - one of asciidoc, double_grid,
                                   double_outline, fancy_grid, fancy_outline, github,
                                   grid, heavy_grid, heavy_outline, html, jira, latex,
                                   latex_booktabs, latex_longtable, latex_raw, mediawiki,
                                   mixed_grid, mixed_outline, moinmoin, orgtbl, outline,
                                   pipe, plain, presto, pretty, psql, rounded_grid,
                                   rounded_outline, rst, simple, simple_grid,
                                   simple_outline, textile, tsv, unsafehtml, youtrack
            --json-cols            Detect JSON cols and output them as JSON, not escaped
                                   strings
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>create-database</b>
       See <u>Creating</u> <u>an</u> <u>empty</u> <u>database</u>.

          Usage: sqlite-utils create-database [OPTIONS] PATH

            Create a new empty database file

            Example:

                sqlite-utils create-database trees.db

          Options:
            --enable-wal           Enable WAL mode on the created database
            --init-spatialite      Enable SpatiaLite on the created database
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>create-table</b>
       See <u>Creating</u> <u>tables</u>.

          Usage: sqlite-utils create-table [OPTIONS] PATH TABLE COLUMNS...

            Add a table with the specified columns. Columns should be specified using
            name, type pairs, for example:

                sqlite-utils create-table my.db people \
                    id integer \
                    name text \
                    height float \
                    photo blob --pk id

            Valid column types are text, integer, float and blob.

          Options:
            --pk TEXT                 Column to use as primary key
            --not-null TEXT           Columns that should be created as NOT NULL
            --default &lt;TEXT TEXT&gt;...  Default value that should be set for a column
            --fk &lt;TEXT TEXT TEXT&gt;...  Column, other table, other column to set as a
                                      foreign key
            --ignore                  If table already exists, do nothing
            --replace                 If table already exists, replace it
            --transform               If table already exists, try to transform the schema
            --load-extension TEXT     Path to SQLite extension, with optional :entrypoint
            --strict                  Apply STRICT mode to created table
            -h, --help                Show this message and exit.

   <b>create-index</b>
       See <u>Creating</u> <u>indexes</u>.

          Usage: sqlite-utils create-index [OPTIONS] PATH TABLE COLUMN...

            Add an index to the specified table for the specified columns

            Example:

                sqlite-utils create-index chickens.db chickens name

            To create an index in descending order:

                sqlite-utils create-index chickens.db chickens -- -name

          Options:
            --name TEXT                Explicit name for the new index
            --unique                   Make this a unique index
            --if-not-exists, --ignore  Ignore if index already exists
            --analyze                  Run ANALYZE after creating the index
            --load-extension TEXT      Path to SQLite extension, with optional :entrypoint
            -h, --help                 Show this message and exit.

   <b>enable-fts</b>
       See <u>Configuring</u> <u>full-text</u> <u>search</u>.

          Usage: sqlite-utils enable-fts [OPTIONS] PATH TABLE COLUMN...

            Enable full-text search for specific table and columns"

            Example:

                sqlite-utils enable-fts chickens.db chickens name

          Options:
            --fts4                 Use FTS4
            --fts5                 Use FTS5
            --tokenize TEXT        Tokenizer to use, e.g. porter
            --create-triggers      Create triggers to update the FTS tables when the
                                   parent table changes.
            --replace              Replace existing FTS configuration if it exists
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>populate-fts</b>
          Usage: sqlite-utils populate-fts [OPTIONS] PATH TABLE COLUMN...

            Re-populate full-text search for specific table and columns

            Example:

                sqlite-utils populate-fts chickens.db chickens name

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>rebuild-fts</b>
          Usage: sqlite-utils rebuild-fts [OPTIONS] PATH [TABLES]...

            Rebuild all or specific full-text search tables

            Example:

                sqlite-utils rebuild-fts chickens.db chickens

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>disable-fts</b>
          Usage: sqlite-utils disable-fts [OPTIONS] PATH TABLE

            Disable full-text search for specific table

            Example:

                sqlite-utils disable-fts chickens.db chickens

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>tui</b>
       See <u>Experimental</u> <u>TUI</u>.

          Usage: sqlite-utils tui [OPTIONS]

            Open Textual TUI.

          Options:
            -h, --help  Show this message and exit.

   <b>optimize</b>
       See <u>Optimize</u>.

          Usage: sqlite-utils optimize [OPTIONS] PATH [TABLES]...

            Optimize all full-text search tables and then run VACUUM - should shrink the
            database file

            Example:

                sqlite-utils optimize chickens.db

          Options:
            --no-vacuum            Don't run VACUUM
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>analyze</b>
       See <u>Optimizing</u> <u>index</u> <u>usage</u> <u>with</u> <u>ANALYZE</u>.

          Usage: sqlite-utils analyze [OPTIONS] PATH [NAMES]...

            Run ANALYZE against the whole database, or against specific named indexes and
            tables

            Example:

                sqlite-utils analyze chickens.db

          Options:
            -h, --help  Show this message and exit.

   <b>vacuum</b>
       See <u>Vacuum</u>.

          Usage: sqlite-utils vacuum [OPTIONS] PATH

            Run VACUUM against the database

            Example:

                sqlite-utils vacuum chickens.db

          Options:
            -h, --help  Show this message and exit.

   <b>dump</b>
       See <u>Dumping</u> <u>the</u> <u>database</u> <u>to</u> <u>SQL</u>.

          Usage: sqlite-utils dump [OPTIONS] PATH

            Output a SQL dump of the schema and full contents of the database

            Example:

                sqlite-utils dump chickens.db

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>add-column</b>
       See <u>Adding</u> <u>columns</u>.

          Usage: sqlite-utils add-column [OPTIONS] PATH TABLE COL_NAME
                                [[integer|int|float|text|str|blob|bytes]]

            Add a column to the specified table

            Example:

                sqlite-utils add-column chickens.db chickens weight float

          Options:
            --fk TEXT                Table to reference as a foreign key
            --fk-col TEXT            Referenced column on that foreign key table - if
                                     omitted will automatically use the primary key
            --not-null-default TEXT  Add NOT NULL DEFAULT 'TEXT' constraint
            --ignore                 If column already exists, do nothing
            --load-extension TEXT    Path to SQLite extension, with optional :entrypoint
            -h, --help               Show this message and exit.

   <b>add-foreign-key</b>
       See <u>Adding</u> <u>foreign</u> <u>key</u> <u>constraints</u>.

          Usage: sqlite-utils add-foreign-key [OPTIONS] PATH TABLE COLUMN [OTHER_TABLE]
                                     [OTHER_COLUMN]

            Add a new foreign key constraint to an existing table

            Example:

                sqlite-utils add-foreign-key my.db books author_id authors id

          Options:
            --ignore               If foreign key already exists, do nothing
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>add-foreign-keys</b>
       See <u>Adding</u> <u>multiple</u> <u>foreign</u> <u>keys</u> <u>at</u> <u>once</u>.

          Usage: sqlite-utils add-foreign-keys [OPTIONS] PATH [FOREIGN_KEY]...

            Add multiple new foreign key constraints to a database

            Example:

                sqlite-utils add-foreign-keys my.db \
                    books author_id authors id \
                    authors country_id countries id

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>index-foreign-keys</b>
       See <u>Adding</u> <u>indexes</u> <u>for</u> <u>all</u> <u>foreign</u> <u>keys</u>.

          Usage: sqlite-utils index-foreign-keys [OPTIONS] PATH

            Ensure every foreign key column has an index on it

            Example:

                sqlite-utils index-foreign-keys chickens.db

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>enable-wal</b>
       See <u>WAL</u> <u>mode</u>.

          Usage: sqlite-utils enable-wal [OPTIONS] PATH...

            Enable WAL for database files

            Example:

                sqlite-utils enable-wal chickens.db

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>disable-wal</b>
          Usage: sqlite-utils disable-wal [OPTIONS] PATH...

            Disable WAL for database files

            Example:

                sqlite-utils disable-wal chickens.db

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>enable-counts</b>
       See <u>Enabling</u> <u>cached</u> <u>counts</u>.

          Usage: sqlite-utils enable-counts [OPTIONS] PATH [TABLES]...

            Configure triggers to update a _counts table with row counts

            Example:

                sqlite-utils enable-counts chickens.db

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>reset-counts</b>
          Usage: sqlite-utils reset-counts [OPTIONS] PATH

            Reset calculated counts in the _counts table

            Example:

                sqlite-utils reset-counts chickens.db

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>duplicate</b>
       See <u>Duplicating</u> <u>tables</u>.

          Usage: sqlite-utils duplicate [OPTIONS] PATH TABLE NEW_TABLE

            Create a duplicate of this table, copying across the schema and all row data.

          Options:
            --ignore               If table does not exist, do nothing
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>rename-table</b>
       See <u>Renaming</u> <u>a</u> <u>table</u>.

          Usage: sqlite-utils rename-table [OPTIONS] PATH TABLE NEW_NAME

            Rename this table.

          Options:
            --ignore               If table does not exist, do nothing
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>drop-table</b>
       See <u>Dropping</u> <u>tables</u>.

          Usage: sqlite-utils drop-table [OPTIONS] PATH TABLE

            Drop the specified table

            Example:

                sqlite-utils drop-table chickens.db chickens

          Options:
            --ignore               If table does not exist, do nothing
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>create-view</b>
       See <u>Creating</u> <u>views</u>.

          Usage: sqlite-utils create-view [OPTIONS] PATH VIEW SELECT

            Create a view for the provided SELECT query

            Example:

                sqlite-utils create-view chickens.db heavy_chickens \
                  'select * from chickens where weight &gt; 3'

          Options:
            --ignore               If view already exists, do nothing
            --replace              If view already exists, replace it
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>drop-view</b>
       See <u>Dropping</u> <u>views</u>.

          Usage: sqlite-utils drop-view [OPTIONS] PATH VIEW

            Drop the specified view

            Example:

                sqlite-utils drop-view chickens.db heavy_chickens

          Options:
            --ignore               If view does not exist, do nothing
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>install</b>
       See <u>Installing</u> <u>packages</u>.

          Usage: sqlite-utils install [OPTIONS] [PACKAGES]...

            Install packages from PyPI into the same environment as sqlite-utils

          Options:
            -U, --upgrade        Upgrade packages to latest version
            -e, --editable TEXT  Install a project in editable mode from this path
            -h, --help           Show this message and exit.

   <b>uninstall</b>
       See <u>Uninstalling</u> <u>packages</u>.

          Usage: sqlite-utils uninstall [OPTIONS] PACKAGES...

            Uninstall Python packages from the sqlite-utils environment

          Options:
            -y, --yes   Don't ask for confirmation
            -h, --help  Show this message and exit.

   <b>add-geometry-column</b>
       See <u>SpatiaLite</u> <u>helpers</u>.

          Usage: sqlite-utils add-geometry-column [OPTIONS] DB_PATH TABLE COLUMN_NAME

            Add a SpatiaLite geometry column to an existing table. Requires SpatiaLite
            extension.

            By default, this command will try to load the SpatiaLite extension from usual
            paths. To load it from a specific path, use --load-extension.

          Options:
            -t, --type [POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION|GEOMETRY]
                                            Specify a geometry type for this column.
                                            [default: GEOMETRY]
            --srid INTEGER                  Spatial Reference ID. See
                                            https://spatialreference.org for details on
                                            specific projections.  [default: 4326]
            --dimensions TEXT               Coordinate dimensions. Use XYZ for three-
                                            dimensional geometries.
            --not-null                      Add a NOT NULL constraint.
            --load-extension TEXT           Path to SQLite extension, with optional
                                            :entrypoint
            -h, --help                      Show this message and exit.

   <b>create-spatial-index</b>
       See <u>Adding</u> <u>spatial</u> <u>indexes</u>.

          Usage: sqlite-utils create-spatial-index [OPTIONS] DB_PATH TABLE COLUMN_NAME

            Create a spatial index on a SpatiaLite geometry column. The table and geometry
            column must already exist before trying to add a spatial index.

            By default, this command will try to load the SpatiaLite extension from usual
            paths. To load it from a specific path, use --load-extension.

          Options:
            --load-extension TEXT  Path to SQLite extension, with optional :entrypoint
            -h, --help             Show this message and exit.

   <b>plugins</b>
          Usage: sqlite-utils plugins [OPTIONS]

            List installed plugins

          Options:
            -h, --help  Show this message and exit.

   <b>Contributing</b>
       Development of <b>sqlite-utils</b> takes place in the <u>sqlite-utils</u> <u>GitHub</u> <u>repository</u>.

       All  improvements  to  the software should start with an issue. Read <u>How</u> <u>I</u> <u>build</u> <u>a</u> <u>feature</u> for a detailed
       description of the recommended process for building bug fixes or enhancements.

   <b>Obtaining</b> <b>the</b> <b>code</b>
       To work on this library locally, first checkout the code. Then create a new virtual environment:

          git clone <a href="mailto:git@github.com">git@github.com</a>:simonw/sqlite-utils
          cd sqlite-utils
          python3 -mvenv venv
          source venv/bin/activate

       Or if you are using <b>pipenv</b>:

          pipenv shell

       Within the virtual environment running <b>sqlite-utils</b> should run your locally editable version of the tool.
       You can use <b>which</b> <b>sqlite-utils</b> to confirm that you are running the version that  lives  in  your  virtual
       environment.

   <b>Running</b> <b>the</b> <b>tests</b>
       To install the dependencies and test dependencies:

          pip install -e '.[test]'

       To run the tests:

          pytest

   <b>Building</b> <b>the</b> <b>documentation</b>
       To build the documentation, first install the documentation dependencies:

          pip install -e '.[docs]'

       Then  run  <b>make</b>  <b>livehtml</b>  from  the  <b>docs/</b>  directory to start a server on port 8000 that will serve the
       documentation and live-reload any time you make an edit to a <b>.rst</b> file:

          cd docs
          make livehtml

       The <u>cog</u> tool is used to maintain portions of the documentation. You can run it like so:

          cog -r docs/*.rst

   <b>Linting</b> <b>and</b> <b>formatting</b>
       <b>sqlite-utils</b> uses <u>Black</u> for code formatting, and <u>flake8</u> and <u>mypy</u> for linting and type checking.

       Black is installed as part of <b>pip</b> <b>install</b> <b>-e</b> <b>'.[test]'</b> - you can then format your code by running  it  in
       the root of the project:

          black .

       To install <b>mypy</b> and <b>flake8</b> run the following:

          pip install -e '.[flake8,mypy]'

       Both commands can then be run in the root of the project like this:

          flake8
          mypy sqlite_utils

       All three of these tools are run by our CI mechanism against every commit and pull request.

   <b>Using</b> <b>Just</b> <b>and</b> <b>pipenv</b>
       If you install <u>Just</u> and <u>pipenv</u> you can use them to manage your local development environment.

       To create a virtual environment and install all development dependencies, run:

          cd sqlite-utils
          just init

       To run all of the tests and linters:

          just

       To run tests, or run a specific test module or test by name:

          just test # All tests
          just test tests/test_cli_memory.py # Just this module
          just test -k test_memory_no_detect_types # Just this test

       To run just the linters:

          just lint

       To apply Black to your code:

          just black

       To update documentation using Cog:

          just cog

       To run the live documentation server (this will run Cog first):

          just docs

       And to list all available commands:

          just -l

   <b>Release</b> <b>process</b>
       Releases  are  performed using tags. When a new release is published on GitHub, a <u>GitHub</u> <u>Actions</u> <u>workflow</u>
       will perform the following:

       • Run the unit tests against all supported Python versions. If the tests pass...

       • Build a wheel bundle of the underlying Python source code

       • Push that new wheel up to PyPI: <u>https://pypi.org/project/sqlite-utils/</u>

       To deploy new releases you will need to have push access to the GitHub repository.

       <b>sqlite-utils</b> follows <u>Semantic</u> <u>Versioning</u>:

          major.minor.patch

       We increment <b>major</b> for backwards-incompatible releases.

       We increment <b>minor</b> for new features.

       We increment <b>patch</b> for bugfix releass.

       To release a new version, first create a commit that updates the version number in <b>setup.py</b> and  the  <u>the</u>
       <u>changelog</u> with highlights of the new version. An example <u>commit</u> <u>can</u> <u>be</u> <u>seen</u> <u>here</u>:

          # Update changelog
          git commit -m " Release 3.29

          Refs #423, #458, #467, #469, #470, #471, #472, #475" -a
          git push

       Referencing the issues that are part of the release in the commit message ensures the name of the release
       shows up on those issue pages, e.g. <u>here</u>.

       You can generate the list of issue references for a specific release by copying and pasting text from the
       release  notes or GitHub changes-since-last-release view into this <u>Extract</u> <u>issue</u> <u>numbers</u> <u>from</u> <u>pasted</u> <u>text</u>
       tool.

       To create the tag for the release, create <u>a</u> <u>new</u> <u>release</u> on GitHub matching the new  version  number.  You
       can  convert  the  release  notes to Markdown by copying and pasting the rendered HTML into this <u>Paste</u> <u>to</u>
       <u>Markdown</u> <u>tool</u>.

   <b>Changelog</b>
   <b>3.38</b> <b>(2024-11-23)</b>
       • Plugins can now reuse  the  implementation  of  the  <b>sqlite-utils</b>  <b>memory</b>  CLI  command  with  the  new
         <b>return_db=True</b> parameter. (<u>#643</u>)

       • <b>table.transform()</b>     now     recreates     indexes    after    transforming    a    table.    A    new
         <b>sqlite_utils.db.TransformError</b> exception is  raised  if  these  indexes  cannot  be  recreated  due  to
         conflicting changes to the table such as a column rename. Thanks, <u>Mat</u> <u>Miller</u>. (<u>#633</u>)

       • <b>table.search()</b>  now  accepts  a  <b>include_rank=True</b> parameter, causing the resulting rows to have a <b>rank</b>
         column showing the calculated relevance score. Thanks, <u>liunux4odoo</u>. (<u>#628</u>)

       • Fixed an error that occurred when creating a strict table with at  least  one  floating  point  column.
         These <b>FLOAT</b> columns are now correctly created as <b>REAL</b> as well, but only for strict tables. (<u>#644</u>)

   <b>3.37</b> <b>(2024-07-18)</b>
       • The  <b>create-table</b>  and  <b>insert-files</b> commands all now accept multiple <b>--pk</b> options for compound primary
         keys. (<u>#620</u>)

       • Now tested against Python 3.13 pre-release. (<u>#619</u>)

       • Fixed a crash that can occur in environments with a  broken  <b>numpy</b>  installation,  producing  a  <b>module</b>
         <b>'numpy'</b> <b>has</b> <b>no</b> <b>attribute</b> <b>'int8'</b>. (<u>#632</u>)

   <b>3.36</b> <b>(2023-12-07)</b>
       •

         <b>Support</b> <b>for</b> <b>creating</b> <b>tables</b> <b>in</b> <u>SQLite</u> <u>STRICT</u> <u>mode</u><b>.</b> <b>Thanks,</b> <u>Taj</u> <u>Khattra</u><b>.</b> <b>(</b><u>#344</u><b>)</b>

                • CLI commands <b>create-table</b>, <b>insert</b> and <b>upsert</b> all now accept a <b>--strict</b> option.

                • Python     methods     that     can     create     a     table     -     <b>table.create()</b>    and
                  <b>insert/upsert/insert_all/upsert_all</b> all now accept an optional <b>strict=True</b> parameter.

                • The <b>transform</b> command and <b>table.transform()</b> method preserve strict mode  when  transforming  a
                  table.

       • The  <b>sqlite-utils</b>  <b>create-table</b> command now accepts <b>str</b>, <b>int</b> and <b>bytes</b> as aliases for <b>text</b>, <b>integer</b> and
         <b>blob</b> respectively. (<u>#606</u>)

   <b>3.35.2</b> <b>(2023-11-03)</b>
       • The <b>--load-extension=spatialite</b> option and <u>find_spatialite()</u> utility function now both  work  correctly
         on <b>arm64</b> Linux. Thanks, <u>Mike</u> <u>Coats</u>. (<u>#599</u>)

       • Fix  for  bug  where  <b>sqlite-utils</b>  <b>insert</b>  could cause your terminal cursor to disappear. Thanks, <u>Luke</u>
         <u>Plant</u>. (<u>#433</u>)

       • <b>datetime.timedelta</b> values are now stored as <b>TEXT</b> columns. Thanks, <u>Harald</u> <u>Nezbeda</u>. (<u>#522</u>)

       • Test suite is now also run against Python 3.12.

   <b>3.35.1</b> <b>(2023-09-08)</b>
       • Fixed a bug where <u>table.transform()</u> would sometimes re-assign the <b>rowid</b> values for a table rather  than
         keeping them consistent across the operation. (<u>#592</u>)

   <b>3.35</b> <b>(2023-08-17)</b>
       Adding  foreign  keys  to  a  table  no longer uses <b>PRAGMA</b> <b>writable_schema</b> <b>=</b> <b>1</b> to directly manipulate the
       <b>sqlite_master</b> table. This was resulting in errors in some Python installations where the  SQLite  library
       was  compiled  in  a  way  that prevented this from working, in particular on macOS. Foreign keys are now
       added using the <u>table</u> <u>transformation</u> mechanism instead. (<u>#577</u>)

       This new mechanism creates a full copy of the table, so it is likely to be significantly slower for large
       tables, but will no longer trigger <b>table</b> <b>sqlite_master</b> <b>may</b> <b>not</b> <b>be</b> <b>modified</b> errors on  platforms  that  do
       not support <b>PRAGMA</b> <b>writable_schema</b> <b>=</b> <b>1</b>.

       A  new  plugin,  <u>sqlite-utils-fast-fks</u>, is now available for developers who still want to use that faster
       but riskier implementation.

       Other changes:

       • The <u>table.transform()</u> <u>method</u> has two new parameters: <b>foreign_keys=</b> allows you to  replace  the  foreign
         key  constraints  defined  on  a table, and <b>add_foreign_keys=</b> lets you specify new foreign keys to add.
         These complement the existing <b>drop_foreign_keys=</b> parameter. (<u>#577</u>)

       • The <u>sqlite-utils</u> <u>transform</u> command has a new <b>--add-foreign-key</b> option  which  can  be  called  multiple
         times to add foreign keys to a table that is being transformed. (<u>#585</u>)

       • <u>sqlite-utils</u>  <u>convert</u>  now  has a <b>--pdb</b> option for opening a debugger on the first encountered error in
         your conversion script. (<u>#581</u>)

       • Fixed a bug where <b>sqlite-utils</b> <b>install</b> <b>-e</b> <b>'.[test]'</b> option did not work correctly.

   <b>3.34</b> <b>(2023-07-22)</b>
       This release introduces a new <u>plugin</u> <u>system</u>. Read more about this in <u>sqlite-utils</u> <u>now</u>  <u>supports</u>  <u>plugins</u>.
       (<u>#567</u>)

       • Documentation describing <u>how</u> <u>to</u> <u>build</u> <u>a</u> <u>plugin</u>.

       • Plugin hook: <u>register_commands(cli)</u>, for plugins to add extra commands to <b>sqlite-utils</b>. (<u>#569</u>)

       • Plugin hook: <u>prepare_connection(conn)</u>. Plugins can use this to help prepare the SQLite connection to do
         things like registering custom SQL functions. Thanks, <u>Alex</u> <u>Garcia</u>. (<u>#574</u>)

       • <b>sqlite_utils.Database(...,</b> <b>execute_plugins=False)</b> option for disabling plugin execution. (<u>#575</u>)

       • <b>sqlite-utils</b>  <b>install</b>  <b>-e</b>  <b>path-to-directory</b> option for installing editable code. This option is useful
         during the development of a plugin. (<u>#570</u>)

       • <b>table.create(...)</b> method now accepts <b>replace=True</b> to drop and replace an existing table with  the  same
         name, or <b>ignore=True</b> to silently do nothing if a table already exists with the same name. (<u>#568</u>)

       • <b>sqlite-utils</b>  <b>insert</b>  <b>...</b>  <b>--stop-after</b>  <b>10</b>  option for stopping the insert after a specified number of
         records. Works for the <b>upsert</b> command as well. (<u>#561</u>)

       • The <b>--csv</b> and <b>--tsv</b> modes for <b>insert</b> now accept a <b>--empty-null</b> option, which causes  empty  strings  in
         the CSV file to be stored as <b>null</b> in the database. (<u>#563</u>)

       • New <b>db.rename_table(table_name,</b> <b>new_name)</b> method for renaming tables. (<u>#565</u>)

       • <b>sqlite-utils</b> <b>rename-table</b> <b>my.db</b> <b>table_name</b> <b>new_name</b> command for renaming tables. (<u>#565</u>)

       • The  <b>table.transform(...)</b>  method now takes an optional <b>keep_table=new_table_name</b> parameter, which will
         cause the original table to be renamed to <b>new_table_name</b> rather than being dropped at the  end  of  the
         transformation. (<u>#571</u>)

       • Documentation  now  notes  that  calling  <b>table.transform()</b> without any arguments will reformat the SQL
         schema stored by SQLite to be more aesthetically pleasing. (<u>#564</u>)

   <b>3.33</b> <b>(2023-06-25)</b>
       • <b>sqlite-utils</b> will now use <u>sqlean.py</u> in place of  <b>sqlite3</b>  if  it  is  installed  in  the  same  virtual
         environment.  This  is useful for Python environments with either an outdated version of SQLite or with
         restrictions  on  SQLite  such  as  disabled  extension  loading  or  restrictions  resulting  in   the
         <b>sqlite3.OperationalError:</b> <b>table</b> <b>sqlite_master</b> <b>may</b> <b>not</b> <b>be</b> <b>modified</b> error. (<u>#559</u>)

       • New  <b>with</b>  <b>db.ensure_autocommit_off()</b> context manager, which ensures that the database is in autocommit
         mode for the duration of a block of code. This is  used  by  <b>db.enable_wal()</b>  and  <b>db.disable_wal()</b>  to
         ensure they work correctly with <b>pysqlite3</b> and <b>sqlean.py</b>.

       • New  <b>db.iterdump()</b>  method, providing an iterator over SQL strings representing a dump of the database.
         This uses <b>sqlite-dump</b> if it is available, otherwise falling back on  the  <b>conn.iterdump()</b>  method  from
         <b>sqlite3</b>.  Both  <b>pysqlite3</b> and <b>sqlean.py</b> omit support for <b>iterdump()</b> - this method helps paper over that
         difference.

   <b>3.32.1</b> <b>(2023-05-21)</b>
       • Examples in the <u>CLI</u> <u>documentation</u> can now all be copied and pasted without needing to remove a  leading
         <b>$</b>. (<u>#551</u>)

       • Documentation now covers <u>Setting</u> <u>up</u> <u>shell</u> <u>completion</u> for <b>bash</b> and <b>zsh</b>. (<u>#552</u>)

   <b>3.32</b> <b>(2023-05-21)</b>
       • New  experimental  <b>sqlite-utils</b>  <b>tui</b>  interface  for  interactively  building command-line invocations,
         powered by <u>Trogon</u>. This requires an optional dependency, installed using <b>sqlite-utils</b>  <b>install</b>  <b>trogon</b>.
         There is a screenshot <u>in</u> <u>the</u> <u>documentation</u>. (<u>#545</u>)

       • <b>sqlite-utils</b> <b>analyze-tables</b> command (<u>documentation</u>) now has a <b>--common-limit</b> <b>20</b> option for changing the
         number of common/least-common values shown for each column. (<u>#544</u>)

       • <b>sqlite-utils</b>  <b>analyze-tables</b>  <b>--no-most</b> and <b>--no-least</b> options for disabling calculation of most-common
         and least-common values.

       • If a column contains only <b>null</b> values, <b>analyze-tables</b> will no longer  attempt  to  calculate  the  most
         common and least common values for that column. (<u>#547</u>)

       • Calling  <b>sqlite-utils</b> <b>analyze-tables</b> with non-existent columns in the <b>-c/--column</b> option now results in
         an error message. (<u>#548</u>)

       • The   <b>table.analyze_column()</b>   method   (<u>documented</u>   <u>here</u>)   now   accepts    <b>most_common=False</b>    and
         <b>least_common=False</b> options for disabling calculation of those values.

   <b>3.31</b> <b>(2023-05-08)</b>
       • Dropped support for Python 3.6. Tests now ensure compatibility with Python 3.11. (<u>#517</u>)

       • Automatically locates the SpatiaLite extension on Apple Silicon. Thanks, Chris Amico. (<u>#536</u>)

       • New  <b>--raw-lines</b> option for the <b>sqlite-utils</b> <b>query</b> and <b>sqlite-utils</b> <b>memory</b> commands, which outputs just
         the raw value of the first column of every row. (<u>#539</u>)

       • Fixed a bug where <b>table.upsert_all()</b> failed if the <b>not_null=</b> option was passed. (<u>#538</u>)

       • Fixed a <b>ResourceWarning</b> when using <b>sqlite-utils</b> <b>insert</b>. (<u>#534</u>)

       • Now shows a more detailed error message when <b>sqlite-utils</b> <b>insert</b> is called with invalid JSON. (<u>#532</u>)

       • <b>table.convert(...,</b> <b>skip_false=False)</b> and <b>sqlite-utils</b> <b>convert</b> <b>--no-skip-false</b> options, for  avoiding  a
         misfeature  where  the  <u>convert()</u>  mechanism  skips  rows  in  the database with a falsey value for the
         specified column. Fixing this by  default  would  be  a  backwards-incompatible  change  and  is  under
         consideration for a 4.0 release in the future. (<u>#527</u>)

       • Tables can now be created with self-referential foreign keys. Thanks, Scott Perry. (<u>#537</u>)

       • <b>sqlite-utils</b>  <b>transform</b>  no  longer breaks if a table defines default values for columns. Thanks, Kenny
         Song. (<u>#509</u>)

       • Fixed a bug where repeated calls to <b>table.transform()</b> did not work correctly. Thanks, Martin Carpenter.
         (<u>#525</u>)

       • Improved error message if <b>rows_from_file()</b> is passed a non-binary-mode file-like object. (<u>#520</u>)

   <b>3.30</b> <b>(2022-10-25)</b>
       • Now tested against Python 3.11. (<u>#502</u>)

       • New <b>table.search_sql(include_rank=True)</b> option, which adds a <b>rank</b> column to the generated SQL.  Thanks,
         Jacob Chapman. (<u>#480</u>)

       • Progress  bars  now  display  for  newline-delimited  JSON  files using the <b>--nl</b> option. Thanks, Mischa
         Untaga. (<u>#485</u>)

       • New <b>db.close()</b> method. (<u>#504</u>)

       • Conversion functions passed to <u>table.convert(...)</u> can now return lists or dictionaries, which  will  be
         inserted into the database as JSON strings. (<u>#495</u>)

       • <b>sqlite-utils</b>  <b>install</b> and <b>sqlite-utils</b> <b>uninstall</b> commands for installing packages into the same virtual
         environment as <b>sqlite-utils</b>, <u>described</u> <u>here</u>. (<u>#483</u>)

       • New <u>sqlite_utils.utils.flatten()</u> utility function. (<u>#500</u>)

       • Documentation on <u>using</u> <u>Just</u> to run tests, linters and build documentation.

       • Documentation now covers the <u>Release</u> <u>process</u> for this package.

   <b>3.29</b> <b>(2022-08-27)</b>
       • The <b>sqlite-utils</b> <b>query</b>, <b>memory</b> and <b>bulk</b> commands now all accept a new <b>--functions</b> option. This  can  be
         passed a string of Python code, and any callable objects defined in that code will be made available to
         SQL queries as custom SQL functions. See <u>Defining</u> <u>custom</u> <u>SQL</u> <u>functions</u> for details. (<u>#471</u>)

       • <b>db[table].create(...)</b> method now accepts a new <b>transform=True</b> parameter. If the table already exists it
         will  be  <u>transformed</u> to match the schema configuration options passed to the function. This may result
         in columns being added or dropped, column types being changed, column order being updated or  not  null
         and default values for columns being set. (<u>#467</u>)

       • Related to the above, the <b>sqlite-utils</b> <b>create-table</b> command now accepts a <b>--transform</b> option.

       • New  introspection  property: <b>table.default_values</b> returns a dictionary mapping each column name with a
         default value to the configured default value. (<u>#475</u>)

       • The <b>--load-extension</b> option can  now  be  provided  a  path  to  a  compiled  SQLite  extension  module
         accompanied  by  the  name  of  an  entrypoint,  separated  by  a  colon - for example <b>--load-extension</b>
         <b>./lines0:sqlite3_lines0_noread_init</b>. This feature is modelled on code first <u>contributed</u> <u>to</u> <u>Datasette</u> by
         Alex Garcia. (<u>#470</u>)

       • Functions registered using the <u>db.register_function()</u> method can now have a custom name specified using
         the new <b>db.register_function(fn,</b> <b>name=...)</b> parameter. (<u>#458</u>)

       • <u>sqlite-utils</u> <u>rows</u> has a new <b>--order</b> option for specifying the sort order for the returned rows. (<u>#469</u>)

       • All of the CLI options that accept Python code blocks can now all be used to define functions that  can
         access modules imported in that same block of code without needing to use the <b>global</b> keyword. (<u>#472</u>)

       • Fixed  bug where <b>table.extract()</b> would not behave correctly for columns containing null values. Thanks,
         Forest Gregg. (<u>#423</u>)

       • New tutorial: <u>Cleaning</u> <u>data</u> <u>with</u> <u>sqlite-utils</u> <u>and</u> <u>Datasette</u> shows how to use <b>sqlite-utils</b> to import and
         clean an example CSV file.

       • Datasette and <b>sqlite-utils</b> now have a Discord community. <u>Join</u> <u>the</u> <u>Discord</u> <u>here</u>.

   <b>3.28</b> <b>(2022-07-15)</b>
       • New <u>table.duplicate(new_name)</u> method for creating a copy of a table with  a  matching  schema  and  row
         contents. Thanks, <u>David</u>. (<u>#449</u>)

       • New <b>sqlite-utils</b> <b>duplicate</b> <b>data.db</b> <b>table_name</b> <b>new_name</b> CLI command for <u>Duplicating</u> <u>tables</u>. (<u>#454</u>)

       • <b>sqlite_utils.utils.rows_from_file()</b>  is  now  a  <u>documented</u>  <u>API</u>.  It can be used to read a sequence of
         dictionaries from a file-like object containing CSV, TSV, JSON or newline-delimited  JSON.  It  can  be
         passed an explicit format or can attempt to detect the format automatically. (<u>#443</u>)

       • <b>sqlite_utils.utils.TypeTracker</b>  is  now  a  documented  API for detecting the likely column types for a
         sequence of string rows, see <u>Detecting</u> <u>column</u> <u>types</u> <u>using</u> <u>TypeTracker</u>. (<u>#445</u>)

       • <b>sqlite_utils.utils.chunks()</b> is now a documented API for <u>splitting</u> <u>an</u> <u>iterator</u> <u>into</u> <u>chunks</u>. (<u>#451</u>)

       • <b>sqlite-utils</b> <b>enable-fts</b> now has a <b>--replace</b> option for replacing the existing FTS configuration  for  a
         table. (<u>#450</u>)

       • The  <b>create-index</b>, <b>add-column</b> and <b>duplicate</b> commands all now take a <b>--ignore</b> option for ignoring errors
         should the database not be in the right state for them to operate. (<u>#450</u>)

   <b>3.27</b> <b>(2022-06-14)</b>
       See also <u>the</u> <u>annotated</u> <u>release</u> <u>notes</u> for this release.

       • Documentation now uses the <u>Furo</u> Sphinx theme. (<u>#435</u>)

       • Code examples in documentation now have a "copy to clipboard" button. (<u>#436</u>)

       • <b>sqlite_utils.utils.utils.rows_from_file()</b> is now a documented API, see <u>Reading</u> <u>rows</u> <u>from</u> <u>a</u> <u>file</u>. (<u>#443</u>)

       • <b>rows_from_file()</b> has two new parameters to help handle CSV files with rows  that  contain  more  values
         than are listed in that CSV file's headings: <b>ignore_extras=True</b> and <b>extras_key="name-of-key"</b>. (<u>#440</u>)

       • <b>sqlite_utils.utils.maximize_csv_field_size_limit()</b>  helper function for increasing the field size limit
         for reading CSV files to its maximum, see <u>Setting</u> <u>the</u> <u>maximum</u> <u>CSV</u> <u>field</u> <u>size</u> <u>limit</u>. (<u>#442</u>)

       • <b>table.search(where=,</b> <b>where_args=)</b> parameters for adding additional <b>WHERE</b> clauses to a search query. The
         <b>where=</b> parameter is available on <b>table.search_sql(...)</b> as well. See <u>Searching</u> <u>with</u>  <u>table.search()</u>.  (‐
         <u>#441</u>)

       • Fixed  bug  where  <b>table.detect_fts()</b>  and other search-related functions could fail if two FTS-enabled
         tables had names that were prefixes of each other. (<u>#434</u>)

   <b>3.26.1</b> <b>(2022-05-02)</b>
       • Now depends on <u>click-default-group-wheel</u>, a pure Python wheel package. This means you can  install  and
         use this package with <u>Pyodide</u>, which can run Python entirely in your browser using WebAssembly. (<u>#429</u>)

         Try that out using the <u>Pyodide</u> <u>REPL</u>:

            &gt;&gt;&gt; import micropip
            &gt;&gt;&gt; await micropip.install("sqlite-utils")
            &gt;&gt;&gt; import sqlite_utils
            &gt;&gt;&gt; db = sqlite_utils.Database(memory=True)
            &gt;&gt;&gt; list(db.query("select 3 * 5"))
            [{'3 * 5': 15}]

   <b>3.26</b> <b>(2022-04-13)</b>
       • New  <b>errors=r.IGNORE/r.SET_NULL</b>  parameter for the <b>r.parsedatetime()</b> and <b>r.parsedate()</b> <u>convert</u> <u>recipes</u>.
         (<u>#416</u>)

       • Fixed a bug where <b>--multi</b> could not be used in combination with <b>--dry-run</b> for the <u>convert</u>  command.  (‐
         <u>#415</u>)

       • New documentation: <u>Defining</u> <u>a</u> <u>convert()</u> <u>function</u>. (<u>#420</u>)

       • More robust detection for whether or not <b>deterministic=True</b> is supported. (<u>#425</u>)

   <b>3.25.1</b> <b>(2022-03-11)</b>
       • Improved display of type information and parameters in the <u>API</u> <u>reference</u> <u>documentation</u>. (<u>#413</u>)

   <b>3.25</b> <b>(2022-03-01)</b>
       • New  <b>hash_id_columns=</b>  parameter  for  creating  a primary key that's a hash of the content of specific
         columns - see <u>Setting</u> <u>an</u> <u>ID</u> <u>based</u> <u>on</u> <u>the</u> <u>hash</u> <u>of</u> <u>the</u> <u>row</u> <u>contents</u> for details. (<u>#343</u>)

       • New <u>db.sqlite_version</u> property, returning a tuple of integers representing the version of  SQLite,  for
         example <b>(3,</b> <b>38,</b> <b>0)</b>.

       • Fixed  a  bug  where <u>register_function(deterministic=True)</u> caused errors on versions of SQLite prior to
         3.8.3. (<u>#408</u>)

       • New documented <u>hash_record(record,</u> <u>keys=...)</u> function.

   <b>3.24</b> <b>(2022-02-15)</b>
       • SpatiaLite helpers for the <b>sqlite-utils</b> command-line tool - thanks, Chris Amico. (<u>#398</u>)

         • <u>sqlite-utils</u> <u>create-database</u> <b>--init-spatialite</b> option for initializing SpatiaLite on a newly  created
           database.

         • <u>sqlite-utils</u> <u>add-geometry-column</u> command for adding geometry columns.

         • <u>sqlite-utils</u> <u>create-spatial-index</u> command for adding spatial indexes.

       • <b>db[table].create(...,</b>  <b>if_not_exists=True)</b>  option  for  <u>creating</u>  <u>a</u>  <u>table</u> only if it does not already
         exist. (<u>#397</u>)

       • <b>Database(memory_name="my_shared_database")</b> parameter for creating a <u>named</u> <u>in-memory</u> <u>database</u>  that  can
         be shared between multiple connections. (<u>#405</u>)

       • Documentation  now describes <u>how</u> <u>to</u> <u>add</u> <u>a</u> <u>primary</u> <u>key</u> <u>to</u> <u>a</u> <u>rowid</u> <u>table</u> using <b>sqlite-utils</b> <b>transform</b>. (‐
         <u>#403</u>)

   <b>3.23</b> <b>(2022-02-03)</b>
       This release introduces four new utility methods for working with <u>SpatiaLite</u>. Thanks, Chris Amico. (<u>#385</u>)

       • <b>sqlite_utils.utils.find_spatialite()</b> <u>finds</u> <u>the</u> <u>location</u> <u>of</u> <u>the</u> <u>SpatiaLite</u> <u>module</u> on disk.

       • <b>db.init_spatialite()</b> <u>initializes</u> <u>SpatiaLite</u> for the given database.

       • <b>table.add_geometry_column(...)</b> <u>adds</u> <u>a</u> <u>geometry</u> <u>column</u> to an existing table.

       • <b>table.create_spatial_index(...)</b> <u>creates</u> <u>a</u> <u>spatial</u> <u>index</u> for a column.

       • <b>sqlite-utils</b> <b>batch</b> now accepts a <b>--batch-size</b> option. (<u>#392</u>)

   <b>3.22.1</b> <b>(2022-01-25)</b>
       • All commands now include example usage in their <b>--help</b> - see <u>CLI</u> <u>reference</u>. (<u>#384</u>)

       • Python library documentation has a new <u>Getting</u> <u>started</u> section. (<u>#387</u>)

       • Documentation now uses <u>Plausible</u> <u>analytics</u>. (<u>#389</u>)

   <b>3.22</b> <b>(2022-01-11)</b>
       • New <u>CLI</u> <u>reference</u> documentation page, listing the output of <b>--help</b> for every one of the  CLI  commands.
         (<u>#383</u>)

       • <b>sqlite-utils</b> <b>rows</b> now has <b>--limit</b> and <b>--offset</b> options for paginating through data. (<u>#381</u>)

       • <b>sqlite-utils</b>  <b>rows</b>  now  has  <b>--where</b>  and  <b>-p</b> options for filtering the table using a <b>WHERE</b> query, see
         <u>Returning</u> <u>all</u> <u>rows</u> <u>in</u> <u>a</u> <u>table</u>. (<u>#382</u>)

   <b>3.21</b> <b>(2022-01-10)</b>
       CLI and Python library improvements to help run <u>ANALYZE</u> after creating indexes or inserting rows, to gain
       better performance from the SQLite query planner when it runs against indexes.

       Three new CLI commands: <b>create-database</b>, <b>analyze</b> and <b>bulk</b>.

       More details and examples can be found in <u>the</u> <u>annotated</u> <u>release</u> <u>notes</u>.

       • New <b>sqlite-utils</b> <b>create-database</b> command for creating new empty database files. (<u>#348</u>)

       • New Python  methods  for  running  <b>ANALYZE</b>  against  a  database,  table  or  index:  <b>db.analyze()</b>  and
         <b>table.analyze()</b>, see <u>Optimizing</u> <u>index</u> <u>usage</u> <u>with</u> <u>ANALYZE</u>. (<u>#366</u>)

       • New <u>sqlite-utils</u> <u>analyze</u> <u>command</u> for running <b>ANALYZE</b> using the CLI. (<u>#379</u>)

       • The  <b>create-index</b>, <b>insert</b> and <b>upsert</b> commands now have a new <b>--analyze</b> option for running <b>ANALYZE</b> after
         the command has completed. (<u>#379</u>)

       • New <u>sqlite-utils</u> <u>bulk</u> <u>command</u> which can import records in the same way  as  <b>sqlite-utils</b>  <b>insert</b>  (from
         JSON, CSV or TSV) and use them to bulk execute a parametrized SQL query. (<u>#375</u>)

       • The CLI tool can now also be run using <b>python</b> <b>-m</b> <b>sqlite_utils</b>. (<u>#368</u>)

       • Using <b>--fmt</b> now implies <b>--table</b>, so you don't need to pass both options. (<u>#374</u>)

       • The <b>--convert</b> function applied to rows can now modify the row in place. (<u>#371</u>)

       • The <u>insert-files</u> <u>command</u> supports two new columns: <b>stem</b> and <b>suffix</b>. (<u>#372</u>)

       • The <b>--nl</b> import option now ignores blank lines in the input. (<u>#376</u>)

       • Fixed  bug  where streaming input to the <b>insert</b> command with <b>--batch-size</b> <b>1</b> would appear to only commit
         after several rows had been ingested, due to unnecessary input buffering. (<u>#364</u>)

   <b>3.20</b> <b>(2022-01-05)</b>
       • <b>sqlite-utils</b> <b>insert</b> <b>...</b> <b>--lines</b> to insert the lines from a file into a table with a single <b>line</b> column,
         see <u>Inserting</u> <u>unstructured</u> <u>data</u> <u>with</u> <u>--lines</u> <u>and</u> <u>--text</u>.

       • <b>sqlite-utils</b> <b>insert</b> <b>...</b> <b>--text</b> to insert the contents of the file into  a  table  with  a  single  <b>text</b>
         column and a single row.

       • <b>sqlite-utils</b>  <b>insert</b> <b>...</b> <b>--convert</b> allows a Python function to be provided that will be used to convert
         each row that is being inserted into the database.  See  <u>Applying</u>  <u>conversions</u>  <u>while</u>  <u>inserting</u>  <u>data</u>,
         including details on special behavior when combined with <b>--lines</b> and <b>--text</b>. (<u>#356</u>)

       • <b>sqlite-utils</b> <b>convert</b> now accepts a code value of <b>-</b> to read code from standard input. (<u>#353</u>)

       • <b>sqlite-utils</b> <b>convert</b> also now accepts code that defines a named <b>convert(value)</b> function, see <u>Converting</u>
         <u>data</u> <u>in</u> <u>columns</u>.

       • <b>db.supports_strict</b> property showing if the database connection supports <u>SQLite</u> <u>strict</u> <u>tables</u>.

       • <b>table.strict</b> property (see <u>.strict</u>) indicating if the table uses strict mode. (<u>#344</u>)

       • Fixed bug where <b>sqlite-utils</b> <b>upsert</b> <b>...</b> <b>--detect-types</b> ignored the <b>--detect-types</b> option. (<u>#362</u>)

   <b>3.19</b> <b>(2021-11-20)</b>
       • The   <u>table.lookup()</u>  <u>method</u>  now  accepts  keyword  arguments  that  match  those  on  the  underlying
         <b>table.insert()</b> method: <b>foreign_keys=</b>, <b>column_order=</b>, <b>not_null=</b>, <b>defaults=</b>, <b>extracts=</b>, <b>conversions=</b>  and
         <b>columns=</b>.  You  can also now pass <b>pk=</b> to specify a different column name to use for the primary key. (‐
         <u>#342</u>)

   <b>3.18</b> <b>(2021-11-14)</b>
       • The <b>table.lookup()</b> method now has an optional second argument which can be  used  to  populate  columns
         only the first time the record is created, see <u>Working</u> <u>with</u> <u>lookup</u> <u>tables</u>. (<u>#339</u>)

       • <b>sqlite-utils</b>  <b>memory</b>  now  has  a  <b>--flatten</b>  option  for  <u>flattening</u> <u>nested</u> <u>JSON</u> <u>objects</u> into separate
         columns, consistent with <b>sqlite-utils</b> <b>insert</b>. (<u>#332</u>)

       • <b>table.create_index(...,</b> <b>find_unique_name=True)</b> parameter, which finds an available name for the created
         index even if the default name has already been taken. This means  that  <b>index-foreign-keys</b>  will  work
         even if one of the indexes it tries to create clashes with an existing index name. (<u>#335</u>)

       • Added  <b>py.typed</b>  to  the  module,  so  <u>mypy</u>  should now correctly pick up the type annotations. Thanks,
         Andreas Longo. (<u>#331</u>)

       • Now depends on <b>python-dateutil</b> instead of depending on <b>dateutils</b>. Thanks, Denys Pavlov. (<u>#324</u>)

       • <b>table.create()</b> (see <u>Explicitly</u> <u>creating</u> <u>a</u> <u>table</u>) now handles <b>dict</b>, <b>list</b> and <b>tuple</b> types,  mapping  them
         to <b>TEXT</b> columns in SQLite so that they can be stored encoded as JSON. (<u>#338</u>)

       • Inserted  data with square braces in the column names (for example a CSV file containing a <b>item[price]</b>)
         column now have the braces converted to underscores: <b>item_price_</b>.  Previously  such  columns  would  be
         rejected with an error. (<u>#329</u>)

       • Now also tested against Python 3.10. (<u>#330</u>)

   <b>3.17.1</b> <b>(2021-09-22)</b>
       • <u>sqlite-utils</u> <u>memory</u> now works if files passed to it share the same file name. (<u>#325</u>)

       • <u>sqlite-utils</u> <u>query</u> now returns <b>[]</b> in JSON mode if no rows are returned. (<u>#328</u>)

   <b>3.17</b> <b>(2021-08-24)</b>
       • The  <u>sqlite-utils</u>  <u>memory</u>  command  has  a  new  <b>--analyze</b>  option,  which  runs  the equivalent of the
         <u>analyze-tables</u> command directly against the in-memory database created from the incoming  CSV  or  JSON
         data. (<u>#320</u>)

       • <u>sqlite-utils</u> <u>insert-files</u> now has the ability to insert file contents in to <b>TEXT</b> columns in addition to
         the default <b>BLOB</b>. Pass the <b>--text</b> option or use <b>content_text</b> as a column specifier. (<u>#319</u>)

   <b>3.16</b> <b>(2021-08-18)</b>
       • Type  signatures added to  more methods, including <b>table.resolve_foreign_keys()</b>, <b>db.create_table_sql()</b>,
         <b>db.create_table()</b> and <b>table.create()</b>. (<u>#314</u>)

       • New <b>db.quote_fts(value)</b> method, see <u>Quoting</u> <u>characters</u> <u>for</u> <u>use</u> <u>in</u> <u>search</u> - thanks, Mark Neumann. (<u>#246</u>)

       • <b>table.search()</b> now accepts an optional <b>quote=True</b> parameter. (<u>#296</u>)

       • CLI command <b>sqlite-utils</b> <b>search</b> now accepts a <b>--quote</b> option. (<u>#296</u>)

       • Fixed bug where <b>--no-headers</b> and <b>--tsv</b> options to <u>sqlite-utils</u> <u>insert</u> could not be  used  together.  (‐
         <u>#295</u>)

       • Various small improvements to <u>API</u> <u>reference</u> documentation.

   <b>3.15.1</b> <b>(2021-08-10)</b>
       • Python  library  now  includes  type annotations on almost all of the methods, plus detailed docstrings
         describing each one. (<u>#311</u>)

       • New <u>API</u> <u>reference</u> documentation page, powered by those docstrings.

       • Fixed bug where <b>.add_foreign_keys()</b> failed to raise an error if called against a <b>View</b>. (<u>#313</u>)

       • Fixed bug where  <b>.delete_where()</b>  returned  a  <b>[]</b>  instead  of  returning  <b>self</b>  if  called  against  a
         non-existent table. (<u>#315</u>)

   <b>3.15</b> <b>(2021-08-09)</b>
       • <b>sqlite-utils</b>  <b>insert</b>  <b>--flatten</b>  option for <u>flattening</u> <u>nested</u> <u>JSON</u> <u>objects</u> to create tables with column
         names like <b>topkey_nestedkey</b>. (<u>#310</u>)

       • Fixed several spelling mistakes in the documentation, spotted <u>using</u> <u>codespell</u>.

       • Errors that occur while using the <b>sqlite-utils</b>  CLI  tool  now  show  the  responsible  SQL  and  query
         parameters, if possible. (<u>#309</u>)

   <b>3.14</b> <b>(2021-08-02)</b>
       This  release introduces the new <u>sqlite-utils</u> <u>convert</u> <u>command</u> (<u>#251</u>) and corresponding <u>table.convert(...)</u>
       Python method (<u>#302</u>). These tools can be used to apply a  Python  conversion  function  to  one  or  more
       columns  of  a  table,  either updating the column in place or using transformed data from that column to
       populate one or more other columns.

       This command-line example uses the Python standard library <u>textwrap</u> <u>module</u> to wrap  the  content  of  the
       <b>content</b> column in the <b>articles</b> table to 100 characters:

          $ sqlite-utils convert content.db articles content \
              '"\n".join(textwrap.wrap(value, 100))' \
              --import=textwrap

       The same operation in Python code looks like this:

          import sqlite_utils, textwrap

          db = sqlite_utils.Database("content.db")
          db["articles"].convert("content", lambda v: "\n".join(textwrap.wrap(v, 100)))

       See  the full documentation for the <u>sqlite-utils</u> <u>convert</u> <u>command</u> and the <u>table.convert(...)</u> Python method
       for more details.

       Also in this release:

       • The new <b>table.count_where(...)</b> method, for counting rows in a table that match  a  specific  SQL  <b>WHERE</b>
         clause. (<u>#305</u>)

       • New  <b>--silent</b>  option  for  the  <u>sqlite-utils</u>  <u>insert-files</u>  <u>command</u> to hide the terminal progress bar,
         consistent with the <b>--silent</b> option for <b>sqlite-utils</b> <b>convert</b>. (<u>#301</u>)

   <b>3.13</b> <b>(2021-07-24)</b>
       • <b>sqlite-utils</b> <b>schema</b> <b>my.db</b> <b>table1</b> <b>table2</b> command now accepts optional table names. (<u>#299</u>)

       • <b>sqlite-utils</b> <b>memory</b> <b>--help</b> now describes the <b>--schema</b> option.

   <b>3.12</b> <b>(2021-06-25)</b>
       • New <u>db.query(sql,</u> <u>params)</u> method, which executes a SQL query and returns the  results  as  an  iterator
         over Python dictionaries. (<u>#290</u>)

       • This project now uses <b>flake8</b> and has started to use <b>mypy</b>. (<u>#291</u>)

       • New documentation on <u>contributing</u> to this project. (<u>#292</u>)

   <b>3.11</b> <b>(2021-06-20)</b>
       • New  <b>sqlite-utils</b>  <b>memory</b> <b>data.csv</b> <b>--schema</b> option, for outputting the schema of the in-memory database
         generated from one or more files. See <u>--schema,</u> <u>--analyze,</u> <u>--dump</u> <u>and</u> <u>--save</u>. (<u>#288</u>)

       • Added <u>installation</u> <u>instructions</u>. (<u>#286</u>)

   <b>3.10</b> <b>(2021-06-19)</b>
       This release introduces the <b>sqlite-utils</b> <b>memory</b> command, which can be used to load CSV or JSON data  into
       a  temporary  in-memory  database  and  run  SQL queries (including joins across multiple files) directly
       against that data.

       Also new: <b>sqlite-utils</b> <b>insert</b> <b>--detect-types</b>, <b>sqlite-utils</b> <b>dump</b>, <b>table.use_rowid</b> plus some smaller fixes.

   <b>sqlite-utils</b> <b>memory</b>
       This example of <b>sqlite-utils</b> <b>memory</b> retrieves information about the all of  the  repositories  in  the  ‐
       <u>Dogsheep</u>  organization  on  GitHub using <u>this</u> <u>JSON</u> <u>API</u>, sorts them by their number of stars and outputs a
       table of the top five (using <b>-t</b>):

          $ curl -s 'https://api.github.com/users/dogsheep/repos' \
            | sqlite-utils memory - '
                select full_name, forks_count, stargazers_count
                from stdin order by stargazers_count desc limit 5
              ' -t
          full_name                            forks_count    stargazers_count
          ---------------------------------  -------------  ------------------
          dogsheep/twitter-to-sqlite                    12                 225
          dogsheep/github-to-sqlite                     14                 139
          dogsheep/dogsheep-photos                       5                 116
          dogsheep/dogsheep.github.io                    7                  90
          dogsheep/healthkit-to-sqlite                   4                  85

       The tool works against files on disk as well. This example joins data from two CSV files:

          $ cat creatures.csv
          species_id,name
          1,Cleo
          2,Bants
          2,Dori
          2,Azi
          $ cat species.csv
          id,species_name
          1,Dog
          2,Chicken
          $ sqlite-utils memory species.csv creatures.csv '
            select * from creatures join species on creatures.species_id = species.id
          '
          [{"species_id": 1, "name": "Cleo", "id": 1, "species_name": "Dog"},
           {"species_id": 2, "name": "Bants", "id": 2, "species_name": "Chicken"},
           {"species_id": 2, "name": "Dori", "id": 2, "species_name": "Chicken"},
           {"species_id": 2, "name": "Azi", "id": 2, "species_name": "Chicken"}]

       Here the <b>species.csv</b> file becomes the <b>species</b> table, the <b>creatures.csv</b> file becomes the  <b>creatures</b>  table
       and the output is JSON, the default output format.

       You  can also use the <b>--attach</b> option to attach existing SQLite database files to the in-memory database,
       in order to join data from CSV or JSON directly against your existing tables.

       Full documentation of this new feature  is  available  in  <u>Querying</u>  <u>data</u>  <u>directly</u>  <u>using</u>  <u>an</u>  <u>in-memory</u>
       <u>database</u>. (<u>#272</u>)

   <b>sqlite-utils</b> <b>insert</b> <b>--detect-types</b>
       The  <u>sqlite-utils</u>  <u>insert</u>  command  can  be used to insert data from JSON, CSV or TSV files into a SQLite
       database file. The new <b>--detect-types</b> option (shortcut <b>-d</b>), when used in conjunction with a  CSV  or  TSV
       import,  will  automatically  detect  if  columns  in  the file are integers or floating point numbers as
       opposed to treating everything as a text column and create the new table with the  corresponding  schema.
       See <u>Inserting</u> <u>CSV</u> <u>or</u> <u>TSV</u> <u>data</u> for details. (<u>#282</u>)

   <b>Other</b> <b>changes</b>
       • <b>Bug</b>  <b>fix</b>:  <b>table.transform()</b>, when run against a table without explicit primary keys, would incorrectly
         create a new version of the table with an explicit primary key column called <b>rowid</b>. (<u>#284</u>)

       • New <b>table.use_rowid</b> introspection property, see <u>.use_rowid</u>. (<u>#285</u>)

       • The new <b>sqlite-utils</b> <b>dump</b> <b>file.db</b> command outputs a SQL dump that can be used to recreate  a  database.
         (<u>#274</u>)

       • <b>-h</b> now works as a shortcut for <b>--help</b>, thanks Loren McIntyre. (<u>#276</u>)

       • Now using <u>pytest-cov</u> and <u>Codecov</u> to track test coverage - currently at 96%. (<u>#275</u>)

       • SQL errors that occur when using <b>sqlite-utils</b> <b>query</b> are now displayed as CLI errors.

   <b>3.9.1</b> <b>(2021-06-12)</b>
       • Fixed  bug when using <b>table.upsert_all()</b> to create a table with only a single column that is treated as
         the primary key. (<u>#271</u>)

   <b>3.9</b> <b>(2021-06-11)</b>
       • New <b>sqlite-utils</b> <b>schema</b> command showing the full SQL schema for a  database,  see  <u>Showing</u>  <u>the</u>  <u>schema</u>
         <u>(CLI)</u>. (<u>#268</u>)

       • <b>db.schema</b>  introspection  property  exposing  the  same  feature to the Python library, see <u>Showing</u> <u>the</u>
         <u>schema</u> <u>(Python</u> <u>library)</u>.

   <b>3.8</b> <b>(2021-06-02)</b>
       • New <b>sqlite-utils</b> <b>indexes</b> command to list indexes in a database, see <u>Listing</u> <u>indexes</u>. (<u>#263</u>)

       • <b>table.xindexes</b> introspection property returning more details about that table's indexes, see <u>.xindexes</u>.
         (<u>#261</u>)

   <b>3.7</b> <b>(2021-05-28)</b>
       • New <b>table.pks_and_rows_where()</b> method returning <b>(primary_key,</b> <b>row_dictionary)</b> tuples - see <u>Listing</u> <u>rows</u>
         <u>with</u> <u>their</u> <u>primary</u> <u>keys</u>. (<u>#240</u>)

       • Fixed bug with <b>table.add_foreign_key()</b> against columns containing spaces. (<u>#238</u>)

       • <b>table_or_view.drop(ignore=True)</b> option for avoiding errors if the table or view does not exist. (<u>#237</u>)

       • <b>sqlite-utils</b> <b>drop-view</b> <b>--ignore</b> and <b>sqlite-utils</b> <b>drop-table</b> <b>--ignore</b> options. (<u>#237</u>)

       • Fixed a bug with inserts of nested JSON containing non-ascii strings - thanks, Dylan Wu. (<u>#257</u>)

       • Suggest <b>--alter</b> if an error occurs caused by a missing column. (<u>#259</u>)

       • Support creating indexes with columns in descending order, see <u>API</u> <u>documentation</u> and <u>CLI</u> <u>documentation</u>.
         (<u>#260</u>)

       • Correctly handle CSV files that start with a UTF-8 BOM. (<u>#250</u>)

   <b>3.6</b> <b>(2021-02-18)</b>
       This release adds the ability to execute queries joining data from more than one database file -  similar
       to the cross database querying feature introduced in <u>Datasette</u> <u>0.55</u>.

       • The  <b>db.attach(alias,</b>  <b>filepath)</b>  Python  method  can  be  used  to  attach extra databases to the same
         connection, see <u>db.attach()</u> <u>in</u> <u>the</u> <u>Python</u> <u>API</u> <u>documentation</u>. (<u>#113</u>)

       • The <b>--attach</b> option attaches extra aliased databases  to  run  SQL  queries  against  directly  on  the
         command-line, see <u>attaching</u> <u>additional</u> <u>databases</u> <u>in</u> <u>the</u> <u>CLI</u> <u>documentation</u>. (<u>#236</u>)

   <b>3.5</b> <b>(2021-02-14)</b>
       • <b>sqlite-utils</b>  <b>insert</b> <b>--sniff</b> option for detecting the delimiter and quote character used by a CSV file,
         see <u>Alternative</u> <u>delimiters</u> <u>and</u> <u>quote</u> <u>characters</u>. (<u>#230</u>)

       • The <b>table.rows_where()</b>, <b>table.search()</b> and <b>table.search_sql()</b> methods all now take optional <b>offset=</b> and
         <b>limit=</b> arguments. (<u>#231</u>)

       • New <b>--no-headers</b> option for <b>sqlite-utils</b> <b>insert</b> <b>--csv</b> to handle CSV files that are missing  the  header
         row, see <u>CSV</u> <u>files</u> <u>without</u> <u>a</u> <u>header</u> <u>row</u>. (<u>#228</u>)

       • Fixed  bug  where inserting data with extra columns in subsequent chunks would throw an error. Thanks ‐
         <u>@nieuwenhoven</u> for the fix. (<u>#234</u>)

       • Fixed bug importing CSV files with columns containing more than 128KB of data. (<u>#229</u>)

       • Test suite now runs in CI against Ubuntu, macOS and Windows. Thanks <u>@nieuwenhoven</u> for the Windows  test
         fixes. (<u>#232</u>)

   <b>3.4.1</b> <b>(2021-02-05)</b>
       • Fixed a code import bug that slipped in to 3.4. (<u>#226</u>)

   <b>3.4</b> <b>(2021-02-05)</b>
       • <b>sqlite-utils</b>  <b>insert</b>  <b>--csv</b>  now  accepts optional <b>--delimiter</b> and <b>--quotechar</b> options. See <u>Alternative</u>
         <u>delimiters</u> <u>and</u> <u>quote</u> <u>characters</u>. (<u>#223</u>)

   <b>3.3</b> <b>(2021-01-17)</b>
       • The <b>table.m2m()</b> method now accepts an optional <b>alter=True</b> argument to specify that any missing  columns
         should be added to the referenced table. See <u>Working</u> <u>with</u> <u>many-to-many</u> <u>relationships</u>. (<u>#222</u>)

   <b>3.2.1</b> <b>(2021-01-12)</b>
       • Fixed  a bug where <b>.add_missing_columns()</b> failed to take case insensitive column names into account. (‐
         <u>#221</u>)

   <b>3.2</b> <b>(2021-01-03)</b>
       This release introduces a new mechanism for speeding up  <b>count(*)</b>  queries  using  cached  table  counts,
       stored  in  a  <b>_counts</b>  table and updated by triggers. This mechanism is described in <u>Cached</u> <u>table</u> <u>counts</u>
       <u>using</u> <u>triggers</u>, and can be enabled using Python API methods or the new <b>enable-counts</b> CLI command. (<u>#212</u>)

       • <b>table.enable_counts()</b> method for enabling these triggers on a specific table.

       • <b>db.enable_counts()</b> method for enabling triggers on every table in the database. (<u>#213</u>)

       • New <b>sqlite-utils</b> <b>enable-counts</b> <b>my.db</b> command for  enabling  counts  on  all  or  specific  tables,  see
         <u>Enabling</u> <u>cached</u> <u>counts</u>. (<u>#214</u>)

       • New  <b>sqlite-utils</b>  <b>triggers</b> command for listing the triggers defined for a database or specific tables,
         see <u>Listing</u> <u>triggers</u>. (<u>#218</u>)

       • New <b>db.use_counts_table</b> property which, if <b>True</b>, causes <b>table.count</b> to read from the <b>_counts</b> table.  (‐
         <u>#215</u>)

       • <b>table.has_counts_triggers</b>  property  revealing  if  a  table  has  been configured with the new <b>_counts</b>
         database triggers.

       • <b>db.reset_counts()</b> method and <b>sqlite-utils</b> <b>reset-counts</b> command for resetting the values in the  <b>_counts</b>
         table. (<u>#219</u>)

       • The previously undocumented <b>db.escape()</b> method has been renamed to <b>db.quote()</b> and is now covered by the
         documentation: <u>Quoting</u> <u>strings</u> <u>for</u> <u>use</u> <u>in</u> <u>SQL</u>. (<u>#217</u>)

       • New <b>table.triggers_dict</b> and <b>db.triggers_dict</b> introspection properties. (<u>#211</u>, <u>#216</u>)

       • <b>sqlite-utils</b> <b>insert</b> now shows a more useful error message for invalid JSON. (<u>#206</u>)

   <b>3.1.1</b> <b>(2021-01-01)</b>
       • Fixed failing test caused by <b>optimize</b> sometimes creating larger database files. (<u>#209</u>)

       • Documentation now lives on <u>https://sqlite-utils.datasette.io/</u>

       • README now includes <b>brew</b> <b>install</b> <b>sqlite-utils</b> installation method.

   <b>3.1</b> <b>(2020-12-12)</b>
       • New  command:  <b>sqlite-utils</b>  <b>analyze-tables</b> <b>my.db</b> outputs useful information about the table columns in
         the database, such as the number of distinct values and how many rows are null.  See  <u>Analyzing</u>  <u>tables</u>
         for documentation. (<u>#207</u>)

       • New  <b>table.analyze_column(column)</b>  Python  method  used by the <b>analyze-tables</b> command - see <u>Analyzing</u> <u>a</u>
         <u>column</u>.

       • The <b>table.update()</b> method now correctly handles values that should be stored as JSON.  Thanks,  Andreas
         Madsack. (<u>#204</u>)

   <b>3.0</b> <b>(2020-11-08)</b>
       This  release  introduces a new <b>sqlite-utils</b> <b>search</b> command for searching tables, see <u>Executing</u> <u>searches</u>.
       (<u>#192</u>)

       The <b>table.search()</b> method has been redesigned, see <u>Searching</u> <u>with</u> <u>table.search()</u>. (<u>#197</u>)

       The release includes minor backwards-incompatible changes, hence the version bump to 3.0. Those  changes,
       which should not affect most users, are:

       • The  <b>-c</b>  shortcut  option  for outputting CSV is no longer available. The full <b>--csv</b> option is required
         instead.

       • The <b>-f</b> shortcut for <b>--fmt</b> has also been removed - use <b>--fmt</b>.

       • The <b>table.search()</b> method now defaults to sorting by relevance, not sorting by <b>rowid</b>. (<u>#198</u>)

       • The <b>table.search()</b> method now returns a generator over a list of  Python  dictionaries.  It  previously
         returned a list of tuples.

       Also in this release:

       • The <b>query</b>, <b>tables</b>, <b>rows</b> and <b>search</b> CLI commands now accept a new <b>--tsv</b> option which outputs the results
         in TSV. (<u>#193</u>)

       • A  new  <b>table.virtual_table_using</b> property reveals if a table is a virtual table, and returns the upper
         case type of virtual table (e.g. <b>FTS4</b> or <b>FTS5</b>) if it is. It returns <b>None</b> if the table is not a  virtual
         table. (<u>#196</u>)

       • The  new <b>table.search_sql()</b> method returns the SQL for searching a table, see <u>Building</u> <u>SQL</u> <u>queries</u> <u>with</u>
         <u>table.search_sql()</u>.

       • <b>sqlite-utils</b> <b>rows</b> now accepts multiple optional <b>-c</b> parameters specifying the columns to return. (<u>#200</u>)

       Changes since the 3.0a0 alpha release:

       • The <b>sqlite-utils</b> <b>search</b> command now defaults to returning every result, unless you  add  a  <b>--limit</b>  <b>20</b>
         option.

       • The <b>sqlite-utils</b> <b>search</b> <b>-c</b> and <b>table.search(columns=[])</b> options are now fully respected. (<u>#201</u>)

   <b>2.23</b> <b>(2020-10-28)</b>
       • <b>table.m2m(other_table,</b>  <b>records)</b>  method now takes any iterable, not just a list or tuple. Thanks, Adam
         Wolf. (<u>#189</u>)

       • <b>sqlite-utils</b> <b>insert</b> now displays a progress bar for CSV or TSV imports. (<u>#173</u>)

       • New <b>@db.register_function(deterministic=True)</b> option for registering deterministic SQLite functions  in
         Python 3.8 or higher. (<u>#191</u>)

   <b>2.22</b> <b>(2020-10-16)</b>
       • New  <b>--encoding</b>  option  for  processing  CSV and TSV files that use a non-utf-8 encoding, for both the
         <b>insert</b> and <b>update</b> commands. (<u>#182</u>)

       • The <b>--load-extension</b> option is now available to many more commands. (<u>#137</u>)

       • <b>--load-extension=spatialite</b> can be used to load SpatiaLite from common installation locations, if it is
         available. (<u>#136</u>)

       • Tests now also run against Python 3.9. (<u>#184</u>)

       • Passing <b>pk=["id"]</b> now has the same effect as passing <b>pk="id"</b>. (<u>#181</u>)

   <b>2.21</b> <b>(2020-09-24)</b>
       • <b>table.extract()</b> and <b>sqlite-utils</b> <b>extract</b> now apply much, much faster - one  example  operation  reduced
         from twelve minutes to just four seconds! (<u>#172</u>)

       • <b>sqlite-utils</b> <b>extract</b> no longer shows a progress bar, because it's fast enough not to need one.

       • New  <b>column_order=</b>  option  for  <b>table.transform()</b> which can be used to alter the order of columns in a
         table. (<u>#175</u>)

       • <b>sqlite-utils</b> <b>transform</b> <b>--column-order=</b> option (with a <b>-o</b> shortcut) for changing column order. (<u>#176</u>)

       • The <b>table.transform(drop_foreign_keys=)</b> parameter and  the  <b>sqlite-utils</b>  <b>transform</b>  <b>--drop-foreign-key</b>
         option have changed. They now accept just the name of the column rather than requiring all three of the
         column,  other  table and other column. This is technically a backwards-incompatible change but I chose
         not to bump the major version number because the transform feature is so new. (<u>#177</u>)

       • The table <b>.disable_fts()</b>, <b>.rebuild_fts()</b>, <b>.delete()</b>, <b>.delete_where()</b> and <b>.add_missing_columns()</b> methods
         all now <b>return</b> <b>self</b>, which means they can be chained together with other table operations.

   <b>2.20</b> <b>(2020-09-22)</b>
       This release introduces two key new capabilities: <b>transform</b> (<u>#114</u>) and <b>extract</b> (<u>#42</u>).

   <b>Transform</b>
       SQLite's ALTER TABLE  has  <u>several</u>  <u>documented</u>  <u>limitations</u>.  The  <b>table.transform()</b>  Python  method  and
       <b>sqlite-utils</b>  <b>transform</b>  CLI command work around these limitations using a pattern where a new table with
       the desired structure is created, data is copied over to it  and  the  old  table  is  then  dropped  and
       replaced by the new one.

       You can use these tools to change column types, rename columns, drop columns, add and remove <b>NOT</b> <b>NULL</b> and
       defaults,  remove  foreign  key  constraints and more. See the <u>transforming</u> <u>tables</u> <u>(CLI)</u> and <u>transforming</u>
       <u>tables</u> <u>(Python</u> <u>library)</u> documentation for full details of how to use them.

   <b>Extract</b>
       Sometimes a database table - especially one imported from a CSV file - will  contain  duplicate  data.  A
       <b>Trees</b>  table  may  include  a  <b>Species</b>  column with only a few dozen unique values, when the table itself
       contains thousands of rows.

       The <b>table.extract()</b> method and <b>sqlite-utils</b> <b>extract</b> commands can extract a column - or multiple columns -
       out into a separate lookup table, and set up a foreign key relationship from the original table.

       The Python library <u>extract()</u> <u>documentation</u> describes how  extraction  works  in  detail,  and  <u>Extracting</u>
       <u>columns</u> <u>into</u> <u>a</u> <u>separate</u> <u>table</u> in the CLI documentation includes a detailed example.

   <b>Other</b> <b>changes</b>
       • The  <b>@db.register_function</b>  decorator  can  be  used to quickly register Python functions as custom SQL
         functions, see <u>Registering</u> <u>custom</u> <u>SQL</u> <u>functions</u>. (<u>#162</u>)

       • The <b>table.rows_where()</b> method now accepts an optional <b>select=</b> argument  for  specifying  which  columns
         should be selected, see <u>Listing</u> <u>rows</u>.

   <b>2.19</b> <b>(2020-09-20)</b>
       • New <b>sqlite-utils</b> <b>add-foreign-keys</b> command for <u>Adding</u> <u>multiple</u> <u>foreign</u> <u>keys</u> <u>at</u> <u>once</u>. (<u>#157</u>)

       • New  <b>table.enable_fts(...,</b>  <b>replace=True)</b>  argument  for  replacing  an  existing  FTS table with a new
         configuration. (<u>#160</u>)

       • New <b>table.add_foreign_key(...,</b> <b>ignore=True)</b> argument for ignoring a foreign key if it  already  exists.
         (<u>#112</u>)

   <b>2.18</b> <b>(2020-09-08)</b>
       • <b>table.rebuild_fts()</b> method for rebuilding a FTS index, see <u>Rebuilding</u> <u>a</u> <u>full-text</u> <u>search</u> <u>table</u>. (<u>#155</u>)

       • <b>sqlite-utils</b> <b>rebuild-fts</b> <b>data.db</b> command for rebuilding FTS indexes across all tables, or just specific
         tables. (<u>#155</u>)

       • <b>table.optimize()</b>  method  no  longer  deletes junk rows from the <b>*_fts_docsize</b> table. This was added in
         2.17 but it turns out running <b>table.rebuild_fts()</b> is a better solution to this problem.

       • Fixed a bug where rows with additional columns that are inserted after the first batch of records could
         cause an error due to breaking SQLite's maximum number of parameters. Thanks, Simon Wiles. (<u>#145</u>)

   <b>2.17</b> <b>(2020-09-07)</b>
       This release handles a bug where replacing rows  in  FTS  tables  could  result  in  growing  numbers  of
       unnecessary rows in the associated <b>*_fts_docsize</b> table. (<u>#149</u>)

       • <b>PRAGMA</b>   <b>recursive_triggers=on</b>   by   default   for   all   connections.  You  can  turn  it  off  with
         <b>Database(recursive_triggers=False)</b>. (<u>#152</u>)

       • <b>table.optimize()</b> method now deletes unnecessary rows from the <b>*_fts_docsize</b> table. (<u>#153</u>)

       • New tracer method for tracking underlying SQL queries, see <u>Tracing</u> <u>queries</u>. (<u>#150</u>)

       • Neater indentation for schema SQL. (<u>#148</u>)

       • Documentation for <b>sqlite_utils.AlterError</b> exception thrown by in <b>add_foreign_keys()</b>.

   <b>2.16.1</b> <b>(2020-08-28)</b>
       • <b>insert_all(...,</b> <b>alter=True)</b> now works for columns introduced after the first 100 records. Thanks, Simon
         Wiles! (<u>#139</u>)

       • Continuous Integration is now powered by GitHub Actions. (<u>#143</u>)

   <b>2.16</b> <b>(2020-08-21)</b>
       • <b>--load-extension</b> option for <b>sqlite-utils</b> <b>query</b> for loading SQLite extensions. (<u>#134</u>)

       • New <b>sqlite_utils.utils.find_spatialite()</b> function for finding SpatiaLite in common locations. (<u>#135</u>)

   <b>2.15.1</b> <b>(2020-08-12)</b>
       • Now available as a <b>sdist</b> package on PyPI in addition to a wheel. (<u>#133</u>)

   <b>2.15</b> <b>(2020-08-10)</b>
       • New <b>db.enable_wal()</b> and <b>db.disable_wal()</b> methods for enabling and disabling <u>Write-Ahead</u> <u>Logging</u>  for  a
         database file - see <u>WAL</u> <u>mode</u> in the Python API documentation.

       • Also  <b>sqlite-utils</b>  <b>enable-wal</b> <b>file.db</b> and <b>sqlite-utils</b> <b>disable-wal</b> <b>file.db</b> commands for doing the same
         thing on the command-line, see <u>WAL</u> <u>mode</u> <u>(CLI)</u>. (<u>#132</u>)

   <b>2.14.1</b> <b>(2020-08-05)</b>
       • Documentation improvements.

   <b>2.14</b> <b>(2020-08-01)</b>
       • The <u>insert-files</u> <u>command</u> can now read from standard input:  <b>cat</b>  <b>dog.jpg</b>  <b>|</b>  <b>sqlite-utils</b>  <b>insert-files</b>
         <b>dogs.db</b> <b>pics</b> <b>-</b> <b>--name=dog.jpg</b>. (<u>#127</u>)

       • You  can  now  specify  a full-text search tokenizer using the new <b>tokenize=</b> parameter to <u>enable_fts()</u>.
         This means you can enable Porter stemming on a table by running  <b>db["articles"].enable_fts(["headline",</b>
         <b>"body"],</b> <b>tokenize="porter")</b>. (<u>#130</u>)

       • You  can  also  set  a  custom  tokenizer  using  the  <u>sqlite-utils</u> <u>enable-fts</u> CLI command, via the new
         <b>--tokenize</b> option.

   <b>2.13</b> <b>(2020-07-29)</b>
       • <b>memoryview</b> and <b>uuid.UUID</b> objects are now supported. <b>memoryview</b> objects will be stored  using  <b>BLOB</b>  and
         <b>uuid.UUID</b> objects will be stored using <b>TEXT</b>. (<u>#128</u>)

   <b>2.12</b> <b>(2020-07-27)</b>
       The  theme of this release is better tools for working with binary data. The new <b>insert-files</b> command can
       be used to insert binary files directly into a database table, and other commands have been improved with
       better support for BLOB columns.

       • <b>sqlite-utils</b> <b>insert-files</b> <b>my.db</b> <b>gifs</b> <b>*.gif</b> can now insert the contents of files into a specified table.
         The columns in the table can be customized to include different pieces of  metadata  derived  from  the
         files. See <u>Inserting</u> <u>data</u> <u>from</u> <u>files</u>. (<u>#122</u>)

       • <b>--raw</b>  option to <b>sqlite-utils</b> <b>query</b> - for outputting just a single raw column value - see <u>Returning</u> <u>raw</u>
         <u>data,</u> <u>such</u> <u>as</u> <u>binary</u> <u>content</u>. (<u>#123</u>)

       • JSON output now encodes BLOB values as special base64 objects - see <u>Returning</u> <u>JSON</u>. (<u>#125</u>)

       • The same format of JSON base64 objects can now be used to insert binary data - see <u>Inserting</u> <u>JSON</u> <u>data</u>.
         (<u>#126</u>)

       • The <b>sqlite-utils</b> <b>query</b> command can now accept named parameters, e.g. <b>sqlite-utils</b> <b>:memory:</b> <b>"select</b> <b>:num</b>
         <b>*</b> <b>:num2"</b> <b>-p</b> <b>num</b> <b>5</b> <b>-p</b> <b>num2</b> <b>6</b> - see <u>Returning</u> <u>JSON</u>. (<u>#124</u>)

   <b>2.11</b> <b>(2020-07-08)</b>
       • New <b>--truncate</b> option to <b>sqlite-utils</b> <b>insert</b>, and  <b>truncate=True</b>  argument  to  <b>.insert_all()</b>.  Thanks,
         Thomas Sibley. (<u>#118</u>)

       • The <b>sqlite-utils</b> <b>query</b> command now runs updates in a transaction. Thanks, Thomas Sibley. (<u>#120</u>)

   <b>2.10.1</b> <b>(2020-06-23)</b>
       • Added documentation for the <b>table.pks</b> introspection property. (<u>#116</u>)

   <b>2.10</b> <b>(2020-06-12)</b>
       • The <b>sqlite-utils</b> command now supports UPDATE/INSERT/DELETE in addition to SELECT. (<u>#115</u>)

   <b>2.9.1</b> <b>(2020-05-11)</b>
       • Added custom project links to the <u>PyPI</u> <u>listing</u>.

   <b>2.9</b> <b>(2020-05-10)</b>
       • New <b>sqlite-utils</b> <b>drop-table</b> command, see <u>Dropping</u> <u>tables</u>. (<u>#111</u>)

       • New <b>sqlite-utils</b> <b>drop-view</b> command, see <u>Dropping</u> <u>views</u>.

       • Python <b>decimal.Decimal</b> objects are now stored as <b>FLOAT</b>. (<u>#110</u>)

   <b>2.8</b> <b>(2020-05-03)</b>
       • New <b>sqlite-utils</b> <b>create-table</b> command, see <u>Creating</u> <u>tables</u>. (<u>#27</u>)

       • New <b>sqlite-utils</b> <b>create-view</b> command, see <u>Creating</u> <u>views</u>. (<u>#107</u>)

   <b>2.7.2</b> <b>(2020-05-02)</b>
       • <b>db.create_view(...)</b>  now  has additional parameters <b>ignore=True</b> or <b>replace=True</b>, see <u>Creating</u> <u>views</u>. (‐
         <u>#106</u>)

   <b>2.7.1</b> <b>(2020-05-01)</b>
       • New <b>sqlite-utils</b> <b>views</b> <b>my.db</b> command for listing views in a database, see <u>Listing</u> <u>views</u>. (<u>#105</u>)

       • <b>sqlite-utils</b> <b>tables</b> (and <b>views</b>) has a new <b>--schema</b> option which  outputs  the  table/view  schema,  see
         <u>Listing</u> <u>tables</u>. (<u>#104</u>)

       • Nested  structures  containing  invalid  JSON values (e.g. Python bytestrings) are now serialized using
         <b>repr()</b> instead of throwing an error. (<u>#102</u>)

   <b>2.7</b> <b>(2020-04-17)</b>
       • New <b>columns=</b> argument for the  <b>.insert()</b>,  <b>.insert_all()</b>,  <b>.upsert()</b>  and  <b>.upsert_all()</b>  methods,  for
         over-riding  the auto-detected types for columns and specifying additional columns that should be added
         when the table is created. See <u>Custom</u> <u>column</u> <u>order</u> <u>and</u> <u>column</u> <u>types</u>. (<u>#100</u>)

   <b>2.6</b> <b>(2020-04-15)</b>
       • New <b>table.rows_where(...,</b> <b>order_by="age</b> <b>desc")</b> argument, see <u>Listing</u> <u>rows</u>. (<u>#76</u>)

   <b>2.5</b> <b>(2020-04-12)</b>
       • Panda's Timestamp is now stored as a SQLite TEXT column. Thanks, b0b5h4rp13! (<u>#96</u>)

       • <b>table.last_pk</b> is now only available for inserts or upserts of a single record. (<u>#98</u>)

       • New <b>Database(filepath,</b> <b>recreate=True)</b> parameter for deleting and recreating the database. (<u>#97</u>)

   <b>2.4.4</b> <b>(2020-03-23)</b>
       • Fixed bug where columns with only null values were not correctly created. (<u>#95</u>)

   <b>2.4.3</b> <b>(2020-03-23)</b>
       • Column type suggestion code is no longer confused by null values. (<u>#94</u>)

   <b>2.4.2</b> <b>(2020-03-14)</b>
       • <b>table.column_dicts</b> now works with all column types - previously it would throw errors  on  types  other
         than <b>TEXT</b>, <b>BLOB</b>, <b>INTEGER</b> or <b>FLOAT</b>. (<u>#92</u>)

       • Documentation for <b>NotFoundError</b> thrown by <b>table.get(pk)</b> - see <u>Retrieving</u> <u>a</u> <u>specific</u> <u>record</u>.

   <b>2.4.1</b> <b>(2020-03-01)</b>
       • <b>table.enable_fts()</b> now works with columns that contain spaces. (<u>#90</u>)

   <b>2.4</b> <b>(2020-02-26)</b>
       • <b>table.disable_fts()</b>  can  now  be  used  to  remove  FTS  tables  and  triggers that were created using
         <b>table.enable_fts(...)</b>. (<u>#88</u>)

       • The <b>sqlite-utils</b> <b>disable-fts</b>  command  can  be  used  to  remove  FTS  tables  and  triggers  from  the
         command-line. (<u>#88</u>)

       • Trying to create table columns with square braces ([ or ]) in the name now raises an error. (<u>#86</u>)

       • Subclasses of <b>dict</b>, <b>list</b> and <b>tuple</b> are now detected as needing a JSON column. (<u>#87</u>)

   <b>2.3.1</b> <b>(2020-02-10)</b>
       <b>table.create_index()</b> now works for columns that contain spaces. (<u>#85</u>)

   <b>2.3</b> <b>(2020-02-08)</b>
       <b>table.exists()</b>  is  now a method, not a property. This was not a documented part of the API before so I'm
       considering this a non-breaking change. (<u>#83</u>)

   <b>2.2.1</b> <b>(2020-02-06)</b>
       Fixed a bug where <b>.upsert(...,</b> <b>hash_id="pk")</b> threw an error (<u>#84</u>).

   <b>2.2</b> <b>(2020-02-01)</b>
       New feature: <b>sqlite_utils.suggest_column_types([records])</b> returns the suggested column types for  a  list
       of records. See <u>Suggesting</u> <u>column</u> <u>types</u>. (<u>#81</u>).

       This replaces the undocumented <b>table.detect_column_types()</b> method.

   <b>2.1</b> <b>(2020-01-30)</b>
       New  feature:  <b>conversions={...}</b>  can  be  passed  to  the  <b>.insert()</b>  family of functions to specify SQL
       conversions that should be applied to values that are being inserted or updated.  See  <u>Converting</u>  <u>column</u>
       <u>values</u> <u>using</u> <u>SQL</u> <u>functions</u> . (<u>#77</u>).

   <b>2.0.1</b> <b>(2020-01-05)</b>
       The  <b>.upsert()</b>  and <b>.upsert_all()</b> methods now raise a <b>sqlite_utils.db.PrimaryKeyRequired</b> exception if you
       call them without specifying the primary key column using <b>pk=</b> (<u>#73</u>).

   <b>2.0</b> <b>(2019-12-29)</b>
       This release changes the behaviour of <b>upsert</b>. It's a breaking change, hence <b>2.0</b>.

       The <b>upsert</b> command-line utility and the <b>.upsert()</b> and <b>.upsert_all()</b> Python API  methods  have  had  their
       behaviour  altered.  They used to completely replace the affected records: now, they update the specified
       values on existing records but leave other columns unaffected.

       See <u>Upserting</u> <u>data</u> <u>using</u> <u>the</u> <u>Python</u> <u>API</u> and <u>Upserting</u> <u>data</u> <u>using</u> <u>the</u> <u>CLI</u> for full details.

       If you want the old behaviour - where records were completely replaced  -  you  can  use  <b>$</b>  <b>sqlite-utils</b>
       <b>insert</b>   <b>...</b>   <b>--replace</b>   on  the  command-line  and  <b>.insert(...,</b>  <b>replace=True)</b>  and  <b>.insert_all(...,</b>
       <b>replace=True)</b> in the Python API. See <u>Insert-replacing</u> <u>data</u> <u>using</u> <u>the</u> <u>Python</u> <u>API</u> and <u>Insert-replacing</u> <u>data</u>
       <u>using</u> <u>the</u> <u>CLI</u> for more.

       For full background on this change, see <u>issue</u> <u>#66</u>.

   <b>1.12.1</b> <b>(2019-11-06)</b>
       • Fixed error thrown when <b>.insert_all()</b> and <b>.upsert_all()</b> were called with empty lists (<u>#52</u>)

   <b>1.12</b> <b>(2019-11-04)</b>
       Python library utilities for deleting records (<u>#62</u>)

       • <b>db["tablename"].<a href="../man4/delete.4.html">delete</a>(4)</b> to delete by primary key, see <u>Deleting</u> <u>a</u> <u>specific</u> <u>record</u>

       • <b>db["tablename"].delete_where("id</b> <b>&gt;</b> <b>?",</b> <b>[3])</b> to delete by a where clause, see <u>Deleting</u> <u>multiple</u> <u>records</u>

   <b>1.11</b> <b>(2019-09-02)</b>
       Option to create triggers to automatically keep FTS tables up-to-date with newly  inserted,  updated  and
       deleted records. Thanks, Amjith Ramanujam! (<u>#57</u>)

       • <b>sqlite-utils</b> <b>enable-fts</b> <b>...</b> <b>--create-triggers</b> - see <u>Configuring</u> <u>full-text</u> <u>search</u> <u>using</u> <u>the</u> <u>CLI</u>

       • <b>db["tablename"].enable_fts(...,</b>  <b>create_triggers=True)</b>  -  see  <u>Configuring</u>  <u>full-text</u> <u>search</u> <u>using</u> <u>the</u>
         <u>Python</u> <u>library</u>

       • Support for introspecting triggers for a database or table - see <u>Introspecting</u> <u>tables</u> <u>and</u> <u>views</u> (<u>#59</u>)

   <b>1.10</b> <b>(2019-08-23)</b>
       Ability to introspect and run queries against views (<u>#54</u>)

       • <b>db.view_names()</b> method and and <b>db.views</b> property

       • Separate <b>View</b> and <b>Table</b> classes, both subclassing new <b>Queryable</b> class

       • <b>view.drop()</b> method

       See <u>Listing</u> <u>views</u>.

   <b>1.9</b> <b>(2019-08-04)</b>
       • <b>table.m2m(...)</b> method for creating many-to-many relationships: <u>Working</u> <u>with</u> <u>many-to-many</u>  <u>relationships</u>
         (<u>#23</u>)

   <b>1.8</b> <b>(2019-07-28)</b>
       • <b>table.update(pk,</b> <b>values)</b> method: <u>Updating</u> <u>a</u> <u>specific</u> <u>record</u> (<u>#35</u>)

   <b>1.7.1</b> <b>(2019-07-28)</b>
       • Fixed  bug  where  inserting  records  with  11  columns  in  a  batch of 100 triggered a "too many SQL
         variables" error (<u>#50</u>)

       • Documentation and tests for <b>table.drop()</b> method: <u>Dropping</u> <u>a</u> <u>table</u> <u>or</u> <u>view</u>

   <b>1.7</b> <b>(2019-07-24)</b>
       Support for lookup tables.

       • New <b>table.lookup({...})</b> utility method for building and querying  lookup  tables  -  see  <u>Working</u>  <u>with</u>
         <u>lookup</u> <u>tables</u> (<u>#44</u>)

       • New   <b>extracts=</b>   table  configuration  option,  see  <u>Populating</u>  <u>lookup</u>  <u>tables</u>  <u>automatically</u>  <u>during</u>
         <u>insert/upsert</u> (<u>#46</u>)

       • Use <u>pysqlite3</u> if it is available, otherwise use <b>sqlite3</b> from the standard library

       • Table options can now be passed to the new <b>db.table(name,</b> <b>**options)</b> factory function  in  addition  to
         being passed to <b>insert_all(records,</b> <b>**options)</b> and friends - see <u>Table</u> <u>configuration</u> <u>options</u>

       • In-memory databases can now be created using <b>db</b> <b>=</b> <b>Database(memory=True)</b>

   <b>1.6</b> <b>(2019-07-18)</b>
       • <b>sqlite-utils</b> <b>insert</b> can now accept TSV data via the new <b>--tsv</b> option (<u>#41</u>)

   <b>1.5</b> <b>(2019-07-14)</b>
       • Support for compound primary keys (<u>#36</u>)

         • Configure these using the CLI tool by passing <b>--pk</b> multiple times

         • In Python, pass a tuple of columns to the <b>pk=(...,</b> <b>...)</b> argument: <u>Compound</u> <u>primary</u> <u>keys</u>

       • New <b>table.get()</b> method for retrieving a record by its primary key: <u>Retrieving</u> <u>a</u> <u>specific</u> <u>record</u> (<u>#39</u>)

   <b>1.4.1</b> <b>(2019-07-14)</b>
       • Assorted minor documentation fixes: <u>changes</u> <u>since</u> <u>1.4</u>

   <b>1.4</b> <b>(2019-06-30)</b>
       • Added <b>sqlite-utils</b> <b>index-foreign-keys</b> command (<u>docs</u>) and <b>db.index_foreign_keys()</b> method (<u>docs</u>) (<u>#33</u>)

   <b>1.3</b> <b>(2019-06-28)</b>
       • New  mechanism for adding multiple foreign key constraints at once: <u>db.add_foreign_keys()</u> <u>documentation</u>
         (<u>#31</u>)

   <b>1.2.2</b> <b>(2019-06-25)</b>
       • Fixed bug where <b>datetime.time</b> was not being handled correctly

   <b>1.2.1</b> <b>(2019-06-20)</b>
       • Check the column exists before attempting to add a foreign key (<u>#29</u>)

   <b>1.2</b> <b>(2019-06-12)</b>
       • Improved foreign  key  definitions:  you  no  longer  need  to  specify  the  <b>column</b>,  <b>other_table</b>  AND
         <b>other_column</b>  to  define  a  foreign  key - if you omit the <b>other_table</b> or <b>other_column</b> the script will
         attempt to guess the correct values by introspecting the database. See <u>Adding</u> <u>foreign</u>  <u>key</u>  <u>constraints</u>
         for details. (<u>#25</u>)

       • Ability  to  set  <b>NOT</b>  <b>NULL</b>  constraints  and <b>DEFAULT</b> values when creating tables (<u>#24</u>). Documentation:
         <u>Setting</u> <u>defaults</u> <u>and</u> <u>not</u> <u>null</u> <u>constraints</u> <u>(Python</u> <u>API)</u>, <u>Setting</u> <u>defaults</u> <u>and</u> <u>not</u> <u>null</u> <u>constraints</u> <u>(CLI)</u>

       • Support for <b>not_null_default=X</b> / <b>--not-null-default</b> for setting a <b>NOT</b> <b>NULL</b> <b>DEFAULT</b> <b>'x'</b>  when  adding  a
         new column. Documentation: <u>Adding</u> <u>columns</u> <u>(Python</u> <u>API)</u>, <u>Adding</u> <u>columns</u> <u>(CLI)</u>

   <b>1.1</b> <b>(2019-05-28)</b>
       • Support  for  <b>ignore=True</b> / <b>--ignore</b> for ignoring inserted records if the primary key already exists (‐
         <u>#21</u>) - documentation: <u>Inserting</u> <u>data</u> <u>(Python</u> <u>API)</u>, <u>Inserting</u> <u>data</u> <u>(CLI)</u>

       • Ability to add a column that is a foreign key reference using <b>fk=...</b>  /  <b>--fk</b>  (<u>#16</u>)  -  documentation:
         <u>Adding</u> <u>columns</u> <u>(Python</u> <u>API)</u>, <u>Adding</u> <u>columns</u> <u>(CLI)</u>

   <b>1.0.1</b> <b>(2019-05-27)</b>
       • <b>sqlite-utils</b> <b>rows</b> <b>data.db</b> <b>table</b> <b>--json-cols</b> - fixed bug where <b>--json-cols</b> was not obeyed

   <b>1.0</b> <b>(2019-05-24)</b>
       •

         <b>Option</b> <b>to</b> <b>automatically</b> <b>add</b> <b>new</b> <b>columns</b> <b>if</b> <b>you</b> <b>attempt</b> <b>to</b> <b>insert</b> <b>or</b> <b>upsert</b> <b>data</b> <b>with</b> <b>extra</b> <b>fields:</b>
                <b>sqlite-utils</b> <b>insert</b> <b>...</b> <b>--alter</b> - see <u>Adding</u> <u>columns</u> <u>automatically</u> <u>with</u> <u>the</u> <u>sqlite-utils</u> <u>CLI</u>

                <b>db["tablename"].insert(record,</b>  <b>alter=True)</b>  - see <u>Adding</u> <u>columns</u> <u>automatically</u> <u>using</u> <u>the</u> <u>Python</u>
                <u>API</u>

       • New <b>--json-cols</b> option for outputting nested JSON, see <u>Nested</u> <u>JSON</u> <u>values</u>

   <b>0.14</b> <b>(2019-02-24)</b>
       • Ability to create unique indexes: <b>db["mytable"].create_index(["name"],</b> <b>unique=True)</b>

       • <b>db["mytable"].create_index(["name"],</b> <b>if_not_exists=True)</b>

       • <b>$</b> <b>sqlite-utils</b> <b>create-index</b> <b>mydb.db</b> <b>mytable</b> <b>col1</b> <b>[col2...]</b>, see <u>Creating</u> <u>indexes</u>

       • <b>table.add_column(name,</b> <b>type)</b> method, see <u>Adding</u> <u>columns</u>

       • <b>$</b> <b>sqlite-utils</b> <b>add-column</b> <b>mydb.db</b> <b>mytable</b> <b>nameofcolumn</b>, see <u>Adding</u> <u>columns</u> (CLI)

       • <b>db["books"].add_foreign_key("author_id",</b> <b>"authors",</b> <b>"id")</b>, see <u>Adding</u> <u>foreign</u> <u>key</u> <u>constraints</u>

       • <b>$</b> <b>sqlite-utils</b> <b>add-foreign-key</b> <b>books.db</b> <b>books</b> <b>author_id</b> <b>authors</b> <b>id</b>, see <u>Adding</u> <u>foreign</u> <u>key</u>  <u>constraints</u>
         (CLI)

       • Improved (but backwards-incompatible) <b>foreign_keys=</b> argument to various methods, see <u>Specifying</u> <u>foreign</u>
         <u>keys</u>

   <b>0.13</b> <b>(2019-02-23)</b>
       • New <b>--table</b> and <b>--fmt</b> options can be used to output query results in a variety of visual table formats,
         see <u>Table-formatted</u> <u>output</u>

       • New <b>hash_id=</b> argument can now be used for <u>Setting</u> <u>an</u> <u>ID</u> <u>based</u> <u>on</u> <u>the</u> <u>hash</u> <u>of</u> <u>the</u> <u>row</u> <u>contents</u>

       • Can now derive correct column types for numpy int, uint and float values

       • <b>table.last_id</b> has been renamed to <b>table.last_rowid</b>

       • <b>table.last_pk</b> now contains the last inserted primary key, if <b>pk=</b> was specified

       • Prettier indentation in the <b>CREATE</b> <b>TABLE</b> generated schemas

   <b>0.12</b> <b>(2019-02-22)</b>
       • Added <b>db[table].rows</b> iterator - see <u>Listing</u> <u>rows</u>

       • Replaced <b>sqlite-utils</b> <b>json</b> and <b>sqlite-utils</b> <b>csv</b> with a new default subcommand called <b>sqlite-utils</b> <b>query</b>
         which  defaults  to JSON and takes formatting options <b>--nl</b>, <b>--csv</b> and <b>--no-headers</b> - see <u>Returning</u> <u>JSON</u>
         and <u>Returning</u> <u>CSV</u> <u>or</u> <u>TSV</u>

       • New <b>sqlite-utils</b> <b>rows</b> <b>data.db</b> <b>name-of-table</b> command, see <u>Returning</u> <u>all</u> <u>rows</u> <u>in</u> <u>a</u> <u>table</u>

       • <b>sqlite-utils</b> <b>table</b> command now takes options <b>--counts</b> and <b>--columns</b> plus  the  standard  output  format
         options, see <u>Listing</u> <u>tables</u>

   <b>0.11</b> <b>(2019-02-07)</b>
       New commands for enabling FTS against a table and columns:

          sqlite-utils enable-fts db.db mytable col1 col2

       See <u>Configuring</u> <u>full-text</u> <u>search</u>.

   <b>0.10</b> <b>(2019-02-06)</b>
       Handle <b>datetime.date</b> and <b>datetime.time</b> values.

       New option for efficiently inserting rows from a CSV:

          sqlite-utils insert db.db foo - --csv

   <b>0.9</b> <b>(2019-01-27)</b>
       Improved support for newline-delimited JSON.

       <b>sqlite-utils</b> <b>insert</b> has two new command-line options:

       • <b>--nl</b>  means  "expect  newline-delimited  JSON".  This is an extremely efficient way of loading in large
         amounts of data, especially if you pipe it into standard input.

       • <b>--batch-size=1000</b> lets you increase the batch size (default is 100). A commit will be  issued  every  X
         records. This also control how many initial records are considered when detecting the desired SQL table
         schema for the data.

       In  the  Python  API,  the  <b>table.insert_all(...)</b>  method can now accept a generator as well as a list of
       objects. This will be efficiently used to populate the table no matter how many records are  produced  by
       the generator.

       The  <b>Database()</b>  constructor  can now accept a <b>pathlib.Path</b> object in addition to a string or an existing
       SQLite connection object.

   <b>0.8</b> <b>(2019-01-25)</b>
       Two new commands: <b>sqlite-utils</b> <b>csv</b> and <b>sqlite-utils</b> <b>json</b>

       These commands execute a SQL query and return the results as CSV or JSON. See <u>Returning</u> <u>CSV</u>  <u>or</u>  <u>TSV</u>  and
       <u>Returning</u> <u>JSON</u> for more details.

          $ sqlite-utils json --help
          Usage: sqlite-utils json [OPTIONS] PATH SQL

            Execute SQL query and return the results as JSON

          Options:
            --nl      Output newline-delimited JSON
            --arrays  Output rows as arrays instead of objects
            --help    Show this message and exit.

          $ sqlite-utils csv --help
          Usage: sqlite-utils csv [OPTIONS] PATH SQL

            Execute SQL query and return the results as CSV

          Options:
            --no-headers  Exclude headers from CSV output
            --help        Show this message and exit.

   <b>0.7</b> <b>(2019-01-24)</b>
       This release implements the <b>sqlite-utils</b> command-line tool with a number of useful subcommands.

       • <b>sqlite-utils</b> <b>tables</b> <b>demo.db</b> lists the tables in the database

       • <b>sqlite-utils</b> <b>tables</b> <b>demo.db</b> <b>--fts4</b> shows just the FTS4 tables

       • <b>sqlite-utils</b> <b>tables</b> <b>demo.db</b> <b>--fts5</b> shows just the FTS5 tables

       • <b>sqlite-utils</b> <b>vacuum</b> <b>demo.db</b> runs VACUUM against the database

       • <b>sqlite-utils</b> <b>optimize</b> <b>demo.db</b> runs OPTIMIZE against all FTS tables, then VACUUM

       • <b>sqlite-utils</b> <b>optimize</b> <b>demo.db</b> <b>--no-vacuum</b> runs OPTIMIZE but skips VACUUM

       The  two  most useful subcommands are <b>upsert</b> and <b>insert</b>, which allow you to ingest JSON files with one or
       more records in them, creating the corresponding table with the correct columns if it  does  not  already
       exist. See <u>Inserting</u> <u>JSON</u> <u>data</u> for more details.

       • <b>sqlite-utils</b>  <b>insert</b>  <b>demo.db</b>  <b>dogs</b>  <b>dogs.json</b> <b>--pk=id</b> inserts new records from <b>dogs.json</b> into the <b>dogs</b>
         table

       • <b>sqlite-utils</b> <b>upsert</b> <b>demo.db</b>  <b>dogs</b>  <b>dogs.json</b>  <b>--pk=id</b>  upserts  records,  replacing  any  records  with
         duplicate primary keys

       One backwards incompatible change: the <b>db["table"].table_names</b> property is now a method:

       • <b>db["table"].table_names()</b> returns a list of table names

       • <b>db["table"].table_names(fts4=True)</b> returns a list of just the FTS4 tables

       • <b>db["table"].table_names(fts5=True)</b> returns a list of just the FTS5 tables

       A few other changes:

       • Plenty of updated documentation, including full coverage of the new command-line tool

       • Allow column names to be reserved words (use correct SQL escaping)

       • Added automatic column support for bytes and datetime.datetime

   <b>0.6</b> <b>(2018-08-12)</b>
       • <b>.enable_fts()</b>  now  takes  optional  argument <b>fts_version</b>, defaults to <b>FTS5</b>. Use <b>FTS4</b> if the version of
         SQLite bundled with your Python does not support FTS5

       • New optional <b>column_order=</b> argument to <b>.insert()</b> and friends for providing a partial  or  full  desired
         order of the columns when a database table is created

       • <u>New</u> <u>documentation</u> for <b>.insert_all()</b> and <b>.upsert()</b> and <b>.upsert_all()</b>

   <b>0.5</b> <b>(2018-08-05)</b>
       • <b>db.tables</b> and <b>db.table_names</b> introspection properties

       • <b>db.indexes</b> property for introspecting indexes

       • <b>table.create_index(columns,</b> <b>index_name)</b> method

       • <b>db.create_view(name,</b> <b>sql)</b> method

       • Table methods can now be chained, plus added <b>table.last_id</b> for accessing the last inserted row ID

   <b>0.4</b> <b>(2018-07-31)</b>
       • <b>enable_fts()</b>, <b>populate_fts()</b> and <b>search()</b> table methods

   <b>0.3.1</b> <b>(2018-07-31)</b>
       • Documented related projects

       • Added badges to the documentation

   <b>0.3</b> <b>(2018-07-31)</b>
       • New <b>Table</b> class representing a table in the SQLite database

   <b>0.2</b> <b>(2018-07-28)</b>
       • Initial release to PyPI

</pre><h4><b>AUTHOR</b></h4><pre>
       Simon Willison

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2018-2024, Simon Willison

                                                  Nov 27, 2024                                   <u><a href="../man1/SQLITE-UTILS.1.html">SQLITE-UTILS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>