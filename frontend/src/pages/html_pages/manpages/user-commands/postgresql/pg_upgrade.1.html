<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pg_upgrade - upgrade a PostgreSQL server instance</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/postgresql-17">postgresql-17_17.5-0ubuntu0.25.04.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pg_upgrade - upgrade a PostgreSQL server instance

</pre><h4><b>SYNOPSIS</b></h4><pre>

       <b>pg_upgrade</b> <b>-b</b> <u>oldbindir</u> [<b>-B</b> <u>newbindir</u>] <b>-d</b> <u>oldconfigdir</u> <b>-D</b> <u>newconfigdir</u> [<u>option</u>...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       pg_upgrade (formerly called pg_migrator) allows data stored in PostgreSQL data files to be upgraded to a
       later PostgreSQL major version without the data dump/restore typically required for major version
       upgrades, e.g., from 12.14 to 13.10 or from 14.9 to 15.5. It is not required for minor version upgrades,
       e.g., from 12.7 to 12.8 or from 14.1 to 14.5.

       Major PostgreSQL releases regularly add new features that often change the layout of the system tables,
       but the internal data storage format rarely changes.  pg_upgrade uses this fact to perform rapid upgrades
       by creating new system tables and simply reusing the old user data files. If a future major release ever
       changes the data storage format in a way that makes the old data format unreadable, pg_upgrade will not
       be usable for such upgrades. (The community will attempt to avoid such situations.)

       pg_upgrade does its best to make sure the old and new clusters are binary-compatible, e.g., by checking
       for compatible compile-time settings, including 32/64-bit binaries. It is important that any external
       modules are also binary compatible, though this cannot be checked by pg_upgrade.

       pg_upgrade supports upgrades from 9.2.X and later to the current major release of PostgreSQL, including
       snapshot and beta releases.

</pre><h4><b>OPTIONS</b></h4><pre>
       pg_upgrade accepts the following command-line arguments:

       <b>-b</b> <u>bindir</u>
       <b>--old-bindir=</b><u>bindir</u>
           the old PostgreSQL executable directory; environment variable <b>PGBINOLD</b>

       <b>-B</b> <u>bindir</u>
       <b>--new-bindir=</b><u>bindir</u>
           the new PostgreSQL executable directory; default is the directory where pg_upgrade resides;
           environment variable <b>PGBINNEW</b>

       <b>-c</b>
       <b>--check</b>
           check clusters only, don't change any data

       <b>-d</b> <u>configdir</u>
       <b>--old-datadir=</b><u>configdir</u>
           the old database cluster configuration directory; environment variable <b>PGDATAOLD</b>

       <b>-D</b> <u>configdir</u>
       <b>--new-datadir=</b><u>configdir</u>
           the new database cluster configuration directory; environment variable <b>PGDATANEW</b>

       <b>-j</b> <u>njobs</u>
       <b>--jobs=</b><u>njobs</u>
           number of simultaneous processes or threads to use

       <b>-k</b>
       <b>--link</b>
           use hard links instead of copying files to the new cluster

       <b>-N</b>
       <b>--no-sync</b>
           By default, <b>pg_upgrade</b> will wait for all files of the upgraded cluster to be written safely to disk.
           This option causes <b>pg_upgrade</b> to return without waiting, which is faster, but means that a subsequent
           operating system crash can leave the data directory corrupt. Generally, this option is useful for
           testing but should not be used on a production installation.

       <b>-o</b> <u>options</u>
       <b>--old-options</b> <u>options</u>
           options to be passed directly to the old <b>postgres</b> command; multiple option invocations are appended

       <b>-O</b> <u>options</u>
       <b>--new-options</b> <u>options</u>
           options to be passed directly to the new <b>postgres</b> command; multiple option invocations are appended

       <b>-p</b> <u>port</u>
       <b>--old-port=</b><u>port</u>
           the old cluster port number; environment variable <b>PGPORTOLD</b>

       <b>-P</b> <u>port</u>
       <b>--new-port=</b><u>port</u>
           the new cluster port number; environment variable <b>PGPORTNEW</b>

       <b>-r</b>
       <b>--retain</b>
           retain SQL and log files even after successful completion

       <b>-s</b> <u>dir</u>
       <b>--socketdir=</b><u>dir</u>
           directory to use for postmaster sockets during upgrade; default is current working directory;
           environment variable <b>PGSOCKETDIR</b>

       <b>-U</b> <u>username</u>
       <b>--username=</b><u>username</u>
           cluster's install user name; environment variable <b>PGUSER</b>

       <b>-v</b>
       <b>--verbose</b>
           enable verbose internal logging

       <b>-V</b>
       <b>--version</b>
           display version information, then exit

       <b>--clone</b>
           Use efficient file cloning (also known as “reflinks” on some systems) instead of copying files to the
           new cluster. This can result in near-instantaneous copying of the data files, giving the speed
           advantages of <b>-k</b>/<b>--link</b> while leaving the old cluster untouched.

           File cloning is only supported on some operating systems and file systems. If it is selected but not
           supported, the pg_upgrade run will error. At present, it is supported on Linux (kernel 4.5 or later)
           with Btrfs and XFS (on file systems created with reflink support), and on macOS with APFS.

       <b>--copy</b>
           Copy files to the new cluster. This is the default. (See also <b>--link</b> and <b>--clone</b>.)

       <b>--copy-file-range</b>
           Use the <b>copy_file_range</b> system call for efficient copying. On some file systems this gives results
           similar to <b>--clone</b>, sharing physical disk blocks, while on others it may still copy blocks, but do so
           via an optimized path. At present, it is supported on Linux and FreeBSD.

       <b>--sync-method=</b><u>method</u>
           When set to fsync, which is the default, <b>pg_upgrade</b> will recursively open and synchronize all files
           in the upgraded cluster's data directory. The search for files will follow symbolic links for the WAL
           directory and each configured tablespace.

           On Linux, syncfs may be used instead to ask the operating system to synchronize the whole file
           systems that contain the upgraded cluster's data directory, its WAL files, and each tablespace. See
           recovery_init_sync_method for information about the caveats to be aware of when using syncfs.

           This option has no effect when <b>--no-sync</b> is used.

       <b>-?</b>
       <b>--help</b>
           show help, then exit

</pre><h4><b>USAGE</b></h4><pre>
       These are the steps to perform an upgrade with pg_upgrade:

        1. Optionally move the old cluster: If you are using a version-specific installation directory, e.g.,
           /opt/PostgreSQL/17, you do not need to move the old cluster. The graphical installers all use
           version-specific installation directories.

           If your installation directory is not version-specific, e.g., /usr/local/pgsql, it is necessary to
           move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL
           installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL
           installation directory; assuming the old directory is /usr/local/pgsql, you can do:

               mv /usr/local/pgsql /usr/local/pgsql.old

           to rename the directory.

        2. For source installs, build the new version: Build the new PostgreSQL source with <b>configure</b> flags that
           are compatible with the old cluster.  pg_upgrade will check <b>pg_controldata</b> to make sure all settings
           are compatible before starting the upgrade.

        3. Install the new PostgreSQL binaries: Install the new server's binaries and support files.  pg_upgrade
           is included in a default installation.

           For source installs, if you wish to install the new server in a custom location, use the prefix
           variable:

               make prefix=/usr/local/pgsql.new install

        4. Initialize the new PostgreSQL cluster: Initialize the new cluster using <b>initdb</b>. Again, use compatible
           <b>initdb</b> flags that match the old cluster. Many prebuilt installers do this step automatically. There
           is no need to start the new cluster.

        5. Install extension shared object files: Many extensions and custom modules, whether from contrib or
           another source, use shared object files (or DLLs), e.g., pgcrypto.so. If the old cluster used these,
           shared object files matching the new server binary must be installed in the new cluster, usually via
           operating system commands. Do not load the schema definitions, e.g., <b>CREATE</b> <b>EXTENSION</b> <b>pgcrypto</b>,
           because these will be duplicated from the old cluster. If extension updates are available, pg_upgrade
           will report this and create a script that can be run later to update them.

        6. Copy custom full-text search files: Copy any custom full text search files (dictionary, synonym,
           thesaurus, stop words) from the old to the new cluster.

        7. Adjust authentication: <b>pg_upgrade</b> will connect to the old and new servers several times, so you might
           want to set authentication to peer in pg_hba.conf or use a <a href="file:~/.pgpass">~/.pgpass</a> file (see Section 32.16).

        8. Prepare for publisher upgrades: pg_upgrade attempts to migrate logical slots. This helps avoid the
           need for manually defining the same logical slots on the new publisher. Migration of logical slots is
           only supported when the old cluster is version 17.0 or later. Logical slots on clusters before
           version 17.0 will silently be ignored.

           Before you start upgrading the publisher cluster, ensure that the subscription is temporarily
           disabled, by executing <b>ALTER</b> <b>SUBSCRIPTION</b> <b>...</b> <b>DISABLE</b>. Re-enable the subscription after the upgrade.

           There are some prerequisites for pg_upgrade to be able to upgrade the logical slots. If these are not
           met an error will be reported.

           •   The new cluster must have <u>wal_level</u> as logical.

           •   The new cluster must have <u>max_replication_slots</u> configured to a value greater than or equal to
               the number of slots present in the old cluster.

           •   The output plugins referenced by the slots on the old cluster must be installed in the new
               PostgreSQL executable directory.

           •   The old cluster has replicated all the transactions and logical decoding messages to subscribers.

           •   All slots on the old cluster must be usable, i.e., there are no slots whose
               pg_replication_slots.conflicting is not true.

           •   The new cluster must not have permanent logical slots, i.e., there must be no slots where
               pg_replication_slots.temporary is false.

        9. Prepare for subscriber upgrades: Setup the subscriber configurations in the new subscriber.
           pg_upgrade attempts to migrate subscription dependencies which includes the subscription's table
           information present in pg_subscription_rel system catalog and also the subscription's replication
           origin. This allows logical replication on the new subscriber to continue from where the old
           subscriber was up to. Migration of subscription dependencies is only supported when the old cluster
           is version 17.0 or later. Subscription dependencies on clusters before version 17.0 will silently be
           ignored.

           There are some prerequisites for pg_upgrade to be able to upgrade the subscriptions. If these are not
           met an error will be reported.

           •   All the subscription tables in the old subscriber should be in state i (initialize) or r (ready).
               This can be verified by checking pg_subscription_rel.srsubstate.

           •   The replication origin entry corresponding to each of the subscriptions should exist in the old
               cluster. This can be found by checking pg_subscription and pg_replication_origin system tables.

           •   The new cluster must have <u>max_replication_slots</u> configured to a value greater than or equal to
               the number of subscriptions present in the old cluster.

        10. Stop both servers: Make sure both database servers are stopped using, on Unix, e.g.:

               pg_ctl -D /opt/PostgreSQL/12 stop
               pg_ctl -D /opt/PostgreSQL/17 stop

           or on Windows, using the proper service names:

               NET STOP postgresql-12
               NET STOP postgresql-17

           Streaming replication and log-shipping standby servers must be running during this shutdown so they
           receive all changes.

        11. Prepare for standby server upgrades: If you are upgrading standby servers using methods outlined in
           section Step 13, verify that the old standby servers are caught up by running pg_controldata against
           the old primary and standby clusters. Verify that the “Latest checkpoint location” values match in
           all clusters. Also, make sure <u>wal_level</u> is not set to minimal in the postgresql.conf file on the new
           primary cluster.

        12. Run pg_upgrade: Always run the pg_upgrade binary of the new server, not the old one.  pg_upgrade
           requires the specification of the old and new cluster's data and executable (bin) directories. You
           can also specify user and port values, and whether you want the data files linked or cloned instead
           of the default copy behavior.

           If you use link mode, the upgrade will be much faster (no file copying) and use less disk space, but
           you will not be able to access your old cluster once you start the new cluster after the upgrade.
           Link mode also requires that the old and new cluster data directories be in the same file system.
           (Tablespaces and pg_wal can be on different file systems.) Clone mode provides the same speed and
           disk space advantages but does not cause the old cluster to be unusable once the new cluster is
           started. Clone mode also requires that the old and new data directories be in the same file system.
           This mode is only available on certain operating systems and file systems.

           The <b>--jobs</b> option allows multiple CPU cores to be used for copying/linking of files and to dump and
           restore database schemas in parallel; a good place to start is the maximum of the number of CPU cores
           and tablespaces. This option can dramatically reduce the time to upgrade a multi-database server
           running on a multiprocessor machine.

           For Windows users, you must be logged into an administrative account, and then run pg_upgrade with
           quoted directories, e.g.:

               pg_upgrade.exe
                       --old-datadir "C:/Program Files/PostgreSQL/12/data"
                       --new-datadir "C:/Program Files/PostgreSQL/17/data"
                       --old-bindir "C:/Program Files/PostgreSQL/12/bin"
                       --new-bindir "C:/Program Files/PostgreSQL/17/bin"

           Once started, <b>pg_upgrade</b> will verify the two clusters are compatible and then do the upgrade. You can
           use <b>pg_upgrade</b> <b>--check</b> to perform only the checks, even if the old server is still running.
           <b>pg_upgrade</b> <b>--check</b> will also outline any manual adjustments you will need to make after the upgrade.
           If you are going to be using link or clone mode, you should use the option <b>--link</b> or <b>--clone</b> with
           <b>--check</b> to enable mode-specific checks.  <b>pg_upgrade</b> requires write permission in the current
           directory.

           Obviously, no one should be accessing the clusters during the upgrade.  pg_upgrade defaults to
           running servers on port 50432 to avoid unintended client connections. You can use the same port
           number for both clusters when doing an upgrade because the old and new clusters will not be running
           at the same time. However, when checking an old running server, the old and new port numbers must be
           different.

           If an error occurs while restoring the database schema, <b>pg_upgrade</b> will exit and you will have to
           revert to the old cluster as outlined in Step 19 below. To try <b>pg_upgrade</b> again, you will need to
           modify the old cluster so the pg_upgrade schema restore succeeds. If the problem is a contrib module,
           you might need to uninstall the contrib module from the old cluster and install it in the new cluster
           after the upgrade, assuming the module is not being used to store user data.

        13. Upgrade streaming replication and log-shipping standby servers: If you used link mode and have
           Streaming Replication (see Section 26.2.5) or Log-Shipping (see Section 26.2) standby servers, you
           can follow these steps to quickly upgrade them. You will not be running pg_upgrade on the standby
           servers, but rather rsync on the primary. Do not start any servers yet.

           If you did <u>not</u> use link mode, do not have or do not want to use rsync, or want an easier solution,
           skip the instructions in this section and simply recreate the standby servers once pg_upgrade
           completes and the new primary is running.

            1. Install the new PostgreSQL binaries on standby servers: Make sure the new binaries and support
               files are installed on all standby servers.

            2. Make sure the new standby data directories do <u>not</u> exist: Make sure the new standby data
               directories do <u>not</u> exist or are empty. If initdb was run, delete the standby servers' new data
               directories.

            3. Install extension shared object files: Install the same extension shared object files on the new
               standbys that you installed in the new primary cluster.

            4. Stop standby servers: If the standby servers are still running, stop them now using the above
               instructions.

            5. Save configuration files: Save any configuration files from the old standbys' configuration
               directories you need to keep, e.g., postgresql.conf (and any files included by it),
               postgresql.auto.conf, pg_hba.conf, because these will be overwritten or removed in the next step.

            6. Run rsync: When using link mode, standby servers can be quickly upgraded using rsync. To
               accomplish this, from a directory on the primary server that is above the old and new database
               cluster directories, run this on the <u>primary</u> for each standby server:

                   rsync --archive --delete --hard-links --size-only --no-inc-recursive old_cluster new_cluster remote_dir

               where <b>old_cluster</b> and <b>new_cluster</b> are relative to the current directory on the primary, and
               <b>remote_dir</b> is <u>above</u> the old and new cluster directories on the standby. The directory structure
               under the specified directories on the primary and standbys must match. Consult the rsync manual
               page for details on specifying the remote directory, e.g.,

                   rsync --archive --delete --hard-links --size-only --no-inc-recursive /opt/PostgreSQL/12 \
                         /opt/PostgreSQL/17 standby.example.com:/opt/PostgreSQL

               You can verify what the command will do using rsync's <b>--dry-run</b> option. While rsync must be run
               on the primary for at least one standby, it is possible to run rsync on an upgraded standby to
               upgrade other standbys, as long as the upgraded standby has not been started.

               What this does is to record the links created by pg_upgrade's link mode that connect files in the
               old and new clusters on the primary server. It then finds matching files in the standby's old
               cluster and creates links for them in the standby's new cluster. Files that were not linked on
               the primary are copied from the primary to the standby. (They are usually small.) This provides
               rapid standby upgrades. Unfortunately, rsync needlessly copies files associated with temporary
               and unlogged tables because these files don't normally exist on standby servers.

               If you have tablespaces, you will need to run a similar rsync command for each tablespace
               directory, e.g.:

                   rsync --archive --delete --hard-links --size-only --no-inc-recursive /vol1/pg_tblsp/PG_12_201909212 \
                         /vol1/pg_tblsp/PG_17_202307071 standby.example.com:/vol1/pg_tblsp

               If you have relocated pg_wal outside the data directories, rsync must be run on those directories
               too.

            7. Configure streaming replication and log-shipping standby servers: Configure the servers for log
               shipping. (You do not need to run <b>pg_backup_start()</b> and <b>pg_backup_stop()</b> or take a file system
               backup as the standbys are still synchronized with the primary.) If the old primary is prior to
               version 17.0, then no slots on the primary are copied to the new standby, so all the slots on the
               old standby must be recreated manually. If the old primary is version 17.0 or later, then only
               logical slots on the primary are copied to the new standby, but other slots on the old standby
               are not copied, so must be recreated manually.

        14. Restore pg_hba.conf: If you modified pg_hba.conf, restore its original settings. It might also be
           necessary to adjust other configuration files in the new cluster to match the old cluster, e.g.,
           postgresql.conf (and any files included by it), postgresql.auto.conf.

        15. Start the new server: The new server can now be safely started, and then any rsync'ed standby
           servers.

        16. Post-upgrade processing: If any post-upgrade processing is required, pg_upgrade will issue warnings
           as it completes. It will also generate script files that must be run by the administrator. The script
           files will connect to each database that needs post-upgrade processing. Each script should be run
           using:

               psql --username=postgres --file=script.sql postgres

           The scripts can be run in any order and can be deleted once they have been run.

               <b>Caution</b>
               In general it is unsafe to access tables referenced in rebuild scripts until the rebuild scripts
               have run to completion; doing so could yield incorrect results or poor performance. Tables not
               referenced in rebuild scripts can be accessed immediately.

        17. Statistics: Because optimizer statistics are not transferred by <b>pg_upgrade</b>, you will be instructed
           to run a command to regenerate that information at the end of the upgrade. You might need to set
           connection parameters to match your new cluster.

           Using <b>vacuumdb</b> <b>--all</b> <b>--analyze-only</b> can efficiently generate such statistics, and the use of <b>--jobs</b>
           can speed it up. Option <b>--analyze-in-stages</b> can be used to generate minimal statistics quickly. If
           <u>vacuum_cost_delay</u> is set to a non-zero value, this can be overridden to speed up statistics
           generation using <b>PGOPTIONS</b>, e.g., PGOPTIONS='-c vacuum_cost_delay=0' vacuumdb ....

        18. Delete old cluster: Once you are satisfied with the upgrade, you can delete the old cluster's data
           directories by running the script mentioned when <b>pg_upgrade</b> completes. (Automatic deletion is not
           possible if you have user-defined tablespaces inside the old data directory.) You can also delete the
           old installation directories (e.g., bin, share).

        19. Reverting to old cluster: If, after running <b>pg_upgrade</b>, you wish to revert to the old cluster, there
           are several options:

           •   If the <b>--check</b> option was used, the old cluster was unmodified; it can be restarted.

           •   If the <b>--link</b> option was <u>not</u> used, the old cluster was unmodified; it can be restarted.

           •   If the <b>--link</b> option was used, the data files might be shared between the old and new cluster:

               •   If <b>pg_upgrade</b> aborted before linking started, the old cluster was unmodified; it can be
                   restarted.

               •   If you did <u>not</u> start the new cluster, the old cluster was unmodified except that, when
                   linking started, a .old suffix was appended to $PGDATA/global/pg_control. To reuse the old
                   cluster, remove the .old suffix from $PGDATA/global/pg_control; you can then restart the old
                   cluster.

               •   If you did start the new cluster, it has written to shared files and it is unsafe to use the
                   old cluster. The old cluster will need to be restored from backup in this case.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       Some environment variables can be used to provide defaults for command-line options:

       <b>PGBINOLD</b>
           The old PostgreSQL executable directory; option <b>-b</b>/<b>--old-bindir</b>.

       <b>PGBINNEW</b>
           The new PostgreSQL executable directory; option <b>-B</b>/<b>--new-bindir</b>.

       <b>PGDATAOLD</b>
           The old database cluster configuration directory; option <b>-d</b>/<b>--old-datadir</b>.

       <b>PGDATANEW</b>
           The new database cluster configuration directory; option <b>-D</b>/<b>--new-datadir</b>.

       <b>PGPORTOLD</b>
           The old cluster port number; option <b>-p</b>/<b>--old-port</b>.

       <b>PGPORTNEW</b>
           The new cluster port number; option <b>-P</b>/<b>--new-port</b>.

       <b>PGSOCKETDIR</b>
           Directory to use for postmaster sockets during upgrade; option <b>-s</b>/<b>--socketdir</b>.

       <b>PGUSER</b>
           Cluster's install user name; option <b>-U</b>/<b>--username</b>.

</pre><h4><b>NOTES</b></h4><pre>
       pg_upgrade creates various working files, such as schema dumps, stored within pg_upgrade_output.d in the
       directory of the new cluster. Each run creates a new subdirectory named with a timestamp formatted as per
       ISO 8601 (%Y%m%dT%H%M%S), where all its generated files are stored.  pg_upgrade_output.d and its
       contained files will be removed automatically if pg_upgrade completes successfully; but in the event of
       trouble, the files there may provide useful debugging information.

       pg_upgrade launches short-lived postmasters in the old and new data directories. Temporary Unix socket
       files for communication with these postmasters are, by default, made in the current working directory. In
       some situations the path name for the current directory might be too long to be a valid socket name. In
       that case you can use the <b>-s</b> option to put the socket files in some directory with a shorter path name.
       For security, be sure that that directory is not readable or writable by any other users. (This is not
       supported on Windows.)

       All failure, rebuild, and reindex cases will be reported by pg_upgrade if they affect your installation;
       post-upgrade scripts to rebuild tables and indexes will be generated automatically. If you are trying to
       automate the upgrade of many clusters, you should find that clusters with identical database schemas
       require the same post-upgrade steps for all cluster upgrades; this is because the post-upgrade steps are
       based on the database schemas, and not user data.

       For deployment testing, create a schema-only copy of the old cluster, insert dummy data, and upgrade
       that.

       pg_upgrade does not support upgrading of databases containing table columns using these reg*
       OID-referencing system data types:
           regcollation
           regconfig
           regdictionary
           regnamespace
           regoper
           regoperator
           regproc
           regprocedure
       (regclass, regrole, and regtype can be upgraded.)

       If you want to use link mode and you do not want your old cluster to be modified when the new cluster is
       started, consider using the clone mode. If that is not available, make a copy of the old cluster and
       upgrade that in link mode. To make a valid copy of the old cluster, use <b>rsync</b> to create a dirty copy of
       the old cluster while the server is running, then shut down the old server and run <b>rsync</b> <b>--checksum</b> again
       to update the copy with any changes to make it consistent. (<b>--checksum</b> is necessary because <b>rsync</b> only
       has file modification-time granularity of one second.) You might want to exclude some files, e.g.,
       postmaster.pid, as documented in Section 25.3.4. If your file system supports file system snapshots or
       copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though
       the snapshot and copies must be created simultaneously or while the database server is down.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/initdb.1.html">initdb</a></b>(1), <b><a href="../man1/pg_ctl.1.html">pg_ctl</a></b>(1), <b><a href="../man1/pg_dump.1.html">pg_dump</a></b>(1), <b><a href="../man1/postgres.1.html">postgres</a></b>(1)

PostgreSQL 17.5                                       2025                                         <u><a href="../man1/PG_UPGRADE.1.html">PG_UPGRADE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>