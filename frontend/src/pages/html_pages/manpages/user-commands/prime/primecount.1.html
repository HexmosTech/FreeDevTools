<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>primecount - count prime numbers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/primecount-bin">primecount-bin_7.14+ds-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       primecount - count prime numbers

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>primecount</b> <u>x</u> [<u>options</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Count the number of primes less than or equal to x (&lt;= 10^31) using fast implementations of the
       combinatorial prime counting function algorithms. By default primecount counts primes using Xavier
       Gourdon’s algorithm which has a runtime complexity of O(x^(2/3) / log^2 x) operations and uses O(x^(2/3)
       * log^3 x) memory. primecount is multi-threaded, it uses all available CPU cores by default.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-d,</b> <b>--deleglise-rivat</b>
           Count primes using the Deleglise-Rivat algorithm.

       <b>-g,</b> <b>--gourdon</b>
           Count primes using Xavier Gourdon’s algorithm (default algorithm).

       <b>-l,</b> <b>--legendre</b>
           Count primes using Legendre’s formula.

       <b>--lehmer</b>
           Count primes using Lehmer’s formula.

       <b>--lmo</b>
           Count primes using the Lagarias-Miller-Odlyzko algorithm.

       <b>-m,</b> <b>--meissel</b>
           Count primes using Meissel’s formula.

       <b>--Li</b>
           Approximate pi(x) using the Eulerian logarithmic integral: Li(x), with Li(x) = li(x) - <a href="../man2/li.2.html">li</a>(2).

       <b>--Li-inverse</b>
           Approximate the nth prime using the inverse Eulerian logarithmic integral: Li^-1(x).

       <b>-n,</b> <b>--nth-prime</b>
           Calculate the nth prime.

       <b>-p,</b> <b>--primesieve</b>
           Count primes using the sieve of Eratosthenes.

       <b>--phi</b> <u>X</u> <u>A</u>
           phi(x, a) counts the numbers &lt;= x that are not divisible by any of the first a primes.

       <b>-R,</b> <b>--RiemannR</b>
           Approximate pi(x) using the Riemann R function: R(x).

       <b>--RiemannR-inverse</b>
           Approximate the nth prime using the inverse Riemann R function: R^-1(x).

       <b>-s,</b> <b>--status</b>[=<u>NUM</u>]
           Show the computation progress e.g. 1%, 2%, 3%, ... Show <u>NUM</u> digits after the decimal point:
           <b>--status=1</b> prints 99.9%.

       <b>--test</b>
           Run various correctness tests and exit.

       <b>--time</b>
           Print the time elapsed in seconds.

       <b>-t,</b> <b>--threads</b>=<u>NUM</u>
           Set the number of threads, 1 &lt;= <u>NUM</u> &lt;= CPU cores. By default primecount uses all available CPU cores.

       <b>-v,</b> <b>--version</b>
           Print version and license information.

       <b>-h,</b> <b>--help</b>
           Print this help menu.

</pre><h4><b>ADVANCED</b> <b>OPTIONS</b> <b>FOR</b> <b>THE</b> <b>DELEGLISE-RIVAT</b> <b>ALGORITHM</b></h4><pre>
       <b>--P2</b>
           Compute the 2nd partial sieve function.

       <b>--S1</b>
           Compute the ordinary leaves.

       <b>--S2-trivial</b>
           Compute the trivial special leaves.

       <b>--S2-easy</b>
           Compute the easy special leaves.

       <b>--S2-hard</b>
           Compute the hard special leaves.

   <b>Tuning</b> <b>factor</b>
       The alpha tuning factor mainly balances the computation of the S2_easy and S2_hard formulas. By
       increasing alpha the runtime of the S2_hard formula will usually decrease but the runtime of the S2_easy
       formula will increase. For large pi(x) computations with x &gt;= 10^25 you can usually achieve a significant
       speedup by increasing alpha.

       The alpha tuning factor is also very useful for verifying pi(x) computations. You compute pi(x) twice but
       for the second computation you use a slightly different alpha factor. If the results of both pi(x)
       computations match then pi(x) has been verified successfully.

       <b>-a,</b> <b>--alpha</b>=<u>NUM</u>
           Set the alpha tuning factor: y = x^(1/3) * alpha, 1 &lt;= alpha &lt;= x^(1/6).

</pre><h4><b>ADVANCED</b> <b>OPTIONS</b> <b>FOR</b> <b>XAVIER</b> <b>GOURDON’S</b> <b>ALGORITHM</b></h4><pre>
       <b>--AC</b>
           Compute the A + C formulas.

       <b>--B</b>
           Compute the B formula.

       <b>--D</b>
           Compute the D formula.

       <b>--Phi0</b>
           Compute the Phi0 formula.

       <b>--Sigma</b>
           Compute the 7 Sigma formulas.

   <b>Tuning</b> <b>factors</b>
       The alpha_y and alpha_z tuning factors mainly balance the computation of the A, B, C and D formulas. When
       alpha_y is decreased but alpha_z is increased then the runtime of the B formula will increase but the
       runtime of the A, C and D formulas will decrease. For large pi(x) computations with x &gt;= 10^25 you can
       usually achieve a significant speedup by decreasing alpha_y and increasing alpha_z. For convenience when
       you increase alpha_z using <b>--alpha-z</b>=<u>NUM</u> then alpha_y is automatically decreased.

       Both the alpha_y and alpha_z tuning factors are also very useful for verifying pi(x) computations. You
       compute pi(x) twice but for the second computation you use a slightly different alpha_y or alpha_z
       factor. If the results of both pi(x) computations match then pi(x) has been verified successfully.

       <b>--alpha-y</b>=<u>NUM</u>
           Set the alpha_y tuning factor: y = x^(1/3) * alpha_y, 1 &lt;= alpha_y &lt;= x^(1/6).

       <b>--alpha-z</b>=<u>NUM</u>
           Set the alpha_z tuning factor: z = y * alpha_z, 1 &lt;= alpha_z &lt;= x^(1/6).

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>primecount</b> <b>1000</b>
           Count the primes &lt;= 1000.

       <b>primecount</b> <b>1e17</b> <b>--status</b>
           Count the primes &lt;= 10^17 and print status information.

       <b>primecount</b> <b>1e15</b> <b>--threads</b> <b>1</b> <b>--time</b>
           Count the primes &lt;= 10^15 using a single thread and print the time elapsed.

</pre><h4><b>HOMEPAGE</b></h4><pre>
       https://github.com/kimwalisch/primecount

</pre><h4><b>AUTHOR</b></h4><pre>
       Kim Walisch &lt;<a href="mailto:kim.walisch@gmail.com">kim.walisch@gmail.com</a>&gt;

                                                   09/02/2024                                      <u><a href="../man1/PRIMECOUNT.1.html">PRIMECOUNT</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>