<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>portserver.py - server to hand out unused port numbers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python3-portpicker">python3-portpicker_1.6.0-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       portserver.py - server to hand out unused port numbers

</pre><h4><b>DESCRIPTION</b></h4><pre>
       usage: portserver.py [-h] [--portserver_static_pool PORTSERVER_STATIC_POOL]

       [--portserver_address PORTSERVER_ADDRESS] [--verbose]
              [--debug]

   <b>options:</b>
       <b>-h</b>, <b>--help</b>
              show this help message and exit

       <b>--portserver_static_pool</b> PORTSERVER_STATIC_POOL
              Comma separated N-P Range(s) of ports to manage (inclusive).

       <b>--portserver_address</b> PORTSERVER_ADDRESS, <b>--portserver_unix_socket_address</b> PORTSERVER_ADDRESS
              Address of AF_UNIX socket on which to listen on Unix (first @ is a NUL) or the name of the pipe on
              Windows (first @ is the \\.\pipe\ prefix).

       <b>--verbose</b>
              Enable verbose messages.

       <b>--debug</b>
              Enable full debug messages.

</pre><h4><b>PORT</b> <b>SERVER</b></h4><pre>
       A  port  server  is  intended  to  be  run  as a daemon, for use by all processes running on the host. It
       coordinates uses of network ports by anything using a portpicker library. If you are using hosts as  part
       of  a  test  automation  cluster,  each  one  should  run  a  port server as a daemon. You should set the
       PORTSERVER_ADDRESS=@unittest-portserver environment  variable  on  all  of  your  test  runners  so  that
       portpicker makes use of it.

       A port server listens on a unix socket, reads a pid from a new connection, tests the ports it is managing
       and replies with a port assignment port for that pid. A port is only reclaimed for potential reassignment
       to another process after the process it was originally assigned to has died. Processes that need multiple
       ports can simply issue multiple requests and are guaranteed they will each be unique.

</pre><h4><b>TYPICAL</b> <b>USAGE</b></h4><pre>
        1) Run one instance of this process on each of your unittest farm hosts.
        2) Set the PORTSERVER_ADDRESS environment variable in your test runner
           environment to let the portpicker library know to use a port server
           rather than attempt to find ports on its own.

        $ /path/to/portserver.py &amp;
        $ export PORTSERVER_ADDRESS=@unittest-portserver
        $ # ... launch a bunch of unittest runners using portpicker ...

portserver.py 1.6.0                               October 2024                                  <u><a href="../man1/PORTSERVER.PY.1.html">PORTSERVER.PY</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>