<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jpnevulator - Just another serial sniffer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/jpnevulator">jpnevulator_2.3.6-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       jpnevulator - Just another serial sniffer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>jpnevulator</b> [<u>OPTION</u>]... &lt;<u>FILE</u>&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       jpnevulator  is  a handy serial sniffer. You can use it to send data on a serial device too. You can read
       or write from/to one or more serial devices at the same time.

       In write (--write) mode data to be sent on the serial device(s) is read from a  file  or  stdin  in  base
       (--base) defined notation. Data is sent on the serial device(s) line by line.

       In  read  (--read)  mode data to be read from the serial device(s) is written to a file or stdout in base
       (--base) defined notation. Skim through the options for several enhancements in  the  output.  It's  even
       possible to pass(--pass) on the data between the several serial devices.

       Mandatory arguments to long options are mandatory for short options too.

       Generic options:

       <b>-B</b>, <b>--base</b>=<u>BASE</u>
              Specify  the  base  unit  of  read/write  bytes.  Currently  only  2=binary and 16=hexadecimal are
              supported. The default base unit is hexadecimal.

              Selecting hexadecimal as the base unit, the input format is FD or 0xFD. Of  course  all  input  is
              treated  case-insensitive.  Spaces may or may not be included in the input. So DEADBEEF is exactly
              the same as DE AD   BE  EF.

              Selecting binary as the base unit, the input format is 01000010. Spaces may or may not be included
              in the input. So 01000010111 is exactely the  same  as  01000010  111.  Yes,  that's  right!  It's
              perfectly  fine to write less than 8 bits, excluding the leading zeros. Please understand if doing
              so, spaces are needed to separate the individual bytes in this case, but  that's  obvious.  If  no
              spaces  are used, the parses reads the first 8 bits before it continues with the next, as shown in
              the example above.

       <b>-l</b>, <b>--alias-separator</b>
              Use the given string as the alias separator. See --tty for more information.

       <b>-f</b>, <b>--file</b>=<u>NAME</u>
              In write mode read the contents of the file given and send them on the  serial  device(s)  and  in
              read mode write the contents of the serial device(s) to the file given.

       <b>-h</b>, <b>--help</b>
              Shows a brief list of options.

       <b>-o</b>, <b>--count</b>=<u>BYTES</u>
              Exit after reading / writing the given amount of bytes.

       <b>-r</b>, <b>--read</b>
              Put the program in read mode. This way you read the data from the given serial device(s) and write
              it to the file given or stdout if none given.  See the read options section for more read specific
              options.

       <b>-t</b>, <b>--tty</b>=<u>NAME:ALIAS</u>
              The serial device to read from or write to. Use multiple times to read/write from/to more than one
              serial  device(s).  For  handy  reference  you can also separate an alias from the tty name with a
              collon ':'. If a collon is for some strange reason part of your  device  name,  you  can  use  the
              --alias-separator  option  to  specify  another separation string. If an alias is given it will be
              used as the name of the serial device.

       <b>-v</b>, <b>--version</b>
              Output the version information, a small GPL notice and exit.

       <b>-w</b>, <b>--write</b>
              Put the program in write mode. This way you read data from a given file or stdin if none given and
              write it to the serial device(s) given. See the write options  section  for  more  write  specific
              options.

       Read options:

       <b>-a</b>, <b>--ascii</b>
              Besides  the  normal  output  of the data, also display an extra column with the data in the ASCII
              representation. Non printable characters are displayed as a dot '.'.  The ASCII data is  displayed
              after the normal data.

       <b>-b</b>, <b>--byte-count</b>
              Besides  the  normal output also display an extra column with the current index number of the byte
              in the output. These numbers are displayed in  front  of  the  normal  output.  When  readin  from
              multiple serial devices at the same time the index number will increase per serial device.

       <b>-C</b>, <b>--control</b>
              Monitor  modem  control  bits  (line  enable, data terminal ready, request to send, secondary TXD,
              secondary RXD, clear to send, carrier detect, ring and data set ready) too and notify changes. Use
              the --control-poll option to specify how often to poll for the bits.

       <b>-D</b>, <b>--control-poll</b>=<u>MICROSECONDS</u>
              The control poll is the amount of microseconds to wait in between two checks of the modem  control
              bits if nothing else is happening.

       <b>-P</b>, <b>--pass</b>
              This  one  passes  all  the  data between the serial devices. Handy if you want to put your serial
              sniffer in between the serial devices you want to sniff.

       <b>-q</b>, <b>--pty</b>=<u>:ALIAS</u>
              The pseudo-terminal device to read from. Use multiple times to read from  more  than  one  pseudo-
              terminal  device(s).  For  handy reference you can also use an alias to name the pty. Make sure it
              starts with a collon ':'. Use the --alias-separator option if you for some reason  don't  like  to
              use a collon.  If an alias is given it will be used as the name of the pseudo-terminal device.

       <b>-e</b>, <b>--timing-delta</b>=<u>MICROSECONDS</u>
              The  timing delta is the amount of microseconds between two bytes that the latter is considered to
              be part of a new package. The default is 100 milliseconds. Use this option in conjunction with the
              --timing-print option.

       <b>-g</b>, <b>--timing-print</b>
              Print a line of timing information before every continues stream of bytes.  When  multiple  serial
              devices are given also print the name or alias of the device where the data is coming from.

       <b>-i</b>, <b>--width</b>=<u>WIDTH</u>
              The number of bytes to display on one line. The default is 16.

       <b>-A</b>, <b>--append</b>
              Append to the output file instead of overwriting. The default is to overwrite.

       <b>-S</b>, <b>--append-separator</b>
              Use  the  given  string  as  the  append  separator. The string is processed and the '\n' sequence
              transforms into a real newline. So far no other sequences do anything special. The  default  is  a
              single newline character.

       Write options:

       <b>-c</b>, <b>--checksum</b>
              Append  a  single  checksum  byte to the line of data written to the serial device(s) chosen. This
              checksum is a simple modulo 256 addition of all input bytes on a line.

       <b>-z</b>, <b>--crc8</b>=<u>POLY</u>
              Append a crc8 checksum to the line of data written  to  the  serial  device(s)  chosen.   Use  the
              optionally  given  poly as the polynomial. Specify the polynomial as hexadecimal value, as in 0x07
              (the default).

       <b>-y</b>, <b>--crc16</b>=<u>POLY</u>
              Append a crc16 checksum to the line of data written to  the  serial  device(s)  chosen.   Use  the
              optionally given poly as the polynomial. Specify the polynomial as hexadecimal value, as in 0xA001
              (the default).

       <b>-k</b>, <b>--delay-byte</b>=<u>MICROSECONDS</u>
              This  delay  is  an optional amount of microseconds to wait in between every input byte is sent on
              the serial device(s).

       <b>-d</b>, <b>--delay-line</b>=<u>MICROSECONDS</u>
              This delay is an optional amount of microseconds to wait in between every input line  is  sent  on
              the serial device(s).

       <b>-j</b>, <b>--fuck-up</b>
              This is the special fuck up option. When the calculation of a checksum is chosen (see checksum and
              crc* options) the checksum will be crippled on purpose. Carefully named after the special Jan Arie
              de Bruin 'fuck up crc' button.

       <b>-n</b>, <b>--no-send</b>
              Do  not actually send the bytes on the serial device(s). Rather pointless, but seemed one day long
              ago to be a rather handy feature.

       <b>-p</b>, <b>--print</b>
              Besided sending the data on the serial device(s) also write the data to stdout.

       <b>-s</b>, <b>--size</b>=<u>SIZE</u>
              The maximum number of bytes per line to send on the serial device(s). The default  is  22,  coming
              from back in the Cham2 days of the program.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Normally,  exit  status is 0 if the program did run with no problem whatsoever. If the exit status is not
       equal to 0 an error message is printed on stderr which should help you solve the problem.

</pre><h4><b>BUGS</b></h4><pre>
       <b>Order</b> <b>of</b> <b>bytes</b> <b>broke</b> <b>when</b> <b>reading</b> <b>several</b> <b>tty</b> <b>devices</b> <b>at</b> <b>once</b>

       The display of incoming bytes can be broke if you use multiple tty devices to read from. At the moment  I
       do  not have a solution for this problem. Since I use select() to watch the several tty devices and after
       the select() I have to read() them one by one, I can not completely 100% display which bytes  came  after
       which on different tty devices. Take the example below:

              $ jpnevulator --ascii --timing-print --tty /dev/ttyS0 --tty /dev/ttyUSB0 --read
              2006-05-30 13:23:49.461075: /dev/ttyS0
              00 00 05 3B 0D 00 00 05                         ...;....
              2006-05-30 13:23:49.461113: /dev/ttyUSB0
              00 05 3B 0D 00 00 05 3B 0D                      ..;....;.
              2006-05-30 13:23:49.473074: /dev/ttyS0
              3B 0D 00 00 05 3B 0D                            ;....;.
              2006-05-30 13:23:49.473105: /dev/ttyUSB0
              00 12 05 06 39 00 12 05 06 39 1F 00 22 80 00 0E ....9....9.."...
              $

       And now see the order in which things really got sent on the line:

              /dev/ttyS0:
              00 00 05 3B 0D
              /dev/ttyUSB0:
              00 00 05 3B 0D
              /dev/ttyS0:
              00 00 05 3B 0D
              /dev/ttyUSB0:
              00 00 05 3B 0D
              /dev/ttyS0:
              00 00 05 3B 0D
              /dev/ttyUSB0:
              00 00 05 3B 0D 00 12 05 06 39 00 12 05 06 39 ...

       As  you  can  see  /dev/ttyUSB0 receives the echo of all things sent by /dev/ttyS0.  This is exactly what
       happens. But since there does exist a small time between the select() who is happy  expressing  something
       is available and the read() who does get the available data, some extra data will be available. I have no
       idea  on how I can use high level system call like select() and read() and be still able to put the bytes
       in the correct order. Anyone an idea?

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Freddy Spierenburg.

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<a href="mailto:freddy@snarl.nl">freddy@snarl.nl</a>&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2006-2020 Freddy Spierenburg

jpnevulator 2.3.6                                   July 2020                                     <u><a href="../man1/JPNEVULATOR.1.html">JPNEVULATOR</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>