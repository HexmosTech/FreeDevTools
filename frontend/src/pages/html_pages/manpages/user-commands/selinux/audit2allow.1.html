<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>audit2allow - generate SELinux policy allow/dontaudit rules from logs of denied operations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/policycoreutils-python-utils">policycoreutils-python-utils_3.7-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>audit2allow</b> - generate SELinux policy allow/dontaudit rules from logs of denied operations

       <b>audit2why</b>  -  translates  SELinux  audit  messages  into  a  description  of  why  the  access was denied
       (audit2allow -w)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>audit2allow</b> [<u>options</u>]

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-a</b> <b>|</b> <b>--all</b>
              Read input from audit and message log, conflicts with -i

       <b>-b</b> <b>|</b> <b>--boot</b>
              Read input from audit messages since last boot, conflicts with -i

       <b>-d</b> <b>|</b> <b>--dmesg</b>
              Read input from output of <u>/bin/dmesg.</u>  Note that all audit messages are not  available  via  dmesg
              when auditd is running; use "ausearch -m avc | audit2allow"  or "-a" instead.

       <b>-D</b> <b>|</b> <b>--dontaudit</b>
              Generate dontaudit rules (Default: allow)

       <b>-e</b> <b>|</b> <b>--explain</b>
              Fully explain generated output

       <b>-h</b> <b>|</b> <b>--help</b>
              Print a short usage message

       <b>-i</b>  <b>&lt;inputfile&gt;</b> <b>|</b> <b>--input</b> <b>&lt;inputfile&gt;</b>
              Read input from <u>&lt;inputfile&gt;</u>

       <b>--interface-info=&lt;interface_info_file&gt;</b>
              Read interface information from <u>&lt;interface_info_file&gt;</u>

       <b>-l</b> <b>|</b> <b>--lastreload</b>
              Read input only after last policy reload

       <b>-m</b> <b>&lt;modulename&gt;</b> <b>|</b> <b>--module</b> <b>&lt;modulename&gt;</b>
              Generate module/require output &lt;modulename&gt;

       <b>-M</b> <b>&lt;modulename&gt;</b>
              Generate loadable module package, conflicts with -o

       <b>-C</b>     Generate CIL output, conflicts with -M

       <b>-p</b> <b>&lt;policyfile&gt;</b> <b>|</b> <b>--policy</b> <b>&lt;policyfile&gt;</b>
              Policy file to use for analysis

       <b>--perm-map</b> <b>&lt;perm_map_file&gt;</b>
              Read permission map from <u>&lt;perm_map_file&gt;</u>

       <b>-o</b> <b>&lt;outputfile&gt;</b> <b>|</b> <b>--output</b> <b>&lt;outputfile&gt;</b>
              Append output to <u>&lt;outputfile&gt;</u>

       <b>-r</b> <b>|</b> <b>--requires</b>
              Generate require output syntax for loadable modules.

       <b>-N</b> <b>|</b> <b>--noreference</b>
              Do not generate reference policy, traditional style allow rules.  This is the default behavior.

       <b>-R</b> <b>|</b> <b>--reference</b>
              Generate  reference  policy  using  installed  macros.   This  attempts  to  match denials against
              interfaces and may be inaccurate.

       <b>-t</b> <b>&lt;type_regex&gt;</b> <b>|</b> <b>--type=&lt;type_regex&gt;</b>
              Only process messages with a type that matches this regex

       <b>-x</b> <b>|</b> <b>--xperms</b>
              Generate extended permission access vector rules

       <b>-w</b> <b>|</b> <b>--why</b>
              Translates SELinux audit messages into a description of why the access was denied

       <b>-v</b> <b>|</b> <b>--verbose</b>
              Turn on verbose output

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This utility scans the logs for messages logged when the system denied  permission  for  operations,  and
       generates  a snippet of policy rules which, if loaded into policy, might have allowed those operations to
       succeed. However, this utility only generates Type Enforcement  (TE)  allow  rules.   Certain  permission
       denials  may  require  other  kinds  of policy changes, e.g. adding an attribute to a type declaration to
       satisfy an existing constraint, adding a role allow rule, or modifying a  constraint.   The  <b><a href="../man8/audit2why.8.html">audit2why</a></b>(8)
       utility may be used to diagnose the reason when it is unclear.

       Care  must  be  exercised  while acting on the output of this utility to ensure that the operations being
       permitted do not pose a security threat. Often it is better to define new domains and/or types,  or  make
       other structural changes to narrowly allow an optimal set of operations to succeed, as opposed to blindly
       implementing  the  sometimes  broad changes recommended by this utility.   Certain permission denials are
       not fatal to the application, in which case it may be preferable to simply suppress logging of the denial
       via a 'dontaudit' rule rather than an 'allow' rule.

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>NOTE:</b> <b>These</b> <b>examples</b> <b>are</b> <b>for</b> <b>systems</b> <b>using</b> <b>the</b> <b>audit</b> <b>package.</b> <b>If</b> <b>you</b> <b>do</b>
       <b>not</b> <b>use</b> <b>the</b> <b>audit</b> <b>package,</b> <b>the</b> <b>AVC</b> <b>messages</b> <b>will</b> <b>be</b> <b>in</b> <b>/var/log/messages.</b>
       <b>Please</b> <b>substitute</b> <b>/var/log/messages</b> <b>for</b> <b>/var/log/audit/audit.log</b> <b>in</b> <b>the</b>
       <b>examples.</b>

       <b>Using</b> <b>audit2allow</b> <b>to</b> <b>generate</b> <b>module</b> <b>policy</b>

       $ cat /var/log/audit/audit.log | audit2allow -m local &gt; local.te
       $ cat local.te
       module local 1.0;

       require {
               class file {  getattr open read };

               type myapp_t;
               type etc_t;
        };

       allow myapp_t etc_t:file { getattr open read };
       &lt;review local.te and customize as desired&gt;

       <b>Using</b> <b>audit2allow</b> <b>to</b> <b>generate</b> <b>module</b> <b>policy</b> <b>using</b> <b>reference</b> <b>policy</b>

       $ cat /var/log/audit/audit.log | audit2allow -R -m local &gt; local.te
       $ cat local.te
       policy_module(local, 1.0)

       gen_require(`
               type myapp_t;
               type etc_t;
       ')

       <a href="../manmyapp_t/files_read_etc_files.myapp_t.html">files_read_etc_files</a>(myapp_t)
       &lt;review local.te and customize as desired&gt;

       <b>Building</b> <b>module</b> <b>policy</b> <b>using</b> <b>Makefile</b>

       # SELinux provides a policy devel environment under
       # /usr/share/selinux/devel including all of the shipped
       # interface files.
       # You can create a te file and compile it by executing

       $ make -f /usr/share/selinux/devel/Makefile local.pp

       # This make command will compile a local.te file in the current
       # directory. If you did not specify a "pp" file, the make file
       # will compile all "te" files in the current directory.  After
       # you compile your te file into a "pp" file, you need to install
       # it using the semodule command.

       $ semodule -i local.pp

       <b>Building</b> <b>module</b> <b>policy</b> <b>manually</b>

       # Compile the module
       $ checkmodule -M -m -o local.mod local.te

       # Create the package
       $ semodule_package -o local.pp -m local.mod

       # Load the module into the kernel
       $ semodule -i local.pp

       <b>Using</b> <b>audit2allow</b> <b>to</b> <b>generate</b> <b>and</b> <b>build</b> <b>module</b> <b>policy</b>

       $ cat /var/log/audit/audit.log | audit2allow -M local
       Generating type enforcement file: local.te

       Compiling policy: checkmodule -M -m -o local.mod local.te
       Building package: semodule_package -o local.pp -m local.mod

       ******************** IMPORTANT ***********************

       In order to load this newly created policy package into the kernel,
       you are required to execute

       semodule -i local.pp

       <b>Using</b> <b>audit2allow</b> <b>to</b> <b>generate</b> <b>monolithic</b> <b>(non-module)</b> <b>policy</b>

       $ cd <a href="file:/etc/selinux/">/etc/selinux/</a>$SELINUXTYPE/src/policy
       $ cat /var/log/audit/audit.log | audit2allow &gt;&gt; domains/misc/local.te
       $ cat domains/misc/local.te
       allow cupsd_config_t unconfined_t:fifo_file { getattr ioctl };
       &lt;review domains/misc/local.te and customize as desired&gt;
       $ make load

</pre><h4><b>AUTHOR</b></h4><pre>
       This manual page was written by <u>Manoj</u> <u>Srivastava</u> <u>&lt;<a href="mailto:srivasta@debian.org">srivasta@debian.org</a>&gt;,</u> for the Debian GNU/Linux  system.
       It was updated by Dan Walsh &lt;<a href="mailto:dwalsh@redhat.com">dwalsh@redhat.com</a>&gt;

       The  <b>audit2allow</b>  utility  has  contributions  from  several people, including <u>Justin</u> <u>R.</u> <u>Smith</u> and <u>Yuichi</u>
       <u>Nakamura.</u>  and <u>Dan</u> <u>Walsh</u>

Security Enhanced Linux                           October 2010                                    <u><a href="../man1/AUDIT2ALLOW.1.html">AUDIT2ALLOW</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>