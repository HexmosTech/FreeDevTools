<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>beet - music tagger and library organizer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/beets">beets_2.2.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       beet - music tagger and library organizer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>beet</b> [<u>args</u>…] <u>command</u> [<u>args</u>…]
       <b>beet</b> <b>help</b> <u>command</u>

</pre><h4><b>COMMANDS</b></h4><pre>
   <b>import</b>
          beet import [-CWAPRqst] [-l LOGPATH] PATH...
          beet import [options] -L QUERY

       Add music to your library, attempting to get correct tags for it from MusicBrainz.

       Point  the  command  at  some music: directories, single files, or compressed archives. The music will be
       copied to a configurable directory structure and added to a library database. The command is  interactive
       and  will try to get you to verify MusicBrainz tags that it thinks are suspect. See the <u>autotagging</u> <u>guide</u>
       for detail on how to use the interactive tag-correction flow.

       Directories passed to the import command can contain either a single album or many,  in  which  case  the
       leaf directories will be considered albums (the latter case is true of typical Artist/Album organizations
       and  many people’s “downloads” folders). The path can also be a single song or an archive. Beets supports
       <u>zip</u> and <u>tar</u> archives out of the box. To extract <u>rar</u> files, install the  <u>rarfile</u>  package  and  the  <u>unrar</u>
       command. To extract <u>7z</u> files, install the <u>py7zr</u> package.

       Optional command flags:

       • By  default, the command copies files to your library directory and updates the ID3 tags on your music.
         In order to move the files, instead of copying, use the <b>-m</b> (move) option. If you’d like to  leave  your
         music  files untouched, try the <b>-C</b> (don’t copy) and <b>-W</b> (don’t write tags) options. You can also disable
         this behavior by default in the configuration file (below).

       • Also, you can disable the autotagging behavior entirely using <b>-A</b> (don’t autotag)—then your  music  will
         be imported with its existing metadata.

       • During  a  long  tagging  import,  it  can  be  useful  to  keep  track  of  albums that weren’t tagged
         successfully—either because they’re not in the MusicBrainz database or because something’s  wrong  with
         the  files.  Use  the  <b>-l</b> option to specify a filename to log every time you skip an album or import it
         “as-is” or an album gets skipped as a duplicate. You can later  review  the  file  manually  or  import
         skipped paths from the logfile automatically by using the <b>--from-logfile</b> <b>LOGFILE</b> argument.

       • Relatedly,  the  <b>-q</b> (quiet) option can help with large imports by autotagging without ever bothering to
         ask for user input. Whenever the normal autotagger mode would ask  for  confirmation,  the  quiet  mode
         performs  a  fallback  action  that  can  be  configured  using  the  <b>quiet_fallback</b>  configuration  or
         <b>--quiet-fallback</b> CLI option.  By default it pessimistically <b>skip``s</b> <b>the</b> <b>file.</b>  <b>Alternatively,</b> <b>it</b> <b>can</b> <b>be</b>
         <b>used</b> <b>as</b> <b>is,</b> <b>by</b> <b>configuring</b> <b>``asis</b>.

       • Speaking of resuming interrupted imports, the tagger will prompt you if it seems like the  last  import
         of  the  directory was interrupted (by you or by a crash). If you want to skip this prompt, you can say
         “yes” automatically by providing <b>-p</b> or “no” using <b>-P</b>. The resuming feature can be disabled  by  default
         using a configuration option (see below).

       • If  you  want  to  import  only the <u>new</u> stuff from a directory, use the <b>-i</b> option to run an <u>incremental</u>
         import. With this flag, beets will keep track of every directory it ever imports  and  avoid  importing
         them  again.   This  is useful if you have an “incoming” directory that you periodically add things to.
         To get this to work correctly, you’ll need to use an incremental import <u>every</u> <u>time</u> you run an import on
         the directory in question—including the first time, when no subdirectories will be skipped. So consider
         enabling the <b>incremental</b> configuration option.

       • If  you  don’t   want   to   record   skipped   files   during   an   <u>incremental</u>   import,   use   the
         <b>--incremental-skip-later</b>  flag  which  corresponds  to the <b>incremental_skip_later</b> configuration option.
         Setting the flag prevents beets from persisting skip decisions during a non-interactive import so  that
         a  user  can  make a decision regarding previously skipped files during a subsequent interactive import
         run.  To record skipped files during incremental import explicitly, use the  <b>--noincremental-skip-later</b>
         option.

       • When  beets  applies metadata to your music, it will retain the value of any existing tags that weren’t
         overwritten, and import them into the database. You may  prefer  to  only  use  existing  metadata  for
         finding matches, and to erase it completely when new metadata is applied. You can enforce this behavior
         with the <b>--from-scratch</b> option, or the <b>from_scratch</b> configuration option.

       • By  default, beets will proceed without asking if it finds a very close metadata match. To disable this
         and have the importer ask you every time, use the <b>-t</b> (for <u>timid</u>) option.

       • The importer typically works in a whole-album-at-a-time mode. If you instead want to import individual,
         non-album tracks, use the <u>singleton</u> mode by supplying the <b>-s</b> option.

       • If you have an album that’s split across several directories under a  common  top  directory,  use  the
         <b>--flat</b>  option.  This  takes all the music files under the directory (recursively) and treats them as a
         single large album instead of as one album per  directory.  This  can  help  with  your  more  stubborn
         multi-disc albums.

       • Similarly,  if  you  have one directory that contains multiple albums, use the <b>--group-albums</b> option to
         split the files based on their metadata before matching them as separate albums.

       • If you want to preview which files would be imported, use the <b>--pretend</b> option. If set, beets will just
         print a list of files that it would otherwise import.

       • If you already have a metadata backend ID that matches the items to be imported, you can instruct beets
         to restrict the search to that ID instead of searching for other candidates by  using  the  <b>--search-id</b>
         <b>SEARCH_ID</b> option.  Multiple IDs can be specified by simply repeating the option several times.

       • You  can supply <b>--set</b> <b>field=value</b> to assign <u>field</u> to <u>value</u> on import.  Values support the same template
         syntax as beets’ <u>path</u>  <u>formats</u>.   These  assignments  will  merge  with  (and  possibly  override)  the
         <u>set_fields</u>  configuration  dictionary.  You can use the option multiple times on the command line, like
         so:

            beet import --set genre="Alternative Rock" --set mood="emotional"

   <b>list</b>
          beet list [-apf] QUERY

       <u>Queries</u> the database for music.

       Want to search for “Gronlandic Edit” by of Montreal? Try <b>beet</b> <b>list</b> <b>gronlandic</b>.  Maybe  you  want  to  see
       everything released in 2009 with “vegetables” in the title? Try <b>beet</b> <b>list</b> <b>year:2009</b> <b>title:vegetables</b>. You
       can also specify the sort order. (Read more in <u>Queries</u>.)

       You  can  use  the <b>-a</b> switch to search for albums instead of individual items.  In this case, the queries
       you use are restricted to album-level fields: for example, you can search for <b>year:1969</b> but  query  parts
       for  item-level  fields  like  <b>title:foo</b>  will  be  ignored. Remember that <b>artist</b> is an item-level field;
       <b>albumartist</b> is the corresponding album field.

       The <b>-p</b> option makes beets print out filenames of matched items, which might be  useful  for  piping  into
       other  Unix  commands  (such  as <u>xargs</u>). Similarly, the <b>-f</b> option lets you specify a specific format with
       which to print every album or track. This uses the same template  syntax  as  beets’  <u>path</u>  <u>formats</u>.  For
       example,  the  command  <b>beet</b> <b>ls</b> <b>-af</b> <b>'$album:</b> <b>$albumtotal'</b> <b>beatles</b> prints out the number of tracks on each
       Beatles album. In Unix shells, remember to enclose the  template  argument  in  single  quotes  to  avoid
       environment variable expansion.

   <b>remove</b>
          beet remove [-adf] QUERY

       Remove music from your library.

       This  command  uses  the same <u>query</u> syntax as the <b>list</b> command.  By default, it just removes entries from
       the library database; it doesn’t touch the files on disk. To actually delete the files, use the <b>-d</b>  flag.
       When the <b>-a</b> flag is given, the command operates on albums instead of individual tracks.

       When  you run the <b>remove</b> command, it prints a list of all affected items in the library and asks for your
       permission before removing them. You can then choose to abort (type <u>n</u>),  confirm  (<u>y</u>),  or  interactively
       choose  some of the items (<u>s</u>). In the latter case, the command will prompt you for every matching item or
       album and invite you to type <u>y</u> to remove the item/album, <u>n</u> to keep it or <u>q</u> to exit and  only  remove  the
       items/albums  selected  up  to  this point.  This option lets you choose precisely which tracks/albums to
       remove without spending too much time to carefully craft a query.  If you do not want to be  prompted  at
       all, use the <b>-f</b> option.

   <b>modify</b>
          beet modify [-IMWay] [-f FORMAT] QUERY [FIELD=VALUE...] [FIELD!...]

       Change the metadata for items or albums in the database.

       Supply  a  <u>query</u>  matching  the things you want to change and a series of <b>field=value</b> pairs. For example,
       <b>beet</b> <b>modify</b> <b>genius</b> <b>of</b> <b>love</b> <b>artist="Tom</b> <b>Tom</b> <b>Club"</b> will change the artist for the track “Genius  of  Love.”
       To  remove  fields  (which  is  only  possible  for  flexible  attributes),  follow  a field name with an
       exclamation point: <b>field!</b>.

       Values can also be <u>templates</u>,  using  the  same  syntax  as  <u>path</u>  <u>formats</u>.   For  example,  <b>beet</b>  <b>modify</b>
       <b>artist='$artist_sort'</b>  will copy the artist sort name into the artist field for all your tracks, and <b>beet</b>
       <b>modify</b> <b>title='$track</b> <b>$title'</b> will add track numbers to their title metadata.

       The <b>-a</b> option changes to querying album fields instead of track fields and also  enables  to  operate  on
       albums in addition to the individual tracks.  Without this flag, the command will only change <u>track-level</u>
       data,  even  if all the tracks belong to the same album. If you want to change an <u>album-level</u> field, such
       as <b>year</b> or <b>albumartist</b>, you’ll want to use the <b>-a</b> flag to avoid a confusing situation where the data  for
       individual tracks conflicts with the data for the whole album.

       Modifications  issued  using  <b>-a</b>  by  default cascade to individual tracks. To prevent this behavior, use
       <b>-I</b>/<b>--noinherit</b>.

       Items will automatically be moved around when necessary if they’re in your library directory, but you can
       disable that with  <b>-M</b>. Tags will be written to the files according to the settings you have for  imports,
       but these can be overridden with <b>-w</b> (write tags, the default) and <b>-W</b> (don’t write tags).

       When  you run the <b>modify</b> command, it prints a list of all affected items in the library and asks for your
       permission before making any changes. You can then choose to abort the change (type <u>n</u>), confirm  (<u>y</u>),  or
       interactively  choose  some  of  the items (<u>s</u>). In the latter case, the command will prompt you for every
       matching item or album and invite you to type <u>y</u> to apply the changes, <u>n</u> to discard them or <u>q</u> to exit  and
       apply  the  selected changes. This option lets you choose precisely which data to change without spending
       too much time to carefully craft a query. To skip the prompts entirely, use the <b>-y</b> option.

   <b>move</b>
          beet move [-capt] [-d DIR] QUERY

       Move or copy items in your library.

       This command, by default, acts as a library consolidator: items matching the query are renamed into  your
       library  directory  structure. By specifying a destination directory with <b>-d</b> manually, you can move items
       matching a query anywhere in your filesystem. The <b>-c</b> option copies files instead of moving them. As  with
       other  commands,  the <b>-a</b> option matches albums instead of items.  The <b>-e</b> flag (for “export”) copies files
       without changing the database.

       To perform a “dry run”, just use the <b>-p</b> (for “pretend”) flag. This will show you a  list  of  files  that
       would  be  moved but won’t actually change anything on disk. The <b>-t</b> option sets the timid mode which will
       ask again before really moving or copying the files.

   <b>update</b>
          beet update [-F] FIELD [-e] EXCLUDE_FIELD [-aM] QUERY

       Update the library (and, by default, move  files)  to  reflect  out-of-band  metadata  changes  and  file
       deletions.

       This will scan all the matched files and read their tags, populating the database with the new values. By
       default,  files  will  be  renamed according to their new metadata; disable this with <b>-M</b>. Beets will skip
       files if their modification times have not changed, so any out-of-band metadata changes must also  update
       these for <b>beet</b> <b>update</b> to recognise that the files have been edited.

       To  perform  a  “dry run” of an update, just use the <b>-p</b> (for “pretend”) flag.  This will show you all the
       proposed changes but won’t actually change anything on disk.

       By default, all the changed metadata will be populated back to the database.  If you  only  want  certain
       fields to be written, specify them with the <b>`-F`</b> flags (which can be used multiple times). Alternatively,
       specify fields to <u>not</u> write with <b>`-e`</b> flags (which can be used multiple times). For the list of supported
       fields, please see <b>`beet</b> <b>fields`</b>.

       When  an  updated track is part of an album, the album-level fields of <u>all</u> tracks from the album are also
       updated. (Specifically, the command copies album-level data from the first track on the album and applies
       it to the rest of the tracks.) This means that, if album-level fields aren’t identical within  an  album,
       some  changes  shown by the <b>update</b> command may be overridden by data from other tracks on the same album.
       This means that running the <b>update</b> command multiple times may show the same changes being applied.

   <b>write</b>
          beet write [-pf] [QUERY]

       Write metadata from the database into files’ tags.

       When you make changes to the metadata stored in beets’ library database (during import or with the <u>modify</u>
       command, for example), you often have the option of storing changes only in the  database,  leaving  your
       files untouched. The <b>write</b> command lets you later change your mind and write the contents of the database
       into  the  files.  By default, this writes the changes only if there is a difference between the database
       and the tags in the file.

       You can think of this command as the opposite of <u>update</u>.

       The <b>-p</b> option previews metadata changes without actually applying them.

       The <b>-f</b> option forces a write to the file, even if the file tags match the database. This  is  useful  for
       making  sure  that  enabled  plugins  that run on write (e.g., the Scrub and Zero plugins) are run on the
       file.

   <b>stats</b>
          beet stats [-e] [QUERY]

       Show some statistics on your entire library (if you don’t provide a <u>query</u>) or the matched items  (if  you
       do).

       By  default,  the command calculates file sizes using their bitrate and duration. The <b>-e</b> (<b>--exact</b>) option
       reads the exact sizes of each file (but is slower). The exact mode also outputs  the  exact  duration  in
       seconds.

   <b>fields</b>
          beet fields

       Show  the  item  and  album  metadata  fields  available for use in <u>Queries</u> and <u>Path</u> <u>Formats</u>. The listing
       includes any template fields provided by plugins and any flexible attributes you’ve manually assigned  to
       your items and albums.

   <b>config</b>
          beet config [-pdc]
          beet config -e

       Show or edit the user configuration. This command does one of three things:

       • With  no  options,  print  a  YAML representation of the current user configuration. With the <b>--default</b>
         option, beets’ default options are also included in the dump.

       • The <b>--path</b> option instead shows the path to your configuration file.  This can  be  combined  with  the
         <b>--default</b> flag to show where beets keeps its internal defaults.

       • By default, sensitive information like passwords is removed when dumping the configuration. The <b>--clear</b>
         option includes this sensitive data.

       • With the <b>--edit</b> option, beets attempts to open your config file for editing. It first tries the <b>$EDITOR</b>
         environment  variable,  followed by <b>$EDITOR</b> and then a fallback option depending on your platform: <b>open</b>
         on OS X, <b>xdg-open</b> on Unix, and direct invocation on Windows.

</pre><h4><b>GLOBAL</b> <b>FLAGS</b></h4><pre>
       Beets has a few “global” flags that affect all commands. These must appear between  the  executable  name
       (<b>beet</b>) and the command—for example, <b>beet</b> <b>-v</b> <b>import</b> <b>...</b>.

       • <b>-l</b> <b>LIBPATH</b>: specify the library database file to use.

       • <b>-d</b> <b>DIRECTORY</b>: specify the library root directory.

       • <b>-v</b>:  verbose  mode;  prints  out a deluge of debugging information. Please use this flag when reporting
         bugs. You can use it twice, as in <b>-vv</b>, to make beets even more verbose.

       • <b>-c</b> <b>FILE</b>: read a specified YAML <u>configuration</u> <u>file</u>. This configuration works as an overlay: rather  than
         replacing your normal configuration options entirely, the two are merged. Any individual options set in
         this config file will override the corresponding settings in your base configuration.

       • <b>-p</b>  <b>plugins</b>: specify a comma-separated list of plugins to enable. If specified, the plugin list in your
         configuration is ignored. The long form of this argument also allows specifying no plugins, effectively
         disabling all plugins: <b>--plugins=</b>.

       • <b>-P</b> <b>plugins</b>: specify a comma-separated list of plugins to disable in a specific  beets  run.  This  will
         overwrite <b>-p</b> if used with it. To disable all plugins, use <b>--plugins=</b> instead.

       Beets also uses the <b>BEETSDIR</b> environment variable to look for configuration and data.

</pre><h4><b>SHELL</b> <b>COMPLETION</b></h4><pre>
       Beets  includes  support  for shell command completion. The command <b>beet</b> <b>completion</b> prints out a <u>bash</u> 3.2
       script; to enable completion put a line like this into your <b>.bashrc</b> or similar file:

          eval "$(beet completion)"

       Or, to avoid slowing down your shell startup time, you can pipe the <b>beet</b> <b>completion</b> output to a file  and
       source that instead.

       You  will  also  need  to source the <u>bash-completion</u> script, which is probably available via your package
       manager. On OS X, you can install it via Homebrew with <b>brew</b> <b>install</b> <b>bash-completion</b>; Homebrew  will  give
       you instructions for sourcing the script.

       The completion script suggests names of subcommands and (after typing <b>-</b>) options of the given command. If
       you are using a command that accepts a query, the script will also complete field names.

          beet list ar[TAB]
          # artist:  artist_credit:  artist_sort:  artpath:
          beet list artp[TAB]
          beet list artpath\:

       (Don’t  worry about the slash in front of the colon: this is a escape sequence for the shell and won’t be
       seen by beets.)

       Completion of plugin commands  only  works  for  those  plugins  that  were  enabled  when  running  <b>beet</b>
       <b>completion</b>. If you add a plugin later on you will want to re-generate the script.

   <b>zsh</b>
       If you use zsh, take a look at the included <u>completion</u> <u>script</u>. The script should be placed in a directory
       that  is  part of your <b>fpath</b>, and <u>not</u> sourced in your <b>.zshrc</b>. Running <b>echo</b> <b>$fpath</b> will give you a list of
       valid directories.

       Another approach is to use zsh’s bash completion compatibility. This snippet defines  some  bash-specific
       functions to make this work without errors:

          autoload bashcompinit
          bashcompinit
          _get_comp_words_by_ref() { :; }
          compopt() { :; }
          _filedir() { :; }
          eval "$(beet completion)"

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>https://beets.readthedocs.org/</b>

       <b><a href="../man5/beetsconfig.5.html">beetsconfig</a>(5)</b>

</pre><h4><b>AUTHOR</b></h4><pre>
       Adrian Sampson

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2016, Adrian Sampson

2.1                                               Apr 04, 2025                                           <u><a href="../man1/BEET.1.html">BEET</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>