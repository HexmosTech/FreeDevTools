<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>states - awk alike text processing tool</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/enscript">enscript_1.6.5.90-3.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       states - awk alike text processing tool

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>states</b> [<b>-hvV</b>] [<b>-D</b> <u>var</u><b>=</b><u>val</u>] [<b>-f</b> <u>file</u>] [<b>-o</b> <u>outputfile</u>] [<b>-p</b> <u>path</u>] [<b>-s</b> <u>startstate</u>] [<b>-W</b> <u>level</u>] [<u>filename</u> ...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>States</b>  is  an  awk-alike  text  processing  tool with some state machine extensions.  It is designed for
       program source code highlighting and to similar tasks where state information helps input processing.

       At a single point of time, <b>States</b> is in one state, each quite similar to  awk's  work  environment,  they
       have  regular expressions which are matched from the input and actions which are executed when a match is
       found.  From the action blocks, <b>states</b> can perform state transitions; it can move to another  state  from
       which  the  processing  is continued.  State transitions are recorded so <b>states</b> can return to the calling
       state once the current state has finished.

       The biggest difference between <b>states</b> and awk, besides state machine extensions, is that  <b>states</b>  is  not
       line-oriented.   It  matches  regular  expression tokens from the input and once a match is processed, it
       continues processing from the current position, not from the beginning of the next input line.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-D</b> <u>var</u><b>=</b><u>val</u><b>,</b> <b>--define=</b><u>var</u><b>=</b><u>val</u>
               Define variable <u>var</u> to have string  value  <u>val</u>.   Command  line  definitions  overwrite  variable
               definitions found from the config file.

       <b>-f</b> <u>file</u><b>,</b> <b>--file=</b><u>file</u>
               Read state definitions from file <u>file</u>.  As a default, <b>states</b> tries to read state definitions from
               file <b>states.st</b> in the current working directory.

       <b>-h,</b> <b>--help</b>
               Print short help message and exit.

       <b>-o</b> <u>file</u><b>,</b> <b>--output=</b><u>file</u>
               Save output to file <u>file</u> instead of printing it to <b>stdout</b>.

       <b>-p</b> <u>path</u><b>,</b> <b>--path=</b><u>path</u>
               Set  the  load  path  to  <u>path</u>.   The  load  path defaults to the directory, from which the state
               definitions file is loaded.

       <b>-s</b> <u>state</u><b>,</b> <b>--state=</b><u>state</u>
               Start execution from state <b>state</b>.  This definition overwrites start state resolved from the <b>start</b>
               block.

       <b>-v,</b> <b>--verbose</b>
               Increase the program verbosity.

       <b>-V,</b> <b>--version</b>
               Print <b>states</b> version and exit.

       <b>-W</b> <u>level</u><b>,</b> <b>--warning=</b><u>level</u>
               Set the warning level to <u>level</u>.  Possible values for <u>level</u> are:

               <b>light</b>   light warnings (default)

               <b>all</b>     all warnings

</pre><h4><b>STATES</b> <b>PROGRAM</b> <b>FILES</b></h4><pre>
       <b>States</b> program files can contain on <u>start</u> block, <u>startrules</u> and <u>namerules</u> blocks to specify  the  initial
       state, <u>state</u> definitions and <u>expressions</u>.

       The <u>start</u> block is the main() of the <b>states</b> program, it is executed on script startup for each input file
       and  it  can  perform any initialization the script needs.  It normally also calls the <b>check_startrules()</b>
       and <b>check_namerules()</b> primitives which resolve the initial state from the input file  name  or  the  data
       found from the beginning of the input file.  Here is a sample start block which initializes two variables
       and does the standard start state resolving:

              start
              {
                a = 1;
                msg = "Hello, world!";
                check_startrules ();
                check_namerules ();
              }

       Once the start block is processed, the input processing is continued from the initial state.

       The  initial  state  is resolved by the information found from the <u>startrules</u> and <u>namerules</u> blocks.  Both
       blocks contain regular expression - symbol pairs, when the regular expression is matched from the name of
       from the beginning of the input file, the initial state  is  named  by  the  corresponding  symbol.   For
       example, the following start and name rules can distinguish C and Fortran files:

              namerules
              {
                /\.(c|h)$/    c;
                /\.[fF]$/     fortran;
              }

              startrules
              {
                /-\*- [cC] -\*-/      c;
                /-\*- fortran -\*-/   fortran;
              }

       If  these rules are used with the previously shown start block, <b>states</b> first check the beginning of input
       file.  If it has string <b>-*-</b> <b>c</b> <b>-*-</b>, the file is assumed to contain C code and the  processing  is  started
       from state called <b>c</b>.  If the beginning of the input file has string <b>-*-</b> <b>fortran</b> <b>-*-</b>, the initial state is
       <b>fortran</b>.   If  none of the start rules matched, the name of the input file is matched with the namerules.
       If the name ends to suffix <b>c</b> or <b>C</b>, we go to state <b>c</b>.  If the suffix is <b>f</b>  or  <b>F</b>,  the  initial  state  is
       fortran.

       If  both  start  and name rules failed to resolve the start state, <b>states</b> just copies its input to output
       unmodified.

       The start state can also be specified from the command line with option <b>-s</b>, <b>--state</b>.

       State definitions have the following syntax:

       <b>state</b> <b>{</b> <u>expr</u> {<u>statements</u>} ... }

       where <u>expr</u> is: a regular expression, special expression or symbol and <u>statements</u> is a list of statements.
       When the expression <u>expr</u> is matched from the input, the statement block is executed.  The statement block
       can call <b>states</b>' primitives, user-defined subroutines,  call  other  states,  etc.   Once  the  block  is
       executed,  the  input  processing  is  continued  from the current intput position (which might have been
       changed if the statement block called other states).

       Special expressions <b>BEGIN</b> and <b>END</b> can be used in  the  place  of  <u>expr</u>.   Expression  <b>BEGIN</b>  matches  the
       beginning of the state, its block is called when the state is entered.  Expression <b>END</b> matches the end of
       the state, its block is executed when <b>states</b> leaves the state.

       If  <u>expr</u>  is  a  symbol,  its  value  is  looked  up  from  the global environment and if it is a regular
       expression, it is matched to the input, otherwise that rule is ignored.

       The <b>states</b> program file can also have top-level expressions, they are evaluated after the program file is
       parsed but before any input files are processed or the <u>start</u> block is evaluated.

</pre><h4><b>PRIMITIVE</b> <b>FUNCTIONS</b></h4><pre>
       <b>call</b> <b>(</b><u>symbol</u><b>)</b>
               Move to state <u>symbol</u> and continue input  file  processing  from  that  state.   Function  returns
               whatever the <b>symbol</b> state's terminating <b>return</b> statement returned.

       <b>calln</b> <b>(</b><u>name</u><b>)</b>
               Like  <b>call</b>  but  the  argument <u>name</u> is evaluated and its value must be string.  For example, this
               function can be used to call a state which name is stored to a variable.

       <b>check_namerules</b> <b>()</b>
               Try to resolve start state from <b>namerules</b> rules.  Function returns <b>1</b> if start state was  resolved
               or <b>0</b> otherwise.

       <b>check_startrules</b> <b>()</b>
               Try to resolve start state from <b>startrules</b> rules.  Function returns <b>1</b> if start state was resolved
               or <b>0</b> otherwise.

       <b>concat</b> <b>(</b><u>str</u><b>,</b> <b>...)</b>
               Concanate argument strings and return result as a new string.

       <b>float</b> <b>(</b><u>any</u><b>)</b>
               Convert argument to a floating point number.

       <b>getenv</b> <b>(</b><u>str</u><b>)</b>
               Get value of environment variable <u>str</u>.  Returns an empty string if variable <u>var</u> is undefined.

       <b>int</b> <b>(</b><u>any</u><b>)</b>
               Convert argument to an integer number.

       <b>length</b> <b>(</b><u>item</u><b>,</b> <b>...)</b>
               Count the length of argument strings or lists.

       <b>list</b> <b>(</b><u>any</u><b>,</b> <b>...)</b>
               Create a new list which contains items <u>any</u>, ...

       <b>panic</b> <b>(</b><u>any</u><b>,</b> <b>...)</b>
               Report a non-recoverable error and exit with status <b>1</b>.  Function never returns.

       <b>print</b> <b>(</b><u>any</u><b>,</b> <b>...)</b>
               Convert arguments to strings and print them to the output.

       <b>range</b> <b>(</b><u>source</u><b>,</b> <u>start</u><b>,</b> <u>end</u><b>)</b>
               Return  a  sub-range  of  <u>source</u> starting from position <u>start</u> (inclusively) to <u>end</u> (exclusively).
               Argument <u>source</u> can be string or list.

       <b>regexp</b> <b>(</b><u>string</u><b>)</b>
               Convert string <u>string</u> to a new regular expression.

       <b>regexp_syntax</b> <b>(</b><u>char</u><b>,</b> <u>syntax</u><b>)</b>
               Modify regular expression character syntaxes by assigning new syntax <u>syntax</u> for  character  <u>char</u>.
               Possible values for <u>syntax</u> are:

               <b>'w'</b>     character is a word constituent

               <b>'</b> <b>'</b>     character isn't a word constituent

       <b>regmatch</b> <b>(</b><u>string</u><b>,</b> <u>regexp</u><b>)</b>
               Check  if  string  <u>string</u> matches regular expression <u>regexp</u>.  Functions returns a boolean success
               status and sets sub-expression registers <b>$</b><u>n</u>.

       <b>regsub</b> <b>(</b><u>string</u>, <u>regexp</u><b>,</b> <u>subst</u><b>)</b>
               Search regular expression <u>regexp</u> from string <u>string</u>  and  replace  the  matching  substring  with
               string  <u>subst</u>.   Returns  the  resulting  string.   The  substitution string <u>subst</u> can contain <b>$</b><u>n</u>
               references to the <u>n</u>:th parenthesized sup-expression.

       <b>regsuball</b> <b>(</b><u>string</u>, <u>regexp</u><b>,</b> <u>subst</u><b>)</b>
               Like <b>regsub</b> but replace all matches of regular expression <u>regexp</u> from string <u>string</u>  with  string
               <u>subst</u>.

       <b>require_state</b> <b>(</b><u>symbol</u><b>)</b>
               Check  that  the state <u>symbol</u> is defined.  If the required state is undefined, the function tries
               to autoload it.  If the loading fails, the program will terminate with an error message.

       <b>split</b> <b>(</b><u>regexp</u><b>,</b> <u>string</u><b>)</b>
               Split string <u>string</u> to list considering matches of regular rexpression <u>regexp</u> as item separator.

       <b>sprintf</b> <b>(</b><u>fmt</u>, ...)
               Format arguments according to <u>fmt</u> and return result as a string.

       <b>strcmp</b> <b>(</b><u>str1</u><b>,</b> <u>str2</u><b>)</b>
               Perform a case-sensitive comparision for strings <u>str1</u> and <u>str2</u>.  Function returns  a  value  that
               is:

               <b>-1</b>      string <u>str1</u> is less than <u>str2</u>

               <b>0</b>       strings are equal

               <b>1</b>       string <u>str1</u> is greater than <u>str2</u>

       <b>string</b> <b>(</b><u>any</u><b>)</b>
               Convert argument to string.

       <b>strncmp</b> <b>(</b><u>str1</u><b>,</b> <u>str2</u><b>,</b> <u>num</u><b>)</b>
               Perform  a  case-sensitive  comparision  for  strings  <u>str1</u>  and  <u>str2</u>  comparing  at maximum <u>num</u>
               <b>characters.</b>

       <b>substring</b> <b>(</b><u>str</u><b>,</b> <u>start</u><b>,</b> <u>end</u><b>)</b>
               Return a substring of string <u>str</u> starting from position <u>start</u> (inclusively) to <u>end</u> (exclusively).

</pre><h4><b>BUILTIN</b> <b>VARIABLES</b></h4><pre>
       <b>$.</b>      current input line number

       <b>$</b><u>n</u>      the <u>n</u>:th parenthesized regular expression sub-expression from the latest state regular expression
               or from the <b>regmatch</b> primitive

       <b>$`</b>      everything before the matched regular rexpression.  This is usable when used  with  the  <b>regmatch</b>
               primitive;  the  contents  of  this variable is undefined when used in action blocks to refer the
               data before the block's regular expression.

       <b>$B</b>      an alias for <b>$`</b>

       <b>argv</b>    list of input file names

       <b>filename</b>
               name of the current input file

       <b>program</b> name of the program (usually <b>states</b>)

       <b>version</b> program version string

</pre><h4><b>FILES</b></h4><pre>
       /usr/share/enscript/hl/*.st             enscript's states definitions

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/awk.1.html">awk</a>(1), <a href="../man1/enscript.1.html">enscript</a>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       Markku Rossi &lt;<a href="mailto:mtr@iki.fi">mtr@iki.fi</a>&gt; &lt;<a href="http://www.iki.fi/~mtr/">http://www.iki.fi/~mtr/</a>&gt;

       GNU Enscript WWW home page: &lt;<a href="http://www.iki.fi/~mtr/genscript/">http://www.iki.fi/~mtr/genscript/</a>&gt;

STATES                                            Oct 23, 1998                                         <u><a href="../man1/STATES.1.html">STATES</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>