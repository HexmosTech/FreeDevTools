<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wipe - securely erase files from magnetic media</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/wipe">wipe_0.24-10_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wipe - securely erase files from magnetic media

</pre><h4><b>SYNOPSIS</b></h4><pre>
       wipe [options] path1 path2 ... pathn

</pre><h4><b>CURRENT-VERSION</b></h4><pre>
       This manual page describes version <b>0.22</b> of <b>wipe</b> , released November 2010.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Recovery  of  supposedly  erased  data  from magnetic media is easier than what many people would like to
       believe. A technique called Magnetic Force Microscopy (MFM) allows  any  moderately  funded  opponent  to
       recover the last two or three layers of data written to disk; <b>wipe</b> repeatedly overwrites special patterns
       to  the  files  to  be  destroyed,  using the fsync() call and/or the O_SYNC bit to force disk access. In
       normal mode, 34 patterns are used (of which 8 are random). These patterns were recommended in an  article
       from Peter Gutmann (<a href="mailto:pgut001@cs.auckland.ac.nz">pgut001@cs.auckland.ac.nz</a>) entitled "Secure Deletion of Data from Magnetic and Solid-
       State  Memory". The normal mode takes 35 passes (0-34). A quick mode allows you to use only 4 passes with
       random patterns, which is of course much less secure.

</pre><h4><b>NOTE</b> <b>ABOUT</b> <b>JOURNALING</b> <b>FILESYSTEMS</b> <b>AND</b> <b>SOME</b> <b>RECOMMENDATIONS</b> <b>(JUNE</b> <b>2004)</b></h4><pre>
       Journaling filesystems (such as  Ext3  or  ReiserFS)  are  now  being  used  by  default  by  most  Linux
       distributions.   No  secure  deletion program that does filesystem-level calls can sanitize files on such
       filesystems, because sensitive data and metadata can be written to the journal, which cannot  be  readily
       accessed.  Per-file secure deletion is better implemented in the operating system.

       Encrypting a whole partition with cryptoloop, for example, does not help very much either, since there is
       a single key for all the partition.

       Therefore  <b>wipe</b>  is  best used to sanitize a harddisk before giving it to untrusted parties (i.e. sending
       your laptop for repair, or selling your disk).  Wiping size issues have been hopefully fixed (I apologize
       for the long delay).

       Be aware that harddisks are quite intelligent beasts those  days.   They  transparently  remap  defective
       blocks.   This  means  that  the  disk can keep an albeit corrupted (maybe slightly) but inaccessible and
       unerasable copy of some of your data.  Modern disks are said to have  about  100%  transparent  remapping
       capacity.  You can have a look at recent discussions on Slashdot.

       I  hereby speculate that harddisks can use the spare remapping area to secretly make copies of your data.
       Rising totalitarianism makes this almost a certitude.  It is  quite  straightforward  to  implement  some
       simple  filtering  schemes that would copy potentially interesting data.  Better, a harddisk can probably
       detect that a given file is being wiped, and silently make a copy of it, while  wiping  the  original  as
       instructed.

       Recovering  such  data is probably easily done with secret IDE/SCSI commands.  My guess is that there are
       agreements between harddisk manufacturers and government agencies.  Well-funded mafia hackers should then
       be able to find those secret commands too.

       Don't trust your harddisk.  Encrypt all your data.

       Of course this shifts the trust to the computing system, the CPU, and so on.   I  guess  there  are  also
       "traps"  in the CPU and, in fact, in every sufficiently advanced mass-marketed chip.  Wealthy nations can
       find those.  Therefore these are mainly used for criminal investigation and "control of public dissent".

       People should better think of their computing devices as facilities lended by the DHS.

</pre><h4><b>IMPORTANT</b> <b>WARNING</b> <b>--</b> <b>READ</b> <b>CAREFULLY</b></h4><pre>
       The author, the maintainers or the contributors of this package can NOT be held responsible in any way if
       <b>wipe</b> destroys something you didn't want it to destroy.  Let's make this very clear. I want you to  assume
       that  this  is a nasty program that will wipe out parts of your files that you didn't want it to wipe. So
       whatever happens after you launch <b>wipe</b> is your entire responsibility.  In particular, no  one  guarantees
       that <b>wipe</b> will conform to the specifications given in this manual page.

       Similarly,  we cannot guarantee that <b>wipe</b> will actually erase data, or that wiped data is not recoverable
       by advanced means.  So if nasties get your secrets because you sold a wiped harddisk to someone you don't
       know, well, too bad for you.

       The best way to sanitize a storage medium is to subject it to temperatures exceeding 1500K.  As  a  cheap
       alternative,  you  might  use <b>wipe</b> at your own risk. Be aware that it is very difficult to assess whether
       running <b>wipe</b> on a given file will actually wipe it -- it depends on an awful lot of factors,  such  as  :
       the  type  of file system the file resides on (in particular, whether the file system is a journaling one
       or not), the type of storage medium used, and the least significant bit of the phase of the moon.

       Wiping over NFS or over a journalling filesystem (ReiserFS etc.) will most probably not work.

       Therefore I strongly recommend to  call  <b>wipe</b>  directly  on  the  corresponding  block  device  with  the
       appropriate  options.  However <u>THIS</u> <u>IS</u> <u>AN</u> <u>EXTREMELY</u> <u>DANGEROUS</u> <u>THING</u> <u>TO</u> <u>DO.</u>  Be sure to be sober. Give the
       right options. In particular : don't wipe a whole harddisk (eg. wipe -kD /dev/hda is bad) since this will
       destroy your master boot record. Bad idea. Prefer wiping partitions (eg. wipe  -kD  /dev/hda2)  is  good,
       provided, of course, that you have backed up all necessary data.

</pre><h4><b>COMMAND-LINE</b> <b>OPTIONS</b></h4><pre>
       <b>-f</b> <b>(force;</b> <b>disable</b> <b>confirmation</b> <b>query)</b>
            By  default  <b>wipe</b>  will ask for confirmation, indicating the number of regular and special files and
            directories specified on the command line. You must type "yes" for confirmation, "no" for rejection.
            You can disable the confirmation query with the <b>-f</b> (force) option.

       <b>-r</b> <b>(recurse</b> <b>into</b> <b>subdirectories)</b>
            Will allow the removal of the entire directory tree. Symbolic links are not followed.

       <b>-c</b> <b>(chmod</b> <b>if</b> <b>necessary)</b>
            If a file or directory to be wiped has no write  permissions  set,  will  do  a  chmod  to  set  the
            permission.

       <b>-i</b> <b>(informational,</b> <b>verbose</b> <b>mode)</b>
            This enables reporting to stdout. By default all data is written to stderr.

       <b>-s</b> <b>(silent</b> <b>mode)</b>
            All messages, except the confirmation prompt and error messages, are suppressed.

       <b>-q</b> <b>(quick</b> <b>wipe)</b>
            If this option is used, <b>wipe</b> will only make (by default) 4 passes on each file, writing random data.
            See option <b>-Q</b>

       <b>-Q</b> <b>&lt;number-of-passes&gt;</b>
            Sets the number of passes for quick wiping. Default is 4. This option requires -q.

       <b>-a</b> <b>(abort</b> <b>on</b> <b>error)</b>
            The program will exit with EXIT_FAILURE if a non-fatal error is encountered.

       <b>-R</b> <b>(set</b> <b>random</b> <b>device</b> <b>OR</b> <b>random</b> <b>seed</b> <b>command)</b>

            With  this  option  which requires an argument you can specify an alternate /dev/random device, or a
            command who's standard output will be hashed using MD5-hashed. The distinction can be made using the
            -S option.

       <b>-S</b> <b>(random</b> <b>seed</b> <b>method)</b>

            This option takes a single-character argument, which specifies how  the  random  device/random  seed
            argument is to be used. The default random device is /dev/random. It can be set using the -R option.

       The possible single-character arguments are:
       <b>r</b>    If  you  want  the  argument to be treated like a regular file/character device. This will work with
            /dev/random, and might also work with FIFOs and the like.
       <b>c</b>    If you want the argument to be executed as a command. The output from the  command  will  be  hashed
            using MD5 to provide the required seed. See the WIPE_SEEDPIPE environment variable for more info.
       <b>p</b>    If  you  want  wipe to get its seed by hashing environment variables, the current date and time, its
            process id. etc. (the random device argument will not be used). This is of course the  least  secure
            setting.

       <b>-M</b> <b>(select</b> <b>pseudo-random</b> <b>number</b> <b>generator</b> <b>algorithm)</b>

       During  the  random passes, <b>wipe</b> overwrites the target files with a stream of binary data, created by the
       following choice of algorithms:
       <b>l</b>    will use (depending on your system) your libc's random() or rand() pseudorandom generator. Note that
            on most systems, rand() is a linear congruential generator, which is awfully  weak.  The  choice  is
            made at compile-time with the HAVE_RANDOM define (see the Makefile).
       <b>a</b>    will  use  the Arcfour stream cipher as a PRNG. Arcfour happens to be compatible with the well-known
            RC4 cipher. This means that under the same key, Arcfour generates exactly the same stream as RC4...
       <b>r</b>    will use the fresh RC6 algorithm as a PRNG; RC6 is keyed with the 128-bit  seed,  and  then  a  null
            block is repeatedly encrypted to get the pseudo-random stream.  I guess this should be quite secure.
            Of course RC6 with 20 rounds is slower than random(); the compile-time option WEAK_RC6 allows you to
            use a 4-round version of RC6, which is faster. In order to be able to use RC6, wipe must be compiled
            with ENABLE_RC6 defined; see the Makefile for warnings about patent issues.

            In  all  cases  the  PRNG  is  seeded  with  the data gathered from the random device (see -R and -S
            options).

       <b>-l</b> <b>&lt;length&gt;</b>
            As there can be some problems in determining the actual size of a block device (as some  devices  do
            not even have fixed sizes, such as floppy disks or tapes), you might need to specify the size of the
            device by hand; &lt;length&gt; is the device capacity expressed as a number of bytes. You can use <b>K</b> (Kilo)
            to  specify  multiplication  by  1024,  <b>M</b>  (Mega)  to specify multiplication by 1048576, <b>G</b> (Giga) to
            specify multiplication by 1073741824 and <b>b</b> (block) to specify multiplication by 512. Thus
            1024 = 2b = 1K

                                20K33 = 20480+33 = 20513

                                114M32K = 114*1024*1024+32*1024.

       <b>-o</b> <b>&lt;offset&gt;</b>
            This allows you to specify an offset inside the file or device to be wiped. The syntax  of  &lt;offset&gt;
            is the same as for the <b>-l</b> option.

       <b>-e</b>   Use exact file size: do not round up file size to wipe possible remaining junk on the last block.

       <b>-Z</b>   Don't  try  to wipe file sizes by repeatedly halving the file size. Note that this is only attempted
            on regular files so there is no use if you use <b>wipe</b> for cleaning a block or special device.

       <b>-X</b> <b>&lt;number&gt;</b>
            Skip a given number of passes.  This is useful to continue wiping from a given point when  you  have
            been wiping, say, a large disk and had to interrupt the operation.  Used with -x.

       <b>-x</b> <b>&lt;pass1&gt;,...,&lt;pass35&gt;</b>
            Specify  the pass order.  When <b>wipe</b> is interrupted, it will print the current randomly selected pass
            order permutation and the pass number as appropriate -x and -X arguments.

       <b>-F</b>   Don't try to wipe file names. Normally, <b>wipe</b> tries to cover file names by renaming them;  this  does
            NOT  guarantee  that the physical location holding the old file name gets overwritten.  Furthermore,
            after renaming a file, the only way to make sure that the name change is physically carried  out  is
            to  call sync (), which flushes out ALL the disk caches of the system, whereas for ading and writing
            one can use the O_SYNC bit to get synchronous I/O for one file. As sync ()  is  very  slow,  calling
            sync () after every rename () makes filename wiping extremely slow.

       <b>-k</b>   Keep  files:  do not unlink the files after they have been overwritten. Useful if you want to wipe a
            device, while keeping the device special file. This implies <b>-F.</b>

       <b>-D</b>   Dereference symlinks: by default, wipe will never follow symlinks. If you specify -D  however,  wipe
            will  consent  to,  well,  wipe  the targets of any symlinks you might happen to name on the command
            line.  You can't specify both -D and -r (recursive) options, first because of possible cycles in the
            symlink-enhanced directory graph, I'd have to keep track of visited files to guarantee  termination,
            which,  you'll  easily  admit,  is a pain in C, and, second, for fear of having a (surprise!!) block
            device buried somewhere unexpected.

       <b>-v</b>   Show version information and quit.

       <b>-h</b>   Display help.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>wipe</b> <b>-rcf</b> <b>/home/berke/plaintext/</b>
            Wipe every file and every directory  (option  -r)  listed  under  /home/berke/plaintext/,  including
            /home/berke/plaintext/.

            Regular  files  will  be wiped with 34 passes and their sizes will then be halved a random number of
            times. Special files (character and block  devices,  FIFOs...)   will  not.  All  directory  entries
            (files,  special  files  and  directories)  will  be renamed 10 times and then unlinked. Things with
            inappropriate permissions will be chmod()'ed (option -c).  All of  this  will  happen  without  user
            confirmation (option -f).

       <b>wipe</b> <b>-kq</b> <b>/dev/hda3</b>
            Assuming  /dev/hda3  is the block device corresponding to the third partition of the master drive on
            the primary IDE interface, it will be wiped in quick mode (option -q) i.e. with four random  passes.
            The  inode  won't  be  renamed  or  unlinked  (option  -k). Before starting, it will ask you to type
            ``yes''.

       <b>wipe</b> <b>-kqD</b> <b>/dev/floppy</b>
            Since <b>wipe</b> never follows symlinks unless explicitly told to do so, if you want to  wipe  /dev/floppy
            which  happens  to  be  a  symlink  to  /dev/fd0u1440 you will have to specify the -D option. Before
            starting, it will ask you to type ``yes''.

       <b>wipe</b> <b>-rfi</b> <b>&gt;wipe.log</b> <b><a href="file:/var/log/">/var/log/</a>*</b>
            Here, wipe will recursively (option -r) destroy everything under <a href="file:/var/log">/var/log</a>,  excepting  /var/log.  It
            will not attempt to chmod() things. It will however be verbose (option -i). It won't ask you to type
            ``yes'' because of the -f option.

       <b>wipe</b> <b>-kq</b> <b>-l</b> <b>1440K</b> <b>/dev/fd0</b>
            Due  to various idiosyncracies of the operating system, it's not always easy to obtain the number of
            bytes a given device might contain (in fact, that  quantity  can  be  variable).  This  is  why  you
            sometimes  need to tell <b>wipe</b> the amount of bytes to destroy. That's what the -l option is for. Plus,
            you can use b,K,M and G as multipliers, respectively for 2^9 (512), 2^10 (1024 or a Kilo),  2^20  (a
            Mega)  and  2^30  (a Giga) bytes.  You can even combine more than one multiplier !! So that 1M416K =
            1474560 bytes.

</pre><h4><b>BUGS/LIMITATIONS</b></h4><pre>
       <b>Wipe</b> should work on harddisks and floppy disks; however  the  internal  cache  of  some  harddisks  might
       prevent  the  necessary  writes to be done to the magnetic surface. It would be funny to use it over NFS.
       Under CFS (Cryptographic File System) the fsync() call has no effect; wipe has  not  much  use  under  it
       anyway  -  use wipe directly on the corresponding encrypted files. Also, under Linux, when using a device
       mounted thru a loopback device, synchronous I/O does not get propagated cleanly.

       For wiping floppy disks, at least under Linux, there is no way, besides  obscure  floppy-driver  specific
       ioctl's  to  determine the block size of the disk. In particular, the BLKGETSIZE ioctl is not implemented
       in the floppy driver. So, for wiping floppies, you must specify the size of the floppy disk using the  -l
       option,  as  in  the last example. This option is normally not needed for other fixed block devices, like
       IDE and SCSI devices.

       File name wiping is implemented since version 0.12. I don't know how efficient it is.  It  first  changes
       the  name of the file to a random- generated name of same length, calls sync (), then changes the name to
       a random-generated name of maximal length.

       File size wiping is implemented by repeatedly truncating the file to half of its size, until  it  becomes
       empty; sync () is called between such operations.

       Note  that  it  is  still not possible to file creation date and permission bits portably. A wipe utility
       working at the block device level could be written using the ext2fs library.

</pre><h4><b>AUTHOR</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       <b>Wipe</b> was written by Berke Durak (to find my email address, just type <b>echo</b> <b>berke1ouvaton2org|tr</b> <b>12</b> <b>@.</b>   in
       a shell).

       <b>Wipe</b> is released under the conditions of the GNU General Public License.

</pre><h4><b>FILES</b></h4><pre>
       <b>/dev/random</b> is used by default to seed the pseudo-random number generators.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       <b>WIPE_SEEDPIPE</b>  If  set,  <b>wipe</b> will execute the command specified in it (using popen()), and will hash the
       command's output with the MD5 message-digest algorithm to get a 128-bit seed for its PRNG.  For  example,
       on  systems  lacking  a  /dev/random device, this variable might be set in <a href="file:/etc/profile">/etc/profile</a> to a shell script
       which contains various commands such as ls, ps, who, last, etc. and which are run asynchronously in order
       to get an output as less predictable as possible.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man2/open.2.html">open</a>(2), <a href="../man2/fsync.2.html">fsync</a>(2), <a href="../man8/sync.8.html">sync</a>(8), <a href="../man2/bdflush.2.html">bdflush</a>(2), <a href="../man8/update.8.html">update</a>(8), <a href="../man3/random.3.html">random</a>(3)

Linux                                     Sun Nov  7 09:41:23 EST 2010                                   <u><a href="../man1/WIPE.1.html">WIPE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>