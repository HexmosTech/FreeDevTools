<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bosh - Browsable Output SHell</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/bosh">bosh_0.6-12_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>bosh</b> <b>-</b> <b>Browsable</b> <b>Output</b> <b>SHell</b>

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>bosh</b> <u>[OPTIONS]</u> <u>[CONFIGURATION]</u> <u>[CONFIGURATION</u> <u>OPTIONS]</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>bosh</b>  takes  the  output  of a program or script and provides a curses interface to browse that output. A
       particular line of that output can be selected and actions can be defined and executed and  make  use  of
       the that selected line.

</pre><h4><b>USAGE</b></h4><pre>
       CONFIGURATION is the name of a bosh configuration file (see below), in which case that is loaded.

       If CONFIGURATION is absent, and bosh is invoked on the end of a pipe, it will read from stdin.

       Bosh now supports passing arguments to the CONFIGURATION. The arguments will be available in the standard
       way ($1...$9,$*,$@,etc).

       Bosh can be invoked as above, or as "interpreter", meaning it can invoked from a shebang (#!) line at the
       top  of  a  script.  This  script  would just be a bosh configuration file. See <b>bops</b> as an example, which
       should have come with <b>bosh.</b>

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-h</b> <b>/</b> <b>--help</b>
              show help and exit

       <b>-v</b> <b>/</b> <b>--version</b>
              show version and exit

       <b>--autorefresh=</b><u>N</u>
              Automatically re-run command every N seconds.

       <b>--cursorsize=</b><u>N</u>
              Set the cursor to N lines high.

       <b>--cursormovement=</b><u>N</u>
              Set how much the cursor moves one an up/down keypress.

       <b>--header=</b><u>[N]</u>
              Prevent the cursor from entering the first N rows of the output.

       <b>--multilineseperator=</b><u>STRING</u>
              When an action is invoked and the cursor is multi-line, the lines selected  will  be  concatenated
              together.   With  this  setting  a  separating  string can be specified to be inserted between the
              lines.

       <b>--preaction=</b><u>COMMANDS</u>
              A command or commands that will be run on the invocation of all actions, before the action is run.
              This allows code that is a common for the actions to be only defined once. Preactions  are  simply
              prefixed  onto  the  action  when  the  action  is  invoked. This means you will need to include a
              separating character (eg ;) at the end of preaction.

       <b>--refresh=</b><u>[0,1]</u>
              A value of 1 means that bosh will re-run the command after an action is performed.

       <b>--uservars=</b><u>N</u>
              Set the number of user variables ( of the form <b>$BOSHVARx</b>  )  available.  See  the  <b>USER</b>  <b>VARIABLES</b>
              section below.

</pre><h4><b>CONFIGURATION</b> <b>FILES</b></h4><pre>
       Bosh configs are fairly simple. Firstly you need a line which tells bosh the actual program to execute to
       show it it's buffer -

              <b>command=ps</b> <b>x</b>

       It could also be a chain of commands (bash) -

              <b>command=for</b> <b>i</b> <b>in</b> <b>*;</b> <b>do</b> <b>echo</b> <b>$i;</b> <b>done</b>

       Or it can spread it over multiple lines for readability with a \ (must be at the end of line!) -

              <b>command=for</b> <b>i</b> <b>in</b> <b>*</b> <b>\</b>

              <b>do</b> <b>\</b>

              <b>echo</b> <b>$i</b> <b>\</b>

              <b>done</b>

       Or now even better, bosh supports blocks delimited by {{ and }} -
              <b>command{{</b>

              <b>for</b> <b>i</b> <b>in</b> <b>*</b>

              <b>do</b>

              <b>echo</b> <b>$i</b>

              <b>done</b>

              <b>}}</b>

       These can be used with all options and actions.

       Command line arguments given to bosh after the COMMAND parameter are available and can be used as follows
       -

              <b>command=ps</b> <b>$*</b>

       This would allow the user to specify the format of ps when invoking bosh.

       Commands  can  also  set <b>BOSHERR.</b>  When execution of the command finishes, bosh will exit and display the
       value of <b>BOSHERR</b> if it has been set.

              <b>command=if</b> <b>[</b> <b>-z</b> <b>"$1"</b> <b>]</b> <b>\</b>

              <b>then</b> <b>\</b>

                       BOSHERR="usage: $BOSHCONF [SECTION] NAME" \

                       return 1 \

              <b>fi</b> <b>\</b>

              <b>man</b> <b>$*</b>

       This will mean bosh exits immediately if no arguments are passed on the command line.  Note  the  use  of
       <b>return</b> rather than <b>exit.</b>

       After  the command option, you can specify any of the options specified above in the <b>OPTIONS</b> section, but
       without the -- prefix -

              <b>header=4</b>

              <b>refresh=1</b>

</pre><h4><b>ACTIONS</b></h4><pre>
       Basic actions are defined as -

              <b>KEY=command</b>

       eg:

              <b>k=kill</b> <b>$(echo</b> <b>$BOSH</b> <b>|</b> <b>cut</b> <b>-f1</b> <b>-d'</b> <b>')</b>

              <b>9=kill</b> <b>-9</b> <b>$(echo</b> <b>$BOSH</b> <b>|</b> <b>cut</b> <b>-f1</b> <b>-d'</b> <b>')</b>

       Or, using the preaction setting (see above) -

              <b>preaction=PID=$(echo</b> <b>$BOSH</b> <b>|</b> <b>cut</b> <b>-f1</b> <b>-d'</b> <b>');</b>

              <b>k=kill</b> <b>$PID</b>

              <b>9=kill</b> <b>-9</b> <b>$PID</b>

       The keys available are a-z,0-9 and enter. Bosh keys are not case sensitive, so A= is the same as a=.

       <b>$BOSH</b> is an environment variable containing the currently selected line(s) in bosh. It is  set  when  the
       action key is invoked. This is how information is passed to the actions. In the example above, the PID is
       extracted  from  the  currently selected line of the ps output using cut, which can then be passed to the
       kill command.

   <b>ACTIONS</b> <b>WITH</b> <b>OUTPUT</b>
       For basic actions such as kill, which has no output  to  stdout,  the  above  definition  is  sufficient.
       However,  bosh  can  now  intercept  the  output  of actions and place that in the bosh window. These are
       defined as follows -

              <b>KEY=[.]command</b>
       Or,

       eg:

              <b>l=[.]/usr/sbin/lsof</b> <b>-p</b> <b>$PID</b>

       Assuming the preaction is used above, this action will use lsof to show in bosh  a  list  of  files  that
       process  $PID  has open. In this situation, the output of the original command is lost, and replaced with
       the output of the action.

       Alternatively an action can be defined -
              <b>KEY=[&gt;]command</b>

       In this situation, bosh is like a web browser, in that this output (lsof) will not override  the  current
       buffer,  but  create a new buffer - You can get then move back and forward through these buffers with the
       left and right arrow keys. At this stage, actions are only available in the original buffer.

       The other possibility is that an action may be required that has output that isn't to  be  shown  in  the
       bosh  window,  such as other curses-based applications. So the following syntax will make bosh end curses
       mode when this action is invoked.

              <b>KEY=[!]command</b>

       eg: If the bosh window contained a list of files, an action like this could be used to load that file  in
       pico.

              <b>e=[!]pico</b> <b>$BOSH</b>

   <b>ACTION</b> <b>PARAMETERS</b>
       Actions can now have a prompt for user input before performing the action.  The value is available to the
       action using the <b>$BOSHPARAM</b> variable.

       eg: Using the ps example above, with PID preaction -

              <b>s=[!:signal]</b> <b>kill</b> <b>-s</b> <b>$BOSHPARAM</b> <b>$PID</b>

       When  this  action is called, <b>bosh</b> will ask for user input with the prompt <b>signal:</b>  <b>.</b>  Once this has been
       entered, the action will run.

</pre><h4><b>BOSH*</b> <b>VARIABLES:</b></h4><pre>
       In addition to <b>$BOSH</b> , <b>$BOSHPARAM</b> and <b>$BOSHERR</b> (all explained above), the following  variables  available
       to actions -

       <b>$BOSHPID</b>
              Process ID of bosh itself

       <b>$BOSHPPID</b>
              Parent process ID of bosh (eg: the shell you ran bosh from)

   <b>USER</b> <b>VARIABLES</b>
       User  variables are variables to be set and used by commands and actions. They are of the form <b>$BOSHVARx.</b>
       When the command or action is run and sets a user variable,  bosh  will  store  the  contents  when  that
       command  or action has finished.  This allows the values to be used by subsequent actions. To make use of
       these, you must first set the <b>uservars</b> to the number you need (eg: uservars=1  will  give  you  BOSHVAR1,
       uservars=10 will give you BOSHVAR1 thru BOSHVAR10).

</pre><h4><b>SHELLS</b></h4><pre>
       Currently  bosh  only  supports  bash as the shell that it spawns for executing the commands and actions.
       Support for other shells and languages will hopefully be included in the future.

</pre><h4><b>EXAMPLE</b> <b>CONFIGURATION:</b></h4><pre>
       Included with bosh should be a simple configuration named bops. It uses  ps  as  the  main  command,  and
       allows  you  to  kill  the  selected process or view its open files (using lsof). This is where the above
       examples are taken from. The original inspiration for bosh was being able to  kill  processes  easily  in
       this manner.

       To run bops, type -

              <b>$</b> <b>./bops</b>

       This invokes bosh through the shebang at the top (assuming the path is set correctly).

       Or to run it the traditional way -

              <b>$</b> <b>./bosh</b> <b>./bops</b>

</pre><h4><b>KEYS</b></h4><pre>
       <b>UP/DOWN</b>
              cursor up/down

       <b>LEFT/RIGHT</b>
              buffer forward/back

       <b>^L</b>     refresh screen

       <b>^O</b>     run new command

       <b>^P</b>     pipe buffer through a command, with the output of that pipe will become the buffer

       <b>^R</b>     refresh program output (re-run the command)

       <b>^V</b>     show the current configuration

       <b>^W</b>     search

       <b>^N</b>     repeat search

       <b>^X</b>     exit

       <b>F3</b>     same as ^W

       <b>F4</b>     same as ^N

       <b>F5</b>     same as ^R

       <b>F6</b>     reload configuration

       <b>F12</b>    same as ^L

       <b>|</b>      same as ^P

</pre><h4><b>STATUS</b> <b>BAR</b></h4><pre>
       The  status bar contains some further information about the current configuration. It shows with exit=num
       the last exit value of a command run in bosh. Furthermore a R indicates that bosh is running with refresh
       option activated. In the status bar there will be a countdown shown if the autorefresh option is set.

</pre><h4><b>AUTHOR</b></h4><pre>
       Alex Sisson (<a href="mailto:alexsisson@gmail.com">alexsisson@gmail.com</a>)

</pre><h4><b>HOMEPAGE</b></h4><pre>
       Check for updates at <a href="http://bosh.sourceforge.net">http://bosh.sourceforge.net</a>

bosh-0.6                                           18-MAR-2008                                           <u><a href="../man1/bosh.1.html">bosh</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>