<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ePerl - Embedded Perl 5 Language</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/eperl">eperl_2.2.15-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ePerl - Embedded Perl 5 Language

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>eperl</b> [<b>-d</b> <u>name</u>=<u>value</u>] [<b>-D</b> <u>name</u>=<u>value</u>] [<b>-B</b> <u>begin_delimiter</u>] [<b>-E</b> <u>end_delimiter</u>] [<b>-i</b>] [<b>-m</b> <u>mode</u>] [<b>-o</b>
       <u>outputfile</u>] [<b>-k</b>] [<b>-I</b> <u>directory</u>] [<b>-P</b>] [<b>-C</b>] [<b>-L</b>] [<b>-x</b>] [<b>-T</b>] [<b>-w</b>] [<b>-c</b>] [<u>inputfile</u>]

       <b>eperl</b> <b>-r</b>|<b>-l</b>|<b>-v</b>|<b>-V</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Abstract</b>
       ePerl interprets a text file sprinkled with Perl 5 program statements by evaluating the Perl 5 code while
       copying the plain text data verbatim. It can operate in various ways: As a stand-alone Unix filter or
       integrated Perl 5 module for general file generation tasks and as a powerful Webserver scripting language
       for dynamic HTML page programming.

   <b>Introduction</b>
       The <b>eperl</b> program is the <u>Embedded</u> <u>Perl</u> <u>5</u> <u>Language</u> interpreter. This really is a full-featured Perl 5
       interpreter, but with a different calling environment and source file layout than the default Perl
       interpreter (<b>perl</b>).  It is designed for general text file generation with the philosophy of <u>embedding</u> the
       Perl 5 program code into the data instead of the usual way where you embed the data into a Perl 5 program
       (usually by quoting the data and using them via "print" statements).  So, instead of writing a plain Perl
       script like

         #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
         print "foo bar\n";
         print "baz quux\n";
         for ($i = 0; $i &lt; 10; $i++) { print "foo #${i}\n"; }
         print "foo bar\n";
         print "baz quux\n";

       you can write it now as an ePerl script:

         #!/usr/bin/eperl
         foo bar
         baz quux
         &lt;: for ($i = 0; $i &lt; 10; $i++) { print "foo #${i}\n"; } :&gt;
         foo bar
         baz quux

       Although the ePerl variant has a different source file layout, the semantic is the same, i.e. both
       scripts create exactly the same resulting data on "STDOUT".

   <b>Intent</b>
       ePerl is simply glue code which combines the programming power of the Perl 5 interpreter library with an
       embedding trick: it converts the source file into a valid Perl script which then gets <u>entirely</u> evaluated
       by only one internal instance of the Perl 5 interpreter.  To achieve this, ePerl translates all plain
       code into (escaped) Perl 5 strings placed into <u>print</u> constructs while passing through all embedded native
       Perl 5 code. This amounts to the same operation as one would do when writing a plain Perl generation
       script.

       Due to the nature of such sprinkled code, ePerl is really the better approach when the generated text
       contains really more static than dynamic data. Or in other words: <u>Use</u> <u>ePerl</u> <u>if</u> <u>you</u> <u>want</u> <u>to</u> <u>keep</u> <u>the</u> <u>most</u>
       <u>of</u> <u>the</u> <u>generated</u> <u>text</u> <u>data</u> <u>in</u> <u>plain</u> <u>format</u> <u>while</u> <u>just</u> <u>programming</u> <u>some</u> <u>sprinkled</u> <u>stuff.</u> Do not use it
       when generating pure dynamic data. There it brings no advantage to the ordinary program code of a plain
       Perl script. So, the static part should be at least 60% or the advantage becomes a disadvantage.

       ePerl in its origin was actually designed for an extreme situation: as a webserver scripting-language for
       on-the-fly HTML page generation. Here you have the typical case that usually 90% of the data consists of
       pure static HTML tags and plain text while just the remaining 10% are programming constructs which
       dynamically generate more markup code. This is the reason why ePerl beside its standard Unix filtering
       runtime-mode also supports the CGI/1.1 and NPH-CGI/1.1 interfaces.

   <b>Embedded</b> <b>Perl</b> <b>Syntax</b>
       Practically you can put any valid Perl constructs inside the ePerl blocks the used Perl 5 interpreter
       library can evaluate. But there are some important points you should always remember and never forget
       when using ePerl:

       <u>1.</u> <u>Delimiters</u> <u>are</u> <u>always</u> <u>discarded.</u>
           Trivially  to  say,  but  should  be  mentioned  at least once. The ePerl block delimiters are always
           discarded and are only necessary for ePerl to recognize the embedded Perl constructs. They are  never
           copied to the final output.

       <u>2.</u> <u>Generated</u> <u>content</u> <u>has</u> <u>to</u> <u>go</u> <u>to</u> <u>"STDOUT".</u>
           Although  you  can define subroutines, calculate some data, etc. inside ePerl blocks, only data which
           is explicitly written to the "STDOUT" filehandle is expanded. In other words:  When  an  ePerl  block
           does  not  generate  content  on  "STDOUT",  it  is entirely replaced by an empty string in the final
           output.  But when content is generated it is put at the point of the ePerl block in the final output.
           Usually content is generated via pure "print"  constructs  which  implicitly  use  "STDOUT"  when  no
           filehandle is given.

       <u>3.</u> <u>Generated</u> <u>content</u> <u>on</u> <u>"STDERR"</u> <u>always</u> <u>leads</u> <u>to</u> <u>an</u> <u>error.</u>
           Whenever  content  is  generated  on  the "STDERR" filehandle, ePerl displays an error (including the
           STDERR content). Use this to exit on errors while passing errors from ePerl  blocks  to  the  calling
           environment.

       <u>4.</u> <u>Last</u> <u>semicolon.</u>
           Because  of  point  6 (below) and the fact that most of the users don't have the internal ePerl block
           translations in mind, ePerl is smart about the last semicolon. Usually every Perl block  has  to  end
           with the semicolon of the last command.

              &lt;: cmd; ...; cmd; :&gt;

           But when the last semicolon is missing it is automatically added by ePerl, i.e.

              &lt;: cmd; ...; cmd :&gt;

           is  also correct syntax.  But sometimes it is necessary to force ePerl <u>not</u> to add the semicolon. Then
           you can add a "_" (underscore) as the last non-whitespace character in the block to  force  ePerl  to
           leave the final semicolon. Use this for constructs like the following

              &lt;: if (...) { _:&gt;
              foo
              &lt;: } else { _:&gt;
              bar
              &lt;: } :&gt;

           where you want to spread a Perl directive over more ePerl blocks.

       <u>5.</u> <u>Shorthand</u> <u>for</u> <u>"print"-only</u> <u>blocks.</u>
           Because most of the time ePerl is used just to interpolate variables, e.g.

              &lt;: print $VARIABLE; :&gt;

           it is useful to provide a shortcut for this kind of constructs.  So ePerl provides a shortcut via the
           character  "=".  When  it immediately (no whitespaces allowed here) follows the begin delimiter of an
           ePerl block, a "print" statement is implicitly generated, i.e. the above block is equivalent to

              &lt;:=$VARIABLE:&gt;

       <u>6.</u> <u>Special</u> <u>end-of-line</u> <u>discard</u> <u>command</u> <u>for</u> <u>ePerl</u> <u>blocks.</u>
           ePerl provides a special discard command named "//" which discards all data up to and  including  the
           following newline character when directly followed an end block delimiter. Usually when you write

             foo
             &lt;: $x = 1; :&gt;
             quux

           the result is

             foo

             quux

           because ePerl always preserves code around ePerl blocks, even just newlines. But when you write

             foo
             &lt;: $x = 1; :&gt;//
             quux

           the result is

             foo
             quux

       <u>7.</u> <u>Restrictions</u> <u>in</u> <u>parsing.</u>
           Perl  is  a  rich  language,  but a horrible one to parse.  Perhaps you've heard "Only <u>perl</u> can parse
           <u>Perl</u>".  The implication of this is that ePerl never tries  to  parse  the  ePerl  blocks  itself.  It
           entirely  relies  on  the Perl interpreter library, because it is the only instance which can do this
           without errors.  But the problem is that ePerl at least has to recognize the begin and end  positions
           of those ePerl blocks.

           There  are  two  ways: It can either look for the end delimiter while parsing, but at least recognize
           quoted strings (where the end delimiter gets treated as pure data). Or it can just  move  forward  to
           the  next end delimiter and say that it can not occur inside Perl constructs. In ePerl 2.0 the latter
           was used, while in ePerl 2.1 the former was taken because a lot of users wanted  it  this  way  while
           using bad end delimiters like "&gt;". But actually the author has again revised its opinion in ePerl 2.2
           and  decided  to  finally  use  latter  approach.  Because  while  the  first one allows more trivial
           delimiters (which itself is not a really good idea), it fails when constructs like "m|"[^"]+"|"  etc.
           are  used  inside ePerl blocks. And it is easier to escape end delimiters inside Perl constructs (for
           instance via backslashes in quoted strings) than rewrite complex Perl constructs to use even  numbers
           of quotes.

           So, whenever your end delimiter also occurs inside Perl constructs you have to some-how escape it.

       <u>8.</u> <u>HTML</u> <u>entity</u> <u>conversion.</u>
           Because one of ePerl's usage is as a server-side scripting-language for HTML pages, there is a common
           problem  in  conjunction  with  HTML editors.  They cannot know ePerl blocks, so when you enter those
           blocks inside the editors they usually encode some characters with the corresponding  HTML  entities.
           The problem is that this encoding leads to invalid Perl code. ePerl provides the <b>-C</b> option (q.v.) for
           decoding these entities to CP-1252, which is automatically turned on in CGI modes.

   <b>Runtime</b> <b>Modes</b>
       ePerl can operate in three different runtime modes:

       <u>Stand-alone</u> <u>Unix</u> <u>filter</u> <u>mode</u>
           This  is the default operation mode when used as a generation tool from the Unix shell or as a batch-
           processing tool from within other programs or scripts:

             $ eperl [options] - &lt; inputfile &gt; outputfile
             $ eperl [options] inputfile &gt; outputfile
             $ eperl [options] -o outputfile - &lt; inputfile
             $ eperl [options] -o outputfile inputfile

           As you can see, ePerl can be used in any combination of STDIO and external files. Additionally  there
           are  two  interesting  variants  of  using  this  mode.   First,  you can put ePerl in the shebang to
           implicitly select it as the interpreter for your script, similar to the way you are used to with  the
           plain Perl interpreter:

             #!/usr/bin/eperl [options]
             foo
             &lt;: print "bar"; :&gt;
             quux

           Second,  you  can  use  ePerl  in conjunction with the shell <u>here-document</u> technique from within your
           shell programs:

             #!<a href="file:/bin/sh">/bin/sh</a>
             ...
             eperl [options] - &lt;&lt;EOS
             foo
             &lt;: print "quux"; :&gt;
             quux
             EOS
             ...

           If you need to generate shell or other scripts with ePerl, i.e. you need a shebang line in the output
           of ePerl, you have to add a shebang line containing e.g. "#!/usr/bin/eperl" first, because ePerl will
           strip the first line from the input if it is a shebang line. For example:

             #!/usr/bin/eperl
             #!<a href="file:/bin/sh">/bin/sh</a>
             echo &lt;: print "quux"; :&gt;

           will result in the following output:

             #!<a href="file:/bin/sh">/bin/sh</a>
             echo quux

           Alternatively you can add a preprocessor comment in the first line:

             #c This is a comment to preserve the shebang line in the following line
             #!<a href="file:/bin/sh">/bin/sh</a>
             echo &lt;: print "quux"; :&gt;

           And finally you can use ePerl directly from within Perl programs by the use  of  the  <b>Parse::<a href="../man3/ePerl.3.html">ePerl</a></b>(3)
           package (assuming that you have installed this also):

             #!/path/to/perl
             ...
             use Parse::ePerl;
             ...
             $script = &lt;&lt;EOT;
             foo
             &lt;: print "quux"; :&gt;
             quux
             EOT
             ...
             $result = Parse::ePerl::Expand({
                 Script =&gt; $script,
                 Result =&gt; \$result,
             });
             ...
             print $result;
             ...

           See <b>Parse::<a href="../man3pm/ePerl.3pm.html">ePerl</a></b>(3pm) for more details.

       <u>CGI/1.1</u> <u>compliant</u> <u>interface</u> <u>mode</u>
           This is the runtime mode where ePerl uses the CGI/1.1 interface of a webserver when used as a server-
           side  scripting  language. ePerl enters this mode automatically when the CGI/1.1 environment variable
           "PATH_TRANSLATED" is set and its or the scripts filename does <u>not</u> begin with the NPH  prefix  "<u>nph-</u>".
           In  this  runtime  mode  it  prefixes  the  resulting  data  with  HTTP/1.0 (default) or HTTP/1.1 (if
           identified by the webserver) compliant response header lines.

           ePerl also recognizes HTTP header lines at the beginning of the script's generated data, for instance
           you can generate your own HTTP headers with

              &lt;? $url = "..";
                 print "Location: $url\n";
                 print "URI: $url\n\n"; !&gt;
              &lt;html&gt;
              ...

           But notice that while you can output arbitrary headers, most webservers restrict  the  headers  which
           are accepted via the CGI/1.1 interface. Usually you can provide only a few specific HTTP headers like
           "Location" or "Status".  If you need more control you have to use the NPH-CGI/1.1 interface mode.

           The  default  HTTP  status  is  "200  OK".  If  your  script's output starts with an HTTP status line
           ("HTTP/1.0 123 Description" (or "/1.1")), that line is used instead.

           Additionally ePerl provides a useful feature in this mode: It can switch its UID/GID to the owner  of
           the script if the set-UID bit is set (see <u>Security</u>).

           There are two commonly known ways of using this CGI/1.1 interface mode on the Web. First, you can use
           it  to  explicitly transform plain HTML files into CGI/1.1 scripts with a shebang (see above). For an
           Apache webserver, just put the following line as the first line of the file:

             #!/usr/bin/eperl -mc

           Then rename the script from <u>file.html</u> to <u>file.cgi</u> and set mark it executable:

             $ mv file.html file.cgi
             $ chmod a+rx file.cgi

           Now make sure that Apache accepts <u>file.cgi</u> as a CGI program by enabling CGI support for the directory
           where <u>file.cgi</u> resides. For this add the line

             Options +ExecCGI

           to the <u>.htaccess</u> file in this  directory.  Finally  make  sure  that  Apache  really  recognizes  the
           extension <u>.cgi</u>. Perhaps you additionally have to add the following line to your <u>httpd.conf</u> file:

             AddHandler cgi-script .cgi

           Now  you  can  use  <u>file.cgi</u>  instead  of  <u>file.html</u>  and  take advantage of the achieved programming
           capability by bristling <u>file.cgi</u> with your Perl blocks (or the transformation into a CGI script would
           have been useless).

           Alternatively (or even additionally) a webmaster can enable ePerl support in a more seamless  way  by
           configuring  ePerl  as  a  real  implicit server-side scripting language. This is done by assigning a
           MIME-type to the various valid ePerl file extensions and forcing all files with this MIME-type to  be
           internally  processed  via  the  ePerl  interpreter. You can accomplish this for Apache by adding the
           following to your <u>httpd.conf</u> file

             AddType      application/x-httpd-eperl  .phtml .eperl .epl
             Action       application/x-httpd-eperl  /internal/cgi/eperl
             ScriptAlias  /internal/cgi              /path/to/apache/cgi-bin

           and creating a copy of the <u>eperl</u> program in your CGI-directory:

             $ cp -p /usr/bin/eperl /path/to/apache/cgi-bin/eperl

           Now all files with the extensions <u>.phtml</u>, <u>.eperl</u> and <u>.epl</u> are automatically processed  by  the  ePerl
           interpreter. There is no need for a shebang or any locally-enabled CGI mode.

           One  final  hint:  When you want to test your scripts offline, just run them with forced CGI/1.1 mode
           from your shell. But make sure you prepare all environment variables your  script  depends  on,  like
           "QUERY_STRING" or "PATH_INFO":

             $ export QUERY_STRING="key1=value1&amp;key2=value2"
             $ eperl -mc file.phtml

       <u>NPH-CGI/1.1</u> <u>compliant</u> <u>interface</u> <u>mode</u>
           This  runtime  mode is a special variant of the CGI/1.1 interface mode, because most webservers (e.g.
           Apache) provide it for special purposes.  NPH stands for <u>Non-Parsed-Header</u> and is usually used by the
           webserver when the filename of the CGI program is prefixed with "nph-".  In this mode  the  webserver
           does  no processing on the HTTP response headers and no buffering of the resulting data, i.e. the CGI
           program actually has to provide a complete HTTP response itself. The advantage is  that  the  program
           can generate arbitrary HTTP headers or MIME-encoded multi-block messages.

           So,  above  we  have  renamed  the  file  to  <u>file.cgi</u>  which  restricted  us  a  little bit. When we
           alternatively rename <u>file.html</u> to <u>nph-file.cgi</u> and force the NPH-CGI/1.1 interface  mode  via  option
           <b>-mn</b> then this file becomes a NPH-CGI/1.1 compliant program under Apache and other webservers. Now our
           script <u>can</u> provide its own HTTP response (it doesn't <u>need</u> to, because ePerl provides a default one if
           it is absent).

             #!/path/to/bin/eperl -mn
             &lt;? print "HTTP/1.0 200 Ok\n";
                print "X-MyHeader: Foo Bar Quux\n";
                print "Content-type: text/html\n\n";
             &lt;html&gt;
             ...

           Expectedly, this can be also used with the implicit Server-Side Scripting Language technique. Put

             AddType      application/x-httpd-eperl  .phtml .eperl .epl
             Action       application/x-httpd-eperl  /internal/cgi/nph-eperl
             ScriptAlias  /internal/cgi              /path/to/apache/cgi-bin

           into your <u>httpd.conf</u> and run the command

             $ cp -p /usr/bin/eperl /path/to/apache/cgi-bin/nph-eperl

           from  your  shell.  <u>This</u>  <u>is</u>  <u>the</u>  <u>preferred</u>  <u>way</u> <u>of</u> <u>using</u> <u>ePerl</u> <u>as</u> <u>a</u> <u>Server-Side</u> <u>Scripting</u> <u>Language,</u>
           <u>because</u> <u>it</u> <u>provides</u> <u>most</u> <u>flexibility.</u>

   <b>Security</b>
       When you are installing ePerl as a CGI/1.1 or NPH-CGI/1.1  compliant  program  (see  above  for  detailed
       description of these modes) via

         $ cp -p /usr/bin/eperl /path/to/apache/cgi-bin/eperl
         $ chown root /path/to/apache/cgi-bin/eperl
         $ chmod u+s  /path/to/apache/cgi-bin/eperl

       or

         $ cp -p /usr/bin/eperl /path/to/apache/cgi-bin/nph-eperl
         $ chown root /path/to/apache/cgi-bin/nph-eperl
         $ chmod u+s  /path/to/apache/cgi-bin/nph-eperl

       i.e.  with  set-UID bit enabled for the <b>root</b> user, ePerl can switch to the UID/GID of the <u>script's</u> <u>owner</u>.
       Although this is a very useful feature for script  programmers  (because  one  no  longer  need  to  make
       auxiliary  files world-readable and temporary files world-writable!), it can be to risky for you when you
       are paranoid about security of set-UID programs. If so, just don't install ePerl  set-UID!  This  is  the
       reason why ePerl is by default only installed as a stand-alone program which never needs this feature.

       For  those  of  us who decided that this feature is essential, ePerl tries really hard to make it secure.
       The following steps have to be successfully passed before ePerl actually switches its  UID/GID  (in  this
       order):

       1. The script has to match the following extensions: <u>.html</u>, <u>.phtml</u>, <u>.eperl</u>, <u>.ephtml</u>, <u>.epl</u>, <u>.pl</u>, <u>.cgi</u>
       2. The UID of the calling process has to be a valid UID, i.e. it has to be found in <b><a href="../man5/passwd.5.html">passwd</a></b>(5)
       3. The UID of the calling process has to match the following users: nobody, root, www-data
       4. The UID of the script owner has to be a valid UID, i.e. it has to be found in <b><a href="../man5/passwd.5.html">passwd</a></b>(5)
       5. The GID of the script group has to be a valid GID, i.e. it has to be found in <b><a href="../man5/group.5.html">group</a></b>(5)
       6. The script has to stay below the owner's home directory

       <u><b>IF</b></u> <u><b>ANY</b></u> <u><b>ONE</b></u> <u><b>OF</b></u> <u><b>THOSE</b></u> <u><b>STEPS</b></u> <u><b>FAILS,</b></u> <u><b>NO</b></u> <u><b>UID/GID</b></u> <u><b>SWITCHING</b></u> <u><b>TAKES</b></u> <u><b>PLACE!</b></u>.  Additionally (if "DO_ON_FAILED_STEP"
       was  defined  to  "STOP_AND_ERROR"  in <u>eperl_security.h</u>, which is not the default) ePerl can totally stop
       processing and display its error page.  This is for the really paranoid webmasters. Per default when  any
       step  failed the UID/GID switching is just disabled, but ePerl goes on with processing. Alternatively you
       can disable some steps at compile time. See <u>eperl_security.h</u>.

       <u>For</u> <u>security</u> <u>reasons,</u> <u>if</u> <u>the</u> <u>effective</u> <u>UID</u> <u>is</u> <u>that</u> <u>of</u> <u>root,</u> <u>the</u> <u>effectuve</u> <u>UID/GID</u> <u>is</u> <u><b>always</b></u> <u>reset</u> <u>to</u>  <u>the</u>
       <u>real</u> <u>UID/GID,</u> <u>regardless</u> <u>of</u> <u>the</u> <u>mode.</u>

   <b>ePerl</b> <b>Preprocessor</b>
       ePerl  provides its own preprocessor, similar to the C preprocessor, which is either enabled manually via
       option <b>-P</b>, or automatically when ePerl runs in (NPH-)CGI mode.  The following directives are supported:

       "#include <u>path</u>"
           The contents of <u>path</u>, which can be either a relative or absolute path or a fully qualified HTTP  URL,
           are read and preprocessed recursively.

           An  absolute  path  is opened directly, relative paths are tried in the working directory and then in
           directories given by <b>-I</b>.  An HTTP URL is retrieved via a HTTP/1.0 request on the network, and 301/303
           redirects are followed.

           While ePerl strictly preserves the line numbers when removing sprinklings to  yield  the  plain  Perl
           format,  the  preprocessor can't do this for this directive.  So, line numbers in error messages will
           be wrong.

           The security implications are obvious: This can run arbitrary code.  You probably shouldn't use  this
           if you don't implicitly trust the reply.  "#sinclude" is appropriate then.

       "#sinclude <u>path</u>"
           This  is  just  like "#include", but all delimiters are removed.  Thus, <u>path</u> is reduced to only data,
           and no code.

       "#if <u>expr</u>", "#elsif <u>expr</u>", "#else", "#endif"
           These  implement  a  C-preprocessor-style  "#if"/"#else"/"#endif"  construct,  but  <u>expr</u>  is  a  Perl
           expression evaluated at run-time.  These are converted as follows (where <u>BD</u>/<u>ED</u> are the delimiters):

             #if expr    → BD if (expr) { _ ED//
             #elsif expr → BD } elsif (expr) { _ ED//
             #else       → BD } else { _ ED//
             #endif      → BD } _ ED//

       "#c"
           Comment, discards everything up to and including the newline.

   <b>Provided</b> <b>Functionality</b>
       You  can put really <u>any</u> Perl code into the ePerl blocks which are valid to the Perl interpreter ePerl was
       linked with.  ePerl does <u>not</u> provide any special functionality inside these ePerl blocks, because Perl is
       already sophisticated enough ;-)

       Because you can use any valid Perl code you can use all available Perl 5 modules, even  those  which  use
       shared  objects. The Comprehensive Perl Archive Network &lt;<a href="http://www.perl.com/perl/CPAN">http://www.perl.com/perl/CPAN</a>&gt; provides packages
       for use  both from within plain Perl scripts <u>and</u> ePerl scripts.  "use name;" works as-expected.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-d</b> <u>name</u>=<u>value</u>
           Sets a Perl variable in the package "main" which can be referenced via $name or more  explicitly  via
           $main::name. This is equivalent to adding

             &lt;? $name = value; !&gt;

           to the beginning of <u>inputfile</u>. This option can occur more than once.

       <b>-D</b> <u>name</u>=<u>value</u>
           Sets  environment  variable  <u>name</u>  to  <u>value</u>,  which  can  be  referenced  via $ENV{'<u>NAME</u>'}.  This is
           equivalent to just running

             $ name=value eperl ...

           This option can occur more than once.

       <b>-B</b> <u>begin_delimiter</u> =item <b>-E</b> <u>end_delimiter</u>
           Set the Perl block begin and end delimiter strings.  Default delimiters are "&lt;?" &amp; "!&gt;" for CGI modes
           and "&lt;:" &amp; ":&gt;" otherwise.

           These may be of interest:

               "&lt;:" &amp; ":&gt;" (the default ePerl stand-alone filtering mode delimiters)
               "&lt;?" &amp; "!&gt;" (the default ePerl CGI interface mode delimiters)
               "&lt;script language='ePerl'&gt;"  &amp; "&lt;/script&gt;" (standard HTML scripting language style)
               "&lt;script type="text/eperl"&gt;" &amp; "&lt;/script&gt;" (forthcoming HTML3.2+ aka Cougar style)
               "&lt;eperl&gt;" &amp; "&lt;/eperl&gt;" (HTML-like style)
               "&lt;!--#eperl code='" &amp; "' --&gt;" (NeoScript and SSI style)
               "&lt;?" &amp; "&gt;" (PHP/FI style; but this no longer recommended because it can lead to parsing problems.
               Should be used only for backward compatibility to old ePerl versions 1.x).
       <b>-i</b>  Forces the begin and end delimiters to be searched case-insensitively.  Use this when you  are  using
           delimiters like "&lt;ePerl&gt;"..."&lt;/ePerl&gt;" or other more textual ones.

       <b>-m</b> <u>mode</u>
           Forces  ePerl  to  act  in  a  specific runtime mode: stand-alone filter (<b>-mf</b>), the CGI/1.1 interface
           (<b>-mc</b>), or the NPH-CGI/1.1 interface (<b>-mn</b>).

       <b>-o</b> <u>outputfile</u>
           Write to <u>outputfile</u> instead of <u>STDOUT</u> ("-" specifies <u>STDOUT</u> explicitly.)  This path  is  relative  to
           the directory containing <u>inputfile</u> in the CGI modes.

       <b>-k</b>  Don't  change  the  working  directory.   By  default,  ePerl will change to the directory containing
           <u>inputfile</u>.

       <b>-x</b>  Output the internally created Perl script to the console (<u>/dev/tty</u>) before executing it.

       <b>-I</b> <u>directory</u>
           Specifies a directory which where "#include" and "#sinclude" files are searched, and which is  to  be
           added to Perl @INC.  This option can occur more than once.

       <b>-P</b>  Enable  the  special  ePerl  Preprocessor  (see  above).  This  option  is  enabled for all CGI modes
           automatically.

       <b>-C</b>  This enables the HTML entity conversion for ePerl blocks. This option is automatically forced in  CGI
           modes.

           The  solved problem here is the following: When you use ePerl as a server-side-scripting-language for
           HTML pages and you edit your ePerl source files via a HTML editor, it's  likely  that  it  translates
           some  entered  characters  into  HTML  entities, like "&lt;" to "&amp;lt;".  This leads to invalid Perl code
           inside ePerl blocks. Using this option, the ePerl parser automatically converts  all  entities  found
           inside  ePerl  blocks  back to plain CP-1252 characters, so the Perl interpreter again receives valid
           code blocks.

       <b>-L</b>  This enables the line continuation character "\" (backslash) outside ePerl blocks. With  this  option
           you  can  spread  one-line  data  over  more lines.  But use with care: This option changes your data
           (outside ePerl blocks).  Usually ePerl really pass through all surrounding data  as  raw  data.  With
           this option the newlines have new semantics.

       <b>-T</b>  This  enabled Perl's <u>Tainting</u> <u>mode</u> where the Perl interpreter takes special precautions called "taint
           checks" to prevent both obvious and subtle traps.  See <b><a href="../man1/perlsec.1.html">perlsec</a></b>(1) for more details.

       <b>-w</b>  This enables Warnings where the Perl interpreter produces some lovely  diagnostics.  See  <b><a href="../man1/perldiag.1.html">perldiag</a></b>(1)
           for more details.

       <b>-c</b>  This only runs a syntax check, like "perl -c".

       <b>-r</b>  This copies the ePerl README to <u>STDOUT</u>.

       <b>-l</b>  This copies the ePerl licences to <u>STDOUT</u>.

       <b>-v</b>  This shows ePerl version information to <u>STDOUT</u>.

       <b>-V</b>  <b>-v</b> + shows the Perl compilation parameters.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
   <b>Used</b> <b>Variables</b>
       "PATH_TRANSLATED"
           This  CGI/1.1  variable  is  used  to  determine the source file when ePerl operates as a NPH-CGI/1.1
           program under the environment of a webserver.

   <b>Provided</b> <b>Variables</b>
       "SCRIPT_SRC_PATH"
           The absolute pathname of the script. Use this when you want to directly access the script from within
           itself, for instance to do <b><a href="../man2/stat.2.html">stat</a></b>(2) and other calls.

       "SCRIPT_SRC_PATH_DIR"
           The directory part of "SCRIPT_SRC_PATH". Use this one when you want to directly  access  other  files
           residing in the same directory as the script, for instance to read config files, etc.

       "SCRIPT_SRC_PATH_FILE"
           The  filename  part  of "SCRIPT_SRC_PATH". Use this one when you need the basename of the script, for
           instance for relative self-references through URLs.

       "SCRIPT_SRC_URL"
           The fully-qualified URL of the script.

       "SCRIPT_SRC_URL_DIR"
           The directory part of "SCRIPT_SRC_URL".

       "SCRIPT_SRC_URL_FILE"
           The filename part of "SCRIPT_SRC_URL".  Same as "SCRIPT_SRC_PATH_FILE", but provided for consistency.

       "SCRIPT_SRC_SIZE"
           The filesize of the script, in bytes.

       "SCRIPT_SRC_MODIFIED"
           The last modification time of the script, in seconds since epoch.

       "SCRIPT_SRC_MODIFIED_CTIME"
           The last modification time of the script, in <b><a href="../man3/ctime.3.html">ctime</a></b>(3) format (<u>WDAY</u> <u>MMM</u> <u>DD</u> <u>HH:MM:SS</u> <u>YYYY</u>).

       "SCRIPT_SRC_MODIFIED_ISOTIME"
           The last modification time of the script, in German format (<u>DD-MM-YYYY</u> <u>HH:MM</u>).

       "SCRIPT_SRC_OWNER"
           The username of the script owner or "unknown-uid-<u>123</u>".

       "VERSION_INTERPRETER"
           The ePerl identification string.

       "VERSION_LANGUAGE"
           The identification string of the Perl interpreter.

   <b>Provided</b> <b>Built-In</b> <b>Images</b>
       The following built-in images can be accessed via URL "/url/to/nph-eperl/"<u>NAME</u>".gif":

       "logo.gif"
           The standard ePerl logo. Please do not include this one on your website.

       "powered.gif"
           The "<u>powered</u> <u>by</u> <u>ePerl</u> <u>2.2</u>" logo. Feel free to use this on your website.

</pre><h4><b>AUTHOR</b></h4><pre>
         Ralf S. Engelschall
         <a href="mailto:rse@engelschall.com">rse@engelschall.com</a>
         www.engelschall.com

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>Parse::<a href="../man3/ePerl.3.html">ePerl</a></b>(3).

       Web-References:

         Perl:   <a href="../man1/perl.1.html">perl</a>(1),  <a href="http://www.perl.com/">http://www.perl.com/</a>
         ePerl:  <a href="../man1/eperl.1.html">eperl</a>(1), <a href="http://sr.ht/~nabijaczleweli/ossp">http://sr.ht/~nabijaczleweli/ossp</a>
         Apache: <a href="../man8/httpd.8.html">httpd</a>(8), <a href="http://www.apache.org/">http://www.apache.org/</a>

ossp-eperl 2.2.15                                  2024-10-19                                           <u><a href="../man1/EPERL.1.html">EPERL</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>