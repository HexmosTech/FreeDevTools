<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>perlhack - How to hack on Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/perl-doc">perl-doc_5.40.1-2ubuntu0.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       perlhack - How to hack on Perl

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This document explains how Perl development works.  It includes details about the Perl 5 Porters email
       list, the Perl repository, the Perl bug tracker, patch guidelines, and commentary on Perl development
       philosophy.

</pre><h4><b>SUPER</b> <b>QUICK</b> <b>PATCH</b> <b>GUIDE</b></h4><pre>
       If you just want to submit a single small patch like a pod fix, a test for a bug, comment fixes, etc.,
       it's easy! Here's how:

       •   Check out the source repository

           The perl source is in a git repository.  You can clone the repository with the following command:

             % git clone https://github.com/Perl/perl5.git perl

       •   Ensure you're following the latest advice

           In case the advice in this guide has been updated recently, read the latest version directly from the
           perl source:

             % perldoc pod/perlhack.pod

       •   Create a branch for your change

           Create  a  branch based on blead to commit your change to, which will later be used to send it to the
           Perl issue tracker.

             % git checkout -b mychange

       •   Make your change

           Hack, hack, hack.  Keep in mind that Perl runs on many different platforms, with different  operating
           systems  that  have  different  capabilities,  different filesystem organizations, and even different
           character sets.  perlhacktips gives advice on this.

       •   Test your change

           You can run all the tests with the following commands:

             % ./Configure -des -Dusedevel
             % make test

           Keep hacking until the tests pass.

       •   Commit your change

           Committing your work will save the change <u>on</u> <u>your</u> <u>local</u> <u>system</u>:

             % git commit -a -m 'Commit message goes here'

           Make sure the commit message describes your  change  in  a  single  sentence.   For  example,  "Fixed
           spelling errors in perlhack.pod".

       •   Send your change to the Perl issue tracker

           The next step is to submit your patch to the Perl core ticket system.

           Create  a  GitHub  fork  of  the  perl5 repository and add it as a remote, if you haven't already, as
           described in the GitHub documentation at &lt;https://help.github.com/en/articles/working-with-forks&gt;.

             % git remote add fork <a href="mailto:git@github.com">git@github.com</a>:MyUser/perl5.git

           For more information, see  "Connecting  to  GitHub  with  SSH"  &lt;https://docs.github.com/en/free-pro-
           team@latest/github/authenticating-to-github/connecting-to-github-with-ssh&gt;.

           If   you'd   rather   use   an  HTTPS  URL  for  your  "git  push"  see  "Cloning  with  HTTPS  URLs"
           &lt;https://docs.github.com/en/free-pro-team@latest/github/using-git/which-remote-url-should-i-
           use#cloning-with-https-urls&gt;.

             % git remote add fork https://github.com/MyUser/perl5.git

           Then, push your new branch to your fork.

             % git push -u fork mychange

           Finally, create a Pull Request on GitHub from your  branch  to  blead  as  described  in  the  GitHub
           documentation at &lt;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&gt;.

       •   Thank you

           The porters appreciate the time you spent helping to make Perl better.  Thank you!

       •   Acknowledgement

           All  contributors  are credited (by name and email address) in the AUTHORS file, which is part of the
           perl distribution, as well as the Git commit history.

           If you don’t want to be included in the AUTHORS file, just let us know. Otherwise we will  take  your
           submission of a patch as permission to credit you in the AUTHORS file.

       •   Next time

           The  next  time you wish to make a patch, you need to start from the latest perl in a pristine state.
           Check you don't have any local changes or added files in your perl check-out which you wish to  keep,
           then run these commands:

             % git checkout blead
             % git pull
             % git reset --hard origin/blead
             % git clean -dxf

</pre><h4><b>BUG</b> <b>REPORTING</b></h4><pre>
       If  you  want  to  report  a  bug in Perl, or browse existing Perl bugs and patches, use the GitHub issue
       tracker at &lt;https://github.com/perl/perl5/issues&gt;.

       Please check the archive of the perl5-porters list (see below) and/or  the  bug  tracking  system  before
       submitting a bug report.  Often, you'll find that the bug has been reported already.

       You  can  log  in to the bug tracking system and comment on existing bug reports.  If you have additional
       information regarding an existing bug, please add it.  This will help the porters fix the bug.

</pre><h4><b>PERL</b> <b>5</b> <b>PORTERS</b></h4><pre>
       The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed.
       The people who maintain Perl are also referred to as the "Perl 5 Porters", "p5p" or just the "porters".

       A searchable archive of the list is available at  &lt;https://markmail.org/search/?q=perl5-porters&gt;.   There
       is also an archive at &lt;https://archive.develooper.com/<a href="mailto:perl5-porters@perl.org">perl5-porters@perl.org</a>/&gt;.

   <b>perl-changes</b> <b>mailing</b> <b>list</b>
       The  perl5-changes  mailing list receives a copy of each patch that gets submitted to the maintenance and
       development branches of the perl repository.   See  &lt;https://lists.perl.org/list/perl5-changes.html&gt;  for
       subscription and archive information.

   <b>#p5p</b> <b>on</b> <b>IRC</b>
       Many porters are also active on the &lt;irc://irc.perl.org/#p5p&gt; channel.  Feel free to join the channel and
       ask questions about hacking on the Perl core.

</pre><h4><b>GETTING</b> <b>THE</b> <b>PERL</b> <b>SOURCE</b></h4><pre>
       All  of  Perl's source code is kept centrally in a Git repository at <u>github.com</u>.  The repository contains
       many Perl revisions from Perl 1 onwards and all the revisions from Perforce, the previous version control
       system.

       For much more detail on using git with the Perl repository, please see perlgit.

   <b>Read</b> <b>access</b> <b>via</b> <b>Git</b>
       You will need a copy of Git for your computer.  You can fetch a copy of  the  repository  using  the  git
       protocol:

         % git clone <a href="mailto:git@github.com">git@github.com</a>:Perl/perl5.git perl

       This clones the repository and makes a local copy in the <u>perl</u> directory.

       If you cannot use the git protocol for firewall reasons, you can also clone via http:

         % git clone https://github.com/Perl/perl5.git perl

   <b>Read</b> <b>access</b> <b>via</b> <b>the</b> <b>web</b>
       You  may  access  the  repository  over the web.  This allows you to browse the tree, see recent commits,
       subscribe to repository notifications, search for particular commits and more.   You  may  access  it  at
       &lt;https://github.com/Perl/perl5&gt;.

   <b>Write</b> <b>access</b> <b>via</b> <b>git</b>
       If you have a commit bit, please see perlgit for more details on using git.

</pre><h4><b>PATCHING</b> <b>PERL</b></h4><pre>
       If  you're  planning  to  do  more  extensive  work than a single small fix, we encourage you to read the
       documentation below.  This will help you focus your work and make your patches easier to incorporate into
       the Perl source.

   <b>Submitting</b> <b>patches</b>
       If you have a small patch to submit, please submit it via the GitHub Pull Request workflow.  You may also
       send patches to the p5p list.

       Patches are reviewed and discussed on GitHub or the  p5p  list.   Simple,  uncontroversial  patches  will
       usually be applied without any discussion.  When the patch is applied, the ticket will be updated and you
       will receive email.

       In  other  cases,  the patch will need more work or discussion.  You are encouraged to participate in the
       discussion and advocate for your patch.  Sometimes  your  patch  may  get  lost  in  the  shuffle.   It's
       appropriate to send a reminder email to p5p if no action has been taken in a month.  Please remember that
       the Perl 5 developers are all volunteers, and be polite.

       Changes  are always applied directly to the main development branch, called "blead".  Some patches may be
       backported to a maintenance branch.  If you think your patch is appropriate for  the  maintenance  branch
       (see "MAINTENANCE BRANCHES" in perlpolicy), please explain why when you submit it.

   <b>Getting</b> <b>your</b> <b>patch</b> <b>accepted</b>
       If  you  are  submitting a code patch there are several things that you can do to help the Perl 5 Porters
       accept your patch.

       <u>Patch</u> <u>style</u>

       Using the GitHub Pull Request workflow, your patch will automatically be available in a suitable  format.
       If you wish to submit a patch to the p5p list for review, make sure to create it appropriately.

       If  you  used  git  to check out the Perl source, then using "git format-patch" will produce a patch in a
       style suitable for Perl.  The "format-patch" command produces one patch file for each  commit  you  made.
       If you prefer to send a single patch for all commits, you can use "git diff".

         % git checkout blead
         % git pull
         % git diff blead my-branch-name

       This  produces  a patch based on the difference between blead and your current branch.  It's important to
       make sure that blead is up to date before producing the diff, that's why we call "git pull" first.

       We strongly recommend that you use git if possible.  It will make your life easier, and ours as well.

       However, if you're not using git, you can still produce a suitable patch.  You'll need a pristine copy of
       the Perl source to diff against.  The porters prefer unified diffs.  Using GNU "diff", you can produce  a
       diff like this:

         % diff -Npurd perl.pristine perl.mine

       Make  sure that you "make realclean" in your copy of Perl to remove any build artifacts, or you may get a
       confusing result.

       <u>Commit</u> <u>message</u>

       As you craft each patch you intend to submit to the Perl core, it's important  to  write  a  good  commit
       message.  This is especially important if your submission will consist of a series of commits.

       The  first  line  of  the commit message should be a short description without a period.  It should be no
       longer than the subject line of an email, 50 characters being a good rule of thumb.

       A lot of Git tools (Gitweb, GitHub, git log --pretty=oneline, ...) will only display the first line  (cut
       off at 50 characters) when presenting commit summaries.

       The  commit  message  should  include  a  description  of  the  problem  that  the  patch corrects or new
       functionality that the patch adds.

       As a general rule of thumb, your commit message should help a programmer who knows the Perl core  quickly
       understand what you were trying to do, how you were trying to do it, and why the change matters to Perl.

       •   Why

           Your  commit  message should describe why the change you are making is important.  When someone looks
           at your change in six months or six years, your intent should be clear.

           If you're deprecating a feature with the intent of later simplifying another bit of code, say so.  If
           you're fixing a performance problem or adding a new feature to support some other bit  of  the  core,
           mention that.

       •   What

           Your  commit  message  should describe what part of the Perl core you're changing and what you expect
           your patch to do.

       •   How

           While it's not necessary for documentation changes, new tests or trivial patches,  it's  often  worth
           explaining  how  your change works.  Even if it's clear to you today, it may not be clear to a porter
           next month or next year.

       A commit message isn't intended to take the place of comments  in  your  code.   Commit  messages  should
       describe the change you made, while code comments should describe the current state of the code.

       If  you've  just  implemented  a  new  feature, complete with doc, tests and well-commented code, a brief
       commit message will often suffice.  If, however, you've just changed  a  single  character  deep  in  the
       parser  or lexer, you might need to write a small novel to ensure that future readers understand what you
       did and why you did it.

       <u>Comments,</u> <u>Comments,</u> <u>Comments</u>

       Be sure to adequately comment your code.  While commenting every line is unnecessary, anything that takes
       advantage of side effects of operators, that creates changes that will be felt outside  of  the  function
       being  patched,  or  that others may find confusing should be documented.  If you are going to err, it is
       better to err on the side of adding too many comments than too few.

       The best comments explain <u>why</u> the code does what it does, not <u>what</u> <u>it</u> <u>does</u>.

       <u>Style</u>

       In general, please follow the particular style of the code you are patching.

       In particular, follow these general guidelines for patching Perl sources:

       •   4-wide indents for code, 2-wide indents for nested CPP "#define"s, with 8-wide tabstops.

       •   Use spaces for indentation, not tab characters.

           The codebase is a mixture of tabs and spaces for indentation, and  we  are  moving  to  spaces  only.
           Converting lines you're patching from 8-wide tabs to spaces will help this migration.

       •   Try not to exceed 79 columns

           In  general,  we target 80 column lines.  When sticking to 80 columns would lead to torturous code or
           rework, it's fine to go longer.  Try to keep your excess past 80 to a minimum.

       •   ANSI C prototypes

       •   Uncuddled elses and "K&amp;R" style for indenting control constructs

       •   No C++ style (//) comments

       •   Mark places that need to be revisited with XXX (and revisit often!)

       •   Opening brace lines up with "if" when conditional spans multiple  lines;  should  be  at  end-of-line
           otherwise

       •   In function definitions, name starts in column 0 (return value-type is on previous line)

       •   Single space after keywords that are followed by parens, no space between function name and following
           paren

       •   Avoid  assignments  in conditionals, but if they're unavoidable, use extra paren, e.g. "if (a &amp;&amp; (b =
           c)) ..."

       •   "return foo;" rather than "return(foo);"

       •   "if (!foo) ..." rather than "if (foo == FALSE) ..." etc.

       •   Do not declare variables using "register".  It may be counterproductive with modern compilers, and is
           deprecated in C++, under which the Perl source is regularly compiled.

       •   In-line functions that are in headers that are accessible to XS code  need  to  be  able  to  compile
           without  warnings  with commonly used extra compilation flags, such as gcc's "-Wswitch-default" which
           warns whenever a switch statement does not have a "default" case.  The use of these extra flags is to
           catch potential problems in legal C code, and is often  used  by  Perl  aggregators,  such  as  Linux
           distributors.

       <u>Test</u> <u>suite</u>

       If your patch changes code (rather than just changing documentation), you should also include one or more
       test  cases  which  illustrate the bug you're fixing or validate the new functionality you're adding.  In
       general, you should update an existing test file rather than create a new one.

       Your test suite additions  should  generally  follow  these  guidelines  (courtesy  of  Gurusamy  Sarathy
       &lt;<a href="mailto:gsar@activestate.com">gsar@activestate.com</a>&gt;):

       •   Know what you're testing.  Read the docs, and the source.

       •   Tend to fail, not succeed.

       •   Interpret results strictly.

       •   Use unrelated features (this will flush out bizarre interactions).

       •   Use non-standard idioms (otherwise you are not testing TIMTOWTDI).

       •   Avoid  using  hardcoded  test numbers whenever possible (the EXPECTED/GOT found in t/op/tie.t is much
           more maintainable, and gives better failure reports).

       •   Give meaningful error messages when a test fails.

       •   Avoid using qx// and <b>system()</b> unless you are testing for them.  If you do use them,  make  sure  that
           you cover _all_ perl platforms.

       •   Unlink any temporary files you create.

       •   Promote unforeseen warnings to errors with $SIG{__WARN__}.

       •   Be  sure  to use the libraries and modules shipped with the version being tested, not those that were
           already installed.

       •   Add comments to the code explaining what you are testing for.

       •   Make updating the '1..42' string unnecessary.  Or make sure that you update it.

       •   Test _all_ behaviors of a given operator, library, or function.

           Test all optional arguments.

           Test return values in various contexts (boolean, scalar, list, lvalue).

           Use both global and lexical variables.

           Don't forget the exceptional, pathological cases.

   <b>Patching</b> <b>a</b> <b>core</b> <b>module</b>
       This works just like patching anything else, with one extra consideration.

       Modules in the <u>cpan/</u> directory of the source tree are maintained outside of  the  Perl  core.   When  the
       author  updates the module, the updates are simply copied into the core.  See that module's documentation
       or its listing on &lt;https://metacpan.org/&gt; for more information on reporting bugs and submitting patches.

       In most cases, patches to modules in <u>cpan/</u> should be sent upstream and should not be applied to the  Perl
       core individually.  If a patch to a file in <u>cpan/</u> absolutely cannot wait for the fix to be made upstream,
       released  to  CPAN  and  copied  to  blead,  you  must  add  (or  update)  a  "CUSTOMIZED"  entry  in the
       <u>Porting/Maintainers.pl</u> file to flag that a local modification has been made.  See  <u>Porting/Maintainers.pl</u>
       for more details.

       In contrast, modules in the <u>dist/</u> directory are maintained in the core.

   <b>Updating</b> <b>perldelta</b>
       For  changes significant enough to warrant a <u>pod/perldelta.pod</u> entry, the porters will greatly appreciate
       it if you submit a delta entry along with your actual change.  Significant changes include, but  are  not
       limited to:

       •   Adding, deprecating, or removing core features

       •   Adding, deprecating, removing, or upgrading core or dual-life modules

       •   Adding new core tests

       •   Fixing security issues and user-visible bugs in the core

       •   Changes that might break existing code, either on the perl or C level

       •   Significant performance improvements

       •   Adding, removing, or significantly changing documentation in the <u>pod/</u> directory

       •   Important platform-specific changes

       Please  make  sure  you  add  the  perldelta  entry  to the right section within <u>pod/perldelta.pod</u>.  More
       information  on  how  to  write  good  perldelta  entries  is  available  in  the  "Style"   section   of
       <u>Porting/how_to_write_a_perldelta.pod</u>.

   <b>What</b> <b>makes</b> <b>for</b> <b>a</b> <b>good</b> <b>patch?</b>
       New  features  and  extensions  to the language can be contentious.  There is no specific set of criteria
       which determine what features get added, but here are some questions to consider when developing a patch:

       <u>Does</u> <u>the</u> <u>concept</u> <u>match</u> <u>the</u> <u>general</u> <u>goals</u> <u>of</u> <u>Perl?</u>

       Our goals include, but are not limited to:

       1.  Keep it fast, simple, and useful.

       2.  Keep features/concepts as orthogonal as possible.

       3.  No arbitrary limits (platforms, data sizes, cultures).

       4.  Keep it open and exciting to use/patch/advocate Perl everywhere.

       5.  Either assimilate new technologies, or build bridges to them.

       <u>Where</u> <u>is</u> <u>the</u> <u>implementation?</u>

       All the talk in the world is useless without an implementation.  In almost  every  case,  the  person  or
       people  who argue for a new feature will be expected to be the ones who implement it.  Porters capable of
       coding new features have their own agendas, and are not available to implement your (possibly good) idea.

       <u>Backwards</u> <u>compatibility</u>

       It's a cardinal sin to break existing Perl programs.  New warnings can be contentious--some  say  that  a
       program  that emits warnings is not broken, while others say it is.  Adding keywords has the potential to
       break programs, changing the meaning of existing token sequences or functions might break programs.

       The Perl 5 core includes mechanisms to help porters make backwards incompatible changes  more  compatible
       such as the feature and deprecate modules.  Please use them when appropriate.

       <u>Could</u> <u>it</u> <u>be</u> <u>a</u> <u>module</u> <u>instead?</u>

       Perl 5 has extension mechanisms, modules and XS, specifically to avoid the need to keep changing the Perl
       interpreter.   You  can  write  modules that export functions, you can give those functions prototypes so
       they can be called like built-in functions, you can even write XS code to  mess  with  the  runtime  data
       structures of the Perl interpreter if you want to implement really complicated things.

       Whenever  possible, new features should be prototyped in a CPAN module before they will be considered for
       the core.

       <u>Is</u> <u>the</u> <u>feature</u> <u>generic</u> <u>enough?</u>

       Is this something that only the submitter  wants  added  to  the  language,  or  is  it  broadly  useful?
       Sometimes, instead of adding a feature with a tight focus, the porters might decide to wait until someone
       implements the more generalized feature.

       <u>Does</u> <u>it</u> <u>potentially</u> <u>introduce</u> <u>new</u> <u>bugs?</u>

       Radical rewrites of large chunks of the Perl interpreter have the potential to introduce new bugs.

       <u>How</u> <u>big</u> <u>is</u> <u>it?</u>

       The  smaller  and more localized the change, the better.  Similarly, a series of small patches is greatly
       preferred over a single large patch.

       <u>Does</u> <u>it</u> <u>preclude</u> <u>other</u> <u>desirable</u> <u>features?</u>

       A patch is likely to be rejected if it closes off future avenues of development.  For instance,  a  patch
       that  placed  a  true  and  final interpretation on prototypes is likely to be rejected because there are
       still options for the future of prototypes that haven't been addressed.

       <u>Is</u> <u>the</u> <u>implementation</u> <u>robust?</u>

       Good patches (tight code, complete, correct) stand more chance of going in.  Sloppy or incorrect  patches
       might be placed on the back burner until fixes can be made, or they might be discarded altogether without
       further notice.

       <u>Is</u> <u>the</u> <u>implementation</u> <u>generic</u> <u>enough</u> <u>to</u> <u>be</u> <u>portable?</u>

       The worst patches make use of system-specific features.  It's highly unlikely that non-portable additions
       to the Perl language will be accepted.

       <u>Is</u> <u>the</u> <u>implementation</u> <u>tested?</u>

       Patches which change behaviour (fixing bugs or introducing new features) must include regression tests to
       verify that everything works as expected.

       Without  tests  provided  by the original author, how can anyone else changing perl in the future be sure
       that they haven't unwittingly broken the behaviour the patch implements? And without tests, how  can  the
       patch's  author  be confident that his/her hard work put into the patch won't be accidentally thrown away
       by someone in the future?

       <u>Is</u> <u>there</u> <u>enough</u> <u>documentation?</u>

       Patches without documentation are probably ill-thought out or incomplete.  No features can  be  added  or
       changed  without  documentation, so submitting a patch for the appropriate pod docs as well as the source
       code is important.

       <u>Is</u> <u>there</u> <u>another</u> <u>way</u> <u>to</u> <u>do</u> <u>it?</u>

       Larry said "Although the Perl Slogan is <u>There's</u> <u>More</u> <u>Than</u> <u>One</u> <u>Way</u> <u>to</u> <u>Do</u> <u>It</u>, I hesitate to make 10 ways to
       do something".  This is a tricky heuristic to navigate, though--one man's essential addition  is  another
       man's pointless cruft.

       <u>Does</u> <u>it</u> <u>create</u> <u>too</u> <u>much</u> <u>work?</u>

       Work  for  the committers, work for Perl programmers, work for module authors, ... Perl is supposed to be
       easy.

       <u>Patches</u> <u>speak</u> <u>louder</u> <u>than</u> <u>words</u>

       Working code is always preferred to pie-in-the-sky ideas.  A patch to add a feature stands a much  higher
       chance  of  making  it to the language than does a random feature request, no matter how fervently argued
       the request might be.  This ties into "Will it be useful?", as the fact that someone  took  the  time  to
       make the patch demonstrates a strong desire for the feature.

</pre><h4><b>TESTING</b></h4><pre>
       The core uses the same testing style as the rest of Perl, a simple "ok/not ok" run through Test::Harness,
       but there are a few special considerations.

       There  are  three  ways  to write a test in the core: Test::More, <u>t/test.pl</u> and ad hoc "print $test ? "ok
       42\n" : "not ok 42\n"".  The decision of which to use depends on what  part  of  the  test  suite  you're
       working  on.  This is a measure to prevent a high-level failure (such as Config.pm breaking) from causing
       basic functionality tests to fail.

       The <u>t/test.pl</u> library provides some of the features of Test::More, but avoids loading  most  modules  and
       uses as few core features as possible.

       If you write your own test, use the Test Anything Protocol &lt;https://testanything.org&gt;.

       •   <u>t/base</u>, <u>t/comp</u> and <u>t/opbasic</u>

           Since  we don't know if "require" works, or even subroutines, use ad hoc tests for these three.  Step
           carefully to avoid using the feature being tested.  Tests  in  <u>t/opbasic</u>,  for  instance,  have  been
           placed there rather than in <u>t/op</u> because they test functionality which <u>t/test.pl</u> presumes has already
           been demonstrated to work.

       •   All other subdirectories of <u>t/</u>

           Now that basic <b>require()</b> and subroutines are tested, you can use the <u>t/test.pl</u> library.

           You can also use certain libraries like Config conditionally, but be sure to skip the test gracefully
           if it's not there.

       •   Test files not found under <u>t/</u>

           This  category includes <u>.t</u> files underneath directories such as <u>dist</u>, <u>ext</u> and <u>lib</u>.  Since the core of
           Perl has now been tested, Test::More can and now should be used.  You can also use the full suite  of
           core  modules  in  the tests.  (As noted in "Patching a core module" above, changes to <u>.t</u> files found
           under <u>cpan/</u> should be submitted to the upstream maintainers of those modules.)

       When you say "make test", Perl uses the <u>t/TEST</u> program to run the test suite (except under Win32 where it
       uses <u>t/harness</u> instead).  All tests are run from the <u>t/</u> directory, <b>not</b> the directory which  contains  the
       test.  This causes some problems with the tests in <u>lib/</u>, so here's some opportunity for some patching.

       You  must  be  triply conscious of cross-platform concerns.  This usually boils down to using File::Spec,
       avoiding things like fork() and system() unless absolutely necessary,  and  not  assuming  that  a  given
       character  has  a  particular  ordinal value (code point) or that its UTF-8 representation is composed of
       particular bytes.

       There are several functions available to specify characters and  code  points  portably  in  tests.   The
       always-preloaded  functions utf8::unicode_to_native() and its inverse utf8::native_to_unicode() take code
       points and translate appropriately.  The file  <u>t/charset_tools.pl</u>  has  several  functions  that  can  be
       useful.   It has versions of the previous two functions that take strings as inputs -- not single numeric
       code points: uni_to_native() and native_to_uni().  If you must look at the individual bytes comprising  a
       UTF-8  encoded  string, byte_utf8a_to_utf8n() takes as input a string of those bytes encoded for an ASCII
       platform,   and   returns   the   equivalent   string   in   the   native   platform.     For    example,
       byte_utf8a_to_utf8n("\xC2\xA0") returns the byte sequence on the current platform that form the UTF-8 for
       "U+00A0",  since  "\xC2\xA0" are the UTF-8 bytes on an ASCII platform for that code point.  This function
       returns "\xC2\xA0" on an ASCII platform, and "\x80\x41" on an EBCDIC 1047 one.

       But easiest is, if the character is specifiable as a literal, like "A" or "%", to use  that;  if  not  so
       specificable,  you  can  use  "\N{}"  ,  if the side effects aren't troublesome.  Simply specify all your
       characters in hex, using "\N{U+ZZ}" instead of "\xZZ".  "\N{}" is the Unicode  name,  and  so  it  always
       gives  you the Unicode character.  "\N{U+41}" is the character whose Unicode code point is 0x41, hence is
       'A' on all platforms.  The side effects are:

       •   These select Unicode rules.  That  means  that  in  double-quotish  strings,  the  string  is  always
           converted to UTF-8 to force a Unicode interpretation (you can utf8::downgrade() afterwards to convert
           back  to  non-UTF8,  if possible).  In regular expression patterns, the conversion isn't done, but if
           the character set modifier would otherwise be "/d", it is changed to "/u".

       •   If you use the form "\N{<u>character</u> <u>name</u>}", the charnames module gets automatically loaded.   This  may
           not be suitable for the test level you are doing.

       If  you  are testing locales (see perllocale), there are helper functions in <u>t/loc_tools.pl</u> to enable you
       to see what locales there are on the current platform.

   <b>Special</b> <b>"make</b> <b>test"</b> <b>targets</b>
       There are various special make targets that can be used  to  test  Perl  slightly  differently  than  the
       standard  "test"  target.   Not  all  them  are  expected to give a 100% success rate.  Many of them have
       several aliases, and many of them are not available on certain operating systems.

       •   test_porting

           This runs some basic sanity tests on the source tree and helps catch basic errors before you submit a
           patch.

       •   minitest

           Run <u>miniperl</u> on <u>t/base</u>, <u>t/comp</u>, <u>t/cmd</u>, <u>t/run</u>, <u>t/io</u>, <u>t/op</u>, <u>t/uni</u> and <u>t/mro</u> tests.

           <u>miniperl</u> is a minimalistic perl built to bootstrap building extensions, utilties, documentation  etc.
           It  doesn't  support  dynamic  loading and depending on the point in the build process will only have
           access to a limited set of core modules.  <u>miniperl</u> is not intended for day to day use.

       •   test.valgrind check.valgrind

           (Only in Linux) Run all the tests using the memory leak + naughty memory access tool "valgrind".  The
           log files will be named <u>testname.valgrind</u>.

       •   test_harness

           Run the test suite with the <u>t/harness</u> controlling program, instead  of  <u>t/TEST</u>.   <u>t/harness</u>  is  more
           sophisticated,  and  uses  the  Test::Harness  module, thus using this test target supposes that perl
           mostly works.  The main advantage for our purposes is that it prints a  detailed  summary  of  failed
           tests at the end.  Also, unlike <u>t/TEST</u>, it doesn't redirect stderr to stdout.

           Note  that  under  Win32  <u>t/harness</u>  is  always  used  instead  of  <u>t/TEST</u>,  so  there  is no special
           "test_harness" target.

           Under the Unix build process you may use the TEST_ARGS and TEST_FILES parameters  to  pass  arguments
           through to the underlying harness call.  This means that for instance you could do

               make test_harness TEST_ARGS="-v -re pat"

           which  would  make,  and then run the test harness in verbose mode over files which contain "pat". Or
           you could do

               make test_harness TEST_ARGS="-torture" TEST_FILES="op/*.t"

           and run torture tests on files matching the glob "op/*.t".

           Under Win32's "test" target you may use the TEST_SWITCHES and  TEST_FILES  environment  variables  to
           control the behaviour of <u>t/harness</u>.  This means you can say

               nmake test TEST_FILES="op/*.t"
               nmake test TEST_SWITCHES="-torture" TEST_FILES="op/*.t"

           Note  that  for  compatibility  with the unix build process TEST_ARGS may also be used instead of the
           traditional TEST_SWITCHES argument.

       •   test-notty test_notty

           Sets PERL_SKIP_TTY_TEST to true before running normal test.

   <b>Parallel</b> <b>tests</b>
       The core distribution can now run its regression tests in parallel on Unix-like  and  Windows  platforms.
       On  Unix,  instead  of running "make test", set "TEST_JOBS" in your environment to the number of tests to
       run in parallel, and run "make test_harness".  On a Bourne-like shell, this can be done as

           TEST_JOBS=3 make test_harness  # Run 3 tests in parallel

       An environment variable is used, rather than parallel make itself, because TAP::Harness needs to be  able
       to  schedule individual non-conflicting test scripts itself, and there is no standard interface to "make"
       utilities to interact with their job schedulers.

       Tests are normally run in a logical order, with the sanity tests first, then the main tests of  the  Perl
       core  functionality, then the tests for the non-core modules.  On many-core systems, this may not use the
       hardware as effectively as possible.  By also specifying

        TEST_JOBS=19 PERL_TEST_HARNESS_ASAP=1 make -j19 test_harness

       you signal that you want the tests to finish in wall-clock time as short as possible.  After  the  sanity
       tests  are  completed, this causes the remaining ones to be packed into the available cores as tightly as
       we know how.  This has its greatest effect on slower, many-core systems.  Throughput was sped up  by  20%
       on an outmoded 24-core system; less on more recent faster ones with fewer cores.

       Note  that  the  command  line above added a "-j" parameter to make, so as to cause parallel compilation.
       This may or may not work on your platform.

       Normally data on how long tests take is stored in <u>t/test_state</u>, however you can  change  this  to  use  a
       different  filename by setting the "PERL_TEST_STATE_FILE" environment variable to something different, or
       to a false value (0 or the empty string) to disable use of the state mechanism entirely.   There  are  no
       protections against the format of the state file changing over time, so if you have any issues related to
       this  file it is up to you to delete the file manually and then let the harness recreate it, although the
       file format does not change frequently so this should not be necessary very often.

   <b>Running</b> <b>tests</b> <b>by</b> <b>hand</b>
       You can run part of the test suite by hand by using one of the following commands from the <u>t/</u> directory:

           ./perl -I..<a href="file:/lib">/lib</a> TEST list-of-.t-files

       or

           ./perl -I..<a href="file:/lib">/lib</a> harness list-of-.t-files

       (If you don't specify test scripts, the whole test suite will be run.)

   <b>Using</b> <u><b>t/harness</b></u> <b>for</b> <b>testing</b>
       If you use "harness" for testing, you have several command line options available to you.  The  arguments
       are as follows, and are in the order that they must appear if used together.

           harness -v -torture -re=pattern LIST OF FILES TO TEST
           harness -v -torture -re LIST OF PATTERNS TO MATCH

       If  "LIST  OF  FILES TO TEST" is omitted, the file list is obtained from the manifest.  The file list may
       include shell wildcards which will be expanded out.

       •   -v

           Run the tests under verbose mode so you can see what tests were run, and debug output.

       •   -torture

           Run the torture tests as well as the normal set.

       •   -re=PATTERN

           Filter the file list so that all the test files run match PATTERN.  Note that this form  is  distinct
           from the <b>-re</b> <b>LIST</b> <b>OF</b> <b>PATTERNS</b> form below in that it allows the file list to be provided as well.

       •   -re LIST OF PATTERNS

           Filter  the file list so that all the test files run match /(LIST|OF|PATTERNS)<a href="file:/.">/.</a>  Note that with this
           form the patterns are joined by '|' and you cannot supply a list of files, instead the test files are
           obtained from the MANIFEST.

       You can run an individual test by a command similar to

           ./perl -I..<a href="file:/lib">/lib</a> path/to/foo.t

       except that the harnesses set up some environment variables that may affect the execution of the test:

       •   PERL_CORE=1

           indicates that we're running this test as part of the perl core  test  suite.   This  is  useful  for
           modules that have a dual life on CPAN.

       •   PERL_DESTRUCT_LEVEL=2

           is set to 2 if it isn't set already (see "PERL_DESTRUCT_LEVEL" in perlhacktips).

       •   PERL

           (used  only  by  <u>t/TEST</u>) if set, overrides the path to the perl executable that should be used to run
           the tests (the default being <u>./perl</u>).

       •   PERL_SKIP_TTY_TEST

           if set, tells to skip the tests that need  a  terminal.   It's  actually  set  automatically  by  the
           Makefile, but can also be forced artificially by running 'make test_notty'.

       <u>Other</u> <u>environment</u> <u>variables</u> <u>that</u> <u>may</u> <u>influence</u> <u>tests</u>

       •   PERL_TEST_Net_Ping

           Setting  this  variable runs all the Net::Ping modules tests, otherwise some tests that interact with
           the outside world are skipped.  See perl58delta.

       •   PERL_TEST_NOVREXX

           Setting this variable skips the vrexx.t tests for OS2::REXX.

       •   PERL_TEST_NUMCONVERTS

           This sets a variable in op/numconvert.t.

       •   PERL_TEST_MEMORY

           Setting this variable includes the tests in <u>t/bigmem/</u>.  This should be set to the number of gigabytes
           of memory available for testing, eg.  "PERL_TEST_MEMORY=4" indicates that tests that require 4GiB  of
           available memory can be run safely.

       See  also  the  documentation for the Test and Test::Harness modules, for more environment variables that
       affect testing.

   <b>Performance</b> <b>testing</b>
       The file <u>t/perf/benchmarks</u> contains snippets of perl code which are intended to be benchmarked  across  a
       range  of  perls by the <u>Porting/bench.pl</u> tool. If you fix or enhance a performance issue, you may want to
       add a representative code sample to the file, then run <u>bench.pl</u> against the previous and current perls to
       see what difference it has made, and whether anything else has slowed down as a consequence.

       The file <u>t/perf/opcount.t</u> is designed to test whether a particular code snippet has been compiled into an
       optree  containing  specified  numbers  of  particular  op  types.  This  is  good  for  testing  whether
       optimisations  which alter ops, such as converting an "aelem" op into an "aelemfast" op, are really doing
       that.

       The files <u>t/perf/speed.t</u> and <u>t/re/speed.t</u> are designed to test things that run thousands of times  slower
       if  a particular optimisation is broken (for example, the utf8 length cache on long utf8 strings).  Add a
       test that will take a fraction of a second normally, and minutes otherwise, causing the test file to time
       out on failure.

   <b>Building</b> <b>perl</b> <b>at</b> <b>older</b> <b>commits</b>
       In the course of hacking on the Perl core distribution, you may have occasion  to  configure,  build  and
       test perl at an old commit.  Sometimes "make" will fail during this process.  If that happens, you may be
       able  to salvage the situation by using the Devel::PatchPerl library from CPAN (not included in the core)
       to bring the source code at that commit to a buildable state.

       Here's   a   real   world    example,    taken    from    work    done    to    resolve    perl    #10118
       &lt;https://github.com/Perl/perl5/issues/10118&gt;.    Use   of   <u>Porting/bisect.pl</u>   had   identified   commit
       "ba77e4cc9d1ceebf472c9c5c18b2377ee47062e6" as the commit in which a bug was corrected.  To confirm, a P5P
       developer wanted to configure and build  perl  at  commit  "ba77e4c^"  (presumably  "bad")  and  then  at
       "ba77e4c" (presumably "good").  Normal configuration and build was attempted:

           $ sh ./Configure -des -Dusedevel
           $ make test_prep

       "make", however, failed with output (excerpted) like this:

           cc -fstack-protector -L/usr/local/lib -o miniperl \
             gv.o toke.o perly.o pad.o regcomp.o dump.o util.o \
             mg.o reentr.o mro.o hv.o av.o run.o pp_hot.o sv.o \
             pp.o scope.o pp_ctl.o pp_sys.o doop.o doio.o regexec.o \
             utf8.o taint.o deb.o universal.o globals.o perlio.o \
             numeric.o mathoms.o locale.o pp_pack.o pp_sort.o  \
             miniperlmain.o opmini.o perlmini.o
           pp.o: In function `Perl_pp_pow':
           pp.c:(.text+0x2db9): undefined reference to `pow'
           ...
           collect2: error: ld returned 1 exit status
           makefile:348: recipe for target 'miniperl' failed
           make: *** [miniperl] Error 1

       Another P5P contributor recommended installation and use of Devel::PatchPerl for this situation, first to
       determine  the  version of perl at the commit in question, then to patch the source code at that point to
       facilitate a build.

        $ perl -MDevel::PatchPerl -e \
            'print Devel::PatchPerl-&gt;determine_version("/path/to/sourcecode"),
                   "\n";'
        5.11.1
        $ perl -MDevel::PatchPerl -e \
            'Devel::PatchPerl-&gt;patch_source("5.11.1", "/path/to/sourcecode");'

       Once the source was patched, "./Configure" and "make test_prep" were called and  completed  successfully,
       enabling confirmation of the findings in RT #72414.

</pre><h4><b>MORE</b> <b>READING</b> <b>FOR</b> <b>GUTS</b> <b>HACKERS</b></h4><pre>
       To hack on the Perl guts, you'll need to read the following things:

       •   perlsource

           An overview of the Perl source tree.  This will help you find the files you're looking for.

       •   perlinterp

           An overview of the Perl interpreter source code and some details on how Perl does what it does.

       •   perlhacktut

           This  document  walks through the creation of a small patch to Perl's C code.  If you're just getting
           started with Perl core hacking, this will help you understand how it works.

       •   perlhacktips

           More details on hacking the Perl core.  This document focuses on lower level details such as  how  to
           write tests, compilation issues, portability, debugging, etc.

           If you plan on doing serious C hacking, make sure to read this.

       •   perlguts

           This  is of paramount importance, since it's the documentation of what goes where in the Perl source.
           Read it over a couple of times and it might start to make sense - don't  worry  if  it  doesn't  yet,
           because  the  best way to study it is to read it in conjunction with poking at Perl source, and we'll
           do that later on.

           Gisle Aas's "illustrated perlguts", also known as <u>illguts</u>, has very helpful pictures:

           &lt;https://metacpan.org/release/RURBAN/illguts-0.49&gt;

       •   perlxstut and perlxs

           A working knowledge of XSUB programming is incredibly useful for core hacking; XSUBs  use  techniques
           drawn  from  the  PP code, the portion of the guts that actually executes a Perl program.  It's a lot
           gentler to learn those techniques from simple examples and explanation than from the core itself.

       •   perlapi

           The documentation for the Perl API explains what some of the internal functions do, as  well  as  the
           many macros used in the source.

       •   <u>Porting/pumpkin.pod</u>

           This  is  a collection of words of wisdom for a Perl porter; some of it is only useful to the pumpkin
           holders, but most of it applies to anyone wanting to go about Perl development.

</pre><h4><b>CPAN</b> <b>TESTERS</b> <b>AND</b> <b>PERL</b> <b>SMOKERS</b></h4><pre>
       The CPAN testers ( &lt;https://cpantesters.org/&gt; ) are a group of volunteers who  test  CPAN  modules  on  a
       variety of platforms.

       Perl          Smokers          (          &lt;https://www.nntp.perl.org/group/perl.daily-build/&gt;         and
       &lt;https://www.nntp.perl.org/group/perl.daily-build.reports/&gt; ) automatically test Perl source releases  on
       platforms with various configurations.

       Both  efforts  welcome  volunteers.   In  order to get involved in smoke testing of the perl itself visit
       &lt;https://metacpan.org/release/Test-Smoke&gt;.   In  order  to  start  smoke  testing  CPAN   modules   visit
       &lt;https://metacpan.org/release/CPANPLUS-YACSmoke&gt;    or   &lt;https://metacpan.org/release/minismokebox&gt;   or
       &lt;https://metacpan.org/release/CPAN-Reporter&gt;.

</pre><h4><b>WHAT</b> <b>NEXT?</b></h4><pre>
       If you've read all the documentation in the document and the ones listed above, you're more than ready to
       hack on Perl.

       Here's some more recommendations

       •   Subscribe to perl5-porters, follow the patches and try and understand them; don't be afraid to ask if
           there's a portion you're not clear on - who knows, you may unearth a bug in the patch...

       •   Do read the README associated with your operating system, e.g.  README.aix on the IBM AIX OS.   Don't
           hesitate  to  supply  patches  to  that  README if you find anything missing or changed over a new OS
           release.

       •   Find an area of Perl that seems interesting to you, and see if you can work out how it  works.   Scan
           through  the  source,  and  step  over  it  in the debugger.  Play, poke, investigate, fiddle! You'll
           probably get to understand not just your chosen area but a much wider range  of  <u>perl</u>'s  activity  as
           well, and probably sooner than you'd think.

   <b>"The</b> <b>Road</b> <b>goes</b> <b>ever</b> <b>on</b> <b>and</b> <b>on,</b> <b>down</b> <b>from</b> <b>the</b> <b>door</b> <b>where</b> <b>it</b> <b>began."</b>
       If  you can do these things, you've started on the long road to Perl porting.  Thanks for wanting to help
       make Perl better - and happy hacking!

   <b>Metaphoric</b> <b>Quotations</b>
       If you recognized the quote about the Road above, you're in luck.

       Most software projects begin each file with a literal description of each file's purpose.   Perl  instead
       begins each with a literary allusion to that file's purpose.

       Like  chapters  in  many  books, all top-level Perl source files (along with a few others here and there)
       begin with an epigrammatic inscription that alludes,  indirectly  and  metaphorically,  to  the  material
       you're about to read.

       Quotations  are  taken  from writings of J.R.R. Tolkien pertaining to his Legendarium, almost always from
       <u>The</u> <u>Lord</u> <u>of</u> <u>the</u> <u>Rings</u>.  Chapters and page numbers are given using the following editions:

       •   <u>The</u> <u>Hobbit</u>, by J.R.R. Tolkien.  The hardcover, 70th-anniversary edition of 2007 was  used,  published
           in the UK by Harper Collins Publishers and in the US by the Houghton Mifflin Company.

       •   <u>The</u>  <u>Lord</u> <u>of</u> <u>the</u> <u>Rings</u>, by J.R.R. Tolkien.  The hardcover, 50th-anniversary edition of 2004 was used,
           published in the UK by Harper Collins Publishers and in the US by the Houghton Mifflin Company.

       •   <u>The</u> <u>Lays</u> <u>of</u> <u>Beleriand</u>, by J.R.R. Tolkien and published posthumously by his son and literary executor,
           C.J.R. Tolkien, being the 3rd of the 12 volumes in Christopher's mammoth  <u>History</u>  <u>of</u>  <u>Middle</u>  <u>Earth</u>.
           Page  numbers  derive from the hardcover edition, first published in 1983 by George Allen &amp; Unwin; no
           page numbers changed for the special 3-volume omnibus edition of  2002  or  the  various  trade-paper
           editions, all again now by Harper Collins or Houghton Mifflin.

       Other  JRRT  books  fair  game  for  quotes  would  thus  include  <u>The</u>  <u>Adventures</u>  <u>of</u>  <u>Tom</u> <u>Bombadil</u>, <u>The</u>
       <u>Silmarillion</u>, <u>Unfinished</u> <u>Tales</u>, and <u>The</u> <u>Tale</u> <u>of</u> <u>the</u> <u>Children</u> <u>of</u> <u>Hurin</u>, all  but  the  first  posthumously
       assembled  by  CJRT.  But <u>The</u> <u>Lord</u> <u>of</u> <u>the</u> <u>Rings</u> itself is perfectly fine and probably best to quote from,
       provided you can find a suitable quote there.

       So if you were to supply a new, complete, top-level source file to add to Perl,  you  should  conform  to
       this  peculiar  practice  by  yourself  selecting  an  appropriate  quotation from Tolkien, retaining the
       original spelling and punctuation and using the same format the rest of the quotes are in.  Indirect  and
       oblique is just fine; remember, it's a metaphor, so being meta is, after all, what it's for.

</pre><h4><b>AUTHOR</b></h4><pre>
       This document was originally written by Nathan Torkington, and is maintained by the perl5-porters mailing
       list.

perl v5.40.1                                       2025-04-14                                        <u><a href="../man1/PERLHACK.1.html">PERLHACK</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>