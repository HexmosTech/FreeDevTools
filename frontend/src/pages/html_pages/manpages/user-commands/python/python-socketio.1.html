<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>python-socketio - python-socketio Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python3-socketio">python3-socketio_5.12.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       python-socketio - python-socketio Documentation

       This  projects  implements  Socket.IO  clients  and  servers that can run standalone or integrated with a
       variety of Python web frameworks.

</pre><h4><b>GETTING</b> <b>STARTED</b></h4><pre>
   <b>What</b> <b>is</b> <b>Socket.IO?</b>
       Socket.IO is a transport protocol that enables real-time bidirectional event-based communication  between
       clients  (typically,  though  not always, web browsers) and a server. The official implementations of the
       client and server components are written in JavaScript. This package provides Python  implementations  of
       both, each with standard and asyncio variants.

   <b>Version</b> <b>compatibility</b>
       The  Socket.IO  protocol  has  been  through a number of revisions, and some of these introduced backward
       incompatible changes, which means that the client  and  the  server  must  use  compatible  versions  for
       everything to work.

       If you are using the Python client and server, the easiest way to ensure compatibility is to use the same
       version  of  this  package  for the client and the server. If you are using this package with a different
       client or server, then you must ensure the versions are compatible.

       The version compatibility chart below maps versions  of  this  package  to  versions  of  the  JavaScript
       reference implementation and the versions of the Socket.IO and Engine.IO protocols.
        ┌───────────────────┬─────────────────────┬─────────────────────┬─────────────────┬─────────────────┐
        │ JavaScript        │ Socket.IO  protocol │ Engine.IO  protocol │ python-socketio │ python-engineio │
        │ Socket.IO version │ revision            │ revision            │ version         │ version         │
        ├───────────────────┼─────────────────────┼─────────────────────┼─────────────────┼─────────────────┤
        │ 0.9.x             │ 1, 2                │ 1, 2                │ Not supported   │ Not supported   │
        ├───────────────────┼─────────────────────┼─────────────────────┼─────────────────┼─────────────────┤
        │ 1.x and 2.x       │ 3, 4                │ 3                   │ 4.x             │ 3.x             │
        ├───────────────────┼─────────────────────┼─────────────────────┼─────────────────┼─────────────────┤
        │ 3.x and 4.x       │ 5                   │ 4                   │ 5.x             │ 4.x             │
        └───────────────────┴─────────────────────┴─────────────────────┴─────────────────┴─────────────────┘

   <b>Client</b> <b>Examples</b>
       The example that follows shows a simple Python client:

          import socketio

          sio = socketio.Client()

          @sio.event
          def connect():
              print('connection established')

          @sio.event
          def my_message(data):
              print('message received with ', data)
              sio.emit('my response', {'response': 'my response'})

          @sio.event
          def disconnect():
              print('disconnected from server')

          sio.connect('<a href="http://localhost">http://localhost</a>:5000')
          sio.wait()

       Below is a similar client, coded for <b>asyncio</b> (Python 3.5+ only):

          import asyncio
          import socketio

          sio = socketio.AsyncClient()

          @sio.event
          async def connect():
              print('connection established')

          @sio.event
          async def my_message(data):
              print('message received with ', data)
              await sio.emit('my response', {'response': 'my response'})

          @sio.event
          async def disconnect():
              print('disconnected from server')

          async def main():
              await sio.connect('<a href="http://localhost">http://localhost</a>:5000')
              await sio.wait()

          if __name__ == '__main__':
              asyncio.run(main())

   <b>Client</b> <b>Features</b>
       • Can  connect  to  other Socket.IO servers that are compatible with the JavaScript Socket.IO 1.x and 2.x
         releases. Work to support release 3.x is in progress.

       • Compatible with Python 3.6+.

       • Two versions of the client, one for standard Python and another for asyncio.

       • Uses an event-based architecture implemented with decorators that hides the details of the protocol.

       • Implements HTTP long-polling and WebSocket transports.

       • Automatically reconnects to the server if the connection is dropped.

   <b>Server</b> <b>Examples</b>
       The following application is a basic server example that uses the Eventlet asynchronous server:

          import eventlet
          import socketio

          sio = socketio.Server()
          app = socketio.WSGIApp(sio, static_files={
              '/': {'content_type': 'text/html', 'filename': 'index.html'}
          })

          @sio.event
          def connect(sid, environ):
              print('connect ', sid)

          @sio.event
          def my_message(sid, data):
              print('message ', data)

          @sio.event
          def disconnect(sid):
              print('disconnect ', sid)

          if __name__ == '__main__':
              eventlet.wsgi.server(eventlet.listen(('', 5000)), app)

       Below is a similar application, coded for <b>asyncio</b> (Python 3.5+ only) and the Uvicorn web server:

          from aiohttp import web
          import socketio

          sio = socketio.AsyncServer()
          app = web.Application()
          sio.attach(app)

          async def index(request):
              """Serve the client-side application."""
              with open('index.html') as f:
                  return web.Response(text=f.read(), content_type='text/html')

          @sio.event
          def connect(sid, environ):
              print("connect ", sid)

          @sio.event
          async def chat_message(sid, data):
              print("message ", data)

          @sio.event
          def disconnect(sid):
              print('disconnect ', sid)

          app.router.add_static('/static', 'static')
          app.router.add_get('/', index)

          if __name__ == '__main__':
              web.run_app(app)

   <b>Server</b> <b>Features</b>
       • Can connect to servers running other Socket.IO clients that are compatible with the  JavaScript  client
         versions 1.x and 2.x. Work to support the 3.x release is in progress.

       • Compatible with Python 3.6+.

       • Two versions of the server, one for standard Python and another for asyncio.

       • Supports large number of clients even on modest hardware due to being asynchronous.

       • Can be hosted on any <u>WSGI</u> or <u>ASGI</u> web server including <u>Gunicorn</u>, <u>Uvicorn</u>, <u>eventlet</u> and <u>gevent</u>.

       • Can be integrated with WSGI applications written in frameworks such as Flask, Django, etc.

       • Can be integrated with <u>aiohttp</u>, <u>sanic</u> and <u>tornado</u> <b>asyncio</b> applications.

       • Broadcasting of messages to all connected clients, or to subsets of them assigned to "rooms".

       • Optional support for multiple servers, connected through a messaging queue such as Redis or RabbitMQ.

       • Send messages to clients from external processes, such as Celery workers or auxiliary scripts.

       • Event-based architecture implemented with decorators that hides the details of the protocol.

       • Support for HTTP long-polling and WebSocket transports.

       • Support for XHR2 and XHR browsers.

       • Support for text and binary messages.

       • Support for gzip and deflate HTTP compression.

       • Configurable CORS responses, to avoid cross-origin problems with browsers.

</pre><h4><b>THE</b> <b>SOCKET.IO</b> <b>CLIENTS</b></h4><pre>
       This package contains two Socket.IO clients:

       • a "simple" client, which provides a straightforward API that is sufficient for most applications

       • an "event-driven" client, which provides access to all the features of the Socket.IO protocol

       Each  of  these  clients  comes  in  two  variants:  one for the standard Python library, and another for
       asynchronous applications built with the <b>asyncio</b> package.

   <b>Installation</b>
       To install the standard Python client along with its dependencies, use the following command:

          pip install "python-socketio[client]"

       If instead you plan on using the <b>asyncio</b> client, then use this:

          pip install "python-socketio[asyncio_client]"

   <b>Using</b> <b>the</b> <b>Simple</b> <b>Client</b>
       The advantage of the simple client is that it abstracts away the logic required to maintain  a  Socket.IO
       connection. This client handles disconnections and reconnections in a completely transparent way, without
       adding any complexity to the application.

   <b>Creating</b> <b>a</b> <b>Client</b> <b>Instance</b>
       The easiest way to create a Socket.IO client is to use the context manager interface:

          import socketio

          # standard Python
          with socketio.SimpleClient() as sio:
              # ... connect to a server and use the client
              # ... no need to manually disconnect!

          # asyncio
          async with socketio.AsyncSimpleClient() as sio:
              # ... connect to a server and use the client
              # ... no need to manually disconnect!

       With  this  usage the context manager will ensure that the client is properly disconnected before exiting
       the <b>with</b> or <b>async</b> <b>with</b> block.

       If preferred, a client can be manually instantiated:

          import socketio

          # standard Python
          sio = socketio.SimpleClient()

          # asyncio
          sio = socketio.AsyncSimpleClient()

   <b>Connecting</b> <b>to</b> <b>a</b> <b>Server</b>
       The connection to a server is established by calling the <b>connect()</b> method:

          sio.connect('<a href="http://localhost">http://localhost</a>:5000')

       In the case of the <b>asyncio</b> client, the method is a coroutine:

          await sio.connect('<a href="http://localhost">http://localhost</a>:5000')

       By default the client first connects to the server using the long-polling transport, and then attempts to
       upgrade the connection to use  WebSocket.  To  connect  directly  using  WebSocket,  use  the  <b>transports</b>
       argument:

          sio.connect('<a href="http://localhost">http://localhost</a>:5000', transports=['websocket'])

       Upon  connection,  the  server  assigns the client a unique session identifier.  The application can find
       this identifier in the <b>sid</b> attribute:

          print('my sid is', sio.sid)

       The Socket.IO transport that is used in the connection can be obtained from the <b>transport</b> attribute:

          print('my transport is', sio.transport)

       The transport is given as a string, and can be either <b>'websocket'</b> or <b>'polling'</b>.

   <b>TLS/SSL</b> <b>Support</b>
       The client supports TLS/SSL connections. To enable it, use a <b>https://</b> connection URL:

          sio.connect('https://example.com')

       Or when using <b>asyncio</b>:

          await sio.connect('https://example.com')

       The client verifies server certificates by default. Consult the documentation for the event-driven client
       for information on how to customize this behavior.

   <b>Emitting</b> <b>Events</b>
       The client can emit an event to the server using the <b>emit()</b> method:

          sio.emit('my message', {'foo': 'bar'})

       Or in the case of <b>asyncio</b>, as a coroutine:

          await sio.emit('my message', {'foo': 'bar'})

       The arguments provided to the method are the name of the event to emit and  the  optional  data  that  is
       passed  on to the server. The data can be of type <b>str</b>, <b>bytes</b>, <b>dict</b>, <b>list</b> or <b>tuple</b>. When sending a <b>list</b> or
       a <b>tuple</b>, the elements in it need to be of any allowed types except <b>tuple</b>.  When  a  tuple  is  used,  the
       elements of the tuple will be passed as individual arguments to the server-side event handler function.

   <b>Receiving</b> <b>Events</b>
       The client can wait for the server to emit an event with the <b>receive()</b> method:

          event = sio.receive()
          print(f'received event: "{event[0]}" with arguments {event[1:]}')

       When using <b>asyncio</b>, this method needs to be awaited:

          event = await sio.receive()
          print(f'received event: "{event[0]}" with arguments {event[1:]}')

       The  return  value  of  <b>receive()</b>  is a list. The first element of this list is the event name, while the
       remaining elements are the arguments passed by the server.

       With the usage shown above, the <b>receive()</b> method will return only when an  event  is  received  from  the
       server. An optional timeout in seconds can be passed to prevent the client from waiting forever:

          from socketio.exceptions import TimeoutError

          try:
              event = sio.receive(timeout=5)
          except TimeoutError:
              print('timed out waiting for event')
          else:
              print('received event:', event)

       Or with <b>asyncio</b>:

          from socketio.exceptions import TimeoutError

          try:
              event = await sio.receive(timeout=5)
          except TimeoutError:
              print('timed out waiting for event')
          else:
              print('received event:', event)

   <b>Disconnecting</b> <b>from</b> <b>the</b> <b>Server</b>
       At  any  time  the  client  can  request  to be disconnected from the server by invoking the <b>disconnect()</b>
       method:

          sio.disconnect()

       For the <b>asyncio</b> client this is a coroutine:

          await sio.disconnect()

   <b>Debugging</b> <b>and</b> <b>Troubleshooting</b>
       To help you debug issues, the client can be configured to output logs to the terminal:

          import socketio

          # standard Python
          sio = socketio.Client(logger=True, engineio_logger=True)

          # asyncio
          sio = socketio.AsyncClient(logger=True, engineio_logger=True)

       The <b>logger</b> argument controls logging related to the Socket.IO protocol,  while  <b>engineio_logger</b>  controls
       logs  that  originate  in the low-level Engine.IO transport. These arguments can be set to <b>True</b> to output
       logs to <b>stderr</b>, or to an object compatible with Python's <b>logging</b> package where the logs should be emitted
       to. A value of <b>False</b> disables logging.

       Logging can help identify the cause of connection problems, unexpected disconnections and other issues.

   <b>Using</b> <b>the</b> <b>Event-Driven</b> <b>Client</b>
   <b>Creating</b> <b>a</b> <b>Client</b> <b>Instance</b>
       To instantiate an Socket.IO client, simply create an instance of the appropriate client class:

          import socketio

          # standard Python
          sio = socketio.Client()

          # asyncio
          sio = socketio.AsyncClient()

   <b>Defining</b> <b>Event</b> <b>Handlers</b>
       The Socket.IO protocol is event based. When a server wants to communicate  with  a  client  it  <u>emits</u>  an
       event.  Each event has a name, and a list of arguments. The client registers event handler functions with
       the <b>socketio.Client.event()</b> or <b>socketio.Client.on()</b> decorators:

          @sio.event
          def message(data):
              print('I received a message!')

          @sio.on('my message')
          def on_message(data):
              print('I received a message!')

       In the first example the event name is obtained from the name of the handler function. The second example
       is slightly more verbose, but it allows the event name to be different  than  the  function  name  or  to
       include characters that are illegal in function names, such as spaces.

       For the <b>asyncio</b> client, event handlers can be regular functions as above, or can also be coroutines:

          @sio.event
          async def message(data):
              print('I received a message!')

       If the server includes arguments with an event, those are passed to the handler function as arguments.

   <b>Catch-All</b> <b>Event</b> <b>and</b> <b>Namespace</b> <b>Handlers</b>
       A "catch-all" event handler is invoked for any events that do not have an event handler. You can define a
       catch-all handler using <b>'*'</b> as event name:

          @sio.on('*')
          def any_event(event, sid, data):
               pass

       Asyncio servers can also use a coroutine:

          @sio.on('*')
          async def any_event(event, sid, data):
              pass

       A  catch-all  event  handler receives the event name as a first argument. The remaining arguments are the
       same as for a regular event handler.

       The <b>connect</b> and <b>disconnect</b> events have to be defined explicitly and are not invoked on a catch-all  event
       handler.

       Similarily,  a  "catch-all" namespace handler is invoked for any connected namespaces that do not have an
       explicitly defined event handler. As with catch-all events, <b>'*'</b> is used in place of a namespace:

          @sio.on('my_event', namespace='*')
          def my_event_any_namespace(namespace, sid, data):
              pass

       For these events, the namespace is passed as first argument, followed by the  regular  arguments  of  the
       event.

       Lastly, it is also possible to define a "catch-all" handler for all events on all namespaces:

          @sio.on('*', namespace='*')
          def any_event_any_namespace(event, namespace, sid, data):
              pass

       Event handlers with catch-all events and namespaces receive the event name and the namespace as first and
       second arguments.

   <b>Connect,</b> <b>Connect</b> <b>Error</b> <b>and</b> <b>Disconnect</b> <b>Event</b> <b>Handlers</b>
       The  <b>connect</b>,  <b>connect_error</b>  and  <b>disconnect</b>  events  are special; they are invoked automatically when a
       client connects or disconnects from the server:

          @sio.event
          def connect():
              print("I'm connected!")

          @sio.event
          def connect_error(data):
              print("The connection failed!")

          @sio.event
          def disconnect():
              print("I'm disconnected!")

       The <b>connect_error</b> handler is invoked when a connection attempt fails. If the server  provides  arguments,
       these  are  passed on to the handler. The server can use an argument to provide information to the client
       regarding the connection failure.

       The <b>disconnect</b> handler is invoked for application initiated disconnects, server initiated disconnects, or
       accidental  disconnects,  for  example  due  to  networking  failures.  In  the  case  of  an  accidental
       disconnection,  the  client  is  going  to attempt to reconnect immediately after invoking the disconnect
       handler. As soon as the connection is re-established the connect handler will be invoked once again.

       The <b>connect</b>, <b>connect_error</b> and <b>disconnect</b> events have to be defined explicitly and are not invoked  on  a
       catch-all event handler.

   <b>Connecting</b> <b>to</b> <b>a</b> <b>Server</b>
       The connection to a server is established by calling the <b>connect()</b> method:

          sio.connect('<a href="http://localhost">http://localhost</a>:5000')

       In the case of the <b>asyncio</b> client, the method is a coroutine:

          await sio.connect('<a href="http://localhost">http://localhost</a>:5000')

       Upon  connection,  the  server  assigns the client a unique session identifier.  The application can find
       this identifier in the <b>sid</b> attribute:

          print('my sid is', sio.sid)

       The Socket.IO transport that is used in the connection can be obtained from the <b>transport</b> attribute:

          print('my transport is', sio.transport)

       The transport is given as a string, and can be either <b>'websocket'</b> or <b>'polling'</b>.

   <b>TLS/SSL</b> <b>Support</b>
       The client supports TLS/SSL connections. To enable it, use a <b>https://</b> connection URL:

          sio.connect('https://example.com')

       Or when using <b>asyncio</b>:

          await sio.connect('https://example.com')

       The client will verify the server certificate by default. To disable certificate verification, or to  use
       other  less common options such as client certificates, the client must be initialized with a custom HTTP
       session object that is configured with the desired TLS/SSL options.

       The following example disables server certificate verification, which can be useful when connecting to  a
       server that uses a self-signed certificate:

          http_session = requests.Session()
          http_session.verify = False
          sio = socketio.Client(http_session=http_session)
          sio.connect('https://example.com')

       And when using <b>asyncio</b>:

          connector = aiohttp.TCPConnector(ssl=False)
          http_session = aiohttp.ClientSession(connector=connector)
          sio = socketio.AsyncClient(http_session=http_session)
          await sio.connect('https://example.com')

       Instead  of  disabling certificate verification, you can provide a custom certificate authority bundle to
       verify the certificate against:

          http_session = requests.Session()
          http_session.verify = '/path/to/ca.pem'
          sio = socketio.Client(http_session=http_session)
          sio.connect('https://example.com')

       And for <b>asyncio</b>:

          ssl_context = ssl.create_default_context()
          ssl_context.load_verify_locations('/path/to/ca.pem')
          connector = aiohttp.TCPConnector(ssl=ssl_context)
          http_session = aiohttp.ClientSession(connector=connector)
          sio = socketio.AsyncClient(http_session=http_session)
          await sio.connect('https://example.com')

       Below you can see how to use a client certificate to authenticate against the server:

          http_session = requests.Session()
          http_session.cert = ('/path/to/client/cert.pem', '/path/to/client/key.pem')
          sio = socketio.Client(http_session=http_session)
          sio.connect('https://example.com')

       And for <b>asyncio</b>:

          ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
          ssl_context.load_cert_chain('/path/to/client/cert.pem',
                                      '/path/to/client/key.pem')
          connector = aiohttp.TCPConnector(ssl=ssl_context)
          http_session = aiohttp.ClientSession(connector=connector)
          sio = socketio.AsyncClient(http_session=http_session)
          await sio.connect('https://example.com')

   <b>Emitting</b> <b>Events</b>
       The client can emit an event to the server using the <b>emit()</b> method:

          sio.emit('my message', {'foo': 'bar'})

       Or in the case of <b>asyncio</b>, as a coroutine:

          await sio.emit('my message', {'foo': 'bar'})

       The arguments provided to the method are the name of the event to emit and  the  optional  data  that  is
       passed  on to the server. The data can be of type <b>str</b>, <b>bytes</b>, <b>dict</b>, <b>list</b> or <b>tuple</b>. When sending a <b>list</b> or
       a <b>tuple</b>, the elements in it need to be of any allowed types except <b>tuple</b>.  When  a  tuple  is  used,  the
       elements of the tuple will be passed as individual arguments to the server-side event handler function.

       The <b>emit()</b> method can be invoked inside an event handler as a response to a server event, or in any other
       part of the application, including in background tasks.

   <b>Event</b> <b>Callbacks</b>
       When a server emits an event to a client, it can optionally provide a callback function, to be invoked as
       a  way  of  acknowledgment that the server has processed the event. While this is entirely managed by the
       server, the client can provide a list of return values that are to be passed on to the callback  function
       set up by the server. This is achieved simply by returning the desired values from the handler function:

          @sio.event
          def my_event(sid, data):
              # handle the message
              return "OK", 123

       Likewise,  the  client  can  request  a callback function to be invoked after the server has processed an
       event. The <b>socketio.Server.emit()</b> method has an optional <b>callback</b> argument that can be set to a callable.
       If this argument is given, the callable will be invoked after the server has processed the event, and any
       values returned by the server handler will be passed as arguments to this function.

   <b>Namespaces</b>
       The Socket.IO protocol supports multiple logical  connections,  all  multiplexed  on  the  same  physical
       connection. Clients can open multiple connections by specifying a different <u>namespace</u> on each. Namespaces
       use  a  path syntax starting with a forward slash. A list of namespaces can be given by the client in the
       <b>connect()</b> call. For example, this example creates two logical connections, the default one plus a  second
       connection under the <b>/chat</b> namespace:

          sio.connect('<a href="http://localhost">http://localhost</a>:5000', namespaces=['/chat'])

       To  define  event  handlers  on  a  namespace,  the <b>namespace</b> argument must be added to the corresponding
       decorator:

          @sio.event(namespace='/chat')
          def my_custom_event(sid, data):
              pass

          @sio.on('connect', namespace='/chat')
          def on_connect():
              print("I'm connected to the /chat namespace!")

       Likewise, the client can emit an event to the server on a namespace by providing its in the <b>emit()</b> call:

          sio.emit('my message', {'foo': 'bar'}, namespace='/chat')

       If the <b>namespaces</b> argument of the <b>connect()</b> call isn't given, any namespaces used in event  handlers  are
       automatically connected.

   <b>Class-Based</b> <b>Namespaces</b>
       As  an  alternative  to the decorator-based event handlers, the event handlers that belong to a namespace
       can be created as methods of a subclass of <b>socketio.ClientNamespace</b>:

          class MyCustomNamespace(socketio.ClientNamespace):
              def on_connect(self):
                  pass

              def on_disconnect(self):
                  pass

              def on_my_event(self, data):
                  self.emit('my_response', data)

          sio.register_namespace(MyCustomNamespace('/chat'))

       For asyncio based servers, namespaces must inherit from  <b>socketio.AsyncClientNamespace</b>,  and  can  define
       event handlers as coroutines if desired:

          class MyCustomNamespace(socketio.AsyncClientNamespace):
              def on_connect(self):
                  pass

              def on_disconnect(self):
                  pass

              async def on_my_event(self, data):
                  await self.emit('my_response', data)

          sio.register_namespace(MyCustomNamespace('/chat'))

       A  catch-all  class-based  namespace  handler  can  be  defined  by  passing  <b>'*'</b> as the namespace during
       registration:

          sio.register_namespace(MyCustomNamespace('*'))

       When class-based namespaces are used, any events received by the client are dispatched to a method  named
       as  the  event  name  with  the <b>on_</b> prefix. For example, event <b>my_event</b> will be handled by a method named
       <b>on_my_event</b>.  If an event is received for which there is no corresponding method defined in the namespace
       class, then the event is ignored. All event names used in class-based namespaces must use characters that
       are legal in method names.

       As a convenience to methods defined in a class-based namespace, the namespace instance includes  versions
       of  several  of  the  methods in the <b>socketio.Client</b> and <b>socketio.AsyncClient</b> classes that default to the
       proper namespace when the <b>namespace</b> argument is not given.

       In the case that an event has a handler in a class-based namespace, and also a  decorator-based  function
       handler, only the standalone function handler is invoked.

   <b>Disconnecting</b> <b>from</b> <b>the</b> <b>Server</b>
       At  any  time  the  client  can  request  to be disconnected from the server by invoking the <b>disconnect()</b>
       method:

          sio.disconnect()

       For the <b>asyncio</b> client this is a coroutine:

          await sio.disconnect()

   <b>Managing</b> <b>Background</b> <b>Tasks</b>
       When a client connection to the server is established, a few background tasks will be spawned to keep the
       connection alive and handle incoming events. The application running on the main thread is free to do any
       work, as this is not going to prevent the functioning of the Socket.IO client.

       If the application does not have anything to do in the main thread and  just  wants  to  wait  until  the
       connection with the server ends, it can call the <b>wait()</b> method:

          sio.wait()

       Or in the <b>asyncio</b> version:

          await sio.wait()

       For the convenience of the application, a helper function is provided to start a custom background task:

          def <a href="../manmy_argument/my_background_task.my_argument.html">my_background_task</a>(my_argument):
              # do some background work here!
              pass

          task = sio.start_background_task(my_background_task, 123)

       The  arguments  passed to this method are the background function and any positional or keyword arguments
       to invoke the function with.

       Here is the <b>asyncio</b> version:

          async def <a href="../manmy_argument/my_background_task.my_argument.html">my_background_task</a>(my_argument):
              # do some background work here!
              pass

          task = sio.start_background_task(my_background_task, 123)

       Note that this function is not a coroutine, since it does not wait for the background  function  to  end.
       The background function must be a coroutine.

       The  <b>sleep()</b>  method  is  a  second convenience function that is provided for the benefit of applications
       working with background tasks of their own:

          <a href="../man2/sio.sleep.2.html">sio.sleep</a>(2)

       Or for <b>asyncio</b>:

          await <a href="../man2/sio.sleep.2.html">sio.sleep</a>(2)

       The single argument passed to the method is the number of seconds to sleep for.

   <b>Debugging</b> <b>and</b> <b>Troubleshooting</b>
       To help you debug issues, the client can be configured to output logs to the terminal:

          import socketio

          # standard Python
          sio = socketio.Client(logger=True, engineio_logger=True)

          # asyncio
          sio = socketio.AsyncClient(logger=True, engineio_logger=True)

       The <b>logger</b> argument controls logging related to the Socket.IO protocol,  while  <b>engineio_logger</b>  controls
       logs  that  originate  in the low-level Engine.IO transport. These arguments can be set to <b>True</b> to output
       logs to <b>stderr</b>, or to an object compatible with Python's <b>logging</b> package where the logs should be emitted
       to. A value of <b>False</b> disables logging.

       Logging can help identify the cause of connection problems, unexpected disconnections and other issues.

</pre><h4><b>THE</b> <b>SOCKET.IO</b> <b>SERVER</b></h4><pre>
       This package contains two Socket.IO servers:

       • The <b>socketio.Server()</b> class creates a server compatible with the Python standard library.

       • The <b>socketio.AsyncServer()</b> class creates a server compatible with the <b>asyncio</b> package.

       The methods in the two servers are the same, with the only difference that in  the  <b>asyncio</b>  server  most
       methods are implemented as coroutines.

   <b>Installation</b>
       To install the Socket.IO server along with its dependencies, use the following command:

          pip install python-socketio

       In  addition to the server, you will need to select an asynchronous framework or server to use along with
       it. The list of supported packages is covered in the <u>Deployment</u> <u>Strategies</u> section.

   <b>Creating</b> <b>a</b> <b>Server</b> <b>Instance</b>
       A Socket.IO server is an instance of class <b>socketio.Server</b>. This  instance  can  be  transformed  into  a
       standard WSGI application by wrapping it with the <b>socketio.WSGIApp</b> class:

          import socketio

          # create a Socket.IO server
          sio = socketio.Server()

          # wrap with a WSGI application
          app = socketio.WSGIApp(sio)

       For  asyncio  based  servers,  the  <b>socketio.AsyncServer</b>  class provides the same functionality, but in a
       coroutine friendly format. If desired, The  <b>socketio.ASGIApp</b>  class  can  transform  the  server  into  a
       standard ASGI application:

          # create a Socket.IO server
          sio = socketio.AsyncServer()

          # wrap with ASGI application
          app = socketio.ASGIApp(sio)

       These  two  wrappers  can  also  act  as  middlewares, forwarding any traffic that is not intended to the
       Socket.IO server to another application. This allows Socket.IO servers to integrate easily into  existing
       WSGI or ASGI applications:

          from wsgi import app  # a Flask, Django, etc. application
          app = socketio.WSGIApp(sio, app)

   <b>Serving</b> <b>Static</b> <b>Files</b>
       The  Socket.IO  server can be configured to serve static files to clients. This is particularly useful to
       deliver HTML, CSS and JavaScript files to clients when this package  is  used  without  a  companion  web
       framework.

       Static  files  are  configured  with  a  Python  dictionary in which each key/value pair is a static file
       mapping rule. In its simplest form, this dictionary has one or more static file URLs  as  keys,  and  the
       corresponding files in the server as values:

          static_files = {
              '/': 'latency.html',
              '/static/socket.io.js': 'static/socket.io.js',
              '/static/style.css': 'static/style.css',
          }

       With  this  example configuration, when the server receives a request for <b>/</b> (the root URL) it will return
       the contents of the file <b>latency.html</b> in the current directory, and will assign a content type  based  on
       the file extension, in this case <b>text/html</b>.

       Files  with  the  <b>.html</b>,  <b>.css</b>,  <b>.js</b>,  <b>.json</b>, <b>.jpg</b>, <b>.png</b>, <b>.gif</b> and <b>.txt</b> file extensions are automatically
       recognized and assigned the correct content type. For files with other file extensions or  with  no  file
       extension, the <b>application/octet-stream</b> content type is used as a default.

       If desired, an explicit content type for a static file can be given as follows:

          static_files = {
              '/': {'filename': 'latency.html', 'content_type': 'text/plain'},
          }

       It  is  also  possible to configure an entire directory in a single rule, so that all the files in it are
       served as static files:

          static_files = {
              '/static': './public',
          }

       In this example any files with URLs starting with <b>/static</b> will be served directly from the <b>public</b>  folder
       in   the  current  directory,  so  for  example,  the  URL  <b>/static/index.html</b>  will  return  local  file
       <b>./public/index.html</b> and the URL <b>/static/css/styles.css</b> will return local file <b>./public/css/styles.css</b>.

       If a URL that ends in a <b>/</b> is requested, then a default filename of <b>index.html</b> is appended to it.  In  the
       previous example, a request for the <b>/static/</b> URL would return local file <b>./public/index.html</b>. The default
       filename to serve for slash-ending URLs can be set in the static files dictionary with an empty key:

          static_files = {
              '/static': './public',
              '': 'image.gif',
          }

       With  this  configuration,  a  request  for  <b>/static/</b>  would  return  local  file  <b>./public/image.gif</b>.  A
       non-standard content type can also be specified if needed:

          static_files = {
              '/static': './public',
              '': {'filename': 'image.gif', 'content_type': 'text/plain'},
          }

       The static file configuration dictionary is given as the <b>static_files</b> argument to the <b>socketio.WSGIApp</b> or
       <b>socketio.ASGIApp</b> classes:

          # for standard WSGI applications
          sio = socketio.Server()
          app = socketio.WSGIApp(sio, static_files=static_files)

          # for asyncio-based ASGI applications
          sio = socketio.AsyncServer()
          app = socketio.ASGIApp(sio, static_files=static_files)

       The routing precedence in these two classes is as follows:

       • First, the path is checked against the Socket.IO endpoint.

       • Next, the path is checked against the static file configuration, if present.

       • If the path did not match the Socket.IO endpoint or any static file, control is passed to the secondary
         application if configured, else a 404 error is returned.

       Note: static file serving is intended for development use only, and as such it lacks  important  features
       such as caching. Do not use in a production environment.

   <b>Defining</b> <b>Event</b> <b>Handlers</b>
       The  Socket.IO  protocol  is  event based. When a client wants to communicate with the server it <u>emits</u> an
       event. Each event has a name, and a list of arguments. The server registers event handler functions  with
       the <b>socketio.Server.event()</b> or <b>socketio.Server.on()</b> decorators:

          @sio.event
          def my_event(sid, data):
              pass

          @sio.on('my custom event')
          def another_event(sid, data):
              pass

       In the first example the event name is obtained from the name of the handler function. The second example
       is  slightly  more  verbose,  but  it  allows the event name to be different than the function name or to
       include characters that are illegal in function names, such as spaces.

       For asyncio servers, event handlers can optionally be given as coroutines:

          @sio.event
          async def my_event(sid, data):
              pass

       The <b>sid</b> argument is the Socket.IO session id, a unique identifier of  each  client  connection.  All  the
       events sent by a given client will have the same <b>sid</b> value.

   <b>Catch-All</b> <b>Event</b> <b>and</b> <b>Namespace</b> <b>Handlers</b>
       A "catch-all" event handler is invoked for any events that do not have an event handler. You can define a
       catch-all handler using <b>'*'</b> as event name:

          @sio.on('*')
          def any_event(event, sid, data):
               pass

       Asyncio servers can also use a coroutine:

          @sio.on('*')
          async def any_event(event, sid, data):
              pass

       A  catch-all  event  handler receives the event name as a first argument. The remaining arguments are the
       same as for a regular event handler.

       The <b>connect</b> and <b>disconnect</b> events have to be defined explicitly and are not invoked on a catch-all  event
       handler.

       Similarily,  a  "catch-all" namespace handler is invoked for any connected namespaces that do not have an
       explicitly defined event handler. As with catch-all events, <b>'*'</b> is used in place of a namespace:

          @sio.on('my_event', namespace='*')
          def my_event_any_namespace(namespace, sid, data):
              pass

       For these events, the namespace is passed as first argument, followed by the  regular  arguments  of  the
       event.

       Lastly, it is also possible to define a "catch-all" handler for all events on all namespaces:

          @sio.on('*', namespace='*')
          def any_event_any_namespace(event, namespace, sid, data):
              pass

       Event handlers with catch-all events and namespaces receive the event name and the namespace as first and
       second arguments.

   <b>Connect</b> <b>and</b> <b>Disconnect</b> <b>Event</b> <b>Handlers</b>
       The  <b>connect</b>  and <b>disconnect</b> events are special; they are invoked automatically when a client connects or
       disconnects from the server:

          @sio.event
          def connect(sid, environ, auth):
              print('connect ', sid)

          @sio.event
          def disconnect(sid):
              print('disconnect ', sid)

       The <b>connect</b> event is an ideal place to perform user authentication, and  any  necessary  mapping  between
       user  entities  in the application and the <b>sid</b> that was assigned to the client. The <b>environ</b> argument is a
       dictionary in standard WSGI format containing the request information, including HTTP headers.  The  <b>auth</b>
       argument  contains  any  authentication  details passed by the client, or <b>None</b> if the client did not pass
       anything. After inspecting the request, the  connect  event  handler  can  return  <b>False</b>  to  reject  the
       connection with the client.

       Sometimes  it is useful to pass data back to the client being rejected. In that case instead of returning
       <b>False</b> <b>socketio.exceptions.ConnectionRefusedError</b> can be raised, and all of its arguments will be sent  to
       the client with the rejection message:

          @sio.event
          def connect(sid, environ):
              raise ConnectionRefusedError('authentication failed')

   <b>Emitting</b> <b>Events</b>
       Socket.IO  is  a  bidirectional  protocol,  so  at any time the server can send an event to its connected
       clients. The <b>socketio.Server.emit()</b> method is used for this task:

          sio.emit('my event', {'data': 'foobar'})

       Sometimes the server may want to send an event just to a particular client.   This  can  be  achieved  by
       adding a <b>room</b> argument to the emit call:

          sio.emit('my event', {'data': 'foobar'}, room=user_sid)

       The  <b>socketio.Server.emit()</b>  method takes an event name, a message payload of type <b>str</b>, <b>bytes</b>, <b>list</b>, <b>dict</b>
       or <b>tuple</b>, and the recipient room. When sending a <b>tuple</b>, the elements in it need to be of any of the other
       four allowed types. The elements of the tuple will be passed as multiple  arguments  to  the  client-side
       event  handler  function. The <b>room</b> argument is used to identify the client that should receive the event,
       and is set to the <b>sid</b> value assigned to that client's connection with the server. When omitted, the event
       is broadcasted to all connected clients.

   <b>Event</b> <b>Callbacks</b>
       When a client sends an event to the server, it can optionally provide a callback function, to be  invoked
       as a way of acknowledgment that the server has processed the event. While this is entirely managed by the
       client, the server can provide a list of values that are to be passed on to the callback function, simply
       by returning them from the handler function:

          @sio.event
          def my_event(sid, data):
              # handle the message
              return "OK", 123

       Likewise, the server can request a callback function to be invoked after a client has processed an event.
       The  <b>socketio.Server.emit()</b>  method  has  an optional <b>callback</b> argument that can be set to a callable. If
       this argument is given, the callable will be invoked after the client has processed the  event,  and  any
       values returned by the client will be passed as arguments to this function. Using callback functions when
       broadcasting to multiple clients is currently not supported.

   <b>Namespaces</b>
       The  Socket.IO  protocol  supports  multiple  logical  connections,  all multiplexed on the same physical
       connection. Clients can open multiple  connections  by  specifying  a  different  <u>namespace</u>  on  each.  A
       namespace  is  given by the client as a pathname following the hostname and port. For example, connecting
       to <u><a href="http://example.com">http://example.com</a>:8000/chat</u> would open a connection to the namespace <u>/chat</u>.

       Each namespace is handled independently from the others, with separate session IDs (<b>sid</b>s), event handlers
       and rooms. It is important that applications that use multiple namespaces specify the  correct  namespace
       when  setting  up  their event handlers and rooms, using the optional <b>namespace</b> argument available in all
       the methods in the <b>socketio.Server</b> class:

          @sio.event(namespace='/chat')
          def my_custom_event(sid, data):
              pass

          @sio.on('my custom event', namespace='/chat')
          def my_custom_event(sid, data):
              pass

       When emitting an event, the <b>namespace</b> optional argument is used to specify which namespace to send it on.
       When the <b>namespace</b> argument is omitted, the default Socket.IO namespace, which is named <b>/</b>, is used.

   <b>Class-Based</b> <b>Namespaces</b>
       As an alternative to the decorator-based event handlers, the event handlers that belong  to  a  namespace
       can be created as methods of a subclass of <b>socketio.Namespace</b>:

          class MyCustomNamespace(socketio.Namespace):
              def on_connect(self, sid, environ):
                  pass

              def on_disconnect(self, sid):
                  pass

              def on_my_event(self, sid, data):
                  self.emit('my_response', data)

          sio.register_namespace(MyCustomNamespace('/test'))

       For  asyncio  based  servers,  namespaces must inherit from <b>socketio.AsyncNamespace</b>, and can define event
       handlers as coroutines if desired:

          class MyCustomNamespace(socketio.AsyncNamespace):
              def on_connect(self, sid, environ):
                  pass

              def on_disconnect(self, sid):
                  pass

              async def on_my_event(self, sid, data):
                  await self.emit('my_response', data)

          sio.register_namespace(MyCustomNamespace('/test'))

       A catch-all class-based namespace handler  can  be  defined  by  passing  <b>'*'</b>  as  the  namespace  during
       registration:

          sio.register_namespace(MyCustomNamespace('*'))

       When  class-based namespaces are used, any events received by the server are dispatched to a method named
       as the event name with the <b>on_</b> prefix. For example, event <b>my_event</b> will be  handled  by  a  method  named
       <b>on_my_event</b>.  If an event is received for which there is no corresponding method defined in the namespace
       class, then the event is ignored. All event names used in class-based namespaces must use characters that
       are legal in method names.

       As  a convenience to methods defined in a class-based namespace, the namespace instance includes versions
       of several of the methods in the <b>socketio.Server</b> and <b>socketio.AsyncServer</b> classes  that  default  to  the
       proper namespace when the <b>namespace</b> argument is not given.

       In  the  case that an event has a handler in a class-based namespace, and also a decorator-based function
       handler, only the standalone function handler is invoked.

       It is important to note that class-based namespaces are singletons. This means that a single instance  of
       a namespace class is used for all clients, and consequently, a namespace instance cannot be used to store
       client specific information.

   <b>Rooms</b>
       To  make  it easy for the server to emit events to groups of related clients, the application can put its
       clients into "rooms", and then address messages to these rooms.

       In the previous section the <b>room</b> argument of the <b>socketio.SocketIO.emit()</b> method was used to designate  a
       specific  client as the recipient of the event. This is because upon connection, a personal room for each
       client is created and named with the <b>sid</b> assigned to the connection. The  application  is  then  free  to
       create  additional  rooms and manage which clients are in them using the <b>socketio.Server.enter_room()</b> and
       <b>socketio.Server.leave_room()</b> methods. Clients can be in as many rooms as needed and can be moved  between
       rooms as often as necessary.

          @sio.event
          def begin_chat(sid):
              sio.enter_room(sid, 'chat_users')

          @sio.event
          def exit_chat(sid):
              sio.leave_room(sid, 'chat_users')

       In  chat  applications  it  is  often desired that an event is broadcasted to all the members of the room
       except one, which is the originator of the event such  as  a  chat  message.  The  <b>socketio.Server.emit()</b>
       method  provides  an  optional  <b>skip_sid</b>  argument to indicate a client that should be skipped during the
       broadcast.

          @sio.event
          def my_message(sid, data):
              sio.emit('my reply', data, room='chat_users', skip_sid=sid)

   <b>User</b> <b>Sessions</b>
       The server can maintain application-specific information in a user session dedicated  to  each  connected
       client.  Applications  can  use  the  user  session  to  write any details about the user that need to be
       preserved throughout the life of the connection, such as usernames or user ids.

       The <b>save_session()</b> and <b>get_session()</b> methods are used to store  and  retrieve  information  in  the  user
       session:

          @sio.event
          def connect(sid, environ):
              username = authenticate_user(environ)
              sio.save_session(sid, {'username': username})

          @sio.event
          def message(sid, data):
              session = sio.get_session(sid)
              print('message from ', session['username'])

       For the <b>asyncio</b> server, these methods are coroutines:

          @sio.event
          async def connect(sid, environ):
              username = authenticate_user(environ)
              await sio.save_session(sid, {'username': username})

          @sio.event
          async def message(sid, data):
              session = await sio.get_session(sid)
              print('message from ', session['username'])

       The session can also be manipulated with the <u>session()</u> context manager:

          @sio.event
          def connect(sid, environ):
              username = authenticate_user(environ)
              with sio.session(sid) as session:
                  session['username'] = username

          @sio.event
          def message(sid, data):
              with sio.session(sid) as session:
                  print('message from ', session['username'])

       For the <b>asyncio</b> server, an asynchronous context manager is used:

          @sio.event
          async def connect(sid, environ):
              username = authenticate_user(environ)
              async with sio.session(sid) as session:
                  session['username'] = username

          @sio.event
          async def message(sid, data):
              async with sio.session(sid) as session:
                  print('message from ', session['username'])

       The  <b>get_session()</b>,  <b>save_session()</b>  and  <b>session()</b>  methods take an optional <b>namespace</b> argument. If this
       argument isn't provided, the session is attached to the default namespace.

       Note: the contents of the user session are destroyed when the client  disconnects.  In  particular,  user
       session  contents  are  not preserved when a client reconnects after an unexpected disconnection from the
       server.

   <b>Using</b> <b>a</b> <b>Message</b> <b>Queue</b>
       When working with distributed applications, it is often necessary to  access  the  functionality  of  the
       Socket.IO from multiple processes. There are two specific use cases:

       • Applications  that  use  work  queues  such  as  <u>Celery</u>  may  need  to emit an event to a client once a
         background job completes. The most convenient place to carry out this task is the worker  process  that
         handled this job.

       • Highly  available applications may want to use horizontal scaling of the Socket.IO server to be able to
         handle very large number of concurrent clients.

       As a solution to the above problems, the Socket.IO server can be configured to connect to a message queue
       such as <u>Redis</u> or <u>RabbitMQ</u>, to communicate with other related Socket.IO servers or auxiliary workers.

   <b>Redis</b>
       To use a Redis message queue, a Python Redis client must be installed:

          # socketio.Server class
          pip install redis

       The Redis queue is configured through the <b>socketio.RedisManager</b> and  <b>socketio.AsyncRedisManager</b>  classes.
       These classes connect directly to the Redis store and use the queue's pub/sub functionality:

          # socketio.Server class
          mgr = socketio.RedisManager('redis://')
          sio = socketio.Server(client_manager=mgr)

          # socketio.AsyncServer class
          mgr = socketio.AsyncRedisManager('redis://')
          sio = socketio.AsyncServer(client_manager=mgr)

       The <b>client_manager</b> argument instructs the server to connect to the given message queue, and to coordinate
       with other processes connected to the queue.

   <b>Kombu</b>
       <u>Kombu</u>  is  a  Python  package  that  provides access to RabbitMQ and many other message queues. It can be
       installed with pip:

          pip install kombu

       To use RabbitMQ or other AMQP protocol compatible queues, that is the only required dependency.  But  for
       other message queues, Kombu may require additional packages. For example, to use a Redis queue via Kombu,
       the Python package for Redis needs to be installed as well:

          pip install redis

       The queue is configured through the <b>socketio.KombuManager</b>:

          mgr = socketio.KombuManager('amqp://')
          sio = socketio.Server(client_manager=mgr)

       The  connection  URL  passed  to  the  <b>KombuManager</b>  constructor is passed directly to Kombu's <u>Connection</u>
       <u>object</u>, so the Kombu documentation should be consulted for information on how to build  the  correct  URL
       for a given message queue.

       Note  that  Kombu  currently does not support asyncio, so it cannot be used with the <b>socketio.AsyncServer</b>
       class.

   <b>Kafka</b>
       <u>Apache</u> <u>Kafka</u> is supported through the <u>kafka-python</u> package:

          pip install kafka-python

       Access to Kafka is configured through the <b>socketio.KafkaManager</b> class:

          mgr = socketio.KafkaManager('kafka://')
          sio = socketio.Server(client_manager=mgr)

       Note that Kafka currently does not support asyncio, so it cannot be used  with  the  <b>socketio.AsyncServer</b>
       class.

   <b>AioPika</b>
       A  RabbitMQ  message queue is supported in asyncio applications through the <u>AioPika</u> package:: You need to
       install aio_pika with pip:

          pip install aio_pika

       The RabbitMQ queue is configured through the <b>socketio.AsyncAioPikaManager</b> class:

          mgr = socketio.AsyncAioPikaManager('amqp://')
          sio = socketio.AsyncServer(client_manager=mgr)

   <b>Horizontal</b> <b>Scaling</b>
       Socket.IO is a stateful protocol, which makes horizontal scaling more difficult. When deploying a cluster
       of Socket.IO processes, all processes must connect to the message queue  by  passing  the  <b>client_manager</b>
       argument  to  the  server  instance.  This  enables  the  workers  to  communicate and coordinate complex
       operations such as broadcasts.

       If the long-polling transport is used, then there are two additional requirements that must be met:

       • Each Socket.IO process must be able to handle multiple requests concurrently. This  is  needed  because
         long-polling  clients  send two requests in parallel. Worker processes that can only handle one request
         at a time are not supported.

       • The load balancer must be configured to always forward requests  from  a  client  to  the  same  worker
         process,  so  that  all requests coming from a client are handled by the same node. Load balancers call
         this <u>sticky</u> <u>sessions</u>, or <u>session</u> <u>affinity</u>.

   <b>Emitting</b> <b>from</b> <b>external</b> <b>processes</b>
       To have a process other than a server connect to the queue to emit a message,  the  same  client  manager
       classes can be used as standalone objects. In this case, the <b>write_only</b> argument should be set to <b>True</b> to
       disable the creation of a listening thread, which only makes sense in a server. For example:

          # connect to the redis queue as an external process
          external_sio = socketio.RedisManager('redis://', write_only=True)

          # emit an event
          external_sio.emit('my event', data={'foo': 'bar'}, room='my room')

       A  limitation  of the write-only client manager object is that it cannot receive callbacks when emitting.
       When the external process needs to receive callbacks, using a client to connect to the server  with  read
       and write support is a better option than a write-only client manager.

   <b>Monitoring</b> <b>and</b> <b>Administration</b>
       The  Socket.IO  server can be configured to accept connections from the official <u>Socket.IO</u> <u>Admin</u> <u>UI</u>. This
       tool provides real-time information about currently connected clients, rooms  in  use  and  events  being
       emitted.  It also allows an administrator to manually emit events, change room assignments and disconnect
       clients. The hosted version of this tool is available at <u>https://admin.socket.io</u>.

       Given that enabling this feature can affect the performance of the server, it is disabled by default.  To
       enable it, call the <b>instrument()</b> method. For example:

          import os
          import socketio

          sio = socketio.Server(cors_allowed_origins=[
              '<a href="http://localhost">http://localhost</a>:5000',
              'https://admin.socket.io',
          ])
          sio.instrument(auth={
              'username': 'admin',
              'password': os.environ['ADMIN_PASSWORD'],
          })

       This configures the server to accept connections from the hosted Admin UI client. Administrators can then
       open  <u>https://admin.socket.io</u> in their web browsers and log in with username <b>admin</b> and the password given
       by the <b>ADMIN_PASSWORD</b> environment variable. To ensure the Admin UI front end is allowed to connect,  CORS
       is also configured.

       Consult the reference documentation to learn about additional configuration options that are available.

   <b>Debugging</b> <b>and</b> <b>Troubleshooting</b>
       To help you debug issues, the server can be configured to output logs to the terminal:

          import socketio

          # standard Python
          sio = socketio.Server(logger=True, engineio_logger=True)

          # asyncio
          sio = socketio.AsyncServer(logger=True, engineio_logger=True)

       The  <b>logger</b>  argument  controls logging related to the Socket.IO protocol, while <b>engineio_logger</b> controls
       logs that originate in the low-level Engine.IO transport. These arguments can be set to  <b>True</b>  to  output
       logs to <b>stderr</b>, or to an object compatible with Python's <b>logging</b> package where the logs should be emitted
       to. A value of <b>False</b> disables logging.

       Logging  can  help  identify  the  cause of connection problems, 400 responses, bad performance and other
       issues.

   <b>Deployment</b> <b>Strategies</b>
       The following sections describe a variety of deployment strategies for Socket.IO servers.

   <b>Uvicorn,</b> <b>Daphne,</b> <b>and</b> <b>other</b> <b>ASGI</b> <b>servers</b>
       The <b>socketio.ASGIApp</b> class is an ASGI compatible application that can forward  Socket.IO  traffic  to  an
       <b>socketio.AsyncServer</b> instance:

          sio = socketio.AsyncServer(async_mode='asgi')
          app = socketio.ASGIApp(sio)

       If  desired,  the  <b>socketio.ASGIApp</b>  class  can forward any traffic that is not Socket.IO to another ASGI
       application, making it possible to deploy a standard ASGI web application and the Socket.IO server  as  a
       bundle:

          sio = socketio.AsyncServer(async_mode='asgi')
          app = socketio.ASGIApp(sio, other_app)

       The  <b>ASGIApp</b> instance is a fully complaint ASGI instance that can be deployed with an ASGI compatible web
       server.

   <b>Aiohttp</b>
       <u>Aiohttp</u> is a framework with support for HTTP and WebSocket, based on asyncio. Support for this  framework
       is limited to Python 3.5 and newer.

       Instances of class <b>socketio.AsyncServer</b> will automatically use aiohttp for asynchronous operations if the
       library  is  installed.  To  request  its  use  explicitly,  the  <b>async_mode</b>  option  can be given in the
       constructor:

          sio = socketio.AsyncServer(async_mode='aiohttp')

       A server configured for aiohttp must be attached to an existing application:

          app = web.Application()
          sio.attach(app)

       The aiohttp application can define regular routes that will coexist with the Socket.IO server. A  typical
       pattern is to add routes that serve a client application and any associated static files.

       The aiohttp application is then executed in the usual manner:

          if __name__ == '__main__':
              web.run_app(app)

   <b>Tornado</b>
       <u>Tornado</u>  is  a  web  framework  with  support for HTTP and WebSocket. Support for this framework requires
       Python 3.5 and newer. Only Tornado version 5 and newer are supported, thanks  to  its  tight  integration
       with asyncio.

       Instances of class <b>socketio.AsyncServer</b> will automatically use tornado for asynchronous operations if the
       library  is  installed.  To  request  its  use  explicitly,  the  <b>async_mode</b>  option  can be given in the
       constructor:

          sio = socketio.AsyncServer(async_mode='tornado')

       A server configured for tornado must include a request handler for Socket.IO:

          app = tornado.web.Application(
              [
                  (r"/socket.io/", socketio.get_tornado_handler(sio)),
              ],
              # ... other application options
          )

       The tornado application can define other routes that will coexist with the Socket.IO  server.  A  typical
       pattern is to add routes that serve a client application and any associated static files.

       The tornado application is then executed in the usual manner:

          app.listen(port)
          tornado.ioloop.IOLoop.current().start()

   <b>Sanic</b>
       Note:  Due  to some backward incompatible changes introduced in recent versions of Sanic, it is currently
       recommended that a Sanic application is deployed with the ASGI integration instead.

       <u>Sanic</u> is a very efficient asynchronous web server for Python 3.5 and newer.

       Instances of class <b>socketio.AsyncServer</b> will automatically use Sanic for asynchronous operations  if  the
       framework  is  installed.  To  request  its  use  explicitly,  the  <b>async_mode</b> option can be given in the
       constructor:

          sio = socketio.AsyncServer(async_mode='sanic')

       A server configured for aiohttp must be attached to an existing application:

          app = Sanic()
          sio.attach(app)

       The Sanic application can define regular routes that will coexist with the Socket.IO  server.  A  typical
       pattern is to add routes that serve a client application and any associated static files.

       The Sanic application is then executed in the usual manner:

          if __name__ == '__main__':
              app.run()

       It  has  been  reported  that the CORS support provided by the Sanic extension <u>sanic-cors</u> is incompatible
       with this package's own support for this protocol. To disable CORS support in this package and let  Sanic
       take full control, initialize the server as follows:

          sio = socketio.AsyncServer(async_mode='sanic', cors_allowed_origins=[])

       On  the Sanic side you will need to enable the <u>CORS_SUPPORTS_CREDENTIALS</u> setting in addition to any other
       configuration that you use:

          app.config['CORS_SUPPORTS_CREDENTIALS'] = True

   <b>Eventlet</b>
       <u>Eventlet</u> is a high performance concurrent networking library for Python 2 and  3  that  uses  coroutines,
       enabling  code  to  be  written  in  the same style used with the blocking standard library functions. An
       Socket.IO server deployed with eventlet has access to the long-polling and WebSocket transports.

       Instances of class <b>socketio.Server</b> will automatically use eventlet for  asynchronous  operations  if  the
       library  is  installed.  To  request  its  use  explicitly,  the  <b>async_mode</b>  option  can be given in the
       constructor:

          sio = socketio.Server(async_mode='eventlet')

       A server configured  for  eventlet  is  deployed  as  a  regular  WSGI  application  using  the  provided
       <b>socketio.WSGIApp</b>:

          app = socketio.WSGIApp(sio)
          import eventlet
          eventlet.wsgi.server(eventlet.listen(('', 8000)), app)

   <b>Eventlet</b> <b>with</b> <b>Gunicorn</b>
       An  alternative  to  running  the eventlet WSGI server as above is to use <u>gunicorn</u>, a fully featured pure
       Python web server. The command to launch the application under gunicorn is shown below:

          $ gunicorn -k eventlet -w 1 module:app

       Due to limitations in its load balancing algorithm, gunicorn can only be used with one worker process, so
       the <b>-w</b> option cannot be set to a value higher than 1. A single eventlet worker can handle a large  number
       of concurrent clients, each handled by a greenlet.

       Eventlet  provides  a  <b>monkey_patch()</b>  function  that replaces all the blocking functions in the standard
       library with equivalent asynchronous versions. While python-socketio does not  require  monkey  patching,
       other libraries such as database drivers are likely to require it.

   <b>Gevent</b>
       <u>Gevent</u>  is  another  asynchronous  framework  based on coroutines, very similar to eventlet. An Engine.IO
       server deployed with gevent has access to the long-polling and websocket transports.

       Instances of class <b>socketio.Server</b> will automatically use  gevent  for  asynchronous  operations  if  the
       library  is  installed  and  eventlet  is not installed. To request gevent to be selected explicitly, the
       <b>async_mode</b> option can be given in the constructor:

          sio = socketio.Server(async_mode='gevent')

       A  server  configured  for  gevent  is  deployed  as  a  regular  WSGI  application  using  the  provided
       <b>socketio.WSGIApp</b>:

          app = socketio.WSGIApp(sio)
          from gevent import pywsgi
          pywsgi.WSGIServer(('', 8000), app).serve_forever()

   <b>Gevent</b> <b>with</b> <b>Gunicorn</b>
       An  alternative  to  running  the  gevent  WSGI server as above is to use <u>gunicorn</u>, a fully featured pure
       Python web server. The command to launch the application under gunicorn is shown below:

          $ gunicorn -k gevent -w 1 module:app

       Same as with eventlet, due to limitations in its load balancing algorithm, gunicorn can only be used with
       one worker process, so the <b>-w</b> option cannot be higher than 1. A single gevent worker can handle  a  large
       number of concurrent clients through the use of greenlets.

       Gevent  provides  a  <b>monkey_patch()</b>  function  that  replaces  all the blocking functions in the standard
       library with equivalent asynchronous versions. While python-socketio does not  require  monkey  patching,
       other libraries such as database drivers are likely to require it.

   <b>uWSGI</b>
       When  using  the  uWSGI  server  in  combination  with gevent, the Socket.IO server can take advantage of
       uWSGI's native WebSocket support.

       Instances of class <b>socketio.Server</b> will automatically use this option for asynchronous operations if both
       gevent and uWSGI are installed  and  eventlet  is  not  installed.  To  request  this  asynchronous  mode
       explicitly, the <b>async_mode</b> option can be given in the constructor:

          # gevent with uWSGI
          sio = socketio.Server(async_mode='gevent_uwsgi')

       A  complete  explanation  of  the configuration and usage of the uWSGI server is beyond the scope of this
       documentation. The uWSGI server is a fairly complex package that provides a large and  comprehensive  set
       of  options.  It  must  be  compiled  with  WebSocket  and  SSL support for the WebSocket transport to be
       available. As way of an introduction, the following command starts a  uWSGI  server  for  the  <b>latency.py</b>
       example on port 5000:

          $ uwsgi --http :5000 --gevent 1000 --http-websockets --master --wsgi-file latency.py --callable app

   <b>Standard</b> <b>Threads</b>
       While  not  comparable  to  eventlet and gevent in terms of performance, the Socket.IO server can also be
       configured to work with multi-threaded web servers that use standard Python threads.  This  is  an  ideal
       setup to use with development servers such as <u>Werkzeug</u>.

       Instances  of  class  <b>socketio.Server</b>  will  automatically use the threading mode if neither eventlet nor
       gevent are installed. To request the threading mode explicitly, the <b>async_mode</b> option can be given in the
       constructor:

          sio = socketio.Server(async_mode='threading')

       A server configured for threading is deployed as a regular web  application,  using  any  WSGI  complaint
       multi-threaded  server.  The  example  below  deploys  an Socket.IO application combined with a Flask web
       application, using Flask's development web server based on Werkzeug:

          sio = socketio.Server(async_mode='threading')
          app = Flask(__name__)
          app.wsgi_app = socketio.WSGIApp(sio, app.wsgi_app)

          # ... Socket.IO and Flask handler functions ...

          if __name__ == '__main__':
              app.run()

       The example that follows shows how to start an Socket.IO application  using  Gunicorn's  threaded  worker
       class:

          $ gunicorn -w 1 --threads 100 module:app

       With the above configuration the server will be able to handle up to 100 concurrent clients.

       When  using  standard threads, WebSocket is supported through the <u>simple-websocket</u> package, which must be
       installed separately. This package provides a multi-threaded WebSocket server  that  is  compatible  with
       Werkzeug  and Gunicorn's threaded worker. Other multi-threaded web servers are not supported and will not
       enable the WebSocket transport.

   <b>Cross-Origin</b> <b>Controls</b>
       For security reasons, this server enforces a same-origin policy by  default.  In  practical  terms,  this
       means the following:

       • If  an incoming HTTP or WebSocket request includes the <b>Origin</b> header, this header must match the scheme
         and host of the connection URL. In case of a mismatch, a 400 status code response is returned  and  the
         connection is rejected.

       • No restrictions are imposed on incoming requests that do not include the <b>Origin</b> header.

       If  necessary,  the  <b>cors_allowed_origins</b> option can be used to allow other origins. This argument can be
       set to a string to set a single allowed origin, or to a list to allow multiple origins. A  special  value
       of  <b>'*'</b>  can  be  used to instruct the server to allow all origins, but this should be done with care, as
       this could make the server vulnerable to Cross-Site Request Forgery (CSRF) attacks.

</pre><h4><b>API</b> <b>REFERENCE</b></h4><pre>
       • <u>Index</u>

       • <u>Module</u> <u>Index</u>

       • <u>Search</u> <u>Page</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Miguel Grinberg

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2018, Miguel Grinberg

                                                  Mar 10, 2025                                <u><a href="../man1/PYTHON-SOCKETIO.1.html">PYTHON-SOCKETIO</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>