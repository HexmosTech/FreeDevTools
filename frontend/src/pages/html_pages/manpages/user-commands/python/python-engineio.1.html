<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>python-engineio - python-engineio Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python3-engineio">python3-engineio_4.11.2-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       python-engineio - python-engineio Documentation

       This  project  implements  Python based Engine.IO client and server that can run standalone or integrated
       with a variety of Python web frameworks and applications.

</pre><h4><b>GETTING</b> <b>STARTED</b></h4><pre>
   <b>What</b> <b>is</b> <b>Engine.IO?</b>
       Engine.IO  is  a  lightweight  transport  protocol  that  enables  real-time  bidirectional   event-based
       communication  between  clients  (typically,  though not always, web browsers) and a server. The official
       implementations of the client and server components are written  in  JavaScript.  This  package  provides
       Python implementations of both, each with standard and <b>asyncio</b> variants.

       The  Engine.IO  protocol  is  extremely  simple.  Once  a  connection  between  a  client and a server is
       established, either side can  send  "messages"  to  the  other  side.  Event  handlers  provided  by  the
       applications  on both ends are invoked when a message is received, or when a connection is established or
       dropped.

   <b>Client</b> <b>Examples</b>
       The example that follows shows a simple Python client:

          import engineio

          eio = engineio.Client()

          @eio.on('connect')
          def on_connect():
              print('connection established')

          @eio.on('message')
          def on_message(data):
              print('message received with ', data)
              eio.send({'response': 'my response'})

          @eio.on('disconnect')
          def on_disconnect():
              print('disconnected from server')

          eio.connect('<a href="http://localhost">http://localhost</a>:5000')
          eio.wait()

       And here is a similar client written using the official Engine.IO Javascript client:

          &lt;script src="/path/to/engine.io.js"&gt;&lt;/script&gt;
          &lt;script&gt;
              var socket = eio('<a href="http://localhost">http://localhost</a>:5000');
              socket.on('open', function() { console.log('connection established'); });
              socket.on('message', function(data) {
                  console.log('message received with ' + data);
                  socket.send({response: 'my response'});
              });
              socket.on('close', function() { console.log('disconnected from server'); });
          &lt;/script&gt;

   <b>Client</b> <b>Features</b>
       • Can connect to other Engine.IO complaint servers besides the one in this package.

       • Compatible with Python 3.6+.

       • Two versions of the client, one for standard Python and another for <b>asyncio</b>.

       • Uses an event-based architecture implemented with decorators that hides the details of the protocol.

       • Implements HTTP long-polling and WebSocket transports.

   <b>Server</b> <b>Examples</b>
       The following application is a basic example that uses the Eventlet asynchronous server:

          import engineio
          import eventlet

          eio = engineio.Server()
          app = engineio.WSGIApp(eio, static_files={
              '/': {'content_type': 'text/html', 'filename': 'index.html'}
          })

          @eio.on('connect')
          def connect(sid, environ):
              print("connect ", sid)

          @eio.on('message')
          def message(sid, data):
              print("message ", data)
              eio.send(sid, 'reply')

          @eio.on('disconnect')
          def disconnect(sid):
              print('disconnect ', sid)

          if __name__ == '__main__':
              eventlet.wsgi.server(eventlet.listen(('', 5000)), app)

       Below is a similar application, coded for asyncio and the Uvicorn web server:

          import engineio
          import uvicorn

          eio = engineio.AsyncServer()
          app = engineio.ASGIApp(eio, static_files={
              '/': {'content_type': 'text/html', 'filename': 'index.html'}
          })

          @eio.on('connect')
          def connect(sid, environ):
              print("connect ", sid)

          @eio.on('message')
          async def message(sid, data):
              print("message ", data)
              await eio.send(sid, 'reply')

          @eio.on('disconnect')
          def disconnect(sid):
              print('disconnect ', sid)

          if __name__ == '__main__':
              uvicorn.run('127.0.0.1', 5000)

   <b>Server</b> <b>Features</b>
       • Can accept clients running other complaint Engine.IO clients besides the one in this package.

       • Compatible with Python 3.6+.

       • Two versions of the server, one for standard Python and another for <b>asyncio</b>.

       • Supports large number of clients even on modest hardware due to being asynchronous.

       • Can be hosted on any <u>WSGI</u> and <u>ASGI</u> web servers includind <u>Gunicorn</u>, <u>Uvicorn</u>, <u>eventlet</u> and <u>gevent</u>.

       • Can be integrated with WSGI applications written in frameworks such as Flask, Django, etc.

       • Can be integrated with <u>aiohttp</u>, <u>sanic</u> and <u>tornado</u> <b>asyncio</b> applications.

       • Uses an event-based architecture implemented with decorators that hides the details of the protocol.

       • Implements HTTP long-polling and WebSocket transports.

       • Supports XHR2 and XHR browsers as clients.

       • Supports text and binary messages.

       • Supports gzip and deflate HTTP compression.

       • Configurable CORS responses to avoid cross-origin problems with browsers.

</pre><h4><b>THE</b> <b>ENGINE.IO</b> <b>CLIENT</b></h4><pre>
       This package contains two Engine.IO clients:

       • The <b>engineio.Client()</b> class creates a client compatible with the standard Python library.

       • The <b>engineio.AsyncClient()</b> class creates a client compatible with the <b>asyncio</b> package.

       The methods in the two clients are the same, with the only difference that in  the  <b>asyncio</b>  client  most
       methods are implemented as coroutines.

   <b>Installation</b>
       To install the standard Python client along with its dependencies, use the following command:

          pip install "python-engineio[client]"

       If instead you plan on using the <b>asyncio</b> client, then use this:

          pip install "python-engineio[asyncio_client]"

   <b>Creating</b> <b>a</b> <b>Client</b> <b>Instance</b>
       To instantiate an Engine.IO client, simply create an instance of the appropriate client class:

          import engineio

          # standard Python
          eio = engineio.Client()

          # asyncio
          eio = engineio.AsyncClient()

   <b>Defining</b> <b>Event</b> <b>Handlers</b>
       To  responds to events triggered by the connection or the server, event Handler functions must be defined
       using the <b>on</b> decorator:

          @eio.on('connect')
          def on_connect():
              print('I'm connected!')

          @eio.on('message')
          def on_message(data):
              print('I received a message!')

          @eio.on('disconnect')
          def on_disconnect(reason):
              print('I'm disconnected! reason:', reason)

       For the <b>asyncio</b> server, event handlers can be regular functions as above, or can also be coroutines:

          @eio.on('message')
          async def on_message(data):
              print('I received a message!')

       The argument given to the <b>on</b> decorator is the event name. The events  that  are  supported  are  <b>connect</b>,
       <b>message</b> and <b>disconnect</b>.

       The  <b>data</b>  argument  passed to the <b>'message'</b> event handler contains application-specific data provided by
       the server with the event.

       The <b>disconnect</b> handler is invoked for client initiated  disconnects,  server  initiated  disconnects,  or
       accidental  disconnects,  for  example  due  to  networking failures. The argument passed to this handler
       provides the disconnect reason. Example:

          @eio.on('disconnect')
          def on_disconnect(reason):
              if reason == eio.reason.CLIENT_DISCONNECT:
                  print('client disconnection')
              elif reason == eio.reason.SERVER_DISCONNECT:
                  print('the server kicked me out')
              else:
                  print(f'disconnect reason: {reason}')

   <b>Connecting</b> <b>to</b> <b>a</b> <b>Server</b>
       The connection to a server is established by calling the <b>connect()</b> method:

          eio.connect('<a href="http://localhost">http://localhost</a>:5000')

       In the case of the <b>asyncio</b> client, the method is a coroutine:

          await eio.connect('<a href="http://localhost">http://localhost</a>:5000')

       Upon connection, the server assigns the client a unique session identifier.  The  applicaction  can  find
       this identifier in the <b>sid</b> attribute:

          print('my sid is', eio.sid)

   <b>Sending</b> <b>Messages</b>
       The client can send a message to the server using the <b>send()</b> method:

          eio.send({'foo': 'bar'})

       Or in the case of <b>asyncio</b>, as a coroutine:

          await eio.send({'foo': 'bar'})

       The  single  argument provided to the method is the data that is passed on to the server. The data can be
       of type <b>str</b>, <b>bytes</b>, <b>dict</b> or <b>list</b>. The data included inside dictionaries and lists is also constrained  to
       these types.

       The <b>send()</b> method can be invoked inside an event handler as a response to a server event, or in any other
       part of the application, including in background tasks.

   <b>Disconnecting</b> <b>from</b> <b>the</b> <b>Server</b>
       At  any  time  the  client  can  request  to be disconnected from the server by invoking the <b>disconnect()</b>
       method:

          eio.disconnect()

       For the <b>asyncio</b> client this is a coroutine:

          await eio.disconnect()

   <b>Managing</b> <b>Background</b> <b>Tasks</b>
       When a client connection to the server is established, a few background tasks will be spawned to keep the
       connection alive and handle incoming events. The application running on the main thread is free to do any
       work, as this is not going to prevent the functioning of the Engine.IO client.

       If the application does not have anything to do in the main thread and  just  wants  to  wait  until  the
       connection ends, it can call the <b>wait()</b> method:

          eio.wait()

       Or in the <b>asyncio</b> version:

          await eio.wait()

       For the convenience of the application, a helper function is provided to start a custom background task:

          def <a href="../manmy_argument/my_background_task.my_argument.html">my_background_task</a>(my_argument)
              # do some background work here!
              pass

          eio.start_background_task(my_background_task, 123)

       The  arguments  passed to this method are the background function and any positional or keyword arguments
       to invoke the function with.

       Here is the <b>asyncio</b> version:

          async def <a href="../manmy_argument/my_background_task.my_argument.html">my_background_task</a>(my_argument)
              # do some background work here!
              pass

          eio.start_background_task(my_background_task, 123)

       Note that this function is not a coroutine, since it does not wait for the background  function  to  end,
       but the background function is.

       The  <b>sleep()</b>  method  is  a  second convenience function that is provided for the benefit of applications
       working with background tasks of their own:

          <a href="../man2/eio.sleep.2.html">eio.sleep</a>(2)

       Or for <b>asyncio</b>:

          await <a href="../man2/eio.sleep.2.html">eio.sleep</a>(2)

       The single argument passed to the method is the number of seconds to sleep for.

   <b>Debugging</b> <b>and</b> <b>Troubleshooting</b>
       To help you debug issues, the client can be configured to output logs to the terminal:

          import engineio

          # standard Python
          eio = engineio.Client(logger=True)

          # asyncio
          eio = engineio.AsyncClient(logger=True)

       The <b>logger</b> argument can be set to <b>True</b> to output logs to <b>stderr</b>, or to an object compatible with Python's
       <b>logging</b> package where the logs should be emitted to. A value of <b>False</b> disables logging.

       Logging can help identify the cause of connection problems, unexpected disconnections and other issues.

</pre><h4><b>THE</b> <b>ENGINE.IO</b> <b>SERVER</b></h4><pre>
       This package contains two Engine.IO servers:

       • The <b>engineio.Server()</b> class creates a server compatible with the standard Python library.

       • The <b>engineio.AsyncServer()</b> class creates a server compatible with the <b>asyncio</b> package.

       The methods in the two servers are the same, with the only difference that in  the  <b>asyncio</b>  server  most
       methods are implemented as coroutines.

   <b>Installation</b>
       To install the Python Engine.IO server use the following command:

          pip install "python-engineio"

       In  addition to the server, you will need to select an asynchronous framework or server to use along with
       it. The list of supported packages is covered in the <u>Deployment</u> <u>Strategies</u> section.

   <b>Creating</b> <b>a</b> <b>Server</b> <b>Instance</b>
       An Engine.IO server is an instance of class <b>engineio.Server</b>. This instance  can  be  transformed  into  a
       standard WSGI application by wrapping it with the <b>engineio.WSGIApp</b> class:

          import engineio

          # create a Engine.IO server
          eio = engineio.Server()

          # wrap with a WSGI application
          app = engineio.WSGIApp(eio)

       For  asyncio  based  servers,  the  <b>engineio.AsyncServer</b>  class provides the same functionality, but in a
       coroutine friendly format. If desired, The  <b>engineio.ASGIApp</b>  class  can  transform  the  server  into  a
       standard ASGI application:

          # create a Engine.IO server
          eio = engineio.AsyncServer()

          # wrap with ASGI application
          app = engineio.ASGIApp(eio)

       These  two  wrappers  can  also  act  as  middlewares, forwarding any traffic that is not intended to the
       Engine.IO server to another application. This allows Engine.IO servers to integrate easily into  existing
       WSGI or ASGI applications:

          from wsgi import app  # a Flask, Django, etc. application
          app = engineio.WSGIApp(eio, app)

   <b>Serving</b> <b>Static</b> <b>Files</b>
       The  Engine.IO  server can be configured to serve static files to clients. This is particularly useful to
       deliver HTML, CSS and JavaScript files to clients when this package  is  used  without  a  companion  web
       framework.

       Static  files  are  configured  with  a  Python  dictionary in which each key/value pair is a static file
       mapping rule. In its simplest form, this dictionary has one or more static file URLs  as  keys,  and  the
       corresponding files in the server as values:

          static_files = {
              '/': 'latency.html',
              '/static/engine.io.js': 'static/engine.io.js',
              '/static/style.css': 'static/style.css',
          }

       With  this  example configuration, when the server receives a request for <b>/</b> (the root URL) it will return
       the contents of the file <b>latency.html</b> in the current directory, and will assign a content type  based  on
       the file extension, in this case <b>text/html</b>.

       Files  with  the  <b>.html</b>,  <b>.css</b>,  <b>.js</b>,  <b>.json</b>, <b>.jpg</b>, <b>.png</b>, <b>.gif</b> and <b>.txt</b> file extensions are automatically
       recognized and assigned the correct content type. For files with other file extensions or  with  no  file
       extension, the <b>application/octet-stream</b> content type is used as a default.

       If desired, an explicit content type for a static file can be given as follows:

          static_files = {
              '/': {'filename': 'latency.html', 'content_type': 'text/plain'},
          }

       It  is  also  possible to configure an entire directory in a single rule, so that all the files in it are
       served as static files:

          static_files = {
              '/static': './public',
          }

       In this example any files with URLs starting with <b>/static</b> will be served directly from the <b>public</b>  folder
       in   the  current  directory,  so  for  example,  the  URL  <b>/static/index.html</b>  will  return  local  file
       <b>./public/index.html</b> and the URL <b>/static/css/styles.css</b> will return local file <b>./public/css/styles.css</b>.

       If a URL that ends in a <b>/</b> is requested, then a default filename of <b>index.html</b> is appended to it.  In  the
       previous example, a request for the <b>/static/</b> URL would return local file <b>./public/index.html</b>. The default
       filename to serve for slash-ending URLs can be set in the static files dictionary with an empty key:

          static_files = {
              '/static': './public',
              '': 'image.gif',
          }

       With  this  configuration,  a  request  for  <b>/static/</b>  would  return  local  file  <b>./public/image.gif</b>.  A
       non-standard content type can also be specified if needed:

          static_files = {
              '/static': './public',
              '': {'filename': 'image.gif', 'content_type': 'text/plain'},
          }

       The static file configuration dictionary is given as the <b>static_files</b> argument to the <b>engineio.WSGIApp</b> or
       <b>engineio.ASGIApp</b> classes:

          # for standard WSGI applications
          eio = engineio.Server()
          app = engineio.WSGIApp(eio, static_files=static_files)

          # for asyncio-based ASGI applications
          eio = engineio.AsyncServer()
          app = engineio.ASGIApp(eio, static_files=static_files)

       The routing precedence in these two classes is as follows:

       • First, the path is checked against the Engine.IO path.

       • Next, the path is checked against the static file configuration, if present.

       • If the path did not match the Engine.IO path or any static file, control is  passed  to  the  secondary
         application if configured, else a 404 error is returned.

       Note:  static  file serving is intended for development use only, and as such it lacks important features
       such as caching. Do not use in a production environment.

   <b>Defining</b> <b>Event</b> <b>Handlers</b>
       To responds to events triggered by the connection or the client, event Handler functions must be  defined
       using the <b>on</b> decorator:

          @eio.on('connect')
          def on_connect(sid):
              print('A client connected!')

          @eio.on('message')
          def on_message(sid, data):
              print('I received a message!')

          @eio.on('disconnect')
          def on_disconnect(sid, reason):
              print('Client disconnected! reason:', reason)

       For the <b>asyncio</b> server, event handlers can be regular functions as above, or can also be coroutines:

          @eio.on('message')
          async def on_message(sid, data):
              print('I received a message!')

       The  argument  given  to  the  <b>on</b> decorator is the event name. The events that are supported are <b>connect</b>,
       <b>message</b> and <b>disconnect</b>.

       The <b>sid</b> argument passed into all the event handlers is a connection identifier for the  client.  All  the
       events from a client will use the same <b>sid</b> value.

       The  <b>connect</b> handler is the place where the server can perform authentication. The value returned by this
       handler is used to determine if the connection is accepted or rejected. When the handler does not  return
       any  value  (which  is the same as returning <b>None</b>) or when it returns <b>True</b> the connection is accepted. If
       the handler returns <b>False</b> or any JSON compatible data type (string,  integer,  list  or  dictionary)  the
       connection is rejected. A rejected connection triggers a response with a 401 status code.

       The  <b>data</b>  argument  passed to the <b>'message'</b> event handler contains application-specific data provided by
       the client with the event.

       The <b>disconnect</b> handler is invoked for client initiated  disconnects,  server  initiated  disconnects,  or
       accidental  disconnects,  for  example  due  to  networking  failures. The second argument passed to this
       handler provides the disconnect reason. Example:

          @eio.on('disconnect')
          def on_disconnect(sid, reason):
              if reason == eio.reason.CLIENT_DISCONNECT:
                  print('the client went away')
              elif reason == eio.reason.SERVER_DISCONNECT:
                  print('the client was kicked out')
              else:
                  print(f'disconnect reason: {reason}')

   <b>Sending</b> <b>Messages</b>
       The server can send a message to any client using the <b>send()</b> method:

          eio.send(sid, {'foo': 'bar'})

       Or in the case of <b>asyncio</b>, as a coroutine:

          await eio.send(sid, {'foo': 'bar'})

       The first argument provided to the method is the connection identifier  for  the  recipient  client.  The
       second  argument is the data that is passed on to the server. The data can be of type <b>str</b>, <b>bytes</b>, <b>dict</b> or
       <b>list</b>. The data included inside dictionaries and lists is also constrained to these types.

       The <b>send()</b> method can be invoked inside an event handler as a response to a client event, or in any other
       part of the application, including in background tasks.

   <b>User</b> <b>Sessions</b>
       The server can maintain application-specific information in a user session dedicated  to  each  connected
       client.  Applications  can  use  the  user  session  to  write any details about the user that need to be
       preserved throughout the life of the connection, such as usernames or user ids.

       The <b>save_session()</b> and <b>get_session()</b> methods are used to store  and  retrieve  information  in  the  user
       session:

          @eio.on('connect')
          def on_connect(sid, environ):
              username = authenticate_user(environ)
              eio.save_session(sid, {'username': username})

          @eio.on('message')
          def on_message(sid, data):
              session = eio.get_session(sid)
              print('message from ', session['username'])

       For the <b>asyncio</b> server, these methods are coroutines:

          @eio.on('connect')
          async def on_connect(sid, environ):
              username = authenticate_user(environ)
              await eio.save_session(sid, {'username': username})

          @eio.on('message')
          async def on_message(sid, data):
              session = await eio.get_session(sid)
              print('message from ', session['username'])

       The session can also be manipulated with the <u>session()</u> context manager:

          @eio.on('connect')
          def on_connect(sid, environ):
              username = authenticate_user(environ)
              with eio.session(sid) as session:
                  session['username'] = username

          @eio.on('message')
          def on_message(sid, data):
              with eio.session(sid) as session:
                  print('message from ', session['username'])

       For the <b>asyncio</b> server, an asynchronous context manager is used:

          @eio.on('connect')
          def on_connect(sid, environ):
              username = authenticate_user(environ)
              async with eio.session(sid) as session:
                  session['username'] = username

          @eio.on('message')
          def on_message(sid, data):
              async with eio.session(sid) as session:
                  print('message from ', session['username'])

       Note: the contents of the user session are destroyed when the client disconnects.

   <b>Disconnecting</b> <b>a</b> <b>Client</b>
       At  any  time  the server can disconnect a client from the server by invoking the <b>disconnect()</b> method and
       passing the <b>sid</b> value assigned to the client:

          eio.disconnect(sid)

       For the <b>asyncio</b> client this is a coroutine:

          await eio.disconnect(sid)

   <b>Managing</b> <b>Background</b> <b>Tasks</b>
       For the convenience of the application, a helper function is provided to start a custom background task:

          def <a href="../manmy_argument/my_background_task.my_argument.html">my_background_task</a>(my_argument)
              # do some background work here!
              pass

          eio.start_background_task(my_background_task, 123)

       The arguments passed to this method are the background function and any positional or  keyword  arguments
       to invoke the function with.

       Here is the <b>asyncio</b> version:

          async def <a href="../manmy_argument/my_background_task.my_argument.html">my_background_task</a>(my_argument)
              # do some background work here!
              pass

          eio.start_background_task(my_background_task, 123)

       Note  that  this  function is not a coroutine, since it does not wait for the background function to end,
       but the background function is.

       The <b>sleep()</b> method is a second convenience function that is provided  for  the  benefit  of  applications
       working with background tasks of their own:

          <a href="../man2/eio.sleep.2.html">eio.sleep</a>(2)

       Or for <b>asyncio</b>:

          await <a href="../man2/eio.sleep.2.html">eio.sleep</a>(2)

       The single argument passed to the method is the number of seconds to sleep for.

   <b>Debugging</b> <b>and</b> <b>Troubleshooting</b>
       To help you debug issues, the server can be configured to output logs to the terminal:

          import engineio

          # standard Python
          eio = engineio.Server(logger=True)

          # asyncio
          eio = engineio.AsyncServer(logger=True)

       The <b>logger</b> argument can be set to <b>True</b> to output logs to <b>stderr</b>, or to an object compatible with Python's
       <b>logging</b> package where the logs should be emitted to. A value of <b>False</b> disables logging.

       Logging  can  help  identify  the  cause of connection problems, 400 responses, bad performance and other
       issues.

   <b>Deployment</b> <b>Strategies</b>
       The following sections describe a variety of deployment strategies for Engine.IO servers.

   <b>Uvicorn,</b> <b>Daphne,</b> <b>and</b> <b>other</b> <b>ASGI</b> <b>servers</b>
       The <b>engineio.ASGIApp</b> class is an ASGI compatible application that can forward  Engine.IO  traffic  to  an
       <b>engineio.AsyncServer</b> instance:

          eio = engineio.AsyncServer(async_mode='asgi')
          app = engineio.ASGIApp(eio)

       If  desired,  the  <b>engineio.ASGIApp</b>  class  can forward any traffic that is not Engine.IO to another ASGI
       application, making it possible to deploy a standard ASGI web application and the Engine.IO server  as  a
       bundle:

          eio = engineio.AsyncServer(async_mode='asgi')
          app = engineio.ASGIApp(eio, other_app)

       The  <b>ASGIApp</b> instance is a fully complaint ASGI instance that can be deployed with an ASGI compatible web
       server.

   <b>Aiohttp</b>
       <u>aiohttp</u> provides a framework with support for HTTP and WebSocket, based on asyncio.

       Instances of class <b>engineio.AsyncServer</b> will automatically use aiohttp for asynchronous operations if the
       library is installed. To request  its  use  explicitly,  the  <b>async_mode</b>  option  can  be  given  in  the
       constructor:

          eio = engineio.AsyncServer(async_mode='aiohttp')

       A server configured for aiohttp must be attached to an existing application:

          app = web.Application()
          eio.attach(app)

       The  aiohttp application can define regular routes that will coexist with the Engine.IO server. A typical
       pattern is to add routes that serve a client application and any associated static files.

       The aiohttp application is then executed in the usual manner:

          if __name__ == '__main__':
              web.run_app(app)

   <b>Tornado</b>
       <u>Tornado</u> is a web framework with support for HTTP and WebSocket. Only Tornado  version  5  and  newer  are
       supported, thanks to its tight integration with asyncio.

       Instances of class <b>engineio.AsyncServer</b> will automatically use tornado for asynchronous operations if the
       library  is  installed.  To  request  its  use  explicitly,  the  <b>async_mode</b>  option  can be given in the
       constructor:

          eio = engineio.AsyncServer(async_mode='tornado')

       A server configured for tornado must include a request handler for Engine.IO:

          app = tornado.web.Application(
              [
                  (r"/engine.io/", engineio.get_tornado_handler(eio)),
              ],
              # ... other application options
          )

       The tornado application can define other routes that will coexist with the Engine.IO  server.  A  typical
       pattern is to add routes that serve a client application and any associated static files.

       The tornado application is then executed in the usual manner:

          app.listen(port)
          tornado.ioloop.IOLoop.current().start()

   <b>Sanic</b>
       Note:  Due  to some backward incompatible changes introduced in recent versions of Sanic, it is currently
       recommended that a Sanic application is deployed with the ASGI integration instead.

       <u>Sanic</u> is a very efficient asynchronous web server for Python.

       Instances of class <b>engineio.AsyncServer</b> will automatically use Sanic for asynchronous operations  if  the
       framework  is  installed.  To  request  its  use  explicitly,  the  <b>async_mode</b> option can be given in the
       constructor:

          eio = engineio.AsyncServer(async_mode='sanic')

       A server configured for Sanic must be attached to an existing application:

          app = Sanic()
          eio.attach(app)

       The Sanic application can define regular routes that will coexist with the Engine.IO  server.  A  typical
       pattern  is  to  add  routes  that  serve  a  client  application and any associated static files to this
       application.

       The Sanic application is then executed in the usual manner:

          if __name__ == '__main__':
              app.run()

       It has been reported that the CORS support provided by the Sanic  extension  <u>sanic-cors</u>  is  incompatible
       with  this package's own support for this protocol. To disable CORS support in this package and let Sanic
       take full control, initialize the server as follows:

          eio = engineio.AsyncServer(async_mode='sanic', cors_allowed_origins=[])

       On the Sanic side you will need to enable the <u>CORS_SUPPORTS_CREDENTIALS</u> setting in addition to any  other
       configuration that you use:

          app.config['CORS_SUPPORTS_CREDENTIALS'] = True

   <b>Eventlet</b>
       <u>Eventlet</u>  is  a  high  performance concurrent networking library for Python 2 and 3 that uses coroutines,
       enabling code to be written in the same style used with  the  blocking  standard  library  functions.  An
       Engine.IO server deployed with eventlet has access to the long-polling and WebSocket transports.

       Instances  of  class  <b>engineio.Server</b>  will automatically use eventlet for asynchronous operations if the
       library is installed. To request  its  use  explicitly,  the  <b>async_mode</b>  option  can  be  given  in  the
       constructor:

          eio = engineio.Server(async_mode='eventlet')

       A  server  configured  for  eventlet  is  deployed  as  a  regular  WSGI  application  using the provided
       <b>engineio.WSGIApp</b>:

          app = engineio.WSGIApp(eio)
          import eventlet
          eventlet.wsgi.server(eventlet.listen(('', 8000)), app)

   <b>Eventlet</b> <b>with</b> <b>Gunicorn</b>
       An alternative to running the eventlet WSGI server as above is to use <u>gunicorn</u>,  a  fully  featured  pure
       Python web server. The command to launch the application under gunicorn is shown below:

          $ gunicorn -k eventlet -w 1 module:app

       Due to limitations in its load balancing algorithm, gunicorn can only be used with one worker process, so
       the  <b>-w</b>  <b>1</b> option is required. Note that a single eventlet worker can handle a large number of concurrent
       clients.

       Another limitation when using gunicorn is that the WebSocket transport is  not  available,  because  this
       transport it requires extensions to the WSGI standard.

       Note:  Eventlet  provides  a  <b>monkey_patch()</b>  function  that  replaces  all the blocking functions in the
       standard library with equivalent asynchronous versions. While python-engineio  does  not  require  monkey
       patching, other libraries such as database drivers are likely to require it.

   <b>Gevent</b>
       <u>Gevent</u>  is  another  asynchronous  framework  based on coroutines, very similar to eventlet. An Engine.IO
       server deployed with gevent has access to the long-polling and websocket transports.

       Instances of class <b>engineio.Server</b> will automatically use  gevent  for  asynchronous  operations  if  the
       library  is  installed  and  eventlet  is not installed. To request gevent to be selected explicitly, the
       <b>async_mode</b> option can be given in the constructor:

          eio = engineio.Server(async_mode='gevent')

       A  server  configured  for  gevent  is  deployed  as  a  regular  WSGI  application  using  the  provided
       <b>engineio.WSGIApp</b>:

          from gevent import pywsgi
          app = engineio.WSGIApp(eio)
          pywsgi.WSGIServer(('', 8000), app).serve_forever()

   <b>Gevent</b> <b>with</b> <b>Gunicorn</b>
       An  alternative  to  running  the  gevent  WSGI server as above is to use <u>gunicorn</u>, a fully featured pure
       Python web server. The command to launch the application under gunicorn is shown below:

          $ gunicorn -k gevent -w 1 module:app

       Same as with eventlet, due to limitations in its load balancing algorithm, gunicorn can only be used with
       one worker process, so the <b>-w</b> <b>1</b> option is required. Note that a single gevent worker can handle  a  large
       number of concurrent clients.

       Note:  Gevent provides a <b>monkey_patch()</b> function that replaces all the blocking functions in the standard
       library with equivalent asynchronous versions. While python-engineio does not  require  monkey  patching,
       other libraries such as database drivers are likely to require it.

   <b>uWSGI</b>
       When  using  the  uWSGI  server  in  combination  with gevent, the Engine.IO server can take advantage of
       uWSGI's native WebSocket support.

       Instances of class <b>engineio.Server</b> will automatically use this option for asynchronous operations if both
       gevent and uWSGI are installed and  eventlet  is  not  installed.  To  request  this  asynchoronous  mode
       explicitly, the <b>async_mode</b> option can be given in the constructor:

          # gevent with uWSGI
          eio = engineio.Server(async_mode='gevent_uwsgi')

       A  complete  explanation  of  the configuration and usage of the uWSGI server is beyond the scope of this
       documentation. The uWSGI server is a fairly complex package that provides a large and  comprehensive  set
       of  options.  It  must  be  compiled  with  WebSocket  and  SSL support for the WebSocket transport to be
       available. As way of an introduction, the following command starts a  uWSGI  server  for  the  <b>latency.py</b>
       example on port 5000:

          $ uwsgi --http :5000 --gevent 1000 --http-websockets --master --wsgi-file latency.py --callable app

   <b>Standard</b> <b>Threads</b>
       While  not  comparable  to  eventlet and gevent in terms of performance, the Engine.IO server can also be
       configured to work with multi-threaded web servers that use standard Python threads.  This  is  an  ideal
       setup to use with development servers such as <u>Werkzeug</u>.

       Instances  of  class  <b>engineio.Server</b>  will  automatically use the threading mode if neither eventlet nor
       gevent are not installed. To request the threading mode explicitly, the <b>async_mode</b> option can be given in
       the constructor:

          eio = engineio.Server(async_mode='threading')

       A server configured for threading is deployed as a regular web  application,  using  any  WSGI  complaint
       multi-threaded  server.  The  example  below  deploys  an Engine.IO application combined with a Flask web
       application, using Flask's development web server based on Werkzeug:

          eio = engineio.Server(async_mode='threading')
          app = Flask(__name__)
          app.wsgi_app = engineio.WSGIApp(eio, app.wsgi_app)

          # ... Engine.IO and Flask handler functions ...

          if __name__ == '__main__':
              app.run()

       The example that follows shows how to start an Engine.IO application  using  Gunicorn's  threaded  worker
       class:

          $ gunicorn -w 1 --threads 100 module:app

       With the above configuration the server will be able to handle up to 100 concurrent clients.

       When  using  standard threads, WebSocket is supported through the <u>simple-websocket</u> package, which must be
       installed separately. This package provides a multi-threaded WebSocket server  that  is  compatible  with
       Werkzeug  and Gunicorn's threaded worker. Other multi-threaded web servers are not supported and will not
       enable the WebSocket transport.

   <b>Scalability</b> <b>Notes</b>
       Engine.IO is a stateful protocol, which makes horizontal scaling more difficult. To deploy a  cluster  of
       Engine.IO processes hosted on one or multiple servers the following conditions must be met:

       • Each  Engine.IO  server process must be able to handle multiple requests concurrently. This is required
         because long-polling clients send two requests in parallel. Worker processes that can only  handle  one
         request at a time are not supported.

       • The load balancer must be configured to always forward requests from a client to the same process. Load
         balancers call this <u>sticky</u> <u>sessions</u>, or <u>session</u> <u>affinity</u>.

   <b>Cross-Origin</b> <b>Controls</b>
       For  security  reasons,  this  server  enforces a same-origin policy by default. In practical terms, this
       means the following:

       • If an incoming HTTP or WebSocket request includes the <b>Origin</b> header, this header must match the  scheme
         and  host  of the connection URL. In case of a mismatch, a 400 status code response is returned and the
         connection is rejected.

       • No restrictions are imposed on incoming requests that do not include the <b>Origin</b> header.

       If necessary, the <b>cors_allowed_origins</b> option can be used to allow other origins. This  argument  can  be
       set  to  a string to set a single allowed origin, or to a list to allow multiple origins. A special value
       of <b>'*'</b> can be used to instruct the server to allow all origins, but this should be  done  with  care,  as
       this could make the server vulnerable to Cross-Site Request Forgery (CSRF) attacks.

</pre><h4><b>API</b> <b>REFERENCE</b></h4><pre>
       • <u>Index</u>

       • <u>Module</u> <u>Index</u>

       • <u>Search</u> <u>Page</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Miguel Grinberg

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2018, Miguel Grinberg

                                                  Mar 10, 2025                                <u><a href="../man1/PYTHON-ENGINEIO.1.html">PYTHON-ENGINEIO</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>