<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mpi4py - MPI for Python</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/noble/+package/python-mpi4py-doc">python-mpi4py-doc_3.1.5-5ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mpi4py - MPI for Python

       <b>Author</b> Lisandro Dalcin

       <b>Contact</b>
              <u><a href="mailto:dalcinl@gmail.com">dalcinl@gmail.com</a></u>

       <b>Date</b>   April 01, 2024

   <b>Abstract</b>
       This  document  describes  the  <u>MPI</u>  <u>for</u>  <u>Python</u> package. <u>MPI</u> <u>for</u> <u>Python</u> provides Python bindings for the
       <u>Message</u> <u>Passing</u> <u>Interface</u> (MPI) standard, allowing Python applications to exploit multiple processors  on
       workstations, clusters and supercomputers.

       This  package  builds  on  the MPI specification and provides an object oriented interface resembling the
       MPI-2 C++ bindings. It supports point-to-point (sends, receives) and  collective  (broadcasts,  scatters,
       gathers)  communication  of  any  <u>picklable</u>  Python  object, as well as efficient communication of Python
       objects exposing the Python buffer  interface  (e.g.  NumPy  arrays  and  builtin  bytes/array/memoryview
       objects).

</pre><h4><b>INTRODUCTION</b></h4><pre>
       Over  the  last  years,  high  performance  computing  has  become  an  affordable  resource to many more
       researchers in the scientific community than ever before. The conjunction of quality open source software
       and commodity hardware strongly influenced the now widespread popularity of <u>Beowulf</u>  class  clusters  and
       cluster of workstations.

       Among  many  parallel  computational  models,  message-passing  has  proven to be an effective one.  This
       paradigm is specially suited for (but not limited to) distributed memory architectures  and  is  used  in
       today’s  most  demanding  scientific and engineering application related to modeling, simulation, design,
       and signal processing.  However, portable message-passing parallel programming used to be a nightmare  in
       the  past because of the many incompatible options developers were faced to.  Fortunately, this situation
       definitely changed after the MPI Forum released its standard specification.

       High  performance  computing  is  traditionally  associated  with  software  development  using  compiled
       languages.  However,  in  typical  applications  programs, only a small part of the code is time-critical
       enough to require the efficiency of compiled languages. The rest of the  code  is  generally  related  to
       memory  management,  error  handling,  input/output, and user interaction, and those are usually the most
       error prone and time-consuming lines of code to  write  and  debug  in  the  whole  development  process.
       Interpreted high-level languages can be really advantageous for this kind of tasks.

       For  implementing  general-purpose  numerical  computations,  MATLAB  [1]  is  the  dominant  interpreted
       programming language. In the open source side, Octave and  Scilab  are  well  known,  freely  distributed
       software  packages  providing  compatibility  with  the MATLAB language. In this work, we present MPI for
       Python, a new package enabling applications to exploit multiple processors using standard MPI  “look  and
       feel” in Python scripts.

       [1]  MATLAB is a registered trademark of The MathWorks, Inc.

   <b>What</b> <b>is</b> <b>MPI?</b>
       <u>MPI</u>,  <u>[mpi-using]</u> <u>[mpi-ref]</u> the <u>Message</u> <u>Passing</u> <u>Interface</u>, is a standardized and portable message-passing
       system designed to function on a wide variety of parallel computers. The standard defines the syntax  and
       semantics  of  library  routines  and  allows  users  to  write  portable programs in the main scientific
       programming languages (Fortran, C, or C++).

       Since its release, the MPI specification <u>[mpi-std1]</u>  <u>[mpi-std2]</u>  has  become  the  leading  standard  for
       message-passing  libraries  for  parallel  computers.   Implementations  are  available  from  vendors of
       high-performance computers and from well known open source projects like <u>MPICH</u> <u>[mpi-mpich]</u> and  <u>Open</u>  <u>MPI</u>
       <u>[mpi-openmpi]</u>.

   <b>What</b> <b>is</b> <b>Python?</b>
       <u>Python</u>  is  a  modern,  easy  to  learn,  powerful programming language. It has efficient high-level data
       structures and a simple but effective approach to object-oriented programming  with  dynamic  typing  and
       dynamic  binding.  It  supports modules and packages, which encourages program modularity and code reuse.
       Python’s elegant syntax, together with its interpreted nature, make it an ideal  language  for  scripting
       and rapid application development in many areas on most platforms.

       The  Python interpreter and the extensive standard library are available in source or binary form without
       charge for all major platforms, and can be freely distributed. It is easily extended with  new  functions
       and data types implemented in C or C++. Python is also suitable as an extension language for customizable
       applications.

       Python  is  an  ideal candidate for writing the higher-level parts of large-scale scientific applications
       <u>[Hinsen97]</u> and driving simulations in parallel architectures <u>[Beazley97]</u> like clusters of PC’s or  SMP’s.
       Python  codes are quickly developed, easily maintained, and can achieve a high degree of integration with
       other libraries written in compiled languages.

   <b>Related</b> <b>Projects</b>
       As this work started and evolved, some ideas were borrowed from well known MPI and  Python  related  open
       source projects from the Internet.

       • <u>OOMPI</u>

         • It has no relation with Python, but is an excellent object oriented approach to MPI.

         • It is a C++ class library specification layered on top of the C bindings that encapsulates MPI into a
           functional class hierarchy.

         • It  provides a flexible and intuitive interface by adding some abstractions, like <u>Ports</u> and <u>Messages</u>,
           which enrich and simplify the syntax.

       • <u>Pypar</u>

         • Its interface is rather minimal. There is no support for communicators or process topologies.

         • It does not require the Python interpreter  to  be  modified  or  recompiled,  but  does  not  permit
           interactive parallel runs.

         • General (<u>picklable</u>) Python objects of any type can be communicated. There is good support for numeric
           arrays, practically full MPI bandwidth can be achieved.

       • <u>pyMPI</u>

         • It  rebuilds  the  Python interpreter providing a built-in module for message passing. It does permit
           interactive parallel runs, which are useful for learning and debugging.

         • It provides an interface suitable for basic parallel programing.   There  is  not  full  support  for
           defining new communicators or process topologies.

         • General  (picklable)  Python  objects  can  be  messaged between processors. There is not support for
           numeric arrays.

       • <u>Scientific</u> <u>Python</u>

         • It provides a collection of Python modules that are useful for scientific computing.

         • There is an interface to MPI and BSP (<u>Bulk</u> <u>Synchronous</u> <u>Parallel</u> <u>programming</u>).

         • The interface is simple but incomplete and does not resemble the MPI specification. There is  support
           for numeric arrays.

       Additionally,  we  would  like  to  mention  some  available  tools for scientific computing and software
       development with Python.

       • <u>NumPy</u> is a package that provides array manipulation and computational  capabilities  similar  to  those
         found  in  IDL,  MATLAB,  or Octave. Using NumPy, it is possible to write many efficient numerical data
         processing applications directly in Python without using any C, C++ or Fortran code.

       • <u>SciPy</u> is an open source library of scientific tools for Python,  gathering  a  variety  of  high  level
         science  and  engineering  modules  together  as a single package. It includes modules for graphics and
         plotting,  optimization,  integration,  special  functions,  signal  and  image   processing,   genetic
         algorithms, ODE solvers, and others.

       • <u>Cython</u>  is a language that makes writing C extensions for the Python language as easy as Python itself.
         The Cython language is very close to the Python language, but Cython additionally  supports  calling  C
         functions and declaring C types on variables and class attributes. This allows the compiler to generate
         very  efficient C code from Cython code. This makes Cython the ideal language for wrapping for external
         C libraries, and for fast C modules that speed up the execution of Python code.

       • <u>SWIG</u> is a software development tool that connects programs written in C  and  C++  with  a  variety  of
         high-level  programming  languages  like Perl, Tcl/Tk, Ruby and Python. Issuing header files to SWIG is
         the simplest approach to interfacing C/C++ libraries from a Python module.

       [mpi-std1]
            MPI Forum. MPI: A Message  Passing  Interface  Standard.   International  Journal  of  Supercomputer
            Applications, volume 8, number 3-4, pages 159-416, 1994.

       [mpi-std2]
            MPI  Forum.  MPI:  A  Message  Passing Interface Standard.  High Performance Computing Applications,
            volume 12, number 1-2, pages 1-299, 1998.

       [mpi-using]
            William Gropp, Ewing Lusk, and Anthony Skjellum.  Using MPI: portable parallel programming with  the
            message-passing interface.  MIT Press, 1994.

       [mpi-ref]
            Mark  Snir,  Steve  Otto, Steven Huss-Lederman, David Walker, and Jack Dongarra.  MPI - The Complete
            Reference, volume 1, The MPI Core.  MIT Press, 2nd. edition, 1998.

       [mpi-mpich]
            W. Gropp, E. Lusk, N. Doss, and A. Skjellum.  A high-performance, portable implementation of the MPI
            message passing interface standard.  Parallel Computing, <a href="../man6/22.6.html">22</a>(6):789-828, September 1996.

       [mpi-openmpi]
            Edgar Gabriel, Graham E. Fagg, George Bosilca, Thara Angskun, Jack J. Dongarra, Jeffrey M.  Squyres,
            Vishal  Sahay,  Prabhanjan  Kambadur,  Brian  Barrett,  Andrew Lumsdaine, Ralph H. Castain, David J.
            Daniel, Richard L. Graham, and Timothy S. Woodall. Open MPI: Goals, Concept, and Design  of  a  Next
            Generation MPI Implementation. In Proceedings, 11th European PVM/MPI Users’ Group Meeting, Budapest,
            Hungary, September 2004.

       [Hinsen97]
            Konrad  Hinsen.   The Molecular Modelling Toolkit: a case study of a large scientific application in
            Python.  In Proceedings of the 6th International Python Conference,  pages  29-35,  San  Jose,  Ca.,
            October 1997.

       [Beazley97]
            David  M.  Beazley  and  Peter S. Lomdahl.  Feeding a large-scale physics application to Python.  In
            Proceedings of the 6th International Python Conference, pages 21-29, San Jose, Ca., October 1997.

</pre><h4><b>OVERVIEW</b></h4><pre>
       MPI for Python provides an object oriented approach to message passing  which  grounds  on  the  standard
       MPI-2  C++  bindings.  The  interface  was designed with focus in translating MPI syntax and semantics of
       standard MPI-2 bindings for C++ to Python. Any user of the standard C/C++ MPI bindings should be able  to
       use this module without need of learning a new interface.

   <b>Communicating</b> <b>Python</b> <b>Objects</b> <b>and</b> <b>Array</b> <b>Data</b>
       The Python standard library supports different mechanisms for data persistence. Many of them rely on disk
       storage, but <u>pickling</u> and <u>marshaling</u> can also work with memory buffers.

       The  <u>pickle</u> modules provide user-extensible facilities to serialize general Python objects using ASCII or
       binary formats. The <u>marshal</u> module provides facilities to  serialize  built-in  Python  objects  using  a
       binary format specific to Python, but independent of machine architecture issues.

       <u>MPI</u>  <u>for</u>  <u>Python</u>  can  communicate  any  built-in  or  user-defined Python object taking advantage of the
       features provided by the <u>pickle</u>  module.  These  facilities  will  be  routinely  used  to  build  binary
       representations  of  objects to communicate (at sending processes), and restoring them back (at receiving
       processes).

       Although simple and general, the  serialization  approach  (i.e.,  <u>pickling</u>  and  <u>unpickling</u>)  previously
       discussed imposes important overheads in memory as well as processor usage, especially in the scenario of
       objects  with  large  memory footprints being communicated. Pickling general Python objects, ranging from
       primitive or container built-in types to user-defined classes, necessarily requires  computer  resources.
       Processing  is also needed for dispatching the appropriate serialization method (that depends on the type
       of the object) and doing the actual packing. Additional memory is always needed, and if its total  amount
       is  not  known <u>a</u> <u>priori</u>, many reallocations can occur.  Indeed, in the case of large numeric arrays, this
       is certainly unacceptable and precludes communication of objects occupying half or more of the  available
       memory resources.

       <u>MPI</u> <u>for</u> <u>Python</u> supports direct communication of any object exporting the single-segment buffer interface.
       This  interface is a standard Python mechanism provided by some types (e.g., strings and numeric arrays),
       allowing access in the C side to a contiguous memory buffer (i.e., address  and  length)  containing  the
       relevant  data.  This  feature,  in  conjunction  with  the  capability  of constructing user-defined MPI
       datatypes describing complicated memory layouts, enables the implementation of many algorithms  involving
       multidimensional  numeric  arrays  (e.g.,  image  processing,  fast Fourier transforms, finite difference
       schemes on structured Cartesian grids) directly in Python, with negligible overhead, and almost  as  fast
       as compiled Fortran, C, or C++ codes.

   <b>Communicators</b>
       In  <u>MPI</u>  <u>for</u>  <u>Python</u>,  <u>Comm</u>  is  the base class of communicators. The <u>Intracomm</u> and <u>Intercomm</u> classes are
       sublcasses of the <u>Comm</u> class.  The <b>Comm.Is_inter</b> method (and <b>Comm.Is_intra</b>, provided for convenience  but
       not  part  of the MPI specification) is defined for communicator objects and can be used to determine the
       particular communicator class.

       The two predefined intracommunicator instances are available: <b>COMM_SELF</b> and <b>COMM_WORLD</b>.  From  them,  new
       communicators can be created as needed.

       The  number of processes in a communicator and the calling process rank can be respectively obtained with
       methods  <b>Comm.Get_size</b>  and  <b>Comm.Get_rank</b>.  The  associated  process  group  can  be  retrieved  from  a
       communicator  by  calling  the  <b>Comm.Get_group</b>  method, which returns an instance of the <b>Group</b> class. Set
       operations with <b>Group</b> objects like like <b>Group.Union</b>, <b>Group.Intersection</b> and  <b>Group.Difference</b>  are  fully
       supported,  as  well  as  the  creation  of  new  communicators  from  these groups using <b>Comm.Create</b> and
       <b>Comm.Create_group</b>.

       New communicator instances can be obtained with the <b>Comm.Clone</b>, <b>Comm.Dup</b> and <b>Comm.Split</b> methods, as  well
       methods <b>Intracomm.Create_intercomm</b> and <b>Intercomm.Merge</b>.

       Virtual  topologies  (<b>Cartcomm</b>,  <b>Graphcomm</b>  and  <b>Distgraphcomm</b>  classes, which are specializations of the
       <u>Intracomm</u> class) are fully supported. New instances can be obtained from intracommunicator instances with
       factory methods <b>Intracomm.Create_cart</b> and <b>Intracomm.Create_graph</b>.

   <b>Point-to-Point</b> <b>Communications</b>
       Point to point communication is a fundamental capability  of  message  passing  systems.  This  mechanism
       enables the transmission of data between a pair of processes, one side sending, the other receiving.

       MPI  provides  a  set  of  <u>send</u>  and  <u>receive</u>  functions allowing the communication of <u>typed</u> data with an
       associated <u>tag</u>.  The type information enables the conversion of data representation from one architecture
       to  another  in  the  case  of  heterogeneous  computing  environments;  additionally,  it   allows   the
       representation  of  non-contiguous data layouts and user-defined datatypes, thus avoiding the overhead of
       (otherwise unavoidable) packing/unpacking operations. The tag information allows selectivity of  messages
       at the receiving end.

   <b>Blocking</b> <b>Communications</b>
       MPI  provides basic send and receive functions that are <u>blocking</u>.  These functions block the caller until
       the data buffers involved in the communication can be safely reused by the application program.

       In <u>MPI</u> <u>for</u> <u>Python</u>, the <b>Comm.Send</b>, <b>Comm.Recv</b> and <b>Comm.Sendrecv</b> methods  of  communicator  objects  provide
       support  for  blocking  point-to-point  communications  within  <u>Intracomm</u>  and <u>Intercomm</u> instances. These
       methods can  communicate  memory  buffers.  The  variants  <u>Comm.send</u>,  <u>Comm.recv</u>  and  <u>Comm.sendrecv</u>  can
       communicate general Python objects.

   <b>Nonblocking</b> <b>Communications</b>
       On many systems, performance can be significantly increased by overlapping communication and computation.
       This  is particularly true on systems where communication can be executed autonomously by an intelligent,
       dedicated communication controller.

       MPI provides <u>nonblocking</u> send and receive functions. They allow the possible overlap of communication and
       computation.  Non-blocking communication always come in two parts: posting  functions,  which  begin  the
       requested  operation;  and  test-for-completion  functions, which allow to discover whether the requested
       operation has completed.

       In <u>MPI</u> <u>for</u>  <u>Python</u>,  the  <b>Comm.Isend</b>  and  <b>Comm.Irecv</b>  methods  initiate  send  and  receive  operations,
       respectively.  These  methods return a <u>Request</u> instance, uniquely identifying the started operation.  Its
       completion can be managed using the <b>Request.Test</b>, <b>Request.Wait</b> and <b>Request.Cancel</b> methods. The management
       of <u>Request</u> objects and associated memory buffers involved in communication  requires  a  careful,  rather
       low-level  coordination. Users must ensure that objects exposing their memory buffers are not accessed at
       the Python level while they are involved in nonblocking message-passing operations.

   <b>Persistent</b> <b>Communications</b>
       Often a communication with the same argument list is repeatedly executed within an inner  loop.  In  such
       cases,  communication  can  be  further optimized by using persistent communication, a particular case of
       nonblocking communication allowing the reduction of the  overhead  between  processes  and  communication
       controllers.  Furthermore  ,  this  kind  of  optimization  can  also  alleviate the extra call overheads
       associated to interpreted, dynamic languages like Python.

       In <u>MPI</u> <u>for</u> <u>Python</u>, the <b>Comm.Send_init</b> and <b>Comm.Recv_init</b> methods create persistent requests  for  a  send
       and  receive operation, respectively.  These methods return an instance of the <b>Prequest</b> class, a subclass
       of the <u>Request</u> class. The actual communication  can  be  effectively  started  using  the  <b>Prequest.Start</b>
       method, and its completion can be managed as previously described.

   <b>Collective</b> <b>Communications</b>
       Collective  communications  allow  the  transmittal  of  data  between  multiple  processes  of  a  group
       simultaneously. The syntax and semantics  of  collective  functions  is  consistent  with  point-to-point
       communication.  Collective  functions  communicate  <u>typed</u>  data,  but  messages  are  not  paired with an
       associated <u>tag</u>; selectivity of messages  is  implied  in  the  calling  order.  Additionally,  collective
       functions come in blocking versions only.

       The more commonly used collective communication operations are the following.

       • Barrier synchronization across all group members.

       • Global communication functions

         • Broadcast data from one member to all members of a group.

         • Gather data from all members to one member of a group.

         • Scatter data from one member to all members of a group.

       • Global reduction operations such as sum, maximum, minimum, etc.

       In  <u>MPI</u>  <u>for</u>  <u>Python</u>,  the  <b>Comm.Bcast</b>,  <b>Comm.Scatter</b>, <b>Comm.Gather</b>, <b>Comm.Allgather</b>, <b>Comm.Alltoall</b> methods
       provide support for collective communications of memory  buffers.  The  lower-case  variants  <u>Comm.bcast</u>,
       <b>Comm.scatter</b>,  <b>Comm.gather</b>, <b>Comm.allgather</b> and <b>Comm.alltoall</b> can communicate general Python objects.  The
       vector variants (which can  communicate  different  amounts  of  data  to  each  process)  <b>Comm.Scatterv</b>,
       <b>Comm.Gatherv</b>,  <b>Comm.Allgatherv</b>,  <b>Comm.Alltoallv</b>  and  <b>Comm.Alltoallw</b>  are  also  supported, they can only
       communicate objects exposing memory buffers.

       Global reducion operations on memory buffers are accessible through the <b>Comm.Reduce</b>, <b>Comm.Reduce_scatter</b>,
       <b>Comm.Allreduce</b>,  <b>Intracomm.Scan</b>  and  <b>Intracomm.Exscan</b>  methods.  The  lower-case  variants  <b>Comm.reduce</b>,
       <b>Comm.allreduce</b>,  <b>Intracomm.scan</b> and <b>Intracomm.exscan</b> can communicate general Python objects; however, the
       actual required reduction computations are performed sequentially at some  process.  All  the  predefined
       (i.e., <b>SUM</b>, <b>PROD</b>, <b>MAX</b>, etc.)  reduction operations can be applied.

   <b>Support</b> <b>for</b> <b>GPU-aware</b> <b>MPI</b>
       Several MPI implementations, including Open MPI and MVAPICH, support passing GPU pointers to MPI calls to
       avoid  explict  data  movement  between the host and the device. On the Python side, GPU arrays have been
       implemented by many libraries that need GPU computation, such as CuPy, Numba, PyTorch,  and  PyArrow.  In
       order  to  increase  library interoperability, two kinds of zero-copy data exchange protocols are defined
       and agreed upon: <u>DLPack</u> and <u>CUDA</u> <u>Array</u> <u>Interface</u>. For example, a CuPy array can  be  passed  to  a  Numba
       CUDA-jit kernel.

       <u>MPI</u> <u>for</u> <u>Python</u> provides an experimental support for GPU-aware MPI.  This feature requires:

       1. mpi4py is built against a GPU-aware MPI library.

       2. The Python GPU arrays are compliant with either of the protocols.

       See the <u>Tutorial</u> section for further information. We note that

       • Whether  or not a MPI call can work for GPU arrays depends on the underlying MPI implementation, not on
         mpi4py.

       • This support is currently experimental and subject to change in the future.

   <b>Dynamic</b> <b>Process</b> <b>Management</b>
       In the context of the MPI-1 specification, a parallel application is static; that is, no processes can be
       added to or deleted from a running application after it has been started.  Fortunately,  this  limitation
       was  addressed  in  MPI-2.  The  new  specification  added  a  process management model providing a basic
       interface between an application and external resources and process managers.

       This MPI-2 extension can be really useful,  especially  for  sequential  applications  built  on  top  of
       parallel modules, or parallel applications with a client/server model. The MPI-2 process model provides a
       mechanism  to  create  new  processes  and  establish  communication  between  them  and the existing MPI
       application.  It  also  provides  mechanisms  to  establish  communication  between  two   existing   MPI
       applications, even when one did not <u>start</u> the other.

       In  <u>MPI</u>  <u>for</u>  <u>Python</u>, new independent process groups can be created by calling the <b>Intracomm.Spawn</b> method
       within an intracommunicator.  This call returns a new intercommunicator (i.e., an <u>Intercomm</u> instance)  at
       the  parent process group. The child process group can retrieve the matching intercommunicator by calling
       the <b>Comm.Get_parent</b> class method. At each side, the new intercommunicator can be used to perform point to
       point and collective communications between the parent and child groups of processes.

       Alternatively, disjoint groups of processes can establish communication using a  client/server  approach.
       Any  server  application  must  first  call  the  <b>Open_port</b>  function to open a <u>port</u> and the <b>Publish_name</b>
       function to publish  a  provided  <u>service</u>,  and  next  call  the  <b>Intracomm.Accept</b>  method.   Any  client
       applications  can  first  find a published <u>service</u> by calling the <b>Lookup_name</b> function, which returns the
       <u>port</u> where a server can be contacted; and next call the <b>Intracomm.Connect</b> method.  Both  <b>Intracomm.Accept</b>
       and  <b>Intracomm.Connect</b>  methods  return  an  <u>Intercomm</u>  instance.  When  connection between client/server
       processes is no  longer  needed,  all  of  them  must  cooperatively  call  the  <b>Comm.Disconnect</b>  method.
       Additionally,  server  applications should release resources by calling the <b>Unpublish_name</b> and <b>Close_port</b>
       functions.

   <b>One-Sided</b> <b>Communications</b>
       One-sided communications (also called <u>Remote</u> <u>Memory</u> <u>Access</u>, <u>RMA</u>) supplements the  traditional  two-sided,
       send/receive  based  MPI  communication  model  with  a  one-sided,  put/get  based  interface. One-sided
       communication that can take advantage  of  the  capabilities  of  highly  specialized  network  hardware.
       Additionally,  this  extension  lowers  latency  and  software  overhead  in applications written using a
       shared-memory-like paradigm.

       The MPI specification revolves around the use of objects called <u>windows</u>; they intuitively specify regions
       of a process’s memory that have been made available for remote read and write operations.  The  published
       memory  blocks  can  be  accessed  through three functions for put (remote send), get (remote write), and
       accumulate (remote update or reduction) data items. A much larger number of functions  support  different
       synchronization styles; the semantics of these synchronization operations are fairly complex.

       In  <u>MPI</u>  <u>for</u>  <u>Python</u>,  one-sided operations are available by using instances of the <b>Win</b> class. New window
       objects are created by calling  the  <b>Win.Create</b>  method  at  all  processes  within  a  communicator  and
       specifying  a  memory  buffer . When a window instance is no longer needed, the <b>Win.Free</b> method should be
       called.

       The three one-sided MPI operations for remote write, read and reduction are available through calling the
       methods <b>Win.Put</b>, <b>Win.Get</b>, and <b>Win.Accumulate</b> respectively within a <b>Win</b> instance.  These methods  need  an
       integer rank identifying the target process and an integer offset relative the base address of the remote
       memory block being accessed.

       The  one-sided operations read, write, and reduction are implicitly nonblocking, and must be synchronized
       by using two primary modes.  Active target synchronization  requires  the  origin  process  to  call  the
       <b>Win.Start</b>  and  <b>Win.Complete</b>  methods at the origin process, and target process cooperates by calling the
       <b>Win.Post</b> and <b>Win.Wait</b> methods. There is also a collective  variant  provided  by  the  <b>Win.Fence</b>  method.
       Passive target synchronization is more lenient, only the origin process calls the <b>Win.Lock</b> and <b>Win.Unlock</b>
       methods.  Locks  are  used  to  protect  remote accesses to the locked remote window and to protect local
       load/store accesses to a locked local window.

   <b>Parallel</b> <b>Input/Output</b>
       The POSIX standard provides a model of a widely portable file system. However,  the  optimization  needed
       for  parallel  input/output cannot be achieved with this generic interface. In order to ensure efficiency
       and scalability, the  underlying  parallel  input/output  system  must  provide  a  high-level  interface
       supporting  partitioning  of  file  data  among  processes and a collective interface supporting complete
       transfers  of  global  data  structures  between  process  memories  and  files.  Additionally,   further
       efficiencies  can  be  gained  via  support  for asynchronous input/output, strided accesses to data, and
       control over physical file layout on storage devices. This scenario motivated the inclusion in the  MPI-2
       standard of a custom interface in order to support more elaborated parallel input/output operations.

       The  MPI specification for parallel input/output revolves around the use objects called <u>files</u>. As defined
       by MPI, files are not just contiguous byte streams. Instead, they are regarded as ordered collections  of
       <u>typed</u>  data  items.  MPI  supports  sequential  or  random  access  to  any  integral set of these items.
       Furthermore, files are opened collectively by a group of processes.

       The common patterns for accessing a shared file (broadcast, scatter, gather, reduction) is  expressed  by
       using  user-defined  datatypes.   Compared to the communication patterns of point-to-point and collective
       communications, this approach has the advantage of added  flexibility  and  expressiveness.  Data  access
       operations  (read  and  write)  are  defined  for different kinds of positioning (using explicit offsets,
       individual file pointers, and shared file pointers), coordination (non-collective  and  collective),  and
       synchronism (blocking, nonblocking, and split collective with begin/end phases).

       In  <u>MPI</u>  <u>for</u>  <u>Python</u>,  all MPI input/output operations are performed through instances of the <b>File</b> class.
       File handles are obtained by calling the <b>File.Open</b> method at all  processes  within  a  communicator  and
       providing  a  file  name  and  the  intended  access mode.  After use, they must be closed by calling the
       <b>File.Close</b> method.  Files even can be deleted by calling method <b>File.Delete</b>.

       After creation, files are typically associated with a per-process <u>view</u>. The view defines the current  set
       of  data  visible  and  accessible from an open file as an ordered set of elementary datatypes. This data
       layout can be set and queried with the <b>File.Set_view</b> and <b>File.Get_view</b> methods respectively.

       Actual input/output operations are achieved by many methods combining read and write calls with different
       behavior regarding positioning, coordination, and synchronism. Summing up, <u>MPI</u> <u>for</u>  <u>Python</u>  provides  the
       thirty  (30) methods defined in MPI-2 for reading from or writing to files using explicit offsets or file
       pointers (individual or shared), in blocking or nonblocking and collective or noncollective versions.

   <b>Environmental</b> <b>Management</b>
   <b>Initialization</b> <b>and</b> <b>Exit</b>
       Module  functions  <b>Init</b>  or  <b>Init_thread</b>  and  <b>Finalize</b>  provide  MPI  initialization  and   finalization
       respectively.  Module  functions  <b>Is_initialized</b>  and  <b>Is_finalized</b>  provide  the  respective  tests  for
       initialization and finalization.

       <b>NOTE:</b>
          <b>MPI_Init()</b> or <b>MPI_Init_thread()</b> is actually called when you import the  <u>MPI</u>  module  from  the  <u>mpi4py</u>
          package,  but  only  if MPI is not already initialized. In such case, calling <b>Init</b> or <b>Init_thread</b> from
          Python is expected to generate an MPI error, and in turn an exception will be raised.

       <b>NOTE:</b>
          <b>MPI_Finalize()</b> is registered (by using Python C/API  function  <u>Py_AtExit()</u>)  for  being  automatically
          called when Python processes exit, but only if <u>mpi4py</u> actually initialized MPI. Therefore, there is no
          need to call <b>Finalize</b> from Python to ensure MPI finalization.

   <b>Implementation</b> <b>Information</b>
       • The  MPI  version  number  can  be retrieved from module function <b>Get_version</b>. It returns a two-integer
         tuple <b>(version,</b> <b>subversion)</b>.

       • The <b>Get_processor_name</b> function can be used to access the processor name.

       • The values of predefined attributes attached to the world communicator can be obtained by  calling  the
         <b>Comm.Get_attr</b> method within the <b>COMM_WORLD</b> instance.

   <b>Timers</b>
       MPI timer functionalities are available through the <b>Wtime</b> and <b>Wtick</b> functions.

   <b>Error</b> <b>Handling</b>
       In  order  facilitate  handle sharing with other Python modules interfacing MPI-based parallel libraries,
       the predefined MPI error handlers <b>ERRORS_RETURN</b> and <b>ERRORS_ARE_FATAL</b> can be  assigned  to  and  retrieved
       from  communicators  using methods <b>Comm.Set_errhandler</b> and <b>Comm.Get_errhandler</b>, and similarly for windows
       and files.

       When the predefined error handler <b>ERRORS_RETURN</b> is set, errors returned from MPI calls within Python code
       will raise an instance of the exception class <u>Exception</u>, which is  a  subclass  of  the  standard  Python
       exception <u>RuntimeError</u>.

       <b>NOTE:</b>
          After  import,  mpi4py  overrides  the  default MPI rules governing inheritance of error handlers. The
          <b>ERRORS_RETURN</b> error handler is set in the predefined <b>COMM_SELF</b> and <b>COMM_WORLD</b> communicators,  as  well
          as  any  new  <u>Comm</u>,  <b>Win</b>,  or  <b>File</b>  instance created through mpi4py. If you ever pass such handles to
          C/C++/Fortran library code, it is recommended to set the <b>ERRORS_ARE_FATAL</b> error  handler  on  them  to
          ensure MPI errors do not pass silently.

       <b>WARNING:</b>
          Importing  with <b>from</b> <b>mpi4py.MPI</b> <b>import</b> <b>*</b> will cause a name clashing with the standard Python <u>Exception</u>
          base class.

</pre><h4><b>TUTORIAL</b></h4><pre>
       <b>WARNING:</b>
          Under construction. Contributions very welcome!

       <b>TIP:</b>
          <u>Rolf</u> <u>Rabenseifner</u> at <u>HLRS</u> developed a comprehensive MPI-3.1/4.0 course with slides and a large set  of
          exercises  including  solutions.  This  material  is  <u>available</u>  <u>online</u> for self-study. The slides and
          exercises show the C, Fortran, and Python (mpi4py) interfaces. For performance  reasons,  most  Python
          exercises use NumPy arrays and communication routines involving buffer-like objects.

       <b>TIP:</b>
          <u>Victor</u> <u>Eijkhout</u> at <u>TACC</u> authored the book <u>Parallel</u> <u>Programming</u> <u>for</u> <u>Science</u> <u>and</u> <u>Engineering</u>.  This book
          is available online in <u>PDF</u> and <u>HTML</u> formats.  The book covers parallel programming with MPI and OpenMP
          in C/C++ and Fortran, and MPI in Python using mpi4py.

       <u>MPI</u>  <u>for</u> <u>Python</u> supports convenient, <u>pickle</u>-based communication of generic Python object as well as fast,
       near C-speed, direct array data communication of buffer-provider objects (e.g., NumPy arrays).

       • Communication of generic Python objects

         You have to use methods with <b>all-lowercase</b> names, like <u>Comm.send</u>, <u>Comm.recv</u>, <u>Comm.bcast</u>,  <b>Comm.scatter</b>,
         <b>Comm.gather</b> . An object to be sent is passed as a parameter to the communication call, and the received
         object is simply the return value.

         The  <u>Comm.isend</u>  and  <u>Comm.irecv</u>  methods  return <u>Request</u> instances; completion of these methods can be
         managed using the <u>Request.test</u> and <u>Request.wait</u> methods.

         The <u>Comm.recv</u> and <u>Comm.irecv</u> methods may be passed a buffer object  that  can  be  repeatedly  used  to
         receive  messages  avoiding  internal  memory  allocation.  This  buffer  must be sufficiently large to
         accommodate the transmitted messages; hence, any buffer passed to <u>Comm.recv</u> or <u>Comm.irecv</u>  must  be  at
         least as long as the <u>pickled</u> data transmitted to the receiver.

         Collective calls like <b>Comm.scatter</b>, <b>Comm.gather</b>, <b>Comm.allgather</b>, <b>Comm.alltoall</b> expect a single value or
         a  sequence  of  <b>Comm.size</b>  elements  at the root or all process. They return a single value, a list of
         <b>Comm.size</b> elements, or <u>None</u>.

         <b>NOTE:</b>
            <u>MPI</u> <u>for</u> <u>Python</u> uses  the  <b>highest</b>  <u>protocol</u>  <u>version</u>  available  in  the  Python  runtime  (see  the
            <u>HIGHEST_PROTOCOL</u> constant in the <u>pickle</u> module).  The default protocol can be changed at import time
            by  setting  the <u>MPI4PY_PICKLE_PROTOCOL</u> environment variable, or at runtime by assigning a different
            value to the <b>PROTOCOL</b> attribute of the <b>pickle</b> object within the <u>MPI</u> module.

       • Communication of buffer-like objects

         You have to use method names starting with an <b>upper-case</b> letter, like <b>Comm.Send</b>, <b>Comm.Recv</b>, <b>Comm.Bcast</b>,
         <b>Comm.Scatter</b>, <b>Comm.Gather</b>.

         In general, buffer arguments to these calls must be explicitly specified by using a 2/3-list/tuple like
         <b>[data,</b> <b>MPI.DOUBLE]</b>, or <b>[data,</b> <b>count,</b> <b>MPI.DOUBLE]</b> (the former one uses the byte-size  of  <b>data</b>  and  the
         extent of the MPI datatype to define <b>count</b>).

         For  vector  collectives communication operations like <b>Comm.Scatterv</b> and <b>Comm.Gatherv</b>, buffer arguments
         are specified as <b>[data,</b> <b>count,</b> <b>displ,</b> <b>datatype]</b>, where  <b>count</b>  and  <b>displ</b>  are  sequences  of  integral
         values.

         Automatic MPI datatype discovery for NumPy/GPU arrays and PEP-3118 buffers is supported, but limited to
         basic C types (all C/C99-native signed/unsigned integral types and single/double precision real/complex
         floating  types)  and  availability of matching datatypes in the underlying MPI implementation. In this
         case, the buffer-provider object can be passed directly  as  a  buffer  argument,  the  count  and  MPI
         datatype will be inferred.

         If  mpi4py  is  built  against  a  GPU-aware MPI implementation, GPU arrays can be passed to upper-case
         methods  as  long  as  they  have  either  the  <b>__dlpack__</b>  and  <b>__dlpack_device__</b>   methods   or   the
         <b>__cuda_array_interface__</b>  attribute  that  are  compliant  with the respective standard specifications.
         Moreover, only C-contiguous or Fortran-contiguous GPU arrays are supported. It  is  important  to  note
         that  GPU buffers must be fully ready before any MPI routines operate on them to avoid race conditions.
         This can be ensured by using the synchronization API of your array library. mpi4py does not have access
         to any GPU-specific functionality and thus cannot perform this operation automatically for users.

   <b>Running</b> <b>Python</b> <b>scripts</b> <b>with</b> <b>MPI</b>
       Most MPI programs can be run with the command <b>mpiexec</b>. In practice, running Python programs looks like:

          $ mpiexec -n 4 python script.py

       to run the program with 4 processors.

   <b>Point-to-Point</b> <b>Communication</b>
       • Python objects (<u>pickle</u> under the hood):

            from mpi4py import MPI

            comm = MPI.COMM_WORLD
            rank = comm.Get_rank()

            if rank == 0:
                data = {'a': 7, 'b': 3.14}
                comm.send(data, dest=1, tag=11)
            elif rank == 1:
                data = comm.recv(source=0, tag=11)

       • Python objects with non-blocking communication:

            from mpi4py import MPI

            comm = MPI.COMM_WORLD
            rank = comm.Get_rank()

            if rank == 0:
                data = {'a': 7, 'b': 3.14}
                req = comm.isend(data, dest=1, tag=11)
                req.wait()
            elif rank == 1:
                req = comm.irecv(source=0, tag=11)
                data = req.wait()

       • NumPy arrays (the fast way!):

            from mpi4py import MPI
            import numpy

            comm = MPI.COMM_WORLD
            rank = comm.Get_rank()

            # passing MPI datatypes explicitly
            if rank == 0:
                data = numpy.arange(1000, dtype='i')
                comm.Send([data, MPI.INT], dest=1, tag=77)
            elif rank == 1:
                data = numpy.empty(1000, dtype='i')
                comm.Recv([data, MPI.INT], source=0, tag=77)

            # automatic MPI datatype discovery
            if rank == 0:
                data = numpy.arange(100, dtype=numpy.float64)
                comm.Send(data, dest=1, tag=13)
            elif rank == 1:
                data = numpy.empty(100, dtype=numpy.float64)
                comm.Recv(data, source=0, tag=13)

   <b>Collective</b> <b>Communication</b>
       • Broadcasting a Python dictionary:

            from mpi4py import MPI

            comm = MPI.COMM_WORLD
            rank = comm.Get_rank()

            if rank == 0:
                data = {'key1' : [7, 2.72, 2+3j],
                        'key2' : ( 'abc', 'xyz')}
            else:
                data = None
            data = comm.bcast(data, root=0)

       • Scattering Python objects:

            from mpi4py import MPI

            comm = MPI.COMM_WORLD
            size = comm.Get_size()
            rank = comm.Get_rank()

            if rank == 0:
                data = [(i+1)**2 for i in range(size)]
            else:
                data = None
            data = comm.scatter(data, root=0)
            assert data == (rank+1)**2

       • Gathering Python objects:

            from mpi4py import MPI

            comm = MPI.COMM_WORLD
            size = comm.Get_size()
            rank = comm.Get_rank()

            data = (rank+1)**2
            data = comm.gather(data, root=0)
            if rank == 0:
                for i in range(size):
                    assert data[i] == (i+1)**2
            else:
                assert data is None

       • Broadcasting a NumPy array:

            from mpi4py import MPI
            import numpy as np

            comm = MPI.COMM_WORLD
            rank = comm.Get_rank()

            if rank == 0:
                data = np.arange(100, dtype='i')
            else:
                data = np.empty(100, dtype='i')
            comm.Bcast(data, root=0)
            for i in <a href="../man100/range.100.html">range</a>(100):
                assert data[i] == i

       • Scattering NumPy arrays:

            from mpi4py import MPI
            import numpy as np

            comm = MPI.COMM_WORLD
            size = comm.Get_size()
            rank = comm.Get_rank()

            sendbuf = None
            if rank == 0:
                sendbuf = np.empty([size, 100], dtype='i')
                sendbuf.T[:,:] = range(size)
            recvbuf = np.empty(100, dtype='i')
            comm.Scatter(sendbuf, recvbuf, root=0)
            assert np.allclose(recvbuf, rank)

       • Gathering NumPy arrays:

            from mpi4py import MPI
            import numpy as np

            comm = MPI.COMM_WORLD
            size = comm.Get_size()
            rank = comm.Get_rank()

            sendbuf = np.zeros(100, dtype='i') + rank
            recvbuf = None
            if rank == 0:
                recvbuf = np.empty([size, 100], dtype='i')
            comm.Gather(sendbuf, recvbuf, root=0)
            if rank == 0:
                for i in range(size):
                    assert np.allclose(recvbuf[i,:], i)

       • Parallel matrix-vector product:

            from mpi4py import MPI
            import numpy

            def matvec(comm, A, x):
                m = A.shape[0] # local rows
                p = comm.Get_size()
                xg = numpy.zeros(m*p, dtype='d')
                comm.Allgather([x,  MPI.DOUBLE],
                               [xg, MPI.DOUBLE])
                y = numpy.dot(A, xg)
                return y

   <b>MPI-IO</b>
       • Collective I/O with NumPy arrays:

            from mpi4py import MPI
            import numpy as np

            amode = MPI.MODE_WRONLY|MPI.MODE_CREATE
            comm = MPI.COMM_WORLD
            fh = MPI.File.Open(comm, "./datafile.contig", amode)

            buffer = np.empty(10, dtype=np.int)
            buffer[:] = comm.Get_rank()

            offset = comm.Get_rank()*buffer.nbytes
            fh.Write_at_all(offset, buffer)

            fh.Close()

       • Non-contiguous Collective I/O with NumPy arrays and datatypes:

            from mpi4py import MPI
            import numpy as np

            comm = MPI.COMM_WORLD
            rank = comm.Get_rank()
            size = comm.Get_size()

            amode = MPI.MODE_WRONLY|MPI.MODE_CREATE
            fh = MPI.File.Open(comm, "./datafile.noncontig", amode)

            item_count = 10

            buffer = np.empty(item_count, dtype='i')
            buffer[:] = rank

            filetype = MPI.INT.Create_vector(item_count, 1, size)
            filetype.Commit()

            displacement = MPI.INT.Get_size()*rank
            fh.Set_view(displacement, filetype=filetype)

            fh.Write_all(buffer)
            filetype.Free()
            fh.Close()

   <b>Dynamic</b> <b>Process</b> <b>Management</b>
       • Compute Pi - Master (or parent, or client) side:

            #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?env">/usr/bin/env</a> python
            from mpi4py import MPI
            import numpy
            import sys

            comm = MPI.COMM_SELF.Spawn(sys.executable,
                                       args=['cpi.py'],
                                       maxprocs=5)

            N = numpy.array(100, 'i')
            comm.Bcast([N, MPI.INT], root=MPI.ROOT)
            PI = numpy.array(0.0, 'd')
            comm.Reduce(None, [PI, MPI.DOUBLE],
                        op=MPI.SUM, root=MPI.ROOT)
            print(PI)

            comm.Disconnect()

       • Compute Pi - Worker (or child, or server) side:

            #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?env">/usr/bin/env</a> python
            from mpi4py import MPI
            import numpy

            comm = MPI.Comm.Get_parent()
            size = comm.Get_size()
            rank = comm.Get_rank()

            N = numpy.array(0, dtype='i')
            comm.Bcast([N, MPI.INT], root=0)
            h = 1.0 / N; s = 0.0
            for i in range(rank, N, size):
                x = h * (i + 0.5)
                s += 4.0 / (1.0 + x**2)
            PI = numpy.array(s * h, dtype='d')
            comm.Reduce([PI, MPI.DOUBLE], None,
                        op=MPI.SUM, root=0)

            comm.Disconnect()

   <b>CUDA-aware</b> <b>MPI</b> <b>+</b> <b>Python</b> <b>GPU</b> <b>arrays</b>
       • Reduce-to-all CuPy arrays:

            from mpi4py import MPI
            import cupy as cp

            comm = MPI.COMM_WORLD
            size = comm.Get_size()
            rank = comm.Get_rank()

            sendbuf = cp.arange(10, dtype='i')
            recvbuf = cp.empty_like(sendbuf)
            assert hasattr(sendbuf, '__cuda_array_interface__')
            assert hasattr(recvbuf, '__cuda_array_interface__')
            cp.cuda.get_current_stream().synchronize()
            comm.Allreduce(sendbuf, recvbuf)

            assert cp.allclose(recvbuf, sendbuf*size)

   <b>One-Sided</b> <b>Communications</b>
       • Read from (write to) the entire RMA window:

            import numpy as np
            from mpi4py import MPI
            from mpi4py.util import dtlib

            comm = MPI.COMM_WORLD
            rank = comm.Get_rank()

            datatype = MPI.FLOAT
            np_dtype = dtlib.to_numpy_dtype(datatype)
            itemsize = datatype.Get_size()

            N = 10
            win_size = N * itemsize if rank == 0 else 0
            win = MPI.Win.Allocate(win_size, comm=comm)

            buf = np.empty(N, dtype=np_dtype)
            if rank == 0:
                <a href="../man42/buf.fill.42.html">buf.fill</a>(42)
                win.Lock(rank=0)
                win.Put(buf, target_rank=0)
                win.Unlock(rank=0)
                comm.Barrier()
            else:
                comm.Barrier()
                win.Lock(rank=0)
                win.Get(buf, target_rank=0)
                win.Unlock(rank=0)
                assert np.all(buf == 42)

       • Accessing a part of the RMA window using the <b>target</b> argument,  which  is  defined  as  <b>(offset,</b>  <b>count,</b>
         <b>datatype)</b>:

            import numpy as np
            from mpi4py import MPI
            from mpi4py.util import dtlib

            comm = MPI.COMM_WORLD
            rank = comm.Get_rank()

            datatype = MPI.FLOAT
            np_dtype = dtlib.to_numpy_dtype(datatype)
            itemsize = datatype.Get_size()

            N = comm.Get_size() + 1
            win_size = N * itemsize if rank == 0 else 0
            win = MPI.Win.Allocate(
                size=win_size,
                disp_unit=itemsize,
                comm=comm,
            )
            if rank == 0:
                mem = np.frombuffer(win, dtype=np_dtype)
                mem[:] = np.arange(<a href="../manmem/len.mem.html">len</a>(mem), dtype=np_dtype)
            comm.Barrier()

            buf = np.zeros(3, dtype=np_dtype)
            target = (rank, 2, datatype)
            win.Lock(rank=0)
            win.Get(buf, target_rank=0, target=target)
            win.Unlock(rank=0)
            assert np.all(buf == [rank, rank+1, 0])

   <b>Wrapping</b> <b>with</b> <b>SWIG</b>
       • C source:

            /* file: helloworld.c */
            void sayhello(MPI_Comm comm)
            {
              int size, rank;
              MPI_Comm_size(comm, &amp;size);
              MPI_Comm_rank(comm, &amp;rank);
              printf("Hello, World! "
                     "I am process %d of %d.\n",
                     rank, size);
            }

       • SWIG interface file:

            // file: helloworld.i
            %module helloworld
            %{
            #include &lt;mpi.h&gt;
            #include "helloworld.c"
            }%

            %include mpi4py/mpi4py.i
            %mpi4py_typemap(Comm, MPI_Comm);
            void sayhello(MPI_Comm comm);

       • Try it in the Python prompt:

            &gt;&gt;&gt; from mpi4py import MPI
            &gt;&gt;&gt; import helloworld
            &gt;&gt;&gt; helloworld.sayhello(MPI.COMM_WORLD)
            Hello, World! I am process 0 of 1.

   <b>Wrapping</b> <b>with</b> <b>F2Py</b>
       • Fortran 90 source:

            ! file: helloworld.f90
            subroutine sayhello(comm)
              use mpi
              implicit none
              integer :: comm, rank, size, ierr
              call MPI_Comm_size(comm, size, ierr)
              call MPI_Comm_rank(comm, rank, ierr)
              print *, 'Hello, World! I am process ',rank,' of ',size,'.'
            end subroutine sayhello

       • Compiling example using f2py

            $ f2py -c --f90exec=mpif90 helloworld.f90 -m helloworld

       • Try it in the Python prompt:

            &gt;&gt;&gt; from mpi4py import MPI
            &gt;&gt;&gt; import helloworld
            &gt;&gt;&gt; fcomm = MPI.COMM_WORLD.py2f()
            &gt;&gt;&gt; helloworld.sayhello(fcomm)
            Hello, World! I am process 0 of 1.

</pre><h4><b>MPI4PY</b></h4><pre>
   <b>Runtime</b> <b>configuration</b> <b>options</b>
       <b>mpi4py.rc</b>
              This  object has attributes exposing runtime configuration options that become effective at import
              time of the <u>MPI</u> module.

       Attributes Summary
                               ┌──────────────┬───────────────────────────────────────┐
                               │ <u>initialize</u>   │ Automatic   MPI   initialization   at │
                               │              │ import                                │
                               ├──────────────┼───────────────────────────────────────┤
                               │ <u>threads</u>      │ Request  initialization  with  thread │
                               │              │ support                               │
                               ├──────────────┼───────────────────────────────────────┤
                               │ <u>thread_level</u> │ Level of thread support to request    │
                               ├──────────────┼───────────────────────────────────────┤
                               │ <u>finalize</u>     │ Automatic MPI finalization at exit    │
                               ├──────────────┼───────────────────────────────────────┤
                               │ <u>fast_reduce</u>  │ Use tree-based reductions for objects │
                               ├──────────────┼───────────────────────────────────────┤
                               │ <u>recv_mprobe</u>  │ Use matched probes to receive objects │
                               ├──────────────┼───────────────────────────────────────┤
                               │ <u>errors</u>       │ Error handling policy                 │
                               └──────────────┴───────────────────────────────────────┘

       Attributes Documentation

       <b>mpi4py.rc.initialize</b>
              Automatic MPI initialization at import.

              <b>Type</b>   <u>bool</u>

              <b>Default</b>
                     <u>True</u>

              <b>SEE</b> <b>ALSO:</b>
                 <u>MPI4PY_RC_INITIALIZE</u>

       <b>mpi4py.rc.threads</b>
              Request initialization with thread support.

              <b>Type</b>   <u>bool</u>

              <b>Default</b>
                     <u>True</u>

              <b>SEE</b> <b>ALSO:</b>
                 <u>MPI4PY_RC_THREADS</u>

       <b>mpi4py.rc.thread_level</b>
              Level of thread support to request.

              <b>Type</b>   <u>str</u>

              <b>Default</b>
                     <b>"multiple"</b>

              <b>Choices</b>
                     <b>"multiple"</b>, <b>"serialized"</b>, <b>"funneled"</b>, <b>"single"</b>

              <b>SEE</b> <b>ALSO:</b>
                 <u>MPI4PY_RC_THREAD_LEVEL</u>

       <b>mpi4py.rc.finalize</b>
              Automatic MPI finalization at exit.

              <b>Type</b>   <u>None</u> or <u>bool</u>

              <b>Default</b>
                     <u>None</u>

              <b>SEE</b> <b>ALSO:</b>
                 <u>MPI4PY_RC_FINALIZE</u>

       <b>mpi4py.rc.fast_reduce</b>
              Use tree-based reductions for objects.

              <b>Type</b>   <u>bool</u>

              <b>Default</b>
                     <u>True</u>

              <b>SEE</b> <b>ALSO:</b>
                 <u>MPI4PY_RC_FAST_REDUCE</u>

       <b>mpi4py.rc.recv_mprobe</b>
              Use matched probes to receive objects.

              <b>Type</b>   <u>bool</u>

              <b>Default</b>
                     <u>True</u>

              <b>SEE</b> <b>ALSO:</b>
                 <u>MPI4PY_RC_RECV_MPROBE</u>

       <b>mpi4py.rc.errors</b>
              Error handling policy.

              <b>Type</b>   <u>str</u>

              <b>Default</b>
                     <b>"exception"</b>

              <b>Choices</b>
                     <b>"exception"</b>, <b>"default"</b>, <b>"fatal"</b>

              <b>SEE</b> <b>ALSO:</b>
                 <u>MPI4PY_RC_ERRORS</u>

       Example

       MPI for Python features automatic initialization and finalization of the MPI  execution  environment.  By
       using the <u>mpi4py.rc</u> object, MPI initialization and finalization can be handled programatically:

          import mpi4py
          mpi4py.rc.initialize = False  # do not initialize MPI automatically
          mpi4py.rc.finalize = False    # do not finalize MPI automatically

          from mpi4py import MPI # import the 'MPI' module

          MPI.Init()      # manual initialization of the MPI environment
          ...             # your finest code here ...
          MPI.Finalize()  # manual finalization of the MPI environment

   <b>Environment</b> <b>variables</b>
       The following environment variables override the corresponding attributes of the <u>mpi4py.rc</u> and <b>MPI.pickle</b>
       objects at import time of the <u>MPI</u> module.

       <b>NOTE:</b>
          For  variables  of  boolean  type,  accepted  values  are  <b>0</b>  and  <b>1</b>  (interpreted  as <u>False</u> and <u>True</u>,
          respectively), and strings specifying a <u>YAML</u> <u>boolean</u> value (case-insensitive).

       <b>MPI4PY_RC_INITIALIZE</b>

              <b>Type</b>   <u>bool</u>

              <b>Default</b>
                     <u>True</u>

              Whether to automatically initialize MPI at import time of the <u>mpi4py.MPI</u> module.

              <b>SEE</b> <b>ALSO:</b>
                 <u>mpi4py.rc.initialize</u>

              New in version 3.1.0.

       <b>MPI4PY_RC_FINALIZE</b>

              <b>Type</b>   <u>None</u> | <u>bool</u>

              <b>Default</b>
                     <u>None</u>

              <b>Choices</b>
                     <u>None</u>, <u>True</u>, <u>False</u>

              Whether to automatically finalize MPI at exit time of the Python process.

              <b>SEE</b> <b>ALSO:</b>
                 <u>mpi4py.rc.finalize</u>

              New in version 3.1.0.

       <b>MPI4PY_RC_THREADS</b>

              <b>Type</b>   <u>bool</u>

              <b>Default</b>
                     <u>True</u>

              Whether to initialize MPI with thread support.

              <b>SEE</b> <b>ALSO:</b>
                 <u>mpi4py.rc.threads</u>

              New in version 3.1.0.

       <b>MPI4PY_RC_THREAD_LEVEL</b>

              <b>Default</b>
                     <b>"multiple"</b>

              <b>Choices</b>
                     <b>"single"</b>, <b>"funneled"</b>, <b>"serialized"</b>, <b>"multiple"</b>

              The level of required thread support.

              <b>SEE</b> <b>ALSO:</b>
                 <u>mpi4py.rc.thread_level</u>

              New in version 3.1.0.

       <b>MPI4PY_RC_FAST_REDUCE</b>

              <b>Type</b>   <u>bool</u>

              <b>Default</b>
                     <u>True</u>

              Whether to use tree-based reductions for objects.

              <b>SEE</b> <b>ALSO:</b>
                 <u>mpi4py.rc.fast_reduce</u>

              New in version 3.1.0.

       <b>MPI4PY_RC_RECV_MPROBE</b>

              <b>Type</b>   <u>bool</u>

              <b>Default</b>
                     <u>True</u>

              Whether to use matched probes to receive objects.

              <b>SEE</b> <b>ALSO:</b>
                 <u>mpi4py.rc.recv_mprobe</u>

       <b>MPI4PY_RC_ERRORS</b>

              <b>Default</b>
                     <b>"exception"</b>

              <b>Choices</b>
                     <b>"exception"</b>, <b>"default"</b>, <b>"fatal"</b>

              Controls default MPI error handling policy.

              <b>SEE</b> <b>ALSO:</b>
                 <u>mpi4py.rc.errors</u>

              New in version 3.1.0.

       <b>MPI4PY_PICKLE_PROTOCOL</b>

              <b>Type</b>   <u>int</u>

              <b>Default</b>
                     <u>pickle.HIGHEST_PROTOCOL</u>

              Controls the default pickle protocol to use when communicating Python objects.

              <b>SEE</b> <b>ALSO:</b>
                 <b>PROTOCOL</b> attribute of the <b>MPI.pickle</b> object within the <u>MPI</u> module.

              New in version 3.1.0.

       <b>MPI4PY_PICKLE_THRESHOLD</b>

              <b>Type</b>   <u>int</u>

              <b>Default</b>
                     <b>262144</b>

              Controls the default buffer size threshold  for  switching  from  in-band  to  out-of-band  buffer
              handling when using pickle protocol version 5 or higher.

              <b>SEE</b> <b>ALSO:</b>
                 Module <u>mpi4py.util.pkl5</u>.

              New in version 3.1.2.

   <b>Miscellaneous</b> <b>functions</b>
       <b>mpi4py.profile()</b>

       <b>mpi4py.get_config()</b>

       <b>mpi4py.get_include()</b>

</pre><h4><b>MPI4PY.MPI</b></h4><pre>
   <b>Classes</b>
       Ancillary
                                                   ┌──────────┬───┐
                                                   │ <b>Datatype</b> │   │
                                                   ├──────────┼───┤
                                                   │ <b>Status</b>   │   │
                                                   ├──────────┼───┤
                                                   │ <b>Request</b>  │   │
                                                   ├──────────┼───┤
                                                   │ <b>Prequest</b> │   │
                                                   ├──────────┼───┤
                                                   │ <b>Grequest</b> │   │
                                                   ├──────────┼───┤
                                                   │ <b>Op</b>       │   │
                                                   ├──────────┼───┤
                                                   │ <b>Group</b>    │   │
                                                   ├──────────┼───┤
                                                   │ <b>Info</b>     │   │
                                                   └──────────┴───┘

       Communication
                                                ┌───────────────┬───┐
                                                │ <b>Comm</b>          │   │
                                                ├───────────────┼───┤
                                                │ <b>Intracomm</b>     │   │
                                                ├───────────────┼───┤
                                                │ <b>Topocomm</b>      │   │
                                                ├───────────────┼───┤
                                                │ <b>Cartcomm</b>      │   │
                                                ├───────────────┼───┤
                                                │ <b>Graphcomm</b>     │   │
                                                ├───────────────┼───┤
                                                │ <b>Distgraphcomm</b> │   │
                                                ├───────────────┼───┤
                                                │ <b>Intercomm</b>     │   │
                                                ├───────────────┼───┤
                                                │ <b>Message</b>       │   │
                                                └───────────────┴───┘

       One-sided operations
                                                     ┌─────┬───┐
                                                     │ <b>Win</b> │   │
                                                     └─────┴───┘

       Input/Output
                                                     ┌──────┬───┐
                                                     │ <b>File</b> │   │
                                                     └──────┴───┘

       Error handling
                                                  ┌────────────┬───┐
                                                  │ <b>Errhandler</b> │   │
                                                  ├────────────┼───┤
                                                  │ <b>Exception</b>  │   │
                                                  └────────────┴───┘

       Auxiliary
                                                    ┌────────┬───┐
                                                    │ <b>Pickle</b> │   │
                                                    ├────────┼───┤
                                                    │ <b>memory</b> │   │
                                                    └────────┴───┘

   <b>Functions</b>
       Version inquiry
                                             ───────────────────────────
                                               <b>Get_version</b>
                                             ───────────────────────────
                                               <b>Get_library_version</b>
                                             ┌─────────────────────┬───┐
                                             │                     │   │
       Initialization and finalization       │                     │   │
                                             │  ┌────────────────┬─┼─┐ │
                                             │  │ <b>Init</b>           │ │ │ │
                                             │  ├────────────────┼─┼─┤ │
                                             │  │ <b>Init_thread</b>    │ │ │ │
                                             │  ├────────────────┼─┼─┤ │
                                             │  │ <b>Finalize</b>       │ │ │ │
                                             │  ├────────────────┼─┼─┤ │
                                             │  │ <b>Is_initialized</b> │ │ │ │
                                             │  ├────────────────┼─┼─┤ │
                                             │  │ <b>Is_finalized</b>   │ │ │ │
                                             │  ├────────────────┼─┼─┤ │
                                             │  │ <b>Query_thread</b>   │ │ │ │
                                             │  ├────────────────┼─┼─┤ │
                                             │  │ <b>Is_thread_main</b> │ │ │ │
                                             │  └────────────────┴─┼─┘ │
                                             │                     │   │
       Memory allocation                     │                     │   │
                                             │    ┌───────────┬───┐│   │
                                             │    │ <b>Alloc_mem</b> │   ││   │
                                             │    ├───────────┼───┤│   │
                                             │    │ <b>Free_mem</b>  │   ││   │
                                             │    └───────────┴───┘│   │
                                             │                     │   │
       Address manipulation                  │                     │   │
                                             │   ┌─────────────┬───┤   │
                                             │   │ <b>Get_address</b> │   │   │
                                             │   ├─────────────┼───┤   │
                                             │   │ <b>Aint_add</b>    │   │   │
                                             │   ├─────────────┼───┤   │
                                             │   │ <b>Aint_diff</b>   │   │   │
                                             │   └─────────────┴───┤   │
                                             │                     │   │
       Timer                                 │                     │   │
                                             │      ┌───────┬───┐  │   │
                                             │      │ <b>Wtick</b> │   │  │   │
                                             │      ├───────┼───┤  │   │
                                             │      │ <b>Wtime</b> │   │  │   │
                                             │      └───────┴───┘  │   │
                                             │                     │   │
       Error handling                        │                     │   │
                                             │ ┌──────────────────┬┼──┐│
                                             │ │ <b>Get_error_class</b>  ││  ││
                                             │ ├──────────────────┼┼──┤│
                                             │ │ <b>Get_error_string</b> ││  ││
                                             │ ├──────────────────┼┼──┤│
                                             │ │ <b>Add_error_class</b>  ││  ││
                                             │ ├──────────────────┼┼──┤│
                                             │ │ <b>Add_error_code</b>   ││  ││
                                             │ ├──────────────────┼┼──┤│
                                             │ │ <b>Add_error_string</b> ││  ││
                                             │ └──────────────────┴┼──┘│
                                             │                     │   │
       Dynamic process management            │                     │   │
                                             │  ┌────────────────┬─┼─┐ │
                                             │  │ <b>Open_port</b>      │ │ │ │
                                             │  ├────────────────┼─┼─┤ │
                                             │  │ <b>Close_port</b>     │ │ │ │
                                             │  ├────────────────┼─┼─┤ │
                                             │  │ <b>Publish_name</b>   │ │ │ │
                                             │  ├────────────────┼─┼─┤ │
                                             │  │ <b>Unpublish_name</b> │ │ │ │
                                             │  ├────────────────┼─┼─┤ │
                                             │  │ <b>Lookup_name</b>    │ │ │ │
                                             │  └────────────────┴─┼─┘ │
                                             │                     │   │
       Miscellanea                           │                     │   │
                                             │─────────────────────┼───┤
                                             │  <b>Attach_buffer</b>      │   │
                                             │─────────────────────┴───┘
                                                <b>Detach_buffer</b>
                                              ──────────────────────────
                                                <b>Compute_dims</b>
                                              ──────────────────────────
                                                <b>Get_processor_name</b>
                                              ──────────────────────────
                                                <b>Register_datarep</b>
                                              ──────────────────────────
                                                <b>Pcontrol</b>
                                              ┌────────────────────┬───┐
                                              │                    │   │
       Utilities                              │                    │   │
                                              │   ┌────────────┬───┤   │
                                              │   │ <b>get_vendor</b> │   │   │
                                              │   └────────────┴───┤   │
                                              │                    │   │
   <b>Attributes</b>                                 │                    │   │
                                          ────┼────────────────────┼───┼────
--
</pre><h4><b>MPI4PY.FUTURES</b></h4><pre>
       New in version 3.0.0.

       This  package  provides a high-level interface for asynchronously executing callables on a pool of worker
       processes using MPI for inter-process communication.

   <b>concurrent.futures</b>
       The <u>mpi4py.futures</u> package is  based  on  <u>concurrent.futures</u>  from  the  Python  standard  library.  More
       precisely, <u>mpi4py.futures</u> provides the <u>MPIPoolExecutor</u> class as a concrete implementation of the abstract
       class  <u>Executor</u>.  The <u>submit()</u> interface schedules a callable to be executed asynchronously and returns a
       <u>Future</u> object representing the execution of the callable.  <u>Future</u> instances can be queried for  the  call
       result or exception. Sets of <u>Future</u> instances can be passed to the <u>wait()</u> and <u>as_completed()</u> functions.

       <b>NOTE:</b>
          The  <u>concurrent.futures</u>  package  was  introduced  in  Python  3.2. A <u>backport</u> targeting Python 2.7 is
          available on <u>PyPI</u>. The <u>mpi4py.futures</u> package uses <u>concurrent.futures</u> if available,  either  from  the
          Python  3  standard  library or the Python 2.7 backport if installed. Otherwise, <u>mpi4py.futures</u> uses a
          bundled copy of core functionality backported from Python 3.5 to work with Python 2.7.

       <b>SEE</b> <b>ALSO:</b>

          <b>Module</b> <u>concurrent.futures</u>
                 Documentation of the <u>concurrent.futures</u> standard module.

   <b>MPIPoolExecutor</b>
       The <u>MPIPoolExecutor</u> class uses a pool of MPI processes to execute  calls  asynchronously.  By  performing
       computations  in  separate  processes,  it allows to side-step the <u>global</u> <u>interpreter</u> <u>lock</u> but also means
       that only picklable objects can be executed and returned. The  <b>__</b><u>main</u><b>__</b>  module  must  be  importable  by
       worker processes, thus <u>MPIPoolExecutor</u> instances may not work in the interactive interpreter.

       <u>MPIPoolExecutor</u>  takes  advantage  of  the  dynamic  process  management features introduced in the MPI-2
       standard. In particular, the <b>MPI.Intracomm.Spawn</b> method of  <b>MPI.COMM_SELF</b>  is  used  in  the  master  (or
       parent) process to spawn new worker (or child) processes running a Python interpreter. The master process
       uses  a  separate  thread  (one for each <u>MPIPoolExecutor</u> instance) to communicate back and forth with the
       workers.  The worker processes serve the execution of tasks in the main (and only) thread until they  are
       signaled for completion.

       <b>NOTE:</b>
          The  worker  processes  must  import  the main script in order to <u>unpickle</u> any callable defined in the
          <b>__</b><u>main</u><b>__</b> module and submitted from the master process. Furthermore, the callables may need  access  to
          other  global  variables. At the worker processes, <u>mpi4py.futures</u> executes the main script code (using
          the <u>runpy</u> module) under the <b>__worker__</b> namespace to define  the  <b>__</b><u>main</u><b>__</b>  module.  The  <b>__</b><u>main</u><b>__</b>  and
          <b>__worker__</b> modules are added to <u>sys.modules</u> (both at the master and worker processes) to ensure proper
          <u>pickling</u> and <u>unpickling</u>.

       <b>WARNING:</b>
          During  the  initial  import  phase  at  the  workers,  the  main  script  cannot  create  and use new
          <u>MPIPoolExecutor</u> instances. Otherwise, each worker would attempt  to  spawn  a  new  pool  of  workers,
          leading to infinite recursion. <u>mpi4py.futures</u> detects such recursive attempts to spawn new workers and
          aborts  the  MPI execution environment. As the main script code is run under the <b>__worker__</b> namespace,
          the easiest way to avoid spawn recursion is using the idiom <b>if</b> <b>__name__</b> <b>==</b> <b>'__main__':</b> <b>...</b> in the main
          script.

       <b>class</b> <b>mpi4py.futures.MPIPoolExecutor(max_workers=None,</b> <b>initializer=None,</b> <b>initargs=(),</b> <b>**kwargs)</b>
              An <u>Executor</u> subclass that executes calls asynchronously  using  a  pool  of  at  most  <u>max_workers</u>
              processes.    If   <u>max_workers</u>   is   <u>None</u>  or  not  given,  its  value  is  determined  from  the
              <u>MPI4PY_FUTURES_MAX_WORKERS</u> environment variable if set, or the MPI universe size if set, otherwise
              a single worker process is spawned.  If <u>max_workers</u> is lower than or equal to <b>0</b>, then a <u>ValueError</u>
              will be raised.

              <u>initializer</u> is an optional callable that is called at the start  of  each  worker  process  before
              executing  any  tasks;  <u>initargs</u> is a tuple of arguments passed to the initializer. If <u>initializer</u>
              raises an exception, all pending tasks and any attempt to submit new tasks to the pool will  raise
              a <u>BrokenExecutor</u> exception.

              Other parameters:

              • <u>python_exe</u>:  Path to the Python interpreter executable used to spawn worker processes, otherwise
                <u>sys.executable</u> is used.

              • <u>python_args</u>: <u>list</u> or iterable  with  additional  command  line  flags  to  pass  to  the  Python
                executable.  Command  line  flags  determined  from inspection of <u>sys.flags</u>, <u>sys.warnoptions</u> and
                <u>sys._xoptions</u> in are passed unconditionally.

              • <u>mpi_info</u>: <u>dict</u> or iterable yielding <b>(key,</b> <b>value)</b> pairs.  These <b>(key,</b>  <b>value)</b>  pairs  are  passed
                (through  an  <b>MPI.Info</b>  object)  to the <b>MPI.Intracomm.Spawn</b> call used to spawn worker processes.
                This mechanism allows telling the MPI runtime system where and how to start the processes. Check
                the documentation of the backend MPI implementation about the set of keys it interprets and  the
                corresponding format for values.

              • <u>globals</u>:  <u>dict</u>  or iterable yielding <b>(name,</b> <b>value)</b> pairs to initialize the main module namespace
                in worker processes.

              • <u>main</u>: If set to <u>False</u>, do not import the <b>__</b><u>main</u><b>__</b> module in worker processes.  Setting  <u>main</u>  to
                <u>False</u> prevents worker processes from accessing definitions in the parent <b>__</b><u>main</u><b>__</b> namespace.

              • <u>path</u>: <u>list</u> or iterable with paths to append to <u>sys.path</u> in worker processes to extend the <u>module</u>
                <u>search</u> <u>path</u>.

              • <u>wdir</u>:  Path  to  set  the  current  working  directory in worker processes using <u>os.chdir()</u>. The
                initial working directory is set by the MPI implementation. Quality MPI  implementations  should
                honor a <b>wdir</b> info key passed through <u>mpi_info</u>, although such feature is not mandatory.

              • <u>env</u>:  <u>dict</u>  or  iterable  yielding  <b>(name,</b>  <b>value)</b>  pairs  with  environment variables to update
                <u>os.environ</u> in worker processes.  The initial environment is set by the MPI  implementation.  MPI
                implementations may allow setting the initial environment through <u>mpi_info</u>, however such feature
                is not required nor recommended by the MPI standard.

              <b>submit(func,</b> <b>*args,</b> <b>**kwargs)</b>
                     Schedule  the  callable, <u>func</u>, to be executed as <b>func(*args,</b> <b>**kwargs)</b> and returns a <u>Future</u>
                     object representing the execution of the callable.

                        executor = MPIPoolExecutor(max_workers=1)
                        future = executor.submit(pow, 321, 1234)
                        print(future.result())

              <b>map(func,</b> <b>*iterables,</b> <b>timeout=None,</b> <b>chunksize=1,</b> <b>**kwargs)</b>
                     Equivalent to <u>map(func,</u> <u>*iterables)</u> except <u>func</u>  is  executed  asynchronously  and  several
                     calls  to <u>func</u> may be made concurrently, out-of-order, in separate processes.  The returned
                     iterator raises a <u>TimeoutError</u> if <b>__</b><u>next</u><b>__</b><u>()</u> is called and the result isn’t available after
                     <u>timeout</u> seconds from the original call to <u>map()</u>.  <u>timeout</u> can be an int  or  a  float.   If
                     <u>timeout</u>  is not specified or <u>None</u>, there is no limit to the wait time.  If a call raises an
                     exception, then that exception will  be  raised  when  its  value  is  retrieved  from  the
                     iterator.  This method chops <u>iterables</u> into a number of chunks which it submits to the pool
                     as separate tasks. The (approximate) size of these  chunks  can  be  specified  by  setting
                     <u>chunksize</u> to a positive integer. For very long iterables, using a large value for <u>chunksize</u>
                     can  significantly improve performance compared to the default size of one. By default, the
                     returned iterator yields results in-order, waiting for successive tasks to complete .  This
                     behavior  can be changed by passing the keyword argument <u>unordered</u> as <u>True</u>, then the result
                     iterator will yield a result as soon as any of the tasks complete.

                        executor = MPIPoolExecutor(max_workers=3)
                        for result in executor.map(pow, [2]*32, <a href="../man32/range.32.html">range</a>(32)):
                            print(result)

              <b>starmap(func,</b> <b>iterable,</b> <b>timeout=None,</b> <b>chunksize=1,</b> <b>**kwargs)</b>
                     Equivalent to <u>itertools.starmap(func,</u>  <u>iterable)</u>.  Used  instead  of  <u>map()</u>  when  argument
                     parameters  are  already  grouped  in  tuples  from  a  single  iterable (the data has been
                     “pre-zipped”). <u>map(func,</u> <u>*iterable)</u> is equivalent to <u>starmap(func,</u> <u>zip(*iterable))</u>.

                        executor = MPIPoolExecutor(max_workers=3)
                        iterable = ((2, n) for n in <a href="../man32/range.32.html">range</a>(32))
                        for result in executor.starmap(pow, iterable):
                            print(result)

              <b>shutdown(wait=True,</b> <b>cancel_futures=False)</b>
                     Signal the executor that it should free any resources that it is using when  the  currently
                     pending futures are done executing.  Calls to <u>submit()</u> and <u>map()</u> made after <u>shutdown()</u> will
                     raise <u>RuntimeError</u>.

                     If  <u>wait</u>  is  <u>True</u>  then this method will not return until all the pending futures are done
                     executing and the resources associated with the executor have been freed.  If <u>wait</u> is <u>False</u>
                     then this method will return immediately and the resources  associated  with  the  executor
                     will  be  freed  when  all  pending futures are done executing.  Regardless of the value of
                     <u>wait</u>, the entire Python program will not exit until all pending futures are done executing.

                     If <u>cancel_futures</u> is <u>True</u>, this method will cancel all pending futures  that  the  executor
                     has  not  started  running.  Any  futures that are completed or running won’t be cancelled,
                     regardless of the value of <u>cancel_futures</u>.

                     You can avoid having to call this method explicitly if you use the  <u>with</u>  statement,  which
                     will  shutdown the executor instance (waiting as if <u>shutdown()</u> were called with <u>wait</u> set to
                     <u>True</u>).

                        import time
                        with MPIPoolExecutor(max_workers=1) as executor:
                            future = executor.submit(time.sleep, 2)
                        assert future.done()

              <b>bootup(wait=True)</b>
                     Signal the executor that it should allocate eagerly any required resources (in  particular,
                     MPI  worker  processes).  If <u>wait</u> is <u>True</u>, then <u>bootup()</u> will not return until the executor
                     resources are ready to process submissions.  Resources are automatically allocated  in  the
                     first call to <u>submit()</u>, thus calling <u>bootup()</u> explicitly is seldom needed.

       <b>MPI4PY_FUTURES_MAX_WORKERS</b>
              If    the    <u>max_workers</u>    parameter   to   <u>MPIPoolExecutor</u>   is   <u>None</u>   or   not   given,   the
              <u>MPI4PY_FUTURES_MAX_WORKERS</u> environment variable provides fallback value for the maximum number  of
              MPI worker processes to spawn.

       <b>NOTE:</b>
          As  the  master  process  uses  a  separate  thread to perform MPI communication with the workers, the
          backend MPI implementation should provide support for <b>MPI.THREAD_MULTIPLE</b>. However, some  popular  MPI
          implementations do not support yet concurrent MPI calls from multiple threads. Additionally, users may
          decide  to  initialize MPI with a lower level of thread support. If the level of thread support in the
          backend MPI is less than <b>MPI.THREAD_MULTIPLE</b>, <u>mpi4py.futures</u> will use a global lock to  serialize  MPI
          calls.  If  the level of thread support is less than <b>MPI.THREAD_SERIALIZED</b>, <u>mpi4py.futures</u> will emit a
          <u>RuntimeWarning</u>.

       <b>WARNING:</b>
          If the level of thread support in the backend MPI is  less  than  <b>MPI.THREAD_SERIALIZED</b>  (i.e,  it  is
          either <b>MPI.THREAD_SINGLE</b> or <b>MPI.THREAD_FUNNELED</b>), in theory <u>mpi4py.futures</u> cannot be used. Rather than
          raising  an exception, <u>mpi4py.futures</u> emits a warning and takes a “cross-fingers” attitude to continue
          execution in the hope that serializing MPI calls with a global lock will actually work.

   <b>MPICommExecutor</b>
       Legacy MPI-1 implementations (as well as some vendor MPI-2 implementations) do not  support  the  dynamic
       process  management  features  introduced  in  the MPI-2 standard. Additionally, job schedulers and batch
       systems in supercomputing  facilities  may  pose  additional  complications  to  applications  using  the
       <b>MPI_Comm_spawn()</b> routine.

       With  these  issues  in  mind,  <u>mpi4py.futures</u>  supports  an additonal, more traditional, SPMD-like usage
       pattern requiring MPI-1 calls only. Python applications are  started  the  usual  way,  e.g.,  using  the
       <b>mpiexec</b>  command.  Python  code  should  make a collective call to the <u>MPICommExecutor</u> context manager to
       partition the set of MPI processes within a MPI communicator in one master  processes  and  many  workers
       processes.  The master process gets access to an <u>MPIPoolExecutor</u> instance to submit tasks. Meanwhile, the
       worker process follow a different execution path and team-up to execute  the  tasks  submitted  from  the
       master.

       Besides  alleviating  the  lack  of  dynamic  process managment features in legacy MPI-1 or partial MPI-2
       implementations,  the  <u>MPICommExecutor</u>  context  manager  may  be  useful  in  classic  MPI-based  Python
       applications willing to take advantage of the simple, task-based, master/worker approach available in the
       <u>mpi4py.futures</u> package.

       <b>class</b> <b>mpi4py.futures.MPICommExecutor(comm=None,</b> <b>root=0)</b>
              Context  manager  for  <u>MPIPoolExecutor</u>. This context manager splits a MPI (intra)communicator <u>comm</u>
              (defaults to <b>MPI.COMM_WORLD</b> if not provided or <u>None</u>) in two disjoint sets: a single master process
              (with rank <u>root</u> in <u>comm</u>) and the remaining worker processes. These sets are then connected through
              an intercommunicator.  The target of the <u>with</u> statement  is  assigned  either  an  <u>MPIPoolExecutor</u>
              instance (at the master) or <u>None</u> (at the workers).

                 from mpi4py import MPI
                 from mpi4py.futures import MPICommExecutor

                 with MPICommExecutor(MPI.COMM_WORLD, root=0) as executor:
                     if executor is not None:
                        future = executor.submit(abs, -42)
                        assert future.result() == 42
                        answer = set(executor.map(abs, [-42, 42]))
                        assert answer == {42}

       <b>WARNING:</b>
          If  <u>MPICommExecutor</u>  is  passed  a  communicator  of size one (e.g., <b>MPI.COMM_SELF</b>), then the executor
          instace assigned to the target of the <u>with</u> statement will execute all  submitted  tasks  in  a  single
          worker  thread, thus ensuring that task execution still progress asynchronously. However, the <u>GIL</u> will
          prevent the main and worker threads from running concurrently in multicore processors.  Moreover,  the
          thread  context switching may harm noticeably the performance of CPU-bound tasks. In case of I/O-bound
          tasks, the <u>GIL</u> is not usually an issue, however, as a single worker thread is used,  it  progress  one
          task  at  a  time.  We advice against using <u>MPICommExecutor</u> with communicators of size one and suggest
          refactoring your code to use instead a <u>ThreadPoolExecutor</u>.

   <b>Command</b> <b>line</b>
       Recalling the issues related to the lack of  support  for  dynamic  process  managment  features  in  MPI
       implementations,  <u>mpi4py.futures</u>  supports  an  alternative  usage pattern where Python code (either from
       scripts, modules, or zip files) is run under command  line  control  of  the  <u>mpi4py.futures</u>  package  by
       passing  <b>-m</b>  <b>mpi4py.futures</b>  to  the <b>python</b> executable.  The <b>mpi4py.futures</b> invocation should be passed a
       <u>pyfile</u> path  to  a  script  (or  a  zipfile/directory  containing  a  <b>__main__.py</b>  file).   Additionally,
       <b>mpi4py.futures</b>  accepts  <b>-m</b> <u>mod</u> to execute a module named <u>mod</u>, <b>-c</b> <u>cmd</u> to execute a command string <u>cmd</u>, or
       even <b>-</b> to read commands from standard input (<u>sys.stdin</u>).  Summarizing, <b>mpi4py.futures</b> can be  invoked  in
       the following ways:

       • <b>$</b> <b>mpiexec</b> <b>-n</b> <u>numprocs</u> <b>python</b> <b>-m</b> <b>mpi4py.futures</b> <u>pyfile</u> <b>[arg]</b> <b>...</b>

       • <b>$</b> <b>mpiexec</b> <b>-n</b> <u>numprocs</u> <b>python</b> <b>-m</b> <b>mpi4py.futures</b> <b>-m</b> <u>mod</u> <b>[arg]</b> <b>...</b>

       • <b>$</b> <b>mpiexec</b> <b>-n</b> <u>numprocs</u> <b>python</b> <b>-m</b> <b>mpi4py.futures</b> <b>-c</b> <u>cmd</u> <b>[arg]</b> <b>...</b>

       • <b>$</b> <b>mpiexec</b> <b>-n</b> <u>numprocs</u> <b>python</b> <b>-m</b> <b>mpi4py.futures</b> <b>-</b> <b>[arg]</b> <b>...</b>

       Before  starting  the  main  script  execution,  <u>mpi4py.futures</u>  splits <b>MPI.COMM_WORLD</b> in one master (the
       process with rank 0 in <b>MPI.COMM_WORLD</b>) and <u>numprocs</u>  <u>-</u>  <u>1</u>  workers  and  connects  them  through  an  MPI
       intercommunicator.   Afterwards,  the master process proceeds with the execution of the user script code,
       which eventually creates <u>MPIPoolExecutor</u> instances to  submit  tasks.  Meanwhile,  the  worker  processes
       follow a different execution path to serve the master.  Upon successful termination of the main script at
       the master, the entire MPI execution environment exists gracefully. In case of any unhandled exception in
       the  main  script,  the  master  process  calls  <b><a href="../man1/MPI.COMM_WORLD.Abort.1.html">MPI.COMM_WORLD.Abort</a>(1)</b>  to  prevent deadlocks and force
       termination of entire MPI execution environment.

       <b>WARNING:</b>
          Running scripts under command  line  control  of  <u>mpi4py.futures</u>  is  quite  similar  to  executing  a
          single-process  application  that  spawn  additional  workers  as  required.  However, there is a very
          important difference users should be aware of. All <u>MPIPoolExecutor</u> instances  created  at  the  master
          will  share  the  pool of workers. Tasks submitted at the master from many different executors will be
          scheduled for execution in random order as soon as a worker is idle. Any executor  can  easily  starve
          all  the  workers  (e.g., by calling <u>MPIPoolExecutor.map()</u> with long iterables). If that ever happens,
          submissions from other executors will not be serviced until free workers are available.

       <b>SEE</b> <b>ALSO:</b>

          <u>Command</u> <u>line</u>
                 Documentation on Python command line interface.

   <b>Examples</b>
       The following <b>julia.py</b> script computes the <u>Julia</u> <u>set</u> and dumps an image to disk in binary <u>PGM</u> format. The
       code starts by importing <u>MPIPoolExecutor</u> from the <u>mpi4py.futures</u> package. Next, some global constants and
       functions implement the computation of the Julia set. The computations are protected with the standard <b>if</b>
       <b>__name__</b> <b>==</b> <b>'__main__':...</b>  idiom.  The image is computed by whole scanlines submitting all  these  tasks
       at  once  using  the  <u>map</u>  method.  The  result iterator yields scanlines in-order as the tasks complete.
       Finally, each scanline is dumped to disk.

       <b>julia.py</b>

          from mpi4py.futures import MPIPoolExecutor

          x0, x1, w = -2.0, +2.0, 640*2
          y0, y1, h = -1.5, +1.5, 480*2
          dx = (x1 - x0) / w
          dy = (y1 - y0) / h

          c = complex(0, 0.65)

          def julia(x, y):
              z = complex(x, y)
              n = 255
              while abs(z) &lt; 3 and n &gt; 1:
                  z = z**2 + c
                  n -= 1
              return n

          def julia_line(k):
              line = bytearray(w)
              y = y1 - k * dy
              for j in range(w):
                  x = x0 + j * dx
                  line[j] = julia(x, y)
              return line

          if __name__ == '__main__':

              with MPIPoolExecutor() as executor:
                  image = executor.map(julia_line, range(h))
                  with open('julia.pgm', 'wb') as f:
                      f.write(b'P5 %d %d %d\n' % (w, h, 255))
                      for line in image:
                          f.write(line)

       The recommended way to execute the script is by using the <b>mpiexec</b>  command  specifying  one  MPI  process
       (master)  and  (optional  but  recommended) the desired MPI universe size, which determines the number of
       additional dynamically spawned processes (workers). The MPI universe size is provided either by  a  batch
       system  or  set  by  the  user  via  command-line arguments to <b>mpiexec</b> or environment variables. Below we
       provide examples for MPICH and Open MPI implementations [1].  In  all  of  these  examples,  the  <b>mpiexec</b>
       command  launches  a  single master process running the Python interpreter and executing the main script.
       When required, <u>mpi4py.futures</u> spawns the pool of 16 worker processes. The master  submits  tasks  to  the
       workers  and  waits  for the results. The workers receive incoming tasks, execute them, and send back the
       results to the master.

       When using MPICH implementation or its derivatives based on the Hydra process manager, users can set  the
       MPI universe size via the <b>-usize</b> argument to <b>mpiexec</b>:

          $ mpiexec -n 1 -usize 17 python julia.py

       or, alternatively, by setting the <b>MPIEXEC_UNIVERSE_SIZE</b> environment variable:

          $ MPIEXEC_UNIVERSE_SIZE=17 mpiexec -n 1 python julia.py

       In the Open MPI implementation, the MPI universe size can be set via the <b>-host</b> argument to <b>mpiexec</b>:

          $ mpiexec -n 1 -host &lt;hostname&gt;:17 python julia.py

       Another  way  to specify the number of workers is to use the <u>mpi4py.futures</u>-specific environment variable
       <u>MPI4PY_FUTURES_MAX_WORKERS</u>:

          $ MPI4PY_FUTURES_MAX_WORKERS=16 mpiexec -n 1 python julia.py

       Note that in this case, the MPI universe size is ignored.

       Alternatively, users may decide to execute the script in a more traditional way, that  is,  all  the  MPI
       processes  are  started  at  once.  The  user  script is run under command-line control of <u>mpi4py.futures</u>
       passing the <u>-m</u> flag to the <b>python</b> executable:

          $ mpiexec -n 17 python -m mpi4py.futures julia.py

       As explained previously, the 17 processes are partitioned in  one  master  and  16  workers.  The  master
       process executes the main script while the workers execute the tasks submitted by the master.

       [1]  When using an MPI implementation other than MPICH or Open MPI, please check the documentation of the
            implementation and/or batch system for the ways to specify the desired MPI universe size.

       <b>GIL</b>    See <u>global</u> <u>interpreter</u> <u>lock</u>.

</pre><h4><b>MPI4PY.UTIL</b></h4><pre>
       New in version 3.1.0.

       The <u>mpi4py.util</u> package collects miscellaneous utilities within the intersection of Python and MPI.

   <b>mpi4py.util.pkl5</b>
       New in version 3.1.0.

       <u>pickle</u>  protocol  5 (see <u>PEP</u> <u>574</u>) introduced support for out-of-band buffers, allowing for more efficient
       handling of certain object types with large memory footprints.

       MPI for Python uses the traditional in-band  handling  of  buffers.  This  approach  is  appropriate  for
       communicating  non-buffer  Python  objects,  or  buffer-like  objects  with  small memory footprints. For
       point-to-point communication, in-band buffer handling allows for the communication of  a  pickled  stream
       with  a  single  MPI  message,  at  the expense of additional CPU and memory overhead in the pickling and
       unpickling steps.

       The  <u>mpi4py.util.pkl5</u>  module  provides  communicator   wrapper   classes   reimplementing   pickle-based
       point-to-point  communication  methods  using pickle protocol 5. Handling out-of-band buffers necessarily
       involve multiple MPI messages, thus increasing latency and hurting performance  in  case  of  small  size
       data. However, in case of large size data, the zero-copy savings of out-of-band buffer handling more than
       offset  the extra latency costs.  Additionally, these wrapper methods overcome the infamous 2 GiB message
       count limit (MPI-1 to MPI-3).

       <b>NOTE:</b>
          Support for pickle protocol 5 is available in the <u>pickle</u> module within  the  Python  standard  library
          since  Python 3.8. Previous Python 3 releases can use the <b>pickle5</b> backport, which is available on <u>PyPI</u>
          and can be installed with:

              python -m pip install pickle5

       <b>class</b> <b>mpi4py.util.pkl5.Request(*args,</b> <b>**kwargs)</b>
              Custom request class for nonblocking communications.

              <b>NOTE:</b>
                 <u>Request</u> is not a subclass of <b>mpi4py.MPI.Request</b>

              <b>Free()</b>

              <b>cancel()</b>

              <b>get_status()</b>

              <b>test()</b>

              <b>wait()</b>

              <b>testall()</b>

                     <b>Classmethod</b>

              <b>waitall()</b>

                     <b>Classmethod</b>

       <b>class</b> <b>mpi4py.util.pkl5.Message(*args,</b> <b>**kwargs)</b>
              Custom message class for matching probes.

              <b>NOTE:</b>
                 <u>Message</u> is not a subclass of <b>mpi4py.MPI.Message</b>

              <b>recv()</b>

              <b>irecv()</b>

              <b>probe()</b>

                     <b>Classmethod</b>

              <b>iprobe()</b>

                     <b>Classmethod</b>

       <b>class</b> <b>mpi4py.util.pkl5.Comm(*args,</b> <b>**kwargs)</b>
              Base communicator wrapper class.

              <b>send()</b>

              <b>bsend()</b>

              <b>ssend()</b>

              <b>isend()</b>

              <b>ibsend()</b>

              <b>issend()</b>

              <b>recv()</b>

              <b>irecv()</b>

                     <b>WARNING:</b>
                        This method cannot be supported reliably and raises <u>RuntimeError</u>.

              <b>sendrecv()</b>

              <b>mprobe()</b>

              <b>improbe()</b>

              <b>bcast()</b>

       <b>class</b> <b>mpi4py.util.pkl5.Intracomm(*args,</b> <b>**kwargs)</b>
              Intracommunicator wrapper class.

       <b>class</b> <b>mpi4py.util.pkl5.Intercomm(*args,</b> <b>**kwargs)</b>
              Intercommunicator wrapper class.

   <b>Examples</b>
       <b>test-pkl5-1.py</b>

          import numpy as np
          from mpi4py import MPI
          from mpi4py.util import pkl5

          comm = pkl5.Intracomm(MPI.COMM_WORLD)  # comm wrapper
          size = comm.Get_size()
          rank = comm.Get_rank()
          dst = (rank + 1) % size
          src = (rank - 1) % size

          sobj = np.full(1024**3, rank, dtype='i4')  # &gt; 4 GiB
          sreq = comm.isend(sobj, dst, tag=42)
          robj = comm.recv (None, src, tag=42)
          sreq.Free()

          assert np.min(robj) == src
          assert np.max(robj) == src

       <b>test-pkl5-2.py</b>

          import numpy as np
          from mpi4py import MPI
          from mpi4py.util import pkl5

          comm = pkl5.Intracomm(MPI.COMM_WORLD)  # comm wrapper
          size = comm.Get_size()
          rank = comm.Get_rank()
          dst = (rank + 1) % size
          src = (rank - 1) % size

          sobj = np.full(1024**3, rank, dtype='i4')  # &gt; 4 GiB
          sreq = comm.isend(sobj, dst, tag=42)

          status = MPI.Status()
          rmsg = comm.mprobe(status=status)
          assert status.Get_source() == src
          assert status.Get_tag() == 42
          rreq = rmsg.irecv()
          robj = rreq.wait()

          sreq.Free()
          assert np.max(robj) == src
          assert np.min(robj) == src

   <b>mpi4py.util.dtlib</b>
       New in version 3.1.0.

       The <u>mpi4py.util.dtlib</u> module provides converter routines between NumPy and MPI datatypes.

       <b>mpi4py.util.dtlib.from_numpy_dtype()</b>

              <b>Parameters</b>
                     <b>dtype</b> -- NumPy dtype-like object.

       <b>mpi4py.util.dtlib.to_numpy_dtype()</b>

              <b>Parameters</b>
                     <b>datatype</b> -- MPI datatype.

</pre><h4><b>MPI4PY.RUN</b></h4><pre>
       New in version 3.0.0.

       At import time, <u>mpi4py</u> initializes the MPI execution environment calling <b>MPI_Init_thread()</b>  and  installs
       an   exit  hook  to  automatically  call  <b>MPI_Finalize()</b>  just  before  the  Python  process  terminates.
       Additionally, <u>mpi4py</u> overrides the default <b>ERRORS_ARE_FATAL</b> error  handler  in  favor  of  <b>ERRORS_RETURN</b>,
       which allows translating MPI errors in Python exceptions. These departures from standard MPI behavior may
       be  controversial,  but  are  quite  convenient within the highly dynamic Python programming environment.
       Third-party code using <u>mpi4py</u> can just <b>from</b> <b>mpi4py</b> <b>import</b> <b>MPI</b> and perform MPI calls without  the  tedious
       initialization/finalization  handling.   MPI  errors, once translated automatically to Python exceptions,
       can be dealt with the common <u>try</u>…<u>except</u>…<u>finally</u> clauses; unhandled MPI exceptions will print a  traceback
       which helps in locating problems in source code.

       Unfortunately,  the  interplay  of  automatic  MPI  finalization  and  unhandled  exceptions  may lead to
       deadlocks. In unattended runs, these deadlocks will drain the battery of your laptop,  or  burn  precious
       allocation hours in your supercomputing facility.

       Consider  the  following  snippet  of Python code. Assume this code is stored in a standard Python script
       file and run with <b>mpiexec</b> in two or more processes.

          from mpi4py import MPI
          assert MPI.COMM_WORLD.Get_size() &gt; 1
          rank = MPI.COMM_WORLD.Get_rank()
          if rank == 0:
              1/0
              MPI.COMM_WORLD.send(None, dest=1, tag=42)
          elif rank == 1:
              MPI.COMM_WORLD.recv(source=0, tag=42)

       Process 0 raises <u>ZeroDivisionError</u> exception before performing a send call to process 1. As the exception
       is not handled, the Python interpreter running in process 0 will proceed to exit  with  non-zero  status.
       However,  as  <u>mpi4py</u>  installed a finalizer hook to call <b>MPI_Finalize()</b> before exit, process 0 will block
       waiting for other processes to also enter the  <b>MPI_Finalize()</b>  call.  Meanwhile,  process  1  will  block
       waiting  for  a  message  to  arrive from process 0, thus never reaching to <b>MPI_Finalize()</b>. The whole MPI
       execution environment is irremediably in a deadlock state.

       To alleviate this issue, <u>mpi4py</u> offers a simple, alternative command line execution  mechanism  based  on
       using  the <u>-m</u> flag and implemented with the <u>runpy</u> module. To use this features, Python code should be run
       passing <b>-m</b> <b>mpi4py</b> in the command line invoking the Python interpreter. In case of  unhandled  exceptions,
       the  finalizer  hook  will call <b>MPI_Abort()</b> on the <b>MPI_COMM_WORLD</b> communicator, thus effectively aborting
       the MPI execution environment.

       <b>WARNING:</b>
          When a process is forced to abort, resources (e.g. open files) are not cleaned-up and  any  registered
          finalizers  (either  with  the  <u>atexit</u>  module,  the  Python C/API function <u>Py_AtExit()</u>, or even the C
          standard library function <b>atexit()</b>) will not be executed. Thus, aborting  execution  is  an  extremely
          impolite way of ensuring process termination. However, MPI provides no other mechanism to recover from
          a deadlock state.

   <b>Interface</b> <b>options</b>
       The use of <b>-m</b> <b>mpi4py</b> to execute Python code on the command line resembles that of the Python interpreter.

       • <b>mpiexec</b> <b>-n</b> <u>numprocs</u> <b>python</b> <b>-m</b> <b>mpi4py</b> <u>pyfile</u> <b>[arg]</b> <b>...</b>

       • <b>mpiexec</b> <b>-n</b> <u>numprocs</u> <b>python</b> <b>-m</b> <b>mpi4py</b> <b>-m</b> <u>mod</u> <b>[arg]</b> <b>...</b>

       • <b>mpiexec</b> <b>-n</b> <u>numprocs</u> <b>python</b> <b>-m</b> <b>mpi4py</b> <b>-c</b> <u>cmd</u> <b>[arg]</b> <b>...</b>

       • <b>mpiexec</b> <b>-n</b> <u>numprocs</u> <b>python</b> <b>-m</b> <b>mpi4py</b> <b>-</b> <b>[arg]</b> <b>...</b>

       <b>&lt;pyfile&gt;</b>
              Execute the Python code contained in <u>pyfile</u>, which must be a filesystem path referring to either a
              Python  file,  a  directory  containing  a <b>__main__.py</b> file, or a zipfile containing a <b>__main__.py</b>
              file.

       <b>-m</b> <b>&lt;mod&gt;</b>
              Search <u>sys.path</u> for the named module <u>mod</u> and execute its contents.

       <b>-c</b> <b>&lt;cmd&gt;</b>
              Execute the Python code in the <u>cmd</u> string command.

       <b>-</b>      Read commands from standard input (<u>sys.stdin</u>).

       <b>SEE</b> <b>ALSO:</b>

          <u>Command</u> <u>line</u>
                 Documentation on Python command line interface.

</pre><h4><b>REFERENCE</b></h4><pre>
                                                  ┌────────────┬───┐
                                                  │ <u>mpi4py.MPI</u> │   │
                                                  └────────────┴───┘

   <b>mpi4py.MPI</b>
       <b>mpi4py.MPI</b>

</pre><h4><b>CITATION</b></h4><pre>
       If MPI for Python been significant to a project that leads to an academic publication, please acknowledge
       that fact by citing the project.

       • L. Dalcin and Y.-L. L. Fang, <u>mpi4py:</u> <u>Status</u> <u>Update</u> <u>After</u> <u>12</u> <u>Years</u> <u>of</u> <u>Development</u>, Computing in  Science
         &amp; Engineering, <a href="../man4/23.4.html">23</a>(4):47-54, 2021.  <u>https://doi.org/10.1109/MCSE.2021.3083216</u>

       • L.  Dalcin,  P.  Kler,  R. Paz, and A. Cosimo, <u>Parallel</u> <u>Distributed</u> <u>Computing</u> <u>using</u> <u>Python</u>, Advances in
         Water Resources, <a href="../man9/34.9.html">34</a>(9):1124-1139, 2011.  <u>https://doi.org/10.1016/j.advwatres.2011.04.013</u>

       • L. Dalcin, R. Paz, M. Storti, and J.  D’Elia,  <u>MPI</u>  <u>for</u>  <u>Python:</u>  <u>performance</u>  <u>improvements</u>  <u>and</u>  <u>MPI-2</u>
         <u>extensions</u>,    Journal    of    Parallel    and    Distributed    Computing,    <a href="../man5/68.5.html">68</a>(5):655-662,    2008.
         <u>https://doi.org/10.1016/j.jpdc.2007.09.005</u>

       • L. Dalcin, R. Paz, and M. Storti, <u>MPI</u> <u>for</u>  <u>Python</u>,  Journal  of  Parallel  and  Distributed  Computing,
         <a href="../man9/65.9.html">65</a>(9):1108-1115, 2005.  <u>https://doi.org/10.1016/j.jpdc.2005.03.010</u>

</pre><h4><b>INSTALLATION</b></h4><pre>
   <b>Requirements</b>
       You need to have the following software properly installed in order to build <u>MPI</u> <u>for</u> <u>Python</u>:

       • A working MPI implementation, preferably supporting MPI-3 and built with shared/dynamic libraries.

         <b>NOTE:</b>
            If  you  want  to build some MPI implementation from sources, check the instructions at <u>Building</u> <u>MPI</u>
            <u>from</u> <u>sources</u> in the appendix.

       • Python 2.7, 3.5 or above.

         <b>NOTE:</b>
            Some MPI-1 implementations <b>do</b> <b>require</b> the actual command line arguments to be passed in  <b>MPI_Init()</b>.
            In  this  case,  you will need to use a rebuilt, MPI-enabled, Python interpreter executable. <u>MPI</u> <u>for</u>
            <u>Python</u> has some support for alleviating you from this task. Check the  instructions  at  <u>MPI-enabled</u>
            <u>Python</u> <u>interpreter</u> in the appendix.

   <b>Using</b> <b>pip</b>
       If  you  already  have  a  working  MPI  (either if you installed it from sources or by using a pre-built
       package from your favourite GNU/Linux distribution) and the <b>mpicc</b> compiler  wrapper  is  on  your  search
       path, you can use <b>pip</b>:

          $ python -m pip install mpi4py

       <b>NOTE:</b>
          If  the  <b>mpicc</b> compiler wrapper is not on your search path (or if it has a different name) you can use
          <b>env</b> to pass the environment variable <b>MPICC</b> providing  the  full  path  to  the  MPI  compiler  wrapper
          executable:

              $ env MPICC=/path/to/mpicc python -m pip install mpi4py

       <b>WARNING:</b>
          <b>pip</b>  keeps  previouly  built  wheel  files on its cache for future reuse. If you want to reinstall the
          <u>mpi4py</u> package using a different or updated MPI implementation, you have to either  first  remove  the
          cached wheel file with:

              $ python -m pip cache remove mpi4py

          or ask <b>pip</b> to disable the cache:

              $ python -m pip install --no-cache-dir mpi4py

   <b>Using</b> <b>distutils</b>
       The  <u>MPI</u> <u>for</u> <u>Python</u> package is available for download at the project website generously hosted by GitHub.
       You can use <b>curl</b> or <b>wget</b> to get a release tarball.

       • Using <b>curl</b>:

            $ curl -O https://github.com/mpi4py/mpi4py/releases/download/X.Y.Z/mpi4py-X.Y.Z.tar.gz

       • Using <b>wget</b>:

            $ wget https://github.com/mpi4py/mpi4py/releases/download/X.Y.Z/mpi4py-X.Y.Z.tar.gz

       After unpacking the release tarball:

          $ tar -zxf mpi4py-X.Y.Z.tar.gz
          $ cd mpi4py-X.Y.Z

       the package is ready for building.

       <u>MPI</u> <u>for</u> <u>Python</u> uses a standard distutils-based build  system.  However,  some  distutils  commands  (like
       <u>build</u>) have additional options:

       <b>--mpicc=</b>
              Lets you specify a special location or name for the <b>mpicc</b> compiler wrapper.

       <b>--mpi=</b> Lets you pass a section with MPI configuration within a special configuration file.

       <b>--configure</b>
              Runs  exhaustive tests for checking about missing MPI types, constants, and functions. This option
              should be passed in order to build <u>MPI</u> <u>for</u> <u>Python</u> against  old  MPI-1  or  MPI-2  implementations,
              possibly providing a subset of MPI-3.

       If  you  use  a MPI implementation providing a <b>mpicc</b> compiler wrapper (e.g., MPICH, Open MPI), it will be
       used for compilation and linking. This is the preferred and easiest way of building <u>MPI</u> <u>for</u> <u>Python</u>.

       If <b>mpicc</b> is located somewhere in your search path, simply run the <u>build</u> command:

          $ python setup.py build

       If <b>mpicc</b> is not in your search path or the compiler wrapper has a different name, you can run  the  <u>build</u>
       command specifying its location:

          $ python setup.py build --mpicc=/where/you/have/mpicc

       Alternatively,  you can provide all the relevant information about your MPI implementation by editing the
       file called <b>mpi.cfg</b>. You can use the default section <b>[mpi]</b> or add a  new,  custom  section,  for  example
       <b>[other_mpi]</b>  (see  the  examples  provided  in  the  <b>mpi.cfg</b>  file  as a starting point to write your own
       section):

          [mpi]

          include_dirs         = /usr/local/mpi/include
          libraries            = mpi
          library_dirs         = /usr/local/mpi/lib
          runtime_library_dirs = /usr/local/mpi/lib

          [other_mpi]

          include_dirs         = /opt/mpi/include ...
          libraries            = mpi ...
          library_dirs         = /opt/mpi/lib ...
          runtime_library_dirs = /op/mpi/lib ...

          ...

       and then run the <u>build</u> command, perhaps specifying you custom configuration section:

          $ python setup.py build --mpi=other_mpi

       After building, the package is ready for install.

       If you have root privileges (either by log-in as the root user of by using <b>sudo</b>) and you want to  install
       <u>MPI</u> <u>for</u> <u>Python</u> in your system for all users, just do:

          $ python setup.py install

       The     previous     steps     will     install    the    <u>mpi4py</u>    package    at    standard    location
       <u>prefix</u><b>/lib/python</b><u>X</u><b>.</b><u>X</u><b>/site-packages</b>.

       If you do not have root privileges or you want to install <u>MPI</u> <u>for</u> <u>Python</u> for your private use, just do:

          $ python setup.py install --user

   <b>Testing</b>
       To quickly test the installation:

          $ mpiexec -n 5 python -m mpi4py.bench helloworld
          Hello, World! I am process 0 of 5 on localhost.
          Hello, World! I am process 1 of 5 on localhost.
          Hello, World! I am process 2 of 5 on localhost.
          Hello, World! I am process 3 of 5 on localhost.
          Hello, World! I am process 4 of 5 on localhost.

       If you installed from source, issuing at the command line:

          $ mpiexec -n 5 python demo/helloworld.py

       or (in the case of ancient MPI-1 implementations):

          $ mpirun -np 5 python `pwd`/demo/helloworld.py

       will launch a five-process run of the Python interpreter and run the test script <b>demo/helloworld.py</b>  from
       the source distribution.

       You can also run all the <u>unittest</u> scripts:

          $ mpiexec -n 5 python test/runtests.py

       or, if you have <u>nose</u> unit testing framework installed:

          $ mpiexec -n 5 nosetests -w test

       or, if you have <u>py.test</u> unit testing framework installed:

          $ mpiexec -n 5 py.test test/

</pre><h4><b>APPENDIX</b></h4><pre>
   <b>MPI-enabled</b> <b>Python</b> <b>interpreter</b>
          <b>WARNING:</b>
              These  days it is no longer required to use the MPI-enabled Python interpreter in most cases, and,
              therefore, it is not built by default anymore because it is too  difficult  to  reliably  build  a
              Python interpreter across different distributions.  If you know that you still <b>really</b> need it, see
              below on how to use the <b>build_exe</b> and <b>install_exe</b> commands.

       Some  MPI-1  implementations (notably, MPICH 1) <b>do</b> <b>require</b> the actual command line arguments to be passed
       at the time <b>MPI_Init()</b> is called. In this case, you will need to  use  a  re-built,  MPI-enabled,  Python
       interpreter binary executable. A basic implementation (targeting Python 2.X) of what is required is shown
       below:

          #include &lt;Python.h&gt;
          #include &lt;mpi.h&gt;

          int main(int argc, char *argv[])
          {
             int status, flag;
             MPI_Init(&amp;argc, &amp;argv);
             status = Py_Main(argc, argv);
             MPI_Finalized(&amp;flag);
             if (!flag) MPI_Finalize();
             return status;
          }

       The  source code above is straightforward; compiling it should also be. However, the linking step is more
       tricky: special flags have to be passed to the linker depending on your platform. In order  to  alleviate
       you  for  such  low-level details, <u>MPI</u> <u>for</u> <u>Python</u> provides some pure-distutils based support to build and
       install an MPI-enabled Python interpreter executable:

          $ cd mpi4py-X.X.X
          $ python setup.py build_exe [--mpi=&lt;name&gt;|--mpicc=/path/to/mpicc]
          $ [sudo] python setup.py install_exe [--install-dir=$HOME/bin]

       After the above steps you should have the MPI-enabled interpreter installed  as  <u>prefix</u><b>/bin/python</b><u>X</u><b>.</b><u>X</u><b>-mpi</b>
       (or  <b>$HOME/bin/python</b><u>X</u><b>.</b><u>X</u><b>-mpi</b>). Assuming that <u>prefix</u><b><a href="file:/bin">/bin</a></b> (or <b>$HOME/bin</b>) is listed on your <b>PATH</b>, you should
       be able to enter your MPI-enabled Python interactively, for example:

          $ python2.7-mpi
          Python 2.7.8 (default, Nov 10 2014, 08:19:18)
          [GCC 4.9.2 20141101 (Red Hat 4.9.2-1)] on linux2
          Type "help", "copyright", "credits" or "license" for more information.
          &gt;&gt;&gt; import sys
          &gt;&gt;&gt; sys.executable
          '/usr/bin/python2.7-mpi'
          &gt;&gt;&gt;

   <b>Building</b> <b>MPI</b> <b>from</b> <b>sources</b>
       In the list below you have  some  executive  instructions  for  building  some  of  the  open-source  MPI
       implementations out there with support for shared/dynamic libraries on POSIX environments.

       • <u>MPICH</u>

            $ tar -zxf mpich-X.X.X.tar.gz
            $ cd mpich-X.X.X
            $ ./configure --enable-shared --prefix=/usr/local/mpich
            $ make
            $ make install

       • <u>Open</u> <u>MPI</u>

            $ tar -zxf openmpi-X.X.X tar.gz
            $ cd openmpi-X.X.X
            $ ./configure --prefix=/usr/local/openmpi
            $ make all
            $ make install

       • <u>MPICH</u> <u>1</u>

            $ tar -zxf mpich-X.X.X.tar.gz
            $ cd mpich-X.X.X
            $ ./configure --enable-sharedlib --prefix=/usr/local/mpich1
            $ make
            $ make install

       Perhaps  you  will  need  to  set  the <b>LD_LIBRARY_PATH</b> environment variable (using <b>export</b>, <b>setenv</b> or what
       applies to your system) pointing to the directory containing the MPI  libraries  .  In  case  of  getting
       runtime  linking  errors  when  running  MPI programs, the following lines can be added to the user login
       shell script (<b>.profile</b>, <b>.bashrc</b>, etc.).

       • <u>MPICH</u>

            MPI_DIR=/usr/local/mpich
            export LD_LIBRARY_PATH=$MPI_DIR/lib:$LD_LIBRARY_PATH

       • <u>Open</u> <u>MPI</u>

            MPI_DIR=/usr/local/openmpi
            export LD_LIBRARY_PATH=$MPI_DIR/lib:$LD_LIBRARY_PATH

       • <u>MPICH</u> <u>1</u>

            MPI_DIR=/usr/local/mpich1
            export LD_LIBRARY_PATH=$MPI_DIR/lib/shared:$LD_LIBRARY_PATH:
            export MPICH_USE_SHLIB=yes

         <b>WARNING:</b>
            MPICH 1 support  for  dynamic  libraries  is  not  completely  transparent.  Users  should  set  the
            environment  variable  <b>MPICH_USE_SHLIB</b>  to  <b>yes</b> in order to avoid link problems when using the <b>mpicc</b>
            compiler wrapper.

</pre><h4><b>AUTHOR</b></h4><pre>
       Lisandro Dalcin

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2024, Lisandro Dalcin

3.1                                              April 01, 2024                                        <u><a href="../man1/MPI4PY.1.html">MPI4PY</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>