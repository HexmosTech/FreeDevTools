<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>python-ipfix - python-ipfix Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python3-ipfix">python3-ipfix_0.9.7-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       python-ipfix - python-ipfix Documentation

       IPFIX implementation for Python 3.3.

       This  module  provides a Python interface to IPFIX message streams, and provides tools for building IPFIX
       Exporting and Collecting Processes.  It handles message framing  and  deframing,  encoding  and  decoding
       IPFIX data records using templates, and a bridge between IPFIX ADTs and appropriate Python data types.

       Before  using any of the functions of this module, it is necessary to populate the information model with
       Information Elements.  <u>ipfix.ie.use_iana_default()</u> populates the default IANA IPFIX  Information  Element
       Registry   shipped   with   the   module;   this   is   the   current   registry   as  of  release  time.
       <u>ipfix.ie.use_5103_default()</u> populates the reverse counterpart  IEs  as  in  <u>RFC</u>  <u>5103</u>.  The  module  also
       supports   the  definition  of  enterprise-specific  Information  Elements  via  <u>ipfix.ie.for_spec()</u>  and
       <u>ipfix.ie.use_specfile()</u>; see <u>ipfix.ie</u> for more.

       For reading and writing of records to IPFIX message streams with automatic message  boundary  management,
       see  the <u>ipfix.reader</u> and <u>ipfix.writer</u> modules, respectively. For manual reading and writing of messages,
       see <u>ipfix.message</u>. In any case, exporters will need to define templates; see <u>ipfix.template</u>.

       This module is copyright 2013 Brian Trammell. It is made available under the  terms  of  the  <u>GNU</u>  <u>Lesser</u>
       <u>General</u> <u>Public</u> <u>License</u>, version 3 or, at your option, any later version.

       Reference documentation for each module is found in the subsections below.

</pre><h4><b>MODULE</b> <b>IPFIX.TYPES</b></h4><pre>
       Implementation of IPFIX abstract data types (ADT) and mappings to Python types.

       Maps each IPFIX ADT to the corresponding Python type, as below:
                                        ┌──────────────────────┬─────────────┐
                                        │ IPFIX Type           │ Python Type │
                                        ├──────────────────────┼─────────────┤
                                        │ octetArray           │ bytes       │
                                        ├──────────────────────┼─────────────┤
                                        │ unsigned8            │ int         │
                                        ├──────────────────────┼─────────────┤
                                        │ unsigned16           │ int         │
                                        ├──────────────────────┼─────────────┤
                                        │ unsigned32           │ int         │
                                        ├──────────────────────┼─────────────┤
                                        │ unsigned64           │ int         │
                                        ├──────────────────────┼─────────────┤
                                        │ signed8              │ int         │
                                        ├──────────────────────┼─────────────┤
                                        │ signed16             │ int         │
                                        ├──────────────────────┼─────────────┤
                                        │ signed32             │ int         │
                                        ├──────────────────────┼─────────────┤
                                        │ signed64             │ int         │
                                        ├──────────────────────┼─────────────┤
                                        │ float32              │ float       │
                                        ├──────────────────────┼─────────────┤
                                        │ float64              │ float       │
                                        ├──────────────────────┼─────────────┤
                                        │ boolean              │ bool        │
                                        ├──────────────────────┼─────────────┤
                                        │ macAddress           │ bytes       │
                                        ├──────────────────────┼─────────────┤
                                        │ string               │ str         │
                                        ├──────────────────────┼─────────────┤
                                        │ dateTimeSeconds      │ datetime    │
                                        ├──────────────────────┼─────────────┤
                                        │ dateTimeMilliseconds │ datetime    │
                                        ├──────────────────────┼─────────────┤
                                        │ dateTimeMicroseconds │ datetime    │
                                        ├──────────────────────┼─────────────┤
                                        │ dateTimeNanoseconds  │ datetime    │
                                        ├──────────────────────┼─────────────┤
                                        │ ipv4Address          │ ipaddress   │
                                        ├──────────────────────┼─────────────┤
                                        │ ipv6Address          │ ipaddress   │
                                        └──────────────────────┴─────────────┘

       Though  client  code generally will not use this module directly, it defines how each IPFIX abstract data
       type will be represented in Python, and the concrete IPFIX representation  of  each  type.  Type  methods
       operate  on  buffers, as used internally by the <u>ipfix.message.MessageBuffer</u> class, so we'll create one to
       illustrate encoding and decoding:

       &gt;&gt;&gt; import ipfix.types
       &gt;&gt;&gt; buf = memoryview(<a href="../man16/bytearray.16.html">bytearray</a>(16))

       Each of the encoding methods returns the offset into the buffer of  the  first  byte  after  the  encoded
       value;  since we're always encoding to the beginning of the buffer in this example, this is equivalent to
       the length.  We use this to bound the encoded value on subsequent decode.

       Integers are represented by the python int type:

       &gt;&gt;&gt; unsigned32 = ipfix.types.for_name("unsigned32")
       &gt;&gt;&gt; length = unsigned32.encode_single_value_to(42, buf, 0)
       &gt;&gt;&gt; buf[0:length].tolist()
       [0, 0, 0, 42]
       &gt;&gt;&gt; unsigned32.decode_single_value_from(buf, 0, length)
       42

       ...floats by the float type, with the usual caveats about precision:

       &gt;&gt;&gt; float32 = ipfix.types.for_name("float32")
       &gt;&gt;&gt; length = float32.encode_single_value_to(42.03579, buf, 0)
       &gt;&gt;&gt; buf[0:length].tolist()
       [66, 40, 36, 166]
       &gt;&gt;&gt; float32.decode_single_value_from(buf, 0, length)
       42.035789489746094

       ...strings by the str type, encoded as UTF-8:

       &gt;&gt;&gt; string = ipfix.types.for_name("string")
       &gt;&gt;&gt; length = string.encode_single_value_to("Grüezi", buf, 0)
       &gt;&gt;&gt; buf[0:length].tolist()
       [71, 114, 195, 188, 101, 122, 105]
       &gt;&gt;&gt; string.decode_single_value_from(buf, 0, length)
       'Grüezi'

       ...addresses as the IPv4Address and IPv6Address types in the ipaddress module:

       &gt;&gt;&gt; from ipaddress import ip_address
       &gt;&gt;&gt; ipv4Address = ipfix.types.for_name("ipv4Address")
       &gt;&gt;&gt; length = ipv4Address.encode_single_value_to(ip_address("198.51.100.27"), buf, 0)
       &gt;&gt;&gt; buf[0:length].tolist()
       [198, 51, 100, 27]
       &gt;&gt;&gt; ipv4Address.decode_single_value_from(buf, 0, length)
       IPv4Address('198.51.100.27')
       &gt;&gt;&gt; ipv6Address = ipfix.types.for_name("ipv6Address")
       &gt;&gt;&gt; length = ipv6Address.encode_single_value_to(ip_address("2001:db8::c0:ffee"), buf, 0)
       &gt;&gt;&gt; buf[0:length].tolist()
       [32, 1, 13, 184, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 255, 238]
       &gt;&gt;&gt; ipv6Address.decode_single_value_from(buf, 0, length)
       IPv6Address('2001:db8::c0:ffee')

       ...and the timestamps of various precision as a python datetime, encoded as per RFC5101bis:

       &gt;&gt;&gt; from datetime import datetime
       &gt;&gt;&gt; from datetime import timezone
       &gt;&gt;&gt; dtfmt = "%Y-%m-%d %H:%M:%S.%f"
       &gt;&gt;&gt; dt = datetime.strptime("2013-06-21 14:00:03.456789", dtfmt)

       dateTimeSeconds truncates microseconds:

       &gt;&gt;&gt; dateTimeSeconds = ipfix.types.for_name("dateTimeSeconds")
       &gt;&gt;&gt; length = dateTimeSeconds.encode_single_value_to(dt, buf, 0)
       &gt;&gt;&gt; buf[0:length].tolist()
       [81, 196, 92, 99]
       &gt;&gt;&gt; dateTimeSeconds.decode_single_value_from(buf, 0, length).strftime(dtfmt)
       '2013-06-21 14:00:03.000000'

       dateTimeMilliseconds truncates microseconds to the nearest millisecond:

       &gt;&gt;&gt; dateTimeMilliseconds = ipfix.types.for_name("dateTimeMilliseconds")
       &gt;&gt;&gt; length = dateTimeMilliseconds.encode_single_value_to(dt, buf, 0)
       &gt;&gt;&gt; buf[0:length].tolist()
       [0, 0, 1, 63, 103, 8, 228, 128]
       &gt;&gt;&gt; dateTimeMilliseconds.decode_single_value_from(buf, 0, length).strftime(dtfmt)
       '2013-06-21 14:00:03.456000'

       dateTimeMicroseconds exports microseconds fully in NTP format:

       &gt;&gt;&gt; dateTimeMicroseconds = ipfix.types.for_name("dateTimeMicroseconds")
       &gt;&gt;&gt; length = dateTimeMicroseconds.encode_single_value_to(dt, buf, 0)
       &gt;&gt;&gt; buf[0:length].tolist()
       [81, 196, 92, 99, 116, 240, 32, 0]
       &gt;&gt;&gt; dateTimeMicroseconds.decode_single_value_from(buf, 0, length).strftime(dtfmt)
       '2013-06-21 14:00:03.456789'

       dateTimeNanoseconds is also supported, but is identical to dateTimeMicroseconds, as the datetime class in
       Python only supports microsecond-level timing.

       <b>class</b> <b>ipfix.types.IpfixType(name,</b> <b>num,</b> <b>valenc,</b> <b>valdec,</b> <b>valstr,</b> <b>valparse,</b> <b>roottype=None)</b>
              Abstract interface for all IPFIX types. Used internally.

       <b>exception</b> <b>ipfix.types.IpfixTypeError(*args)</b>
              Raised when attempting to do an unsupported operation on a type

       <b>class</b> <b>ipfix.types.OctetArrayType(name,</b> <b>num,</b> <b>valenc=&lt;function</b> <b>_identity&gt;,</b> <b>valdec=&lt;function</b> <b>_identity&gt;,</b>
       <b>valstr=&lt;built-in</b> <b>function</b> <b>hexlify&gt;,</b> <b>valparse=&lt;built-in</b> <b>function</b> <b>unhexlify&gt;,</b> <b>roottype=None)</b>
              Type encoded by byte array packing. Used internally.

       <b>class</b> <b>ipfix.types.StructType(name,</b> <b>num,</b> <b>stel,</b> <b>valenc=&lt;function</b> <b>_identity&gt;,</b> <b>valdec=&lt;function</b> <b>_identity&gt;,</b>
       <b>valstr=&lt;class</b> <b>'str'&gt;,</b> <b>valparse=&lt;class</b> <b>'int'&gt;,</b> <b>roottype=None)</b>
              Type encoded by struct packing. Used internally.

       <b>ipfix.types.decode_varlen(buf,</b> <b>offset)</b>
              Decode a IPFIX varlen encoded length; used internally by template

       <b>ipfix.types.encode_varlen(buf,</b> <b>offset,</b> <b>length)</b>
              Encode a IPFIX varlen encoded length; used internally by template

       <b>ipfix.types.for_name(name)</b>
              Return an IPFIX type for a given type name

              <b>Parameters</b>
                     <b>name</b> -- the name of the type to look up

              <b>Returns</b>
                     IpfixType -- type instance for that name

              <b>Raises</b> IpfixTypeError

       <b>ipfix.types.use_integer_ipv4()</b>
              Use integers instead of ipaddress.IPv4Address to store IPv4 addresses.  Changes behavior globally;
              should be called before using any IPFIX types.  Designed for use with numpy arrays, to not require
              a Python object for storing IP addresses.

</pre><h4><b>MODULE</b> <b>IPFIX.IE</b></h4><pre>
       IESpec-based interface to IPFIX information elements,  and  interface  to  use  the  default  IPFIX  IANA
       Information Model

       An  IESpec  is  a  string  representation  of an IPFIX information element, including all the information
       required      to      define      it,      as      documented      in      Section      9      of       ‐
       <u><a href="http://tools.ietf.org/html/draft-ietf-ipfix-ie-doctors">http://tools.ietf.org/html/draft-ietf-ipfix-ie-doctors</a></u>.  It has the format:
          name(pen/num)&lt;type&gt;[size]

       To specify a new Information Element, a complete IESpec must be passed to for_spec():

       &gt;&gt;&gt; import ipfix.ie
       &gt;&gt;&gt; e = ipfix.ie.for_spec("myNewInformationElement(35566/1)&lt;string&gt;")
       &gt;&gt;&gt; e
       InformationElement('myNewInformationElement', 35566, 1, ipfix.types.for_name('string'), 65535)

       The string representation of an InformationElement is its IESpec:

       &gt;&gt;&gt; str(e)
       'myNewInformationElement(35566/1)&lt;string&gt;[65535]'

       To  get  an  Information  Element already specified, an incomplete specification can be passed; a name or
       number is enough:

       &gt;&gt;&gt; ipfix.ie.use_iana_default()
       &gt;&gt;&gt; ipfix.ie.use_5103_default()
       &gt;&gt;&gt; str(ipfix.ie.for_spec("octetDeltaCount"))
       'octetDeltaCount(0/1)&lt;unsigned64&gt;[8]'
       &gt;&gt;&gt; str(ipfix.ie.for_spec("(2)"))
       'packetDeltaCount(0/2)&lt;unsigned64&gt;[8]'

       Reduced-length encoding and fixed-length sequence types are supported by the for_length method;  this  is
       used internally by templates.

       &gt;&gt;&gt; str(<a href="../man32/e.for_length.32.html">e.for_length</a>(32))
       'myNewInformationElement(35566/1)&lt;string&gt;[32]'

       An  Information  Element  object  can  also  be  used  to  translate  between  native  Python  and string
       representations of an Information Element value:

       &gt;&gt;&gt; ipfix.ie.for_spec("sourceIPv4Address").parse("192.0.2.19")
       IPv4Address('192.0.2.19')
       &gt;&gt;&gt; from datetime import datetime
       &gt;&gt;&gt; ipfix.ie.for_spec("flowEndMilliseconds").unparse(datetime(2013,6,21,14))
       '2013-06-21 14:00:00.000'

       Most client code will only need the <u>use_iana_default()</u>, <u>use_5103_default()</u>, and <u>use_specfile()</u> functions;
       client code using tuple interfaces will need <u>spec_list()</u> as well.

       <b>class</b> <b>ipfix.ie.InformationElement(name,</b> <b>pen,</b> <b>num,</b> <b>ietype=ipfix.types.for_name('octetArray'),</b> <b>length=None,</b>
       <b>valstr=None,</b> <b>valparse=None)</b>
              An IPFIX Information Element (IE). This is essentially a five-tuple of name, element number (num),
              a private enterprise number (pen; 0 if it is an IANA registered IE), a type, and a length.

              Information Elements may also have value string and parser functions, for representing the  values
              as strings; if not set, these default to

              InformationElement  instances  should  be  obtained  using  the <u>for_spec()</u> or <u>for_template_entry()</u>
              functions.

              <b>for_length(length)</b>
                     Get an instance of this IE for  the  specified  length.   Used  to  support  reduced-length
                     encoding (RLE).

                     <b>Parameters</b>
                            <b>length</b> -- length of the new IE

                     <b>Returns</b>
                            this IE if length matches, or a new IE for the length

                     <b>Raises</b> ValueError

              <b>parse(s)</b>
                     Parse  a string to a value using the conversion function for this Information Element. Uses
                     the default string conversion for the IE's type if not overridden at IE creation time.

                     <b>Parameters</b>
                            <b>s</b> -- string to parse using this IEs's string conversion

                     <b>Returns</b>
                            value for given string

                     <b>Raises</b> ValueError is not a valid string representation for this IE

              <b>unparse(v)</b>
                     Unparse a value to a string using the conversion function  for  this  Information  Element.
                     Uses the default string conversion for the IE's type if not overridden at IE creation time.

                     <b>Parameters</b>
                            <b>v</b> -- value to unparse using this IEs's string conversion

                     <b>Returns</b>
                            string representation of v

                     <b>Raises</b> ValueError if v is not a valid value for this IE

       <b>class</b> <b>ipfix.ie.InformationElementList(iterable=None)</b>
              A hashable ordered list of Information Elements.

              Used  internally by templates, and to specify the order of tuples to the tuple append and iterator
              interfaces. Get an instance by calling <u>spec_list()</u>

       <b>ipfix.ie.clear_infomodel()</b>
              Reset the cache of known Information Elements.

       <b>ipfix.ie.for_spec(spec)</b>
              Get an IE from the cache of known IEs, or create a new IE if not found, given an IESpec.

              <b>Parameters</b>
                     <b>spec</b> -- IEspec, as in draft-ietf-ipfix-ie-doctors, of the  form  name(pen/num)&lt;type&gt;[size];
                     some fields may be omitted unless creating a new IE in the cache.

              <b>Returns</b>
                     an IE for the name

              <b>Raises</b> ValueError

       <b>ipfix.ie.for_template_entry(pen,</b> <b>num,</b> <b>length)</b>
              Get an IE from the cache of known IEs, or create a new IE if not found, given a private enterprise
              number, element number, and length. Used internally by Templates.

              <b>Parameters</b>

                     • <b>pen</b> -- private enterprise number, or 0 for an IANA IE

                     • <b>num</b> -- IE number (Element ID)

                     • <b>length</b> -- length of the IE in bytes

              <b>Returns</b>
                     an  IE  for  the given pen, num, and length. If the IE has not been previously added to the
                     cache of known IEs, the IE will be named _ipfix_pen_num, and have octetArray as a type.

       <b>ipfix.ie.parse_spec(spec)</b>
              Parse an IESpec into name, pen, number, typename, and length fields

       <b>ipfix.ie.spec_list(specs)</b>
              Given a list or iterable of IESpecs, return a hashable list of  IEs.   Pass  this  as  the  ielist
              argument to the tuple export and iterator functions.

              <b>Parameters</b>
                     <b>specs</b> -- list of IESpecs

              <b>Returns</b>
                     a  new  Information  Element  List,  suitable  for  use  with the tuple export and iterator
                     functions in <b>message</b>

              <b>Raises</b> ValueError

       <b>ipfix.ie.use_5103_default()</b>
              Load the module internal list of RFC 5103 reverse IEs for IANA registered IEs into  the  cache  of
              known IEs. Normally, biflow-aware client code should call this just after use_iana_default().

       <b>ipfix.ie.use_iana_default()</b>
              Load the module internal list of IANA registered IEs into the cache of known IEs. Normally, client
              code should call this before using any other part of this module.

       <b>ipfix.ie.use_specfile(filename)</b>
              Load a file listing IESpecs into the cache of known IEs

              <b>Parameters</b>
                     <b>filename</b> -- name of file containing IESpecs to open

              <b>Raises</b> ValueError

</pre><h4><b>MODULE</b> <b>IPFIX.TEMPLATE</b></h4><pre>
       Representation  of  IPFIX  templates.   Provides  template-based  packing  and unpacking of data in IPFIX
       messages.

       For reading, templates are handled internally. For writing, use <b>from_ielist()</b> to create a template.

       See <u>ipfix.message</u> for examples.

       <b>exception</b> <b>ipfix.template.IpfixDecodeError(*args)</b>
              Raised when decoding a malformed IPFIX message

       <b>exception</b> <b>ipfix.template.IpfixEncodeError(*args)</b>
              Raised on internal encoding errors, or if message MTU is too small

       <b>class</b> <b>ipfix.template.Template(tid=0,</b> <b>iterable=None)</b>
              An IPFIX Template.

              A template is an ordered list of IPFIX Information Elements with an ID.

              <b>append(ie)</b>
                     Append an IE to this Template

              <b>count()</b>
                     Count IEs in this template

              <b>decode_from(buf,</b> <b>offset,</b> <b>packplan=None)</b>
                     Decodes a record into a tuple containing values in template order

              <b>decode_namedict_from(buf,</b> <b>offset,</b> <b>recinf=None)</b>
                     Decodes a record from a buffer into a dict keyed by IE name.

              <b>decode_tuple_from(buf,</b> <b>offset,</b> <b>recinf=None)</b>
                     Decodes  a  record  from  a  buffer  into  a   tuple,   ordered   as   the   IEs   in   the
                     InformationElementList given as recinf.

              <b>encode_namedict_to(buf,</b> <b>offset,</b> <b>rec,</b> <b>recinf=None)</b>
                     Encodes a record from a dict containing values keyed by IE name

              <b>encode_template_to(buf,</b> <b>offset,</b> <b>setid)</b>
                     Encodes the template to a buffer.  Encodes as a Template if setid is TEMPLATE_SET_ID, as an
                     Options Template if setid is OPTIONS_SET_ID.

              <b>encode_to(buf,</b> <b>offset,</b> <b>vals,</b> <b>packplan=None)</b>
                     Encodes a record from a tuple containing values in template order

              <b>encode_tuple_to(buf,</b> <b>offset,</b> <b>rec,</b> <b>recinf=None)</b>
                     Encodes a record from a tuple containing values ordered as the IEs in the template.

              <b>finalize()</b>
                     Compile a default packing plan. Called after append()ing all IEs.

              <b>fixlen_count()</b>
                     Count of fixed-length IEs in this template before the first variable-length IE; this is the
                     size of the portion of the template which can be encoded/decoded efficiently.

              <b>identical_to(other)</b>
                     Determine if two templates are identical to each other.

                     Two  templates are considered identical if they contain the same IEs in the same order, and
                     the same scope count. Template ID is not considered  as  part  of  the  test  for  template
                     identity.

              <b>packplan_for_ielist(ielist)</b>
                     Given a list of IEs, devise and cache a packing plan.  Used by the tuple interfaces.

       <b>class</b> <b>ipfix.template.TemplatePackingPlan(tmpl,</b> <b>indices)</b>
              Plan  to  pack/unpack  a specific set of indices for a template.  Used internally by Templates for
              efficient encoding and decoding.

       <b>ipfix.template.decode_template_from(buf,</b> <b>offset,</b> <b>setid)</b>
              Decodes a template from a buffer.  Decodes as a  Template  if  setid  is  TEMPLATE_SET_ID,  as  an
              Options Template if setid is OPTIONS_SET_ID.

       <b>ipfix.template.for_specs(tid,</b> <b>*specs)</b>
              Create a template from a template ID and a list of IESpecs

              <b>Parameters</b>

                     • <b>tid</b> -- Template ID, must be between 256 and 65535.

                     • <b>*specs</b> --

                       List of IESpecs

              <b>Returns</b>
                     A new Template, ready to use for writing to a Message

</pre><h4><b>MODULE</b> <b>IPFIX.MESSAGE</b></h4><pre>
       Provides the MessageBuffer class for encoding and decoding IPFIX Messages.

       This  interface allows direct control over Messages; for reading or writing records automatically from/to
       streams, see <u>ipfix.reader</u> and <u>ipfix.writer</u>, respectively.

       To create a message buffer:

       &gt;&gt;&gt; import ipfix.message
       &gt;&gt;&gt; msg = ipfix.message.MessageBuffer()
       &gt;&gt;&gt; msg
       &lt;MessageBuffer domain 0 length 0&gt;

       To prepare the buffer to write records:

       &gt;&gt;&gt; <a href="../man8304/msg.begin_export.8304.html">msg.begin_export</a>(8304)
       &gt;&gt;&gt; msg
       &lt;MessageBuffer domain 8304 length 16 (writing)&gt;

       Note that the buffer grows to contain the message header.

       To write records to the buffer, first you'll need a template:

       &gt;&gt;&gt; import ipfix.ie
       &gt;&gt;&gt; ipfix.ie.use_iana_default()
       &gt;&gt;&gt; import ipfix.template
       &gt;&gt;&gt; tmpl = ipfix.template.from_ielist(256,
       ...        ipfix.ie.spec_list(("flowStartMilliseconds",
       ...                            "sourceIPv4Address",
       ...                            "destinationIPv4Address",
       ...                            "packetDeltaCount")))
       &gt;&gt;&gt; tmpl
       &lt;Template ID 256 count 4 scope 0&gt;

       To add the template to the message:

       &gt;&gt;&gt; msg.add_template(tmpl)
       &gt;&gt;&gt; msg
       &lt;MessageBuffer domain 8304 length 40 (writing set 2)&gt;

       Note that <u>MessageBuffer.add_template()</u> exports the template when it is written by default, and  that  the
       current set ID is 2 (template set).

       Now,  a  set must be created to add records to the message; the set ID must match the ID of the template.
       MessageBuffer automatically uses the template matching the set ID for record encoding.

       &gt;&gt;&gt; <a href="../man256/msg.export_ensure_set.256.html">msg.export_ensure_set</a>(256)
       &gt;&gt;&gt; msg
       &lt;MessageBuffer domain 8304 length 44 (writing set 256)&gt;

       Records can be added to the set either as dictionaries keyed by IE name:

       &gt;&gt;&gt; from datetime import datetime
       &gt;&gt;&gt; from ipaddress import ip_address
       &gt;&gt;&gt; rec = { "flowStartMilliseconds" : datetime.strptime("2013-06-21 14:00:00",
       ...                                       "%Y-%m-%d %H:%M:%S"),
       ...         "sourceIPv4Address" : ip_address("10.1.2.3"),
       ...         "destinationIPv4Address" : ip_address("10.5.6.7"),
       ...         "packetDeltaCount" : 27 }
       &gt;&gt;&gt; msg.export_namedict(rec)
       &gt;&gt;&gt; msg
       &lt;MessageBuffer domain 8304 length 68 (writing set 256)&gt;

       or as tuples in template order:

       &gt;&gt;&gt; rec = (datetime.strptime("2013-06-21 14:00:02", "%Y-%m-%d %H:%M:%S"),
       ...        ip_address("10.8.9.11"), ip_address("10.12.13.14"), 33)
       &gt;&gt;&gt; msg.export_tuple(rec)
       &gt;&gt;&gt; msg
       &lt;MessageBuffer domain 8304 length 92 (writing set 256)&gt;

       Variable-length information elements will be encoded using the native length of the passed value:

       &gt;&gt;&gt; ipfix.ie.for_spec("myNewInformationElement(35566/1)&lt;string&gt;")
       InformationElement('myNewInformationElement', 35566, 1, ipfix.types.for_name('string'), 65535)
       &gt;&gt;&gt; tmpl = ipfix.template.from_ielist(257,
       ...        ipfix.ie.spec_list(("flowStartMilliseconds",
       ...                            "myNewInformationElement")))
       &gt;&gt;&gt; msg.add_template(tmpl)
       &gt;&gt;&gt; <a href="../man257/msg.export_ensure_set.257.html">msg.export_ensure_set</a>(257)
       &gt;&gt;&gt; msg
       &lt;MessageBuffer domain 8304 length 116 (writing set 257)&gt;
       &gt;&gt;&gt; rec = { "flowStartMilliseconds" : datetime.strptime("2013-06-21 14:00:04",
       ...                                   "%Y-%m-%d %H:%M:%S"),
       ...         "myNewInformationElement" : "Grüezi, Y'all" }
       &gt;&gt;&gt; msg.export_namedict(rec)
       &gt;&gt;&gt; msg
       &lt;MessageBuffer domain 8304 length 139 (writing set 257)&gt;

       Attempts to write past the end of the message (set via  the  mtu  parameter,  default  65535)  result  in
       <u>EndOfMessage</u> being raised.

       Messages  can  be  written to a stream using <u>MessageBuffer.write_message()</u>, or dumped to a byte array for
       transmission using <u>MessageBuffer.to_bytes()</u>.  The message must be reset before starting to write again.

       &gt;&gt;&gt; b = msg.to_bytes()
       &gt;&gt;&gt; msg.begin_export()
       &gt;&gt;&gt; msg
       &lt;MessageBuffer domain 8304 length 16 (writing)&gt;

       Reading happens more or less  in  reverse.  To  begin,  a  message  is  read  from  a  byte  array  using
       <u>MessageBuffer.from_bytes()</u>, or from a stream using <u>MessageBuffer.read_message()</u>.

       &gt;&gt;&gt; msg.from_bytes(b)
       &gt;&gt;&gt; msg
       &lt;MessageBuffer domain 8304 length 139 (deframed 4 sets)&gt;

       Both of these methods scan the message in advance to find the sets within the message. The records within
       these  sets  can  then  be  accessed  by  iterating  over the message. As with export, the records can be
       accessed as a dictionary mapping IE names to values or as tuples. The dictionary  interface  is  designed
       for general IPFIX processing applications, such as collectors accepting many types of data, or diagnostic
       tools for debugging IPFIX export:

       &gt;&gt;&gt; for rec in msg.namedict_iterator():
       ...    print(sorted(rec.items()))
       ...
       [('destinationIPv4Address', IPv4Address('10.5.6.7')), ('flowStartMilliseconds', datetime.datetime(2013, 6, 21, 14, 0)), ('packetDeltaCount', 27), ('sourceIPv4Address', IPv4Address('10.1.2.3'))]
       [('destinationIPv4Address', IPv4Address('10.12.13.14')), ('flowStartMilliseconds', datetime.datetime(2013, 6, 21, 14, 0, 2)), ('packetDeltaCount', 33), ('sourceIPv4Address', IPv4Address('10.8.9.11'))]
       [('flowStartMilliseconds', datetime.datetime(2013, 6, 21, 14, 0, 4)), ('myNewInformationElement', "Grüezi, Y'all")]

       The  tuple  interface  for  reading  messages  is designed for applications with a specific internal data
       model. It can be much faster than the dictionary interface, as it skips decoding of IEs not requested  by
       the caller, and can skip entire sets not containing all the requested IEs. Requested IEs are specified as
       an <u>ipfix.ie.InformationElementList</u> instance, from <b>ie.spec_list()</b>:

       &gt;&gt;&gt; ielist = ipfix.ie.spec_list(["flowStartMilliseconds", "packetDeltaCount"])
       &gt;&gt;&gt; for rec in msg.tuple_iterator(ielist):
       ...     print(rec)
       ...
       (datetime.datetime(2013, 6, 21, 14, 0), 27)
       (datetime.datetime(2013, 6, 21, 14, 0, 2), 33)

       Notice  that  the  variable-length record written to the message are not returned by this iterator, since
       that record doesn't include a packetDeltaCount IE.  The record is, however, still there:

       &gt;&gt;&gt; ielist = ipfix.ie.spec_list(["myNewInformationElement"])
       &gt;&gt;&gt; for rec in msg.tuple_iterator(ielist):
       ...     print(rec)
       ...
       ("Grüezi, Y'all",)

       <b>exception</b> <b>ipfix.message.EndOfMessage(*args)</b>
              Exception raised when a write operation on a Message fails because there is not  enough  space  in
              the message.

       <b>class</b> <b>ipfix.message.MessageBuffer</b>
              Implements a buffer for reading or writing IPFIX messages.

              <b>active_template_ids()</b>
                     Get  an  iterator  over  all  active template IDs in the current domain.  Provided to allow
                     callers to export some or all active Templates across multiple Messages.

                     <b>Returns</b>
                            a template ID iterator

              <b>add_template(tmpl,</b> <b>export=True)</b>
                     Add a template to this MessageBuffer. Adding a template makes  it  available  for  use  for
                     exporting records; see <u>export_new_set()</u>.

                     <b>Parameters</b>

                            • <b>tmpl</b> -- the template to add

                            • <b>export</b> -- If True, export this template to the MessageBuffer after adding it.

                     <b>Raises</b> EndOfMessage

              <b>begin_export(odid=None)</b>
                     Start  exporting  a  new  message.  Clears any previous message content, but keeps template
                     information intact. Sets the message sequence number.

                     <b>Parameters</b>
                            <b>odid</b> -- Observation domain ID to use for export. By default,  uses  the  observation
                            domain  ID  of  the  previous message. Note that templates are scoped to observation
                            domain, so templates will need to be added after  switching  to  a  new  observation
                            domain ID.

                     <b>Raises</b> IpfixEncodeError

              <b>delete_template(tid,</b> <b>export=True)</b>
                     Delete a template by ID from this MessageBuffer.

                     <b>Parameters</b>

                            • <b>tid</b> -- ID of the template to delete

                            • <b>export</b>  --  if True, export a Template Withdrawal for this Template after deleting
                              it

                     <b>Raises</b> EndOfMessage

              <b>export_ensure_set(setid)</b>
                     Ensure that the current set for export has the given Set ID.  Starts a new set if not using
                     <u>export_new_set()</u>

                     <b>Parameters</b>
                            <b>setid</b> -- Set ID of the new Set; corresponds to the Template ID of the Template  that
                            will  be used to encode records into the Set. The require Template must have already
                            been added to the MessageBuffer, see <u>add_template()</u>.

                     <b>Raises</b> IpfixEncodeError, EndOfMessage

              <b>export_namedict(rec)</b>
                     Export a record to the message, using the template for the current Set ID. The record is  a
                     dictionary  mapping  IE names to values. The dictionary must contain a value for each IE in
                     the template. Keys in the dictionary not in the template will be ignored.

                     <b>Parameters</b>
                            <b>rec</b> -- the record to export, as a dictionary

                     <b>Raises</b> EndOfMessage

              <b>export_needs_flush()</b>
                     True  if  content  has  been  written  to  this  MessageBuffer  since  the  last  call   to
                     <u>begin_export()</u>

              <b>export_new_set(setid)</b>
                     Start  exporting a new Set with the given set ID. Creates a new set even if the current Set
                     has the given set ID; client code should in most cases use <u>export_ensure_set()</u> instead.

                     <b>Parameters</b>
                            <b>setid</b> -- Set ID of the new Set; corresponds to the Template ID of the Template  that
                            will  be used to encode records into the Set. The require Template must have already
                            been added to the MessageBuffer, see <u>add_template()</u>.

                     <b>Raises</b> IpfixEncodeError, EndOfMessage

              <b>export_record(rec,</b> <b>encode_fn=&lt;function</b> <b>Template.encode_namedict_to&gt;,</b> <b>recinf=None)</b>
                     Low-level interface to record export.

                     Export a record to a MessageBuffer, using the template associated with the Set ID given  to
                     the  most  recent  <u>export_new_set()</u>  or  <u>export_ensure_set()</u>  call,  and  the  given encode
                     function. By default, the record is assumed to be a dictionary mapping IE names  to  values
                     (i.e., the same as <u>export_namedict()</u>).

                     <b>Parameters</b>

                            • <b>encode_fn</b>  --  Function  used  to  encode  a record; must be an (unbound) "encode"
                              instance method of the <u>ipfix.template.Template</u> class.

                            • <b>recinf</b> -- Record information opaquely passed to decode function

                     <b>Raises</b> EndOfMessage

              <b>export_template(tid)</b>
                     Export a template to this Message given its template ID.

                     <b>Parameters</b>
                            <b>tid</b> -- ID of template to export; must have been added  to  this  message  previously
                            with <u>add_template()</u>.

                     <b>Raises</b> EndOfMessage, KeyError

              <b>export_tuple(rec)</b>
                     Export  a record to the message, using the template for the current Set ID. The record is a
                     tuple of values in template order.

                     <b>Parameters</b>
                            <b>rec</b> -- the record to export, as a tuple in template order.

                     <b>Raises</b> EndOfMessage

              <b>from_bytes(bytes)</b>
                     Read an IPFIX message from a byte array.

                     This populates message header fields and the internal setlist.  Call for each  new  message
                     before iterating over records when reading from a byte array.

                     <b>Parameters</b>
                            <b>bytes</b> -- a byte array containing a complete IPFIX message.

                     <b>Raises</b> IpfixDecodeError

              <b>get_export_time()</b>
                     Return  the export time of this message. When reading, returns the export time as read from
                     the  message  header.  When  writing,  this  is  the  argument  of   the   last   call   to
                     <u>set_export_time()</u>,  or,  if  :attr:auto_export_time  is  True, the time of the last message
                     export.

                     <b>Returns</b>
                            export time of the last message read/written.

              <b>namedict_iterator()</b>
                     Iterate over all records in the Message, as dicts mapping IE names to values.

                     <b>Returns</b>
                            a name dictionary iterator

              <b>read_message(stream)</b>
                     Read a IPFIX message from a stream.

                     This populates message header fields and the internal setlist.  Call for each  new  message
                     before iterating over records when reading from a stream.

                     <b>Parameters</b>
                            <b>stream</b> -- stream to read from

                     <b>Raises</b> IpfixDecodeError

              <b>record_iterator(decode_fn=&lt;function</b> <b>Template.decode_namedict_from&gt;,</b> <b>tmplaccept_fn=&lt;function</b>
              <b>accept_all_templates&gt;,</b> <b>recinf=None)</b>
                     Low-level interface to record iteration.

                     Iterate   over  records  in  an  IPFIX  message  previously  read  with  <u>read_message()</u>  or
                     <u>from_bytes()</u>. Automatically handles templates in set order. By default, iterates over  each
                     record  in  the  stream  as  a  dictionary  mapping  IE  name  to  value (i.e., the same as
                     <u>namedict_iterator()</u>)

                     <b>Parameters</b>

                            • <b>decode_fn</b> -- Function used to decode a  record;  must  be  an  (unbound)  "decode"
                              instance method of the <u>ipfix.template.Template</u> class.

                            • <b>tmplaccept_fn</b>  --  Function returning True if the given template is of interest to
                              the caller, False if not.   Default  accepts  all  templates.  Sets  described  by
                              templates for which this function returns False will be skipped.

                            • <b>recinf</b> -- Record information opaquely passed to decode function

                     <b>Returns</b>
                            an iterator over records decoded by decode_fn.

              <b>set_export_time(dt=None)</b>
                     Set  the  export  time  for  the  next  message written with <u>write_message()</u> or <u>to_bytes()</u>.
                     Disables automatic export time updates. By default, sets the export  time  to  the  current
                     time.

                     <b>Parameters</b>
                            <b>dt</b> -- export time to set, as a datetime

              <b>template_for_id(tid)</b>
                     Retrieve a Template for a given ID in the current domain.

                     <b>Parameters</b>
                            <b>tid</b> -- template ID to get

                     <b>Returns</b>
                            the template

                     <b>Raises</b> KeyError

              <b>to_bytes()</b>
                     Convert  this MessageBuffer to a byte array, suitable for writing to a binary file, socket,
                     or datagram. Finalizes the message by rewriting the message header with current length, and
                     export time.

                     <b>Returns</b>
                            message as a byte array

              <b>tuple_iterator(ielist)</b>
                     Iterate over all records in the Message containing all the IEs in the given ielist. Records
                     are returned as tuples in ielist order.

                     <b>Parameters</b>
                            <b>ielist</b> -- an instance of <u>ipfix.ie.InformationElementList</u> listing IEs to return as  a
                            tuple

                     <b>Returns</b>
                            a tuple iterator for tuples as in ielist order

              <b>write_message(stream)</b>
                     Convenience method to write a message to a stream; see <u>to_bytes()</u>.

</pre><h4><b>MODULE</b> <b>IPFIX.READER</b></h4><pre>
       Interface to read IPFIX Messages from a stream.

       <b>class</b> <b>ipfix.reader.MessageStreamReader(stream)</b>
              Reads records from a stream of IPFIX messages.

              Uses  an  <u>ipfix.message.MessageBuffer</u>  internally,  and  continually reads messages from the given
              stream into the buffer, iterating over records, until the end of the stream. Use <u>from_stream()</u>  to
              get an instance.

              Suitable  for  reading  from  IPFIX  files  (see <u>RFC</u> <u>5655</u>) as well as from UDP or TCP sockets with
              <b>socketserver.StreamRequestHandler</b>.  When opening a stream from a file, use mode='rb'.

              <b>namedict_iterator()</b>
                     Iterate over all records in the stream, as dicts mapping IE names to values.

                     <b>Returns</b>
                            a name dictionary iterator

              <b>tuple_iterator(ielist)</b>
                     Iterate over all records in the stream containing all the IEs in the given ielist.  Records
                     are returned as tuples in ielist order.

                     <b>Parameters</b>
                            <b>ielist</b>  -- an instance of <u>ipfix.ie.InformationElementList</u> listing IEs to return as a
                            tuple

                     <b>Returns</b>
                            a tuple iterator for tuples in ielist order

       <b>ipfix.reader.from_stream(stream)</b>
              Get a MessageStreamReader for a given stream

              <b>Parameters</b>
                     <b>stream</b> -- stream to read

              <b>Returns</b>
                     a <u>MessageStreamReader</u> wrapped around the stream.

</pre><h4><b>MODULE</b> <b>IPFIX.WRITER</b></h4><pre>
       <b>class</b> <b>ipfix.writer.MessageStreamWriter(stream,</b> <b>mtu=65535)</b>
              Writes records to a stream of IPFIX messages.

              Uses an <u>ipfix.message.MessageBuffer</u> internally, and  continually  writes  records  into  messages,
              exporting  messages  to  the  stream  each  time  the  maximum  message size (MTU) is reached. Use
              <u>to_stream()</u> to get an instance.

              Suitable for writing to IPFIX files (see <u>RFC</u> <u>5655</u>) as well as  to  TCP  sockets.  When  writing  a
              stream to a file, use mode='wb'.

              <b>..warning:</b> <b>This</b> <b>class</b> <b>is</b> <b>not</b> <b>yet</b> <b>suitable</b> <b>for</b> <b>UDP</b> <b>export;</b> <b>this</b> <b>is</b> <b>an</b> <b>open</b>
                     issue to be fixed in a subsequent release.

              <b>add_template(tmpl)</b>
                     Add  a  template to this Writer. Adding a template makes it available for use for exporting
                     records; see <u>set_export_template()</u>.

                     <b>Parameters</b>
                            <b>tmpl</b> -- the template to add

              <b>export_namedict(rec)</b>
                     Export a record to the message, using the current  template  The  record  is  a  dictionary
                     mapping  IE  names  to  values.  The  dictionary  must  contain  a value for each IE in the
                     template. Keys in the dictionary not in the template will be ignored.

                     <b>Parameters</b>
                            <b>rec</b> -- the record to export, as a dictionary

              <b>flush()</b>
                     Export an in-progress Message immediately.

                     Used internally to manage message boundaries, but can  also  be  used  to  force  immediate
                     export  (e.g.  to  reduce  delay  due  to  buffer  dwell  time), as well as to finish write
                     operations on a Writer before closing the underlying stream.

              <b>set_domain(odid)</b>
                     Sets the observation domain for subsequent messages sent with this Writer.

                     <b>Parameters</b>
                            <b>odid</b> -- Observation domain ID to use for export. Note that templates are  scoped  to
                            observation  domain,  so  templates  will  need to be added after switching to a new
                            observation domain ID.

              <b>set_export_template(tid)</b>
                     Set the template to be used  for  export  by  subsequent  calls  to  <u>export_namedict()</u>  and
                     <b>export_tuple()</b>.

                     <b>Parameters</b>
                            <b>tid</b>  --  Template  ID  of  the  Template  that will be used to encode records to the
                            Writer. The corresponding Template must have already been added to the  Writer,  see
                            <u>add_template()</u>.

       <b>ipfix.writer.to_stream(stream,</b> <b>mtu=65535)</b>
              Get a MessageStreamWriter for a given stream

              <b>Parameters</b>

                     • <b>stream</b> -- stream to write

                     • <b>mtu</b>  --  maximum  message  size  in  bytes; defaults to 65535, the largest possible ipfix
                       message.

              <b>Returns</b>
                     a <u>MessageStreamWriter</u> wrapped around the stream.

       • <u>Index</u>

       • <u>Module</u> <u>Index</u>

       • <u>Search</u> <u>Page</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Brian Trammell

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2013-2014, Brian Trammell

0.9                                               Dec 19, 2024                                   <u><a href="../man1/PYTHON-IPFIX.1.html">PYTHON-IPFIX</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>