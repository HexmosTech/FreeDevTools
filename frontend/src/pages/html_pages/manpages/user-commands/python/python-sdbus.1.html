<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>python-sdbus - python-sdbus</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python3-sdbus">python3-sdbus_0.13.0-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       python-sdbus - python-sdbus

       Python-sdbus is the python D-Bus library that aim to use the modern features of python

       • <u>Asyncio</u>

       • <u>Type</u> <u>hints</u>

       • <u>Based</u> <u>on</u> <u>fast</u> <u>sd-bus</u>

       • Unified client/server interface classes. Write interface class once.

       • D-Bus methods can have keyword and default arguments.

</pre><h4><b>D-BUS</b></h4><pre>
       D-Bus is the inter-process communication standard commonly used on Linux desktop.

       This documentation expects you to be familiar with D-Bus concepts and conventions.

       If you are unfamiliar with D-Bus you might want to read following pages:

       <u>Wikipedia</u> <u>page</u>

       <u>Lennart</u> <u>Poettering</u> <u>post</u> <u>about</u> <u>D-Bus</u>

       <u>D-Bus</u> <u>specification</u> <u>by</u> <u>freedesktop.org</u>

       <u>Install</u> <u>D-Spy</u> <u>D-Bus</u> <u>debugger</u> <u>and</u> <u>observe</u> <u>services</u> <u>and</u> <u>objects</u> <u>on</u> <u>your</u> <u>D-Bus</u>

   <b>General</b> <b>Information</b>
   <b>Blocking</b> <b>vs</b> <b>Async</b>
       Python-sdbus supports both blocking and async IO.

       Regular python functions are always blocking.

       Asyncio is a part of python standard library that allows non-blocking io.

       <u>Asyncio</u> <u>documentation</u>

       Generally  blocking  IO  should  only be used for simple scripts and programs that interact with existing
       D-Bus objects.

   <b>Blocking:</b>
       • Blocking is easier to initiate (no event loop)

       • Properties behave exactly as Python properties do. (i.e. can assign with '=' operator)

       • Only allows one request at a time.

       • No D-Bus signals.

       • Cannot serve objects, only interact with existing object on D-Bus.

       <u>Blocking</u> <u>quick</u> <u>start</u>

       <u>Blocking</u> <u>API</u>

   <b>Asyncio:</b>
       • Calls need to be <b>await</b> ed.

       • Multiple requests at the same time.

       • Serve object on D-Bus for other programs.

       • D-Bus Signals.

       <u>Asyncio</u> <u>quick</u> <u>start</u>

       <u>Asyncio</u> <u>API</u>

   <b>D-Bus</b> <b>types</b> <b>conversion</b>
       <u>D-Bus</u> <u>types</u> <u>reference</u>

       <b>NOTE:</b>
          Python integers are unlimited size but D-Bus integers are not.  All integer types raise  <b>OverflowError</b>
          if you try to pass number outside the type size.

          Unsigned integers range is <b>0</b> <b>&lt;</b> <b>(2**bit_size)-1</b>.

          Signed integers range is <b>-(2**(bit_size-1))</b> <b>&lt;</b> <b>(2**(bit_size-1))-1</b>.
                         ┌─────────────┬────────────┬─────────────┬────────────────────────┐
                         │ Name        │ D-Bus type │ Python type │ Description            │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Boolean     │ b          │ <b>bool</b>        │ <b>True</b> or <b>False</b>          │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Byte        │ y          │ <b>int</b>         │ Unsigned         8-bit │
                         │             │            │             │ integer.  <b>Note:</b>  array │
                         │             │            │             │ of   bytes   (<u>ay</u>)  has │
                         │             │            │             │ different   type    in │
                         │             │            │             │ python domain.         │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Int16       │ n          │ <b>int</b>         │ Signed 16-bit integer. │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Uint16      │ q          │ <b>int</b>         │ Unsigned        16-bit │
                         │             │            │             │ integer.               │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Int32       │ i          │ <b>int</b>         │ Signed 32-bit integer. │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Uint32      │ u          │ <b>int</b>         │ Unsigned        32-bit │
                         │             │            │             │ integer.               │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Int64       │ x          │ <b>int</b>         │ Signed 64-bit integer. │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Uint64      │ t          │ <b>int</b>         │ Unsigned        64-bit │
                         │             │            │             │ integer.               │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Double      │ d          │ <b>float</b>       │ Float point number     │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Unix FD     │ h          │ <b>int</b>         │ File descriptor        │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ String      │ s          │ <b>str</b>         │ String                 │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Object Path │ o          │ <b>str</b>         │ Syntactically  correct │
                         │             │            │             │ D-Bus object path      │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Signature   │ g          │ <b>str</b>         │ D-Bus type signature   │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Array       │ a          │ <b>list</b>        │ List  of  some  single │
                         │             │            │             │ type.                  │
                         │             │            │             │                        │
                         │             │            │             │ Example: <b>as</b>  array  of │
                         │             │            │             │ strings                │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Byte Array  │ ay         │ <b>bytes</b>       │ Array  of bytes. Not a │
                         │             │            │             │ unique type  in  D-Bus │
                         │             │            │             │ but  a  different type │
                         │             │            │             │ in   Python.   Accepts │
                         │             │            │             │ both     <b>bytes</b>     and │
                         │             │            │             │ <b>bytearray</b>.   Used  for │
                         │             │            │             │ binary data.           │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Struct      │ ()         │ <b>tuple</b>       │ Tuple.                 │
                         │             │            │             │                        │
                         │             │            │             │ Example:  <b>(isax)</b> tuple │
                         │             │            │             │ of  int,  string   and │
                         │             │            │             │ array of int.          │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Dictionary  │ a{}        │ <b>dict</b>        │ Dictionary   with  key │
                         │             │            │             │ type and value type.   │
                         │             │            │             │                        │
                         │             │            │             │ <b>Note:</b>  Dictionary   is │
                         │             │            │             │ always   a   part   of │
                         │             │            │             │ array.  I.E. <b>a{si}</b>  is │
                         │             │            │             │ the  dict  with string │
                         │             │            │             │ keys    and    integer │
                         │             │            │             │ values.  <b>{si}</b> is NOT a │
                         │             │            │             │ valid signature.       │
                         ├─────────────┼────────────┼─────────────┼────────────────────────┤
                         │ Variant     │ v          │ <b>tuple</b>       │ Unknown  type that can │
                         │             │            │             │ be  any  single  type. │
                         │             │            │             │ In  Python represented │
                         │             │            │             │ by  a   tuple   of   a │
                         │             │            │             │ signature string and a │
                         │             │            │             │ single type.           │
                         │             │            │             │                        │
                         │             │            │             │ Example: <b>("s",</b> <b>"test")</b> │
                         │             │            │             │ variant  of  a  single │
                         │             │            │             │ string                 │
                         └─────────────┴────────────┴─────────────┴────────────────────────┘

   <b>Name</b> <b>conversions</b>
       D-Bus uses CamelCase for method names.

       Python uses snake_case.

       When decorating a method name will be automatically translated from  snake_case  to  CamelCase.  Example:
       <b>close_notification</b> -&gt; <b>CloseNotification</b>

       However,  all decorators have a parameter to force D-Bus name to a specific value.  See API documentation
       for a particular decorator.

   <b>Default</b> <b>bus</b>
       Most object methods that take a bus as a parameter will use a thread-local default bus  connection  if  a
       bus object is not explicitly passed.

       Session bus is default bus when running as a user and system bus otherwise.

       <u>request_default_bus_name_async()</u> can be used to acquire a service name on default bus.

       Use <u>sd_bus_open_user()</u> and <u>sd_bus_open_system()</u> to acquire a specific bus connection.

       Set  the  default  connection  to  a  new default with <u>set_default_bus()</u>.  This should be done before any
       object that take bus as an init argument are created.

       In the future there will be a better way to create and acquire new bus connections.

   <b>Glossary</b>
       • <b>Bus</b> object representing connection to D-Bus.

       •

         <b>Proxy</b> Python object that represents an object on D-Bus.
                Without proxy you manipulate messages directly.

       • <b>Remote</b> something that exists outside current Python process.

       • <b>Local</b> something that exists inside current Python scope.

       •

         <b>Service</b> <b>Name</b> a well known name that an process can acquire on D-Bus.
                For example, systemd acquires <b>org.freedesktop.systemd1</b> name.

       • <b>Signature</b> D-Bus type definition. Represented by a string. See <u>D-Bus</u> <u>types</u> <u>conversion</u>.

   <b>Contents</b>
       • <u>Index</u>

       • <u>API</u> <u>Index</u>

       • <u>Search</u> <u>Page</u>

   <b>Common</b> <b>API</b>
       These calls are shared between async and blocking API.

   <b>D-Bus</b> <b>connections</b> <b>calls</b>
       <b>async</b> <b>sdbus.request_default_bus_name_async(new_name,</b> <b>allow_replacement,</b> <b>replace_existing,</b> <b>queue)</b>
              Acquire a name on the default bus async.

              <b>Parameters</b>

                     • <b>new_name</b> (<u>str</u>) -- the name to acquire.  Must be a valid D-Bus service name.

                     • <b>new_name</b> -- the name to acquire.  Must be a valid D-Bus service name.

                     • <b>allow_replacement</b> (<u>bool</u>) -- If name was acquired allow other peers to take away the name.

                     • <b>replace_existing</b> (<u>bool</u>) -- If current name owner allows, take away the name.

                     • <b>queue</b> (<u>bool</u>) -- Queue up for  name  acquisition.   <u>SdBusRequestNameInQueueError</u>  will  be
                       raised when successfully placed in queue. <u>Ownership</u> <u>change</u> <u>signal</u> should be monitored get
                       notified when the name was acquired.

              <b>Raises</b> <u>Name</u> <u>request</u> <u>exceptions</u> and other D-Bus exceptions.

       <b>sdbus.request_default_bus_name(new_name,</b> <b>allow_replacement,</b> <b>replace_existing,</b> <b>queue)</b>
              Acquire a name on the default bus.

              <b>Parameters</b>

                     • <b>new_name</b> (<u>str</u>) -- the name to acquire.  Must be a valid D-Bus service name.

                     • <b>allow_replacement</b> (<u>bool</u>) -- If name was acquired allow other peers to take away the name.

                     • <b>replace_existing</b> (<u>bool</u>) -- If current name owner allows, take away the name.

                     • <b>queue</b>  (<u>bool</u>)  --  Queue  up  for name acquisition.  <u>SdBusRequestNameInQueueError</u> will be
                       raised when successfully placed in queue. <u>Ownership</u> <u>change</u> <u>signal</u> should be monitored get
                       notified when the name was acquired.

              <b>Raises</b> <u>Name</u> <u>request</u> <u>exceptions</u> and other D-Bus exceptions.

       <b>sdbus.set_default_bus(new_default)</b>
              Sets default bus.

              Should be called before you create any objects that might use default bus.

              Default bus can be replaced but the change will only affect newly created objects.

              <b>Parameters</b>
                     <b>new_default</b> (<u>SdBus</u>) -- The bus object to set default to.

       <b>sdbus.get_default_bus(new_default)</b>
              Gets default bus.

              <b>Returns</b>
                     default bus

              <b>Return</b> <b>type</b>
                     SdBus

       <b>sdbus.sd_bus_open_user()</b>
              Opens a new user session bus connection.

              <b>Returns</b>
                     session bus

              <b>Return</b> <b>type</b>
                     SdBus

       <b>sdbus.sd_bus_open_system()</b>
              Opens a new system bus connection.

              <b>Returns</b>
                     system bus

              <b>Return</b> <b>type</b>
                     SdBus

       <b>sdbus.sd_bus_open_system_remote(host)</b>
              Opens a new system bus connection on a  remote  host  through  SSH.  Host  can  be  prefixed  with
              <b>username@</b> and followed by <b>:port</b> and <b>/machine_name</b> as in <b>systemd-nspawn</b> container name.

              <b>Parameters</b>
                     <b>host</b> (<u>str</u>) -- Host name to connect.

              <b>Returns</b>
                     Remote system bus

              <b>Return</b> <b>type</b>
                     SdBus

       <b><a href="../manmachine/sdbus.sd_bus_open_system_machine.machine.html">sdbus.sd_bus_open_system_machine</a>(machine)</b>
              Opens a new system bus connection in a systemd-nspawn container. Machine name can be prefixed with
              <b>username@</b>.  Special machine name <b>.host</b> indicates local system.

              <b>Parameters</b>
                     <b>machine</b> (<u>str</u>) -- Machine (container) name.

              <b>Returns</b>
                     Remote system bus

              <b>Return</b> <b>type</b>
                     SdBus

       <b><a href="../manmachine/sdbus.sd_bus_open_user_machine.machine.html">sdbus.sd_bus_open_user_machine</a>(machine)</b>
              Opens a new user session bus connection in a systemd-nspawn container. Opens root user bus session
              or can be prefixed with <b>username@</b> for a specific user.

              <b>Parameters</b>
                     <b>machine</b> (<u>str</u>) -- Machine (container) name.

              <b>Returns</b>
                     Remote system bus

              <b>Return</b> <b>type</b>
                     SdBus

   <b>Helper</b> <b>functions</b>
       <b>sdbus.encode_object_path(prefix,</b> <b>external)</b>
              Encode that arbitrary string as a valid object path prefixed with prefix.

              <b>Parameters</b>

                     • <b>prefix</b> (<u>str</u>) -- Prefix path. Must be a valid object path.

                     • <b>external</b> (<u>str</u>) -- Arbitrary string to identify object.

              <b>Returns</b>
                     valid object path

              <b>Return</b> <b>type</b>
                     str

              Example on how systemd encodes unit names on D-Bus:

                 from sdbus import encode_object_path

                 # System uses /org/freedesktop/systemd1/unit as prefix of all units
                 # dbus.service is a name of D-Bus unit but dot . is not a valid object path
                 s = encode_object_path('/org/freedesktop/systemd1/unit', 'dbus.service')
                 print(s)
                 # Prints: /org/freedesktop/systemd1/unit/dbus_2eservice

       <b>sdbus.decode_object_path(prefix,</b> <b>full_path)</b>
              Decode object name that was encoded with <u>encode_object_path()</u>.

              <b>Parameters</b>

                     • <b>prefix</b> (<u>str</u>) -- Prefix path. Must be a valid object path.

                     • <b>full_path</b> (<u>str</u>) -- Full path to be decoded.

              <b>Returns</b>
                     Arbitrary name

              <b>Return</b> <b>type</b>
                     str

              Example decoding systemd unit name:

                 from sdbus import decode_object_path

                 s = decode_object_path(
                     '/org/freedesktop/systemd1/unit',
                     '/org/freedesktop/systemd1/unit/dbus_2eservice'
                 )
                 print(s)
                 # Prints: dbus.service

   <b>Flags</b>
       Flags are <b>int</b> values that should be ORed to combine.

       Example, <u>DbusDeprecatedFlag</u> plus <u>DbusHiddenFlag</u>: <b>DbusDeprecatedFlag</b> <b>|</b> <b>DbusHiddenFlag</b>

       <b>sdbus.DbusDeprecatedFlag:</b> <b>int</b>
              Mark this method or property as deprecated in introspection data.

       <b>sdbus.DbusHiddenFlag:</b> <b>int</b>
              Method or property will not show up in introspection data.

       <b>sdbus.DbusUnprivilegedFlag:</b> <b>int</b>
              Mark this method or property as unprivileged. This means anyone can call it. Only works for system
              bus as user session bus is fully trusted by default.

       <b>sdbus.DbusNoReplyFlag:</b> <b>int</b>
              This method does not have a reply message. It instantly returns and does not have any errors.

       <b>sdbus.DbusPropertyConstFlag:</b> <b>int</b>
              Mark that this property does not change during object life time.

       <b>sdbus.DbusPropertyEmitsChangeFlag:</b> <b>int</b>
              This property emits signal when it changes.

       <b>sdbus.DbusPropertyEmitsInvalidationFlag:</b> <b>int</b>
              This  property emits signal when it invalidates. (means the value changed but does not include new
              value in the signal)

       <b>sdbus.DbusPropertyExplicitFlag:</b> <b>int</b>
              This property is too heavy to calculate so its not included in GetAll method call.

       <b>sdbus.DbusSensitiveFlag:</b> <b>int</b>
              Data in messages in sensitive and will be scrubbed from memory after message is red.

   <b>Blocking</b> <b>quick</b> <b>start</b>
   <b>Interface</b> <b>classes</b>
       Python-sdbus works by declaring interface classes.

       Interface classes for blocking IO should be derived from <u>DbusInterfaceCommon</u>.

       The class constructor takes <b>interface_name</b> keyword to determine the D-Bus interface name  for  all  D-Bus
       elements declared in the class body.

       Example:

          class ExampleInterface(DbusInterfaceCommon,
                                 interface_name='org.example.myinterface'
                                 ):
              ...

       Interface  class  body  should  contain  the  definitions  of methods and properties using the decorators
       <u>dbus_method()</u> and <u>dbus_property()</u> respectively.

       Example:

          from sdbus import (DbusInterfaceCommon,
                             dbus_method, dbus_property)

          class ExampleInterface(DbusInterfaceCommon,
                                 interface_name='org.example.myinterface'
                                 ):
              # Method that takes an integer and does not return anything
              @dbus_method('u')
              def close_notification(self, an_int: int) -&gt; None:
                  raise NotImplementedError

              # Read only property of int
              @dbus_property()
              def test_int(self) -&gt; int:
                  raise NotImplementedError

       This is an interface of that defines a one D-Bus method and one property.

       The actual body of the decorated function will not be called. Instead the call  will  be  routed  through
       D-Bus to a another process. Interface can have non-decorated functions that will act as regular methods.

       Blocking  IO  can  only interact with existing D-Bus objects and can not be served for other processes to
       interact with. See <u>Blocking</u> <u>vs</u> <u>Async</u>

   <b>Initiating</b> <b>proxy</b>
       <u>DbusInterfaceCommon.</u><b>__</b><u>init</u><b>__</b><u>()</u> method takes service_name and object_path of the remote  object  that  the
       object will proxy to.

       Example creating a proxy and calling method:

          ...
          # Initialize the object
          d = ExampleInterface(
              service_name='org.example.test',
              object_path='/',
          )

          <a href="../man1234/d.close_notification.1234.html">d.close_notification</a>(1234)

       <b>NOTE:</b>
          Successfully initiating a proxy object does NOT guarantee that the D-Bus object exists.

   <b>Methods</b>
       Methods are functions wrapped with <u>dbus_method()</u> decorator.

       If  the  remote object sends an error reply an exception with base of <u>DbusFailedError</u> will be raised. See
       <u>Exceptions</u> for list of exceptions.

       The  wrapped  function  will  not  be  called.  Its  recommended   to   set   the   function   to   <b>raise</b>
       <b>NotImplementedError</b>.

       Example:

          from sdbus import DbusInterfaceCommon, dbus_method

          class ExampleInterface(...):

              ...
              # Body of some class

              @dbus_method('u')
              def close_notification(self, an_int: int) -&gt; None:
                  raise NotImplementedError

   <b>Properties</b>
       D-Bus property is defined by wrapping a function with <u>dbus_property()</u> decorator.

       Example:

          from sdbus import DbusInterfaceCommon, dbus_property

          class ExampleInterface(...):

              ...
              # Body of some class

              # Property of str
              @dbus_property('s')
              def test_string(self) -&gt; str:
                  raise NotImplementedError

       The new property behaves very similar to Pythons <b>property()</b> decorator.

          # Initialize the proxy
          d = ExampleInterface(
              service_name='org.example.test',
              object_path='/',
          )

          # Print it
          print(d.test_string)

          # Assign new string
          d.test_string = 'some_string'

       If property is read-only when <u>DbusPropertyReadOnlyError</u> will be raised.

   <b>Multiple</b> <b>interfaces</b>
       A D-Bus object can have multiple interfaces with different methods and properties.

       To  implement  this define multiple interface classes and do a multiple inheritance on all interfaces the
       object has.

       Example:

          from sdbus import DbusInterfaceCommon, dbus_method

          class ExampleInterface(DbusInterfaceCommon,
                                 interface_name='org.example.myinterface'
                                 ):

              @dbus_method('i')
              def example_method(self, an_int: int) -&gt; None:
                  raise NotImplementedError

          class TestInterface(DbusInterfaceCommon,
                              interface_name='org.example.test'
                              ):

              @dbus_method('as')
              def test_method(self, str_array: List[str]) -&gt; None:
                  raise NotImplementedError

          class MultipleInterfaces(TestInterface, ExampleInterface):
              ...

       <b>MultipleInterfaces</b> class will have both <b>test_method</b> and <b>example_method</b> that will be  proxied  to  correct
       interface names. (<b>org.example.myinterface</b> and <b>org.example.test</b> respectively)

   <b>Blocking</b> <b>API</b>
   <b>Classes</b>
       <b>class</b> <b>sdbus.DbusInterfaceCommon(interface_name)</b>
              D-Bus  interface  class.  D-Bus methods and properties should be defined using <u>dbus_property()</u> and
              <u>dbus_method()</u> decorators.

              <b>Parameters</b>
                     <b>interface_name</b> (<u>str</u>) -- Sets the D-Bus interface name that will be used for all  properties
                     and methods defined in the body of the class

              <b>__init__(service_name,</b> <b>object_path[,</b> <b>bus])</b>
                     Init will create a proxy to a remote object

                     <b>Parameters</b>

                            • <b>service_name</b>  (<u>str</u>)  -- Remote object D-Bus connection name.  For example, systemd
                              uses <b>org.freedesktop.systemd1</b>

                            • <b>object_path</b> (<u>str</u>) --  Remote  object  D-Bus  path.   Should  be  a  forward  slash
                              separated     path.      Starting     object     is     usually    <b>/</b>.     Example:
                              <b>/org/freedesktop/systemd/unit/dbus_2eservice</b>

                            • <b>bus</b> (<u>SdBus</u>) -- Optional D-Bus connection object.  If not passed the default  D-Bus
                              will be used.

              <b>dbus_ping()</b>
                     Pings the remote service using D-Bus.

                     Useful to test if connection or remote service is alive.

                     <b>WARNING:</b>
                        This  method is ignores the particular object path meaning it can NOT be used to test if
                        object exist.

              <b>dbus_machine_id()</b>
                     Returns the machine UUID of D-Bus the object is connected to.

                     <b>Returns</b>
                            machine UUID

                     <b>Return</b> <b>type</b>
                            str

              <b>dbus_introspect()</b>
                     Get D-Bus introspection XML.

                     It is users responsibility to parse that data.

                     <b>Returns</b>
                            string with introspection XML

                     <b>Return</b> <b>type</b>
                            str

              <b>properties_get_all_dict()</b>
                     Get all object properties as a dictionary where  keys  are  member  names  and  values  are
                     properties values.

                     Equivalent to <b>GetAll</b> method of the <b>org.freedesktop.DBus.Properties</b> interface but the member
                     names are automatically translated to python names. (internally calls it for each interface
                     used in class definition)

                     <b>Parameters</b>
                            <b>on_unknown_member</b> (<u>str</u>) -- If an unknown D-Bus property was encountered either raise
                            an  <b>"error"</b>  (default),  <b>"ignore"</b>  the  property  or  <b>"reuse"</b> the D-Bus name for the
                            member.

                     <b>Returns</b>
                            dictionary of properties

                     <b>Return</b> <b>type</b>
                            Dict[str, Any]

              Example:

                 from sdbus import (DbusInterfaceCommon,
                                    dbus_method, dbus_property)

                 class ExampleInterface(DbusInterfaceCommon,
                                        interface_name='org.example.my'
                                        ):

                     # Method that takes an integer and does not return anything
                     @dbus_method('u')
                     def close_notification(self, an_int: int) -&gt; None:
                         raise NotImplementedError

                     # Method that does not take any arguments and returns a list of str
                     @dbus_method()
                     def get_capabilities(self) -&gt; List[str]:
                         raise NotImplementedError

                     # Method that takes a dict of {str: str} and returns an int
                     @dbus_method('a{ss}')
                     def count_entries(self, a_dict: Dict[str, str]) -&gt; int:
                         raise NotImplementedError

                     # Read only property of int
                     @dbus_property()
                     def test_int(self) -&gt; int:
                         raise NotImplementedError

                     # Read/Write property of str
                     @dbus_property('s')
                     def test_string(self) -&gt; str:
                         raise NotImplementedError

       <b>class</b> <b>sdbus.DbusObjectManagerInterface(interface_name)</b>
              This class is almost identical to <u>DbusInterfaceCommon</u> but implements <u>ObjectManager</u> interface.

              <b>get_managed_objects()</b>
                     Get the objects this object manager in managing.

                     <b>Returns</b>
                            Triple nested dictionary that contains all the objects paths with  their  properties
                            values.

                            Dict[ObjectPath, Dict[InterfaceName, Dict[PropertyName, PropertyValue]]]

                     <b>Return</b> <b>type</b>
                            Dict[str, Dict[str, Dict[str, Any]]]

   <b>Decorators</b>
       <b>@sdbus.dbus_method([input_signature[,</b> <b>flags[,</b> <b>method_name]]])</b>
              Define D-Bus method

              Decorated  function  becomes  linked  to D-Bus method.  Always use round brackets () even when not
              passing any arguments.

              <b>Parameters</b>

                     • <b>input_signature</b> (<u>str</u>) -- D-Bus input signature.  Defaults to "" meaning method  takes  no
                       arguments.  Required if method takes any arguments.

                     • <b>flags</b> (<u>int</u>) --

                       modifies  behavior.   No  effect on remote connections.  Defaults to 0 meaning no special
                       behavior.

                       See <u>Flags</u> .

                     • <b>method_name</b> (<u>str</u>) -- Explicitly define remote  method  name.   Usually  not  required  as
                       remote method name will be constructed based on original method name.

              Defining methods example:

                 from sdbus import DbusInterfaceCommon, dbus_method

                 class ExampleInterface(DbusInterfaceCommon,
                                        interface_name='org.example.my'
                                        ):

                     # Method that takes an integer and does not return anything
                     @dbus_method('u')
                     def close_notification(self, an_int: int) -&gt; None:
                         raise NotImplementedError

                     # Method that does not take any arguments and returns a list of str
                     @dbus_method()
                     def get_capabilities(self) -&gt; List[str]:
                         raise NotImplementedError

                     # Method that takes a dict of {str: str} and returns an int
                     @dbus_method('a{ss}')
                     def count_entries(self, a_dict: Dict[str, str]) -&gt; int:
                         raise NotImplementedError

              Calling methods example:

                 # Initialize the object
                 d = ExampleInterface(
                     service_name='org.example.test',
                     object_path='/',
                 )

                 <a href="../man1234/d.close_notification.1234.html">d.close_notification</a>(1234)

                 l = d.get_capabilities()

                 d.count_entries({'a': 'asdasdasd', 'b': 'hgterghead213d'})

       <b>@sdbus.dbus_property([property_signature[,</b> <b>flags[,</b> <b>property_name]]])</b>
              Define D-Bus property

              Property  works  just  like @property decorator would.  Always use round brackets () even when not
              passing any arguments.

              Read only property can be indicated by passing empty D-Bus signature "".

              Trying to assign a read only property will raise <b>AttributeError</b>

              <b>Parameters</b>

                     • <b>property_signature</b> (<u>str</u>) -- D-Bus  property  signature.   Empty  signature  ""  indicates
                       read-only  property.   Defaults  to  empty  signature  "".   Required  only  for writable
                       properties.

                     • <b>flags</b> (<u>int</u>) --

                       modifies behavior.  No effect on remote connections.  Defaults to 0  meaning  no  special
                       behavior.

                       See <u>Flags</u> .

                     • <b>property_name</b>  (<u>str</u>)  -- Explicitly define remote property name.  Usually not required as
                       remote property name will be constructed based on original method name.

              Defining properties example:

                 from sdbus import DbusInterfaceCommon, dbus_property

                 class ExampleInterface(DbusInterfaceCommon,
                                        interface_name='org.example.myproperty'
                                        ):

                     # Property of int
                     @dbus_property('i')
                     def test_int(self) -&gt; int:
                         raise NotImplementedError

                     # Property of str
                     @dbus_property('s')
                     def test_string(self) -&gt; str:
                         raise NotImplementedError

              Properties usage example:

                 # Initialize the object
                 d = ExampleInterface(
                     service_name='org.example.test',
                     object_path='/',
                 )

                 # Print the int
                 print(d.test_int)

                 # Assign new string
                 d.test_string = 'some_string'

                 # Print it
                 print(d.test_string)

       • <u>Index</u>

       • <u>Module</u> <u>Index</u>

       • <u>Search</u> <u>Page</u>

   <b>Asyncio</b> <b>quick</b> <b>start</b>
   <b>Interface</b> <b>classes</b>
       Python-sdbus works by declaring interface classes.

       Interface classes for async IO should be derived from <u>DbusInterfaceCommonAsync</u>.

       The class constructor takes <b>interface_name</b> keyword to determine the D-Bus interface name  for  all  D-Bus
       elements declared in the class body.

       Example:

          from sdbus import DbusInterfaceCommonAsync

          class ExampleInterface(DbusInterfaceCommonAsync,
                                 interface_name='org.example.myinterface'
                                 ):
              ...

       Interface  class  body should contain the definitions of methods, properties and signals using decorators
       such as <u>dbus_method_async()</u>, <u>dbus_property_async()</u> and <u>dbus_signal_async()</u>.

       Example:

          from sdbus import (DbusInterfaceCommonAsync, dbus_method_async,
                             dbus_property_async, dbus_signal_async)

          class ExampleInterface(DbusInterfaceCommonAsync,
                                 interface_name='org.example.myinterface'
                                 ):
              # Method that takes an integer and multiplies it by 2
              @dbus_method_async('i', 'i')
              async def double_int(self, an_int: int) -&gt; None:
                  return an_int * 2

              # Read only property of str
              @dbus_property_async('s')
              def read_string(self) -&gt; int:
                  return 'Test'

              # Signal with a list of strings
              @dbus_signal_async('as')
              def str_signal(self) -&gt; List[str]:
                  raise NotImplementedError

   <b>Initiating</b> <b>proxy</b>
       <u>DbusInterfaceCommonAsync</u> provides two methods for proxying remote objects.

       <u>DbusInterfaceCommonAsync.new_proxy()</u> class method bypasses the class <b>__init__</b> and returns proxy object.

       <u>DbusInterfaceCommonAsync._proxify()</u> should be used inside the <b>__init__</b> methods if your class is  a  proxy
       only.

       Recommended to create proxy classes that a subclass of the interface:

          from sdbus import DbusInterfaceCommonAsync

          class ExampleInterface(...):
              # Some interface class
              ...

          class ExampleClient(ExampleInterface):
              def __init__(self) -&gt; None:
                  # Your client init can proxy to any object based on passed arguments.
                  self._proxify('org.example.test', '/')

       <b>NOTE:</b>
          Successfully initiating a proxy object does NOT guarantee that the D-Bus object exists.

   <b>Serving</b> <b>objects</b>
       <u>DbusInterfaceCommonAsync.export_to_dbus()</u>  method  will  export the object to the D-Bus. After calling it
       the object becomes visible on D-Bus for other processes to call.

       Example using ExampleInterface from before:

          from sdbus import request_default_bus_name_async

          loop = get_event_loop()

          i = ExampleInterface()

          async def start() -&gt; None:
              # Acquire a name on the bus
              await request_default_bus_name_async('org.example.test')
              # Start serving at / path
              i.export_to_dbus('/')

          loop.run_until_complete(start())
          loop.run_forever()

   <b>Connection</b> <b>transparency</b>
       The interface objects are designed to be transparent to their connection status. This means if the object
       not proxied to remote the calls to decorated methods will still work in the local scope.

       This is the call to local object:

          i = ExampleInterface()

          async def test() -&gt; None:
              print(await <a href="../man5/i.double_int.5.html">i.double_int</a>(5))  # Will print 10

       This is a call to remote object at <b>'org.example.test'</b> service name and <b>'/'</b> path:

          i = ExampleInterface.new_proxy('org.example.test', '/')

          async def test() -&gt; None:
              print(await <a href="../man5/i.double_int.5.html">i.double_int</a>(5))  # Will print 10

   <b>Methods</b>
       Methods are async function calls wrapped with <u>dbus_method_async()</u> decorator. (see the API  reference  for
       decorator parameters)

       Methods have to be async function, otherwise <b>AssertionError</b> will be raised.

       While method calls are async there is a inherit timeout timer for any method call.

       To  return  an  error to caller you need to raise exception which has a <u>DbusFailedError</u> as base.  Regular
       exceptions will not propagate.

       See <u>Exceptions</u>.

       Example:

          from sdbus import DbusInterfaceCommonAsync, dbus_method_async

          class ExampleInterface(...):

              ...
              # Body of some class

              # Method that takes a string
              # and returns uppercase of that string
              @dbus_method_async(
                  input_signature='s',
                  result_signature='s',
                  result_args_names=('uppercased', )  # This is optional but
                                                      # makes arguments have names in
                                                      # introspection data.
              )
              async def upper(self, str_to_up: str) -&gt; str:
                  return str_to_up.upper()

       Methods behave exact same way as Python methods would:

          print(await example_object.upper('test'))  # prints TEST

   <b>Properties</b>
       Properties are a single value that can be read and write.

       To declare a read only property you need  to  decorate  a  regular  function  with  <u>dbus_property_async()</u>
       decorator.

       Example:

          from sdbus import DbusInterfaceCommonAsync, dbus_property_async

          class ExampleInterface(...):

              ...
              # Body of some class

              # Read only property. No setter defined.
              @dbus_property_async('i')
              def read_only_number(self) -&gt; int:
                  return 10

       To  create  a  read/write  property you need to decorate the setter function with the <b>setter</b> attribute of
       your getter function.

       Example:

          from sdbus import DbusInterfaceCommonAsync, dbus_property_async

          class ExampleInterface(...):

              ...
              # Body of some class

              # Read/write property. First define getter.
              @dbus_property_async('s')
              def read_write_str(self) -&gt; str:
                  return self.s

              # Now create setter. Method name does not matter.
              @read_write_str.setter  # Use the property setter method as decorator
              def read_write_str_setter(self, new_str: str) -&gt; None:
                  self.s = new_str

       Properties are supposed to be lightweight. Make sure you don't block event loop with getter or setter.

       Async properties do not behave the same way as <b>property()</b> decorator does.

       To get the value of the property you can either directly <b>await</b> on property  or  use  <b>get_async()</b>  method.
       (also need to be awaited)

       To set property use <b>set_async()</b> method.

       Example:

          ...
          # Somewhere in async function
          # Assume we have example_object of class defined above
          print(await example_object.read_write_str)  # Print the value of read_write_str

          ...
          # Set read_write_str to new value
          await example_object.read_write_str.set_async('test')

   <b>Signals</b>
       To define a D-Bus signal wrap a function with <u>dbus_signal_async()</u> decorator.

       The   function  is  only  used  for  type  hints  information.  It  is  recommended  to  just  put  <b>raise</b>
       <b>NotImplementedError</b> in to the body of the function.

       Example:

          from sdbus import DbusInterfaceCommonAsync, dbus_signal_async

          class ExampleInterface(...):

                  ...
                  # Body of some class
                  @dbus_signal_async('s')
                  def name_changed(self) -&gt; str:
                      raise NotImplementedError

       To catch a signal use <b>async</b> <b>for</b> loop:

          async for x in example_object.name_changed:
              print(x)

       <b>WARNING:</b>
          If you are creating an asyncio task to listen on signals make sure to bind it to a variable  and  keep
          it referenced otherwise garbage collector will destroy your task.

       A signal can be emitted with <u>emit</u> method.

       Example:

          example_object.name_changed.emit('test')

       Signals  can  also  be caught from multiple D-Bus objects using <u>catch_anywhere</u> method. The async iterator
       will yield the path of the object that emitted the signal and the signal data.

       <u>catch_anywhere</u> can be called from class but in such case the service name must be provided.

       Example:

          async for path, x in ExampleInterface.name_changed.catch_anywhere('org.example.test'):
              print(f"On {path} caught: {x}")

   <b>Subclass</b> <b>Overrides</b>
       If you define a  subclass  which  overrides  a  declared  D-Bus  method  or  property  you  need  to  use
       <u>dbus_method_async_override()</u>  and  <u>dbus_property_async_override()</u>  decorators.  Overridden  property  can
       decorate a new setter.

       Overridden methods should take same number and type of arguments.

       Example:

          from sdbus import (dbus_method_async_override,
                             dbus_property_async_override)

          # Some subclass
          class SubclassInterface(...):

              ...
              @dbus_method_async_override()
              async def upper(self, str_to_up: str) -&gt; str:
                  return 'Upper: ' + str_to_up.upper()

              @dbus_property_async_override()
              def str_prop(self) -&gt; str:
                  return 'Test property' + self.s

              # Setter needs to be decorated again to override
              @str_prop.setter
              def str_prop_setter(self, new_s: str) -&gt; None:
                  self.s = new_s.upper()

   <b>Multiple</b> <b>interfaces</b>
       A D-Bus object can have multiple interfaces with different methods and properties.

       To implement this define multiple interface classes and do a multiple inheritance on all  interfaces  the
       object has.

       Example:

          from sdbus import DbusInterfaceCommonAsync

          class ExampleInterface(DbusInterfaceCommonAsync,
                                 interface_name='org.example.myinterface'
                                 ):

              @dbus_method_async('i', 'i')
              async def double_int(self, an_int: int) -&gt; None:
                  return an_int * 2

          class TestInterface(DbusInterfaceCommonAsync,
                              interface_name='org.example.test'
                              ):

              @dbus_method_async('as', 's')
              async def join_str(self, str_array: List[str]) -&gt; str:
                  return ''.join(str_array)

          class MultipleInterfaces(TestInterface, ExampleInterface):
              ...

       <b>MultipleInterfaces</b>  class  will  have  both  <b>test_method</b> and <b>example_method</b> that will be wired to correct
       interface names. (<b>org.example.myinterface</b> and <b>org.example.test</b> respectively)

   <b>Asyncio</b> <b>API</b>
   <b>Classes</b>
       <b>class</b> <b>sdbus.DbusInterfaceCommonAsync(interface_name)</b>
              D-Bus  async  interface  class.   D-Bus  methods  and   properties   should   be   defined   using
              <u>dbus_property_async()</u>, <u>dbus_signal_async()</u>, and <u>dbus_method_async()</u> decorators.

              <b>NOTE:</b>
                 Don't  forget  to call <b>super().__init__()</b> in derived classes init calls as it sets up important
                 attributes.

              <b>Parameters</b>

                     • <b>interface_name</b> (<u>str</u>) -- Sets  the  D-Bus  interface  name  that  will  be  used  for  all
                       properties, methods and signals defined in the body of the class.

                     • <b>serving_enabled</b>  (<u>bool</u>)  --  If  set  to  <b>True</b> the interface will not be served on D-Bus.
                       Mostly   used    for    interfaces    that    sd-bus    already    provides    such    as
                       <b>org.freedesktop.DBus.Peer</b>.

              <b>async</b> <b>dbus_ping()</b>
                     Pings the remote service using D-Bus.

                     Useful to test if connection or remote service is alive.

                     <b>WARNING:</b>
                        This  method is ignores the particular object path meaning it can NOT be used to test if
                        object exist.

              <b>async</b> <b>dbus_machine_id()</b>
                     Returns the machine UUID of D-Bus the object is connected to.

                     <b>Returns</b>
                            machine UUID

                     <b>Return</b> <b>type</b>
                            str

              <b>async</b> <b>dbus_introspect()</b>
                     Get D-Bus introspection XML.

                     It is users responsibility to parse that data.

                     <b>Returns</b>
                            string with introspection XML

                     <b>Return</b> <b>type</b>
                            str

              <b>async</b> <b>properties_get_all_dict()</b>
                     Get all object properties as a dictionary where  keys  are  member  names  and  values  are
                     properties values.

                     Equivalent to <b>GetAll</b> method of the <b>org.freedesktop.DBus.Properties</b> interface but the member
                     names are automatically translated to python names. (internally calls it for each interface
                     used in class definition)

                     <b>Parameters</b>
                            <b>on_unknown_member</b> (<u>str</u>) -- If an unknown D-Bus property was encountered either raise
                            an  <b>"error"</b>  (default),  <b>"ignore"</b>  the  property  or  <b>"reuse"</b> the D-Bus name for the
                            member.

                     <b>Returns</b>
                            dictionary of properties

                     <b>Return</b> <b>type</b>
                            Dict[str, Any]

              <b>properties_changed:</b> <b>Tuple[str,</b> <b>Dict[str,</b> <b>Tuple[str,</b> <b>Any]],</b> <b>List[str]]</b>
                     Signal when one of the objects properties changes.

                     <u>sdbus.utils.parse.parse_properties_changed()</u> can be used to transform this signal  data  in
                     to an easier to work with dictionary.

                     Signal data is:

                     <b>Interface</b> <b>name</b> <b>(str)</b>
                            Name of the interface where property changed

                     <b>Changed</b> <b>properties</b> <b>(Dict[str,</b> <b>Tuple[str,</b> <b>Any]])</b>
                            Dictionary there keys are names of properties changed and values are variants of new
                            value.

                     <b>Invalidated</b> <b>properties</b> <b>(List[str])</b>
                            List of property names changed but no new value had been provided

              <b>_proxify(bus,</b> <b>service_name,</b> <b>object_path)</b>
                     Begin proxying to a remote D-Bus object.

                     <b>Parameters</b>

                            • <b>service_name</b>  (<u>str</u>)  -- Remote object D-Bus connection name.  For example, systemd
                              uses <b>org.freedesktop.systemd1</b>

                            • <b>object_path</b> (<u>str</u>) --  Remote  object  D-Bus  path.   Should  be  a  forward  slash
                              separated     path.      Starting     object     is     usually    <b>/</b>.     Example:
                              <b>/org/freedesktop/systemd/unit/dbus_2eservice</b>

                            • <b>bus</b> (<u>SdBus</u>) -- Optional D-Bus connection object.  If not passed the default  D-Bus
                              will be used.

              <b>classmethod</b> <b>new_proxy(bus,</b> <b>service_name,</b> <b>object_path)</b>
                     Create new proxy object and bypass <b>__init__</b>.

                     <b>Parameters</b>

                            • <b>service_name</b>  (<u>str</u>)  -- Remote object D-Bus connection name.  For example, systemd
                              uses <b>org.freedesktop.systemd1</b>

                            • <b>object_path</b> (<u>str</u>) --  Remote  object  D-Bus  path.   Should  be  a  forward  slash
                              separated     path.      Starting     object     is     usually    <b>/</b>.     Example:
                              <b>/org/freedesktop/systemd/unit/dbus_2eservice</b>

                            • <b>bus</b> (<u>SdBus</u>) -- Optional D-Bus connection object.  If not passed the default  D-Bus
                              will be used.

              <b>export_to_dbus(object_path,</b> <b>bus)</b>
                     Object will appear and become callable on D-Bus.

                     Returns  a  handle  that  can either be used as a context manager to remove the object from
                     D-Bus or <b>.stop()</b> method of the handle can be called to remove object from D-Bus.

                     Returns a handle that can be used to remove object from D-Bus  by  either  using  it  as  a
                     context manager or by calling <b>.stop()</b> method of the handle.

                        with dbus_object.export_to_dbus("/"):
                            # dbus_object can be called from D-Bus inside this
                            # with block.
                            ...

                        ...

                        handle = dbus_object2.export_to_dbus("/")
                        # dbus_object2 can be called from D-Bus between these statements
                        handle.stop()

                        ...

                        dbus_object3.export_to_dbus("/")
                        # dbus_object3 can be called from D-Bus until all references are
                        # dropped.
                        del dbus_object3

                     If the handle is discarded the object will remain exported until it gets deallocated.

                     <u>Changed</u> <u>in</u> <u>version</u> <u>0.12.0:</u> Added a handle return.

                     <b>Parameters</b>

                            • <b>object_path</b> (<u>str</u>) -- Object path that it will be available at.

                            • <b>bus</b>  (<u>SdBus</u>) -- Optional D-Bus connection object.  If not passed the default D-Bus
                              will be used.

                     <b>Returns</b>
                            Handle to control the export.

       <b>class</b> <b>sdbus.DbusObjectManagerInterfaceAsync(interface_name)</b>
              This class is almost identical to <u>DbusInterfaceCommonAsync</u> but implements <u>ObjectManager</u> interface.

              Example of serving objects with ObjectManager:

                 my_object_manager = DbusObjectManagerInterfaceAsync()
                 my_object_manager.export_to_dbus('/object/manager')

                 managed_object = DbusInterfaceCommonAsync()
                 my_object_manager.export_with_manager('/object/manager/example')

              <b>async</b> <b>get_managed_objects()</b>
                     Get the objects this object manager in managing.

                     <u>sdbus.utils.parse.parse_get_managed_objects()</u> can be used to make returned data  easier  to
                     work with.

                     <b>Returns</b>
                            Triple  nested  dictionary that contains all the objects paths with their properties
                            values.

                            Dict[ObjectPath, Dict[InterfaceName, Dict[PropertyName, PropertyValue]]]

                     <b>Return</b> <b>type</b>
                            Dict[str, Dict[str, Dict[str, Any]]]

              <b>interfaces_added:</b> <b>Tuple[str,</b> <b>Dict[str,</b> <b>Dict[str,</b> <b>Any]]]</b>
                     Signal when a new object is added or and existing object gains a new interface.

                     <u>sdbus.utils.parse.parse_interfaces_added()</u> can be used to make signal data easier  to  work
                     with.

                     Signal data is:

                     <b>Object</b> <b>path</b> <b>(str)</b>
                            Path to object that was added or modified.

                     <b>Object</b> <b>interfaces</b> <b>and</b> <b>properties</b> <b>(Dict[str,</b> <b>Dict[str,</b> <b>Any]]])</b>
                            Dict[InterfaceName, Dict[PropertyName, PropertyValue]]

              <b>interfaces_removed:</b> <b>Tuple[str,</b> <b>List[str]]</b>
                     Signal when existing object or and interface of existing object is removed.

                     <u>sdbus.utils.parse.parse_interfaces_removed()</u> can be used to make signal data easier to work
                     with.

                     Signal data is:

                     <b>Object</b> <b>path</b> <b>(str)</b>
                            Path to object that was removed or modified.

                     <b>Interfaces</b> <b>list</b> <b>(List[str])</b>
                            Interfaces names that were removed.

              <b>export_with_manager(object_path,</b> <b>object_to_export,</b> <b>bus)</b>
                     Export object to D-Bus and emit a signal that it was added.

                     ObjectManager must be exported first.

                     Path  should  be  a subpath of where ObjectManager was exported.  Example, if ObjectManager
                     exported to <b>/object/manager</b>, the managed object can be exported at <b>/object/manager/test</b>.

                     ObjectManager will keep the reference to the object.

                     Returns a handle that can be used to remove object from D-Bus and drop reference to  it  by
                     either  using  it  as  a context manager or by calling <b>.stop()</b> method of the handle. Signal
                     will be emitted once the object is stopped being exported.

                        manager = DbusObjectManagerInterfaceAsync()
                        manager.export_to_dbus('/object/manager')

                        with manager.export_with_manager("/object/manager/example", dbus_object):
                            # dbus_object can be called from D-Bus inside this
                            # with block.
                            ...

                        # Removed signal will be emitted once the with block exits

                        ...

                        handle = manager.export_with_manager("/object/manager/example", dbus_object2)
                        # dbus_object2 can be called from D-Bus between these statements
                        handle.stop()
                        # Removed signal will be emitted once the .stop() method is called

                     If the handle is discarded the object will remain  exported  until  it  gets  removed  from
                     manager with <u>remove_managed_object()</u> and the object gets deallocated.

                     <u>Changed</u> <u>in</u> <u>version</u> <u>0.12.0:</u> Added a handle return.

                     <b>Parameters</b>

                            • <b>object_path</b> (<u>str</u>) -- Object path that it will be available at.

                            • <b>object_to_export</b> (<u>DbusInterfaceCommonAsync</u>) -- Object to export to D-Bus.

                            • <b>bus</b>  (<u>SdBus</u>) -- Optional D-Bus connection object.  If not passed the default D-Bus
                              will be used.

                     <b>Raises</b> <b>RuntimeError</b> -- ObjectManager was not exported.

                     <b>Returns</b>
                            Handle to control the export.

              <b><a href="../manmanaged_object/remove_managed_object.managed_object.html">remove_managed_object</a>(managed_object)</b>
                     Emit signal that object was removed.

                     Releases reference to the object.

                     <b>CAUTION:</b>
                        The object will still be accessible over D-Bus  until  all  references  to  it  will  be
                        removed.

                     <b>Parameters</b>
                            <b>managed_object</b> (<u>DbusInterfaceCommonAsync</u>) -- Object to remove from ObjectManager.

                     <b>Raises</b>

                            • <b>RuntimeError</b> -- ObjectManager was not exported.

                            • <b>KeyError</b> -- Passed object is not managed by ObjectManager.

   <b>Decorators</b>
       <b>@sdbus.dbus_method_async([input_signature[,</b> <b>result_signature[,</b> <b>flags[,</b> <b>result_args_names[,</b>
       <b>input_args_names[,</b> <b>method_name]]]]]])</b>
              Define a method.

              Underlying function must be a coroutine function.

              <b>Parameters</b>

                     • <b>input_signature</b>  (<u>str</u>)  -- D-Bus input signature.  Defaults to "" meaning method takes no
                       arguments.  Required if you intend to connect to a remote object.

                     • <b>result_signature</b> (<u>str</u>) -- D-Bus result signature.  Defaults to "" meaning method  returns
                       empty reply on success.  Required if you intend to serve the object.

                     • <b>flags</b> (<u>int</u>) --

                       modifies  behavior.   No  effect on remote connections.  Defaults to 0 meaning no special
                       behavior.

                       See <u>Flags</u> .

                     • <b>result_args_names</b> (<u>Sequence[str]</u>) --

                       sequence of result argument names.

                       These names will show up in introspection data but otherwise have no effect.

                       Sequence can be list, tuple, etc...  Number of elements in the sequence should match  the
                       number of result arguments otherwise <b>SdBusLibraryError</b> will be raised.

                       Defaults to result arguments being nameless.

                     • <b>input_args_names</b> (<u>Sequence[str]</u>) --

                       sequence of input argument names.

                       These names will show up in introspection data but otherwise have no effect.

                       Sequence  can be list, tuple, etc...  Number of elements in the sequence should match the
                       number of result arguments otherwise <b>RuntimeError</b> will be raised.

                       If <b>result_args_names</b> has been passed when Python function argument  names  will  be  used
                       otherwise input arguments will be nameless

                     • <b>method_name</b>  (<u>str</u>)  --  Force specific D-Bus method name instead of being based on Python
                       function name.

              Example:

                 from sdbus import DbusInterfaceCommonAsync, dbus_method_async

                 class ExampleInterface(DbusInterfaceCommonAsync,
                                        interface_name='org.example.test'
                                        ):

                     # Method that takes a string
                     # and returns uppercase of that string
                     @dbus_method_async(
                         input_signature='s',
                         result_signature='s',
                         result_args_names=('uppercased', )  # This is optional but
                                                             # makes arguments have names in
                                                             # introspection data.
                     )
                     async def upper(self, str_to_up: str) -&gt; str:
                         return str_to_up.upper()

       <b>@sdbus.dbus_property_async(property_signature[,</b> <b>flags[,</b> <b>property_name]])</b>
              Declare a D-Bus property.

              The underlying function has to be a regular <b>def</b> function.

              The property will be read-only or read/write based on if setter was declared.

              <b>WARNING:</b>
                 Properties are supposed to be lightweight to get or set.  Make sure property getter  or  setter
                 does not perform heavy IO or computation as that will block other methods or properties.

              <b>Parameters</b>

                     • <b>property_signature</b>  (<u>str</u>)  --  Property  D-Bus  signature.   Has  to  be a single type or
                       container.

                     • <b>flags</b> (<u>int</u>) --

                       modifies behavior.  No effect on remote connections.  Defaults to 0  meaning  no  special
                       behavior.

                       See <u>Flags</u> .

                     • <b>property_name</b>  (<u>str</u>)  -- Force specific property name instead of constructing it based on
                       Python function name.

              Example:

                 from sdbus import DbusInterfaceCommonAsync, dbus_property_async

                 class ExampleInterface(DbusInterfaceCommonAsync,
                                        interface_name='org.example.test'
                                        ):

                     def __init__(self) -&gt; None:
                         # This is just a generic init
                         self.i = 12345
                         self.s = 'test'

                     # Read only property. No setter defined.
                     @dbus_property_async('i')
                     def read_only_number(self) -&gt; int:
                         return self.i

                     # Read/write property. First define getter.
                     @dbus_property_async('s')
                     def read_write_str(self) -&gt; str:
                         return self.s

                     # Now create setter. Method name does not matter.
                     @read_write_str.setter  # Use the property setter method as decorator
                     def read_write_str_setter(self, new_str: str) -&gt; None:
                         self.s = new_str

              <b>class</b> <b>sdbus.DbusPropertyAsync</b>
                     Properties have following methods:

                     <b>@setter(set_function)</b>
                            Defines the  setter  function.   This  makes  the  property  read/write  instead  of
                            read-only.

                            See example on how to use.

                     <b>@setter_private(set_function)</b>
                            Defines  the private setter function.  The setter can be called locally but property
                            will be read-only from D-Bus.

                            Calling the setter locally will emit <u>properties_changed</u> signal to D-Bus.

                            <u>Changed</u> <u>in</u> <u>version</u> <u>0.12.0:</u> can now be used in overrides.

                     <b>async</b> <b>get_async()</b>
                            Get the property value.

                            The property can also be directly <b>await</b> ed instead of calling this method.

                     <b>async</b> <b>set_async(new_value)</b>
                            Set property value.

       <b>@sdbus.dbus_signal_async([signal_signature[,</b> <b>signal_args_names[,</b> <b>flags[,</b> <b>signal_name]]]])</b>
              Defines a D-Bus signal.

              Underlying function return type hint is used for signal type hints.

              <b>Parameters</b>

                     • <b>signal_signature</b> (<u>str</u>) -- signal D-Bus signature.  Defaults to empty signal.

                     • <b>signal_args_names</b> (<u>Sequence[str]</u>) --

                       sequence of signal argument names.

                       These names will show up in introspection data but otherwise have no effect.

                       Sequence can be list, tuple, etc...  Number of elements in the sequence should match  the
                       number of result arguments otherwise <b>RuntimeError</b> will be raised.

                       Defaults to result arguments being nameless.

                     • <b>flags</b> (<u>int</u>) --

                       modifies  behavior.   No  effect on remote connections.  Defaults to 0 meaning no special
                       behavior.

                       See <u>Flags</u> .

                     • <b>signal_name</b> (<u>str</u>) -- Forces specific  signal  name  instead  of  being  based  on  Python
                       function name.

              Example:

                 from sdbus import DbusInterfaceCommonAsync, dbus_signal_async

                 class ExampleInterface(DbusInterfaceCommonAsync,
                                        interface_name='org.example.signal'
                                        ):

                     @dbus_signal_async('s')
                     def name_changed(self) -&gt; str:
                         raise NotImplementedError

              <b>class</b> <b>sdbus.DbusSignalAsync</b>
                     Signals have following methods:

                     <b>catch()</b>
                            Catch   D-Bus   signals  using  the  async  generator  for  loop:  <b>async</b>  <b>for</b>  <b>x</b>  <b>in</b>
                            <b>something.some_signal.catch():</b>

                            This is main way to await for new events.

                            Both remote and local objects operate the same way.

                            Signal  objects  can  also  be   async   iterated   directly:   <b>async</b>   <b>for</b>   <b>x</b>   <b>in</b>
                            <b>something.some_signal</b>

                     <b>catch_anywhere(service_name,</b> <b>bus)</b>
                            Catch  signal  independent of path.  Yields tuple of path of the object that emitted
                            signal and signal data.

                            <b>async</b> <b>for</b> <b>path,</b> <b>data</b> <b>in</b> <b>something.some_signal.catch_anywhere():</b>

                            This method can be called from both an proxy object and class.  However,  it  cannot
                            be called on local objects and will raise <b>NotImplementedError</b>.

                            <b>Parameters</b>

                                   • <b>service_name</b> (<u>str</u>) -- Service name of which signals belong to.  Required if
                                     called  from  class.  When called from proxy object the service name of the
                                     proxy will be used.

                                   • <b>bus</b> (<u>str</u>) -- Optional D-Bus connection object.  If not passed  when  called
                                     from  proxy  the  bus  connected  to proxy will be used or when called from
                                     class default bus will be used.

                     <b>emit(args)</b>
                            Emit a new signal with <u>args</u> data.

       <b>@sdbus.dbus_method_async_override</b>
              Override the method.

              Method name should match the super class method name that you want to override.

              New method should take same arguments.

              You <b>must</b> add round brackets to decorator.

              Example:

                 from sdbus import (DbusInterfaceCommonAsync, dbus_method_async
                                    dbus_method_async_override)

                 class ExampleInterface(DbusInterfaceCommonAsync,
                                        interface_name='org.example.test'
                                        ):

                     # Original call
                     @dbus_method_async('s', 's')
                     async def upper(self, str_to_up: str) -&gt; str:
                         return str_to_up.upper()

                 class ExampleOverride(ExampleInterface):

                     @dbus_method_async_override()
                     async def upper(self, str_to_up: str) -&gt; str:
                         return 'Upper: ' + str_to_up.upper()

       <b>@sdbus.dbus_property_async_override</b>
              Override property.

              You <b>must</b> add round brackets to decorator.

              Example:

                 from sdbus import (DbusInterfaceCommonAsync, dbus_property_async
                                    dbus_property_async_override)

                 class ExampleInterface(DbusInterfaceCommonAsync,
                                        interface_name='org.example.test'
                                        ):

                     def __init__(self) -&gt; None:
                         self.s = 'aaaaaaaaa'

                     # Original property
                     @dbus_property_async('s')
                     def str_prop(self) -&gt; str:
                         return self.s

                     @str_prop.setter
                     def str_prop_setter(self, new_s: str) -&gt; None:
                         self.s = new_s

                 class ExampleOverride(ExampleInterface):

                     @dbus_property_async_override()
                     def str_prop(self) -&gt; str:
                         return 'Test property' + self.s

                     # Setter needs to be decorated again to override
                     @str_prop.setter
                     def str_prop_setter(self, new_s: str) -&gt; None:
                         self.s = new_s.upper()

   <b>Asyncio</b> <b>advanced</b> <b>topics</b>
   <b>Signals</b> <b>without</b> <b>data</b>
       D-Bus allows signals to not carry any data. Such signals have the type signature of <b>""</b>. (empty string)

       To emit such signals the <u>emit</u> must be explicitly called with <b>None</b>.

       Example of an empty signal:

          from asyncio import new_event_loop
          from sdbus import DbusInterfaceCommonAsync, dbus_signal_async

          class ExampleInterface(
              DbusInterfaceCommonAsync,
              interface_name="org.example.signal"
          ):

              @dbus_signal_async("")
              def name_invalidated(self) -&gt; None:
                  raise NotImplementedError

          test_object = ExampleInterface()

          async def emit_empty_signal() -&gt; None:
              test_object.export_to_dbus("/")

              test_object.name_invalidated.emit(None)

          loop = new_event_loop()
          loop.run_until_complete(emit_empty_signal())

   <b>Exceptions</b>
   <b>Error</b> <b>name</b> <b>bound</b> <b>exceptions</b>
       These exceptions are bound to specific D-Bus error  names.  For  example,  <u>DbusFailedError</u>  is  bound  to
       <u>org.freedesktop.DBus.Error.Failed</u> error name.

       This  means if the remote object sends an error message with this error name the Python will receive this
       exception.

       When raised in a method callback an error message will be sent back to caller.

       See <u>list</u> <u>of</u> <u>error</u> <u>exceptions</u>.

   <b>New</b> <b>error</b> <b>bound</b> <b>exceptions</b>
       If you want to create a new error bound exception you should subclass it from <u>DbusFailedError</u> and provide
       a <b>unique</b> <b>dbus_error_name</b> attribute in the exception body definition.

       Example:

          class DbusExampleError(DbusFailedError):
              dbus_error_name = 'org.example.Error'

       If <b>dbus_error_name</b> is not unique the <b>ValueError</b> will be raised.

       Defining an exception will automatically bind incoming error message to this new exception.

       Existing exceptions can be manually binded using <u>map_exception_to_dbus_error()</u> function.

   <b>Python</b> <b>built-in</b> <b>exceptions</b>
       All Python built-in exceptions are mapped to D-Bus errors.

       The D-Bus error name is created by appending <b>org.python.Error.</b>  to the exception name.

       For example, <b>AssertionError</b> is bound to <b>org.python.Error.AssertionError</b> name.

   <b>Functions</b>
       <b>sdbus.exceptions.map_exception_to_dbus_error(exception,</b> <b>dbus_error_name)</b>
              Map exception to a D-bus error. Error name must be unique.

              <b>Parameters</b>

                     • <b>exception</b> (<u>Type[Exception]</u>) -- Exception to bind.

                     • <b>dbus_error_name</b> (<u>str</u>) -- D-Bus error name to bind to.

   <b>Other</b> <b>exceptions</b>
       <b>exception</b> <b>sdbus.exceptions.SdBusBaseError</b>
              Base exceptions for all exceptions defined in sdbus.

       <b>exception</b> <b>sdbus.exceptions.SdBusUnmappedMessageError</b>
              Message error that is unmapped.

              The exceptions argument is a tuple of error name and error message.

       <b>exception</b> <b>sdbus.exceptions.SdBusLibraryError</b>
              sd-bus library returned error.

              Exception message contains line number and the error name.

   <b>Name</b> <b>request</b> <b>exceptions</b>
       These exceptions will be raise if an error related to  ownership  of  D-Bus  names  occurs  when  calling
       <u>request_default_bus_name_async()</u> or <u>request_default_bus_name()</u>.

       <b>exception</b> <b>sdbus.exceptions.SdBusRequestNameError</b>
              Common base exception for any name ownership error.

       <b>exception</b> <b>sdbus.exceptions.SdBusRequestNameInQueueError</b>
              Someone already owns the name but the request has been placed in queue.

       <b>exception</b> <b>sdbus.exceptions.SdBusRequestNameExistsError</b>
              Someone already owns the name.

       <b>exception</b> <b>sdbus.exceptions.SdBusRequestNameAlreadyOwnerError</b>
              The caller already owns the name.

   <b>Error</b> <b>name</b> <b>exception</b> <b>list</b>
       <b>exception</b> <b>sdbus.exceptions.DbusFailedError</b>
              Generic failure exception.

              Recommended to subclass to create a new exception.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.Failed</b>

       <b>exception</b> <b>sdbus.exceptions.DbusNoMemoryError</b>
              Remote object is out of memory.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.NoMemory</b>

       <b>exception</b> <b>sdbus.exceptions.DbusServiceUnknownError</b>
              No service with such name exists.

              Probably should only be raised by bus daemon.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.ServiceUnknown</b>

       <b>exception</b> <b>sdbus.exceptions.DbusNameHasNoOwnerError</b>
              No process owns the name you called.

              Probably should only be raised by bus daemon.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.NameHasNoOwner</b>

       <b>exception</b> <b>sdbus.exceptions.DbusNoReplyError</b>
              Timeout on reply.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.NoReply</b>

       <b>exception</b> <b>sdbus.exceptions.DbusIOError</b>
              Input/Output error.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.IOError</b>

       <b>exception</b> <b>sdbus.exceptions.DbusBadAddressError</b>
              Bad address.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.BadAddress</b>

       <b>exception</b> <b>sdbus.exceptions.DbusNotSupportedError</b>
              Something is unsupported on this platform.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.NotSupported</b>

       <b>exception</b> <b>sdbus.exceptions.DbusLimitsExceededError</b>
              Some resource was exhausted. (for example, file descriptors)

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.LimitsExceeded</b>

       <b>exception</b> <b>sdbus.exceptions.DbusAccessDeniedError</b>
              Caller does not have enough privileges.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.AccessDenied</b>

       <b>exception</b> <b>sdbus.exceptions.DbusAuthFailedError</b>
              Authentication failed.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.AuthFailed</b>

       <b>exception</b> <b>sdbus.exceptions.DbusNoServerError</b>
              Unable to connect to bus.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.NoServer</b>

       <b>exception</b> <b>sdbus.exceptions.DbusTimeoutError</b>
              Socket timeout.

              This  is  different  from  <u>DbusNoReplyError</u>  as  here the connection to bus timeout not the remote
              object not replying.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.Timeout</b>

       <b>exception</b> <b>sdbus.exceptions.DbusNoNetworkError</b>
              No network access.

              Encountered you use D-Bus over TCP or SSH.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.NoNetwork</b>

       <b>exception</b> <b>sdbus.exceptions.DbusAddressInUseError</b>
              Address in use.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.AddressInUse</b>

       <b>exception</b> <b>sdbus.exceptions.DbusDisconnectedError</b>
              Disconnected from bus.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.Disconnected</b>

       <b>exception</b> <b>sdbus.exceptions.DbusInvalidArgsError</b>
              Method call args are invalid.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.InvalidArgs</b>

       <b>exception</b> <b>sdbus.exceptions.DbusFileNotFoundError</b>
              File not found.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.FileNotFound</b>

       <b>exception</b> <b>sdbus.exceptions.DbusFileExistsError</b>
              Generic failure exception.

              Recommended to subclass to create a new exception.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.FileExists</b>

       <b>exception</b> <b>sdbus.exceptions.DbusUnknownMethodError</b>
              Unknown D-Bus method.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.UnknownMethod</b>

       <b>exception</b> <b>sdbus.exceptions.DbusUnknownObjectError</b>
              Unknown D-Bus object.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.UnknownObject</b>

       <b>exception</b> <b>sdbus.exceptions.DbusUnknownInterfaceError</b>
              Unknown D-Bus interface.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.UnknownInterface</b>

       <b>exception</b> <b>sdbus.exceptions.DbusUnknownPropertyError</b>
              Unknown D-Bus property.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.UnknownProperty</b>

       <b>exception</b> <b>sdbus.exceptions.DbusPropertyReadOnlyError</b>
              D-Bus property is read only.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.PropertyReadOnly</b>

       <b>exception</b> <b>sdbus.exceptions.DbusUnixProcessIdUnknownError</b>
              PID does not exists.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.UnixProcessIdUnknown</b>

       <b>exception</b> <b>sdbus.exceptions.DbusInvalidSignatureError</b>
              Invalid D-Bus type signature.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.InvalidSignature</b>

       <b>exception</b> <b>sdbus.exceptions.DbusInvalidFileContentError</b>
              Invalid file content.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.InvalidFileContent</b>

       <b>exception</b> <b>sdbus.exceptions.DbusInconsistentMessageError</b>
              D-Bus message is malformed.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.InconsistentMessage</b>

       <b>exception</b> <b>sdbus.exceptions.DbusMatchRuleNotFound</b>
              Match rule does not exist.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.MatchRuleNotFound</b>

       <b>exception</b> <b>sdbus.exceptions.DbusMatchRuleInvalidError</b>
              Match rule is invalid.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.MatchRuleInvalid</b>

       <b>exception</b> <b>sdbus.exceptions.DbusInteractiveAuthorizationRequiredError</b>
              Requires interactive authorization.

              <b>dbus_error_name:</b> <b>str</b> <b>=</b> <b>org.freedesktop.DBus.Error.InteractiveAuthorizationRequired</b>

   <b>Utilities</b>
   <b>Parsing</b> <b>utilities</b>
       Parse unweildy D-Bus structures in to Python native objects and names.  Available under <b>sdbus.utils.parse</b>
       subpackage.

       <b>sdbus.utils.parse.parse_properties_changed(interface,</b> <b>properties_changed_data,</b> <b>on_unknown_member='error')</b>
              Parse data from <u>properties_changed</u> signal.

              Member names will be translated to python defined names.  Invalidated properties will have a value
              of None.

              <b>Parameters</b>

                     • <b>interface</b> (<u>DbusInterfaceBaseAsync</u>) -- Takes either D-Bus interface or interface class.

                     • <b>properties_changed_data</b> (<u>Tuple</u>) -- Tuple caught from signal.

                     • <b>on_unknown_member</b> (<u>str</u>) -- If an unknown D-Bus property was encountered either  raise  an
                       <b>"error"</b> (default), <b>"ignore"</b> the property or <b>"reuse"</b> the D-Bus name for the member.

              <b>Return</b> <b>type</b>
                     Dict[str, Any]

              <b>Returns</b>
                     Dictionary  of  changed  properties  with  keys  translated  to  python  names. Invalidated
                     properties will have value of None.

       <b>sdbus.utils.parse.parse_interfaces_added(interfaces,</b> <b>interfaces_added_data,</b> <b>on_unknown_interface='error',</b>
       <b>on_unknown_member='error')</b>
              Parse data from <u>interfaces_added</u> signal.

              Takes an iterable of D-Bus interface classes (or a single class) and the signal data.  Returns the
              path of new object, the class of the added object (if it matched one of passed interface  classes)
              and the dictionary of python named properties and their values.

              <b>Parameters</b>

                     • <b>interfaces</b>  (<u>Iterable[DbusInterfaceBaseAsync]</u>)  --  Possible  interfaces that were added.
                       Can accept classes with multiple interfaces defined.

                     • <b>interfaces_added_data</b> (<u>Tuple</u>) -- Tuple caught from signal.

                     • <b>on_unknown_interface</b> (<u>str</u>) -- If an unknown D-Bus interface was encountered either  raise
                       an <b>"error"</b> (default) or return <b>"none"</b> instead of interface class.

                     • <b>on_unknown_member</b>  (<u>str</u>)  -- If an unknown D-Bus property was encountered either raise an
                       <b>"error"</b> (default), <b>"ignore"</b> the property or <b>"reuse"</b> the D-Bus name for the member.

              <b>Return</b> <b>type</b>
                     Tuple[str, Optional[Type[DbusInterfaceBaseAsync]], Dict[str, Any]]

              <b>Returns</b>
                     Path of new added object, object's class (or <b>None</b>)  and  dictionary  of  python  translated
                     members and their values.

       <b>sdbus.utils.parse.parse_interfaces_removed(interfaces,</b> <b>interfaces_removed_data,</b>
       <b>on_unknown_interface='error')</b>
              Parse data from <u>interfaces_added</u> signal.

              Takes an iterable of D-Bus interface classes (or a single class) and the signal data.  Returns the
              path  of removed object and the class of the added object.  (if it matched one of passed interface
              classes)

              <b>Parameters</b>

                     • <b>interfaces</b> (<u>Iterable[DbusInterfaceBaseAsync]</u>) -- Possible interfaces that  were  removed.
                       Can accept classes with multiple interfaces defined.

                     • <b>interfaces_added_data</b> (<u>Tuple</u>) -- Tuple caught from signal.

                     • <b>on_unknown_member</b>  (<u>str</u>) -- If an unknown D-Bus interface was encountered either raise an
                       <b>"error"</b> (default) or return <b>"none"</b> instead of interface class.

              <b>Return</b> <b>type</b>
                     Tuple[str, Optional[Type[DbusInterfaceBaseAsync]]]

              <b>Returns</b>
                     Path of removed object and object's class (or <b>None</b>).

       <b>sdbus.utils.parse.parse_get_managed_objects(interfaces,</b> <b>managed_objects_data,</b>
       <b>on_unknown_interface='error',</b> <b>on_unknown_member='error')</b>
              Parse data from <u>get_managed_objects</u> call.

              Takes an iterable of D-Bus interface classes (or a single class) and  the  method  returned  data.
              Returns  a  dictionary  where keys a paths of the managed objects and value is a tuple of class of
              the object and dictionary of its python named properties and their values.

              <b>Parameters</b>

                     • <b>interfaces</b> (<u>Iterable[DbusInterfaceBaseAsync]</u>)  --  Possible  interfaces  of  the  managed
                       objects.  Can accept classes with multiple interfaces defined.

                     • <b>managed_objects_data</b> (<u>Dict</u>) -- Data returned by <b>get_managed_objects</b> call.

                     • <b>on_unknown_interface</b>  (<u>str</u>) -- If an unknown D-Bus interface was encountered either raise
                       an <b>"error"</b> (default) or return <b>"none"</b> instead of interface class.

                     • <b>on_unknown_member</b> (<u>str</u>) -- If an unknown D-Bus property was encountered either  raise  an
                       <b>"error"</b> (default), <b>"ignore"</b> the property or <b>"reuse"</b> the D-Bus name for the member.

              <b>Return</b> <b>type</b>
                     Dict[str, Tuple[Optional[Type[DbusInterfaceBaseAsync], Dict[str, Any]]]]

              <b>Returns</b>
                     Dictionary  where keys are paths and values are tuples of managed objects classes and their
                     properties data.

              <u>New</u> <u>in</u> <u>version</u> <u>0.12.0.</u>

   <b>Inspect</b> <b>utilities</b>
       Inspect D-Bus objects and retrieve their D-Bus related attributes such as D-Bus object paths  and  etc...
       Available under <b>sdbus.utils.inspect</b> subpackage.

       <b>sdbus.utils.inspect.inspect_dbus_path(obj,</b> <b>bus=None)</b>
              Returns the D-Bus path of an object.

              If called on a D-Bus proxy returns path of the proxied object.

              If  called  on  a  local  D-Bus object returns the exported D-Bus path.  If object is not exported
              raises <b>LookupError</b>.

              If called on an object that is unrelated to D-Bus raises <b>TypeError</b>.

              The object's path is inspected in the context of the given bus and if the object is attached to  a
              different  bus  the  <b>LookupError</b>  will be raised.  If the bus argument is not given or is <b>None</b> the
              default bus will be checked against.

              <b>Parameters</b>

                     • <b>obj</b> (<u>object</u>) -- Object to inspect.

                     • <b>bus</b> (<u>SdBus</u>) -- Bus to inspect against.  If not given or <b>None</b>  the  default  bus  will  be
                       used.

              <b>Return</b> <b>type</b>
                     str

              <b>Returns</b>
                     D-Bus path of the object.

              <u>New</u> <u>in</u> <u>version</u> <u>0.13.0.</u>

   <b>Examples</b>
   <b>Asyncio</b> <b>client</b> <b>and</b> <b>server</b>
       In this example we create a simple example server and client.

       There are 3 files:

       • <b>example_interface.py</b> File that contains the interface definition.

       • <b>example_server.py</b> Server.

       • <b>example_client.py</b> Client.

       <b>example_interface.py</b> file:

          from sdbus import (DbusInterfaceCommonAsync, dbus_method_async,
                                 dbus_property_async, dbus_signal_async)

          # This is file only contains interface definition for easy import
          # in server and client files

          class ExampleInterface(
              DbusInterfaceCommonAsync,
              interface_name='org.example.interface'
          ):
              @dbus_method_async(
                  input_signature='s',
                  result_signature='s',
              )
              async def upper(self, string: str) -&gt; str:
                  return string.upper()

              @dbus_property_async(
                  property_signature='s',
              )
              def hello_world(self) -&gt; str:
                  return 'Hello, World!'

              @dbus_signal_async(
                  signal_signature='i'
              )
              def clock(self) -&gt; int:
                  raise NotImplementedError

       <b>example_server.py</b> file:

          from asyncio import get_event_loop, sleep
          from random import randint
          from time import time

          from example_interface import ExampleInterface

          from sdbus import request_default_bus_name_async

          loop = get_event_loop()

          export_object = ExampleInterface()

          async def clock() -&gt; None:
              """
              This coroutine will sleep a random time and emit a signal with current clock
              """
              while True:
                  await sleep(randint(2, 7))  # Sleep a random time
                  current_time = int(time())  # The interface we defined uses integers
                  export_object.clock.emit(current_time)

          async def startup() -&gt; None:
              """Perform async startup actions"""
              # Acquire a known name on the bus
              # Clients will use that name to address to this server
              await request_default_bus_name_async('org.example.test')
              # Export the object to D-Bus
              export_object.export_to_dbus('/')

          loop.run_until_complete(startup())
          task_clock = loop.create_task(clock())
          loop.run_forever()

       <b>example_client.py</b> file:

          from asyncio import get_event_loop

          from example_interface import ExampleInterface

          # Create a new proxy object
          example_object = ExampleInterface.new_proxy('org.example.test', '/')

          async def print_clock() -&gt; None:
              # Use async for loop to print clock signals we receive
              async for x in example_object.clock:
                  print('Got clock: ', x)

          async def call_upper() -&gt; None:
              s = 'test string'
              s_after = await example_object.upper(s)

              print('Initial string: ', s)
              print('After call: ', s_after)

          async def get_hello_world() -&gt; None:
              print('Remote property: ', await example_object.hello_world)

          loop = get_event_loop()

          # Always binds your tasks to a variable
          task_upper = loop.create_task(call_upper())
          task_clock = loop.create_task(print_clock())
          task_hello_world = loop.create_task(get_hello_world())

          loop.run_forever()

       Start server before client. <b>python</b> <b>example_server.py</b>

       In separated terminal start client. <b>python</b> <b>example_client.py</b>

       Use CTRL-C to close client and server.

       You can also use <b>ExampleInterface</b> as a local object:

          from asyncio import run
          from example_interface import ExampleInterface

          example_object = ExampleInterface()

          async def test() -&gt; None:
              print(await example_object.upper('test'))

              print(await example_object.hello_world)

          run(test())

   <b>Interfaces</b> <b>repository</b>
       python-sdbus includes two namespace packages <b>sdbus_async</b> and <b>sdbus_block</b> which are used for proxies.

       For  example,  D-Bus daemon interface (which comes by default) can be found under <b>sdbus_async.dbus_daemon</b>
       for async binds and <b>sdbus_block.dbus_daemon</b> for blocking binds.

   <b>Known</b> <b>proxies</b>
   <b>D-Bus</b> <b>daemon</b> <b>interface</b>
       <b>class</b> <b>sdbus_async.dbus_daemon.FreedesktopDbus(bus=None)</b>
              D-Bus daemon.

              This is the D-Bus daemon interface. Used for querying D-Bus state.

              D-Bus interface object path  and  service  name  is  predetermined.   (at  <b>'org.freedesktop.DBus'</b>,
              <b>'/org/freedesktop/DBus'</b>)

              <b>Parameters</b>
                     <b>bus</b> (<u>SdBus</u>) -- Optional D-Bus connection.  If not passed the default D-Bus will be used.

              <b>async</b> <b>get_connection_pid(service_name)</b>
                     <b>D-Bus</b> <b>Method</b>

                     Get process ID that owns a specified name.

                     <b>Parameters</b>
                            <b>service_name</b> (<u>str</u>) -- Service name to query.

                     <b>Returns</b>
                            PID of name owner

                     <b>Raises</b> <u>DbusNameHasNoOwnerError</u> -- Nobody owns that name

                     <b>Return</b> <b>type</b>
                            int

              <b>async</b> <b>get_connection_uid(service_name)</b>
                     <b>D-Bus</b> <b>Method</b>

                     Get process user ID that owns a specified name.

                     <b>Parameters</b>
                            <b>service_name</b> (<u>str</u>) -- Service name to query.

                     <b>Returns</b>
                            User ID of name owner

                     <b>Raises</b> <u>DbusNameHasNoOwnerError</u> -- Nobody owns that name

                     <b>Return</b> <b>type</b>
                            int

              <b>async</b> <b>get_id()</b>
                     <b>D-Bus</b> <b>Method</b>

                     Returns machine id where bus is run. (stored in <b><a href="file:/etc/machine-id">/etc/machine-id</a></b>)

                     <b>Returns</b>
                            Machine id

                     <b>Return</b> <b>type</b>
                            str

              <b>async</b> <b>get_name_owner(service_name)</b>
                     <b>D-Bus</b> <b>Method</b>

                     Returns unique bus name (i.e. <b>':1.94'</b>) for given service name.

                     <b>Parameters</b>
                            <b>service_name</b> (<u>str</u>) -- Service name to query.

                     <b>Returns</b>
                            Unique bus name.

                     <b>Raises</b> <u>DbusNameHasNoOwnerError</u> -- Nobody owns that name

                     <b>Return</b> <b>type</b>
                            str

              <b>async</b> <b>list_activatable_names()</b>
                     <b>D-Bus</b> <b>Method</b>

                     Lists all activatable services names.

                     <b>Returns</b>
                            List of all names.

                     <b>Return</b> <b>type</b>
                            <u>List</u>[str]

              <b>async</b> <b>list_names()</b>
                     <b>D-Bus</b> <b>Method</b>

                     List all services and connections currently of the bus.

                     <b>Returns</b>
                            List of all current names.

                     <b>Return</b> <b>type</b>
                            <u>List</u>[str]

              <b>async</b> <b>name_has_owner(service_name)</b>
                     <b>D-Bus</b> <b>Method</b>

                     Return True if someone already owns the name, False if nobody does.

                     <b>Parameters</b>
                            <b>service_name</b> (<u>str</u>) -- Service name to query.

                     <b>Returns</b>
                            Is the name owned?

                     <b>Return</b> <b>type</b>
                            bool

              <b>async</b> <b>start_service_by_name(service_name,</b> <b>flags=0)</b>
                     <b>D-Bus</b> <b>Method</b>

                     Starts a specified service.

                     Flags parameter is not used currently and should be omitted or set to 0.

                     <b>Parameters</b>

                            • <b>service_name</b> (<u>str</u>) -- Service name to start.

                            • <b>flags</b> (<u>int</u>) -- Not used. Omit or pass 0.

                     <b>Returns</b>
                            1 on success, 2 if already started.

                     <b>Return</b> <b>type</b>
                            int

              <b>features</b>
                     <b>D-Bus</b> <b>property</b>

                     <b>Python</b> <b>type</b>: <u>List[str]</u>

                     <b>D-Bus</b> <b>type</b>: as

                     List of D-Bus daemon features.

                     Features include:

                     • 'AppArmor' - Messages filtered by AppArmor on this bus.

                     • 'HeaderFiltering'     -    Messages    are    filtered    if    they    have    incorrect
                       header fields.

                     • 'SELinux' - Messages filtered by SELinux on this bus.

                     • 'SystemdActivation'     -     services     activated     by     systemd     if      their
                       .service file specifies a D-Bus name.

              <b>interfaces</b>
                     <b>D-Bus</b> <b>property</b>

                     <b>Python</b> <b>type</b>: <u>List[str]</u>

                     <b>D-Bus</b> <b>type</b>: as

                     Extra D-Bus daemon interfaces

              <b>name_acquired</b>
                     <b>D-Bus</b> <b>signal</b>

                     <b>Python</b> <b>type</b>: <u>str</u>

                     <b>D-Bus</b> <b>type</b>: s

                     Signal when current process acquires a bus name.

              <b>name_lost</b>
                     <b>D-Bus</b> <b>signal</b>

                     <b>Python</b> <b>type</b>: <u>str</u>

                     <b>D-Bus</b> <b>type</b>: s

                     Signal when current process loses a bus name.

              <b>name_owner_changed</b>
                     <b>D-Bus</b> <b>signal</b>

                     <b>Python</b> <b>type</b>: <u>Tuple[str,</u> <u>str,</u> <u>str]</u>

                     <b>D-Bus</b> <b>type</b>: sss

                     Signal when some name on a bus changes owner.

                     Is a tuple of:

                     • The name that acquired or lost

                     • Old owner (by unique bus name) or empty string if no one owned it

                     • New owner (by unique bus name) or empty string if no one owns it now

       This list contains the known python-sdbus interface collections:

       • <u>D-Bus</u> <u>daemon</u> <u>interface</u>. Built-in.

       • <u>Notifications</u>.

       • <u>NetworkManager</u>.

       • <u>Secrets</u>.

   <b>Interface</b> <b>code</b> <b>generator</b>
       Python-sdbus  is  able  to  generate the interfaces code from the D-Bus introspection XML. (either from a
       file or live object on D-Bus)  Currently  async  interfaces  code  is  generated  by  default.   Blocking
       interfaces can be generated by passing <b>--block</b> option.

       Running code generator requires <u>Jinja</u> to be installed.

       <b>WARNING:</b>
          Do NOT send the generator result to <b>exec()</b> function.  Interface code MUST be inspected before running.

       The  generated  interfaces  code  will be syntactically correct but NOT stylistically.  It is recommended
       running a code formatter on the generated code. (for example <b>black</b>)

   <b>Generating</b> <b>from</b> <b>XML</b> <b>files</b>
       To run generator on files (such as found under <b><a href="file:/usr/share/dbus-1/interfaces/">/usr/share/dbus-1/interfaces/</a></b> folder)  execute  the  <b>sdbus</b>
       module with <b>gen-from-file</b> first argument and file paths to introspection XML files:

          python -m sdbus gen-from-file /usr/share/dbus-1/interfaces/org.gnome.Shell.Screenshot.xml

       The  generated interface code will be printed in to stdout. You can use shell redirection <b>&gt;</b> to save it in
       to file.

       Multiple interface files can be passed which generates a file containing multiple interfaces.

   <b>Generating</b> <b>from</b> <b>run-time</b> <b>introspection</b>
       To run generator on some service on the D-Bus execute the <b>sdbus</b>  module  with  <b>gen-from-connection</b>  first
       argument, the service connection name as second and one or more object paths:

          python -m sdbus gen-from-connection org.freedesktop.systemd1 /org/freedesktop/systemd1

       The  generated interface code will be printed in to stdout. You can use shell redirection <b>&gt;</b> to save it in
       to file.

       Multiple object paths can be passed which generates a file containing all interfaces encountered  in  the
       objects.

       Pass <b>--system</b> option to use system bus instead of session bus.

   <b>Renaming</b> <b>interfaces</b> <b>and</b> <b>members</b>
       <u>New</u> <u>in</u> <u>version</u> <u>0.13.0.</u>

       Some  interface  and  member  names  might  conflict  with  Python  keywords  when  converted  from D-Bus
       introspection to Python code by gerator. The CLI interface allow to override the particular interface and
       member names using the <b>--select-*</b> and <b>--set-name</b> options. The selector  options  move  the  cursor  to  a
       particular interface and member

       Available override options:

       •

         <b>--set-name</b>
                Sets the name of currently selected element as it would be in generated Python code. Can be used
                if either interface or member is selected.

       •

         <b>--select-interface</b>
                Selects the interface using its D-Bus name.

       •

         <b>--select-method</b>
                Selects the method using its D-Bus name.  An interface must be selected first.

       •

         <b>--select-property</b>
                Selects the property using its D-Bus name.  An interface must be selected first.

       •

         <b>--select-signal</b>
                Selects the signal using its D-Bus name.  An interface must be selected first.

       For  example,  an  <b>org.example.Interface</b>  interface  has  a  property  called  <b>Class</b>.  When automatically
       converted the name will become <b>class</b> which is a reserved Python keyword.

       Using these CLI options it is possible to override the name of the property and class:

          python -m sdbus gen-from-file \
              org.example.interface.xml \
                  --select-interface org.example.Interface \
                      --set-name Example \
                      --select-property Class \
                          --set-name example_class

       This will generate following Python code:

          class Example:
              @dbus_property_async(
                  property_signature="s",
              )
              def example_class(self) -&gt; str:
                  raise NotImplementedError

   <b>Autodoc</b> <b>extensions</b>
       Python-sdbus has an extension for Sphinx autodoc that can document D-Bus interfaces.

       To use it include <b>"sdbus.autodoc"</b> extension in your <b>conf.py</b> file.

          extensions = ['sdbus.autodoc']

       The extension can document interface class bodies. For example, <u>python-sdbus-networkmanager</u>  uses  it  to
       document the classes.

          .. autoclass:: sdbus_async.networkmanager.NetworkManagerDeviceBluetoothInterfaceAsync
              :members:

       <b>WARNING:</b>
          Autodoc  extension  is  early  in  development  and  has multiple issues. For example, the inheritance
          <b>:inherited-members:</b> does not work on the D-Bus elements.

   <b>Writing</b> <b>docstrings</b>
       The D-Bus methods should be documented same way as the regular function would. See  <u>Sphinx</u>  <u>documentation</u>
       <u>on</u> <u>possible</u> <u>fields</u>

       Example docstring for a D-Bus method:

          @dbus_method_async('s', method_name='GetConnectionUnixProcessID')
          async def get_connection_pid(self, service_name: str) -&gt; int:
              """Get process ID that owns a specified name.

              :param service_name: Service name to query.
              :return: PID of name owner
              :raises DbusNameHasNoOwnerError: Nobody owns that name
              """
              raise NotImplementedError

       D-Bus properties and signals will be annotated with type taken from the stub function.

          @dbus_property_async('as')
          def features(self) -&gt; List[str]:
              """List of D-Bus daemon features.

              Features include:

              * 'AppArmor' - Messages filtered by AppArmor on this bus.
              * 'HeaderFiltering' - Messages are filtered if they have incorrect \
                                    header fields.
              * 'SELinux' - Messages filtered by SELinux on this bus.
              * 'SystemdActivation' - services activated by systemd if their \
                                     .service file specifies a D-Bus name.
              """
              raise NotImplementedError

       No parameters are supported at the moment for properties and signals.

   <b>Unit</b> <b>testing</b>
       Python-sdbus provides several utilities to enable unit testing.

       <b>class</b> <b>sdbus.unittest.IsolatedDbusTestCase</b>
              Extension of <u>unittest.IsolatedAsyncioTestCase</u> from standard library.

              Creates an isolated instance of session D-Bus. The D-Bus will be closed and cleaned up after tests
              are finished.

              Requires <b>dbus-daemon</b> executable be installed.

              Example:

                 from sdbus import DbusInterfaceCommonAsync, dbus_method_async
                 from sdbus.unittest import IsolatedDbusTestCase

                 class TestInterface(DbusInterfaceCommonAsync,
                                     interface_name='org.test.test',
                                     ):

                     @dbus_method_async("s", "s")
                     async def upper(self, string: str) -&gt; str:
                         """Uppercase the input"""
                         return string.upper()

                 def initialize_object() -&gt; Tuple[TestInterface, TestInterface]:
                     test_object = TestInterface()
                     test_object.export_to_dbus('/')

                     test_object_connection = TestInterface.new_proxy(
                     "org.example.test", '/')

                     return test_object, test_object_connection

                 class TestProxy(IsolatedDbusTestCase):
                     async def asyncSetUp(self) -&gt; None:
                         await super().asyncSetUp()
                         await self.bus.request_name_async("org.example.test", 0)

                     async def test_method_kwargs(self) -&gt; None:
                         test_object, test_object_connection = initialize_object()

                         self.assertEqual(
                             'TEST',
                             await test_object_connection.upper('test'),
                         )

              <b>bus:</b> <b>SdBus</b>
                     Bus instance connected to isolated D-Bus environment.

                     It is also set as a default bus.

              <b>assertDbusSignalEmits(signal,</b> <b>timeout=1)</b>
                     Assert that a given signal was emitted at least once within the given timeout.

                     <b>Parameters</b>

                            • <b>signal</b> -- D-Bus signal object. Can be a signal from either local or proxy object.

                            • <b>timeout</b> (<u>Union[int,</u> <u>float]</u>) -- Maximum wait time until first captured signal.

                     Should  be  used  as  an  async context manager. The context manager exits as soon as first
                     signal is captured.

                     The object returned by context manager has following attributes:

                     <b>output:</b> <b>List[Any]</b>
                            List of captured data.

                     Example:

                        async with self.assertDbusSignalEmits(test_object.test_signal) as signal_record:
                            test_object.test_signal.emit("test")

                        self.assertEqual(["test"], signal_record.output)

                     <u>New</u> <u>in</u> <u>version</u> <u>0.12.0.</u>

   <b>API</b> <b>Index</b>
   <b>Common:</b>
       <u>get_default_bus()</u>

       <u>request_default_bus_name_async()</u>

       <u>set_default_bus()</u>

       <u>decode_object_path()</u>

       <u>encode_object_path()</u>

       <u>sd_bus_open_system()</u>

       <u>sd_bus_open_user()</u>

       <u>DbusDeprecatedFlag</u>

       <u>DbusHiddenFlag</u>

       <u>DbusNoReplyFlag</u>

       <u>DbusPropertyConstFlag</u>

       <u>DbusPropertyEmitsChangeFlag</u>

       <u>DbusPropertyEmitsInvalidationFlag</u>

       <u>DbusPropertyExplicitFlag</u>

       <u>DbusSensitiveFlag</u>

       <u>DbusUnprivilegedFlag</u>

   <b>Asyncio:</b>
       <u>DbusInterfaceCommonAsync</u>

       <u>dbus_method_async()</u>

       <u>dbus_method_async_override()</u>

       <u>dbus_property_async()</u>

       <u>dbus_property_async_override()</u>

       <u>dbus_signal_async()</u>

   <b>Blocking:</b>
       <u>DbusInterfaceCommon</u>

       <u>dbus_method()</u>

       <u>dbus_property()</u>

   <b>Exceptions:</b>
       <u>exceptions.DbusAccessDeniedError</u>

       <u>exceptions.DbusAccessDeniedError</u>

       <u>exceptions.DbusAddressInUseError</u>

       <u>exceptions.DbusAuthFailedError</u>

       <u>exceptions.DbusBadAddressError</u>

       <u>exceptions.DbusDisconnectedError</u>

       <u>exceptions.DbusFailedError</u>

       <u>exceptions.DbusFileExistsError</u>

       <u>exceptions.DbusFileNotFoundError</u>

       <u>exceptions.DbusInconsistentMessageError</u>

       <u>exceptions.DbusInteractiveAuthorizationRequiredError</u>

       <u>exceptions.DbusInvalidArgsError</u>

       <u>exceptions.DbusInvalidFileContentError</u>

       <u>exceptions.DbusInvalidSignatureError</u>

       <u>exceptions.DbusIOError</u>

       <u>exceptions.DbusLimitsExceededError</u>

       <u>exceptions.DbusMatchRuleInvalidError</u>

       <u>exceptions.DbusMatchRuleNotFound</u>

       <u>exceptions.DbusNameHasNoOwnerError</u>

       <u>exceptions.DbusNoMemoryError</u>

       <u>exceptions.DbusNoNetworkError</u>

       <u>exceptions.DbusNoReplyError</u>

       <u>exceptions.DbusNoServerError</u>

       <u>exceptions.DbusNotSupportedError</u>

       <u>exceptions.DbusPropertyReadOnlyError</u>

       <u>exceptions.DbusServiceUnknownError</u>

       <u>exceptions.DbusTimeoutError</u>

       <u>exceptions.DbusUnixProcessIdUnknownError</u>

       <u>exceptions.DbusUnknownInterfaceError</u>

       <u>exceptions.DbusUnknownMethodError</u>

       <u>exceptions.DbusUnknownObjectError</u>

       <u>exceptions.DbusUnknownPropertyError</u>

       <u>exceptions.SdBusBaseError</u>

       <u>exceptions.SdBusLibraryError</u>

       <u>exceptions.SdBusUnmappedMessageError</u>

       <u>exceptions.map_exception_to_dbus_error()</u>

       <u>exceptions.SdBusRequestNameError</u>

       <u>exceptions.SdBusRequestNameInQueueError</u>

       <u>exceptions.SdBusRequestNameExistsError</u>

       <u>exceptions.SdBusRequestNameAlreadyOwnerError</u>

       • <u>Index</u>

       • <u>API</u> <u>Index</u>

       • <u>Search</u> <u>Page</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       igo95862

                                                  Mar 05, 2025                                   <u><a href="../man1/PYTHON-SDBUS.1.html">PYTHON-SDBUS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>