<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nfssvc — NFS services</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       nfssvc — NFS services

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/mount.h&gt;</b>
       <b>#include</b> <b>&lt;sys/time.h&gt;</b>
       <b>#include</b> <b>&lt;nfs/rpcv2.h&gt;</b>
       <b>#include</b> <b>&lt;nfsserver/nfs.h&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <u>int</u>
       <b>nfssvc</b>(<u>int</u> <u>flags</u>, <u>void</u> <u>*argstructp</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>nfssvc</b>()  system  call is used by the NFS daemons to pass information into and out of the kernel and
       also to enter the kernel as a server daemon.  The <u>flags</u> argument consists of several bits that show  what
       action  is  to be taken once in the kernel and the <u>argstructp</u> points to one of three structures depending
       on which bits are set in flags.

       On the client side, <u><a href="../man8/nfsiod.8.html">nfsiod</a></u>(8) calls <b>nfssvc</b>() with the <u>flags</u> argument set to  NFSSVC_BIOD  and  <u>argstructp</u>
       set  to  NULL  to  enter the kernel as a block I/O server daemon.  For NQNFS, <u><a href="../man8/mount_nfs.8.html">mount_nfs</a></u>(8) calls <b>nfssvc</b>()
       with the NFSSVC_MNTD flag, optionally or'd with the flags NFSSVC_GOTAUTH and NFSSVC_AUTHINFAIL along with
       a pointer to a

       struct nfsd_cargs {
               char            *ncd_dirp;      /* Mount dir path */
               uid_t           ncd_authuid;    /* Effective uid */
               int             ncd_authtype;   /* Type of authenticator */
               int             ncd_authlen;    /* Length of authenticator string */
               u_char          *ncd_authstr;   /* Authenticator string */
               int             ncd_verflen;    /* and the verifier */
               u_char          *ncd_verfstr;
               NFSKERBKEY_T    ncd_key;        /* Session key */
       };

       structure.  The initial call has only the NFSSVC_MNTD flag set to specify service for  the  mount  point.
       If  the mount point is using Kerberos, then the <u><a href="../man8/mount_nfs.8.html">mount_nfs</a></u>(8) utility will return from <b>nfssvc</b>() with <u>errno</u>
       == ENEEDAUTH whenever the client side requires an ``rcmd''  authentication  ticket  for  the  user.   The
       <u><a href="../man8/mount_nfs.8.html">mount_nfs</a></u>(8)  utility  will attempt to get the Kerberos ticket, and if successful will call <b>nfssvc</b>() with
       the flags NFSSVC_MNTD and NFSSVC_GOTAUTH after filling the ticket into the ncd_authstr field and  setting
       the  ncd_authlen  and ncd_authtype fields of the nfsd_cargs structure.  If <u><a href="../man8/mount_nfs.8.html">mount_nfs</a></u>(8) failed to get the
       ticket, <b>nfssvc</b>() will be called with the  flags  NFSSVC_MNTD,  NFSSVC_GOTAUTH  and  NFSSVC_AUTHINFAIL  to
       denote a failed authentication attempt.

       On the server side, <b>nfssvc</b>() is called with the flag NFSSVC_NFSD and a pointer to a

       struct nfsd_srvargs {
               struct nfsd     *nsd_nfsd;      /* Pointer to in kernel nfsd struct */
               uid_t           nsd_uid;        /* Effective uid mapped to cred */
               uint32_t        nsd_haddr;      /* Ip address of client */
               struct ucred    nsd_cr;         /* Cred. uid maps to */
               int             nsd_authlen;    /* Length of auth string (ret) */
               u_char          *nsd_authstr;   /* Auth string (ret) */
               int             nsd_verflen;    /* and the verifier */
               u_char          *nsd_verfstr;
               struct timeval  nsd_timestamp;  /* timestamp from verifier */
               uint32_t        nsd_ttl;        /* credential ttl (sec) */
               NFSKERBKEY_T    nsd_key;        /* Session key */
       };

       to  enter the kernel as an <u><a href="../man8/nfsd.8.html">nfsd</a></u>(8) daemon.  Whenever an <u><a href="../man8/nfsd.8.html">nfsd</a></u>(8) daemon receives a Kerberos authentication
       ticket, it will return from <b>nfssvc</b>() with <u>errno</u> ==  ENEEDAUTH.   The  <u><a href="../man8/nfsd.8.html">nfsd</a></u>(8)  utility  will  attempt  to
       authenticate  the ticket and generate a set of credentials on the server for the ``user id'' specified in
       the field nsd_uid.  This is done by first  authenticating  the  Kerberos  ticket  and  then  mapping  the
       Kerberos  principal  to  a  local name and getting a set of credentials for that user via <u><a href="../man3/getpwnam.3.html">getpwnam</a></u>(3) and
       <u><a href="../man3/getgrouplist.3.html">getgrouplist</a></u>(3).  If successful, the  <u><a href="../man8/nfsd.8.html">nfsd</a></u>(8)  utility  will  call  <b>nfssvc</b>()  with  the  NFSSVC_NFSD  and
       NFSSVC_AUTHIN  flags  set  to  pass  the credential mapping in nsd_cr into the kernel to be cached on the
       server socket for that client.  If the authentication failed,  <u><a href="../man8/nfsd.8.html">nfsd</a></u>(8)  calls  <b>nfssvc</b>()  with  the  flags
       NFSSVC_NFSD and NFSSVC_AUTHINFAIL to denote an authentication failure.

       The master <u><a href="../man8/nfsd.8.html">nfsd</a></u>(8) server daemon calls <b>nfssvc</b>() with the flag NFSSVC_ADDSOCK and a pointer to a

       struct nfsd_args {
               int     sock;   /* Socket to serve */
               caddr_t name;   /* Client address for connection based sockets */
               int     namelen;/* Length of name */
       };

       to pass a server side NFS socket into the kernel for servicing by the <u><a href="../man8/nfsd.8.html">nfsd</a></u>(8) daemons.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Normally  <b>nfssvc</b>()  does  not  return  unless  the  server is terminated by a signal when a value of 0 is
       returned.  Otherwise, -1 is returned and the global variable <u>errno</u> is set to specify the error.

</pre><h4><b>ERRORS</b></h4><pre>
       [ENEEDAUTH]        This special error value is  really  used  for  authentication  support,  particularly
                          Kerberos, as explained above.

       [EPERM]            The caller is not the super-user.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man8/mount_nfs.8.html">mount_nfs</a></u>(8), <u><a href="../man8/nfsd.8.html">nfsd</a></u>(8), <u><a href="../man8/nfsiod.8.html">nfsiod</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>nfssvc</b>() system call first appeared in 4.4BSD.

</pre><h4><b>BUGS</b></h4><pre>
       The  <b>nfssvc</b>() system call is designed specifically for the NFS support daemons and as such is specific to
       their requirements.  It should really return values to indicate  the  need  for  authentication  support,
       since  ENEEDAUTH  is  not  really  an error.  Several fields of the argument structures are assumed to be
       valid and sometimes to be unchanged from a previous call, such that <b>nfssvc</b>() must be  used  with  extreme
       care.

Debian                                            June 9, 1993                                         <u><a href="../man2/NFSSVC.2.html">NFSSVC</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>