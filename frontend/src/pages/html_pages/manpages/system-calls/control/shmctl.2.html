<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shmctl - System V shared memory control</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       shmctl - System V shared memory control

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/shm.h&gt;</b>

       <b>int</b> <b>shmctl(int</b> <u>shmid</u><b>,</b> <b>int</b> <u>op</u><b>,</b> <b>struct</b> <b>shmid_ds</b> <b>*</b><u>buf</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>shmctl</b>()  performs  the  control  operation  specified  by <u>op</u> on the System V shared memory segment whose
       identifier is given in <u>shmid</u>.

       The <u>buf</u> argument is a pointer to a <u>shmid_ds</u> structure, defined in <u>&lt;sys/shm.h&gt;</u> as follows:

           struct shmid_ds {
               struct ipc_perm shm_perm;    /* Ownership and permissions */
               size_t          shm_segsz;   /* Size of segment (bytes) */
               time_t          shm_atime;   /* Last attach time */
               time_t          shm_dtime;   /* Last detach time */
               time_t          shm_ctime;   /* Creation time/time of last
                                               modification via shmctl() */
               pid_t           shm_cpid;    /* PID of creator */
               pid_t           shm_lpid;    /* PID of last <a href="../man2/shmat.2.html">shmat</a>(2)/<a href="../man2/shmdt.2.html">shmdt</a>(2) */
               shmatt_t        shm_nattch;  /* No. of current attaches */
               ...
           };

       The fields of the <u>shmid_ds</u> structure are as follows:

       <u>shm_perm</u>    This is an <u>ipc_perm</u> structure (see below) that specifies the access permissions on the shared
                   memory segment.

       <u>shm_segsz</u>   Size in bytes of the shared memory segment.

       <u>shm_atime</u>   Time of the last <b><a href="../man2/shmat.2.html">shmat</a></b>(2) system call that attached this segment.

       <u>shm_dtime</u>   Time of the last <b><a href="../man2/shmdt.2.html">shmdt</a></b>(2) system call that detached tgis segment.

       <u>shm_ctime</u>   Time of creation of segment or time of the last <b>shmctl</b>() <b>IPC_SET</b> operation.

       <u>shm_cpid</u>    ID of the process that created the shared memory segment.

       <u>shm_lpid</u>    ID of the last process that executed a <b><a href="../man2/shmat.2.html">shmat</a></b>(2) or <b><a href="../man2/shmdt.2.html">shmdt</a></b>(2) system call on this segment.

       <u>shm_nattch</u>  Number of processes that have this segment attached.

       The <u>ipc_perm</u> structure is defined as follows (the highlighted fields are settable using <b>IPC_SET</b>):

           struct ipc_perm {
               key_t          __key;    /* Key supplied to <a href="../man2/shmget.2.html">shmget</a>(2) */
               uid_t          <b>uid</b>;      /* Effective UID of owner */
               gid_t          <b>gid</b>;      /* Effective GID of owner */
               uid_t          cuid;     /* Effective UID of creator */
               gid_t          cgid;     /* Effective GID of creator */
               unsigned short <b>mode</b>;     /* <b>Permissions</b> + SHM_DEST and
                                           SHM_LOCKED flags */
               unsigned short __seq;    /* Sequence number */
           };

       The least significant 9 bits of the <u>mode</u> field of the <u>ipc_perm</u> structure define  the  access  permissions
       for the shared memory segment.  The permission bits are as follows:
       0400   Read by user
       0200   Write by user
       0040   Read by group
       0020   Write by group
       0004   Read by others
       0002   Write by others

       Bits  0100,  0010,  and  0001  (the execute bits) are unused by the system.  (It is not necessary to have
       execute permission on a segment in order to perform a <b><a href="../man2/shmat.2.html">shmat</a></b>(2) call with the <b>SHM_EXEC</b> flag.)

       Valid values for <u>op</u> are:

       <b>IPC_STAT</b>
              Copy information from the kernel data structure associated with <u>shmid</u> into the <u>shmid_ds</u>  structure
              pointed to by <u>buf</u>.  The caller must have read permission on the shared memory segment.

       <b>IPC_SET</b>
              Write  the  values  of some members of the <u>shmid_ds</u> structure pointed to by <u>buf</u> to the kernel data
              structure associated with this shared memory segment, updating also its <u>shm_ctime</u> member.

              The following fields are updated: <u>shm_perm.uid</u>, <u>shm_perm.gid</u>, and (the least  significant  9  bits
              of) <u>shm_perm.mode</u>.

              The  effective  UID  of  the  calling  process  must  match  the  owner  (<u>shm_perm.uid</u>) or creator
              (<u>shm_perm.cuid</u>) of the shared memory segment, or the caller must be privileged.

       <b>IPC_RMID</b>
              Mark the segment to be destroyed.  The segment will actually be  destroyed  only  after  the  last
              process  detaches  it  (i.e.,  when  the <u>shm_nattch</u> member of the associated structure <u>shmid_ds</u> is
              zero).  The caller must be the owner or creator  of  the  segment,  or  be  privileged.   The  <u>buf</u>
              argument is ignored.

              If  a  segment  has  been  marked  for  destruction,  then  the (nonstandard) <b>SHM_DEST</b> flag of the
              <u>shm_perm.mode</u> field in the associated data structure retrieved by <b>IPC_STAT</b> will be set.

              The caller <u>must</u> ensure that a segment is eventually  destroyed;  otherwise  its  pages  that  were
              faulted in will remain in memory or swap.

              See also the description of <u><a href="file:/proc/sys/kernel/shm_rmid_forced">/proc/sys/kernel/shm_rmid_forced</a></u> in <b><a href="../man5/proc.5.html">proc</a></b>(5).

       <b>IPC_INFO</b> (Linux-specific)
              Return  information about system-wide shared memory limits and parameters in the structure pointed
              to by <u>buf</u>.  This structure is of type <u>shminfo</u> (thus, a cast is required), defined  in  <u>&lt;sys/shm.h&gt;</u>
              if the <b>_GNU_SOURCE</b> feature test macro is defined:

                  struct shminfo {
                      unsigned long shmmax; /* Maximum segment size */
                      unsigned long shmmin; /* Minimum segment size;
                                               always 1 */
                      unsigned long shmmni; /* Maximum number of segments */
                      unsigned long shmseg; /* Maximum number of segments
                                               that a process can attach;
                                               unused within kernel */
                      unsigned long shmall; /* Maximum number of pages of
                                               shared memory, system-wide */
                  };

              The  <u>shmmni</u>,  <u>shmmax</u>,  and  <u>shmall</u>  settings  can be changed via <u><a href="file:/proc">/proc</a></u> files of the same name; see
              <b><a href="../man5/proc.5.html">proc</a></b>(5) for details.

       <b>SHM_INFO</b> (Linux-specific)
              Return a <u>shm_info</u> structure whose fields contain information about system  resources  consumed  by
              shared  memory.  This structure is defined in <u>&lt;sys/shm.h&gt;</u> if the <b>_GNU_SOURCE</b> feature test macro is
              defined:

                  struct shm_info {
                      int           used_ids; /* # of currently existing
                                                 segments */
                      unsigned long shm_tot;  /* Total number of shared
                                                 memory pages */
                      unsigned long shm_rss;  /* # of resident shared
                                                 memory pages */
                      unsigned long shm_swp;  /* # of swapped shared
                                                 memory pages */
                      unsigned long swap_attempts;
                                              /* Unused since Linux 2.4 */
                      unsigned long swap_successes;
                                              /* Unused since Linux 2.4 */
                  };

       <b>SHM_STAT</b> (Linux-specific)
              Return a <u>shmid_ds</u> structure as for <b>IPC_STAT</b>.   However,  the  <u>shmid</u>  argument  is  not  a  segment
              identifier, but instead an index into the kernel's internal array that maintains information about
              all shared memory segments on the system.

       <b>SHM_STAT_ANY</b> (Linux-specific, since Linux 4.17)
              Return  a  <u>shmid_ds</u>  structure  as  for  <b>SHM_STAT</b>.  However, <u>shm_perm.mode</u> is not checked for read
              access for <u>shmid</u>, meaning that any user can employ this operation  (just  as  any  user  may  read
              <u><a href="file:/proc/sysvipc/shm">/proc/sysvipc/shm</a></u> to obtain the same information).

       The caller can prevent or allow swapping of a shared memory segment with the following <u>op</u> values:

       <b>SHM_LOCK</b> (Linux-specific)
              Prevent  swapping  of  the  shared  memory  segment.   The caller must fault in any pages that are
              required to be present after locking  is  enabled.   If  a  segment  has  been  locked,  then  the
              (nonstandard)  <b>SHM_LOCKED</b>  flag  of  the  <u>shm_perm.mode</u>  field  in  the  associated data structure
              retrieved by <b>IPC_STAT</b> will be set.

       <b>SHM_UNLOCK</b> (Linux-specific)
              Unlock the segment, allowing it to be swapped out.

       Before Linux 2.6.10, only a privileged process could employ <b>SHM_LOCK</b> and <b>SHM_UNLOCK</b>.  Since Linux 2.6.10,
       an unprivileged process can employ these operations if its effective UID matches the owner or creator UID
       of the segment, and (for <b>SHM_LOCK</b>) the amount of memory to be  locked  falls  within  the  <b>RLIMIT_MEMLOCK</b>
       resource limit (see <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2)).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       A  successful  <b>IPC_INFO</b> or <b>SHM_INFO</b> operation returns the index of the highest used entry in the kernel's
       internal array recording information about all shared memory segments.  (This  information  can  be  used
       with  repeated <b>SHM_STAT</b> or <b>SHM_STAT_ANY</b> operations to obtain information about all shared memory segments
       on the system.)  A successful <b>SHM_STAT</b> operation returns the identifier  of  the  shared  memory  segment
       whose index was given in <u>shmid</u>.  Other operations return 0 on success.

       On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EACCES</b> <b>IPC_STAT</b>  or <b>SHM_STAT</b> is requested and <u>shm_perm.mode</u> does not allow read access for <u>shmid</u>, and the
              calling process does not have the <b>CAP_IPC_OWNER</b> capability in the user namespace that governs  its
              IPC namespace.

       <b>EFAULT</b> The argument <u>op</u> has value <b>IPC_SET</b> or <b>IPC_STAT</b> but the address pointed to by <u>buf</u> isn't accessible.

       <b>EIDRM</b>  <u>shmid</u> points to a removed identifier.

       <b>EINVAL</b> <u>shmid</u>  is  not  a  valid  identifier,  or  <u>op</u>  is  not  a  valid operation.  Or: for a <b>SHM_STAT</b> or
              <b>SHM_STAT_ANY</b> operation, the index value specified in <u>shmid</u> referred  to  an  array  slot  that  is
              currently unused.

       <b>ENOMEM</b> (Since  Linux  2.6.9),  <b>SHM_LOCK</b> was specified and the size of the to-be-locked segment would mean
              that the total bytes in locked shared memory segments would exceed the limit for the real user  ID
              of  the  calling  process.   This  limit is defined by the <b>RLIMIT_MEMLOCK</b> soft resource limit (see
              <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2)).

       <b>EOVERFLOW</b>
              <b>IPC_STAT</b> is attempted, and the GID or UID value is too large to be stored in the structure pointed
              to by <u>buf</u>.

       <b>EPERM</b>  <b>IPC_SET</b> or <b>IPC_RMID</b> is attempted, and the effective user ID of the calling process is not that  of
              the  creator  (found  in <u>shm_perm.cuid</u>), or the owner (found in <u>shm_perm.uid</u>), and the process was
              not privileged (Linux: did not have the <b>CAP_SYS_ADMIN</b> capability).

              Or (before Linux 2.6.9), <b>SHM_LOCK</b> or <b>SHM_UNLOCK</b> was specified, but the process was not  privileged
              (Linux:  did not have the <b>CAP_IPC_LOCK</b> capability).  (Since Linux 2.6.9, this error can also occur
              if the <b>RLIMIT_MEMLOCK</b> is 0 and the caller is not privileged.)

</pre><h4><b>VERSIONS</b></h4><pre>
       Linux permits a process to attach (<b><a href="../man2/shmat.2.html">shmat</a></b>(2)) a shared memory segment that has  already  been  marked  for
       deletion  using  <u>shmctl(IPC_RMID)</u>.  This feature is not available on other UNIX implementations; portable
       applications should avoid relying on it.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001, SVr4.

       Various fields in a <u>struct</u> <u>shmid_ds</u> were typed as <u>short</u> under Linux 2.2 and have become <u>long</u> under  Linux
       2.4.  To take advantage of this, a recompilation under glibc-2.1.91 or later should suffice.  (The kernel
       distinguishes old and new calls by an <b>IPC_64</b> flag in <u>op</u>.)

</pre><h4><b>NOTES</b></h4><pre>
       The <b>IPC_INFO</b>, <b>SHM_STAT</b>, and <b>SHM_INFO</b> operations are used by the <b><a href="../man1/ipcs.1.html">ipcs</a></b>(1) program to provide information on
       allocated resources.  In the future, these may modified or moved to a <u><a href="file:/proc">/proc</a></u> filesystem interface.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/mlock.2.html">mlock</a></b>(2), <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2), <b><a href="../man2/shmget.2.html">shmget</a></b>(2), <b><a href="../man2/shmop.2.html">shmop</a></b>(2), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/sysvipc.7.html">sysvipc</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                          <u><a href="../man2/shmctl.2.html">shmctl</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>