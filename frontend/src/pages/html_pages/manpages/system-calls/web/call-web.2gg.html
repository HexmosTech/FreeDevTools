<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>call-web -  (web)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/golf">golf_601.4.41-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       call-web -  (web)

</pre><h4><b>PURPOSE</b></h4><pre>
       Get content of URL resource (call a web address).

</pre><h4><b>SYNTAX</b></h4><pre>
           call-web &lt;URL&gt; \
               response &lt;result&gt; \
               [ response-code &lt;response code&gt; ] \
               [ response-headers &lt;headers&gt; ] \
               [ status &lt;status&gt; ] \
               [ method &lt;request method&gt; ] \
               [ request-headers \
                   [ content-type &lt;content type&gt; ] \
                   [ content-length &lt;content length&gt; ] \
                   custom &lt;header name&gt;=&lt;header value&gt; [ , ... ] ] \
               [ request-body \
                   ( [ fields &lt;field name&gt;=&lt;field value&gt; [ , ... ] ] \
                       [ files &lt;file name&gt;=&lt;file location&gt; [ , ... ] ] ) \
                   | \
                   ( content &lt;body content&gt; ) \
               ] \
               [ error &lt;error&gt; ] \
               [ cert &lt;certificate&gt; | no-cert ] \
               [ cookie-jar &lt;cookie jar&gt; ] \
               [ timeout &lt;timeout&gt; ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       With  call-web,  you can get the content of any accessible URL resource, for example web page, image, PDF
       document, XML document, REST API etc. It allows you to programmatically download URL's content, including
       the header. For instance, you might want to obtain (i.e. download) the source code of a web page and  its
       HTTP headers. You can then save such downloaded items into files, analyze them, or do anything else.

       &lt;URL&gt; is the resource locator, for example "https://some.web.page.com" or if you are downloading an image
       (for  instance) it could be "https://web.page.com/image.jpg". Anything you can access from a client (such
       as web browser), you can also obtain programmatically. You can specify any URL  parameters,  for  example
       "https://some.web.page.com?par1=val1&amp;par2=val2".

       <b>RESPONSE</b> <b>AND</b> <b>HEADERS</b>

       The  result  is  obtained via "response" clause into variable &lt;result&gt;, and the length (in bytes) of such
       response is obtained via "status" clause in &lt;status&gt; variable.

       The response code (such as 200 for "OK", 404 for "Not  Found"  etc.)  is  available  via  "response-code"
       clause  in  number  &lt;response code&gt;; the default value is 0 if response code is unavailable (due to error
       for instance).

       "response-headers" clause allows for retrieval of response headers (such as HTTP  headers)  in  &lt;headers&gt;
       variable, as a single string variable.

       <b>REQUEST</b> <b>METHOD</b>

       You  can  specify  the  request  method using "method" clause. &lt;method&gt; has a string value of the request
       method, such as "GET", "POST", "PUT", "PATCH", "DELETE" or any other.

       <b>STATUS</b>

       In case of error, &lt;status&gt; is negative, and has  value  of  GG_ERR_FAILED  (typically  indicating  system
       issue,  such  as lack of memory, library or system issue or local permissions), GG_ERR_WEB_CALL (error in
       accessing URL or obtaining data) - otherwise &lt;status&gt; is the length  in  bytes  of  the  response  (0  or
       positive).  Optionally, you can obtain the error message (if any) via "error" clause in &lt;error&gt; variable.
       Error is an empty string ("") if there is no error.

       <b>TIMEOUT</b>

       If "timeout" clause is specified, call-web will timeout if operation has not completed  within  &lt;timeout&gt;
       seconds. If this clause is not specified, the default timeout is 120 seconds. If timeout occurs, &lt;status&gt;
       will  be  GG_ERR_WEB_CALL  and &lt;error&gt; will indicate timeout. Timeout cannot be negative nor greater than
       86400 seconds.

       <b>HTTPS</b> <b>AND</b> <b>CERTIFICATES</b>

       You can call any valid URL that uses protocol supported by the underlying library (cURL). If you're using
       https protocol (or any other that requires a SSL/TSL certificate),  you  can  either  use  the  local  CA
       (certificate  authority)  issued,  specify the location of a certificate with "cert" clause, or if you do
       not want it checked, use "no-cert". By default, the locally installed certificates are used; if  the  URL
       you  are  visiting  is not trusted via those certificates, and you still want to visit it, use "no-cert";
       and if you do have a no-CA (i.e. self-signed certificate) for that URL, use "cert" to  provide  it  as  a
       file name (either a full path or a name relative to current working directory, see <b>directories</b>).

       <b>COOKIES</b>

       If  you'd  like to obtain cookies (for example to maintain session or examine their values), use "cookie-
       jar" clause. &lt;cookie jar&gt; specifies the location of a file holding cookies. Cookies are  read  from  this
       file  (which  can  be  empty  or  non-existent to begin with) before making a call-web and any changes to
       cookies are reflected in this file after the call. This way, multiple calls to the same  server  maintain
       cookies  the same way browser would do. Make sure the same &lt;cookie jar&gt; file is not used across different
       application spaces, meaning it should be under the application home directory (see <b>directories</b>)  and  not
       used  by  multiple  requests  simultaneously (use different cookie jar file names for that), which is the
       most likely method of implementation.

       <b>BINARY</b> <b>RESULT</b>

       The result of call-web (which is &lt;result&gt;) can be a text value or a binary value (for example if  getting
       "JPG",  "PNG",  "PDF"  or  other documents). Either way, &lt;status&gt; is the number of bytes in a buffer that
       holds the value, which is also the value's <b>string-length</b>.

       <b>REQUEST</b> <b>BODY,</b> <b>SENDING</b> <b>FILES</b> <b>AND</b> <b>ARBITRARY</b> <b>CONTENT</b>

       In order to include request body, for instance to send files, use "request-body" clause. Request body  is
       typically  used  with  POST,  PUT or PATCH methods. Even though not common, you can also use it with GET,
       DELETE or any other custom method, such as for example if the resource  you  wish  to  identify  requires
       binary data; perhaps a disposable image is used to identify the resource.

       <b>-</b> <b>Structured</b> <b>content</b>

       Use "fields" and/or "files" subclauses to send a structured body request in the form of name/value pairs,
       the  same  as  sent  from an HTML form. To do that, you can specify fields with "fields" subclause in the
       form of &lt;field name&gt;=&lt;field value&gt; pairs separated by a comma. For instance,  here  two  fields  are  set
       (field "source" with value "web" and field "act" with value "setcookie"):

           call-web "<a href="http://website.com/app_name/some_request">http://website.com/app_name/some_request</a>" response resp response-code rc status len \
               request-body fields "source"="web","act"="setcookie"

       To  include  files, use "files" subclause in the form of &lt;file name&gt;=&lt;file location&gt; separated by commas.
       For example, here "file1" is the file name sent (which can be anything), and local file  "uploadtest.jpg"
       is  the  file  whose  contents  is sent; and "file23" is the file name sent (which can be anything),  and
       "fileup4.pdf" is the actual local file read and sent. In this case files  are  in  the  application  home
       directory (see <b>directories</b>), but in general you can specify a relative or absolute path:

           call-web "<a href="http://website.com">http://website.com</a>" response resp response-code rc status len \
               request-body files "file1"="uploadtest.jpg", "file23"="fileup4.pdf"

       You  can  specify  both  "files"  and  "fields"  fields,  for instance (along with getting error text and
       status):

           call-web "<a href="http://website.com/app_name/some_request">http://website.com/app_name/some_request</a>" response resp response-code rc
               request-body fields "source"="web","act"="setcookie" \
                   files "file1"="uploadtest.jpg", "file23"="fileup4.pdf" \
               status st error err

       There is no limit on the number of files and fields you can specify, other than of  the  underlying  HTTP
       protocol.

       <b>-</b> <b>Non-structured</b> <b>content</b>

       To  send  any  arbitrary (non-structured) content in the request body, such as JSON text for example, use
       "content" subclause:

           call-web "https://website.com" response resp \
               request-headers content-type "application/json" \
               request-body content "{ \
                   \"employee\": { \
                       \"name\":       \"sonoo\", \
                       \"salary\":      56000, \
                       \"married\":    true \
                   } \
               }"

       &lt;content length&gt; number in "content-length" subclause (in "request-headers" clause) can be  specified  to
       denote the length of body content:

           read-file "somefile" to file_contents status file_length
           call-web "https://website.com" response resp \
               request-headers content-type "image/jpeg" \
               request-headers content-length file_length \
               request-body content file_contents

       If "content-length" is not used, then it is assumed to be the length of string &lt;content&gt;.

       <b>REQUEST</b> <b>HEADERS</b>

       If  your  request  has  a  body  (i.e.  "request-body" clause is used), you can set the content type with
       "content-type" subclause of a request-headers clause:

           call-web "https://&lt;web address&gt;/resource" \
               request-headers content-type "application/json" \
               request-body content some_json

       Note that using "content-type" without the request body may be ignored  by  the  server  processing  your
       request  or  may  cause it to consider the request invalid. If "content-type" is not used, the default is
       "multipart/form-data" if "fields" or "files" subclause(s) are used with "body-request" clause. Otherwise,
       if you use "content" subclause to send other types of data, you must  set  content  type  explicitly  via
       "content-type" subclause of "request-headers" clause.

       You  can also specify custom request headers with "request-headers" clause, using "custom" subclause with
       a list of &lt;header name&gt;=&lt;header value&gt; pairs separated by a comma. For example, here custom header "Golf-
       header" has value of "Some_ID", and "Another-Header" a value of "New_ID":

           call-web "<a href="http://website.com/">http://website.com/</a>&lt;app name&gt;/&lt;request name&gt;?act=get_file" response resp response-code rc status len \
               request-headers custom "Golf-header"="Some_ID", "Another-Header"="New_ID"

       On the receiving side you can get any such  custom  header  by  using  "header"  clause  of  the  <b>get-req</b>
       statement:

           get-req header "Golf-header" to hvh0
           get-req header "Another-Header" to hvh1

</pre><h4><b>EXAMPLES</b></h4><pre>
       Get the web page and print it out:

           call-web "https://website.com/page.html" response resp
           print-out resp

       Get the "JPG" image from the web and save it to a file "pic.jpg":

           call-web "https://website.com/images/someimg.jpg" status wlen response resp
           write-file "pic.jpg" from resp length wlen

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        Web

       <b>call-web</b> <b>out-header</b> <b>send-file</b> <b>silent-header</b> See all <b>documentation</b>

$DATE                                               $VERSION                                           <u><a href="../man2gg/GOLF.2gg.html">GOLF</a></u>(2gg)
</pre>
 </div>
</div></section>
</div>
</body>
</html>