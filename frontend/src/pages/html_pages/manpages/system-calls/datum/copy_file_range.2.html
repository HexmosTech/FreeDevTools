<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>copy_file_range - Copy a range of data from one file to another</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       copy_file_range - Copy a range of data from one file to another

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>
       <b>#define</b> <b>_FILE_OFFSET_BITS</b> <b>64</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>ssize_t</b> <b>copy_file_range(int</b> <u>fd_in</u><b>,</b> <b>off_t</b> <b>*_Nullable</b> <u>off_in</u><b>,</b>
                               <b>int</b> <u>fd_out</u><b>,</b> <b>off_t</b> <b>*_Nullable</b> <u>off_out</u><b>,</b>
                               <b>size_t</b> <u>len</u><b>,</b> <b>unsigned</b> <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>copy_file_range</b>()  system  call  performs an in-kernel copy between two file descriptors without the
       additional cost of transferring data from the kernel to user space and then back  into  the  kernel.   It
       copies  up  to  <u>len</u>  bytes  of  data  from the source file descriptor <u>fd_in</u> to the target file descriptor
       <u>fd_out</u>, overwriting any data that exists within the requested range of the target file.

       The following semantics apply for <u>off_in</u>, and similar statements apply to <u>off_out</u>:

       •  If <u>off_in</u> is NULL, then bytes are read from <u>fd_in</u> starting from the file offset, and the  file  offset
          is adjusted by the number of bytes copied.

       •  If  <u>off_in</u>  is  not  NULL, then <u>off_in</u> must point to a buffer that specifies the starting offset where
          bytes from <u>fd_in</u> will be read.  The file offset of <u>fd_in</u>  is  not  changed,  but  <u>off_in</u>  is  adjusted
          appropriately.

       <u>fd_in</u>  and <u>fd_out</u> can refer to the same file.  If they refer to the same file, then the source and target
       ranges are not allowed to overlap.

       The <u>flags</u> argument is provided to allow for future extensions and currently must be set to 0.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, <b>copy_file_range</b>() will return the number of bytes copied between files.  This
       could be less than the length originally requested.  If the file offset of <u>fd_in</u> is at or past the end of
       file, no bytes are copied, and <b>copy_file_range</b>() returns zero.

       On error, <b>copy_file_range</b>() returns -1 and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EBADF</b>  One or more file descriptors are not valid.

       <b>EBADF</b>  <u>fd_in</u> is not open for reading; or <u>fd_out</u> is not open for writing.

       <b>EBADF</b>  The <b>O_APPEND</b> flag is set for the open file description (see  <b><a href="../man2/open.2.html">open</a></b>(2))  referred  to  by  the  file
              descriptor <u>fd_out</u>.

       <b>EFBIG</b>  An attempt was made to write at a position past the maximum file offset the kernel supports.

       <b>EFBIG</b>  An attempt was made to write a range that exceeds the allowed maximum file size.  The maximum file
              size differs between filesystem implementations and can be different from the maximum allowed file
              offset.

       <b>EFBIG</b>  An  attempt was made to write beyond the process's file size resource limit.  This may also result
              in the process receiving a <b>SIGXFSZ</b> signal.

       <b>EINVAL</b> The <u>flags</u> argument is not 0.

       <b>EINVAL</b> <u>fd_in</u> and <u>fd_out</u> refer to the same file and the source and target ranges overlap.

       <b>EINVAL</b> Either <u>fd_in</u> or <u>fd_out</u> is not a regular file.

       <b>EIO</b>    A low-level I/O error occurred while copying.

       <b>EISDIR</b> Either <u>fd_in</u> or <u>fd_out</u> refers to a directory.

       <b>ENOMEM</b> Out of memory.

       <b>ENOSPC</b> There is not enough space on the target filesystem to complete the copy.

       <b>EOPNOTSUPP</b> (since Linux 5.19)
              The filesystem does not support this operation.

       <b>EOVERFLOW</b>
              The requested source or destination range is too large to represent in the specified data types.

       <b>EPERM</b>  <u>fd_out</u> refers to an immutable file.

       <b>ETXTBSY</b>
              Either <u>fd_in</u> or <u>fd_out</u> refers to an active swap file.

       <b>EXDEV</b> (before Linux 5.3)
              The files referred to by <u>fd_in</u> and <u>fd_out</u> are not on the same filesystem.

       <b>EXDEV</b> (since Linux 5.19)
              The files referred to by <u>fd_in</u> and <u>fd_out</u> are not on the  same  filesystem,  and  the  source  and
              target filesystems are not of the same type, or do not support cross-filesystem copy.

</pre><h4><b>VERSIONS</b></h4><pre>
       A major rework of the kernel implementation occurred in Linux 5.3.  Areas of the API that weren't clearly
       defined were clarified and the API bounds are much more strictly checked than on earlier kernels.

       Since Linux 5.19, cross-filesystem copies can be achieved when both filesystems are of the same type, and
       that filesystem implements support for it.  See BUGS for behavior prior to Linux 5.19.

       Applications  should  target  the  behaviour  and requirements of Linux 5.19, that was also backported to
       earlier stable kernels.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux, GNU.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 4.5, but glibc 2.27 provides a user-space emulation when it is not available.

</pre><h4><b>NOTES</b></h4><pre>
       If <u>fd_in</u> is a sparse file, then <b>copy_file_range</b>() may expand any holes existing in the  requested  range.
       Users  may  benefit  from  calling  <b>copy_file_range</b>()  in  a  loop,  and using the <b><a href="../man2/lseek.2.html">lseek</a></b>(2) <b>SEEK_DATA</b> and
       <b>SEEK_HOLE</b> operations to find the locations of data segments.

       <b>copy_file_range</b>() gives filesystems an opportunity to implement "copy acceleration" techniques,  such  as
       the  use of reflinks (i.e., two or more inodes that share pointers to the same copy-on-write disk blocks)
       or server-side-copy (in the case of NFS).

       <b>_FILE_OFFSET_BITS</b> should be defined to be 64 in code that uses non-null <u>off_in</u> or <u>off_out</u> or  that  takes
       the  address of <b>copy_file_range</b>, if the code is intended to be portable to traditional 32-bit x86 and ARM
       platforms where <b>off_t</b>'s width defaults to 32 bits.

</pre><h4><b>BUGS</b></h4><pre>
       In Linux 5.3 to Linux 5.18, cross-filesystem copies were implemented by the kernel, if the operation  was
       not  supported by individual filesystems.  However, on some virtual filesystems, the call failed to copy,
       while still reporting success.

</pre><h4><b>EXAMPLES</b></h4><pre>
       #define _GNU_SOURCE
       #define _FILE_OFFSET_BITS 64
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           int          fd_in, fd_out;
           off_t        len, ret;
           struct stat  stat;

           if (argc != 3) {
               fprintf(stderr, "Usage: %s &lt;source&gt; &lt;destination&gt;\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           fd_in = open(argv[1], O_RDONLY);
           if (fd_in == -1) {
               perror("open (argv[1])");
               exit(EXIT_FAILURE);
           }

           if (fstat(fd_in, &amp;stat) == -1) {
               perror("fstat");
               exit(EXIT_FAILURE);
           }

           len = stat.st_size;

           fd_out = open(argv[2], O_CREAT | O_WRONLY | O_TRUNC, 0644);
           if (fd_out == -1) {
               perror("open (argv[2])");
               exit(EXIT_FAILURE);
           }

           do {
               ret = copy_file_range(fd_in, NULL, fd_out, NULL, len, 0);
               if (ret == -1) {
                   perror("copy_file_range");
                   exit(EXIT_FAILURE);
               }

               len -= ret;
           } while (len &gt; 0 &amp;&amp; ret &gt; 0);

           close(fd_in);
           close(fd_out);
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/lseek.2.html">lseek</a></b>(2), <b><a href="../man2/sendfile.2.html">sendfile</a></b>(2), <b><a href="../man2/splice.2.html">splice</a></b>(2)

Linux man-pages 6.9.1                              2024-06-15                                 <u><a href="../man2/copy_file_range.2.html">copy_file_range</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>