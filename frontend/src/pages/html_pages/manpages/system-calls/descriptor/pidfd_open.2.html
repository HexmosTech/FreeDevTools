<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pidfd_open - obtain a file descriptor that refers to a process</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pidfd_open - obtain a file descriptor that refers to a process

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/syscall.h&gt;</b>      /* Definition of <b>SYS_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>int</b> <b>syscall(SYS_pidfd_open,</b> <b>pid_t</b> <u>pid</u><b>,</b> <b>unsigned</b> <b>int</b> <u>flags</u><b>);</b>

       <u>Note</u>: glibc provides no wrapper for <b>pidfd_open</b>(), necessitating the use of <b><a href="../man2/syscall.2.html">syscall</a></b>(2).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>pidfd_open</b>() system call creates a file descriptor that refers to the process whose PID is specified
       in <u>pid</u>.  The file descriptor is returned as the function result; the close-on-exec flag  is  set  on  the
       file descriptor.

       The <u>flags</u> argument either has the value 0, or contains the following flag:

       <b>PIDFD_NONBLOCK</b> (since Linux 5.10)
              Return  a  nonblocking file descriptor.  If the process referred to by the file descriptor has not
              yet terminated, then an attempt to wait on the file descriptor using  <b><a href="../man2/waitid.2.html">waitid</a></b>(2)  will  immediately
              return the error <b>EAGAIN</b> rather than blocking.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>pidfd_open</b>() returns a file descriptor (a nonnegative integer).  On error, -1 is returned and
       <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EINVAL</b> <u>flags</u> is not valid.

       <b>EINVAL</b> <u>pid</u> is not valid.

       <b>EMFILE</b> The per-process limit on the number of open file descriptors has been reached (see the description
              of <b>RLIMIT_NOFILE</b> in <b><a href="../man2/getrlimit.2.html">getrlimit</a></b>(2)).

       <b>ENFILE</b> The system-wide limit on the total number of open files has been reached.

       <b>ENODEV</b> The anonymous inode filesystem is not available in this kernel.

       <b>ENOMEM</b> Insufficient kernel memory was available.

       <b>ESRCH</b>  The process specified by <u>pid</u> does not exist.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 5.3.

</pre><h4><b>NOTES</b></h4><pre>
       The following code sequence can be used to obtain a file descriptor for the child of <b><a href="../man2/fork.2.html">fork</a></b>(2):

           pid = fork();
           if (pid &gt; 0) {     /* If parent */
               pidfd = pidfd_open(pid, 0);
               ...
           }

       Even if the child has already terminated by the time of the <b>pidfd_open</b>() call, its PID will not have been
       recycled  and  the  returned  file descriptor will refer to the resulting zombie process.  Note, however,
       that this is guaranteed only if the following conditions hold true:

       •  the disposition of <b>SIGCHLD</b> has not been explicitly set to <b>SIG_IGN</b> (see <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2));

       •  the <b>SA_NOCLDWAIT</b> flag was not specified while establishing a handler for <b>SIGCHLD</b> or while setting  the
          disposition of that signal to <b>SIG_DFL</b> (see <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2)); and

       •  the zombie process was not reaped elsewhere in the program (e.g., either by an asynchronously executed
          signal handler or by <b><a href="../man2/wait.2.html">wait</a></b>(2) or similar in another thread).

       If  any  of these conditions does not hold, then the child process (along with a PID file descriptor that
       refers to it) should instead be created using <b><a href="../man2/clone.2.html">clone</a></b>(2) with the <b>CLONE_PIDFD</b> flag.

   <b>Use</b> <b>cases</b> <b>for</b> <b>PID</b> <b>file</b> <b>descriptors</b>
       A PID file descriptor returned by <b>pidfd_open</b>() (or by <b><a href="../man2/clone.2.html">clone</a></b>(2) with the <b>CLONE_PID</b> flag) can be  used  for
       the following purposes:

       •  The  <b><a href="../man2/pidfd_send_signal.2.html">pidfd_send_signal</a></b>(2) system call can be used to send a signal to the process referred to by a PID
          file descriptor.

       •  A PID file descriptor can be monitored using <b><a href="../man2/poll.2.html">poll</a></b>(2), <b><a href="../man2/select.2.html">select</a></b>(2), and <b><a href="../man7/epoll.7.html">epoll</a></b>(7).  When the process  that
          it  refers  to  terminates, these interfaces indicate the file descriptor as readable.  Note, however,
          that in the current implementation, nothing can be read from the file descriptor (<b><a href="../man2/read.2.html">read</a></b>(2) on the  file
          descriptor fails with the error <b>EINVAL</b>).

       •  If  the  PID  file descriptor refers to a child of the calling process, then it can be waited on using
          <b><a href="../man2/waitid.2.html">waitid</a></b>(2).

       •  The <b><a href="../man2/pidfd_getfd.2.html">pidfd_getfd</a></b>(2) system call can be used to obtain a duplicate  of  a  file  descriptor  of  another
          process referred to by a PID file descriptor.

       •  A PID file descriptor can be used as the argument of <b><a href="../man2/setns.2.html">setns</a></b>(2) in order to move into one or more of the
          same namespaces as the process referred to by the file descriptor.

       •  A  PID file descriptor can be used as the argument of <b><a href="../man2/process_madvise.2.html">process_madvise</a></b>(2) in order to provide advice on
          the memory usage patterns of the process referred to by the file descriptor.

       The <b>pidfd_open</b>() system call is the preferred way of obtaining a  PID  file  descriptor  for  an  already
       existing  process.   The  alternative  is  to  obtain a file descriptor by opening a <u><a href="file:/proc/">/proc/</a></u>pid directory.
       However, the latter technique is possible only if the <b><a href="../man5/proc.5.html">proc</a></b>(5) filesystem  is  mounted;  furthermore,  the
       file descriptor obtained in this way is <u>not</u> pollable and can't be waited on with <b><a href="../man2/waitid.2.html">waitid</a></b>(2).

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program below opens a PID file descriptor for the process whose PID is specified as its command-line
       argument.  It then uses <b><a href="../man2/poll.2.html">poll</a></b>(2) to monitor the file descriptor for  process  exit,  as  indicated  by  an
       <b>EPOLLIN</b> event.

   <b>Program</b> <b>source</b>

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/poll.h">poll.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/syscall.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       static int
       pidfd_open(pid_t pid, unsigned int flags)
       {
           return syscall(SYS_pidfd_open, pid, flags);
       }

       int
       main(int argc, char *argv[])
       {
           int            pidfd, ready;
           struct pollfd  pollfd;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s &lt;pid&gt;\n", argv[0]);
               exit(EXIT_SUCCESS);
           }

           pidfd = pidfd_open(atoi(argv[1]), 0);
           if (pidfd == -1) {
               perror("pidfd_open");
               exit(EXIT_FAILURE);
           }

           pollfd.fd = pidfd;
           pollfd.events = POLLIN;

           ready = poll(&amp;pollfd, 1, -1);
           if (ready == -1) {
               perror("poll");
               exit(EXIT_FAILURE);
           }

           printf("Events (%#x): POLLIN is %sset\n", pollfd.revents,
                  (pollfd.revents &amp; POLLIN) ? "" : "not ");

           close(pidfd);
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/clone.2.html">clone</a></b>(2),   <b><a href="../man2/kill.2.html">kill</a></b>(2),   <b><a href="../man2/pidfd_getfd.2.html">pidfd_getfd</a></b>(2),   <b><a href="../man2/pidfd_send_signal.2.html">pidfd_send_signal</a></b>(2),  <b><a href="../man2/poll.2.html">poll</a></b>(2),  <b><a href="../man2/process_madvise.2.html">process_madvise</a></b>(2),  <b><a href="../man2/select.2.html">select</a></b>(2),
       <b><a href="../man2/setns.2.html">setns</a></b>(2), <b><a href="../man2/waitid.2.html">waitid</a></b>(2), <b><a href="../man7/epoll.7.html">epoll</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                      <u><a href="../man2/pidfd_open.2.html">pidfd_open</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>