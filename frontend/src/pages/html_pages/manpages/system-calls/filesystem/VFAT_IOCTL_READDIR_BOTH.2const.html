<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VFAT_IOCTL_READDIR_BOTH, VFAT_IOCTL_READDIR_SHORT - read filenames of a directory in a FAT filesystem</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       VFAT_IOCTL_READDIR_BOTH, VFAT_IOCTL_READDIR_SHORT - read filenames of a directory in a FAT filesystem

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/linux/msdos_fs.h">linux/msdos_fs.h</a>&gt;</b>  /* Definition of <b>VFAT_*</b> constants */
       <b>#include</b> <b>&lt;sys/ioctl.h&gt;</b>

       <b>int</b> <b>ioctl(int</b> <u>fd</u><b>,</b> <b>VFAT_IOCTL_READDIR_BOTH,</b>
                 <b>struct</b> <b>__fat_dirent</b> <u>entry</u><b>[2]);</b>
       <b>int</b> <b>ioctl(int</b> <u>fd</u><b>,</b> <b>VFAT_IOCTL_READDIR_SHORT,</b>
                 <b>struct</b> <b>__fat_dirent</b> <u>entry</u><b>[2]);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A  file  or  directory  on  a  FAT  filesystem  always has a short filename consisting of up to 8 capital
       letters, optionally followed by a period and up to 3 capital letters for  the  file  extension.   If  the
       actual  filename  does  not  fit  into  this  scheme, it is stored as a long filename of up to 255 UTF-16
       characters.

       The short filenames in a directory can be read  with  <b>VFAT_IOCTL_READDIR_SHORT</b>.   <b>VFAT_IOCTL_READDIR_BOTH</b>
       reads both the short and the long filenames.

       The  <u>fd</u>  argument  must  be  a  file  descriptor  for  a  directory.  It is sufficient to create the file
       descriptor by calling <b><a href="../man2/open.2.html">open</a></b>(2) with the <b>O_RDONLY</b> flag.  The file descriptor  can  be  used  only  once  to
       iterate over the directory entries by calling <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) repeatedly.

       The <u>entry</u> argument is a two-element array of the following structures:

           struct __fat_dirent {
               long            d_ino;
               __kernel_off_t  d_off;
               uint32_t short  d_reclen;
               char            d_name[256];
           };

       The first entry in the array is for the short filename.  The second entry is for the long filename.

       The <u>d_ino</u> and <u>d_off</u> fields are filled only for long filenames.  The <u>d_ino</u> field holds the inode number of
       the directory.  The <u>d_off</u> field holds the offset of the file entry in the directory.  As these values are
       not available for short filenames, the user code should simply ignore them.

       The  field  <u>d_reclen</u>  contains  the  length  of  the  filename  in  the  field  <u>d_name</u>.  To keep backward
       compatibility, a length of 0 for the short filename signals that  the  end  of  the  directory  has  been
       reached.   However,  the  preferred method for detecting the end of the directory is to test the <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)
       return value.  If no long filename exists, field <u>d_reclen</u> is set to 0 and <u>d_name</u> is a character string of
       length 0 for the long filename.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       A return value of 1 signals that a new directory entry has been read and a return value of 0 signals that
       the end of the directory has been reached.

       On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>ENOENT</b> <u>fd</u> refers to a removed, but still open directory.

       <b>ENOTDIR</b>
              <u>fd</u> does not refer to a directory.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.0.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following program demonstrates the use of <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) to list a directory.

       The following was recorded when applying the program to the directory <u>/mnt/user</u>:

           $ <b>./fat_dir</b> <b>/mnt/user</b>
           . -&gt; ''
           .. -&gt; ''
           ALONGF~1.TXT -&gt; 'a long filename.txt'
           UPPER.TXT -&gt; ''
           LOWER.TXT -&gt; 'lower.txt'

   <b>Program</b> <b>source</b>
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/linux/msdos_fs.h">linux/msdos_fs.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/ioctl.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           int                  fd;
           int                  ret;
           struct __fat_dirent  entry[2];

           if (argc != 2) {
               printf("Usage: %s DIRECTORY\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           /*
            * Open file descriptor for the directory.
            */
           fd = open(argv[1], O_RDONLY | O_DIRECTORY);
           if (fd == -1) {
               perror("open");
               exit(EXIT_FAILURE);
           }

           for (;;) {

               /*
                * Read next directory entry.
                */
               ret = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, entry);

               /*
                * If an error occurs, the return value is -1.
                * If the end of the directory list has been reached,
                * the return value is 0.
                * For backward compatibility the end of the directory
                * list is also signaled by d_reclen == 0.
                */
               if (ret &lt; 1)
                   break;

               /*
                * Write both the short name and the long name.
                */
               printf("%s -&gt; '%s'\n", entry[0].d_name, entry[1].d_name);
           }

           if (ret == -1) {
               perror("VFAT_IOCTL_READDIR_BOTH");
               exit(EXIT_FAILURE);
           }

           /*
            * Close the file descriptor.
            */
           close(fd);

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2), <b><a href="../man2/ioctl_fat.2.html">ioctl_fat</a></b>(2)

Linux man-pages 6.9.1                              2024-06-15                    <u><a href="../man2const/VFAT_IOCTL_READDIR_BOTH.2const.html">VFAT_IOCTL_READDIR_BOTH</a></u>(2const)
</pre>
 </div>
</div></section>
</div>
</body>
</html>