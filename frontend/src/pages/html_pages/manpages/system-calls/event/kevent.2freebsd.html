<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kqueue, kevent — kernel event notification mechanism</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       kqueue, kevent — kernel event notification mechanism

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/event.h&gt;</b>

       <u>int</u>
       <b>kqueue</b>(<u>void</u>);

       <u>int</u>
       <b>kevent</b>(<u>int</u>  <u>kq</u>,  <u>const</u>  <u>struct</u>  <u>kevent</u>  <u>*changelist</u>, <u>int</u> <u>nchanges</u>, <u>struct</u> <u>kevent</u> <u>*eventlist</u>, <u>int</u> <u>nevents</u>,
           <u>const</u> <u>struct</u> <u>timespec</u> <u>*timeout</u>);

       <b>EV_SET</b>(<u>kev</u>, <u>ident</u>, <u>filter</u>, <u>flags</u>, <u>fflags</u>, <u>data</u>, <u>udata</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>kqueue</b>() system call provides a generic method of notifying the user  when  an  event  happens  or  a
       condition  holds,  based  on  the  results  of  small  pieces of kernel code termed filters.  A kevent is
       identified by the (ident, filter) pair; there may only be one unique kevent per kqueue.

       The filter is executed upon the initial registration of a kevent in order to detect whether a preexisting
       condition is present, and is also executed whenever an event is passed to the filter for evaluation.   If
       the  filter determines that the condition should be reported, then the kevent is placed on the kqueue for
       the user to retrieve.

       The filter is also run when the user attempts to retrieve the kevent from  the  kqueue.   If  the  filter
       indicates  that  the  condition  that triggered the event no longer holds, the kevent is removed from the
       kqueue and is not returned.

       Multiple events which trigger the filter do not result in multiple kevents being placed  on  the  kqueue;
       instead,  the  filter  will  aggregate the events into a single struct kevent.  Calling <b>close</b>() on a file
       descriptor will remove any kevents that reference the descriptor.

       The <b>kqueue</b>() system call creates a new kernel event queue and returns a descriptor.   The  queue  is  not
       inherited  by  a child created with <u><a href="../man2/fork.2.html">fork</a></u>(2).  However, if <u><a href="../man2/rfork.2.html">rfork</a></u>(2) is called without the RFFDG flag, then
       the descriptor table is shared, which will allow sharing of the kqueue between two processes.

       The <b>kevent</b>() system call is used to register events with the queue, and return any pending events to  the
       user.   The  <u>changelist</u>  argument  is  a  pointer  to  an  array  of  <u>kevent</u>  structures,  as  defined in
       &lt;<u>sys/event.h</u>&gt;.  All changes contained in the <u>changelist</u> are applied before any pending  events  are  read
       from the queue.  The <u>nchanges</u> argument gives the size of <u>changelist</u>.  The <u>eventlist</u> argument is a pointer
       to  an  array of kevent structures.  The <u>nevents</u> argument determines the size of <u>eventlist</u>.  When <u>nevents</u>
       is zero, <b>kevent</b>() will return immediately even if there is a  <u>timeout</u>  specified  unlike  <u><a href="../man2/select.2.html">select</a></u>(2).   If
       <u>timeout</u>  is  a  non-NULL  pointer,  it  specifies  a maximum interval to wait for an event, which will be
       interpreted as a struct timespec.  If <u>timeout</u> is a NULL pointer, <b>kevent</b>() waits indefinitely.  To  effect
       a  poll, the <u>timeout</u> argument should be non-NULL, pointing to a zero-valued <u>timespec</u> structure.  The same
       array may be used for the <u>changelist</u> and <u>eventlist</u>.

       The <b>EV_SET</b>() macro is provided for ease of initializing a kevent structure.

       The <u>kevent</u> structure is defined as:

       struct kevent {
               uintptr_t  ident;       /* identifier for this event */
               short     filter;       /* filter for event */
               u_short   flags;        /* action flags for kqueue */
               u_int     fflags;       /* filter flag value */
               int64_t   data;         /* filter data value */
               void      *udata;       /* opaque user data identifier */
               uint64_t  ext[4];       /* extensions */
       };

       The fields of <u>struct</u> <u>kevent</u> are:

       <u>ident</u>      Value used to identify this event.  The exact interpretation is  determined  by  the  attached
                  filter, but often is a file descriptor.

       <u>filter</u>     Identifies  the  kernel filter used to process this event.  The pre-defined system filters are
                  described below.

       <u>flags</u>      Actions to perform on the event.

       <u>fflags</u>     Filter-specific flags.

       <u>data</u>       Filter-specific data value.

       <u>udata</u>      Opaque user-defined value passed through the kernel unchanged.

       <u>ext</u>        Extended data passed to and from kernel.  The <u>ext[0]</u> and <u>ext[1]</u> members use is defined by  the
                  filter.   If  the  filter does not use them, the members are copied unchanged.  The <u>ext[2]</u> and
                  <u>ext[3]</u> members are always passed through the kernel as-is, making additional context available
                  to application.

       The <u>flags</u> field can contain the following values:

       EV_ADD       Adds the event to the kqueue.  Re-adding an existing event will modify the parameters of the
                    original event, and not result in a duplicate entry.  Adding an event automatically  enables
                    it, unless overridden by the EV_DISABLE flag.

       EV_ENABLE    Permit <b>kevent</b>() to return the event if it is triggered.

       EV_DISABLE   Disable the event so <b>kevent</b>() will not return it.  The filter itself is not disabled.

       EV_DISPATCH  Disable the event source immediately after delivery of an event.  See EV_DISABLE above.

       EV_DELETE    Removes  the  event  from  the  kqueue.   Events  which are attached to file descriptors are
                    automatically deleted on the last close of the descriptor.

       EV_RECEIPT   This flag is useful for making bulk changes to a kqueue without draining any pending events.
                    When passed as input,  it  forces  EV_ERROR  to  always  be  returned.   When  a  filter  is
                    successfully  added  the <u>data</u> field will be zero.  Note that if this flag is encountered and
                    there is no remaining space in <u>eventlist</u> to hold the EV_ERROR event, then subsequent changes
                    will not get processed.

       EV_ONESHOT   Causes the event to return only the first occurrence of the filter being  triggered.   After
                    the user retrieves the event from the kqueue, it is deleted.

       EV_CLEAR     After  the  event  is retrieved by the user, its state is reset.  This is useful for filters
                    which report state transitions instead of the current state.  Note  that  some  filters  may
                    automatically set this flag internally.

       EV_EOF       Filters may set this flag to indicate filter-specific EOF condition.

       EV_ERROR     See “RETURN VALUES” below.

       The  predefined  system filters are listed below.  Arguments may be passed to and from the filter via the
       <u>fflags</u> and <u>data</u> fields in the kevent structure.

       EVFILT_READ         Takes a descriptor as the identifier, and returns whenever there is data available to
                           read.  The behavior of the filter is slightly different depending on  the  descriptor
                           type.

                           Sockets
                               Sockets  which  have  previously  been passed to <b>listen</b>() return when there is an
                               incoming connection pending.  <u>data</u> contains the size of the listen backlog.

                               Other socket descriptors return when there is data to be  read,  subject  to  the
                               SO_RCVLOWAT value of the socket buffer.  This may be overridden with a per-filter
                               low  water mark at the time the filter is added by setting the NOTE_LOWAT flag in
                               <u>fflags</u>, and specifying the new low water mark in <u>data</u>.  On return, <u>data</u>  contains
                               the number of bytes of protocol data available to read.

                               If  the  read  direction  of  the  socket has shutdown, then the filter also sets
                               EV_EOF in <u>flags</u>, and returns the socket error (if any) in <u>fflags</u>.  It is possible
                               for EOF to be returned (indicating the connection is gone) while there  is  still
                               data pending in the socket buffer.

                           Vnodes
                               Returns  when  the  file  pointer  is  not at the end of file.  <u>data</u> contains the
                               offset from current position to end of file, and may be negative.

                               This behavior is different from <u><a href="../man2/poll.2.html">poll</a></u>(2), where  read  events  are  triggered  for
                               regular  files  unconditionally.   This event can be triggered unconditionally by
                               setting the NOTE_FILE_POLL flag in <u>fflags</u>.

                           Fifos, Pipes
                               Returns when the there is data  to  read;  <u>data</u>  contains  the  number  of  bytes
                               available.

                               When the last writer disconnects, the filter will set EV_EOF in <u>flags</u>.  This will
                               be  cleared  by  the filter when a new writer connects, at which point the filter
                               will resume waiting for data to become available before returning.

                           BPF devices
                               Returns when the BPF buffer is full, the BPF timeout has expired, or when the BPF
                               has “immediate mode” enabled and there is any data to  read;  <u>data</u>  contains  the
                               number of bytes available.

       EVFILT_WRITE        Takes a descriptor as the identifier, and returns whenever it is possible to write to
                           the  descriptor.  For sockets, pipes and fifos, <u>data</u> will contain the amount of space
                           remaining in  the  write  buffer.   The  filter  will  set  EV_EOF  when  the  reader
                           disconnects,  and for the fifo case, this will be cleared when a new reader connects.
                           Note that this filter is not supported for vnodes or BPF devices.

                           For sockets, the low water mark  and  socket  error  handling  is  identical  to  the
                           EVFILT_READ case.

       EVFILT_EMPTY        Takes a descriptor as the identifier, and returns whenever there is no remaining data
                           in the write buffer.

       EVFILT_AIO          Events  for  this filter are not registered with <b>kevent</b>() directly but are registered
                           via the <u>aio_sigevent</u> member of an asynchronous I/O request when it is  scheduled  via
                           an  asynchronous  I/O  system  call such as <b>aio_read</b>().  The filter returns under the
                           same conditions as <b>aio_error</b>().  For more details on this filter see <u><a href="../man3/sigevent.3.html">sigevent</a></u>(3)  and
                           <u><a href="../man4/aio.4.html">aio</a></u>(4).

       EVFILT_VNODE        Takes  a file descriptor as the identifier and the events to watch for in <u>fflags</u>, and
                           returns when one or more of the requested  events  occurs  on  the  descriptor.   The
                           events to monitor are:

                           NOTE_ATTRIB          The  file  referenced  by  the  descriptor  had  its  attributes
                                                changed.

                           NOTE_CLOSE           A file descriptor referencing the monitored  file,  was  closed.
                                                The closed file descriptor did not have write access.

                           NOTE_CLOSE_WRITE     A  file  descriptor  referencing the monitored file, was closed.
                                                The closed file descriptor had write access.

                                                This note, as well as NOTE_CLOSE, are not activated  when  files
                                                are  closed  forcibly  by  <u><a href="../man2/unmount.2.html">unmount</a></u>(2)  or  <u><a href="../man2/revoke.2.html">revoke</a></u>(2).   Instead,
                                                NOTE_REVOKE is sent for such events.

                           NOTE_DELETE          The <b>unlink</b>() system call was called on the  file  referenced  by
                                                the descriptor.

                           NOTE_EXTEND          For  regular  file,  the  file  referenced by the descriptor was
                                                extended.

                                                For directory, reports that  a  directory  entry  was  added  or
                                                removed,  as  the  result  of rename operation.  The NOTE_EXTEND
                                                event is  not  reported  when  a  name  is  changed  inside  the
                                                directory.

                           NOTE_LINK            The  link  count  on  the  file  changed.   In  particular,  the
                                                NOTE_LINK event is reported if a  subdirectory  was  created  or
                                                deleted inside the directory referenced by the descriptor.

                           NOTE_OPEN            The file referenced by the descriptor was opened.

                           NOTE_READ            A read occurred on the file referenced by the descriptor.

                           NOTE_RENAME          The file referenced by the descriptor was renamed.

                           NOTE_REVOKE          Access  to  the file was revoked via <u><a href="../man2/revoke.2.html">revoke</a></u>(2) or the underlying
                                                file system was unmounted.

                           NOTE_WRITE           A write occurred on the file referenced by the descriptor.

                           On return, <u>fflags</u> contains the events which triggered the filter.

       EVFILT_PROC         Takes the process ID to monitor as the identifier and the  events  to  watch  for  in
                           <u>fflags</u>,  and  returns  when the process performs one or more of the requested events.
                           If a process can normally see another process, it can attach an  event  to  it.   The
                           events to monitor are:

                           NOTE_EXIT         The process has exited.  The exit status will be stored in <u>data</u>.

                           NOTE_FORK         The process has called <b>fork</b>().

                           NOTE_EXEC         The  process  has executed a new process via <u><a href="../man2/execve.2.html">execve</a></u>(2) or a similar
                                             call.

                           NOTE_TRACK        Follow a process across <b>fork</b>() calls.  The parent process registers
                                             a new kevent to monitor the child process using the same <u>fflags</u>  as
                                             the  original  event.   The child process will signal an event with
                                             NOTE_CHILD set in <u>fflags</u> and the parent PID in <u>data</u>.

                                             If the parent process fails to register a new kevent  (usually  due
                                             to   resource   limitations),   it   will   signal  an  event  with
                                             NOTE_TRACKERR set in <u>fflags</u>, and the child process will not  signal
                                             a NOTE_CHILD event.

                           On return, <u>fflags</u> contains the events which triggered the filter.

       EVFILT_PROCDESC     Takes  the  process  descriptor created by <u><a href="../man2/pdfork.2.html">pdfork</a></u>(2) to monitor as the identifier and
                           the events to watch for in <u>fflags</u>, and returns when the associated  process  performs
                           one or more of the requested events.  The events to monitor are:

                           NOTE_EXIT     The process has exited.  The exit status will be stored in <u>data</u>.

                           On return, <u>fflags</u> contains the events which triggered the filter.

       EVFILT_SIGNAL       Takes  the  signal  number  to  monitor  as the identifier and returns when the given
                           signal is delivered to the process.  This coexists with the <b>signal</b>() and  <b>sigaction</b>()
                           facilities,  and  has  a  lower  precedence.   The filter will record all attempts to
                           deliver a signal to a process, even if the signal has been marked as SIG_IGN,  except
                           for the SIGCHLD signal, which, if ignored, will not be recorded by the filter.  Event
                           notification  happens  after  normal  signal  delivery  processing.  <u>data</u> returns the
                           number of times the signal has occurred since the last call to <b>kevent</b>().  This filter
                           automatically sets the EV_CLEAR flag internally.

       EVFILT_TIMER        Establishes an arbitrary timer identified  by  <u>ident</u>.   When  adding  a  timer,  <u>data</u>
                           specifies the moment to fire the timer (for NOTE_ABSTIME) or the timeout period.  The
                           timer  will  be  periodic unless EV_ONESHOT or NOTE_ABSTIME is specified.  On return,
                           <u>data</u> contains the number of times the timeout has expired  since  the  last  call  to
                           <b>kevent</b>().  For non-monotonic timers, this filter automatically sets the EV_CLEAR flag
                           internally.

                           The filter accepts the following flags in the <u>fflags</u> argument:

                           NOTE_SECONDS      <u>data</u> is in seconds.

                           NOTE_MSECONDS     <u>data</u> is in milliseconds.

                           NOTE_USECONDS     <u>data</u> is in microseconds.

                           NOTE_NSECONDS     <u>data</u> is in nanoseconds.

                           NOTE_ABSTIME      The specified expiration time is absolute.

                           If  <u>fflags</u>  is  not set, the default is milliseconds.  On return, <u>fflags</u> contains the
                           events which triggered the filter.

                           If an existing timer is re-added, the existing timer  will  be  effectively  canceled
                           (throwing  away  any  undelivered record of previous timer expiration) and re-started
                           using the new parameters contained in <u>data</u> and <u>fflags</u>.

                           There is a system wide limit on the number of  timers  which  is  controlled  by  the
                           <u>kern.kq_calloutmax</u> sysctl.

       EVFILT_USER         Establishes  a user event identified by <u>ident</u> which is not associated with any kernel
                           mechanism but is triggered by user level code.  The lower 24 bits of the  <u>fflags</u>  may
                           be used for user defined flags and manipulated using the following:

                           NOTE_FFNOP          Ignore the input <u>fflags</u>.

                           NOTE_FFAND          Bitwise AND <u>fflags</u>.

                           NOTE_FFOR           Bitwise OR <u>fflags</u>.

                           NOTE_FFCOPY         Copy <u>fflags</u>.

                           NOTE_FFCTRLMASK     Control mask for <u>fflags</u>.

                           NOTE_FFLAGSMASK     User defined flag mask for <u>fflags</u>.

                           A user event is triggered for output with the following:

                           NOTE_TRIGGER        Cause the event to be triggered.

                           On return, <u>fflags</u> contains the users defined flags in the lower 24 bits.

</pre><h4><b>CANCELLATION</b> <b>BEHAVIOUR</b></h4><pre>
       If  <u>nevents</u>  is  non-zero,  i.e., the function is potentially blocking, the call is a cancellation point.
       Otherwise, i.e., if <u>nevents</u> is zero, the call is not cancellable.  Cancellation can only occur before any
       changes are made to the kqueue, or when the call was blocked and no changes to the queue were requested.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>kqueue</b>() system call creates a new kernel event queue and returns a file descriptor.  If there was an
       error creating the kernel event queue, a value of -1 is returned and errno set.

       The <b>kevent</b>() system call returns the number of events placed in the <u>eventlist</u>, up to the value  given  by
       <u>nevents</u>.   If  an  error occurs while processing an element of the <u>changelist</u> and there is enough room in
       the <u>eventlist</u>, then the event will be placed in the <u>eventlist</u> with EV_ERROR set in <u>flags</u> and  the  system
       error  in  <u>data</u>.   Otherwise, -1 will be returned, and errno will be set to indicate the error condition.
       If the time limit expires, then <b>kevent</b>() returns 0.

</pre><h4><b>EXAMPLES</b></h4><pre>
       #include &lt;sys/event.h&gt;
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;

       int
       main(int argc, char **argv)
       {
           struct kevent event;    /* Event we want to monitor */
           struct kevent tevent;   /* Event triggered */
           int kq, fd, ret;

           if (argc != 2)
               err(EXIT_FAILURE, "Usage: %s path\n", argv[0]);
           fd = open(argv[1], O_RDONLY);
           if (fd == -1)
               err(EXIT_FAILURE, "Failed to open '%s'", argv[1]);

           /* Create kqueue. */
           kq = kqueue();
           if (kq == -1)
               err(EXIT_FAILURE, "kqueue() failed");

           /* Initialize kevent structure. */
           EV_SET(&amp;event, fd, EVFILT_VNODE, EV_ADD | EV_CLEAR, NOTE_WRITE,
               0, NULL);
           /* Attach event to the kqueue. */
           ret = kevent(kq, &amp;event, 1, NULL, 0, NULL);
           if (ret == -1)
               err(EXIT_FAILURE, "kevent register");
           if (event.flags &amp; EV_ERROR)
               errx(EXIT_FAILURE, "Event error: %s", strerror(event.data));

           for (;;) {
               /* Sleep until something happens. */
               ret = kevent(kq, NULL, 0, &amp;tevent, 1, NULL);
               if (ret == -1) {
                   err(EXIT_FAILURE, "kevent wait");
               } else if (ret &gt; 0) {
                   printf("Something was written in '%s'\n", argv[1]);
               }
           }
       }

</pre><h4><b>ERRORS</b></h4><pre>
       The <b>kqueue</b>() system call fails if:

       [ENOMEM]           The kernel failed to allocate enough memory for the kernel queue.

       [ENOMEM]           The RLIMIT_KQUEUES rlimit (see <u><a href="../man2/getrlimit.2.html">getrlimit</a></u>(2)) for the current user would be exceeded.

       [EMFILE]           The per-process descriptor table is full.

       [ENFILE]           The system file table is full.

       The <b>kevent</b>() system call fails if:

       [EACCES]           The process does not have permission to register a filter.

       [EFAULT]           There was an error reading or writing the <u>kevent</u> structure.

       [EBADF]            The specified descriptor is invalid.

       [EINTR]            A signal was delivered before the timeout expired and before any events were placed on
                          the kqueue for return.

       [EINTR]            A cancellation request was delivered to the thread, but not yet handled.

       [EINVAL]           The specified time limit or filter is invalid.

       [ENOENT]           The event could not be found to be modified or deleted.

       [ENOMEM]           No memory was available to register the event or, in the special case of a timer,  the
                          maximum  number  of  timers  has  been exceeded.  This maximum is configurable via the
                          <u>kern.kq_calloutmax</u> sysctl.

       [ESRCH]            The specified process to attach to does not exist.

       When <b>kevent</b>() call fails with EINTR error, all changes in the <u>changelist</u> have been applied.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/aio_error.2.html">aio_error</a></u>(2),  <u><a href="../man2/aio_read.2.html">aio_read</a></u>(2),  <u><a href="../man2/aio_return.2.html">aio_return</a></u>(2),  <u><a href="../man2/poll.2.html">poll</a></u>(2),   <u><a href="../man2/read.2.html">read</a></u>(2),   <u><a href="../man2/select.2.html">select</a></u>(2),   <u><a href="../man2/sigaction.2.html">sigaction</a></u>(2),   <u><a href="../man2/write.2.html">write</a></u>(2),
       <u><a href="../man3/pthread_setcancelstate.3.html">pthread_setcancelstate</a></u>(3), <u><a href="../man3/signal.3.html">signal</a></u>(3)

       Jonathan  Lemon, “Kqueue: A Generic and Scalable Event Notification Facility”, <u>Proceedings</u> <u>of</u> <u>the</u> <u>FREENIX</u>
       <u>Track:</u> <u>2001</u> <u>USENIX</u> <u>Annual</u> <u>Technical</u> <u>Conference</u>, <u>USENIX</u> <u>Association</u>, June 25-30, 2001.

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>kqueue</b>() and <b>kevent</b>() system calls first appeared in FreeBSD 4.1.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>kqueue</b>() system and this manual page were written by Jonathan Lemon &lt;<u><a href="mailto:jlemon@FreeBSD.org">jlemon@FreeBSD.org</a></u>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       The <u>timeout</u> value is limited to 24 hours; longer timeouts will be silently reinterpreted as 24 hours.

       In versions older than FreeBSD 12.0,  &lt;<u>sys/event.h</u>&gt;  failed  to  parse  without  including  &lt;<u>sys/types.h</u>&gt;
       manually.

Debian                                             May 1, 2020                                         <u><a href="../man2/KQUEUE.2.html">KQUEUE</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>