<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pivot_root - change the root mount</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pivot_root - change the root mount

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/syscall.h&gt;</b>      /* Definition of <b>SYS_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>int</b> <b>syscall(SYS_pivot_root,</b> <b>const</b> <b>char</b> <b>*</b><u>new_root</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>put_old</u><b>);</b>

       <u>Note</u>: glibc provides no wrapper for <b>pivot_root</b>(), necessitating the use of <b><a href="../man2/syscall.2.html">syscall</a></b>(2).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>pivot_root</b>()  changes  the  root mount in the mount namespace of the calling process.  More precisely, it
       moves the root mount to the directory <u>put_old</u> and makes <u>new_root</u> the new root mount.  The calling process
       must have the <b>CAP_SYS_ADMIN</b> capability in the user namespace that owns the caller's mount namespace.

       <b>pivot_root</b>() changes the root directory and the current working directory of each process  or  thread  in
       the  same mount namespace to <u>new_root</u> if they point to the old root directory.  (See also NOTES.)  On the
       other hand, <b>pivot_root</b>() does not change the caller's current working directory (unless it is on the  old
       root directory), and thus it should be followed by a <b>chdir("/")</b> call.

       The following restrictions apply:

       •  <u>new_root</u> and <u>put_old</u> must be directories.

       •  <u>new_root</u> and <u>put_old</u> must not be on the same mount as the current root.

       •  <u>put_old</u>  must  be at or underneath <u>new_root</u>; that is, adding some nonnegative number of "<u><a href="file:/..">/..</a></u>" suffixes
          to the pathname pointed to by <u>put_old</u> must yield the same directory as <u>new_root</u>.

       •  <u>new_root</u> must be a path to a mount point, but can't be <u>"/"</u>.  A path that is not already a mount  point
          can be converted into one by bind mounting the path onto itself.

       •  The  propagation  type  of  the  parent  mount  of  <u>new_root</u>  and the parent mount of the current root
          directory must not be <b>MS_SHARED</b>; similarly, if <u>put_old</u> is an existing  mount  point,  its  propagation
          type  must not be <b>MS_SHARED</b>.  These restrictions ensure that <b>pivot_root</b>() never propagates any changes
          to another mount namespace.

       •  The current root directory must be a mount point.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, zero is returned.  On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>pivot_root</b>() may fail with any of the same errors  as  <b><a href="../man2/stat.2.html">stat</a></b>(2).   Additionally,  it  may  fail  with  the
       following errors:

       <b>EBUSY</b>  <u>new_root</u>  or <u>put_old</u> is on the current root mount.  (This error covers the pathological case where
              <u>new_root</u> is <u>"/"</u>.)

       <b>EINVAL</b> <u>new_root</u> is not a mount point.

       <b>EINVAL</b> <u>put_old</u> is not at or underneath <u>new_root</u>.

       <b>EINVAL</b> The current root directory is not a mount point (because of an earlier <b><a href="../man2/chroot.2.html">chroot</a></b>(2)).

       <b>EINVAL</b> The current root is on the rootfs (initial ramfs) mount; see NOTES.

       <b>EINVAL</b> Either the mount point at <u>new_root</u>, or the parent mount of that mount point, has propagation  type
              <b>MS_SHARED</b>.

       <b>EINVAL</b> <u>put_old</u> is a mount point and has the propagation type <b>MS_SHARED</b>.

       <b>ENOTDIR</b>
              <u>new_root</u> or <u>put_old</u> is not a directory.

       <b>EPERM</b>  The calling process does not have the <b>CAP_SYS_ADMIN</b> capability.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.3.41.

</pre><h4><b>NOTES</b></h4><pre>
       A command-line interface for this system call is provided by <b><a href="../man8/pivot_root.8.html">pivot_root</a></b>(8).

       <b>pivot_root</b>()  allows the caller to switch to a new root filesystem while at the same time placing the old
       root mount at a location under <u>new_root</u> from where it can subsequently be unmounted.  (The fact  that  it
       moves  all processes that have a root directory or current working directory on the old root directory to
       the new root frees the old root directory of users, allowing the old root  mount  to  be  unmounted  more
       easily.)

       One  use  of  <b>pivot_root</b>()  is  during system startup, when the system mounts a temporary root filesystem
       (e.g., an <b><a href="../man4/initrd.4.html">initrd</a></b>(4)), then mounts the real root filesystem, and eventually turns the latter into the root
       directory of all relevant processes and threads.  A modern use is to set up a root filesystem during  the
       creation of a container.

       The  fact  that <b>pivot_root</b>() modifies process root and current working directories in the manner noted in
       DESCRIPTION is necessary in order to prevent kernel threads from keeping the old  root  mount  busy  with
       their root and current working directories, even if they never access the filesystem in any way.

       The  rootfs  (initial  ramfs)  cannot  be  <b>pivot_root</b>()ed.   The  recommended method of changing the root
       filesystem in this case is to delete everything in rootfs, overmount rootfs with  the  new  root,  attach
       <u>stdin</u>/<u>stdout</u>/<u>stderr</u>  to the new <u>/dev/console</u>, and exec the new <b><a href="../man1/init.1.html">init</a></b>(1).  Helper programs for this process
       exist; see <b><a href="../man8/switch_root.8.html">switch_root</a></b>(8).

   <b>pivot_root(".",</b> <b>".")</b>
       <u>new_root</u> and <u>put_old</u> may be the same directory.  In particular, the following sequence  allows  a  pivot-
       root operation without needing to create and remove a temporary directory:

           chdir(new_root);
           pivot_root(".", ".");
           umount2(".", MNT_DETACH);

       This  sequence  succeeds  because the <b>pivot_root</b>() call stacks the old root mount point on top of the new
       root mount point at <u>/</u>.  At that point, the calling process's root directory and current working directory
       refer to the new root mount point (<u>new_root</u>).  During the subsequent <b>umount</b>()  call,  resolution  of  <u>"."</u>
       starts  with  <u>new_root</u>  and  then moves up the list of mounts stacked at <u>/</u>, with the result that old root
       mount point is unmounted.

   <b>Historical</b> <b>notes</b>
       For many years, this manual page carried the following text:

              <b>pivot_root</b>() may or may not change the current root and  the  current  working  directory  of  any
              processes  or  threads  which  use the old root directory.  The caller of <b>pivot_root</b>() must ensure
              that processes with root or current working directory at the old root operate correctly in  either
              case.   An  easy  way  to  ensure  this  is  to change their root and current working directory to
              <u>new_root</u> before invoking <b>pivot_root</b>().

       This text, written before the system call implementation was even finalized in the kernel,  was  probably
       intended  to warn users at that time that the implementation might change before final release.  However,
       the behavior stated in DESCRIPTION has remained consistent since this system call was  first  implemented
       and will not change now.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program  below  demonstrates  the use of <b>pivot_root</b>() inside a mount namespace that is created using
       <b><a href="../man2/clone.2.html">clone</a></b>(2).  After pivoting to the root directory named in the program's first command-line  argument,  the
       child created by <b><a href="../man2/clone.2.html">clone</a></b>(2) then executes the program named in the remaining command-line arguments.

       We demonstrate the program by creating a directory that will serve as the new root filesystem and placing
       a copy of the (statically linked) <b><a href="../man1/busybox.1.html">busybox</a></b>(1) executable in that directory.

           $ <b>mkdir</b> <b>/tmp/rootfs</b>
           $ <b>ls</b> <b>-id</b> <b>/tmp/rootfs</b>    # Show inode number of new root directory
           319459 /tmp/rootfs
           $ <b>cp</b> <b>$(which</b> <b>busybox)</b> <b>/tmp/rootfs</b>
           $ <b>PS1='bbsh$</b> <b>'</b> <b>sudo</b> <b>./pivot_root_demo</b> <b>/tmp/rootfs</b> <b>/busybox</b> <b>sh</b>
           bbsh$ <b>PATH=/</b>
           bbsh$ <b>busybox</b> <b>ln</b> <b>busybox</b> <b>ln</b>
           bbsh$ <b>ln</b> <b>busybox</b> <b>echo</b>
           bbsh$ <b>ln</b> <b>busybox</b> <b>ls</b>
           bbsh$ <b>ls</b>
           busybox  echo     ln       ls
           bbsh$ <b>ls</b> <b>-id</b> <b>/</b>          # Compare with inode number above
           319459 /
           bbsh$ <b>echo</b> <b>'hello</b> <b>world'</b>
           hello world

   <b>Program</b> <b>source</b>

       /* pivot_root_demo.c */

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/limits.h">limits.h</a>&gt;
       #include &lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/mman.h&gt;
       #include &lt;sys/mount.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;sys/syscall.h&gt;
       #include &lt;sys/wait.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       static int
       pivot_root(const char *new_root, const char *put_old)
       {
           return syscall(SYS_pivot_root, new_root, put_old);
       }

       #define STACK_SIZE (1024 * 1024)

       static int              /* Startup function for cloned child */
       child(void *arg)
       {
           char        path[PATH_MAX];
           char        **args = arg;
           char        *new_root = args[0];
           const char  *put_old = "/oldrootfs";

           /* Ensure that 'new_root' and its parent mount don't have
              shared propagation (which would cause pivot_root() to
              return an error), and prevent propagation of mount
              events to the initial mount namespace. */

           if (mount(NULL, "/", NULL, MS_REC | MS_PRIVATE, NULL) == -1)
               err(EXIT_FAILURE, "mount-MS_PRIVATE");

           /* Ensure that 'new_root' is a mount point. */

           if (mount(new_root, new_root, NULL, MS_BIND, NULL) == -1)
               err(EXIT_FAILURE, "mount-MS_BIND");

           /* Create directory to which old root will be pivoted. */

           snprintf(path, sizeof(path), "%s/%s", new_root, put_old);
           if (mkdir(path, 0777) == -1)
               err(EXIT_FAILURE, "mkdir");

           /* And pivot the root filesystem. */

           if (pivot_root(new_root, path) == -1)
               err(EXIT_FAILURE, "pivot_root");

           /* Switch the current working directory to "/". */

           if (chdir("/") == -1)
               err(EXIT_FAILURE, "chdir");

           /* Unmount old root and remove mount point. */

           if (umount2(put_old, MNT_DETACH) == -1)
               perror("umount2");
           if (rmdir(put_old) == -1)
               perror("rmdir");

           /* Execute the command specified in argv[1]... */

           execv(args[1], &amp;args[1]);
           err(EXIT_FAILURE, "execv");
       }

       int
       main(int argc, char *argv[])
       {
           char *stack;

           /* Create a child process in a new mount namespace. */

           stack = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
           if (stack == MAP_FAILED)
               err(EXIT_FAILURE, "mmap");

           if (clone(child, stack + STACK_SIZE,
                     CLONE_NEWNS | SIGCHLD, &amp;argv[1]) == -1)
               err(EXIT_FAILURE, "clone");

           /* Parent falls through to here; wait for child. */

           if (wait(NULL) == -1)
               err(EXIT_FAILURE, "wait");

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/chdir.2.html">chdir</a></b>(2), <b><a href="../man2/chroot.2.html">chroot</a></b>(2), <b><a href="../man2/mount.2.html">mount</a></b>(2), <b><a href="../man2/stat.2.html">stat</a></b>(2), <b><a href="../man4/initrd.4.html">initrd</a></b>(4), <b><a href="../man7/mount_namespaces.7.html">mount_namespaces</a></b>(7), <b><a href="../man8/pivot_root.8.html">pivot_root</a></b>(8), <b><a href="../man8/switch_root.8.html">switch_root</a></b>(8)

Linux man-pages 6.9.1                              2024-05-02                                      <u><a href="../man2/pivot_root.2.html">pivot_root</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>