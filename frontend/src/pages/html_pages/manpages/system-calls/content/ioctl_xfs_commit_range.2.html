<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ioctl_xfs_commit_range - conditionally exchange the contents of parts of two files ioctl_xfs_start_commit</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/xfslibs-dev">xfslibs-dev_6.13.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ioctl_xfs_commit_range - conditionally exchange the contents of parts of two files ioctl_xfs_start_commit
       - prepare to exchange the contents of two files

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/ioctl.h&gt;</b>
       <b>#include</b> <b>&lt;xfs/xfs_fs.h&gt;</b>

       <b>int</b> <b>ioctl(int</b> <u>file2_fd</u><b>,</b> <b>XFS_IOC_START_COMMIT,</b> <b>struct</b> <b>xfs_commit_range</b> <b>*</b><u>arg</u><b>);</b>

       <b>int</b> <b>ioctl(int</b> <u>file2_fd</u><b>,</b> <b>XFS_IOC_COMMIT_RANGE,</b> <b>struct</b> <b>xfs_commit_range</b> <b>*</b><u>arg</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Given  a  range  of bytes in a first file <b>file1_fd</b> and a second range of bytes in a second file <b>file2_fd</b>,
       this <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) exchanges the contents of the two ranges if <b>file2_fd</b> passes certain freshness criteria.

       Before exchanging the contents, the program must call the <b>XFS_IOC_START_COMMIT</b> ioctl to sample  freshness
       data  for  <b>file2_fd</b>.   If  the  sampled  metadata  does  not  match  the  file  metadata  at commit time,
       <b>XFS_IOC_COMMIT_RANGE</b> will return <b>EBUSY</b>.

       Exchanges are atomic with regards to concurrent file operations.   Implementations  must  guarantee  that
       readers see either the old contents or the new contents in their entirety, even if the system fails.

       The system call parameters are conveyed in structures of the following form:

           struct xfs_commit_range {
               __s32    file1_fd;
               __u32    pad;
               __u64    file1_offset;
               __u64    file2_offset;
               __u64    length;
               __u64    flags;
               __u64    file2_freshness[5];
           };

       The field <u>pad</u> must be zero.

       The fields <u>file1_fd</u>, <u>file1_offset</u>, and <u>length</u> define the first range of bytes to be exchanged.

       The fields <u>file2_fd</u>, <u>file2_offset</u>, and <u>length</u> define the second range of bytes to be exchanged.

       The  field  <u>file2_freshness</u>  is  an opaque field whose contents are determined by the kernel.  These file
       attributes are used to confirm that <b>file2_fd</b> has not changed by another thread since the  current  thread
       began staging its own update.

       Both  files must be from the same filesystem mount.  If the two file descriptors represent the same file,
       the byte ranges must not overlap.  Most disk-based filesystems require that the  starts  of  both  ranges
       must  be  aligned  to  the  file block size.  If this is the case, the ends of the ranges must also be so
       aligned unless the <b>XFS_EXCHANGE_RANGE_TO_EOF</b> flag is set.

       The field <u>flags</u> control the behavior of the exchange operation.

           <b>XFS_EXCHANGE_RANGE_TO_EOF</b>
                  Ignore the <u>length</u> parameter.  All bytes in <u>file1_fd</u> from <u>file1_offset</u>  to  EOF  are  moved  to
                  <u>file2_fd</u>,  and  file2's size is set to (<u>file2_offset</u>+(<u>file1_length</u>-<u>file1_offset</u>)).  Meanwhile,
                  all bytes in file2 from <u>file2_offset</u> to EOF are moved to file1 and  file1's  size  is  set  to
                  (<u>file1_offset</u>+(<u>file2_length</u>-<u>file2_offset</u>)).

           <b>XFS_EXCHANGE_RANGE_DSYNC</b>
                  Ensure  that all modified in-core data in both file ranges and all metadata updates pertaining
                  to the exchange operation are flushed to persistent storage before the call returns.   Opening
                  either file descriptor with <b>O_SYNC</b> or <b>O_DSYNC</b> will have the same effect.

           <b>XFS_EXCHANGE_RANGE_FILE1_WRITTEN</b>
                  Only  exchange  sub-ranges  of  <u>file1_fd</u> that are known to contain data written by application
                  software.  Each sub-range may be expanded (both upwards and downwards) to align with the  file
                  allocation  unit.   For  files on the data device, this is one filesystem block.  For files on
                  the realtime device, this is the realtime extent size.  This facility can be used to implement
                  fast atomic scatter-gather writes of any complexity for software-defined  storage  targets  if
                  all writes are aligned to the file allocation unit.

           <b>XFS_EXCHANGE_RANGE_DRY_RUN</b>
                  Check the parameters and the feasibility of the operation, but do not change anything.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       Error codes can be one of, but are not limited to, the following:

       <b>EBADF</b>  <u>file1_fd</u> is not open for reading and writing or is open for append-only writes; or <u>file2_fd</u> is not
              open for reading and writing or is open for append-only writes.

       <b>EBUSY</b>  The file2 inode number and timestamps supplied do not match <u>file2_fd</u>.

       <b>EINVAL</b> The  parameters  are  not  correct  for  these  files.   This error can also appear if either file
              descriptor represents a device, FIFO, or socket.  Disk filesystems generally  require  the  offset
              and length arguments to be aligned to the fundamental block sizes of both files.

       <b>EIO</b>    An I/O error occurred.

       <b>EISDIR</b> One of the files is a directory.

       <b>ENOMEM</b> The kernel was unable to allocate sufficient memory to perform the operation.

       <b>ENOSPC</b> There is not enough free space in the filesystem exchange the contents safely.

       <b>EOPNOTSUPP</b>
              The filesystem does not support exchanging bytes between the two files.

       <b>EPERM</b>  <u>file1_fd</u> or <u>file2_fd</u> are immutable.

       <b>ETXTBSY</b>
              One of the files is a swap file.

       <b>EUCLEAN</b>
              The filesystem is corrupt.

       <b>EXDEV</b>  <u>file1_fd</u> and <u>file2_fd</u> are not on the same mounted filesystem.

</pre><h4><b>CONFORMING</b> <b>TO</b></h4><pre>
       This API is XFS-specific.

</pre><h4><b>USE</b> <b>CASES</b></h4><pre>
       Several  use cases are imagined for this system call.  Coordination between multiple threads is performed
       by the kernel.

       The first is a filesystem defragmenter, which copies the contents of a file into another file and  wishes
       to exchange the space mappings of the two files, provided that the original file has not changed.

       An example program might look like this:

           int fd = open("/some/file", O_RDWR);
           int temp_fd = open("/some", O_TMPFILE | O_RDWR);
           struct stat sb;
           struct xfs_commit_range args = {
               .flags = XFS_EXCHANGE_RANGE_TO_EOF,
           };

           /* gather file2's freshness information */
           ioctl(fd, XFS_IOC_START_COMMIT, &amp;args);
           fstat(fd, &amp;sb);

           /* make a fresh copy of the file with terrible alignment to avoid reflink */
           clone_file_range(fd, NULL, temp_fd, NULL, 1, 0);
           clone_file_range(fd, NULL, temp_fd, NULL, sb.st_size - 1, 0);

           /* commit the entire update */
           args.file1_fd = temp_fd;
           ret = ioctl(fd, XFS_IOC_COMMIT_RANGE, &amp;args);
           if (ret &amp;&amp; errno == EBUSY)
               printf("file changed while defrag was underway\n");

       The  second  is  a data storage program that wants to commit non-contiguous updates to a file atomically.
       This program cannot coordinate updates to the file and therefore relies  on  the  kernel  to  reject  the
       COMMIT_RANGE  command  if  the  file  has  been  updated by someone else.  This can be done by creating a
       temporary file, calling <b><a href="../man2/FICLONE.2.html">FICLONE</a></b>(2) to share the contents, and staging  the  updates  into  the  temporary
       file.  The <b>FULL_FILES</b> flag is recommended for this purpose.  The temporary file can be deleted or punched
       out afterwards.

       An example program might look like this:

           int fd = open("/some/file", O_RDWR);
           int temp_fd = open("/some", O_TMPFILE | O_RDWR);
           struct xfs_commit_range args = {
               .flags = XFS_EXCHANGE_RANGE_TO_EOF,
           };

           /* gather file2's freshness information */
           ioctl(fd, XFS_IOC_START_COMMIT, &amp;args);

           ioctl(temp_fd, FICLONE, fd);

           /* append 1MB of records */
           lseek(temp_fd, 0, SEEK_END);
           write(temp_fd, data1, 1000000);

           /* update record index */
           pwrite(temp_fd, data1, 600, 98765);
           pwrite(temp_fd, data2, 320, 54321);
           pwrite(temp_fd, data2, 15, 0);

           /* commit the entire update */
           args.file1_fd = temp_fd;
           ret = ioctl(fd, XFS_IOC_COMMIT_RANGE, &amp;args);
           if (ret &amp;&amp; errno == EBUSY)
               printf("file changed before commit; will roll back\n");

</pre><h4><b>NOTES</b></h4><pre>
       Some  filesystems may limit the amount of data or the number of extents that can be exchanged in a single
       call.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)

XFS                                                2024-02-18                          <u><a href="../man2/IOCTL-XFS-COMMIT-RANGE.2.html">IOCTL-XFS-COMMIT-RANGE</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>