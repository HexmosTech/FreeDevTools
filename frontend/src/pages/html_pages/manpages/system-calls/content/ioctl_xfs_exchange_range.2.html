<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ioctl_xfs_exchange_range - exchange the contents of parts of two files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/xfslibs-dev">xfslibs-dev_6.13.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ioctl_xfs_exchange_range - exchange the contents of parts of two files

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/ioctl.h&gt;</b>
       <b>#include</b> <b>&lt;xfs/xfs_fs.h&gt;</b>

       <b>int</b> <b>ioctl(int</b> <u>file2_fd</u><b>,</b> <b>XFS_IOC_EXCHANGE_RANGE,</b> <b>struct</b> <b>xfs_exchange_range</b> <b>*</b><u>arg</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Given  a  range  of bytes in a first file <b>file1_fd</b> and a second range of bytes in a second file <b>file2_fd</b>,
       this <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) exchanges the contents of the two ranges.

       Exchanges are atomic with regards to concurrent file operations.   Implementations  must  guarantee  that
       readers see either the old contents or the new contents in their entirety, even if the system fails.

       The system call parameters are conveyed in structures of the following form:

           struct xfs_exchange_range {
               __s32    file1_fd;
               __u32    pad;
               __u64    file1_offset;
               __u64    file2_offset;
               __u64    length;
               __u64    flags;
           };

       The field <u>pad</u> must be zero.

       The fields <u>file1_fd</u>, <u>file1_offset</u>, and <u>length</u> define the first range of bytes to be exchanged.

       The fields <u>file2_fd</u>, <u>file2_offset</u>, and <u>length</u> define the second range of bytes to be exchanged.

       Both  files must be from the same filesystem mount.  If the two file descriptors represent the same file,
       the byte ranges must not overlap.  Most disk-based filesystems require that the  starts  of  both  ranges
       must  be  aligned  to  the  file block size.  If this is the case, the ends of the ranges must also be so
       aligned unless the <b>XFS_EXCHANGE_RANGE_TO_EOF</b> flag is set.

       The field <u>flags</u> control the behavior of the exchange operation.

           <b>XFS_EXCHANGE_RANGE_TO_EOF</b>
                  Ignore the <u>length</u> parameter.  All bytes in <u>file1_fd</u> from <u>file1_offset</u>  to  EOF  are  moved  to
                  <u>file2_fd</u>,  and  file2's size is set to (<u>file2_offset</u>+(<u>file1_length</u>-<u>file1_offset</u>)).  Meanwhile,
                  all bytes in file2 from <u>file2_offset</u> to EOF are moved to file1 and  file1's  size  is  set  to
                  (<u>file1_offset</u>+(<u>file2_length</u>-<u>file2_offset</u>)).

           <b>XFS_EXCHANGE_RANGE_DSYNC</b>
                  Ensure  that all modified in-core data in both file ranges and all metadata updates pertaining
                  to the exchange operation are flushed to persistent storage before the call returns.   Opening
                  either file descriptor with <b>O_SYNC</b> or <b>O_DSYNC</b> will have the same effect.

           <b>XFS_EXCHANGE_RANGE_FILE1_WRITTEN</b>
                  Only  exchange  sub-ranges  of  <u>file1_fd</u> that are known to contain data written by application
                  software.  Each sub-range may be expanded (both upwards and downwards) to align with the  file
                  allocation  unit.   For  files on the data device, this is one filesystem block.  For files on
                  the realtime device, this is the realtime extent size.  This facility can be used to implement
                  fast atomic scatter-gather writes of any complexity for software-defined  storage  targets  if
                  all writes are aligned to the file allocation unit.

           <b>XFS_EXCHANGE_RANGE_DRY_RUN</b>
                  Check the parameters and the feasibility of the operation, but do not change anything.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       Error codes can be one of, but are not limited to, the following:

       <b>EBADF</b>  <u>file1_fd</u> is not open for reading and writing or is open for append-only writes; or <u>file2_fd</u> is not
              open for reading and writing or is open for append-only writes.

       <b>EINVAL</b> The  parameters  are  not  correct  for  these  files.   This error can also appear if either file
              descriptor represents a device, FIFO, or socket.  Disk filesystems generally  require  the  offset
              and length arguments to be aligned to the fundamental block sizes of both files.

       <b>EIO</b>    An I/O error occurred.

       <b>EISDIR</b> One of the files is a directory.

       <b>ENOMEM</b> The kernel was unable to allocate sufficient memory to perform the operation.

       <b>ENOSPC</b> There is not enough free space in the filesystem exchange the contents safely.

       <b>EOPNOTSUPP</b>
              The filesystem does not support exchanging bytes between the two files.

       <b>EPERM</b>  <u>file1_fd</u> or <u>file2_fd</u> are immutable.

       <b>ETXTBSY</b>
              One of the files is a swap file.

       <b>EUCLEAN</b>
              The filesystem is corrupt.

       <b>EXDEV</b>  <u>file1_fd</u> and <u>file2_fd</u> are not on the same mounted filesystem.

</pre><h4><b>CONFORMING</b> <b>TO</b></h4><pre>
       This API is XFS-specific.

</pre><h4><b>USE</b> <b>CASES</b></h4><pre>
       Several  use cases are imagined for this system call.  In all cases, application software must coordinate
       updates to the file because the exchange is performed unconditionally.

       The first is a data storage program that wants to commit non-contiguous updates to a file atomically  and
       coordinates write access to that file.  This can be done by creating a temporary file, calling <b><a href="../man2/FICLONE.2.html">FICLONE</a></b>(2)
       to  share  the  contents,  and  staging  the  updates  into  the  temporary file.  The <b>FULL_FILES</b> flag is
       recommended for this purpose.  The temporary file can be deleted or punched out afterwards.

       An example program might look like this:

           int fd = open("/some/file", O_RDWR);
           int temp_fd = open("/some", O_TMPFILE | O_RDWR);

           ioctl(temp_fd, FICLONE, fd);

           /* append 1MB of records */
           lseek(temp_fd, 0, SEEK_END);
           write(temp_fd, data1, 1000000);

           /* update record index */
           pwrite(temp_fd, data1, 600, 98765);
           pwrite(temp_fd, data2, 320, 54321);
           pwrite(temp_fd, data2, 15, 0);

           /* commit the entire update */
           struct xfs_exchange_range args = {
               .file1_fd = temp_fd,
               .flags = XFS_EXCHANGE_RANGE_TO_EOF,
           };

           ioctl(fd, XFS_IOC_EXCHANGE_RANGE, &amp;args);

       The second is a software-defined storage host (e.g. a disk jukebox) which implements an  atomic  scatter-
       gather write command.  Provided the exported disk's logical block size matches the file's allocation unit
       size,  this can be done by creating a temporary file and writing the data at the appropriate offsets.  It
       is recommended that the temporary file be truncated to the size of the regular file before any writes are
       staged to the temporary file to avoid issues with zeroing during EOF extension.  Use this call  with  the
       <b>FILE1_WRITTEN</b>  flag  to  exchange  only the file allocation units involved in the emulated device's write
       command.  The temporary file should be truncated or punched out completely before being reused  to  stage
       another write.

       An example program might look like this:

           int fd = open("/some/file", O_RDWR);
           int temp_fd = open("/some", O_TMPFILE | O_RDWR);
           struct stat sb;
           int blksz;

           fstat(fd, &amp;sb);
           blksz = sb.st_blksize;

           /* land scatter gather writes between 100fsb and 500fsb */
           pwrite(temp_fd, data1, blksz * 2, blksz * 100);
           pwrite(temp_fd, data2, blksz * 20, blksz * 480);
           pwrite(temp_fd, data3, blksz * 7, blksz * 257);

           /* commit the entire update */
           struct xfs_exchange_range args = {
               .file1_fd = temp_fd,
               .file1_offset = blksz * 100,
               .file2_offset = blksz * 100,
               .length       = blksz * 400,
               .flags        = XFS_EXCHANGE_RANGE_FILE1_WRITTEN |
                               XFS_EXCHANGE_RANGE_FILE1_DSYNC,
           };

           ioctl(fd, XFS_IOC_EXCHANGE_RANGE, &amp;args);

</pre><h4><b>NOTES</b></h4><pre>
       Some  filesystems may limit the amount of data or the number of extents that can be exchanged in a single
       call.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)

XFS                                                2024-02-10                        <u><a href="../man2/IOCTL-XFS-EXCHANGE-RANGE.2.html">IOCTL-XFS-EXCHANGE-RANGE</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>