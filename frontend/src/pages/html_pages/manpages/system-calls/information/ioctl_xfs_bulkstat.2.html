<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ioctl_xfs_bulkstat - query information for a batch of XFS inodes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/xfslibs-dev">xfslibs-dev_6.13.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ioctl_xfs_bulkstat - query information for a batch of XFS inodes

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;xfs/xfs_fs.h&gt;</b>

       <b>int</b> <b>ioctl(int</b> <u>fd</u><b>,</b> <b>XFS_IOC_BULKSTAT,</b> <b>struct</b> <b>xfs_bulkstat_req</b> <b>*</b><u>arg</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Query  stat  information  for a group of XFS inodes.  This ioctl uses <b>struct</b> <b>xfs_bulkstat_req</b> to set up a
       bulk transfer from the kernel:

           struct xfs_bulkstat_req {
                struct xfs_bulk_ireq    hdr;
                struct xfs_bulkstat     bulkstat[];
           };

       See below for the <b>xfs_bulkstat</b> structure definition.

           struct xfs_bulk_ireq {
                uint64_t                ino;
                uint32_t                flags;
                uint32_t                icount;
                uint32_t                ocount;
                uint32_t                agno;
                uint64_t                reserved[5];
           };

       <u>hdr.ino</u> should be set to the number of the first inode for which the caller wants information; or zero to
       start with the first inode in the filesystem; or a special value if <b>XFS_BULK_IREQ_SPECIAL</b> is set  in  the
       flags  field.  Note that this is a different semantic than the <b>lastip</b> in the old <b>FSBULKSTAT</b> ioctl.  After
       the call, this value will be set to the number of the next inode for which  information  could  supplied.
       This sets up the next call for an iteration loop.

       If  the  <b>XFS_BULK_IREQ_SPECIAL</b>  flag is set in the flags field, the <u>ino</u> field is interpreted according to
       the following special values:

           <b>XFS_BULK_IREQ_SPECIAL_ROOT</b>
                  Return stat information for the root directory inode.

       <u>hdr.flags</u> is a bit set of operational flags:

           <b>XFS_BULK_IREQ_AGNO</b>
                  If this is set, the call will only return  results  for  the  allocation  group  (AG)  set  in
                  <b>hdr.agno</b>.   If  <b>hdr.ino</b> is set to zero, results will be returned starting with the first inode
                  in the AG.  This flag may not be set at the same time as the <b>XFS_BULK_IREQ_SPECIAL</b> flag.

           <b>XFS_BULK_IREQ_SPECIAL</b>
                  If this is set, results will be returned for only the special inode specified in  the  <b>hdr.ino</b>
                  field.  This flag may not be set at the same time as the <b>XFS_BULK_IREQ_AGNO</b> flag.

           <b>XFS_BULK_IREQ_NREXT64</b>
                  If this is set, data fork extent count is returned via bs_extents64 field and 0 is assigned to
                  bs_extents.   Otherwise,  data  fork  extent  count  is  returned  via  bs_extents  field  and
                  bs_extents64 is assigned a value of 0. In the second case, bs_extents is set to (2^31 - 1)  if
                  data  fork  extent  count  is  larger than 2^31. This flag may be set independently of whether
                  other flags have been set.

       <u>hdr.icount</u> is the maximum number of records to return.  This should be the size of the array  that  comes
       after the header.

       <u>hdr.ocount</u> will be set to the number of records actually returned.

       <u>hdr.agno</u> is the number of the allocation group (AG) for which we want results.  If the <b>XFS_BULK_IREQ_AGNO</b>
       flag is not set, this field is ignored.

       <u>hdr.reserved</u> must be set to zero.

       <u>bulkstat</u>  is  an  array  of  <b>struct</b>  <b>xfs_bulkstat</b> which is described below.  The array must have at least
       <u>icount</u> elements.

           struct xfs_bulkstat {
                uint64_t                bs_ino;
                uint64_t                bs_size;

                uint64_t                bs_blocks;
                uint64_t                bs_xflags;

                uint64_t                bs_atime;
                uint64_t                bs_mtime;

                uint64_t                bs_ctime;
                uint64_t                bs_btime;

                uint32_t                bs_gen;
                uint32_t                bs_uid;
                uint32_t                bs_gid;
                uint32_t                bs_projectid;

                uint32_t                bs_atime_nsec;
                uint32_t                bs_mtime_nsec;
                uint32_t                bs_ctime_nsec;
                uint32_t                bs_btime_nsec;

                uint32_t                bs_blksize;
                uint32_t                bs_rdev;
                uint32_t                bs_cowextsize_blks;
                uint32_t                bs_extsize_blks;

                uint32_t                bs_nlink;
                uint32_t                bs_extents;
                uint32_t                bs_aextents;
                uint16_t                bs_version;
                uint16_t                bs_forkoff;

                uint16_t                bs_sick;
                uint16_t                bs_checked;
                uint16_t                bs_mode;
                uint16_t                bs_pad2;
                uint64_t                bs_extents64;

                uint64_t                bs_pad[6];
           };

       <u>bs_ino</u> is the inode number of this record.

       <u>bs_size</u> is the size of the file, in bytes.

       <u>bs_blocks</u> is the number of filesystem blocks allocated to this file, including metadata.

       <u>bs_xflags</u> tell us what extended flags are set this inode.  These flags  are  the  same  values  as  those
       defined in the <b>XFS</b> <b>INODE</b> <b>FLAGS</b> section of the <b><a href="../man2/ioctl_xfs_fsgetxattr.2.html">ioctl_xfs_fsgetxattr</a></b>(2) manpage.

       <u>bs_atime</u> is the last time this file was accessed, in seconds.

       <u>bs_mtime</u> is the last time the contents of this file were modified, in seconds.

       <u>bs_ctime</u> is the last time this inode record was modified, in seconds.

       <u>bs_btime</u> is the time this inode record was created, in seconds.

       <u>bs_gen</u> is the generation number of the inode record.

       <u>bs_uid</u> is the user id.

       <u>bs_gid</u> is the group id.

       <u>bs_projectid</u> is the the project id.

       <u>bs_atime_nsec</u> is the nanoseconds component of the last time this file was accessed.

       <u>bs_mtime_nsec</u> is the nanoseconds component of the last time the contents of this file were modified.

       <u>bs_ctime_nsec</u> is the nanoseconds component of the last time this inode record was modified.

       <u>bs_btime_nsec</u> is the nanoseconds component of the time this inode record was created.

       <u>bs_blksize</u> is the size of a data block for this file, in units of bytes.

       <u>bs_rdev</u> is the encoded device id if this is a special file.

       <u>bs_cowextsize_blks</u> is the Copy on Write extent size hint for this file, in units of data blocks.

       <u>bs_extsize_blks</u> is the extent size hint for this file, in units of data blocks.

       <u>bs_nlink</u> is the number of hard links to this inode.

       <u>bs_extents</u> is the number of storage mappings associated with this file's data.

       <u>bs_aextents</u> is the number of storage mappings associated with this file's extended attributes.

       <u>bs_version</u>  is  the  version  of this data structure.  This will be set to <u>XFS_BULKSTAT_VERSION_V5</u> by the
       kernel.

       <u>bs_forkoff</u> is the offset of the attribute fork in the inode record, in bytes.

       The fields <u>bs_sick</u> and <u>bs_checked</u> indicate the relative health  of  various  allocation  group  metadata.
       Please see the section <b>XFS</b> <b>INODE</b> <b>METADATA</b> <b>HEALTH</b> <b>REPORTING</b> for more information.

       <u>bs_mode</u> is the file type and mode.

       <u>bs_pad[7]</u> is zeroed.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>XFS</b> <b>INODE</b> <b>METADATA</b> <b>HEALTH</b> <b>REPORTING</b></h4><pre>
       The  online  filesystem  checking  utility  scans  inode metadata and records what it finds in the kernel
       incore state.  The following scheme is used for userspace to read the incore health status of an inode:

       • If a given sick flag is set in <u>bs_sick</u>, then that piece of metadata has been observed  to  be  damaged.
         The same bit should be set in <u>bs_checked</u>.

       • If  a  given  sick flag is set in <u>bs_checked</u> but is not set in <u>bs_sick</u>, then that piece of metadata has
         been checked and is not faulty.

       • If a given sick flag is not set in <u>bs_checked</u>, then no conclusion can be made.

       The following flags apply to these fields:

           <b>XFS_BS_SICK_INODE</b>
                  The inode's record itself.

           <b>XFS_BS_SICK_BMBTD</b>
                  File data extent mappings.

           <b>XFS_BS_SICK_BMBTA</b>
                  Extended attribute extent mappings.

           <b>XFS_BS_SICK_BMBTC</b>
                  Copy on Write staging extent mappings.

           <b>XFS_BS_SICK_DIR</b>
                  Directory information.

           <b>XFS_BS_SICK_XATTR</b>
                  Extended attribute data.

           <b>XFS_BS_SICK_SYMLINK</b>
                  Symbolic link target.

           <b>XFS_BS_SICK_PARENT</b>
                  Parent pointers.

           <b>XFS_BS_SICK_DIRTREE</b>
                  Directory is the source of corruption in the directory tree.

</pre><h4><b>ERRORS</b></h4><pre>
       Error codes can be one of, but are not limited to, the following:

       <b>EFAULT</b> The kernel was not able to copy into the userspace buffer.

       <b>EFSBADCRC</b>
              Metadata checksum validation failed while performing the query.

       <b>EFSCORRUPTED</b>
              Metadata corruption was encountered while performing the query.

       <b>EINVAL</b> One of the arguments was not valid.

       <b>EIO</b>    An I/O error was encountered while performing the query.

       <b>ENOMEM</b> There was insufficient memory to perform the query.

</pre><h4><b>CONFORMING</b> <b>TO</b></h4><pre>
       This API is specific to XFS filesystem on the Linux kernel.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2), <b><a href="../man2/ioctl_xfs_fsgetxattr.2.html">ioctl_xfs_fsgetxattr</a></b>(2)

XFS                                                2019-05-23                              <u><a href="../man2/IOCTL-XFS-BULKSTAT.2.html">IOCTL-XFS-BULKSTAT</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>