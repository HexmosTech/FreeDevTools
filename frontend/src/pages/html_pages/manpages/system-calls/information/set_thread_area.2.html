<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>get_thread_area, set_thread_area - manipulate thread-local storage information</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       get_thread_area, set_thread_area - manipulate thread-local storage information

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/syscall.h&gt;</b>     /* Definition of <b>SYS_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>#if</b> <b>defined</b> <b>__i386__</b> <b>||</b> <b>defined</b> <b>__x86_64__</b>
       <b>#</b> <b>include</b> <b>&lt;asm/ldt.h&gt;</b>        /* Definition of <b>struct</b> <b>user_desc</b> */

       <b>int</b> <b>syscall(SYS_get_thread_area,</b> <b>struct</b> <b>user_desc</b> <b>*</b><u>u_info</u><b>);</b>
       <b>int</b> <b>syscall(SYS_set_thread_area,</b> <b>struct</b> <b>user_desc</b> <b>*</b><u>u_info</u><b>);</b>

       <b>#elif</b> <b>defined</b> <b>__m68k__</b>

       <b>int</b> <b>syscall(SYS_get_thread_area);</b>
       <b>int</b> <b>syscall(SYS_set_thread_area,</b> <b>unsigned</b> <b>long</b> <u>tp</u><b>);</b>

       <b>#elif</b> <b>defined</b> <b>__mips__</b> <b>||</b> <b>defined</b> <b>__csky__</b>

       <b>int</b> <b>syscall(SYS_set_thread_area,</b> <b>unsigned</b> <b>long</b> <u>addr</u><b>);</b>

       <b>#endif</b>

       <u>Note</u>: glibc provides no wrappers for these system calls, necessitating the use of <b><a href="../man2/syscall.2.html">syscall</a></b>(2).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  calls  provide  architecture-specific  support  for a thread-local storage implementation.  At the
       moment, <b>set_thread_area</b>() is available on m68k, MIPS, C-SKY, and x86 (both 32-bit and  64-bit  variants);
       <b>get_thread_area</b>() is available on m68k and x86.

       On  m68k,  MIPS  and  C-SKY,  <b>set_thread_area</b>()  allows  storing an arbitrary pointer (provided in the <b>tp</b>
       argument on m68k and in the <b>addr</b> argument on MIPS and C-SKY) in the kernel data structure associated with
       the calling thread; this pointer can later be retrieved  using  <b>get_thread_area</b>()  (see  also  NOTES  for
       information regarding obtaining the thread pointer on MIPS).

       On  x86,  Linux dedicates three global descriptor table (GDT) entries for thread-local storage.  For more
       information about the GDT, see the Intel Software Developer's Manual or the AMD Architecture  Programming
       Manual.

       Both of these system calls take an argument that is a pointer to a structure of the following type:

           struct user_desc {
               unsigned int  entry_number;
               unsigned int  base_addr;
               unsigned int  limit;
               unsigned int  seg_32bit:1;
               unsigned int  contents:2;
               unsigned int  read_exec_only:1;
               unsigned int  limit_in_pages:1;
               unsigned int  seg_not_present:1;
               unsigned int  useable:1;
           #ifdef __x86_64__
               unsigned int  lm:1;
           #endif
           };

       <b>get_thread_area</b>()  reads  the  GDT  entry  indicated by <u>u_info-&gt;entry_number</u> and fills in the rest of the
       fields in <u>u_info</u>.

       <b>set_thread_area</b>() sets a TLS entry in the GDT.

       The TLS array entry set by <b>set_thread_area</b>() corresponds to the value of <u>u_info-&gt;entry_number</u>  passed  in
       by  the  user.   If  this  value  is in bounds, <b>set_thread_area</b>() writes the TLS descriptor pointed to by
       <u>u_info</u> into the thread's TLS array.

       When <b>set_thread_area</b>() is passed  an  <u>entry_number</u>  of  -1,  it  searches  for  a  free  TLS  entry.   If
       <b>set_thread_area</b>()  finds  a  free TLS entry, the value of <u>u_info-&gt;entry_number</u> is set upon return to show
       which entry was changed.

       A <u>user_desc</u> is considered "empty" if <u>read_exec_only</u> and <u>seg_not_present</u> are set to 1 and all of the other
       fields are 0.  If an "empty" descriptor is passed to <b>set_thread_area</b>(), the corresponding TLS entry  will
       be cleared.  See BUGS for additional details.

       Since  Linux  3.19,  <b>set_thread_area</b>()  cannot be used to write non-present segments, 16-bit segments, or
       code segments, although clearing a segment is still acceptable.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On x86, these system calls return 0 on success, and -1 on failure, with <u>errno</u> set to indicate the error.

       On C-SKY, MIPS and m68k, <b>set_thread_area</b>() always returns 0.   On  m68k,  <b>get_thread_area</b>()  returns  the
       thread area pointer value (previously set via <b>set_thread_area</b>()).

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> <u>u_info</u> is an invalid pointer.

       <b>EINVAL</b> <u>u_info-&gt;entry_number</u> is out of bounds.

       <b>ENOSYS</b> <b>get_thread_area</b>() or <b>set_thread_area</b>() was invoked as a 64-bit system call.

       <b>ESRCH</b>  (<b>set_thread_area</b>()) A free TLS entry could not be located.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>set_thread_area</b>()
              Linux 2.5.29.

       <b>get_thread_area</b>()
              Linux 2.5.32.

</pre><h4><b>NOTES</b></h4><pre>
       These system calls are generally intended for use only by threading libraries.

       <b><a href="../man2/arch_prctl.2.html">arch_prctl</a></b>(2)  can interfere with <b>set_thread_area</b>() on x86.  See <b><a href="../man2/arch_prctl.2.html">arch_prctl</a></b>(2) for more details.  This is
       not normally a problem, as <b><a href="../man2/arch_prctl.2.html">arch_prctl</a></b>(2) is normally used only by 64-bit programs.

       On MIPS, the current value of the thread area pointer can be obtained using the instruction:

           rdhwr dest, $29

       This instruction traps and is handled by kernel.

</pre><h4><b>BUGS</b></h4><pre>
       On 64-bit kernels before Linux 3.19, one of the padding bits in <u>user_desc</u>,  if  set,  would  prevent  the
       descriptor  from being considered empty (see <b><a href="../man2/modify_ldt.2.html">modify_ldt</a></b>(2)).  As a result, the only reliable way to clear
       a TLS entry is to use <b><a href="../man3/memset.3.html">memset</a></b>(3) to zero the entire <u>user_desc</u> structure, including padding bits, and  then
       to  set  the  <u>read_exec_only</u> and <u>seg_not_present</u> bits.  On Linux 3.19, a <u>user_desc</u> consisting entirely of
       zeros except for <u>entry_number</u> will also be interpreted as a request  to  clear  a  TLS  entry,  but  this
       behaved differently on older kernels.

       Prior to Linux 3.19, the DS and ES segment registers must not reference TLS entries.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/arch_prctl.2.html">arch_prctl</a></b>(2), <b><a href="../man2/modify_ldt.2.html">modify_ldt</a></b>(2), <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2) (<b>PTRACE_GET_THREAD_AREA</b> and <b>PTRACE_SET_THREAD_AREA</b>)

Linux man-pages 6.9.1                              2024-05-02                                 <u><a href="../man2/set_thread_area.2.html">set_thread_area</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>