<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pipe, pipe2 - create pipe</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pipe, pipe2 - create pipe

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>int</b> <b>pipe(int</b> <u>pipefd</u><b>[2]);</b>

       <b>#define</b> <b>_GNU_SOURCE</b>             /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;</b>              /* Definition of <b>O_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>int</b> <b>pipe2(int</b> <u>pipefd</u><b>[2],</b> <b>int</b> <u>flags</u><b>);</b>

       /* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64, pipe() has the
          following prototype; see VERSIONS */

       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>struct</b> <b>fd_pair</b> <b>{</b>
           <b>long</b> <b>fd[2];</b>
       <b>};</b>
       <b>struct</b> <b>fd_pair</b> <b>pipe(void);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>pipe</b>()  creates  a  pipe,  a unidirectional data channel that can be used for interprocess communication.
       The array <u>pipefd</u> is used to return two file descriptors referring to the ends  of  the  pipe.   <u>pipefd[0]</u>
       refers  to the read end of the pipe.  <u>pipefd[1]</u> refers to the write end of the pipe.  Data written to the
       write end of the pipe is buffered by the kernel until it is read from the read  end  of  the  pipe.   For
       further details, see <b><a href="../man7/pipe.7.html">pipe</a></b>(7).

       If  <u>flags</u> is 0, then <b>pipe2</b>() is the same as <b>pipe</b>().  The following values can be bitwise ORed in <u>flags</u> to
       obtain different behavior:

       <b>O_CLOEXEC</b>
              Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the two new file descriptors.  See the  description  of
              the same flag in <b><a href="../man2/open.2.html">open</a></b>(2) for reasons why this may be useful.

       <b>O_DIRECT</b> (since Linux 3.4)
              Create  a  pipe  that performs I/O in "packet" mode.  Each <b><a href="../man2/write.2.html">write</a></b>(2) to the pipe is dealt with as a
              separate packet, and <b><a href="../man2/read.2.html">read</a></b>(2)s from the pipe will read one packet at a time.   Note  the  following
              points:

              •  Writes  of  greater than <b>PIPE_BUF</b> bytes (see <b><a href="../man7/pipe.7.html">pipe</a></b>(7)) will be split into multiple packets.  The
                 constant <b>PIPE_BUF</b> is defined in <u>&lt;limits.h&gt;</u>.

              •  If a <b><a href="../man2/read.2.html">read</a></b>(2) specifies a buffer size that is smaller than the next packet, then  the  requested
                 number  of  bytes  are  read,  and  the excess bytes in the packet are discarded.  Specifying a
                 buffer size of <b>PIPE_BUF</b> will be sufficient to  read  the  largest  possible  packets  (see  the
                 previous point).

              •  Zero-length  packets  are  not supported.  (A <b><a href="../man2/read.2.html">read</a></b>(2) that specifies a buffer size of zero is a
                 no-op, and returns 0.)

              Older kernels that do not support this flag will indicate this via an <b>EINVAL</b> error.

              Since Linux 4.5, it is possible to change the <b>O_DIRECT</b> setting of a  pipe  file  descriptor  using
              <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2).

       <b>O_NONBLOCK</b>
              Set  the  <b>O_NONBLOCK</b>  file  status  flag on the open file descriptions referred to by the new file
              descriptors.  Using this flag saves extra calls to <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) to achieve the same result.

       <b>O_NOTIFICATION_PIPE</b>
              Since Linux 5.8, general notification mechanism is built on the  top  of  the  pipe  where  kernel
              splices  notification messages into pipes opened by user space.  The owner of the pipe has to tell
              the kernel which sources of events to watch and filters  can  also  be  applied  to  select  which
              subevents should be placed into the pipe.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  zero is returned.  On error, -1 is returned, <u>errno</u> is set to indicate the error, and <u>pipefd</u>
       is left unchanged.

       On Linux (and other systems), <b>pipe</b>() does not modify <u>pipefd</u> on failure.  A requirement standardizing this
       behavior was added in POSIX.1-2008 TC2.  The Linux-specific <b>pipe2</b>() system call likewise does not  modify
       <u>pipefd</u> on failure.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> <u>pipefd</u> is not valid.

       <b>EINVAL</b> (<b>pipe2</b>()) Invalid value in <u>flags</u>.

       <b>EMFILE</b> The per-process limit on the number of open file descriptors has been reached.

       <b>ENFILE</b> The system-wide limit on the total number of open files has been reached.

       <b>ENFILE</b> The  user  hard limit on memory that can be allocated for pipes has been reached and the caller is
              not privileged; see <b><a href="../man7/pipe.7.html">pipe</a></b>(7).

       <b>ENOPKG</b> (<b>pipe2</b>())   <b>O_NOTIFICATION_PIPE</b>   was   passed   in   <u>flags</u>   and   support   for    notifications
              (<b>CONFIG_WATCH_QUEUE</b>) is not compiled into the kernel.

</pre><h4><b>VERSIONS</b></h4><pre>
       The  System  V  ABI on some architectures allows the use of more than one register for returning multiple
       values; several architectures (namely, Alpha,  IA-64,  MIPS,  SuperH,  and  SPARC/SPARC64)  (ab)use  this
       feature  in  order  to implement the <b>pipe</b>() system call in a functional manner: the call doesn't take any
       arguments and returns a pair of file descriptors as the  return  value  on  success.   The  glibc  <b>pipe</b>()
       wrapper  function transparently deals with this.  See <b><a href="../man2/syscall.2.html">syscall</a></b>(2) for information regarding registers used
       for storing second file descriptor.

</pre><h4><b>STANDARDS</b></h4><pre>
       <b>pipe</b>() POSIX.1-2008.

       <b>pipe2</b>()
              Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>pipe</b>() POSIX.1-2001.

       <b>pipe2</b>()
              Linux 2.6.27, glibc 2.9.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following program creates a pipe, and then <b><a href="../man2/fork.2.html">fork</a></b>(2)s to create a child process; the child  inherits  a
       duplicate  set  of  file descriptors that refer to the same pipe.  After the <b><a href="../man2/fork.2.html">fork</a></b>(2), each process closes
       the file descriptors that it doesn't need for the pipe (see <b><a href="../man7/pipe.7.html">pipe</a></b>(7)).  The parent then writes the  string
       contained in the program's command-line argument to the pipe, and the child reads this string a byte at a
       time from the pipe and echoes it on standard output.

   <b>Program</b> <b>source</b>
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;sys/wait.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           int    pipefd[2];
           char   buf;
           pid_t  cpid;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s &lt;string&gt;\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (pipe(pipefd) == -1) {
               perror("pipe");
               exit(EXIT_FAILURE);
           }

           cpid = fork();
           if (cpid == -1) {
               perror("fork");
               exit(EXIT_FAILURE);
           }

           if (cpid == 0) {    /* Child reads from pipe */
               close(pipefd[1]);          /* Close unused write end */

               while (read(pipefd[0], &amp;buf, 1) &gt; 0)
                   write(STDOUT_FILENO, &amp;buf, 1);

               write(STDOUT_FILENO, "\n", 1);
               close(pipefd[0]);
               _exit(EXIT_SUCCESS);

           } else {            /* Parent writes argv[1] to pipe */
               close(pipefd[0]);          /* Close unused read end */
               write(pipefd[1], argv[1], strlen(argv[1]));
               close(pipefd[1]);          /* Reader will see EOF */
               wait(NULL);                /* Wait for child */
               exit(EXIT_SUCCESS);
           }
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/fork.2.html">fork</a></b>(2), <b><a href="../man2/read.2.html">read</a></b>(2), <b><a href="../man2/socketpair.2.html">socketpair</a></b>(2), <b><a href="../man2/splice.2.html">splice</a></b>(2), <b><a href="../man2/tee.2.html">tee</a></b>(2), <b><a href="../man2/vmsplice.2.html">vmsplice</a></b>(2), <b><a href="../man2/write.2.html">write</a></b>(2), <b><a href="../man3/popen.3.html">popen</a></b>(3), <b><a href="../man7/pipe.7.html">pipe</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                            <u><a href="../man2/pipe.2.html">pipe</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>