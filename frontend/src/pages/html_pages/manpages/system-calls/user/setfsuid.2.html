<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>setfsuid - set user identity used for filesystem checks</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       setfsuid - set user identity used for filesystem checks

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/fsuid.h&gt;</b>

       <b>[[deprecated]]</b> <b>int</b> <b>setfsuid(uid_t</b> <u>fsuid</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       On  Linux,  a  process  has  both  a  filesystem  user ID and an effective user ID.  The (Linux-specific)
       filesystem user ID is used  for  permissions  checking  when  accessing  filesystem  objects,  while  the
       effective user ID is used for various other kinds of permissions checks (see <b><a href="../man7/credentials.7.html">credentials</a></b>(7)).

       Normally,  the  value  of the process's filesystem user ID is the same as the value of its effective user
       ID.  This is so, because whenever a process's effective user ID is changed, the kernel also  changes  the
       filesystem  user  ID  to  be the same as the new value of the effective user ID.  A process can cause the
       value of its filesystem user ID to diverge from its effective user ID by using <b>setfsuid</b>() to  change  its
       filesystem user ID to the value given in <u>fsuid</u>.

       Explicit  calls  to <b>setfsuid</b>() and <b><a href="../man2/setfsgid.2.html">setfsgid</a></b>(2) are (were) usually used only by programs such as the Linux
       NFS server that need to change what user and group ID is used for file  access  without  a  corresponding
       change  in the real and effective user and group IDs.  A change in the normal user IDs for a program such
       as the NFS server is (was) a security hole that can expose it to unwanted signals.  (However, this  issue
       is historical; see below.)

       <b>setfsuid</b>()  will succeed only if the caller is the superuser or if <u>fsuid</u> matches either the caller's real
       user ID, effective user ID, saved set-user-ID, or current filesystem user ID.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On both success and failure, this call returns the previous filesystem user ID of the caller.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 1.2.

       At the time when this system call was introduced, one process could send a signal to another process with
       the same effective user ID.  This meant that if a privileged process changed its effective  user  ID  for
       the  purpose  of  file  permission checking, then it could become vulnerable to receiving signals sent by
       another (unprivileged) process with the same user ID.  The filesystem user ID attribute was thus added to
       allow a process to change its user ID for the purposes of file permission checking without  at  the  same
       time  becoming  vulnerable to receiving unwanted signals.  Since Linux 2.0, signal permission handling is
       different (see <b><a href="../man2/kill.2.html">kill</a></b>(2)), with the result that a process can change its effective user  ID  without  being
       vulnerable  to  receiving  signals  from  unwanted  processes.  Thus, <b>setfsuid</b>() is nowadays unneeded and
       should be avoided in new applications (likewise for <b><a href="../man2/setfsgid.2.html">setfsgid</a></b>(2)).

       The original Linux <b>setfsuid</b>() system call supported only 16-bit user IDs.  Subsequently, Linux 2.4  added
       <b>setfsuid32</b>()  supporting  32-bit IDs.  The glibc <b>setfsuid</b>() wrapper function transparently deals with the
       variation across kernel versions.

   <b>C</b> <b>library/kernel</b> <b>differences</b>
       In glibc 2.15 and earlier, when the wrapper for this system call determines that the  argument  can't  be
       passed  to  the  kernel without integer truncation (because the kernel is old and does not support 32-bit
       user IDs), it will return -1 and set <u>errno</u> to <b>EINVAL</b> without attempting the system call.

</pre><h4><b>BUGS</b></h4><pre>
       No error indications of any kind are returned to the caller,  and  the  fact  that  both  successful  and
       unsuccessful  calls  return  the  same  value  makes it impossible to directly determine whether the call
       succeeded or failed.  Instead, the caller must resort to looking at the return value from a further  call
       such  as  <u>setfsuid(-1)</u>  (which will always fail), in order to determine if a preceding call to <b>setfsuid</b>()
       changed the filesystem user ID.  At the very least, <b>EPERM</b> should be returned when the call fails (because
       the caller lacks the <b>CAP_SETUID</b> capability).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/kill.2.html">kill</a></b>(2), <b><a href="../man2/setfsgid.2.html">setfsgid</a></b>(2), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/credentials.7.html">credentials</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                        <u><a href="../man2/setfsuid.2.html">setfsuid</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>