<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>setuid - set user identity</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       setuid - set user identity

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>int</b> <b>setuid(uid_t</b> <u>uid</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>setuid</b>()  sets  the effective user ID of the calling process.  If the calling process is privileged (more
       precisely: if the process has the <b>CAP_SETUID</b> capability in its user namespace), the real  UID  and  saved
       set-user-ID are also set.

       Under  Linux,  <b>setuid</b>()  is  implemented  like the POSIX version with the <b>_POSIX_SAVED_IDS</b> feature.  This
       allows a set-user-ID (other than root) program to drop all of its user privileges, do some  un-privileged
       work, and then reengage the original effective user ID in a secure manner.

       If  the  user is root or the program is set-user-ID-root, special care must be taken: <b>setuid</b>() checks the
       effective user ID of the caller and if it is the superuser, all process-related user ID's are set to <u>uid</u>.
       After this has occurred, it is impossible for the program to regain root privileges.

       Thus, a set-user-ID-root program wishing to temporarily drop root privileges, assume the identity  of  an
       unprivileged  user,  and  then  regain root privileges afterward cannot use <b>setuid</b>().  You can accomplish
       this with <b><a href="../man2/seteuid.2.html">seteuid</a></b>(2).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, zero is returned.  On error, -1 is returned, and <u>errno</u> is set to indicate the error.

       <u>Note</u>: there are cases where <b>setuid</b>() can fail even when the caller is UID 0; it is a grave security error
       to omit checking for a failure return from <b>setuid</b>().

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EAGAIN</b> The call would change the caller's real UID (i.e., <u>uid</u> does not match the caller's real UID),  but
              there was a temporary failure allocating the necessary kernel data structures.

       <b>EAGAIN</b> <u>uid</u>  does  not  match  the  real  user  ID  of  the caller and this call would bring the number of
              processes belonging to the real user ID <u>uid</u> over the caller's <b>RLIMIT_NPROC</b> resource limit.   Since
              Linux 3.1, this error case no longer occurs (but robust applications should check for this error);
              see the description of <b>EAGAIN</b> in <b><a href="../man2/execve.2.html">execve</a></b>(2).

       <b>EINVAL</b> The user ID specified in <u>uid</u> is not valid in this user namespace.

       <b>EPERM</b>  The  user is not privileged (Linux: does not have the <b>CAP_SETUID</b> capability in its user namespace)
              and <u>uid</u> does not match the real UID or saved set-user-ID of the calling process.

</pre><h4><b>VERSIONS</b></h4><pre>
   <b>C</b> <b>library/kernel</b> <b>differences</b>
       At the kernel level, user IDs and group IDs are a per-thread attribute.  However, POSIX requires that all
       threads in a process share the same credentials.  The NPTL threading  implementation  handles  the  POSIX
       requirements  by  providing  wrapper  functions for the various system calls that change process UIDs and
       GIDs.  These wrapper functions (including the one for <b>setuid</b>()) employ a signal-based technique to ensure
       that when one thread changes credentials, all of the other threads  in  the  process  also  change  their
       credentials.  For details, see <b><a href="../man7/nptl.7.html">nptl</a></b>(7).

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001, SVr4.

       Not quite compatible with the 4.4BSD call, which sets all of the real, saved, and effective user IDs.

       The  original  Linux  <b>setuid</b>() system call supported only 16-bit user IDs.  Subsequently, Linux 2.4 added
       <b>setuid32</b>() supporting 32-bit IDs.  The glibc <b>setuid</b>()  wrapper  function  transparently  deals  with  the
       variation across kernel versions.

</pre><h4><b>NOTES</b></h4><pre>
       Linux  has  the concept of the filesystem user ID, normally equal to the effective user ID.  The <b>setuid</b>()
       call also sets the filesystem user ID of the calling process.  See <b><a href="../man2/setfsuid.2.html">setfsuid</a></b>(2).

       If <u>uid</u> is different from the old effective UID, the process will be forbidden from leaving core dumps.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/getuid.2.html">getuid</a></b>(2), <b><a href="../man2/seteuid.2.html">seteuid</a></b>(2), <b><a href="../man2/setfsuid.2.html">setfsuid</a></b>(2), <b><a href="../man2/setreuid.2.html">setreuid</a></b>(2), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/credentials.7.html">credentials</a></b>(7), <b><a href="../man7/user_namespaces.7.html">user_namespaces</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                          <u><a href="../man2/setuid.2.html">setuid</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>