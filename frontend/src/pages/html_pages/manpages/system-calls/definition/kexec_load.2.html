<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kexec_load, kexec_file_load - load a new kernel for later execution</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       kexec_load, kexec_file_load - load a new kernel for later execution

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/linux/kexec.h">linux/kexec.h</a>&gt;</b>      /* Definition of <b>KEXEC_*</b> constants */
       <b>#include</b> <b>&lt;sys/syscall.h&gt;</b>      /* Definition of <b>SYS_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>long</b> <b>syscall(SYS_kexec_load,</b> <b>unsigned</b> <b>long</b> <u>entry</u><b>,</b>
                    <b>unsigned</b> <b>long</b> <u>nr_segments</u><b>,</b> <b>struct</b> <b>kexec_segment</b> <b>*</b><u>segments</u><b>,</b>
                    <b>unsigned</b> <b>long</b> <u>flags</u><b>);</b>
       <b>long</b> <b>syscall(SYS_kexec_file_load,</b> <b>int</b> <u>kernel_fd</u><b>,</b> <b>int</b> <u>initrd_fd</u><b>,</b>
                    <b>unsigned</b> <b>long</b> <u>cmdline_len</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>cmdline</u><b>,</b>
                    <b>unsigned</b> <b>long</b> <u>flags</u><b>);</b>

       <u>Note</u>: glibc provides no wrappers for these system calls, necessitating the use of <b><a href="../man2/syscall.2.html">syscall</a></b>(2).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>kexec_load</b>() system call loads a new kernel that can be executed later by <b><a href="../man2/reboot.2.html">reboot</a></b>(2).

       The  <u>flags</u>  argument  is a bit mask that controls the operation of the call.  The following values can be
       specified in <u>flags</u>:

       <b>KEXEC_ON_CRASH</b> (since Linux 2.6.13)
              Execute the new kernel automatically on a system crash.  This "crash kernel"  is  loaded  into  an
              area  of reserved memory that is determined at boot time using the <u>crashkernel</u> kernel command-line
              parameter.  The location of this reserved memory is exported to user  space  via  the  <u><a href="file:/proc/iomem">/proc/iomem</a></u>
              file,  in  an  entry  labeled  "Crash  kernel".   A user-space application can parse this file and
              prepare a list of segments (see below) that specify this reserved memory as destination.  If  this
              flag  is  specified,  the kernel checks that the target segments specified in <u>segments</u> fall within
              the reserved region.

       <b>KEXEC_PRESERVE_CONTEXT</b> (since Linux 2.6.27)
              Preserve the system hardware and software states before executing the new kernel.  This  could  be
              used  for  system  suspend.   This  flag  is  available  only  if  the  kernel was configured with
              <b>CONFIG_KEXEC_JUMP</b>, and is effective only if <u>nr_segments</u> is greater than 0.

       The high-order bits (corresponding to the mask 0xffff0000) of <u>flags</u> contain the architecture of  the  to-
       be-executed kernel.  Specify (OR) the constant <b>KEXEC_ARCH_DEFAULT</b> to use the current architecture, or one
       of    the   following   architecture   constants   <b>KEXEC_ARCH_386</b>,   <b>KEXEC_ARCH_68K</b>,   <b>KEXEC_ARCH_X86_64</b>,
       <b>KEXEC_ARCH_PPC</b>,  <b>KEXEC_ARCH_PPC64</b>,  <b>KEXEC_ARCH_IA_64</b>,  <b>KEXEC_ARCH_ARM</b>,  <b>KEXEC_ARCH_S390</b>,   <b>KEXEC_ARCH_SH</b>,
       <b>KEXEC_ARCH_MIPS</b>, and <b>KEXEC_ARCH_MIPS_LE</b>.  The architecture must be executable on the CPU of the system.

       The  <u>entry</u>  argument  is the physical entry address in the kernel image.  The <u>nr_segments</u> argument is the
       number of segments pointed to by the <u>segments</u> pointer; the kernel imposes an (arbitrary) limit of  16  on
       the  number  of segments.  The <u>segments</u> argument is an array of <u>kexec_segment</u> structures which define the
       kernel layout:

           struct kexec_segment {
               void   *buf;        /* Buffer in user space */
               size_t  bufsz;      /* Buffer length in user space */
               void   *mem;        /* Physical address of kernel */
               size_t  memsz;      /* Physical address length */
           };

       The kernel image defined by <u>segments</u> is copied from the calling process into the kernel either in regular
       memory or in reserved memory (if <b>KEXEC_ON_CRASH</b> is set).  The kernel first performs various sanity checks
       on the information passed in <u>segments</u>.  If these checks pass, the  kernel  copies  the  segment  data  to
       kernel memory.  Each segment specified in <u>segments</u> is copied as follows:

       •  <u>buf</u> and <u>bufsz</u> identify a memory region in the caller's virtual address space that is the source of the
          copy.  The value in <u>bufsz</u> may not exceed the value in the <u>memsz</u> field.

       •  <u>mem</u>  and  <u>memsz</u> specify a physical address range that is the target of the copy.  The values specified
          in both fields must be multiples of the system page size.

       •  <u>bufsz</u> bytes are copied from the source buffer to the target kernel buffer.   If  <u>bufsz</u>  is  less  than
          <u>memsz</u>, then the excess bytes in the kernel buffer are zeroed out.

       In  case  of a normal kexec (i.e., the <b>KEXEC_ON_CRASH</b> flag is not set), the segment data is loaded in any
       available memory and is moved to the final destination at kexec reboot  time  (e.g.,  when  the  <b><a href="../man8/kexec.8.html">kexec</a></b>(8)
       command is executed with the <u>-e</u> option).

       In  case of kexec on panic (i.e., the <b>KEXEC_ON_CRASH</b> flag is set), the segment data is loaded to reserved
       memory at the time of the call, and, after a crash, the kexec mechanism simply  passes  control  to  that
       kernel.

       The <b>kexec_load</b>() system call is available only if the kernel was configured with <b>CONFIG_KEXEC</b>.

   <b>kexec_file_load()</b>
       The  <b>kexec_file_load</b>() system call is similar to <b>kexec_load</b>(), but it takes a different set of arguments.
       It reads the kernel to be loaded from the file referred to by the  file  descriptor  <u>kernel_fd</u>,  and  the
       initrd  (initial  RAM  disk)  to  be  loaded from file referred to by the file descriptor <u>initrd_fd</u>.  The
       <u>cmdline</u> argument is a pointer to  a  buffer  containing  the  command  line  for  the  new  kernel.   The
       <u>cmdline_len</u>  argument  specifies  size  of  the  buffer.  The last byte in the buffer must be a null byte
       ('\0').

       The <u>flags</u> argument is a bit mask which modifies the behavior of the call.  The following  values  can  be
       specified in <u>flags</u>:

       <b>KEXEC_FILE_UNLOAD</b>
              Unload the currently loaded kernel.

       <b>KEXEC_FILE_ON_CRASH</b>
              Load  the  new  kernel in the memory region reserved for the crash kernel (as for <b>KEXEC_ON_CRASH</b>).
              This kernel is booted if the currently running kernel crashes.

       <b>KEXEC_FILE_NO_INITRAMFS</b>
              Loading initrd/initramfs is optional.  Specify this flag if no initramfs is being loaded.  If this
              flag is set, the value passed in <u>initrd_fd</u> is ignored.

       The <b>kexec_file_load</b>() system call was added to provide support for systems where "kexec"  loading  should
       be  restricted  to  only  kernels  that are signed.  This system call is available only if the kernel was
       configured with <b>CONFIG_KEXEC_FILE</b>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, these system calls returns 0.  On error, -1 is returned and <u>errno</u>  is  set  to  indicate  the
       error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EADDRNOTAVAIL</b>
              The  <b>KEXEC_ON_CRASH</b>  flags  was specified, but the region specified by the <u>mem</u> and <u>memsz</u> fields of
              one of the <u>segments</u> entries lies outside the range of memory reserved for the crash kernel.

       <b>EADDRNOTAVAIL</b>
              The value in a <u>mem</u> or <u>memsz</u> field in one of the <u>segments</u> entries is not a multiple of  the  system
              page size.

       <b>EBADF</b>  <u>kernel_fd</u> or <u>initrd_fd</u> is not a valid file descriptor.

       <b>EBUSY</b>  Another crash kernel is already being loaded or a crash kernel is already in use.

       <b>EINVAL</b> <u>flags</u> is invalid.

       <b>EINVAL</b> The  value  of a <u>bufsz</u> field in one of the <u>segments</u> entries exceeds the value in the corresponding
              <u>memsz</u> field.

       <b>EINVAL</b> <u>nr_segments</u> exceeds <b>KEXEC_SEGMENT_MAX</b> (16).

       <b>EINVAL</b> Two or more of the kernel target buffers overlap.

       <b>EINVAL</b> The value in <u>cmdline[cmdline_len-1]</u> is not '\0'.

       <b>EINVAL</b> The file referred to by <u>kernel_fd</u> or <u>initrd_fd</u> is empty (length zero).

       <b>ENOEXEC</b>
              <u>kernel_fd</u> does not refer to an open file, or the kernel can't load this file.  Currently, the file
              must be a bzImage and contain an x86 kernel that is loadable above 4 GiB in memory (see the kernel
              source file <u>Documentation/x86/boot.txt</u>).

       <b>ENOMEM</b> Could not allocate memory.

       <b>EPERM</b>  The caller does not have the <b>CAP_SYS_BOOT</b> capability.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>kexec_load</b>()
              Linux 2.6.13.

       <b>kexec_file_load</b>()
              Linux 3.17.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/reboot.2.html">reboot</a></b>(2), <b><a href="../man2/syscall.2.html">syscall</a></b>(2), <b><a href="../man8/kexec.8.html">kexec</a></b>(8)

       The kernel source files <u>Documentation/kdump/kdump.txt</u> and <u>Documentation/admin-guide/kernel-parameters.txt</u>

Linux man-pages 6.9.1                              2024-06-15                                      <u><a href="../man2/kexec_load.2.html">kexec_load</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>