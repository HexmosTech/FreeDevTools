<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>spu_run - execute an SPU context</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       spu_run - execute an SPU context

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/spu.h&gt;</b>          /* Definition of <b>SPU_*</b> constants */
       <b>#include</b> <b>&lt;sys/syscall.h&gt;</b>      /* Definition of <b>SYS_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>int</b> <b>syscall(SYS_spu_run,</b> <b>int</b> <u>fd</u><b>,</b> <b>uint32_t</b> <b>*</b><u>npc</u><b>,</b> <b>uint32_t</b> <b>*</b><u>event</u><b>);</b>

       <u>Note</u>: glibc provides no wrapper for <b>spu_run</b>(), necessitating the use of <b><a href="../man2/syscall.2.html">syscall</a></b>(2).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>spu_run</b>()  system  call  is  used  on  PowerPC  machines  that  implement  the Cell Broadband Engine
       Architecture in order to access Synergistic Processor Units (SPUs).  The <u>fd</u> argument is a file descriptor
       returned by <b><a href="../man2/spu_create.2.html">spu_create</a></b>(2) that refers to a specific SPU context.  When the context gets  scheduled  to  a
       physical SPU, it starts execution at the instruction pointer passed in <u>npc</u>.

       Execution  of  SPU  code  happens  synchronously,  meaning  that  <b>spu_run</b>() blocks while the SPU is still
       running.  If there is a need to execute SPU code in parallel with other code on either the  main  CPU  or
       other SPUs, a new thread of execution must be created first (e.g., using <b><a href="../man3/pthread_create.3.html">pthread_create</a></b>(3)).

       When  <b>spu_run</b>()  returns,  the  current value of the SPU program counter is written to <u>npc</u>, so successive
       calls to <b>spu_run</b>() can use the same <u>npc</u> pointer.

       The <u>event</u> argument provides a buffer for an extended status code.  If the SPU context  was  created  with
       the  <b>SPU_CREATE_EVENTS_ENABLED</b>  flag,  then this buffer is populated by the Linux kernel before <b>spu_run</b>()
       returns.

       The status code may be one (or more) of the following constants:

       <b>SPE_EVENT_DMA_ALIGNMENT</b>
              A DMA alignment error occurred.

       <b>SPE_EVENT_INVALID_DMA</b>
              An invalid MFC DMA command was attempted.

       <b>SPE_EVENT_SPE_DATA_STORAGE</b>
              A DMA storage error occurred.

       <b>SPE_EVENT_SPE_ERROR</b>
              An illegal instruction was executed.

       NULL is a valid value for the <u>event</u> argument.  In this case, the events  will  not  be  reported  to  the
       calling process.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  <b>spu_run</b>() returns the value of the <u>spu_status</u> register.  On failure, it returns -1 and sets
       <u>errno</u> is set to indicate the error.

       The <u>spu_status</u> register value is a bit mask of status codes and optionally a 14-bit  code  returned  from
       the <b>stop-and-signal</b> instruction on the SPU.  The bit masks for the status codes are:

       <b>0x02</b>   SPU was stopped by a <b>stop-and-signal</b> instruction.

       <b>0x04</b>   SPU was stopped by a <b>halt</b> instruction.

       <b>0x08</b>   SPU is waiting for a channel.

       <b>0x10</b>   SPU is in single-step mode.

       <b>0x20</b>   SPU has tried to execute an invalid instruction.

       <b>0x40</b>   SPU has tried to access an invalid channel.

       <b>0x3fff0000</b>
              The  bits  masked  with  this  value contain the code returned from a <b>stop-and-signal</b> instruction.
              These bits are valid only if the 0x02 bit is set.

       If <b>spu_run</b>() has not returned an error, one or more bits among the lower eight ones are always set.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EBADF</b>  <u>fd</u> is not a valid file descriptor.

       <b>EFAULT</b> <u>npc</u> is not a valid pointer, or <u>event</u> is non-NULL and an invalid pointer.

       <b>EINTR</b>  A signal occurred while <b>spu_run</b>() was in progress; see <b><a href="../man7/signal.7.html">signal</a></b>(7).  The <u>npc</u> value has been  updated
              to the new program counter value if necessary.

       <b>EINVAL</b> <u>fd</u> is not a valid file descriptor returned from <b><a href="../man2/spu_create.2.html">spu_create</a></b>(2).

       <b>ENOMEM</b> There  was  not  enough  memory  available  to  handle  a  page fault resulting from a Memory Flow
              Controller (MFC) direct memory access.

       <b>ENOSYS</b> The functionality is not provided by the current system, because  either  the  hardware  does  not
              provide SPUs or the spufs module is not loaded.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux on PowerPC.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.16.

</pre><h4><b>NOTES</b></h4><pre>
       <b>spu_run</b>()  is meant to be used from libraries that implement a more abstract interface to SPUs, not to be
       used  from  regular  applications.   See  <a href="http://www.bsc.es/projects/deepcomputing/linuxoncell/">http://www.bsc.es/projects/deepcomputing/linuxoncell/</a>  for  the
       recommended libraries.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  is  an example of running a simple, one-instruction SPU program with the <b>spu_run</b>() system
       call.

       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int main(void)
       {
           int       context, fd, spu_status;
           uint32_t  instruction, npc;

           context = syscall(SYS_spu_create, "/spu/example-context", 0, 0755);
           if (context == -1)
               err(EXIT_FAILURE, "spu_create");

           /*
            * Write a 'stop 0x1234' instruction to the SPU's
            * local store memory.
            */
           instruction = 0x00001234;

           fd = open("/spu/example-context/mem", O_RDWR);
           if (fd == -1)
               err(EXIT_FAILURE, "open");
           write(fd, &amp;instruction, sizeof(instruction));

           /*
            * set npc to the starting instruction address of the
            * SPU program. Since we wrote the instruction at the
            * start of the mem file, the entry point will be 0x0.
            */
           npc = 0;

           spu_status = syscall(SYS_spu_run, context, &amp;npc, NULL);
           if (spu_status == -1)
               err(EXIT_FAILURE, "open");

           /*
            * We should see a status code of 0x12340002:
            *   0x00000002 (spu was stopped due to stop-and-signal)
            * | 0x12340000 (the stop-and-signal code)
            */
           printf("SPU Status: %#08x\n", spu_status);

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/close.2.html">close</a></b>(2), <b><a href="../man2/spu_create.2.html">spu_create</a></b>(2), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/spufs.7.html">spufs</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                         <u><a href="../man2/spu_run.2.html">spu_run</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>