<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>perf_event_open - set up performance monitoring</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       perf_event_open - set up performance monitoring

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/linux/perf_event.h">linux/perf_event.h</a>&gt;</b>    /* Definition of <b>PERF_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/linux/hw_breakpoint.h">linux/hw_breakpoint.h</a>&gt;</b> /* Definition of <b>HW_*</b> constants */
       <b>#include</b> <b>&lt;sys/syscall.h&gt;</b>         /* Definition of <b>SYS_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>int</b> <b>syscall(SYS_perf_event_open,</b> <b>struct</b> <b>perf_event_attr</b> <b>*</b><u>attr</u><b>,</b>
                   <b>pid_t</b> <u>pid</u><b>,</b> <b>int</b> <u>cpu</u><b>,</b> <b>int</b> <u>group_fd</u><b>,</b> <b>unsigned</b> <b>long</b> <u>flags</u><b>);</b>

       <u>Note</u>: glibc provides no wrapper for <b>perf_event_open</b>(), necessitating the use of <b><a href="../man2/syscall.2.html">syscall</a></b>(2).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Given  a  list  of  parameters, <b>perf_event_open</b>() returns a file descriptor, for use in subsequent system
       calls (<b><a href="../man2/read.2.html">read</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man2/prctl.2.html">prctl</a></b>(2), <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2), etc.).

       A call to <b>perf_event_open</b>() creates a file descriptor  that  allows  measuring  performance  information.
       Each  file descriptor corresponds to one event that is measured; these can be grouped together to measure
       multiple events simultaneously.

       Events can be enabled and disabled in two ways: via <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) and via <b><a href="../man2/prctl.2.html">prctl</a></b>(2).  When an event is disabled
       it does not count or generate overflows but does continue to exist and maintain its count value.

       Events come in two flavors: counting and sampled.  A <u>counting</u> event is one that is used for counting  the
       aggregate  number  of  events that occur.  In general, counting event results are gathered with a <b><a href="../man2/read.2.html">read</a></b>(2)
       call.  A <u>sampling</u> event periodically writes measurements to a  buffer  that  can  then  be  accessed  via
       <b><a href="../man2/mmap.2.html">mmap</a></b>(2).

   <b>Arguments</b>
       The <u>pid</u> and <u>cpu</u> arguments allow specifying which process and CPU to monitor:

       <b>pid</b> <b>==</b> <b>0</b> and <b>cpu</b> <b>==</b> <b>-1</b>
              This measures the calling process/thread on any CPU.

       <b>pid</b> <b>==</b> <b>0</b> and <b>cpu</b> <b>&gt;=</b> <b>0</b>
              This measures the calling process/thread only when running on the specified CPU.

       <b>pid</b> <b>&gt;</b> <b>0</b> and <b>cpu</b> <b>==</b> <b>-1</b>
              This measures the specified process/thread on any CPU.

       <b>pid</b> <b>&gt;</b> <b>0</b> and <b>cpu</b> <b>&gt;=</b> <b>0</b>
              This measures the specified process/thread only when running on the specified CPU.

       <b>pid</b> <b>==</b> <b>-1</b> and <b>cpu</b> <b>&gt;=</b> <b>0</b>
              This  measures all processes/threads on the specified CPU.  This requires <b>CAP_PERFMON</b> (since Linux
              5.8) or <b>CAP_SYS_ADMIN</b> capability or a <u><a href="file:/proc/sys/kernel/perf_event_paranoid">/proc/sys/kernel/perf_event_paranoid</a></u> value of less than 1.

       <b>pid</b> <b>==</b> <b>-1</b> and <b>cpu</b> <b>==</b> <b>-1</b>
              This setting is invalid and will return an error.

       When <u>pid</u> is greater than zero, permission to perform this system call is governed by  <b>CAP_PERFMON</b>  (since
       Linux  5.9)  and  a  ptrace  access  mode  <b>PTRACE_MODE_READ_REALCREDS</b>  check on older Linux versions; see
       <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2).

       The <u>group_fd</u> argument allows event groups to be created.  An event group has one event which is the group
       leader.  The leader is created first, with <u>group_fd</u> = -1.  The rest of the group members are created with
       subsequent <b>perf_event_open</b>() calls with <u>group_fd</u> being set to the file descriptor of  the  group  leader.
       (A  single  event  on  its  own is created with <u>group_fd</u> = -1 and is considered to be a group with only 1
       member.)  An event group is scheduled onto the CPU as a unit: it will be put onto the CPU only if all  of
       the  events in the group can be put onto the CPU.  This means that the values of the member events can be
       meaningfully compared —added, divided (to get ratios), and so  on—  with  each  other,  since  they  have
       counted events for the same set of executed instructions.

       The <u>flags</u> argument is formed by ORing together zero or more of the following values:

       <b>PERF_FLAG_FD_CLOEXEC</b> (since Linux 3.14)
              This  flag  enables the close-on-exec flag for the created event file descriptor, so that the file
              descriptor is automatically closed on <b><a href="../man2/execve.2.html">execve</a></b>(2).  Setting  the  close-on-exec  flags  at  creation
              time,  rather  than later with <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2), avoids potential race conditions where the calling thread
              invokes <b>perf_event_open</b>() and <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) at the same time  as  another  thread  calls  <b><a href="../man2/fork.2.html">fork</a></b>(2)  then
              <b><a href="../man2/execve.2.html">execve</a></b>(2).

       <b>PERF_FLAG_FD_NO_GROUP</b>
              This  flag  tells  the event to ignore the <u>group_fd</u> parameter except for the purpose of setting up
              output redirection using the <b>PERF_FLAG_FD_OUTPUT</b> flag.

       <b>PERF_FLAG_FD_OUTPUT</b> (broken since Linux 2.6.35)
              This flag re-routes the event's sampled output to instead be included in the mmap  buffer  of  the
              event specified by <u>group_fd</u>.

       <b>PERF_FLAG_PID_CGROUP</b> (since Linux 2.6.39)
              This  flag  activates  per-container  system-wide  monitoring.  A container is an abstraction that
              isolates a set of resources for finer-grained control (CPUs, memory, etc.).   In  this  mode,  the
              event  is  measured  only  if  the  thread  running on the monitored CPU belongs to the designated
              container (cgroup).  The cgroup is identified by passing a file descriptor opened on its directory
              in the cgroupfs filesystem.  For instance, if the cgroup to monitor is called <u>test</u>,  then  a  file
              descriptor opened on <u>/dev/cgroup/test</u> (assuming cgroupfs is mounted on <u>/dev/cgroup</u>) must be passed
              as  the  <u>pid</u>  parameter.   cgroup  monitoring  is  available  only  for system-wide events and may
              therefore require extra permissions.

       The <u>perf_event_attr</u> structure provides detailed configuration information for the event being created.

           struct perf_event_attr {
               __u32 type;                 /* Type of event */
               __u32 size;                 /* Size of attribute structure */
               __u64 config;               /* Type-specific configuration */

               union {
                   __u64 sample_period;    /* Period of sampling */
                   __u64 sample_freq;      /* Frequency of sampling */
               };

               __u64 sample_type;  /* Specifies values included in sample */
               __u64 read_format;  /* Specifies values returned in read */

               __u64 disabled       : 1,   /* off by default */
                     inherit        : 1,   /* children inherit it */
                     pinned         : 1,   /* must always be on PMU */
                     exclusive      : 1,   /* only group on PMU */
                     exclude_user   : 1,   /* don't count user */
                     exclude_kernel : 1,   /* don't count kernel */
                     exclude_hv     : 1,   /* don't count hypervisor */
                     exclude_idle   : 1,   /* don't count when idle */
                     mmap           : 1,   /* include mmap data */
                     comm           : 1,   /* include comm data */
                     freq           : 1,   /* use freq, not period */
                     inherit_stat   : 1,   /* per task counts */
                     enable_on_exec : 1,   /* next exec enables */
                     task           : 1,   /* trace fork/exit */
                     watermark      : 1,   /* wakeup_watermark */
                     precise_ip     : 2,   /* skid constraint */
                     mmap_data      : 1,   /* non-exec mmap data */
                     sample_id_all  : 1,   /* sample_type all events */
                     exclude_host   : 1,   /* don't count in host */
                     exclude_guest  : 1,   /* don't count in guest */
                     exclude_callchain_kernel : 1,
                                           /* exclude kernel callchains */
                     exclude_callchain_user   : 1,
                                           /* exclude user callchains */
                     mmap2          :  1,  /* include mmap with inode data */
                     comm_exec      :  1,  /* flag comm events that are
                                              due to exec */
                     use_clockid    :  1,  /* use clockid for time fields */
                     context_switch :  1,  /* context switch data */
                     write_backward :  1,  /* Write ring buffer from end
                                              to beginning */
                     namespaces     :  1,  /* include namespaces data */
                     ksymbol        :  1,  /* include ksymbol events */
                     bpf_event      :  1,  /* include bpf events */
                     aux_output     :  1,  /* generate AUX records
                                              instead of events */
                     cgroup         :  1,  /* include cgroup events */
                     text_poke      :  1,  /* include text poke events */
                     build_id       :  1,  /* use build id in mmap2 events */
                     inherit_thread :  1,  /* children only inherit */
                                           /* if cloned with CLONE_THREAD */
                     remove_on_exec :  1,  /* event is removed from task
                                              on exec */
                     sigtrap        :  1,  /* send synchronous SIGTRAP
                                              on event */

                     __reserved_1   : 26;

               union {
                   __u32 wakeup_events;    /* wakeup every n events */
                   __u32 wakeup_watermark; /* bytes before wakeup */
               };

               __u32     bp_type;          /* breakpoint type */

               union {
                   __u64 bp_addr;          /* breakpoint address */
                   __u64 kprobe_func;      /* for perf_kprobe */
                   __u64 uprobe_path;      /* for perf_uprobe */
                   __u64 config1;          /* extension of config */
               };

               union {
                   __u64 bp_len;           /* breakpoint length */
                   __u64 kprobe_addr;      /* with kprobe_func == NULL */
                   __u64 probe_offset;     /* for perf_[k,u]probe */
                   __u64 config2;          /* extension of config1 */
               };
               __u64 branch_sample_type;   /* enum perf_branch_sample_type */
               __u64 sample_regs_user;     /* user regs to dump on samples */
               __u32 sample_stack_user;    /* size of stack to dump on
                                              samples */
               __s32 clockid;              /* clock to use for time fields */
               __u64 sample_regs_intr;     /* regs to dump on samples */
               __u32 aux_watermark;        /* aux bytes before wakeup */
               __u16 sample_max_stack;     /* max frames in callchain */
               __u16 __reserved_2;         /* align to u64 */
               __u32 aux_sample_size;      /* max aux sample size */
               __u32 __reserved_3;         /* align to u64 */
               __u64 sig_data;             /* user data for sigtrap */

           };

       The fields of the <u>perf_event_attr</u> structure are described in more detail below:

       <u>type</u>   This field specifies the overall event type.  It has one of the following values:

              <b>PERF_TYPE_HARDWARE</b>
                     This indicates one of the "generalized" hardware events provided by the  kernel.   See  the
                     <u>config</u> field definition for more details.

              <b>PERF_TYPE_SOFTWARE</b>
                     This  indicates  one  of  the  software-defined  events  provided by the kernel (even if no
                     hardware support is available).

              <b>PERF_TYPE_TRACEPOINT</b>
                     This indicates a tracepoint provided by the kernel tracepoint infrastructure.

              <b>PERF_TYPE_HW_CACHE</b>
                     This indicates a hardware cache event.  This has  a  special  encoding,  described  in  the
                     <u>config</u> field definition.

              <b>PERF_TYPE_RAW</b>
                     This indicates a "raw" implementation-specific event in the <u>config</u> field.

              <b>PERF_TYPE_BREAKPOINT</b> (since Linux 2.6.33)
                     This indicates a hardware breakpoint as provided by the CPU.  Breakpoints can be read/write
                     accesses to an address as well as execution of an instruction address.

              dynamic PMU
                     Since  Linux  2.6.38, <b>perf_event_open</b>() can support multiple PMUs.  To enable this, a value
                     exported by the kernel can be used in the <u>type</u> field to indicate which  PMU  to  use.   The
                     value to use can be found in the sysfs filesystem: there is a subdirectory per PMU instance
                     under  <u><a href="file:/sys/bus/event_source/devices">/sys/bus/event_source/devices</a></u>.   In  each  subdirectory  there  is a <u>type</u> file whose
                     content  is  an  integer  that  can  be  used   in   the   <u>type</u>   field.    For   instance,
                     <u><a href="file:/sys/bus/event_source/devices/cpu/type">/sys/bus/event_source/devices/cpu/type</a></u>  contains  the  value for the core CPU PMU, which is
                     usually 4.

              <b>kprobe</b> and <b>uprobe</b> (since Linux 4.17)
                     These two dynamic PMUs create  a  kprobe/uprobe  and  attach  it  to  the  file  descriptor
                     generated  by  perf_event_open.   The kprobe/uprobe will be destroyed on the destruction of
                     the file descriptor.  See fields <u>kprobe_func</u>, <u>uprobe_path</u>,  <u>kprobe_addr</u>,  and  <u>probe_offset</u>
                     for more details.

       <u>size</u>   The  size  of  the  <u>perf_event_attr</u>  structure for forward/backward compatibility.  Set this using
              <u>sizeof(struct</u> <u>perf_event_attr)</u> to allow the  kernel  to  see  the  struct  size  at  the  time  of
              compilation.

              The  related  define  <b>PERF_ATTR_SIZE_VER0</b>  is  set to 64; this was the size of the first published
              struct.  <b>PERF_ATTR_SIZE_VER1</b> is 72, corresponding to the addition of breakpoints in Linux  2.6.33.
              <b>PERF_ATTR_SIZE_VER2</b>  is  80  corresponding  to  the  addition  of  branch  sampling  in Linux 3.4.
              <b>PERF_ATTR_SIZE_VER3</b> is 96 corresponding to the addition of <u>sample_regs_user</u> and  <u>sample_stack_user</u>
              in  Linux  3.7.   <b>PERF_ATTR_SIZE_VER4</b>  is 104 corresponding to the addition of <u>sample_regs_intr</u> in
              Linux 3.19.  <b>PERF_ATTR_SIZE_VER5</b> is 112 corresponding to the addition of  <u>aux_watermark</u>  in  Linux
              4.1.

       <u>config</u> This  specifies which event you want, in conjunction with the <u>type</u> field.  The <u>config1</u> and <u>config2</u>
              fields are also taken into account in cases where 64 bits is  not  enough  to  fully  specify  the
              event.  The encoding of these fields are event dependent.

              There  are  various ways to set the <u>config</u> field that are dependent on the value of the previously
              described <u>type</u> field.  What follows are various possible settings  for  <u>config</u>  separated  out  by
              <u>type</u>.

              If  <u>type</u>  is <b>PERF_TYPE_HARDWARE</b>, we are measuring one of the generalized hardware CPU events.  Not
              all of these are available on all platforms.  Set <u>config</u> to one of the following:

                   <b>PERF_COUNT_HW_CPU_CYCLES</b>
                          Total cycles.  Be wary of what happens during CPU frequency scaling.

                   <b>PERF_COUNT_HW_INSTRUCTIONS</b>
                          Retired instructions.  Be careful, these can  be  affected  by  various  issues,  most
                          notably hardware interrupt counts.

                   <b>PERF_COUNT_HW_CACHE_REFERENCES</b>
                          Cache  accesses.   Usually  this indicates Last Level Cache accesses but this may vary
                          depending on your CPU.  This may include prefetches and coherency messages; again this
                          depends on the design of your CPU.

                   <b>PERF_COUNT_HW_CACHE_MISSES</b>
                          Cache misses.  Usually this indicates Last Level Cache misses; this is intended to  be
                          used  in  conjunction with the <b>PERF_COUNT_HW_CACHE_REFERENCES</b> event to calculate cache
                          miss rates.

                   <b>PERF_COUNT_HW_BRANCH_INSTRUCTIONS</b>
                          Retired branch instructions.  Prior to Linux 2.6.35, this used the wrong event on  AMD
                          processors.

                   <b>PERF_COUNT_HW_BRANCH_MISSES</b>
                          Mispredicted branch instructions.

                   <b>PERF_COUNT_HW_BUS_CYCLES</b>
                          Bus cycles, which can be different from total cycles.

                   <b>PERF_COUNT_HW_STALLED_CYCLES_FRONTEND</b> (since Linux 3.0)
                          Stalled cycles during issue.

                   <b>PERF_COUNT_HW_STALLED_CYCLES_BACKEND</b> (since Linux 3.0)
                          Stalled cycles during retirement.

                   <b>PERF_COUNT_HW_REF_CPU_CYCLES</b> (since Linux 3.3)
                          Total cycles; not affected by CPU frequency scaling.

              If  <u>type</u>  is  <b>PERF_TYPE_SOFTWARE</b>,  we  are  measuring software events provided by the kernel.  Set
              <u>config</u> to one of the following:

                   <b>PERF_COUNT_SW_CPU_CLOCK</b>
                          This reports the CPU clock, a high-resolution per-CPU timer.

                   <b>PERF_COUNT_SW_TASK_CLOCK</b>
                          This reports a clock count specific to the task that is running.

                   <b>PERF_COUNT_SW_PAGE_FAULTS</b>
                          This reports the number of page faults.

                   <b>PERF_COUNT_SW_CONTEXT_SWITCHES</b>
                          This counts context switches.  Until Linux 2.6.34, these were all  reported  as  user-
                          space events, after that they are reported as happening in the kernel.

                   <b>PERF_COUNT_SW_CPU_MIGRATIONS</b>
                          This reports the number of times the process has migrated to a new CPU.

                   <b>PERF_COUNT_SW_PAGE_FAULTS_MIN</b>
                          This  counts  the  number  of  minor  page  faults.  These did not require disk I/O to
                          handle.

                   <b>PERF_COUNT_SW_PAGE_FAULTS_MAJ</b>
                          This counts the number of major page faults.  These required disk I/O to handle.

                   <b>PERF_COUNT_SW_ALIGNMENT_FAULTS</b> (since Linux 2.6.33)
                          This counts the number of  alignment  faults.   These  happen  when  unaligned  memory
                          accesses happen; the kernel can handle these but it reduces performance.  This happens
                          only on some architectures (never on x86).

                   <b>PERF_COUNT_SW_EMULATION_FAULTS</b> (since Linux 2.6.33)
                          This   counts  the  number  of  emulation  faults.   The  kernel  sometimes  traps  on
                          unimplemented instructions and emulates them for  user  space.   This  can  negatively
                          impact performance.

                   <b>PERF_COUNT_SW_DUMMY</b> (since Linux 3.12)
                          This  is  a  placeholder event that counts nothing.  Informational sample record types
                          such as mmap or comm must be associated with an active event.  This dummy event allows
                          gathering such records without requiring a counting event.

                   <b>PERF_COUNT_SW_BPF_OUTPUT</b> (since Linux 4.4)
                          This is used to generate raw sample data from BPF.  BPF programs  can  write  to  this
                          event using <b>bpf_perf_event_output</b> helper.

                   <b>PERF_COUNT_SW_CGROUP_SWITCHES</b> (since Linux 5.13)
                          This  counts context switches to a task in a different cgroup.  In other words, if the
                          next task is in the same cgroup, it won't count the switch.

              If <u>type</u> is <b>PERF_TYPE_TRACEPOINT</b>, then we are measuring kernel tracepoints.  The value  to  use  in
              <u>config</u>  can  be  obtained  from  under  debugfs  <u>tracing/events/*/*/id</u> if ftrace is enabled in the
              kernel.

              If <u>type</u> is <b>PERF_TYPE_HW_CACHE</b>, then we are measuring a hardware CPU cache event.  To calculate the
              appropriate <u>config</u> value, use the following equation:

                      config = (perf_hw_cache_id) |
                               (perf_hw_cache_op_id &lt;&lt; 8) |
                               (perf_hw_cache_op_result_id &lt;&lt; 16);

                  where <u>perf_hw_cache_id</u> is one of:

                      <b>PERF_COUNT_HW_CACHE_L1D</b>
                             for measuring Level 1 Data Cache

                      <b>PERF_COUNT_HW_CACHE_L1I</b>
                             for measuring Level 1 Instruction Cache

                      <b>PERF_COUNT_HW_CACHE_LL</b>
                             for measuring Last-Level Cache

                      <b>PERF_COUNT_HW_CACHE_DTLB</b>
                             for measuring the Data TLB

                      <b>PERF_COUNT_HW_CACHE_ITLB</b>
                             for measuring the Instruction TLB

                      <b>PERF_COUNT_HW_CACHE_BPU</b>
                             for measuring the branch prediction unit

                      <b>PERF_COUNT_HW_CACHE_NODE</b> (since Linux 3.1)
                             for measuring local memory accesses

                  and <u>perf_hw_cache_op_id</u> is one of:

                      <b>PERF_COUNT_HW_CACHE_OP_READ</b>
                             for read accesses

                      <b>PERF_COUNT_HW_CACHE_OP_WRITE</b>
                             for write accesses

                      <b>PERF_COUNT_HW_CACHE_OP_PREFETCH</b>
                             for prefetch accesses

                  and <u>perf_hw_cache_op_result_id</u> is one of:

                      <b>PERF_COUNT_HW_CACHE_RESULT_ACCESS</b>
                             to measure accesses

                      <b>PERF_COUNT_HW_CACHE_RESULT_MISS</b>
                             to measure misses

              If <u>type</u> is <b>PERF_TYPE_RAW</b>, then a custom "raw" <u>config</u> value is needed.  Most  CPUs  support  events
              that  are not covered by the "generalized" events.  These are implementation defined; see your CPU
              manual (for example the Intel Volume 3B documentation or the AMD BIOS and Kernel Developer Guide).
              The libpfm4 library can be used to translate from the name in the architectural manuals to the raw
              hex value <b>perf_event_open</b>() expects in this field.

              If <u>type</u> is <b>PERF_TYPE_BREAKPOINT</b>, then leave <u>config</u> set to zero.  Its parameters are set  in  other
              places.

              If    <u>type</u>    is    <b>kprobe</b>    or    <b>uprobe</b>,    set    <u>retprobe</u>    (bit    0    of    <u>config</u>,   see
              <u><a href="file:/sys/bus/event_source/devices/">/sys/bus/event_source/devices/</a>[k,u]probe/format/retprobe</u>)  for  kretprobe/uretprobe.   See  fields
              <u>kprobe_func</u>, <u>uprobe_path</u>, <u>kprobe_addr</u>, and <u>probe_offset</u> for more details.

       <u>kprobe_func</u>
       <u>uprobe_path</u>
       <u>kprobe_addr</u>
       <u>probe_offset</u>
              These  fields  describe  the  kprobe/uprobe  for  dynamic PMUs <b>kprobe</b> and <b>uprobe</b>.  For <b>kprobe</b>: use
              <u>kprobe_func</u> and <u>probe_offset</u>, or use <u>kprobe_addr</u> and leave <u>kprobe_func</u> as NULL.  For  <b>uprobe</b>:  use
              <u>uprobe_path</u> and <u>probe_offset</u>.

       <u>sample_period</u>
       <u>sample_freq</u>
              A "sampling" event is one that generates an overflow notification every N events, where N is given
              by  <u>sample_period</u>.   A  sampling  event has <u>sample_period</u> &gt; 0.  When an overflow occurs, requested
              data is recorded in the mmap buffer.  The <u>sample_type</u> field controls what data is recorded on each
              overflow.

              <u>sample_freq</u> can be used if you wish to use frequency rather than period.  In this  case,  you  set
              the  <u>freq</u>  flag.   The kernel will adjust the sampling period to try and achieve the desired rate.
              The rate of adjustment is a timer tick.

       <u>sample_type</u>
              The various bits in this field specify which values to  include  in  the  sample.   They  will  be
              recorded in a ring-buffer, which is available to user space using <b><a href="../man2/mmap.2.html">mmap</a></b>(2).  The order in which the
              values  are  saved in the sample are documented in the MMAP Layout subsection below; it is not the
              <u>enum</u> <u>perf_event_sample_format</u> order.

              <b>PERF_SAMPLE_IP</b>
                     Records instruction pointer.

              <b>PERF_SAMPLE_TID</b>
                     Records the process and thread IDs.

              <b>PERF_SAMPLE_TIME</b>
                     Records a timestamp.

              <b>PERF_SAMPLE_ADDR</b>
                     Records an address, if applicable.

              <b>PERF_SAMPLE_READ</b>
                     Record counter values for all events in a group, not just the group leader.

              <b>PERF_SAMPLE_CALLCHAIN</b>
                     Records the callchain (stack backtrace).

              <b>PERF_SAMPLE_ID</b>
                     Records a unique ID for the opened event's group leader.

              <b>PERF_SAMPLE_CPU</b>
                     Records CPU number.

              <b>PERF_SAMPLE_PERIOD</b>
                     Records the current sampling period.

              <b>PERF_SAMPLE_STREAM_ID</b>
                     Records a unique ID for the opened event.  Unlike <b>PERF_SAMPLE_ID</b> the actual ID is returned,
                     not the group leader.  This ID is the same as the one returned by <b>PERF_FORMAT_ID</b>.

              <b>PERF_SAMPLE_RAW</b>
                     Records additional data, if applicable.  Usually returned by tracepoint events.

              <b>PERF_SAMPLE_BRANCH_STACK</b> (since Linux 3.4)
                     This provides a record of recent branches, as provided  by  CPU  branch  sampling  hardware
                     (such as Intel Last Branch Record).  Not all hardware supports this feature.

                     See the <u>branch_sample_type</u> field for how to filter which branches are reported.

              <b>PERF_SAMPLE_REGS_USER</b> (since Linux 3.7)
                     Records  the  current  user-level  CPU register state (the values in the process before the
                     kernel was called).

              <b>PERF_SAMPLE_STACK_USER</b> (since Linux 3.7)
                     Records the user level stack, allowing stack unwinding.

              <b>PERF_SAMPLE_WEIGHT</b> (since Linux 3.10)
                     Records a hardware provided weight value that expresses how costly the sampled  event  was.
                     This allows the hardware to highlight expensive events in a profile.

              <b>PERF_SAMPLE_DATA_SRC</b> (since Linux 3.10)
                     Records the data source: where in the memory hierarchy the data associated with the sampled
                     instruction  came  from.   This  is available only if the underlying hardware supports this
                     feature.

              <b>PERF_SAMPLE_IDENTIFIER</b> (since Linux 3.12)
                     Places the <b>SAMPLE_ID</b> value in a fixed position in the record, either at the beginning  (for
                     sample events) or at the end (if a non-sample event).

                     This  was  necessary  because a sample stream may have records from various different event
                     sources with different <u>sample_type</u> settings.  Parsing the event  stream  properly  was  not
                     possible  because  the  format  of  the record was needed to find <b>SAMPLE_ID</b>, but the format
                     could not be found without knowing what event the sample belonged to  (causing  a  circular
                     dependency).

                     The  <b>PERF_SAMPLE_IDENTIFIER</b>  setting  makes  the  event  stream  always parsable by putting
                     <b>SAMPLE_ID</b> in a fixed location, even though it means having duplicate  <b>SAMPLE_ID</b>  values  in
                     records.

              <b>PERF_SAMPLE_TRANSACTION</b> (since Linux 3.13)
                     Records  reasons  for  transactional  memory  abort  events  (for  example,  from Intel TSX
                     transactional memory support).

                     The <u>precise_ip</u> setting must be greater than 0 and a transactional memory abort  event  must
                     be  measured  or  no values will be recorded.  Also note that some perf_event measurements,
                     such as sampled cycle counting, may cause extraneous aborts (by causing an interrupt during
                     a transaction).

              <b>PERF_SAMPLE_REGS_INTR</b> (since Linux 3.19)
                     Records a subset of the current  CPU  register  state  as  specified  by  <u>sample_regs_intr</u>.
                     Unlike  <b>PERF_SAMPLE_REGS_USER</b>  the register values will return kernel register state if the
                     overflow happened while kernel code is running.  If the CPU supports hardware  sampling  of
                     register  state  (i.e.,  PEBS on Intel x86) and <u>precise_ip</u> is set higher than zero then the
                     register values returned are those  captured  by  hardware  at  the  time  of  the  sampled
                     instruction's retirement.

              <b>PERF_SAMPLE_PHYS_ADDR</b> (since Linux 4.13)
                     Records physical address of data like in <b>PERF_SAMPLE_ADDR</b>.

              <b>PERF_SAMPLE_CGROUP</b> (since Linux 5.7)
                     Records  (perf_event)  cgroup  ID  of the process.  This corresponds to the <u>id</u> field in the
                     <b>PERF_RECORD_CGROUP</b> event.

              <b>PERF_SAMPLE_DATA_PAGE_SIZE</b> (since Linux 5.11)
                     Records page size of data like in <b>PERF_SAMPLE_ADDR</b>.

              <b>PERF_SAMPLE_CODE_PAGE_SIZE</b> (since Linux 5.11)
                     Records page size of ip like in <b>PERF_SAMPLE_IP</b>.

              <b>PERF_SAMPLE_WEIGHT_STRUCT</b> (since Linux 5.12)
                     Records hardware provided weight values like in <b>PERF_SAMPLE_WEIGHT</b>, but  it  can  represent
                     multiple  values  in  a struct.  This shares the same space as <b>PERF_SAMPLE_WEIGHT</b>, so users
                     can apply either of those, not both.  It has the following format and the meaning  of  each
                     field is dependent on the hardware implementation.

                  union perf_sample_weight {
                      u64  full;           /* PERF_SAMPLE_WEIGHT */
                      struct {             /* PERF_SAMPLE_WEIGHT_STRUCT */
                          u32  var1_dw;
                          u16  var2_w;
                          u16  var3_w;
                      };
                  };

       <u>read_format</u>
              This  field  specifies  the  format  of  the  data returned by <b><a href="../man2/read.2.html">read</a></b>(2) on a <b>perf_event_open</b>() file
              descriptor.

              <b>PERF_FORMAT_TOTAL_TIME_ENABLED</b>
                     Adds the 64-bit <u>time_enabled</u> field.  This can be used to calculate estimated totals if  the
                     PMU is overcommitted and multiplexing is happening.

              <b>PERF_FORMAT_TOTAL_TIME_RUNNING</b>
                     Adds  the 64-bit <u>time_running</u> field.  This can be used to calculate estimated totals if the
                     PMU is overcommitted and multiplexing is happening.

              <b>PERF_FORMAT_ID</b>
                     Adds a 64-bit unique value that corresponds to the event group.

              <b>PERF_FORMAT_GROUP</b>
                     Allows all counter values in an event group to be read with one read.

              <b>PERF_FORMAT_LOST</b>  <b>(since</b> <b>Linux</b> <b>6.0)</b>
                     Adds a 64-bit value that is the number of lost samples for this event.  This would be  only
                     meaningful when <u>sample_period</u> or <u>sample_freq</u> is set.

       <u>disabled</u>
              The  <u>disabled</u>  bit specifies whether the counter starts out disabled or enabled.  If disabled, the
              event can later be enabled by <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2), <b><a href="../man2/prctl.2.html">prctl</a></b>(2), or <u>enable_on_exec</u>.

              When creating an event group, typically the group leader is initialized with <u>disabled</u> set to 1 and
              any child events are initialized with <u>disabled</u> set to 0.  Despite  <u>disabled</u>  being  0,  the  child
              events will not start until the group leader is enabled.

       <u>inherit</u>
              The <u>inherit</u> bit specifies that this counter should count events of child tasks as well as the task
              specified.   This  applies  only  to  new  children,  not to any existing children at the time the
              counter is created (nor to any new children of existing children).

              Inherit does not work for some combinations of <u>read_format</u> values, such as <b>PERF_FORMAT_GROUP</b>.

       <u>pinned</u> The <u>pinned</u> bit specifies that the counter should always be on the CPU  if  at  all  possible.   It
              applies  only  to  hardware counters and only to group leaders.  If a pinned counter cannot be put
              onto the CPU (e.g., because there are not enough hardware counters or because of a  conflict  with
              some  other  event),  then  the counter goes into an 'error' state, where reads return end-of-file
              (i.e., <b><a href="../man2/read.2.html">read</a></b>(2) returns 0) until the counter is subsequently enabled or disabled.

       <u>exclusive</u>
              The <u>exclusive</u> bit specifies that when this counter's group is on the CPU, it should  be  the  only
              group  using  the CPU's counters.  In the future this may allow monitoring programs to support PMU
              features that need to run alone so that they do not disrupt other hardware counters.

              Note that many unexpected situations may prevent events with  the  <u>exclusive</u>  bit  set  from  ever
              running.   This  includes any users running a system-wide measurement as well as any kernel use of
              the performance counters (including the commonly enabled NMI Watchdog Timer interface).

       <u>exclude_user</u>
              If this bit is set, the count excludes events that happen in user space.

       <u>exclude_kernel</u>
              If this bit is set, the count excludes events that happen in kernel space.

       <u>exclude_hv</u>
              If this bit is set, the count excludes events that happen in the hypervisor.  This is  mainly  for
              PMUs  that  have  built-in support for handling this (such as POWER).  Extra support is needed for
              handling hypervisor measurements on most machines.

       <u>exclude_idle</u>
              If set, don't count when the CPU is running the idle task.  While you can  currently  enable  this
              for any event type, it is ignored for all but software events.

       <u>mmap</u>   The  <u>mmap</u>  bit  enables  generation  of  <b>PERF_RECORD_MMAP</b>  samples for every <b><a href="../man2/mmap.2.html">mmap</a></b>(2) call that has
              <b>PROT_EXEC</b> set.  This allows tools to notice new  executable  code  being  mapped  into  a  program
              (dynamic shared libraries for example) so that addresses can be mapped back to the original code.

       <u>comm</u>   The  <u>comm</u>  bit  enables  tracking  of  process  command  name  as  modified  by  the <b><a href="../man2/execve.2.html">execve</a></b>(2) and
              <b>prctl</b>(PR_SET_NAME) system calls as well as writing to <u><a href="file:/proc/self/comm">/proc/self/comm</a></u>.  If the <u>comm_exec</u>  flag  is
              also  successfully  set (possible since Linux 3.16), then the misc flag <b>PERF_RECORD_MISC_COMM_EXEC</b>
              can be used to differentiate the <b><a href="../man2/execve.2.html">execve</a></b>(2) case from the others.

       <u>freq</u>   If this bit is set, then <u>sample_frequency</u> not <u>sample_period</u> is used when setting up  the  sampling
              interval.

       <u>inherit_stat</u>
              This bit enables saving of event counts on context switch for inherited tasks.  This is meaningful
              only if the <u>inherit</u> field is set.

       <u>enable_on_exec</u>
              If this bit is set, a counter is automatically enabled after a call to <b><a href="../man2/execve.2.html">execve</a></b>(2).

       <u>task</u>   If this bit is set, then fork/exit notifications are included in the ring buffer.

       <u>watermark</u>
              If  set,  have  an  overflow  notification  happen  when  we  cross the <u>wakeup_watermark</u> boundary.
              Otherwise, overflow notifications happen after <u>wakeup_events</u> samples.

       <u>precise_ip</u> (since Linux 2.6.35)
              This controls the amount of skid.  Skid is how many  instructions  execute  between  an  event  of
              interest happening and the kernel being able to stop and record the event.  Smaller skid is better
              and  allows more accurate reporting of which events correspond to which instructions, but hardware
              is often limited with how small this can be.

              The possible values of this field are the following:

              <b>0</b>      <b>SAMPLE_IP</b> can have arbitrary skid.

              <b>1</b>      <b>SAMPLE_IP</b> must have constant skid.

              <b>2</b>      <b>SAMPLE_IP</b> requested to have 0 skid.

              <b>3</b>      <b>SAMPLE_IP</b> must have 0 skid.  See also the description of <b>PERF_RECORD_MISC_EXACT_IP</b>.

       <u>mmap_data</u> (since Linux 2.6.36)
              This is the counterpart of the <u>mmap</u> field.  This enables generation  of  <b>PERF_RECORD_MMAP</b>  samples
              for <b><a href="../man2/mmap.2.html">mmap</a></b>(2) calls that do not have <b>PROT_EXEC</b> set (for example data and SysV shared memory).

       <u>sample_id_all</u> (since Linux 2.6.38)
              If   set,  then  TID,  TIME,  ID,  STREAM_ID,  and  CPU  can  additionally  be  included  in  non-
              <b>PERF_RECORD_SAMPLE</b>s if the corresponding <u>sample_type</u> is selected.

              If <b>PERF_SAMPLE_IDENTIFIER</b> is specified, then an additional ID value is included as the last  value
              to ease parsing the record stream.  This may lead to the <u>id</u> value appearing twice.

              The layout is described by this pseudo-structure:

                  struct sample_id {
                      { u32 pid, tid; }   /* if PERF_SAMPLE_TID set */
                      { u64 time;     }   /* if PERF_SAMPLE_TIME set */
                      { u64 id;       }   /* if PERF_SAMPLE_ID set */
                      { u64 stream_id;}   /* if PERF_SAMPLE_STREAM_ID set  */
                      { u32 cpu, res; }   /* if PERF_SAMPLE_CPU set */
                      { u64 id;       }   /* if PERF_SAMPLE_IDENTIFIER set */
                  };

       <u>exclude_host</u> (since Linux 3.2)
              When  conducting  measurements  that include processes running VM instances (i.e., have executed a
              <b>KVM_RUN</b> <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)), only measure events happening inside a guest instance.  This is only meaningful
              outside the guests; this setting does not change counts gathered inside of  a  guest.   Currently,
              this functionality is x86 only.

       <u>exclude_guest</u> (since Linux 3.2)
              When  conducting  measurements  that include processes running VM instances (i.e., have executed a
              <b>KVM_RUN</b> <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)), do  not  measure  events  happening  inside  guest  instances.   This  is  only
              meaningful  outside  the  guests;  this setting does not change counts gathered inside of a guest.
              Currently, this functionality is x86 only.

       <u>exclude_callchain_kernel</u> (since Linux 3.7)
              Do not include kernel callchains.

       <u>exclude_callchain_user</u> (since Linux 3.7)
              Do not include user callchains.

       <u>mmap2</u> (since Linux 3.16)
              Generate an extended executable  mmap  record  that  contains  enough  additional  information  to
              uniquely identify shared mappings.  The <u>mmap</u> flag must also be set for this to work.

       <u>comm_exec</u> (since Linux 3.16)
              This  is  purely  a  feature-detection flag, it does not change kernel behavior.  If this flag can
              successfully be set, then, when <u>comm</u> is enabled, the <b>PERF_RECORD_MISC_COMM_EXEC</b> flag will  be  set
              in  the <u>misc</u> field of a comm record header if the rename event being reported was caused by a call
              to <b><a href="../man2/execve.2.html">execve</a></b>(2).  This allows tools to distinguish between the various types of process renaming.

       <u>use_clockid</u> (since Linux 4.1)
              This allows selecting which internal Linux clock to use when generating timestamps via the <u>clockid</u>
              field.  This can make it easier to correlate perf sample times with timestamps generated by  other
              tools.

       <u>context_switch</u> (since Linux 4.3)
              This  enables  the generation of <b>PERF_RECORD_SWITCH</b> records when a context switch occurs.  It also
              enables the generation of <b>PERF_RECORD_SWITCH_CPU_WIDE</b> records  when  sampling  in  CPU-wide  mode.
              This functionality is in addition to existing tracepoint and software events for measuring context
              switches.   The  advantage  of  this method is that it will give full information even with strict
              <u>perf_event_paranoid</u> settings.

       <u>write_backward</u> (since Linux 4.6)
              This causes the ring buffer to be written from the end to  the  beginning.   This  is  to  support
              reading from overwritable ring buffer.

       <u>namespaces</u> (since Linux 4.11)
              This  enables the generation of <b>PERF_RECORD_NAMESPACES</b> records when a task enters a new namespace.
              Each namespace has a combination of device and inode numbers.

       <u>ksymbol</u> (since Linux 5.0)
              This enables the generation of <b>PERF_RECORD_KSYMBOL</b> records when new kernel symbols are  registered
              or unregistered.  This is analyzing dynamic kernel functions like eBPF.

       <u>bpf_event</u> (since Linux 5.0)
              This  enables  the  generation  of <b>PERF_RECORD_BPF_EVENT</b> records when an eBPF program is loaded or
              unloaded.

       <u>aux_output</u> (since Linux 5.4)
              This allows normal (non-AUX) events to generate data for AUX events if the hardware supports it.

       <u>cgroup</u> (since Linux 5.7)
              This enables the generation of <b>PERF_RECORD_CGROUP</b> records  when  a  new  cgroup  is  created  (and
              activated).

       <u>text_poke</u> (since Linux 5.8)
              This  enables  the generation of <b>PERF_RECORD_TEXT_POKE</b> records when there's a change to the kernel
              text (i.e., self-modifying code).

       <u>build_id</u> (since Linux 5.12)
              This changes the contents in the <b>PERF_RECORD_MMAP2</b> to have a build-id instead of device and  inode
              numbers.

       <u>inherit_thread</u> (since Linux 5.13)
              This  disables  the  inheritance  of  the  event to a child process.  Only new threads in the same
              process (which is cloned with <b>CLONE_THREAD</b>) will inherit the event.

       <u>remove_on_exec</u> (since Linux 5.13)
              This closes the event when it starts a new process image by <b><a href="../man2/execve.2.html">execve</a></b>(2).

       <u>sigtrap</u> (since Linux 5.13)
              This enables synchronous signal delivery of <b>SIGTRAP</b> on event overflow.

       <u>wakeup_events</u>
       <u>wakeup_watermark</u>
              This union sets how many samples (<u>wakeup_events</u>) or  bytes  (<u>wakeup_watermark</u>)  happen  before  an
              overflow notification happens.  Which one is used is selected by the <u>watermark</u> bit flag.

              <u>wakeup_events</u>  counts  only <b>PERF_RECORD_SAMPLE</b> record types.  To receive overflow notification for
              all <b>PERF_RECORD</b> types choose watermark and set <u>wakeup_watermark</u> to 1.

              Prior to Linux 3.0, setting <u>wakeup_events</u> to 0 resulted in no overflow notifications; more  recent
              kernels treat 0 the same as 1.

       <u>bp_type</u> (since Linux 2.6.33)
              This chooses the breakpoint type.  It is one of:

              <b>HW_BREAKPOINT_EMPTY</b>
                     No breakpoint.

              <b>HW_BREAKPOINT_R</b>
                     Count when we read the memory location.

              <b>HW_BREAKPOINT_W</b>
                     Count when we write the memory location.

              <b>HW_BREAKPOINT_RW</b>
                     Count when we read or write the memory location.

              <b>HW_BREAKPOINT_X</b>
                     Count when we execute code at the memory location.

              The  values  can  be  combined  via  a  bitwise  or,  but  the  combination  of <b>HW_BREAKPOINT_R</b> or
              <b>HW_BREAKPOINT_W</b> with <b>HW_BREAKPOINT_X</b> is not allowed.

       <u>bp_addr</u> (since Linux 2.6.33)
              This is the address of the breakpoint.  For execution breakpoints, this is the memory  address  of
              the  instruction  of  interest;  for  read  and write breakpoints, it is the memory address of the
              memory location of interest.

       <u>config1</u> (since Linux 2.6.39)
              <u>config1</u> is used for setting events that need an extra register or otherwise  do  not  fit  in  the
              regular  config field.  Raw OFFCORE_EVENTS on Nehalem/Westmere/SandyBridge use this field on Linux
              3.3 and later kernels.

       <u>bp_len</u> (since Linux 2.6.33)
              <u>bp_len</u> is the length of the breakpoint being measured if <u>type</u>  is  <b>PERF_TYPE_BREAKPOINT</b>.   Options
              are  <b>HW_BREAKPOINT_LEN_1</b>,  <b>HW_BREAKPOINT_LEN_2</b>, <b>HW_BREAKPOINT_LEN_4</b>, and <b>HW_BREAKPOINT_LEN_8</b>.  For
              an execution breakpoint, set this to <u>sizeof(long)</u>.

       <u>config2</u> (since Linux 2.6.39)
              <u>config2</u> is a further extension of the <u>config1</u> field.

       <u>branch_sample_type</u> (since Linux 3.4)
              If <b>PERF_SAMPLE_BRANCH_STACK</b> is enabled, then this specifies what branches to include in the branch
              record.

              The first part of the value is the privilege level, which is a combination of one  of  the  values
              listed  below.   If  the  user  does  not  set privilege level explicitly, the kernel will use the
              event's privilege level.  Event and branch privilege levels do not have to match.

              <b>PERF_SAMPLE_BRANCH_USER</b>
                     Branch target is in user space.

              <b>PERF_SAMPLE_BRANCH_KERNEL</b>
                     Branch target is in kernel space.

              <b>PERF_SAMPLE_BRANCH_HV</b>
                     Branch target is in hypervisor.

              <b>PERF_SAMPLE_BRANCH_PLM_ALL</b>
                     A convenience value that is the three preceding values ORed together.

              In addition to the privilege value, at least one or more of the following bits must be set.

              <b>PERF_SAMPLE_BRANCH_ANY</b>
                     Any branch type.

              <b>PERF_SAMPLE_BRANCH_ANY_CALL</b>
                     Any call branch (includes direct calls, indirect calls, and far jumps).

              <b>PERF_SAMPLE_BRANCH_IND_CALL</b>
                     Indirect calls.

              <b>PERF_SAMPLE_BRANCH_CALL</b> (since Linux 4.4)
                     Direct calls.

              <b>PERF_SAMPLE_BRANCH_ANY_RETURN</b>
                     Any return branch.

              <b>PERF_SAMPLE_BRANCH_IND_JUMP</b> (since Linux 4.2)
                     Indirect jumps.

              <b>PERF_SAMPLE_BRANCH_COND</b> (since Linux 3.16)
                     Conditional branches.

              <b>PERF_SAMPLE_BRANCH_ABORT_TX</b> (since Linux 3.11)
                     Transactional memory aborts.

              <b>PERF_SAMPLE_BRANCH_IN_TX</b> (since Linux 3.11)
                     Branch in transactional memory transaction.

              <b>PERF_SAMPLE_BRANCH_NO_TX</b> (since Linux 3.11)
                     Branch not in transactional memory transaction.  <b>PERF_SAMPLE_BRANCH_CALL_STACK</b> (since Linux
                     4.1) Branch is part of a hardware-generated call stack.  This  requires  hardware  support,
                     currently only found on Intel x86 Haswell or newer.

       <u>sample_regs_user</u> (since Linux 3.7)
              This  bit  mask  defines  the  set  of  user  CPU registers to dump on samples.  The layout of the
              register  mask  is  architecture-specific  and  is   described   in   the   kernel   header   file
              <u>arch/ARCH/include/uapi/asm/perf_regs.h</u>.

       <u>sample_stack_user</u> (since Linux 3.7)
              This defines the size of the user stack to dump if <b>PERF_SAMPLE_STACK_USER</b> is specified.

       <u>clockid</u> (since Linux 4.1)
              If  <u>use_clockid</u>  is set, then this field selects which internal Linux timer to use for timestamps.
              The available timers are  defined  in  <u>linux/time.h</u>,  with  <b>CLOCK_MONOTONIC</b>,  <b>CLOCK_MONOTONIC_RAW</b>,
              <b>CLOCK_REALTIME</b>, <b>CLOCK_BOOTTIME</b>, and <b>CLOCK_TAI</b> currently supported.

       <u>aux_watermark</u> (since Linux 4.1)
              This specifies how much data is required to trigger a <b>PERF_RECORD_AUX</b> sample.

       <u>sample_max_stack</u> (since Linux 4.8)
              When  <u>sample_type</u>  includes  <b>PERF_SAMPLE_CALLCHAIN</b>,  this field specifies how many stack frames to
              report when generating the callchain.

       <u>aux_sample_size</u> (since Linux 5.5)
              When <b>PERF_SAMPLE_AUX</b> flag is set, specify the desired size of AUX data.   Note  that  it  can  get
              smaller data than the specified size.

       <u>sig_data</u> (since Linux 5.13)
              This  data  will  be  copied  to  user's  signal  handler  (through  <u>si_perf</u>  in the <u>siginfo_t</u>) to
              disambiguate which event triggered the signal.

   <b>Reading</b> <b>results</b>
       Once a <b>perf_event_open</b>() file descriptor has been opened, the values of the events can be read  from  the
       file  descriptor.  The values that are there are specified by the <u>read_format</u> field in the <u>attr</u> structure
       at open time.

       If you attempt to read into a buffer that is not big enough to hold the data, the error <b>ENOSPC</b> results.

       Here is the layout of the data returned by a read:

       •  If <b>PERF_FORMAT_GROUP</b> was specified to allow reading all events in a group at once:

              struct read_format {
                  u64 nr;            /* The number of events */
                  u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
                  u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
                  struct {
                      u64 value;     /* The value of the event */
                      u64 id;        /* if PERF_FORMAT_ID */
                      u64 lost;      /* if PERF_FORMAT_LOST */
                  } values[nr];
              };

       •  If <b>PERF_FORMAT_GROUP</b> was <u>not</u> specified:

              struct read_format {
                  u64 value;         /* The value of the event */
                  u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
                  u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
                  u64 id;            /* if PERF_FORMAT_ID */
                  u64 lost;          /* if PERF_FORMAT_LOST */
              };

       The values read are as follows:

       <u>nr</u>     The number of events in this file descriptor.  Available only if <b>PERF_FORMAT_GROUP</b> was specified.

       <u>time_enabled</u>
       <u>time_running</u>
              Total time the event was enabled and running.  Normally these values are the  same.   Multiplexing
              happens  if  the number of events is more than the number of available PMU counter slots.  In that
              case the events run only part of the time and the <u>time_enabled</u> and <u>time</u> <u>running</u> values can be used
              to scale an estimated value for the count.

       <u>value</u>  An unsigned 64-bit value containing the counter result.

       <u>id</u>     A globally unique value for this particular event; only present if <b>PERF_FORMAT_ID</b> was specified in
              <u>read_format</u>.

       <u>lost</u>   The number of lost samples of this event;  only  present  if  <b>PERF_FORMAT_LOST</b>  was  specified  in
              <u>read_format</u>.

   <b>MMAP</b> <b>layout</b>
       When  using  <b>perf_event_open</b>()  in  sampled mode, asynchronous events (like counter overflow or <b>PROT_EXEC</b>
       mmap tracking) are logged into a ring-buffer.  This ring-buffer is created and accessed through <b><a href="../man2/mmap.2.html">mmap</a></b>(2).

       The  mmap  size  should  be  1+2^n  pages,  where  the  first   page   is   a   metadata   page   (<u>struct</u>
       <u>perf_event_mmap_page</u>) that contains various bits of information such as where the ring-buffer head is.

       Before  Linux  2.6.39, there is a bug that means you must allocate an mmap ring buffer when sampling even
       if you do not plan to access it.

       The structure of the first metadata mmap page is as follows:

           struct perf_event_mmap_page {
               __u32 version;        /* version number of this structure */
               __u32 compat_version; /* lowest version this is compat with */
               __u32 lock;           /* seqlock for synchronization */
               __u32 index;          /* hardware counter identifier */
               __s64 offset;         /* add to hardware counter value */
               __u64 time_enabled;   /* time event active */
               __u64 time_running;   /* time event on CPU */
               union {
                   __u64   capabilities;
                   struct {
                       __u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1,
                             cap_bit0_is_deprecated : 1,
                             cap_user_rdpmc         : 1,
                             cap_user_time          : 1,
                             cap_user_time_zero     : 1,
                   };
               };
               __u16 pmc_width;
               __u16 time_shift;
               __u32 time_mult;
               __u64 time_offset;
               __u64 __reserved[120];   /* Pad to 1 k */
               __u64 data_head;         /* head in the data section */
               __u64 data_tail;         /* user-space written tail */
               __u64 data_offset;       /* where the buffer starts */
               __u64 data_size;         /* data buffer size */
               __u64 aux_head;
               __u64 aux_tail;
               __u64 aux_offset;
               __u64 aux_size;

           }

       The following list describes the fields in the <u>perf_event_mmap_page</u> structure in more detail:

       <u>version</u>
              Version number of this structure.

       <u>compat_version</u>
              The lowest version this is compatible with.

       <u>lock</u>   A seqlock for synchronization.

       <u>index</u>  A unique hardware counter identifier.

       <u>offset</u> When using rdpmc for reads this offset value must be added to the one returned by rdpmc to get the
              current total event count.

       <u>time_enabled</u>
              Time the event was active.

       <u>time_running</u>
              Time the event was running.

       <u>cap_usr_time</u> / <u>cap_usr_rdpmc</u> / <u>cap_bit0</u> (since Linux 3.4)
              There was a bug in the definition of <u>cap_usr_time</u> and <u>cap_usr_rdpmc</u> from  Linux  3.4  until  Linux
              3.11.   Both  bits  were  defined  to  point to the same location, so it was impossible to know if
              <u>cap_usr_time</u> or <u>cap_usr_rdpmc</u> were actually set.

              Starting with Linux 3.12, these are renamed to <u>cap_bit0</u> and you should use the  <u>cap_user_time</u>  and
              <u>cap_user_rdpmc</u> fields instead.

       <u>cap_bit0_is_deprecated</u> (since Linux 3.12)
              If  set,  this  bit  indicates  that  the kernel supports the properly separated <u>cap_user_time</u> and
              <u>cap_user_rdpmc</u> bits.

              If not-set, it indicates an older kernel where <u>cap_usr_time</u> and <u>cap_usr_rdpmc</u> map to the same  bit
              and thus both features should be used with caution.

       <u>cap_user_rdpmc</u> (since Linux 3.12)
              If  the  hardware  supports  user-space  read of performance counters without syscall (this is the
              "rdpmc" instruction on x86), then the following code can be used to do a read:

                  u32 seq, time_mult, time_shift, idx, width;
                  u64 count, enabled, running;
                  u64 cyc, time_offset;

                  do {
                      seq = pc-&gt;lock;
                      barrier();
                      enabled = pc-&gt;time_enabled;
                      running = pc-&gt;time_running;

                      if (pc-&gt;cap_usr_time &amp;&amp; enabled != running) {
                          cyc = rdtsc();
                          time_offset = pc-&gt;time_offset;
                          time_mult   = pc-&gt;time_mult;
                          time_shift  = pc-&gt;time_shift;
                      }

                      idx = pc-&gt;index;
                      count = pc-&gt;offset;

                      if (pc-&gt;cap_usr_rdpmc &amp;&amp; idx) {
                          width = pc-&gt;pmc_width;
                          count += rdpmc(idx - 1);
                      }

                      barrier();
                  } while (pc-&gt;lock != seq);

       <u>cap_user_time</u> (since Linux 3.12)
              This bit indicates the hardware has a constant, nonstop timestamp counter (TSC on x86).

       <u>cap_user_time_zero</u> (since Linux 3.12)
              Indicates the presence of <u>time_zero</u> which allows mapping timestamp values to the hardware clock.

       <u>pmc_width</u>
              If <u>cap_usr_rdpmc</u>, this field provides  the  bit-width  of  the  value  read  using  the  rdpmc  or
              equivalent instruction.  This can be used to sign extend the result like:

                  pmc &lt;&lt;= 64 - pmc_width;
                  pmc &gt;&gt;= 64 - pmc_width; // signed shift right
                  count += pmc;

       <u>time_shift</u>
       <u>time_mult</u>
       <u>time_offset</u>

              If  <u>cap_usr_time</u>,  these  fields  can  be  used  to  compute the time delta since <u>time_enabled</u> (in
              nanoseconds) using rdtsc or similar.

                  u64 quot, rem;
                  u64 delta;

                  quot  = cyc &gt;&gt; time_shift;
                  rem   = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1);
                  delta = time_offset + quot * time_mult +
                          ((rem * time_mult) &gt;&gt; time_shift);

              Where <u>time_offset</u>, <u>time_mult</u>, <u>time_shift</u>, and <u>cyc</u> are read in the seqcount loop  described  above.
              This delta can then be added to enabled and possible running (if idx), improving the scaling:

                  enabled += delta;
                  if (idx)
                      running += delta;
                  quot  = count / running;
                  rem   = count % running;
                  count = quot * enabled + (rem * enabled) / running;

       <u>time_zero</u> (since Linux 3.12)

              If  <u>cap_usr_time_zero</u>  is  set,  then the hardware clock (the TSC timestamp counter on x86) can be
              calculated from the <u>time_zero</u>, <u>time_mult</u>, and <u>time_shift</u> values:

                  time = timestamp - time_zero;
                  quot = time / time_mult;
                  rem  = time % time_mult;
                  cyc  = (quot &lt;&lt; time_shift) + (rem &lt;&lt; time_shift) / time_mult;

              And vice versa:

                  quot = cyc &gt;&gt; time_shift;
                  rem  = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1);
                  timestamp = time_zero + quot * time_mult +
                              ((rem * time_mult) &gt;&gt; time_shift);

       <u>data_head</u>
              This points to the head of the data section.  The value continuously increases, it does not  wrap.
              The  value  needs  to  be  manually  wrapped  by  the size of the mmap buffer before accessing the
              samples.

              On SMP-capable platforms, after reading the <u>data_head</u> value, user space should issue an rmb().

       <u>data_tail</u>
              When the mapping is <b>PROT_WRITE</b>, the <u>data_tail</u> value should be written by user space to reflect the
              last read data.  In this case, the kernel will not overwrite unread data.

       <u>data_offset</u> (since Linux 4.1)
              Contains the offset of the location in the mmap buffer where perf sample data begins.

       <u>data_size</u> (since Linux 4.1)
              Contains the size of the perf sample region within the mmap buffer.

       <u>aux_head</u>
       <u>aux_tail</u>
       <u>aux_offset</u>
       <u>aux_size</u>  <u>(since</u> <u>Linux</u> <u>4.1)</u>
              The AUX region allows <b><a href="../man2/mmap.2.html">mmap</a></b>(2)-ing  a  separate  sample  buffer  for  high-bandwidth  data  streams
              (separate from the main perf sample buffer).  An example of a high-bandwidth stream is instruction
              tracing support, as is found in newer Intel processors.

              To  set  up  an  AUX  area,  first  <u>aux_offset</u>  needs  to  be  set  with  an  offset  greater than
              <u>data_offset</u>+<u>data_size</u> and <u>aux_size</u> needs to be set to the desired buffer size.  The desired offset
              and size must be page aligned, and the size must be a power of two.  These values are then  passed
              to  mmap  in  order  to  map  the AUX buffer.  Pages in the AUX buffer are included as part of the
              <b>RLIMIT_MEMLOCK</b> resource limit (see <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2)), and also  as  part  of  the  <u>perf_event_mlock_kb</u>
              allowance.

              By default, the AUX buffer will be truncated if it will not fit in the available space in the ring
              buffer.   If  the  AUX buffer is mapped as a read only buffer, then it will operate in ring buffer
              mode where old data will be overwritten by new.  In overwrite mode, it might not  be  possible  to
              infer  where the new data began, and it is the consumer's job to disable measurement while reading
              to avoid possible data races.

              The <u>aux_head</u> and <u>aux_tail</u> ring buffer pointers have the same behavior and ordering  rules  as  the
              previous described <u>data_head</u> and <u>data_tail</u>.

       The following 2^n ring-buffer pages have the layout described below.

       If  <u>perf_event_attr.sample_id_all</u>  is set, then all event types will have the sample_type selected fields
       related to where/when (identity) an event took  place  (TID,  TIME,  ID,  CPU,  STREAM_ID)  described  in
       <b>PERF_RECORD_SAMPLE</b>  below,  it  will  be  stashed just after the <u>perf_event_header</u> and the fields already
       present for the existing fields, that is, at the end of the payload.  This allows a newer perf.data  file
       to be supported by older perf tools, with the new optional fields being ignored.

       The mmap values start with a header:

           struct perf_event_header {
               __u32   type;
               __u16   misc;
               __u16   size;
           };

       Below,  we  describe  the  <u>perf_event_header</u> fields in more detail.  For ease of reading, the fields with
       shorter descriptions are presented first.

       <u>size</u>   This indicates the size of the record.

       <u>misc</u>   The <u>misc</u> field contains additional information about the sample.

              The CPU mode can be determined from this value by masking with  <b>PERF_RECORD_MISC_CPUMODE_MASK</b>  and
              looking for one of the following (note these are not bit masks, only one can be set at a time):

              <b>PERF_RECORD_MISC_CPUMODE_UNKNOWN</b>
                     Unknown CPU mode.

              <b>PERF_RECORD_MISC_KERNEL</b>
                     Sample happened in the kernel.

              <b>PERF_RECORD_MISC_USER</b>
                     Sample happened in user code.

              <b>PERF_RECORD_MISC_HYPERVISOR</b>
                     Sample happened in the hypervisor.

              <b>PERF_RECORD_MISC_GUEST_KERNEL</b> (since Linux 2.6.35)
                     Sample happened in the guest kernel.

              <b>PERF_RECORD_MISC_GUEST_USER</b>  <b>(since</b> <b>Linux</b> <b>2.6.35)</b>
                     Sample happened in guest user code.

              Since the following three statuses are generated by different record types, they alias to the same
              bit:

              <b>PERF_RECORD_MISC_MMAP_DATA</b> (since Linux 3.10)
                     This is set when the mapping is not executable; otherwise the mapping is executable.

              <b>PERF_RECORD_MISC_COMM_EXEC</b> (since Linux 3.16)
                     This  is  set  for  a  <b>PERF_RECORD_COMM</b>  record on kernels more recent than Linux 3.16 if a
                     process name change was caused by an <b><a href="../man2/execve.2.html">execve</a></b>(2) system call.

              <b>PERF_RECORD_MISC_SWITCH_OUT</b> (since Linux 4.3)
                     When a <b>PERF_RECORD_SWITCH</b> or <b>PERF_RECORD_SWITCH_CPU_WIDE</b>  record  is  generated,  this  bit
                     indicates  that  the  context  switch is away from the current process (instead of into the
                     current process).

              In addition, the following bits can be set:

              <b>PERF_RECORD_MISC_EXACT_IP</b>
                     This indicates that the content of <b>PERF_SAMPLE_IP</b> points to  the  actual  instruction  that
                     triggered the event.  See also <u>perf_event_attr.precise_ip</u>.

              <b>PERF_RECORD_MISC_SWITCH_OUT_PREEMPT</b> (since Linux 4.17)
                     When   a  <b>PERF_RECORD_SWITCH</b>  or  <b>PERF_RECORD_SWITCH_CPU_WIDE</b>  record  is  generated,  this
                     indicates the context switch was a preemption.

              <b>PERF_RECORD_MISC_MMAP_BUILD_ID</b> (since Linux 5.12)
                     This indicates that the content of <b>PERF_SAMPLE_MMAP2</b>  contains  build-ID  data  instead  of
                     device major and minor numbers as well as the inode number.

              <b>PERF_RECORD_MISC_EXT_RESERVED</b> (since Linux 2.6.35)
                     This indicates there is extended data available (currently not used).

              <b>PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT</b>
                     This  bit  is  not  set  by  the kernel.  It is reserved for the user-space perf utility to
                     indicate that <u><a href="file:/proc/">/proc/</a></u>pid<u>/maps</u> parsing was taking too long and was stopped, and thus the mmap
                     records may be truncated.

       <u>type</u>   The <u>type</u> value is one of the below.  The values in the  corresponding  record  (that  follows  the
              header) depend on the <u>type</u> selected as shown.

              <b>PERF_RECORD_MMAP</b>
                  The MMAP events record the <b>PROT_EXEC</b> mappings so that we can correlate user-space IPs to code.
                  They have the following structure:

                      struct {
                          struct perf_event_header header;
                          u32    pid, tid;
                          u64    addr;
                          u64    len;
                          u64    pgoff;
                          char   filename[];
                      };

                  <u>pid</u>    is the process ID.

                  <u>tid</u>    is the thread ID.

                  <u>addr</u>   is  the  address  of  the allocated memory.  <u>len</u> is the length of the allocated memory.
                         <u>pgoff</u> is the page offset of the allocated memory.  <u>filename</u> is a string describing  the
                         backing of the allocated memory.

              <b>PERF_RECORD_LOST</b>
                  This record indicates when events are lost.

                      struct {
                          struct perf_event_header header;
                          u64    id;
                          u64    lost;
                          struct sample_id sample_id;
                      };

                  <u>id</u>     is the unique event ID for the samples that were lost.

                  <u>lost</u>   is the number of events that were lost.

              <b>PERF_RECORD_COMM</b>
                  This record indicates a change in the process name.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                          char   comm[];
                          struct sample_id sample_id;
                      };

                  <u>pid</u>    is the process ID.

                  <u>tid</u>    is the thread ID.

                  <u>comm</u>   is a string containing the new name of the process.

              <b>PERF_RECORD_EXIT</b>
                  This record indicates a process exit event.

                      struct {
                          struct perf_event_header header;
                          u32    pid, ppid;
                          u32    tid, ptid;
                          u64    time;
                          struct sample_id sample_id;
                      };

              <b>PERF_RECORD_THROTTLE</b>
              <b>PERF_RECORD_UNTHROTTLE</b>
                  This record indicates a throttle/unthrottle event.

                      struct {
                          struct perf_event_header header;
                          u64    time;
                          u64    id;
                          u64    stream_id;
                          struct sample_id sample_id;
                      };

              <b>PERF_RECORD_FORK</b>
                  This record indicates a fork event.

                      struct {
                          struct perf_event_header header;
                          u32    pid, ppid;
                          u32    tid, ptid;
                          u64    time;
                          struct sample_id sample_id;
                      };

              <b>PERF_RECORD_READ</b>
                  This record indicates a read event.

                      struct {
                          struct perf_event_header header;
                          u32    pid, tid;
                          struct read_format values;
                          struct sample_id sample_id;
                      };

              <b>PERF_RECORD_SAMPLE</b>
                  This record indicates a sample.

                      struct {
                          struct perf_event_header header;
                          u64    sample_id;   /* if PERF_SAMPLE_IDENTIFIER */
                          u64    ip;          /* if PERF_SAMPLE_IP */
                          u32    pid, tid;    /* if PERF_SAMPLE_TID */
                          u64    time;        /* if PERF_SAMPLE_TIME */
                          u64    addr;        /* if PERF_SAMPLE_ADDR */
                          u64    id;          /* if PERF_SAMPLE_ID */
                          u64    stream_id;   /* if PERF_SAMPLE_STREAM_ID */
                          u32    cpu, res;    /* if PERF_SAMPLE_CPU */
                          u64    period;      /* if PERF_SAMPLE_PERIOD */
                          struct read_format v;
                                              /* if PERF_SAMPLE_READ */
                          u64    nr;          /* if PERF_SAMPLE_CALLCHAIN */
                          u64    ips[nr];     /* if PERF_SAMPLE_CALLCHAIN */
                          u32    size;        /* if PERF_SAMPLE_RAW */
                          char   data[size];  /* if PERF_SAMPLE_RAW */
                          u64    bnr;         /* if PERF_SAMPLE_BRANCH_STACK */
                          struct perf_branch_entry lbr[bnr];
                                              /* if PERF_SAMPLE_BRANCH_STACK */
                          u64    abi;         /* if PERF_SAMPLE_REGS_USER */
                          u64    regs[<a href="../manmask/weight.mask.html">weight</a>(mask)];
                                              /* if PERF_SAMPLE_REGS_USER */
                          u64    size;        /* if PERF_SAMPLE_STACK_USER */
                          char   data[size];  /* if PERF_SAMPLE_STACK_USER */
                          u64    dyn_size;    /* if PERF_SAMPLE_STACK_USER &amp;&amp;
                                                 size != 0 */
                          union perf_sample_weight weight;
                                              /* if PERF_SAMPLE_WEIGHT */
                                              /* || PERF_SAMPLE_WEIGHT_STRUCT */
                          u64    data_src;    /* if PERF_SAMPLE_DATA_SRC */
                          u64    transaction; /* if PERF_SAMPLE_TRANSACTION */
                          u64    abi;         /* if PERF_SAMPLE_REGS_INTR */
                          u64    regs[<a href="../manmask/weight.mask.html">weight</a>(mask)];
                                              /* if PERF_SAMPLE_REGS_INTR */
                          u64    phys_addr;   /* if PERF_SAMPLE_PHYS_ADDR */
                          u64    cgroup;      /* if PERF_SAMPLE_CGROUP */
                          u64    data_page_size;
                                            /* if PERF_SAMPLE_DATA_PAGE_SIZE */
                          u64    code_page_size;
                                            /* if PERF_SAMPLE_CODE_PAGE_SIZE */
                          u64    size;        /* if PERF_SAMPLE_AUX */
                          char   data[size];  /* if PERF_SAMPLE_AUX */
                      };

                  <u>sample_id</u>
                      If  <b>PERF_SAMPLE_IDENTIFIER</b>  is  enabled,  a  64-bit  unique  ID  is  included.   This is a
                      duplication of the <b>PERF_SAMPLE_ID</b> <u>id</u> value, but included at the beginning of the sample so
                      parsers can easily obtain the value.

                  <u>ip</u>  If <b>PERF_SAMPLE_IP</b> is enabled, then a 64-bit instruction pointer value is included.

                  <u>pid</u>
                  <u>tid</u> If <b>PERF_SAMPLE_TID</b> is enabled, then a 32-bit process ID and 32-bit thread ID are included.

                  <u>time</u>
                      If <b>PERF_SAMPLE_TIME</b> is enabled, then a 64-bit timestamp is included.  This is obtained via
                      local_clock() which is a hardware timestamp if available and the jiffies value if not.

                  <u>addr</u>
                      If <b>PERF_SAMPLE_ADDR</b> is enabled, then a 64-bit address is included.  This  is  usually  the
                      address of a tracepoint, breakpoint, or software event; otherwise the value is 0.

                  <u>id</u>  If <b>PERF_SAMPLE_ID</b> is enabled, a 64-bit unique ID is included.  If the event is a member of
                      an  event group, the group leader ID is returned.  This ID is the same as the one returned
                      by <b>PERF_FORMAT_ID</b>.

                  <u>stream_id</u>
                      If  <b>PERF_SAMPLE_STREAM_ID</b>  is  enabled,  a  64-bit  unique   ID   is   included.    Unlike
                      <b>PERF_SAMPLE_ID</b>  the  actual  ID is returned, not the group leader.  This ID is the same as
                      the one returned by <b>PERF_FORMAT_ID</b>.

                  <u>cpu</u>
                  <u>res</u> If <b>PERF_SAMPLE_CPU</b> is enabled, this is a 32-bit value indicating which CPU was being used,
                      in addition to a reserved (unused) 32-bit value.

                  <u>period</u>
                      If <b>PERF_SAMPLE_PERIOD</b> is enabled, a 64-bit value indicating the current sampling period is
                      written.

                  <u>v</u>   If <b>PERF_SAMPLE_READ</b> is enabled, a structure of type  read_format  is  included  which  has
                      values  for  all events in the event group.  The values included depend on the <u>read_format</u>
                      value used at <b>perf_event_open</b>() time.

                  <u>nr</u>
                  <u>ips[nr]</u>
                      If <b>PERF_SAMPLE_CALLCHAIN</b> is enabled, then a 64-bit number is included which indicates  how
                      many following 64-bit instruction pointers will follow.  This is the current callchain.

                  <u>size</u>
                  <u>data[size]</u>
                      If <b>PERF_SAMPLE_RAW</b> is enabled, then a 32-bit value indicating size is included followed by
                      an  array  of  8-bit  values  of length size.  The values are padded with 0 to have 64-bit
                      alignment.

                      This RAW record data is opaque with respect to the ABI.  The ABI doesn't make any promises
                      with respect to the stability of its content, it may vary depending  on  event,  hardware,
                      and kernel version.

                  <u>bnr</u>
                  <u>lbr[bnr]</u>
                      If  <b>PERF_SAMPLE_BRANCH_STACK</b>  is  enabled,  then  a  64-bit value indicating the number of
                      records is included, followed by <u>bnr</u> <u>perf_branch_entry</u> structures which each  include  the
                      fields:

                      <u>from</u>   This indicates the source instruction (may not be a branch).

                      <u>to</u>     The branch target.

                      <u>mispred</u>
                             The branch target was mispredicted.

                      <u>predicted</u>
                             The branch target was predicted.

                      <u>in_tx</u> (since Linux 3.11)
                             The branch was in a transactional memory transaction.

                      <u>abort</u> (since Linux 3.11)
                             The branch was in an aborted transactional memory transaction.

                      <u>cycles</u> (since Linux 4.3)
                             This reports the number of cycles elapsed since the previous branch stack update.

                      The entries are from most to least recent, so the first entry has the most recent branch.

                      Support  for  <u>mispred</u>,  <u>predicted</u>,  and <u>cycles</u> is optional; if not supported, those values
                      will be 0.

                      The type of branches recorded is specified by the <u>branch_sample_type</u> field.

                  <u>abi</u>
                  <u>regs[<a href="../manmask/weight.mask.html">weight</a>(mask)]</u>
                      If <b>PERF_SAMPLE_REGS_USER</b> is enabled, then the user CPU registers are recorded.

                      The  <u>abi</u>  field  is  one   of   <b>PERF_SAMPLE_REGS_ABI_NONE</b>,   <b>PERF_SAMPLE_REGS_ABI_32</b>,   or
                      <b>PERF_SAMPLE_REGS_ABI_64</b>.

                      The   <u>regs</u>   field  is  an  array  of  the  CPU  registers  that  were  specified  by  the
                      <u>sample_regs_user</u> attr field.  The number of values is  the  number  of  bits  set  in  the
                      <u>sample_regs_user</u> bit mask.

                  <u>size</u>
                  <u>data[size]</u>
                  <u>dyn_size</u>
                      If  <b>PERF_SAMPLE_STACK_USER</b>  is enabled, then the user stack is recorded.  This can be used
                      to generate stack backtraces.  <u>size</u> is the size requested by the user in <u>sample_stack_user</u>
                      or else the maximum record size.  <u>data</u> is the stack data (a raw dump of the memory pointed
                      to by the stack pointer at the time of sampling).  <u>dyn_size</u> is the amount of data actually
                      dumped (can be less than <u>size</u>).  Note that <u>dyn_size</u> is omitted if <u>size</u> is 0.

                  <u>weight</u>
                      If <b>PERF_SAMPLE_WEIGHT</b>  or  <b>PERF_SAMPLE_WEIGHT_STRUCT</b>  is  enabled,  then  a  64-bit  value
                      provided by the hardware is recorded that indicates how costly the event was.  This allows
                      expensive events to stand out more clearly in profiles.

                  <u>data_src</u>
                      If <b>PERF_SAMPLE_DATA_SRC</b> is enabled, then a 64-bit value is recorded that is made up of the
                      following fields:

                      <u>mem_op</u>
                          Type of opcode, a bitwise combination of:

                          <b>PERF_MEM_OP_NA</b>          Not available
                          <b>PERF_MEM_OP_LOAD</b>        Load instruction
                          <b>PERF_MEM_OP_STORE</b>       Store instruction
                          <b>PERF_MEM_OP_PFETCH</b>      Prefetch
                          <b>PERF_MEM_OP_EXEC</b>        Executable code

                      <u>mem_lvl</u>
                          Memory  hierarchy  level  hit or miss, a bitwise combination of the following, shifted
                          left by <b>PERF_MEM_LVL_SHIFT</b>:

                          <b>PERF_MEM_LVL_NA</b>         Not available
                          <b>PERF_MEM_LVL_HIT</b>        Hit
                          <b>PERF_MEM_LVL_MISS</b>       Miss
                          <b>PERF_MEM_LVL_L1</b>         Level 1 cache
                          <b>PERF_MEM_LVL_LFB</b>        Line fill buffer
                          <b>PERF_MEM_LVL_L2</b>         Level 2 cache
                          <b>PERF_MEM_LVL_L3</b>         Level 3 cache
                          <b>PERF_MEM_LVL_LOC_RAM</b>    Local DRAM
                          <b>PERF_MEM_LVL_REM_RAM1</b>   Remote DRAM 1 hop
                          <b>PERF_MEM_LVL_REM_RAM2</b>   Remote DRAM 2 hops
                          <b>PERF_MEM_LVL_REM_CCE1</b>   Remote cache 1 hop
                          <b>PERF_MEM_LVL_REM_CCE2</b>   Remote cache 2 hops
                          <b>PERF_MEM_LVL_IO</b>         I/O memory
                          <b>PERF_MEM_LVL_UNC</b>        Uncached memory

                      <u>mem_snoop</u>
                          Snoop  mode,   a   bitwise   combination   of   the   following,   shifted   left   by
                          <b>PERF_MEM_SNOOP_SHIFT</b>:

                          <b>PERF_MEM_SNOOP_NA</b>       Not available
                          <b>PERF_MEM_SNOOP_NONE</b>     No snoop
                          <b>PERF_MEM_SNOOP_HIT</b>      Snoop hit
                          <b>PERF_MEM_SNOOP_MISS</b>     Snoop miss
                          <b>PERF_MEM_SNOOP_HITM</b>     Snoop hit modified

                      <u>mem_lock</u>
                          Lock   instruction,   a   bitwise  combination  of  the  following,  shifted  left  by
                          <b>PERF_MEM_LOCK_SHIFT</b>:

                          <b>PERF_MEM_LOCK_NA</b>        Not available
                          <b>PERF_MEM_LOCK_LOCKED</b>    Locked transaction

                      <u>mem_dtlb</u>
                          TLB access hit or miss, a bitwise  combination  of  the  following,  shifted  left  by
                          <b>PERF_MEM_TLB_SHIFT</b>:

                          <b>PERF_MEM_TLB_NA</b>         Not available
                          <b>PERF_MEM_TLB_HIT</b>        Hit
                          <b>PERF_MEM_TLB_MISS</b>       Miss
                          <b>PERF_MEM_TLB_L1</b>         Level 1 TLB
                          <b>PERF_MEM_TLB_L2</b>         Level 2 TLB
                          <b>PERF_MEM_TLB_WK</b>         Hardware walker
                          <b>PERF_MEM_TLB_OS</b>         OS fault handler

                  <u>transaction</u>
                      If the <b>PERF_SAMPLE_TRANSACTION</b> flag is set, then a 64-bit field is recorded describing the
                      sources of any transactional memory aborts.

                      The field is a bitwise combination of the following values:

                      <b>PERF_TXN_ELISION</b>
                             Abort from an elision type transaction (Intel-CPU-specific).

                      <b>PERF_TXN_TRANSACTION</b>
                             Abort from a generic transaction.

                      <b>PERF_TXN_SYNC</b>
                             Synchronous abort (related to the reported instruction).

                      <b>PERF_TXN_ASYNC</b>
                             Asynchronous abort (not related to the reported instruction).

                      <b>PERF_TXN_RETRY</b>
                             Retryable abort (retrying the transaction may have succeeded).

                      <b>PERF_TXN_CONFLICT</b>
                             Abort due to memory conflicts with other threads.

                      <b>PERF_TXN_CAPACITY_WRITE</b>
                             Abort due to write capacity overflow.

                      <b>PERF_TXN_CAPACITY_READ</b>
                             Abort due to read capacity overflow.

                      In  addition,  a  user-specified  abort  code can be obtained from the high 32 bits of the
                      field  by  shifting  right  by   <b>PERF_TXN_ABORT_SHIFT</b>   and   masking   with   the   value
                      <b>PERF_TXN_ABORT_MASK</b>.

                  <u>abi</u>
                  <u>regs[<a href="../manmask/weight.mask.html">weight</a>(mask)]</u>
                      If <b>PERF_SAMPLE_REGS_INTR</b> is enabled, then the user CPU registers are recorded.

                      The   <u>abi</u>   field   is   one  of  <b>PERF_SAMPLE_REGS_ABI_NONE</b>,  <b>PERF_SAMPLE_REGS_ABI_32</b>,  or
                      <b>PERF_SAMPLE_REGS_ABI_64</b>.

                      The  <u>regs</u>  field  is  an  array  of  the  CPU  registers  that  were  specified   by   the
                      <u>sample_regs_intr</u>  attr  field.   The  number  of  values  is the number of bits set in the
                      <u>sample_regs_intr</u> bit mask.

                  <u>phys_addr</u>
                      If the <b>PERF_SAMPLE_PHYS_ADDR</b> flag is set, then the 64-bit physical address is recorded.

                  <u>cgroup</u>
                      If the <b>PERF_SAMPLE_CGROUP</b> flag is set, then the  64-bit  cgroup  ID  (for  the  perf_event
                      subsystem)  is recorded.  To get the pathname of the cgroup, the ID should match to one in
                      a <b>PERF_RECORD_CGROUP</b>.

                  <u>data_page_size</u>
                      If the <b>PERF_SAMPLE_DATA_PAGE_SIZE</b> flag is set, then the 64-bit page size value of the <b>data</b>
                      address is recorded.

                  <u>code_page_size</u>
                      If the <b>PERF_SAMPLE_CODE_PAGE_SIZE</b> flag is set, then the 64-bit page size value of  the  <b>ip</b>
                      address is recorded.

                  <u>size</u>
                  <u>data</u>[<u>size</u>]
                      If <b>PERF_SAMPLE_AUX</b> is enabled, a snapshot of the aux buffer is recorded.

              <b>PERF_RECORD_MMAP2</b>
                  This record includes extended information on <b><a href="../man2/mmap.2.html">mmap</a></b>(2) calls returning executable mappings.  The
                  format is similar to that of the <b>PERF_RECORD_MMAP</b> record, but includes extra values that allow
                  uniquely  identifying shared mappings.  Depending on the <b>PERF_RECORD_MISC_MMAP_BUILD_ID</b> bit in
                  the header, the extra values have different layout and meanings.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                          u64    addr;
                          u64    len;
                          u64    pgoff;
                          union {
                              struct {
                                  u32    maj;
                                  u32    min;
                                  u64    ino;
                                  u64    ino_generation;
                              };
                              struct {   /* if PERF_RECORD_MISC_MMAP_BUILD_ID */
                                  u8     build_id_size;
                                  u8     __reserved_1;
                                  u16    __reserved_2;
                                  u8     build_id[20];
                              };
                          };
                          u32    prot;
                          u32    flags;
                          char   filename[];
                          struct sample_id sample_id;
                      };

                  <u>pid</u>    is the process ID.

                  <u>tid</u>    is the thread ID.

                  <u>addr</u>   is the address of the allocated memory.

                  <u>len</u>    is the length of the allocated memory.

                  <u>pgoff</u>  is the page offset of the allocated memory.

                  <u>maj</u>    is the major ID of the underlying device.

                  <u>min</u>    is the minor ID of the underlying device.

                  <u>ino</u>    is the inode number.

                  <u>ino_generation</u>
                         is the inode generation.

                  <u>build_id_size</u>
                         is the actual size of <u>build_id</u> field (up to 20).

                  <u>build_id</u>
                         is a raw data to identify a binary.

                  <u>prot</u>   is the protection information.

                  <u>flags</u>  is the flags information.

                  <u>filename</u>
                         is a string describing the backing of the allocated memory.

              <b>PERF_RECORD_AUX</b> (since Linux 4.1)
                  This record reports that new data is available in the separate AUX buffer region.

                      struct {
                          struct perf_event_header header;
                          u64    aux_offset;
                          u64    aux_size;
                          u64    flags;
                          struct sample_id sample_id;
                      };

                  <u>aux_offset</u>
                         offset in the AUX mmap region where the new data begins.

                  <u>aux_size</u>
                         size of the data made available.

                  <u>flags</u>  describes the AUX update.

                         <b>PERF_AUX_FLAG_TRUNCATED</b>
                                if set, then the data returned was truncated to fit the available buffer size.

                         <b>PERF_AUX_FLAG_OVERWRITE</b>
                                if set, then the data returned has overwritten previous data.

              <b>PERF_RECORD_ITRACE_START</b> (since Linux 4.1)
                  This record indicates which process has initiated an instruction trace event,  allowing  tools
                  to properly correlate the instruction addresses in the AUX buffer with the proper executable.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                      };

                  <u>pid</u>    process ID of the thread starting an instruction trace.

                  <u>tid</u>    thread ID of the thread starting an instruction trace.

              <b>PERF_RECORD_LOST_SAMPLES</b> (since Linux 4.2)
                  When using hardware sampling (such as Intel PEBS) this record indicates some number of samples
                  that may have been lost.

                      struct {
                          struct perf_event_header header;
                          u64    lost;
                          struct sample_id sample_id;
                      };

                  <u>lost</u>   the number of potentially lost samples.

              <b>PERF_RECORD_SWITCH</b> (since Linux 4.3)
                  This  record  indicates a context switch has happened.  The <b>PERF_RECORD_MISC_SWITCH_OUT</b> bit in
                  the <u>misc</u> field indicates whether it was a  context  switch  into  or  away  from  the  current
                  process.

                      struct {
                          struct perf_event_header header;
                          struct sample_id sample_id;
                      };

              <b>PERF_RECORD_SWITCH_CPU_WIDE</b> (since Linux 4.3)
                  As  with  <b>PERF_RECORD_SWITCH</b>  this record indicates a context switch has happened, but it only
                  occurs when sampling in CPU-wide mode and provides additional information on the process being
                  switched to/from.  The <b>PERF_RECORD_MISC_SWITCH_OUT</b> bit in the <u>misc</u> field indicates whether  it
                  was a context switch into or away from the current process.

                      struct {
                          struct perf_event_header header;
                          u32 next_prev_pid;
                          u32 next_prev_tid;
                          struct sample_id sample_id;
                      };

                  <u>next_prev_pid</u>
                         The  process ID of the previous (if switching in) or next (if switching out) process on
                         the CPU.

                  <u>next_prev_tid</u>
                         The thread ID of the previous (if switching in) or next (if switching  out)  thread  on
                         the CPU.

              <b>PERF_RECORD_NAMESPACES</b> (since Linux 4.11)
                  This record includes various namespace information of a process.

                      struct {
                          struct perf_event_header header;
                          u32    pid;
                          u32    tid;
                          u64    nr_namespaces;
                          struct { u64 dev, inode } [nr_namespaces];
                          struct sample_id sample_id;
                      };

                  <u>pid</u>    is the process ID

                  <u>tid</u>    is the thread ID

                  <u>nr_namespace</u>
                         is the number of namespaces in this record

                  Each namespace has <u>dev</u> and <u>inode</u> fields and is recorded in the fixed position like below:

                  <b>NET_NS_INDEX</b>=<b>0</b>
                         Network namespace

                  <b>UTS_NS_INDEX</b>=<b>1</b>
                         UTS namespace

                  <b>IPC_NS_INDEX</b>=<b>2</b>
                         IPC namespace

                  <b>PID_NS_INDEX</b>=<b>3</b>
                         PID namespace

                  <b>USER_NS_INDEX</b>=<b>4</b>
                         User namespace

                  <b>MNT_NS_INDEX</b>=<b>5</b>
                         Mount namespace

                  <b>CGROUP_NS_INDEX</b>=<b>6</b>
                         Cgroup namespace

              <b>PERF_RECORD_KSYMBOL</b> (since Linux 5.0)
                  This record indicates kernel symbol register/unregister events.

                      struct {
                          struct perf_event_header header;
                          u64    addr;
                          u32    len;
                          u16    ksym_type;
                          u16    flags;
                          char   name[];
                          struct sample_id sample_id;
                      };

                  <u>addr</u>   is the address of the kernel symbol.

                  <u>len</u>    is the length of the kernel symbol.

                  <u>ksym_type</u>
                         is the type of the kernel symbol.  Currently the following types are available:

                         <b>PERF_RECORD_KSYMBOL_TYPE_BPF</b>
                                The kernel symbol is a BPF function.

                  <u>flags</u>  If   the   <b>PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER</b>   is   set,  then  this  event  is  for
                         unregistering the kernel symbol.

              <b>PERF_RECORD_BPF_EVENT</b> (since Linux 5.0)
                  This record indicates BPF program is loaded or unloaded.

                      struct {
                          struct perf_event_header header;
                          u16 type;
                          u16 flags;
                          u32 id;
                          u8 tag[BPF_TAG_SIZE];
                          struct sample_id sample_id;
                      };

                  <u>type</u>   is one of the following values:

                         <b>PERF_BPF_EVENT_PROG_LOAD</b>
                                A BPF program is loaded

                         <b>PERF_BPF_EVENT_PROG_UNLOAD</b>
                                A BPF program is unloaded

                  <u>id</u>     is the ID of the BPF program.

                  <u>tag</u>    is the tag of the BPF program.  Currently, <b>BPF_TAG_SIZE</b> is defined as 8.

              <b>PERF_RECORD_CGROUP</b> (since Linux 5.7)
                  This record indicates a new cgroup is created and activated.

                      struct {
                          struct perf_event_header header;
                          u64    id;
                          char   path[];
                          struct sample_id sample_id;
                      };

                  <u>id</u>     is the cgroup identifier.  This can be also retrieved by  <b><a href="../man2/name_to_handle_at.2.html">name_to_handle_at</a></b>(2)  on  the
                         cgroup path (as a file handle).

                  <u>path</u>   is the path of the cgroup from the root.

              <b>PERF_RECORD_TEXT_POKE</b> (since Linux 5.8)
                  This  record indicates a change in the kernel text.  This includes addition and removal of the
                  text and the corresponding length is zero in this case.

                      struct {
                          struct perf_event_header header;
                          u64    addr;
                          u16    old_len;
                          u16    new_len;
                          u8     bytes[];
                          struct sample_id sample_id;
                      };

                  <u>addr</u>   is the address of the change

                  <u>old_len</u>
                         is the old length

                  <u>new_len</u>
                         is the new length

                  <u>bytes</u>  contains old bytes immediately followed by new bytes.

   <b>Overflow</b> <b>handling</b>
       Events can be set to notify when a threshold is crossed, indicating an overflow.  Overflow conditions can
       be captured by monitoring the event file descriptor with <b><a href="../man2/poll.2.html">poll</a></b>(2), <b><a href="../man2/select.2.html">select</a></b>(2), or <b><a href="../man7/epoll.7.html">epoll</a></b>(7).  Alternatively,
       the overflow events can be captured via sa  signal  handler,  by  enabling  I/O  signaling  on  the  file
       descriptor; see the discussion of the <b>F_SETOWN</b> and <b>F_SETSIG</b> operations in <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2).

       Overflows are generated only by sampling events (<u>sample_period</u> must have a nonzero value).

       There are two ways to generate overflow notifications.

       The  first  is  to set a <u>wakeup_events</u> or <u>wakeup_watermark</u> value that will trigger if a certain number of
       samples or bytes have been written to the mmap ring buffer.  In this case, <b>POLL_IN</b> is indicated.

       The other way is by use of  the  <b>PERF_EVENT_IOC_REFRESH</b>  ioctl.   This  ioctl  adds  to  a  counter  that
       decrements  each  time  the  event  overflows.   When nonzero, <b>POLL_IN</b> is indicated, but once the counter
       reaches 0 <b>POLL_HUP</b> is indicated and the underlying event is disabled.

       Refreshing an event group leader refreshes all siblings and refreshing with a parameter  of  0  currently
       enables infinite refreshes; these behaviors are unsupported and should not be relied on.

       Starting  with  Linux 3.18, <b>POLL_HUP</b> is indicated if the event being monitored is attached to a different
       process and that process exits.

   <b>rdpmc</b> <b>instruction</b>
       Starting with Linux 3.4 on x86, you can use the <u>rdpmc</u> instruction to get low-latency reads without having
       to enter the kernel.  Note that using <u>rdpmc</u> is not necessarily faster  than  other  methods  for  reading
       event values.

       Support  for  this can be detected with the <u>cap_usr_rdpmc</u> field in the mmap page; documentation on how to
       calculate event values can be found in that section.

       Originally, when rdpmc support was enabled, any process (not just ones with an active perf  event)  could
       use the rdpmc instruction to access the counters.  Starting with Linux 4.0, rdpmc support is only allowed
       if  an event is currently enabled in a process's context.  To restore the old behavior, write the value 2
       to <u><a href="file:/sys/devices/cpu/rdpmc">/sys/devices/cpu/rdpmc</a></u>.

   <b>perf_event</b> <b>ioctl</b> <b>calls</b>
       Various ioctls act on <b>perf_event_open</b>() file descriptors:

       <b>PERF_EVENT_IOC_ENABLE</b>
              This enables the individual event or event group specified by the file descriptor argument.

              If the <b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument,  then  all  events  in  a  group  are
              enabled, even if the event specified is not the group leader (but see BUGS).

       <b>PERF_EVENT_IOC_DISABLE</b>
              This disables the individual counter or event group specified by the file descriptor argument.

              Enabling  or  disabling the leader of a group enables or disables the entire group; that is, while
              the group leader is disabled, none of the counters in the group will count.  Enabling or disabling
              a member of a group other than the leader affects only that counter; disabling a non-leader  stops
              that counter from counting but doesn't affect any other counter.

              If  the  <b>PERF_IOC_FLAG_GROUP</b>  bit  is  set  in  the ioctl argument, then all events in a group are
              disabled, even if the event specified is not the group leader (but see BUGS).

       <b>PERF_EVENT_IOC_REFRESH</b>
              Non-inherited overflow counters can use this to  enable  a  counter  for  a  number  of  overflows
              specified  by  the  argument,  after which it is disabled.  Subsequent calls of this ioctl add the
              argument value to the current count.  An overflow notification with <b>POLL_IN</b>  set  will  happen  on
              each  overflow  until  the  count reaches 0; when that happens a notification with <b>POLL_HUP</b> set is
              sent and the event is disabled.  Using an argument of 0 is considered undefined behavior.

       <b>PERF_EVENT_IOC_RESET</b>
              Reset the event count specified by the file descriptor argument to zero.   This  resets  only  the
              counts; there is no way to reset the multiplexing <u>time_enabled</u> or <u>time_running</u> values.

              If the <b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument, then all events in a group are reset,
              even if the event specified is not the group leader (but see BUGS).

       <b>PERF_EVENT_IOC_PERIOD</b>
              This updates the overflow period for the event.

              Since  Linux  3.7  (on  ARM) and Linux 3.14 (all other architectures), the new period takes effect
              immediately.  On older kernels, the new period did not take effect until after the next overflow.

              The argument is a pointer to a 64-bit value containing the desired new period.

              Prior to Linux 2.6.36, this ioctl always failed due to a bug in the kernel.

       <b>PERF_EVENT_IOC_SET_OUTPUT</b>
              This tells the kernel to report event notifications to the specified file descriptor  rather  than
              the default one.  The file descriptors must all be on the same CPU.

              The argument specifies the desired file descriptor, or -1 if output should be ignored.

       <b>PERF_EVENT_IOC_SET_FILTER</b> (since Linux 2.6.33)
              This adds an ftrace filter to this event.

              The argument is a pointer to the desired ftrace filter.

       <b>PERF_EVENT_IOC_ID</b> (since Linux 3.12)
              This returns the event ID value for the given event file descriptor.

              The argument is a pointer to a 64-bit unsigned integer to hold the result.

       <b>PERF_EVENT_IOC_SET_BPF</b> (since Linux 4.1)
              This  allows  attaching  a  Berkeley  Packet Filter (BPF) program to an existing kprobe tracepoint
              event.  You need <b>CAP_PERFMON</b> (since Linux 5.8) or <b>CAP_SYS_ADMIN</b> privileges to use this ioctl.

              The argument is a BPF program file descriptor that was created by a previous <b><a href="../man2/bpf.2.html">bpf</a></b>(2) system call.

       <b>PERF_EVENT_IOC_PAUSE_OUTPUT</b> (since Linux 4.7)
              This allows pausing and resuming the event's ring-buffer.  A paused ring-buffer does  not  prevent
              generation  of  samples, but simply discards them.  The discarded samples are considered lost, and
              cause a <b>PERF_RECORD_LOST</b> sample to be generated when possible.  An overflow signal  may  still  be
              triggered by the discarded sample even though the ring-buffer remains empty.

              The  argument is an unsigned 32-bit integer.  A nonzero value pauses the ring-buffer, while a zero
              value resumes the ring-buffer.

       <b>PERF_EVENT_MODIFY_ATTRIBUTES</b> (since Linux 4.17)
              This allows modifying an existing event without the overhead of closing and reopening a new event.
              Currently this is supported only for breakpoint events.

              The argument is a pointer to a <u>perf_event_attr</u> structure containing the updated event settings.

       <b>PERF_EVENT_IOC_QUERY_BPF</b> (since Linux 4.16)
              This allows querying which Berkeley Packet Filter (BPF)  programs  are  attached  to  an  existing
              kprobe  tracepoint.   You  can  only  attach  one BPF program per event, but you can have multiple
              events attached to a tracepoint.  Querying this value on one tracepoint event returns  the  ID  of
              all BPF programs in all events attached to the tracepoint.  You need <b>CAP_PERFMON</b> (since Linux 5.8)
              or <b>CAP_SYS_ADMIN</b> privileges to use this ioctl.

              The argument is a pointer to a structure
                  struct perf_event_query_bpf {
                      __u32    ids_len;
                      __u32    prog_cnt;
                      __u32    ids[0];
                  };

              The  <u>ids_len</u>  field  indicates  the  number  of  ids  that can fit in the provided <u>ids</u> array.  The
              <u>prog_cnt</u> value is filled in by the kernel with the number of attached BPF programs.  The <u>ids</u> array
              is filled with the ID of each attached BPF program.  If there are more programs than will  fit  in
              the  array, then the kernel will return <b>ENOSPC</b> and <u>ids_len</u> will indicate the number of program IDs
              that were successfully copied.

   <b>Using</b> <b><a href="../man2/prctl.2.html">prctl</a>(2)</b>
       A  process  can  enable   or   disable   all   currently   open   event   groups   using   the   <b><a href="../man2/prctl.2.html">prctl</a></b>(2)
       <b>PR_TASK_PERF_EVENTS_ENABLE</b>  and  <b>PR_TASK_PERF_EVENTS_DISABLE</b>  operations.   This  applies  only to events
       created locally by the calling process.  This does  not  apply  to  events  created  by  other  processes
       attached  to  the  calling  process  or  inherited  events from a parent process.  Only group leaders are
       enabled and disabled, not any other members of the groups.

   <b>perf_event</b> <b>related</b> <b>configuration</b> <b>files</b>
       Files in <u><a href="file:/proc/sys/kernel/">/proc/sys/kernel/</a></u>

           <u><a href="file:/proc/sys/kernel/perf_event_paranoid">/proc/sys/kernel/perf_event_paranoid</a></u>
                  The <u>perf_event_paranoid</u> file can be set to restrict access to the performance counters.

                  <b>2</b>      allow only user-space measurements (default since Linux 4.6).
                  <b>1</b>      allow both kernel and user measurements (default before Linux 4.6).
                  <b>0</b>      allow access to CPU-specific data but not raw tracepoint samples.
                  <b>-1</b>     no restrictions.

                  The existence of the <u>perf_event_paranoid</u> file is the official  method  for  determining  if  a
                  kernel supports <b>perf_event_open</b>().

           <u><a href="file:/proc/sys/kernel/perf_event_max_sample_rate">/proc/sys/kernel/perf_event_max_sample_rate</a></u>
                  This  sets the maximum sample rate.  Setting this too high can allow users to sample at a rate
                  that impacts overall machine performance and potentially lock up  the  machine.   The  default
                  value is 100000 (samples per second).

           <u><a href="file:/proc/sys/kernel/perf_event_max_stack">/proc/sys/kernel/perf_event_max_stack</a></u>
                  This file sets the maximum depth of stack frame entries reported when generating a call trace.

           <u><a href="file:/proc/sys/kernel/perf_event_mlock_kb">/proc/sys/kernel/perf_event_mlock_kb</a></u>
                  Maximum number of pages an unprivileged user can <b><a href="../man2/mlock.2.html">mlock</a></b>(2).  The default is 516 (kB).

       Files in <u><a href="file:/sys/bus/event_source/devices/">/sys/bus/event_source/devices/</a></u>

           Since  Linux  2.6.34, the kernel supports having multiple PMUs available for monitoring.  Information
           on how to program these PMUs can be found under  <u><a href="file:/sys/bus/event_source/devices/">/sys/bus/event_source/devices/</a></u>.   Each  subdirectory
           corresponds to a different PMU.

           <u><a href="file:/sys/bus/event_source/devices/">/sys/bus/event_source/devices/</a>*/type</u> (since Linux 2.6.38)
                  This  contains  an  integer  that can be used in the <u>type</u> field of <u>perf_event_attr</u> to indicate
                  that you wish to use this PMU.

           <u><a href="file:/sys/bus/event_source/devices/cpu/rdpmc">/sys/bus/event_source/devices/cpu/rdpmc</a></u> (since Linux 3.4)
                  If this file is 1, then direct user-space access  to  the  performance  counter  registers  is
                  allowed via the rdpmc instruction.  This can be disabled by echoing 0 to the file.

                  As  of  Linux 4.0 the behavior has changed, so that 1 now means only allow access to processes
                  with active perf events, with 2 indicating the old allow-anyone-access behavior.

           <u><a href="file:/sys/bus/event_source/devices/">/sys/bus/event_source/devices/</a>*/format/</u> (since Linux 3.4)
                  This subdirectory contains information on the architecture-specific  subfields  available  for
                  programming the various <u>config</u> fields in the <u>perf_event_attr</u> struct.

                  The  content  of each file is the name of the config field, followed by a colon, followed by a
                  series of integer bit ranges separated by commas.  For example, the file <u>event</u> may contain the
                  value <u>config1:1,6-10,44</u> which indicates that event is an attribute that occupies bits  1,6–10,
                  and 44 of <u>perf_event_attr::config1</u>.

           <u><a href="file:/sys/bus/event_source/devices/">/sys/bus/event_source/devices/</a>*/events/</u> (since Linux 3.4)
                  This  subdirectory contains files with predefined events.  The contents are strings describing
                  the event settings expressed in  terms  of  the  fields  found  in  the  previously  mentioned
                  <u>./format/</u>  directory.   These  are not necessarily complete lists of all events supported by a
                  PMU, but usually a subset of events deemed useful or interesting.

                  The content of each file is a list of attribute names separated by commas.  Each entry has  an
                  optional  value (either hex or decimal).  If no value is specified, then it is assumed to be a
                  single-bit  field  with  a  value  of   1.    An   example   entry   may   look   like   this:
                  <u>event=0x2,inv,ldlat=3</u>.

           <u><a href="file:/sys/bus/event_source/devices/">/sys/bus/event_source/devices/</a>*/uevent</u>
                  This file is the standard kernel device interface for injecting hotplug events.

           <u><a href="file:/sys/bus/event_source/devices/">/sys/bus/event_source/devices/</a>*/cpumask</u> (since Linux 3.7)
                  The  <u>cpumask</u>  file  contains a comma-separated list of integers that indicate a representative
                  CPU number for each socket (package) on the motherboard.   This  is  needed  when  setting  up
                  uncore or northbridge events, as those PMUs present socket-wide events.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>perf_event_open</b>() returns the new file descriptor.  On error, -1 is returned and <u>errno</u> is set
       to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The errors returned by <b>perf_event_open</b>() can be inconsistent, and may vary across processor architectures
       and performance monitoring units.

       <b>E2BIG</b>  Returned  if  the  <u>perf_event_attr</u> <u>size</u> value is too small (smaller than <b>PERF_ATTR_SIZE_VER0</b>), too
              big (larger than the page size), or larger than the kernel supports and the extra  bytes  are  not
              zero.   When  <b>E2BIG</b> is returned, the <u>perf_event_attr</u> <u>size</u> field is overwritten by the kernel to be
              the size of the structure it was expecting.

       <b>EACCES</b> Returned when the  requested  event  requires  <b>CAP_PERFMON</b>  (since  Linux  5.8)  or  <b>CAP_SYS_ADMIN</b>
              permissions  (or  a  more  permissive  perf_event  paranoid  setting).  Some common cases where an
              unprivileged process may encounter this error: attaching to a process owned by a  different  user;
              monitoring all processes on a given CPU (i.e., specifying the <u>pid</u> argument as -1); and not setting
              <u>exclude_kernel</u> when the paranoid setting requires it.

       <b>EBADF</b>  Returned  if  the  <u>group_fd</u>  file descriptor is not valid, or, if <b>PERF_FLAG_PID_CGROUP</b> is set, the
              cgroup file descriptor in <u>pid</u> is not valid.

       <b>EBUSY</b> (since Linux 4.1)
              Returned if another event already has exclusive access to the PMU.

       <b>EFAULT</b> Returned if the <u>attr</u> pointer points at an invalid memory address.

       <b>EINTR</b>  Returned when trying to mix perf and ftrace handling for a uprobe.

       <b>EINVAL</b> Returned if the specified event is invalid.  There are many possible reasons  for  this.   A  not-
              exhaustive  list:  <u>sample_freq</u>  is  higher  than  the maximum setting; the <u>cpu</u> to monitor does not
              exist; <u>read_format</u> is out of range; <u>sample_type</u> is out of range; the <u>flags</u> value is out of  range;
              <u>exclusive</u>  or  <u>pinned</u>  set and the event is not a group leader; the event <u>config</u> values are out of
              range or set reserved bits; the generic event selected is not supported; or there  is  not  enough
              room to add the selected event.

       <b>EMFILE</b> Each  opened  event  uses  one  file descriptor.  If a large number of events are opened, the per-
              process limit on the number of open file descriptors will be reached, and no more  events  can  be
              created.

       <b>ENODEV</b> Returned when the event involves a feature not supported by the current CPU.

       <b>ENOENT</b> Returned  if  the  <u>type</u>  setting  is  not valid.  This error is also returned for some unsupported
              generic events.

       <b>ENOSPC</b> Prior to Linux 3.3, if there was not enough room for the event, <b>ENOSPC</b>  was  returned.   In  Linux
              3.3,  this  was  changed  to  <b>EINVAL</b>.   <b>ENOSPC</b> is still returned if you try to add more breakpoint
              events than supported by the hardware.

       <b>ENOSYS</b> Returned if <b>PERF_SAMPLE_STACK_USER</b> is set in <u>sample_type</u> and it is not supported by hardware.

       <b>EOPNOTSUPP</b>
              Returned if an event requiring a specific hardware feature is requested but there is  no  hardware
              support.   This  includes requesting low-skid events if not supported, branch tracing if it is not
              available, sampling if no PMU interrupt is available, and branch stacks for software events.

       <b>EOVERFLOW</b> (since Linux 4.8)
              Returned if <b>PERF_SAMPLE_CALLCHAIN</b> is requested and <u>sample_max_stack</u> is  larger  than  the  maximum
              specified in <u><a href="file:/proc/sys/kernel/perf_event_max_stack">/proc/sys/kernel/perf_event_max_stack</a></u>.

       <b>EPERM</b>  Returned  on  many  (but  not  all)  architectures  when  an unsupported <u>exclude_hv</u>, <u>exclude_idle</u>,
              <u>exclude_user</u>, or <u>exclude_kernel</u> setting is specified.

              It can also happen, as with <b>EACCES</b>, when the requested event  requires  <b>CAP_PERFMON</b>  (since  Linux
              5.8)  or  <b>CAP_SYS_ADMIN</b>  permissions  (or  a  more  permissive perf_event paranoid setting).  This
              includes setting a breakpoint on a kernel  address,  and  (since  Linux  3.13)  setting  a  kernel
              function-trace tracepoint.

       <b>ESRCH</b>  Returned if attempting to attach to a process that does not exist.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>perf_event_open</b>()  was  introduced in Linux 2.6.31 but was called <b>perf_counter_open</b>().  It was renamed in
       Linux 2.6.32.

</pre><h4><b>NOTES</b></h4><pre>
       The official way of knowing if <b>perf_event_open</b>() support is enabled is checking for the existence of  the
       file <u><a href="file:/proc/sys/kernel/perf_event_paranoid">/proc/sys/kernel/perf_event_paranoid</a></u>.

       <b>CAP_PERFMON</b>  capability  (since  Linux  5.8)  provides  secure  approach  to  performance  monitoring and
       observability operations in a system according to the principal of least privilege (POSIX IEEE  1003.1e).
       Accessing  system  performance  monitoring and observability operations using <b>CAP_PERFMON</b> rather than the
       much more powerful <b>CAP_SYS_ADMIN</b> excludes chances to misuse credentials and makes operations more secure.
       <b>CAP_SYS_ADMIN</b> usage for secure system performance monitoring and observability is discouraged in favor of
       the <b>CAP_PERFMON</b> capability.

</pre><h4><b>BUGS</b></h4><pre>
       The <b>F_SETOWN_EX</b> option to <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) is needed to properly get  overflow  signals  in  threads.   This  was
       introduced in Linux 2.6.32.

       Prior  to Linux 2.6.33 (at least for x86), the kernel did not check if events could be scheduled together
       until read time.  The same happens on all known kernels if the NMI watchdog is enabled.   This  means  to
       see  if  a  given set of events works you have to <b>perf_event_open</b>(), start, then read before you know for
       sure you can get valid measurements.

       Prior to Linux 2.6.34, event constraints were not enforced by the kernel.   In  that  case,  some  events
       would silently return "0" if the kernel scheduled them in an improper counter slot.

       Prior to Linux 2.6.34, there was a bug when multiplexing where the wrong results could be returned.

       Kernels  from  Linux 2.6.35 to Linux 2.6.39 can quickly crash the kernel if "inherit" is enabled and many
       threads are started.

       Prior to Linux 2.6.35, <b>PERF_FORMAT_GROUP</b> did not work with attached processes.

       There is a bug in the kernel code between Linux 2.6.36 and Linux 3.0 that ignores the  "watermark"  field
       and acts as if a wakeup_event was chosen if the union has a nonzero value in it.

       From  Linux  2.6.31  to Linux 3.4, the <b>PERF_IOC_FLAG_GROUP</b> ioctl argument was broken and would repeatedly
       operate on the event specified rather than iterating across all sibling events in a group.

       From Linux 3.4 to Linux 3.11, the mmap <u>cap_usr_rdpmc</u> and <u>cap_usr_time</u> bits mapped to the  same  location.
       Code should migrate to the new <u>cap_user_rdpmc</u> and <u>cap_user_time</u> fields instead.

       Always  double-check  your  results!   Various  generalized  events  have had wrong values.  For example,
       retired branches measured the wrong thing on AMD machines until Linux 2.6.35.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following is a short example that measures the total instruction count of a call to <b><a href="../man3/printf.3.html">printf</a></b>(3).

       #include &lt;<a href="file:/usr/include/linux/perf_event.h">linux/perf_event.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;sys/ioctl.h&gt;
       #include &lt;sys/syscall.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       static long
       perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
                       int cpu, int group_fd, unsigned long flags)
       {
           int ret;

           ret = syscall(SYS_perf_event_open, hw_event, pid, cpu,
                         group_fd, flags);
           return ret;
       }

       int
       main(void)
       {
           int                     fd;
           long long               count;
           struct perf_event_attr  pe;

           memset(&amp;pe, 0, sizeof(pe));
           pe.type = PERF_TYPE_HARDWARE;
           pe.size = sizeof(pe);
           pe.config = PERF_COUNT_HW_INSTRUCTIONS;
           pe.disabled = 1;
           pe.exclude_kernel = 1;
           pe.exclude_hv = 1;

           fd = perf_event_open(&amp;pe, 0, -1, -1, 0);
           if (fd == -1) {
              fprintf(stderr, "Error opening leader %llx\n", pe.config);
              exit(EXIT_FAILURE);
           }

           ioctl(fd, PERF_EVENT_IOC_RESET, 0);
           ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);

           printf("Measuring instruction count for this printf\n");

           ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);
           read(fd, &amp;count, sizeof(count));

           printf("Used %lld instructions\n", count);

           close(fd);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perf.1.html">perf</a></b>(1), <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man2/open.2.html">open</a></b>(2), <b><a href="../man2/prctl.2.html">prctl</a></b>(2), <b><a href="../man2/read.2.html">read</a></b>(2)

       <u>Documentation/admin-guide/perf-security.rst</u> in the kernel source tree

Linux man-pages 6.9.1                              2024-06-15                                 <u><a href="../man2/perf_event_open.2.html">perf_event_open</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>