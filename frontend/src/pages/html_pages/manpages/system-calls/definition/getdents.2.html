<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>getdents, getdents64 - get directory entries</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       getdents, getdents64 - get directory entries

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/syscall.h&gt;</b>      /* Definition of <b>SYS_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>long</b> <b>syscall(SYS_getdents,</b> <b>unsigned</b> <b>int</b> <u>fd</u><b>,</b> <b>struct</b> <b>linux_dirent</b> <b>*</b><u>dirp</u><b>,</b>
                    <b>unsigned</b> <b>int</b> <u>count</u><b>);</b>

       <b>#define</b> <b>_GNU_SOURCE</b>           /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/dirent.h">dirent.h</a>&gt;</b>

       <b>ssize_t</b> <b>getdents64(int</b> <u>fd</u><b>,</b> <b>void</b> <u>dirp</u><b>[.</b><u>count</u><b>],</b> <b>size_t</b> <u>count</u><b>);</b>

       <u>Note</u>: glibc provides no wrapper for <b>getdents</b>(), necessitating the use of <b><a href="../man2/syscall.2.html">syscall</a></b>(2).

       <u>Note</u>: There is no definition of <u>struct</u> <u>linux_dirent</u> in glibc; see NOTES.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  are  not  the  interfaces  you  are  interested in.  Look at <b><a href="../man3/readdir.3.html">readdir</a></b>(3) for the POSIX-conforming C
       library interface.  This page documents the bare kernel system call interfaces.

   <b>getdents()</b>
       The system call <b>getdents</b>() reads several <u>linux_dirent</u> structures from the directory referred  to  by  the
       open  file  descriptor  <u>fd</u>  into the buffer pointed to by <u>dirp</u>.  The argument <u>count</u> specifies the size of
       that buffer.

       The <u>linux_dirent</u> structure is declared as follows:

           struct linux_dirent {
               unsigned long  d_ino;     /* Inode number */
               unsigned long  d_off;     /* Not an offset; see below */
               unsigned short d_reclen;  /* Length of this <u>linux_dirent</u> */
               char           d_name[];  /* Filename (null-terminated) */
                                 /* length is actually (d_reclen - 2 -
                                    offsetof(struct linux_dirent, d_name)) */
               /*
               char           pad;       // Zero padding byte
               char           d_type;    // File type (only since Linux
                                         // 2.6.4); offset is (d_reclen - 1)
               */
           }

       <u>d_ino</u> is an inode number.  <u>d_off</u> is a filesystem-specific value with no specific meaning to  user  space,
       though  on  older  filesystems it used to be the distance from the start of the directory to the start of
       the next <u>linux_dirent</u>; see <b><a href="../man3/readdir.3.html">readdir</a></b>(3)<b>.</b>  <u>d_reclen</u> is the size of this entire <u>linux_dirent</u>.   <u>d_name</u>  is  a
       null-terminated filename.

       <u>d_type</u>  is  a  byte  at  the  end  of the structure that indicates the file type.  It contains one of the
       following values (defined in <u>&lt;dirent.h&gt;</u>):

       <b>DT_BLK</b>      This is a block device.

       <b>DT_CHR</b>      This is a character device.

       <b>DT_DIR</b>      This is a directory.

       <b>DT_FIFO</b>     This is a named pipe (FIFO).

       <b>DT_LNK</b>      This is a symbolic link.

       <b>DT_REG</b>      This is a regular file.

       <b>DT_SOCK</b>     This is a UNIX domain socket.

       <b>DT_UNKNOWN</b>  The file type is unknown.

       The <u>d_type</u> field is implemented since Linux 2.6.4.  It occupies a space that was previously a zero-filled
       padding byte in the <u>linux_dirent</u> structure.  Thus, on kernels up to and including Linux 2.6.3, attempting
       to access this field always provides the value 0 (<b>DT_UNKNOWN</b>).

       Currently, only some filesystems (among them:  Btrfs,  ext2,  ext3,  and  ext4)  have  full  support  for
       returning the file type in <u>d_type</u>.  All applications must properly handle a return of <b>DT_UNKNOWN</b>.

   <b>getdents64()</b>
       The  original  Linux  <b>getdents</b>()  system  call  did  not handle large filesystems and large file offsets.
       Consequently, Linux 2.4 added <b>getdents64</b>(), with  wider  types  for  the  <u>d_ino</u>  and  <u>d_off</u>  fields.   In
       addition, <b>getdents64</b>() supports an explicit <u>d_type</u> field.

       The <b>getdents64</b>() system call is like <b>getdents</b>(), except that its second argument is a pointer to a buffer
       containing structures of the following type:

           struct linux_dirent64 {
               ino64_t        d_ino;    /* 64-bit inode number */
               off64_t        d_off;    /* Not an offset; see getdents() */
               unsigned short d_reclen; /* Size of this dirent */
               unsigned char  d_type;   /* File type */
               char           d_name[]; /* Filename (null-terminated) */
           };

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  the number of bytes read is returned.  On end of directory, 0 is returned.  On error, -1 is
       returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EBADF</b>  Invalid file descriptor <u>fd</u>.

       <b>EFAULT</b> Argument points outside the calling process's address space.

       <b>EINVAL</b> Result buffer is too small.

       <b>ENOENT</b> No such directory.

       <b>ENOTDIR</b>
              File descriptor does not refer to a directory.

</pre><h4><b>STANDARDS</b></h4><pre>
       None.

</pre><h4><b>HISTORY</b></h4><pre>
       SVr4.

       <b>getdents64</b>()
              glibc 2.30.

</pre><h4><b>NOTES</b></h4><pre>
       glibc does not provide a wrapper for <b>getdents</b>(); call <b>getdents</b>() using <b><a href="../man2/syscall.2.html">syscall</a></b>(2).  In that case you will
       need to define the <u>linux_dirent</u> or <u>linux_dirent64</u> structure yourself.

       Probably, you want to use <b><a href="../man3/readdir.3.html">readdir</a></b>(3) instead of these system calls.

       These calls supersede <b><a href="../man2/readdir.2.html">readdir</a></b>(2).

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below demonstrates the use of <b>getdents</b>().  The following output shows an example of  what  we
       see when running this program on an ext2 directory:

           $ <b>./a.out</b> <b>/testfs/</b>
           --------------- nread=120 ---------------
           inode#    file type  d_reclen  d_off   d_name
                  2  directory    16         12  .
                  2  directory    16         24  ..
                 11  directory    24         44  lost+found
                 12  regular      16         56  a
             228929  directory    16         68  sub
              16353  directory    16         80  sub2
             130817  directory    16       4096  sub3

   <b>Program</b> <b>source</b>

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/dirent.h">dirent.h</a>&gt;     /* Defines DT_* constants */
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/syscall.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       struct linux_dirent {
           unsigned long  d_ino;
           off_t          d_off;
           unsigned short d_reclen;
           char           d_name[];
       };

       #define BUF_SIZE 1024

       int
       main(int argc, char *argv[])
       {
           int                  fd;
           char                 d_type;
           char                 buf[BUF_SIZE];
           long                 nread;
           struct linux_dirent  *d;

           fd = open(argc &gt; 1 ? argv[1] : ".", O_RDONLY | O_DIRECTORY);
           if (fd == -1)
               err(EXIT_FAILURE, "open");

           for (;;) {
               nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);
               if (nread == -1)
                   err(EXIT_FAILURE, "getdents");

               if (nread == 0)
                   break;

               printf("--------------- nread=%ld ---------------\n", nread);
               printf("inode#    file type  d_reclen  d_off   d_name\n");
               for (size_t bpos = 0; bpos &lt; nread;) {
                   d = (struct linux_dirent *) (buf + bpos);
                   printf("%8lu  ", d-&gt;d_ino);
                   d_type = *(buf + bpos + d-&gt;d_reclen - 1);
                   printf("%-10s ", (d_type == DT_REG) ?  "regular" :
                                    (d_type == DT_DIR) ?  "directory" :
                                    (d_type == DT_FIFO) ? "FIFO" :
                                    (d_type == DT_SOCK) ? "socket" :
                                    (d_type == DT_LNK) ?  "symlink" :
                                    (d_type == DT_BLK) ?  "block dev" :
                                    (d_type == DT_CHR) ?  "char dev" : "???");
                   printf("%4d %10jd  %s\n", d-&gt;d_reclen,
                          (intmax_t) d-&gt;d_off, d-&gt;d_name);
                   bpos += d-&gt;d_reclen;
               }
           }

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/readdir.2.html">readdir</a></b>(2), <b><a href="../man3/readdir.3.html">readdir</a></b>(3), <b><a href="../man7/inode.7.html">inode</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                        <u><a href="../man2/getdents.2.html">getdents</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>