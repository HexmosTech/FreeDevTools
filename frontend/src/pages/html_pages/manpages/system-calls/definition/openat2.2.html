<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>openat2 - open and possibly create a file (extended)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       openat2 - open and possibly create a file (extended)

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;</b>          /* Definition of <b>O_*</b> and <b>S_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/linux/openat2.h">linux/openat2.h</a>&gt;</b>  /* Definition of <b>RESOLVE_*</b> constants */
       <b>#include</b> <b>&lt;sys/syscall.h&gt;</b>    /* Definition of <b>SYS_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>long</b> <b>syscall(SYS_openat2,</b> <b>int</b> <u>dirfd</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>pathname</u><b>,</b>
                    <b>struct</b> <b>open_how</b> <b>*</b><u>how</u><b>,</b> <b>size_t</b> <u>size</u><b>);</b>

       <u>Note</u>: glibc provides no wrapper for <b>openat2</b>(), necessitating the use of <b><a href="../man2/syscall.2.html">syscall</a></b>(2).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>openat2</b>() system call is an extension of <b><a href="../man2/openat.2.html">openat</a></b>(2) and provides a superset of its functionality.

       The <b>openat2</b>() system call opens the file specified by <u>pathname</u>.  If the specified file does not exist, it
       may optionally (if <b>O_CREAT</b> is specified in <u>how.flags</u>) be created.

       As  with  <b><a href="../man2/openat.2.html">openat</a></b>(2), if <u>pathname</u> is a relative pathname, then it is interpreted relative to the directory
       referred to by the file descriptor <u>dirfd</u> (or the current working directory of  the  calling  process,  if
       <u>dirfd</u> is the special value <b>AT_FDCWD</b>).  If <u>pathname</u> is an absolute pathname, then <u>dirfd</u> is ignored (unless
       <u>how.resolve</u> contains <b>RESOLVE_IN_ROOT</b>, in which case <u>pathname</u> is resolved relative to <u>dirfd</u>).

       Rather  than  taking a single <u>flags</u> argument, an extensible structure (<u>how</u>) is passed to allow for future
       extensions.  The <u>size</u> argument must be specified as <u>sizeof(struct</u> <u>open_how)</u>.

   <b>The</b> <b>open_how</b> <b>structure</b>
       The <u>how</u> argument specifies how <u>pathname</u> should be opened, and acts as a superset of the  <u>flags</u>  and  <u>mode</u>
       arguments   to   <b><a href="../man2/openat.2.html">openat</a></b>(2).   This  argument  is  a  pointer  to  an  <u>open_how</u>  structure,  described  in
       <b><a href="../man2type/open_how.2type.html">open_how</a></b>(2type).

       Any future extensions to <b>openat2</b>() will be implemented as new fields appended to the <u>open_how</u>  structure,
       with  a zero value in a new field resulting in the kernel behaving as though that extension field was not
       present.   Therefore,  the  caller  <u>must</u>  zero-fill  this  structure   on   initialization.    (See   the
       "Extensibility" section of the <b>NOTES</b> for more detail on why this is necessary.)

       The fields of the <u>open_how</u> structure are as follows:

       <u>flags</u>  This field specifies the file creation and file status flags to use when opening the file.  All of
              the <b>O_*</b> flags defined for <b><a href="../man2/openat.2.html">openat</a></b>(2) are valid <b>openat2</b>() flag values.

              Whereas  <b><a href="../man2/openat.2.html">openat</a></b>(2)  ignores  unknown  bits  in  its  <u>flags</u> argument, <b>openat2</b>() returns an error if
              unknown or conflicting flags are specified in <u>how.flags</u>.

       <u>mode</u>   This field specifies the mode for the new file, with identical semantics to the <u>mode</u>  argument  of
              <b><a href="../man2/openat.2.html">openat</a></b>(2).

              Whereas <b><a href="../man2/openat.2.html">openat</a></b>(2) ignores bits other than those in the range <u>07777</u> in its <u>mode</u> argument, <b>openat2</b>()
              returns  an  error if <u>how.mode</u> contains bits other than <u>07777</u>.  Similarly, an error is returned if
              <b>openat2</b>() is called with a nonzero <u>how.mode</u> and <u>how.flags</u> does not contain <b>O_CREAT</b> or <b>O_TMPFILE</b>.

       <u>resolve</u>
              This is a bit-mask of flags that modify the way in  which  <b>all</b>  components  of  <u>pathname</u>  will  be
              resolved.  (See <b><a href="../man7/path_resolution.7.html">path_resolution</a></b>(7) for background information.)

              The  primary use case for these flags is to allow trusted programs to restrict how untrusted paths
              (or paths inside untrusted directories) are resolved.  The  full  list  of  <u>resolve</u>  flags  is  as
              follows:

              <b>RESOLVE_BENEATH</b>
                     Do  not  permit  the path resolution to succeed if any component of the resolution is not a
                     descendant of the directory indicated by <u>dirfd</u>.  This causes absolute symbolic  links  (and
                     absolute values of <u>pathname</u>) to be rejected.

                     Currently,  this  flag  also disables magic-link resolution (see below).  However, this may
                     change in the future.  Therefore, to ensure that magic links are not resolved,  the  caller
                     should explicitly specify <b>RESOLVE_NO_MAGICLINKS</b>.

              <b>RESOLVE_IN_ROOT</b>
                     Treat  the  directory  referred to by <u>dirfd</u> as the root directory while resolving <u>pathname</u>.
                     Absolute symbolic links are interpreted relative  to  <u>dirfd</u>.   If  a  prefix  component  of
                     <u>pathname</u>  equates  to <u>dirfd</u>, then an immediately following <u>..</u> component likewise equates to
                     <u>dirfd</u> (just as <u><a href="file:/..">/..</a></u> is traditionally equivalent to <u>/</u>).  If <u>pathname</u> is an absolute path,  it
                     is also interpreted relative to <u>dirfd</u>.

                     The  effect  of  this  flag  is  as  though  the  calling  process  had  used  <b><a href="../man2/chroot.2.html">chroot</a></b>(2) to
                     (temporarily) modify its root directory (to the directory referred to by <u>dirfd</u>).   However,
                     unlike   <b><a href="../man2/chroot.2.html">chroot</a></b>(2)   (which  changes  the  filesystem  root  permanently  for  a  process),
                     <b>RESOLVE_IN_ROOT</b> allows a program to efficiently restrict  path  resolution  on  a  per-open
                     basis.

                     Currently,  this flag also disables magic-link resolution.  However, this may change in the
                     future.  Therefore, to ensure  that  magic  links  are  not  resolved,  the  caller  should
                     explicitly specify <b>RESOLVE_NO_MAGICLINKS</b>.

              <b>RESOLVE_NO_MAGICLINKS</b>
                     Disallow all magic-link resolution during path resolution.

                     Magic links are symbolic link-like objects that are most notably found in <b><a href="../man5/proc.5.html">proc</a></b>(5); examples
                     include <u><a href="file:/proc/">/proc/</a></u>pid<u>/exe</u> and <u><a href="file:/proc/">/proc/</a></u>pid<u>/fd/*</u>.  (See <b><a href="../man7/symlink.7.html">symlink</a></b>(7) for more details.)

                     Unknowingly opening magic links can be risky for some applications.  Examples of such risks
                     include the following:

                     •  If  the  process  opening  a  pathname  is  a  controlling process that currently has no
                        controlling terminal (see <b><a href="../man7/credentials.7.html">credentials</a></b>(7)), then opening a magic link inside <u><a href="file:/proc/">/proc/</a></u>pid<u>/fd</u>
                        that happens to refer to a terminal would cause the process  to  acquire  a  controlling
                        terminal.

                     •  In a containerized environment, a magic link inside <u><a href="file:/proc">/proc</a></u> may refer to an object outside
                        the container, and thus may provide a means to escape from the container.

                     Because of such risks, an application may prefer to disable magic link resolution using the
                     <b>RESOLVE_NO_MAGICLINKS</b> flag.

                     If  the  trailing  component  (i.e.,  basename)  of  <u>pathname</u>  is a magic link, <u>how.resolve</u>
                     contains <b>RESOLVE_NO_MAGICLINKS</b>, and <u>how.flags</u> contains both <b>O_PATH</b> and <b>O_NOFOLLOW</b>, then  an
                     <b>O_PATH</b> file descriptor referencing the magic link will be returned.

              <b>RESOLVE_NO_SYMLINKS</b>
                     Disallow  resolution  of  symbolic  links  during  path  resolution.   This  option implies
                     <b>RESOLVE_NO_MAGICLINKS</b>.

                     If the trailing component (i.e., basename) of <u>pathname</u>  is  a  symbolic  link,  <u>how.resolve</u>
                     contains  <b>RESOLVE_NO_SYMLINKS</b>,  and  <u>how.flags</u> contains both <b>O_PATH</b> and <b>O_NOFOLLOW</b>, then an
                     <b>O_PATH</b> file descriptor referencing the symbolic link will be returned.

                     Note that the effect of the  <b>RESOLVE_NO_SYMLINKS</b>  flag,  which  affects  the  treatment  of
                     symbolic  links  in  all  of  the  components  of  <u>pathname</u>, differs from the effect of the
                     <b>O_NOFOLLOW</b> file creation flag (in <u>how.flags</u>), which affects the handling of symbolic  links
                     only in the final component of <u>pathname</u>.

                     Applications  that  employ  the  <b>RESOLVE_NO_SYMLINKS</b>  flag  are  encouraged to make its use
                     configurable (unless it is used for a specific security purpose),  as  symbolic  links  are
                     very  widely  used by end-users.  Setting this flag indiscriminately—i.e., for purposes not
                     specifically related to security—for all uses of <b>openat2</b>() may result in spurious errors on
                     previously functional systems.  This may occur if, for example, a system pathname  that  is
                     used by an application is modified (e.g., in a new distribution release) so that a pathname
                     component (now) contains a symbolic link.

              <b>RESOLVE_NO_XDEV</b>
                     Disallow  traversal  of  mount  points  during path resolution (including all bind mounts).
                     Consequently, <u>pathname</u> must either be on the same mount as the  directory  referred  to  by
                     <u>dirfd</u>,  or  on  the  same  mount  as the current working directory if <u>dirfd</u> is specified as
                     <b>AT_FDCWD</b>.

                     Applications  that  employ  the  <b>RESOLVE_NO_XDEV</b>  flag  are  encouraged  to  make  its  use
                     configurable (unless it is used for a specific security purpose), as bind mounts are widely
                     used  by end-users.  Setting this flag indiscriminately—i.e., for purposes not specifically
                     related to security—for all uses of <b>openat2</b>() may result in spurious errors  on  previously
                     functional  systems.   This may occur if, for example, a system pathname that is used by an
                     application is modified (e.g., in a new distribution release) so that a pathname  component
                     (now) contains a bind mount.

              <b>RESOLVE_CACHED</b>
                     Make the open operation fail unless all path components are already present in the kernel's
                     lookup  cache.   If  any  kind  of  revalidation  or  I/O  is needed to satisfy the lookup,
                     <b>openat2</b>() fails with the error <b>EAGAIN</b>.  This is useful in providing a fast-path  open  that
                     can  be  performed  without  resorting  to  thread  offload,  or  other  mechanisms that an
                     application might use to offload slower operations.

              If any bits other than those listed above are set in <u>how.resolve</u>, an error is returned.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, a new file descriptor is returned.  On error, -1 is returned, and <u>errno</u> is  set  to  indicate
       the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The  set of errors returned by <b>openat2</b>() includes all of the errors returned by <b><a href="../man2/openat.2.html">openat</a></b>(2), as well as the
       following additional errors:

       <b>E2BIG</b>  An extension that this kernel does not support was specified in  <u>how</u>.   (See  the  "Extensibility"
              section of <b>NOTES</b> for more detail on how extensions are handled.)

       <b>EAGAIN</b> <u>how.resolve</u>  contains  either  <b>RESOLVE_IN_ROOT</b> or <b>RESOLVE_BENEATH</b>, and the kernel could not ensure
              that a ".." component didn't escape (due to a race condition or potential attack).  The caller may
              choose to retry the <b>openat2</b>() call.

       <b>EAGAIN</b> <b>RESOLVE_CACHED</b> was set, and the open operation cannot be performed using only cached  information.
              The caller should retry without <b>RESOLVE_CACHED</b> set in <u>how.resolve</u>.

       <b>EINVAL</b> An unknown flag or invalid value was specified in <u>how</u>.

       <b>EINVAL</b> <u>mode</u> is nonzero, but <u>how.flags</u> does not contain <b>O_CREAT</b> or <b>O_TMPFILE</b>.

       <b>EINVAL</b> <u>size</u> was smaller than any known version of <u>struct</u> <u>open_how</u>.

       <b>ELOOP</b>  <u>how.resolve</u>  contains  <b>RESOLVE_NO_SYMLINKS</b>, and one of the path components was a symbolic link (or
              magic link).

       <b>ELOOP</b>  <u>how.resolve</u> contains <b>RESOLVE_NO_MAGICLINKS</b>, and one of the path components was a magic link.

       <b>EXDEV</b>  <u>how.resolve</u> contains either <b>RESOLVE_IN_ROOT</b> or <b>RESOLVE_BENEATH</b>, and an escape from the root during
              path resolution was detected.

       <b>EXDEV</b>  <u>how.resolve</u> contains <b>RESOLVE_NO_XDEV</b>, and a path component crosses a mount point.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 5.6.

       The semantics of <b>RESOLVE_BENEATH</b> were modeled after FreeBSD's <b>O_BENEATH</b>.

</pre><h4><b>NOTES</b></h4><pre>
   <b>Extensibility</b>
       In order to allow for future extensibility, <b>openat2</b>() requires the user-space application to specify  the
       size  of  the  <u>open_how</u>  structure that it is passing.  By providing this information, it is possible for
       <b>openat2</b>() to provide both forwards- and backwards-compatibility, with <u>size</u> acting as an implicit  version
       number.  (Because new extension fields will always be appended, the structure size will always increase.)
       This   extensibility   design   is   very  similar  to  other  system  calls  such  as  <b><a href="../man2/sched_setattr.2.html">sched_setattr</a></b>(2),
       <b><a href="../man2/perf_event_open.2.html">perf_event_open</a></b>(2), and <b><a href="../man2/clone3.2.html">clone3</a></b>(2).

       If we let <u>usize</u> be the size of the structure as specified by the user-space application, and <u>ksize</u> be the
       size of the structure which the kernel supports, then there are three cases to consider:

       •  If <u>ksize</u> equals <u>usize</u>, then there is no version mismatch and <u>how</u> can be used verbatim.

       •  If <u>ksize</u> is larger than <u>usize</u>, then there are some extension fields that the kernel supports which the
          user-space application is unaware of.  Because a zero value in any added extension field  signifies  a
          no-op,  the  kernel  treats  all of the extension fields not provided by the user-space application as
          having zero values.  This provides backwards-compatibility.

       •  If <u>ksize</u> is smaller than <u>usize</u>, then there are some extension fields which the user-space  application
          is  aware  of  but  which the kernel does not support.  Because any extension field must have its zero
          values signify a no-op, the kernel can safely ignore the unsupported extension fields if they are all-
          zero.  If any unsupported extension fields are nonzero, then -1 is returned and <u>errno</u> is set to <b>E2BIG</b>.
          This provides forwards-compatibility.

       Because the definition of <u>struct</u> <u>open_how</u> may change in the future (with  new  fields  being  added  when
       system  headers  are  updated),  user-space  applications should zero-fill <u>struct</u> <u>open_how</u> to ensure that
       recompiling the program with new headers will not result in spurious errors at run  time.   The  simplest
       way is to use a designated initializer:

           struct open_how how = { .flags = O_RDWR,
                                   .resolve = RESOLVE_IN_ROOT };

       or explicitly using <b><a href="../man3/memset.3.html">memset</a></b>(3) or similar:

           struct open_how how;
           memset(&amp;how, 0, sizeof(how));
           how.flags = O_RDWR;
           how.resolve = RESOLVE_IN_ROOT;

       A  user-space application that wishes to determine which extensions the running kernel supports can do so
       by conducting a binary search on <u>size</u> with a structure which has every byte nonzero (to find the  largest
       value which doesn't produce an error of <b>E2BIG</b>).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/openat.2.html">openat</a></b>(2), <b><a href="../man2type/open_how.2type.html">open_how</a></b>(2type), <b><a href="../man7/path_resolution.7.html">path_resolution</a></b>(7), <b><a href="../man7/symlink.7.html">symlink</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                         <u><a href="../man2/openat2.2.html">openat2</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>