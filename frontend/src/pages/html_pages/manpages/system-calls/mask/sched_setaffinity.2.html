<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sched_setaffinity, sched_getaffinity - set and get a thread's CPU affinity mask</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sched_setaffinity, sched_getaffinity - set and get a thread's CPU affinity mask

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>             /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;</b>

       <b>int</b> <b>sched_setaffinity(pid_t</b> <u>pid</u><b>,</b> <b>size_t</b> <u>cpusetsize</u><b>,</b>
                             <b>const</b> <b>cpu_set_t</b> <b>*</b><u>mask</u><b>);</b>
       <b>int</b> <b>sched_getaffinity(pid_t</b> <u>pid</u><b>,</b> <b>size_t</b> <u>cpusetsize</u><b>,</b>
                             <b>cpu_set_t</b> <b>*</b><u>mask</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A  thread's  CPU  affinity  mask  determines  the  set  of  CPUs  on  which  it is eligible to run.  On a
       multiprocessor system, setting the CPU affinity mask can be used to  obtain  performance  benefits.   For
       example,  by dedicating one CPU to a particular thread (i.e., setting the affinity mask of that thread to
       specify a single CPU, and setting the affinity mask of all other threads to  exclude  that  CPU),  it  is
       possible  to ensure maximum execution speed for that thread.  Restricting a thread to run on a single CPU
       also avoids the performance cost caused by the cache invalidation that occurs when  a  thread  ceases  to
       execute on one CPU and then recommences execution on a different CPU.

       A CPU affinity mask is represented by the <u>cpu_set_t</u> structure, a "CPU set", pointed to by <u>mask</u>.  A set of
       macros for manipulating CPU sets is described in <b><a href="../man3/CPU_SET.3.html">CPU_SET</a></b>(3).

       <b>sched_setaffinity</b>()  sets  the  CPU affinity mask of the thread whose ID is <u>pid</u> to the value specified by
       <u>mask</u>.  If <u>pid</u> is zero, then the calling thread is used.  The argument <u>cpusetsize</u> is the length (in bytes)
       of the data pointed to by <u>mask</u>.  Normally this argument would be specified as <u>sizeof(cpu_set_t)</u>.

       If the thread specified by <u>pid</u> is not currently running on one of the CPUs specified in <u>mask</u>,  then  that
       thread is migrated to one of the CPUs specified in <u>mask</u>.

       <b>sched_getaffinity</b>()  writes  the affinity mask of the thread whose ID is <u>pid</u> into the <u>cpu_set_t</u> structure
       pointed to by <u>mask</u>.  The <u>cpusetsize</u> argument specifies the size (in bytes) of <u>mask</u>.  If <u>pid</u> is zero, then
       the mask of the calling thread is returned.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>sched_setaffinity</b>() and <b>sched_getaffinity</b>() return 0 (but see "C library/kernel  differences"
       below,  which notes that the underlying <b>sched_getaffinity</b>() differs in its return value).  On failure, -1
       is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> A supplied memory address was invalid.

       <b>EINVAL</b> The affinity bit mask <u>mask</u> contains no processors that are currently physically on the system  and
              permitted to the thread according to any restrictions that may be imposed by <u>cpuset</u> cgroups or the
              "cpuset" mechanism described in <b><a href="../man7/cpuset.7.html">cpuset</a></b>(7).

       <b>EINVAL</b> (<b>sched_getaffinity</b>()  and, before Linux 2.6.9, <b>sched_setaffinity</b>()) <u>cpusetsize</u> is smaller than the
              size of the affinity mask used by the kernel.

       <b>EPERM</b>  (<b>sched_setaffinity</b>()) The calling thread does not have appropriate privileges.  The  caller  needs
              an  effective  user  ID equal to the real user ID or effective user ID of the thread identified by
              <u>pid</u>, or it must possess the <b>CAP_SYS_NICE</b> capability in the user namespace of the thread <u>pid</u>.

       <b>ESRCH</b>  The thread whose ID is <u>pid</u> could not be found.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.5.8, glibc 2.3.

       Initially, the glibc interfaces included a <u>cpusetsize</u> argument, typed as <u>unsigned</u> <u>int</u>.  In  glibc  2.3.3,
       the <u>cpusetsize</u> argument was removed, but was then restored in glibc 2.3.4, with type <u>size_t</u>.

</pre><h4><b>NOTES</b></h4><pre>
       After  a  call  to  <b>sched_setaffinity</b>(),  the  set  of  CPUs on which the thread will actually run is the
       intersection of the set specified in the <u>mask</u> argument and the  set  of  CPUs  actually  present  on  the
       system.   The  system  may  further  restrict  the  set  of CPUs on which the thread runs if the "cpuset"
       mechanism described in <b><a href="../man7/cpuset.7.html">cpuset</a></b>(7) is being used.  These restrictions on the actual set of  CPUs  on  which
       the thread will run are silently imposed by the kernel.

       There  are  various ways of determining the number of CPUs available on the system, including: inspecting
       the contents of <u><a href="file:/proc/cpuinfo">/proc/cpuinfo</a></u>; using <b><a href="../man3/sysconf.3.html">sysconf</a></b>(3) to obtain the  values  of  the  <b>_SC_NPROCESSORS_CONF</b>  and
       <b>_SC_NPROCESSORS_ONLN</b>    parameters;    and    inspecting    the    list    of   CPU   directories   under
       <u><a href="file:/sys/devices/system/cpu/">/sys/devices/system/cpu/</a></u>.

       <b><a href="../man7/sched.7.html">sched</a></b>(7) has a description of the Linux scheduling scheme.

       The affinity mask is a per-thread attribute that can be adjusted independently for each of the threads in
       a thread group.  The value returned from a  call  to  <b><a href="../man2/gettid.2.html">gettid</a></b>(2)  can  be  passed  in  the  argument  <u>pid</u>.
       Specifying  <u>pid</u> as 0 will set the attribute for the calling thread, and passing the value returned from a
       call to <b><a href="../man2/getpid.2.html">getpid</a></b>(2) will set the attribute for the main thread of the thread group.  (If you are using  the
       POSIX threads API, then use <b><a href="../man3/pthread_setaffinity_np.3.html">pthread_setaffinity_np</a></b>(3) instead of <b>sched_setaffinity</b>().)

       The  <u>isolcpus</u>  boot option can be used to isolate one or more CPUs at boot time, so that no processes are
       scheduled onto those CPUs.  Following the use of this boot option, the only  way  to  schedule  processes
       onto  the  isolated CPUs is via <b>sched_setaffinity</b>() or the <b><a href="../man7/cpuset.7.html">cpuset</a></b>(7) mechanism.  For further information,
       see the kernel source file  <u>Documentation/admin-guide/kernel-parameters.txt</u>.   As  noted  in  that  file,
       <u>isolcpus</u> is the preferred mechanism of isolating CPUs (versus the alternative of manually setting the CPU
       affinity of all processes on the system).

       A  child  created  via  <b><a href="../man2/fork.2.html">fork</a></b>(2)  inherits its parent's CPU affinity mask.  The affinity mask is preserved
       across an <b><a href="../man2/execve.2.html">execve</a></b>(2).

   <b>C</b> <b>library/kernel</b> <b>differences</b>
       This manual page describes the glibc interface for the  CPU  affinity  calls.   The  actual  system  call
       interface  is  slightly different, with the <u>mask</u> being typed as <u>unsigned</u> <u>long</u> <u>*</u>, reflecting the fact that
       the underlying implementation of CPU sets is a simple bit mask.

       On success, the raw <b>sched_getaffinity</b>() system call returns the number of bytes placed  copied  into  the
       <u>mask</u>  buffer;  this  will be the minimum of <u>cpusetsize</u> and the size (in bytes) of the <u>cpumask_t</u> data type
       that is used internally by the kernel to represent the CPU set bit mask.

   <b>Handling</b> <b>systems</b> <b>with</b> <b>large</b> <b>CPU</b> <b>affinity</b> <b>masks</b>
       The underlying system calls (which represent CPU masks as bit masks of type <u>unsigned</u>  <u>long</u> <u>*</u>)  impose  no
       restriction on the size of the CPU mask.  However, the <u>cpu_set_t</u> data type used by glibc has a fixed size
       of  128  bytes,  meaning  that the maximum CPU number that can be represented is 1023.  If the kernel CPU
       affinity mask is larger than 1024, then calls of the form:

           sched_getaffinity(pid, sizeof(cpu_set_t), &amp;mask);

       fail with the error <b>EINVAL</b>, the error produced by the underlying system call for the case where the  <u>mask</u>
       size  specified  in  <u>cpusetsize</u>  is  smaller  than  the  size  of  the  affinity mask used by the kernel.
       (Depending on the system CPU topology, the kernel affinity mask can  be  substantially  larger  than  the
       number of active CPUs in the system.)

       When  working  on  systems  with  large kernel CPU affinity masks, one must dynamically allocate the <u>mask</u>
       argument (see <b><a href="../man3/CPU_ALLOC.3.html">CPU_ALLOC</a></b>(3)).  Currently, the only way to do this is  by  probing  for  the  size  of  the
       required  mask  using  <b>sched_getaffinity</b>() calls with increasing mask sizes (until the call does not fail
       with the error <b>EINVAL</b>).

       Be aware that <b><a href="../man3/CPU_ALLOC.3.html">CPU_ALLOC</a></b>(3) may allocate a slightly larger CPU set than requested (because  CPU  sets  are
       implemented  as bit masks allocated in units of <u>sizeof(long)</u>).  Consequently, <b>sched_getaffinity</b>() can set
       bits beyond the requested allocation size, because the kernel sees a few additional bits.  Therefore, the
       caller should iterate over the bits in the returned set, counting those which  are  set,  and  stop  upon
       reaching  the  value returned by <b><a href="../man3/CPU_COUNT.3.html">CPU_COUNT</a></b>(3) (rather than iterating over the number of bits requested to
       be allocated).

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below creates a child process.  The parent  and  child  then  each  assign  themselves  to  a
       specified  CPU  and  execute  identical loops that consume some CPU time.  Before terminating, the parent
       waits for the child to complete.  The program takes three command-line arguments: the CPU number for  the
       parent,  the  CPU  number  for  the  child,  and the number of loop iterations that both processes should
       perform.

       As the sample runs below demonstrate, the amount of real and CPU time consumed when running  the  program
       will depend on intra-core caching effects and whether the processes are using the same CPU.

       We first employ <b><a href="../man1/lscpu.1.html">lscpu</a></b>(1) to determine that this (x86) system has two cores, each with two CPUs:

           $ <b>lscpu</b> <b>|</b> <b>egrep</b> <b>-i</b> <b>'core.*:|socket'</b>
           Thread(s) per core:    2
           Core(s) per socket:    2
           Socket(s):             1

       We  then  time  the  operation of the example program for three cases: both processes running on the same
       CPU; both processes running on different CPUs on the same core; and both processes running  on  different
       CPUs on different cores.

           $ <b>time</b> <b>-p</b> <b>./a.out</b> <b>0</b> <b>0</b> <b>100000000</b>
           real 14.75
           user 3.02
           sys 11.73
           $ <b>time</b> <b>-p</b> <b>./a.out</b> <b>0</b> <b>1</b> <b>100000000</b>
           real 11.52
           user 3.98
           sys 19.06
           $ <b>time</b> <b>-p</b> <b>./a.out</b> <b>0</b> <b>3</b> <b>100000000</b>
           real 7.89
           user 3.29
           sys 12.07

   <b>Program</b> <b>source</b>

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/wait.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           int           parentCPU, childCPU;
           cpu_set_t     set;
           unsigned int  nloops;

           if (argc != 4) {
               fprintf(stderr, "Usage: %s parent-cpu child-cpu num-loops\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           parentCPU = atoi(argv[1]);
           childCPU = atoi(argv[2]);
           nloops = atoi(argv[3]);

           CPU_ZERO(&amp;set);

           switch (fork()) {
           case -1:            /* Error */
               err(EXIT_FAILURE, "fork");

           case 0:             /* Child */
               CPU_SET(childCPU, &amp;set);

               if (sched_setaffinity(getpid(), sizeof(set), &amp;set) == -1)
                   err(EXIT_FAILURE, "sched_setaffinity");

               for (unsigned int j = 0; j &lt; nloops; j++)
                   getppid();

               exit(EXIT_SUCCESS);

           default:            /* Parent */
               CPU_SET(parentCPU, &amp;set);

               if (sched_setaffinity(getpid(), sizeof(set), &amp;set) == -1)
                   err(EXIT_FAILURE, "sched_setaffinity");

               for (unsigned int j = 0; j &lt; nloops; j++)
                   getppid();

               wait(NULL);     /* Wait for child to terminate */
               exit(EXIT_SUCCESS);
           }
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/lscpu.1.html">lscpu</a></b>(1), <b><a href="../man1/nproc.1.html">nproc</a></b>(1), <b><a href="../man1/taskset.1.html">taskset</a></b>(1), <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/getcpu.2.html">getcpu</a></b>(2), <b><a href="../man2/getpriority.2.html">getpriority</a></b>(2), <b><a href="../man2/gettid.2.html">gettid</a></b>(2), <b><a href="../man2/nice.2.html">nice</a></b>(2),
       <b><a href="../man2/sched_get_priority_max.2.html">sched_get_priority_max</a></b>(2), <b><a href="../man2/sched_get_priority_min.2.html">sched_get_priority_min</a></b>(2), <b><a href="../man2/sched_getscheduler.2.html">sched_getscheduler</a></b>(2), <b><a href="../man2/sched_setscheduler.2.html">sched_setscheduler</a></b>(2),
       <b><a href="../man2/setpriority.2.html">setpriority</a></b>(2), <b><a href="../man3/CPU_SET.3.html">CPU_SET</a></b>(3), <b><a href="../man3/get_nprocs.3.html">get_nprocs</a></b>(3), <b><a href="../man3/pthread_setaffinity_np.3.html">pthread_setaffinity_np</a></b>(3), <b><a href="../man3/sched_getcpu.3.html">sched_getcpu</a></b>(3), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7),
       <b><a href="../man7/cpuset.7.html">cpuset</a></b>(7), <b><a href="../man7/sched.7.html">sched</a></b>(7), <b><a href="../man8/numactl.8.html">numactl</a></b>(8)

Linux man-pages 6.9.1                              2024-06-15                               <u><a href="../man2/sched_setaffinity.2.html">sched_setaffinity</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>