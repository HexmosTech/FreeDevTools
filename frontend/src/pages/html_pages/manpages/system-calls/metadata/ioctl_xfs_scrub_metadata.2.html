<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ioctl_xfs_scrub_metadata - check XFS filesystem metadata</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/xfslibs-dev">xfslibs-dev_6.13.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ioctl_xfs_scrub_metadata - check XFS filesystem metadata

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;xfs/xfs_fs.h&gt;</b>

       <b>int</b> <b>ioctl(int</b> <u>dest_fd</u><b>,</b> <b>XFS_IOC_SCRUB_METADATA,</b> <b>struct</b> <b>xfs_scrub_metadata</b> <b>*</b><u>arg</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  XFS ioctl asks the kernel driver to examine a piece of filesystem metadata for errors or suboptimal
       metadata.  Examination includes running metadata verifiers, checking records for obviously  incorrect  or
       impossible values, and cross-referencing each record with any other available metadata in the filesystem.
       This  ioctl  can  also  try  to  repair  or  optimize  metadata,  though this may block normal filesystem
       operations for a long period of time.  The type and location of the metadata to scrub is  conveyed  in  a
       structure of the following form:

           struct xfs_scrub_metadata {
                __u32 sm_type;
                __u32 sm_flags;
                __u64 sm_ino;
                __u32 sm_gen;
                __u32 sm_agno;
                __u64 sm_reserved[5];
           };

       The field <u>sm_reserved</u> must be zero.

       The field <u>sm_type</u> indicates the type of metadata to check:

           <b>XFS_SCRUB_TYPE_PROBE</b>
                  Probe  the kernel to see if it is willing to try to check or repair this filesystem.  <b>sm_agno</b>,
                  <b>sm_ino</b>, and <b>sm_gen</b> must be zero.

           <b>XFS_SCRUB_TYPE_SB</b>
           <b>XFS_SCRUB_TYPE_AGF</b>
           <b>XFS_SCRUB_TYPE_AGFL</b>
           <b>XFS_SCRUB_TYPE_AGI</b>
                  Examine a given allocation group's superblock, free space header, free block  list,  or  inode
                  header, respectively.  Headers are checked for obviously incorrect values and cross-referenced
                  against the allocation group's metadata btrees, if possible.  The allocation group number must
                  be given in <b>sm_agno</b>.  <b>sm_ino</b> and <b>sm_gen</b> must be zero.

           <b>XFS_SCRUB_TYPE_BNOBT</b>
           <b>XFS_SCRUB_TYPE_CNTBT</b>
           <b>XFS_SCRUB_TYPE_INOBT</b>
           <b>XFS_SCRUB_TYPE_FINOBT</b>
           <b>XFS_SCRUB_TYPE_RMAPBT</b>
           <b>XFS_SCRUB_TYPE_REFCNTBT</b>
                  Examine  a  given  allocation group's two free space btrees, two inode btrees, reverse mapping
                  btrees, or reference count btrees, respectively.  Records are checked for obviously  incorrect
                  values  and cross-referenced with other allocation group metadata records to ensure that there
                  are no conflicts.  The allocation group number must be given in <b>sm_agno</b>.   <b>sm_ino</b>  and  <b>sm_gen</b>
                  must be zero.

           <b>XFS_SCRUB_TYPE_RGSUPER</b>
                  Examine  a given realtime allocation group's superblock.  The realtime allocation group number
                  must be given in <u>sm_agno</u>.  <u>sm_ino</u> and <u>sm_gen</u> must be zero.

           <b>XFS_SCRUB_TYPE_INODE</b>
                  Examine a given inode record for obviously incorrect values and discrepancies with the rest of
                  filesystem metadata.  Parent pointers are checked for impossible inode  values  and  are  then
                  followed  up  to  the  parent  directory  to ensure that the linkage is correct.  The inode to
                  examine may be specified either through <b>sm_ino</b> and <b>sm_gen</b>; if not  specified,  then  the  file
                  described by <b>dest_fd</b> will be examined.  <b>sm_agno</b> must be zero.

           <b>XFS_SCRUB_TYPE_BMBTD</b>
           <b>XFS_SCRUB_TYPE_BMBTA</b>
           <b>XFS_SCRUB_TYPE_BMBTC</b>
                  Examine  a  given inode's data block map, extended attribute block map, or copy on write block
                  map.  Inode records are examined for obviously incorrect values  and  discrepancies  with  the
                  three  block  map  types.   The  block  maps are checked for obviously wrong values and cross-
                  referenced with the allocation group space extent metadata for discrepancies.   The  inode  to
                  examine can be specified in the same manner as <b>XFS_SCRUB_TYPE_INODE</b>.

           <b>XFS_SCRUB_TYPE_XATTR</b>
                  Examine the extended attribute records and indices of a given inode for incorrect pointers and
                  other  signs  of  damage.   The  inode  to  examine  can  be  specified  in the same manner as
                  <b>XFS_SCRUB_TYPE_INODE</b>.

           <b>XFS_SCRUB_TYPE_DIR</b>
                  Examine the entries in a given directory for  invalid  data  or  dangling  pointers.   If  the
                  filesystem  supports directory parent pointers, each entry will be checked to confirm that the
                  child file has a matching parent pointer.  The directory to examine can be  specified  in  the
                  same manner as <b>XFS_SCRUB_TYPE_INODE</b>.

           <b>XFS_SCRUB_TYPE_PARENT</b>
                  For  filesystems that support directory parent pointers, this scrubber examines all the parent
                  pointers attached to a file and confirms that the parent directory has an entry  matching  the
                  parent  pointer.  For filesystems that do not support directory parent pointers, this scrubber
                  checks that a subdirectory's dotdot entry points to a directory with an entry that points back
                  to the  subdirectory.   The  inode  to  examine  can  be  specified  in  the  same  manner  as
                  <b>XFS_SCRUB_TYPE_INODE</b>.

           <b>XFS_SCRUB_TYPE_DIRTREE</b>
                  This scrubber looks for problems in the directory tree structure such as loops and directories
                  accessible  through  more  than  one  path.   Problems are detected by walking parent pointers
                  upwards towards the root.  Loops are detected by comparing the parent directory at  each  step
                  against  the  directories  already  examined.  Directories with multiple paths are detected by
                  counting the parent pointers attached to a  directory.   Non-directories  do  not  have  links
                  pointing  away  from the directory tree root and can be skipped.  The directory to examine can
                  be specified in the same manner as <b>XFS_SCRUB_TYPE_INODE</b>.

           <b>XFS_SCRUB_TYPE_SYMLINK</b>
                  Examine the target of a symbolic link for obvious pathname problems.  The link to examine  can
                  be specified in the same manner as <b>XFS_SCRUB_TYPE_INODE</b>.

           <b>XFS_SCRUB_TYPE_RTBITMAP</b>
           <b>XFS_SCRUB_TYPE_RTSUM</b>
                  Examine the realtime block bitmap and realtime summary inodes for corruption.

           <b>XFS_SCRUB_TYPE_UQUOTA</b>
           <b>XFS_SCRUB_TYPE_GQUOTA</b>
           <b>XFS_SCRUB_TYPE_PQUOTA</b>
                  Examine all user, group, or project quota records for corruption.

           <b>XFS_SCRUB_TYPE_FSCOUNTERS</b>
                  Examine  all  filesystem  summary  counters  (free  blocks, inode count, free inode count) for
                  errors.

           <b>XFS_SCRUB_TYPE_NLINKS</b>
                  Scan all inodes in the filesystem to verify each file's link count.

           <b>XFS_SCRUB_TYPE_HEALTHY</b>
                  Mark everything healthy after a clean scrub run.  This clears  out  all  the  indirect  health
                  problem markers that might remain in the system.

           <b>XFS_SCRUB_TYPE_METAPATH</b>
                  Check  that  a metadata directory path actually points to the active metadata inode.  Metadata
                  inodes are usually cached for the duration of the mount, so this  scrubber  ensures  that  the
                  same inode will still be reachable after an unmount and mount cycle.  Discrepancies can happen
                  if  the  directory or parent pointer scrubbers rebuild a metadata directory but lose a link in
                  the process.  The <b>sm_ino</b> field should be  passed  one  of  the  following  special  values  to
                  communicate which path to check:

                  <b>XFS_SCRUB_METAPATH_RTDIR</b>
                         Realtime metadata file subdirectory.
                  <b>XFS_SCRUB_METAPATH_RTBITMAP</b>
                         Realtime bitmap file.
                  <b>XFS_SCRUB_METAPATH_RTSUMMARY</b>
                         Realtime summary file.
                  <b>XFS_SCRUB_METAPATH_QUOTADIR</b>
                         Quota metadata file subdirectory.
                  <b>XFS_SCRUB_METAPATH_USRQUOTA</b>
                         User quota file.
                  <b>XFS_SCRUB_METAPATH_GRPQUOTA</b>
                         Group quota file.
                  <b>XFS_SCRUB_METAPATH_PRJQUOTA</b>
                         Project quota file.

           The values of <u>sm_agno</u> and <u>sm_gen</u> must be zero.

       The  field  <u>sm_flags</u>  control  the behavior of the scrub operation and provide more information about the
       outcome of the operation.  If none of the <b>XFS_SCRUB_OFLAG_*</b> flags are set upon return,  the  metadata  is
       clean.

           <b>XFS_SCRUB_IFLAG_REPAIR</b>
                  If  the  caller sets this flag, the kernel driver will examine the metadata and try to fix all
                  problems and to optimize metadata when  possible.   If  no  errors  occur  during  the  repair
                  operation, the check is performed a second time to determine whether the repair succeeded.  If
                  errors occur, the call returns an error status immediately.

           <b>XFS_SCRUB_OFLAG_CORRUPT</b>
                  The  metadata  was  corrupt  when the call returned.  If <b>XFS_SCRUB_IFLAG_REPAIR</b> was specified,
                  then an attempted repair failed to fix the problem.  Unmount the filesystem and run <b>xfs_repair</b>
                  to fix the filesystem.

           <b>XFS_SCRUB_OFLAG_PREEN</b>
                  The metadata is  ok,  but  some  aspect  of  the  metadata  could  be  optimized  to  increase
                  performance.  Call again with <b>XFS_SCRUB_IFLAG_REPAIR</b> to optimize the metadata.

           <b>XFS_SCRUB_OFLAG_XFAIL</b>
                  Filesystem  errors  were  encountered  when  accessing  other  metadata to cross-reference the
                  records attached to this metadata object.

           <b>XFS_SCRUB_OFLAG_XCORRUPT</b>
                  Discrepancies were found when cross-referencing the records attached to this  metadata  object
                  against all other available metadata in the system.

           <b>XFS_SCRUB_OFLAG_INCOMPLETE</b>
                  The checker was unable to complete its check of all records.

           <b>XFS_SCRUB_OFLAG_WARNING</b>
                  The  checker encountered a metadata object with potentially problematic records.  However, the
                  records were not obviously corrupt.

       For metadata checkers that operate on inodes or inode metadata, the fields  <u>sm_ino</u>  and  <u>sm_gen</u>  are  the
       inode  number  and  generation  number  of  the  inode  to check.  If the inode number is zero, the inode
       represented by <u>dest_fd</u> is used instead.  If the generation number of the inode does not match <u>sm_gen</u>, the
       call will return an error code for the invalid argument.  The <u>sm_agno</u> field must be zero.

       For metadata checkers that operate  on  allocation  group  metadata,  the  field  <u>sm_agno</u>  indicates  the
       allocation group in which to find the metadata.  The <u>sm_ino</u> and <u>sm_gen</u> fields must be zero.

       For  metadata  checkers  that  operate  on  filesystem-wide  metadata, no further arguments are required.
       <u>sm_agno</u>, <u>sm_ino</u>, and <u>sm_gen</u> must all be zero.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       Error codes can be one of, but are not limited to, the following:

       <b>EBUSY</b>  The filesystem object is busy; the operation will have to be tried again.

       <b>EFSCORRUPTED</b>
              Severe filesystem corruption was detected and could not be repaired.  Unmount the  filesystem  and
              run <b>xfs_repair</b> to fix the filesystem.

       <b>EINVAL</b> One or more of the arguments specified is invalid.

       <b>ENOENT</b> The  specified  metadata  object  does  not exist.  For example, this error code is returned for a
              <b>XFS_SCRUB_TYPE_REFCNTBT</b> request on a filesystem that does not support reflink.

       <b>ENOMEM</b> There was not sufficient memory to perform the scrub or repair operation.  Some  operations  (most
              notably reference count checking) require large amounts of memory.

       <b>ENOSPC</b> There is not enough free disk space to attempt a repair.

       <b>ENOTRECOVERABLE</b>
              Filesystem  was  mounted  in  <b>norecovery</b> mode and therefore has an unclean log.  Neither scrub nor
              repair operations can be attempted with an unclean log.

       <b>ENOTTY</b> Online scrubbing or repair were not enabled.

       <b>EOPNOTSUPP</b>
              Repairs of the requested metadata object are not supported.

       <b>EROFS</b>  Filesystem is read-only and a repair was requested.

       <b>ESHUTDOWN</b>
              Filesystem is shut down due to previous errors.

</pre><h4><b>CONFORMING</b> <b>TO</b></h4><pre>
       This API is specific to XFS filesystem on the Linux kernel.

</pre><h4><b>NOTES</b></h4><pre>
       These operations may block other filesystem operations for a long time.  A calling process can  stop  the
       operation by being sent a fatal signal, but non-fatal signals are blocked.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) <b><a href="../man8/xfs_scrub.8.html">xfs_scrub</a></b>(8) <b><a href="../man8/xfs_repair.8.html">xfs_repair</a></b>(8)

XFS                                                2017-12-01                        <u><a href="../man2/IOCTL-XFS-SCRUB-METADATA.2.html">IOCTL-XFS-SCRUB-METADATA</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>