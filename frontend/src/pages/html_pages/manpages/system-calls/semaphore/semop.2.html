<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>semop, semtimedop - System V semaphore operations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       semop, semtimedop - System V semaphore operations

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/sem.h&gt;</b>

       <b>int</b> <b>semop(int</b> <u>semid</u><b>,</b> <b>struct</b> <b>sembuf</b> <b>*</b><u>sops</u><b>,</b> <b>size_t</b> <u>nsops</u><b>);</b>
       <b>int</b> <b>semtimedop(int</b> <u>semid</u><b>,</b> <b>struct</b> <b>sembuf</b> <b>*</b><u>sops</u><b>,</b> <b>size_t</b> <u>nsops</u><b>,</b>
                      <b>const</b> <b>struct</b> <b>timespec</b> <b>*_Nullable</b> <u>timeout</u><b>);</b>

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>semtimedop</b>():
           _GNU_SOURCE

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Each semaphore in a System V semaphore set has the following associated values:

           unsigned short  semval;   /* semaphore value */
           unsigned short  semzcnt;  /* # waiting for zero */
           unsigned short  semncnt;  /* # waiting for increase */
           pid_t           sempid;   /* PID of process that last
                                        modified the semaphore value */

       <b>semop</b>()  performs  operations  on  selected  semaphores in the set indicated by <u>semid</u>.  Each of the <u>nsops</u>
       elements in the array pointed to by <u>sops</u> is a structure that specifies an operation to be performed on  a
       single  semaphore.   The  elements  of this structure are of type <u>struct</u> <u>sembuf</u>, containing the following
       members:

           unsigned short sem_num;  /* semaphore number */
           short          sem_op;   /* semaphore operation */
           short          sem_flg;  /* operation flags */

       Flags recognized in <u>sem_flg</u> are <b>IPC_NOWAIT</b> and <b>SEM_UNDO</b>.  If an operation specifies <b>SEM_UNDO</b>, it will  be
       automatically undone when the process terminates.

       The  set  of  operations  contained  in  <u>sops</u>  is  performed in <u>array</u> <u>order</u>, and <u>atomically</u>, that is, the
       operations are performed either as a complete unit, or not at all.  The behavior of the  system  call  if
       not  all  operations  can  be performed immediately depends on the presence of the <b>IPC_NOWAIT</b> flag in the
       individual <u>sem_flg</u> fields, as noted below.

       Each operation is performed on the <u>sem_num</u>-th semaphore of the semaphore set, where the  first  semaphore
       of the set is numbered 0.  There are three types of operation, distinguished by the value of <u>sem_op</u>.

       If  <u>sem_op</u>  is  a  positive  integer,  the  operation  adds  this  value to the semaphore value (<u>semval</u>).
       Furthermore, if <b>SEM_UNDO</b> is specified for this operation, the system subtracts the value <u>sem_op</u> from  the
       semaphore  adjustment  (<u>semadj</u>)  value  for  this  semaphore.  This operation can always proceed—it never
       forces a thread to wait.  The calling process must have alter permission on the semaphore set.

       If <u>sem_op</u> is zero, the process must have read permission on the semaphore set.  This is a "wait-for-zero"
       operation: if <u>semval</u> is zero, the  operation  can  immediately  proceed.   Otherwise,  if  <b>IPC_NOWAIT</b>  is
       specified  in  <u>sem_flg</u>,  <b>semop</b>()  fails  with  <u>errno</u> set to <b>EAGAIN</b> (and none of the operations in <u>sops</u> is
       performed).  Otherwise, <u>semzcnt</u> (the count of threads waiting until this semaphore's value becomes  zero)
       is incremented by one and the thread sleeps until one of the following occurs:

       •  <u>semval</u> becomes 0, at which time the value of <u>semzcnt</u> is decremented.

       •  The semaphore set is removed: <b>semop</b>() fails, with <u>errno</u> set to <b>EIDRM</b>.

       •  The calling thread catches a signal: the value of <u>semzcnt</u> is decremented and <b>semop</b>() fails, with <u>errno</u>
          set to <b>EINTR</b>.

       If  <u>sem_op</u>  is less than zero, the process must have alter permission on the semaphore set.  If <u>semval</u> is
       greater than or equal to the absolute value  of  <u>sem_op</u>,  the  operation  can  proceed  immediately:  the
       absolute value of <u>sem_op</u> is subtracted from <u>semval</u>, and, if <b>SEM_UNDO</b> is specified for this operation, the
       system  adds  the absolute value of <u>sem_op</u> to the semaphore adjustment (<u>semadj</u>) value for this semaphore.
       If the absolute value of <u>sem_op</u> is greater than <u>semval</u>, and <b>IPC_NOWAIT</b> is specified in  <u>sem_flg</u>,  <b>semop</b>()
       fails,  with  <u>errno</u>  set to <b>EAGAIN</b> (and none of the operations in <u>sops</u> is performed).  Otherwise, <u>semncnt</u>
       (the counter of threads waiting for this semaphore's value to increase) is incremented  by  one  and  the
       thread sleeps until one of the following occurs:

       •  <u>semval</u>  becomes  greater than or equal to the absolute value of <u>sem_op</u>: the operation now proceeds, as
          described above.

       •  The semaphore set is removed from the system: <b>semop</b>() fails, with <u>errno</u> set to <b>EIDRM</b>.

       •  The calling thread catches a signal: the value of <u>semncnt</u> is decremented and <b>semop</b>() fails, with <u>errno</u>
          set to <b>EINTR</b>.

       On successful completion, the <u>sempid</u> value for each semaphore specified in the array pointed to  by  <u>sops</u>
       is set to the caller's process ID.  In addition, the <u>sem_otime</u> is set to the current time.

   <b>semtimedop()</b>
       <b>semtimedop</b>()  behaves  identically  to  <b>semop</b>() except that in those cases where the calling thread would
       sleep, the duration of that sleep is limited by the amount of elapsed  time  specified  by  the  <u>timespec</u>
       structure  whose  address  is passed in the <u>timeout</u> argument.  (This sleep interval will be rounded up to
       the system clock granularity, and kernel scheduling delays mean that the interval may overrun by a  small
       amount.)   If the specified time limit has been reached, <b>semtimedop</b>() fails with <u>errno</u> set to <b>EAGAIN</b> (and
       none of the operations in <u>sops</u> is performed).  If the <u>timeout</u> argument is NULL, then <b>semtimedop</b>() behaves
       exactly like <b>semop</b>().

       Note that if <b>semtimedop</b>() is interrupted by a signal, causing the call to fail with the error <b>EINTR</b>,  the
       contents of <u>timeout</u> are left unchanged.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>semop</b>() and <b>semtimedop</b>() return 0.  On failure, they return -1, and set <u>errno</u> to indicate the
       error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>E2BIG</b>  The  argument  <u>nsops</u>  is  greater than <b>SEMOPM</b>, the maximum number of operations allowed per system
              call.

       <b>EACCES</b> The calling process does not have the permissions required  to  perform  the  specified  semaphore
              operations,  and does not have the <b>CAP_IPC_OWNER</b> capability in the user namespace that governs its
              IPC namespace.

       <b>EAGAIN</b> An operation could not proceed immediately and either <b>IPC_NOWAIT</b> was specified in <u>sem_flg</u>  or  the
              time limit specified in <u>timeout</u> expired.

       <b>EFAULT</b> An address specified in either the <u>sops</u> or the <u>timeout</u> argument isn't accessible.

       <b>EFBIG</b>  For  some  operation the value of <u>sem_num</u> is less than 0 or greater than or equal to the number of
              semaphores in the set.

       <b>EIDRM</b>  The semaphore set was removed.

       <b>EINTR</b>  While blocked in this system call, the thread caught a signal; see <b><a href="../man7/signal.7.html">signal</a></b>(7).

       <b>EINVAL</b> The semaphore set doesn't exist, or <u>semid</u> is less than zero, or <u>nsops</u> has a nonpositive value.

       <b>ENOMEM</b> The <u>sem_flg</u> of some operation specified <b>SEM_UNDO</b> and the system does not  have  enough  memory  to
              allocate the undo structure.

       <b>ERANGE</b> For  some  operation  <u>sem_op+semval</u>  is  greater than <b>SEMVMX</b>, the implementation dependent maximum
              value for <u>semval</u>.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>VERSIONS</b></h4><pre>
       Linux 2.5.52 (backported into Linux 2.4.22), glibc 2.3.3.  POSIX.1-2001, SVr4.

</pre><h4><b>NOTES</b></h4><pre>
       The <u>sem_undo</u> structures of a process aren't inherited by the child produced  by  <b><a href="../man2/fork.2.html">fork</a></b>(2),  but  they  are
       inherited across an <b><a href="../man2/execve.2.html">execve</a></b>(2) system call.

       <b>semop</b>()  is  never automatically restarted after being interrupted by a signal handler, regardless of the
       setting of the <b>SA_RESTART</b> flag when establishing a signal handler.

       A semaphore adjustment (<u>semadj</u>) value is a per-process, per-semaphore integer that is the negated sum  of
       all  operations performed on a semaphore specifying the <b>SEM_UNDO</b> flag.  Each process has a list of <u>semadj</u>
       values—one value for each semaphore on which it has operated using <b>SEM_UNDO</b>.  When a process  terminates,
       each  of its per-semaphore <u>semadj</u> values is added to the corresponding semaphore, thus undoing the effect
       of that process's operations on the semaphore (but see BUGS below).  When a semaphore's value is directly
       set using the <b>SETVAL</b> or <b>SETALL</b> request to <b><a href="../man2/semctl.2.html">semctl</a></b>(2), the corresponding <u>semadj</u> values in all processes are
       cleared.  The <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_SYSVSEM</b> flag allows more than one  process  to  share  a  <u>semadj</u>  list;  see
       <b><a href="../man2/clone.2.html">clone</a></b>(2) for details.

       The  <u>semval</u>,  <u>sempid</u>,  <u>semzcnt</u>,  and <u>semnct</u> values for a semaphore can all be retrieved using appropriate
       <b><a href="../man2/semctl.2.html">semctl</a></b>(2) calls.

   <b>Semaphore</b> <b>limits</b>
       The following limits on semaphore set resources affect the <b>semop</b>() call:

       <b>SEMOPM</b> Maximum number of operations allowed for one <b>semop</b>() call.  Before Linux 3.19, the  default  value
              for  this  limit was 32.  Since Linux 3.19, the default value is 500.  On Linux, this limit can be
              read and modified via the third field of <u><a href="file:/proc/sys/kernel/sem">/proc/sys/kernel/sem</a></u>.  <u>Note</u>: this  limit  should  not  be
              raised  above  1000,  because of the risk of that <b>semop</b>() fails due to kernel memory fragmentation
              when allocating memory to copy the <u>sops</u> array.

       <b>SEMVMX</b> Maximum allowable value for <u>semval</u>: implementation dependent (32767).

       The implementation has no intrinsic limits for the adjust on exit maximum value (<b>SEMAEM</b>), the system wide
       maximum number of undo structures (<b>SEMMNU</b>) and the per-process maximum  number  of  undo  entries  system
       parameters.

</pre><h4><b>BUGS</b></h4><pre>
       When  a  process terminates, its set of associated <u>semadj</u> structures is used to undo the effect of all of
       the semaphore operations it performed with the <b>SEM_UNDO</b> flag.  This raises a difficulty: if one (or more)
       of these semaphore adjustments would result in an attempt to decrease a  semaphore's  value  below  zero,
       what  should  an  implementation  do?   One  possible  approach would be to block until all the semaphore
       adjustments could be performed.  This is however undesirable since it could force process termination  to
       block  for  arbitrarily  long  periods.   Another possibility is that such semaphore adjustments could be
       ignored altogether (somewhat analogously  to  failing  when  <b>IPC_NOWAIT</b>  is  specified  for  a  semaphore
       operation).   Linux  adopts a third approach: decreasing the semaphore value as far as possible (i.e., to
       zero) and allowing process termination to proceed immediately.

       In Linux 2.6.x, x &lt;= 10, there is a bug that in some circumstances prevents a thread that is waiting  for
       a  semaphore value to become zero from being woken up when the value does actually become zero.  This bug
       is fixed in Linux 2.6.11.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following code segment uses <b>semop</b>() to atomically wait for the value of semaphore 0 to  become  zero,
       and then increment the semaphore value by one.

           struct sembuf sops[2];
           int semid;

           /* Code to set <u>semid</u> omitted */

           sops[0].sem_num = 0;        /* Operate on semaphore 0 */
           sops[0].sem_op = 0;         /* Wait for value to equal 0 */
           sops[0].sem_flg = 0;

           sops[1].sem_num = 0;        /* Operate on semaphore 0 */
           sops[1].sem_op = 1;         /* Increment value by one */
           sops[1].sem_flg = 0;

           if (semop(semid, sops, 2) == -1) {
               perror("semop");
               exit(EXIT_FAILURE);
           }

       A further example of the use of <b>semop</b>() can be found in <b><a href="../man2/shmop.2.html">shmop</a></b>(2).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/semctl.2.html">semctl</a></b>(2), <b><a href="../man2/semget.2.html">semget</a></b>(2), <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/sem_overview.7.html">sem_overview</a></b>(7), <b><a href="../man7/sysvipc.7.html">sysvipc</a></b>(7), <b><a href="../man7/time.7.html">time</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                           <u><a href="../man2/semop.2.html">semop</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>