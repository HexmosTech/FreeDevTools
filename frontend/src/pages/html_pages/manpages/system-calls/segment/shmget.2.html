<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shmget - allocates a System V shared memory segment</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       shmget - allocates a System V shared memory segment

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/shm.h&gt;</b>

       <b>int</b> <b>shmget(key_t</b> <u>key</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b> <b>int</b> <u>shmflg</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>shmget</b>()  returns  the  identifier of the System V shared memory segment associated with the value of the
       argument <u>key</u>.  It may be used either to obtain the identifier  of  a  previously  created  shared  memory
       segment (when <u>shmflg</u> is zero and <u>key</u> does not have the value <b>IPC_PRIVATE</b>), or to create a new set.

       A  new shared memory segment, with size equal to the value of <u>size</u> rounded up to a multiple of <b>PAGE_SIZE</b>,
       is created if <u>key</u> has  the  value  <b>IPC_PRIVATE</b>  or  <u>key</u>  isn't  <b>IPC_PRIVATE</b>,  no  shared  memory  segment
       corresponding to <u>key</u> exists, and <b>IPC_CREAT</b> is specified in <u>shmflg</u>.

       If  <u>shmflg</u> specifies both <b>IPC_CREAT</b> and <b>IPC_EXCL</b> and a shared memory segment already exists for <u>key</u>, then
       <b>shmget</b>() fails with <u>errno</u> set to <b>EEXIST</b>.  (This is analogous to the effect of the combination  <b>O_CREAT</b>  <b>|</b>
       <b>O_EXCL</b> for <b><a href="../man2/open.2.html">open</a></b>(2).)

       The value <u>shmflg</u> is composed of:

       <b>IPC_CREAT</b>
              Create  a  new  segment.  If this flag is not used, then <b>shmget</b>() will find the segment associated
              with <u>key</u> and check to see if the user has permission to access the segment.

       <b>IPC_EXCL</b>
              This flag is used with <b>IPC_CREAT</b> to ensure that this call creates the  segment.   If  the  segment
              already exists, the call fails.

       <b>SHM_HUGETLB</b> (since Linux 2.6)
              Allocate    the    segment   using   "huge"   pages.    See   the   Linux   kernel   source   file
              <u>Documentation/admin-guide/mm/hugetlbpage.rst</u> for further information.

       <b>SHM_HUGE_2MB</b>
       <b>SHM_HUGE_1GB</b> (since Linux 3.8)
              Used in conjunction with <b>SHM_HUGETLB</b> to select alternative hugetlb page sizes (respectively,  2 MB
              and 1 GB) on systems that support multiple hugetlb page sizes.

              More  generally,  the desired huge page size can be configured by encoding the base-2 logarithm of
              the desired page size in the six bits at the offset <b>SHM_HUGE_SHIFT</b>.  Thus, the above two constants
              are defined as:

                  #define SHM_HUGE_2MB    (21 &lt;&lt; SHM_HUGE_SHIFT)
                  #define SHM_HUGE_1GB    (30 &lt;&lt; SHM_HUGE_SHIFT)

              For some additional details, see the discussion of the similarly named constants in <b><a href="../man2/mmap.2.html">mmap</a></b>(2).

       <b>SHM_NORESERVE</b> (since Linux 2.6.15)
              This flag serves the same purpose as the <b><a href="../man2/mmap.2.html">mmap</a></b>(2) <b>MAP_NORESERVE</b> flag.  Do not  reserve  swap  space
              for  this  segment.   When  swap  space  is reserved, one has the guarantee that it is possible to
              modify the segment.  When swap space is not reserved one might get <b>SIGSEGV</b>  upon  a  write  if  no
              physical  memory is available.  See also the discussion of the file <u><a href="file:/proc/sys/vm/overcommit_memory">/proc/sys/vm/overcommit_memory</a></u>
              in <b><a href="../man5/proc.5.html">proc</a></b>(5).

       In addition to the above flags, the least significant 9 bits of <u>shmflg</u> specify the permissions granted to
       the owner, group, and others.  These bits have the same  format,  and  the  same  meaning,  as  the  <u>mode</u>
       argument of <b><a href="../man2/open.2.html">open</a></b>(2).  Presently, execute permissions are not used by the system.

       When  a  new  shared  memory  segment  is  created,  its contents are initialized to zero values, and its
       associated data structure, <u>shmid_ds</u> (see <b><a href="../man2/shmctl.2.html">shmctl</a></b>(2)), is initialized as follows:

       •  <u>shm_perm.cuid</u> and <u>shm_perm.uid</u> are set to the effective user ID of the calling process.

       •  <u>shm_perm.cgid</u> and <u>shm_perm.gid</u> are set to the effective group ID of the calling process.

       •  The least significant 9 bits of <u>shm_perm.mode</u> are set to the least significant 9 bit of <u>shmflg</u>.

       •  <u>shm_segsz</u> is set to the value of <u>size</u>.

       •  <u>shm_lpid</u>, <u>shm_nattch</u>, <u>shm_atime</u>, and <u>shm_dtime</u> are set to 0.

       •  <u>shm_ctime</u> is set to the current time.

       If the shared memory segment already exists, the permissions are verified, and a check is made to see  if
       it is marked for destruction.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success, a valid shared memory identifier is returned.  On error, -1 is returned, and <u>errno</u> is set to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EACCES</b> The user does not have permission to access the shared memory  segment,  and  does  not  have  the
              <b>CAP_IPC_OWNER</b> capability in the user namespace that governs its IPC namespace.

       <b>EEXIST</b> <b>IPC_CREAT</b>  and  <b>IPC_EXCL</b>  were specified in <u>shmflg</u>, but a shared memory segment already exists for
              <u>key</u>.

       <b>EINVAL</b> A new segment was to be created and <u>size</u> is less than <b>SHMMIN</b> or greater than <b>SHMMAX</b>.

       <b>EINVAL</b> A segment for the given <u>key</u> exists, but <u>size</u> is greater than the size of that segment.

       <b>ENFILE</b> The system-wide limit on the total number of open files has been reached.

       <b>ENOENT</b> No segment exists for the given <u>key</u>, and <b>IPC_CREAT</b> was not specified.

       <b>ENOMEM</b> No memory could be allocated for segment overhead.

       <b>ENOSPC</b> All possible shared memory IDs have been taken (<b>SHMMNI</b>), or allocating a segment of the  requested
              <u>size</u> would cause the system to exceed the system-wide limit on shared memory (<b>SHMALL</b>).

       <b>EPERM</b>  The  <b>SHM_HUGETLB</b>  flag  was  specified,  but  the  caller  was  not  privileged  (did not have the
              <b>CAP_IPC_LOCK</b> capability) and is not a  member  of  the  <u>sysctl_hugetlb_shm_group</u>  group;  see  the
              description of <u>/proc/sys/vm/sysctl_hugetlb_shm_group</u> in <b><a href="../man5/proc.5.html">proc</a></b>(5).

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

       <b>SHM_HUGETLB</b> and <b>SHM_NORESERVE</b> are Linux extensions.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001, SVr4.

</pre><h4><b>NOTES</b></h4><pre>
       <b>IPC_PRIVATE</b>  isn't a flag field but a <u>key_t</u> type.  If this special value is used for <u>key</u>, the system call
       ignores all but the least significant 9 bits of <u>shmflg</u> and creates a new shared memory segment.

   <b>Shared</b> <b>memory</b> <b>limits</b>
       The following limits on shared memory segment resources affect the <b>shmget</b>() call:

       <b>SHMALL</b> System-wide limit on the total amount of shared memory, measured in units of the system page size.

              On Linux, this limit can be read and modified via <u><a href="file:/proc/sys/kernel/shmall">/proc/sys/kernel/shmall</a></u>.  Since Linux 3.16,  the
              default value for this limit is:

                  ULONG_MAX - 2^24

              The  effect  of  this value (which is suitable for both 32-bit and 64-bit systems) is to impose no
              limitation on allocations.  This value, rather than  <b>ULONG_MAX</b>,  was  chosen  as  the  default  to
              prevent  some  cases  where historical applications simply raised the existing limit without first
              checking its current value.  Such applications would cause the value to overflow if the limit  was
              set at <b>ULONG_MAX</b>.

              From Linux 2.4 up to Linux 3.15, the default value for this limit was:

                  SHMMAX / PAGE_SIZE * (SHMMNI / 16)

              If  <b>SHMMAX</b>  and  <b>SHMMNI</b> were not modified, then multiplying the result of this formula by the page
              size (to get a value in bytes) yielded a value of 8 GB as the limit on the total  memory  used  by
              all shared memory segments.

       <b>SHMMAX</b> Maximum size in bytes for a shared memory segment.

              On  Linux, this limit can be read and modified via <u><a href="file:/proc/sys/kernel/shmmax">/proc/sys/kernel/shmmax</a></u>.  Since Linux 3.16, the
              default value for this limit is:

                  ULONG_MAX - 2^24

              The effect of this value (which is suitable for both 32-bit and 64-bit systems) is  to  impose  no
              limitation  on  allocations.   See  the description of <b>SHMALL</b> for a discussion of why this default
              value (rather than <b>ULONG_MAX</b>) is used.

              From Linux 2.2 up to Linux 3.15, the default value of this limit was 0x2000000 (32 MiB).

              Because it is not possible to map just part of a shared memory  segment,  the  amount  of  virtual
              memory  places  another  limit  on  the maximum size of a usable segment: for example, on i386 the
              largest segments that can be mapped have a size of around 2.8 GB,  and  on  x86-64  the  limit  is
              around 127 TB.

       <b>SHMMIN</b> Minimum  size  in  bytes  for a shared memory segment: implementation dependent (currently 1 byte,
              though <b>PAGE_SIZE</b> is the effective minimum size).

       <b>SHMMNI</b> System-wide limit on the number of shared memory segments.  In Linux 2.2, the  default  value  for
              this limit was 128; since Linux 2.4, the default value is 4096.

              On Linux, this limit can be read and modified via <u><a href="file:/proc/sys/kernel/shmmni">/proc/sys/kernel/shmmni</a></u>.

       The  implementation  has  no specific limits for the per-process maximum number of shared memory segments
       (<b>SHMSEG</b>).

   <b>Linux</b> <b>notes</b>
       Until Linux 2.3.30, Linux would return <b>EIDRM</b> for a <b>shmget</b>() on a  shared  memory  segment  scheduled  for
       deletion.

</pre><h4><b>BUGS</b></h4><pre>
       The name choice <b>IPC_PRIVATE</b> was perhaps unfortunate, <b>IPC_NEW</b> would more clearly show its function.

</pre><h4><b>EXAMPLES</b></h4><pre>
       See <b><a href="../man2/shmop.2.html">shmop</a></b>(2).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/memfd_create.2.html">memfd_create</a></b>(2), <b><a href="../man2/shmat.2.html">shmat</a></b>(2), <b><a href="../man2/shmctl.2.html">shmctl</a></b>(2), <b><a href="../man2/shmdt.2.html">shmdt</a></b>(2), <b><a href="../man3/ftok.3.html">ftok</a></b>(3), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/shm_overview.7.html">shm_overview</a></b>(7), <b><a href="../man7/sysvipc.7.html">sysvipc</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                          <u><a href="../man2/shmget.2.html">shmget</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>