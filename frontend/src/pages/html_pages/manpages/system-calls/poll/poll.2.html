<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>poll, ppoll - wait for some event on a file descriptor</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       poll, ppoll - wait for some event on a file descriptor

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/poll.h">poll.h</a>&gt;</b>

       <b>int</b> <b>poll(struct</b> <b>pollfd</b> <b>*</b><u>fds</u><b>,</b> <b>nfds_t</b> <u>nfds</u><b>,</b> <b>int</b> <u>timeout</u><b>);</b>

       <b>#define</b> <b>_GNU_SOURCE</b>         /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/poll.h">poll.h</a>&gt;</b>

       <b>int</b> <b>ppoll(struct</b> <b>pollfd</b> <b>*</b><u>fds</u><b>,</b> <b>nfds_t</b> <u>nfds</u><b>,</b>
                 <b>const</b> <b>struct</b> <b>timespec</b> <b>*_Nullable</b> <u>tmo_p</u><b>,</b>
                 <b>const</b> <b>sigset_t</b> <b>*_Nullable</b> <u>sigmask</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>poll</b>()  performs  a  similar  task  to <b><a href="../man2/select.2.html">select</a></b>(2): it waits for one of a set of file descriptors to become
       ready to perform I/O.  The Linux-specific <b><a href="../man7/epoll.7.html">epoll</a></b>(7) API performs  a  similar  task,  but  offers  features
       beyond those found in <b>poll</b>().

       The  set  of  file  descriptors  to  be  monitored is specified in the <u>fds</u> argument, which is an array of
       structures of the following form:

           struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */
               short revents;    /* returned events */
           };

       The caller should specify the number of items in the <u>fds</u> array in <u>nfds</u>.

       The field <u>fd</u> contains a file descriptor  for  an  open  file.   If  this  field  is  negative,  then  the
       corresponding  <u>events</u> field is ignored and the <u>revents</u> field returns zero.  (This provides an easy way of
       ignoring a file descriptor for a single <b>poll</b>() call: simply set the <u>fd</u> field to its bitwise complement.)

       The field <u>events</u> is an input parameter, a bit mask specifying the events the application is interested in
       for the file descriptor <u>fd</u>.  This field may be specified as zero, in which case the only events that  can
       be returned in <u>revents</u> are <b>POLLHUP</b>, <b>POLLERR</b>, and <b>POLLNVAL</b> (see below).

       The  field  <u>revents</u>  is an output parameter, filled by the kernel with the events that actually occurred.
       The bits returned in <u>revents</u> can include any of those specified in <u>events</u>, or one of the values  <b>POLLERR</b>,
       <b>POLLHUP</b>,  or  <b>POLLNVAL</b>.   (These  three  bits are meaningless in the <u>events</u> field, and will be set in the
       <u>revents</u> field whenever the corresponding condition is true.)

       If none of the events requested (and no error) has occurred for any of the file descriptors, then  <b>poll</b>()
       blocks until one of the events occurs.

       The  <u>timeout</u>  argument  specifies  the number of milliseconds that <b>poll</b>() should block waiting for a file
       descriptor to become ready.  The call will block until either:

       •  a file descriptor becomes ready;

       •  the call is interrupted by a signal handler; or

       •  the timeout expires.

       Being "ready" means that the requested operation will not block; thus,  <b>poll</b>()ing  regular  files,  block
       devices,  and  other  files with no reasonable polling semantic <u>always</u> returns instantly as ready to read
       and write.

       Note that the <u>timeout</u> interval will be rounded up to the system clock granularity, and kernel  scheduling
       delays  mean  that  the  blocking interval may overrun by a small amount.  Specifying a negative value in
       <u>timeout</u> means an infinite timeout.  Specifying a <u>timeout</u> of zero causes  <b>poll</b>()  to  return  immediately,
       even if no file descriptors are ready.

       The bits that may be set/returned in <u>events</u> and <u>revents</u> are defined in <u>&lt;poll.h&gt;</u>:

       <b>POLLIN</b> There is data to read.

       <b>POLLPRI</b>
              There is some exceptional condition on the file descriptor.  Possibilities include:

              •  There is out-of-band data on a TCP socket (see <b><a href="../man7/tcp.7.html">tcp</a></b>(7)).

              •  A pseudoterminal master in packet mode has seen a state change on the slave (see <b><a href="../man2/ioctl_tty.2.html">ioctl_tty</a></b>(2)).

              •  A <u>cgroup.events</u> file has been modified (see <b><a href="../man7/cgroups.7.html">cgroups</a></b>(7)).

       <b>POLLOUT</b>
              Writing  is  now possible, though a write larger than the available space in a socket or pipe will
              still block (unless <b>O_NONBLOCK</b> is set).

       <b>POLLRDHUP</b> (since Linux 2.6.17)
              Stream socket peer closed connection, or shut down writing half of  connection.   The  <b>_GNU_SOURCE</b>
              feature  test  macro  must  be defined (before including <u>any</u> header files) in order to obtain this
              definition.

       <b>POLLERR</b>
              Error condition (only returned in <u>revents</u>; ignored in <u>events</u>).  This bit is also set  for  a  file
              descriptor referring to the write end of a pipe when the read end has been closed.

       <b>POLLHUP</b>
              Hang up (only returned in <u>revents</u>; ignored in <u>events</u>).  Note that when reading from a channel such
              as  a  pipe  or  a  stream socket, this event merely indicates that the peer closed its end of the
              channel.  Subsequent reads from the channel will return 0 (end of file) only after all outstanding
              data in the channel has been consumed.

       <b>POLLNVAL</b>
              Invalid request: <u>fd</u> not open (only returned in <u>revents</u>; ignored in <u>events</u>).

       When compiling with  <b>_XOPEN_SOURCE</b>  defined,  one  also  has  the  following,  which  convey  no  further
       information beyond the bits listed above:

       <b>POLLRDNORM</b>
              Equivalent to <b>POLLIN</b>.

       <b>POLLRDBAND</b>
              Priority band data can be read (generally unused on Linux).

       <b>POLLWRNORM</b>
              Equivalent to <b>POLLOUT</b>.

       <b>POLLWRBAND</b>
              Priority data may be written.

       Linux also knows about, but does not use <b>POLLMSG</b>.

   <b>ppoll()</b>
       The  relationship  between  <b>poll</b>()  and  <b>ppoll</b>()  is  analogous to the relationship between <b><a href="../man2/select.2.html">select</a></b>(2) and
       <b><a href="../man2/pselect.2.html">pselect</a></b>(2): like <b><a href="../man2/pselect.2.html">pselect</a></b>(2), <b>ppoll</b>() allows an application to safely wait until either a file  descriptor
       becomes ready or until a signal is caught.

       Other than the difference in the precision of the <u>timeout</u> argument, the following <b>ppoll</b>() call:

           ready = ppoll(&amp;fds, nfds, tmo_p, &amp;sigmask);

       is nearly equivalent to <u>atomically</u> executing the following calls:

           sigset_t origmask;
           int timeout;

           timeout = (tmo_p == NULL) ? -1 :
                     (tmo_p-&gt;tv_sec * 1000 + tmo_p-&gt;tv_nsec / 1000000);
           pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);
           ready = poll(&amp;fds, nfds, timeout);
           pthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);

       The  above  code  segment  is described as <u>nearly</u> equivalent because whereas a negative <u>timeout</u> value for
       <b>poll</b>() is interpreted as an infinite timeout, a negative value expressed in <u>*tmo_p</u> results  in  an  error
       from <b>ppoll</b>().

       See the description of <b><a href="../man2/pselect.2.html">pselect</a></b>(2) for an explanation of why <b>ppoll</b>() is necessary.

       If  the  <u>sigmask</u>  argument  is specified as NULL, then no signal mask manipulation is performed (and thus
       <b>ppoll</b>() differs from <b>poll</b>() only in the precision of the <u>timeout</u> argument).

       The <u>tmo_p</u> argument specifies an upper limit on the amount of time that <b>ppoll</b>() will block.  This argument
       is a pointer to a <b><a href="../man3/timespec.3.html">timespec</a></b>(3) structure.

       If <u>tmo_p</u> is specified as NULL, then <b>ppoll</b>() can block indefinitely.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>poll</b>() returns a nonnegative value which is the number  of  elements  in  the  <u>pollfds</u>  whose
       <u>revents</u>  fields  have  been  set to a nonzero value (indicating an event or an error).  A return value of
       zero indicates that the system call timed out before any file descriptors became ready.

       On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> <u>fds</u> points outside the process's accessible address space.  The array given as  argument  was  not
              contained in the calling program's address space.

       <b>EINTR</b>  A signal occurred before any requested event; see <b><a href="../man7/signal.7.html">signal</a></b>(7).

       <b>EINVAL</b> The <u>nfds</u> value exceeds the <b>RLIMIT_NOFILE</b> value.

       <b>EINVAL</b> (<b>ppoll</b>()) The timeout value expressed in <u>*tmo_p</u> is invalid (negative).

       <b>ENOMEM</b> Unable to allocate memory for kernel data structures.

</pre><h4><b>VERSIONS</b></h4><pre>
       On some other UNIX systems, <b>poll</b>() can fail with the error <b>EAGAIN</b> if the system fails to allocate kernel-
       internal  resources,  rather  than <b>ENOMEM</b> as Linux does.  POSIX permits this behavior.  Portable programs
       may wish to check for <b>EAGAIN</b> and loop, just as with <b>EINTR</b>.

       Some implementations define the nonstandard constant <b>INFTIM</b> with the value -1 for use as  a  <u>timeout</u>  for
       <b>poll</b>().  This constant is not provided in glibc.

   <b>C</b> <b>library/kernel</b> <b>differences</b>
       The  Linux  <b>ppoll</b>()  system  call modifies its <u>tmo_p</u> argument.  However, the glibc wrapper function hides
       this behavior by using a local variable for the timeout argument that  is  passed  to  the  system  call.
       Thus, the glibc <b>ppoll</b>() function does not modify its <u>tmo_p</u> argument.

       The raw <b>ppoll</b>() system call has a fifth argument, <u>size_t</u> <u>sigsetsize</u>, which specifies the size in bytes of
       the <u>sigmask</u> argument.  The glibc <b>ppoll</b>() wrapper function specifies this argument as a fixed value (equal
       to  <u>sizeof(kernel_sigset_t)</u>).   See <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2) for a discussion on the differences between the kernel
       and the libc notion of the sigset.

</pre><h4><b>STANDARDS</b></h4><pre>
       <b>poll</b>() POSIX.1-2008.

       <b>ppoll</b>()
              Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>poll</b>() POSIX.1-2001.  Linux 2.1.23.

              On older kernels that lack this system call, the glibc <b>poll</b>() wrapper function provides  emulation
              using <b><a href="../man2/select.2.html">select</a></b>(2).

       <b>ppoll</b>()
              Linux 2.6.16, glibc 2.4.

</pre><h4><b>NOTES</b></h4><pre>
       The operation of <b>poll</b>() and <b>ppoll</b>() is not affected by the <b>O_NONBLOCK</b> flag.

       For  a  discussion of what may happen if a file descriptor being monitored by <b>poll</b>() is closed in another
       thread, see <b><a href="../man2/select.2.html">select</a></b>(2).

</pre><h4><b>BUGS</b></h4><pre>
       See the discussion of spurious readiness notifications under the BUGS section of <b><a href="../man2/select.2.html">select</a></b>(2).

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below opens each of the files named in its command-line arguments and monitors the  resulting
       file  descriptors  for readiness to read (<b>POLLIN</b>).  The program loops, repeatedly using <b>poll</b>() to monitor
       the file descriptors, printing the number of ready file descriptors  on  return.   For  each  ready  file
       descriptor, the program:

       •  displays the returned <u>revents</u> field in a human-readable form;

       •  if  the  file  descriptor  is  readable,  reads  some data from it, and displays that data on standard
          output; and

       •  if the file descriptor was not readable, but some other event occurred  (presumably  <b>POLLHUP</b>),  closes
          the file descriptor.

       Suppose we run the program in one terminal, asking it to open a FIFO:

           $ <b>mkfifo</b> <b>myfifo</b>
           $ <b>./poll_input</b> <b>myfifo</b>

       In  a  second  terminal  window,  we then open the FIFO for writing, write some data to it, and close the
       FIFO:

           $ <b>echo</b> <b>aaaaabbbbbccccc</b> <b>&gt;</b> <b>myfifo</b>

       In the terminal where we are running the program, we would then see:

           Opened "myfifo" on fd 3
           About to poll()
           Ready: 1
             fd=3; events: POLLIN POLLHUP
               read 10 bytes: aaaaabbbbb
           About to poll()
           Ready: 1
             fd=3; events: POLLIN POLLHUP
               read 6 bytes: ccccc

           About to poll()
           Ready: 1
             fd=3; events: POLLHUP
               closing fd 3
           All file descriptors closed; bye

       In the above output, we see that <b>poll</b>() returned three times:

       •  On the first return, the bits returned in the <u>revents</u> field were  <b>POLLIN</b>,  indicating  that  the  file
          descriptor  is  readable, and <b>POLLHUP</b>, indicating that the other end of the FIFO has been closed.  The
          program then consumed some of the available input.

       •  The second return from <b>poll</b>() also indicated <b>POLLIN</b> and <b>POLLHUP</b>; the program then consumed the last of
          the available input.

       •  On the final return, <b>poll</b>() indicated only <b>POLLHUP</b> on the FIFO, at which point the file descriptor was
          closed and the program terminated.

   <b>Program</b> <b>source</b>

       /* poll_input.c

          Licensed under GNU General Public License v2 or later.
       */
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/poll.h">poll.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       #define <a href="../manmsg/errExit.msg.html">errExit</a>(msg)    do { <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); \
                               } while (0)

       int
       main(int argc, char *argv[])
       {
           int            ready;
           char           buf[10];
           nfds_t         num_open_fds, nfds;
           ssize_t        s;
           struct pollfd  *pfds;

           if (argc &lt; 2) {
              fprintf(stderr, "Usage: %s file...\n", argv[0]);
              exit(EXIT_FAILURE);
           }

           num_open_fds = nfds = argc - 1;
           pfds = calloc(nfds, sizeof(struct pollfd));
           if (pfds == NULL)
               errExit("malloc");

           /* Open each file on command line, and add it to 'pfds' array. */

           for (nfds_t j = 0; j &lt; nfds; j++) {
               pfds[j].fd = open(argv[j + 1], O_RDONLY);
               if (pfds[j].fd == -1)
                   errExit("open");

               printf("Opened \"%s\" on fd %d\n", argv[j + 1], pfds[j].fd);

               pfds[j].events = POLLIN;
           }

           /* Keep calling poll() as long as at least one file descriptor is
              open. */

           while (num_open_fds &gt; 0) {
               printf("About to poll()\n");
               ready = poll(pfds, nfds, -1);
               if (ready == -1)
                   errExit("poll");

               printf("Ready: %d\n", ready);

               /* Deal with array returned by poll(). */

               for (nfds_t j = 0; j &lt; nfds; j++) {
                   if (pfds[j].revents != 0) {
                       printf("  fd=%d; events: %s%s%s\n", pfds[j].fd,
                              (pfds[j].revents &amp; POLLIN)  ? "POLLIN "  : "",
                              (pfds[j].revents &amp; POLLHUP) ? "POLLHUP " : "",
                              (pfds[j].revents &amp; POLLERR) ? "POLLERR " : "");

                       if (pfds[j].revents &amp; POLLIN) {
                           s = read(pfds[j].fd, buf, sizeof(buf));
                           if (s == -1)
                               errExit("read");
                           printf("    read %zd bytes: %.*s\n",
                                  s, (int) s, buf);
                       } else {                /* POLLERR | POLLHUP */
                           printf("    closing fd %d\n", pfds[j].fd);
                           if (close(pfds[j].fd) == -1)
                               errExit("close");
                           num_open_fds--;
                       }
                   }
               }
           }

           printf("All file descriptors closed; bye\n");
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/restart_syscall.2.html">restart_syscall</a></b>(2), <b><a href="../man2/select.2.html">select</a></b>(2), <b><a href="../man2/select_tut.2.html">select_tut</a></b>(2), <b><a href="../man3/timespec.3.html">timespec</a></b>(3), <b><a href="../man7/epoll.7.html">epoll</a></b>(7), <b><a href="../man7/time.7.html">time</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                            <u><a href="../man2/poll.2.html">poll</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>