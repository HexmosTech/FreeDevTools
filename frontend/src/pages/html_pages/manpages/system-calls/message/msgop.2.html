<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>msgrcv, msgsnd - System V message queue operations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       msgrcv, msgsnd - System V message queue operations

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/msg.h&gt;</b>

       <b>int</b> <b>msgsnd(int</b> <u>msqid</u><b>,</b> <b>const</b> <b>void</b> <u>msgp</u><b>[.</b><u>msgsz</u><b>],</b> <b>size_t</b> <u>msgsz</u><b>,</b>
                      <b>int</b> <u>msgflg</u><b>);</b>

       <b>ssize_t</b> <b>msgrcv(int</b> <u>msqid</u><b>,</b> <b>void</b> <u>msgp</u><b>[.</b><u>msgsz</u><b>],</b> <b>size_t</b> <u>msgsz</u><b>,</b> <b>long</b> <u>msgtyp</u><b>,</b>
                      <b>int</b> <u>msgflg</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>msgsnd</b>()  and  <b>msgrcv</b>()  system  calls  are  used  to send messages to, and receive messages from, a
       System V message queue.  The calling process must have write permission on the message queue in order  to
       send a message, and read permission to receive a message.

       The <u>msgp</u> argument is a pointer to a caller-defined structure of the following general form:

           struct msgbuf {
               long mtype;       /* message type, must be &gt; 0 */
               char mtext[1];    /* message data */
           };

       The  <u>mtext</u> field is an array (or other structure) whose size is specified by <u>msgsz</u>, a nonnegative integer
       value.  Messages of zero length (i.e., no <u>mtext</u> field) are  permitted.   The  <u>mtype</u>  field  must  have  a
       strictly  positive  integer value.  This value can be used by the receiving process for message selection
       (see the description of <b>msgrcv</b>() below).

   <b>msgsnd()</b>
       The <b>msgsnd</b>() system call appends a copy of the message pointed to by <u>msgp</u>  to  the  message  queue  whose
       identifier is specified by <u>msqid</u>.

       If  sufficient  space  is  available  in the queue, <b>msgsnd</b>() succeeds immediately.  The queue capacity is
       governed by the <u>msg_qbytes</u> field in the associated data structure for the message  queue.   During  queue
       creation  this  field  is initialized to <b>MSGMNB</b> bytes, but this limit can be modified using <b><a href="../man2/msgctl.2.html">msgctl</a></b>(2).  A
       message queue is considered to be full if either of the following conditions is true:

       •  Adding a new message to the queue would cause the total number of bytes in the  queue  to  exceed  the
          queue's maximum size (the <u>msg_qbytes</u> field).

       •  Adding  another  message  to the queue would cause the total number of messages in the queue to exceed
          the queue's maximum size (the <u>msg_qbytes</u> field).  This check is  necessary  to  prevent  an  unlimited
          number  of  zero-length  messages  being placed on the queue.  Although such messages contain no data,
          they nevertheless consume (locked) kernel memory.

       If insufficient space is available in the queue, then the default behavior of <b>msgsnd</b>() is to block  until
       space  becomes  available.   If  <b>IPC_NOWAIT</b>  is specified in <u>msgflg</u>, then the call instead fails with the
       error <b>EAGAIN</b>.

       A blocked <b>msgsnd</b>() call may also fail if:

       •  the queue is removed, in which case the system call fails with <u>errno</u> set to <b>EIDRM</b>; or

       •  a signal is caught, in which case the system  call  fails  with  <u>errno</u>  set  to  <b>EINTR</b>;<b>see</b>  <b><a href="../man7/signal.7.html">signal</a></b>(7).
          (<b>msgsnd</b>()  is never automatically restarted after being interrupted by a signal handler, regardless of
          the setting of the <b>SA_RESTART</b> flag when establishing a signal handler.)

       Upon successful completion the message queue data structure is updated as follows:

       •  <u>msg_lspid</u> is set to the process ID of the calling process.

       •  <u>msg_qnum</u> is incremented by 1.

       •  <u>msg_stime</u> is set to the current time.

   <b>msgrcv()</b>
       The <b>msgrcv</b>() system call removes a message from the queue specified by <u>msqid</u> and places it in the  buffer
       pointed to by <u>msgp</u>.

       The  argument  <u>msgsz</u> specifies the maximum size in bytes for the member <u>mtext</u> of the structure pointed to
       by the <u>msgp</u> argument.  If the message text has length greater than <u>msgsz</u>, then the  behavior  depends  on
       whether  <b>MSG_NOERROR</b>  is specified in <u>msgflg</u>.  If <b>MSG_NOERROR</b> is specified, then the message text will be
       truncated (and the truncated part will be lost); if <b>MSG_NOERROR</b> is not specified, then the message  isn't
       removed from the queue and the system call fails returning -1 with <u>errno</u> set to <b>E2BIG</b>.

       Unless  <b>MSG_COPY</b>  is  specified  in <u>msgflg</u> (see below), the <u>msgtyp</u> argument specifies the type of message
       requested, as follows:

       •  If <u>msgtyp</u> is 0, then the first message in the queue is read.

       •  If <u>msgtyp</u> is greater than 0, then the first message in the  queue  of  type  <u>msgtyp</u>  is  read,  unless
          <b>MSG_EXCEPT</b>  was specified in <u>msgflg</u>, in which case the first message in the queue of type not equal to
          <u>msgtyp</u> will be read.

       •  If <u>msgtyp</u> is less than 0, then the first message in the queue with the lowest type less than or  equal
          to the absolute value of <u>msgtyp</u> will be read.

       The <u>msgflg</u> argument is a bit mask constructed by ORing together zero or more of the following flags:

       <b>IPC_NOWAIT</b>
              Return  immediately  if  no  message of the requested type is in the queue.  The system call fails
              with <u>errno</u> set to <b>ENOMSG</b>.

       <b>MSG_COPY</b> (since Linux 3.8)
              Nondestructively fetch a copy of the message at the ordinal position in  the  queue  specified  by
              <u>msgtyp</u> (messages are considered to be numbered starting at 0).

              This  flag  must be specified in conjunction with <b>IPC_NOWAIT</b>, with the result that, if there is no
              message available at the given position,  the  call  fails  immediately  with  the  error  <b>ENOMSG</b>.
              Because  they alter the meaning of <u>msgtyp</u> in orthogonal ways, <b>MSG_COPY</b> and <b>MSG_EXCEPT</b> may not both
              be specified in <u>msgflg</u>.

              The <b>MSG_COPY</b> flag was added for the implementation of the kernel checkpoint-restore  facility  and
              is available only if the kernel was built with the <b>CONFIG_CHECKPOINT_RESTORE</b> option.

       <b>MSG_EXCEPT</b>
              Used  with  <u>msgtyp</u>  greater  than  0 to read the first message in the queue with message type that
              differs from <u>msgtyp</u>.

       <b>MSG_NOERROR</b>
              To truncate the message text if longer than <u>msgsz</u> bytes.

       If no message of the requested type is available and <b>IPC_NOWAIT</b> isn't specified in  <u>msgflg</u>,  the  calling
       process is blocked until one of the following conditions occurs:

       •  A message of the desired type is placed in the queue.

       •  The  message  queue is removed from the system.  In this case, the system call fails with <u>errno</u> set to
          <b>EIDRM</b>.

       •  The calling process catches a signal.  In this case, the system call fails with <u>errno</u>  set  to  <b>EINTR</b>.
          (<b>msgrcv</b>()  is never automatically restarted after being interrupted by a signal handler, regardless of
          the setting of the <b>SA_RESTART</b> flag when establishing a signal handler.)

       Upon successful completion the message queue data structure is updated as follows:

              <u>msg_lrpid</u> is set to the process ID of the calling process.

              <u>msg_qnum</u> is decremented by 1.

              <u>msg_rtime</u> is set to the current time.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>msgsnd</b>() returns 0 and <b>msgrcv</b>() returns the number of bytes actually copied  into  the  <u>mtext</u>
       array.  On failure, both functions return -1, and set <u>errno</u> to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>msgsnd</b>() can fail with the following errors:

       <b>EACCES</b> The  calling  process  does  not have write permission on the message queue, and does not have the
              <b>CAP_IPC_OWNER</b> capability in the user namespace that governs its IPC namespace.

       <b>EAGAIN</b> The message can't be sent due to the <u>msg_qbytes</u> limit for the queue and <b>IPC_NOWAIT</b>  was  specified
              in <u>msgflg</u>.

       <b>EFAULT</b> The address pointed to by <u>msgp</u> isn't accessible.

       <b>EIDRM</b>  The message queue was removed.

       <b>EINTR</b>  Sleeping on a full message queue condition, the process caught a signal.

       <b>EINVAL</b> Invalid  <u>msqid</u>  value,  or nonpositive <u>mtype</u> value, or invalid <u>msgsz</u> value (less than 0 or greater
              than the system value <b>MSGMAX</b>).

       <b>ENOMEM</b> The system does not have enough memory to make a copy of the message pointed to by <u>msgp</u>.

       <b>msgrcv</b>() can fail with the following errors:

       <b>E2BIG</b>  The message text length is greater than <u>msgsz</u> and <b>MSG_NOERROR</b> isn't specified in <u>msgflg</u>.

       <b>EACCES</b> The calling process does not have read permission on the message queue,  and  does  not  have  the
              <b>CAP_IPC_OWNER</b> capability in the user namespace that governs its IPC namespace.

       <b>EFAULT</b> The address pointed to by <u>msgp</u> isn't accessible.

       <b>EIDRM</b>  While the process was sleeping to receive a message, the message queue was removed.

       <b>EINTR</b>  While the process was sleeping to receive a message, the process caught a signal; see <b><a href="../man7/signal.7.html">signal</a></b>(7).

       <b>EINVAL</b> <u>msqid</u> was invalid, or <u>msgsz</u> was less than 0.

       <b>EINVAL</b> (since Linux 3.14)
              <u>msgflg</u> specified <b>MSG_COPY</b>, but not <b>IPC_NOWAIT</b>.

       <b>EINVAL</b> (since Linux 3.14)
              <u>msgflg</u> specified both <b>MSG_COPY</b> and <b>MSG_EXCEPT</b>.

       <b>ENOMSG</b> <b>IPC_NOWAIT</b>  was  specified  in  <u>msgflg</u> and no message of the requested type existed on the message
              queue.

       <b>ENOMSG</b> <b>IPC_NOWAIT</b> and <b>MSG_COPY</b> were specified in <u>msgflg</u> and the queue contains less than <u>msgtyp</u> messages.

       <b>ENOSYS</b> (since Linux 3.8)
              Both <b>MSG_COPY</b> and <b>IPC_NOWAIT</b> were specified in <u>msgflg</u>, and  this  kernel  was  configured  without
              <b>CONFIG_CHECKPOINT_RESTORE</b>.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

       The  <b>MSG_EXCEPT</b>  and <b>MSG_COPY</b> flags are Linux-specific; their definitions can be obtained by defining the
       <b>_GNU_SOURCE</b> feature test macro.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001, SVr4.

       The <u>msgp</u> argument is declared as <u>struct</u> <u>msgbuf</u> <u>*</u> in glibc 2.0 and 2.1.  It is declared as <u>void</u> <u>*</u> in glibc
       2.2 and later, as required by SUSv2 and SUSv3.

</pre><h4><b>NOTES</b></h4><pre>
       The following limits on message queue resources affect the <b>msgsnd</b>() call:

       <b>MSGMAX</b> Maximum size of a message text, in bytes (default value: 8192 bytes).  On Linux, this limit can be
              read and modified via <u><a href="file:/proc/sys/kernel/msgmax">/proc/sys/kernel/msgmax</a></u>.

       <b>MSGMNB</b> Maximum number of bytes that can be held in a message queue  (default  value:  16384  bytes).   On
              Linux,  this  limit  can  be  read and modified via <u><a href="file:/proc/sys/kernel/msgmnb">/proc/sys/kernel/msgmnb</a></u>.  A privileged process
              (Linux: a process with the <b>CAP_SYS_RESOURCE</b> capability) can increase the size of a  message  queue
              beyond <b>MSGMNB</b> using the <b><a href="../man2/msgctl.2.html">msgctl</a></b>(2) <b>IPC_SET</b> operation.

       The  implementation has no intrinsic system-wide limits on the number of message headers (<b>MSGTQL</b>) and the
       number of bytes in the message pool (<b>MSGPOOL</b>).

</pre><h4><b>BUGS</b></h4><pre>
       In Linux 3.13 and earlier, if <b>msgrcv</b>() was called with the <b>MSG_COPY</b> flag, but without <b>IPC_NOWAIT</b>, and the
       message queue contained less than <u>msgtyp</u> messages, then the call would block until the  next  message  is
       written  to the queue.  At that point, the call would return a copy of the message, <u>regardless</u> of whether
       that message was at the ordinal position <u>msgtyp</u>.  This bug is fixed in Linux 3.14.

       Specifying both <b>MSG_COPY</b> and <b>MSC_EXCEPT</b> in <u>msgflg</u> is a logical error (since these flags impose  different
       interpretations  on  <u>msgtyp</u>).  In Linux 3.13 and earlier, this error was not diagnosed by <b>msgrcv</b>().  This
       bug is fixed in Linux 3.14.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below demonstrates the use of <b>msgsnd</b>() and <b>msgrcv</b>().

       The example program is first run with the <b>-s</b> option to send a message and then  run  again  with  the  <b>-r</b>
       option to receive a message.

       The following shell session shows a sample run of the program:

           $ <b>./a.out</b> <b>-s</b>
           sent: a message at Wed Mar  4 16:25:45 2015

       $ <b>./a.out</b> <b>-r</b>
       message received: a message at Wed Mar  4 16:25:45 2015

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/ipc.h&gt;
       #include &lt;sys/msg.h&gt;
       #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       struct msgbuf {
           long mtype;
           char mtext[80];
       };

       static void
       usage(char *prog_name, char *msg)
       {
           if (msg != NULL)
               fputs(msg, stderr);

           fprintf(stderr, "Usage: %s [options]\n", prog_name);
           fprintf(stderr, "Options are:\n");
           fprintf(stderr, "-s        send message using msgsnd()\n");
           fprintf(stderr, "-r        read message using msgrcv()\n");
           fprintf(stderr, "-t        message type (default is 1)\n");
           fprintf(stderr, "-k        message queue key (default is 1234)\n");
           exit(EXIT_FAILURE);
       }

       static void
       send_msg(int qid, int msgtype)
       {
           time_t         t;
           struct msgbuf  msg;

           msg.mtype = msgtype;

           time(&amp;t);
           snprintf(msg.mtext, sizeof(msg.mtext), "a message at %s",
                    ctime(&amp;t));

           if (msgsnd(qid, &amp;msg, sizeof(msg.mtext),
                      IPC_NOWAIT) == -1)
           {
               perror("msgsnd error");
               exit(EXIT_FAILURE);
           }
           printf("sent: %s\n", msg.mtext);
       }

       static void
       get_msg(int qid, int msgtype)
       {
           struct msgbuf msg;

           if (msgrcv(qid, &amp;msg, sizeof(msg.mtext), msgtype,
                      MSG_NOERROR | IPC_NOWAIT) == -1) {
               if (errno != ENOMSG) {
                   perror("msgrcv");
                   exit(EXIT_FAILURE);
               }
               printf("No message available for msgrcv()\n");
           } else {
               printf("message received: %s\n", msg.mtext);
           }
       }

       int
       main(int argc, char *argv[])
       {
           int  qid, opt;
           int  mode = 0;               /* 1 = send, 2 = receive */
           int  msgtype = 1;
           int  msgkey = 1234;

           while ((opt = getopt(argc, argv, "srt:k:")) != -1) {
               switch (opt) {
               case 's':
                   mode = 1;
                   break;
               case 'r':
                   mode = 2;
                   break;
               case 't':
                   msgtype = atoi(optarg);
                   if (msgtype &lt;= 0)
                       usage(argv[0], "-t option must be greater than 0\n");
                   break;
               case 'k':
                   msgkey = atoi(optarg);
                   break;
               default:
                   usage(argv[0], "Unrecognized option\n");
               }
           }

           if (mode == 0)
               usage(argv[0], "must use either -s or -r option\n");

           qid = msgget(msgkey, IPC_CREAT | 0666);

           if (qid == -1) {
               perror("msgget");
               exit(EXIT_FAILURE);
           }

           if (mode == 2)
               get_msg(qid, msgtype);
           else
               send_msg(qid, msgtype);

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/msgctl.2.html">msgctl</a></b>(2), <b><a href="../man2/msgget.2.html">msgget</a></b>(2), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/mq_overview.7.html">mq_overview</a></b>(7), <b><a href="../man7/sysvipc.7.html">sysvipc</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                           <u><a href="../man2/MSGOP.2.html">MSGOP</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>