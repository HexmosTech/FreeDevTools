<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mremap - remap a virtual memory address</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mremap - remap a virtual memory address

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>         /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;sys/mman.h&gt;</b>

       <b>void</b> <b>*mremap(void</b> <u>old_address</u><b>[.</b><u>old_size</u><b>],</b> <b>size_t</b> <u>old_size</u><b>,</b>
                    <b>size_t</b> <u>new_size</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>...</b> <b>/*</b> <b>void</b> <b>*</b><u>new_address</u> <b>*/);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>mremap</b>()  expands  (or  shrinks)  an  existing  memory  mapping,  potentially  moving it at the same time
       (controlled by the <u>flags</u> argument and the available virtual address space).

       <u>old_address</u> is the old address of the virtual memory block that you want to  expand  (or  shrink).   Note
       that <u>old_address</u> has to be page aligned.  <u>old_size</u> is the old size of the virtual memory block.  <u>new_size</u>
       is  the  requested  size  of  the  virtual  memory  block  after the resize.  An optional fifth argument,
       <u>new_address</u>, may be provided; see the description of <b>MREMAP_FIXED</b> below.

       If the value of <u>old_size</u> is zero, and <u>old_address</u> refers to a shareable mapping (see the  description  of
       <b>MAP_SHARED</b>  in <b><a href="../man2/mmap.2.html">mmap</a></b>(2)), then <b>mremap</b>() will create a new mapping of the same pages.  <u>new_size</u> will be the
       size of the new mapping and the location of the new mapping may be specified with  <u>new_address</u>;  see  the
       description  of  <b>MREMAP_FIXED</b>  below.   If  a  new  mapping  is  requested  via  this  method,  then  the
       <b>MREMAP_MAYMOVE</b> flag must also be specified.

       The <u>flags</u> bit-mask argument may be 0, or include the following flags:

       <b>MREMAP_MAYMOVE</b>
              By default, if there is not sufficient space to expand a mapping at  its  current  location,  then
              <b>mremap</b>()  fails.   If this flag is specified, then the kernel is permitted to relocate the mapping
              to a new virtual address, if necessary.  If the mapping is relocated, then absolute pointers  into
              the  old  mapping location become invalid (offsets relative to the starting address of the mapping
              should be employed).

       <b>MREMAP_FIXED</b> (since Linux 2.3.31)
              This flag serves a similar purpose to the <b>MAP_FIXED</b> flag of <b><a href="../man2/mmap.2.html">mmap</a></b>(2).  If this flag  is  specified,
              then  <b>mremap</b>() accepts a fifth argument, <u>void</u> <u>*new_address</u>, which specifies a page-aligned address
              to which the mapping must be moved.  Any previous  mapping  at  the  address  range  specified  by
              <u>new_address</u> and <u>new_size</u> is unmapped.

              If <b>MREMAP_FIXED</b> is specified, then <b>MREMAP_MAYMOVE</b> must also be specified.

       <b>MREMAP_DONTUNMAP</b> (since Linux 5.7)
              This  flag,  which  must  be  used  in  conjunction with <b>MREMAP_MAYMOVE</b>, remaps a mapping to a new
              address but does not unmap the mapping at <u>old_address</u>.

              The <b>MREMAP_DONTUNMAP</b> flag can be used only with private anonymous mappings (see the description of
              <b>MAP_PRIVATE</b> and <b>MAP_ANONYMOUS</b> in <b><a href="../man2/mmap.2.html">mmap</a></b>(2)).

              After completion, any access to the range specified by <u>old_address</u> and <u>old_size</u> will result  in  a
              page  fault.   The  page  fault will be handled by a <b><a href="../man2/userfaultfd.2.html">userfaultfd</a></b>(2) handler if the address is in a
              range previously registered with <b><a href="../man2/userfaultfd.2.html">userfaultfd</a></b>(2).  Otherwise, the kernel  allocates  a  zero-filled
              page to handle the fault.

              The  <b>MREMAP_DONTUNMAP</b>  flag  may  be  used  to  atomically move a mapping while leaving the source
              mapped.  See NOTES for some possible applications of <b>MREMAP_DONTUNMAP</b>.

       If the memory segment specified by <u>old_address</u> and <u>old_size</u> is locked (using <b><a href="../man2/mlock.2.html">mlock</a></b>(2) or  similar),  then
       this  lock  is  maintained when the segment is resized and/or relocated.  As a consequence, the amount of
       memory locked by the process may change.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success <b>mremap</b>() returns a pointer to the new virtual memory area.  On  error,  the  value  <b>MAP_FAILED</b>
       (that is, <u>(void</u> <u>*)</u> <u>-1</u>) is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EAGAIN</b> The  caller  tried  to  expand  a memory segment that is locked, but this was not possible without
              exceeding the <b>RLIMIT_MEMLOCK</b> resource limit.

       <b>EFAULT</b> Some address in the range <u>old_address</u> to <u>old_address</u>+<u>old_size</u> is an invalid virtual memory address
              for this process.  You can also get <b>EFAULT</b> even if there  exist  mappings  that  cover  the  whole
              address space requested, but those mappings are of different types.

       <b>EINVAL</b> An invalid argument was given.  Possible causes are:

              •  <u>old_address</u> was not page aligned;

              •  a value other than <b>MREMAP_MAYMOVE</b> or <b>MREMAP_FIXED</b> or <b>MREMAP_DONTUNMAP</b> was specified in <u>flags</u>;

              •  <u>new_size</u> was zero;

              •  <u>new_size</u> or <u>new_address</u> was invalid;

              •  the  new  address  range specified by <u>new_address</u> and <u>new_size</u> overlapped the old address range
                 specified by <u>old_address</u> and <u>old_size</u>;

              •  <b>MREMAP_FIXED</b> or <b>MREMAP_DONTUNMAP</b> was specified without also specifying <b>MREMAP_MAYMOVE</b>;

              •  <b>MREMAP_DONTUNMAP</b> was specified, but one or more pages in the range specified by <u>old_address</u> and
                 <u>old_size</u> were not private anonymous;

              •  <b>MREMAP_DONTUNMAP</b> was specified and <u>old_size</u> was not equal to <u>new_size</u>;

              •  <u>old_size</u> was zero and <u>old_address</u> does not refer to a shareable mapping (but see BUGS);

              •  <u>old_size</u> was zero and the <b>MREMAP_MAYMOVE</b> flag was not specified.

       <b>ENOMEM</b> Not enough memory was available to complete the operation.  Possible causes are:

              •  The memory area cannot be expanded at the current virtual address, and the <b>MREMAP_MAYMOVE</b>  flag
                 is not set in <u>flags</u>.  Or, there is not enough (virtual) memory available.

              •  <b>MREMAP_DONTUNMAP</b>  was  used causing a new mapping to be created that would exceed the (virtual)
                 memory available.  Or, it would exceed the maximum number of allowed mappings.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Prior to glibc 2.4, glibc did not expose the definition of <b>MREMAP_FIXED</b>, and the prototype  for  <b>mremap</b>()
       did not allow for the <u>new_address</u> argument.

</pre><h4><b>NOTES</b></h4><pre>
       <b>mremap</b>() changes the mapping between virtual addresses and memory pages.  This can be used to implement a
       very efficient <b><a href="../man3/realloc.3.html">realloc</a></b>(3).

       In  Linux,  memory is divided into pages.  A process has (one or) several linear virtual memory segments.
       Each virtual memory segment has one or more mappings to real memory pages  (in  the  page  table).   Each
       virtual  memory  segment has its own protection (access rights), which may cause a segmentation violation
       (<b>SIGSEGV</b>) if the memory is accessed incorrectly  (e.g.,  writing  to  a  read-only  segment).   Accessing
       virtual memory outside of the segments will also cause a segmentation violation.

       If  <b>mremap</b>() is used to move or expand an area locked with <b><a href="../man2/mlock.2.html">mlock</a></b>(2) or equivalent, the <b>mremap</b>() call will
       make a best effort to populate the new area but  will  not  fail  with  <b>ENOMEM</b>  if  the  area  cannot  be
       populated.

   <b>MREMAP_DONTUNMAP</b> <b>use</b> <b>cases</b>
       Possible applications for <b>MREMAP_DONTUNMAP</b> include:

       •  Non-cooperative   <b><a href="../man2/userfaultfd.2.html">userfaultfd</a></b>(2):   an  application  can  yank  out  a  virtual  address  range  using
          <b>MREMAP_DONTUNMAP</b> and then employ a <b><a href="../man2/userfaultfd.2.html">userfaultfd</a></b>(2) handler to handle the page faults that  subsequently
          occur as other threads in the process touch pages in the yanked range.

       •  Garbage  collection:  <b>MREMAP_DONTUNMAP</b>  can  be  used  in conjunction with <b><a href="../man2/userfaultfd.2.html">userfaultfd</a></b>(2) to implement
          garbage collection algorithms (e.g., in a Java  virtual  machine).   Such  an  implementation  can  be
          cheaper  (and simpler) than conventional garbage collection techniques that involve marking pages with
          protection <b>PROT_NONE</b> in conjunction with the use of a <b>SIGSEGV</b>  handler  to  catch  accesses  to  those
          pages.

</pre><h4><b>BUGS</b></h4><pre>
       Before  Linux 4.14, if <u>old_size</u> was zero and the mapping referred to by <u>old_address</u> was a private mapping
       (see the description of <b>MAP_PRIVATE</b> in <b><a href="../man2/mmap.2.html">mmap</a></b>(2)), <b>mremap</b>() created a new private mapping unrelated to  the
       original mapping.  This behavior was unintended and probably unexpected in user-space applications (since
       the  intention  of <b>mremap</b>() is to create a new mapping based on the original mapping).  Since Linux 4.14,
       <b>mremap</b>() fails with the error <b>EINVAL</b> in this scenario.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/brk.2.html">brk</a></b>(2), <b><a href="../man2/getpagesize.2.html">getpagesize</a></b>(2), <b><a href="../man2/getrlimit.2.html">getrlimit</a></b>(2), <b><a href="../man2/mlock.2.html">mlock</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man2/sbrk.2.html">sbrk</a></b>(2), <b><a href="../man3/malloc.3.html">malloc</a></b>(3), <b><a href="../man3/realloc.3.html">realloc</a></b>(3)

       Your favorite text book on operating systems for more information on paged memory (e.g., <u>Modern</u> <u>Operating</u>
       <u>Systems</u> by Andrew S. Tanenbaum, <u>Inside</u> <u>Linux</u> by Randolph Bentson, <u>The</u> <u>Design</u> <u>of</u> <u>the</u> <u>UNIX</u> <u>Operating</u> <u>System</u>
       by Maurice J. Bach)

Linux man-pages 6.9.1                              2024-05-02                                          <u><a href="../man2/mremap.2.html">mremap</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>