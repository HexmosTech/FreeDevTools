<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO, fd_set - synchronous I/O multiplexing</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO, fd_set - synchronous I/O multiplexing

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/select.h&gt;</b>

       <b>typedef</b> /* ... */ <b>fd_set;</b>

       <b>int</b> <b>select(int</b> <u>nfds</u><b>,</b> <b>fd_set</b> <b>*_Nullable</b> <b>restrict</b> <u>readfds</u><b>,</b>
                  <b>fd_set</b> <b>*_Nullable</b> <b>restrict</b> <u>writefds</u><b>,</b>
                  <b>fd_set</b> <b>*_Nullable</b> <b>restrict</b> <u>exceptfds</u><b>,</b>
                  <b>struct</b> <b>timeval</b> <b>*_Nullable</b> <b>restrict</b> <u>timeout</u><b>);</b>

       <b>void</b> <b>FD_CLR(int</b> <u>fd</u><b>,</b> <b>fd_set</b> <b>*</b><u>set</u><b>);</b>
       <b>int</b>  <b>FD_ISSET(int</b> <u>fd</u><b>,</b> <b>fd_set</b> <b>*</b><u>set</u><b>);</b>
       <b>void</b> <b>FD_SET(int</b> <u>fd</u><b>,</b> <b>fd_set</b> <b>*</b><u>set</u><b>);</b>
       <b>void</b> <b>FD_ZERO(fd_set</b> <b>*</b><u>set</u><b>);</b>

       <b>int</b> <b>pselect(int</b> <u>nfds</u><b>,</b> <b>fd_set</b> <b>*_Nullable</b> <b>restrict</b> <u>readfds</u><b>,</b>
                  <b>fd_set</b> <b>*_Nullable</b> <b>restrict</b> <u>writefds</u><b>,</b>
                  <b>fd_set</b> <b>*_Nullable</b> <b>restrict</b> <u>exceptfds</u><b>,</b>
                  <b>const</b> <b>struct</b> <b>timespec</b> <b>*_Nullable</b> <b>restrict</b> <u>timeout</u><b>,</b>
                  <b>const</b> <b>sigset_t</b> <b>*_Nullable</b> <b>restrict</b> <u>sigmask</u><b>);</b>

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>pselect</b>():
           _POSIX_C_SOURCE &gt;= 200112L

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>WARNING</b>:  <b>select</b>()  can  monitor  only  file  descriptors numbers that are less than <b>FD_SETSIZE</b> (1024)—an
       unreasonably low limit for many modern applications—and this limitation  will  not  change.   All  modern
       applications should instead use <b><a href="../man2/poll.2.html">poll</a></b>(2) or <b><a href="../man7/epoll.7.html">epoll</a></b>(7), which do not suffer this limitation.

       <b>select</b>()  allows  a  program  to monitor multiple file descriptors, waiting until one or more of the file
       descriptors become "ready" for some class of I/O operation (e.g., input possible).  A file descriptor  is
       considered  ready  if  it  is  possible  to  perform  a  corresponding I/O operation (e.g., <b><a href="../man2/read.2.html">read</a></b>(2), or a
       sufficiently small <b><a href="../man2/write.2.html">write</a></b>(2)) without blocking.

   <b>fd_set</b>
       A structure type that can represent a set of file descriptors.  According to POSIX, the maximum number of
       file descriptors in an <u>fd_set</u> structure is the value of the macro <b>FD_SETSIZE</b>.

   <b>File</b> <b>descriptor</b> <b>sets</b>
       The principal arguments of <b>select</b>() are three "sets" of file descriptors (declared with the type <u>fd_set</u>),
       which allow the caller to wait for three classes of events on the  specified  set  of  file  descriptors.
       Each  of  the  <u>fd_set</u> arguments may be specified as NULL if no file descriptors are to be watched for the
       corresponding class of events.

       <b>Note</b> <b>well</b>: Upon return, each of the file descriptor sets is modified in  place  to  indicate  which  file
       descriptors are currently "ready".  Thus, if using <b>select</b>() within a loop, the sets <u>must</u> <u>be</u> <u>reinitialized</u>
       before each call.

       The contents of a file descriptor set can be manipulated using the following macros:

       <b>FD_ZERO</b>()
              This  macro  clears  (removes  all file descriptors from) <u>set</u>.  It should be employed as the first
              step in initializing a file descriptor set.

       <b>FD_SET</b>()
              This macro adds the file descriptor <u>fd</u> to <u>set</u>.  Adding a file descriptor that is  already  present
              in the set is a no-op, and does not produce an error.

       <b>FD_CLR</b>()
              This  macro  removes  the  file  descriptor  <u>fd</u>  from <u>set</u>.  Removing a file descriptor that is not
              present in the set is a no-op, and does not produce an error.

       <b>FD_ISSET</b>()
              <b>select</b>() modifies the contents of the sets according to the rules described below.  After  calling
              <b>select</b>(), the <b>FD_ISSET</b>() macro can be used to test if a file descriptor is still present in a set.
              <b>FD_ISSET</b>() returns nonzero if the file descriptor <u>fd</u> is present in <u>set</u>, and zero if it is not.

   <b>Arguments</b>
       The arguments of <b>select</b>() are as follows:

       <u>readfds</u>
              The  file  descriptors  in  this  set  are  watched  to see if they are ready for reading.  A file
              descriptor is ready for reading if a  read  operation  will  not  block;  in  particular,  a  file
              descriptor is also ready on end-of-file.

              After <b>select</b>() has returned, <u>readfds</u> will be cleared of all file descriptors except for those that
              are ready for reading.

       <u>writefds</u>
              The  file  descriptors  in  this  set  are  watched  to see if they are ready for writing.  A file
              descriptor is ready for writing if a write operation will not block.   However,  even  if  a  file
              descriptor indicates as writable, a large write may still block.

              After  <b>select</b>()  has  returned,  <u>writefds</u> will be cleared of all file descriptors except for those
              that are ready for writing.

       <u>exceptfds</u>
              The file descriptors in this set are watched for "exceptional conditions".  For examples  of  some
              exceptional conditions, see the discussion of <b>POLLPRI</b> in <b><a href="../man2/poll.2.html">poll</a></b>(2).

              After  <b>select</b>()  has  returned, <u>exceptfds</u> will be cleared of all file descriptors except for those
              for which an exceptional condition has occurred.

       <u>nfds</u>   This argument should be set to the highest-numbered file descriptor in any of the three sets, plus
              1.  The indicated file descriptors in each set are checked, up to this limit (but see BUGS).

       <u>timeout</u>
              The <u>timeout</u> argument is a <u>timeval</u>  structure  (shown  below)  that  specifies  the  interval  that
              <b>select</b>()  should  block  waiting for a file descriptor to become ready.  The call will block until
              either:

              •  a file descriptor becomes ready;

              •  the call is interrupted by a signal handler; or

              •  the timeout expires.

              Note that the <u>timeout</u> interval will be rounded up to the  system  clock  granularity,  and  kernel
              scheduling delays mean that the blocking interval may overrun by a small amount.

              If  both  fields  of  the <u>timeval</u> structure are zero, then <b>select</b>() returns immediately.  (This is
              useful for polling.)

              If <u>timeout</u> is specified as NULL, <b>select</b>() blocks indefinitely waiting for  a  file  descriptor  to
              become ready.

   <b>pselect()</b>
       The  <b>pselect</b>()  system  call  allows an application to safely wait until either a file descriptor becomes
       ready or until a signal is caught.

       The operation of <b>select</b>() and <b>pselect</b>() is identical, other than these three differences:

       •  <b>select</b>() uses a timeout that is a <u>struct</u> <u>timeval</u> (with seconds and microseconds), while <b>pselect</b>() uses
          a <u>struct</u> <u>timespec</u> (with seconds and nanoseconds).

       •  <b>select</b>() may update the <u>timeout</u> argument to indicate how much  time  was  left.   <b>pselect</b>()  does  not
          change this argument.

       •  <b>select</b>() has no <u>sigmask</u> argument, and behaves as <b>pselect</b>() called with NULL <u>sigmask</u>.

       <u>sigmask</u>  is  a  pointer  to  a  signal mask (see <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2)); if it is not NULL, then <b>pselect</b>() first
       replaces the current signal mask by the one pointed to by <u>sigmask</u>, then does the "select"  function,  and
       then  restores the original signal mask.  (If <u>sigmask</u> is NULL, the signal mask is not modified during the
       <b>pselect</b>() call.)

       Other than the difference in the precision of the <u>timeout</u> argument, the following <b>pselect</b>() call:

           ready = pselect(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds,
                           timeout, &amp;sigmask);

       is equivalent to <u>atomically</u> executing the following calls:

           sigset_t origmask;

           pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);
           ready = select(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds, timeout);
           pthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);

       The reason that <b>pselect</b>() is needed is that if one wants to wait for  either  a  signal  or  for  a  file
       descriptor  to  become  ready,  then  an  atomic test is needed to prevent race conditions.  (Suppose the
       signal handler sets a global flag and returns.  Then a test of this global flag followed  by  a  call  of
       <b>select</b>()  could hang indefinitely if the signal arrived just after the test but just before the call.  By
       contrast, <b>pselect</b>() allows one to first block signals, handle the signals that have come  in,  then  call
       <b>pselect</b>() with the desired <u>sigmask</u>, avoiding the race.)

   <b>The</b> <b>timeout</b>
       The <u>timeout</u> argument for <b>select</b>() is a structure of the following type:

           struct timeval {
               time_t      tv_sec;         /* seconds */
               suseconds_t tv_usec;        /* microseconds */
           };

       The corresponding argument for <b>pselect</b>() is a <b><a href="../man3/timespec.3.html">timespec</a></b>(3) structure.

       On  Linux,  <b>select</b>() modifies <u>timeout</u> to reflect the amount of time not slept; most other implementations
       do not do this.  (POSIX.1 permits either behavior.)  This causes problems  both  when  Linux  code  which
       reads <u>timeout</u> is ported to other operating systems, and when code is ported to Linux that reuses a <u>struct</u>
       <u>timeval</u>  for  multiple  <b>select</b>()s  in a loop without reinitializing it.  Consider <u>timeout</u> to be undefined
       after <b>select</b>() returns.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>select</b>() and <b>pselect</b>() return the number of file descriptors contained in the three  returned
       descriptor  sets  (that  is, the total number of bits that are set in <u>readfds</u>, <u>writefds</u>, <u>exceptfds</u>).  The
       return value may be zero if the timeout expired before any file descriptors became ready.

       On error, -1 is returned, and <u>errno</u>  is  set  to  indicate  the  error;  the  file  descriptor  sets  are
       unmodified, and <u>timeout</u> becomes undefined.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EBADF</b>  An  invalid  file  descriptor  was  given in one of the sets.  (Perhaps a file descriptor that was
              already closed, or one on which an error has occurred.)  However, see BUGS.

       <b>EINTR</b>  A signal was caught; see <b><a href="../man7/signal.7.html">signal</a></b>(7).

       <b>EINVAL</b> <u>nfds</u> is negative or exceeds the <b>RLIMIT_NOFILE</b> resource limit (see <b><a href="../man2/getrlimit.2.html">getrlimit</a></b>(2)).

       <b>EINVAL</b> The value contained within <u>timeout</u> is invalid.

       <b>ENOMEM</b> Unable to allocate memory for internal tables.

</pre><h4><b>VERSIONS</b></h4><pre>
       On some other UNIX systems, <b>select</b>() can fail with the error <b>EAGAIN</b>  if  the  system  fails  to  allocate
       kernel-internal resources, rather than <b>ENOMEM</b> as Linux does.  POSIX specifies this error for <b><a href="../man2/poll.2.html">poll</a></b>(2), but
       not for <b>select</b>().  Portable programs may wish to check for <b>EAGAIN</b> and loop, just as with <b>EINTR</b>.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>select</b>()
              POSIX.1-2001, 4.4BSD (first appeared in 4.2BSD).

              Generally  portable  to/from  non-BSD systems supporting clones of the BSD socket layer (including
              System V variants).  However, note that the System V variant typically sets the  timeout  variable
              before returning, but the BSD variant does not.

       <b>pselect</b>()
              Linux 2.6.16.  POSIX.1g, POSIX.1-2001.

              Prior to this, it was emulated in glibc (but see BUGS).

       <b>fd_set</b> POSIX.1-2001.

</pre><h4><b>NOTES</b></h4><pre>
       The following header also provides the <u>fd_set</u> type: <u>&lt;sys/time.h&gt;</u>.

       An  <u>fd_set</u> is a fixed size buffer.  Executing <b>FD_CLR</b>() or <b>FD_SET</b>() with a value of <u>fd</u> that is negative or
       is equal to or larger than <b>FD_SETSIZE</b> will result in undefined behavior.  Moreover, POSIX requires <u>fd</u>  to
       be a valid file descriptor.

       The operation of <b>select</b>() and <b>pselect</b>() is not affected by the <b>O_NONBLOCK</b> flag.

   <b>The</b> <b>self-pipe</b> <b>trick</b>
       On  systems  that  lack <b>pselect</b>(), reliable (and more portable) signal trapping can be achieved using the
       self-pipe trick.  In this technique, a signal handler writes  a  byte  to  a  pipe  whose  other  end  is
       monitored  by  <b>select</b>() in the main program.  (To avoid possibly blocking when writing to a pipe that may
       be full or reading from a pipe that may be empty, nonblocking I/O is used when reading from  and  writing
       to the pipe.)

   <b>Emulating</b> <b><a href="../man3/usleep.3.html">usleep</a>(3)</b>
       Before  the  advent  of  <b><a href="../man3/usleep.3.html">usleep</a></b>(3), some code employed a call to <b>select</b>() with all three sets empty, <u>nfds</u>
       zero, and a non-NULL <u>timeout</u> as a fairly portable way to sleep with subsecond precision.

   <b>Correspondence</b> <b>between</b> <b>select()</b> <b>and</b> <b>poll()</b> <b>notifications</b>
       Within the Linux kernel source, we find the following definitions which show the  correspondence  between
       the  readable,  writable, and exceptional condition notifications of <b>select</b>() and the event notifications
       provided by <b><a href="../man2/poll.2.html">poll</a></b>(2) and <b><a href="../man7/epoll.7.html">epoll</a></b>(7):

           #define POLLIN_SET  (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN |
                                EPOLLHUP | EPOLLERR)
                              /* Ready for reading */
           #define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT |
                                EPOLLERR)
                              /* Ready for writing */
           #define POLLEX_SET  (EPOLLPRI)
                              /* Exceptional condition */

   <b>Multithreaded</b> <b>applications</b>
       If a file descriptor being monitored by <b>select</b>() is closed in another thread, the result is  unspecified.
       On some UNIX systems, <b>select</b>() unblocks and returns, with an indication that the file descriptor is ready
       (a  subsequent  I/O  operation  will  likely  fail with an error, unless another process reopens the file
       descriptor between the time <b>select</b>() returned and the I/O operation is performed).  On  Linux  (and  some
       other systems), closing the file descriptor in another thread has no effect on <b>select</b>().  In summary, any
       application that relies on a particular behavior in this scenario must be considered buggy.

   <b>C</b> <b>library/kernel</b> <b>differences</b>
       The  Linux kernel allows file descriptor sets of arbitrary size, determining the length of the sets to be
       checked from the value of <u>nfds</u>.  However, in the glibc implementation, the <u>fd_set</u> type is fixed in  size.
       See also BUGS.

       The <b>pselect</b>() interface described in this page is implemented by glibc.  The underlying Linux system call
       is named <b>pselect6</b>().  This system call has somewhat different behavior from the glibc wrapper function.

       The  Linux  <b>pselect6</b>()  system  call  modifies its <u>timeout</u> argument.  However, the glibc wrapper function
       hides this behavior by using a local variable for the timeout argument that is passed to the system call.
       Thus, the glibc <b>pselect</b>() function does not modify its <u>timeout</u> argument; this is the behavior required by
       POSIX.1-2001.

       The final argument of the <b>pselect6</b>() system call is not a <u>sigset_t</u> <u>*</u> pointer, but is instead a  structure
       of the form:

           struct {
               const kernel_sigset_t *ss;   /* Pointer to signal set */
               size_t ss_len;               /* Size (in bytes) of object
                                               pointed to by 'ss' */
           };

       This  allows  the system call to obtain both a pointer to the signal set and its size, while allowing for
       the fact that most architectures support a maximum of 6 arguments to a system call.   See  <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2)
       for a discussion of the difference between the kernel and libc notion of the signal set.

   <b>Historical</b> <b>glibc</b> <b>details</b>
       glibc 2.0 provided an incorrect version of <b>pselect</b>() that did not take a <u>sigmask</u> argument.

       From  glibc  2.1  to  glibc  2.2.1,  one  must  define  <b>_GNU_SOURCE</b> in order to obtain the declaration of
       <b>pselect</b>() from <u>&lt;sys/select.h&gt;</u>.

</pre><h4><b>BUGS</b></h4><pre>
       POSIX allows an implementation to define an upper limit, advertised via the constant <b>FD_SETSIZE</b>,  on  the
       range  of  file  descriptors that can be specified in a file descriptor set.  The Linux kernel imposes no
       fixed limit, but the glibc implementation makes <u>fd_set</u> a fixed-size  type,  with  <b>FD_SETSIZE</b>  defined  as
       1024,  and the <b>FD_*</b>() macros operating according to that limit.  To monitor file descriptors greater than
       1023, use <b><a href="../man2/poll.2.html">poll</a></b>(2) or <b><a href="../man7/epoll.7.html">epoll</a></b>(7) instead.

       The implementation of the <u>fd_set</u> arguments as value-result arguments is a design error that is avoided in
       <b><a href="../man2/poll.2.html">poll</a></b>(2) and <b><a href="../man7/epoll.7.html">epoll</a></b>(7).

       According to POSIX, <b>select</b>() should check all specified file descriptors in  the  three  file  descriptor
       sets,  up  to the limit <u>nfds-1</u>.  However, the current implementation ignores any file descriptor in these
       sets that is greater than the maximum file  descriptor  number  that  the  process  currently  has  open.
       According  to  POSIX,  any such file descriptor that is specified in one of the sets should result in the
       error <b>EBADF</b>.

       Starting  with  glibc  2.1,  glibc  provided  an  emulation  of  <b>pselect</b>()  that  was  implemented  using
       <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2)  and  <b>select</b>().   This  implementation remained vulnerable to the very race condition that
       <b>pselect</b>() was designed to prevent.  Modern versions of glibc use the (race-free) <b>pselect</b>() system call on
       kernels where it is provided.

       On Linux, <b>select</b>() may report a socket file descriptor as  "ready  for  reading",  while  nevertheless  a
       subsequent read blocks.  This could for example happen when data has arrived but upon examination has the
       wrong  checksum  and  is  discarded.   There  may  be  other  circumstances in which a file descriptor is
       spuriously reported as ready.  Thus it may be safer to use <b>O_NONBLOCK</b> on sockets that should not block.

       On Linux, <b>select</b>() also modifies <u>timeout</u> if the call is interrupted by a signal handler (i.e., the  <b>EINTR</b>
       error return).  This is not permitted by POSIX.1.  The Linux <b>pselect</b>() system call has the same behavior,
       but  the  glibc  wrapper  hides  this  behavior by internally copying the <u>timeout</u> to a local variable and
       passing that variable to the system call.

</pre><h4><b>EXAMPLES</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/select.h&gt;

       int
       main(void)
       {
           int             retval;
           fd_set          rfds;
           struct timeval  tv;

           /* Watch stdin (fd 0) to see when it has input. */

           FD_ZERO(&amp;rfds);
           FD_SET(0, &amp;rfds);

           /* Wait up to five seconds. */

           tv.tv_sec = 5;
           tv.tv_usec = 0;

           retval = select(1, &amp;rfds, NULL, NULL, &amp;tv);
           /* Don't rely on the value of tv now! */

           if (retval == -1)
               perror("select()");
           else if (retval)
               printf("Data is available now.\n");
               /* FD_ISSET(0, &amp;rfds) will be true. */
           else
               printf("No data within five seconds.\n");

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/accept.2.html">accept</a></b>(2), <b><a href="../man2/connect.2.html">connect</a></b>(2), <b><a href="../man2/poll.2.html">poll</a></b>(2), <b><a href="../man2/read.2.html">read</a></b>(2), <b><a href="../man2/recv.2.html">recv</a></b>(2), <b><a href="../man2/restart_syscall.2.html">restart_syscall</a></b>(2), <b><a href="../man2/send.2.html">send</a></b>(2), <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2),  <b><a href="../man2/write.2.html">write</a></b>(2),
       <b><a href="../man3/timespec.3.html">timespec</a></b>(3), <b><a href="../man7/epoll.7.html">epoll</a></b>(7), <b><a href="../man7/time.7.html">time</a></b>(7)

       For a tutorial with discussion and examples, see <b><a href="../man2/select_tut.2.html">select_tut</a></b>(2).

Linux man-pages 6.9.1                              2024-06-15                                          <u><a href="../man2/select.2.html">select</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>