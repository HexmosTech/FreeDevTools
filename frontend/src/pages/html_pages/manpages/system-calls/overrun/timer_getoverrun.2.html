<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>timer_getoverrun - get overrun count for a POSIX per-process timer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       timer_getoverrun - get overrun count for a POSIX per-process timer

</pre><h4><b>LIBRARY</b></h4><pre>
       Real-time library (<u>librt</u>, <u>-lrt</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/time.h">time.h</a>&gt;</b>

       <b>int</b> <b>timer_getoverrun(timer_t</b> <u>timerid</u><b>);</b>

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>timer_getoverrun</b>():
           _POSIX_C_SOURCE &gt;= 199309L

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>timer_getoverrun</b>()  returns the "overrun count" for the timer referred to by <u>timerid</u>.  An application can
       use the overrun count to accurately calculate the number of timer expirations that  would  have  occurred
       over  a  given  time interval.  Timer overruns can occur both when receiving expiration notifications via
       signals (<b>SIGEV_SIGNAL</b>), and via threads (<b>SIGEV_THREAD</b>).

       When expiration notifications are delivered via a signal, overruns can occur as follows.   Regardless  of
       whether  or  not a real-time signal is used for timer notifications, the system queues at most one signal
       per timer.  (This is the behavior specified by POSIX.1.  The alternative, queuing  one  signal  for  each
       timer  expiration,  could  easily  result  in  overflowing  the  allowed limits for queued signals on the
       system.)  Because of system scheduling delays, or because the signal may be  temporarily  blocked,  there
       can  be  a  delay  between  the  time  when  the notification signal is generated and the time when it is
       delivered (e.g., caught by a signal handler) or accepted (e.g., using <b><a href="../man2/sigwaitinfo.2.html">sigwaitinfo</a></b>(2)).  In this interval,
       further timer expirations may occur.   The  timer  overrun  count  is  the  number  of  additional  timer
       expirations  that  occurred  between  the time when the signal was generated and when it was delivered or
       accepted.

       Timer overruns can also occur when expiration notifications are delivered via  invocation  of  a  thread,
       since  there  may  be  an  arbitrary  delay  between an expiration of the timer and the invocation of the
       notification thread, and in that delay interval, additional timer expirations may occur.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>timer_getoverrun</b>() returns the overrun count of the specified timer; this count may be  0  if
       no overruns have occurred.  On failure, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EINVAL</b> <u>timerid</u> is not a valid timer ID.

</pre><h4><b>VERSIONS</b></h4><pre>
       When timer notifications are delivered via signals (<b>SIGEV_SIGNAL</b>), on Linux it is also possible to obtain
       the overrun count via the <u>si_overrun</u> field of the <u>siginfo_t</u> structure (see <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2)).  This allows an
       application  to  avoid  the  overhead  of  making  a  system  call  to obtain the overrun count, but is a
       nonportable extension to POSIX.1.

       POSIX.1 discusses timer overruns only in the context of timer notifications using signals.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.  POSIX.1-2001.

</pre><h4><b>BUGS</b></h4><pre>
       POSIX.1 specifies that if the timer overrun count is equal to or greater than  an  implementation-defined
       maximum,  <b>DELAYTIMER_MAX</b>,  then  <b>timer_getoverrun</b>()  should return <b>DELAYTIMER_MAX</b>.  However, before Linux
       4.19, if the timer overrun value exceeds the maximum representable integer, the counter cycles,  starting
       once  more  from  low  values.   Since  Linux 4.19, <b>timer_getoverrun</b>() returns <b>DELAYTIMER_MAX</b> (defined as
       <b>INT_MAX</b> in <u>&lt;limits.h&gt;</u>) in this case (and the overrun value is reset to 0).

</pre><h4><b>EXAMPLES</b></h4><pre>
       See <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2),   <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2),   <b><a href="../man2/signalfd.2.html">signalfd</a></b>(2),   <b><a href="../man2/sigwaitinfo.2.html">sigwaitinfo</a></b>(2),   <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2),    <b><a href="../man2/timer_delete.2.html">timer_delete</a></b>(2),
       <b><a href="../man2/timer_settime.2.html">timer_settime</a></b>(2), <b><a href="../man7/signal.7.html">signal</a></b>(7), <b><a href="../man7/time.7.html">time</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                <u><a href="../man2/timer_getoverrun.2.html">timer_getoverrun</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>