<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ioctl_kd - ioctls for console terminal and virtual consoles</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ioctl_kd - ioctls for console terminal and virtual consoles

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/linux/kd.h">linux/kd.h</a>&gt;</b>  /* Definition of op constants */
       <b>#include</b> <b>&lt;sys/ioctl.h&gt;</b>

       <b>int</b> <b>ioctl(int</b> <u>fd</u><b>,</b> <b>unsigned</b> <b>long</b> <u>op</u><b>,</b> <b>void</b> <b>*</b><u>argp</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  following  Linux-specific  <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)  operations  are  supported  for  console  terminals and virtual
       consoles.

       <b>KDGETLED</b>
              Get state of LEDs.  <u>argp</u> points to a <u>char</u>.  The lower three bits of <u>*argp</u> are set to the state  of
              the LEDs, as follows:
              LED_CAP    0x04   caps lock led
              LED_NUM    0x02   num lock led
              LED_SCR    0x01   scroll lock led

       <b>KDSETLED</b>
              Set the LEDs.  The LEDs are set to correspond to the lower three bits of the unsigned long integer
              in  <u>argp</u>.   However, if a higher order bit is set, the LEDs revert to normal: displaying the state
              of the keyboard functions of caps lock, num lock, and scroll lock.

       Before Linux 1.1.54, the LEDs  just  reflected  the  state  of  the  corresponding  keyboard  flags,  and
       KDGETLED/KDSETLED  would  also  change  the  keyboard  flags.  Since Linux 1.1.54 the LEDs can be made to
       display arbitrary information, but by default they display the keyboard flags.  The following two  ioctls
       are used to access the keyboard flags.

       <b>KDGKBLED</b>
              Get keyboard flags CapsLock, NumLock, ScrollLock (not lights).  <u>argp</u> points to a char which is set
              to  the  flag  state.  The low order three bits (mask 0x7) get the current flag state, and the low
              order bits of the next nibble (mask 0x70) get the default flag state.  (Since Linux 1.1.54.)

       <b>KDSKBLED</b>
              Set keyboard flags CapsLock, NumLock, ScrollLock (not lights).  <u>argp</u> is an unsigned  long  integer
              that has the desired flag state.  The low order three bits (mask 0x7) have the flag state, and the
              low order bits of the next nibble (mask 0x70) have the default flag state.  (Since Linux 1.1.54.)

       <b>KDGKBTYPE</b>
              Get keyboard type.  This returns the value KB_101, defined as 0x02.

       <b>KDADDIO</b>
              Add I/O port as valid.  Equivalent to <u>ioperm(arg,1,1)</u>.

       <b>KDDELIO</b>
              Delete I/O port as valid.  Equivalent to <u>ioperm(arg,1,0)</u>.

       <b>KDENABIO</b>
              Enable I/O to video board.  Equivalent to <u>ioperm(0x3b4,</u> <u>0x3df-0x3b4+1,</u> <u>1)</u>.

       <b>KDDISABIO</b>
              Disable I/O to video board.  Equivalent to <u>ioperm(0x3b4,</u> <u>0x3df-0x3b4+1,</u> <u>0)</u>.

       <b>KDSETMODE</b>
              Set text/graphics mode.  <u>argp</u> is an unsigned integer containing one of:
              KD_TEXT       0x00
              KD_GRAPHICS   0x01

       <b>KDGETMODE</b>
              Get  text/graphics  mode.  <u>argp</u> points to an <u>int</u> which is set to one of the values shown above for
              <b>KDSETMODE</b>.

       <b>KDMKTONE</b>
              Generate tone of specified length.  The lower 16 bits of the unsigned long integer in <u>argp</u> specify
              the period in clock cycles, and the upper 16 bits give the duration in msec.  If the  duration  is
              zero,  the  sound  is  turned  off.  Control returns immediately.  For example, <u>argp</u> = (125&lt;&lt;16) +
              0x637 would specify the beep normally associated with a ctrl-G.  (Thus since Linux 0.99pl1; broken
              in Linux 2.1.49-50.)

       <b>KIOCSOUND</b>
              Start or stop sound generation.  The lower 16 bits of <u>argp</u> specify  the  period  in  clock  cycles
              (that  is,  <u>argp</u> = 1193180/frequency).  <u>argp</u> = 0 turns sound off.  In either case, control returns
              immediately.

       <b>GIO_CMAP</b>
              Get the current default color map from kernel.  <u>argp</u> points to  a  48-byte  array.   (Since  Linux
              1.3.3.)

       <b>PIO_CMAP</b>
              Change  the default text-mode color map.  <u>argp</u> points to a 48-byte array which contains, in order,
              the Red, Green, and Blue values for the 16 available screen colors: 0 is  off,  and  255  is  full
              intensity.   The default colors are, in order: black, dark red, dark green, brown, dark blue, dark
              purple, dark cyan, light grey, dark grey, bright red, bright green, yellow,  bright  blue,  bright
              purple, bright cyan, and white.  (Since Linux 1.3.3.)

       <b>GIO_FONT</b>
              Gets  256-character  screen font in expanded form.  <u>argp</u> points to an 8192-byte array.  Fails with
              error code <b>EINVAL</b> if the currently loaded font is a 512-character font, or if the console  is  not
              in text mode.

       <b>GIO_FONTX</b>
              Gets  screen  font  and  associated  information.   <u>argp</u>  points  to a <u>struct</u> <u>consolefontdesc</u> (see
              <b>PIO_FONTX</b>).  On call, the <u>charcount</u> field should be set to the maximum number of  characters  that
              would  fit  in  the  buffer  pointed  to by <u>chardata</u>.  On return, the <u>charcount</u> and <u>charheight</u> are
              filled with the respective data for the currently loaded font, and the <u>chardata</u> array contains the
              font data if the initial value of <u>charcount</u> indicated enough space was  available;  otherwise  the
              buffer is untouched and <u>errno</u> is set to <b>ENOMEM</b>.  (Since Linux 1.3.1.)

       <b>PIO_FONT</b>
              Sets  256-character  screen font.  Load font into the EGA/VGA character generator.  <u>argp</u> points to
              an 8192-byte map, with 32 bytes per character.  Only the first <u>N</u> of them are used for an 8x<u>N</u>  font
              (0 &lt; <u>N</u> &lt;= 32).  This call also invalidates the Unicode mapping.

       <b>PIO_FONTX</b>
              Sets screen font and associated rendering information.  <u>argp</u> points to a

                  struct consolefontdesc {
                      unsigned short charcount;  /* characters in font
                                                    (256 or 512) */
                      unsigned short charheight; /* scan lines per
                                                    character (1-32) */
                      char          *chardata;   /* font data in
                                                    expanded form */
                  };

              If  necessary,  the  screen  will  be  appropriately resized, and <b>SIGWINCH</b> sent to the appropriate
              processes.  This call also invalidates the Unicode mapping.  (Since Linux 1.3.1.)

       <b>PIO_FONTRESET</b>
              Resets the screen font, size, and Unicode mapping to the bootup defaults.   <u>argp</u>  is  unused,  but
              should  be  set  to  NULL  to  ensure  compatibility  with future versions of Linux.  (Since Linux
              1.3.28.)

       <b>GIO_SCRNMAP</b>
              Get screen mapping from kernel.  <u>argp</u> points to an area of size E_TABSZ, which is loaded with  the
              font  positions used to display each character.  This call is likely to return useless information
              if the currently loaded font is more than 256 characters.

       <b>GIO_UNISCRNMAP</b>
              Get  full  Unicode  screen  mapping   from   kernel.    <u>argp</u>   points   to   an   area   of   size
              <u>E_TABSZ*sizeof(unsigned</u>  <u>short)</u>,  which  is  loaded with the Unicodes each character represent.  A
              special set of Unicodes, starting at U+F000, are used to  represent  "direct  to  font"  mappings.
              (Since Linux 1.3.1.)

       <b>PIO_SCRNMAP</b>
              Loads  the  "user  definable"  (fourth)  table  in the kernel which maps bytes into console screen
              symbols.  <u>argp</u> points to an area of size E_TABSZ.

       <b>PIO_UNISCRNMAP</b>
              Loads the "user definable" (fourth) table in the kernel which maps bytes into Unicodes, which  are
              then  translated  into  screen  symbols  according  to  the  currently loaded Unicode-to-font map.
              Special Unicodes starting at U+F000 can be used to map directly to the font symbols.  (Since Linux
              1.3.1.)

       <b>GIO_UNIMAP</b>
              Get Unicode-to-font mapping from kernel.  <u>argp</u> points to a

                  struct unimapdesc {
                      unsigned short  entry_ct;
                      struct unipair *entries;
                  };

              where <u>entries</u> points to an array of

                  struct unipair {
                      unsigned short unicode;
                      unsigned short fontpos;
                  };

              (Since Linux 1.1.92.)

       <b>PIO_UNIMAP</b>
              Put unicode-to-font mapping in kernel.  <u>argp</u> points to a <u>struct</u> <u>unimapdesc</u>.  (Since Linux 1.1.92)

       <b>PIO_UNIMAPCLR</b>
              Clear table, possibly advise hash algorithm.  <u>argp</u> points to a

                  struct unimapinit {
                      unsigned short advised_hashsize;  /* 0 if no opinion */
                      unsigned short advised_hashstep;  /* 0 if no opinion */
                      unsigned short advised_hashlevel; /* 0 if no opinion */
                  };

              (Since Linux 1.1.92.)

       <b>KDGKBMODE</b>
              Gets current keyboard mode.  <u>argp</u> points to a <u>long</u> which is set to one of these:
              K_RAW         0x00  /* Raw (scancode) mode */
              K_XLATE       0x01  /* Translate keycodes using keymap */
              K_MEDIUMRAW   0x02  /* Medium raw (scancode) mode */
              K_UNICODE     0x03  /* Unicode mode */
              K_OFF         0x04  /* Disabled mode; since Linux 2.6.39 */

       <b>KDSKBMODE</b>
              Sets current keyboard mode.  <u>argp</u> is a <u>long</u> equal to one of the values shown for <b>KDGKBMODE</b>.

       <b>KDGKBMETA</b>
              Gets meta key handling mode.  <u>argp</u> points to a <u>long</u> which is set to one of these:
              K_METABIT     0x03   set high order bit
              K_ESCPREFIX   0x04   escape prefix

       <b>KDSKBMETA</b>
              Sets meta key handling mode.  <u>argp</u> is a <u>long</u> equal to one of the values shown above for <b>KDGKBMETA</b>.

       <b>KDGKBENT</b>
              Gets one entry in key translation table (keycode to action code).  <u>argp</u> points to a

                  struct kbentry {
                      unsigned char  kb_table;
                      unsigned char  kb_index;
                      unsigned short kb_value;
                  };

              with the first  two  members  filled  in:  <u>kb_table</u>  selects  the  key  table  (0  &lt;=  <u>kb_table</u>  &lt;
              MAX_NR_KEYMAPS),  and  <u>kb_index</u>  is the keycode (0 &lt;= <u>kb_index</u> &lt; NR_KEYS).  <u>kb_value</u> is set to the
              corresponding action code, or K_HOLE if there is no  such  key,  or  K_NOSUCHMAP  if  <u>kb_table</u>  is
              invalid.

       <b>KDSKBENT</b>
              Sets one entry in translation table.  <u>argp</u> points to a <u>struct</u> <u>kbentry</u>.

       <b>KDGKBSENT</b>
              Gets one function key string.  <u>argp</u> points to a

                  struct kbsentry {
                      unsigned char kb_func;
                      unsigned char kb_string[512];
                  };

              <u>kb_string</u>  is  set  to  the  (null-terminated)  string corresponding to the <u>kb_func</u>th function key
              action code.

       <b>KDSKBSENT</b>
              Sets one function key string entry.  <u>argp</u> points to a <u>struct</u> <u>kbsentry</u>.

       <b>KDGKBDIACR</b>
              Read kernel accent table.  <u>argp</u> points to a

                  struct kbdiacrs {
                      unsigned int   kb_cnt;
                      struct kbdiacr kbdiacr[256];
                  };

              where <u>kb_cnt</u> is the number of entries in the array, each of which is a

                  struct kbdiacr {
                      unsigned char diacr;
                      unsigned char base;
                      unsigned char result;
                  };

       <b>KDGETKEYCODE</b>
              Read kernel keycode table entry (scan code to keycode).  <u>argp</u> points to a

                  struct kbkeycode {
                      unsigned int scancode;
                      unsigned int keycode;
                  };

              <u>keycode</u> is set to correspond to the given <u>scancode</u>.  (89 &lt;=  <u>scancode</u>  &lt;=  255  only.   For  1  &lt;=
              <u>scancode</u> &lt;= 88, <u>keycode</u>==<u>scancode</u>.)  (Since Linux 1.1.63.)

       <b>KDSETKEYCODE</b>
              Write kernel keycode table entry.  <u>argp</u> points to a <u>struct</u> <u>kbkeycode</u>.  (Since Linux 1.1.63.)

       <b>KDSIGACCEPT</b>
              The  calling  process  indicates its willingness to accept the signal <u>argp</u> when it is generated by
              pressing an  appropriate  key  combination.   (1  &lt;=  <u>argp</u>  &lt;=  NSIG).   (See  <u>spawn_console</u>()  in
              <u>linux/drivers/char/keyboard.c</u>.)

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  0  is  returned  (except where indicated).  On failure, -1 is returned, and <u>errno</u> is set to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EINVAL</b> <u>argp</u> is invalid.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2), <b><a href="../man2/ioctl_console.2.html">ioctl_console</a></b>(2)

Linux man-pages 6.9.1                              2024-06-13                                        <u><a href="../man2/ioctl_kd.2.html">ioctl_kd</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>