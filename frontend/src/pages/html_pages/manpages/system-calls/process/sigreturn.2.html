<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sigreturn, rt_sigreturn - return from signal handler and cleanup stack frame</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sigreturn, rt_sigreturn - return from signal handler and cleanup stack frame

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>int</b> <b>sigreturn(...);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       If  the  Linux  kernel  determines  that  an unblocked signal is pending for a process, then, at the next
       transition back to user mode in that process (e.g., upon return from a system call or when the process is
       rescheduled onto the CPU), it creates a new frame on the user-space stack where it saves  various  pieces
       of process context (processor status word, registers, signal mask, and signal stack settings).

       The kernel also arranges that, during the transition back to user mode, the signal handler is called, and
       that,  upon  return  from  the  handler, control passes to a piece of user-space code commonly called the
       "signal trampoline".  The signal trampoline code in turn calls <b>sigreturn</b>().

       This <b>sigreturn</b>() call undoes everything that was  done—changing  the  process's  signal  mask,  switching
       signal stacks (see <b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2))—in order to invoke the signal handler.  Using the information that was
       earlier  saved  on  the user-space stack <b>sigreturn</b>() restores the process's signal mask, switches stacks,
       and restores the process's context (processor flags  and  registers,  including  the  stack  pointer  and
       instruction  pointer), so that the process resumes execution at the point where it was interrupted by the
       signal.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>sigreturn</b>() never returns.

</pre><h4><b>VERSIONS</b></h4><pre>
       Many UNIX-type systems have a <b>sigreturn</b>() system call or near equivalent.   However,  this  call  is  not
       specified in POSIX, and details of its behavior vary across systems.

</pre><h4><b>STANDARDS</b></h4><pre>
       None.

</pre><h4><b>NOTES</b></h4><pre>
       <b>sigreturn</b>()  exists  only  to  allow  the  implementation  of signal handlers.  It should <b>never</b> be called
       directly.  (Indeed, a simple <b>sigreturn</b>() wrapper in the GNU C library simply returns -1, with  <u>errno</u>  set
       to  <b>ENOSYS</b>.)  Details of the arguments (if any) passed to <b>sigreturn</b>() vary depending on the architecture.
       (On some architectures, such as x86-64, <b>sigreturn</b>() takes no arguments, since all of the information that
       it requires is available in the stack frame that was previously created by the kernel on  the  user-space
       stack.)

       Once upon a time, UNIX systems placed the signal trampoline code onto the user stack.  Nowadays, pages of
       the  user  stack  are  protected  so as to disallow code execution.  Thus, on contemporary Linux systems,
       depending on the architecture, the signal trampoline code lives  either  in  the  <b><a href="../man7/vdso.7.html">vdso</a></b>(7)  or  in  the  C
       library.   In  the  latter  case, the C library's <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2) wrapper function informs the kernel of the
       location of the trampoline code by placing  its  address  in  the  <u>sa_restorer</u>  field  of  the  <u>sigaction</u>
       structure, and sets the <b>SA_RESTORER</b> flag in the <u>sa_flags</u> field.

       The  saved  process context information is placed in a <u>ucontext_t</u> structure (see <u>&lt;sys/ucontext.h&gt;</u>).  That
       structure is visible within the signal handler as  the  third  argument  of  a  handler  established  via
       <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2) with the <b>SA_SIGINFO</b> flag.

       On  some  other UNIX systems, the operation of the signal trampoline differs a little.  In particular, on
       some systems, upon transitioning back to user mode, the kernel passes control to the  trampoline  (rather
       than  the  signal  handler), and the trampoline code calls the signal handler (and then calls <b>sigreturn</b>()
       once the handler returns).

   <b>C</b> <b>library/kernel</b> <b>differences</b>
       The original Linux system call was named <b>sigreturn</b>().  However, with the addition of real-time signals in
       Linux 2.2, a new system call, <b>rt_sigreturn</b>() was added to support an enlarged <u>sigset_t</u> type.  The  GNU  C
       library hides these details from us, transparently employing <b>rt_sigreturn</b>() when the kernel provides it.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/kill.2.html">kill</a></b>(2), <b><a href="../man2/restart_syscall.2.html">restart_syscall</a></b>(2), <b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2), <b><a href="../man2/signal.2.html">signal</a></b>(2), <b><a href="../man3/getcontext.3.html">getcontext</a></b>(3), <b><a href="../man7/signal.7.html">signal</a></b>(7), <b><a href="../man7/vdso.7.html">vdso</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                       <u><a href="../man2/sigreturn.2.html">sigreturn</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>