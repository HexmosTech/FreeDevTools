<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rfork — manipulate process resources</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rfork — manipulate process resources

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <u>pid_t</u>
       <b>rfork</b>(<u>int</u> <u>flags</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Forking, vforking or rforking are the only ways new processes are created.  The <u>flags</u> argument to <b>rfork</b>()
       selects  which  resources  of  the  invoking  process  (parent)  are shared by the new process (child) or
       initialized to their default values.  The resources include the open file descriptor table  (which,  when
       shared,  permits  processes  to  open  and  close  files for other processes), and open files.  The <u>flags</u>
       argument is either RFSPAWN or the logical OR of some subset of:

       RFPROC       If set a new process is created; otherwise changes affect the current process.

       RFNOWAIT     If set, the child process will be dissociated from the parent.  Upon exit the child will not
                    leave a status for the parent to collect.  See <u><a href="../man2/wait.2.html">wait</a></u>(2).

       RFFDG        If set, the invoker's file descriptor table (see <u><a href="../man2/intro.2.html">intro</a></u>(2))  is  copied;  otherwise  the  two
                    processes share a single table.

       RFCFDG       If  set,  the  new process starts with a clean file descriptor table.  Is mutually exclusive
                    with RFFDG.

       RFTHREAD     If set, the new process shares file descriptor to process leaders  table  with  its  parent.
                    Only applies when neither RFFDG nor RFCFDG are set.

       RFMEM        If  set, the kernel will force sharing of the entire address space, typically by sharing the
                    hardware page table directly.  The child will thus inherit and share all  the  segments  the
                    parent  process  owns, whether they are normally shareable or not.  The stack segment is not
                    split (both the parent and child return on the same stack) and thus <b>rfork</b>() with  the  RFMEM
                    flag may not generally be called directly from high level languages including C.  May be set
                    only  with RFPROC.  A helper function is provided to assist with this problem and will cause
                    the new process to run on the provided stack.  See <u><a href="../man3/rfork_thread.3.html">rfork_thread</a></u>(3)  for  information.   Note
                    that a lot of code will not run correctly in such an environment.

       RFSIGSHARE   If  set,  the  kernel  will  force  sharing  the sigacts structure between the child and the
                    parent.

       RFTSIGZMB    If set, the kernel will deliver a specified signal  to  the  parent  upon  the  child  exit,
                    instead   of  default  SIGCHLD.   The  signal  number  signum  is  specified  by  oring  the
                    RFTSIGFLAGS(signum) expression into <u>flags</u>.   Specifying  signal  number  0  disables  signal
                    delivery upon the child exit.

       RFLINUXTHPN  If  set,  the kernel will deliver SIGUSR1 instead of SIGCHLD upon thread exit for the child.
                    This is intended to mimic certain Linux clone behaviour.

       File descriptors in a shared file descriptor table are kept open until either they are explicitly  closed
       or all processes sharing the table exit.

       If  RFSPAWN  is  passed,  <b>rfork</b>  will use <u><a href="../man2/vfork.2.html">vfork</a></u>(2) semantics but reset all signal actions in the child to
       default.  This flag is used by the <u><a href="../man3/posix_spawn.3.html">posix_spawn</a></u>(3) implementation in libc.

       If RFPROC is set, the value returned in the parent process is the process id of the  child  process;  the
       value  returned in the child is zero.  Without RFPROC, the return value is zero.  Process id's range from
       1 to the maximum integer (<u>int</u>) value.  The <b>rfork</b>() system call will sleep, if necessary,  until  required
       process resources are available.

       The  <b>fork</b>()  system  call  can be implemented as a call to <b>rfork</b>(<u>RFFDG</u> <u>|</u> <u>RFPROC</u>) but is not for backwards
       compatibility.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Upon successful completion, <b>rfork</b>() returns a value of 0 to the child process and returns the process  ID
       of  the child process to the parent process.  Otherwise, a value of -1 is returned to the parent process,
       no child process is created, and the global variable <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <b>rfork</b>() system call will fail and no child process will be created if:

       [EAGAIN]           The system-imposed limit on the total number of processes  under  execution  would  be
                          exceeded.   The limit is given by the <u><a href="../man3/sysctl.3.html">sysctl</a></u>(3) MIB variable KERN_MAXPROC.  (The limit
                          is actually ten less than this except for the super user).

       [EAGAIN]           The user is not the super user, and the system-imposed limit on the  total  number  of
                          processes  under  execution by a single user would be exceeded.  The limit is given by
                          the <u><a href="../man3/sysctl.3.html">sysctl</a></u>(3) MIB variable KERN_MAXPROCPERUID.

       [EAGAIN]           The user is not the super user, and the  soft  resource  limit  corresponding  to  the
                          <u>resource</u> argument RLIMIT_NOFILE would be exceeded (see <u><a href="../man2/getrlimit.2.html">getrlimit</a></u>(2)).

       [EINVAL]           Both the RFFDG and the RFCFDG flags were specified.

       [EINVAL]           Any flags not listed above were specified.

       [EINVAL]           An invalid signal number was specified.

       [ENOMEM]           There is insufficient swap space for the new process.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/fork.2.html">fork</a></u>(2), <u><a href="../man2/intro.2.html">intro</a></u>(2), <u><a href="../man2/minherit.2.html">minherit</a></u>(2), <u><a href="../man2/vfork.2.html">vfork</a></u>(2), <u><a href="../man3/pthread_create.3.html">pthread_create</a></u>(3), <u><a href="../man3/rfork_thread.3.html">rfork_thread</a></u>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>rfork</b>() function first appeared in Plan9.

Debian                                         September 25, 2019                                       <u><a href="../man2/RFORK.2.html">RFORK</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>