<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fork - create a child process</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fork - create a child process

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>pid_t</b> <b>fork(void);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>fork</b>()  creates  a new process by duplicating the calling process.  The new process is referred to as the
       <u>child</u> process.  The calling process is referred to as the <u>parent</u> process.

       The child process and the parent process run in separate memory spaces.   At  the  time  of  <b>fork</b>()  both
       memory  spaces have the same content.  Memory writes, file mappings (<b><a href="../man2/mmap.2.html">mmap</a></b>(2)), and unmappings (<b><a href="../man2/munmap.2.html">munmap</a></b>(2))
       performed by one of the processes do not affect the other.

       The child process is an exact duplicate of the parent process except for the following points:

       •  The child has its own unique process ID, and this PID does not match the ID of  any  existing  process
          group (<b><a href="../man2/setpgid.2.html">setpgid</a></b>(2)) or session.

       •  The child's parent process ID is the same as the parent's process ID.

       •  The child does not inherit its parent's memory locks (<b><a href="../man2/mlock.2.html">mlock</a></b>(2), <b><a href="../man2/mlockall.2.html">mlockall</a></b>(2)).

       •  Process resource utilizations (<b><a href="../man2/getrusage.2.html">getrusage</a></b>(2)) and CPU time counters (<b><a href="../man2/times.2.html">times</a></b>(2)) are reset to zero in the
          child.

       •  The child's set of pending signals is initially empty (<b><a href="../man2/sigpending.2.html">sigpending</a></b>(2)).

       •  The child does not inherit semaphore adjustments from its parent (<b><a href="../man2/semop.2.html">semop</a></b>(2)).

       •  The  child does not inherit process-associated record locks from its parent (<b><a href="../man2/fcntl.2.html">fcntl</a></b>(2)).  (On the other
          hand, it does inherit <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) open file description locks and <b><a href="../man2/flock.2.html">flock</a></b>(2) locks from its parent.)

       •  The child does not inherit timers from its parent (<b><a href="../man2/setitimer.2.html">setitimer</a></b>(2), <b><a href="../man2/alarm.2.html">alarm</a></b>(2), <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2)).

       •  The child does not inherit outstanding asynchronous  I/O  operations  from  its  parent  (<b><a href="../man3/aio_read.3.html">aio_read</a></b>(3),
          <b><a href="../man3/aio_write.3.html">aio_write</a></b>(3)), nor does it inherit any asynchronous I/O contexts from its parent (see <b><a href="../man2/io_setup.2.html">io_setup</a></b>(2)).

       The  process  attributes  in  the preceding list are all specified in POSIX.1.  The parent and child also
       differ with respect to the following Linux-specific process attributes:

       •  The child does not  inherit  directory  change  notifications  (dnotify)  from  its  parent  (see  the
          description of <b>F_NOTIFY</b> in <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2)).

       •  The  <b><a href="../man2/prctl.2.html">prctl</a></b>(2)  <b>PR_SET_PDEATHSIG</b>  setting is reset so that the child does not receive a signal when its
          parent terminates.

       •  The default timer slack value is set to the parent's current timer slack value.  See  the  description
          of <b>PR_SET_TIMERSLACK</b> in <b><a href="../man2/prctl.2.html">prctl</a></b>(2).

       •  Memory  mappings that have been marked with the <b><a href="../man2/madvise.2.html">madvise</a></b>(2) <b>MADV_DONTFORK</b> flag are not inherited across
          a <b>fork</b>().

       •  Memory in address ranges that have been marked with the <b><a href="../man2/madvise.2.html">madvise</a></b>(2) <b>MADV_WIPEONFORK</b> flag is  zeroed  in
          the  child  after a <b>fork</b>().  (The <b>MADV_WIPEONFORK</b> setting remains in place for those address ranges in
          the child.)

       •  The termination signal of the child is always <b>SIGCHLD</b> (see <b><a href="../man2/clone.2.html">clone</a></b>(2)).

       •  The port access permission bits set by <b><a href="../man2/ioperm.2.html">ioperm</a></b>(2) are not inherited by the child; the child  must  turn
          on any bits that it requires using <b><a href="../man2/ioperm.2.html">ioperm</a></b>(2).

       Note the following further points:

       •  The  child  process  is  created  with a single thread—the one that called <b>fork</b>().  The entire virtual
          address space of the parent is replicated in the child, including the  states  of  mutexes,  condition
          variables,  and  other  pthreads objects; the use of <b><a href="../man3/pthread_atfork.3.html">pthread_atfork</a></b>(3) may be helpful for dealing with
          problems that this can cause.

       •  After a <b>fork</b>() in a multithreaded program, the child can safely call only async-signal-safe  functions
          (see <b><a href="../man7/signal-safety.7.html">signal-safety</a></b>(7)) until such time as it calls <b><a href="../man2/execve.2.html">execve</a></b>(2).

       •  The  child  inherits copies of the parent's set of open file descriptors.  Each file descriptor in the
          child refers to the same open file description (see <b><a href="../man2/open.2.html">open</a></b>(2)) as the corresponding file  descriptor  in
          the  parent.   This means that the two file descriptors share open file status flags, file offset, and
          signal-driven I/O attributes (see the description of <b>F_SETOWN</b> and <b>F_SETSIG</b> in <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2)).

       •  The child inherits copies of the parent's set of open message queue descriptors (see  <b><a href="../man7/mq_overview.7.html">mq_overview</a></b>(7)).
          Each  file  descriptor  in  the  child  refers  to  the  same  open  message  queue description as the
          corresponding file descriptor in the parent.  This means that the two file descriptors share the  same
          flags (<u>mq_flags</u>).

       •  The  child  inherits  copies  of the parent's set of open directory streams (see <b><a href="../man3/opendir.3.html">opendir</a></b>(3)).  POSIX.1
          says that the corresponding directory streams in the parent and child <u>may</u> share the  directory  stream
          positioning; on Linux/glibc they do not.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  the PID of the child process is returned in the parent, and 0 is returned in the child.  On
       failure, -1 is returned in the parent, no child process is created, and <u>errno</u>  is  set  to  indicate  the
       error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EAGAIN</b> A  system-imposed  limit  on  the number of threads was encountered.  There are a number of limits
              that may trigger this error:

              •  the <b>RLIMIT_NPROC</b> soft resource limit  (set  via  <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2)),  which  limits  the  number  of
                 processes and threads for a real user ID, was reached;

              •  the    kernel's    system-wide    limit    on    the   number   of   processes   and   threads,
                 <u><a href="file:/proc/sys/kernel/threads-max">/proc/sys/kernel/threads-max</a></u>, was reached (see <b><a href="../man5/proc.5.html">proc</a></b>(5));

              •  the maximum number of PIDs, <u><a href="file:/proc/sys/kernel/pid_max">/proc/sys/kernel/pid_max</a></u>, was reached (see <b><a href="../man5/proc.5.html">proc</a></b>(5)); or

              •  the PID limit (<u>pids.max</u>) imposed by the cgroup "process number" (PIDs) controller was reached.

       <b>EAGAIN</b> The caller is operating under the <b>SCHED_DEADLINE</b> scheduling policy and does not have the reset-on-
              fork flag set.  See <b><a href="../man7/sched.7.html">sched</a></b>(7).

       <b>ENOMEM</b> <b>fork</b>() failed to allocate the necessary kernel structures because memory is tight.

       <b>ENOMEM</b> An attempt was made to create a child  process  in  a  PID  namespace  whose  "init"  process  has
              terminated.  See <b><a href="../man7/pid_namespaces.7.html">pid_namespaces</a></b>(7).

       <b>ENOSYS</b> <b>fork</b>() is not supported on this platform (for example, hardware without a Memory-Management Unit).

       <b>ERESTARTNOINTR</b> (since Linux 2.6.17)
              System  call  was  interrupted by a signal and will be restarted.  (This can be seen only during a
              trace.)

</pre><h4><b>VERSIONS</b></h4><pre>
   <b>C</b> <b>library/kernel</b> <b>differences</b>
       Since glibc 2.3.3, rather than invoking the kernel's <b>fork</b>() system call, the glibc <b>fork</b>() wrapper that is
       provided as part of the NPTL threading implementation invokes <b><a href="../man2/clone.2.html">clone</a></b>(2) with flags that provide  the  same
       effect  as the traditional system call.  (A call to <b>fork</b>() is equivalent to a call to <b><a href="../man2/clone.2.html">clone</a></b>(2) specifying
       <u>flags</u> as just <b>SIGCHLD</b>.)  The glibc wrapper invokes any fork handlers that  have  been  established  using
       <b><a href="../man3/pthread_atfork.3.html">pthread_atfork</a></b>(3).

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001, SVr4, 4.3BSD.

</pre><h4><b>NOTES</b></h4><pre>
       Under  Linux,  <b>fork</b>() is implemented using copy-on-write pages, so the only penalty that it incurs is the
       time and memory required to duplicate the parent's page tables, and to create a unique task structure for
       the child.

</pre><h4><b>EXAMPLES</b></h4><pre>
       See <b><a href="../man2/pipe.2.html">pipe</a></b>(2) and <b><a href="../man2/wait.2.html">wait</a></b>(2) for more examples.

       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int
       main(void)
       {
           pid_t pid;

           if (signal(SIGCHLD, SIG_IGN) == SIG_ERR) {
               perror("signal");
               exit(EXIT_FAILURE);
           }
           pid = fork();
           switch (pid) {
           case -1:
               perror("fork");
               exit(EXIT_FAILURE);
           case 0:
               puts("Child exiting.");
               exit(EXIT_SUCCESS);
           default:
               printf("Child is PID %jd\n", (intmax_t) pid);
               puts("Parent exiting.");
               exit(EXIT_SUCCESS);
           }
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/execve.2.html">execve</a></b>(2), <b><a href="../man2/exit.2.html">exit</a></b>(2), <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2), <b><a href="../man2/unshare.2.html">unshare</a></b>(2), <b><a href="../man2/vfork.2.html">vfork</a></b>(2), <b><a href="../man2/wait.2.html">wait</a></b>(2), <b><a href="../man3/daemon.3.html">daemon</a></b>(3),  <b><a href="../man3/pthread_atfork.3.html">pthread_atfork</a></b>(3),
       <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/credentials.7.html">credentials</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                            <u><a href="../man2/fork.2.html">fork</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>