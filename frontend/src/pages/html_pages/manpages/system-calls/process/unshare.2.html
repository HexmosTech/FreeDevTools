<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unshare - disassociate parts of the process execution context</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unshare - disassociate parts of the process execution context

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;</b>

       <b>int</b> <b>unshare(int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>unshare</b>()  allows a process (or thread) to disassociate parts of its execution context that are currently
       being shared with other processes (or threads).  Part  of  the  execution  context,  such  as  the  mount
       namespace,  is  shared  implicitly  when  a new process is created using <b><a href="../man2/fork.2.html">fork</a></b>(2) or <b><a href="../man2/vfork.2.html">vfork</a></b>(2), while other
       parts, such as virtual memory, may be shared by explicit request when creating a process or thread  using
       <b><a href="../man2/clone.2.html">clone</a></b>(2).

       The  main use of <b>unshare</b>() is to allow a process to control its shared execution context without creating
       a new process.

       The <u>flags</u> argument is a bit mask that specifies which parts of the execution context should be  unshared.
       This argument is specified by ORing together zero or more of the following constants:

       <b>CLONE_FILES</b>
              Reverse  the  effect of the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_FILES</b> flag.  Unshare the file descriptor table, so that
              the calling process no longer shares its file descriptors with any other process.

       <b>CLONE_FS</b>
              Reverse the effect of the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_FS</b> flag.  Unshare  filesystem  attributes,  so  that  the
              calling  process no longer shares its root directory (<b><a href="../man2/chroot.2.html">chroot</a></b>(2)), current directory (<b><a href="../man2/chdir.2.html">chdir</a></b>(2)), or
              umask (<b><a href="../man2/umask.2.html">umask</a></b>(2)) attributes with any other process.

       <b>CLONE_NEWCGROUP</b> (since Linux 4.6)
              This flag has the same effect as the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_NEWCGROUP</b> flag.  Unshare the cgroup namespace.
              Use of <b>CLONE_NEWCGROUP</b> requires the <b>CAP_SYS_ADMIN</b> capability.

       <b>CLONE_NEWIPC</b> (since Linux 2.6.19)
              This flag has the same effect as the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_NEWIPC</b> flag.  Unshare the  IPC  namespace,  so
              that  the  calling  process  has  a private copy of the IPC namespace which is not shared with any
              other process.  Specifying  this  flag  automatically  implies  <b>CLONE_SYSVSEM</b>  as  well.   Use  of
              <b>CLONE_NEWIPC</b> requires the <b>CAP_SYS_ADMIN</b> capability.

       <b>CLONE_NEWNET</b> (since Linux 2.6.24)
              This  flag  has the same effect as the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_NEWNET</b> flag.  Unshare the network namespace,
              so that the calling process is moved into a new network namespace which is  not  shared  with  any
              previously existing process.  Use of <b>CLONE_NEWNET</b> requires the <b>CAP_SYS_ADMIN</b> capability.

       <b>CLONE_NEWNS</b>
              This  flag  has the same effect as the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_NEWNS</b> flag.  Unshare the mount namespace, so
              that the calling process has a private copy of its namespace which is not shared  with  any  other
              process.   Specifying  this  flag  automatically  implies  <b>CLONE_FS</b>  as  well.  Use of <b>CLONE_NEWNS</b>
              requires the <b>CAP_SYS_ADMIN</b> capability.  For further information, see <b><a href="../man7/mount_namespaces.7.html">mount_namespaces</a></b>(7).

       <b>CLONE_NEWPID</b> (since Linux 3.8)
              This flag has the same effect as the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_NEWPID</b> flag.  Unshare the  PID  namespace,  so
              that  the  calling  process  has a new PID namespace for its children which is not shared with any
              previously existing process.  The calling process is <u>not</u> moved into the new namespace.  The  first
              child  created  by  the  calling  process  will  have the process ID 1 and will assume the role of
              <b><a href="../man1/init.1.html">init</a></b>(1) in the new namespace.  <b>CLONE_NEWPID</b> automatically implies <b>CLONE_THREAD</b> as  well.   Use  of
              <b>CLONE_NEWPID</b>    requires   the   <b>CAP_SYS_ADMIN</b>   capability.    For   further   information,   see
              <b><a href="../man7/pid_namespaces.7.html">pid_namespaces</a></b>(7).

       <b>CLONE_NEWTIME</b> (since Linux 5.6)
              Unshare the time namespace, so that the calling process has a new time namespace for its  children
              which  is  not shared with any previously existing process.  The calling process is <u>not</u> moved into
              the new namespace.  Use of <b>CLONE_NEWTIME</b>  requires  the  <b>CAP_SYS_ADMIN</b>  capability.   For  further
              information, see <b><a href="../man7/time_namespaces.7.html">time_namespaces</a></b>(7).

       <b>CLONE_NEWUSER</b> (since Linux 3.8)
              This  flag has the same effect as the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_NEWUSER</b> flag.  Unshare the user namespace, so
              that the calling process is moved into  a  new  user  namespace  which  is  not  shared  with  any
              previously existing process.  As with the child process created by <b><a href="../man2/clone.2.html">clone</a></b>(2) with the <b>CLONE_NEWUSER</b>
              flag, the caller obtains a full set of capabilities in the new namespace.

              <b>CLONE_NEWUSER</b>  requires  that  the  calling  process  is  not  threaded;  specifying <b>CLONE_NEWUSER</b>
              automatically implies <b>CLONE_THREAD</b>.  Since Linux 3.9,  <b>CLONE_NEWUSER</b>  also  automatically  implies
              <b>CLONE_FS</b>.   <b>CLONE_NEWUSER</b> requires that the user ID and group ID of the calling process are mapped
              to user IDs and group IDs in the user namespace of the calling process at the time of the call.

              For further information on user namespaces, see <b><a href="../man7/user_namespaces.7.html">user_namespaces</a></b>(7).

       <b>CLONE_NEWUTS</b> (since Linux 2.6.19)
              This flag has the same effect as the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_NEWUTS</b> flag.  Unshare the UTS  IPC  namespace,
              so  that  the calling process has a private copy of the UTS namespace which is not shared with any
              other process.  Use of <b>CLONE_NEWUTS</b> requires the <b>CAP_SYS_ADMIN</b> capability.

       <b>CLONE_SYSVSEM</b> (since Linux 2.6.26)
              This flag reverses the effect of the <b><a href="../man2/clone.2.html">clone</a></b>(2)  <b>CLONE_SYSVSEM</b>  flag.   Unshare  System V  semaphore
              adjustment  (<u>semadj</u>)  values,  so that the calling process has a new empty <u>semadj</u> list that is not
              shared with any other process.  If this is the last process that has a reference to the  process's
              current  <u>semadj</u>  list,  then  the  adjustments  in  that  list  are  applied  to the corresponding
              semaphores, as described in <b><a href="../man2/semop.2.html">semop</a></b>(2).

       In addition, <b>CLONE_THREAD</b>, <b>CLONE_SIGHAND</b>, and <b>CLONE_VM</b> can be specified in <u>flags</u> if the caller is  single
       threaded (i.e., it is not sharing its address space with another process or thread).  In this case, these
       flags  have  no  effect.   (Note  also  that  specifying <b>CLONE_THREAD</b> automatically implies <b>CLONE_VM</b>, and
       specifying <b>CLONE_VM</b> automatically implies <b>CLONE_SIGHAND</b>.)  If the process is multithreaded, then the  use
       of these flags results in an error.

       If  <u>flags</u>  is  specified as zero, then <b>unshare</b>() is a no-op; no changes are made to the calling process's
       execution context.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, zero returned.  On failure, -1 is returned and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EINVAL</b> An invalid bit was specified in <u>flags</u>.

       <b>EINVAL</b> <b>CLONE_THREAD</b>, <b>CLONE_SIGHAND</b>, or <b>CLONE_VM</b> was specified in <u>flags</u>, and the caller is multithreaded.

       <b>EINVAL</b> <b>CLONE_NEWIPC</b> was specified in <u>flags</u>, but the kernel was not configured with the <b>CONFIG_SYSVIPC</b> and
              <b>CONFIG_IPC_NS</b> options.

       <b>EINVAL</b> <b>CLONE_NEWNET</b> was specified in <u>flags</u>, but the kernel was  not  configured  with  the  <b>CONFIG_NET_NS</b>
              option.

       <b>EINVAL</b> <b>CLONE_NEWPID</b>  was  specified  in  <u>flags</u>,  but the kernel was not configured with the <b>CONFIG_PID_NS</b>
              option.

       <b>EINVAL</b> <b>CLONE_NEWUSER</b> was specified in <u>flags</u>, but the kernel was not configured  with  the  <b>CONFIG_USER_NS</b>
              option.

       <b>EINVAL</b> <b>CLONE_NEWUTS</b>  was  specified  in  <u>flags</u>,  but the kernel was not configured with the <b>CONFIG_UTS_NS</b>
              option.

       <b>EINVAL</b> <b>CLONE_NEWPID</b> was specified in <u>flags</u>, but the process has  previously  called  <b>unshare</b>()  with  the
              <b>CLONE_NEWPID</b> flag.

       <b>ENOMEM</b> Cannot allocate sufficient memory to copy parts of caller's context that need to be unshared.

       <b>ENOSPC</b> (since Linux 3.7)
              <b>CLONE_NEWPID</b>  was  specified  in flags, but the limit on the nesting depth of PID namespaces would
              have been exceeded; see <b><a href="../man7/pid_namespaces.7.html">pid_namespaces</a></b>(7).

       <b>ENOSPC</b> (since Linux 4.9; beforehand <b>EUSERS</b>)
              <b>CLONE_NEWUSER</b> was specified in <u>flags</u>, and the call would cause the limit on the number  of  nested
              user namespaces to be exceeded.  See <b><a href="../man7/user_namespaces.7.html">user_namespaces</a></b>(7).

              From Linux 3.11 to Linux 4.8, the error diagnosed in this case was <b>EUSERS</b>.

       <b>ENOSPC</b> (since Linux 4.9)
              One of the values in <u>flags</u> specified the creation of a new user namespace, but doing so would have
              caused  the limit defined by the corresponding file in <u><a href="file:/proc/sys/user">/proc/sys/user</a></u> to be exceeded.  For further
              details, see <b><a href="../man7/namespaces.7.html">namespaces</a></b>(7).

       <b>EPERM</b>  The calling process did not have the required privileges for this operation.

       <b>EPERM</b>  <b>CLONE_NEWUSER</b> was specified in <u>flags</u>, but either the effective user ID or the effective  group  ID
              of the caller does not have a mapping in the parent namespace (see <b><a href="../man7/user_namespaces.7.html">user_namespaces</a></b>(7)).

       <b>EPERM</b> (since Linux 3.9)
              <b>CLONE_NEWUSER</b> was specified in <u>flags</u> and the caller is in a chroot environment (i.e., the caller's
              root directory does not match the root directory of the mount namespace in which it resides).

       <b>EUSERS</b> (from Linux 3.11 to Linux 4.8)
              <b>CLONE_NEWUSER</b>  was specified in <u>flags</u>, and the limit on the number of nested user namespaces would
              be exceeded.  See the discussion of the <b>ENOSPC</b> error above.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.16.

</pre><h4><b>NOTES</b></h4><pre>
       Not all of the process attributes that can be shared when a new process is created using <b><a href="../man2/clone.2.html">clone</a></b>(2) can  be
       unshared  using  <b>unshare</b>().   In  particular,  as  at kernel 3.8, <b>unshare</b>() does not implement flags that
       reverse the effects of <b>CLONE_SIGHAND</b>, <b>CLONE_THREAD</b>, or <b>CLONE_VM</b>.  Such functionality may be added in  the
       future, if required.

       Creating all kinds of namespace, except user namespaces, requires the <b>CAP_SYS_ADMIN</b> capability.  However,
       since  creating  a  user namespace automatically confers a full set of capabilities, creating both a user
       namespace and any other type of namespace in the same <b>unshare</b>() call does not require  the  <b>CAP_SYS_ADMIN</b>
       capability in the original namespace.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program below provides a simple implementation of the <b><a href="../man1/unshare.1.html">unshare</a></b>(1) command, which unshares one or more
       namespaces and executes the command supplied in its command-line arguments.  Here's an example of the use
       of this program, running a shell in a new mount namespace, and verifying that the original shell and  the
       new shell are in separate mount namespaces:

           $ <b>readlink</b> <b><a href="file:/proc/">/proc/</a>$$/ns/mnt</b>
           mnt:[4026531840]
           $ <b>sudo</b> <b>./unshare</b> <b>-m</b> <b><a href="file:/bin/bash">/bin/bash</a></b>
           # <b>readlink</b> <b><a href="file:/proc/">/proc/</a>$$/ns/mnt</b>
           mnt:[4026532325]

       The  differing  output  of  the two <b><a href="../man1/readlink.1.html">readlink</a></b>(1) commands shows that the two shells are in different mount
       namespaces.

   <b>Program</b> <b>source</b>

       /* unshare.c

          A simple implementation of the <a href="../man1/unshare.1.html">unshare</a>(1) command: unshare
          namespaces and execute a command.
       */
       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       static void
       usage(char *pname)
       {
           fprintf(stderr, "Usage: %s [options] program [arg...]\n", pname);
           fprintf(stderr, "Options can be:\n");
           fprintf(stderr, "    -C   unshare cgroup namespace\n");
           fprintf(stderr, "    -i   unshare IPC namespace\n");
           fprintf(stderr, "    -m   unshare mount namespace\n");
           fprintf(stderr, "    -n   unshare network namespace\n");
           fprintf(stderr, "    -p   unshare PID namespace\n");
           fprintf(stderr, "    -t   unshare time namespace\n");
           fprintf(stderr, "    -u   unshare UTS namespace\n");
           fprintf(stderr, "    -U   unshare user namespace\n");
           exit(EXIT_FAILURE);
       }

       int
       main(int argc, char *argv[])
       {
           int flags, opt;

           flags = 0;

           while ((opt = getopt(argc, argv, "CimnptuU")) != -1) {
               switch (opt) {
               case 'C': flags |= CLONE_NEWCGROUP;     break;
               case 'i': flags |= CLONE_NEWIPC;        break;
               case 'm': flags |= CLONE_NEWNS;         break;
               case 'n': flags |= CLONE_NEWNET;        break;
               case 'p': flags |= CLONE_NEWPID;        break;
               case 't': flags |= CLONE_NEWTIME;       break;
               case 'u': flags |= CLONE_NEWUTS;        break;
               case 'U': flags |= CLONE_NEWUSER;       break;
               default:  usage(argv[0]);
               }
           }

           if (optind &gt;= argc)
               usage(argv[0]);

           if (unshare(flags) == -1)
               err(EXIT_FAILURE, "unshare");

           execvp(argv[optind], &amp;argv[optind]);
           err(EXIT_FAILURE, "execvp");
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/unshare.1.html">unshare</a></b>(1), <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/fork.2.html">fork</a></b>(2), <b><a href="../man2/kcmp.2.html">kcmp</a></b>(2), <b><a href="../man2/setns.2.html">setns</a></b>(2), <b><a href="../man2/vfork.2.html">vfork</a></b>(2), <b><a href="../man7/namespaces.7.html">namespaces</a></b>(7)

       <u>Documentation/userspace-api/unshare.rst</u> in the Linux kernel  source  tree  (or  <u>Documentation/unshare.txt</u>
       before Linux 4.12)

Linux man-pages 6.9.1                              2024-06-15                                         <u><a href="../man2/unshare.2.html">unshare</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>