<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>procctl — control processes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       procctl — control processes

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/procctl.h&gt;</b>

       <u>int</u>
       <b>procctl</b>(<u>idtype_t</u> <u>idtype</u>, <u>id_t</u> <u>id</u>, <u>int</u> <u>cmd</u>, <u>void</u> <u>*data</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>procctl</b>()  system call provides for control over processes.  The <u>idtype</u> and <u>id</u> arguments specify the
       set of processes to control.  If multiple processes match the  identifier,  <b>procctl</b>  will  make  a  “best
       effort”  to  control  as  many  of  the  selected processes as possible.  An error is only returned if no
       selected processes successfully complete the request.  The following identifier types are supported:

       P_PID   Control the process with the process ID <u>id</u>.

       P_PGID  Control processes belonging to the process group with the ID <u>id</u>.

       The control request to perform is specified by the <u>cmd</u> argument.  The following commands are supported:

       PROC_ASLR_CTL        Controls the Address Space Layout Randomization (ASLR) in the program images created
                            by <u><a href="../man2/execve.2.html">execve</a></u>(2) in the specified process or its descendants that did  not  changed  the
                            control  nor  modified  it  by  other  means.   The <u>data</u> parameter must point to the
                            integer variable holding one of the following values:

                            PROC_ASLR_FORCE_ENABLE   Request that ASLR is enabled after execution, even if it is
                                                     disabled system-wide.  The image  flag  and  set-uid  might
                                                     prevent ASLR enablement still.

                            PROC_ASLR_FORCE_DISABLE  Request  that ASLR is disabled after execution.  Same notes
                                                     as for PROC_ASLR_FORCE_ENABLE apply.

                            PROC_ASLR_NOFORCE        Use system-wide configured policy for ASLR.

       PROC_ASLR_STATUS     Returns the current status of ASLR enablement for  the  target  process.   The  <u>data</u>
                            parameter  must  point to the integer variable, where one of the following values is
                            written:

                            PROC_ASLR_FORCE_ENABLE

                            PROC_ASLR_FORCE_DISABLE

                            PROC_ASLR_NOFORCE

                            If the currently executed  image  in  the  process  itself  has  ASLR  enabled,  the
                            PROC_ASLR_ACTIVE flag is or-ed with the value listed above.

       PROC_SPROTECT        Set  process  protection  state.   This  is used to mark a process as protected from
                            being killed if the system  exhausts  the  available  memory  and  swap.   The  <u>data</u>
                            parameter must point to an integer containing an operation and zero or more optional
                            flags.  The following operations are supported:

                            PPROT_SET    Mark the selected processes as protected.

                            PPROT_CLEAR  Clear the protected state of selected processes.

                            The following optional flags are supported:

                            PPROT_DESCEND  Apply the requested operation to all child processes of each selected
                                           process in addition to each selected process.

                            PPROT_INHERIT  When  used  with  PPROT_SET,  mark all future child processes of each
                                           selected process as protected.  Future child processes will also mark
                                           all of their future child processes.

       PROC_REAP_ACQUIRE    Acquires the reaper status for  the  current  process.   Reaper  status  means  that
                            children orphaned by the reaper's descendants that were forked after the acquisition
                            of reaper status are reparented to the reaper process.  After system initialization,
                            <u><a href="../man8/init.8.html">init</a></u>(8) is the default reaper.

       PROC_REAP_RELEASE    Release the reaper state for the current process.  The reaper of the current process
                            becomes the new reaper of the current process's descendants.

       PROC_REAP_STATUS     Provides  information  about  the  reaper  of  the specified process, or the process
                            itself when it is a reaper.  The <u>data</u> argument must point to a <u>procctl_reaper_status</u>
                            structure which is filled in by the syscall on successful return.

                            struct procctl_reaper_status {
                                    u_int   rs_flags;
                                    u_int   rs_children;
                                    u_int   rs_descendants;
                                    pid_t   rs_reaper;
                                    pid_t   rs_pid;
                            };
                            The <u>rs_flags</u> may have the following flags returned:

                            REAPER_STATUS_OWNED     The specified process has acquired reaper status and has not
                                                    released it.  When  the  flag  is  returned,  the  specified
                                                    process  <u>id</u>,  pid,  identifies  the  reaper,  otherwise  the
                                                    <u>rs_reaper</u> field of the structure is set to the  pid  of  the
                                                    reaper for the specified process id.

                            REAPER_STATUS_REALINIT  The  specified process is the root of the reaper tree, i.e.,
                                                    <u><a href="../man8/init.8.html">init</a></u>(8).

                            The <u>rs_children</u> field returns the  number  of  children  of  the  reaper  among  the
                            descendants.   It  is  possible  to  have  a child whose reaper is not the specified
                            process,  since  the  reaper  for  any  existing  children  is  not  reset  on   the
                            PROC_REAP_ACQUIRE  operation.   The <u>rs_descendants</u> field returns the total number of
                            descendants of the reaper(s), not counting descendants of the reaper in the subtree.
                            The <u>rs_reaper</u> field returns the reaper pid.  The  <u>rs_pid</u>  returns  the  pid  of  one
                            reaper child if there are any descendants.

       PROC_REAP_GETPIDS    Queries the list of descendants of the reaper of the specified process.  The request
                            takes a pointer to a <u>procctl_reaper_pids</u> structure in the <u>data</u> parameter.

                            struct procctl_reaper_pids {
                                    u_int   rp_count;
                                    struct procctl_reaper_pidinfo *rp_pids;
                            };
                            When  called,  the  <u>rp_pids</u>  field  must point to an array of <u>procctl_reaper_pidinfo</u>
                            structures, to be filled in on return, and the <u>rp_count</u> field must specify the  size
                            of  the  array,  into  which no more than <u>rp_count</u> elements will be filled in by the
                            kernel.

                            The <u>struct</u> <u>procctl_reaper_pidinfo</u> structure provides some information about  one  of
                            the reaper's descendants.  Note that for a descendant that is not a child, it may be
                            incorrectly  identified because of a race in which the original child process exited
                            and the exited process's pid was reused for an unrelated process.

                            struct procctl_reaper_pidinfo {
                                    pid_t   pi_pid;
                                    pid_t   pi_subtree;
                                    u_int   pi_flags;
                            };
                            The <u>pi_pid</u> field is the process id of the descendant.  The <u>pi_subtree</u> field provides
                            the pid of the child of the reaper, which is the (grand-)parent of the process.  The
                            <u>pi_flags</u> field returns the following flags, further describing the descendant:

                            REAPER_PIDINFO_VALID   Set to indicate that the <u>procctl_reaper_pidinfo</u> structure was
                                                   filled in by the kernel.  Zero-filling the <u>rp_pids</u> array  and
                                                   testing  the  REAPER_PIDINFO_VALID  flag allows the caller to
                                                   detect the end of the returned array.

                            REAPER_PIDINFO_CHILD   The <u>pi_pid</u> field identifies the direct child of the reaper.

                            REAPER_PIDINFO_REAPER  The reported process is itself a reaper.  The descendants  of
                                                   the subordinate reaper are not reported.

       PROC_REAP_KILL       Request  to  deliver  a signal to some subset of the descendants of the reaper.  The
                            <u>data</u> parameter must point to a <u>procctl_reaper_kill</u> structure, which is used both for
                            parameters and status return.

                            struct procctl_reaper_kill {
                                    int     rk_sig;
                                    u_int   rk_flags;
                                    pid_t   rk_subtree;
                                    u_int   rk_killed;
                                    pid_t   rk_fpid;
                            };
                            The <u>rk_sig</u> field specifies the signal to be delivered.  Zero is not a  valid  signal
                            number,  unlike  for <u><a href="../man2/kill.2.html">kill</a></u>(2).  The <u>rk_flags</u> field further directs the operation.  It
                            is or-ed from the following flags:

                            REAPER_KILL_CHILDREN  Deliver the specified signal only to direct  children  of  the
                                                  reaper.

                            REAPER_KILL_SUBTREE   Deliver  the  specified  signal  only to descendants that were
                                                  forked  by  the  direct  child  with  pid  specified  in   the
                                                  <u>rk_subtree</u> field.
                            If neither the REAPER_KILL_CHILDREN nor the REAPER_KILL_SUBTREE flags are specified,
                            all current descendants of the reaper are signalled.

                            If a signal was delivered to any process, the return value from the request is zero.
                            In this case, the <u>rk_killed</u> field identifies the number of processes signalled.  The
                            <u>rk_fpid</u>  field  is  set  to  the  pid of the first process for which signal delivery
                            failed, e.g., due to permission problems.  If no such process  exists,  the  <u>rk_fpid</u>
                            field is set to -1.

       PROC_TRACE_CTL       Enable  or  disable  tracing of the specified process(es), according to the value of
                            the integer  argument.   Tracing  includes  attachment  to  the  process  using  the
                            <u><a href="../man2/ptrace.2.html">ptrace</a></u>(2)  and  <u><a href="../man2/ktrace.2.html">ktrace</a></u>(2), debugging sysctls, <u><a href="../man4/hwpmc.4.html">hwpmc</a></u>(4), <u><a href="../man1/dtrace.1.html">dtrace</a></u>(1), and core dumping.
                            Possible values for the <u>data</u> argument are:

                            PROC_TRACE_CTL_ENABLE        Enable   tracing,   after   it    was    disabled    by
                                                         PROC_TRACE_CTL_DISABLE.  Only allowed for self.

                            PROC_TRACE_CTL_DISABLE       Disable  tracing for the specified process.  Tracing is
                                                         re-enabled  when  the  process  changes  the  executing
                                                         program  with  the <u><a href="../man2/execve.2.html">execve</a></u>(2) syscall.  A child inherits
                                                         the trace settings from the parent on <u><a href="../man2/fork.2.html">fork</a></u>(2).

                            PROC_TRACE_CTL_DISABLE_EXEC  Same  as  PROC_TRACE_CTL_DISABLE,   but   the   setting
                                                         persists for the process even after <u><a href="../man2/execve.2.html">execve</a></u>(2).

       PROC_TRACE_STATUS    Returns the current tracing status for the specified process in the integer variable
                            pointed  to  by  <u>data</u>.   If  tracing  is disabled, <u>data</u> is set to -1.  If tracing is
                            enabled, but no debugger is attached by the <u><a href="../man2/ptrace.2.html">ptrace</a></u>(2) syscall, <u>data</u> is set to 0.  If
                            a debugger is attached, <u>data</u> is set to the pid of the debugger process.

       PROC_TRAPCAP_CTL     Controls the capability mode sandbox actions for the specified sandboxed  processes,
                            on a return from any syscall which gives either a ENOTCAPABLE or ECAPMODE error.  If
                            the  control  is  enabled,  such  errors  from  the  syscalls  cause delivery of the
                            synchronous SIGTRAP signal to the  thread  immediately  before  returning  from  the
                            syscalls.

                            Possible values for the <u>data</u> argument are:

                            PROC_TRAPCAP_CTL_ENABLE   Enable  the  SIGTRAP  signal  delivery  on capability mode
                                                      access violations.  The enabled mode is inherited  by  the
                                                      children  of  the  process,  and  is kept after <u><a href="../man2/fexecve.2.html">fexecve</a></u>(2)
                                                      calls.

                            PROC_TRAPCAP_CTL_DISABLE  Disable the signal  delivery  on  capability  mode  access
                                                      violations.  Note that the global sysctl kern.trap_enotcap
                                                      might  still  cause  the  signal  to  be  delivered.   See
                                                      <u><a href="../man4/capsicum.4.html">capsicum</a></u>(4).

                            On signal delivery, the <u>si_errno</u> member of the <u>siginfo</u> signal handler  parameter  is
                            set to the syscall error value, and the <u>si_code</u> member is set to TRAP_CAP.

                            See <u><a href="../man4/capsicum.4.html">capsicum</a></u>(4) for more information about the capability mode.

       PROC_TRAPCAP_STATUS  Return  the  current  status of signalling capability mode access violations for the
                            specified process.  The integer value pointed to by the <u>data</u> argument is set to  the
                            PROC_TRAPCAP_CTL_ENABLE value if the process control enables signal delivery, and to
                            PROC_TRAPCAP_CTL_DISABLE otherwise.

                            See  the  note  about sysctl kern.trap_enotcap above, which gives independent global
                            control of signal delivery.

       PROC_PDEATHSIG_CTL   Request the delivery of a signal when the  parent  of  the  calling  process  exits.
                            <u>idtype</u>  must  be  P_PID  and  <u>id</u>  must  be  the either caller's pid or zero, with no
                            difference in effect.  The value is cleared for child processes and  when  executing
                            set-user-ID  or  set-group-ID  binaries.   <u>arg</u>  must  point  to  a value of type <u>int</u>
                            indicating the signal that should be delivered to the caller.  Use zero to cancel  a
                            previously requested signal delivery.

       PROC_PDEATHSIG_STATUS
                            Query  the  current  signal  number  that  will  be delivered when the parent of the
                            calling process exits.  <u>idtype</u> must be P_PID and <u>id</u> must be the either caller's  pid
                            or zero, with no difference in effect.  <u>arg</u> must point to a memory location that can
                            hold  a  value  of  type  <u>int</u>.   If  signal delivery has not been requested, it will
                            contain zero on return.

       PROC_STACKGAP_CTL    Controls the stack gaps in the specified process.  A stack gap is the  part  of  the
                            growth  area  for  a  MAP_STACK  mapped  region that is reserved and never filled by
                            memory.  Instead, the process is guaranteed to receive a SIGSEGV signal on accessing
                            pages in the gap.  Gaps protect against stack overflow corrupting memory adjacent to
                            the stack.

                            The <u>data</u> argument must point to an integer variable containing flags.  The following
                            flags are allowed:

                            PROC_STACKGAP_ENABLE        This  flag  is  only  accepted  for   consistency   with
                                                        PROC_STACKGAP_STATUS.   If  stack  gaps are enabled, the
                                                        flag is ignored.  If disabled, the flag causes an EINVAL
                                                        error to be returned.  After  gaps  are  disabled  in  a
                                                        process,  they  can only be re-enabled when an <u><a href="../man2/execve.2.html">execve</a></u>(2)
                                                        is performed.

                            PROC_STACKGAP_DISABLE       Disable  stack  gaps  for  the  process.   For  existing
                                                        stacks,  the  gap  is  no  longer a reserved part of the
                                                        growth area and can be filled by memory on access.

                            PROC_STACKGAP_ENABLE_EXEC   Enable  stack  gaps  for  programs  started   after   an
                                                        <u><a href="../man2/execve.2.html">execve</a></u>(2) by the specified process.

                            PROC_STACKGAP_DISABLE_EXEC  Inherit  disabled  stack gaps state after <u><a href="../man2/execve.2.html">execve</a></u>(2).  In
                                                        other words, if  the  currently  executing  program  has
                                                        stack gaps disabled, they are kept disabled on exec.  If
                                                        gaps were enabled, they are kept enabled after exec.

                            The stack gap state is inherited from the parent on <u><a href="../man2/fork.2.html">fork</a></u>(2).

       PROC_STACKGAP_STATUS
                            Returns  the  current stack gap state for the specified process.  <u>data</u> must point to
                            an integer variable, which is used to return a bitmask consisting of  the  following
                            flags:

                            PROC_STACKGAP_ENABLE        Stack gaps are enabled.

                            PROC_STACKGAP_DISABLE       Stack gaps are disabled.

                            PROC_STACKGAP_ENABLE_EXEC   Stack gaps are enabled in the process after <u><a href="../man2/execve.2.html">execve</a></u>(2).

                            PROC_STACKGAP_DISABLE_EXEC  Stack gaps are disabled in the process after <u><a href="../man2/execve.2.html">execve</a></u>(2).

</pre><h4><b>x86</b> <b>MACHINE-SPECIFIC</b> <b>REQUESTS</b></h4><pre>
       PROC_KPTI_CTL     AMD64 only.  Controls the Kernel Page Table Isolation (KPTI) option for the children of
                         the  specified  process.   For  the  command  to work, the <u>vm.pmap.kpti</u> tunable must be
                         enabled on boot.  It is not possible to change the KPTI setting for a running  process,
                         except at the <u><a href="../man2/execve.2.html">execve</a></u>(2), where the address space is reinitialized.

                         The  <u>data</u>  parameter  must point to an integer variable containing one of the following
                         commands:

                         PROC_KPTI_CTL_ENABLE_ON_EXEC   Enable KPTI after <u><a href="../man2/execve.2.html">execve</a></u>(2).

                         PROC_KPTI_CTL_DISABLE_ON_EXEC  Disable KPTI after <u><a href="../man2/execve.2.html">execve</a></u>(2).  Only root  or  a  process
                                                        having the <u>PRIV_IO</u> privilege might use this option.

       PROC_KPTI_STATUS  Returns  the  current  KPTI  status  for the specified process.  <u>data</u> <u>must</u> <u>point</u> <u>to</u> <u>the</u>
                         <u>integer</u> <u>variable,</u> <u>which</u> <u>returns</u> <u>the</u> following statuses:

                         PROC_KPTI_CTL_ENABLE_ON_EXEC

                         PROC_KPTI_CTL_DISABLE_ON_EXEC

                         The status is or-ed with the <u>PROC_KPTI_STATUS_ACTIVE</u> in case KPTI  is  active  for  the
                         current address space of the process.

</pre><h4><b>NOTES</b></h4><pre>
       Disabling  tracing  on a process should not be considered a security feature, as it is bypassable both by
       the kernel and privileged processes, and via other system mechanisms.  As such, it should not be utilized
       to reliably protect cryptographic keying material or other confidential data.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       If an error occurs, a value of -1 is returned and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <b>procctl</b>() system call will fail if:

       [EFAULT]           The <u>arg</u> parameter points outside the process's allocated address space.

       [EINVAL]           The <u>cmd</u> argument specifies an unsupported command.

                          The <u>idtype</u> argument specifies an unsupported identifier type.

       [EPERM]            The calling process does not have permission to perform the requested operation on any
                          of the selected processes.

       [ESRCH]            No processes matched the requested <u>idtype</u> and <u>id</u>.

       [EINVAL]           An invalid operation or flag was passed in <u>arg</u> for a PROC_SPROTECT command.

       [EPERM]            The <u>idtype</u> argument is not equal to P_PID, or <u>id</u> is  not  equal  to  the  pid  of  the
                          calling process, for PROC_REAP_ACQUIRE or PROC_REAP_RELEASE requests.

       [EINVAL]           Invalid or undefined flags were passed to a PROC_REAP_KILL request.

       [EINVAL]           An invalid or zero signal number was requested for a PROC_REAP_KILL request.

       [EINVAL]           The PROC_REAP_RELEASE request was issued by the <u><a href="../man8/init.8.html">init</a></u>(8) process.

       [EBUSY]            The PROC_REAP_ACQUIRE request was issued by a process that had already acquired reaper
                          status and has not yet released it.

       [EBUSY]            The PROC_TRACE_CTL request was issued for a process already being traced.

       [EPERM]            The    PROC_TRACE_CTL    request    to    re-enable    tracing    of    the    process
                          (PROC_TRACE_CTL_ENABLE),  or  to  disable  persistence  of  PROC_TRACE_CTL_DISABLE  on
                          <u><a href="../man2/execve.2.html">execve</a></u>(2) was issued for a non-current process.

       [EINVAL]           The  value  of  the  integer <u>data</u> parameter for the PROC_TRACE_CTL or PROC_TRAPCAP_CTL
                          request is invalid.

       [EINVAL]           The PROC_PDEATHSIG_CTL or PROC_PDEATHSIG_STATUS request referenced an unsupported  <u>id</u>,
                          <u>idtype</u> or invalid signal number.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/dtrace.1.html">dtrace</a></u>(1), <u><a href="../man2/cap_enter.2.html">cap_enter</a></u>(2), <u><a href="../man2/kill.2.html">kill</a></u>(2), <u><a href="../man2/ktrace.2.html">ktrace</a></u>(2), <u><a href="../man2/ptrace.2.html">ptrace</a></u>(2), <u><a href="../man2/wait.2.html">wait</a></u>(2), <u><a href="../man4/capsicum.4.html">capsicum</a></u>(4), <u><a href="../man4/hwpmc.4.html">hwpmc</a></u>(4), <u><a href="../man8/init.8.html">init</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>procctl</b>() function appeared in FreeBSD 10.0.

       The  reaper  facility  is  based  on  a  similar feature of Linux and DragonflyBSD, and first appeared in
       FreeBSD 10.2.

       The PROC_PDEATHSIG_CTL facility is based on the prctl(PR_SET_PDEATHSIG, ...) feature of Linux, and  first
       appeared in FreeBSD 11.2.

       The ASLR support was added to system for the checklists compliance in FreeBSD 13.0.

Debian                                            June 13, 2020                                       <u><a href="../man2/PROCCTL.2.html">PROCCTL</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>