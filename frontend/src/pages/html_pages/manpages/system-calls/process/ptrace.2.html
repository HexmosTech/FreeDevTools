<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ptrace - process trace</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ptrace - process trace

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/ptrace.h&gt;</b>

       <b>long</b> <b>ptrace(enum</b> <b>__ptrace_request</b> <u>op</u><b>,</b> <b>pid_t</b> <u>pid</u><b>,</b>
                   <b>void</b> <b>*</b><u>addr</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>ptrace</b>() system call provides a means by which one process (the "tracer") may observe and control the
       execution  of  another  process (the "tracee"), and examine and change the tracee's memory and registers.
       It is primarily used to implement breakpoint debugging and system call tracing.

       A tracee first needs to be attached to the tracer.  Attachment and subsequent commands are per thread: in
       a multithreaded process, every thread can be individually attached to a (potentially  different)  tracer,
       or  left  not  attached and thus not debugged.  Therefore, "tracee" always means "(one) thread", never "a
       (possibly multithreaded) process".  Ptrace commands are always sent to a specific tracee using a call  of
       the form

           ptrace(PTRACE_foo, pid, ...)

       where <u>pid</u> is the thread ID of the corresponding Linux thread.

       (Note  that  in  this  page, a "multithreaded process" means a thread group consisting of threads created
       using the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_THREAD</b> flag.)

       A process can initiate a trace by calling <b><a href="../man2/fork.2.html">fork</a></b>(2) and having the resulting  child  do  a  <b>PTRACE_TRACEME</b>,
       followed  (typically)  by  an <b><a href="../man2/execve.2.html">execve</a></b>(2).  Alternatively, one process may commence tracing another process
       using <b>PTRACE_ATTACH</b> or <b>PTRACE_SEIZE</b>.

       While being traced, the tracee will stop each time a signal is delivered, even if  the  signal  is  being
       ignored.  (An exception is <b>SIGKILL</b>, which has its usual effect.)  The tracer will be notified at its next
       call  to  <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2)  (or  one  of the related "wait" system calls); that call will return a <u>status</u> value
       containing information that indicates the cause of the stop in the tracee.  While the tracee is  stopped,
       the  tracer  can  use various ptrace operations to inspect and modify the tracee.  The tracer then causes
       the tracee to continue, optionally ignoring the delivered signal (or even delivering a  different  signal
       instead).

       If  the  <b>PTRACE_O_TRACEEXEC</b>  option  is  not  in  effect, all successful calls to <b><a href="../man2/execve.2.html">execve</a></b>(2) by the traced
       process will cause it to be sent a <b>SIGTRAP</b> signal, giving the parent a chance to gain control before  the
       new program begins execution.

       When  the tracer is finished tracing, it can cause the tracee to continue executing in a normal, untraced
       mode via <b>PTRACE_DETACH</b>.

       The value of <u>op</u> determines the operation to be performed:

       <b>PTRACE_TRACEME</b>
              Indicate that this process is to be traced by its parent.  A process probably shouldn't make  this
              operation if its parent isn't expecting to trace it.  (<u>pid</u>, <u>addr</u>, and <u>data</u> are ignored.)

              The <b>PTRACE_TRACEME</b> operation is used only by the tracee; the remaining operations are used only by
              the  tracer.   In  the following operations, <u>pid</u> specifies the thread ID of the tracee to be acted
              on.  For operations other than <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b>, <b>PTRACE_INTERRUPT</b>, and <b>PTRACE_KILL</b>, the
              tracee must be stopped.

       <b>PTRACE_PEEKTEXT</b>
       <b>PTRACE_PEEKDATA</b>
              Read a word at the address <u>addr</u> in the tracee's memory, returning the word as the  result  of  the
              <b>ptrace</b>() call.  Linux does not have separate text and data address spaces, so these two operations
              are currently equivalent.  (<u>data</u> is ignored; but see NOTES.)

       <b>PTRACE_PEEKUSER</b>
              Read  a  word  at  offset  <u>addr</u>  in  the  tracee's  USER area, which holds the registers and other
              information about the process (see <u>&lt;sys/user.h&gt;</u>).  The word is  returned  as  the  result  of  the
              <b>ptrace</b>()   call.   Typically,  the  offset  must  be  word-aligned,  though  this  might  vary  by
              architecture.  See NOTES.  (<u>data</u> is ignored; but see NOTES.)

       <b>PTRACE_POKETEXT</b>
       <b>PTRACE_POKEDATA</b>
              Copy the word <u>data</u> to the address <u>addr</u>  in  the  tracee's  memory.   As  for  <b>PTRACE_PEEKTEXT</b>  and
              <b>PTRACE_PEEKDATA</b>, these two operations are currently equivalent.

       <b>PTRACE_POKEUSER</b>
              Copy  the  word <u>data</u> to offset <u>addr</u> in the tracee's USER area.  As for <b>PTRACE_PEEKUSER</b>, the offset
              must typically be  word-aligned.   In  order  to  maintain  the  integrity  of  the  kernel,  some
              modifications to the USER area are disallowed.

       <b>PTRACE_GETREGS</b>
       <b>PTRACE_GETFPREGS</b>
              Copy  the  tracee's general-purpose or floating-point registers, respectively, to the address <u>data</u>
              in the tracer.  See <u>&lt;sys/user.h&gt;</u> for information on the format of this data.  (<u>addr</u>  is  ignored.)
              Note  that  SPARC systems have the meaning of <u>data</u> and <u>addr</u> reversed; that is, <u>data</u> is ignored and
              the registers are copied to the address <u>addr</u>.  <b>PTRACE_GETREGS</b> and <b>PTRACE_GETFPREGS</b> are not present
              on all architectures.

       <b>PTRACE_GETREGSET</b> (since Linux 2.6.34)
              Read the tracee's registers.  <u>addr</u> specifies,  in  an  architecture-dependent  way,  the  type  of
              registers to be read.  <b>NT_PRSTATUS</b> (with numerical value 1) usually results in reading of general-
              purpose  registers.  If the CPU has, for example, floating-point and/or vector registers, they can
              be retrieved by setting <u>addr</u> to the corresponding <b>NT_foo</b> constant.  <u>data</u> points to a <b>struct</b> <b>iovec</b>,
              which describes the destination buffer's location and length.   On  return,  the  kernel  modifies
              <b>iov.len</b> to indicate the actual number of bytes returned.

       <b>PTRACE_SETREGS</b>
       <b>PTRACE_SETFPREGS</b>
              Modify  the  tracee's  general-purpose or floating-point registers, respectively, from the address
              <u>data</u> in the tracer.  As for <b>PTRACE_POKEUSER</b>, some general-purpose register  modifications  may  be
              disallowed.   (<u>addr</u>  is  ignored.)   Note  that  SPARC  systems  have the meaning of <u>data</u> and <u>addr</u>
              reversed; that is,  <u>data</u>  is  ignored  and  the  registers  are  copied  from  the  address  <u>addr</u>.
              <b>PTRACE_SETREGS</b> and <b>PTRACE_SETFPREGS</b> are not present on all architectures.

       <b>PTRACE_SETREGSET</b> (since Linux 2.6.34)
              Modify the tracee's registers.  The meaning of <u>addr</u> and <u>data</u> is analogous to <b>PTRACE_GETREGSET</b>.

       <b>PTRACE_GETSIGINFO</b> (since Linux 2.3.99-pre6)
              Retrieve  information  about  the  signal  that  caused the stop.  Copy a <u>siginfo_t</u> structure (see
              <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2)) from the tracee to the address <u>data</u> in the tracer.  (<u>addr</u> is ignored.)

       <b>PTRACE_SETSIGINFO</b> (since Linux 2.3.99-pre6)
              Set signal information: copy a <u>siginfo_t</u> structure from the address <u>data</u>  in  the  tracer  to  the
              tracee.   This  will  affect  only signals that would normally be delivered to the tracee and were
              caught by the tracer.  It may be difficult to tell these normal  signals  from  synthetic  signals
              generated by <b>ptrace</b>() itself.  (<u>addr</u> is ignored.)

       <b>PTRACE_PEEKSIGINFO</b> (since Linux 3.10)
              Retrieve  <u>siginfo_t</u>  structures  without  removing  signals  from  a  queue.   <u>addr</u>  points  to  a
              <u>ptrace_peeksiginfo_args</u> structure that specifies  the  ordinal  position  from  which  copying  of
              signals should start, and the number of signals to copy.  <u>siginfo_t</u> structures are copied into the
              buffer pointed to by <u>data</u>.  The return value contains the number of copied signals (zero indicates
              that  there  is  no  signal corresponding to the specified ordinal position).  Within the returned
              <u>siginfo</u> structures, the <u>si_code</u> field includes information (<b>__SI_CHLD</b>, <b>__SI_FAULT</b>, etc.) that  are
              not otherwise exposed to user space.

           struct ptrace_peeksiginfo_args {
               u64 off;    /* Ordinal position in queue at which
                              to start copying signals */
               u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED or 0 */
               s32 nr;     /* Number of signals to copy */
           };

              Currently,  there  is  only  one  flag,  <b>PTRACE_PEEKSIGINFO_SHARED</b>,  for  dumping signals from the
              process-wide signal queue.  If this flag is not set, signals are read from the per-thread queue of
              the specified thread.

       <b>PTRACE_GETSIGMASK</b> (since Linux 3.11)
              Place a copy of the mask of blocked signals (see <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2)) in the buffer pointed to by <u>data</u>,
              which should be a pointer to a buffer of type <u>sigset_t</u>.  The <u>addr</u> argument contains  the  size  of
              the buffer pointed to by <u>data</u> (i.e., <u>sizeof(sigset_t)</u>).

       <b>PTRACE_SETSIGMASK</b> (since Linux 3.11)
              Change  the  mask  of  blocked  signals  (see <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2)) to the value specified in the buffer
              pointed to by <u>data</u>, which should be a pointer to a buffer of type  <u>sigset_t</u>.   The  <u>addr</u>  argument
              contains the size of the buffer pointed to by <u>data</u> (i.e., <u>sizeof(sigset_t)</u>).

       <b>PTRACE_SETOPTIONS</b> (since Linux 2.4.6; see BUGS for caveats)
              Set  ptrace  options from <u>data</u>.  (<u>addr</u> is ignored.)  <u>data</u> is interpreted as a bit mask of options,
              which are specified by the following flags:

              <b>PTRACE_O_EXITKILL</b> (since Linux 3.8)
                     Send a <b>SIGKILL</b> signal to the tracee if the tracer exits.  This option is useful for  ptrace
                     jailers that want to ensure that tracees can never escape the tracer's control.

              <b>PTRACE_O_TRACECLONE</b> (since Linux 2.5.46)
                     Stop  the  tracee  at  the  next  <b><a href="../man2/clone.2.html">clone</a></b>(2) and automatically start tracing the newly cloned
                     process, which will start with a <b>SIGSTOP</b>, or <b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used.  A
                     <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) by the tracer will return a <u>status</u> value such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_CLONE&lt;&lt;8))

                     The PID of the new process can be retrieved with <b>PTRACE_GETEVENTMSG</b>.

                     This option may not catch <b><a href="../man2/clone.2.html">clone</a></b>(2) calls in all cases.  If the tracee calls  <b><a href="../man2/clone.2.html">clone</a></b>(2)  with
                     the  <b>CLONE_VFORK</b>  flag, <b>PTRACE_EVENT_VFORK</b> will be delivered instead if <b>PTRACE_O_TRACEVFORK</b>
                     is set; otherwise if the tracee calls  <b><a href="../man2/clone.2.html">clone</a></b>(2)  with  the  exit  signal  set  to  <b>SIGCHLD</b>,
                     <b>PTRACE_EVENT_FORK</b> will be delivered if <b>PTRACE_O_TRACEFORK</b> is set.

              <b>PTRACE_O_TRACEEXEC</b> (since Linux 2.5.46)
                     Stop  the  tracee  at  the next <b><a href="../man2/execve.2.html">execve</a></b>(2).  A <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) by the tracer will return a <u>status</u>
                     value such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_EXEC&lt;&lt;8))

                     If the execing thread is not a thread group leader, the thread ID is reset to thread  group
                     leader's  ID before this stop.  Since Linux 3.0, the former thread ID can be retrieved with
                     <b>PTRACE_GETEVENTMSG</b>.

              <b>PTRACE_O_TRACEEXIT</b> (since Linux 2.5.60)
                     Stop the tracee at exit.  A <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) by the tracer will return a <u>status</u> value such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_EXIT&lt;&lt;8))

                     The tracee's exit status can be retrieved with <b>PTRACE_GETEVENTMSG</b>.

                     The tracee is stopped early during  process  exit,  when  registers  are  still  available,
                     allowing the tracer to see where the exit occurred, whereas the normal exit notification is
                     done  after  the process is finished exiting.  Even though context is available, the tracer
                     cannot prevent the exit from happening at this point.

              <b>PTRACE_O_TRACEFORK</b> (since Linux 2.5.46)
                     Stop the tracee at the next <b><a href="../man2/fork.2.html">fork</a></b>(2)  and  automatically  start  tracing  the  newly  forked
                     process, which will start with a <b>SIGSTOP</b>, or <b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used.  A
                     <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) by the tracer will return a <u>status</u> value such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_FORK&lt;&lt;8))

                     The PID of the new process can be retrieved with <b>PTRACE_GETEVENTMSG</b>.

              <b>PTRACE_O_TRACESYSGOOD</b> (since Linux 2.4.6)
                     When  delivering  system  call  traps,  set  bit  7  in  the  signal  number (i.e., deliver
                     <u>SIGTRAP|0x80</u>).  This makes it easy for the tracer to distinguish normal  traps  from  those
                     caused by a system call.

              <b>PTRACE_O_TRACEVFORK</b> (since Linux 2.5.46)
                     Stop  the  tracee  at  the  next <b><a href="../man2/vfork.2.html">vfork</a></b>(2) and automatically start tracing the newly vforked
                     process, which will start with a <b>SIGSTOP</b>, or <b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used.  A
                     <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) by the tracer will return a <u>status</u> value such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_VFORK&lt;&lt;8))

                     The PID of the new process can be retrieved with <b>PTRACE_GETEVENTMSG</b>.

              <b>PTRACE_O_TRACEVFORKDONE</b> (since Linux 2.5.60)
                     Stop the tracee at the completion of the next <b><a href="../man2/vfork.2.html">vfork</a></b>(2).  A <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) by  the  tracer  will
                     return a <u>status</u> value such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONE&lt;&lt;8))

                     The PID of the new process can (since Linux 2.6.18) be retrieved with <b>PTRACE_GETEVENTMSG</b>.

              <b>PTRACE_O_TRACESECCOMP</b> (since Linux 3.5)
                     Stop the tracee when a <b><a href="../man2/seccomp.2.html">seccomp</a></b>(2) <b>SECCOMP_RET_TRACE</b> rule is triggered.  A <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) by the
                     tracer will return a <u>status</u> value such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_SECCOMP&lt;&lt;8))

                     While  this  triggers  a  <b>PTRACE_EVENT</b>  stop,  it  is similar to a syscall-enter-stop.  For
                     details, see the note on <b>PTRACE_EVENT_SECCOMP</b> below.  The seccomp event message data  (from
                     the   <b>SECCOMP_RET_DATA</b>   portion  of  the  seccomp  filter  rule)  can  be  retrieved  with
                     <b>PTRACE_GETEVENTMSG</b>.

              <b>PTRACE_O_SUSPEND_SECCOMP</b> (since Linux 4.3)
                     Suspend the tracee's seccomp protections.  This applies regardless of mode, and can be used
                     when the tracee has not yet installed seccomp filters.  That is, a valid  use  case  is  to
                     suspend  a  tracee's  seccomp  protections before they are installed by the tracee, let the
                     tracee install the filters, and then clear this flag when the filters  should  be  resumed.
                     Setting  this  option  requires that the tracer have the <b>CAP_SYS_ADMIN</b> capability, not have
                     any seccomp protections installed, and not have <b>PTRACE_O_SUSPEND_SECCOMP</b> set on itself.

       <b>PTRACE_GETEVENTMSG</b> (since Linux 2.5.46)
              Retrieve a message (as an <u>unsigned</u> <u>long</u>) about the ptrace event that just happened, placing it  at
              the  address  <u>data</u>  in  the tracer.  For <b>PTRACE_EVENT_EXIT</b>, this is the tracee's exit status.  For
              <b>PTRACE_EVENT_FORK</b>, <b>PTRACE_EVENT_VFORK</b>, <b>PTRACE_EVENT_VFORK_DONE</b>, and  <b>PTRACE_EVENT_CLONE</b>,  this  is
              the  PID  of  the  new  process.   For  <b>PTRACE_EVENT_SECCOMP</b>,  this  is  the  <b><a href="../man2/seccomp.2.html">seccomp</a></b>(2)  filter's
              <b>SECCOMP_RET_DATA</b> associated with the triggered rule.  (<u>addr</u> is ignored.)

       <b>PTRACE_CONT</b>
              Restart the stopped tracee process.  If <u>data</u> is nonzero, it is interpreted  as  the  number  of  a
              signal  to  be delivered to the tracee; otherwise, no signal is delivered.  Thus, for example, the
              tracer can control whether a signal sent to the tracee is delivered or not.  (<u>addr</u> is ignored.)

       <b>PTRACE_SYSCALL</b>
       <b>PTRACE_SINGLESTEP</b>
              Restart the stopped tracee as for <b>PTRACE_CONT</b>, but arrange for the tracee to  be  stopped  at  the
              next  entry  to  or  exit  from  a  system  call,  or  after  execution  of  a single instruction,
              respectively.  (The tracee will also, as usual, be stopped upon receipt of a  signal.)   From  the
              tracer's  perspective,  the  tracee will appear to have been stopped by receipt of a <b>SIGTRAP</b>.  So,
              for <b>PTRACE_SYSCALL</b>, for example, the idea is to inspect the arguments to the system  call  at  the
              first  stop, then do another <b>PTRACE_SYSCALL</b> and inspect the return value of the system call at the
              second stop.  The <u>data</u> argument is treated as for <b>PTRACE_CONT</b>.  (<u>addr</u> is ignored.)

       <b>PTRACE_SET_SYSCALL</b> (since Linux 2.6.16)
              When in syscall-enter-stop, change the number of the system call that is about to be  executed  to
              the  number  specified  in  the  <u>data</u>  argument.  The <u>addr</u> argument is ignored.  This operation is
              currently supported only on arm (and arm64, though only for  backwards  compatibility),  but  most
              other  architectures have other means of accomplishing this (usually by changing the register that
              the userland code passed the system call number in).

       <b>PTRACE_SYSEMU</b>
       <b>PTRACE_SYSEMU_SINGLESTEP</b> (since Linux 2.6.14)
              For <b>PTRACE_SYSEMU</b>, continue and stop on entry to the next system call, which will not be executed.
              See the documentation on syscall-stops below.  For <b>PTRACE_SYSEMU_SINGLESTEP</b>, do the same but  also
              singlestep  if not a system call.  This call is used by programs like User Mode Linux that want to
              emulate all the tracee's system calls.  The <u>data</u> argument is treated as for <b>PTRACE_CONT</b>.  The <u>addr</u>
              argument is ignored.  These operations are currently supported only on x86.

       <b>PTRACE_LISTEN</b> (since Linux 3.4)
              Restart the stopped tracee, but prevent it from executing.  The resulting state of the  tracee  is
              similar  to  a  process  which  has been stopped by a <b>SIGSTOP</b> (or other stopping signal).  See the
              "group-stop" subsection for additional information.  <b>PTRACE_LISTEN</b> works only on tracees  attached
              by <b>PTRACE_SEIZE</b>.

       <b>PTRACE_KILL</b>
              Send the tracee a <b>SIGKILL</b> to terminate it.  (<u>addr</u> and <u>data</u> are ignored.)

              <u>This</u>  <u>operation</u>  <u>is</u>  <u>deprecated;</u> <u>do</u> <u>not</u> <u>use</u> <u>it!</u>  Instead, send a <b>SIGKILL</b> directly using <b><a href="../man2/kill.2.html">kill</a></b>(2) or
              <b><a href="../man2/tgkill.2.html">tgkill</a></b>(2).  The problem with <b>PTRACE_KILL</b> is that it requires the tracee to be in  signal-delivery-
              stop,  otherwise  it may not work (i.e., may complete successfully but won't kill the tracee).  By
              contrast, sending a <b>SIGKILL</b> directly has no such limitation.

       <b>PTRACE_INTERRUPT</b> (since Linux 3.4)
              Stop a tracee.  If the tracee is running or sleeping in kernel  space  and  <b>PTRACE_SYSCALL</b>  is  in
              effect, the system call is interrupted and syscall-exit-stop is reported.  (The interrupted system
              call  is  restarted  when the tracee is restarted.)  If the tracee was already stopped by a signal
              and <b>PTRACE_LISTEN</b> was sent to it, the tracee stops  with  <b>PTRACE_EVENT_STOP</b>  and  <u>WSTOPSIG(status)</u>
              returns  the stop signal.  If any other ptrace-stop is generated at the same time (for example, if
              a signal is sent to the tracee), this ptrace-stop happens.  If none  of  the  above  applies  (for
              example,  if  the  tracee  is  running  in  user  space),  it  stops  with  <b>PTRACE_EVENT_STOP</b> with
              <u>WSTOPSIG(status)</u> == <b>SIGTRAP</b>.  <b>PTRACE_INTERRUPT</b> only works on tracees attached by <b>PTRACE_SEIZE</b>.

       <b>PTRACE_ATTACH</b>
              Attach to the process specified in <u>pid</u>, making it a tracee of the calling process.  The tracee  is
              sent  a  <b>SIGSTOP</b>,  but  will  not  necessarily  have  stopped  by the completion of this call; use
              <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) to wait for the tracee to stop.  See  the  "Attaching  and  detaching"  subsection  for
              additional information.  (<u>addr</u> and <u>data</u> are ignored.)

              Permission    to    perform    a   <b>PTRACE_ATTACH</b>   is   governed   by   a   ptrace   access   mode
              <b>PTRACE_MODE_ATTACH_REALCREDS</b> check; see below.

       <b>PTRACE_SEIZE</b> (since Linux 3.4)
              Attach to the process specified in <u>pid</u>, making  it  a  tracee  of  the  calling  process.   Unlike
              <b>PTRACE_ATTACH</b>,   <b>PTRACE_SEIZE</b>   does   not   stop   the  process.   Group-stops  are  reported  as
              <b>PTRACE_EVENT_STOP</b> and <u>WSTOPSIG(status)</u> returns the stop signal.  Automatically  attached  children
              stop  with <b>PTRACE_EVENT_STOP</b> and <u>WSTOPSIG(status)</u> returns <b>SIGTRAP</b> instead of having <b>SIGSTOP</b> signal
              delivered to them.  <b><a href="../man2/execve.2.html">execve</a></b>(2) does not deliver an extra <b>SIGTRAP</b>.  Only a <b>PTRACE_SEIZE</b>d process can
              accept <b>PTRACE_INTERRUPT</b> and <b>PTRACE_LISTEN</b> commands.   The  "seized"  behavior  just  described  is
              inherited    by    children    that   are   automatically   attached   using   <b>PTRACE_O_TRACEFORK</b>,
              <b>PTRACE_O_TRACEVFORK</b>, and <b>PTRACE_O_TRACECLONE</b>.  <u>addr</u> must be zero.  <u>data</u> contains  a  bit  mask  of
              ptrace options to activate immediately.

              Permission    to    perform    a    <b>PTRACE_SEIZE</b>   is   governed   by   a   ptrace   access   mode
              <b>PTRACE_MODE_ATTACH_REALCREDS</b> check; see below.

       <b>PTRACE_SECCOMP_GET_FILTER</b> (since Linux 4.4)
              This operation allows the tracer to dump the tracee's classic BPF filters.

              <u>addr</u> is an integer specifying the index of the filter to be dumped.  The most  recently  installed
              filter  has  the  index 0.  If <u>addr</u> is greater than the number of installed filters, the operation
              fails with the error <b>ENOENT</b>.

              <u>data</u> is either a pointer to a <u>struct</u> <u>sock_filter</u> array that is  large  enough  to  store  the  BPF
              program, or NULL if the program is not to be stored.

              Upon  success,  the  return  value  is the number of instructions in the BPF program.  If <u>data</u> was
              NULL, then this return value can be used to correctly size the <u>struct</u> <u>sock_filter</u> array passed  in
              a subsequent call.

              This  operation  fails  with  the  error  <b>EACCES</b>  if  the  caller  does not have the <b>CAP_SYS_ADMIN</b>
              capability or if the caller is in strict or filter seccomp mode.  If the  filter  referred  to  by
              <u>addr</u> is not a classic BPF filter, the operation fails with the error <b>EMEDIUMTYPE</b>.

              This  operation  is available if the kernel was configured with both the <b>CONFIG_SECCOMP_FILTER</b> and
              the <b>CONFIG_CHECKPOINT_RESTORE</b> options.

       <b>PTRACE_DETACH</b>
              Restart the stopped tracee as for <b>PTRACE_CONT</b>, but first detach from it.  Under  Linux,  a  tracee
              can  be  detached  in  this way regardless of which method was used to initiate tracing.  (<u>addr</u> is
              ignored.)

       <b>PTRACE_GET_THREAD_AREA</b> (since Linux 2.6.0)
              This operation performs a similar task to <b><a href="../man2/get_thread_area.2.html">get_thread_area</a></b>(2).  It reads the TLS entry in  the  GDT
              whose  index is given in <u>addr</u>, placing a copy of the entry into the <u>struct</u> <u>user_desc</u> pointed to by
              <u>data</u>.  (By contrast with <b><a href="../man2/get_thread_area.2.html">get_thread_area</a></b>(2), the <u>entry_number</u> of the <u>struct</u> <u>user_desc</u> is ignored.)

       <b>PTRACE_SET_THREAD_AREA</b> (since Linux 2.6.0)
              This operation performs a similar task to <b><a href="../man2/set_thread_area.2.html">set_thread_area</a></b>(2).  It sets the TLS entry  in  the  GDT
              whose index is given in <u>addr</u>, assigning it the data supplied in the <u>struct</u> <u>user_desc</u> pointed to by
              <u>data</u>.   (By contrast with <b><a href="../man2/set_thread_area.2.html">set_thread_area</a></b>(2), the <u>entry_number</u> of the <u>struct</u> <u>user_desc</u> is ignored;
              in other words, this ptrace operation can't be used to allocate a free TLS entry.)

       <b>PTRACE_GET_SYSCALL_INFO</b> (since Linux 5.3)
              Retrieve information about the system call that caused the stop.  The information is  placed  into
              the  buffer  pointed  by  the  <u>data</u> argument, which should be a pointer to a buffer of type <u>struct</u>
              <u>ptrace_syscall_info</u>.  The <u>addr</u> argument contains the size of the buffer pointed  to  by  the  <u>data</u>
              argument  (i.e.,  <u>sizeof(struct</u>  <u>ptrace_syscall_info)</u>).   The  return value contains the number of
              bytes available to be written by the kernel.  If the size of the data to be written by the  kernel
              exceeds the size specified by the <u>addr</u> argument, the output data is truncated.

              The <u>ptrace_syscall_info</u> structure contains the following fields:

                  struct ptrace_syscall_info {
                      __u8 op;        /* Type of system call stop */
                      __u32 arch;     /* AUDIT_ARCH_* value; see <a href="../man2/seccomp.2.html">seccomp</a>(2) */
                      __u64 instruction_pointer; /* CPU instruction pointer */
                      __u64 stack_pointer;    /* CPU stack pointer */
                      union {
                          struct {    /* op == PTRACE_SYSCALL_INFO_ENTRY */
                              __u64 nr;       /* System call number */
                              __u64 args[6];  /* System call arguments */
                          } entry;
                          struct {    /* op == PTRACE_SYSCALL_INFO_EXIT */
                              __s64 rval;     /* System call return value */
                              __u8 is_error;  /* System call error flag;
                                                 Boolean: does rval contain
                                                 an error value (-ERRCODE) or
                                                 a nonerror return value? */
                          } exit;
                          struct {    /* op == PTRACE_SYSCALL_INFO_SECCOMP */
                              __u64 nr;       /* System call number */
                              __u64 args[6];  /* System call arguments */
                              __u32 ret_data; /* SECCOMP_RET_DATA portion
                                                 of SECCOMP_RET_TRACE
                                                 return value */
                          } seccomp;
                      };
                  };

              The  <u>op</u>,  <u>arch</u>,  <u>instruction_pointer</u>, and <u>stack_pointer</u> fields are defined for all kinds of ptrace
              system call stops.  The rest of the structure is a union; one should read only those  fields  that
              are meaningful for the kind of system call stop specified by the <u>op</u> field.

              The <u>op</u> field has one of the following values (defined in <u>&lt;linux/ptrace.h&gt;</u>) indicating what type of
              stop occurred and which part of the union is filled:

              <b>PTRACE_SYSCALL_INFO_ENTRY</b>
                     The <u>entry</u> component of the union contains information relating to a system call entry stop.

              <b>PTRACE_SYSCALL_INFO_EXIT</b>
                     The <u>exit</u> component of the union contains information relating to a system call exit stop.

              <b>PTRACE_SYSCALL_INFO_SECCOMP</b>
                     The  <u>seccomp</u> component of the union contains information relating to a <b>PTRACE_EVENT_SECCOMP</b>
                     stop.

              <b>PTRACE_SYSCALL_INFO_NONE</b>
                     No component of the union contains relevant information.

              In case of system call entry or exit  stops,  the  data  returned  by  <b>PTRACE_GET_SYSCALL_INFO</b>  is
              limited  to  type  <b>PTRACE_SYSCALL_INFO_NONE</b>  unless <b>PTRACE_O_TRACESYSGOOD</b> option is set before the
              corresponding system call stop has occurred.

   <b>Death</b> <b>under</b> <b>ptrace</b>
       When a (possibly multithreaded) process receives a killing  signal  (one  whose  disposition  is  set  to
       <b>SIG_DFL</b>  and  whose default action is to kill the process), all threads exit.  Tracees report their death
       to their tracer(s).  Notification of this event is delivered via <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2).

       Note that the killing signal will first cause signal-delivery-stop (on one tracee only), and  only  after
       it is injected by the tracer (or after it was dispatched to a thread which isn't traced), will death from
       the  signal  happen  on  <u>all</u> tracees within a multithreaded process.  (The term "signal-delivery-stop" is
       explained below.)

       <b>SIGKILL</b> does not generate signal-delivery-stop and therefore the tracer can't suppress it.  <b>SIGKILL</b> kills
       even within system calls (syscall-exit-stop is not generated prior to death by <b>SIGKILL</b>).  The net  effect
       is  that  <b>SIGKILL</b>  always  kills  the  process (all its threads), even if some threads of the process are
       ptraced.

       When the tracee calls <b><a href="../man2/_exit.2.html">_exit</a></b>(2), it reports its death to its tracer.  Other threads are not affected.

       When any thread executes <b><a href="../man2/exit_group.2.html">exit_group</a></b>(2), every tracee in its thread group reports its death to its tracer.

       If the <b>PTRACE_O_TRACEEXIT</b> option is on, <b>PTRACE_EVENT_EXIT</b> will happen before actual death.  This  applies
       to  exits via <b><a href="../man2/exit.2.html">exit</a></b>(2), <b><a href="../man2/exit_group.2.html">exit_group</a></b>(2), and signal deaths (except <b>SIGKILL</b>, depending on the kernel version;
       see BUGS below), and when threads are torn down on <b><a href="../man2/execve.2.html">execve</a></b>(2) in a multithreaded process.

       The tracer cannot assume that the ptrace-stopped tracee exists.  There are many scenarios when the tracee
       may die while stopped (such as <b>SIGKILL</b>).  Therefore, the tracer must be prepared to handle an <b>ESRCH</b> error
       on any ptrace operation.  Unfortunately, the same error is returned if  the  tracee  exists  but  is  not
       ptrace-stopped (for commands which require a stopped tracee), or if it is not traced by the process which
       issued  the  ptrace call.  The tracer needs to keep track of the stopped/running state of the tracee, and
       interpret <b>ESRCH</b> as "tracee died unexpectedly" only if it knows that the tracee has been observed to enter
       ptrace-stop.  Note that there is no guarantee that <u>waitpid(WNOHANG)</u> will  reliably  report  the  tracee's
       death  status  if  a  ptrace  operation returned <b>ESRCH</b>.  <u>waitpid(WNOHANG)</u> may return 0 instead.  In other
       words, the tracee may be "not yet fully dead", but already refusing ptrace operations.

       The tracer can't assume  that  the  tracee  <u>always</u>  ends  its  life  by  reporting  <u>WIFEXITED(status)</u>  or
       <u>WIFSIGNALED(status)</u>;  there  are  cases  where  this does not occur.  For example, if a thread other than
       thread group leader does an <b><a href="../man2/execve.2.html">execve</a></b>(2), it  disappears;  its  PID  will  never  be  seen  again,  and  any
       subsequent ptrace stops will be reported under the thread group leader's PID.

   <b>Stopped</b> <b>states</b>
       A tracee can be in two states: running or stopped.  For the purposes of ptrace, a tracee which is blocked
       in a system call (such as <b><a href="../man2/read.2.html">read</a></b>(2), <b><a href="../man2/pause.2.html">pause</a></b>(2), etc.)  is nevertheless considered to be running, even if the
       tracee  is  blocked  for  a long time.  The state of the tracee after <b>PTRACE_LISTEN</b> is somewhat of a gray
       area: it is not in any ptrace-stop (ptrace commands won't work on it,  and  it  will  deliver  <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2)
       notifications),  but it also may be considered "stopped" because it is not executing instructions (is not
       scheduled), and if it was in group-stop before <b>PTRACE_LISTEN</b>,  it  will  not  respond  to  signals  until
       <b>SIGCONT</b> is received.

       There  are  many  kinds  of  states  when the tracee is stopped, and in ptrace discussions they are often
       conflated.  Therefore, it is important to use precise terms.

       In this manual page, any stopped state in which the tracee is ready to accept ptrace  commands  from  the
       tracer  is  called <u>ptrace-stop</u>.  Ptrace-stops can be further subdivided into <u>signal-delivery-stop</u>, <u>group-</u>
       <u>stop</u>, <u>syscall-stop</u>, <u>PTRACE_EVENT</u> <u>stops</u>, and so on.  These stopped states are described in detail below.

       When the running tracee enters ptrace-stop, it notifies its tracer using <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) (or one of the  other
       "wait" system calls).  Most of this manual page assumes that the tracer waits with:

           pid = waitpid(pid_or_minus_1, &amp;status, __WALL);

       Ptrace-stopped tracees are reported as returns with <u>pid</u> greater than 0 and <u>WIFSTOPPED(status)</u> true.

       The <b>__WALL</b> flag does not include the <b>WSTOPPED</b> and <b>WEXITED</b> flags, but implies their functionality.

       Setting  the  <b>WCONTINUED</b>  flag  when calling <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) is not recommended: the "continued" state is per-
       process and consuming it can confuse the real parent of the tracee.

       Use of the <b>WNOHANG</b> flag may cause <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) to return 0 ("no wait results available yet")  even  if  the
       tracer knows there should be a notification.  Example:

           errno = 0;
           ptrace(PTRACE_CONT, pid, 0L, 0L);
           if (errno == ESRCH) {
               /* tracee is dead */
               r = waitpid(tracee, &amp;status, __WALL | WNOHANG);
               /* r can still be 0 here! */
           }

       The  following  kinds  of  ptrace-stops  exist:  signal-delivery-stops,  group-stops, <b>PTRACE_EVENT</b> stops,
       syscall-stops.  They  all  are  reported  by  <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2)  with  <u>WIFSTOPPED(status)</u>  true.   They  may  be
       differentiated  by  examining  the  value <u>status&gt;&gt;8</u>, and if there is ambiguity in that value, by querying
       <b>PTRACE_GETSIGINFO</b>.  (Note: the <u>WSTOPSIG(status)</u> macro can't be used to perform this examination,  because
       it returns the value <u>(status&gt;&gt;8)</u> <u>&amp;</u> <u>0xff</u>.)

   <b>Signal-delivery-stop</b>
       When  a  (possibly  multithreaded)  process  receives  any  signal  except <b>SIGKILL</b>, the kernel selects an
       arbitrary thread which handles the signal.  (If the signal is generated with <b><a href="../man2/tgkill.2.html">tgkill</a></b>(2), the target thread
       can be explicitly selected by the caller.)  If the selected thread is traced, it enters  signal-delivery-
       stop.   At  this  point,  the  signal  is  not yet delivered to the process, and can be suppressed by the
       tracer.  If the tracer doesn't suppress the signal, it passes the signal to the tracee in the next ptrace
       restart operation.  This second step of signal delivery is called <u>signal</u> <u>injection</u> in this  manual  page.
       Note  that  if  the signal is blocked, signal-delivery-stop doesn't happen until the signal is unblocked,
       with the usual exception that <b>SIGSTOP</b> can't be blocked.

       Signal-delivery-stop is observed by the tracer as <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) returning with <u>WIFSTOPPED(status)</u> true, with
       the signal returned by <u>WSTOPSIG(status)</u>.  If the signal is <b>SIGTRAP</b>, this  may  be  a  different  kind  of
       ptrace-stop;  see  the  "Syscall-stops"  and  "execve"  sections  below for details.  If <u>WSTOPSIG(status)</u>
       returns a stopping signal, this may be a group-stop; see below.

   <b>Signal</b> <b>injection</b> <b>and</b> <b>suppression</b>
       After signal-delivery-stop is observed by the tracer, the tracer should restart the tracee with the call

           ptrace(PTRACE_restart, pid, 0, sig)

       where <b>PTRACE_restart</b> is one of the restarting ptrace operations.  If <u>sig</u> is  0,  then  a  signal  is  not
       delivered.   Otherwise,  the  signal <u>sig</u> is delivered.  This operation is called <u>signal</u> <u>injection</u> in this
       manual page, to distinguish it from signal-delivery-stop.

       The <u>sig</u> value may be different from the <u>WSTOPSIG(status)</u> value: the tracer can cause a  different  signal
       to be injected.

       Note  that  a  suppressed  signal  still causes system calls to return prematurely.  In this case, system
       calls will be restarted: the tracer will observe the tracee to reexecute the interrupted system call  (or
       <b><a href="../man2/restart_syscall.2.html">restart_syscall</a></b>(2)  system call for a few system calls which use a different mechanism for restarting) if
       the tracer uses <b>PTRACE_SYSCALL</b>.  Even system calls (such as <b><a href="../man2/poll.2.html">poll</a></b>(2))  which  are  not  restartable  after
       signal are restarted after signal is suppressed; however, kernel bugs exist which cause some system calls
       to fail with <b>EINTR</b> even though no observable signal is injected to the tracee.

       Restarting  ptrace  commands issued in ptrace-stops other than signal-delivery-stop are not guaranteed to
       inject a signal, even if <u>sig</u> is nonzero.  No error is reported; a nonzero  <u>sig</u>  may  simply  be  ignored.
       Ptrace users should not try to "create a new signal" this way: use <b><a href="../man2/tgkill.2.html">tgkill</a></b>(2) instead.

       The  fact  that  signal injection operations may be ignored when restarting the tracee after ptrace stops
       that are not signal-delivery-stops is a cause of confusion among ptrace users.  One typical  scenario  is
       that the tracer observes group-stop, mistakes it for signal-delivery-stop, restarts the tracee with

           ptrace(PTRACE_restart, pid, 0, stopsig)

       with the intention of injecting <u>stopsig</u>, but <u>stopsig</u> gets ignored and the tracee continues to run.

       The  <b>SIGCONT</b>  signal  has a side effect of waking up (all threads of) a group-stopped process.  This side
       effect happens before signal-delivery-stop.  The tracer can't suppress this  side  effect  (it  can  only
       suppress  signal  injection,  which  only causes the <b>SIGCONT</b> handler to not be executed in the tracee, if
       such a handler is installed).  In fact, waking up from group-stop may be followed by signal-delivery-stop
       for signal(s) <u>other</u> <u>than</u> <b>SIGCONT</b>, if they were pending when  <b>SIGCONT</b>  was  delivered.   In  other  words,
       <b>SIGCONT</b> may be not the first signal observed by the tracee after it was sent.

       Stopping  signals  cause  (all threads of) a process to enter group-stop.  This side effect happens after
       signal injection, and therefore can be suppressed by the tracer.

       In Linux 2.4 and earlier, the <b>SIGSTOP</b> signal can't be injected.

       <b>PTRACE_GETSIGINFO</b> can be used to retrieve a  <u>siginfo_t</u>  structure  which  corresponds  to  the  delivered
       signal.   <b>PTRACE_SETSIGINFO</b>  may  be  used  to  modify  it.   If <b>PTRACE_SETSIGINFO</b> has been used to alter
       <u>siginfo_t</u>, the <u>si_signo</u> field and the <u>sig</u> parameter in the restarting command must match,  otherwise  the
       result is undefined.

   <b>Group-stop</b>
       When  a  (possibly  multithreaded) process receives a stopping signal, all threads stop.  If some threads
       are traced, they enter a group-stop.  Note that the stopping signal will first cause signal-delivery-stop
       (on one tracee only), and only after it is injected by the tracer (or after it was dispatched to a thread
       which isn't traced), will group-stop be initiated on <u>all</u> tracees within the  multithreaded  process.   As
       usual, every tracee reports its group-stop separately to the corresponding tracer.

       Group-stop  is  observed  by  the  tracer  as <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) returning with <u>WIFSTOPPED(status)</u> true, with the
       stopping signal available via <u>WSTOPSIG(status)</u>.  The same result is returned by  some  other  classes  of
       ptrace-stops, therefore the recommended practice is to perform the call

           ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo)

       The  call  can  be  avoided  if  the signal is not <b>SIGSTOP</b>, <b>SIGTSTP</b>, <b>SIGTTIN</b>, or <b>SIGTTOU</b>; only these four
       signals are stopping signals.  If the tracer sees something else, it can't be a  group-stop.   Otherwise,
       the  tracer  needs  to  call  <b>PTRACE_GETSIGINFO</b>.   If  <b>PTRACE_GETSIGINFO</b>  fails  with  <b>EINVAL</b>, then it is
       definitely a group-stop.  (Other failure codes are possible, such as  <b>ESRCH</b>  ("no  such  process")  if  a
       <b>SIGKILL</b> killed the tracee.)

       If  tracee  was  attached using <b>PTRACE_SEIZE</b>, group-stop is indicated by <b>PTRACE_EVENT_STOP</b>: <u>status&gt;&gt;16</u> <u>==</u>
       <u>PTRACE_EVENT_STOP</u>.  This allows detection of group-stops without  requiring  an  extra  <b>PTRACE_GETSIGINFO</b>
       call.

       As  of  Linux 2.6.38, after the tracer sees the tracee ptrace-stop and until it restarts or kills it, the
       tracee will not run, and will not send notifications (except <b>SIGKILL</b> death) to the tracer,  even  if  the
       tracer enters into another <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) call.

       The  kernel  behavior  described  in the previous paragraph causes a problem with transparent handling of
       stopping signals.  If the tracer restarts the tracee after group-stop, the stopping signal is effectively
       ignored—the tracee doesn't remain stopped, it runs.  If the tracer  doesn't  restart  the  tracee  before
       entering  into the next <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2), future <b>SIGCONT</b> signals will not be reported to the tracer; this would
       cause the <b>SIGCONT</b> signals to have no effect on the tracee.

       Since Linux 3.4, there is a method to overcome this problem:  instead  of  <b>PTRACE_CONT</b>,  a  <b>PTRACE_LISTEN</b>
       command  can  be  used  to restart a tracee in a way where it does not execute, but waits for a new event
       which it can report via <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) (such as when it is restarted by a <b>SIGCONT</b>).

   <b>PTRACE_EVENT</b> <b>stops</b>
       If the tracer sets <b>PTRACE_O_TRACE_*</b> options, the  tracee  will  enter  ptrace-stops  called  <b>PTRACE_EVENT</b>
       stops.

       <b>PTRACE_EVENT</b>  stops  are  observed  by  the  tracer  as <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2) returning with <u>WIFSTOPPED(status)</u>, and
       <u>WSTOPSIG(status)</u> returns <b>SIGTRAP</b> (or for <b>PTRACE_EVENT_STOP</b>, returns the stopping signal if tracee is in a
       group-stop).  An additional bit is set in the higher byte of the status word: the value <u>status&gt;&gt;8</u> will be

           ((PTRACE_EVENT_foo&lt;&lt;8) | SIGTRAP).

       The following events exist:

       <b>PTRACE_EVENT_VFORK</b>
              Stop before return from <b><a href="../man2/vfork.2.html">vfork</a></b>(2) or <b><a href="../man2/clone.2.html">clone</a></b>(2) with  the  <b>CLONE_VFORK</b>  flag.   When  the  tracee  is
              continued after this stop, it will wait for child to exit/exec before continuing its execution (in
              other words, the usual behavior on <b><a href="../man2/vfork.2.html">vfork</a></b>(2)).

       <b>PTRACE_EVENT_FORK</b>
              Stop before return from <b><a href="../man2/fork.2.html">fork</a></b>(2) or <b><a href="../man2/clone.2.html">clone</a></b>(2) with the exit signal set to <b>SIGCHLD</b>.

       <b>PTRACE_EVENT_CLONE</b>
              Stop before return from <b><a href="../man2/clone.2.html">clone</a></b>(2).

       <b>PTRACE_EVENT_VFORK_DONE</b>
              Stop  before  return  from  <b><a href="../man2/vfork.2.html">vfork</a></b>(2)  or  <b><a href="../man2/clone.2.html">clone</a></b>(2)  with the <b>CLONE_VFORK</b> flag, but after the child
              unblocked this tracee by exiting or execing.

       For all four stops described above, the stop occurs in the parent (i.e., the tracee), not  in  the  newly
       created thread.  <b>PTRACE_GETEVENTMSG</b> can be used to retrieve the new thread's ID.

       <b>PTRACE_EVENT_EXEC</b>
              Stop  before return from <b><a href="../man2/execve.2.html">execve</a></b>(2).  Since Linux 3.0, <b>PTRACE_GETEVENTMSG</b> returns the former thread
              ID.

       <b>PTRACE_EVENT_EXIT</b>
              Stop before exit (including death from <b><a href="../man2/exit_group.2.html">exit_group</a></b>(2)), signal death, or exit caused  by  <b><a href="../man2/execve.2.html">execve</a></b>(2)
              in  a  multithreaded  process.   <b>PTRACE_GETEVENTMSG</b>  returns  the  exit  status.  Registers can be
              examined (unlike when  "real"  exit  happens).   The  tracee  is  still  alive;  it  needs  to  be
              <b>PTRACE_CONT</b>ed or <b>PTRACE_DETACH</b>ed to finish exiting.

       <b>PTRACE_EVENT_STOP</b>
              Stop  induced  by <b>PTRACE_INTERRUPT</b> command, or group-stop, or initial ptrace-stop when a new child
              is attached (only if attached using <b>PTRACE_SEIZE</b>).

       <b>PTRACE_EVENT_SECCOMP</b>
              Stop triggered by a <b><a href="../man2/seccomp.2.html">seccomp</a></b>(2) rule on tracee syscall entry when  <b>PTRACE_O_TRACESECCOMP</b>  has  been
              set  by  the  tracer.   The  seccomp  event message data (from the <b>SECCOMP_RET_DATA</b> portion of the
              seccomp filter rule) can be retrieved with <b>PTRACE_GETEVENTMSG</b>.  The semantics  of  this  stop  are
              described in detail in a separate section below.

       <b>PTRACE_GETSIGINFO</b>   on   <b>PTRACE_EVENT</b>   stops   returns   <b>SIGTRAP</b>   in  <u>si_signo</u>,  with  <u>si_code</u>  set  to
       <u>(event&lt;&lt;8)</u> <u>|</u> <u>SIGTRAP</u>.

   <b>Syscall-stops</b>
       If the tracee was restarted by <b>PTRACE_SYSCALL</b> or <b>PTRACE_SYSEMU</b>, the tracee enters syscall-enter-stop just
       prior to entering any system call (which will not be executed if the  restart  was  using  <b>PTRACE_SYSEMU</b>,
       regardless of any change made to registers at this point or how the tracee is restarted after this stop).
       No  matter  which  method  caused  the  syscall-entry-stop,  if  the  tracer  restarts  the  tracee  with
       <b>PTRACE_SYSCALL</b>, the tracee enters syscall-exit-stop when the  system  call  is  finished,  or  if  it  is
       interrupted  by  a  signal.   (That is, signal-delivery-stop never happens between syscall-enter-stop and
       syscall-exit-stop; it happens <u>after</u> syscall-exit-stop.).  If the tracee  is  continued  using  any  other
       method  (including  <b>PTRACE_SYSEMU</b>),  no  syscall-exit-stop  occurs.  Note that all mentions <b>PTRACE_SYSEMU</b>
       apply equally to <b>PTRACE_SYSEMU_SINGLESTEP</b>.

       However, even if the tracee was continued using <b>PTRACE_SYSCALL</b>, it is not guaranteed that the  next  stop
       will  be  a  syscall-exit-stop.   Other possibilities are that the tracee may stop in a <b>PTRACE_EVENT</b> stop
       (including seccomp stops), exit (if it entered <b><a href="../man2/_exit.2.html">_exit</a></b>(2) or <b><a href="../man2/exit_group.2.html">exit_group</a></b>(2)), be killed by <b>SIGKILL</b>,  or  die
       silently  (if  it  is a thread group leader, the <b><a href="../man2/execve.2.html">execve</a></b>(2) happened in another thread, and that thread is
       not traced by the same tracer; this situation is discussed later).

       Syscall-enter-stop and syscall-exit-stop  are  observed  by  the  tracer  as  <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2)  returning  with
       <u>WIFSTOPPED(status)</u>  true,  and  <u>WSTOPSIG(status)</u> giving <b>SIGTRAP</b>.  If the <b>PTRACE_O_TRACESYSGOOD</b> option was
       set by the tracer, then <u>WSTOPSIG(status)</u> will give the value <u>(SIGTRAP</u> <u>|</u> <u>0x80)</u>.

       Syscall-stops can be distinguished from signal-delivery-stop with <b>SIGTRAP</b> by  querying  <b>PTRACE_GETSIGINFO</b>
       for the following cases:

       <u>si_code</u> &lt;= 0
              <b>SIGTRAP</b>  was  delivered as a result of a user-space action, for example, a system call (<b><a href="../man2/tgkill.2.html">tgkill</a></b>(2),
              <b><a href="../man2/kill.2.html">kill</a></b>(2), <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3), etc.), expiration of a POSIX timer, change  of  state  on  a  POSIX  message
              queue, or completion of an asynchronous I/O operation.

       <u>si_code</u> == SI_KERNEL (0x80)
              <b>SIGTRAP</b> was sent by the kernel.

       <u>si_code</u> == SIGTRAP or <u>si_code</u> == (SIGTRAP|0x80)
              This is a syscall-stop.

       However,  syscall-stops  happen  very often (twice per system call), and performing <b>PTRACE_GETSIGINFO</b> for
       every syscall-stop may be somewhat expensive.

       Some architectures allow the cases to be distinguished by examining registers.  For example, on x86,  <u>rax</u>
       ==  -<b>ENOSYS</b>  in  syscall-enter-stop.  Since <b>SIGTRAP</b> (like any other signal) always happens <u>after</u> syscall-
       exit-stop, and at this point <u>rax</u> almost never contains -<b>ENOSYS</b>,  the  <b>SIGTRAP</b>  looks  like  "syscall-stop
       which  is  not  syscall-enter-stop"; in other words, it looks like a "stray syscall-exit-stop" and can be
       detected this way.  But such detection is fragile and is best avoided.

       Using the <b>PTRACE_O_TRACESYSGOOD</b> option is the recommended method to distinguish syscall-stops from  other
       kinds of ptrace-stops, since it is reliable and does not incur a performance penalty.

       Syscall-enter-stop and syscall-exit-stop are indistinguishable from each other by the tracer.  The tracer
       needs  to  keep  track of the sequence of ptrace-stops in order to not misinterpret syscall-enter-stop as
       syscall-exit-stop or vice versa.  In general, a syscall-enter-stop is always  followed  by  syscall-exit-
       stop,  <b>PTRACE_EVENT</b>  stop,  or  the  tracee's  death; no other kinds of ptrace-stop can occur in between.
       However, note that seccomp stops (see below) can cause  syscall-exit-stops,  without  preceding  syscall-
       entry-stops.   If  seccomp  is  in use, care needs to be taken not to misinterpret such stops as syscall-
       entry-stops.

       If after syscall-enter-stop, the tracer uses a restarting command  other  than  <b>PTRACE_SYSCALL</b>,  syscall-
       exit-stop is not generated.

       <b>PTRACE_GETSIGINFO</b>  on  syscall-stops  returns  <b>SIGTRAP</b>  in  <u>si_signo</u>,  with  <u>si_code</u>  set  to  <b>SIGTRAP</b> or
       <u>(SIGTRAP|0x80)</u>.

   <b>PTRACE_EVENT_SECCOMP</b> <b>stops</b> <b>(Linux</b> <b>3.5</b> <b>to</b> <b>Linux</b> <b>4.7)</b>
       The behavior of <b>PTRACE_EVENT_SECCOMP</b> stops and their interaction with other kinds  of  ptrace  stops  has
       changed  between  kernel  versions.   This documents the behavior from their introduction until Linux 4.7
       (inclusive).  The behavior in later kernel versions is documented in the next section.

       A <b>PTRACE_EVENT_SECCOMP</b> stop occurs whenever a <b>SECCOMP_RET_TRACE</b> rule is triggered.  This  is  independent
       of which methods was used to restart the system call.  Notably, seccomp still runs even if the tracee was
       restarted using <b>PTRACE_SYSEMU</b> and this system call is unconditionally skipped.

       Restarts from this stop will behave as if the stop had occurred right before the system call in question.
       In particular, both <b>PTRACE_SYSCALL</b> and <b>PTRACE_SYSEMU</b> will normally cause a subsequent syscall-entry-stop.
       However,  if  after  the <b>PTRACE_EVENT_SECCOMP</b> the system call number is negative, both the syscall-entry-
       stop and the system call itself will be skipped.  This means that if the system call number  is  negative
       after  a  <b>PTRACE_EVENT_SECCOMP</b>  and  the tracee is restarted using <b>PTRACE_SYSCALL</b>, the next observed stop
       will be a syscall-exit-stop, rather than the syscall-entry-stop that might have been expected.

   <b>PTRACE_EVENT_SECCOMP</b> <b>stops</b> <b>(since</b> <b>Linux</b> <b>4.8)</b>
       Starting with Linux 4.8, the <b>PTRACE_EVENT_SECCOMP</b> stop was reordered to occur between  syscall-entry-stop
       and  syscall-exit-stop.   Note that seccomp no longer runs (and no <b>PTRACE_EVENT_SECCOMP</b> will be reported)
       if the system call is skipped due to <b>PTRACE_SYSEMU</b>.

       Functionally,  a  <b>PTRACE_EVENT_SECCOMP</b>  stop  functions  comparably  to   a   syscall-entry-stop   (i.e.,
       continuations  using  <b>PTRACE_SYSCALL</b> will cause syscall-exit-stops, the system call number may be changed
       and any other modified registers are visible to the to-be-executed system call as well).  Note that there
       may be, but need not have been a preceding syscall-entry-stop.

       After a <b>PTRACE_EVENT_SECCOMP</b> stop, seccomp will be rerun, with a <b>SECCOMP_RET_TRACE</b> rule  now  functioning
       the  same as a <b>SECCOMP_RET_ALLOW</b>.  Specifically, this means that if registers are not modified during the
       <b>PTRACE_EVENT_SECCOMP</b> stop, the system call will then be allowed.

   <b>PTRACE_SINGLESTEP</b> <b>stops</b>
       [Details of these kinds of stops are yet to be documented.]

   <b>Informational</b> <b>and</b> <b>restarting</b> <b>ptrace</b> <b>commands</b>
       Most ptrace commands (all  except  <b>PTRACE_ATTACH</b>,  <b>PTRACE_SEIZE</b>,  <b>PTRACE_TRACEME</b>,  <b>PTRACE_INTERRUPT</b>,  and
       <b>PTRACE_KILL</b>) require the tracee to be in a ptrace-stop, otherwise they fail with <b>ESRCH</b>.

       When  the  tracee is in ptrace-stop, the tracer can read and write data to the tracee using informational
       commands.  These commands leave the tracee in ptrace-stopped state:

           ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);
           ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);
           ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &amp;struct);
           ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &amp;struct);
           ptrace(PTRACE_GETREGSET, pid, NT_foo, &amp;iov);
           ptrace(PTRACE_SETREGSET, pid, NT_foo, &amp;iov);
           ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo);
           ptrace(PTRACE_SETSIGINFO, pid, 0, &amp;siginfo);
           ptrace(PTRACE_GETEVENTMSG, pid, 0, &amp;long_var);
           ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);

       Note that some errors are not reported.  For example, setting signal information (<u>siginfo</u>)  may  have  no
       effect  in  some  ptrace-stops,  yet  the  call  may  succeed  (return  0  and  not  set <u>errno</u>); querying
       <b>PTRACE_GETEVENTMSG</b> may succeed and return some random value if current ptrace-stop is not  documented  as
       returning a meaningful event message.

       The call

           ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);

       affects one tracee.  The tracee's current flags are replaced.  Flags are inherited by new tracees created
       and "auto-attached" via active <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or <b>PTRACE_O_TRACECLONE</b> options.

       Another group of commands makes the ptrace-stopped tracee run.  They have the form:

           ptrace(cmd, pid, 0, sig);

       where <u>cmd</u> is <b>PTRACE_CONT</b>, <b>PTRACE_LISTEN</b>, <b>PTRACE_DETACH</b>, <b>PTRACE_SYSCALL</b>, <b>PTRACE_SINGLESTEP</b>, <b>PTRACE_SYSEMU</b>,
       or  <b>PTRACE_SYSEMU_SINGLESTEP</b>.  If the tracee is in signal-delivery-stop, <u>sig</u> is the signal to be injected
       (if it is nonzero).  Otherwise, <u>sig</u> may be ignored.  (When restarting a tracee from a  ptrace-stop  other
       than signal-delivery-stop, recommended practice is to always pass 0 in <u>sig</u>.)

   <b>Attaching</b> <b>and</b> <b>detaching</b>
       A thread can be attached to the tracer using the call

           ptrace(PTRACE_ATTACH, pid, 0, 0);

       or

           ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);

       <b>PTRACE_ATTACH</b> sends <b>SIGSTOP</b> to this thread.  If the tracer wants this <b>SIGSTOP</b> to have no effect, it needs
       to  suppress  it.   Note  that  if  other signals are concurrently sent to this thread during attach, the
       tracer may see the tracee enter signal-delivery-stop with other signal(s) first!  The usual  practice  is
       to reinject these signals until <b>SIGSTOP</b> is seen, then suppress <b>SIGSTOP</b> injection.  The design bug here is
       that  a  ptrace  attach  and  a concurrently delivered <b>SIGSTOP</b> may race and the concurrent <b>SIGSTOP</b> may be
       lost.

       Since attaching sends <b>SIGSTOP</b> and the tracer usually suppresses it, this may cause a stray  <b>EINTR</b>  return
       from  the  currently  executing  system  call  in  the  tracee, as described in the "Signal injection and
       suppression" section.

       Since Linux 3.4, <b>PTRACE_SEIZE</b> can be used instead of  <b>PTRACE_ATTACH</b>.   <b>PTRACE_SEIZE</b>  does  not  stop  the
       attached  process.   If  you  need  to stop it after attach (or at any other time) without sending it any
       signals, use <b>PTRACE_INTERRUPT</b> command.

       The operation

           ptrace(PTRACE_TRACEME, 0, 0, 0);

       turns the calling thread into a tracee.  The thread continues to  run  (doesn't  enter  ptrace-stop).   A
       common practice is to follow the <b>PTRACE_TRACEME</b> with

           raise(SIGSTOP);

       and allow the parent (which is our tracer now) to observe our signal-delivery-stop.

       If  the  <b>PTRACE_O_TRACEFORK</b>,  <b>PTRACE_O_TRACEVFORK</b>,  or  <b>PTRACE_O_TRACECLONE</b>  options  are in effect, then
       children created by, respectively, <b><a href="../man2/vfork.2.html">vfork</a></b>(2) or <b><a href="../man2/clone.2.html">clone</a></b>(2) with the <b>CLONE_VFORK</b> flag,  <b><a href="../man2/fork.2.html">fork</a></b>(2)  or  <b><a href="../man2/clone.2.html">clone</a></b>(2)
       with  the exit signal set to <b>SIGCHLD</b>, and other kinds of <b><a href="../man2/clone.2.html">clone</a></b>(2), are automatically attached to the same
       tracer which traced their parent.  <b>SIGSTOP</b> is delivered to the children, causing them  to  enter  signal-
       delivery-stop after they exit the system call which created them.

       Detaching of the tracee is performed by:

           ptrace(PTRACE_DETACH, pid, 0, sig);

       <b>PTRACE_DETACH</b>  is  a restarting operation; therefore it requires the tracee to be in ptrace-stop.  If the
       tracee is in signal-delivery-stop, a signal can  be  injected.   Otherwise,  the  <u>sig</u>  parameter  may  be
       silently ignored.

       If the tracee is running when the tracer wants to detach it, the usual solution is to send <b>SIGSTOP</b> (using
       <b><a href="../man2/tgkill.2.html">tgkill</a></b>(2),  to  make sure it goes to the correct thread), wait for the tracee to stop in signal-delivery-
       stop for <b>SIGSTOP</b> and then detach it (suppressing <b>SIGSTOP</b> injection).  A design bug is that this can  race
       with concurrent <b>SIGSTOP</b>s.  Another complication is that the tracee may enter other ptrace-stops and needs
       to be restarted and waited for again, until <b>SIGSTOP</b> is seen.  Yet another complication is to be sure that
       the  tracee  is  not  already  ptrace-stopped,  because  no  signal delivery happens while it is—not even
       <b>SIGSTOP</b>.

       If the tracer dies, all tracees are automatically detached and restarted, unless they were in group-stop.
       Handling of restart from group-stop is currently buggy, but the "as planned" behavior is to leave  tracee
       stopped  and  waiting  for  <b>SIGCONT</b>.   If  the tracee is restarted from signal-delivery-stop, the pending
       signal is injected.

   <b><a href="../man2/execve.2.html">execve</a>(2)</b> <b>under</b> <b>ptrace</b>
       When one thread in a multithreaded process calls <b><a href="../man2/execve.2.html">execve</a></b>(2), the kernel destroys all other threads in  the
       process, and resets the thread ID of the execing thread to the thread group ID (process ID).  (Or, to put
       things another way, when a multithreaded process does an <b><a href="../man2/execve.2.html">execve</a></b>(2), at completion of the call, it appears
       as  though  the  <b><a href="../man2/execve.2.html">execve</a></b>(2)  occurred  in  the  thread  group  leader,  regardless of which thread did the
       <b><a href="../man2/execve.2.html">execve</a></b>(2).)  This resetting of the thread ID looks very confusing to tracers:

       •  All other threads stop in <b>PTRACE_EVENT_EXIT</b> stop, if the  <b>PTRACE_O_TRACEEXIT</b>  option  was  turned  on.
          Then all other threads except the thread group leader report death as if they exited via <b><a href="../man2/_exit.2.html">_exit</a></b>(2) with
          exit code 0.

       •  The  execing  tracee changes its thread ID while it is in the <b><a href="../man2/execve.2.html">execve</a></b>(2).  (Remember, under ptrace, the
          "pid" returned from <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2), or fed into ptrace calls, is the tracee's thread ID.)   That  is,  the
          tracee's  thread  ID  is reset to be the same as its process ID, which is the same as the thread group
          leader's thread ID.

       •  Then a <b>PTRACE_EVENT_EXEC</b> stop happens, if the <b>PTRACE_O_TRACEEXEC</b> option was turned on.

       •  If the thread group leader has reported its <b>PTRACE_EVENT_EXIT</b> stop by this time,  it  appears  to  the
          tracer  that the dead thread leader "reappears from nowhere".  (Note: the thread group leader does not
          report death via <u>WIFEXITED(status)</u> until there is at least one other live thread.  This eliminates the
          possibility that the tracer will see it dying and then reappearing.)  If the thread group  leader  was
          still  alive,  for  the tracer this may look as if thread group leader returns from a different system
          call than it entered, or even "returned from a system call even though it was not in any system call".
          If the thread group leader was not traced (or was traced by a different tracer), then during <b><a href="../man2/execve.2.html">execve</a></b>(2)
          it will appear as if it has become a tracee of the tracer of the execing tracee.

       All of the above effects are the artifacts of the thread ID change in the tracee.

       The <b>PTRACE_O_TRACEEXEC</b> option is the recommended tool for dealing with this situation.  First, it enables
       <b>PTRACE_EVENT_EXEC</b> stop, which occurs before  <b><a href="../man2/execve.2.html">execve</a></b>(2)  returns.   In  this  stop,  the  tracer  can  use
       <b>PTRACE_GETEVENTMSG</b>  to  retrieve  the  tracee's  former thread ID.  (This feature was introduced in Linux
       3.0.)  Second, the <b>PTRACE_O_TRACEEXEC</b> option disables legacy <b>SIGTRAP</b> generation on <b><a href="../man2/execve.2.html">execve</a></b>(2).

       When the tracer receives <b>PTRACE_EVENT_EXEC</b> stop notification, it is guaranteed that  except  this  tracee
       and the thread group leader, no other threads from the process are alive.

       On  receiving  the  <b>PTRACE_EVENT_EXEC</b> stop notification, the tracer should clean up all its internal data
       structures describing the threads of this process, and retain only one data structure—one which describes
       the single still running tracee, with

           thread ID == thread group ID == process ID.

       Example: two threads call <b><a href="../man2/execve.2.html">execve</a></b>(2) at the same time:

       *** we get syscall-enter-stop in thread 1: **
       PID1 execve("/bin/foo", "foo" &lt;unfinished ...&gt;
       *** we issue PTRACE_SYSCALL for thread 1 **
       *** we get syscall-enter-stop in thread 2: **
       PID2 execve("/bin/bar", "bar" &lt;unfinished ...&gt;
       *** we issue PTRACE_SYSCALL for thread 2 **
       *** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **
       *** we get syscall-exit-stop for PID0: **
       PID0 &lt;... execve resumed&gt; )             = 0

       If the <b>PTRACE_O_TRACEEXEC</b> option is <u>not</u> in  effect  for  the  execing  tracee,  and  if  the  tracee  was
       <b>PTRACE_ATTACH</b>ed  rather  that  <b>PTRACE_SEIZE</b>d,  the  kernel  delivers an extra <b>SIGTRAP</b> to the tracee after
       <b><a href="../man2/execve.2.html">execve</a></b>(2) returns.  This is an ordinary signal (similar to one which can be generated by <u>kill</u> <u>-TRAP</u>), not
       a special kind of ptrace-stop.  Employing <b>PTRACE_GETSIGINFO</b> for this signal  returns  <u>si_code</u>  set  to  0
       (<u>SI_USER</u>).  This signal may be blocked by signal mask, and thus may be delivered (much) later.

       Usually, the tracer (for example, <b><a href="../man1/strace.1.html">strace</a></b>(1)) would not want to show this extra post-execve <b>SIGTRAP</b> signal
       to the user, and would suppress its delivery to the tracee (if <b>SIGTRAP</b> is set to <b>SIG_DFL</b>, it is a killing
       signal).   However,  determining  <u>which</u>  <b>SIGTRAP</b> to suppress is not easy.  Setting the <b>PTRACE_O_TRACEEXEC</b>
       option or using <b>PTRACE_SEIZE</b> and thus suppressing this extra <b>SIGTRAP</b> is the recommended approach.

   <b>Real</b> <b>parent</b>
       The ptrace API (ab)uses the standard UNIX parent/child signaling over <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2).  This used to cause the
       real parent of the process to stop receiving several kinds of <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2)  notifications  when  the  child
       process is traced by some other process.

       Many of these bugs have been fixed, but as of Linux 2.6.38 several still exist; see BUGS below.

       As of Linux 2.6.38, the following is believed to work correctly:

       •  exit/death  by  signal  is reported first to the tracer, then, when the tracer consumes the <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2)
          result, to the real parent (to the real parent only when the whole multithreaded process  exits).   If
          the tracer and the real parent are the same process, the report is sent only once.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On   success,   the   <b>PTRACE_PEEK*</b>   operations   return   the   requested  data  (but  see  NOTES),  the
       <b>PTRACE_SECCOMP_GET_FILTER</b>  operation  returns  the  number  of  instructions  in  the  BPF  program,  the
       <b>PTRACE_GET_SYSCALL_INFO</b>  operation returns the number of bytes available to be written by the kernel, and
       other operations return zero.

       On error, all operations return -1, and <u>errno</u> is set to indicate the error.  Since the value returned  by
       a  successful  <b>PTRACE_PEEK*</b>  operation  may  be -1, the caller must clear <u>errno</u> before the call, and then
       check it afterward to determine whether or not an error occurred.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EBUSY</b>  (i386 only) There was an error with allocating or freeing a debug register.

       <b>EFAULT</b> There was an attempt to read from or write to an invalid area in  the  tracer's  or  the  tracee's
              memory,  probably  because  the  area  wasn't  mapped  or accessible.  Unfortunately, under Linux,
              different variations of this fault will return <b>EIO</b> or <b>EFAULT</b> more or less arbitrarily.

       <b>EINVAL</b> An attempt was made to set an invalid option.

       <b>EIO</b>    <u>op</u> is invalid, or an attempt was made to read from or write to an invalid area in the tracer's  or
              the  tracee's  memory, or there was a word-alignment violation, or an invalid signal was specified
              during a restart operation.

       <b>EPERM</b>  The specified process cannot be traced.   This  could  be  because  the  tracer  has  insufficient
              privileges  (the  required  capability  is  <b>CAP_SYS_PTRACE</b>);  unprivileged  processes cannot trace
              processes that they cannot send signals to or those running set-user-ID/set-group-ID programs, for
              obvious reasons.  Alternatively, the process may already be being traced, or (before Linux 2.6.26)
              be <b><a href="../man1/init.1.html">init</a></b>(1) (PID 1).

       <b>ESRCH</b>  The specified process does not exist, or is not currently being traced by the caller,  or  is  not
              stopped (for operations that require a stopped tracee).

</pre><h4><b>STANDARDS</b></h4><pre>
       None.

</pre><h4><b>HISTORY</b></h4><pre>
       SVr4, 4.3BSD.

       Before Linux 2.6.26, <b><a href="../man1/init.1.html">init</a></b>(1), the process with PID 1, may not be traced.

</pre><h4><b>NOTES</b></h4><pre>
       Although arguments to <b>ptrace</b>() are interpreted according to the prototype given, glibc currently declares
       <b>ptrace</b>() as a variadic function with only the <u>op</u> argument fixed.  It is recommended to always supply four
       arguments,  even  if the requested operation does not use them, setting unused/ignored arguments to <u>0L</u> or
       <u>(void</u> <u>*)</u> <u>0</u>.

       A tracees parent continues to be the tracer even if that tracer calls <b><a href="../man2/execve.2.html">execve</a></b>(2).

       The layout of the contents of memory and the USER area  are  quite  operating-system-  and  architecture-
       specific.   The  offset  supplied, and the data returned, might not entirely match with the definition of
       <u>struct</u> <u>user</u>.

       The size of a "word" is determined by the operating-system variant (e.g.,  for  32-bit  Linux  it  is  32
       bits).

       This  page  documents  the  way  the  <b>ptrace</b>()  call  works  currently  in  Linux.   Its behavior differs
       significantly on other flavors of UNIX.  In any case, use of <b>ptrace</b>() is highly specific to the operating
       system and architecture.

   <b>Ptrace</b> <b>access</b> <b>mode</b> <b>checking</b>
       Various parts of the kernel-user-space API (not just  <b>ptrace</b>()  operations),  require  so-called  "ptrace
       access  mode"  checks,  whose  outcome  determines whether an operation is permitted (or, in a few cases,
       causes a "read" operation to return sanitized data).  These checks  are  performed  in  cases  where  one
       process  can  inspect sensitive information about, or in some cases modify the state of, another process.
       The checks are based on factors such as the credentials and capabilities of the two processes, whether or
       not the "target" process is dumpable, and the results of checks performed by any enabled  Linux  Security
       Module (LSM)—for example, SELinux, Yama, or Smack—and by the commoncap LSM (which is always invoked).

       Prior  to  Linux  2.6.27,  all  access checks were of a single type.  Since Linux 2.6.27, two access mode
       levels are distinguished:

       <b>PTRACE_MODE_READ</b>
              For "read" operations or other operations that are less dangerous,  such  as:  <b><a href="../man2/get_robust_list.2.html">get_robust_list</a></b>(2);
              <b><a href="../man2/kcmp.2.html">kcmp</a></b>(2);  reading  <u><a href="file:/proc/">/proc/</a></u>pid<u>/auxv</u>,  <u><a href="file:/proc/">/proc/</a></u>pid<u>/environ</u>,  or  <u><a href="file:/proc/">/proc/</a></u>pid<u>/stat</u>;  or  <b><a href="../man2/readlink.2.html">readlink</a></b>(2)  of a
              <u><a href="file:/proc/">/proc/</a></u>pid<u>/ns/*</u> file.

       <b>PTRACE_MODE_ATTACH</b>
              For "write" operations, or other operations that are more dangerous,  such  as:  ptrace  attaching
              (<b>PTRACE_ATTACH</b>)  to  another  process  or  calling  <b><a href="../man2/process_vm_writev.2.html">process_vm_writev</a></b>(2).  (<b>PTRACE_MODE_ATTACH</b> was
              effectively the default before Linux 2.6.27.)

       Since Linux 4.5, the above access mode checks are combined (ORed) with one of the following modifiers:

       <b>PTRACE_MODE_FSCREDS</b>
              Use the caller's filesystem UID and GID (see <b><a href="../man7/credentials.7.html">credentials</a></b>(7)) or  effective  capabilities  for  LSM
              checks.

       <b>PTRACE_MODE_REALCREDS</b>
              Use  the caller's real UID and GID or permitted capabilities for LSM checks.  This was effectively
              the default before Linux 4.5.

       Because combining one of the credential modifiers with one of the aforementioned access modes is typical,
       some macros are defined in the kernel sources for the combinations:

       <b>PTRACE_MODE_READ_FSCREDS</b>
              Defined as <b>PTRACE_MODE_READ</b> <b>|</b> <b>PTRACE_MODE_FSCREDS</b>.

       <b>PTRACE_MODE_READ_REALCREDS</b>
              Defined as <b>PTRACE_MODE_READ</b> <b>|</b> <b>PTRACE_MODE_REALCREDS</b>.

       <b>PTRACE_MODE_ATTACH_FSCREDS</b>
              Defined as <b>PTRACE_MODE_ATTACH</b> <b>|</b> <b>PTRACE_MODE_FSCREDS</b>.

       <b>PTRACE_MODE_ATTACH_REALCREDS</b>
              Defined as <b>PTRACE_MODE_ATTACH</b> <b>|</b> <b>PTRACE_MODE_REALCREDS</b>.

       One further modifier can be ORed with the access mode:

       <b>PTRACE_MODE_NOAUDIT</b> (since Linux 3.3)
              Don't audit this access mode check.  This modifier is employed for ptrace access mode checks (such
              as checks when reading <u><a href="file:/proc/">/proc/</a></u>pid<u>/stat</u>) that merely cause the output to be filtered  or  sanitized,
              rather  than causing an error to be returned to the caller.  In these cases, accessing the file is
              not a security violation and there is no  reason  to  generate  a  security  audit  record.   This
              modifier suppresses the generation of such an audit record for the particular access check.

       Note  that  all  of the <b>PTRACE_MODE_*</b> constants described in this subsection are kernel-internal, and not
       visible to user space.  The constant names are mentioned here in order to  label  the  various  kinds  of
       ptrace access mode checks that are performed for various system calls and accesses to various pseudofiles
       (e.g.,  under  <u><a href="file:/proc">/proc</a></u>).   These  names  are  used  in other manual pages to provide a simple shorthand for
       labeling the different kernel checks.

       The algorithm employed for ptrace access mode checking determines whether the calling process is  allowed
       to  perform the corresponding action on the target process.  (In the case of opening <u><a href="file:/proc/">/proc/</a></u>pid files, the
       "calling process" is the one opening the file, and the process with the corresponding PID is the  "target
       process".)  The algorithm is as follows:

       (1)  If the calling thread and the target thread are in the same thread group, access is always allowed.

       (2)  If  the  access mode specifies <b>PTRACE_MODE_FSCREDS</b>, then, for the check in the next step, employ the
            caller's filesystem UID and GID.  (As noted in <b><a href="../man7/credentials.7.html">credentials</a></b>(7), the filesystem  UID  and  GID  almost
            always have the same values as the corresponding effective IDs.)

            Otherwise, the access mode specifies <b>PTRACE_MODE_REALCREDS</b>, so use the caller's real UID and GID for
            the  checks in the next step.  (Most APIs that check the caller's UID and GID use the effective IDs.
            For historical reasons, the <b>PTRACE_MODE_REALCREDS</b> check uses the real IDs instead.)

       (3)  Deny access if <u>neither</u> of the following is true:

            •  The real, effective, and saved-set user IDs of the target match the caller's  user  ID,  <u>and</u>  the
               real, effective, and saved-set group IDs of the target match the caller's group ID.

            •  The caller has the <b>CAP_SYS_PTRACE</b> capability in the user namespace of the target.

       (4)  Deny access if the target process "dumpable" attribute has a value other than 1 (<b>SUID_DUMP_USER</b>; see
            the  discussion  of  <b>PR_SET_DUMPABLE</b>  in  <b><a href="../man2/prctl.2.html">prctl</a></b>(2)), and the caller does not have the <b>CAP_SYS_PTRACE</b>
            capability in the user namespace of the target process.

       (5)  The kernel LSM <u>security_ptrace_access_check</u>() interface is  invoked  to  see  if  ptrace  access  is
            permitted.  The results depend on the LSM(s).  The implementation of this interface in the commoncap
            LSM performs the following steps:

            (5.1)  If  the  access mode includes <b>PTRACE_MODE_FSCREDS</b>, then use the caller's <u>effective</u> capability
                   set in the following check; otherwise (the access mode specifies  <b>PTRACE_MODE_REALCREDS</b>,  so)
                   use the caller's <u>permitted</u> capability set.

            (5.2)  Deny access if <u>neither</u> of the following is true:

                   •  The  caller  and  the  target  process  are  in  the same user namespace, and the caller's
                      capabilities are a superset of the target process's <u>permitted</u> capabilities.

                   •  The caller has the <b>CAP_SYS_PTRACE</b> capability in the target process's user namespace.

                   Note  that  the  commoncap  LSM   does   not   distinguish   between   <b>PTRACE_MODE_READ</b>   and
                   <b>PTRACE_MODE_ATTACH</b>.

       (6)  If access has not been denied by any of the preceding steps, then access is allowed.

   <b><a href="file:/proc/sys/kernel/yama/ptrace_scope">/proc/sys/kernel/yama/ptrace_scope</a></b>
       On  systems  with  the  Yama  Linux Security Module (LSM) installed (i.e., the kernel was configured with
       <b>CONFIG_SECURITY_YAMA</b>), the <u><a href="file:/proc/sys/kernel/yama/ptrace_scope">/proc/sys/kernel/yama/ptrace_scope</a></u> file (available since  Linux  3.4)  can  be
       used  to  restrict  the  ability to trace a process with <b>ptrace</b>() (and thus also the ability to use tools
       such as <b><a href="../man1/strace.1.html">strace</a></b>(1) and <b><a href="../man1/gdb.1.html">gdb</a></b>(1)).  The goal of such restrictions is to prevent attack escalation  whereby  a
       compromised  process can ptrace-attach to other sensitive processes (e.g., a GPG agent or an SSH session)
       owned by the user in order to gain additional credentials that may exist in memory and  thus  expand  the
       scope of the attack.

       More precisely, the Yama LSM limits two types of operations:

       •  Any  operation  that  performs  a  ptrace  access  mode <b>PTRACE_MODE_ATTACH</b> check—for example, <b>ptrace</b>()
          <b>PTRACE_ATTACH</b>.  (See the "Ptrace access mode checking" discussion above.)

       •  <b>ptrace</b>() <b>PTRACE_TRACEME</b>.

       A process that has the <b>CAP_SYS_PTRACE</b> capability can update the  <u><a href="file:/proc/sys/kernel/yama/ptrace_scope">/proc/sys/kernel/yama/ptrace_scope</a></u>  file
       with one of the following values:

       0 ("classic ptrace permissions")
              No  additional  restrictions  on  operations  that perform <b>PTRACE_MODE_ATTACH</b> checks (beyond those
              imposed by the commoncap and other LSMs).

              The use of <b>PTRACE_TRACEME</b> is unchanged.

       1 ("restricted ptrace") [default value]
              When performing an operation that requires a <b>PTRACE_MODE_ATTACH</b> check, the  calling  process  must
              either  have  the <b>CAP_SYS_PTRACE</b> capability in the user namespace of the target process or it must
              have a predefined relationship with the target process.  By default, the  predefined  relationship
              is that the target process must be a descendant of the caller.

              A  target  process  can  employ the <b><a href="../man2/prctl.2.html">prctl</a></b>(2) <b>PR_SET_PTRACER</b> operation to declare an additional PID
              that is allowed to perform <b>PTRACE_MODE_ATTACH</b> operations on the target.   See  the  kernel  source
              file <u>Documentation/admin-guide/LSM/Yama.rst</u> (or <u>Documentation/security/Yama.txt</u> before Linux 4.13)
              for further details.

              The use of <b>PTRACE_TRACEME</b> is unchanged.

       2 ("admin-only attach")
              Only  processes with the <b>CAP_SYS_PTRACE</b> capability in the user namespace of the target process may
              perform <b>PTRACE_MODE_ATTACH</b> operations or trace children that employ <b>PTRACE_TRACEME</b>.

       3 ("no attach")
              No process may perform <b>PTRACE_MODE_ATTACH</b> operations or trace children that employ <b>PTRACE_TRACEME</b>.

              Once this value has been written to the file, it cannot be changed.

       With respect to values 1 and 2,  note  that  creating  a  new  user  namespace  effectively  removes  the
       protection  offered  by Yama.  This is because a process in the parent user namespace whose effective UID
       matches the UID of the creator of a child namespace has all capabilities (including <b>CAP_SYS_PTRACE</b>)  when
       performing  operations  within  the  child  user  namespace  (and  further-removed  descendants  of  that
       namespace).   Consequently,  when  a  process  tries  to  use  user  namespaces  to  sandbox  itself,  it
       inadvertently weakens the protections offered by the Yama LSM.

   <b>C</b> <b>library/kernel</b> <b>differences</b>
       At  the  system  call  level, the <b>PTRACE_PEEKTEXT</b>, <b>PTRACE_PEEKDATA</b>, and <b>PTRACE_PEEKUSER</b> operations have a
       different API: they store the result at the address specified by the <u>data</u> parameter, and the return value
       is the error flag.  The glibc wrapper function provides the API given  in  DESCRIPTION  above,  with  the
       result being returned via the function return value.

</pre><h4><b>BUGS</b></h4><pre>
       On hosts with Linux 2.6 kernel headers, <b>PTRACE_SETOPTIONS</b> is declared with a different value than the one
       for  Linux  2.4.   This  leads to applications compiled with Linux 2.6 kernel headers failing when run on
       Linux 2.4.  This can be worked around by redefining <b>PTRACE_SETOPTIONS</b> to <b>PTRACE_OLDSETOPTIONS</b>, if that is
       defined.

       Group-stop notifications are sent to the tracer, but not to real parent.  Last confirmed on 2.6.38.6.

       If a thread group leader is traced and exits by calling <b><a href="../man2/_exit.2.html">_exit</a></b>(2), a <b>PTRACE_EVENT_EXIT</b>  stop  will  happen
       for  it  (if  requested), but the subsequent <b>WIFEXITED</b> notification will not be delivered until all other
       threads exit.  As explained above, if one of other threads calls <b><a href="../man2/execve.2.html">execve</a></b>(2), the death of the thread group
       leader will <u>never</u> be reported.  If the execed thread is not traced by this tracer, the tracer will  never
       know  that  <b><a href="../man2/execve.2.html">execve</a></b>(2)  happened.   One  possible  workaround  is to <b>PTRACE_DETACH</b> the thread group leader
       instead of restarting it in this case.  Last confirmed on 2.6.38.6.

       A <b>SIGKILL</b> signal may still cause a <b>PTRACE_EVENT_EXIT</b> stop  before  actual  signal  death.   This  may  be
       changed  in  the  future;  <b>SIGKILL</b>  is  meant  to  always immediately kill tasks even under ptrace.  Last
       confirmed on Linux 3.13.

       Some system calls return with <b>EINTR</b> if a signal was sent to a tracee, but delivery was suppressed by  the
       tracer.   (This  is  very typical operation: it is usually done by debuggers on every attach, in order to
       not introduce a bogus <b>SIGSTOP</b>).  As of Linux 3.2.9, the following system calls are affected (this list is
       likely incomplete): <b><a href="../man2/epoll_wait.2.html">epoll_wait</a></b>(2), and <b><a href="../man2/read.2.html">read</a></b>(2) from an <b><a href="../man7/inotify.7.html">inotify</a></b>(7) file descriptor.  The usual symptom  of
       this bug is that when you attach to a quiescent process with the command

           strace -p &lt;process-ID&gt;

       then, instead of the usual and expected one-line output such as

           restart_syscall(&lt;... resuming interrupted call ...&gt;_

       or

           select(6, [5], NULL, [5], NULL_

       ('_' denotes the cursor position), you observe more than one line.  For example:

               clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0
               epoll_wait(4,_

       What  is  not visible here is that the process was blocked in <b><a href="../man2/epoll_wait.2.html">epoll_wait</a></b>(2) before <b><a href="../man1/strace.1.html">strace</a></b>(1) has attached
       to it.  Attaching caused <b><a href="../man2/epoll_wait.2.html">epoll_wait</a></b>(2) to return to user space with the error <b>EINTR</b>.  In this  particular
       case,  the program reacted to <b>EINTR</b> by checking the current time, and then executing <b><a href="../man2/epoll_wait.2.html">epoll_wait</a></b>(2) again.
       (Programs which do not expect such "stray" <b>EINTR</b> errors may behave in an unintended way upon an <b><a href="../man1/strace.1.html">strace</a></b>(1)
       attach.)

       Contrary to the normal rules, the glibc wrapper for <b>ptrace</b>() can set <u>errno</u> to zero.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/gdb.1.html">gdb</a></b>(1),  <b><a href="../man1/ltrace.1.html">ltrace</a></b>(1),  <b><a href="../man1/strace.1.html">strace</a></b>(1),  <b><a href="../man2/clone.2.html">clone</a></b>(2),   <b><a href="../man2/execve.2.html">execve</a></b>(2),   <b><a href="../man2/fork.2.html">fork</a></b>(2),   <b><a href="../man2/gettid.2.html">gettid</a></b>(2),   <b><a href="../man2/prctl.2.html">prctl</a></b>(2),   <b><a href="../man2/seccomp.2.html">seccomp</a></b>(2),
       <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2), <b><a href="../man2/tgkill.2.html">tgkill</a></b>(2), <b><a href="../man2/vfork.2.html">vfork</a></b>(2), <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2), <b><a href="../man3/exec.3.html">exec</a></b>(3), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/signal.7.html">signal</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                          <u><a href="../man2/ptrace.2.html">ptrace</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>