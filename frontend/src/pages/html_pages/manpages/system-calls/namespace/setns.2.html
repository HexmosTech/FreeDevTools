<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>setns - reassociate thread with a namespace</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       setns - reassociate thread with a namespace

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>             /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;</b>

       <b>int</b> <b>setns(int</b> <u>fd</u><b>,</b> <b>int</b> <u>nstype</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>setns</b>() system call allows the calling thread to move into different namespaces.  The <u>fd</u> argument is
       one of the following:

       •  a file descriptor referring to one of the magic links in a <u><a href="file:/proc/">/proc/</a></u>pid<u>/ns/</u> directory (or a bind mount to
          such a link);

       •  a PID file descriptor (see <b><a href="../man2/pidfd_open.2.html">pidfd_open</a></b>(2)).

       The <u>nstype</u> argument is interpreted differently in each case.

   <b>fd</b> <b>refers</b> <b>to</b> <b>a</b> <u><b><a href="file:/proc/">/proc/</a></b></u><b>pid</b><u><b>/ns/</b></u> <b>link</b>
       If <u>fd</u> refers to a <u><a href="file:/proc/">/proc/</a></u>pid<u>/ns/</u> link, then <b>setns</b>() reassociates the calling  thread  with  the  namespace
       associated  with  that  link,  subject to any constraints imposed by the <u>nstype</u> argument.  In this usage,
       each call to <b>setns</b>() changes just one of the caller's namespace memberships.

       The <u>nstype</u> argument specifies which type of namespace the calling thread may be reassociated with.   This
       argument can have <u>one</u> of the following values:

       <b>0</b>      Allow any type of namespace to be joined.

       <b>CLONE_NEWCGROUP</b> (since Linux 4.6)
              <u>fd</u> must refer to a cgroup namespace.

       <b>CLONE_NEWIPC</b> (since Linux 3.0)
              <u>fd</u> must refer to an IPC namespace.

       <b>CLONE_NEWNET</b> (since Linux 3.0)
              <u>fd</u> must refer to a network namespace.

       <b>CLONE_NEWNS</b> (since Linux 3.8)
              <u>fd</u> must refer to a mount namespace.

       <b>CLONE_NEWPID</b> (since Linux 3.8)
              <u>fd</u> must refer to a descendant PID namespace.

       <b>CLONE_NEWTIME</b> (since Linux 5.8)
              <u>fd</u> must refer to a time namespace.

       <b>CLONE_NEWUSER</b> (since Linux 3.8)
              <u>fd</u> must refer to a user namespace.

       <b>CLONE_NEWUTS</b> (since Linux 3.0)
              <u>fd</u> must refer to a UTS namespace.

       Specifying <u>nstype</u> as 0 suffices if the caller knows (or does not care) what type of namespace is referred
       to  by  <u>fd</u>.   Specifying  a  nonzero  value for <u>nstype</u> is useful if the caller does not know what type of
       namespace is referred to by <u>fd</u> and wants to ensure that the namespace is  of  a  particular  type.   (The
       caller  might  not  know the type of the namespace referred to by <u>fd</u> if the file descriptor was opened by
       another process and, for example, passed to the caller via a UNIX domain socket.)

   <b>fd</b> <b>is</b> <b>a</b> <b>PID</b> <b>file</b> <b>descriptor</b>
       Since Linux 5.8, <u>fd</u> may refer to a PID file descriptor obtained from <b><a href="../man2/pidfd_open.2.html">pidfd_open</a></b>(2) or <b><a href="../man2/clone.2.html">clone</a></b>(2).  In  this
       usage,  <b>setns</b>() atomically moves the calling thread into one or more of the same namespaces as the thread
       referred to by <u>fd</u>.

       The <u>nstype</u> argument is a bit mask specified by ORing together <u>one</u> <u>or</u> <u>more</u>  of  the  <b>CLONE_NEW*</b>  namespace
       constants  listed  above.   The  caller  is  moved  into  each  of the target thread's namespaces that is
       specified in <u>nstype</u>; the caller's memberships in the remaining namespaces are left unchanged.

       For example, the following code would move the caller into the same user, network, and UTS namespaces  as
       PID 1234, but would leave the caller's other namespace memberships unchanged:

           int fd = pidfd_open(1234, 0);
           setns(fd, CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWUTS);

   <b>Details</b> <b>for</b> <b>specific</b> <b>namespace</b> <b>types</b>
       Note the following details and restrictions when reassociating with specific namespace types:

       User namespaces
              A process reassociating itself with a user namespace must have the <b>CAP_SYS_ADMIN</b> capability in the
              target  user  namespace.   (This necessarily implies that it is only possible to join a descendant
              user  namespace.)   Upon  successfully  joining  a  user  namespace,  a  process  is  granted  all
              capabilities in that namespace, regardless of its user and group IDs.

              A multithreaded process may not change user namespace with <b>setns</b>().

              It  is not permitted to use <b>setns</b>() to reenter the caller's current user namespace.  This prevents
              a caller that has dropped capabilities from regaining those capabilities via a call to <b>setns</b>().

              For security reasons, a process can't join a new user  namespace  if  it  is  sharing  filesystem-
              related attributes (the attributes whose sharing is controlled by the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_FS</b> flag) with
              another process.

              For further details on user namespaces, see <b><a href="../man7/user_namespaces.7.html">user_namespaces</a></b>(7).

       Mount namespaces
              Changing   the   mount  namespace  requires  that  the  caller  possess  both  <b>CAP_SYS_CHROOT</b>  and
              <b>CAP_SYS_ADMIN</b> capabilities in its own user namespace and <b>CAP_SYS_ADMIN</b> in the user namespace  that
              owns the target mount namespace.

              A  process  can't  join  a new mount namespace if it is sharing filesystem-related attributes (the
              attributes whose sharing is controlled by the <b><a href="../man2/clone.2.html">clone</a></b>(2) <b>CLONE_FS</b> flag) with another process.

              See <b><a href="../man7/user_namespaces.7.html">user_namespaces</a></b>(7) for details on the interaction of user namespaces and mount namespaces.

       PID namespaces
              In order to reassociate itself with a new PID namespace, the caller must  have  the  <b>CAP_SYS_ADMIN</b>
              capability  both  in  its  own  user  namespace and in the user namespace that owns the target PID
              namespace.

              Reassociating the PID namespace has somewhat different from other namespace types.   Reassociating
              the  calling  thread with a PID namespace changes only the PID namespace that subsequently created
              child processes of the caller will be placed in; it does not  change  the  PID  namespace  of  the
              caller itself.

              Reassociating  with  a  PID  namespace is allowed only if the target PID namespace is a descendant
              (child, grandchild, etc.)  of, or is the same as, the current PID namespace of the caller.

              For further details on PID namespaces, see <b><a href="../man7/pid_namespaces.7.html">pid_namespaces</a></b>(7).

       Cgroup namespaces
              In order to reassociate itself with a new cgroup namespace, the caller must have the <b>CAP_SYS_ADMIN</b>
              capability both in its own user namespace and in the user namespace that owns  the  target  cgroup
              namespace.

              Using  <b>setns</b>()  to  change  the  caller's  cgroup  namespace  does  not change the caller's cgroup
              memberships.

       Network, IPC, time, and UTS namespaces
              In order to reassociate itself with a new network, IPC, time, or UTS namespace,  the  caller  must
              have  the  <b>CAP_SYS_ADMIN</b>  capability both in its own user namespace and in the user namespace that
              owns the target namespace.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>setns</b>() returns 0.  On failure, -1 is returned and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EBADF</b>  <u>fd</u> is not a valid file descriptor.

       <b>EINVAL</b> <u>fd</u> refers to a namespace whose type does not match that specified in <u>nstype</u>.

       <b>EINVAL</b> There is problem with reassociating the thread with the specified namespace.

       <b>EINVAL</b> The caller tried to join an ancestor (parent, grandparent, and so on) PID namespace.

       <b>EINVAL</b> The caller attempted to join the user namespace in which it is already a member.

       <b>EINVAL</b> The caller shares filesystem (<b>CLONE_FS</b>) state (in  particular,  the  root  directory)  with  other
              processes and tried to join a new user namespace.

       <b>EINVAL</b> The caller is multithreaded and tried to join a new user namespace.

       <b>EINVAL</b> <u>fd</u> is a PID file descriptor and <u>nstype</u> is invalid (e.g., it is 0).

       <b>ENOMEM</b> Cannot allocate sufficient memory to change the specified namespace.

       <b>EPERM</b>  The calling thread did not have the required capability for this operation.

       <b>ESRCH</b>  <u>fd</u> is a PID file descriptor but the process it refers to no longer exists (i.e., it has terminated
              and been waited on).

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>VERSIONS</b></h4><pre>
       Linux 3.0, glibc 2.14.

</pre><h4><b>NOTES</b></h4><pre>
       For further information on the <u><a href="file:/proc/">/proc/</a></u>pid<u>/ns/</u> magic links, see <b><a href="../man7/namespaces.7.html">namespaces</a></b>(7).

       Not  all  of the attributes that can be shared when a new thread is created using <b><a href="../man2/clone.2.html">clone</a></b>(2) can be changed
       using <b>setns</b>().

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below takes two or more arguments.  The first argument specifies the pathname of a  namespace
       file  in  an  existing  <u><a href="file:/proc/">/proc/</a></u>pid<u>/ns/</u>  directory.   The  remaining  arguments  specify  a command and its
       arguments.  The program opens the namespace file, joins that namespace using <b>setns</b>(),  and  executes  the
       specified command inside that namespace.

       The  following shell session demonstrates the use of this program (compiled as a binary named <u>ns_exec</u>) in
       conjunction with the <b>CLONE_NEWUTS</b> example program in the <b><a href="../man2/clone.2.html">clone</a></b>(2) man page (complied as  a  binary  named
       <u>newuts</u>).

       We begin by executing the example program in <b><a href="../man2/clone.2.html">clone</a></b>(2) in the background.  That program creates a child in
       a  separate  UTS  namespace.   The  child  changes the hostname in its namespace, and then both processes
       display the hostnames in their UTS namespaces, so that we can see that they are different.

           $ <b>su</b>                   # Need privilege for namespace operations
           Password:
           # <b>./newuts</b> <b>bizarro</b> <b>&amp;</b>
           [1] 3549
           clone() returned 3550
           uts.nodename in child:  bizarro
           uts.nodename in parent: antero
           # <b>uname</b> <b>-n</b>             # Verify hostname in the shell
           antero

       We then run the program shown below, using it to execute a shell.  Inside that shell, we verify that  the
       hostname is the one set by the child created by the first program:

           # <b>./ns_exec</b> <b>/proc/3550/ns/uts</b> <b><a href="file:/bin/bash">/bin/bash</a></b>
           # <b>uname</b> <b>-n</b>             # Executed in shell started by ns_exec
           bizarro

   <b>Program</b> <b>source</b>
       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           int fd;

           if (argc &lt; 3) {
               fprintf(stderr, "%s /proc/PID/ns/FILE cmd args...\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           /* Get file descriptor for namespace; the file descriptor is opened
              with O_CLOEXEC so as to ensure that it is not inherited by the
              program that is later executed. */

           fd = open(argv[1], O_RDONLY | O_CLOEXEC);
           if (fd == -1)
               err(EXIT_FAILURE, "open");

           if (setns(fd, 0) == -1)       /* Join that namespace */
               err(EXIT_FAILURE, "setns");

           execvp(argv[2], &amp;argv[2]);    /* Execute a command in namespace */
           err(EXIT_FAILURE, "execvp");
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/nsenter.1.html">nsenter</a></b>(1), <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/fork.2.html">fork</a></b>(2), <b><a href="../man2/unshare.2.html">unshare</a></b>(2), <b><a href="../man2/vfork.2.html">vfork</a></b>(2), <b><a href="../man7/namespaces.7.html">namespaces</a></b>(7), <b><a href="../man7/unix.7.html">unix</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                           <u><a href="../man2/setns.2.html">setns</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>