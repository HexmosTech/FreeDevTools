<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sigaction — software signal facilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sigaction — software signal facilities

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;</b>

       struct  sigaction {
               void    (*sa_handler)(int);
               void    (*sa_sigaction)(int, siginfo_t *, void *);
               int     sa_flags;               /* see signal options below */
               sigset_t sa_mask;               /* signal mask to apply */
       };

       <u>int</u>
       <b>sigaction</b>(<u>int</u> <u>sig</u>, <u>const</u> <u>struct</u> <u>sigaction</u> <u>*</u> <u>restrict</u> <u>act</u>, <u>struct</u> <u>sigaction</u> <u>*</u> <u>restrict</u> <u>oact</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  system  defines  a set of signals that may be delivered to a process.  Signal delivery resembles the
       occurrence of a hardware interrupt: the signal is normally blocked from further occurrence,  the  current
       thread  context  is  saved, and a new one is built.  A process may specify a <u>handler</u> to which a signal is
       delivered, or specify that a signal is to be <u>ignored</u>.  A process may also specify that a  default  action
       is  to  be taken by the system when a signal occurs.  A signal may also be <u>blocked</u> for a thread, in which
       case it will not be delivered to that thread until it is <u>unblocked</u>.  The action to be taken  on  delivery
       is  determined  at  the  time of delivery.  Normally, signal handlers execute on the current stack of the
       thread.  This may be changed, on a per-handler basis, so that signals  are  taken  on  a  special  <u>signal</u>
       <u>stack</u>.

       Signal  routines normally execute with the signal that caused their invocation <u>blocked</u>, but other signals
       may yet occur.  A global <u>signal</u> <u>mask</u> defines the set of signals currently  blocked  from  delivery  to  a
       thread.  The signal mask for a thread is initialized from that of its parent (normally empty).  It may be
       changed with a <u><a href="../man2/sigprocmask.2.html">sigprocmask</a></u>(2) or <u><a href="../man3/pthread_sigmask.3.html">pthread_sigmask</a></u>(3) call, or when a signal is delivered to the thread.

       When  a  signal condition arises for a process or thread, the signal is added to a set of signals pending
       for the process or thread.  Whether the signal is directed at the process in general  or  at  a  specific
       thread  depends  on how it is generated.  For signals directed at a specific thread, if the signal is not
       currently <u>blocked</u> by the thread then it is delivered to the thread.  For signals directed at the process,
       if the signal is not currently <u>blocked</u> by all threads then it is delivered to one thread  that  does  not
       have  it  blocked  (the  selection  of which is unspecified).  Signals may be delivered any time a thread
       enters the operating system (e.g., during a system call, page fault or trap,  or  clock  interrupt).   If
       multiple  signals  are  ready to be delivered at the same time, any signals that could be caused by traps
       are delivered first.  Additional signals may be processed at  the  same  time,  with  each  appearing  to
       interrupt  the  handlers  for  the  previous signals before their first instructions.  The set of pending
       signals is returned by the <u><a href="../man2/sigpending.2.html">sigpending</a></u>(2) system call.  When a caught signal  is  delivered,  the  current
       state  of  the  thread  is  saved,  a  new signal mask is calculated (as described below), and the signal
       handler is invoked.  The call to the handler is arranged so that if the signal handling  routine  returns
       normally  the  thread  will  resume  execution  in the context from before the signal's delivery.  If the
       thread wishes to resume in a different context, then it must arrange  to  restore  the  previous  context
       itself.

       When  a  signal  is delivered to a thread a new signal mask is installed for the duration of the process'
       signal handler (or until a <u><a href="../man2/sigprocmask.2.html">sigprocmask</a></u>(2) system call is made).  This mask is formed by taking the  union
       of  the  current  signal  mask  set,  the signal to be delivered, and the signal mask associated with the
       handler to be invoked.

       The <b>sigaction</b>() system call assigns an action for a signal specified by <u>sig</u>.   If  <u>act</u>  is  non-NULL,  it
       specifies  an  action  (SIG_DFL,  SIG_IGN,  or a handler routine) and mask to be used when delivering the
       specified signal.  If <u>oact</u> is non-NULL, the previous handling information for the signal is  returned  to
       the user.

       The  above  declaration  of  <u>struct</u> <u>sigaction</u> is not literal.  It is provided only to list the accessible
       members.  See &lt;<u>sys/signal.h</u>&gt;  for  the  actual  definition.   In  particular,  the  storage  occupied  by
       <u>sa_handler</u>  and  <u>sa_sigaction</u>  overlaps,  and it is nonsensical for an application to attempt to use both
       simultaneously.

       Once a signal handler is installed, it normally remains installed until another <b>sigaction</b>()  system  call
       is  made,  or  an  <u><a href="../man2/execve.2.html">execve</a></u>(2)  is  performed.   A  signal-specific  default action may be reset by setting
       <u>sa_handler</u> to SIG_DFL.  The defaults are  process  termination,  possibly  with  core  dump;  no  action;
       stopping  the  process;  or  continuing the process.  See the signal list below for each signal's default
       action.  If <u>sa_handler</u> is SIG_DFL, the default action for the signal is to discard the signal, and  if  a
       signal is pending, the pending signal is discarded even if the signal is masked.  If <u>sa_handler</u> is set to
       SIG_IGN current and pending instances of the signal are ignored and discarded.

       Options may be specified by setting <u>sa_flags</u>.  The meaning of the various bits is as follows:

             SA_NOCLDSTOP    If  this bit is set when installing a catching function for the SIGCHLD signal, the
                             SIGCHLD signal will be generated only when a child process exits, not when a  child
                             process stops.

             SA_NOCLDWAIT    If this bit is set when calling <b>sigaction</b>() for the SIGCHLD signal, the system will
                             not  create  zombie  processes  when  children of the calling process exit.  If the
                             calling process subsequently issues a <u><a href="../man2/wait.2.html">wait</a></u>(2) (or equivalent), it blocks until  all
                             of  the calling process's child processes terminate, and then returns a value of -1
                             with <u>errno</u> set to ECHILD.  The same effect of avoiding zombie creation can also  be
                             achieved by setting <u>sa_handler</u> for SIGCHLD to SIG_IGN.

             SA_ONSTACK      If  this  bit is set, the system will deliver the signal to the process on a <u>signal</u>
                             <u>stack</u>, specified by each thread with <u><a href="../man2/sigaltstack.2.html">sigaltstack</a></u>(2).

             SA_NODEFER      If this bit is set, further occurrences of the  delivered  signal  are  not  masked
                             during the execution of the handler.

             SA_RESETHAND    If  this  bit is set, the handler is reset back to SIG_DFL at the moment the signal
                             is delivered.

             SA_RESTART      See paragraph below.

             SA_SIGINFO      If this bit is set, the handler function  is  assumed  to  be  pointed  to  by  the
                             <u>sa_sigaction</u>  member of <u>struct</u> <u>sigaction</u> and should match the prototype shown above
                             or as below in “EXAMPLES”.  This bit should not be set when  assigning  SIG_DFL  or
                             SIG_IGN.

       If  a signal is caught during the system calls listed below, the call may be forced to terminate with the
       error EINTR, the call may return with a data  transfer  shorter  than  requested,  or  the  call  may  be
       restarted.   Restart  of  pending  calls  is  requested  by  setting the SA_RESTART bit in <u>sa_flags</u>.  The
       affected system  calls  include  <u><a href="../man2/open.2.html">open</a></u>(2),  <u><a href="../man2/read.2.html">read</a></u>(2),  <u><a href="../man2/write.2.html">write</a></u>(2),  <u><a href="../man2/sendto.2.html">sendto</a></u>(2),  <u><a href="../man2/recvfrom.2.html">recvfrom</a></u>(2),  <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2)  and
       <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2)  on a communications channel or a slow device (such as a terminal, but not a regular file) and
       during a <u><a href="../man2/wait.2.html">wait</a></u>(2) or <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2).  However, calls that have already committed are not restarted, but  instead
       return a partial success (for example, a short read count).

       After  a  <u><a href="../man3/pthread_create.3.html">pthread_create</a></u>(3) the signal mask is inherited by the new thread and the set of pending signals
       and the signal stack for the new thread are empty.

       After a <u><a href="../man2/fork.2.html">fork</a></u>(2) or <u><a href="../man2/vfork.2.html">vfork</a></u>(2) all signals, the signal mask, the signal  stack,  and  the  restart/interrupt
       flags are inherited by the child.

       The  <u><a href="../man2/execve.2.html">execve</a></u>(2) system call reinstates the default action for all signals which were caught and resets all
       signals to be caught on the user stack.  Ignored signals remain ignored;  the  signal  mask  remains  the
       same; signals that restart pending system calls continue to do so.

       The following is a list of all signals with names as in the include file &lt;<u>signal.h</u>&gt;:

       <b>NAME</b>            <b>Default</b> <b>Action</b>          <b>Description</b>
       SIGHUP          terminate process       terminal line hangup
       SIGINT          terminate process       interrupt program
       SIGQUIT         create core image       quit program
       SIGILL          create core image       illegal instruction
       SIGTRAP         create core image       trace trap
       SIGABRT         create core image       <u><a href="../man3/abort.3.html">abort</a></u>(3) call (formerly SIGIOT)
       SIGEMT          create core image       emulate instruction executed
       SIGFPE          create core image       floating-point exception
       SIGKILL         terminate process       kill program
       SIGBUS          create core image       bus error
       SIGSEGV         create core image       segmentation violation
       SIGSYS          create core image       non-existent system call invoked
       SIGPIPE         terminate process       write on a pipe with no reader
       SIGALRM         terminate process       real-time timer expired
       SIGTERM         terminate process       software termination signal
       SIGURG          discard signal          urgent condition present on socket
       SIGSTOP         stop process            stop (cannot be caught or ignored)
       SIGTSTP         stop process            stop signal generated from keyboard
       SIGCONT         discard signal          continue after stop
       SIGCHLD         discard signal          child status has changed
       SIGTTIN         stop process            background read attempted from control terminal
       SIGTTOU         stop process            background write attempted to control terminal
       SIGIO           discard signal          I/O is possible on a descriptor (see <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2))
       SIGXCPU         terminate process       cpu time limit exceeded (see <u><a href="../man2/setrlimit.2.html">setrlimit</a></u>(2))
       SIGXFSZ         terminate process       file size limit exceeded (see <u><a href="../man2/setrlimit.2.html">setrlimit</a></u>(2))
       SIGVTALRM       terminate process       virtual time alarm (see <u><a href="../man2/setitimer.2.html">setitimer</a></u>(2))
       SIGPROF         terminate process       profiling timer alarm (see <u><a href="../man2/setitimer.2.html">setitimer</a></u>(2))
       SIGWINCH        discard signal          window size change
       SIGINFO         discard signal          status request from keyboard
       SIGUSR1         terminate process       user defined signal 1
       SIGUSR2         terminate process       user defined signal 2

</pre><h4><b>NOTE</b></h4><pre>
       The <u>sa_mask</u> field specified in <u>act</u> is not allowed to block SIGKILL or SIGSTOP.  Any attempt to do so will
       be silently ignored.

       The  following  functions are either reentrant or not interruptible by signals and are async-signal safe.
       Therefore applications may invoke them, without restriction, from signal-catching  functions  or  from  a
       child process after calling <u><a href="../man2/fork.2.html">fork</a></u>(2) in a multi-threaded process:

       Base Interfaces:

       <b>_Exit</b>(),  <b>_exit</b>(),  <b>accept</b>(),  <b>access</b>(),  <b>alarm</b>(),  <b>bind</b>(),  <b>cfgetispeed</b>(), <b>cfgetospeed</b>(), <b>cfsetispeed</b>(),
       <b>cfsetospeed</b>(), <b>chdir</b>(), <b>chmod</b>(), <b>chown</b>(), <b>close</b>(), <b>connect</b>(), <b>creat</b>(), <b>dup</b>(), <b>dup2</b>(), <b>execl</b>(),  <b>execle</b>(),
       <b>execv</b>(),  <b>execve</b>(),  <b>faccessat</b>(),  <b>fchdir</b>(), <b>fchmod</b>(), <b>fchmodat</b>(), <b>fchown</b>(), <b>fchownat</b>(), <b>fcntl</b>(), <b>fork</b>(),
       <b>fstat</b>(), <b>fstatat</b>(), <b>fsync</b>(), <b>ftruncate</b>(), <b>getegid</b>(),  <b>geteuid</b>(),  <b>getgid</b>(),  <b>getgroups</b>(),  <b>getpeername</b>(),
       <b>getpgrp</b>(),   <b>getpid</b>(),  <b>getppid</b>(),  <b>getsockname</b>(),  <b>getsockopt</b>(),  <b>getuid</b>(),  <b>kill</b>(),  <b>link</b>(),  <b>linkat</b>(),
       <b>listen</b>(), <b>lseek</b>(),  <b>lstat</b>(),  <b>mkdir</b>(),  <b>mkdirat</b>(),  <b>mkfifo</b>(),  <b>mkfifoat</b>(),  <b>mknod</b>(),  <b>mknodat</b>(),  <b>open</b>(),
       <b>openat</b>(),   <b>pause</b>(),   <b>pipe</b>(),   <b>poll</b>(),   <b>pselect</b>(),  <b>pthread_sigmask</b>(),  <b>raise</b>(),  <b>read</b>(),  <b>readlink</b>(),
       <b>readlinkat</b>(), <b>recv</b>(), <b>recvfrom</b>(), <b>recvmsg</b>(), <b>rename</b>(), <b>renameat</b>(), <b>rmdir</b>(), <b>select</b>(), <b>send</b>(),  <b>sendmsg</b>(),
       <b>sendto</b>(),  <b>setgid</b>(),  <b>setpgid</b>(),  <b>setsid</b>(), <b>setsockopt</b>(), <b>setuid</b>(), <b>shutdown</b>(), <b>sigaction</b>(), <b>sigaddset</b>(),
       <b>sigdelset</b>(),  <b>sigemptyset</b>(),  <b>sigfillset</b>(),   <b>sigismember</b>(),   <b>signal</b>(),   <b>sigpending</b>(),   <b>sigprocmask</b>(),
       <b>sigsuspend</b>(),  <b>sleep</b>(),  <b>sockatmark</b>(), <b>socket</b>(), <b>socketpair</b>(), <b>stat</b>(), <b>symlink</b>(), <b>symlinkat</b>(), <b>tcdrain</b>(),
       <b>tcflow</b>(), <b>tcflush</b>(), <b>tcgetattr</b>(), <b>tcgetpgrp</b>(), <b>tcsendbreak</b>(), <b>tcsetattr</b>(), <b>tcsetpgrp</b>(), <b>time</b>(),  <b>times</b>(),
       <b>umask</b>(), <b>uname</b>(), <b>unlink</b>(), <b>unlinkat</b>(), <b>utime</b>(), <b>wait</b>(), <b>waitpid</b>(), <b>write</b>().

       X/Open Systems Interfaces:

       <b>sigpause</b>(), <b>sigset</b>(), <b>utimes</b>().

       Realtime Interfaces:

       <b>aio_error</b>(), <b>clock_gettime</b>(), <b>timer_getoverrun</b>(), <b>aio_return</b>(), <b>fdatasync</b>(), <b>sigqueue</b>(), <b>timer_gettime</b>(),
       <b>aio_suspend</b>(), <b>sem_post</b>(), <b>timer_settime</b>().

       Base Interfaces not specified as async-signal safe by POSIX:

       <b>fpathconf</b>(), <b>pathconf</b>(), <b>sysconf</b>().

       Base Interfaces not specified as async-signal safe by POSIX, but planned to be:

       <b>ffs</b>(),  <b>htonl</b>(), <b>htons</b>(), <b>memccpy</b>(), <b>memchr</b>(), <b>memcmp</b>(), <b>memcpy</b>(), <b>memmove</b>(), <b>memset</b>(), <b>ntohl</b>(), <b>ntohs</b>(),
       <b>stpcpy</b>(), <b>stpncpy</b>(), <b>strcat</b>(), <b>strchr</b>(), <b>strcmp</b>(), <b>strcpy</b>(), <b>strcspn</b>(), <b>strlen</b>(),  <b>strncat</b>(),  <b>strncmp</b>(),
       <b>strncpy</b>(),   <b>strnlen</b>(),  <b>strpbrk</b>(),  <b>strrchr</b>(),  <b>strspn</b>(),  <b>strstr</b>(),  <b>strtok_r</b>(),  <b>wcpcpy</b>(),  <b>wcpncpy</b>(),
       <b>wcscat</b>(), <b>wcschr</b>(), <b>wcscmp</b>(), <b>wcscpy</b>(), <b>wcscspn</b>(), <b>wcslen</b>(), <b>wcsncat</b>(), <b>wcsncmp</b>(), <b>wcsncpy</b>(),  <b>wcsnlen</b>(),
       <b>wcspbrk</b>(),   <b>wcsrchr</b>(),  <b>wcsspn</b>(),  <b>wcsstr</b>(),  <b>wcstok</b>(),  <b>wmemchr</b>(),  <b>wmemcmp</b>(),  <b>wmemcpy</b>(),  <b>wmemmove</b>(),
       <b>wmemset</b>().

       Extension Interfaces:

       <b>accept4</b>(), <b>bindat</b>(), <b>close_range</b>(), <b>closefrom</b>(), <b>connectat</b>(), <b>eaccess</b>(), <b>ffsl</b>(), <b>ffsll</b>(), <b>flock</b>(), <b>fls</b>(),
       <b>flsl</b>(), <b>flsll</b>(), <b>futimesat</b>(), <b>pipe2</b>(), <b>strlcat</b>().  <b>strlcpy</b>(), <b>strsep</b>().

       In addition, reading or writing <u>errno</u> is async-signal safe.

       All functions not in the above lists are considered to be unsafe with respect to  signals.   That  is  to
       say,  the  behaviour  of  such  functions  is  undefined  when they are called from a signal handler that
       interrupted an unsafe function.  In general though, signal handlers should do  little  more  than  set  a
       flag; most other actions are not safe.

       Also,  it  is  good  practice to make a copy of the global variable <u>errno</u> and restore it before returning
       from the signal handler.  This protects against the side effect of <u>errno</u> being set  by  functions  called
       from inside the signal handler.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The  <b>sigaction</b>()  function  returns the value 0 if successful; otherwise the value -1 is returned and the
       global variable <u>errno</u> is set to indicate the error.

</pre><h4><b>EXAMPLES</b></h4><pre>
       There are three possible prototypes the handler may match:

             ANSI C:
                    <u>void</u> <b>handler</b>(<u>int</u>);

             Traditional BSD style:
                    <u>void</u> <b>handler</b>(<u>int</u>, <u>int</u> <u>code</u>, <u>struct</u> <u>sigcontext</u> <u>*scp</u>);

             POSIX SA_SIGINFO:
                    <u>void</u> <b>handler</b>(<u>int</u>, <u>siginfo_t</u> <u>*info</u>, <u>ucontext_t</u> <u>*uap</u>);

       The handler function should match the SA_SIGINFO prototype if the SA_SIGINFO bit is set in <u>sa_flags</u>.   It
       then  should  be  pointed  to  by  the <u>sa_sigaction</u> member of <u>struct</u> <u>sigaction</u>.  Note that you should not
       assign SIG_DFL or SIG_IGN this way.

       If the SA_SIGINFO flag is not set, the handler function should match either the ANSI C or traditional BSD
       prototype and be pointed to by the <u>sa_handler</u> member of <u>struct</u> <u>sigaction</u>.  In  practice,  FreeBSD  always
       sends  the three arguments of the latter and since the ANSI C prototype is a subset, both will work.  The
       <u>sa_handler</u> member declaration in FreeBSD include files is that of ANSI C (as required  by  POSIX),  so  a
       function  pointer of a BSD-style function needs to be casted to compile without warning.  The traditional
       BSD style is not portable and since its capabilities are a full subset of a SA_SIGINFO handler,  its  use
       is deprecated.

       The <u>sig</u> argument is the signal number, one of the SIG... values from &lt;<u>signal.h</u>&gt;.

       The  <u>code</u>  argument  of the BSD-style handler and the <u>si_code</u> member of the <u>info</u> argument to a SA_SIGINFO
       handler contain a numeric code explaining the cause of the signal, usually one of the SI_... values  from
       &lt;<u>sys/signal.h</u>&gt; or codes specific to a signal, i.e., one of the FPE_... values for SIGFPE.

       The <u>scp</u> argument to a BSD-style handler points to an instance of <u>struct</u> <u>sigcontext</u>.

       The <u>uap</u> argument to a POSIX SA_SIGINFO handler points to an instance of ucontext_t.

</pre><h4><b>ERRORS</b></h4><pre>
       The <b>sigaction</b>() system call will fail and no new signal handler will be installed if one of the following
       occurs:

       [EINVAL]           The <u>sig</u> argument is not a valid signal number.

       [EINVAL]           An attempt is made to ignore or supply a handler for SIGKILL or SIGSTOP.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/kill.1.html">kill</a></u>(1),  <u><a href="../man2/kill.2.html">kill</a></u>(2),  <u><a href="../man2/ptrace.2.html">ptrace</a></u>(2), <u><a href="../man2/setitimer.2.html">setitimer</a></u>(2), <u><a href="../man2/setrlimit.2.html">setrlimit</a></u>(2), <u><a href="../man2/sigaltstack.2.html">sigaltstack</a></u>(2), <u><a href="../man2/sigpending.2.html">sigpending</a></u>(2), <u><a href="../man2/sigprocmask.2.html">sigprocmask</a></u>(2),
       <u><a href="../man2/sigsuspend.2.html">sigsuspend</a></u>(2), <u><a href="../man2/wait.2.html">wait</a></u>(2), <u><a href="../man3/fpsetmask.3.html">fpsetmask</a></u>(3), <u><a href="../man3/setjmp.3.html">setjmp</a></u>(3), <u><a href="../man3/siginfo.3.html">siginfo</a></u>(3), <u><a href="../man3/siginterrupt.3.html">siginterrupt</a></u>(3), <u><a href="../man3/sigsetops.3.html">sigsetops</a></u>(3),  <u><a href="../man3/ucontext.3.html">ucontext</a></u>(3),
       <u><a href="../man4/tty.4.html">tty</a></u>(4)

</pre><h4><b>STANDARDS</b></h4><pre>
       The  <b>sigaction</b>()  system  call is expected to conform to ISO/IEC 9945-1:1990 (“POSIX.1”).  The SA_ONSTACK
       and SA_RESTART flags are Berkeley extensions, as  are  the  signals,  SIGTRAP,  SIGEMT,  SIGBUS,  SIGSYS,
       SIGURG,  SIGIO, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH, and SIGINFO.  Those signals are available
       on most  BSD-derived  systems.   The  SA_NODEFER  and  SA_RESETHAND  flags  are  intended  for  backwards
       compatibility  with  other  operating  systems.   The  SA_NOCLDSTOP, and SA_NOCLDWAIT flags are featuring
       options commonly found in other operating systems.  The flags are approved by Version  2  of  the  Single
       UNIX Specification (“SUSv2”), along with the option to avoid zombie creation by ignoring SIGCHLD.

Debian                                            June 29, 2020                                     <u><a href="../man2/SIGACTION.2.html">SIGACTION</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>