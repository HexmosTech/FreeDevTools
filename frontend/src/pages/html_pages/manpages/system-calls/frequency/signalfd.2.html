<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>signalfd - create a file descriptor for accepting signals</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       signalfd - create a file descriptor for accepting signals

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/signalfd.h&gt;</b>

       <b>int</b> <b>signalfd(int</b> <u>fd</u><b>,</b> <b>const</b> <b>sigset_t</b> <b>*</b><u>mask</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>signalfd</b>()  creates  a  file  descriptor that can be used to accept signals targeted at the caller.  This
       provides an alternative to the use of a signal handler or <b><a href="../man2/sigwaitinfo.2.html">sigwaitinfo</a></b>(2), and has the advantage that  the
       file descriptor may be monitored by <b><a href="../man2/select.2.html">select</a></b>(2), <b><a href="../man2/poll.2.html">poll</a></b>(2), and <b><a href="../man7/epoll.7.html">epoll</a></b>(7).

       The  <u>mask</u> argument specifies the set of signals that the caller wishes to accept via the file descriptor.
       This argument is a  signal  set  whose  contents  can  be  initialized  using  the  macros  described  in
       <b><a href="../man3/sigsetops.3.html">sigsetops</a></b>(3).   Normally,  the  set  of  signals to be received via the file descriptor should be blocked
       using <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2), to prevent the signals being handled according to their default  dispositions.   It
       is  not  possible to receive <b>SIGKILL</b> or <b>SIGSTOP</b> signals via a signalfd file descriptor; these signals are
       silently ignored if specified in <u>mask</u>.

       If the <u>fd</u> argument is -1, then the call creates a new file  descriptor  and  associates  the  signal  set
       specified  in  <u>mask</u>  with  that  file descriptor.  If <u>fd</u> is not -1, then it must specify a valid existing
       signalfd file descriptor, and <u>mask</u>  is  used  to  replace  the  signal  set  associated  with  that  file
       descriptor.

       Starting  with  Linux 2.6.27, the following values may be bitwise ORed in <u>flags</u> to change the behavior of
       <b>signalfd</b>():

       <b>SFD_NONBLOCK</b>  Set the <b>O_NONBLOCK</b> file status flag on the open file description (see <b><a href="../man2/open.2.html">open</a></b>(2)) referred  to
                     by  the  new file descriptor.  Using this flag saves extra calls to <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) to achieve the
                     same result.

       <b>SFD_CLOEXEC</b>   Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the new file descriptor.  See the description of
                     the <b>O_CLOEXEC</b> flag in <b><a href="../man2/open.2.html">open</a></b>(2) for reasons why this may be useful.

       Up to Linux 2.6.26, the <u>flags</u> argument is unused, and must be specified as zero.

       <b>signalfd</b>() returns a file descriptor that supports the following operations:

       <b><a href="../man2/read.2.html">read</a></b>(2)
              If one or more of the signals specified in <u>mask</u> is  pending  for  the  process,  then  the  buffer
              supplied  to  <b><a href="../man2/read.2.html">read</a></b>(2)  is  used to return one or more <u>signalfd_siginfo</u> structures (see below) that
              describe the signals.  The <b><a href="../man2/read.2.html">read</a></b>(2) returns information for as many signals as are pending and will
              fit in the supplied buffer.  The buffer must be at least  <u>sizeof(struct</u>  <u>signalfd_siginfo)</u>  bytes.
              The return value of the <b><a href="../man2/read.2.html">read</a></b>(2) is the total number of bytes read.

              As  a consequence of the <b><a href="../man2/read.2.html">read</a></b>(2), the signals are consumed, so that they are no longer pending for
              the process (i.e.,  will  not  be  caught  by  signal  handlers,  and  cannot  be  accepted  using
              <b><a href="../man2/sigwaitinfo.2.html">sigwaitinfo</a></b>(2)).

              If  none  of  the signals in <u>mask</u> is pending for the process, then the <b><a href="../man2/read.2.html">read</a></b>(2) either blocks until
              one of the signals in <u>mask</u> is generated for the process, or fails with the  error  <b>EAGAIN</b>  if  the
              file descriptor has been made nonblocking.

       <b><a href="../man2/poll.2.html">poll</a></b>(2)
       <b><a href="../man2/select.2.html">select</a></b>(2)
       (and similar)
              The  file  descriptor is readable (the <b><a href="../man2/select.2.html">select</a></b>(2) <u>readfds</u> argument; the <b><a href="../man2/poll.2.html">poll</a></b>(2) <b>POLLIN</b> flag) if one
              or more of the signals in <u>mask</u> is pending for the process.

              The  signalfd  file  descriptor  also  supports  the  other  file-descriptor  multiplexing   APIs:
              <b><a href="../man2/pselect.2.html">pselect</a></b>(2), <b><a href="../man2/ppoll.2.html">ppoll</a></b>(2), and <b><a href="../man7/epoll.7.html">epoll</a></b>(7).

       <b><a href="../man2/close.2.html">close</a></b>(2)
              When  the  file  descriptor  is no longer required it should be closed.  When all file descriptors
              associated with the same signalfd object have been closed, the resources for object are  freed  by
              the kernel.

   <b>The</b> <b>signalfd_siginfo</b> <b>structure</b>
       The  format  of the <u>signalfd_siginfo</u> structure(s) returned by <b><a href="../man2/read.2.html">read</a></b>(2)s from a signalfd file descriptor is
       as follows:

           struct signalfd_siginfo {
               uint32_t ssi_signo;    /* Signal number */
               int32_t  ssi_errno;    /* Error number (unused) */
               int32_t  ssi_code;     /* Signal code */
               uint32_t ssi_pid;      /* PID of sender */
               uint32_t ssi_uid;      /* Real UID of sender */
               int32_t  ssi_fd;       /* File descriptor (SIGIO) */
               uint32_t ssi_tid;      /* Kernel timer ID (POSIX timers)
               uint32_t ssi_band;     /* Band event (SIGIO) */
               uint32_t ssi_overrun;  /* POSIX timer overrun count */
               uint32_t ssi_trapno;   /* Trap number that caused signal */
               int32_t  ssi_status;   /* Exit status or signal (SIGCHLD) */
               int32_t  ssi_int;      /* Integer sent by <a href="../man3/sigqueue.3.html">sigqueue</a>(3) */
               uint64_t ssi_ptr;      /* Pointer sent by <a href="../man3/sigqueue.3.html">sigqueue</a>(3) */
               uint64_t ssi_utime;    /* User CPU time consumed (SIGCHLD) */
               uint64_t ssi_stime;    /* System CPU time consumed
                                         (SIGCHLD) */
               uint64_t ssi_addr;     /* Address that generated signal
                                         (for hardware-generated signals) */
               uint16_t ssi_addr_lsb; /* Least significant bit of address
                                         (SIGBUS; since Linux 2.6.37) */
               uint8_t  pad[<u>X</u>];       /* Pad size to 128 bytes (allow for
                                         additional fields in the future) */
           };

       Each of the fields in this structure  is  analogous  to  the  similarly  named  field  in  the  <u>siginfo_t</u>
       structure.   The  <u>siginfo_t</u>  structure  is  described  in  <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2).   Not all fields in the returned
       <u>signalfd_siginfo</u> structure will be valid for a specific signal; the set of valid fields can be determined
       from the value returned in the <u>ssi_code</u> field.  This field is the analog of the <u>siginfo_t</u> <u>si_code</u>  field;
       see <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2) for details.

   <b><a href="../man2/fork.2.html">fork</a>(2)</b> <b>semantics</b>
       After  a  <b><a href="../man2/fork.2.html">fork</a></b>(2),  the  child  inherits a copy of the signalfd file descriptor.  A <b><a href="../man2/read.2.html">read</a></b>(2) from the file
       descriptor in the child will return information about signals queued to the child.

   <b>Semantics</b> <b>of</b> <b>file</b> <b>descriptor</b> <b>passing</b>
       As with other file descriptors, signalfd file descriptors can be passed to another  process  via  a  UNIX
       domain  socket (see <b><a href="../man7/unix.7.html">unix</a></b>(7)).  In the receiving process, a <b><a href="../man2/read.2.html">read</a></b>(2) from the received file descriptor will
       return information about signals queued to that process.

   <b><a href="../man2/execve.2.html">execve</a>(2)</b> <b>semantics</b>
       Just like any other file descriptor, a signalfd file descriptor remains open across an <b><a href="../man2/execve.2.html">execve</a></b>(2),  unless
       it  has been marked for close-on-exec (see <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2)).  Any signals that were available for reading before
       the <b><a href="../man2/execve.2.html">execve</a></b>(2) remain available to the newly loaded program.  (This is  analogous  to  traditional  signal
       semantics, where a blocked signal that is pending remains pending across an <b><a href="../man2/execve.2.html">execve</a></b>(2).)

   <b>Thread</b> <b>semantics</b>
       The  semantics  of signalfd file descriptors in a multithreaded program mirror the standard semantics for
       signals.  In other words, when a thread reads from a signalfd file descriptor, it will read  the  signals
       that are directed to the thread itself and the signals that are directed to the process (i.e., the entire
       thread  group).   (A  thread  will  not be able to read signals that are directed to other threads in the
       process.)

   <b><a href="../man7/epoll.7.html">epoll</a>(7)</b> <b>semantics</b>
       If a process  adds  (via  <b><a href="../man2/epoll_ctl.2.html">epoll_ctl</a></b>(2))  a  signalfd  file  descriptor  to  an  <b><a href="../man7/epoll.7.html">epoll</a></b>(7)  instance,  then
       <b><a href="../man2/epoll_wait.2.html">epoll_wait</a></b>(2)  returns  events only for signals sent to that process.  In particular, if the process then
       uses <b><a href="../man2/fork.2.html">fork</a></b>(2) to create a child process, then the child will be able to <b><a href="../man2/read.2.html">read</a></b>(2) signals that are  sent  to
       it  using  the  signalfd  file  descriptor,  but  <b><a href="../man2/epoll_wait.2.html">epoll_wait</a></b>(2)  will <b>not</b> indicate that the signalfd file
       descriptor is ready.  In this scenario, a possible workaround  is  that  after  the  <b><a href="../man2/fork.2.html">fork</a></b>(2),  the  child
       process  can close the signalfd file descriptor that it inherited from the parent process and then create
       another signalfd file descriptor and add it to the epoll instance.  Alternatively,  the  parent  and  the
       child  could  delay  creating  their  (separate)  signalfd  file descriptors and adding them to the epoll
       instance until after the call to <b><a href="../man2/fork.2.html">fork</a></b>(2).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>signalfd</b>() returns a signalfd file descriptor; this is either a new file  descriptor  (if  <u>fd</u>
       was  -1), or <u>fd</u> if <u>fd</u> was a valid signalfd file descriptor.  On error, -1 is returned and <u>errno</u> is set to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EBADF</b>  The <u>fd</u> file descriptor is not a valid file descriptor.

       <b>EINVAL</b> <u>fd</u> is not a valid signalfd file descriptor.

       <b>EINVAL</b> <u>flags</u> is invalid; or, in Linux 2.6.26 or earlier, <u>flags</u> is nonzero.

       <b>EMFILE</b> The per-process limit on the number of open file descriptors has been reached.

       <b>ENFILE</b> The system-wide limit on the total number of open files has been reached.

       <b>ENODEV</b> Could not mount (internal) anonymous inode device.

       <b>ENOMEM</b> There was insufficient memory to create a new signalfd file descriptor.

</pre><h4><b>VERSIONS</b></h4><pre>
   <b>C</b> <b>library/kernel</b> <b>differences</b>
       The underlying Linux system call requires an additional argument, <u>size_t</u> <u>sizemask</u>,  which  specifies  the
       size  of  the <u>mask</u> argument.  The glibc <b>signalfd</b>() wrapper function does not include this argument, since
       it provides the required value for the underlying system call.

       There are two underlying Linux system calls: <b>signalfd</b>() and the  more  recent  <b>signalfd4</b>().   The  former
       system  call  does  not  implement  a <u>flags</u> argument.  The latter system call implements the <u>flags</u> values
       described above.  Starting with glibc 2.9, the <b>signalfd</b>() wrapper function will use <b>signalfd4</b>() where  it
       is available.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>signalfd</b>()
              Linux 2.6.22, glibc 2.8.

       <b>signalfd4</b>()
              Linux 2.6.27.

</pre><h4><b>NOTES</b></h4><pre>
       A  process  can  create  multiple  signalfd file descriptors.  This makes it possible to accept different
       signals on different file descriptors.  (This may be useful if  monitoring  the  file  descriptors  using
       <b><a href="../man2/select.2.html">select</a></b>(2),  <b><a href="../man2/poll.2.html">poll</a></b>(2),  or  <b><a href="../man7/epoll.7.html">epoll</a></b>(7): the arrival of different signals will make different file descriptors
       ready.)  If a signal appears in the <u>mask</u> of more than one of the file descriptors,  then  occurrences  of
       that signal can be read (once) from any one of the file descriptors.

       Attempts to include <b>SIGKILL</b> and <b>SIGSTOP</b> in <u>mask</u> are silently ignored.

       The  signal mask employed by a signalfd file descriptor can be viewed via the entry for the corresponding
       file descriptor in the process's <u><a href="file:/proc/">/proc/</a></u>pid<u>/fdinfo</u> directory.  See <b><a href="../man5/proc.5.html">proc</a></b>(5) for further details.

   <b>Limitations</b>
       The signalfd mechanism can't be used to receive signals that are synchronously  generated,  such  as  the
       <b>SIGSEGV</b>  signal  that  results from accessing an invalid memory address or the <b>SIGFPE</b> signal that results
       from an arithmetic error.  Such signals can be caught only via signal handler.

       As described above, in normal usage one blocks the signals that will  be  accepted  via  <b>signalfd</b>().   If
       spawning  a  child process to execute a helper program (that does not need the signalfd file descriptor),
       then, after the call to <b><a href="../man2/fork.2.html">fork</a></b>(2),  you  will  normally  want  to  unblock  those  signals  before  calling
       <b><a href="../man2/execve.2.html">execve</a></b>(2),  so  that  the  helper program can see any signals that it expects to see.  Be aware, however,
       that this won't be possible in the case of a helper program spawned behind  the  scenes  by  any  library
       function  that  the  program  may  call.  In such cases, one must fall back to using a traditional signal
       handler that writes to a file descriptor monitored by <b><a href="../man2/select.2.html">select</a></b>(2), <b><a href="../man2/poll.2.html">poll</a></b>(2), or <b><a href="../man7/epoll.7.html">epoll</a></b>(7).

</pre><h4><b>BUGS</b></h4><pre>
       Before Linux 2.6.25, the <u>ssi_ptr</u> and <u>ssi_int</u> fields are not filled in with the data accompanying a signal
       sent by <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3).

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below accepts the signals <b>SIGINT</b> and <b>SIGQUIT</b> via a signalfd  file  descriptor.   The  program
       terminates  after  accepting  a  <b>SIGQUIT</b> signal.  The following shell session demonstrates the use of the
       program:

           $ <b>./signalfd_demo</b>
           <b>^C</b>                   # Control-C generates SIGINT
           Got SIGINT
           <b>^C</b>
           Got SIGINT
           <b>^\</b>                    # Control-\ generates SIGQUIT
           Got SIGQUIT
           $

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/signalfd.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int
       main(void)
       {
           int                      sfd;
           ssize_t                  s;
           sigset_t                 mask;
           struct signalfd_siginfo  fdsi;

           sigemptyset(&amp;mask);
           sigaddset(&amp;mask, SIGINT);
           sigaddset(&amp;mask, SIGQUIT);

           /* Block signals so that they aren't handled
              according to their default dispositions. */

           if (sigprocmask(SIG_BLOCK, &amp;mask, NULL) == -1)
               err(EXIT_FAILURE, "sigprocmask");

           sfd = signalfd(-1, &amp;mask, 0);
           if (sfd == -1)
               err(EXIT_FAILURE, "signalfd");

           for (;;) {
               s = read(sfd, &amp;fdsi, sizeof(fdsi));
               if (s != sizeof(fdsi))
                   err(EXIT_FAILURE, "read");

               if (fdsi.ssi_signo == SIGINT) {
                   printf("Got SIGINT\n");
               } else if (fdsi.ssi_signo == SIGQUIT) {
                   printf("Got SIGQUIT\n");
                   exit(EXIT_SUCCESS);
               } else {
                   printf("Read unexpected signal\n");
               }
           }
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/eventfd.2.html">eventfd</a></b>(2), <b><a href="../man2/poll.2.html">poll</a></b>(2), <b><a href="../man2/read.2.html">read</a></b>(2), <b><a href="../man2/select.2.html">select</a></b>(2), <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2), <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2), <b><a href="../man2/sigwaitinfo.2.html">sigwaitinfo</a></b>(2), <b><a href="../man2/timerfd_create.2.html">timerfd_create</a></b>(2),
       <b><a href="../man3/sigsetops.3.html">sigsetops</a></b>(3), <b><a href="../man3/sigwait.3.html">sigwait</a></b>(3), <b><a href="../man7/epoll.7.html">epoll</a></b>(7), <b><a href="../man7/signal.7.html">signal</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                        <u><a href="../man2/signalfd.2.html">signalfd</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>