<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sigaltstack - set and/or get signal stack context</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sigaltstack - set and/or get signal stack context

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;</b>

       <b>int</b> <b>sigaltstack(const</b> <b>stack_t</b> <b>*_Nullable</b> <b>restrict</b> <u>ss</u><b>,</b>
                       <b>stack_t</b> <b>*_Nullable</b> <b>restrict</b> <u>old_ss</u><b>);</b>

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>sigaltstack</b>():
           _XOPEN_SOURCE &gt;= 500
               || /* Since glibc 2.12: */ _POSIX_C_SOURCE &gt;= 200809L
               || /* glibc &lt;= 2.19: */ _BSD_SOURCE

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sigaltstack</b>()  allows  a  thread  to  define a new alternate signal stack and/or retrieve the state of an
       existing alternate signal stack.  An alternate signal stack is used during  the  execution  of  a  signal
       handler if the establishment of that handler (see <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2)) requested it.

       The normal sequence of events for using an alternate signal stack is the following:

       1. Allocate an area of memory to be used for the alternate signal stack.

       2. Use <b>sigaltstack</b>() to inform the system of the existence and location of the alternate signal stack.

       3. When  establishing  a  signal  handler  using  <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2), inform the system that the signal handler
          should be executed on the alternate signal stack by specifying the <b>SA_ONSTACK</b> flag.

       The <u>ss</u> argument is used to specify a new alternate signal stack, while the <u>old_ss</u>  argument  is  used  to
       retrieve  information  about  the currently established signal stack.  If we are interested in performing
       just one of these tasks, then the other argument can be specified as NULL.

       The <u>stack_t</u> type used to type the arguments of this function is defined as follows:

           typedef struct {
               void  *ss_sp;     /* Base address of stack */
               int    ss_flags;  /* Flags */
               size_t ss_size;   /* Number of bytes in stack */
           } stack_t;

       To establish a new alternate signal stack, the fields of this structure are set as follows:

       <u>ss.ss_flags</u>
              This field contains either 0, or the following flag:

              <b>SS_AUTODISARM</b> (since Linux 4.7)
                     Clear the alternate signal stack settings on entry to the signal handler.  When the  signal
                     handler returns, the previous alternate signal stack settings are restored.

                     This  flag  was  added in order to make it safe to switch away from the signal handler with
                     <b><a href="../man3/swapcontext.3.html">swapcontext</a></b>(3).  Without this flag, a subsequently handled signal will corrupt the state of
                     the  switched-away  signal  handler.   On  kernels  where  this  flag  is  not   supported,
                     <b>sigaltstack</b>() fails with the error <b>EINVAL</b> when this flag is supplied.

       <u>ss.ss_sp</u>
              This  field  specifies the starting address of the stack.  When a signal handler is invoked on the
              alternate stack, the kernel automatically aligns the address  given  in  <u>ss.ss_sp</u>  to  a  suitable
              address boundary for the underlying hardware architecture.

       <u>ss.ss_size</u>
              This  field  specifies the size of the stack.  The constant <b>SIGSTKSZ</b> is defined to be large enough
              to cover the usual size requirements for an alternate signal stack, and the  constant  <b>MINSIGSTKSZ</b>
              defines the minimum size required to execute a signal handler.

       To  disable  an  existing stack, specify <u>ss.ss_flags</u> as <b>SS_DISABLE</b>.  In this case, the kernel ignores any
       other flags in <u>ss.ss_flags</u> and the remaining fields in <u>ss</u>.

       If <u>old_ss</u> is not NULL, then it is used to return information about the alternate signal stack  which  was
       in  effect  prior  to  the  call to <b>sigaltstack</b>().  The <u>old_ss.ss_sp</u> and <u>old_ss.ss_size</u> fields return the
       starting address and size of that stack.  The <u>old_ss.ss_flags</u> may return either of the following values:

       <b>SS_ONSTACK</b>
              The thread is currently executing on the alternate signal stack.  (Note that it is not possible to
              change the alternate signal stack if the thread is currently executing on it.)

       <b>SS_DISABLE</b>
              The alternate signal stack is currently disabled.

              Alternatively, this value is returned if the thread is currently executing on an alternate  signal
              stack  that was established using the <b>SS_AUTODISARM</b> flag.  In this case, it is safe to switch away
              from the signal handler  with  <b><a href="../man3/swapcontext.3.html">swapcontext</a></b>(3).   It  is  also  possible  to  set  up  a  different
              alternative signal stack using a further call to <b>sigaltstack</b>().

       <b>SS_AUTODISARM</b>
              The alternate signal stack has been marked to be autodisarmed as described above.

       By  specifying  <u>ss</u>  as  NULL, and <u>old_ss</u> as a non-NULL value, one can obtain the current settings for the
       alternate signal stack without changing them.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>sigaltstack</b>() returns 0 on success, or -1 on failure with <u>errno</u> set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> Either <u>ss</u> or <u>old_ss</u> is not NULL and points to an area outside of the process's address space.

       <b>EINVAL</b> <u>ss</u> is not NULL and the <u>ss_flags</u> field contains an invalid flag.

       <b>ENOMEM</b> The specified size of the new alternate signal stack <u>ss.ss_size</u> was less than <b>MINSIGSTKSZ</b>.

       <b>EPERM</b>  An attempt was made to change the alternate signal stack while it was active (i.e., the thread was
              already executing on the current alternate signal stack).

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>                                                                   │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │ <b>sigaltstack</b>()                                                               │ Thread safety │ MT-Safe │
       └─────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

       <b>SS_AUTODISARM</b> is a Linux extension.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001, SUSv2, SVr4.

</pre><h4><b>NOTES</b></h4><pre>
       The most common usage of an alternate signal stack is to handle the <b>SIGSEGV</b> signal that is  generated  if
       the  space  available  for  the  standard  stack is exhausted: in this case, a signal handler for <b>SIGSEGV</b>
       cannot be invoked on the standard stack; if we wish to handle it, we must use an alternate signal stack.

       Establishing an alternate signal stack is useful if a thread expects that it  may  exhaust  its  standard
       stack.   This  may  occur,  for example, because the stack grows so large that it encounters the upwardly
       growing heap, or it reaches a limit established by a call  to  <b>setrlimit(RLIMIT_STACK,</b>  <b>&amp;rlim)</b>.   If  the
       standard  stack  is  exhausted, the kernel sends the thread a <b>SIGSEGV</b> signal.  In these circumstances the
       only way to catch this signal is on an alternate signal stack.

       On most hardware architectures supported by Linux, stacks  grow  downward.   <b>sigaltstack</b>()  automatically
       takes account of the direction of stack growth.

       Functions called from a signal handler executing on an alternate signal stack will also use the alternate
       signal stack.  (This also applies to any handlers invoked for other signals while the thread is executing
       on  the alternate signal stack.)  Unlike the standard stack, the system does not automatically extend the
       alternate signal stack.  Exceeding the allocated  size  of  the  alternate  signal  stack  will  lead  to
       unpredictable results.

       A  successful call to <b><a href="../man2/execve.2.html">execve</a></b>(2) removes any existing alternate signal stack.  A child process created via
       <b><a href="../man2/fork.2.html">fork</a></b>(2) inherits a copy of its parent's alternate signal stack settings.  The same is  also  true  for  a
       child  process  created  using  <b><a href="../man2/clone.2.html">clone</a></b>(2),  unless  the  clone  flags  include <b>CLONE_VM</b> and do not include
       <b>CLONE_VFORK</b>, in which case any alternate signal stack that was established in the parent is  disabled  in
       the child process.

       <b>sigaltstack</b>()  supersedes  the  older  <b>sigstack</b>()  call.  For backward compatibility, glibc also provides
       <b>sigstack</b>().  All new applications should be written using <b>sigaltstack</b>().

   <b>History</b>
       4.2BSD had a <b>sigstack</b>() system call.  It used a slightly different struct, and had the major disadvantage
       that the caller had to know the direction of stack growth.

</pre><h4><b>BUGS</b></h4><pre>
       In Linux 2.2 and earlier, the only flag that could be specified in <u>ss.sa_flags</u> was  <b>SS_DISABLE</b>.   In  the
       lead  up  to  the  release  of  the  Linux  2.4 kernel, a change was made to allow <b>sigaltstack</b>() to allow
       <u>ss.ss_flags==SS_ONSTACK</u> with the same meaning as <u>ss.ss_flags==0</u> (i.e., the  inclusion  of  <b>SS_ONSTACK</b>  in
       <u>ss.ss_flags</u>  is a no-op).  On other implementations, and according to POSIX.1, <b>SS_ONSTACK</b> appears only as
       a reported flag in  <u>old_ss.ss_flags</u>.   On  Linux,  there  is  no  need  ever  to  specify  <b>SS_ONSTACK</b>  in
       <u>ss.ss_flags</u>,  and indeed doing so should be avoided on portability grounds: various other systems give an
       error if <b>SS_ONSTACK</b> is specified in <u>ss.ss_flags</u>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following code segment demonstrates the  use  of  <b>sigaltstack</b>()  (and  <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2))  to  install  an
       alternate signal stack that is employed by a handler for the <b>SIGSEGV</b> signal:

           stack_t ss;

           ss.ss_sp = malloc(SIGSTKSZ);
           if (ss.ss_sp == NULL) {
               perror("malloc");
               exit(EXIT_FAILURE);
           }

           ss.ss_size = SIGSTKSZ;
           ss.ss_flags = 0;
           if (sigaltstack(&amp;ss, NULL) == -1) {
               perror("sigaltstack");
               exit(EXIT_FAILURE);
           }

           sa.sa_flags = SA_ONSTACK;
           sa.sa_handler = handler();      /* Address of a signal handler */
           sigemptyset(&amp;sa.sa_mask);
           if (sigaction(SIGSEGV, &amp;sa, NULL) == -1) {
               perror("sigaction");
               exit(EXIT_FAILURE);
           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/execve.2.html">execve</a></b>(2), <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2), <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2), <b><a href="../man3/siglongjmp.3.html">siglongjmp</a></b>(3), <b><a href="../man3/sigsetjmp.3.html">sigsetjmp</a></b>(3), <b><a href="../man7/signal.7.html">signal</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                     <u><a href="../man2/sigaltstack.2.html">sigaltstack</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>