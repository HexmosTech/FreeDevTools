<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sigaltstack — set and/or get signal stack context</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sigaltstack — set and/or get signal stack context

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;</b>

       typedef struct {
               char    *ss_sp;
               size_t  ss_size;
               int     ss_flags;
       } stack_t;

       <u>int</u>
       <b>sigaltstack</b>(<u>const</u> <u>stack_t</u> <u>*</u> <u>restrict</u> <u>ss</u>, <u>stack_t</u> <u>*</u> <u>restrict</u> <u>oss</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>sigaltstack</b>() system call allows defining an alternate stack on which signals are to be processed for
       the current thread.  If <u>ss</u> is non-zero, it specifies a pointer to and the size of a <u>signal</u> <u>stack</u> on which
       to  deliver  signals.   When  a  signal's action indicates its handler should execute on the signal stack
       (specified with a <u><a href="../man2/sigaction.2.html">sigaction</a></u>(2) system call), the  system  checks  to  see  if  the  thread  is  currently
       executing  on  that  stack.   If  the  thread  is not currently executing on the signal stack, the system
       arranges a switch to the signal stack for the duration of the signal handler's execution.

       An active stack cannot be modified.

       If SS_DISABLE is set in <u>ss_flags</u>, <u>ss_sp</u> and <u>ss_size</u> are ignored and the signal stack will be disabled.  A
       disabled stack will cause all signals to be taken on the regular user stack.  If the stack is  later  re-
       enabled then all signals that were specified to be processed on an alternate stack will resume doing so.

       If  <u>oss</u>  is  non-zero,  the  current signal stack state is returned.  The <u>ss_flags</u> field will contain the
       value SS_ONSTACK if the thread is currently on a signal stack and  SS_DISABLE  if  the  signal  stack  is
       currently disabled.

</pre><h4><b>NOTES</b></h4><pre>
       The  value SIGSTKSZ is defined to be the number of bytes/chars that would be used to cover the usual case
       when allocating an alternate stack area.  The following code fragment is typically used  to  allocate  an
       alternate stack.

             if ((sigstk.ss_sp = malloc(SIGSTKSZ)) == NULL)
                     /* error return */
             sigstk.ss_size = SIGSTKSZ;
             sigstk.ss_flags = 0;
             if (sigaltstack(&amp;sigstk, NULL) &lt; 0)
                     perror("sigaltstack");
       An  alternative  approach is provided for programs with signal handlers that require a specific amount of
       stack space other than the default  size.   The  value  MINSIGSTKSZ  is  defined  to  be  the  number  of
       bytes/chars  that  is  required  by  the  operating  system to implement the alternate stack feature.  In
       computing an alternate stack size, programs should add MINSIGSTKSZ to their stack requirements  to  allow
       for the operating system overhead.

       Signal  stacks  are  automatically adjusted for the direction of stack growth and alignment requirements.
       Signal stacks may or may not be protected by the hardware and are not ``grown'' automatically as is  done
       for  the  normal stack.  If the stack overflows and this space is not protected unpredictable results may
       occur.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>sigaltstack</b>() function returns the value 0 if successful; otherwise the value -1 is returned and  the
       global variable <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The  <b>sigaltstack</b>() system call will fail and the signal stack context will remain unchanged if one of the
       following occurs.

       [EFAULT]           Either <u>ss</u> or <u>oss</u> points to memory that is not a valid  part  of  the  process  address
                          space.

       [EPERM]            An attempt was made to modify an active stack.

       [EINVAL]           The <u>ss_flags</u> field was invalid.

       [ENOMEM]           Size of alternate stack area is less than or equal to MINSIGSTKSZ.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/sigaction.2.html">sigaction</a></u>(2), <u><a href="../man3/setjmp.3.html">setjmp</a></u>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The predecessor to <b>sigaltstack</b>(), the <b>sigstack</b>() system call, appeared in 4.2BSD.

Debian                                             May 6, 2010                                    <u><a href="../man2/SIGALTSTACK.2.html">SIGALTSTACK</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>