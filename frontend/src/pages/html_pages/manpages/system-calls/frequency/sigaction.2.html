<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sigaction, rt_sigaction - examine and change a signal action</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sigaction, rt_sigaction - examine and change a signal action

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;</b>

       <b>int</b> <b>sigaction(int</b> <u>signum</u><b>,</b>
                     <b>const</b> <b>struct</b> <b>sigaction</b> <b>*_Nullable</b> <b>restrict</b> <u>act</u><b>,</b>
                     <b>struct</b> <b>sigaction</b> <b>*_Nullable</b> <b>restrict</b> <u>oldact</u><b>);</b>

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>sigaction</b>():
           _POSIX_C_SOURCE

       <u>siginfo_t</u>:
           _POSIX_C_SOURCE &gt;= 199309L

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>sigaction</b>()  system  call  is  used to change the action taken by a process on receipt of a specific
       signal.  (See <b><a href="../man7/signal.7.html">signal</a></b>(7) for an overview of signals.)

       <u>signum</u> specifies the signal and can be any valid signal except <b>SIGKILL</b> and <b>SIGSTOP</b>.

       If <u>act</u> is non-NULL, the new action for signal <u>signum</u> is installed from <u>act</u>.  If <u>oldact</u> is  non-NULL,  the
       previous action is saved in <u>oldact</u>.

       The <u>sigaction</u> structure is defined as something like:

           struct sigaction {
               void     (*sa_handler)(int);
               void     (*sa_sigaction)(int, siginfo_t *, void *);
               sigset_t   sa_mask;
               int        sa_flags;
               void     (*sa_restorer)(void);
           };

       On some architectures a union is involved: do not assign to both <u>sa_handler</u> and <u>sa_sigaction</u>.

       The <u>sa_restorer</u> field is not intended for application use.  (POSIX does not specify a <u>sa_restorer</u> field.)
       Some further details of the purpose of this field can be found in <b><a href="../man2/sigreturn.2.html">sigreturn</a></b>(2).

       <u>sa_handler</u> specifies the action to be associated with <u>signum</u> and can be one of the following:

       •  <b>SIG_DFL</b> for the default action.

       •  <b>SIG_IGN</b> to ignore this signal.

       •  A  pointer  to  a  signal  handling  function.   This  function receives the signal number as its only
          argument.

       If <b>SA_SIGINFO</b> is specified in <u>sa_flags</u>, then <u>sa_sigaction</u> (instead of <u>sa_handler</u>) specifies  the  signal-
       handling function for <u>signum</u>.  This function receives three arguments, as described below.

       <u>sa_mask</u> specifies a mask of signals which should be blocked (i.e., added to the signal mask of the thread
       in  which the signal handler is invoked) during execution of the signal handler.  In addition, the signal
       which triggered the handler will be blocked, unless the <b>SA_NODEFER</b> flag is used.

       <u>sa_flags</u> specifies a set of flags which modify the behavior of the signal.  It is formed by  the  bitwise
       OR of zero or more of the following:

       <b>SA_NOCLDSTOP</b>
              If  <u>signum</u>  is  <b>SIGCHLD</b>,  do  not  receive notification when child processes stop (i.e., when they
              receive one of <b>SIGSTOP</b>, <b>SIGTSTP</b>, <b>SIGTTIN</b>, or <b>SIGTTOU</b>) or resume (i.e., they receive <b>SIGCONT</b>)  (see
              <b><a href="../man2/wait.2.html">wait</a></b>(2)).  This flag is meaningful only when establishing a handler for <b>SIGCHLD</b>.

       <b>SA_NOCLDWAIT</b> (since Linux 2.6)
              If  <u>signum</u>  is  <b>SIGCHLD</b>,  do  not  transform  children into zombies when they terminate.  See also
              <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2).  This flag is meaningful only when establishing a handler for <b>SIGCHLD</b>, or when setting
              that signal's disposition to <b>SIG_DFL</b>.

              If the <b>SA_NOCLDWAIT</b> flag is set when  establishing  a  handler  for  <b>SIGCHLD</b>,  POSIX.1  leaves  it
              unspecified  whether  a  <b>SIGCHLD</b> signal is generated when a child process terminates.  On Linux, a
              <b>SIGCHLD</b> signal is generated in this case; on some other implementations, it is not.

       <b>SA_NODEFER</b>
              Do not add the signal to the thread's signal mask while  the  handler  is  executing,  unless  the
              signal  is  specified  in  <u>act.sa_mask</u>.   Consequently,  a  further  instance of the signal may be
              delivered to the thread while it is executing the handler.  This  flag  is  meaningful  only  when
              establishing a signal handler.

              <b>SA_NOMASK</b> is an obsolete, nonstandard synonym for this flag.

       <b>SA_ONSTACK</b>
              Call  the signal handler on an alternate signal stack provided by <b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2).  If an alternate
              stack is not available, the default stack will  be  used.   This  flag  is  meaningful  only  when
              establishing a signal handler.

       <b>SA_RESETHAND</b>
              Restore  the  signal  action  to  the  default  upon  entry  to  the signal handler.  This flag is
              meaningful only when establishing a signal handler.

              <b>SA_ONESHOT</b> is an obsolete, nonstandard synonym for this flag.

       <b>SA_RESTART</b>
              Provide behavior compatible with BSD signal semantics by making certain system  calls  restartable
              across  signals.   This flag is meaningful only when establishing a signal handler.  See <b><a href="../man7/signal.7.html">signal</a></b>(7)
              for a discussion of system call restarting.

       <b>SA_RESTORER</b>
              <u>Not</u> <u>intended</u> <u>for</u> <u>application</u> <u>use</u>.  This  flag  is  used  by  C  libraries  to  indicate  that  the
              <u>sa_restorer</u>  field  contains  the  address  of  a  "signal trampoline".  See <b><a href="../man2/sigreturn.2.html">sigreturn</a></b>(2) for more
              details.

       <b>SA_SIGINFO</b> (since Linux 2.2)
              The signal handler takes three arguments, not one.  In  this  case,  <u>sa_sigaction</u>  should  be  set
              instead of <u>sa_handler</u>.  This flag is meaningful only when establishing a signal handler.

       <b>SA_UNSUPPORTED</b> (since Linux 5.11)
              Used to dynamically probe for flag bit support.

              If  an  attempt to register a handler succeeds with this flag set in <u>act-&gt;sa_flags</u> alongside other
              flags that are potentially unsupported by the kernel, and an  immediately  subsequent  <b>sigaction</b>()
              call  specifying  the same signal number and with a non-NULL <u>oldact</u> argument yields <b>SA_UNSUPPORTED</b>
              <u>clear</u> in <u>oldact-&gt;sa_flags</u>, then <u>oldact-&gt;sa_flags</u> may be used as a bitmask describing which of  the
              potentially  unsupported  flags are, in fact, supported.  See the section "Dynamically probing for
              flag bit support" below for more details.

       <b>SA_EXPOSE_TAGBITS</b> (since Linux 5.11)
              Normally, when delivering a signal, an architecture-specific set of tag bits are cleared from  the
              <u>si_addr</u>  field of <u>siginfo_t</u>.  If this flag is set, an architecture-specific subset of the tag bits
              will be preserved in <u>si_addr</u>.

              Programs that need to be compatible with Linux versions older than 5.11 must use <b>SA_UNSUPPORTED</b> to
              probe for support.

   <b>The</b> <b>siginfo_t</b> <b>argument</b> <b>to</b> <b>a</b> <b>SA_SIGINFO</b> <b>handler</b>
       When the <b>SA_SIGINFO</b> flag is specified in <u>act.sa_flags</u>, the signal  handler  address  is  passed  via  the
       <u>act.sa_sigaction</u> field.  This handler takes three arguments, as follows:

           void
           handler(int sig, siginfo_t *info, void *ucontext)
           {
               ...
           }

       These three arguments are as follows

       <u>sig</u>    The number of the signal that caused invocation of the handler.

       <u>info</u>   A pointer to a <u>siginfo_t</u>, which is a structure containing further information about the signal, as
              described below.

       <u>ucontext</u>
              This  is  a  pointer  to a <u>ucontext_t</u> structure, cast to <u>void</u> <u>*</u>.  The structure pointed to by this
              field contains signal context information that was saved on the user-space stack  by  the  kernel;
              for details, see <b><a href="../man2/sigreturn.2.html">sigreturn</a></b>(2).  Further information about the <u>ucontext_t</u> structure can be found in
              <b><a href="../man3/getcontext.3.html">getcontext</a></b>(3)  and  <b><a href="../man7/signal.7.html">signal</a></b>(7).   Commonly,  the handler function doesn't make any use of the third
              argument.

       The <u>siginfo_t</u> data type is a structure with the following fields:

           siginfo_t {
               int      si_signo;     /* Signal number */
               int      si_errno;     /* An errno value */
               int      si_code;      /* Signal code */
               int      si_trapno;    /* Trap number that caused
                                         hardware-generated signal
                                         (unused on most architectures) */
               pid_t    si_pid;       /* Sending process ID */
               uid_t    si_uid;       /* Real user ID of sending process */
               int      si_status;    /* Exit value or signal */
               clock_t  si_utime;     /* User time consumed */
               clock_t  si_stime;     /* System time consumed */
               union sigval si_value; /* Signal value */
               int      si_int;       /* POSIX.1b signal */
               void    *si_ptr;       /* POSIX.1b signal */
               int      si_overrun;   /* Timer overrun count;
                                         POSIX.1b timers */
               int      si_timerid;   /* Timer ID; POSIX.1b timers */
               void    *si_addr;      /* Memory location which caused fault */
               long     si_band;      /* Band event (was <u>int</u> in
                                         glibc 2.3.2 and earlier) */
               int      si_fd;        /* File descriptor */
               short    si_addr_lsb;  /* Least significant bit of address
                                         (since Linux 2.6.32) */
               void    *si_lower;     /* Lower bound when address violation
                                         occurred (since Linux 3.19) */
               void    *si_upper;     /* Upper bound when address violation
                                         occurred (since Linux 3.19) */
               int      si_pkey;      /* Protection key on PTE that caused
                                         fault (since Linux 4.6) */
               void    *si_call_addr; /* Address of system call instruction
                                         (since Linux 3.5) */
               int      si_syscall;   /* Number of attempted system call
                                         (since Linux 3.5) */
               unsigned int si_arch;  /* Architecture of attempted system call
                                         (since Linux 3.5) */
           }

       <u>si_signo</u>, <u>si_errno</u> and <u>si_code</u> are defined for all signals.  (<u>si_errno</u> is  generally  unused  on  Linux.)
       The  rest  of  the struct may be a union, so that one should read only the fields that are meaningful for
       the given signal:

       •  Signals sent with <b><a href="../man2/kill.2.html">kill</a></b>(2) and <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3) fill in <u>si_pid</u> and <u>si_uid</u>.  In addition, signals  sent  with
          <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3)  fill  in  <u>si_int</u>  and  <u>si_ptr</u>  with the values specified by the sender of the signal; see
          <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3) for more details.

       •  Signals sent by POSIX.1b timers (since Linux 2.6) fill in <u>si_overrun</u> and <u>si_timerid</u>.   The  <u>si_timerid</u>
          field  is  an internal ID used by the kernel to identify the timer; it is not the same as the timer ID
          returned by <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2).  The <u>si_overrun</u> field is the  timer  overrun  count;  this  is  the  same
          information  as  is  obtained  by  a  call to <b><a href="../man2/timer_getoverrun.2.html">timer_getoverrun</a></b>(2).  These fields are nonstandard Linux
          extensions.

       •  Signals sent for message queue notification (see the description of <b>SIGEV_SIGNAL</b> in <b><a href="../man3/mq_notify.3.html">mq_notify</a></b>(3)) fill
          in <u>si_int</u>/<u>si_ptr</u>, with the <u>sigev_value</u> supplied to <b><a href="../man3/mq_notify.3.html">mq_notify</a></b>(3); <u>si_pid</u>, with the process  ID  of  the
          message sender; and <u>si_uid</u>, with the real user ID of the message sender.

       •  <b>SIGCHLD</b>  fills  in  <u>si_pid</u>, <u>si_uid</u>, <u>si_status</u>, <u>si_utime</u>, and <u>si_stime</u>, providing information about the
          child.  The <u>si_pid</u> field is the process ID of the child; <u>si_uid</u> is the  child's  real  user  ID.   The
          <u>si_status</u> field contains the exit status of the child (if <u>si_code</u> is <b>CLD_EXITED</b>), or the signal number
          that  caused  the  process to change state.  The <u>si_utime</u> and <u>si_stime</u> contain the user and system CPU
          time used by the child process; these fields do not include the  times  used  by  waited-for  children
          (unlike  <b><a href="../man2/getrusage.2.html">getrusage</a></b>(2) and <b><a href="../man2/times.2.html">times</a></b>(2)).  Up to Linux 2.6, and since Linux 2.6.27, these fields report CPU
          time in units of <u>sysconf(_SC_CLK_TCK)</u>.  In Linux 2.6 kernels before Linux 2.6.27,  a  bug  meant  that
          these fields reported time in units of the (configurable) system jiffy (see <b><a href="../man7/time.7.html">time</a></b>(7)).

       •  <b>SIGILL</b>,  <b>SIGFPE</b>,  <b>SIGSEGV</b>, <b>SIGBUS</b>, and <b>SIGTRAP</b> fill in <u>si_addr</u> with the address of the fault.  On some
          architectures, these signals also fill in the <u>si_trapno</u> field.

          Some suberrors of <b>SIGBUS</b>, in particular <b>BUS_MCEERR_AO</b> and <b>BUS_MCEERR_AR</b>,  also  fill  in  <u>si_addr_lsb</u>.
          This field indicates the least significant bit of the reported address and therefore the extent of the
          corruption.     For    example,    if    a    full    page   was   corrupted,   <u>si_addr_lsb</u>   contains
          <u>log2(sysconf(_SC_PAGESIZE))</u>.   When  <b>SIGTRAP</b>  is  delivered  in  response   to   a   <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2)   event
          (PTRACE_EVENT_foo),  <u>si_addr</u> is not populated, but <u>si_pid</u> and <u>si_uid</u> are populated with the respective
          process ID and user ID responsible for delivering the trap.  In the case  of  <b><a href="../man2/seccomp.2.html">seccomp</a></b>(2),  the  tracee
          will be shown as delivering the event.  <b>BUS_MCEERR_*</b> and <u>si_addr_lsb</u> are Linux-specific extensions.

          The <b>SEGV_BNDERR</b> suberror of <b>SIGSEGV</b> populates <u>si_lower</u> and <u>si_upper</u>.

          The <b>SEGV_PKUERR</b> suberror of <b>SIGSEGV</b> populates <u>si_pkey</u>.

       •  <b>SIGIO</b>/<b>SIGPOLL</b>  (the two names are synonyms on Linux) fills in <u>si_band</u> and <u>si_fd</u>.  The <u>si_band</u> event is
          a bit mask containing the same values as are filled in the <u>revents</u> field by <b><a href="../man2/poll.2.html">poll</a></b>(2).  The <u>si_fd</u>  field
          indicates  the  file  descriptor  for  which  the  I/O  event  occurred;  for further details, see the
          description of <b>F_SETSIG</b> in <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2).

       •  <b>SIGSYS</b>, generated (since  Linux  3.5)  when  a  seccomp  filter  returns  <b>SECCOMP_RET_TRAP</b>,  fills  in
          <u>si_call_addr</u>, <u>si_syscall</u>, <u>si_arch</u>, <u>si_errno</u>, and other fields as described in <b><a href="../man2/seccomp.2.html">seccomp</a></b>(2).

   <b>The</b> <b>si_code</b> <b>field</b>
       The  <u>si_code</u> field inside the <u>siginfo_t</u> argument that is passed to a <b>SA_SIGINFO</b> signal handler is a value
       (not a bit mask) indicating why this signal was sent.   For  a  <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2)  event,  <u>si_code</u>  will  contain
       <b>SIGTRAP</b> and have the ptrace event in the high byte:

           (SIGTRAP | PTRACE_EVENT_foo &lt;&lt; 8).

       For  a  non-<b><a href="../man2/ptrace.2.html">ptrace</a></b>(2) event, the values that can appear in <u>si_code</u> are described in the remainder of this
       section.  Since glibc 2.20, the definitions of most of these symbols  are  obtained  from  <u>&lt;signal.h&gt;</u>  by
       defining feature test macros (before including <u>any</u> header file) as follows:

       •  <b>_XOPEN_SOURCE</b> with the value 500 or greater;

       •  <b>_XOPEN_SOURCE</b> and <b>_XOPEN_SOURCE_EXTENDED</b>; or

       •  <b>_POSIX_C_SOURCE</b> with the value 200809L or greater.

       For  the <b>TRAP_*</b> constants, the symbol definitions are provided only in the first two cases.  Before glibc
       2.20, no feature test macros were required to obtain these symbols.

       For a regular signal, the following list shows the values which can be placed in <u>si_code</u> for any  signal,
       along with the reason that the signal was generated.

           <b>SI_USER</b>
                  <b><a href="../man2/kill.2.html">kill</a></b>(2).

           <b>SI_KERNEL</b>
                  Sent by the kernel.

           <b>SI_QUEUE</b>
                  <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3).

           <b>SI_TIMER</b>
                  POSIX timer expired.

           <b>SI_MESGQ</b> (since Linux 2.6.6)
                  POSIX message queue state changed; see <b><a href="../man3/mq_notify.3.html">mq_notify</a></b>(3).

           <b>SI_ASYNCIO</b>
                  AIO completed.

           <b>SI_SIGIO</b>
                  Queued  <b>SIGIO</b>  (only  up to Linux 2.2; from Linux 2.4 onward <b>SIGIO</b>/<b>SIGPOLL</b> fills in <u>si_code</u> as
                  described below).

           <b>SI_TKILL</b> (since Linux 2.4.19)
                  <b><a href="../man2/tkill.2.html">tkill</a></b>(2) or <b><a href="../man2/tgkill.2.html">tgkill</a></b>(2).

       The following values can be placed in <u>si_code</u> for a <b>SIGILL</b> signal:

           <b>ILL_ILLOPC</b>
                  Illegal opcode.

           <b>ILL_ILLOPN</b>
                  Illegal operand.

           <b>ILL_ILLADR</b>
                  Illegal addressing mode.

           <b>ILL_ILLTRP</b>
                  Illegal trap.

           <b>ILL_PRVOPC</b>
                  Privileged opcode.

           <b>ILL_PRVREG</b>
                  Privileged register.

           <b>ILL_COPROC</b>
                  Coprocessor error.

           <b>ILL_BADSTK</b>
                  Internal stack error.

       The following values can be placed in <u>si_code</u> for a <b>SIGFPE</b> signal:

           <b>FPE_INTDIV</b>
                  Integer divide by zero.

           <b>FPE_INTOVF</b>
                  Integer overflow.

           <b>FPE_FLTDIV</b>
                  Floating-point divide by zero.

           <b>FPE_FLTOVF</b>
                  Floating-point overflow.

           <b>FPE_FLTUND</b>
                  Floating-point underflow.

           <b>FPE_FLTRES</b>
                  Floating-point inexact result.

           <b>FPE_FLTINV</b>
                  Floating-point invalid operation.

           <b>FPE_FLTSUB</b>
                  Subscript out of range.

       The following values can be placed in <u>si_code</u> for a <b>SIGSEGV</b> signal:

           <b>SEGV_MAPERR</b>
                  Address not mapped to object.

           <b>SEGV_ACCERR</b>
                  Invalid permissions for mapped object.

           <b>SEGV_BNDERR</b> (since Linux 3.19)
                  Failed address bound checks.

           <b>SEGV_PKUERR</b> (since Linux 4.6)
                  Access was denied by memory protection keys.  See <b><a href="../man7/pkeys.7.html">pkeys</a></b>(7).  The protection key which  applied
                  to this access is available via <u>si_pkey</u>.

       The following values can be placed in <u>si_code</u> for a <b>SIGBUS</b> signal:

           <b>BUS_ADRALN</b>
                  Invalid address alignment.

           <b>BUS_ADRERR</b>
                  Nonexistent physical address.

           <b>BUS_OBJERR</b>
                  Object-specific hardware error.

           <b>BUS_MCEERR_AR</b> (since Linux 2.6.32)
                  Hardware memory error consumed on a machine check; action required.

           <b>BUS_MCEERR_AO</b> (since Linux 2.6.32)
                  Hardware memory error detected in process but not consumed; action optional.

       The following values can be placed in <u>si_code</u> for a <b>SIGTRAP</b> signal:

           <b>TRAP_BRKPT</b>
                  Process breakpoint.

           <b>TRAP_TRACE</b>
                  Process trace trap.

           <b>TRAP_BRANCH</b> (since Linux 2.4, IA64 only)
                  Process taken branch trap.

           <b>TRAP_HWBKPT</b> (since Linux 2.4, IA64 only)
                  Hardware breakpoint/watchpoint.

       The following values can be placed in <u>si_code</u> for a <b>SIGCHLD</b> signal:

           <b>CLD_EXITED</b>
                  Child has exited.

           <b>CLD_KILLED</b>
                  Child was killed.

           <b>CLD_DUMPED</b>
                  Child terminated abnormally.

           <b>CLD_TRAPPED</b>
                  Traced child has trapped.

           <b>CLD_STOPPED</b>
                  Child has stopped.

           <b>CLD_CONTINUED</b> (since Linux 2.6.9)
                  Stopped child has continued.

       The following values can be placed in <u>si_code</u> for a <b>SIGIO</b>/<b>SIGPOLL</b> signal:

           <b>POLL_IN</b>
                  Data input available.

           <b>POLL_OUT</b>
                  Output buffers available.

           <b>POLL_MSG</b>
                  Input message available.

           <b>POLL_ERR</b>
                  I/O error.

           <b>POLL_PRI</b>
                  High priority input available.

           <b>POLL_HUP</b>
                  Device disconnected.

       The following value can be placed in <u>si_code</u> for a <b>SIGSYS</b> signal:

           <b>SYS_SECCOMP</b> (since Linux 3.5)
                  Triggered by a <b><a href="../man2/seccomp.2.html">seccomp</a></b>(2) filter rule.

   <b>Dynamically</b> <b>probing</b> <b>for</b> <b>flag</b> <b>bit</b> <b>support</b>
       The  <b>sigaction</b>()  call on Linux accepts unknown bits set in <u>act-&gt;sa_flags</u> without error.  The behavior of
       the kernel starting with  Linux  5.11  is  that  a  second  <b>sigaction</b>()  will  clear  unknown  bits  from
       <u>oldact-&gt;sa_flags</u>.   However, historically, a second <b>sigaction</b>() call would typically leave those bits set
       in <u>oldact-&gt;sa_flags</u>.

       This means that support for new flags cannot be detected simply by testing for a flag in <u>sa_flags</u>, and  a
       program must test that <b>SA_UNSUPPORTED</b> has been cleared before relying on the contents of <u>sa_flags</u>.

       Since  the  behavior  of  the  signal handler cannot be guaranteed unless the check passes, it is wise to
       either block the affected signal while registering the handler and performing the check in this case,  or
       where  this is not possible, for example if the signal is synchronous, to issue the second <b>sigaction</b>() in
       the signal handler itself.

       In kernels that do not support a specific flag, the kernel's behavior is as if the flag was not set, even
       if the flag was set in <u>act-&gt;sa_flags</u>.

       The flags <b>SA_NOCLDSTOP</b>, <b>SA_NOCLDWAIT</b>, <b>SA_SIGINFO</b>, <b>SA_ONSTACK</b>, <b>SA_RESTART</b>, <b>SA_NODEFER</b>, <b>SA_RESETHAND</b>,  and,
       if  defined by the architecture, <b>SA_RESTORER</b> may not be reliably probed for using this mechanism, because
       they were introduced before Linux 5.11.  However, in general, programs may assume that  these  flags  are
       supported, since they have all been supported since Linux 2.6, which was released in the year 2003.

       See EXAMPLES below for a demonstration of the use of <b>SA_UNSUPPORTED</b>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>sigaction</b>() returns 0 on success; on error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> <u>act</u> or <u>oldact</u> points to memory which is not a valid part of the process address space.

       <b>EINVAL</b> An  invalid signal was specified.  This will also be generated if an attempt is made to change the
              action for <b>SIGKILL</b> or <b>SIGSTOP</b>, which cannot be caught or ignored.

</pre><h4><b>VERSIONS</b></h4><pre>
   <b>C</b> <b>library/kernel</b> <b>differences</b>
       The glibc wrapper function for <b>sigaction</b>() gives an error (<b>EINVAL</b>) on attempts to change the  disposition
       of  the  two  real-time  signals  used  internally by the NPTL threading implementation.  See <b><a href="../man7/nptl.7.html">nptl</a></b>(7) for
       details.

       On architectures where the signal trampoline resides in the C library, the  glibc  wrapper  function  for
       <b>sigaction</b>()  places  the  address  of  the  trampoline  code  in  the  <u>act.sa_restorer</u> field and sets the
       <b>SA_RESTORER</b> flag in the <u>act.sa_flags</u> field.  See <b><a href="../man2/sigreturn.2.html">sigreturn</a></b>(2).

       The original Linux system call was named <b>sigaction</b>().  However, with the addition of real-time signals in
       Linux 2.2, the fixed-size, 32-bit <u>sigset_t</u> type supported by that system  call  was  no  longer  fit  for
       purpose.   Consequently,  a  new  system  call, <b>rt_sigaction</b>(), was added to support an enlarged <u>sigset_t</u>
       type.  The new system call takes a fourth argument, <u>size_t</u> <u>sigsetsize</u>, which specifies the size in  bytes
       of  the  signal  sets in <u>act.sa_mask</u> and <u>oldact.sa_mask</u>.  This argument is currently required to have the
       value <u>sizeof(sigset_t)</u> (or the error <b>EINVAL</b> results).  The glibc <b>sigaction</b>() wrapper function hides these
       details from us, transparently calling <b>rt_sigaction</b>() when the kernel provides it.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001, SVr4.

       POSIX.1-1990 disallowed setting the action for <b>SIGCHLD</b> to <b>SIG_IGN</b>.  POSIX.1-2001  and  later  allow  this
       possibility,  so  that  ignoring  <b>SIGCHLD</b>  can  be used to prevent the creation of zombies (see <b><a href="../man2/wait.2.html">wait</a></b>(2)).
       Nevertheless, the historical BSD and System V behaviors for ignoring <b>SIGCHLD</b> differ,  so  that  the  only
       completely  portable  method  of  ensuring that terminated children do not become zombies is to catch the
       <b>SIGCHLD</b> signal and perform a <b><a href="../man2/wait.2.html">wait</a></b>(2) or similar.

       POSIX.1-1990 specified only  <b>SA_NOCLDSTOP</b>.   POSIX.1-2001  added  <b>SA_NOCLDWAIT</b>,  <b>SA_NODEFER</b>,  <b>SA_ONSTACK</b>,
       <b>SA_RESETHAND</b>, <b>SA_RESTART</b>, and <b>SA_SIGINFO</b> as XSI extensions.  POSIX.1-2008 moved <b>SA_NODEFER</b>, <b>SA_RESETHAND</b>,
       <b>SA_RESTART</b>,  and  <b>SA_SIGINFO</b>  to  the base specifications.  Use of these latter values in <u>sa_flags</u> may be
       less portable in applications intended for older UNIX implementations.

       The <b>SA_RESETHAND</b> flag is compatible with the SVr4 flag of the same name.

       The <b>SA_NODEFER</b> flag is compatible with the SVr4 flag of the same name under kernels 1.3.9 and later.   On
       older  kernels  the  Linux  implementation  allowed  the  receipt  of any signal, not just the one we are
       installing (effectively overriding any <u>sa_mask</u> settings).

</pre><h4><b>NOTES</b></h4><pre>
       A child created via <b><a href="../man2/fork.2.html">fork</a></b>(2) inherits a copy of its parent's signal dispositions.   During  an  <b><a href="../man2/execve.2.html">execve</a></b>(2),
       the  dispositions  of  handled  signals are reset to the default; the dispositions of ignored signals are
       left unchanged.

       According to POSIX, the behavior of a process is undefined after it ignores a <b>SIGFPE</b>, <b>SIGILL</b>, or  <b>SIGSEGV</b>
       signal that was not generated by <b><a href="../man2/kill.2.html">kill</a></b>(2) or <b><a href="../man3/raise.3.html">raise</a></b>(3).  Integer division by zero has undefined result.  On
       some  architectures it will generate a <b>SIGFPE</b> signal.  (Also dividing the most negative integer by -1 may
       generate <b>SIGFPE</b>.)  Ignoring this signal might lead to an endless loop.

       <b>sigaction</b>() can be called with a NULL second argument to query the current signal handler.  It  can  also
       be  used  to check whether a given signal is valid for the current machine by calling it with NULL second
       and third arguments.

       It is not possible to block <b>SIGKILL</b> or <b>SIGSTOP</b> (by specifying them in <u>sa_mask</u>).  Attempts to  do  so  are
       silently ignored.

       See <b><a href="../man3/sigsetops.3.html">sigsetops</a></b>(3) for details on manipulating signal sets.

       See  <b><a href="../man7/signal-safety.7.html">signal-safety</a></b>(7) for a list of the async-signal-safe functions that can be safely called inside from
       inside a signal handler.

   <b>Undocumented</b>
       Before the introduction of <b>SA_SIGINFO</b>, it was also possible to get some additional information about  the
       signal.   This  was  done by providing an <u>sa_handler</u> signal handler with a second argument of type <u>struct</u>
       <u>sigcontext</u>, which is the same structure as the one that  is  passed  in  the  <u>uc_mcontext</u>  field  of  the
       <u>ucontext</u> structure that is passed (via a pointer) in the third argument of the <u>sa_sigaction</u> handler.  See
       the relevant Linux kernel sources for details.  This use is obsolete now.

</pre><h4><b>BUGS</b></h4><pre>
       When  delivering a signal with a <b>SA_SIGINFO</b> handler, the kernel does not always provide meaningful values
       for all of the fields of the <u>siginfo_t</u> that are relevant for that signal.

       Up to and including Linux 2.6.13, specifying <b>SA_NODEFER</b> in  <u>sa_flags</u>  prevents  not  only  the  delivered
       signal  from  being  masked  during  execution of the handler, but also the signals specified in <u>sa_mask</u>.
       This bug was fixed in Linux 2.6.14.

</pre><h4><b>EXAMPLES</b></h4><pre>
       See <b><a href="../man2/mprotect.2.html">mprotect</a></b>(2).

   <b>Probing</b> <b>for</b> <b>flag</b> <b>support</b>
       The following example program exits with status <b>EXIT_SUCCESS</b> if <b>SA_EXPOSE_TAGBITS</b>  is  determined  to  be
       supported, and <b>EXIT_FAILURE</b> otherwise.

       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       void
       handler(int signo, siginfo_t *info, void *context)
       {
           struct sigaction oldact;

           if (sigaction(SIGSEGV, NULL, &amp;oldact) == -1
               || (oldact.sa_flags &amp; SA_UNSUPPORTED)
               || !(oldact.sa_flags &amp; SA_EXPOSE_TAGBITS))
           {
               _exit(EXIT_FAILURE);
           }
           _exit(EXIT_SUCCESS);
       }

       int
       main(void)
       {
           struct sigaction act = { 0 };

           act.sa_flags = SA_SIGINFO | SA_UNSUPPORTED | SA_EXPOSE_TAGBITS;
           act.sa_sigaction = &amp;handler;
           if (sigaction(SIGSEGV, &amp;act, NULL) == -1) {
               perror("sigaction");
               exit(EXIT_FAILURE);
           }

           raise(SIGSEGV);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/kill.1.html">kill</a></b>(1),   <b><a href="../man2/kill.2.html">kill</a></b>(2),   <b><a href="../man2/pause.2.html">pause</a></b>(2),  <b><a href="../man2/pidfd_send_signal.2.html">pidfd_send_signal</a></b>(2),  <b><a href="../man2/restart_syscall.2.html">restart_syscall</a></b>(2),  <b><a href="../man2/seccomp.2.html">seccomp</a></b>(2),  <b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2),
       <b><a href="../man2/signal.2.html">signal</a></b>(2), <b><a href="../man2/signalfd.2.html">signalfd</a></b>(2), <b><a href="../man2/sigpending.2.html">sigpending</a></b>(2), <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2), <b><a href="../man2/sigreturn.2.html">sigreturn</a></b>(2), <b><a href="../man2/sigsuspend.2.html">sigsuspend</a></b>(2),  <b><a href="../man2/wait.2.html">wait</a></b>(2),  <b><a href="../man3/killpg.3.html">killpg</a></b>(3),
       <b><a href="../man3/raise.3.html">raise</a></b>(3), <b><a href="../man3/siginterrupt.3.html">siginterrupt</a></b>(3), <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3), <b><a href="../man3/sigsetops.3.html">sigsetops</a></b>(3), <b><a href="../man3/sigvec.3.html">sigvec</a></b>(3), <b><a href="../man5/core.5.html">core</a></b>(5), <b><a href="../man7/signal.7.html">signal</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                       <u><a href="../man2/sigaction.2.html">sigaction</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>