<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sendfile — send a file to a socket</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sendfile — send a file to a socket

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>
       <b>#include</b> <b>&lt;sys/uio.h&gt;</b>

       <u>int</u>
       <b>sendfile</b>(<u>int</u> <u>fd</u>, <u>int</u> <u>s</u>, <u>off_t</u> <u>offset</u>, <u>size_t</u> <u>nbytes</u>, <u>struct</u> <u>sf_hdtr</u> <u>*hdtr</u>, <u>off_t</u> <u>*sbytes</u>, <u>int</u> <u>flags</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>sendfile</b>() system call sends a regular file or shared memory object specified by descriptor <u>fd</u> out a
       stream socket specified by descriptor <u>s</u>.

       The <u>offset</u> argument specifies where to begin in the file.  Should <u>offset</u> fall beyond the end of file, the
       system will return success and report 0 bytes sent as described below.  The <u>nbytes</u> argument specifies how
       many bytes of the file should be sent, with 0 having the special meaning of send until the  end  of  file
       has been reached.

       An optional header and/or trailer can be sent before and after the file data by specifying a pointer to a
       <u>struct</u> <u>sf_hdtr</u>, which has the following structure:

             struct sf_hdtr {
                     struct iovec *headers;  /* pointer to header iovecs */
                     int hdr_cnt;            /* number of header iovecs */
                     struct iovec *trailers; /* pointer to trailer iovecs */
                     int trl_cnt;            /* number of trailer iovecs */
             };

       The  <u>headers</u>  and  <u>trailers</u>  pointers,  if non-NULL, point to arrays of <u>struct</u> <u>iovec</u> structures.  See the
       <b>writev</b>() system call for information on the iovec structure.  The number of iovecs  in  these  arrays  is
       specified by <u>hdr_cnt</u> and <u>trl_cnt</u>.

       If  non-NULL,  the system will write the total number of bytes sent on the socket to the variable pointed
       to by <u>sbytes</u>.

       The least significant 16 bits of <u>flags</u> argument is a bitmap of these values:

             SF_NODISKIO        This flag causes <b>sendfile</b> to return EBUSY instead of blocking when a  busy  page
                                is  encountered.   This  rare  situation can happen if some other process is now
                                working with the same region of the file.  It is advised to retry the  operation
                                after a short period.

                                Note  that  in  older  FreeBSD  versions  the SF_NODISKIO had slightly different
                                notion.  The flag prevented <b>sendfile</b> to run I/O operations in case if an invalid
                                (not cached) page is encountered, thus avoiding blocking on I/O.  Starting  with
                                FreeBSD  11  <b>sendfile</b>  sending files off the <u><a href="../man7/ffs.7.html">ffs</a></u>(7) filesystem does not block on
                                I/O (see “IMPLEMENTATION NOTES” ), so the condition no longer applies.  However,
                                it is safe if an application utilizes SF_NODISKIO and on EBUSY performs the same
                                action as it did in  older  FreeBSD  versions,  e.g.,  <u><a href="../man2/aio_read.2.html">aio_read</a></u>(2),  <u><a href="../man2/read.2.html">read</a></u>(2)  or
                                <b>sendfile</b> in a different context.

             SF_NOCACHE         The  data  sent  to  socket will not be cached by the virtual memory system, and
                                will be freed directly to the pool of free pages.

             SF_SYNC            <b>sendfile</b> sleeps until the network stack no longer references the VM pages of the
                                file, making subsequent modifications to it safe.  Please note that this is  not
                                a guarantee that the data has actually been sent.

             SF_USER_READAHEAD  <b>sendfile</b>  has  some internal heuristics to do readahead when sending data.  This
                                flag forces <b>sendfile</b> to override any heuristically calculated readahead and  use
                                exactly  the  application specified readahead.  See “SETTING READAHEAD” for more
                                details on readahead.

       When using a socket marked for non-blocking I/O, <b>sendfile</b>() may send fewer bytes than requested.  In this
       case, the number of bytes successfully written is returned in  <u>*sbytes</u>  (if  specified),  and  the  error
       EAGAIN is returned.

</pre><h4><b>SETTING</b> <b>READAHEAD</b></h4><pre>
       <b>sendfile</b>  uses  internal  heuristics  based  on  request  size  and  file  system layout to do readahead.
       Additionally application may request extra readahead.  The most significant  16  bits  of  <u>flags</u>  specify
       amount  of  pages  that <b>sendfile</b> may read ahead when reading the file.  A macro <b>SF_FLAGS</b>() is provided to
       combine readahead amount and flags.  An example showing specifying readahead of 16 pages  and  SF_NOCACHE
       flag:

                     SF_FLAGS(16, SF_NOCACHE)

       <b>sendfile</b>  will  use either application specified readahead or internally calculated, whichever is bigger.
       Setting flag SF_USER_READAHEAD would turn off any heuristics and set maximum possible readahead length to
       the number of pages specified via flags.

</pre><h4><b>IMPLEMENTATION</b> <b>NOTES</b></h4><pre>
       The FreeBSD implementation of <b>sendfile</b>() does not block on disk I/O when it sends a file off  the  <u><a href="../man7/ffs.7.html">ffs</a></u>(7)
       filesystem.  The syscall returns success before the actual I/O completes, and data is put into the socket
       later  unattended.   However,  the  order of data in the socket is preserved, so it is safe to do further
       writes to the socket.

       The FreeBSD implementation of <b>sendfile</b>() is "zero-copy", meaning that  it  has  been  optimized  so  that
       copying of the file data is avoided.

</pre><h4><b>TUNING</b></h4><pre>
       On  some  architectures,  this system call internally uses a special <b>sendfile</b>() buffer (<u>struct</u> <u>sf_buf</u>) to
       handle sending file data to the client.  If the sending socket is blocking,  and  there  are  not  enough
       <b>sendfile</b>()  buffers  available,  <b>sendfile</b>()  will  block  and report a state of “<b>sfbufa</b>”.  If the sending
       socket is non-blocking and there are not enough <b>sendfile</b>() buffers available, the  call  will  block  and
       wait for the necessary buffers to become available before finishing the call.

       The number of <u>sf_buf</u>'s allocated should be proportional to the number of nmbclusters used to send data to
       a client via <b>sendfile</b>().  Tune accordingly to avoid blocking!  Busy installations that make extensive use
       of  <b>sendfile</b>()  may  want  to  increase  these  values  to be inline with their <u>kern.ipc.nmbclusters</u> (see
       <u><a href="../man7/tuning.7.html">tuning</a></u>(7) for details).

       The number of <b>sendfile</b>() buffers available is determined at boot  time  by  either  the  <u>kern.ipc.nsfbufs</u>
       <u><a href="../man5/loader.conf.5.html">loader.conf</a></u>(5)  variable  or  the NSFBUFS kernel configuration tunable.  The number of <b>sendfile</b>() buffers
       scales  with  <u>kern.maxusers</u>.   The  <u>kern.ipc.nsfbufsused</u>  and  <u>kern.ipc.nsfbufspeak</u>  read-only  <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8)
       variables  show  current and peak <b>sendfile</b>() buffers usage respectively.  These values may also be viewed
       through <b>netstat</b> <b>-m</b>.

       If a value of zero is reported for <u>kern.ipc.nsfbufs</u>, your architecture does not need  to  use  <b>sendfile</b>()
       buffers because their task can be efficiently performed by the generic virtual memory structures.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The  <b>sendfile</b>()  function  returns  the value 0 if successful; otherwise the value -1 is returned and the
       global variable <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       [EAGAIN]           The socket is marked for non-blocking I/O and not all data was sent due to the  socket
                          buffer  being  filled.   If  specified,  the number of bytes successfully sent will be
                          returned in <u>*sbytes</u>.

       [EBADF]            The <u>fd</u> argument is not a valid file descriptor.

       [EBADF]            The <u>s</u> argument is not a valid socket descriptor.

       [EBUSY]            A busy page was encountered and SF_NODISKIO had been specified.  Partial data may have
                          been sent.

       [EFAULT]           An invalid address was specified for an argument.

       [EINTR]            A signal interrupted <b>sendfile</b>() before it  could  be  completed.   If  specified,  the
                          number of bytes successfully sent will be returned in <u>*sbytes</u>.

       [EINVAL]           The <u>fd</u> argument is not a regular file.

       [EINVAL]           The <u>s</u> argument is not a SOCK_STREAM type socket.

       [EINVAL]           The <u>offset</u> argument is negative.

       [EIO]              An error occurred while reading from <u>fd</u>.

       [EINTEGRITY]       Corrupted data was detected while reading from <u>fd</u>.

       [ENOTCAPABLE]      The <u>fd</u> or the <u>s</u> argument has insufficient rights.

       [ENOBUFS]          The system was unable to allocate an internal buffer.

       [ENOTCONN]         The <u>s</u> argument points to an unconnected socket.

       [ENOTSOCK]         The <u>s</u> argument is not a socket.

       [EOPNOTSUPP]       The file system for descriptor <u>fd</u> does not support <b>sendfile</b>().

       [EPIPE]            The socket peer has closed the connection.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/netstat.1.html">netstat</a></u>(1), <u><a href="../man2/open.2.html">open</a></u>(2), <u><a href="../man2/send.2.html">send</a></u>(2), <u><a href="../man2/socket.2.html">socket</a></u>(2), <u><a href="../man2/writev.2.html">writev</a></u>(2), <u><a href="../man7/tuning.7.html">tuning</a></u>(7)

       K.  Elmeleegy,  A.  Chanda, A. L. Cox, and W. Zwaenepoel, “A Portable Kernel Abstraction for Low-Overhead
       Ephemeral Mapping Management”, <u>The</u> <u>Proceedings</u>  <u>of</u>  <u>the</u>  <u>2005</u>  <u>USENIX</u>  <u>Annual</u>  <u>Technical</u>  <u>Conference</u>,  pp
       223-236, 2005.

</pre><h4><b>HISTORY</b></h4><pre>
       The  <b>sendfile</b>()  system  call  first  appeared  in  FreeBSD  3.0.   This  manual  page  first appeared in
       FreeBSD 3.1.  In FreeBSD 10 support for sending  shared  memory  descriptors  had  been  introduced.   In
       FreeBSD 11 a non-blocking implementation had been introduced.

</pre><h4><b>AUTHORS</b></h4><pre>
       The  initial  implementation  of  <b>sendfile</b>()  system  call  and this manual page were written by David G.
       Lawrence &lt;<u><a href="mailto:dg@dglawrence.com">dg@dglawrence.com</a></u>&gt;.  The FreeBSD 11 implementation was written by
       Gleb Smirnoff &lt;<u><a href="mailto:glebius@FreeBSD.org">glebius@FreeBSD.org</a></u>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       The <b>sendfile</b>() system call will not fail, i.e., return -1 and set <u>errno</u> to EFAULT, if provided an invalid
       address for <u>sbytes</u>.  The <b>sendfile</b>() system call does not support SCTP sockets, it will return -1 and  set
       <u>errno</u> to EINVAL.

Debian                                           March 30, 2020                                      <u><a href="../man2/SENDFILE.2.html">SENDFILE</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>