<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>recvmmsg - receive multiple messages on a socket</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       recvmmsg - receive multiple messages on a socket

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>         /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>

       <b>int</b> <b>recvmmsg(int</b> <u>sockfd</u><b>,</b> <b>struct</b> <b>mmsghdr</b> <b>*</b><u>msgvec</u><b>,</b> <b>unsigned</b> <b>int</b> <u>vlen</u><b>,</b>
                    <b>int</b> <u>flags</u><b>,</b> <b>struct</b> <b>timespec</b> <b>*</b><u>timeout</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>recvmmsg</b>()  system  call  is  an  extension of <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2) that allows the caller to receive multiple
       messages  from  a  socket  using  a  single  system  call.   (This  has  performance  benefits  for  some
       applications.)  A further extension over <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2) is support for a timeout on the receive operation.

       The <u>sockfd</u> argument is the file descriptor of the socket to receive data from.

       The  <u>msgvec</u> argument is a pointer to an array of <u>mmsghdr</u> structures.  The size of this array is specified
       in <u>vlen</u>.

       The <u>mmsghdr</u> structure is defined in <u>&lt;sys/socket.h&gt;</u> as:

           struct mmsghdr {
               struct msghdr msg_hdr;  /* Message header */
               unsigned int  msg_len;  /* Number of received bytes for header */
           };

       The <u>msg_hdr</u> field is a <u>msghdr</u> structure, as described in <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2).  The <u>msg_len</u> field is the number  of
       bytes  returned  for  the  message  in the entry.  This field has the same value as the return value of a
       single <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2) on the header.

       The <u>flags</u> argument contains flags ORed together.  The flags are the same as  documented  for  <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2),
       with the following addition:

       <b>MSG_WAITFORONE</b> (since Linux 2.6.34)
              Turns on <b>MSG_DONTWAIT</b> after the first message has been received.

       The  <u>timeout</u> argument points to a <u>struct</u> <u>timespec</u> (see <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2)) defining a timeout (seconds plus
       nanoseconds) for the receive operation (<u>but</u> <u>see</u> <u>BUGS!</u>).  (This interval will be rounded up to the  system
       clock  granularity,  and  kernel scheduling delays mean that the blocking interval may overrun by a small
       amount.)  If <u>timeout</u> is NULL, then the operation blocks indefinitely.

       A blocking <b>recvmmsg</b>() call blocks until <u>vlen</u> messages have been received or until the timeout expires.  A
       nonblocking call reads as many messages as are available (up to the limit specified by <u>vlen</u>) and  returns
       immediately.

       On  return  from  <b>recvmmsg</b>(), successive elements of <u>msgvec</u> are updated to contain information about each
       received message: <u>msg_len</u> contains the size of the received message; the subfields of <u>msg_hdr</u> are updated
       as described in <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2).  The return value of the call indicates the number of elements of <u>msgvec</u> that
       have been updated.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>recvmmsg</b>() returns the number of messages received in <u>msgvec</u>; on error, -1 is  returned,  and
       <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       Errors are as for <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2).  In addition, the following error can occur:

       <b>EINVAL</b> <u>timeout</u> is invalid.

       See also BUGS.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.33, glibc 2.12.

</pre><h4><b>BUGS</b></h4><pre>
       The  <u>timeout</u>  argument  does not work as intended.  The timeout is checked only after the receipt of each
       datagram, so that if up to <u>vlen-1</u> datagrams are received before the timeout expires, but then no  further
       datagrams are received, the call will block forever.

       If  an  error  occurs  after  at  least one message has been received, the call succeeds, and returns the
       number of messages received.  The error code  is  expected  to  be  returned  on  a  subsequent  call  to
       <b>recvmmsg</b>().  In the current implementation, however, the error code can be overwritten in the meantime by
       an unrelated network event on a socket, for example an incoming ICMP packet.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  program  uses  <b>recvmmsg</b>()  to  receive  multiple  messages on a socket and stores them in
       multiple buffers.  The call returns if all buffers are filled or if the timeout specified has expired.

       The following snippet periodically generates UDP datagrams containing a random number:

           $ <b>while</b> <b>true;</b> <b>do</b> <b>echo</b> <b>$RANDOM</b> <b>&gt;</b> <b>/dev/udp/127.0.0.1/1234;</b>
                 <b>sleep</b> <b>0.25;</b> <b>done</b>

       These datagrams are read by the example application, which can give the following output:

           $ <b>./a.out</b>
           5 messages received
           1 11782
           2 11345
           3 304
           4 13514
           5 28421

   <b>Program</b> <b>source</b>

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/arpa/inet.h">arpa/inet.h</a>&gt;
       #include &lt;<a href="file:/usr/include/netinet/in.h">netinet/in.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;sys/socket.h&gt;
       #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;

       int
       main(void)
       {
       #define VLEN 10
       #define BUFSIZE 200
       #define TIMEOUT 1
           int                 sockfd, retval;
           char                bufs[VLEN][BUFSIZE+1];
           struct iovec        iovecs[VLEN];
           struct mmsghdr      msgs[VLEN];
           struct timespec     timeout;
           struct sockaddr_in  addr;

           sockfd = socket(AF_INET, SOCK_DGRAM, 0);
           if (sockfd == -1) {
               perror("socket()");
               exit(EXIT_FAILURE);
           }

           addr.sin_family = AF_INET;
           addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
           addr.sin_port = <a href="../man1234/htons.1234.html">htons</a>(1234);
           if (bind(sockfd, (struct sockaddr *) &amp;addr, sizeof(addr)) == -1) {
               perror("bind()");
               exit(EXIT_FAILURE);
           }

           memset(msgs, 0, <a href="../manmsgs/sizeof.msgs.html">sizeof</a>(msgs));
           for (size_t i = 0; i &lt; VLEN; i++) {
               iovecs[i].iov_base         = bufs[i];
               iovecs[i].iov_len          = BUFSIZE;
               msgs[i].msg_hdr.msg_iov    = &amp;iovecs[i];
               msgs[i].msg_hdr.msg_iovlen = 1;
           }

           timeout.tv_sec = TIMEOUT;
           timeout.tv_nsec = 0;

           retval = recvmmsg(sockfd, msgs, VLEN, 0, &amp;timeout);
           if (retval == -1) {
               perror("recvmmsg()");
               exit(EXIT_FAILURE);
           }

           printf("%d messages received\n", retval);
           for (size_t i = 0; i &lt; retval; i++) {
               bufs[i][msgs[i].msg_len] = 0;
               printf("%zu %s", i+1, bufs[i]);
           }
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2), <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2), <b><a href="../man2/sendmmsg.2.html">sendmmsg</a></b>(2), <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2), <b><a href="../man2/socket.2.html">socket</a></b>(2), <b><a href="../man7/socket.7.html">socket</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                        <u><a href="../man2/recvmmsg.2.html">recvmmsg</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>