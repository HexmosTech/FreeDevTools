<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>send, sendto, sendmsg - send a message on a socket</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       send, sendto, sendmsg - send a message on a socket

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>

       <b>ssize_t</b> <b>send(int</b> <u>sockfd</u><b>,</b> <b>const</b> <b>void</b> <u>buf</u><b>[.</b><u>len</u><b>],</b> <b>size_t</b> <u>len</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>
       <b>ssize_t</b> <b>sendto(int</b> <u>sockfd</u><b>,</b> <b>const</b> <b>void</b> <u>buf</u><b>[.</b><u>len</u><b>],</b> <b>size_t</b> <u>len</u><b>,</b> <b>int</b> <u>flags</u><b>,</b>
                      <b>const</b> <b>struct</b> <b>sockaddr</b> <b>*</b><u>dest_addr</u><b>,</b> <b>socklen_t</b> <u>addrlen</u><b>);</b>
       <b>ssize_t</b> <b>sendmsg(int</b> <u>sockfd</u><b>,</b> <b>const</b> <b>struct</b> <b>msghdr</b> <b>*</b><u>msg</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The system calls <b>send</b>(), <b>sendto</b>(), and <b>sendmsg</b>() are used to transmit a message to another socket.

       The  <b>send</b>() call may be used only when the socket is in a <u>connected</u> state (so that the intended recipient
       is known).  The only difference between <b>send</b>() and <b><a href="../man2/write.2.html">write</a></b>(2) is the presence of <u>flags</u>.  With a zero  <u>flags</u>
       argument, <b>send</b>() is equivalent to <b><a href="../man2/write.2.html">write</a></b>(2).  Also, the following call

           send(sockfd, buf, len, flags);

       is equivalent to

           sendto(sockfd, buf, len, flags, NULL, 0);

       The argument <u>sockfd</u> is the file descriptor of the sending socket.

       If  <b>sendto</b>()  is  used on a connection-mode (<b>SOCK_STREAM</b>, <b>SOCK_SEQPACKET</b>) socket, the arguments <u>dest_addr</u>
       and <u>addrlen</u> are ignored (and the error <b>EISCONN</b> may be returned when they are not NULL  and  0),  and  the
       error  <b>ENOTCONN</b>  is  returned  when the socket was not actually connected.  Otherwise, the address of the
       target is given by <u>dest_addr</u> with <u>addrlen</u> specifying its size.  For <b>sendmsg</b>(), the address of the  target
       is given by <u>msg.msg_name</u>, with <u>msg.msg_namelen</u> specifying its size.

       For  <b>send</b>()  and <b>sendto</b>(), the message is found in <u>buf</u> and has length <u>len</u>.  For <b>sendmsg</b>(), the message is
       pointed to by the elements of the array <u>msg.msg_iov</u>.  The <b>sendmsg</b>() call also  allows  sending  ancillary
       data (also known as control information).

       If  the  message  is  too  long to pass atomically through the underlying protocol, the error <b>EMSGSIZE</b> is
       returned, and the message is not transmitted.

       No indication of failure to deliver is implicit in a <b>send</b>().  Locally detected errors are indicated by  a
       return value of -1.

       When  the  message  does  not  fit into the send buffer of the socket, <b>send</b>() normally blocks, unless the
       socket has been placed in nonblocking I/O mode.  In nonblocking mode it would fail with the error  <b>EAGAIN</b>
       or  <b>EWOULDBLOCK</b>  in  this  case.  The <b><a href="../man2/select.2.html">select</a></b>(2) call may be used to determine when it is possible to send
       more data.

   <b>The</b> <b>flags</b> <b>argument</b>
       The <u>flags</u> argument is the bitwise OR of zero or more of the following flags.

       <b>MSG_CONFIRM</b> (since Linux 2.3.15)
              Tell the link layer that forward progress happened: you got a  successful  reply  from  the  other
              side.   If  the  link  layer  doesn't get this it will regularly reprobe the neighbor (e.g., via a
              unicast ARP).  Valid only on <b>SOCK_DGRAM</b> and <b>SOCK_RAW</b> sockets and currently  implemented  only  for
              IPv4 and IPv6.  See <b><a href="../man7/arp.7.html">arp</a></b>(7) for details.

       <b>MSG_DONTROUTE</b>
              Don't  use  a  gateway  to send out the packet, send to hosts only on directly connected networks.
              This is usually used only by diagnostic or routing programs.  This is defined  only  for  protocol
              families that route; packet sockets don't.

       <b>MSG_DONTWAIT</b> (since Linux 2.2)
              Enables  nonblocking  operation;  if the operation would block, <b>EAGAIN</b> or <b>EWOULDBLOCK</b> is returned.
              This provides  similar  behavior  to  setting  the  <b>O_NONBLOCK</b>  flag  (via  the  <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2)  <b>F_SETFL</b>
              operation), but differs in that <b>MSG_DONTWAIT</b> is a per-call option, whereas <b>O_NONBLOCK</b> is a setting
              on  the  open file description (see <b><a href="../man2/open.2.html">open</a></b>(2)), which will affect all threads in the calling process
              as well as other processes that hold file descriptors referring to the same open file description.

       <b>MSG_EOR</b> (since Linux 2.2)
              Terminates a record (when this notion is supported, as for sockets of type <b>SOCK_SEQPACKET</b>).

       <b>MSG_MORE</b> (since Linux 2.4.4)
              The caller has more data to send.  This flag is used with TCP sockets to obtain the same effect as
              the <b>TCP_CORK</b> socket option (see <b><a href="../man7/tcp.7.html">tcp</a></b>(7)), with the difference that this flag can be set on  a  per-
              call basis.

              Since  Linux  2.6,  this flag is also supported for UDP sockets, and informs the kernel to package
              all of the data sent in calls with this flag set into a single datagram which is transmitted  only
              when  a  call  is performed that does not specify this flag.  (See also the <b>UDP_CORK</b> socket option
              described in <b><a href="../man7/udp.7.html">udp</a></b>(7).)

       <b>MSG_NOSIGNAL</b> (since Linux 2.2)
              Don't generate a <b>SIGPIPE</b> signal if the peer on a stream-oriented socket has closed the connection.
              The <b>EPIPE</b> error is still returned.  This provides similar behavior to using <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2) to ignore
              <b>SIGPIPE</b>, but, whereas <b>MSG_NOSIGNAL</b>  is  a  per-call  feature,  ignoring  <b>SIGPIPE</b>  sets  a  process
              attribute that affects all threads in the process.

       <b>MSG_OOB</b>
              Sends  <u>out-of-band</u>  data  on  sockets  that  support  this notion (e.g., of type <b>SOCK_STREAM</b>); the
              underlying protocol must also support <u>out-of-band</u> data.

       <b>MSG_FASTOPEN</b> (since Linux 3.7)
              Attempts TCP Fast Open (RFC7413) and sends data in the SYN like a combination  of  <b><a href="../man2/connect.2.html">connect</a></b>(2)  and
              <b><a href="../man2/write.2.html">write</a></b>(2),  by  performing  an implicit <b><a href="../man2/connect.2.html">connect</a></b>(2) operation.  It blocks until the data is buffered
              and the handshake has completed.  For a non-blocking  socket,  it  returns  the  number  of  bytes
              buffered  and  sent  in  the  SYN  packet.   If  the  cookie  is not available locally, it returns
              <b>EINPROGRESS</b>, and sends a SYN with a Fast Open cookie request automatically.  The caller  needs  to
              write  the  data  again  when  the  socket  is  connected.   On  errors, it sets the same <u>errno</u> as
              <b><a href="../man2/connect.2.html">connect</a></b>(2) if the handshake fails.  This flag requires enabling TCP Fast Open  client  support  on
              sysctl <u>net.ipv4.tcp_fastopen</u>.

              Refer to <b>TCP_FASTOPEN_CONNECT</b> socket option in <b><a href="../man7/tcp.7.html">tcp</a></b>(7) for an alternative approach.

   <b>sendmsg()</b>
       The definition of the <u>msghdr</u> structure employed by <b>sendmsg</b>() is as follows:

           struct msghdr {
               void         *msg_name;       /* Optional address */
               socklen_t     msg_namelen;    /* Size of address */
               struct iovec *msg_iov;        /* Scatter/gather array */
               size_t        msg_iovlen;     /* # elements in msg_iov */
               void         *msg_control;    /* Ancillary data, see below */
               size_t        msg_controllen; /* Ancillary data buffer len */
               int           msg_flags;      /* Flags (unused) */
           };

       The  <u>msg_name</u>  field  is  used on an unconnected socket to specify the target address for a datagram.  It
       points to a buffer containing the address; the <u>msg_namelen</u> field  should  be  set  to  the  size  of  the
       address.  For a connected socket, these fields should be specified as NULL and 0, respectively.

       The <u>msg_iov</u> and <u>msg_iovlen</u> fields specify scatter-gather locations, as for <b><a href="../man2/writev.2.html">writev</a></b>(2).

       You  may send control information (ancillary data) using the <u>msg_control</u> and <u>msg_controllen</u> members.  The
       maximum  control  buffer  length  the  kernel  can  process  is  limited  per  socket  by  the  value  in
       <u><a href="file:/proc/sys/net/core/optmem_max">/proc/sys/net/core/optmem_max</a></u>;  see  <b><a href="../man7/socket.7.html">socket</a></b>(7).   For further information on the use of ancillary data in
       various socket domains, see <b><a href="../man7/unix.7.html">unix</a></b>(7) and <b><a href="../man7/ip.7.html">ip</a></b>(7).

       The <u>msg_flags</u> field is ignored.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, these calls return the number of bytes sent.  On error, -1 is returned, and <u>errno</u> is  set  to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       These  are  some  standard  errors generated by the socket layer.  Additional errors may be generated and
       returned from the underlying protocol modules; see their respective manual pages.

       <b>EACCES</b> (For UNIX domain sockets, which are identified by pathname) Write  permission  is  denied  on  the
              destination  socket  file,  or  search  permission  is  denied for one of the directories the path
              prefix.  (See <b><a href="../man7/path_resolution.7.html">path_resolution</a></b>(7).)

              (For UDP sockets) An attempt was made to send to a network/broadcast address as though  it  was  a
              unicast address.

       <b>EAGAIN</b> or <b>EWOULDBLOCK</b>
              The  socket  is  marked  nonblocking and the requested operation would block.  POSIX.1-2001 allows
              either error to be returned for this case, and does not require these constants to have  the  same
              value, so a portable application should check for both possibilities.

       <b>EAGAIN</b> (Internet  domain datagram sockets) The socket referred to by <u>sockfd</u> had not previously been bound
              to an address and, upon attempting to bind it to an ephemeral port, it  was  determined  that  all
              port  numbers  in  the  ephemeral  port  range  are  currently  in  use.   See  the  discussion of
              <u><a href="file:/proc/sys/net/ipv4/ip_local_port_range">/proc/sys/net/ipv4/ip_local_port_range</a></u> in <b><a href="../man7/ip.7.html">ip</a></b>(7).

       <b>EALREADY</b>
              Another Fast Open is in progress.

       <b>EBADF</b>  <u>sockfd</u> is not a valid open file descriptor.

       <b>ECONNRESET</b>
              Connection reset by peer.

       <b>EDESTADDRREQ</b>
              The socket is not connection-mode, and no peer address is set.

       <b>EFAULT</b> An invalid user space address was specified for an argument.

       <b>EINTR</b>  A signal occurred before any data was transmitted; see <b><a href="../man7/signal.7.html">signal</a></b>(7).

       <b>EINVAL</b> Invalid argument passed.

       <b>EISCONN</b>
              The connection-mode socket was connected already but a recipient was specified.  (Now either  this
              error is returned, or the recipient specification is ignored.)

       <b>EMSGSIZE</b>
              The  socket  type requires that message be sent atomically, and the size of the message to be sent
              made this impossible.

       <b>ENOBUFS</b>
              The output queue for a network interface was full.  This generally indicates  that  the  interface
              has stopped sending, but may be caused by transient congestion.  (Normally, this does not occur in
              Linux.  Packets are just silently dropped when a device queue overflows.)

       <b>ENOMEM</b> No memory available.

       <b>ENOTCONN</b>
              The socket is not connected, and no target has been given.

       <b>ENOTSOCK</b>
              The file descriptor <u>sockfd</u> does not refer to a socket.

       <b>EOPNOTSUPP</b>
              Some bit in the <u>flags</u> argument is inappropriate for the socket type.

       <b>EPIPE</b>  The  local end has been shut down on a connection oriented socket.  In this case, the process will
              also receive a <b>SIGPIPE</b> unless <b>MSG_NOSIGNAL</b> is set.

</pre><h4><b>VERSIONS</b></h4><pre>
       According to POSIX.1-2001, the <u>msg_controllen</u> field of the <u>msghdr</u> structure should be typed as <u>socklen_t</u>,
       and the <u>msg_iovlen</u> field should be typed as <u>int</u>, but glibc currently types both as <u>size_t</u>.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

       <b>MSG_CONFIRM</b> is a Linux extension.

</pre><h4><b>HISTORY</b></h4><pre>
       4.4BSD, SVr4, POSIX.1-2001.  (first appeared in 4.2BSD).

       POSIX.1-2001 describes only the  <b>MSG_OOB</b>  and  <b>MSG_EOR</b>  flags.   POSIX.1-2008  adds  a  specification  of
       <b>MSG_NOSIGNAL</b>.

</pre><h4><b>NOTES</b></h4><pre>
       See  <b><a href="../man2/sendmmsg.2.html">sendmmsg</a></b>(2) for information about a Linux-specific system call that can be used to transmit multiple
       datagrams in a single call.

</pre><h4><b>BUGS</b></h4><pre>
       Linux may return <b>EPIPE</b> instead of <b>ENOTCONN</b>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       An example of the use of <b>sendto</b>() is shown in <b><a href="../man3/getaddrinfo.3.html">getaddrinfo</a></b>(3).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2), <b><a href="../man2/getsockopt.2.html">getsockopt</a></b>(2), <b><a href="../man2/recv.2.html">recv</a></b>(2), <b><a href="../man2/select.2.html">select</a></b>(2), <b><a href="../man2/sendfile.2.html">sendfile</a></b>(2), <b><a href="../man2/sendmmsg.2.html">sendmmsg</a></b>(2), <b><a href="../man2/shutdown.2.html">shutdown</a></b>(2), <b><a href="../man2/socket.2.html">socket</a></b>(2),  <b><a href="../man2/write.2.html">write</a></b>(2),
       <b><a href="../man3/cmsg.3.html">cmsg</a></b>(3), <b><a href="../man7/ip.7.html">ip</a></b>(7), <b><a href="../man7/ipv6.7.html">ipv6</a></b>(7), <b><a href="../man7/socket.7.html">socket</a></b>(7), <b><a href="../man7/tcp.7.html">tcp</a></b>(7), <b><a href="../man7/udp.7.html">udp</a></b>(7), <b><a href="../man7/unix.7.html">unix</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                            <u><a href="../man2/send.2.html">send</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>