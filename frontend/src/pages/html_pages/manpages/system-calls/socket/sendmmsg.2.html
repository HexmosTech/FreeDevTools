<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sendmmsg - send multiple messages on a socket</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sendmmsg - send multiple messages on a socket

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>         /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>

       <b>int</b> <b>sendmmsg(int</b> <u>sockfd</u><b>,</b> <b>struct</b> <b>mmsghdr</b> <b>*</b><u>msgvec</u><b>,</b> <b>unsigned</b> <b>int</b> <u>vlen</u><b>,</b>
                    <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>sendmmsg</b>()  system  call  is  an extension of <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2) that allows the caller to transmit multiple
       messages on a socket using a single system call.  (This has performance benefits for some applications.)

       The <u>sockfd</u> argument is the file descriptor of the socket on which data is to be transmitted.

       The <u>msgvec</u> argument is a pointer to an array of <u>mmsghdr</u> structures.  The size of this array is  specified
       in <u>vlen</u>.

       The <u>mmsghdr</u> structure is defined in <u>&lt;sys/socket.h&gt;</u> as:

           struct mmsghdr {
               struct msghdr msg_hdr;  /* Message header */
               unsigned int  msg_len;  /* Number of bytes transmitted */
           };

       The <u>msg_hdr</u> field is a <u>msghdr</u> structure, as described in <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2).  The <u>msg_len</u> field is used to return
       the  number  of  bytes sent from the message in <u>msg_hdr</u> (i.e., the same as the return value from a single
       <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2) call).

       The <u>flags</u> argument contains flags ORed together.  The flags are the same as for <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2).

       A blocking <b>sendmmsg</b>() call blocks until <u>vlen</u> messages have been sent.  A nonblocking call sends  as  many
       messages as possible (up to the limit specified by <u>vlen</u>) and returns immediately.

       On return from <b>sendmmsg</b>(), the <u>msg_len</u> fields of successive elements of <u>msgvec</u> are updated to contain the
       number  of  bytes transmitted from the corresponding <u>msg_hdr</u>.  The return value of the call indicates the
       number of elements of <u>msgvec</u> that have been updated.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>sendmmsg</b>() returns the number of messages sent from <u>msgvec</u>; if this is less  than  <u>vlen</u>,  the
       caller can retry with a further <b>sendmmsg</b>() call to send the remaining messages.

       On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       Errors are as for <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2).  An error is returned only if no datagrams could be sent.  See also BUGS.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 3.0, glibc 2.14.

</pre><h4><b>NOTES</b></h4><pre>
       The value specified in <u>vlen</u> is capped to <b>UIO_MAXIOV</b> (1024).

</pre><h4><b>BUGS</b></h4><pre>
       If an error occurs after at least one message has been sent, the call succeeds, and returns the number of
       messages  sent.   The  error  code is lost.  The caller can retry the transmission, starting at the first
       failed message, but there is no guarantee that, if an error is returned, it will be the same as  the  one
       that was lost on the previous call.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The example below uses <b>sendmmsg</b>() to send <u>onetwo</u> and <u>three</u> in two distinct UDP datagrams using one system
       call.  The contents of the first datagram originates from a pair of buffers.

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/arpa/inet.h">arpa/inet.h</a>&gt;
       #include &lt;<a href="file:/usr/include/netinet/in.h">netinet/in.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;sys/socket.h&gt;
       #include &lt;sys/types.h&gt;

       int
       main(void)
       {
           int                 retval;
           int                 sockfd;
           struct iovec        msg1[2], msg2;
           struct mmsghdr      msg[2];
           struct sockaddr_in  addr;

           sockfd = socket(AF_INET, SOCK_DGRAM, 0);
           if (sockfd == -1) {
               perror("socket()");
               exit(EXIT_FAILURE);
           }

           addr.sin_family = AF_INET;
           addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
           addr.sin_port = <a href="../man1234/htons.1234.html">htons</a>(1234);
           if (connect(sockfd, (struct sockaddr *) &amp;addr, sizeof(addr)) == -1) {
               perror("connect()");
               exit(EXIT_FAILURE);
           }

           memset(msg1, 0, <a href="../manmsg1/sizeof.msg1.html">sizeof</a>(msg1));
           msg1[0].iov_base = "one";
           msg1[0].iov_len = 3;
           msg1[1].iov_base = "two";
           msg1[1].iov_len = 3;

           memset(&amp;msg2, 0, <a href="../manmsg2/sizeof.msg2.html">sizeof</a>(msg2));
           msg2.iov_base = "three";
           msg2.iov_len = 5;

           memset(msg, 0, <a href="../manmsg/sizeof.msg.html">sizeof</a>(msg));
           msg[0].msg_hdr.msg_iov = msg1;
           msg[0].msg_hdr.msg_iovlen = 2;

           msg[1].msg_hdr.msg_iov = &amp;msg2;
           msg[1].msg_hdr.msg_iovlen = 1;

           retval = sendmmsg(sockfd, msg, 2, 0);
           if (retval == -1)
               perror("sendmmsg()");
           else
               printf("%d messages sent\n", retval);

           <a href="../man0/exit.0.html">exit</a>(0);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/recvmmsg.2.html">recvmmsg</a></b>(2), <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2), <b><a href="../man2/socket.2.html">socket</a></b>(2), <b><a href="../man7/socket.7.html">socket</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                        <u><a href="../man2/sendmmsg.2.html">sendmmsg</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>