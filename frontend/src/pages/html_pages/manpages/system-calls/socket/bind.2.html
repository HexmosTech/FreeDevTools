<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bind - bind a name to a socket</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       bind - bind a name to a socket

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>

       <b>int</b> <b>bind(int</b> <u>sockfd</u><b>,</b> <b>const</b> <b>struct</b> <b>sockaddr</b> <b>*</b><u>addr</u><b>,</b>
                <b>socklen_t</b> <u>addrlen</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       When  a  socket  is created with <b><a href="../man2/socket.2.html">socket</a></b>(2), it exists in a name space (address family) but has no address
       assigned to it.  <b>bind</b>() assigns the address specified by <u>addr</u> to the  socket  referred  to  by  the  file
       descriptor  <u>sockfd</u>.   <u>addrlen</u>  specifies the size, in bytes, of the address structure pointed to by <u>addr</u>.
       Traditionally, this operation is called “assigning a name to a socket”.

       It is normally necessary to assign a local address using <b>bind</b>() before a <b>SOCK_STREAM</b> socket  may  receive
       connections (see <b><a href="../man2/accept.2.html">accept</a></b>(2)).

       The  rules  used  in name binding vary between address families.  Consult the manual entries in Section 7
       for detailed information.  For <b>AF_INET</b>, see <b><a href="../man7/ip.7.html">ip</a></b>(7); for <b>AF_INET6</b>, see <b><a href="../man7/ipv6.7.html">ipv6</a></b>(7); for <b>AF_UNIX</b>,  see  <b><a href="../man7/unix.7.html">unix</a></b>(7);
       for  <b>AF_APPLETALK</b>,  see <b><a href="../man7/ddp.7.html">ddp</a></b>(7); for <b>AF_PACKET</b>, see <b><a href="../man7/packet.7.html">packet</a></b>(7); for <b>AF_X25</b>, see <b><a href="../man7/x25.7.html">x25</a></b>(7); and for <b>AF_NETLINK</b>,
       see <b><a href="../man7/netlink.7.html">netlink</a></b>(7).

       The actual structure passed for the <u>addr</u> argument will  depend  on  the  address  family.   The  <u>sockaddr</u>
       structure is defined as something like:

           struct sockaddr {
               sa_family_t sa_family;
               char        sa_data[14];
           }

       The  only  purpose  of  this  structure is to cast the structure pointer passed in <u>addr</u> in order to avoid
       compiler warnings.  See EXAMPLES below.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, zero is returned.  On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EACCES</b> The address is protected, and the user is not the superuser.

       <b>EADDRINUSE</b>
              The given address is already in use.

       <b>EADDRINUSE</b>
              (Internet domain sockets) The port number was specified as zero in the socket  address  structure,
              but,  upon attempting to bind to an ephemeral port, it was determined that all port numbers in the
              ephemeral    port    range    are    currently    in    use.     See     the     discussion     of
              <u><a href="file:/proc/sys/net/ipv4/ip_local_port_range">/proc/sys/net/ipv4/ip_local_port_range</a></u> <b><a href="../man7/ip.7.html">ip</a></b>(7).

       <b>EBADF</b>  <u>sockfd</u> is not a valid file descriptor.

       <b>EINVAL</b> The socket is already bound to an address.

       <b>EINVAL</b> <u>addrlen</u> is wrong, or <u>addr</u> is not a valid address for this socket's domain.

       <b>ENOTSOCK</b>
              The file descriptor <u>sockfd</u> does not refer to a socket.

       The following errors are specific to UNIX domain (<b>AF_UNIX</b>) sockets:

       <b>EACCES</b> Search permission is denied on a component of the path prefix.  (See also <b><a href="../man7/path_resolution.7.html">path_resolution</a></b>(7).)

       <b>EADDRNOTAVAIL</b>
              A nonexistent interface was requested or the requested address was not local.

       <b>EFAULT</b> <u>addr</u> points outside the user's accessible address space.

       <b>ELOOP</b>  Too many symbolic links were encountered in resolving <u>addr</u>.

       <b>ENAMETOOLONG</b>
              <u>addr</u> is too long.

       <b>ENOENT</b> A component in the directory prefix of the socket pathname does not exist.

       <b>ENOMEM</b> Insufficient kernel memory was available.

       <b>ENOTDIR</b>
              A component of the path prefix is not a directory.

       <b>EROFS</b>  The socket inode would reside on a read-only filesystem.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001, SVr4, 4.4BSD (<b>bind</b>() first appeared in 4.2BSD).

</pre><h4><b>BUGS</b></h4><pre>
       The transparent proxy options are not described.

</pre><h4><b>EXAMPLES</b></h4><pre>
       An example of the use of <b>bind</b>() with Internet domain sockets can be found in <b><a href="../man3/getaddrinfo.3.html">getaddrinfo</a></b>(3).

       The  following  example  shows  how  to  bind  a  stream  socket in the UNIX (<b>AF_UNIX</b>) domain, and accept
       connections:

       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;sys/socket.h&gt;
       #include &lt;sys/un.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       #define MY_SOCK_PATH "/somepath"
       #define LISTEN_BACKLOG 50

       #define <a href="../manmsg/handle_error.msg.html">handle_error</a>(msg) \
           do { <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); } while (0)

       int
       main(void)
       {
           int                 sfd, cfd;
           socklen_t           peer_addr_size;
           struct sockaddr_un  my_addr, peer_addr;

           sfd = socket(AF_UNIX, SOCK_STREAM, 0);
           if (sfd == -1)
               handle_error("socket");

           memset(&amp;my_addr, 0, <a href="../manmy_addr/sizeof.my_addr.html">sizeof</a>(my_addr));
           my_addr.sun_family = AF_UNIX;
           strncpy(my_addr.sun_path, MY_SOCK_PATH,
                   sizeof(my_addr.sun_path) - 1);

           if (bind(sfd, (struct sockaddr *) &amp;my_addr,
                    <a href="../manmy_addr/sizeof.my_addr.html">sizeof</a>(my_addr)) == -1)
               handle_error("bind");

           if (listen(sfd, LISTEN_BACKLOG) == -1)
               handle_error("listen");

           /* Now we can accept incoming connections one
              at a time using <a href="../man2/accept.2.html">accept</a>(2). */

           peer_addr_size = sizeof(peer_addr);
           cfd = accept(sfd, (struct sockaddr *) &amp;peer_addr,
                        &amp;peer_addr_size);
           if (cfd == -1)
               handle_error("accept");

           /* Code to deal with incoming connection(s)... */

           if (close(sfd) == -1)
               handle_error("close");

           if (unlink(MY_SOCK_PATH) == -1)
               handle_error("unlink");
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/accept.2.html">accept</a></b>(2),  <b><a href="../man2/connect.2.html">connect</a></b>(2),  <b><a href="../man2/getsockname.2.html">getsockname</a></b>(2),  <b><a href="../man2/listen.2.html">listen</a></b>(2),  <b><a href="../man2/socket.2.html">socket</a></b>(2),  <b><a href="../man3/getaddrinfo.3.html">getaddrinfo</a></b>(3),  <b><a href="../man3/getifaddrs.3.html">getifaddrs</a></b>(3),  <b><a href="../man7/ip.7.html">ip</a></b>(7),
       <b><a href="../man7/ipv6.7.html">ipv6</a></b>(7), <b><a href="../man7/path_resolution.7.html">path_resolution</a></b>(7), <b><a href="../man7/socket.7.html">socket</a></b>(7), <b><a href="../man7/unix.7.html">unix</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                            <u><a href="../man2/bind.2.html">bind</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>