<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>space - piecewise polynomial finite element space (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       space - piecewise polynomial finite element space (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The space class contains the numbering of the <u>degrees</u> <u>of</u> <u>freedoms</u>. The degrees of freedoms are the
       coefficients in the basis of the vectorial space of piecewise polynomial finite element functions. The
       set of degrees of freedom coefficients is splited in two subsets: the <u>unknowns</u> and the <u>blocked</u> degrees of
       freedoms. The blocked degrees of freedom are associated to Dirichlet boundary conditions, where the
       values of the function, and thus, of the coefficients, are prescribed. The unknown degrees of freedom are
       all the others. Finally, the space class is mainly a table of renumbering for these coefficients.

       The space is characterized by two entities: its finite element, described by the <b><a href="../man2/basis.2.html">basis</a>(2)</b> class and its
       mesh, described by the <b><a href="../man2/geo.2.html">geo</a>(2)</b> class. By default, the space is scalar valued. It extends to vector and
       tensor valued functions.

</pre><h4><b>EXAMPLE</b></h4><pre>
           space Q (omega, 'P1');
           space V (omega, 'P2', 'vector');
           space T (omega, 'P1d', 'tensor');

</pre><h4><b>PRODUCT</b> <b>OF</b> <b>SPACES</b></h4><pre>
           space X = T*V*Q;
           space Q2 = pow(Q,2);

</pre><h4><b>SPACE</b> <b>OF</b> <b>REALS</b></h4><pre>
       The 'space::real()' function returns the space of reals and could be used in a product of spaces as:

           space IR = space::real();
           space Yh = Xh*IR;

        This convention is useful e.g. when a Lagrange multiplier is a real, not a field. It extends to IR^n for
       any size_t n as:

           space IRn = pow(IR,n);

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file main/lib/space.h

       The space class is simply an alias to the <b>space_basic</b> <b>class</b>

       typedef space_basic&lt;Float&gt; space;

       The <b>space_basic</b> <b>class</b> <b>provides</b> <b>an</b> <b>interface</b> <b>to</b> <b>a</b> <b>data</b> <b>container:</b>

       template &lt;class T&gt;
       class space_basic&lt;T,sequential&gt; : public smart_pointer&lt;space_rep&lt;T,sequential&gt; &gt; {
       public:

       // typedefs:

           typedef space_rep&lt;T,sequential&gt;   rep;
           typedef smart_pointer&lt;rep&gt;        base;
           typedef typename rep::size_type   size_type;
           typedef typename rep::valued_type valued_type;

       // allocators:

           space_basic (const geo_basic&lt;T,sequential&gt;&amp; omega = (geo_basic&lt;T,sequential&gt;()),
                        std::string approx                   = "",
                        std::string prod_valued              = "scalar");
           space_basic (const geo_basic&lt;T,sequential&gt;&amp; omega,
                        const basis_basic&lt;T&gt;&amp;          b);
           space_basic (const space_mult_list&lt;T,sequential&gt;&amp; expr);
           space_basic (const space_constitution&lt;T,sequential&gt;&amp; constit);
           static space_basic&lt;T,sequential&gt; real();

       // accessors:

           void block  (std::string dom_name);
           void unblock(std::string dom_name);
           void block  (const domain_indirect_basic&lt;sequential&gt;&amp; dom);
           void unblock(const domain_indirect_basic&lt;sequential&gt;&amp; dom);

           void block_n  (std::string dom_name);
           void unblock_n(std::string dom_name);
           void block_n  (const domain_indirect_basic&lt;sequential&gt;&amp; dom);
           void unblock_n(const domain_indirect_basic&lt;sequential&gt;&amp; dom);

           const distributor&amp;  ownership() const;
           const communicator&amp; comm() const;
           size_type           ndof() const;
           size_type           dis_ndof() const;

           const geo_basic&lt;T,sequential&gt;&amp; get_geo() const;
           const basis_basic&lt;T&gt;&amp; get_basis() const;
           size_type size() const;
           valued_type           valued_tag()   const;
           const std::string&amp;    valued()       const;
           space_component&lt;T,sequential&gt;       operator[] (size_type i_comp);
           space_component_const&lt;T,sequential&gt; operator[] (size_type i_comp) const;
           const space_constitution&lt;T,sequential&gt;&amp; get_constitution() const;
           size_type degree() const;
           std::string get_approx() const;
           std::string name() const;

           void dis_idof (const geo_element&amp; K, std::vector&lt;size_type&gt;&amp; dis_idof) const;

           const distributor&amp; iu_ownership() const;
           const distributor&amp; ib_ownership() const;

           bool            is_blocked (size_type     idof) const;
           size_type          dis_iub (size_type     idof) const;
           bool        dis_is_blocked (size_type dis_idof) const;
           size_type dis_idof2dis_iub (size_type dis_idof) const;

           const distributor&amp; ios_ownership() const;
           size_type idof2ios_dis_idof (size_type idof) const;
           size_type ios_idof2dis_idof (size_type ios_idof) const;

           const point_basic&lt;T&gt;&amp; xdof (size_type idof) const;
           const disarray&lt;point_basic&lt;T&gt;,sequential&gt;&amp; get_xdofs() const;

           template &lt;class Function&gt;
           T momentum (const Function&amp; f, size_type idof) const;

           template &lt;class Function&gt;
           point_basic&lt;T&gt; vector_momentum (const Function&amp; f, size_type idof) const;

           template &lt;class Function&gt;
           tensor_basic&lt;T&gt; tensor_momentum (const Function&amp; f, size_type idof) const;

           disarray&lt;size_type, sequential&gt; build_dom_dis_idof2bgd_dis_idof (
               const space_basic&lt;T,sequential&gt;&amp; Wh, const std::string&amp; dom_name) const;

           disarray&lt;size_type, sequential&gt; build_dom_dis_idof2bgd_dis_idof (
               const space_basic&lt;T,sequential&gt;&amp; Wh, const geo_basic&lt;T,sequential&gt;&amp; bgd_gamma) const;

           const std::set&lt;size_type&gt;&amp; ext_iu_set() const { return base::data().ext_iu_set(); }
           const std::set&lt;size_type&gt;&amp; ext_ib_set() const { return base::data().ext_ib_set(); }

       // comparator:

           bool operator== (const space_basic&lt;T,sequential&gt;&amp; V2) const { return base::data().operator==(V2.data()); }
           bool operator!= (const space_basic&lt;T,sequential&gt;&amp; V2) const { return ! operator== (V2); }
           friend bool are_compatible (const space_basic&lt;T,sequential&gt;&amp; V1, const space_basic&lt;T,sequential&gt;&amp; V2) {
               return are_compatible (V1.data(), V2.data()); }

       // for lazy (un-assembled) on geo_domains:

           template &lt;class Set&gt;
           void get_parent_subgeo_owner_dis_indexes (Set&amp; ext_dis_idofs) const
               {        base::data().get_parent_subgeo_owner_dis_indexes (ext_dis_idofs); }
           size_type get_parent_subgeo_owner (size_type dis_idof) const
               { return base::data().get_parent_subgeo_owner (dis_idof); }
       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                   <u><a href="../man2rheolef/space.2rheolef.html">space</a></u>(2rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>