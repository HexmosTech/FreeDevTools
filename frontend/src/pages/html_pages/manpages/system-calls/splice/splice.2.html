<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>splice - splice data to/from a pipe</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       splice - splice data to/from a pipe

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>         /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#define</b> <b>_FILE_OFFSET_BITS</b> <b>64</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;</b>

       <b>ssize_t</b> <b>splice(int</b> <u>fd_in</u><b>,</b> <b>off_t</b> <b>*_Nullable</b> <u>off_in</u><b>,</b>
                      <b>int</b> <u>fd_out</u><b>,</b> <b>off_t</b> <b>*_Nullable</b> <u>off_out</u><b>,</b>
                      <b>size_t</b> <u>len</u><b>,</b> <b>unsigned</b> <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>splice</b>()  moves  data  between two file descriptors without copying between kernel address space and user
       address space.  It transfers up to <u>len</u> bytes  of  data  from  the  file  descriptor  <u>fd_in</u>  to  the  file
       descriptor <u>fd_out</u>, where one of the file descriptors must refer to a pipe.

       The following semantics apply for <u>fd_in</u> and <u>off_in</u>:

       •  If <u>fd_in</u> refers to a pipe, then <u>off_in</u> must be NULL.

       •  If <u>fd_in</u> does not refer to a pipe and <u>off_in</u> is NULL, then bytes are read from <u>fd_in</u> starting from the
          file offset, and the file offset is adjusted appropriately.

       •  If  <u>fd_in</u>  does  not  refer to a pipe and <u>off_in</u> is not NULL, then <u>off_in</u> must point to a buffer which
          specifies the starting offset from which bytes will be read from <u>fd_in</u>; in this case, the file  offset
          of <u>fd_in</u> is not changed.

       Analogous statements apply for <u>fd_out</u> and <u>off_out</u>.

       The <u>flags</u> argument is a bit mask that is composed by ORing together zero or more of the following values:

       <b>SPLICE_F_MOVE</b>
              Attempt  to  move pages instead of copying.  This is only a hint to the kernel: pages may still be
              copied if the kernel cannot move the pages from the pipe, or if the pipe buffers  don't  refer  to
              full pages.  The initial implementation of this flag was buggy: therefore starting in Linux 2.6.21
              it is a no-op (but is still permitted in a <b>splice</b>() call); in the future, a correct implementation
              may be restored.

       <b>SPLICE_F_NONBLOCK</b>
              Do  not  block  on  I/O.   This  makes  the  splice  pipe operations nonblocking, but <b>splice</b>() may
              nevertheless block because the file descriptors that are spliced to/from may  block  (unless  they
              have the <b>O_NONBLOCK</b> flag set).

       <b>SPLICE_F_MORE</b>
              More data will be coming in a subsequent splice.  This is a helpful hint when the <u>fd_out</u> refers to
              a  socket  (see  also  the  description of <b>MSG_MORE</b> in <b><a href="../man2/send.2.html">send</a></b>(2), and the description of <b>TCP_CORK</b> in
              <b><a href="../man7/tcp.7.html">tcp</a></b>(7)).

       <b>SPLICE_F_GIFT</b>
              Unused for <b>splice</b>(); see <b><a href="../man2/vmsplice.2.html">vmsplice</a></b>(2).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, <b>splice</b>() returns the number of bytes spliced to or from the pipe.

       A return value of 0 means end of input.  If <u>fd_in</u> refers to a pipe, then this means  that  there  was  no
       data  to  transfer,  and  it  would not make sense to block because there are no writers connected to the
       write end of the pipe.

       On error, <b>splice</b>() returns -1 and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EAGAIN</b> <b>SPLICE_F_NONBLOCK</b> was specified in <u>flags</u> or one  of  the  file  descriptors  had  been  marked  as
              nonblocking (<b>O_NONBLOCK</b>)<b>,</b> and the operation would block.

       <b>EBADF</b>  One or both file descriptors are not valid, or do not have proper read-write mode.

       <b>EINVAL</b> The target filesystem doesn't support splicing.

       <b>EINVAL</b> The target file is opened in append mode.

       <b>EINVAL</b> Neither of the file descriptors refers to a pipe.

       <b>EINVAL</b> An offset was given for nonseekable device (e.g., a pipe).

       <b>EINVAL</b> <u>fd_in</u> and <u>fd_out</u> refer to the same pipe.

       <b>ENOMEM</b> Out of memory.

       <b>ESPIPE</b> Either <u>off_in</u> or <u>off_out</u> was not NULL, but the corresponding file descriptor refers to a pipe.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.17, glibc 2.5.

       In  Linux  2.6.30  and  earlier,  exactly one of <u>fd_in</u> and <u>fd_out</u> was required to be a pipe.  Since Linux
       2.6.31, both arguments may refer to pipes.

</pre><h4><b>NOTES</b></h4><pre>
       The three system calls <b>splice</b>(), <b><a href="../man2/vmsplice.2.html">vmsplice</a></b>(2), and <b><a href="../man2/tee.2.html">tee</a></b>(2), provide user-space programs with  full  control
       over an arbitrary kernel buffer, implemented within the kernel using the same type of buffer that is used
       for a pipe.  In overview, these system calls perform the following tasks:

       <b>splice</b>()
              moves  data  from the buffer to an arbitrary file descriptor, or vice versa, or from one buffer to
              another.

       <b><a href="../man2/tee.2.html">tee</a></b>(2) "copies" the data from one buffer to another.

       <b><a href="../man2/vmsplice.2.html">vmsplice</a></b>(2)
              "copies" data from user space into the buffer.

       Though we talk of copying, actual copies are generally avoided.  The kernel does this by  implementing  a
       pipe  buffer  as  a  set  of  reference-counted  pointers  to pages of kernel memory.  The kernel creates
       "copies" of pages in a buffer by creating new pointers (for the output buffer) referring  to  the  pages,
       and increasing the reference counts for the pages: only pointers are copied, not the pages of the buffer.

       <b>_FILE_OFFSET_BITS</b>  should  be defined to be 64 in code that uses non-null <u>off_in</u> or <u>off_out</u> or that takes
       the address of <b>splice</b>, if the code is intended to be portable to traditional 32-bit x86 and ARM platforms
       where <b>off_t</b>'s width defaults to 32 bits.

</pre><h4><b>EXAMPLES</b></h4><pre>
       See <b><a href="../man2/tee.2.html">tee</a></b>(2).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/copy_file_range.2.html">copy_file_range</a></b>(2), <b><a href="../man2/sendfile.2.html">sendfile</a></b>(2), <b><a href="../man2/tee.2.html">tee</a></b>(2), <b><a href="../man2/vmsplice.2.html">vmsplice</a></b>(2), <b><a href="../man7/pipe.7.html">pipe</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                          <u><a href="../man2/splice.2.html">splice</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>