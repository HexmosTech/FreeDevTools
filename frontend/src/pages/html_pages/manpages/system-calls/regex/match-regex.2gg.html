<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>match-regex -  (regex)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/golf">golf_601.4.41-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       match-regex -  (regex)

</pre><h4><b>PURPOSE</b></h4><pre>
       Find, or find and replace patterns in strings using regex (regular expressions).

</pre><h4><b>SYNTAX</b></h4><pre>
           match-regex &lt;pattern&gt; in &lt;target&gt; \
               [ \
                   ( replace-with &lt;replace pattern&gt; \
                       result &lt;result&gt; \
                       [ status &lt;status&gt; ] )  \
               | \
                   ( status &lt;status&gt; \
                       [ case-insensitive [ &lt;case-insensitive&gt; ] ] \
                       [ single-match [ &lt;single-match&gt; ] ] \
                       [ utf [ &lt;utf&gt; ] ] ) \
               ] \
               [ cache ] \
               [ clear-cache &lt;clear cache&gt; )

</pre><h4><b>DESCRIPTION</b></h4><pre>
       match-regex  searches  &lt;target&gt;  string  for  regex  &lt;pattern&gt;.  If  "replace-with"  is  specified,  then
       instance(s) of &lt;pattern&gt; in &lt;target&gt; are replaced with &lt;replace pattern&gt; string, and the result is stored
       in &lt;result&gt; string.

       The number of found or found/replaced patterns can be obtained in number &lt;status&gt; variable  (in  "status"
       clause).

       If  "replace-with"  is  not  specified, then the number of matched &lt;pattern&gt;s within &lt;target&gt; is given in
       &lt;status&gt; number, which in this case must be specified.

       If "case-insensitive" is used without  boolean  variable  &lt;case-insensitive&gt;,  or  if  &lt;case-insensitive&gt;
       evaluates to true, then searching for pattern is case insensitive. By default, it is case sensitive.

       If "single-match" is specified without boolean variable &lt;single-match&gt;, or if &lt;single-match&gt; evaluates to
       true,  then  only  the  very  first  occurrence  of  &lt;pattern&gt;  in  &lt;target&gt; is processed. Otherwise, all
       occurrences are processed.

       If "utf" is used, then the pattern itself and all data strings used for matching  are  treated  as  UTF-8
       strings.

       &lt;result&gt; and &lt;status&gt; variables can be created within the statement.

       If  the  pattern  is bad (i.e. &lt;pattern&gt; is not a correct regular expression), Golf will <b>error</b> <b>out</b> with a
       message.

       <b>PCRE2</b> <b>AND</b> <b>POSIX</b> <b>REGEX</b>

       By default, <b>PCRE2</b> <b>regex</b> <b>syntax</b> (Perl-compatible Regular Expressions v2) is used. To  use  <b>extended</b>  <b>regex</b>
       <b>syntax</b>  (Posix  ERE),  specify  "--posix-regex" when building your application with <b>gg</b>. See more below in
       Limitations about differences.

       <b>CACHING</b> <b>AND</b> <b>PERFORMANCE</b>

       If "cache" clause is used, then regex compilation of &lt;pattern&gt; will be  done  only  once  and  saved  for
       future  use. There is a significant performance benefit when match-regex executes repeatedly with "cache"
       (such as in case of web applications or in any kind of loop).  If  &lt;pattern&gt;  changes  and  you  need  to
       recompile  it  once  in  a while, use "clear-cache" clause. &lt;clear cache&gt; is a "bool" variable; the regex
       cache is cleared if it is true, and stays if it is false. For example:

           set-bool cl_c
           if-true q equal 0
               set-bool cl_c = true
           end-if
           match-regex ps in look_in replace-with "Yes it is \e1!" result res cache clear-cache cl_c

       In this case, when "q" is 0, cache will be cleared, and the pattern in variable "ps" will be  recompiled.
       In all other cases, the last computed regex stays the same.

       While  every pattern is different, when using cache, even a relatively small pattern was seen in tests to
       speed up the match-regex by about 500%, or 5x faster. Use cache whenever possible as  it  brings  parsing
       performance close to its theoretical limits.

       <b>SUBEXPRESSIONS</b> <b>AND</b> <b>BACK-REFERENCING</b>

       Subexpressions  are  referenced  via  a  backslash  followed  by a number. Because in strings a backslash
       followed by a number is an octal number, you must use double backslash (\e). For example:

           match-regex "(good).*(day)" \
               in "Hello, good day!" \
               replace-with "\e2 \e1" \
               result res

       will produce string "Hello, day good!" as a result in "res" variable. Each  subexpression  is  within  ()
       parenthesis,  so for instance "day" in the above pattern is the 2nd subexpression, and is back-referenced
       as \e2 in replacement.

       There can be a maximum of 23 subexpressions.

       Note that backreferences to non-existing subexpressions are ignored - for example \e4 when there are only
       3 subexpressions. Golf is "smart" about using two digits and differentiating between  \e1  and  \e10  for
       instance  -  it  takes into account the actual number of subexpressions and their validity, and selects a
       proper subexpression even when two digits are used in a backreference.

       <b>LOOKAHEADS</b> <b>AND</b> <b>LOOKBEHINDS</b>

       match-regex supports  syntax  for  lookaheads  (i.e.  "(?=...)"  and  "(?!...)")  and  lookbehinds  (i.e.
       "(?&lt;=...)"  and  "(?&lt;!...)").  See  <b>PCRE2</b>  <b>pattern</b> <b>matching</b> for more details. For instance, the following
       matches "bar" only if preceded by "foo":

           match-regex "\ew*(?&lt;=foo)bar" in "foobar" status st single-match

       and the following matches "foo" if followed by "bar":

           match-regex "\ew*foo(?=bar)" in "foofoo" status st single-match

       <b>LIMITATIONS</b>

       If you are using older versions of PCRE2 (10.36 or earlier) such as by default in Debian 10 or Ubuntu 18,
       then instead of PCRE2, an <b>Extended</b> <b>Regex</b> <b>Expressions</b> (ERE) from the   built-in  Linux  regex  library  is
       used,  due to older PCRE2 versions having name conflicts with other libraries. In this case, "utf" clause
       will have no effect, and lookaheads/lookbehinds functionality will not work; possibly  a  few  others  as
       well,  however  for the most part the two are compatible. If your system uses an older PCRE2 library, you
       can upgrade to 10.37 or later to use PCRE2.

       In any case, if you need to use Posix ERE instead of PCRE2 (for compatibility, to reduce memory footprint
       or some other reason), you can use "--posix-regex" option of <b>gg</b>; the same  limitations  as  above  apply.
       Note that PCRE2 (the default) is generally faster than ERE.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Use match-regex statement to find out if a string matches a pattern, for example:

           match-regex "SOME (.*) IS (.*)" in "WOW SOME THING IS GOOD HERE" status st

       In  this  case, the first parameter ("SOME (.*) IS (.*)") is a pattern and you're matching it with string
       ("WOW SOME THING IS GOOD HERE"). Since there is a match, status variable (defined on the fly as  integer)
       "st"  will  be  "1"  (meaning  one  match  was found) - in general it will contain the number of patterns
       matched.

       Search for patterns and replace them by using replace-with clause, for example:

           match-regex "SOME (.*) IS ([^ ]+)" in "WOW SOME THING IS GOOD HERE FOR SURE" replace-with "THINGS ARE \e2 YES!" result res status st

       In this case, the result from replacement will be in a new  string  variable  "res"  specified  with  the
       result clause, and it will be

           WOW THINGS ARE GOOD YES! HERE FOR SURE

       The  above  demonstrates  a  typical  use  of subexpressions in regex (meaning "()" statements) and their
       referencing with "\e1", "\e2" etc. in the order in which they appear.  Consult  regex  documentation  for
       more  information.   Status variable specified with status clause ("st" in this example) will contain the
       number of patterns matched and replaced.

       Matching is by default case sensitive. Use "case-insensitive" clause to change it  to  case  insensitive,
       for instance:

           match-regex "SOME (.*) IS (.*)" in "WOW some THING IS GOOD HERE" status st case-insensitive

       In  the  above  case, the pattern would not be found without "case-insensitive" clause because "SOME" and
       "some" would not match. This clause works the same in matching-only as well as replacing strings.

       If you want to match only the first occurrence of a pattern, use "single-match" option:

           match-regex "SOME ([^ ]+) IS ([^ ]+)" in "WOW SOME THING IS GOOD HERE AND SOME STUFF IS GOOD TOO" status st single-match

       In this case there would be two matches by default ("SOME THING IS GOOD" and "SOME STUFF  IS  GOOD")  but
       only  the  first  would  be  found.  This  clause  works  the same for replacing as well - only the first
       occurrence would be replaced.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        Regex

       <b>match-regex</b> See all <b>documentation</b>

$DATE                                               $VERSION                                           <u><a href="../man2gg/GOLF.2gg.html">GOLF</a></u>(2gg)
</pre>
 </div>
</div></section>
</div>
</body>
</html>