<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>diststream - i/o streams in distributed environment (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       diststream - i/o streams in distributed environment (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The idiststream and odiststream classes provide a stream input and output interface for parallel and
       distributed codes. The main difference Recall that, with the usual std::istream and std::ostream, any i/o
       operation are executed on all processes: e.g. the output is printed many times. In contrast, idiststream
       and odiststream manage nicely the distributed environment.

       For small data, e.g. int, double or string, a specific processor is selected for i/o operations. For
       large data, the i/o operations are delegated to a specific class member functions when available.

       For convenience, the standard streams cin, cout, clog and cerr are extended as din, dout, dlog and derr,
       respectively.

</pre><h4><b>FILE</b> <b>SUFFIXES</b></h4><pre>
       Finally, optional suffix extension to the file name is automatically handled:

           odiststream foo('NAME', 'suffix');

        is similar

           ofstream foo('NAME.suffix').

        Conversely,

           irheostream foo('NAME','suffix');

        is similar to

           ifstream foo('NAME.suffix').

</pre><h4><b>FILE</b> <b>SEARCH</b></h4><pre>
       Recursive search in a directory list is provided for finding the input file. However, we look at a search
       path environment variable RHEOPATH in order to find NAME while the suffix is assumed. Moreover, gzip
       compressed files, ending with the .gz suffix are handled, and decompression is done automatically on the
       fly in that case.

</pre><h4><b>COMPRESSION</b></h4><pre>
       File compression/decompresion is handled on the fly, thanks to the gzip library. The data compression is
       assumed by default for output: it can be deactivated while opening a file by an optional argument:

           odiststream foo('NAME', 'suffix', io::nogz);

</pre><h4><b>APPEND</b> <b>MODE</b></h4><pre>
       An existing file, possibly compressed, can be reopen in append mode. New results will be appended at the
       end of an existing file:

           odiststream foo('NAME', 'suffix', io::app);

</pre><h4><b>FLUSH</b></h4><pre>
       The flush member function is nicely handled in compression mode: this feature allows intermediate results
       to be available during long computations. Buffers are flushed and data are available in the output file.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file linalg/lib/diststream.h

       class idiststream {
       public:
         typedef std::size_t size_type;

       // allocators/deallocators:

         idiststream();
         idiststream (std::istream&amp; is, const communicator&amp; comm = communicator());
         idiststream (std::string filename, std::string suffix = "",
                    const communicator&amp; comm = communicator());
         ~idiststream();

       // modifiers:

         void open (std::string filename, std::string suffix = "",
                    const communicator&amp; comm = communicator());
         void close();

       // accessors:

         const communicator&amp; comm() const { return _comm; }
         bool good() const;
         operator bool() const { return good(); }
         static size_type io_proc();

       };

       class odiststream {
       public:
         typedef std::size_t size_type;

       // allocators/deallocators:

         odiststream();
         odiststream (std::string filename, std::string suffix = "",
                     io::mode_type mode = io::out, const communicator&amp; comm = communicator());
         odiststream (std::string filename,
                     io::mode_type mode, const communicator&amp; comm = communicator());
         odiststream (std::string filename, std::string suffix, const communicator&amp; comm);
         odiststream (std::string filename, const communicator&amp; comm);
         odiststream(std::ostream&amp; os, const communicator&amp; comm = communicator());
         ~odiststream();

       // modifiers:

          void open (std::string filename, std::string suffix = "",
                    io::mode_type mode = io::out, const communicator&amp; comm = communicator());
          void open (std::string filename,
                    io::mode_type mode, const communicator&amp; comm = communicator());
          void open (std::string filename, std::string suffix,
                    const communicator&amp; comm);
          void open (std::string filename, const communicator&amp; comm);
          void flush();
          void close();

       // accessors:

          const communicator&amp; comm() const { return _comm; }
          bool good() const;
          operator bool() const { return good(); }
          static size_type io_proc();

       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                              <u><a href="../man2rheolef/diststream.2rheolef.html">diststream</a></u>(2rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>