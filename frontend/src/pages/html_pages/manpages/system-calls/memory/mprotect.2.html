<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mprotect, pkey_mprotect - set protection on a region of memory</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mprotect, pkey_mprotect - set protection on a region of memory

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/mman.h&gt;</b>

       <b>int</b> <b>mprotect(void</b> <u>addr</u><b>[.</b><u>len</u><b>],</b> <b>size_t</b> <u>len</u><b>,</b> <b>int</b> <u>prot</u><b>);</b>

       <b>#define</b> <b>_GNU_SOURCE</b>             /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;sys/mman.h&gt;</b>

       <b>int</b> <b>pkey_mprotect(void</b> <u>addr</u><b>[.</b><u>len</u><b>],</b> <b>size_t</b> <u>len</u><b>,</b> <b>int</b> <u>prot</u><b>,</b> <b>int</b> <u>pkey</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>mprotect</b>()  changes  the access protections for the calling process's memory pages containing any part of
       the address range in the interval [<u>addr</u>, <u>addr</u>+<u>len</u>-1].  <u>addr</u> must be aligned to a page boundary.

       If the calling process tries to access memory in a manner that violates the protections, then the  kernel
       generates a <b>SIGSEGV</b> signal for the process.

       <u>prot</u> is a combination of the following access flags: <b>PROT_NONE</b> or a bitwise OR of the other values in the
       following list:

       <b>PROT_NONE</b>
              The memory cannot be accessed at all.

       <b>PROT_READ</b>
              The memory can be read.

       <b>PROT_WRITE</b>
              The memory can be modified.

       <b>PROT_EXEC</b>
              The memory can be executed.

       <b>PROT_SEM</b> (since Linux 2.5.7)
              The  memory  can  be used for atomic operations.  This flag was introduced as part of the <b><a href="../man2/futex.2.html">futex</a></b>(2)
              implementation (in order to guarantee  the  ability  to  perform  atomic  operations  required  by
              commands such as <b>FUTEX_WAIT</b>), but is not currently used in on any architecture.

       <b>PROT_SAO</b> (since Linux 2.6.26)
              The  memory  should  have  strong  access  ordering.   This  feature  is  specific  to the PowerPC
              architecture (version 2.06 of the architecture specification adds the SAO CPU feature, and  it  is
              available on POWER 7 or PowerPC A2, for example).

       Additionally (since Linux 2.6.0), <u>prot</u> can have one of the following flags set:

       <b>PROT_GROWSUP</b>
              Apply  the  protection  mode  up  to  the end of a mapping that grows upwards.  (Such mappings are
              created for the stack area on architectures—for example, HP-PARISC—that have an  upwardly  growing
              stack.)

       <b>PROT_GROWSDOWN</b>
              Apply  the protection mode down to the beginning of a mapping that grows downward (which should be
              a stack segment or a segment mapped with the <b>MAP_GROWSDOWN</b> flag set).

       Like <b>mprotect</b>(), <b>pkey_mprotect</b>() changes the protection on the pages specified by <u>addr</u> and <u>len</u>.  The <u>pkey</u>
       argument specifies the protection key (see <b><a href="../man7/pkeys.7.html">pkeys</a></b>(7)) to assign to the memory.  The protection key must be
       allocated with <b><a href="../man2/pkey_alloc.2.html">pkey_alloc</a></b>(2) before it is passed to <b>pkey_mprotect</b>().  For an example of the use  of  this
       system call, see <b><a href="../man7/pkeys.7.html">pkeys</a></b>(7).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  <b>mprotect</b>()  and  <b>pkey_mprotect</b>()  return zero.  On error, these system calls return -1, and
       <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EACCES</b> The memory cannot be given the specified access.  This can happen, for example, if you  <b><a href="../man2/mmap.2.html">mmap</a></b>(2)  a
              file to which you have read-only access, then ask <b>mprotect</b>() to mark it <b>PROT_WRITE</b>.

       <b>EINVAL</b> <u>addr</u> is not a valid pointer, or not a multiple of the system page size.

       <b>EINVAL</b> (<b>pkey_mprotect</b>()) <u>pkey</u> has not been allocated with <b><a href="../man2/pkey_alloc.2.html">pkey_alloc</a></b>(2)

       <b>EINVAL</b> Both <b>PROT_GROWSUP</b> and <b>PROT_GROWSDOWN</b> were specified in <u>prot</u>.

       <b>EINVAL</b> Invalid flags specified in <u>prot</u>.

       <b>EINVAL</b> (PowerPC architecture) <b>PROT_SAO</b> was specified in <u>prot</u>, but SAO hardware feature is not available.

       <b>ENOMEM</b> Internal kernel structures could not be allocated.

       <b>ENOMEM</b> Addresses  in  the  range  [<u>addr</u>, <u>addr</u>+<u>len</u>-1] are invalid for the address space of the process, or
              specify one or more pages that are not  mapped.   (Before  Linux  2.4.19,  the  error  <b>EFAULT</b>  was
              incorrectly produced for these cases.)

       <b>ENOMEM</b> Changing  the  protection  of  a  memory  region would result in the total number of mappings with
              distinct attributes (e.g., read versus read/write protection) exceeding the allowed maximum.  (For
              example, making the protection of a range <b>PROT_READ</b> in the middle of a region currently  protected
              as  <b>PROT_READ|PROT_WRITE</b> would result in three mappings: two read/write mappings at each end and a
              read-only mapping in the middle.)

</pre><h4><b>VERSIONS</b></h4><pre>
       POSIX says that the behavior of <b>mprotect</b>() is unspecified if it is applied to a region of memory that was
       not obtained via <b><a href="../man2/mmap.2.html">mmap</a></b>(2).

       On Linux, it is always permissible to call <b>mprotect</b>() on any address in a process's address space (except
       for the kernel vsyscall area).  In particular, it can be used to change  existing  code  mappings  to  be
       writable.

       Whether  <b>PROT_EXEC</b>  has  any  effect  different  from <b>PROT_READ</b> depends on processor architecture, kernel
       version, and process state.  If  <b>READ_IMPLIES_EXEC</b>  is  set  in  the  process's  personality  flags  (see
       <b><a href="../man2/personality.2.html">personality</a></b>(2)), specifying <b>PROT_READ</b> will implicitly add <b>PROT_EXEC</b>.

       On some hardware architectures (e.g., i386), <b>PROT_WRITE</b> implies <b>PROT_READ</b>.

       POSIX.1 says that an implementation may permit access other than that specified in <u>prot</u>, but at a minimum
       can  allow  write  access only if <b>PROT_WRITE</b> has been set, and must not allow any access if <b>PROT_NONE</b> has
       been set.

       Applications should be careful  when  mixing  use  of  <b>mprotect</b>()  and  <b>pkey_mprotect</b>().   On  x86,  when
       <b>mprotect</b>() is used with <u>prot</u> set to <b>PROT_EXEC</b> a pkey may be allocated and set on the memory implicitly by
       the kernel, but only when the pkey was 0 previously.

       On  systems  that do not support protection keys in hardware, <b>pkey_mprotect</b>() may still be used, but <u>pkey</u>
       must be set to -1.  When called this way, the operation of <b>pkey_mprotect</b>() is equivalent to <b>mprotect</b>().

</pre><h4><b>STANDARDS</b></h4><pre>
       <b>mprotect</b>()
              POSIX.1-2008.

       <b>pkey_mprotect</b>()
              Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>mprotect</b>()
              POSIX.1-2001, SVr4.

       <b>pkey_mprotect</b>()
              Linux 4.9, glibc 2.27.

</pre><h4><b>NOTES</b></h4><pre>
</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below demonstrates the use of <b>mprotect</b>().  The program allocates four pages of memory,  makes
       the  third  of  these  pages  read-only, and then executes a loop that walks upward through the allocated
       region modifying bytes.

       An example of what we might see when running the program is the following:

           $ <b>./a.out</b>
           Start of region:        0x804c000
           Got SIGSEGV at address: 0x804e000

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/malloc.h">malloc.h</a>&gt;
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/mman.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       #define <a href="../manmsg/handle_error.msg.html">handle_error</a>(msg) \
           do { <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); } while (0)

       static char *buffer;

       static void
       handler(int sig, siginfo_t *si, void *unused)
       {
           /* Note: calling printf() from a signal handler is not safe
              (and should not be done in production programs), since
              printf() is not async-signal-safe; see <a href="../man7/signal-safety.7.html">signal-safety</a>(7).
              Nevertheless, we use printf() here as a simple way of
              showing that the handler was called. */

           printf("Got SIGSEGV at address: %p\n", si-&gt;si_addr);
           exit(EXIT_FAILURE);
       }

       int
       main(void)
       {
           int               pagesize;
           struct sigaction  sa;

           sa.sa_flags = SA_SIGINFO;
           sigemptyset(&amp;sa.sa_mask);
           sa.sa_sigaction = handler;
           if (sigaction(SIGSEGV, &amp;sa, NULL) == -1)
               handle_error("sigaction");

           pagesize = sysconf(_SC_PAGE_SIZE);
           if (pagesize == -1)
               handle_error("sysconf");

           /* Allocate a buffer aligned on a page boundary;
              initial protection is PROT_READ | PROT_WRITE. */

           buffer = memalign(pagesize, 4 * pagesize);
           if (buffer == NULL)
               handle_error("memalign");

           printf("Start of region:        %p\n", buffer);

           if (mprotect(buffer + pagesize * 2, pagesize,
                        PROT_READ) == -1)
               handle_error("mprotect");

           for (char *p = buffer ; ; )
               *(p++) = 'a';

           printf("Loop completed\n");     /* Should never happen */
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man3/sysconf.3.html">sysconf</a></b>(3), <b><a href="../man7/pkeys.7.html">pkeys</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                        <u><a href="../man2/mprotect.2.html">mprotect</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>