<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mbind - set memory policy for a memory range</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mbind - set memory policy for a memory range

</pre><h4><b>LIBRARY</b></h4><pre>
       NUMA (Non-Uniform Memory Access) policy library (<u>libnuma</u>, <u>-lnuma</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;numaif.h&gt;</b>

       <b>long</b> <b>mbind(void</b> <u>addr</u><b>[.</b><u>len</u><b>],</b> <b>unsigned</b> <b>long</b> <u>len</u><b>,</b> <b>int</b> <u>mode</u><b>,</b>
                  <b>const</b> <b>unsigned</b> <b>long</b> <u>nodemask</u><b>[(.</b><u>maxnode</u> <b>+</b> <b>ULONG_WIDTH</b> <b>-</b> <b>1)</b>
                                               <b>/</b> <b>ULONG_WIDTH],</b>
                  <b>unsigned</b> <b>long</b> <u>maxnode</u><b>,</b> <b>unsigned</b> <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>mbind</b>()  sets  the  NUMA  memory  policy, which consists of a policy mode and zero or more nodes, for the
       memory range starting with <u>addr</u> and continuing for <u>len</u> bytes.  The memory policy defines from which  node
       memory is allocated.

       If the memory range specified by the <u>addr</u> and <u>len</u> arguments includes an "anonymous" region of memory—that
       is  a  region  of  memory created using the <b><a href="../man2/mmap.2.html">mmap</a></b>(2) system call with the <b>MAP_ANONYMOUS</b>—or a memory-mapped
       file, mapped using the <b><a href="../man2/mmap.2.html">mmap</a></b>(2) system call with the  <b>MAP_PRIVATE</b>  flag,  pages  will  be  allocated  only
       according  to  the  specified  policy  when  the  application writes (stores) to the page.  For anonymous
       regions, an initial read access will use a shared page in the kernel containing all zeros.   For  a  file
       mapped with <b>MAP_PRIVATE</b>, an initial read access will allocate pages according to the memory policy of the
       thread that causes the page to be allocated.  This may not be the thread that called <b>mbind</b>().

       The  specified  policy will be ignored for any <b>MAP_SHARED</b> mappings in the specified memory range.  Rather
       the pages will be allocated according to the memory policy of the thread  that  caused  the  page  to  be
       allocated.  Again, this may not be the thread that called <b>mbind</b>().

       If the specified memory range includes a shared memory region created using the <b><a href="../man2/shmget.2.html">shmget</a></b>(2) system call and
       attached  using  the <b><a href="../man2/shmat.2.html">shmat</a></b>(2) system call, pages allocated for the anonymous or shared memory region will
       be allocated according to the policy specified, regardless of which process attached to the shared memory
       segment causes the allocation.  If, however, the shared memory region was created  with  the  <b>SHM_HUGETLB</b>
       flag,  the  huge pages will be allocated according to the policy specified only if the page allocation is
       caused by the process that calls <b>mbind</b>() for that region.

       By default, <b>mbind</b>() has an effect only for new allocations; if the  pages  inside  the  range  have  been
       already  touched  before setting the policy, then the policy has no effect.  This default behavior may be
       overridden by the <b>MPOL_MF_MOVE</b> and <b>MPOL_MF_MOVE_ALL</b> flags described below.

       The <u>mode</u> argument must specify one of <b>MPOL_DEFAULT</b>, <b>MPOL_BIND</b>, <b>MPOL_INTERLEAVE</b>, <b>MPOL_WEIGHTED_INTERLEAVE</b>,
       <b>MPOL_PREFERRED</b>,  or  <b>MPOL_LOCAL</b>  (which  are  described  in  detail  below).   All  policy  modes  except
       <b>MPOL_DEFAULT</b>  require the caller to specify the node or nodes to which the mode applies, via the <u>nodemask</u>
       argument.

       The <u>mode</u> argument may also include an optional <u>mode</u> <u>flag</u>.  The supported <u>mode</u> <u>flags</u> are:

       <b>MPOL_F_NUMA_BALANCING</b> (since Linux 5.15)
              When <u>mode</u> is <b>MPOL_BIND</b>, enable the kernel NUMA balancing for the task if it is  supported  by  the
              kernel.   If the flag isn't supported by the kernel, or is used with <u>mode</u> other than <b>MPOL_BIND</b>, -1
              is returned and <u>errno</u> is set to <b>EINVAL</b>.

       <b>MPOL_F_STATIC_NODES</b> (since Linux-2.6.26)
              A nonempty <u>nodemask</u> specifies physical node IDs.  Linux does  not  remap  the  <u>nodemask</u>  when  the
              thread  moves  to  a  different  cpuset context, nor when the set of nodes allowed by the thread's
              current cpuset context changes.

       <b>MPOL_F_RELATIVE_NODES</b> (since Linux-2.6.26)
              A nonempty <u>nodemask</u> specifies node IDs that are relative to the set of node  IDs  allowed  by  the
              thread's current cpuset.

       <u>nodemask</u>  points  to  a bit mask of nodes containing up to <u>maxnode</u> bits.  The bit mask size is rounded to
       the next multiple of <u>sizeof(unsigned</u> <u>long)</u>, but the kernel will use bits only  up  to  <u>maxnode</u>.   A  NULL
       value  of  <u>nodemask</u> or a <u>maxnode</u> value of zero specifies the empty set of nodes.  If the value of <u>maxnode</u>
       is zero, the <u>nodemask</u> argument is ignored.  Where a <u>nodemask</u> is required, it must contain  at  least  one
       node that is on-line, allowed by the thread's current cpuset context (unless the <b>MPOL_F_STATIC_NODES</b> mode
       flag is specified), and contains memory.

       The <u>mode</u> argument must include one of the following values:

       <b>MPOL_DEFAULT</b>
              This  mode  requests  that  any  nondefault  policy  be removed, restoring default behavior.  When
              applied to a range of memory via <b>mbind</b>(), this means to use the thread memory  policy,  which  may
              have  been  set  with  <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2).   If  the  mode  of  the  thread  memory  policy  is also
              <b>MPOL_DEFAULT</b>, the system-wide default  policy  will  be  used.   The  system-wide  default  policy
              allocates  pages  on  the  node  of  the  CPU that triggers the allocation.  For <b>MPOL_DEFAULT</b>, the
              <u>nodemask</u> and <u>maxnode</u> arguments must be specify the empty set of nodes.

       <b>MPOL_BIND</b>
              This mode specifies a strict policy that restricts memory allocation to  the  nodes  specified  in
              <u>nodemask</u>.  If <u>nodemask</u> specifies more than one node, page allocations will come from the node with
              sufficient  free  memory that is closest to the node where the allocation takes place.  Pages will
              not be allocated from any node not specified in the IR nodemask  .   (Before  Linux  2.6.26,  page
              allocations came from the node with the lowest numeric node ID first, until that node contained no
              free  memory.   Allocations  then  came  from  the node with the next highest node ID specified in
              <u>nodemask</u> and so forth, until none of the specified nodes contained free memory.)

       <b>MPOL_INTERLEAVE</b>
              This mode specifies that page allocations be interleaved across the  set  of  nodes  specified  in
              <u>nodemask</u>.   This  optimizes  for  bandwidth  instead  of latency by spreading out pages and memory
              accesses to those pages across multiple nodes.  To be effective the memory area should  be  fairly
              large, at least 1 MB or bigger with a fairly uniform access pattern.  Accesses to a single page of
              the area will still be limited to the memory bandwidth of a single node.

       <b>MPOL_WEIGHTED_INTERLEAVE</b> (since Linux 6.9)
              This  mode  interleaves  page  allocations across the nodes specified in <u>nodemask</u> according to the
              weights in <u>/sys/kernel/mm/mempolicy/weighted_interleave</u>.  For example, if bits 0, 2, and 5 are set
              in   <u>nodemask</u>,   and   the   contents    of    <u>/sys/kernel/mm/mempolicy/weighted_interleave/node0</u>,
              <u><a href="file:/sys/">/sys/</a></u>...<u>/node2</u>,  and  <u><a href="file:/sys/">/sys/</a></u>...<u>/node5</u> are 4, 7, and 9, respectively, then pages in this region will
              be allocated on nodes 0, 2, and 5 in a 4:7:9 ratio.

       <b>MPOL_PREFERRED</b>
              This mode sets the preferred node for allocation.  The kernel will try to allocate pages from this
              node first and fall back to other nodes if the preferred nodes is low on free memory.  If <u>nodemask</u>
              specifies more than one node ID, the first node in the mask will  be  selected  as  the  preferred
              node.   If  the <u>nodemask</u> and <u>maxnode</u> arguments specify the empty set, then the memory is allocated
              on the node of the CPU that triggered the allocation.

       <b>MPOL_LOCAL</b> (since Linux 3.8)
              This mode specifies "local allocation"; the memory is allocated  on  the  node  of  the  CPU  that
              triggered  the allocation (the "local node").  The <u>nodemask</u> and <u>maxnode</u> arguments must specify the
              empty set.  If the "local node" is low on free memory, the kernel will try to allocate memory from
              other nodes.  The kernel will allocate memory from the "local node" whenever memory for this  node
              is  available.   If  the  "local  node" is not allowed by the thread's current cpuset context, the
              kernel will try to allocate memory from other nodes.  The kernel will  allocate  memory  from  the
              "local  node"  whenever  it  becomes allowed by the thread's current cpuset context.  By contrast,
              <b>MPOL_DEFAULT</b> reverts to the memory policy of the thread (which may be set  via  <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2));
              that policy may be something other than "local allocation".

       If <b>MPOL_MF_STRICT</b> is passed in <u>flags</u> and <u>mode</u> is not <b>MPOL_DEFAULT</b>, then the call fails with the error <b>EIO</b>
       if the existing pages in the memory range don't follow the policy.

       If <b>MPOL_MF_MOVE</b> is specified in <u>flags</u>, then the kernel will attempt to move all the existing pages in the
       memory  range  so  that  they  follow the policy.  Pages that are shared with other processes will not be
       moved.  If <b>MPOL_MF_STRICT</b> is also specified, then the call fails with the error <b>EIO</b> if some  pages  could
       not be moved.  If the <b>MPOL_INTERLEAVE</b> policy was specified, pages already residing on the specified nodes
       will not be moved such that they are interleaved.

       If  <b>MPOL_MF_MOVE_ALL</b>  is  passed in <u>flags</u>, then the kernel will attempt to move all existing pages in the
       memory range regardless of whether other processes use the pages.  The calling thread must be  privileged
       (<b>CAP_SYS_NICE</b>) to use this flag.  If <b>MPOL_MF_STRICT</b> is also specified, then the call fails with the error
       <b>EIO</b>  if  some  pages  could  not  be  moved.   If the <b>MPOL_INTERLEAVE</b> policy was specified, pages already
       residing on the specified nodes will not be moved such that they are interleaved.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>mbind</b>() returns 0; on error, -1 is returned and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> Part or all of the memory range specified by <u>nodemask</u> and <u>maxnode</u> points outside  your  accessible
              address space.  Or, there was an unmapped hole in the specified memory range specified by <u>addr</u> and
              <u>len</u>.

       <b>EINVAL</b> An invalid value was specified for <u>flags</u> or <u>mode</u>; or <u>addr</u> <u>+</u> <u>len</u> was less than <u>addr</u>; or <u>addr</u> is not
              a  multiple  of  the system page size.  Or, <u>mode</u> is <b>MPOL_DEFAULT</b> and <u>nodemask</u> specified a nonempty
              set; or <u>mode</u> is <b>MPOL_BIND</b> or <b>MPOL_INTERLEAVE</b> and <u>nodemask</u> is empty.  Or, <u>maxnode</u> exceeds a kernel-
              imposed limit.  Or, <u>nodemask</u> specifies one or more node IDs that  are  greater  than  the  maximum
              supported  node ID.  Or, none of the node IDs specified by <u>nodemask</u> are on-line and allowed by the
              thread's current cpuset context, or none of the specified nodes  contain  memory.   Or,  the  <u>mode</u>
              argument specified both <b>MPOL_F_STATIC_NODES</b> and <b>MPOL_F_RELATIVE_NODES</b>.

       <b>EIO</b>    <b>MPOL_MF_STRICT</b>  was  specified and an existing page was already on a node that does not follow the
              policy; or <b>MPOL_MF_MOVE</b> or <b>MPOL_MF_MOVE_ALL</b> was specified and the kernel was unable  to  move  all
              existing pages in the range.

       <b>ENOMEM</b> Insufficient kernel memory was available.

       <b>EPERM</b>  The  <u>flags</u>  argument  included  the  <b>MPOL_MF_MOVE_ALL</b>  flag  and  the  caller  does  not  have the
              <b>CAP_SYS_NICE</b> privilege.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.7.

       Support for huge page policy was added with Linux 2.6.16.  For interleave policy to be effective on  huge
       page mappings the policied memory needs to be tens of megabytes or larger.

       Before Linux 5.7.  <b>MPOL_MF_STRICT</b> was ignored on huge page mappings.

       <b>MPOL_MF_MOVE</b> and <b>MPOL_MF_MOVE_ALL</b> are available only on Linux 2.6.16 and later.

</pre><h4><b>NOTES</b></h4><pre>
       For information on library support, see <b><a href="../man7/numa.7.html">numa</a></b>(7).

       NUMA policy is not supported on a memory-mapped file range that was mapped with the <b>MAP_SHARED</b> flag.

       The  <b>MPOL_DEFAULT</b> mode can have different effects for <b>mbind</b>() and <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2).  When <b>MPOL_DEFAULT</b> is
       specified for <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2), the thread's memory policy reverts to the system default policy or  local
       allocation.   When  <b>MPOL_DEFAULT</b> is specified for a range of memory using <b>mbind</b>(), any pages subsequently
       allocated for that range will  use  the  thread's  memory  policy,  as  set  by  <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2).   This
       effectively removes the explicit policy from the specified range, "falling back" to a possibly nondefault
       policy.   To  select  explicit  "local  allocation"  for  a memory range, specify a <u>mode</u> of <b>MPOL_LOCAL</b> or
       <b>MPOL_PREFERRED</b> with an empty set of nodes.  This method will work for <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2), as well.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/get_mempolicy.2.html">get_mempolicy</a></b>(2), <b><a href="../man2/getcpu.2.html">getcpu</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2), <b><a href="../man2/shmat.2.html">shmat</a></b>(2), <b><a href="../man2/shmget.2.html">shmget</a></b>(2), <b><a href="../man3/numa.3.html">numa</a></b>(3), <b><a href="../man7/cpuset.7.html">cpuset</a></b>(7), <b><a href="../man7/numa.7.html">numa</a></b>(7),
       <b><a href="../man8/numactl.8.html">numactl</a></b>(8)

Linux man-pages 6.9.1                              2024-05-02                                           <u><a href="../man2/mbind.2.html">mbind</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>