<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>set_mempolicy - set default NUMA memory policy for a thread and its children</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       set_mempolicy - set default NUMA memory policy for a thread and its children

</pre><h4><b>LIBRARY</b></h4><pre>
       NUMA (Non-Uniform Memory Access) policy library (<u>libnuma</u>, <u>-lnuma</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;numaif.h&gt;</b>

       <b>long</b> <b>set_mempolicy(int</b> <u>mode</u><b>,</b> <b>const</b> <b>unsigned</b> <b>long</b> <b>*</b><u>nodemask</u><b>,</b>
                          <b>unsigned</b> <b>long</b> <u>maxnode</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>set_mempolicy</b>()  sets  the  NUMA memory policy of the calling thread, which consists of a policy mode and
       zero or more nodes, to the values specified by the <u>mode</u>, <u>nodemask</u>, and <u>maxnode</u> arguments.

       A NUMA machine has different memory controllers with different distances to specific  CPUs.   The  memory
       policy defines from which node memory is allocated for the thread.

       This  system  call  defines  the  default policy for the thread.  The thread policy governs allocation of
       pages in the process's address space outside of memory ranges controlled by a more specific policy set by
       <b><a href="../man2/mbind.2.html">mbind</a></b>(2).  The thread default policy also controls allocation of any pages for memory-mapped files mapped
       using the <b><a href="../man2/mmap.2.html">mmap</a></b>(2) call with the <b>MAP_PRIVATE</b> flag and that are only read (loaded) from by the  thread  and
       of  memory-mapped  files mapped using the <b><a href="../man2/mmap.2.html">mmap</a></b>(2) call with the <b>MAP_SHARED</b> flag, regardless of the access
       type.  The policy is applied only when a new page is allocated for the thread.  For anonymous memory this
       is when the page is first touched by the thread.

       The <u>mode</u> argument must specify one of <b>MPOL_DEFAULT</b>, <b>MPOL_BIND</b>, <b>MPOL_INTERLEAVE</b>, <b>MPOL_WEIGHTED_INTERLEAVE</b>,
       <b>MPOL_PREFERRED</b>, or <b>MPOL_LOCAL</b> (which are described in  detail  below).   All  modes  except  <b>MPOL_DEFAULT</b>
       require the caller to specify the node or nodes to which the mode applies, via the <u>nodemask</u> argument.

       The <u>mode</u> argument may also include an optional <u>mode</u> <u>flag</u>.  The supported <u>mode</u> <u>flags</u> are:

       <b>MPOL_F_NUMA_BALANCING</b> (since Linux 5.12)
              When  <u>mode</u>  is  <b>MPOL_BIND</b>, enable the kernel NUMA balancing for the task if it is supported by the
              kernel.  If the flag isn't supported by the kernel, or is used with <u>mode</u> other than <b>MPOL_BIND</b>,  -1
              is returned and <u>errno</u> is set to <b>EINVAL</b>.

       <b>MPOL_F_RELATIVE_NODES</b> (since Linux 2.6.26)
              A  nonempty  <u>nodemask</u>  specifies  node IDs that are relative to the set of node IDs allowed by the
              process's current cpuset.

       <b>MPOL_F_STATIC_NODES</b> (since Linux 2.6.26)
              A nonempty <u>nodemask</u> specifies physical node IDs.  Linux will  not  remap  the  <u>nodemask</u>  when  the
              process  moves  to  a different cpuset context, nor when the set of nodes allowed by the process's
              current cpuset context changes.

       <u>nodemask</u> points to a bit mask of node IDs that contains up to <u>maxnode</u> bits.  The bit mask size is rounded
       to the next multiple of <u>sizeof(unsigned</u> <u>long)</u>, but the kernel will use bits only up to <u>maxnode</u>.   A  NULL
       value  of  <u>nodemask</u> or a <u>maxnode</u> value of zero specifies the empty set of nodes.  If the value of <u>maxnode</u>
       is zero, the <u>nodemask</u> argument is ignored.

       Where a <u>nodemask</u> is required, it must contain at least one node that is on-line, allowed by the process's
       current cpuset context, (unless the <b>MPOL_F_STATIC_NODES</b> mode flag is specified), and contains memory.  If
       the <b>MPOL_F_STATIC_NODES</b> is set in <u>mode</u> and a required <u>nodemask</u> contains no nodes that are allowed by  the
       process's  current  cpuset  context,  the  memory  policy  reverts to <u>local</u> <u>allocation</u>.  This effectively
       overrides the specified policy until the process's cpuset context includes  one  or  more  of  the  nodes
       specified by <u>nodemask</u>.

       The <u>mode</u> argument must include one of the following values:

       <b>MPOL_DEFAULT</b>
              This mode specifies that any nondefault thread memory policy be removed, so that the memory policy
              "falls  back"  to the system default policy.  The system default policy is "local allocation"â€”that
              is, allocate memory on the node of the CPU  that  triggered  the  allocation.   <u>nodemask</u>  must  be
              specified  as  NULL.   If  the  "local  node"  contains no free memory, the system will attempt to
              allocate memory from a "near by" node.

       <b>MPOL_BIND</b>
              This mode defines a strict policy that restricts memory  allocation  to  the  nodes  specified  in
              <u>nodemask</u>.  If <u>nodemask</u> specifies more than one node, page allocations will come from the node with
              the  lowest numeric node ID first, until that node contains no free memory.  Allocations will then
              come from the node with the next highest node ID specified in <u>nodemask</u> and so forth, until none of
              the specified nodes contain free memory.  Pages will not be allocated from any node not  specified
              in the <u>nodemask</u>.

       <b>MPOL_INTERLEAVE</b>
              This  mode  interleaves page allocations across the nodes specified in <u>nodemask</u> in numeric node ID
              order.  This optimizes for bandwidth instead of latency by spreading out pages and memory accesses
              to those pages across multiple nodes.  However, accesses to a single page will still be limited to
              the memory bandwidth of a single node.

       <b>MPOL_WEIGHTED_INTERLEAVE</b> (since Linux 6.9)
              This mode interleaves page allocations across the nodes specified in  <u>nodemask</u>  according  to  the
              weights in <u>/sys/kernel/mm/mempolicy/weighted_interleave</u>.  For example, if bits 0, 2, and 5 are set
              in    <u>nodemask</u>,    and   the   contents   of   <u>/sys/kernel/mm/mempolicy/weighted_interleave/node0</u>,
              <u><a href="file:/sys/">/sys/</a></u>...<u>/node2</u>, and <u><a href="file:/sys/">/sys/</a></u>...<u>/node5</u> are 4, 7, and 9, respectively, then pages in this  region  will
              be allocated on nodes 0, 2, and 5 in a 4:7:9 ratio.

       <b>MPOL_PREFERRED</b>
              This mode sets the preferred node for allocation.  The kernel will try to allocate pages from this
              node  first  and  fall  back  to  "near by" nodes if the preferred node is low on free memory.  If
              <u>nodemask</u> specifies more than one node ID, the first node in the  mask  will  be  selected  as  the
              preferred  node.   If  the  <u>nodemask</u>  and <u>maxnode</u> arguments specify the empty set, then the policy
              specifies "local allocation" (like the system default policy discussed above).

       <b>MPOL_LOCAL</b> (since Linux 3.8)
              This mode specifies "local allocation"; the memory is allocated  on  the  node  of  the  CPU  that
              triggered  the allocation (the "local node").  The <u>nodemask</u> and <u>maxnode</u> arguments must specify the
              empty set.  If the "local node" is low on free memory, the kernel will try to allocate memory from
              other nodes.  The kernel will allocate memory from the "local node" whenever memory for this  node
              is  available.   If  the  "local node" is not allowed by the process's current cpuset context, the
              kernel will try to allocate memory from other nodes.  The kernel will  allocate  memory  from  the
              "local node" whenever it becomes allowed by the process's current cpuset context.

       The  thread  memory  policy  is  preserved across an <b><a href="../man2/execve.2.html">execve</a></b>(2), and is inherited by child threads created
       using <b><a href="../man2/fork.2.html">fork</a></b>(2) or <b><a href="../man2/clone.2.html">clone</a></b>(2).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>set_mempolicy</b>() returns 0; on error, -1 is returned and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> Part of all of the memory range specified by <u>nodemask</u> and <u>maxnode</u> points outside  your  accessible
              address space.

       <b>EINVAL</b> <u>mode</u>  is  invalid.   Or,  <u>mode</u>  is  <b>MPOL_DEFAULT</b> and <u>nodemask</u> is nonempty, or <u>mode</u> is <b>MPOL_BIND</b> or
              <b>MPOL_INTERLEAVE</b> and <u>nodemask</u> is empty.  Or, <u>maxnode</u> specifies more than a page worth of bits.  Or,
              <u>nodemask</u> specifies one or more node IDs that are greater than the maximum supported node ID.   Or,
              none of the node IDs specified by <u>nodemask</u> are on-line and allowed by the process's current cpuset
              context,  or  none  of  the  specified nodes contain memory.  Or, the <u>mode</u> argument specified both
              <b>MPOL_F_STATIC_NODES</b> and <b>MPOL_F_RELATIVE_NODES</b>.  Or, the <b>MPOL_F_NUMA_BALANCING</b> isn't  supported  by
              the kernel, or is used with <u>mode</u> other than <b>MPOL_BIND</b>.

       <b>ENOMEM</b> Insufficient kernel memory was available.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.7.

</pre><h4><b>NOTES</b></h4><pre>
       Memory  policy  is not remembered if the page is swapped out.  When such a page is paged back in, it will
       use the policy of the thread or memory range that is in effect at the time the page is allocated.

       For information on library support, see <b><a href="../man7/numa.7.html">numa</a></b>(7).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/get_mempolicy.2.html">get_mempolicy</a></b>(2), <b><a href="../man2/getcpu.2.html">getcpu</a></b>(2), <b><a href="../man2/mbind.2.html">mbind</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man3/numa.3.html">numa</a></b>(3), <b><a href="../man7/cpuset.7.html">cpuset</a></b>(7), <b><a href="../man7/numa.7.html">numa</a></b>(7), <b><a href="../man8/numactl.8.html">numactl</a></b>(8)

Linux man-pages 6.9.1                              2024-05-02                                   <u><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>