<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mmap — allocate memory, or map files or devices into memory</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mmap — allocate memory, or map files or devices into memory

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/mman.h&gt;</b>

       <u>void</u> <u>*</u>
       <b>mmap</b>(<u>void</u> <u>*addr</u>, <u>size_t</u> <u>len</u>, <u>int</u> <u>prot</u>, <u>int</u> <u>flags</u>, <u>int</u> <u>fd</u>, <u>off_t</u> <u>offset</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>mmap</b>()  system  call  causes  the  pages starting at <u>addr</u> and continuing for at most <u>len</u> bytes to be
       mapped from the object described by <u>fd</u>, starting at byte offset <u>offset</u>.  If <u>len</u> is not a multiple of  the
       page  size,  the mapped region may extend past the specified range.  Any such extension beyond the end of
       the mapped object will be zero-filled.

       If <u>fd</u> references a regular file or a shared memory object, the range of  bytes  starting  at  <u>offset</u>  and
       continuing  for  <u>len</u>  bytes  must be legitimate for the possible (not necessarily current) offsets in the
       object.  In particular, the <u>offset</u> value cannot be negative.  If the object is truncated and the  process
       later  accesses  a  page  that  is wholly within the truncated region, the access is aborted and a SIGBUS
       signal is delivered to the process.

       If <u>fd</u> references a device file, the interpretation of the <u>offset</u> value is device specific and defined  by
       the  device  driver.  The virtual memory subsystem does not impose any restrictitions on the <u>offset</u> value
       in this case, passing it unchanged to the driver.

       If <u>addr</u> is non-zero, it is used as a hint to the system.  (As a convenience to  the  system,  the  actual
       address  of  the  region  may  differ  from  the  address supplied.)  If <u>addr</u> is zero, an address will be
       selected by the system.  The actual starting address of  the  region  is  returned.   A  successful  <u>mmap</u>
       deletes any previous mapping in the allocated address range.

       The protections (region accessibility) are specified in the <u>prot</u> argument by <u>or</u>'ing the following values:

       PROT_NONE   Pages may not be accessed.
       PROT_READ   Pages may be read.
       PROT_WRITE  Pages may be written.
       PROT_EXEC   Pages may be executed.

       The  <u>flags</u>  argument  specifies  the type of the mapped object, mapping options and whether modifications
       made to the mapped copy of the page are private to the process or are to be shared with other references.
       Sharing, mapping type and options are specified in the <u>flags</u> argument by <u>or</u>'ing the following values:

       MAP_32BIT          Request a region in the first 2GB of  the  current  process's  address  space.   If  a
                          suitable  region  cannot  be  found, <b>mmap</b>() will fail.  This flag is only available on
                          64-bit platforms.

       MAP_ALIGNED(<u>n</u>)     Align the region on a requested boundary.  If  a  suitable  region  cannot  be  found,
                          <b>mmap</b>()  will  fail.   The  <u>n</u>  argument  specifies  the binary logarithm of the desired
                          alignment.

       MAP_ALIGNED_SUPER  Align the region to maximize the  potential  use  of  large  (“super”)  pages.   If  a
                          suitable  region cannot be found, <b>mmap</b>() will fail.  The system will choose a suitable
                          page size based on the size of mapping.  The page size used as well as  the  alignment
                          of  the  region  may  both  be  affected  by  properties of the file being mapped.  In
                          particular, the physical address of existing pages of a file may  require  a  specific
                          alignment.  The region is not guaranteed to be aligned on any specific boundary.

       MAP_ANON           Map  anonymous memory not associated with any specific file.  The file descriptor used
                          for creating MAP_ANON must be -1.  The <u>offset</u> argument must be 0.

       MAP_ANONYMOUS      This flag is identical to MAP_ANON and is provided for compatibility.

       MAP_EXCL           This flag can only be used in combination with MAP_FIXED.  Please see  the  definition
                          of MAP_FIXED for the description of its effect.

       MAP_FIXED          Do not permit the system to select a different address than the one specified.  If the
                          specified  address  cannot be used, <b>mmap</b>() will fail.  If MAP_FIXED is specified, <u>addr</u>
                          must be a multiple of the page size.  If  MAP_EXCL  is  not  specified,  a  successful
                          MAP_FIXED  request  replaces any previous mappings for the process' pages in the range
                          from <u>addr</u> to <u>addr</u> + <u>len</u>.  In contrast, if MAP_EXCL is specified, the request will fail
                          if a mapping already exists within the range.

       MAP_GUARD          Instead of a mapping, create a guard of the specified size.  Guards allow a process to
                          create reservations in its address space,  which  can  later  be  replaced  by  actual
                          mappings.

                          <u>mmap</u>  will  not  create  mappings  in  the address range of a guard unless the request
                          specifies MAP_FIXED.  Guards can be destroyed with <u><a href="../man2/munmap.2.html">munmap</a></u>(2).  Any memory access by  a
                          thread  to  the  guarded  range  results  in  the delivery of a SIGSEGV signal to that
                          thread.

       MAP_NOCORE         Region is not included in a core file.

       MAP_NOSYNC         Causes data dirtied via this VM  map  to  be  flushed  to  physical  media  only  when
                          necessary  (usually  by  the pager) rather than gratuitously.  Typically this prevents
                          the update daemons from flushing pages dirtied  through  such  maps  and  thus  allows
                          efficient  sharing  of memory across unassociated processes using a file-backed shared
                          memory map.  Without this option any VM pages you dirty may be flushed to  disk  every
                          so often (every 30-60 seconds usually) which can create performance problems if you do
                          not need that to occur (such as when you are using shared file-backed mmap regions for
                          IPC  purposes).   Dirty  data  will  be  flushed automatically when all mappings of an
                          object are removed and all descriptors referencing the object are closed.   Note  that
                          VM/file system coherency is maintained whether you use MAP_NOSYNC or not.  This option
                          is  not  portable  across  Unix  platforms  (yet),  though some may implement the same
                          behavior by default.

                          <u>WARNING</u>!  Extending a file with <u><a href="../man2/ftruncate.2.html">ftruncate</a></u>(2), thus  creating  a  big  hole,  and  then
                          filling  the  hole by modifying a shared <b>mmap</b>() can lead to severe file fragmentation.
                          In order to avoid such fragmentation you should always pre-allocate the file's backing
                          store by <b>write</b>()ing zero's into the newly extended area prior to  modifying  the  area
                          via  your  <b>mmap</b>().   The  fragmentation  problem is especially sensitive to MAP_NOSYNC
                          pages, because pages may be flushed to disk in a totally random order.

                          The same applies when using MAP_NOSYNC to implement a file-based shared memory  store.
                          It  is  recommended  that  you  create  the  backing store by <b>write</b>()ing zero's to the
                          backing file rather than <b>ftruncate</b>()ing  it.   You  can  test  file  fragmentation  by
                          observing the KB/t (kilobytes per transfer) results from an “<b>iostat</b> <b>1</b>” while reading a
                          large file sequentially, e.g., using “<b>dd</b> <b>if=filename</b> <b>of=/dev/null</b> <b>bs=32k</b>”.

                          The  <u><a href="../man2/fsync.2.html">fsync</a></u>(2)  system  call  will  flush all dirty data and metadata associated with a
                          file, including dirty NOSYNC VM data, to physical  media.   The  <u><a href="../man8/sync.8.html">sync</a></u>(8)  command  and
                          <u><a href="../man2/sync.2.html">sync</a></u>(2)  system call generally do not flush dirty NOSYNC VM data.  The <u><a href="../man2/msync.2.html">msync</a></u>(2) system
                          call is usually not needed since BSD implements a coherent file system  buffer  cache.
                          However,  it may be used to associate dirty VM pages with file system buffers and thus
                          cause them to be flushed to physical media sooner rather than later.

       MAP_PREFAULT_READ  Immediately update the calling  process's  lowest-level  virtual  address  translation
                          structures,  such  as  its  page  table, so that every memory resident page within the
                          region is mapped for read access.  Ordinarily these  structures  are  updated  lazily.
                          The  effect  of this option is to eliminate any soft faults that would otherwise occur
                          on the initial read accesses to the region.  Although this option  does  not  preclude
                          <u>prot</u> from including PROT_WRITE, it does not eliminate soft faults on the initial write
                          accesses to the region.

       MAP_PRIVATE        Modifications are private.

       MAP_SHARED         Modifications are shared.

       MAP_STACK          MAP_STACK implies MAP_ANON, and <u>offset</u> of 0.  The <u>fd</u> argument must be -1 and <u>prot</u> must
                          include at least PROT_READ and PROT_WRITE.

                          This  option creates a memory region that grows to at most <u>len</u> bytes in size, starting
                          from the stack top and growing down.  The stack top is the starting  address  returned
                          by  the  call,  plus  <u>len</u>  bytes.   The  bottom  of the stack at maximum growth is the
                          starting address returned by the call.

                          Stacks created with MAP_STACK automatically grow.  Guards prevent inadvertent  use  of
                          the regions into which those stacks can grow without requiring mapping the whole stack
                          in advance.

       The <u><a href="../man2/close.2.html">close</a></u>(2) system call does not unmap pages, see <u><a href="../man2/munmap.2.html">munmap</a></u>(2) for further information.

</pre><h4><b>NOTES</b></h4><pre>
       Although  this  implementation  does  not  impose  any  alignment  restrictions on the <u>offset</u> argument, a
       portable program must only use page-aligned values.

       Large page mappings require that the pages backing an object be aligned in matching blocks  in  both  the
       virtual  address  space  and  RAM.  The system will automatically attempt to use large page mappings when
       mapping an object that is already backed by large pages in RAM by aligning the  mapping  request  in  the
       virtual  address space to match the alignment of the large physical pages.  The system may also use large
       page mappings when mapping portions of an  object  that  are  not  yet  backed  by  pages  in  RAM.   The
       MAP_ALIGNED_SUPER flag is an optimization that will align the mapping request to the size of a large page
       similar  to  MAP_ALIGNED,  except  that the system will override this alignment if an object already uses
       large pages so that the mapping will be consistent with the existing large pages.  This  flag  is  mostly
       useful  for  maximizing the use of large pages on the first mapping of objects that do not yet have pages
       present in RAM.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Upon successful completion, <b>mmap</b>() returns a pointer  to  the  mapped  region.   Otherwise,  a  value  of
       MAP_FAILED is returned and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <b>mmap</b>() system call will fail if:

       [EACCES]           The  flag PROT_READ was specified as part of the <u>prot</u> argument and <u>fd</u> was not open for
                          reading.  The flags MAP_SHARED and PROT_WRITE were specified as part of the <u>flags</u>  and
                          <u>prot</u> argument and <u>fd</u> was not open for writing.

       [EBADF]            The <u>fd</u> argument is not a valid open file descriptor.

       [EINVAL]           An  invalid  (negative)  value was passed in the <u>offset</u> argument, when <u>fd</u> referenced a
                          regular file or shared memory.

       [EINVAL]           An invalid value was passed in the <u>prot</u> argument.

       [EINVAL]           An undefined option was set in the <u>flags</u> argument.

       [EINVAL]           Both MAP_PRIVATE and MAP_SHARED were specified.

       [EINVAL]           None of MAP_ANON, MAP_GUARD, MAP_PRIVATE, MAP_SHARED, or MAP_STACK was specified.   At
                          least one of these flags must be included.

       [EINVAL]           MAP_FIXED  was  specified  and  the <u>addr</u> argument was not page aligned, or part of the
                          desired address space resides out of the valid address space for a user process.

       [EINVAL]           Both MAP_FIXED and MAP_32BIT were specified and part  of  the  desired  address  space
                          resides outside of the first 2GB of user address space.

       [EINVAL]           The <u>len</u> argument was equal to zero.

       [EINVAL]           MAP_ALIGNED was specified and the desired alignment was either larger than the virtual
                          address size of the machine or smaller than a page.

       [EINVAL]           MAP_ANON was specified and the <u>fd</u> argument was not -1.

       [EINVAL]           MAP_ANON was specified and the <u>offset</u> argument was not 0.

       [EINVAL]           Both  MAP_FIXED  and MAP_EXCL were specified, but the requested region is already used
                          by a mapping.

       [EINVAL]           MAP_EXCL was specified, but MAP_FIXED was not.

       [EINVAL]           MAP_GUARD was specified, but the <u>offset</u> argument was not zero, the <u>fd</u> argument was not
                          -1, or the <u>prot</u> argument was not PROT_NONE.

       [EINVAL]           MAP_GUARD was specified  together  with  one  of  the  flags  MAP_ANON,  MAP_PREFAULT,
                          MAP_PREFAULT_READ, MAP_PRIVATE, MAP_SHARED, MAP_STACK.

       [ENODEV]           MAP_ANON  has  not  been  specified  and  <u>fd</u>  did not reference a regular or character
                          special file.

       [ENOMEM]           MAP_FIXED was specified and  the  <u>addr</u>  argument  was  not  available.   MAP_ANON  was
                          specified and insufficient memory was available.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/madvise.2.html">madvise</a></u>(2),   <u><a href="../man2/mincore.2.html">mincore</a></u>(2),   <u><a href="../man2/minherit.2.html">minherit</a></u>(2),   <u><a href="../man2/mlock.2.html">mlock</a></u>(2),   <u><a href="../man2/mprotect.2.html">mprotect</a></u>(2),   <u><a href="../man2/msync.2.html">msync</a></u>(2),   <u><a href="../man2/munlock.2.html">munlock</a></u>(2),  <u><a href="../man2/munmap.2.html">munmap</a></u>(2),
       <u><a href="../man3/getpagesize.3.html">getpagesize</a></u>(3), <u><a href="../man3/getpagesizes.3.html">getpagesizes</a></u>(3)

Debian                                            June 22, 2017                                          <u><a href="../man2/MMAP.2.html">MMAP</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>