<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>get_mempolicy - retrieve NUMA memory policy for a thread</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       get_mempolicy - retrieve NUMA memory policy for a thread

</pre><h4><b>LIBRARY</b></h4><pre>
       NUMA (Non-Uniform Memory Access) policy library (<u>libnuma</u>, <u>-lnuma</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;numaif.h&gt;</b>

       <b>long</b> <b>get_mempolicy(int</b> <b>*</b><u>mode</u><b>,</b>
                          <b>unsigned</b> <b>long</b> <u>nodemask</u><b>[(.</b><u>maxnode</u> <b>+</b> <b>ULONG_WIDTH</b> <b>-</b> <b>1)</b>
                                                 <b>/</b> <b>ULONG_WIDTH],</b>
                          <b>unsigned</b> <b>long</b> <u>maxnode</u><b>,</b> <b>void</b> <b>*</b><u>addr</u><b>,</b>
                          <b>unsigned</b> <b>long</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>get_mempolicy</b>()  retrieves the NUMA policy of the calling thread or of a memory address, depending on the
       setting of <u>flags</u>.

       A NUMA machine has different memory controllers with different distances to specific  CPUs.   The  memory
       policy defines from which node memory is allocated for the thread.

       If  <u>flags</u>  is  specified  as  0,  then  information  about the calling thread's default policy (as set by
       <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2)) is returned, in the buffers pointed to by <u>mode</u> and <u>nodemask</u>.   The  value  returned  in
       these  arguments  may  be  used  to  restore  the thread's policy to its state at the time of the call to
       <b>get_mempolicy</b>() using <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2).  When <u>flags</u> is 0, <u>addr</u> must be specified as NULL.

       If <u>flags</u> specifies <b>MPOL_F_MEMS_ALLOWED</b> (available since Linux 2.6.24), the <u>mode</u> argument is  ignored  and
       the  set  of  nodes  (memories)  that the thread is allowed to specify in subsequent calls to <b><a href="../man2/mbind.2.html">mbind</a></b>(2) or
       <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2) (in the absence of any <u>mode</u> <u>flags</u>) is returned in <u>nodemask</u>.   It  is  not  permitted  to
       combine <b>MPOL_F_MEMS_ALLOWED</b> with either <b>MPOL_F_ADDR</b> or <b>MPOL_F_NODE</b>.

       If  <u>flags</u>  specifies  <b>MPOL_F_ADDR</b>,  then  information  is  returned about the policy governing the memory
       address given in <u>addr</u>.  This policy may be different from the thread's default policy if <b><a href="../man2/mbind.2.html">mbind</a></b>(2) or  one
       of  the  helper  functions  described in <b><a href="../man3/numa.3.html">numa</a></b>(3) has been used to establish a policy for the memory range
       containing <u>addr</u>.

       If the <u>mode</u> argument is not NULL, then <b>get_mempolicy</b>() will store the policy mode and any  optional  <u>mode</u>
       <u>flags</u> of the requested NUMA policy in the location pointed to by this argument.  If <u>nodemask</u> is not NULL,
       then  the nodemask associated with the policy will be stored in the location pointed to by this argument.
       <u>maxnode</u> specifies the number of node IDs that can be stored into <u>nodemask</u>â€”that is, the  maximum  node  ID
       plus one.  The value specified by <u>maxnode</u> is always rounded to a multiple of <u>sizeof(unsigned</u> <u>long)*8</u>.

       If  <u>flags</u> specifies both <b>MPOL_F_NODE</b> and <b>MPOL_F_ADDR</b>, <b>get_mempolicy</b>() will return the node ID of the node
       on which the address <u>addr</u> is allocated into the location pointed to by <u>mode</u>.  If no  page  has  yet  been
       allocated  for the specified address, <b>get_mempolicy</b>() will allocate a page as if the thread had performed
       a read (load) access to that address, and return the ID of the node where that page was allocated.

       If <u>flags</u> specifies <b>MPOL_F_NODE</b>, but not <b>MPOL_F_ADDR</b>, and the thread's current policy  is  <b>MPOL_INTERLEAVE</b>
       or  <b>MPOL_WEIGHTED_INTERLEAVE</b>,  then  <b>get_mempolicy</b>() will return in the location pointed to by a non-NULL
       <u>mode</u> argument, the node ID of the next node that will be used for interleaving of internal  kernel  pages
       allocated  on  behalf  of the thread.  These allocations include pages for memory-mapped files in process
       memory ranges mapped using the <b><a href="../man2/mmap.2.html">mmap</a></b>(2) call with the <b>MAP_PRIVATE</b> flag for read accesses,  and  in  memory
       ranges mapped with the <b>MAP_SHARED</b> flag for all accesses.

       Other flag values are reserved.

       For an overview of the possible policies see <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>get_mempolicy</b>() returns 0; on error, -1 is returned and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> Part  of  all of the memory range specified by <u>nodemask</u> and <u>maxnode</u> points outside your accessible
              address space.

       <b>EINVAL</b> The value specified by <u>maxnode</u> is less than the number of node IDs supported by  the  system.   Or
              <u>flags</u>  specified  values other than <b>MPOL_F_NODE</b> or <b>MPOL_F_ADDR</b>; or <u>flags</u> specified <b>MPOL_F_ADDR</b> and
              <u>addr</u> is NULL, or <u>flags</u> did not specify <b>MPOL_F_ADDR</b> and <u>addr</u> is  not  NULL.   Or,  <u>flags</u>  specified
              <b>MPOL_F_NODE</b>  but  not  <b>MPOL_F_ADDR</b>  and  the  current thread policy is neither <b>MPOL_INTERLEAVE</b> nor
              <b>MPOL_WEIGHTED_INTERLEAVE</b>.  Or, <u>flags</u> specified  <b>MPOL_F_MEMS_ALLOWED</b>  with  either  <b>MPOL_F_ADDR</b>  or
              <b>MPOL_F_NODE</b>.  (And there are other <b>EINVAL</b> cases.)

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.7.

</pre><h4><b>NOTES</b></h4><pre>
       For information on library support, see <b><a href="../man7/numa.7.html">numa</a></b>(7).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/getcpu.2.html">getcpu</a></b>(2), <b><a href="../man2/mbind.2.html">mbind</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man2/set_mempolicy.2.html">set_mempolicy</a></b>(2), <b><a href="../man3/numa.3.html">numa</a></b>(3), <b><a href="../man7/numa.7.html">numa</a></b>(7), <b><a href="../man8/numactl.8.html">numactl</a></b>(8)

Linux man-pages 6.9.1                              2024-05-02                                   <u><a href="../man2/get_mempolicy.2.html">get_mempolicy</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>