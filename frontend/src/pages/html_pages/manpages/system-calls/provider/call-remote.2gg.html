<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>call-remote -  (distributed-computing)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/golf">golf_601.4.41-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       call-remote -  (distributed-computing)

</pre><h4><b>PURPOSE</b></h4><pre>
       Make a remote service call.

</pre><h4><b>SYNTAX</b></h4><pre>
           call-remote &lt;service&gt; [ ,... ]   \
               [ status &lt;status&gt; ]  \
               [ started &lt;started&gt; ] \
               [ finished-okay &lt;finished okay&gt; ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       call-remote  will make service call(s) as described in a single &lt;service&gt; or a list of &lt;service&gt;s. Unless
       only a single &lt;service&gt; is specified, each call  will  execute  in  parallel  with  others  (as  multiple
       threads).  call-remote  finishes  when all &lt;service&gt; calls do. Each &lt;service&gt; must have beed created with
       <b>new-remote</b>.

       A &lt;service&gt; call is made to a remote service. "Remote service" means a process accepting requests that is
       not the same process executing call-remote; it may be running on the same or a different computer, or  it
       may be a different process started by the very same application.

       <b>-</b> <b>Multiple</b> <b>service</b> <b>calls</b> <b>in</b> <b>parallel</b>

       Executing  multiple  &lt;service&gt; calls in parallel is possible by specifying a list of &lt;service&gt;s separated
       by a comma.

       There is no limit on how many &lt;service&gt;s you can call at the  same  time;  it  is  limited  only  by  the
       underlying Operating System resources, such as threads/processes and sockets.

       <b>-</b> <b>Call</b> <b>status</b>

       &lt;status&gt;  number  (in "status" clause) will be GG_OKAY if all &lt;service&gt; calls have each returned GG_OKAY;
       this means all have started and all have finished with a valid message from the service; or GG_ERR_FAILED
       if at least one did not (for example if the service could not be contacted, if there was a network  error
       etc.);  or  GG_ERR_MEMORY  if  out  of  memory;  or GG_ERR_TOO_MANY if there is too many calls (more than
       1,000,000).

       Note that GG_OKAY does not mean that the reply is considered a success in any logical  sense;  only  that
       the request was made and a reply was received according to the service protocol.

       <b>-</b> <b>Request(s)</b> <b>status</b>

       Note  that the actual application status for each &lt;service&gt;, as well as data returned and any application
       errors can  be  obtained  via  "exit-status",  "data"  and  "error"  clauses  of  <b>read-remote</b>  statement,
       respectively.

       <b>-</b> <b>Request(s)</b> <b>duration</b>

       call-remote will wait for all &lt;service&gt; requests to finish. For that reason, it is a good idea to specify
       "timeout"  clause  in  <b>new-remote</b> for each &lt;service&gt; used, in order to limit the time you would wait. Use
       <b>read-remote</b> to detect a timeout, in which case "exit-status" clause would produce GG_CLI_ERR_TIMEOUT.

       <b>-</b> <b>How</b> <b>many</b> <b>calls</b> <b>started</b> <b>and</b> <b>finished</b>

       &lt;started&gt; (in "started" clause) will be the number of service calls that have  started.  &lt;finished  okay&gt;
       (in  "finished-okay"  clause)  is  the number of calls that have finished with return value of GG_OKAY as
       described above. By using &lt;status&gt;, &lt;started&gt; and &lt;finished okay&gt; you may surmise whether the results  of
       call-remote meet your expectations.

       <b>-</b> <b>Performance,</b> <b>security</b>

       call-remote  is faster than <b>call-web</b> because it does not use HTTP protocol; rather it only uses small and
       binary protocol, which is extremenly fast, especially when using Unix sockets on the  same  machine  (see
       <b>new-remote</b>).  Note that the binary protocol does not have any inherent security built-in; that is part of
       the reason why it is fast. As such, it is very well suited for remote service calls on the  same  machine
       or between networked machines on a secure network.

</pre><h4><b>EXAMPLES</b></h4><pre>
       This  example will connect to local Unix socket file "/var/lib/gg/app_name/sock/sock" (a Golf application
       named "app_name"), and make a request named "server" (i.e. it will  be  processed  by  source  code  file
       "server.golf")  with  URL  path  of "/op=add/key=2" (meaning with input parameters "op=add" and "key=2").
       Then, service reply is read and displayed.

           // Create single call
           new-remote srv location "/var/lib/gg/app_name/sock/sock" \
               method "GET" app-path "/app_name" request-path "/server" \
               url-params "/op=add/key=2"
           // Call single service call
           call-remote srv finished-okay sfok
           // Get results of a remote service call
           read-remote srv data rdata
           // Display results
           @Data from service is &lt;&lt;print-out rdata&gt;&gt;

       If you are connecting to a service via TCP (and not with a Unix socket like in the  example  above),  the
       "location" clause in <b>new-remote</b> might be:

           new-remote srv location "192.168.0.28:2400" \
               method "GET" app-path "/app_name" request-path "/server" \
               url-params "/op=add/key=2"

       In this case, you are connecting to another service (running on IP "192.168.0.28") on port 2400. See <b>mgrg</b>
       on  how  to  start  a service that listens on a TCP port. You would likely use TCP connectivity only if a
       service you're connecting to is on a different computer.

       See also <b>new-remote</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        Distributed computing

       <b>call-remote</b> <b>new-remote</b> <b>read-remote</b> <b>run-remote</b> See all <b>documentation</b>

$DATE                                               $VERSION                                           <u><a href="../man2gg/GOLF.2gg.html">GOLF</a></u>(2gg)
</pre>
 </div>
</div></section>
</div>
</body>
</html>