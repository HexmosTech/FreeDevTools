<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>memfd_create - create an anonymous file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       memfd_create - create an anonymous file

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>         /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;sys/mman.h&gt;</b>

       <b>int</b> <b>memfd_create(const</b> <b>char</b> <b>*</b><u>name</u><b>,</b> <b>unsigned</b> <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>memfd_create</b>()  creates  an  anonymous  file  and  returns a file descriptor that refers to it.  The file
       behaves like a regular file, and so can be modified,  truncated,  memory-mapped,  and  so  on.   However,
       unlike  a  regular  file, it lives in RAM and has a volatile backing storage.  Once all references to the
       file are dropped, it is automatically released.  Anonymous memory is used for all backing  pages  of  the
       file.   Therefore,  files  created  by  <b>memfd_create</b>()  have the same semantics as other anonymous memory
       allocations such as those allocated using <b><a href="../man2/mmap.2.html">mmap</a></b>(2) with the <b>MAP_ANONYMOUS</b> flag.

       The initial size of the file is set to 0.  Following  the  call,  the  file  size  should  be  set  using
       <b><a href="../man2/ftruncate.2.html">ftruncate</a></b>(2).  (Alternatively, the file may be populated by calls to <b><a href="../man2/write.2.html">write</a></b>(2) or similar.)

       The  name supplied in <u>name</u> is used as a filename and will be displayed as the target of the corresponding
       symbolic link in the directory <u><a href="file:/proc/self/fd/">/proc/self/fd/</a></u>.  The displayed name is always  prefixed  with  <u>memfd:</u>  and
       serves only for debugging purposes.  Names do not affect the behavior of the file descriptor, and as such
       multiple files can have the same name without any side effects.

       The following values may be bitwise ORed in <u>flags</u> to change the behavior of <b>memfd_create</b>():

       <b>MFD_CLOEXEC</b>
              Set  the  close-on-exec  (<b>FD_CLOEXEC</b>) flag on the new file descriptor.  See the description of the
              <b>O_CLOEXEC</b> flag in <b><a href="../man2/open.2.html">open</a></b>(2) for reasons why this may be useful.

       <b>MFD_ALLOW_SEALING</b>
              Allow sealing operations on this file.  See the discussion  of  the  <b>F_ADD_SEALS</b>  and  <b>F_GET_SEALS</b>
              operations  in  <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2), and also NOTES, below.  The initial set of seals is empty.  If this flag
              is not set, the initial set of seals will be <b>F_SEAL_SEAL</b>, meaning that no other seals can  be  set
              on the file.

       <b>MFD_HUGETLB</b> (since Linux 4.14)
              The  anonymous  file  will be created in the hugetlbfs filesystem using huge pages.  See the Linux
              kernel  source  file  <u>Documentation/admin-guide/mm/hugetlbpage.rst</u>  for  more  information   about
              hugetlbfs.   Specifying  both  <b>MFD_HUGETLB</b> and <b>MFD_ALLOW_SEALING</b> in <u>flags</u> is supported since Linux
              4.16.

       <b>MFD_HUGE_2MB</b>
       <b>MFD_HUGE_1GB</b>
       ...    Used in conjunction with <b>MFD_HUGETLB</b> to select alternative hugetlb page sizes (respectively, 2 MB,
              1 GB, ...)  on systems that support multiple hugetlb page sizes.  Definitions for known huge  page
              sizes are included in the header file <u>&lt;linux/memfd.h&gt;.</u>

              For details on encoding huge page sizes not included in the header file, see the discussion of the
              similarly named constants in <b><a href="../man2/mmap.2.html">mmap</a></b>(2).

       Unused bits in <u>flags</u> must be 0.

       As  its return value, <b>memfd_create</b>() returns a new file descriptor that can be used to refer to the file.
       This file descriptor is opened for both reading and writing (<b>O_RDWR</b>) and <b>O_LARGEFILE</b> is set for the  file
       descriptor.

       With  respect  to  <b><a href="../man2/fork.2.html">fork</a></b>(2)  and  <b><a href="../man2/execve.2.html">execve</a></b>(2),  the usual semantics apply for the file descriptor created by
       <b>memfd_create</b>().  A copy of the file descriptor is inherited by the child produced by <b><a href="../man2/fork.2.html">fork</a></b>(2)  and  refers
       to  the  same file.  The file descriptor is preserved across <b><a href="../man2/execve.2.html">execve</a></b>(2), unless the close-on-exec flag has
       been set.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>memfd_create</b>() returns a new file descriptor.  On error, -1 is returned and <u>errno</u> is  set  to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> The address in <u>name</u> points to invalid memory.

       <b>EINVAL</b> <u>flags</u> included unknown bits.

       <b>EINVAL</b> <u>name</u> was too long.  (The limit is 249 bytes, excluding the terminating null byte.)

       <b>EINVAL</b> Both <b>MFD_HUGETLB</b> and <b>MFD_ALLOW_SEALING</b> were specified in <u>flags</u>.

       <b>EMFILE</b> The per-process limit on the number of open file descriptors has been reached.

       <b>ENFILE</b> The system-wide limit on the total number of open files has been reached.

       <b>ENOMEM</b> There was insufficient memory to create a new anonymous file.

       <b>EPERM</b>  The  <b>MFD_HUGETLB</b>  flag  was  specified,  but  the  caller  was  not  privileged  (did not have the
              <b>CAP_IPC_LOCK</b> capability) and is not a  member  of  the  <u>sysctl_hugetlb_shm_group</u>  group;  see  the
              description of <u>/proc/sys/vm/sysctl_hugetlb_shm_group</u> in <b><a href="../man5/proc.5.html">proc</a></b>(5).

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 3.17, glibc 2.27.

</pre><h4><b>NOTES</b></h4><pre>
       The  <b>memfd_create</b>()  system call provides a simple alternative to manually mounting a <b><a href="../man5/tmpfs.5.html">tmpfs</a></b>(5) filesystem
       and creating and opening a file in that filesystem.  The primary purpose of <b>memfd_create</b>() is  to  create
       files and associated file descriptors that are used with the file-sealing APIs provided by <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2).

       The <b>memfd_create</b>() system call also has uses without file sealing (which is why file-sealing is disabled,
       unless  explicitly  requested  with  the  <b>MFD_ALLOW_SEALING</b>  flag).   In particular, it can be used as an
       alternative to creating files in <u>tmp</u> or as an alternative to using the <b><a href="../man2/open.2.html">open</a></b>(2) <b>O_TMPFILE</b> in  cases  where
       there is no intention to actually link the resulting file into the filesystem.

   <b>File</b> <b>sealing</b>
       In  the  absence  of  file  sealing,  processes that communicate via shared memory must either trust each
       other, or take measures to deal with the possibility that an untrusted peer  may  manipulate  the  shared
       memory  region  in  problematic  ways.   For  example, an untrusted peer might modify the contents of the
       shared memory at any time, or shrink the shared memory region.  The former possibility leaves  the  local
       process  vulnerable to time-of-check-to-time-of-use race conditions (typically dealt with by copying data
       from the shared memory region before checking and using it).  The latter  possibility  leaves  the  local
       process  vulnerable to <b>SIGBUS</b> signals when an attempt is made to access a now-nonexistent location in the
       shared memory region.  (Dealing with this possibility necessitates the use of a handler  for  the  <b>SIGBUS</b>
       signal.)

       Dealing with untrusted peers imposes extra complexity on code that employs shared memory.  Memory sealing
       enables  that extra complexity to be eliminated, by allowing a process to operate secure in the knowledge
       that its peer can't modify the shared memory in an undesired fashion.

       An example of the usage of the sealing mechanism is as follows:

       (1)  The first process creates a <b><a href="../man5/tmpfs.5.html">tmpfs</a></b>(5) file using <b>memfd_create</b>().  The call yields a  file  descriptor
            used in subsequent steps.

       (2)  The  first  process  sizes  the  file created in the previous step using <b><a href="../man2/ftruncate.2.html">ftruncate</a></b>(2), maps it using
            <b><a href="../man2/mmap.2.html">mmap</a></b>(2), and populates the shared memory with the desired data.

       (3)  The first process uses the <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) <b>F_ADD_SEALS</b> operation to place one or more seals on the file, in
            order to restrict further modifications on the file.  (If placing the  seal  <b>F_SEAL_WRITE</b>,  then  it
            will  be  necessary  to  first  unmap  the  shared  writable  mapping  created in the previous step.
            Otherwise, behavior similar to <b>F_SEAL_WRITE</b> can be achieved by using <b>F_SEAL_FUTURE_WRITE</b>, which will
            prevent future writes via <b><a href="../man2/mmap.2.html">mmap</a></b>(2)  and  <b><a href="../man2/write.2.html">write</a></b>(2)  from  succeeding  while  keeping  existing  shared
            writable mappings).

       (4)  A  second  process  obtains a file descriptor for the <b><a href="../man5/tmpfs.5.html">tmpfs</a></b>(5) file and maps it.  Among the possible
            ways in which this could happen are the following:

            •  The process that called <b>memfd_create</b>() could transfer the resulting file descriptor to the second
               process via a UNIX domain socket (see <b><a href="../man7/unix.7.html">unix</a></b>(7) and <b><a href="../man3/cmsg.3.html">cmsg</a></b>(3)).  The second  process  then  maps  the
               file using <b><a href="../man2/mmap.2.html">mmap</a></b>(2).

            •  The second process is created via <b><a href="../man2/fork.2.html">fork</a></b>(2) and thus automatically inherits the file descriptor and
               mapping.  (Note that in this case and the next, there is a natural trust relationship between the
               two  processes, since they are running under the same user ID.  Therefore, file sealing would not
               normally be necessary.)

            •  The second process opens the file <u><a href="file:/proc/">/proc/</a></u>pid<u>/fd/</u>fd, where <u>&lt;pid&gt;</u> is the PID of  the  first  process
               (the  one  that called <b>memfd_create</b>()), and <u>&lt;fd&gt;</u> is the number of the file descriptor returned by
               the call to <b>memfd_create</b>() in that process.  The second process then maps the file using <b><a href="../man2/mmap.2.html">mmap</a></b>(2).

       (5)  The second process uses the <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) <b>F_GET_SEALS</b> operation to retrieve the bit mask  of  seals  that
            has  been  applied  to the file.  This bit mask can be inspected in order to determine what kinds of
            restrictions have been placed on file modifications.  If  desired,  the  second  process  can  apply
            further  seals  to  impose additional restrictions (so long as the <b>F_SEAL_SEAL</b> seal has not yet been
            applied).

</pre><h4><b>EXAMPLES</b></h4><pre>
       Below are shown two example programs that demonstrate the use of <b>memfd_create</b>() and the file sealing API.

       The first program, <u>t_memfd_create.c</u>, creates a <b><a href="../man5/tmpfs.5.html">tmpfs</a></b>(5) file using <b>memfd_create</b>(), sets a  size  for  the
       file, maps it into memory, and optionally places some seals on the file.  The program accepts up to three
       command-line arguments, of which the first two are required.  The first argument is the name to associate
       with the file, the second argument is the size to be set for the file, and the optional third argument is
       a string of characters that specify seals to be set on the file.

       The  second  program,  <u>t_get_seals.c</u>,  can  be  used  to  open  an  existing  file  that  was created via
       <b>memfd_create</b>() and inspect the set of seals that have been applied to that file.

       The following shell session demonstrates the use of these programs.  First we create a <b><a href="../man5/tmpfs.5.html">tmpfs</a></b>(5) file  and
       set some seals on it:

           $ <b>./t_memfd_create</b> <b>my_memfd_file</b> <b>4096</b> <b>sw</b> <b>&amp;</b>
           [1] 11775
           PID: 11775; fd: 3; /proc/11775/fd/3

       At  this  point, the <u>t_memfd_create</u> program continues to run in the background.  From another program, we
       can obtain a file descriptor for the file created by <b>memfd_create</b>() by opening the <u><a href="file:/proc/">/proc/</a></u>pid<u>/fd</u> file that
       corresponds to the file descriptor opened by <b>memfd_create</b>().  Using that pathname, we inspect the content
       of the <u><a href="file:/proc/">/proc/</a></u>pid<u>/fd</u> symbolic link, and use our <u>t_get_seals</u> program to  view  the  seals  that  have  been
       placed on the file:

           $ <b>readlink</b> <b>/proc/11775/fd/3</b>
           /memfd:my_memfd_file (deleted)
           $ <b>./t_get_seals</b> <b>/proc/11775/fd/3</b>
           Existing seals: WRITE SHRINK

   <b>Program</b> <b>source:</b> <b>t_memfd_create.c</b>

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;sys/mman.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           int           fd;
           char          *name, *seals_arg;
           ssize_t       len;
           unsigned int  seals;

           if (argc &lt; 3) {
               fprintf(stderr, "%s name size [seals]\n", argv[0]);
               fprintf(stderr, "\t'seals' can contain any of the "
                       "following characters:\n");
               fprintf(stderr, "\t\tg - F_SEAL_GROW\n");
               fprintf(stderr, "\t\ts - F_SEAL_SHRINK\n");
               fprintf(stderr, "\t\tw - F_SEAL_WRITE\n");
               fprintf(stderr, "\t\tW - F_SEAL_FUTURE_WRITE\n");
               fprintf(stderr, "\t\tS - F_SEAL_SEAL\n");
               exit(EXIT_FAILURE);
           }

           name = argv[1];
           len = atoi(argv[2]);
           seals_arg = argv[3];

           /* Create an anonymous file in tmpfs; allow seals to be
              placed on the file. */

           fd = memfd_create(name, MFD_ALLOW_SEALING);
           if (fd == -1)
               err(EXIT_FAILURE, "memfd_create");

           /* Size the file as specified on the command line. */

           if (ftruncate(fd, len) == -1)
               err(EXIT_FAILURE, "truncate");

           printf("PID: %jd; fd: %d; <a href="file:/proc/">/proc/</a>%jd/fd/%d\n",
                  (intmax_t) getpid(), fd, (intmax_t) getpid(), fd);

           /* Code to map the file and populate the mapping with data
              omitted. */

           /* If a 'seals' command-line argument was supplied, set some
              seals on the file. */

           if (seals_arg != NULL) {
               seals = 0;

               if (strchr(seals_arg, 'g') != NULL)
                   seals |= F_SEAL_GROW;
               if (strchr(seals_arg, 's') != NULL)
                   seals |= F_SEAL_SHRINK;
               if (strchr(seals_arg, 'w') != NULL)
                   seals |= F_SEAL_WRITE;
               if (strchr(seals_arg, 'W') != NULL)
                   seals |= F_SEAL_FUTURE_WRITE;
               if (strchr(seals_arg, 'S') != NULL)
                   seals |= F_SEAL_SEAL;

               if (fcntl(fd, F_ADD_SEALS, seals) == -1)
                   err(EXIT_FAILURE, "fcntl");
           }

           /* Keep running, so that the file created by memfd_create()
              continues to exist. */

           pause();

           exit(EXIT_SUCCESS);
       }

   <b>Program</b> <b>source:</b> <b>t_get_seals.c</b>

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           int           fd;
           unsigned int  seals;

           if (argc != 2) {
               fprintf(stderr, "%s /proc/PID/fd/FD\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           fd = open(argv[1], O_RDWR);
           if (fd == -1)
               err(EXIT_FAILURE, "open");

           seals = fcntl(fd, F_GET_SEALS);
           if (seals == -1)
               err(EXIT_FAILURE, "fcntl");

           printf("Existing seals:");
           if (seals &amp; F_SEAL_SEAL)
               printf(" SEAL");
           if (seals &amp; F_SEAL_GROW)
               printf(" GROW");
           if (seals &amp; F_SEAL_WRITE)
               printf(" WRITE");
           if (seals &amp; F_SEAL_FUTURE_WRITE)
               printf(" FUTURE_WRITE");
           if (seals &amp; F_SEAL_SHRINK)
               printf(" SHRINK");
           printf("\n");

           /* Code to map the file and access the contents of the
              resulting mapping omitted. */

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2), <b><a href="../man2/ftruncate.2.html">ftruncate</a></b>(2), <b><a href="../man2/memfd_secret.2.html">memfd_secret</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man2/shmget.2.html">shmget</a></b>(2), <b><a href="../man3/shm_open.3.html">shm_open</a></b>(3)

Linux man-pages 6.9.1                              2024-06-15                                    <u><a href="../man2/memfd_create.2.html">memfd_create</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>