<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>memfd_secret - create an anonymous RAM-based file to access secret memory regions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       memfd_secret - create an anonymous RAM-based file to access secret memory regions

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/syscall.h&gt;</b>      /* Definition of <b>SYS_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>int</b> <b>syscall(SYS_memfd_secret,</b> <b>unsigned</b> <b>int</b> <u>flags</u><b>);</b>

       <u>Note</u>: glibc provides no wrapper for <b>memfd_secret</b>(), necessitating the use of <b><a href="../man2/syscall.2.html">syscall</a></b>(2).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>memfd_secret</b>()  creates an anonymous RAM-based file and returns a file descriptor that refers to it.  The
       file provides a way to create and access memory regions with stronger  protection  than  usual  RAM-based
       files  and  anonymous  memory  mappings.   Once  all  open  references  to  the  file  are  closed, it is
       automatically released.  The initial size of the file is set to 0.  Following the  call,  the  file  size
       should be set using <b><a href="../man2/ftruncate.2.html">ftruncate</a></b>(2).

       The  memory  areas  backing  the file created with <b><a href="../man2/memfd_secret.2.html">memfd_secret</a></b>(2) are visible only to the processes that
       have access to the file descriptor.  The memory region is removed from the kernel page  tables  and  only
       the  page  tables  of  the  processes  holding the file descriptor map the corresponding physical memory.
       (Thus, the pages in the region can't be accessed by the kernel itself, so that, for example, pointers  to
       the region can't be passed to system calls.)

       The following values may be bitwise ORed in <u>flags</u> to control the behavior of <b>memfd_secret</b>():

       <b>FD_CLOEXEC</b>
              Set  the close-on-exec flag on the new file descriptor, which causes the region to be removed from
              the process on <b><a href="../man2/execve.2.html">execve</a></b>(2).  See the description of the <b>O_CLOEXEC</b> flag in <b><a href="../man2/open.2.html">open</a></b>(2)

       As its return value, <b>memfd_secret</b>() returns a new file descriptor that refers to an anonymous file.  This
       file descriptor is opened for both reading and writing (<b>O_RDWR</b>) and  <b>O_LARGEFILE</b>  is  set  for  the  file
       descriptor.

       With  respect  to  <b><a href="../man2/fork.2.html">fork</a></b>(2)  and  <b><a href="../man2/execve.2.html">execve</a></b>(2),  the usual semantics apply for the file descriptor created by
       <b>memfd_secret</b>().  A copy of the file descriptor is inherited by the child produced by <b><a href="../man2/fork.2.html">fork</a></b>(2)  and  refers
       to  the  same file.  The file descriptor is preserved across <b><a href="../man2/execve.2.html">execve</a></b>(2), unless the close-on-exec flag has
       been set.

       The memory region is locked into memory in the same way as with  <b><a href="../man2/mlock.2.html">mlock</a></b>(2),  so  that  it  will  never  be
       written  into  swap,  and  hibernation is inhibited for as long as any <b>memfd_secret</b>() descriptions exist.
       However the implementation of <b>memfd_secret</b>() will not try to populate the whole range during the  <b><a href="../man2/mmap.2.html">mmap</a></b>(2)
       call  that  attaches  the  region  into the process's address space; instead, the pages are only actually
       allocated as they are faulted in.  The  amount  of  memory  allowed  for  memory  mappings  of  the  file
       descriptor obeys the same rules as <b><a href="../man2/mlock.2.html">mlock</a></b>(2) and cannot exceed <b>RLIMIT_MEMLOCK</b>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  <b>memfd_secret</b>() returns a new file descriptor.  On error, -1 is returned and <u>errno</u> is set to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EINVAL</b> <u>flags</u> included unknown bits.

       <b>EMFILE</b> The per-process limit on the number of open file descriptors has been reached.

       <b>EMFILE</b> The system-wide limit on the total number of open files has been reached.

       <b>ENOMEM</b> There was insufficient memory to create a new anonymous file.

       <b>ENOSYS</b> <b>memfd_secret</b>() is not implemented on this architecture, or has not  been  enabled  on  the  kernel
              command-line with <b>secretmem_enable</b>=1.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 5.14.

</pre><h4><b>NOTES</b></h4><pre>
       The <b>memfd_secret</b>() system call is designed to allow a user-space process to create a range of memory that
       is  inaccessible to anybody else - kernel included.  There is no 100% guarantee that kernel won't be able
       to access memory ranges backed by <b>memfd_secret</b>() in any  circumstances,  but  nevertheless,  it  is  much
       harder to exfiltrate data from these regions.

       <b>memfd_secret</b>() provides the following protections:

       •  Enhanced  protection  (in  conjunction with all the other in-kernel attack prevention systems) against
          ROP attacks.  Absence of any in-kernel primitive for accessing memory backed by  <b>memfd_secret</b>()  means
          that  one-gadget  ROP attack can't work to perform data exfiltration.  The attacker would need to find
          enough ROP gadgets to reconstruct the  missing  page  table  entries,  which  significantly  increases
          difficulty  of  the  attack,  especially  when  other protections like the kernel stack size limit and
          address space layout randomization are in place.

       •  Prevent cross-process user-space memory exposures.  Once a region for a <b>memfd_secret</b>() memory  mapping
          is  allocated,  the  user can't accidentally pass it into the kernel to be transmitted somewhere.  The
          memory pages in this region cannot be  accessed  via  the  direct  map  and  they  are  disallowed  in
          get_user_pages.

       •  Harden  against  exploited  kernel flaws.  In order to access memory areas backed by <b>memfd_secret</b>(), a
          kernel-side attack would need to either walk the page tables and create  new  ones,  or  spawn  a  new
          privileged user-space process to perform secrets exfiltration using <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2).

       The  way  <b>memfd_secret</b>()  allocates and locks the memory may impact overall system performance, therefore
       the system call is disabled by default and only available if the system administrator turned it on  using
       "secretmem.enable=y" kernel parameter.

       To  prevent  potential  data  leaks  of memory regions backed by <b>memfd_secret</b>() from a hybernation image,
       hybernation is prevented when there are active <b>memfd_secret</b>() users.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2), <b><a href="../man2/ftruncate.2.html">ftruncate</a></b>(2), <b><a href="../man2/mlock.2.html">mlock</a></b>(2), <b><a href="../man2/memfd_create.2.html">memfd_create</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2)

Linux man-pages 6.9.1                              2024-05-02                                    <u><a href="../man2/memfd_secret.2.html">memfd_secret</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>