<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>name_to_handle_at, open_by_handle_at - obtain handle for a pathname and open file via a handle</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       name_to_handle_at, open_by_handle_at - obtain handle for a pathname and open file via a handle

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>         /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;</b>

       <b>int</b> <b>name_to_handle_at(int</b> <u>dirfd</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>pathname</u><b>,</b>
                             <b>struct</b> <b>file_handle</b> <b>*</b><u>handle</u><b>,</b>
                             <b>int</b> <b>*</b><u>mount_id</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>
       <b>int</b> <b>open_by_handle_at(int</b> <u>mount_fd</u><b>,</b> <b>struct</b> <b>file_handle</b> <b>*</b><u>handle</u><b>,</b>
                             <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>name_to_handle_at</b>()  and  <b>open_by_handle_at</b>() system calls split the functionality of <b><a href="../man2/openat.2.html">openat</a></b>(2) into
       two  parts:  <b>name_to_handle_at</b>()  returns  an  opaque  handle  that  corresponds  to  a  specified  file;
       <b>open_by_handle_at</b>()   opens  the  file  corresponding  to  a  handle  returned  by  a  previous  call  to
       <b>name_to_handle_at</b>() and returns an open file descriptor.

   <b>name_to_handle_at()</b>
       The <b>name_to_handle_at</b>() system call returns a file handle and  a  mount  ID  corresponding  to  the  file
       specified  by  the  <u>dirfd</u>  and  <u>pathname</u> arguments.  The file handle is returned via the argument <u>handle</u>,
       which is a pointer to a structure of the following form:

           struct file_handle {
               unsigned int  handle_bytes;   /* Size of f_handle [in, out] */
               int           handle_type;    /* Handle type [out] */
               unsigned char f_handle[0];    /* File identifier (sized by
                                                caller) [out] */
           };

       It is the caller's responsibility to allocate the structure with a size large enough to hold  the  handle
       returned  in  <u>f_handle</u>.   Before  the  call,  the <u>handle_bytes</u> field should be initialized to contain the
       allocated size for <u>f_handle</u>.  (The constant <b>MAX_HANDLE_SZ</b>, defined in <u>&lt;fcntl.h&gt;</u>,  specifies  the  maximum
       expected  size  for  a file handle.  It is not a guaranteed upper limit as future filesystems may require
       more space.)  Upon successful return, the <u>handle_bytes</u> field is updated to contain the  number  of  bytes
       actually written to <u>f_handle</u>.

       The  caller  can  discover  the  required  size  for  the <u>file_handle</u> structure by making a call in which
       <u>handle-&gt;handle_bytes</u>  is  zero;  in  this  case,  the  call  fails   with   the   error   <b>EOVERFLOW</b>   and
       <u>handle-&gt;handle_bytes</u>  is  set  to indicate the required size; the caller can then use this information to
       allocate a structure of the correct size (see EXAMPLES below).  Some care is needed here as <b>EOVERFLOW</b> can
       also indicate that no file handle is available for this  particular  name  in  a  filesystem  which  does
       normally  support  file-handle  lookup.   This  case can be detected when the <b>EOVERFLOW</b> error is returned
       without <u>handle_bytes</u> being increased.

       Other than the use of the <u>handle_bytes</u> field, the caller should treat the  <u>file_handle</u>  structure  as  an
       opaque   data  type:  the  <u>handle_type</u>  and  <u>f_handle</u>  fields  can  be  used  in  a  subsequent  call  to
       <b>open_by_handle_at</b>().  The caller can  also  use  the  opaque  <u>file_handle</u>  to  compare  the  identity  of
       filesystem objects that were queried at different times and possibly at different paths.  The <b><a href="../man7/fanotify.7.html">fanotify</a></b>(7)
       subsystem  can  report  events  with  an  information  record  containing  a  <u>file_handle</u> to identify the
       filesystem object.

       The <u>flags</u> argument is  a  bit  mask  constructed  by  ORing  together  zero  or  more  of  <b>AT_HANDLE_FID</b>,
       <b>AT_EMPTY_PATH</b>, and <b>AT_SYMLINK_FOLLOW</b>, described below.

       When  <u>flags</u>  contain  the  <b>AT_HANDLE_FID</b>  (since  Linux 6.5) flag, the caller indicates that the returned
       <u>file_handle</u> is needed to identify the filesystem object, and not for opening the file later, so it should
       be expected that a subsequent call to <b>open_by_handle_at</b>() with the returned <u>file_handle</u> may fail.

       Together, the <u>pathname</u> and <u>dirfd</u> arguments identify the file for which a handle is to be obtained.  There
       are four distinct cases:

       •  If <u>pathname</u> is a nonempty string containing an absolute pathname, then a handle is  returned  for  the
          file referred to by that pathname.  In this case, <u>dirfd</u> is ignored.

       •  If  <u>pathname</u>  is  a  nonempty  string  containing  a relative pathname and <u>dirfd</u> has the special value
          <b>AT_FDCWD</b>, then <u>pathname</u> is interpreted relative to the current working directory of the caller, and  a
          handle is returned for the file to which it refers.

       •  If  <u>pathname</u>  is  a  nonempty  string  containing  a  relative pathname and <u>dirfd</u> is a file descriptor
          referring to a directory, then <u>pathname</u> is interpreted relative to the directory referred to by <u>dirfd</u>,
          and a handle is returned for the file to which it refers.  (See <b><a href="../man2/openat.2.html">openat</a></b>(2) for an  explanation  of  why
          "directory file descriptors" are useful.)

       •  If  <u>pathname</u> is an empty string and <u>flags</u> specifies the value <b>AT_EMPTY_PATH</b>, then <u>dirfd</u> can be an open
          file descriptor referring to any type of file, or <b>AT_FDCWD</b>, meaning the current working directory, and
          a handle is returned for the file to which it refers.

       The <u>mount_id</u> argument returns an identifier for the filesystem mount that corresponds to <u>pathname</u>.   This
       corresponds  to  the  first field in one of the records in <u><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></u>.  Opening the pathname in
       the fifth field of that record yields a file descriptor for the mount point; that file descriptor can  be
       used  in  a  subsequent call to <b>open_by_handle_at</b>().  <u>mount_id</u> is returned both for a successful call and
       for a call that results in the error <b>EOVERFLOW</b>.

       By default, <b>name_to_handle_at</b>() does not dereference <u>pathname</u> if it is a symbolic link, and thus  returns
       a handle for the link itself.  If <b>AT_SYMLINK_FOLLOW</b> is specified in <u>flags</u>, <u>pathname</u> is dereferenced if it
       is a symbolic link (so that the call returns a handle for the file referred to by the link).

       <b>name_to_handle_at</b>()  does  not  trigger  a mount when the final component of the pathname is an automount
       point.  When a filesystem supports both file handles and automount points, a <b>name_to_handle_at</b>() call  on
       an  automount  point  will  return  with error <b>EOVERFLOW</b> without having increased <u>handle_bytes</u>.  This can
       happen since Linux 4.13 with NFS when accessing a directory which is on  a  separate  filesystem  on  the
       server.  In this case, the automount can be triggered by adding a "/" to the end of the pathname.

   <b>open_by_handle_at()</b>
       The  <b>open_by_handle_at</b>()  system  call  opens the file referred to by <u>handle</u>, a file handle returned by a
       previous call to <b>name_to_handle_at</b>().

       The <u>mount_fd</u> argument is a file descriptor for  any  object  (file,  directory,  etc.)   in  the  mounted
       filesystem  with  respect  to  which  <u>handle</u>  should  be  interpreted.  The special value <b>AT_FDCWD</b> can be
       specified, meaning the current working directory of the caller.

       The <u>flags</u> argument is as for <b><a href="../man2/open.2.html">open</a></b>(2).  If <u>handle</u> refers to a symbolic link, the caller must  specify  the
       <b>O_PATH</b> flag, and the symbolic link is not dereferenced; the <b>O_NOFOLLOW</b> flag, if specified, is ignored.

       The caller must have the <b>CAP_DAC_READ_SEARCH</b> capability to invoke <b>open_by_handle_at</b>().

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  <b>name_to_handle_at</b>()  returns  0,  and  <b>open_by_handle_at</b>()  returns  a  file  descriptor (a
       nonnegative integer).

       In the event of an error, both system calls return -1 and set <u>errno</u> to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>name_to_handle_at</b>() and <b>open_by_handle_at</b>() can fail for the same errors as <b><a href="../man2/openat.2.html">openat</a></b>(2).  In addition, they
       can fail with the errors noted below.

       <b>name_to_handle_at</b>() can fail with the following errors:

       <b>EFAULT</b> <u>pathname</u>, <u>mount_id</u>, or <u>handle</u> points outside your accessible address space.

       <b>EINVAL</b> <u>flags</u> includes an invalid bit value.

       <b>EINVAL</b> <u>handle-&gt;handle_bytes</u> is greater than <b>MAX_HANDLE_SZ</b>.

       <b>ENOENT</b> <u>pathname</u> is an empty string, but <b>AT_EMPTY_PATH</b> was not specified in <u>flags</u>.

       <b>ENOTDIR</b>
              The file descriptor supplied in <u>dirfd</u> does not refer to a directory, and it is not the  case  that
              both <u>flags</u> includes <b>AT_EMPTY_PATH</b> and <u>pathname</u> is an empty string.

       <b>EOPNOTSUPP</b>
              The filesystem does not support decoding of a pathname to a file handle.

       <b>EOVERFLOW</b>
              The  <u>handle-&gt;handle_bytes</u>  value  passed  into  the  call  was too small.  When this error occurs,
              <u>handle-&gt;handle_bytes</u> is updated to indicate the required size for the handle.

       <b>open_by_handle_at</b>() can fail with the following errors:

       <b>EBADF</b>  <u>mount_fd</u> is not an open file descriptor.

       <b>EBADF</b>  <u>pathname</u> is relative but <u>dirfd</u> is neither <b>AT_FDCWD</b> nor a valid file descriptor.

       <b>EFAULT</b> <u>handle</u> points outside your accessible address space.

       <b>EINVAL</b> <u>handle-&gt;handle_bytes</u> is greater than <b>MAX_HANDLE_SZ</b> or is equal to zero.

       <b>ELOOP</b>  <u>handle</u> refers to a symbolic link, but <b>O_PATH</b> was not specified in <u>flags</u>.

       <b>EPERM</b>  The caller does not have the <b>CAP_DAC_READ_SEARCH</b> capability.

       <b>ESTALE</b> The specified <u>handle</u> is not valid for opening a file.  This error will occur if, for example,  the
              file  has  been  deleted.   This  error  can  also  occur  if  the  <u>handle</u>  was acquired using the
              <b>AT_HANDLE_FID</b> flag and the filesystem does not support <b>open_by_handle_at</b>().

</pre><h4><b>VERSIONS</b></h4><pre>
       FreeBSD has a broadly similar pair of system calls in the form of <b>getfh</b>() and <b>fhopen</b>().

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.39, glibc 2.14.

</pre><h4><b>NOTES</b></h4><pre>
       A file handle can be generated in one process using <b>name_to_handle_at</b>() and later  used  in  a  different
       process that calls <b>open_by_handle_at</b>().

       Some filesystem don't support the translation of pathnames to file handles, for example, <u><a href="file:/proc">/proc</a></u>, <u><a href="file:/sys">/sys</a></u>, and
       various  network filesystems.  Some filesystems support the translation of pathnames to file handles, but
       do not support using those file handles in <b>open_by_handle_at</b>().

       A file handle may become invalid ("stale") if  a  file  is  deleted,  or  for  other  filesystem-specific
       reasons.  Invalid handles are notified by an <b>ESTALE</b> error from <b>open_by_handle_at</b>().

       These system calls are designed for use by user-space file servers.  For example, a user-space NFS server
       might  generate  a  file  handle  and pass it to an NFS client.  Later, when the client wants to open the
       file, it could pass the handle back to the server.  This sort of functionality allows a  user-space  file
       server to operate in a stateless fashion with respect to the files it serves.

       If   <u>pathname</u>   refers   to   a  symbolic  link  and  <u>flags</u>  does  not  specify  <b>AT_SYMLINK_FOLLOW</b>,  then
       <b>name_to_handle_at</b>() returns a handle for the link (rather than the file to which it refers).  The process
       receiving the handle can later perform operations on the symbolic link by converting the handle to a file
       descriptor using <b>open_by_handle_at</b>() with the <b>O_PATH</b> flag, and then passing the file  descriptor  as  the
       <u>dirfd</u> argument in system calls such as <b><a href="../man2/readlinkat.2.html">readlinkat</a></b>(2) and <b><a href="../man2/fchownat.2.html">fchownat</a></b>(2).

   <b>Obtaining</b> <b>a</b> <b>persistent</b> <b>filesystem</b> <b>ID</b>
       The mount IDs in <u><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></u> can be reused as filesystems are unmounted and mounted.  Therefore,
       the  mount  ID  returned  by  <b>name_to_handle_at</b>()  (in  <u>*mount_id</u>)  should not be treated as a persistent
       identifier for the corresponding mounted filesystem.  However, an application can use the information  in
       the <u>mountinfo</u> record that corresponds to the mount ID to derive a persistent identifier.

       For  example,  one  can  use the device name in the fifth field of the <u>mountinfo</u> record to search for the
       corresponding device UUID via the symbolic links in  <u>/dev/disks/by-uuid</u>.   (A  more  comfortable  way  of
       obtaining the UUID is to use the <b><a href="../man3/libblkid.3.html">libblkid</a></b>(3) library.)  That process can then be reversed, using the UUID
       to  look  up  the  device name, and then obtaining the corresponding mount point, in order to produce the
       <u>mount_fd</u> argument used by <b>open_by_handle_at</b>().

</pre><h4><b>EXAMPLES</b></h4><pre>
       The two programs below demonstrate the use of <b>name_to_handle_at</b>()  and  <b>open_by_handle_at</b>().   The  first
       program  (<u>t_name_to_handle_at.c</u>)  uses <b>name_to_handle_at</b>() to obtain the file handle and mount ID for the
       file specified in its command-line argument; the handle and mount ID are written to standard output.

       The second program (<u>t_open_by_handle_at.c</u>) reads a mount ID and file handle  from  standard  input.   The
       program then employs <b>open_by_handle_at</b>() to open the file using that handle.  If an optional command-line
       argument  is  supplied,  then  the  <u>mount_fd</u>  argument for <b>open_by_handle_at</b>() is obtained by opening the
       directory named in that argument.  Otherwise, <u>mount_fd</u> is obtained by  scanning  <u><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></u>  to
       find  a  record  whose  mount  ID  matches the mount ID read from standard input, and the mount directory
       specified in that record is opened.  (These programs do not deal with the fact that  mount  IDs  are  not
       persistent.)

       The following shell session demonstrates the use of these two programs:

           $ <b>echo</b> <b>'Can</b> <b>you</b> <b>please</b> <b>think</b> <b>about</b> <b>it?'</b> <b>&gt;</b> <b>cecilia.txt</b>
           $ <b>./t_name_to_handle_at</b> <b>cecilia.txt</b> <b>&gt;</b> <b>fh</b>
           $ <b>./t_open_by_handle_at</b> <b>&lt;</b> <b>fh</b>
           open_by_handle_at: Operation not permitted
           $ <b>sudo</b> <b>./t_open_by_handle_at</b> <b>&lt;</b> <b>fh</b>      # Need CAP_SYS_ADMIN
           Read 31 bytes
           $ <b>rm</b> <b>cecilia.txt</b>

       Now  we  delete and (quickly) re-create the file so that it has the same content and (by chance) the same
       inode.  Nevertheless, <b>open_by_handle_at</b>() recognizes that the original  file  referred  to  by  the  file
       handle no longer exists.

           $ <b>stat</b> <b>--printf="%i\n"</b> <b>cecilia.txt</b>     # Display inode number
           4072121
           $ <b>rm</b> <b>cecilia.txt</b>
           $ <b>echo</b> <b>'Can</b> <b>you</b> <b>please</b> <b>think</b> <b>about</b> <b>it?'</b> <b>&gt;</b> <b>cecilia.txt</b>
           $ <b>stat</b> <b>--printf="%i\n"</b> <b>cecilia.txt</b>     # Check inode number
           4072121
           $ <b>sudo</b> <b>./t_open_by_handle_at</b> <b>&lt;</b> <b>fh</b>
           open_by_handle_at: Stale NFS file handle

   <b>Program</b> <b>source:</b> <b>t_name_to_handle_at.c</b>

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           int                 mount_id, fhsize, flags, dirfd;
           char                *pathname;
           struct file_handle  *fhp;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s pathname\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           pathname = argv[1];

           /* Allocate file_handle structure. */

           fhsize = sizeof(*fhp);
           fhp = malloc(fhsize);
           if (fhp == NULL)
               err(EXIT_FAILURE, "malloc");

           /* Make an initial call to name_to_handle_at() to discover
              the size required for file handle. */

           dirfd = AT_FDCWD;           /* For name_to_handle_at() calls */
           flags = 0;                  /* For name_to_handle_at() calls */
           fhp-&gt;handle_bytes = 0;
           if (name_to_handle_at(dirfd, pathname, fhp,
                                 &amp;mount_id, flags) != -1
               || errno != EOVERFLOW)
           {
               fprintf(stderr, "Unexpected result from name_to_handle_at()\n");
               exit(EXIT_FAILURE);
           }

           /* Reallocate file_handle structure with correct size. */

           fhsize = sizeof(*fhp) + fhp-&gt;handle_bytes;
           fhp = realloc(fhp, fhsize);         /* Copies fhp-&gt;handle_bytes */
           if (fhp == NULL)
               err(EXIT_FAILURE, "realloc");

           /* Get file handle from pathname supplied on command line. */

           if (name_to_handle_at(dirfd, pathname, fhp, &amp;mount_id, flags) == -1)
               err(EXIT_FAILURE, "name_to_handle_at");

           /* Write mount ID, file handle size, and file handle to stdout,
              for later reuse by t_open_by_handle_at.c. */

           printf("%d\n", mount_id);
           printf("%u %d   ", fhp-&gt;handle_bytes, fhp-&gt;handle_type);
           for (size_t j = 0; j &lt; fhp-&gt;handle_bytes; j++)
               printf(" %02x", fhp-&gt;f_handle[j]);
           printf("\n");

           exit(EXIT_SUCCESS);
       }

   <b>Program</b> <b>source:</b> <b>t_open_by_handle_at.c</b>

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/limits.h">limits.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       /* Scan <a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a> to find the line whose mount ID matches
          'mount_id'. (An easier way to do this is to install and use the
          'libmount' library provided by the 'util-linux' project.)
          Open the corresponding mount path and return the resulting file
          descriptor. */

       static int
       open_mount_path_by_id(int mount_id)
       {
           int      mi_mount_id, found;
           char     mount_path[PATH_MAX];
           char     *linep;
           FILE     *fp;
           size_t   lsize;
           ssize_t  nread;

           fp = fopen("<a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a>", "r");
           if (fp == NULL)
               err(EXIT_FAILURE, "fopen");

           found = 0;
           linep = NULL;
           while (!found) {
               nread = getline(&amp;linep, &amp;lsize, fp);
               if (nread == -1)
                   break;

               nread = sscanf(linep, "%d %*d %*s %*s %s",
                              &amp;mi_mount_id, mount_path);
               if (nread != 2) {
                   fprintf(stderr, "Bad sscanf()\n");
                   exit(EXIT_FAILURE);
               }

               if (mi_mount_id == mount_id)
                   found = 1;
           }
           free(linep);

           fclose(fp);

           if (!found) {
               fprintf(stderr, "Could not find mount point\n");
               exit(EXIT_FAILURE);
           }

           return open(mount_path, O_RDONLY);
       }

       int
       main(int argc, char *argv[])
       {
           int                 mount_id, fd, mount_fd, handle_bytes;
           char                buf[1000];
       #define LINE_SIZE 100
           char                line1[LINE_SIZE], line2[LINE_SIZE];
           char                *nextp;
           ssize_t             nread;
           struct file_handle  *fhp;

           if ((argc &gt; 1 &amp;&amp; strcmp(argv[1], "--help") == 0) || argc &gt; 2) {
               fprintf(stderr, "Usage: %s [mount-path]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           /* Standard input contains mount ID and file handle information:

                Line 1: &lt;mount_id&gt;
                Line 2: &lt;handle_bytes&gt; &lt;handle_type&gt;   &lt;bytes of handle in hex&gt;
           */

           if (fgets(line1, sizeof(line1), stdin) == NULL ||
               fgets(line2, sizeof(line2), stdin) == NULL)
           {
               fprintf(stderr, "Missing mount_id / file handle\n");
               exit(EXIT_FAILURE);
           }

           mount_id = atoi(line1);

           handle_bytes = strtoul(line2, &amp;nextp, 0);

           /* Given handle_bytes, we can now allocate file_handle structure. */

           fhp = malloc(sizeof(*fhp) + handle_bytes);
           if (fhp == NULL)
               err(EXIT_FAILURE, "malloc");

           fhp-&gt;handle_bytes = handle_bytes;

           fhp-&gt;handle_type = strtoul(nextp, &amp;nextp, 0);

           for (size_t j = 0; j &lt; fhp-&gt;handle_bytes; j++)
               fhp-&gt;f_handle[j] = strtoul(nextp, &amp;nextp, 16);

           /* Obtain file descriptor for mount point, either by opening
              the pathname specified on the command line, or by scanning
              <a href="file:/proc/self/mounts">/proc/self/mounts</a> to find a mount that matches the 'mount_id'
              that we received from stdin. */

           if (argc &gt; 1)
               mount_fd = open(argv[1], O_RDONLY);
           else
               mount_fd = <a href="../manmount_id/open_mount_path_by_id.mount_id.html">open_mount_path_by_id</a>(mount_id);

           if (mount_fd == -1)
               err(EXIT_FAILURE, "opening mount fd");

           /* Open file using handle and mount point. */

           fd = open_by_handle_at(mount_fd, fhp, O_RDONLY);
           if (fd == -1)
               err(EXIT_FAILURE, "open_by_handle_at");

           /* Try reading a few bytes from the file. */

           nread = read(fd, buf, sizeof(buf));
           if (nread == -1)
               err(EXIT_FAILURE, "read");

           printf("Read %zd bytes\n", nread);

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/open.2.html">open</a></b>(2), <b><a href="../man3/libblkid.3.html">libblkid</a></b>(3), <b><a href="../man8/blkid.8.html">blkid</a></b>(8), <b><a href="../man8/findfs.8.html">findfs</a></b>(8), <b><a href="../man8/mount.8.html">mount</a></b>(8)

       The    <u>libblkid</u>    and    <u>libmount</u>    documentation    in    the    latest    <u>util-linux</u>    release    at
       https://www.kernel.org/pub/linux/utils/util-linux/

Linux man-pages 6.9.1                              2024-06-15                               <u><a href="../man2/open_by_handle_at.2.html">open_by_handle_at</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>