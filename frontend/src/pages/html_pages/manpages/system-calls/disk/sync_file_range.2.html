<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sync_file_range - sync a file segment with disk</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sync_file_range - sync a file segment with disk

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>         /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#define</b> <b>_FILE_OFFSET_BITS</b> <b>64</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;</b>

       <b>int</b> <b>sync_file_range(int</b> <u>fd</u><b>,</b> <b>off_t</b> <u>offset</u><b>,</b> <b>off_t</b> <u>nbytes</u><b>,</b>
                           <b>unsigned</b> <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sync_file_range</b>()  permits  fine  control  when  synchronizing  the  open  file  referred  to by the file
       descriptor <u>fd</u> with disk.

       <u>offset</u> is the starting byte of the file range to be synchronized.  <u>nbytes</u> specifies  the  length  of  the
       range  to  be synchronized, in bytes; if <u>nbytes</u> is zero, then all bytes from <u>offset</u> through to the end of
       file are synchronized.  Synchronization is in units of the system page size: <u>offset</u> is rounded down to  a
       page boundary; <u>(offset+nbytes-1)</u> is rounded up to a page boundary.

       The <u>flags</u> bit-mask argument can include any of the following values:

       <b>SYNC_FILE_RANGE_WAIT_BEFORE</b>
              Wait  upon  write-out  of all pages in the specified range that have already been submitted to the
              device driver for write-out before performing any write.

       <b>SYNC_FILE_RANGE_WRITE</b>
              Initiate write-out of all dirty pages in the specified range which  are  not  presently  submitted
              write-out.  Note that even this may block if you attempt to write more than request queue size.

       <b>SYNC_FILE_RANGE_WAIT_AFTER</b>
              Wait upon write-out of all pages in the range after performing any write.

       Specifying <u>flags</u> as 0 is permitted, as a no-op.

   <b>Warning</b>
       This  system  call  is  extremely  dangerous  and should not be used in portable programs.  None of these
       operations writes out the file's metadata.  Therefore, unless  the  application  is  strictly  performing
       overwrites  of  already-instantiated disk blocks, there are no guarantees that the data will be available
       after a crash.  There is no user interface to know if a write is purely  an  overwrite.   On  filesystems
       using  copy-on-write  semantics  (e.g.,  <u>btrfs</u>)  an overwrite of existing allocated blocks is impossible.
       When writing into preallocated space, many filesystems also require calls into the block allocator, which
       this system call does not sync out to disk.  This system call does not flush disk write caches  and  thus
       does not provide any data integrity on systems with volatile disk write caches.

   <b>Some</b> <b>details</b>
       <b>SYNC_FILE_RANGE_WAIT_BEFORE</b>   and  <b>SYNC_FILE_RANGE_WAIT_AFTER</b>  will  detect  any  I/O  errors  or  <b>ENOSPC</b>
       conditions and will return these to the caller.

       Useful combinations of the <u>flags</u> bits are:

       <b>SYNC_FILE_RANGE_WAIT_BEFORE</b> <b>|</b> <b>SYNC_FILE_RANGE_WRITE</b>
              Ensures that all pages in the specified range which were dirty when <b>sync_file_range</b>()  was  called
              are placed under write-out.  This is a start-write-for-data-integrity operation.

       <b>SYNC_FILE_RANGE_WRITE</b>
              Start write-out of all dirty pages in the specified range which are not presently under write-out.
              This  is  an  asynchronous  flush-to-disk  operation.   This  is  not  suitable for data integrity
              operations.

       <b>SYNC_FILE_RANGE_WAIT_BEFORE</b> (or <b>SYNC_FILE_RANGE_WAIT_AFTER</b>)
              Wait for completion of write-out of all pages in the specified range.  This can be used  after  an
              earlier  <b>SYNC_FILE_RANGE_WAIT_BEFORE</b>  <b>|</b>  <b>SYNC_FILE_RANGE_WRITE</b> operation to wait for completion of
              that operation, and obtain its result.

       <b>SYNC_FILE_RANGE_WAIT_BEFORE</b> <b>|</b> <b>SYNC_FILE_RANGE_WRITE</b> <b>|</b> <b>SYNC_FILE_RANGE_WAIT_AFTER</b>
              This is a write-for-data-integrity operation that will ensure that  all  pages  in  the  specified
              range which were dirty when <b>sync_file_range</b>() was called are committed to disk.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  <b>sync_file_range</b>()  returns  0;  on  failure -1 is returned and <u>errno</u> is set to indicate the
       error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EBADF</b>  <u>fd</u> is not a valid file descriptor.

       <b>EINVAL</b> <u>flags</u> specifies an invalid bit; or <u>offset</u> or <u>nbytes</u> is invalid.

       <b>EIO</b>    I/O error.

       <b>ENOMEM</b> Out of memory.

       <b>ENOSPC</b> Out of disk space.

       <b>ESPIPE</b> <u>fd</u> refers to something other than a regular file, a block device, or a directory.

</pre><h4><b>VERSIONS</b></h4><pre>
   <b>sync_file_range2()</b>
       Some architectures (e.g., PowerPC, ARM) need 64-bit arguments  to  be  aligned  in  a  suitable  pair  of
       registers.   On  such  architectures, the call signature of <b>sync_file_range</b>() shown in the SYNOPSIS would
       force a register to be wasted as padding between the  <u>fd</u>  and  <u>offset</u>  arguments.   (See  <b><a href="../man2/syscall.2.html">syscall</a></b>(2)  for
       details.)   Therefore,  these  architectures  define  a  different  system call that orders the arguments
       suitably:

           <b>int</b> <b>sync_file_range2(int</b> <u>fd</u><b>,</b> <b>unsigned</b> <b>int</b> <u>flags</u><b>,</b>
                                <b>off_t</b> <u>offset</u><b>,</b> <b>off_t</b> <u>nbytes</u><b>);</b>

       The behavior of this system call is otherwise exactly the same as <b>sync_file_range</b>().

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.17.

   <b>sync_file_range2()</b>
       A system call with this signature first appeared on the ARM architecture in Linux 2.6.20, with  the  name
       <b>arm_sync_file_range</b>().   It  was  renamed  in  Linux 2.6.22, when the analogous system call was added for
       PowerPC.  On architectures where glibc support is provided, glibc transparently wraps  <b>sync_file_range2</b>()
       under the name <b>sync_file_range</b>().

</pre><h4><b>NOTES</b></h4><pre>
       <b>_FILE_OFFSET_BITS</b>  should  be  defined to be 64 in code that takes the address of <b>sync_file_range</b>, if the
       code is intended to be portable to traditional 32-bit x86 and ARM platforms where <b>off_t</b>'s width  defaults
       to 32 bits.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/fdatasync.2.html">fdatasync</a></b>(2), <b><a href="../man2/fsync.2.html">fsync</a></b>(2), <b><a href="../man2/msync.2.html">msync</a></b>(2), <b><a href="../man2/sync.2.html">sync</a></b>(2)

Linux man-pages 6.9.1                              2024-05-02                                 <u><a href="../man2/sync_file_range.2.html">sync_file_range</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>