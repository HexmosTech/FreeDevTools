<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>point - d-dimensional physical point or vector (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       point - d-dimensional physical point or vector (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The point defines a vertex or vector in the physical d-dimensional space, d=1,2,3. It is represented as
       an array of coordinates. The coordinate index starts at zero and finishes at d-1, e.g. x[0], x[1] and
       x[2].

       The default constructor set all components to zero:

           point x;

        and this default could be overridden:

           point x (1, 2, 3.14);

        or alternatively:

           point x = {1, 2, 3.14};

        The standard linear algebra for vectors is supported by the point class.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file fem/geo_element/point.h

       The point class is simply an alias to the <b>point_basic</b> <b>class</b>

       typedef point_basic&lt;Float&gt; point;

       The <b>point_basic</b> <b>class</b> <b>is</b> <b>a</b> <b>template</b> <b>class</b> <b>with</b> <b>the</b> <b>floating</b> <b>type</b> <b>as</b> <b>parameter:</b>

       template &lt;class T&gt;
       class point_basic {
       public:

       // typedefs:

         typedef size_t size_type;
         typedef T      element_type;
         typedef T      scalar_type;
         typedef T      float_type;

       // allocators:

         explicit point_basic();
         explicit point_basic (const T&amp; x0, const T&amp; x1 = 0, const T&amp; x2 = 0);

         template &lt;class T1&gt;
         point_basic&lt;T&gt;(const point_basic&lt;T1&gt;&amp; p);

         template &lt;class T1&gt;
         point_basic&lt;T&gt;&amp; operator= (const point_basic&lt;T1&gt;&amp; p);

         point_basic (const std::initializer_list&lt;T&gt;&amp; il);

       // accessors:

         T&amp; operator[](int i_coord)              { return _x[i_coord%3]; }
         T&amp; operator()(int i_coord)              { return _x[i_coord%3]; }
         const T&amp;  operator[](int i_coord) const { return _x[i_coord%3]; }
         const T&amp;  operator()(int i_coord) const { return _x[i_coord%3]; }

       // algebra:

         bool operator== (const point_basic&lt;T&gt;&amp; v) const;
         bool operator!= (const point_basic&lt;T&gt;&amp; v) const;
         point_basic&lt;T&gt; operator+ (const point_basic&lt;T&gt;&amp; v) const;
         point_basic&lt;T&gt; operator- (const point_basic&lt;T&gt;&amp; v) const;
         point_basic&lt;T&gt; operator- () const;
         point_basic&lt;T&gt;&amp; operator+= (const point_basic&lt;T&gt;&amp; v);
         point_basic&lt;T&gt;&amp; operator-= (const point_basic&lt;T&gt;&amp; v);
         point_basic&lt;T&gt;&amp; operator*= (const T&amp; a);
         point_basic&lt;T&gt;&amp; operator/= (const T&amp; a);

         template &lt;class U&gt;
         typename
         std::enable_if&lt;
           details::is_rheolef_arithmetic&lt;U&gt;::value
           ,point_basic&lt;T&gt;
         &gt;::type
         operator* (const U&amp; a) const;
         point_basic&lt;T&gt; operator/ (const T&amp; a) const;
         point_basic&lt;T&gt; operator/ (point_basic&lt;T&gt; v) const;

       // i/o:

         std::istream&amp; get (std::istream&amp; s, int d = 3);
         std::ostream&amp; put (std::ostream&amp; s, int d = 3) const;

       };

       These linear and nonlinear functions are completed by some usual functions:

       template&lt;class T&gt;
       std::istream&amp; operator &gt;&gt; (std::istream&amp; s, point_basic&lt;T&gt;&amp; p);

       template&lt;class T&gt;
       std::ostream&amp; operator &lt;&lt; (std::ostream&amp; s, const point_basic&lt;T&gt;&amp; p);

       template &lt;class T, class U&gt;
       typename
       std::enable_if&lt;
         details::is_rheolef_arithmetic&lt;U&gt;::value
        ,point_basic&lt;T&gt;
       &gt;::type
       operator* (const U&amp; a, const point_basic&lt;T&gt;&amp; u);

       template&lt;class T&gt;
       point_basic&lt;T&gt;
       vect (const point_basic&lt;T&gt;&amp; v, const point_basic&lt;T&gt;&amp; w);

       // metrics:
       template&lt;class T&gt;
       T dot (const point_basic&lt;T&gt;&amp; x, const point_basic&lt;T&gt;&amp; y);

       template&lt;class T&gt;
       T norm2 (const point_basic&lt;T&gt;&amp; x);

       template&lt;class T&gt;
       T norm (const point_basic&lt;T&gt;&amp; x);

       template&lt;class T&gt;
       T dist2 (const point_basic&lt;T&gt;&amp; x,  const point_basic&lt;T&gt;&amp; y);

       template&lt;class T&gt;
       T dist (const point_basic&lt;T&gt;&amp; x,  const point_basic&lt;T&gt;&amp; y);

       template&lt;class T&gt;
       T dist_infty (const point_basic&lt;T&gt;&amp; x,  const point_basic&lt;T&gt;&amp; y);

       template &lt;class T&gt;
       T vect2d (const point_basic&lt;T&gt;&amp; v, const point_basic&lt;T&gt;&amp; w);

       template &lt;class T&gt;
       T mixt (const point_basic&lt;T&gt;&amp; u, const point_basic&lt;T&gt;&amp; v, const point_basic&lt;T&gt;&amp; w);

       // robust(exact) floating point predicates: return the sign of the value as (0, &gt; 0, &lt; 0)
       // formally: orient2d(a,b,x) = vect2d(a-x,b-x)
       template &lt;class T&gt;
       int sign_orient2d (
         const point_basic&lt;T&gt;&amp; a,
         const point_basic&lt;T&gt;&amp; b,
         const point_basic&lt;T&gt;&amp; c);

       template &lt;class T&gt;
       int sign_orient3d (
         const point_basic&lt;T&gt;&amp; a,
         const point_basic&lt;T&gt;&amp; b,
         const point_basic&lt;T&gt;&amp; c,
         const point_basic&lt;T&gt;&amp; d);

       // compute also the value:
       template &lt;class T&gt;
       T orient2d(
         const point_basic&lt;T&gt;&amp; a,
         const point_basic&lt;T&gt;&amp; b,
         const point_basic&lt;T&gt;&amp; c);

       // formally: orient3d(a,b,c,x) = mixt3d(a-x,b-x,c-x)
       template &lt;class T&gt;
       T orient3d(
         const point_basic&lt;T&gt;&amp; a,
         const point_basic&lt;T&gt;&amp; b,
         const point_basic&lt;T&gt;&amp; c,
         const point_basic&lt;T&gt;&amp; d);

       template &lt;class T&gt;
       std::string ptos (const point_basic&lt;T&gt;&amp; x, int d = 3);

       // ccomparators: lexicographic order
       template&lt;class T, size_t d&gt;
       bool lexicographically_less (const point_basic&lt;T&gt;&amp; a, const point_basic&lt;T&gt;&amp; b);

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                   <u><a href="../man2rheolef/point.2rheolef.html">point</a></u>(2rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>