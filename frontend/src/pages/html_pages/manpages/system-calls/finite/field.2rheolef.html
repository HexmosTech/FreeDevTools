<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>field - piecewise polynomial finite element function (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       field - piecewise polynomial finite element function (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class represents a piecewise polynomial finite element function. Since this function spans onto a
       finite dimensional basis, it simply stores its coefficients on this basis: these coefficients are called
       the <u>degrees</u> <u>of</u> <u>freedom</u> (see <b><a href="../man2/space.2.html">space</a>(2)</b>).

</pre><h4><b>INTERPOLATION</b></h4><pre>
       For any function u, its interpolation on the finite element space Xh as a field uh in Xh expresses simply
       via the <b><a href="../man3/interpolate.3.html">interpolate</a>(3)</b> function:

           Float u (const point&amp; x) { return exp(x[0]*x[1]); }
           ...
           field uh = interpolate (Xh, u);

</pre><h4><b>LINEAR</b> <b>ALGEBRA</b></h4><pre>
       Linear algebra, such as uh+vh, uh-vh and lambda*uh + mu*vh, where lambda and mu are of type Float, are
       supported. The duality product between two fields lh and uh writes simply dual(lh,uh). As we consider
       finite dimensional spaces, this duality product coincides with the usual Euclidean dot product in
       IR^dim(Xh). The application of the a bilinear <b><a href="../man2/form.2.html">form</a>(2)</b> writes a(uh,vh) and is equivalent to dual(m*uh,vh).

</pre><h4><b>COMMON</b> <b>ACCESSORS</b></h4><pre>
       For convenience, uh.max(), uh.min() and uh.max_abs() returns respectively the maximum, minimum and
       maximum of the absolute value of the degrees of freedom.

</pre><h4><b>NON-LINEAR</b> <b>ALGEBRA</b></h4><pre>
       Non-linear operations, such as sqrt(uh) or 1/uh are also available. Note that non-linear operations do
       not returns in general piecewise polynomials: the value returned by sqrt(uh) may be filtered by
       <b><a href="../man3/interpolate.3.html">interpolate</a>(3)</b> function:

           field vh = interpolate (Xh, sqrt(uh));

        Also, the multiplication uh*vh and the division uh/vh returns a result that is not in the same discrete
       finite element space: its result also may be filtered by <b><a href="../man3/interpolate.3.html">interpolate</a>(3)</b>`:

           field wh = interpolate(Xh, uh*vh);

        All standard unary and binary math functions abs, cos, sin... are extended to scalar fields. Also
       sqr(uh), the square of a field, and min(uh,vh), max(uh,vh) are provided. Binary functions can be used
       also with a scalar, as in

           field vh = interpolate (Xh, max (abs(uh), 0));
           field wh = interpolate (Xh, pow (abs(uh), 1./3));

        For applying a user-provided function to a field, please see the <b><a href="../man3/compose.3.html">compose</a>(3)</b> function.

</pre><h4><b>ACCESS</b> <b>BY</b> <b>DOMAIN</b></h4><pre>
       The restriction of a field to a geometric domain, says 'boundary' writes uh['boundary']: it represents
       the trace of the field on the boundary:

           space Xh (omega, 'P1');
           uh['boundary'] = 0;

        A possible alternative uses a <b><a href="../man2/geo.2.html">geo</a>(2)</b> domain as index:

           geo boundary = omega['boundary'];
           uh[boundary] = 0;

</pre><h4><b>MULTI-VALUED</b> <b>FIELDS</b></h4><pre>
       A vector-valued field contains several components, as:

           space Xh (omega, 'P2', 'vector');
           field uh (Xh);

        Conversely, for a tensor-valued field:

           space Th (omega, 'P1d', 'tensor');
           field sigma_h (Xh);

</pre><h4><b>GENERAL</b> <b>SPACE</b> <b>PRODUCT</b> <b>INTERFACE</b></h4><pre>
       A general multi-component field writes:

           space Th (omega, 'P1d', 'tensor');
           space Vh (omega, 'P2', 'vector');
           space Qh (omega, 'P1');
           space Xh = Th*Vh*Qh;
           field xh (Xh);
           field tau_h = xh[0]; // tensor-valued
           field uh    = xh[1]; // vector-valued
           field qh    = xh[2]; // scalar

        Remark the hierarchical multi-component field structure: the first-component is tensor-valued and the
       second-one is vector-valued. There is no limitation upon the hierarchical number of levels in use: the
       hierarchy is not flattened.

       The xh.size() returns the number of field components. When the field is scalar, it returns zero by
       convention, and xh[0] is undefined.

</pre><h4><b>DIRECT</b> <b>ACCESS</b> <b>TO</b> <b>DEGREES-OF-FREEDOM</b></h4><pre>
       The field class provides a STL-like container interface for accessing the degrees-of-freedom (dofs) of a
       finite element field uh. The number of dofs is uh.ndof() and any dof can be accessed via uh.dof(idof). In
       a distributed memory environment, a non-local dof at the partition interface can be obtain via
       uh.dis_dof(dis_idof) where dis_idof is the (global) distributed index assoiated to the distribution
       uh.ownership(). See <b><a href="../man4/distributor.4.html">distributor</a>(4)</b>.

       For better performances, a STL-like iterator interface is available, with uh.begin_dof() and uh.end_dof()
       returns iterators to the dofs on the current processor.

</pre><h4><b>REPRESENTATION</b></h4><pre>
       The degrees of freedom (see <b><a href="../man2/space.2.html">space</a>(2)</b>) are splited between <u>unknowns</u> <u>and</u> <u>blocked</u>, i.e. uh=[uh.u,uh.b] for
       any field uh in Xh. Access to these vectors is allowed via some accessors: a read-only one, as uh.u() and
       uh.b(), and a read-and-write one, as uh.set_u() and uh.set_b(), see <b><a href="../man4/vec.4.html">vec</a>(4)</b>.

       Note that blocked and unknown degrees of freedom could also be elegantly set by using a domain name
       indexation (see <b><a href="../man2/geo.2.html">geo</a>(2)</b>):

           geo omega ('circle');
           space Xh (omega, 'P1');
           Xh.block ('boundary');
           field uh (Xh);
           uh ['boundary'] = 0;

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file main/lib/field.h

       The field class is simply an alias to the <b>field_basic</b> <b>class</b>

       typedef field_basic&lt;Float&gt; field;

       The <b>field_basic</b> <b>class</b> <b>provides</b> <b>an</b> <b>interface</b> <b>to</b> <b>a</b> <b>vector</b> <b>data</b> <b>container:</b>

       template &lt;class T, class M = rheo_default_memory_model&gt;
       class field_basic: public details::field_wdof_base&lt;field_basic&lt;T,M&gt;&gt; {
       public :
       // typedefs:

         using wdof_base     = details::field_wdof_base&lt;field_basic&lt;T,M&gt;&gt;;
         using rdof_base     = details::field_rdof_base&lt;field_basic&lt;T,M&gt;&gt;;
         using size_type     = std::size_t;
         using scalar_type   = T;
         using memory_type   = M;
         using float_type    = typename float_traits&lt;T&gt;::type;
         using geo_type      = geo_basic  &lt;float_type,memory_type&gt;;
         using space_type    = space_basic&lt;float_type,memory_type&gt;;
         using dis_reference = typename vec&lt;scalar_type,memory_type&gt;::dis_reference;
         using valued_type   = space_constant::valued_type;
         using value_type    = T; // TODO: run-time dependent, set it to undeterminated&lt;T&gt;
         using result_type   = T; // TODO: run-time dependent, set it to undeterminated&lt;T&gt;
         class iterator;
         class const_iterator;

       // allocator/deallocator:

         field_basic();

         explicit field_basic (
           const space_type&amp; V,
           const T&amp; init_value = std::numeric_limits&lt;T&gt;::max());

         void resize (
           const space_type&amp; V,
           const T&amp; init_value = std::numeric_limits&lt;T&gt;::max());

         // expressions: field_expr or field_lazy are accepted here
         // TODO: merge with FieldLazy piecewise_poly
         template &lt;class Expr, class Sfinae =
           typename std::enable_if&lt;
             (      details::is_field_expr_affine_homogeneous&lt;Expr&gt;::value
               &amp;&amp; ! details::is_field&lt;Expr&gt;::value
             )
             ||   details::is_field_lazy&lt;Expr&gt;::value
           &gt;::type&gt;
         field_basic (const Expr&amp; expr);

         field_basic (const std::initializer_list&lt;details::field_concat_value&lt;T,M&gt; &gt;&amp; init_list);

       // assignments:

         field_basic&lt;T,M&gt;&amp; operator= (const field_basic&lt;T,M&gt;&amp;);
         field_basic&lt;T,M&gt;&amp; operator= (const std::initializer_list&lt;details::field_concat_value&lt;T,M&gt; &gt;&amp; init_list);

       // accessors:

         const space_type&amp;  get_space()  const { return _V; }
         const geo_type&amp;    get_geo()    const { return _V.get_geo(); }
         std::string        get_approx() const { return _V.get_approx(); }
         valued_type        valued_tag() const { return _V.valued_tag(); }
         const std::string&amp; valued()     const { return _V.valued(); }
       #ifdef TO_CLEAN
         std::string        name()      const { return _V.name(); }
         bool have_homogeneous_space (space_basic&lt;T,M&gt;&amp; Xh) const { Xh = get_space(); return true; }
       #endif // TO_CLEAN

       // accessors &amp; modifiers to unknown &amp; blocked parts:

         const vec&lt;T,M&gt;&amp;     u() const { return _u; }
         const vec&lt;T,M&gt;&amp;     b() const { return _b; }
               vec&lt;T,M&gt;&amp; set_u()       { dis_dof_indexes_requires_update(); return _u; }
               vec&lt;T,M&gt;&amp; set_b()       { dis_dof_indexes_requires_update(); return _b; }

       // accessors to extremas:

         T min() const;
         T max() const;
         T max_abs() const;
         T min_abs() const;

       // accessors by degrees-of-freedom (dof):

         const distributor&amp; ownership() const { return get_space().ownership(); }
         const communicator&amp; comm() const { return ownership().comm(); }
         size_type     ndof() const { return ownership().size(); }
         size_type dis_ndof() const { return ownership().dis_size(); }
               T&amp; dof (size_type idof);
         const T&amp; dof (size_type idof) const;
         const T&amp; dis_dof (size_type dis_idof) const;
         // write access to non-local dis_idof changes to others procs
         dis_reference dis_dof_entry (size_type dis_idof);

         iterator begin_dof();
         iterator end_dof();
         const_iterator begin_dof() const;
         const_iterator end_dof() const;

       // input/output:

         idiststream&amp; get (idiststream&amp; ips);
         odiststream&amp; put (odiststream&amp; ops) const;
         odiststream&amp; put_field (odiststream&amp; ops) const;

       // evaluate uh(x) where x is given locally as hat_x in K:

         T dis_evaluate (const point_basic&lt;T&gt;&amp; x, size_type i_comp = 0) const;
         T operator()   (const point_basic&lt;T&gt;&amp; x) const { return dis_evaluate (x,0); }
         point_basic&lt;T&gt; dis_vector_evaluate (const point_basic&lt;T&gt;&amp; x) const;

       };

       namespace details {

       // concepts:
       template&lt;class T, class M&gt;
       struct is_field&lt;field_basic&lt;T,M&gt;&gt; : std::true_type {};

       // field class is not an ordinary function/functor : for compose(field,args...) filtering
       template &lt;typename T, typename M&gt;  struct function_traits &lt;field_basic&lt;T,M&gt; &gt; {};

       template&lt;class T, class M&gt;
       struct field_traits&lt;field_basic&lt;T,M&gt;&gt; {
         using size_type     = std::size_t;
         using scalar_type   = T;
         using memory_type   = M;
       };

       } // namespace details

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                   <u><a href="../man2rheolef/field.2rheolef.html">field</a></u>(2rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>