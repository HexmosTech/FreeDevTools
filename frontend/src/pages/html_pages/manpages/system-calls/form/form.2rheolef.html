<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>form - finite element bilinear form (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       form - finite element bilinear form (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The form class groups four sparse matrix, associated to a bilinear form defined on two finite element
       spaces:

          a: Uh*Vh   ----&gt; IR
            (uh,vh)  +---&gt; a(uh,vh)

        The A operator associated to the bilinear form is defined by:

          A: Uh  ----&gt; Vh
             uh  +---&gt; A*uh

        where uh is a <b><a href="../man2/field.2.html">field</a>(2)</b>, and vh=A*uh in Vh is such that a(uh,vh)=dual(A*uh,vh) for all vh in Vh and where
       dual(.,.) denotes the duality product between Vh and its dual. Since Vh is a finite dimensional space,
       its dual is identified to Vh itself and the duality product is the euclidean product in IR^dim(Vh). Also,
       the linear operator can be represented by a matrix.

       In practice, bilinear forms are created by using the <b><a href="../man3/integrate.3.html">integrate</a>(3)</b> function.

</pre><h4><b>ALGEBRA</b></h4><pre>
       Forms, as matrix, support standard algebra. Adding or subtracting two forms writes a+b and a-b,
       respectively, while multiplying by a scalar lambda writes lambda*a and multiplying two forms writes a*b.
       Also, multiplying a form by a field uh writes a*uh. The form inversion is not as direct as e.g. as
       inv(a), since forms are very large matrix in practice: form inversion can be obtained via the <b><a href="../man4/solver.4.html">solver</a>(4)</b>
       class. A notable exception is the case of block-diagonal forms at the element level: in that case, a
       direct inversion is possible during the assembly process, see <b><a href="../man3/integrate_option.3.html">integrate_option</a>(3)</b>.

</pre><h4><b>REPRESENTATION</b></h4><pre>
       The degrees of freedom (see <b><a href="../man2/space.2.html">space</a>(2)</b>) are splited between <u>unknowns</u> <u>and</u> <u>blocked</u>, i.e. uh=[uh.u,uh.b] for
       any field uh in Uh. Conversely, vh=[vh.u,vh.b] for any field vh in Vh. Then, the form-field vh=a*uh
       operation is formally equivalent to the following matrix-vector block operations:

           [ vh.u ]   [ a.uu  a.ub ] [ uh.u ]
           [      ] = [            ] [      ]
           [ vh.b ]   [ a.bu  a.bb ] [ uh.n ]

        or, after expansion:

           vh.u = a.uu*uh.u + a.ub*vh.b
           vh.b = a.bu*uh.b + a.bb*vh.b

        i.e. the A matrix also admits a 2x2 block structure. Then, the form class is represented by four sparse
       matrix and the <b><a href="../man4/csr.4.html">csr</a>(4)</b> compressed format is used. Note that the previous formal relations for vh=a*uh
       writes equivalently within the Rheolef library as:

           vh.set_u() = a.uu()*uh.u() + a.ub()*uh.b();
           vh.set_b() = a.bu()*uh.u() + a.bb()*uh.b();

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file main/lib/form.h

       The form class is simply an alias to the <b>form_basic</b> <b>class</b>

       typedef form_basic&lt;Float,rheo_default_memory_model&gt; form;

       The <b>form_basic</b> <b>class</b> <b>provides</b> <b>an</b> <b>interface</b> <b>to</b> <b>four</b> <b>sparse</b> <b>matrix:</b>

       template&lt;class T, class M&gt;
       class form_basic {
       public :
       // typedefs:

           typedef typename csr&lt;T,M&gt;::size_type    size_type;
           typedef T                               value_type;
           typedef typename scalar_traits&lt;T&gt;::type float_type;
           typedef geo_basic&lt;float_type,M&gt;         geo_type;
           typedef space_basic&lt;float_type,M&gt;       space_type;

       // allocator/deallocator:

           form_basic ();
           form_basic (const form_basic&lt;T,M&gt;&amp;);
           form_basic&lt;T,M&gt;&amp; operator= (const form_basic&lt;T,M&gt;&amp;);

           template&lt;class Expr, class Sfinae = typename std::enable_if&lt;details::is_form_lazy&lt;Expr&gt;::value, Expr&gt;::type&gt;
           form_basic (const Expr&amp;);

           template&lt;class Expr, class Sfinae = typename std::enable_if&lt;details::is_form_lazy&lt;Expr&gt;::value, Expr&gt;::type&gt;
           form_basic&lt;T,M&gt;&amp; operator= (const Expr&amp;);

       // allocators from initializer list (c++ 2011):

           form_basic (const std::initializer_list&lt;details::form_concat_value&lt;T,M&gt; &gt;&amp; init_list);
           form_basic (const std::initializer_list&lt;details::form_concat_line &lt;T,M&gt; &gt;&amp; init_list);

       // accessors:

           const space_type&amp; get_first_space() const;
           const space_type&amp; get_second_space() const;
           const geo_type&amp;   get_geo() const;
           bool is_symmetric() const;
           void set_symmetry (bool is_symm = true) const;
           bool is_definite_positive() const;
           void set_definite_positive (bool is_dp = true) const;
           bool is_symmetric_definite_positive() const;
           void set_symmetric_definite_positive() const;

           const communicator&amp; comm() const;

       // linear algebra:

           form_basic&lt;T,M&gt;  operator+  (const form_basic&lt;T,M&gt;&amp; b) const;
           form_basic&lt;T,M&gt;  operator-  (const form_basic&lt;T,M&gt;&amp; b) const;
           form_basic&lt;T,M&gt;  operator*  (const form_basic&lt;T,M&gt;&amp; b) const;
           form_basic&lt;T,M&gt;&amp; operator*= (const T&amp; lambda);
           field_basic&lt;T,M&gt; operator*  (const field_basic&lt;T,M&gt;&amp; xh) const;
           field_basic&lt;T,M&gt; trans_mult (const field_basic&lt;T,M&gt;&amp; yh) const;
           float_type operator () (const field_basic&lt;T,M&gt;&amp; uh, const field_basic&lt;T,M&gt;&amp; vh) const;

       // io:

           odiststream&amp; put (odiststream&amp; ops, bool show_partition = true) const;
           void dump (std::string name) const;

       // accessors &amp; modifiers to unknown &amp; blocked parts:

           const csr&lt;T,M&gt;&amp;     uu() const { return _uu; }
           const csr&lt;T,M&gt;&amp;     ub() const { return _ub; }
           const csr&lt;T,M&gt;&amp;     bu() const { return _bu; }
           const csr&lt;T,M&gt;&amp;     bb() const { return _bb; }
                 csr&lt;T,M&gt;&amp; set_uu()       { return _uu; }
                 csr&lt;T,M&gt;&amp; set_ub()       { return _ub; }
                 csr&lt;T,M&gt;&amp; set_bu()       { return _bu; }
                 csr&lt;T,M&gt;&amp; set_bb()       { return _bb; }

       };
       template&lt;class T, class M&gt; form_basic&lt;T,M&gt; trans (const form_basic&lt;T,M&gt;&amp; a);
       template&lt;class T, class M&gt; field_basic&lt;T,M&gt; diag (const form_basic&lt;T,M&gt;&amp; a);
       template&lt;class T, class M&gt; form_basic&lt;T,M&gt;  diag (const field_basic&lt;T,M&gt;&amp; dh);

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                    <u><a href="../man2rheolef/form.2rheolef.html">form</a></u>(2rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>