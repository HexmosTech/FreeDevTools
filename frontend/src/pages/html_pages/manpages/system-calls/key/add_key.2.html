<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>add_key - add a key to the kernel's key management facility</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       add_key - add a key to the kernel's key management facility

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;keyutils.h&gt;</b>

       <b>key_serial_t</b> <b>add_key(const</b> <b>char</b> <b>*</b><u>type</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>description</u><b>,</b>
                            <b>const</b> <b>void</b> <u>payload</u><b>[.</b><u>plen</u><b>],</b> <b>size_t</b> <u>plen</u><b>,</b>
                            <b>key_serial_t</b> <u>keyring</u><b>);</b>

       <u>Note</u>: There is no glibc wrapper for this system call; see NOTES.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>add_key</b>() creates or updates a key of the given <u>type</u> and <u>description</u>, instantiates it with the <u>payload</u> of
       length <u>plen</u>, attaches it to the nominated <u>keyring</u>, and returns the key's serial number.

       The key may be rejected if the provided data is in the wrong format or it is invalid in some other way.

       If  the destination <u>keyring</u> already contains a key that matches the specified <u>type</u> and <u>description</u>, then,
       if the key type supports it, that key will be updated rather than a new key being created; if not, a  new
       key  (with  a  different  ID)  will  be  created and it will displace the link to the extant key from the
       keyring.

       The destination <u>keyring</u> serial number may be that of a valid keyring  for  which  the  caller  has  <u>write</u>
       permission.  Alternatively, it may be one of the following special keyring IDs:

       <b>KEY_SPEC_THREAD_KEYRING</b>
              This specifies the caller's thread-specific keyring (<b><a href="../man7/thread-keyring.7.html">thread-keyring</a></b>(7)).

       <b>KEY_SPEC_PROCESS_KEYRING</b>
              This specifies the caller's process-specific keyring (<b><a href="../man7/process-keyring.7.html">process-keyring</a></b>(7)).

       <b>KEY_SPEC_SESSION_KEYRING</b>
              This specifies the caller's session-specific keyring (<b><a href="../man7/session-keyring.7.html">session-keyring</a></b>(7)).

       <b>KEY_SPEC_USER_KEYRING</b>
              This specifies the caller's UID-specific keyring (<b><a href="../man7/user-keyring.7.html">user-keyring</a></b>(7)).

       <b>KEY_SPEC_USER_SESSION_KEYRING</b>
              This specifies the caller's UID-session keyring (<b><a href="../man7/user-session-keyring.7.html">user-session-keyring</a></b>(7)).

   <b>Key</b> <b>types</b>
       The  key  <u>type</u> is a string that specifies the key's type.  Internally, the kernel defines a number of key
       types that are available in the core key management code.  Among the types that are available  for  user-
       space use and can be specified as the <u>type</u> argument to <b>add_key</b>() are the following:

       <u>"keyring"</u>
              Keyrings  are special key types that may contain links to sequences of other keys of any type.  If
              this interface is used to create a keyring, then <u>payload</u> should be NULL and <u>plen</u> should be zero.

       <u>"user"</u> This is a general  purpose  key  type  whose  payload  may  be  read  and  updated  by  user-space
              applications.   The  key is kept entirely within kernel memory.  The payload for keys of this type
              is a blob of arbitrary data of up to 32,767 bytes.

       <u>"logon"</u> (since Linux 3.3)
              This key type is essentially the same as <u>"user"</u>, but it does not permit the key to read.  This  is
              suitable for storing payloads that you do not want to be readable from user space.

       This  key  type vets the <u>description</u> to ensure that it is qualified by a "service" prefix, by checking to
       ensure that the <u>description</u> contains a ':' that is preceded by other characters.

       <u>"big_key"</u> (since Linux 3.13)
              This key type is similar to <u>"user"</u>, but may hold a payload of up to 1 MiB.  If the key payload  is
              large  enough,  then  it  may  be stored encrypted in tmpfs (which can be swapped out) rather than
              kernel memory.

       For further details on these key types, see <b><a href="../man7/keyrings.7.html">keyrings</a></b>(7).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>add_key</b>() returns the serial number of the key it  created  or  updated.   On  error,  -1  is
       returned and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EACCES</b> The keyring wasn't available for modification by the user.

       <b>EDQUOT</b> The key quota for this user would be exceeded by creating this key or linking it to the keyring.

       <b>EFAULT</b> One or more of <u>type</u>, <u>description</u>, and <u>payload</u> points outside process's accessible address space.

       <b>EINVAL</b> The  size  of  the  string  (including the terminating null byte) specified in <u>type</u> or <u>description</u>
              exceeded the limit (32 bytes and 4096 bytes respectively).

       <b>EINVAL</b> The payload data was invalid.

       <b>EINVAL</b> <u>type</u> was <u>"logon"</u> and the  <u>description</u>  was  not  qualified  with  a  prefix  string  of  the  form
              <u>"service:"</u>.

       <b>EKEYEXPIRED</b>
              The keyring has expired.

       <b>EKEYREVOKED</b>
              The keyring has been revoked.

       <b>ENOKEY</b> The keyring doesn't exist.

       <b>ENOMEM</b> Insufficient memory to create a key.

       <b>EPERM</b>  The  <u>type</u>  started  with  a  period ('.').  Key types that begin with a period are reserved to the
              implementation.

       <b>EPERM</b>  <u>type</u> was <u>"keyring"</u> and the <u>description</u> started with a period ('.').   Keyrings  with  descriptions
              (names) that begin with a period are reserved to the implementation.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.10.

</pre><h4><b>NOTES</b></h4><pre>
       glibc does not provide a wrapper for this system call.  A wrapper is provided in the <u>libkeyutils</u> library.
       (The  accompanying  package  provides  the <u>&lt;keyutils.h&gt;</u> header file.)  When employing the wrapper in that
       library, link with <u>-lkeyutils</u>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below creates a key with the type, description, and payload  specified  in  its  command-line
       arguments, and links that key into the session keyring.  The following shell session demonstrates the use
       of the program:

           $ <b>./a.out</b> <b>user</b> <b>mykey</b> <b>"Some</b> <b>payload"</b>
           Key ID is 64a4dca
           $ <b>grep</b> <b>'64a4dca'</b> <b><a href="file:/proc/keys">/proc/keys</a></b>
           064a4dca I--Q---    1 perm 3f010000  1000  1000 user    mykey: 12

   <b>Program</b> <b>source</b>

       #include &lt;keyutils.h&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           key_serial_t key;

           if (argc != 4) {
               fprintf(stderr, "Usage: %s type description payload\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           key = add_key(argv[1], argv[2], argv[3], strlen(argv[3]),
                         KEY_SPEC_SESSION_KEYRING);
           if (key == -1) {
               perror("add_key");
               exit(EXIT_FAILURE);
           }

           printf("Key ID is %jx\n", (uintmax_t) key);

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/keyctl.1.html">keyctl</a></b>(1), <b><a href="../man2/keyctl.2.html">keyctl</a></b>(2), <b><a href="../man2/request_key.2.html">request_key</a></b>(2), <b><a href="../man3/keyctl.3.html">keyctl</a></b>(3), <b><a href="../man7/keyrings.7.html">keyrings</a></b>(7), <b><a href="../man7/keyutils.7.html">keyutils</a></b>(7), <b><a href="../man7/persistent-keyring.7.html">persistent-keyring</a></b>(7),
       <b><a href="../man7/process-keyring.7.html">process-keyring</a></b>(7), <b><a href="../man7/session-keyring.7.html">session-keyring</a></b>(7), <b><a href="../man7/thread-keyring.7.html">thread-keyring</a></b>(7), <b><a href="../man7/user-keyring.7.html">user-keyring</a></b>(7), <b><a href="../man7/user-session-keyring.7.html">user-session-keyring</a></b>(7)

       The kernel source files <u>Documentation/security/keys/core.rst</u> and <u>Documentation/keys/request-key.rst</u> (or,
       before Linux 4.13, in the files <u>Documentation/security/keys.txt</u> and
       <u>Documentation/security/keys-request-key.txt</u>).

Linux man-pages 6.9.1                              2024-06-15                                         <u><a href="../man2/add_key.2.html">add_key</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>