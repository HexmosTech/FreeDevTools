<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>request_key - request a key from the kernel's key management facility</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       request_key - request a key from the kernel's key management facility

</pre><h4><b>LIBRARY</b></h4><pre>
       Linux Key Management Utilities (<u>libkeyutils</u>, <u>-lkeyutils</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;keyutils.h&gt;</b>

       <b>key_serial_t</b> <b>request_key(const</b> <b>char</b> <b>*</b><u>type</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>description</u><b>,</b>
                                <b>const</b> <b>char</b> <b>*_Nullable</b> <u>callout_info</u><b>,</b>
                                <b>key_serial_t</b> <u>dest_keyring</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>request_key</b>()  attempts  to  find  a  key  of  the  given <u>type</u> with a description (name) that matches the
       specified <u>description</u>.  If such a key could not be found, then the key is optionally created.  If the key
       is found or created, <b>request_key</b>() attaches it to the keyring whose ID is specified in  <u>dest_keyring</u>  and
       returns the key's serial number.

       <b>request_key</b>()  first  recursively  searches  for  a  matching  key in all of the keyrings attached to the
       calling process.  The keyrings are searched  in  the  order:  thread-specific  keyring,  process-specific
       keyring, and then session keyring.

       If  <b>request_key</b>()  is  called  from a program invoked by <b>request_key</b>() on behalf of some other process to
       generate a key, then the keyrings of that other process will be searched next, using that other process's
       user ID, group ID, supplementary group IDs, and security context to determine access.

       The search of the keyring tree is breadth-first: the keys in each keyring  searched  are  checked  for  a
       match  before any child keyrings are recursed into.  Only keys for which the caller has <u>search</u> permission
       be found, and only keyrings for which the caller has <u>search</u> permission may be searched.

       If the key is not found and <u>callout</u> is NULL, then the call fails with the error <b>ENOKEY</b>.

       If the key is not found and <u>callout</u> is not NULL, then the kernel attempts to invoke a user-space  program
       to instantiate the key.  The details are given below.

       The  <u>dest_keyring</u> serial number may be that of a valid keyring for which the caller has <u>write</u> permission,
       or it may be one of the following special keyring IDs:

       <b>KEY_SPEC_THREAD_KEYRING</b>
              This specifies the caller's thread-specific keyring (see <b><a href="../man7/thread-keyring.7.html">thread-keyring</a></b>(7)).

       <b>KEY_SPEC_PROCESS_KEYRING</b>
              This specifies the caller's process-specific keyring (see <b><a href="../man7/process-keyring.7.html">process-keyring</a></b>(7)).

       <b>KEY_SPEC_SESSION_KEYRING</b>
              This specifies the caller's session-specific keyring (see <b><a href="../man7/session-keyring.7.html">session-keyring</a></b>(7)).

       <b>KEY_SPEC_USER_KEYRING</b>
              This specifies the caller's UID-specific keyring (see <b><a href="../man7/user-keyring.7.html">user-keyring</a></b>(7)).

       <b>KEY_SPEC_USER_SESSION_KEYRING</b>
              This specifies the caller's UID-session keyring (see <b><a href="../man7/user-session-keyring.7.html">user-session-keyring</a></b>(7)).

       When the <u>dest_keyring</u> is specified as 0 and no key construction has been performed,  then  no  additional
       linking is done.

       Otherwise, if <u>dest_keyring</u> is 0 and a new key is constructed, the new key will be linked to the "default"
       keyring.   More  precisely, when the kernel tries to determine to which keyring the newly constructed key
       should be linked, it tries the following keyrings, beginning with  the  keyring  set  via  the  <b><a href="../man2/keyctl.2.html">keyctl</a></b>(2)
       <b>KEYCTL_SET_REQKEY_KEYRING</b>  operation  and  continuing  in  the order shown below until it finds the first
       keyring that exists:

       •  The requestor keyring (<b>KEY_REQKEY_DEFL_REQUESTOR_KEYRING</b>, since Linux 2.6.29).

       •  The thread-specific keyring (<b>KEY_REQKEY_DEFL_THREAD_KEYRING</b>; see <b><a href="../man7/thread-keyring.7.html">thread-keyring</a></b>(7)).

       •  The process-specific keyring (<b>KEY_REQKEY_DEFL_PROCESS_KEYRING</b>; see <b><a href="../man7/process-keyring.7.html">process-keyring</a></b>(7)).

       •  The session-specific keyring (<b>KEY_REQKEY_DEFL_SESSION_KEYRING</b>; see <b><a href="../man7/session-keyring.7.html">session-keyring</a></b>(7)).

       •  The  session  keyring  for  the   process's   user   ID   (<b>KEY_REQKEY_DEFL_USER_SESSION_KEYRING</b>;   see
          <b><a href="../man7/user-session-keyring.7.html">user-session-keyring</a></b>(7)).  This keyring is expected to always exist.

       •  The  UID-specific  keyring  (<b>KEY_REQKEY_DEFL_USER_KEYRING</b>; see <b><a href="../man7/user-keyring.7.html">user-keyring</a></b>(7)).  This keyring is also
          expected to always exist.

       If  the  <b><a href="../man2/keyctl.2.html">keyctl</a></b>(2)  <b>KEYCTL_SET_REQKEY_KEYRING</b>  operation   specifies   <b>KEY_REQKEY_DEFL_DEFAULT</b>   (or   no
       <b>KEYCTL_SET_REQKEY_KEYRING</b>  operation is performed), then the kernel looks for a keyring starting from the
       beginning of the list.

   <b>Requesting</b> <b>user-space</b> <b>instantiation</b> <b>of</b> <b>a</b> <b>key</b>
       If the kernel cannot find a key matching <u>type</u> and <u>description</u>, and <u>callout</u> is not NULL, then  the  kernel
       attempts  to  invoke  a  user-space program to instantiate a key with the given <u>type</u> and <u>description</u>.  In
       this case, the following steps are performed:

       (1)  The kernel creates an uninstantiated key, U, with the requested <u>type</u> and <u>description</u>.

       (2)  The kernel creates an authorization key, V, that refers to the key U and records the facts that  the
            caller of <b>request_key</b>() is:

            (2.1)  the context in which the key U should be instantiated and secured, and

            (2.2)  the context from which associated key requests may be satisfied.

            The authorization key is constructed as follows:

            •  The key type is <u>".request_key_auth"</u>.

            •  The key's UID and GID are the same as the corresponding filesystem IDs of the requesting process.

            •  The key grants <u>view</u>, <u>read</u>, and <u>search</u> permissions to the key possessor as well as <u>view</u> permission
               for the key user.

            •  The  description  (name) of the key is the hexadecimal string representing the ID of the key that
               is to be instantiated in the requesting program.

            •  The payload of the key is taken from the data specified in <u>callout_info</u>.

            •  Internally, the kernel also records the PID of the process that called <b>request_key</b>().

       (3)  The kernel creates a process that executes a user-space service such as <b><a href="../man8/request-key.8.html">request-key</a></b>(8)  with  a  new
            session keyring that contains a link to the authorization key, V.

            This program is supplied with the following command-line arguments:

            [0]  The string <u>"/sbin/request-key"</u>.

            [1]  The string <u>"create"</u> (indicating that a key is to be created).

            [2]  The ID of the key that is to be instantiated.

            [3]  The filesystem UID of the caller of <b>request_key</b>().

            [4]  The filesystem GID of the caller of <b>request_key</b>().

            [5]  The  ID of the thread keyring of the caller of <b>request_key</b>().  This may be zero if that keyring
                 hasn't been created.

            [6]  The ID of the process keyring of the caller of <b>request_key</b>().  This may be zero if that keyring
                 hasn't been created.

            [7]  The ID of the session keyring of the caller of <b>request_key</b>().

            <u>Note</u>: each of the command-line arguments that is a key ID is encoded in <u>decimal</u> (unlike the key  IDs
            shown in <u><a href="file:/proc/keys">/proc/keys</a></u>, which are shown as hexadecimal values).

       (4)  The program spawned in the previous step:

            •  Assumes  the  authority  to  instantiate  the  key  U using the <b><a href="../man2/keyctl.2.html">keyctl</a></b>(2) <b>KEYCTL_ASSUME_AUTHORITY</b>
               operation (typically via the <b><a href="../man3/keyctl_assume_authority.3.html">keyctl_assume_authority</a></b>(3) function).

            •  Obtains the callout data from the payload  of  the  authorization  key  V  (using  the  <b><a href="../man2/keyctl.2.html">keyctl</a></b>(2)
               <b>KEYCTL_READ</b>  operation  (or,  more  commonly, the <b><a href="../man3/keyctl_read.3.html">keyctl_read</a></b>(3) function) with a key ID value of
               <b>KEY_SPEC_REQKEY_AUTH_KEY</b>).

            •  Instantiates the key (or execs another program that performs that task), specifying  the  payload
               and  destination  keyring.   (The  destination  keyring that the requestor specified when calling
               <b>request_key</b>()  can  be  accessed  using   the   special   key   ID   <b>KEY_SPEC_REQUESTOR_KEYRING</b>.)
               Instantiation  is  performed using the <b><a href="../man2/keyctl.2.html">keyctl</a></b>(2) <b>KEYCTL_INSTANTIATE</b> operation (or, more commonly,
               the <b><a href="../man3/keyctl_instantiate.3.html">keyctl_instantiate</a></b>(3) function).  At this point, the <b>request_key</b>() call  completes,  and  the
               requesting program can continue execution.

       If these steps are unsuccessful, then an <b>ENOKEY</b> error will be returned to the caller of <b>request_key</b>() and
       a  temporary,  negatively  instantiated  key  will be installed in the keyring specified by <u>dest_keyring</u>.
       This will expire after a few seconds, but will cause subsequent calls to <b>request_key</b>() to fail  until  it
       does.   The  purpose  of  this  negatively  instantiated key is to prevent (possibly different) processes
       making repeated requests (that require expensive <b><a href="../man8/request-key.8.html">request-key</a></b>(8) upcalls) for a key  that  can't  (at  the
       moment) be positively instantiated.

       Once  the key has been instantiated, the authorization key (<b>KEY_SPEC_REQKEY_AUTH_KEY</b>) is revoked, and the
       destination keyring (<b>KEY_SPEC_REQUESTOR_KEYRING</b>) is no longer accessible from the <b><a href="../man8/request-key.8.html">request-key</a></b>(8) program.

       If a key is created, then—regardless of whether it is a valid key or  a  negatively  instantiated  key—it
       will  displace  any  other  key  with  the  same  type  and  description  from  the  keyring specified in
       <u>dest_keyring</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>request_key</b>() returns the serial number of the key it found or  caused  to  be  created.   On
       error, -1 is returned and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EACCES</b> The keyring wasn't available for modification by the user.

       <b>EDQUOT</b> The key quota for this user would be exceeded by creating this key or linking it to the keyring.

       <b>EFAULT</b> One of <u>type</u>, <u>description</u>, or <u>callout_info</u> points outside the process's accessible address space.

       <b>EINTR</b>  The request was interrupted by a signal; see <b><a href="../man7/signal.7.html">signal</a></b>(7).

       <b>EINVAL</b> The  size  of  the  string  (including the terminating null byte) specified in <u>type</u> or <u>description</u>
              exceeded the limit (32 bytes and 4096 bytes respectively).

       <b>EINVAL</b> The size of the string (including the terminating null byte) specified  in  <u>callout_info</u>  exceeded
              the system page size.

       <b>EKEYEXPIRED</b>
              An expired key was found, but no replacement could be obtained.

       <b>EKEYREJECTED</b>
              The attempt to generate a new key was rejected.

       <b>EKEYREVOKED</b>
              A revoked key was found, but no replacement could be obtained.

       <b>ENOKEY</b> No matching key was found.

       <b>ENOMEM</b> Insufficient memory to create a key.

       <b>EPERM</b>  The <u>type</u> argument started with a period ('.').

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.10.

       The ability to instantiate keys upon request was added in Linux 2.6.13.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program  below  demonstrates  the  use  of  <b>request_key</b>().   The <u>type</u>, <u>description</u>, and <u>callout_info</u>
       arguments for the system call are taken from the values supplied in the command-line arguments.  The call
       specifies the session keyring as the target keyring.

       In order to demonstrate this program, we first create a suitable entry in the file <u>/etc/request-key.conf</u>.

           $ sudo sh
           # <b>echo</b> <b>'create</b> <b>user</b> <b>mtk:*</b> <b>*</b>   <b>/bin/keyctl</b> <b>instantiate</b> <b>%k</b> <b>%c</b> <b>%S'</b> <b>\</b>
                     <b>&gt;</b> <b>/etc/request-key.conf</b>
           # <b>exit</b>

       This entry specifies that when a new "user" key with the prefix "mtk:" must be  instantiated,  that  task
       should  be  performed  via  the <b><a href="../man1/keyctl.1.html">keyctl</a></b>(1) command's <b>instantiate</b> operation.  The arguments supplied to the
       <b>instantiate</b> operation are: the ID of the uninstantiated key  (<u>%k</u>);  the  callout  data  supplied  to  the
       <b>request_key</b>()  call  (<u>%c</u>);  and  the  session  keyring  (<u>%S</u>)  of  the  requestor  (i.e.,  the  caller  of
       <b>request_key</b>()).  See <b><a href="../man5/request-key.conf.5.html">request-key.conf</a></b>(5) for details of these <u>%</u> specifiers.

       Then we run the program and check the contents of <u><a href="file:/proc/keys">/proc/keys</a></u> to verify that the requested  key  has  been
       instantiated:

           $ <b>./t_request_key</b> <b>user</b> <b>mtk:key1</b> <b>"Payload</b> <b>data"</b>
           $ <b>grep</b> <b>'2dddaf50'</b> <b><a href="file:/proc/keys">/proc/keys</a></b>
           2dddaf50 I--Q---  1 perm 3f010000  1000  1000 user  mtk:key1: 12

       For another example of the use of this program, see <b><a href="../man2/keyctl.2.html">keyctl</a></b>(2).

   <b>Program</b> <b>source</b>

       /* t_request_key.c */

       #include &lt;keyutils.h&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           key_serial_t key;

           if (argc != 4) {
               fprintf(stderr, "Usage: %s type description callout-data\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           key = request_key(argv[1], argv[2], argv[3],
                             KEY_SPEC_SESSION_KEYRING);
           if (key == -1) {
               perror("request_key");
               exit(EXIT_FAILURE);
           }

           printf("Key ID is %jx\n", (uintmax_t) key);

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/keyctl.1.html">keyctl</a></b>(1), <b><a href="../man2/add_key.2.html">add_key</a></b>(2), <b><a href="../man2/keyctl.2.html">keyctl</a></b>(2), <b><a href="../man3/keyctl.3.html">keyctl</a></b>(3), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/keyrings.7.html">keyrings</a></b>(7), <b><a href="../man7/keyutils.7.html">keyutils</a></b>(7),
       <b><a href="../man7/persistent-keyring.7.html">persistent-keyring</a></b>(7), <b><a href="../man7/process-keyring.7.html">process-keyring</a></b>(7), <b><a href="../man7/session-keyring.7.html">session-keyring</a></b>(7), <b><a href="../man7/thread-keyring.7.html">thread-keyring</a></b>(7), <b><a href="../man7/user-keyring.7.html">user-keyring</a></b>(7),
       <b><a href="../man7/user-session-keyring.7.html">user-session-keyring</a></b>(7), <b><a href="../man8/request-key.8.html">request-key</a></b>(8)

       The kernel source files <u>Documentation/security/keys/core.rst</u> and <u>Documentation/keys/request-key.rst</u> (or,
       before Linux 4.13, in the files <u>Documentation/security/keys.txt</u> and
       <u>Documentation/security/keys-request-key.txt</u>).

Linux man-pages 6.9.1                              2024-06-15                                     <u><a href="../man2/request_key.2.html">request_key</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>