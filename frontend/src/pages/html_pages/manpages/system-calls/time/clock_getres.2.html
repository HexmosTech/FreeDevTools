<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>clock_getres, clock_gettime, clock_settime - clock and time functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       clock_getres, clock_gettime, clock_settime - clock and time functions

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>), since glibc 2.17

       Before glibc 2.17, Real-time library (<u>librt</u>, <u>-lrt</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/time.h">time.h</a>&gt;</b>

       <b>int</b> <b>clock_getres(clockid_t</b> <u>clockid</u><b>,</b> <b>struct</b> <b>timespec</b> <b>*_Nullable</b> <u>res</u><b>);</b>

       <b>int</b> <b>clock_gettime(clockid_t</b> <u>clockid</u><b>,</b> <b>struct</b> <b>timespec</b> <b>*</b><u>tp</u><b>);</b>
       <b>int</b> <b>clock_settime(clockid_t</b> <u>clockid</u><b>,</b> <b>const</b> <b>struct</b> <b>timespec</b> <b>*</b><u>tp</u><b>);</b>

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>clock_getres</b>(), <b>clock_gettime</b>(), <b>clock_settime</b>():
           _POSIX_C_SOURCE &gt;= 199309L

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  function <b>clock_getres</b>() finds the resolution (precision) of the specified clock <u>clockid</u>, and, if <u>res</u>
       is non-NULL, stores it in the <u>struct</u> <u>timespec</u> pointed to by <u>res</u>.  The resolution of clocks depends on the
       implementation and cannot be configured by a particular process.  If the time value  pointed  to  by  the
       argument <u>tp</u> of <b>clock_settime</b>() is not a multiple of <u>res</u>, then it is truncated to a multiple of <u>res</u>.

       The  functions  <b>clock_gettime</b>()  and  <b>clock_settime</b>()  retrieve  and  set the time of the specified clock
       <u>clockid</u>.

       The <u>res</u> and <u>tp</u> arguments are <b><a href="../man3/timespec.3.html">timespec</a></b>(3) structures.

       The <u>clockid</u> argument is the identifier of the particular clock on which to act.  A clock may  be  system-
       wide  and  hence  visible  for  all  processes,  or  per-process if it measures time only within a single
       process.

       All implementations support the system-wide real-time clock, which is identified by <b>CLOCK_REALTIME</b>.   Its
       time represents seconds and nanoseconds since the Epoch.  When its time is changed, timers for a relative
       interval are unaffected, but timers for an absolute point in time are affected.

       More  clocks  may  be implemented.  The interpretation of the corresponding time values and the effect on
       timers is unspecified.

       Sufficiently recent versions of glibc and the Linux kernel support the following clocks:

       <b>CLOCK_REALTIME</b>
              A settable system-wide clock that measures real  (i.e.,  wall-clock)  time.   Setting  this  clock
              requires appropriate privileges.  This clock is affected by discontinuous jumps in the system time
              (e.g.,  if  the  system  administrator  manually  changes the clock), and by frequency adjustments
              performed by NTP and similar  applications  via  <b><a href="../man3/adjtime.3.html">adjtime</a></b>(3),  <b><a href="../man2/adjtimex.2.html">adjtimex</a></b>(2),  <b><a href="../man2/clock_adjtime.2.html">clock_adjtime</a></b>(2),  and
              <b><a href="../man3/ntp_adjtime.3.html">ntp_adjtime</a></b>(3).   This  clock  normally  counts  the  number  of seconds since 1970-01-01 00:00:00
              Coordinated Universal Time (UTC) except that it ignores leap seconds; near a  leap  second  it  is
              typically adjusted by NTP to stay roughly in sync with UTC.

       <b>CLOCK_REALTIME_ALARM</b> (since Linux 3.0; Linux-specific)
              Like <b>CLOCK_REALTIME</b>, but not settable.  See <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2) for further details.

       <b>CLOCK_REALTIME_COARSE</b> (since Linux 2.6.32; Linux-specific)
              A  faster  but  less precise version of <b>CLOCK_REALTIME</b>.  This clock is not settable.  Use when you
              need very fast, but not fine-grained timestamps.  Requires per-architecture support, and  probably
              also architecture support for this flag in the <b><a href="../man7/vdso.7.html">vdso</a></b>(7).

       <b>CLOCK_TAI</b> (since Linux 3.10; Linux-specific)
              A  nonsettable  system-wide  clock  derived  from wall-clock time but counting leap seconds.  This
              clock does not experience discontinuities  or  frequency  adjustments  caused  by  inserting  leap
              seconds as <b>CLOCK_REALTIME</b> does.

              The acronym TAI refers to International Atomic Time.

       <b>CLOCK_MONOTONIC</b>
              A  nonsettable  system-wide clock that represents monotonic time since—as described by POSIX—"some
              unspecified point in the past".  On Linux, that point corresponds to the number  of  seconds  that
              the system has been running since it was booted.

              The  <b>CLOCK_MONOTONIC</b> clock is not affected by discontinuous jumps in the system time (e.g., if the
              system administrator manually changes the clock), but is affected by frequency adjustments.   This
              clock  does  not  count time that the system is suspended.  All <b>CLOCK_MONOTONIC</b> variants guarantee
              that the time returned by consecutive calls will not  go  backwards,  but  successive  calls  may—
              depending on the architecture—return identical (not-increased) time values.

       <b>CLOCK_MONOTONIC_COARSE</b> (since Linux 2.6.32; Linux-specific)
              A  faster but less precise version of <b>CLOCK_MONOTONIC</b>.  Use when you need very fast, but not fine-
              grained timestamps.  Requires per-architecture support, and probably also architecture support for
              this flag in the <b><a href="../man7/vdso.7.html">vdso</a></b>(7).

       <b>CLOCK_MONOTONIC_RAW</b> (since Linux 2.6.28; Linux-specific)
              Similar to <b>CLOCK_MONOTONIC</b>, but provides access to a raw hardware-based time that is  not  subject
              to frequency adjustments.  This clock does not count time that the system is suspended.

       <b>CLOCK_BOOTTIME</b> (since Linux 2.6.39; Linux-specific)
              A nonsettable system-wide clock that is identical to <b>CLOCK_MONOTONIC</b>, except that it also includes
              any  time that the system is suspended.  This allows applications to get a suspend-aware monotonic
              clock  without  having  to  deal  with  the  complications  of  <b>CLOCK_REALTIME</b>,  which  may   have
              discontinuities if the time is changed using <b><a href="../man2/settimeofday.2.html">settimeofday</a></b>(2) or similar.

       <b>CLOCK_BOOTTIME_ALARM</b> (since Linux 3.0; Linux-specific)
              Like <b>CLOCK_BOOTTIME</b>.  See <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2) for further details.

       <b>CLOCK_PROCESS_CPUTIME_ID</b> (since Linux 2.6.12)
              This  is  a  clock that measures CPU time consumed by this process (i.e., CPU time consumed by all
              threads in the process).  On Linux, this clock is not settable.

       <b>CLOCK_THREAD_CPUTIME_ID</b> (since Linux 2.6.12)
              This is a clock that measures CPU time consumed by this thread.   On  Linux,  this  clock  is  not
              settable.

       Linux also implements dynamic clock instances as described below.

   <b>Dynamic</b> <b>clocks</b>
       In  addition  to the hard-coded System-V style clock IDs described above, Linux also supports POSIX clock
       operations on certain character devices.  Such devices are called "dynamic"  clocks,  and  are  supported
       since Linux 2.6.39.

       Using  the  appropriate  macros,  open  file  descriptors  may  be converted into clock IDs and passed to
       <b>clock_gettime</b>(), <b>clock_settime</b>(), and <b><a href="../man2/clock_adjtime.2.html">clock_adjtime</a></b>(2).  The following example shows  how  to  convert  a
       file descriptor into a dynamic clock ID.

           #define CLOCKFD 3
           #define FD_TO_CLOCKID(fd)   ((~(clockid_t) (fd) &lt;&lt; 3) | CLOCKFD)
           #define CLOCKID_TO_FD(clk)  ((unsigned int) ~((clk) &gt;&gt; 3))

           struct timespec ts;
           clockid_t clkid;
           int fd;

           fd = open("/dev/ptp0", O_RDWR);
           clkid = FD_TO_CLOCKID(fd);
           clock_gettime(clkid, &amp;ts);

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>clock_gettime</b>(),  <b>clock_settime</b>(), and <b>clock_getres</b>() return 0 for success.  On error, -1 is returned and
       <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EACCES</b> <b>clock_settime</b>() does not have write permission for the dynamic POSIX clock device indicated.

       <b>EFAULT</b> <u>tp</u> points outside the accessible address space.

       <b>EINVAL</b> The <u>clockid</u> specified is invalid for one of two reasons.  Either the  System-V  style  hard  coded
              positive  value  is  out of range, or the dynamic clock ID does not refer to a valid instance of a
              clock object.

       <b>EINVAL</b> (<b>clock_settime</b>()): <u>tp.tv_sec</u> is negative or <u>tp.tv_nsec</u> is outside the range [0, 999,999,999].

       <b>EINVAL</b> The <u>clockid</u> specified in a call to <b>clock_settime</b>() is not a settable clock.

       <b>EINVAL</b> (since Linux 4.3)
              A call to <b>clock_settime</b>() with a <u>clockid</u> of <b>CLOCK_REALTIME</b> attempted to set the time  to  a  value
              less than the current value of the <b>CLOCK_MONOTONIC</b> clock.

       <b>ENODEV</b> The  hot-pluggable  device  (like USB for example) represented by a dynamic <u>clk_id</u> has disappeared
              after its character device was opened.

       <b>ENOTSUP</b>
              The operation is not supported by the dynamic POSIX clock device specified.

       <b>EOVERFLOW</b>
              The timestamp would not fit in <u>time_t</u> range.  This can happen if an executable with 32-bit  <u>time_t</u>
              is  run  on  a 64-bit kernel when the time is 2038-01-19 03:14:08 UTC or later.  However, when the
              system time is out of <u>time_t</u> range in other situations, the behavior is undefined.

       <b>EPERM</b>  <b>clock_settime</b>() does not have permission to set the clock indicated.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>                                                                   │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │ <b>clock_getres</b>(), <b>clock_gettime</b>(), <b>clock_settime</b>()                            │ Thread safety │ MT-Safe │
       └─────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

</pre><h4><b>VERSIONS</b></h4><pre>
       POSIX.1 specifies the following:

              Setting the value of the <b>CLOCK_REALTIME</b> clock via <b>clock_settime</b>() shall have no effect on  threads
              that  are  blocked  waiting  for  a  relative  time  service  based upon this clock, including the
              <b>nanosleep</b>()  function;  nor  on  the  expiration  of  relative  timers  based  upon  this   clock.
              Consequently,  these  time  services  shall  expire  when the requested relative interval elapses,
              independently of the new or old value of the clock.

       According to POSIX.1-2001, a process with "appropriate privileges" may set  the  <b>CLOCK_PROCESS_CPUTIME_ID</b>
       and <b>CLOCK_THREAD_CPUTIME_ID</b> clocks using <b>clock_settime</b>().  On Linux, these clocks are not settable (i.e.,
       no process has "appropriate privileges").

   <b>C</b> <b>library/kernel</b> <b>differences</b>
       On some architectures, an implementation of <b>clock_gettime</b>() is provided in the <b><a href="../man7/vdso.7.html">vdso</a></b>(7).

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001, SUSv2.  Linux 2.6.

       On  POSIX  systems  on  which  these  functions  are  available,  the  symbol <b>_POSIX_TIMERS</b> is defined in
       <u>&lt;unistd.h&gt;</u> to a value greater than 0.  POSIX.1-2008 makes these functions mandatory.

       The symbols <b>_POSIX_MONOTONIC_CLOCK</b>, <b>_POSIX_CPUTIME</b>, <b>_POSIX_THREAD_CPUTIME</b> indicate that  <b>CLOCK_MONOTONIC</b>,
       <b>CLOCK_PROCESS_CPUTIME_ID</b>, <b>CLOCK_THREAD_CPUTIME_ID</b> are available.  (See also <b><a href="../man3/sysconf.3.html">sysconf</a></b>(3).)

   <b>Historical</b> <b>note</b> <b>for</b> <b>SMP</b> <b>systems</b>
       Before  Linux  added  kernel  support  for  <b>CLOCK_PROCESS_CPUTIME_ID</b>  and  <b>CLOCK_THREAD_CPUTIME_ID</b>, glibc
       implemented these clocks on many platforms using timer registers from the CPUs (TSC on  i386,  AR.ITC  on
       Itanium).   These  registers  may  differ between CPUs and as a consequence these clocks may return <b>bogus</b>
       <b>results</b> if a process is migrated to another CPU.

       If the CPUs in an SMP system have different clock sources, then there is no way to maintain a correlation
       between the timer registers since each CPU will run at a slightly different frequency.  If  that  is  the
       case, then <u><a href="../man0/clock_getcpuclockid.0.html">clock_getcpuclockid</a>(0)</u> will return <b>ENOENT</b> to signify this condition.  The two clocks will then
       be useful only if it can be ensured that a process stays on a certain CPU.

       The  processors  in  an  SMP  system  do  not  start all at exactly the same time and therefore the timer
       registers are typically running at an offset.  Some architectures include code  that  attempts  to  limit
       these  offsets  on  bootup.   However,  the  code cannot guarantee to accurately tune the offsets.  glibc
       contains no provisions to deal with these offsets (unlike the Linux Kernel).  Typically these offsets are
       small and therefore the effects may be negligible in most cases.

       Since glibc 2.4,  the  wrapper  functions  for  the  system  calls  described  in  this  page  avoid  the
       abovementioned   problems   by  employing  the  kernel  implementation  of  <b>CLOCK_PROCESS_CPUTIME_ID</b>  and
       <b>CLOCK_THREAD_CPUTIME_ID</b>, on systems that provide such an implementation (i.e., Linux 2.6.12 and later).

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below demonstrates the use of <b>clock_gettime</b>() and <b>clock_getres</b>() with various  clocks.   This
       is an example of what we might see when running the program:

           $ <b>./clock_times</b> <b>x</b>
           CLOCK_REALTIME : 1585985459.446 (18356 days +  7h 30m 59s)
                resolution:          0.000000001
           CLOCK_TAI      : 1585985496.447 (18356 days +  7h 31m 36s)
                resolution:          0.000000001
           CLOCK_MONOTONIC:      52395.722 (14h 33m 15s)
                resolution:          0.000000001
           CLOCK_BOOTTIME :      72691.019 (20h 11m 31s)
                resolution:          0.000000001

   <b>Program</b> <b>source</b>

       /* clock_times.c

          Licensed under GNU General Public License v2 or later.
       */
       #define _XOPEN_SOURCE 600
       #include &lt;stdbool.h&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;

       #define SECS_IN_DAY (24 * 60 * 60)

       static void
       displayClock(clockid_t clock, const char *name, bool showRes)
       {
           long             days;
           struct timespec  ts;

           if (clock_gettime(clock, &amp;ts) == -1) {
               perror("clock_gettime");
               exit(EXIT_FAILURE);
           }

           printf("%-15s: %10jd.%03ld (", name,
                  (intmax_t) ts.tv_sec, ts.tv_nsec / 1000000);

           days = ts.tv_sec / SECS_IN_DAY;
           if (days &gt; 0)
               printf("%ld days + ", days);

           printf("%2dh %2dm %2ds",
                  (int) (ts.tv_sec % SECS_IN_DAY) / 3600,
                  (int) (ts.tv_sec % 3600) / 60,
                  (int) ts.tv_sec % 60);
           printf(")\n");

           if (clock_getres(clock, &amp;ts) == -1) {
               perror("clock_getres");
               exit(EXIT_FAILURE);
           }

           if (showRes)
               printf("     resolution: %10jd.%09ld\n",
                      (intmax_t) ts.tv_sec, ts.tv_nsec);
       }

       int
       main(int argc, char *argv[])
       {
           bool showRes = argc &gt; 1;

           displayClock(CLOCK_REALTIME, "CLOCK_REALTIME", showRes);
       #ifdef CLOCK_TAI
           displayClock(CLOCK_TAI, "CLOCK_TAI", showRes);
       #endif
           displayClock(CLOCK_MONOTONIC, "CLOCK_MONOTONIC", showRes);
       #ifdef CLOCK_BOOTTIME
           displayClock(CLOCK_BOOTTIME, "CLOCK_BOOTTIME", showRes);
       #endif
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/date.1.html">date</a></b>(1),   <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2),   <b><a href="../man2/settimeofday.2.html">settimeofday</a></b>(2),  <b><a href="../man2/time.2.html">time</a></b>(2),  <b><a href="../man3/adjtime.3.html">adjtime</a></b>(3),  <b><a href="../man3/clock_getcpuclockid.3.html">clock_getcpuclockid</a></b>(3),  <b><a href="../man3/ctime.3.html">ctime</a></b>(3),
       <b><a href="../man3/ftime.3.html">ftime</a></b>(3),  <b><a href="../man3/pthread_getcpuclockid.3.html">pthread_getcpuclockid</a></b>(3),  <b><a href="../man3/sysconf.3.html">sysconf</a></b>(3),  <b><a href="../man3/timespec.3.html">timespec</a></b>(3),  <b><a href="../man7/time.7.html">time</a></b>(7),  <b><a href="../man7/time_namespaces.7.html">time_namespaces</a></b>(7),   <b><a href="../man7/vdso.7.html">vdso</a></b>(7),
       <b><a href="../man8/hwclock.8.html">hwclock</a></b>(8)

Linux man-pages 6.9.1                              2024-06-15                                    <u><a href="../man2/clock_getres.2.html">clock_getres</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>