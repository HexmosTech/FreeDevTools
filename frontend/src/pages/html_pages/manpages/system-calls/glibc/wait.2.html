<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wait, waitpid, waitid - wait for process to change state</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wait, waitpid, waitid - wait for process to change state

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/wait.h&gt;</b>

       <b>pid_t</b> <b>wait(int</b> <b>*_Nullable</b> <u>wstatus</u><b>);</b>
       <b>pid_t</b> <b>waitpid(pid_t</b> <u>pid</u><b>,</b> <b>int</b> <b>*_Nullable</b> <u>wstatus</u><b>,</b> <b>int</b> <u>options</u><b>);</b>

       <b>int</b> <b>waitid(idtype_t</b> <u>idtype</u><b>,</b> <b>id_t</b> <u>id</u><b>,</b> <b>siginfo_t</b> <b>*</b><u>infop</u><b>,</b> <b>int</b> <u>options</u><b>);</b>
                       /* This is the glibc and POSIX interface; see
                          NOTES for information on the raw system call. */

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>waitid</b>():
           Since glibc 2.26:
               _XOPEN_SOURCE &gt;= 500 || _POSIX_C_SOURCE &gt;= 200809L
           glibc 2.25 and earlier:
               _XOPEN_SOURCE
                   || /* Since glibc 2.12: */ _POSIX_C_SOURCE &gt;= 200809L
                   || /* glibc &lt;= 2.19: */ _BSD_SOURCE

</pre><h4><b>DESCRIPTION</b></h4><pre>
       All  of  these  system  calls  are  used to wait for state changes in a child of the calling process, and
       obtain information about the child whose state has changed.  A state change  is  considered  to  be:  the
       child  terminated;  the child was stopped by a signal; or the child was resumed by a signal.  In the case
       of a terminated child, performing a wait allows the system to release the resources associated  with  the
       child;  if  a  wait  is  not  performed, then the terminated child remains in a "zombie" state (see NOTES
       below).

       If a child has already changed state, then these calls return immediately.  Otherwise, they  block  until
       either  a child changes state or a signal handler interrupts the call (assuming that system calls are not
       automatically restarted using the <b>SA_RESTART</b> flag of <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2)).  In the remainder  of  this  page,  a
       child  whose  state  has  changed  and which has not yet been waited upon by one of these system calls is
       termed <u>waitable</u>.

   <b>wait()</b> <b>and</b> <b>waitpid()</b>
       The <b>wait</b>() system call suspends execution of the calling thread until one  of  its  children  terminates.
       The call <u>wait(&amp;wstatus)</u> is equivalent to:

           waitpid(-1, &amp;wstatus, 0);

       The  <b>waitpid</b>()  system  call  suspends  execution  of  the  calling thread until a child specified by <u>pid</u>
       argument has changed state.  By default, <b>waitpid</b>() waits only for terminated children, but this  behavior
       is modifiable via the <u>options</u> argument, as described below.

       The value of <u>pid</u> can be:

       &lt; <b>-1</b>   meaning wait for any child process whose process group ID is equal to the absolute value of <u>pid</u>.

       <b>-1</b>     meaning wait for any child process.

       <b>0</b>      meaning  wait for any child process whose process group ID is equal to that of the calling process
              at the time of the call to <b>waitpid</b>().

       &gt; <b>0</b>    meaning wait for the child whose process ID is equal to the value of <u>pid</u>.

       The value of <u>options</u> is an OR of zero or more of the following constants:

       <b>WNOHANG</b>
              return immediately if no child has exited.

       <b>WUNTRACED</b>
              also return if a child has stopped (but not traced via <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2)).   Status  for  <u>traced</u>  children
              which have stopped is provided even if this option is not specified.

       <b>WCONTINUED</b> (since Linux 2.6.10)
              also return if a stopped child has been resumed by delivery of <b>SIGCONT</b>.

       (For Linux-only options, see below.)

       If  <u>wstatus</u>  is  not  NULL,  <b>wait</b>() and <b>waitpid</b>() store status information in the <u>int</u> to which it points.
       This integer can be inspected with the following macros (which take the integer itself  as  an  argument,
       not a pointer to it, as is done in <b>wait</b>() and <b>waitpid</b>()!):

       <b>WIFEXITED(</b><u>wstatus</u><b>)</b>
              returns  true  if  the  child  terminated normally, that is, by calling <b><a href="../man3/exit.3.html">exit</a></b>(3) or <b><a href="../man2/_exit.2.html">_exit</a></b>(2), or by
              returning from main().

       <b>WEXITSTATUS(</b><u>wstatus</u><b>)</b>
              returns the exit status of the child.  This consists of the least significant 8 bits of the <u>status</u>
              argument that the child specified in a call to <b><a href="../man3/exit.3.html">exit</a></b>(3) or <b><a href="../man2/_exit.2.html">_exit</a></b>(2) or as the argument for a return
              statement in main().  This macro should be employed only if <b>WIFEXITED</b> returned true.

       <b>WIFSIGNALED(</b><u>wstatus</u><b>)</b>
              returns true if the child process was terminated by a signal.

       <b>WTERMSIG(</b><u>wstatus</u><b>)</b>
              returns the number of the signal that caused the child process to terminate.  This macro should be
              employed only if <b>WIFSIGNALED</b> returned true.

       <b>WCOREDUMP(</b><u>wstatus</u><b>)</b>
              returns true if the child produced a core dump (see <b><a href="../man5/core.5.html">core</a></b>(5)).  This macro should be employed  only
              if <b>WIFSIGNALED</b> returned true.

              This  macro  is  not  specified  in POSIX.1-2001 and is not available on some UNIX implementations
              (e.g., AIX, SunOS).  Therefore, enclose its use inside <u>#ifdef</u> <u>WCOREDUMP</u> <u>...</u> <u>#endif</u>.

       <b>WIFSTOPPED(</b><u>wstatus</u><b>)</b>
              returns true if the child process was stopped by delivery of a signal; this is  possible  only  if
              the call was done using <b>WUNTRACED</b> or when the child is being traced (see <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2)).

       <b>WSTOPSIG(</b><u>wstatus</u><b>)</b>
              returns  the  number  of the signal which caused the child to stop.  This macro should be employed
              only if <b>WIFSTOPPED</b> returned true.

       <b>WIFCONTINUED(</b><u>wstatus</u><b>)</b>
              (since Linux 2.6.10) returns true if the child process was resumed by delivery of <b>SIGCONT</b>.

   <b>waitid()</b>
       The <b>waitid</b>() system call (available since Linux 2.6.9) provides more precise  control  over  which  child
       state changes to wait for.

       The <u>idtype</u> and <u>id</u> arguments select the child(ren) to wait for, as follows:

       <u>idtype</u> == <b>P_PID</b>
              Wait for the child whose process ID matches <u>id</u>.

       <u>idtype</u> == <b>P_PIDFD</b> (since Linux 5.4)
              Wait for the child referred to by the PID file descriptor specified in <u>id</u>.  (See <b><a href="../man2/pidfd_open.2.html">pidfd_open</a></b>(2) for
              further information on PID file descriptors.)

       <u>idtype</u> == <b>P_PGID</b>
              Wait  for  any child whose process group ID matches <u>id</u>.  Since Linux 5.4, if <u>id</u> is zero, then wait
              for any child that is in the same process group as the caller's process group at the time  of  the
              call.

       <u>idtype</u> == <b>P_ALL</b>
              Wait for any child; <u>id</u> is ignored.

       The child state changes to wait for are specified by ORing one or more of the following flags in <u>options</u>:

       <b>WEXITED</b>
              Wait for children that have terminated.

       <b>WSTOPPED</b>
              Wait for children that have been stopped by delivery of a signal.

       <b>WCONTINUED</b>
              Wait for (previously stopped) children that have been resumed by delivery of <b>SIGCONT</b>.

       The following flags may additionally be ORed in <u>options</u>:

       <b>WNOHANG</b>
              As for <b>waitpid</b>().

       <b>WNOWAIT</b>
              Leave  the  child  in  a waitable state; a later wait call can be used to again retrieve the child
              status information.

       Upon successful return, <b>waitid</b>() fills in the following fields of the <u>siginfo_t</u> structure pointed  to  by
       <u>infop</u>:

       <u>si_pid</u> The process ID of the child.

       <u>si_uid</u> The real user ID of the child.  (This field is not set on most other implementations.)

       <u>si_signo</u>
              Always set to <b>SIGCHLD</b>.

       <u>si_status</u>
              Either  the exit status of the child, as given to <b><a href="../man2/_exit.2.html">_exit</a></b>(2) (or <b><a href="../man3/exit.3.html">exit</a></b>(3)), or the signal that caused
              the child to terminate, stop, or continue.  The <u>si_code</u> field can be  used  to  determine  how  to
              interpret this field.

       <u>si_code</u>
              Set to one of: <b>CLD_EXITED</b> (child called <b><a href="../man2/_exit.2.html">_exit</a></b>(2)); <b>CLD_KILLED</b> (child killed by signal); <b>CLD_DUMPED</b>
              (child  killed  by  signal,  and  dumped core); <b>CLD_STOPPED</b> (child stopped by signal); <b>CLD_TRAPPED</b>
              (traced child has trapped); or <b>CLD_CONTINUED</b> (child continued by <b>SIGCONT</b>).

       If <b>WNOHANG</b> was specified in <u>options</u> and there were no children in a waitable state, then <b>waitid</b>() returns
       0 immediately and the state of the <u>siginfo_t</u> structure pointed to by <u>infop</u> depends on the implementation.
       To (portably) distinguish this case from that where a child was in a waitable state, zero out the  <u>si_pid</u>
       field before the call and check for a nonzero value in this field after the call returns.

       POSIX.1-2008  Technical  Corrigendum  1  (2013)  adds  the  requirement that when <b>WNOHANG</b> is specified in
       <u>options</u> and there were no children in a waitable state, then <b>waitid</b>() should  zero  out  the  <u>si_pid</u>  and
       <u>si_signo</u> fields of the structure.  On Linux and other implementations that adhere to this requirement, it
       is  not necessary to zero out the <u>si_pid</u> field before calling <b>waitid</b>().  However, not all implementations
       follow the POSIX.1 specification on this point.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>wait</b>(): on success, returns the process ID of the terminated child; on failure, -1 is returned.

       <b>waitpid</b>(): on success, returns the process ID of the child  whose  state  has  changed;  if  <b>WNOHANG</b>  was
       specified  and  one  or more child(ren) specified by <u>pid</u> exist, but have not yet changed state, then 0 is
       returned.  On failure, -1 is returned.

       <b>waitid</b>(): returns 0 on success or if <b>WNOHANG</b> was specified and no child(ren)  specified  by  <u>id</u>  has  yet
       changed state; on failure, -1 is returned.

       On failure, each of these calls sets <u>errno</u> to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EAGAIN</b> The  PID  file descriptor specified in <u>id</u> is nonblocking and the process that it refers to has not
              terminated.

       <b>ECHILD</b> (for <b>wait</b>()) The calling process does not have any unwaited-for children.

       <b>ECHILD</b> (for <b>waitpid</b>() or <b>waitid</b>()) The process specified by <u>pid</u> (<b>waitpid</b>()) or <u>idtype</u> and  <u>id</u>  (<b>waitid</b>())
              does  not exist or is not a child of the calling process.  (This can happen for one's own child if
              the action for <b>SIGCHLD</b> is set to <b>SIG_IGN</b>.  See also the <u>Linux</u> <u>Notes</u> section about threads.)

       <b>EINTR</b>  <b>WNOHANG</b> was not set and an unblocked signal or a <b>SIGCHLD</b> was caught; see <b><a href="../man7/signal.7.html">signal</a></b>(7).

       <b>EINVAL</b> The <u>options</u> argument was invalid.

       <b>ESRCH</b>  (for <b>wait</b>() or <b>waitpid</b>()) <u>pid</u> is equal to <b>INT_MIN</b>.

</pre><h4><b>VERSIONS</b></h4><pre>
   <b>C</b> <b>library/kernel</b> <b>differences</b>
       <b>wait</b>() is actually a library function that (in glibc) is implemented as a call to <b><a href="../man2/wait4.2.html">wait4</a></b>(2).

       On some architectures, there is no <b>waitpid</b>() system call; instead, this interface is implemented via a  C
       library wrapper function that calls <b><a href="../man2/wait4.2.html">wait4</a></b>(2).

       The  raw  <b>waitid</b>() system call takes a fifth argument, of type <u>struct</u> <u>rusage</u> <u>*</u>.  If this argument is non-
       NULL, then it is used to return resource usage information  about  the  child,  in  the  same  manner  as
       <b><a href="../man2/wait4.2.html">wait4</a></b>(2).  See <b><a href="../man2/getrusage.2.html">getrusage</a></b>(2) for details.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       SVr4, 4.3BSD, POSIX.1-2001.

</pre><h4><b>NOTES</b></h4><pre>
       A  child that terminates, but has not been waited for becomes a "zombie".  The kernel maintains a minimal
       set of information about the zombie process (PID, termination  status,  resource  usage  information)  in
       order  to  allow  the parent to later perform a wait to obtain information about the child.  As long as a
       zombie is not removed from the system via a wait, it will consume a slot in the kernel process table, and
       if this table fills, it will  not  be  possible  to  create  further  processes.   If  a  parent  process
       terminates,  then  its  "zombie" children (if any) are adopted by <b><a href="../man1/init.1.html">init</a></b>(1), (or by the nearest "subreaper"
       process  as  defined  through  the  use  of  the  <b><a href="../man2/prctl.2.html">prctl</a></b>(2)  <b>PR_SET_CHILD_SUBREAPER</b>  operation);   <b><a href="../man1/init.1.html">init</a></b>(1)
       automatically performs a wait to remove the zombies.

       POSIX.1-2001  specifies  that if the disposition of <b>SIGCHLD</b> is set to <b>SIG_IGN</b> or the <b>SA_NOCLDWAIT</b> flag is
       set for <b>SIGCHLD</b> (see <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2)), then children that terminate do not become  zombies  and  a  call  to
       <b>wait</b>()  or  <b>waitpid</b>()  will  block  until  all  children have terminated, and then fail with <u>errno</u> set to
       <b>ECHILD</b>.  (The original POSIX standard left the behavior of setting <b>SIGCHLD</b> to <b>SIG_IGN</b> unspecified.   Note
       that  even  though  the default disposition of <b>SIGCHLD</b> is "ignore", explicitly setting the disposition to
       <b>SIG_IGN</b> results in different treatment of zombie process children.)

       Linux 2.6 conforms to the POSIX requirements.  However, Linux 2.4 (and earlier) does not: if a <b>wait</b>()  or
       <b>waitpid</b>()  call  is made while <b>SIGCHLD</b> is being ignored, the call behaves just as though <b>SIGCHLD</b> were not
       being ignored, that is, the call blocks until the next child terminates and then returns the  process  ID
       and status of that child.

   <b>Linux</b> <b>notes</b>
       In  the  Linux  kernel, a kernel-scheduled thread is not a distinct construct from a process.  Instead, a
       thread is simply a process that is created using the Linux-unique <b><a href="../man2/clone.2.html">clone</a></b>(2) system  call;  other  routines
       such  as  the portable <b><a href="../man3/pthread_create.3.html">pthread_create</a></b>(3) call are implemented using <b><a href="../man2/clone.2.html">clone</a></b>(2).  Before Linux 2.4, a thread
       was just a special case of a process, and as a consequence one thread could not wait on the  children  of
       another  thread,  even  when the latter belongs to the same thread group.  However, POSIX prescribes such
       functionality, and since Linux 2.4 a thread can, and by default will, wait on children of  other  threads
       in the same thread group.

       The  following  Linux-specific  <u>options</u>  are for use with children created using <b><a href="../man2/clone.2.html">clone</a></b>(2); they can also,
       since Linux 4.7, be used with <b>waitid</b>():

       <b>__WCLONE</b>
              Wait for "clone" children only.  If omitted, then wait for "non-clone" children only.  (A  "clone"
              child  is  one  which  delivers  no  signal,  or  a  signal  other than <b>SIGCHLD</b> to its parent upon
              termination.)  This option is ignored if <b>__WALL</b> is also specified.

       <b>__WALL</b> (since Linux 2.4)
              Wait for all children, regardless of type ("clone" or "non-clone").

       <b>__WNOTHREAD</b> (since Linux 2.4)
              Do not wait for children of other threads in the same thread group.  This was the  default  before
              Linux 2.4.

       Since Linux 4.7, the <b>__WALL</b> flag is automatically implied if the child is being ptraced.

</pre><h4><b>BUGS</b></h4><pre>
       According  to  POSIX.1-2008, an application calling <b>waitid</b>() must ensure that <u>infop</u> points to a <u>siginfo_t</u>
       structure (i.e., that it is a non-null pointer).  On Linux, if <u>infop</u>  is  NULL,  <b>waitid</b>()  succeeds,  and
       returns  the process ID of the waited-for child.  Applications should avoid relying on this inconsistent,
       nonstandard, and unnecessary feature.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following program demonstrates the use of  <b><a href="../man2/fork.2.html">fork</a></b>(2)  and  <b>waitpid</b>().   The  program  creates  a  child
       process.   If  no command-line argument is supplied to the program, then the child suspends its execution
       using <b><a href="../man2/pause.2.html">pause</a></b>(2), to allow the user to send signals to the child.  Otherwise, if a command-line argument is
       supplied, then the child exits immediately, using the integer supplied on the command line  as  the  exit
       status.   The  parent  process executes a loop that monitors the child using <b>waitpid</b>(), and uses the W*()
       macros described above to analyze the wait status value.

       The following shell session demonstrates the use of the program:

           $ <b>./a.out</b> <b>&amp;</b>
           Child PID is 32360
           [1] 32359
           $ <b>kill</b> <b>-STOP</b> <b>32360</b>
           stopped by signal 19
           $ <b>kill</b> <b>-CONT</b> <b>32360</b>
           continued
           $ <b>kill</b> <b>-TERM</b> <b>32360</b>
           killed by signal 15
           [1]+  Done                    ./a.out
           $

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;sys/wait.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           int    wstatus;
           pid_t  cpid, w;

           cpid = fork();
           if (cpid == -1) {
               perror("fork");
               exit(EXIT_FAILURE);
           }

           if (cpid == 0) {            /* Code executed by child */
               printf("Child PID is %jd\n", (intmax_t) getpid());
               if (argc == 1)
                   pause();                    /* Wait for signals */
               _exit(atoi(argv[1]));

           } else {                    /* Code executed by parent */
               do {
                   w = waitpid(cpid, &amp;wstatus, WUNTRACED | WCONTINUED);
                   if (w == -1) {
                       perror("waitpid");
                       exit(EXIT_FAILURE);
                   }

                   if (WIFEXITED(wstatus)) {
                       printf("exited, status=%d\n", WEXITSTATUS(wstatus));
                   } else if (WIFSIGNALED(wstatus)) {
                       printf("killed by signal %d\n", WTERMSIG(wstatus));
                   } else if (WIFSTOPPED(wstatus)) {
                       printf("stopped by signal %d\n", WSTOPSIG(wstatus));
                   } else if (WIFCONTINUED(wstatus)) {
                       printf("continued\n");
                   }
               } while (!WIFEXITED(wstatus) &amp;&amp; !WIFSIGNALED(wstatus));
               exit(EXIT_SUCCESS);
           }
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/_exit.2.html">_exit</a></b>(2), <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/fork.2.html">fork</a></b>(2), <b><a href="../man2/kill.2.html">kill</a></b>(2), <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2), <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2),  <b><a href="../man2/signal.2.html">signal</a></b>(2),  <b><a href="../man2/wait4.2.html">wait4</a></b>(2),  <b><a href="../man3/pthread_create.3.html">pthread_create</a></b>(3),
       <b><a href="../man5/core.5.html">core</a></b>(5), <b><a href="../man7/credentials.7.html">credentials</a></b>(7), <b><a href="../man7/signal.7.html">signal</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                            <u><a href="../man2/wait.2.html">wait</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>