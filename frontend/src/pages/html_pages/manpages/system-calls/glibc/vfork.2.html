<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vfork - create a child process and block parent</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       vfork - create a child process and block parent

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>pid_t</b> <b>vfork(void);</b>

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>vfork</b>():
           Since glibc 2.12:
               (_XOPEN_SOURCE &gt;= 500) &amp;&amp; ! (_POSIX_C_SOURCE &gt;= 200809L)
                   || /* Since glibc 2.19: */ _DEFAULT_SOURCE
                   || /* glibc &lt;= 2.19: */ _BSD_SOURCE
           Before glibc 2.12:
               _BSD_SOURCE || _XOPEN_SOURCE &gt;= 500

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Standard</b> <b>description</b>
       (From POSIX.1) The <b>vfork</b>() function has the same effect as <b><a href="../man2/fork.2.html">fork</a></b>(2), except that the behavior is undefined
       if  the  process  created by <b>vfork</b>() either modifies any data other than a variable of type <u>pid_t</u> used to
       store the return value from <b>vfork</b>(), or returns from the function in which <b>vfork</b>() was called,  or  calls
       any other function before successfully calling <b><a href="../man2/_exit.2.html">_exit</a></b>(2) or one of the <b><a href="../man3/exec.3.html">exec</a></b>(3) family of functions.

   <b>Linux</b> <b>description</b>
       <b>vfork</b>(), just like <b><a href="../man2/fork.2.html">fork</a></b>(2), creates a child process of the calling process.  For details and return value
       and errors, see <b><a href="../man2/fork.2.html">fork</a></b>(2).

       <b>vfork</b>()  is  a  special  case  of  <b><a href="../man2/clone.2.html">clone</a></b>(2).  It is used to create new processes without copying the page
       tables of the parent process.  It may be useful in performance-sensitive applications where  a  child  is
       created which then immediately issues an <b><a href="../man2/execve.2.html">execve</a></b>(2).

       <b>vfork</b>()  differs  from <b><a href="../man2/fork.2.html">fork</a></b>(2) in that the calling thread is suspended until the child terminates (either
       normally, by calling <b><a href="../man2/_exit.2.html">_exit</a></b>(2), or abnormally, after delivery of a fatal signal), or it makes  a  call  to
       <b><a href="../man2/execve.2.html">execve</a></b>(2).   Until  that  point,  the  child shares all memory with its parent, including the stack.  The
       child must not return from the current function or call <b><a href="../man3/exit.3.html">exit</a></b>(3) (which would have the effect  of  calling
       exit handlers established by the parent process and flushing the parent's <b><a href="../man3/stdio.3.html">stdio</a></b>(3) buffers), but may call
       <b><a href="../man2/_exit.2.html">_exit</a></b>(2).

       As  with <b><a href="../man2/fork.2.html">fork</a></b>(2), the child process created by <b>vfork</b>() inherits copies of various of the caller's process
       attributes (e.g., file descriptors, signal dispositions, and current working directory); the <b>vfork</b>() call
       differs only in the treatment of the virtual address space, as described above.

       Signals sent to the parent arrive after the child releases the parent's memory  (i.e.,  after  the  child
       terminates or calls <b><a href="../man2/execve.2.html">execve</a></b>(2)).

   <b>Historic</b> <b>description</b>
       Under Linux, <b><a href="../man2/fork.2.html">fork</a></b>(2) is implemented using copy-on-write pages, so the only penalty incurred by <b><a href="../man2/fork.2.html">fork</a></b>(2) is
       the time and memory required to duplicate the parent's page tables, and to create a unique task structure
       for  the  child.   However,  in  the  bad  old days a <b><a href="../man2/fork.2.html">fork</a></b>(2) would require making a complete copy of the
       caller's data space, often needlessly, since usually immediately afterward an <b><a href="../man3/exec.3.html">exec</a></b>(3) is done.  Thus, for
       greater efficiency, BSD introduced the <b>vfork</b>() system call, which did not fully copy the address space of
       the parent process, but borrowed the parent's memory and thread of control until a call to  <b><a href="../man2/execve.2.html">execve</a></b>(2)  or
       an  exit occurred.  The parent process was suspended while the child was using its resources.  The use of
       <b>vfork</b>() was tricky: for example, not modifying data in the  parent  process  depended  on  knowing  which
       variables were held in a register.

</pre><h4><b>VERSIONS</b></h4><pre>
       The  requirements  put  on  <b>vfork</b>()  by  the  standards  are  weaker  than  those  put  on <b><a href="../man2/fork.2.html">fork</a></b>(2), so an
       implementation where the two are synonymous is compliant.  In particular, the programmer cannot  rely  on
       the parent remaining blocked until the child either terminates or calls <b><a href="../man2/execve.2.html">execve</a></b>(2), and cannot rely on any
       specific behavior with respect to shared memory.

       Some  consider  the  semantics of <b>vfork</b>() to be an architectural blemish, and the 4.2BSD man page stated:
       “This system call will be eliminated when proper system sharing mechanisms are implemented.  Users should
       not depend on the memory sharing semantics of <u>vfork</u> as it will, in  that  case,  be  made  synonymous  to
       <u>fork</u>.”   However,  even though modern memory management hardware has decreased the performance difference
       between <b><a href="../man2/fork.2.html">fork</a></b>(2) and <b>vfork</b>(), there are various reasons why Linux and other systems have retained <b>vfork</b>():

       •  Some performance-critical applications require the small performance advantage conferred by <b>vfork</b>().

       •  <b>vfork</b>() can be implemented on systems that lack a memory-management unit (MMU), but <b><a href="../man2/fork.2.html">fork</a></b>(2)  can't  be
          implemented on such systems.  (POSIX.1-2008 removed <b>vfork</b>() from the standard; the POSIX rationale for
          the  <b><a href="../man3/posix_spawn.3.html">posix_spawn</a></b>(3)  function  notes  that  that  function, which provides functionality equivalent to
          <b><a href="../man2/fork.2.html">fork</a></b>(2)+<b><a href="../man3/exec.3.html">exec</a></b>(3), is designed to be implementable on systems that lack an MMU.)

       •  On systems where memory is constrained, <b>vfork</b>() avoids the need to temporarily commit memory (see  the
          description  of  <u><a href="file:/proc/sys/vm/overcommit_memory">/proc/sys/vm/overcommit_memory</a></u>  in <b><a href="../man5/proc.5.html">proc</a></b>(5)) in order to execute a new program.  (This
          can be especially beneficial where a large parent process wishes to execute a small helper program  in
          a child process.)  By contrast, using <b><a href="../man2/fork.2.html">fork</a></b>(2) in this scenario requires either committing an amount of
          memory  equal  to  the  size  of  the  parent  process  (if  strict  overcommitting  is  in  force) or
          overcommitting memory with the risk that a process is terminated by the out-of-memory (OOM) killer.

   <b>Linux</b> <b>notes</b>
       Fork handlers established using <b><a href="../man3/pthread_atfork.3.html">pthread_atfork</a></b>(3) are not called when a multithreaded  program  employing
       the  NPTL  threading library calls <b>vfork</b>().  Fork handlers are called in this case in a program using the
       LinuxThreads threading library.  (See <b><a href="../man7/pthreads.7.html">pthreads</a></b>(7) for a description of Linux threading libraries.)

       A call to <b>vfork</b>() is equivalent to calling <b><a href="../man2/clone.2.html">clone</a></b>(2) with <u>flags</u> specified as:

            CLONE_VM | CLONE_VFORK | SIGCHLD

</pre><h4><b>STANDARDS</b></h4><pre>
       None.

</pre><h4><b>HISTORY</b></h4><pre>
       4.3BSD; POSIX.1-2001 (but marked OBSOLETE).  POSIX.1-2008 removes the specification of <b>vfork</b>().

       The <b>vfork</b>() system call appeared in 3.0BSD.  In 4.4BSD it was  made  synonymous  to  <b><a href="../man2/fork.2.html">fork</a></b>(2)  but  NetBSD
       introduced  it  again;  see <a href="http://www.netbsd.org/Documentation/kernel/vfork.html">http://www.netbsd.org/Documentation/kernel/vfork.html</a>.  In Linux, it has been
       equivalent to <b><a href="../man2/fork.2.html">fork</a></b>(2) until Linux 2.2.0-pre6 or so.  Since Linux 2.2.0-pre9 (on i386, somewhat  later  on
       other architectures) it is an independent system call.  Support was added in glibc 2.0.112.

</pre><h4><b>CAVEATS</b></h4><pre>
       The  child  process should take care not to modify the memory in unintended ways, since such changes will
       be seen by the parent process once the child terminates or executes another  program.   In  this  regard,
       signal  handlers  can  be  especially  problematic:  if  a signal handler that is invoked in the child of
       <b>vfork</b>() changes memory, those changes may result in an inconsistent process state from the perspective of
       the parent process (e.g., memory changes would be visible in the parent, but changes to the state of open
       file descriptors would not be visible).

       When <b>vfork</b>() is called in a multithreaded process, only the calling thread is suspended until  the  child
       terminates  or  executes a new program.  This means that the child is sharing an address space with other
       running code.  This can be dangerous if another thread in the parent process changes  credentials  (using
       <b><a href="../man2/setuid.2.html">setuid</a></b>(2)  or  similar), since there are now two processes with different privilege levels running in the
       same address space.  As an example of the dangers, suppose that a multithreaded program running  as  root
       creates a child using <b>vfork</b>().  After the <b>vfork</b>(), a thread in the parent process drops the process to an
       unprivileged  user in order to run some untrusted code (e.g., perhaps via plug-in opened with <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3)).
       In this case, attacks are possible where the parent process uses <b><a href="../man2/mmap.2.html">mmap</a></b>(2) to map  in  code  that  will  be
       executed by the privileged child process.

</pre><h4><b>BUGS</b></h4><pre>
       Details  of  the  signal  handling  are obscure and differ between systems.  The BSD man page states: "To
       avoid a possible deadlock situation, processes that are children in the middle of  a  <b>vfork</b>()  are  never
       sent  <b>SIGTTOU</b>  or  <b>SIGTTIN</b>  signals; rather, output or <u>ioctl</u>s are allowed and input attempts result in an
       end-of-file indication."

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/execve.2.html">execve</a></b>(2), <b><a href="../man2/_exit.2.html">_exit</a></b>(2), <b><a href="../man2/fork.2.html">fork</a></b>(2), <b><a href="../man2/unshare.2.html">unshare</a></b>(2), <b><a href="../man2/wait.2.html">wait</a></b>(2)

Linux man-pages 6.9.1                              2024-05-02                                           <u><a href="../man2/vfork.2.html">vfork</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>