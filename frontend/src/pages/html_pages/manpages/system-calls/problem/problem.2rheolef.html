<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>problem - linear solver (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       problem - linear solver (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The problem class solves a given linear system for PDEs in variational formulation.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The degrees of freedom are splitting between <u>unknown</u> degrees of freedom and <u>blocked</u> one. See also <b><a href="../man2/form.2.html">form</a>(2)</b>
       and <b><a href="../man2/space.2.html">space</a>(2)</b>. Let a be a bilinear <b><a href="../man2/form.2.html">form</a>(2)</b> and lh be the right-hand-side, as in the previous example. The
       linear system expands as:

           [ a.uu  a.ub ] [ uh.u ]   [ lh.u ]
           [            ] [      ] = [      ]
           [ a.bu  a.bb ] [ uh.b ]   [ lh.b ]

        The uh.b are blocked degrees of freedom: their values are prescribed and the corresponding values are
       move to the right-hand-side of the system that reduces to:

           a.uu*uh.u =  lh.u - a.ub*uh.b

        This writes:

           problem p (a);
           p.solve (lh, uh);

        Observe that, during the p.solve call, uh is both an input variable, for the uh.b contribution to the
       right-hand-side, and an output variable, with uh.u. When using an iterative resolution, the details about
       its convergence, e.g. the number of iterations and the final residue, can be obtain via the p.option()
       member function, see <b><a href="../man4/solver_option.4.html">solver_option</a>(4)</b>. Finally, the previous linear system is solved via the <b><a href="../man4/solver.4.html">solver</a>(4)</b>
       class: the problem class is simply a convenient wrapper around the <b><a href="../man4/solver.4.html">solver</a>(4)</b> one.

</pre><h4><b>EXAMPLE</b></h4><pre>
       See <b>dirichlet.cc</b>

</pre><h4><b>CUSTOMIZATION</b></h4><pre>
       The <b><a href="../man4/solver.4.html">solver</a>(4)</b> could be customized via the constructor optional <b><a href="../man4/solver_option.4.html">solver_option</a>(4)</b> argument:

           problem p (a, sopt);

        When using a direct <b><a href="../man4/solver.4.html">solver</a>(4)</b>, the determinant of the linear system matrix is also available as p.det().
       When using an iterative <b><a href="../man4/solver.4.html">solver</a>(4)</b>, the preconditionner could be customized:

           p.set_preconditionner (m);

</pre><h4><b>TODO</b></h4><pre>
       The solve method could return a boolean when success.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file main/lib/problem.h

       The problem class is simply an alias to the <b>problem_basic</b> <b>class</b>

       typedef problem_basic&lt;Float&gt; problem;

       The <b>problem_basic</b> <b>class</b> <b>provides</b> <b>a</b> <b>generic</b> <b>interface:</b>

       template &lt;class T, class M = rheo_default_memory_model&gt;
       class problem_basic {
       public:

       // typedefs:

         typedef typename solver_basic&lt;T,M&gt;::size_type         size_type;
         typedef typename solver_basic&lt;T,M&gt;::determinant_type  determinant_type;

       // allocators:

         problem_basic ();
         problem_basic (const form_basic&lt;T,M&gt;&amp; a,
                        const solver_option&amp; sopt = solver_option());

         void update_value (const form_basic&lt;T,M&gt;&amp; a);

         void set_preconditioner (const solver_basic&lt;T,M&gt;&amp;);

       // accessor:

         void solve       (const field_basic&lt;T,M&gt;&amp; lh, field_basic&lt;T,M&gt;&amp; uh) const;
         void trans_solve (const field_basic&lt;T,M&gt;&amp; lh, field_basic&lt;T,M&gt;&amp; uh) const;

         determinant_type det() const;
         const solver_option&amp; option() const;
         bool initialized() const;

       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                 <u><a href="../man2rheolef/problem.2rheolef.html">problem</a></u>(2rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>