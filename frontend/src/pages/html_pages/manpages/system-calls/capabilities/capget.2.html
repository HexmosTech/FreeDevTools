<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>capget, capset - set/get capabilities of thread(s)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       capget, capset - set/get capabilities of thread(s)

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/linux/capability.h">linux/capability.h</a>&gt;</b> /* Definition of <b>CAP_*</b> and
                                        <b>_LINUX_CAPABILITY_*</b> constants */
       <b>#include</b> <b>&lt;sys/syscall.h&gt;</b>      /* Definition of <b>SYS_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;</b>

       <b>int</b> <b>syscall(SYS_capget,</b> <b>cap_user_header_t</b> <u>hdrp</u><b>,</b>
                   <b>cap_user_data_t</b> <u>datap</u><b>);</b>
       <b>int</b> <b>syscall(SYS_capset,</b> <b>cap_user_header_t</b> <u>hdrp</u><b>,</b>
                   <b>const</b> <b>cap_user_data_t</b> <u>datap</u><b>);</b>

       <u>Note</u>: glibc provides no wrappers for these system calls, necessitating the use of <b><a href="../man2/syscall.2.html">syscall</a></b>(2).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  two  system  calls  are the raw kernel interface for getting and setting thread capabilities.  Not
       only are these system calls specific to Linux, but the kernel API is likely to change and  use  of  these
       system  calls  (in  particular  the  format  of the <u>cap_user_*_t</u> types) is subject to extension with each
       kernel revision, but old programs will keep working.

       The portable interfaces are <b><a href="../man3/cap_set_proc.3.html">cap_set_proc</a></b>(3) and  <b><a href="../man3/cap_get_proc.3.html">cap_get_proc</a></b>(3);  if  possible,  you  should  use  those
       interfaces in applications; see NOTES.

   <b>Current</b> <b>details</b>
       Now that you have been warned, some current kernel details.  The structures are defined as follows.

           #define _LINUX_CAPABILITY_VERSION_1  0x19980330
           #define _LINUX_CAPABILITY_U32S_1     1

                   /* V2 added in Linux 2.6.25; deprecated */
           #define _LINUX_CAPABILITY_VERSION_2  0x20071026
           #define _LINUX_CAPABILITY_U32S_2     2

                   /* V3 added in Linux 2.6.26 */
           #define _LINUX_CAPABILITY_VERSION_3  0x20080522
           #define _LINUX_CAPABILITY_U32S_3     2

           typedef struct __user_cap_header_struct {
              __u32 version;
              int pid;
           } *cap_user_header_t;

           typedef struct __user_cap_data_struct {
              __u32 effective;
              __u32 permitted;
              __u32 inheritable;
           } *cap_user_data_t;

       The  <u>effective</u>,  <u>permitted</u>,  and  <u>inheritable</u>  fields  are  bit  masks  of  the  capabilities  defined in
       <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7).  Note that the <b>CAP_*</b> values are bit indexes and need to be bit-shifted before ORing into
       the bit fields.  To define the structures for passing to the system call, you  have  to  use  the  <u>struct</u>
       <b>__</b><u>user_cap_header_struct</u> and <u>struct</u> <b>__</b><u>user_cap_data_struct</u> names because the typedefs are only pointers.

       Kernels prior to Linux 2.6.25 prefer 32-bit capabilities with version <b>_LINUX_CAPABILITY_VERSION_1</b>.  Linux
       2.6.25  added  64-bit  capability sets, with version <b>_LINUX_CAPABILITY_VERSION_2</b>.  There was, however, an
       API glitch, and Linux 2.6.26 added <b>_LINUX_CAPABILITY_VERSION_3</b> to fix the problem.

       Note that 64-bit capabilities use <u>datap[0]</u> and <u>datap[1]</u>, whereas 32-bit capabilities use only <u>datap[0]</u>.

       On kernels that support file capabilities (VFS capabilities support), these system calls behave  slightly
       differently.   This  support  was  added  as an option in Linux 2.6.24, and became fixed (nonoptional) in
       Linux 2.6.33.

       For <b>capget</b>() calls, one can probe the capabilities of any process by specifying its process ID  with  the
       <u>hdrp-&gt;pid</u> field value.

       For details on the data, see <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7).

   <b>With</b> <b>VFS</b> <b>capabilities</b> <b>support</b>
       VFS  capabilities employ a file extended attribute (see <b><a href="../man7/xattr.7.html">xattr</a></b>(7)) to allow capabilities to be attached to
       executables.  This privilege model obsoletes kernel support for one process  asynchronously  setting  the
       capabilities  of another.  That is, on kernels that have VFS capabilities support, when calling <b>capset</b>(),
       the only permitted values for <u>hdrp-&gt;pid</u> are 0 or, equivalently, the value returned by <b><a href="../man2/gettid.2.html">gettid</a></b>(2).

   <b>Without</b> <b>VFS</b> <b>capabilities</b> <b>support</b>
       On older kernels that do not provide VFS capabilities  support  <b>capset</b>()  can,  if  the  caller  has  the
       <b>CAP_SETPCAP</b>  capability,  be  used  to  change  not  only  the  caller's  own  capabilities, but also the
       capabilities of other threads.  The call operates on the capabilities of the thread specified by the  <u>pid</u>
       field  of  <u>hdrp</u>  when  that is nonzero, or on the capabilities of the calling thread if <u>pid</u> is 0.  If <u>pid</u>
       refers to a single-threaded process, then <u>pid</u> can be specified as a traditional process ID; operating  on
       a  thread  of  a  multithreaded  process  requires  a  thread  ID of the type returned by <b><a href="../man2/gettid.2.html">gettid</a></b>(2).  For
       <b>capset</b>(), <u>pid</u> can also be: -1, meaning perform the change on all threads except the caller  and  <b><a href="../man1/init.1.html">init</a></b>(1);
       or a value less than -1, in which case the change is applied to all members of the process group whose ID
       is -<u>pid</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, zero is returned.  On error, -1 is returned, and <u>errno</u> is set to indicate the error.

       The  calls fail with the error <b>EINVAL</b>, and set the <u>version</u> field of <u>hdrp</u> to the kernel preferred value of
       <b>_LINUX_CAPABILITY_VERSION_?</b>  when an unsupported <u>version</u> value is specified.  In this way, one can  probe
       what the current preferred capability revision is.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> Bad  memory  address.   <u>hdrp</u>  must not be NULL.  <u>datap</u> may be NULL only when the user is trying to
              determine the preferred capability version format supported by the kernel.

       <b>EINVAL</b> One of the arguments was invalid.

       <b>EPERM</b>  An attempt was made to add a capability to the permitted set,  or  to  set  a  capability  in  the
              effective set that is not in the permitted set.

       <b>EPERM</b>  An attempt was made to add a capability to the inheritable set, and either:

              •  that capability was not in the caller's bounding set; or

              •  the  capability  was  not  in  the caller's permitted set and the caller lacked the <b>CAP_SETPCAP</b>
                 capability in its effective set.

       <b>EPERM</b>  The caller attempted to use <b>capset</b>() to modify the capabilities of a thread other than itself, but
              lacked sufficient privilege.  For kernels supporting VFS capabilities, this  is  never  permitted.
              For kernels lacking VFS support, the <b>CAP_SETPCAP</b> capability is required.  (A bug in kernels before
              Linux  2.6.11  meant that this error could also occur if a thread without this capability tried to
              change its own capabilities by specifying the <u>pid</u> field  as  a  nonzero  value  (i.e.,  the  value
              returned by <b><a href="../man2/getpid.2.html">getpid</a></b>(2)) instead of 0.)

       <b>ESRCH</b>  No such thread.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>NOTES</b></h4><pre>
       The portable interface to the capability querying and setting functions is provided by the <u>libcap</u> library
       and is available here:
       <a href="http://git.kernel.org/cgit/linux/kernel/git/morgan/libcap.git">http://git.kernel.org/cgit/linux/kernel/git/morgan/libcap.git</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/gettid.2.html">gettid</a></b>(2), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                          <u><a href="../man2/capget.2.html">capget</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>