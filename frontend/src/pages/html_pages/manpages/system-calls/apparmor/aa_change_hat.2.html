<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>aa_change_hat  - change to or from a "hat" within a AppArmor profile</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libapparmor-dev">libapparmor-dev_4.1.1-0ubuntu6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       aa_change_hat  - change to or from a "hat" within a AppArmor profile

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/apparmor.h&gt;</b>

       <b>int</b> <b>aa_change_hat</b> <b>(char</b> <b>*subprofile,</b> <b>unsigned</b> <b>long</b> <b>magic_token);</b>

       <b>int</b> <b>aa_change_hatv</b> <b>(char</b> <b>*subprofiles[],</b> <b>unsigned</b> <b>long</b> <b>magic_token);</b>

       <b>int</b> <b>aa_change_hat_vargs</b> <b>(unsigned</b> <b>long</b> <b>magic_token,</b> <b>...);</b>

       Link with <b>-lapparmor</b> when compiling.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       An AppArmor profile applies to an executable program; if a portion of the program needs different access
       permissions than other portions, the program can "change hats" to a different role, also known as a
       subprofile.

       To change into a new hat, it calls one of the family of change_hat functions to do so. It passes in a
       pointer to the <u>subprofile</u> which it wants to change into, and a 64bit <u>magic_token</u>.  The <u>magic_token</u> is
       used to return out of the subprofile at a later time.

       The <b>aa_change_hat()</b> function allows specifying the name of a single <u>subprofile</u> that the application wants
       to change into.  A pointer to the name of the <u>subprofile</u> is passed along with the <u>magic_token</u>.  If the
       profile is not present the call will fail with the appropriate error.

       The <b>aa_change_hatv()</b> function allows passing a <u>NULL</u> terminated vector of pointers to <u>subprofile</u> names
       which will be tried in order.  The first <u>subprofile</u> in the vector that exists will be transitioned to and
       if none of the <u>subprofiles</u> exist the call will fail with the appropriate error.

       The <b>aa_change_hat_vargs()</b> function is a convenience wrapper for the <b>aa_change_hatv()</b> function.  After the
       <u>magic_token</u> it takes an arbitrary number of pointers to <u>subprofile</u> names.  Similar to <b><a href="../man3/execl.3.html">execl</a></b>(3),
       <b>aa_change_hat_vargs()</b> assembles the list of <u>subprofile</u> names into a vector and calls <b>aa_change_hatv()</b>.

       If a program wants to return out of the current subprofile to the original profile, it calls
       <b>aa_change_hat()</b> with a pointer to NULL as the <u>subprofile</u>, and the original <u>magic_token</u> value. If the
       <u>magic_token</u> does not match the original <u>magic_token</u> passed into the kernel when the program entered the
       subprofile, the change back to the original profile will not happen, and the current task will be killed.
       If the <u>magic_token</u> matches the original token, then the process will change back to the original profile.

       As both <b><a href="../man2/read.2.html">read</a></b>(2) and <b><a href="../man2/write.2.html">write</a></b>(2) are mediated, a file must be listed in a subprofile definition if the file
       is to be accessed while the process is in a "hat".

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success zero is returned. On error, -1 is returned, and <b><a href="../man3/errno.3.html">errno</a></b>(3) is set appropriately.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EINVAL</b>
           The  apparmor  kernel module is not loaded or the communication via the <u><a href="file:/proc/">/proc/</a>*/attr/current</u> file did
           not conform to protocol.

       <b>ENOMEM</b>
           Insufficient kernel memory was available.

       <b>EPERM</b>
           The calling application is not confined by apparmor, the specified <u>subprofile</u> is not a  <u>hat</u>  <u>profile</u>,
           the  task  is  being  ptraced  and  the  tracing task does not have permission to trace the specified
           <u>subprofile</u> or the no_new_privs execution bit is enabled.

       <b>ECHILD</b>
           The application's profile has no hats defined for it.

       <b>ENOENT</b>
           The specified <u>subprofile</u> does not exist in this profile but other hats are defined.

       <b>EACCES</b>
           The specified magic token did not match, and permissions to change to the  specified  <u>subprofile</u>  has
           been  denied.  This  will  in  most situations also result in the task being killed, to prevent brute
           force attacks.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following code examples shows simple, if  contrived,  uses  of  <b>aa_change_hat()</b>;  a  typical  use  of
       <b>aa_change_hat()</b>  will  separate privileged portions of a process from unprivileged portions of a process,
       such as keeping unauthenticated network traffic handling  separate  from  authenticated  network  traffic
       handling in OpenSSH or executing user-supplied CGI scripts in apache.

       The use of <b><a href="../man3/random.3.html">random</a></b>(3) is simply illustrative. Use of <u>/dev/urandom</u> is recommended.

       First, a simple high-level overview of <b>aa_change_hat()</b> use:

        void foo (void) {
               unsigned long magic_token;

               /* get a random magic token value
               from our huge entropy pool */
               magic_token = random_function();

               /* change into the subprofile while
                * we do stuff we don't trust */
               aa_change_hat("stuff_we_dont_trust", magic_token);

               /* Go do stuff we don't trust -- this is all
                * done in *this* process space, no separate
                * fork()/exec()'s are done. */
               interpret_perl_stuff(stuff_from_user);

               /* now change back to our original profile */
               aa_change_hat(NULL, magic_token);
        }

       Second,  an  example  to  show  that  files not listed in a subprofile ("hat") aren't accessible after an
       <b>aa_change_hat()</b> call:

        #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
        #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
        #include &lt;sys/apparmor.h&gt;
        #include &lt;sys/types.h&gt;
        #include &lt;sys/stat.h&gt;
        #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
        #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
        #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

        int main(int argc, char *argv[]) {
               int fd;
               unsigned long tok;
               char buf[10];

               /* random() is a poor choice */
               tok = random();

               /* open <a href="file:/etc/passwd">/etc/passwd</a> outside of any hat */
               if ((fd=open("<a href="file:/etc/passwd">/etc/passwd</a>", O_RDONLY)) &lt; 0)
                       perror("Failure opening <a href="file:/etc/passwd">/etc/passwd</a>");

               /* confirm for ourselves that we can really read <a href="file:/etc/passwd">/etc/passwd</a> */
               memset(&amp;buf, 0, 10);
               if (read(fd, &amp;buf, 10) == -1) {
                       perror("Failure reading <a href="file:/etc/passwd">/etc/passwd</a> pre-hat");
                       <a href="../man1/_exit.1.html">_exit</a>(1);
               }
               buf[9] = '\0';
               printf("<a href="file:/etc/passwd">/etc/passwd</a>: %s\n", buf);

               /* change hat to the "hat" subprofile, which should not have
                * read access to <a href="file:/etc/passwd">/etc/passwd</a> -- even though we have a valid
                * file descriptor at the time of the aa_change_hat() call. */
               if (aa_change_hat("hat", tok)) {
                       perror("Failure changing hat -- aborting");
                       <a href="../man1/_exit.1.html">_exit</a>(1);
               }

               /* confirm that we cannot read <a href="file:/etc/passwd">/etc/passwd</a> */
               lseek(fd,0,SEEK_SET);
               memset(&amp;buf, 0, 10);
               if (read(fd, &amp;buf, 10) == -1)
                       perror("Failure reading <a href="file:/etc/passwd">/etc/passwd</a> post-hat");
               buf[9] = '\0';
               printf("<a href="file:/etc/passwd">/etc/passwd</a>: %s\n", buf);

               return 0;
        }

       This code example requires the following profile to be loaded with <b><a href="../man8/apparmor_parser.8.html">apparmor_parser</a></b>(8):

        /tmp/ch {
          <a href="file:/etc/ld.so.cache">/etc/ld.so.cache</a>               mr,
          /etc/locale/**                 r,
          <a href="file:/etc/localtime">/etc/localtime</a>                 r,
          <a href="file:/usr/share/locale/">/usr/share/locale/</a>**           r,
          <a href="file:/usr/share/zoneinfo/">/usr/share/zoneinfo/</a>**         r,
          <a href="file:/usr/lib/locale/">/usr/lib/locale/</a>**             mr,
          /usr/lib/gconv/*.so            mr,
          /usr/lib/gconv/gconv-modules*  mr,

          /lib/ld-*.so*         mrix,
          /lib/libc*.so*        mr,
          /lib/libapparmor*.so* mr,
          <a href="file:/dev/pts/">/dev/pts/</a>*            rw,
          /tmp/ch               mr,

          <a href="file:/etc/passwd">/etc/passwd</a>           r,

          ^hat {
            <a href="file:/dev/pts/">/dev/pts/</a>*     rw,
          }
        }

       The output when run:

        $ /tmp/ch
        <a href="file:/etc/passwd">/etc/passwd</a>: root:x:0:
        Failure reading <a href="file:/etc/passwd">/etc/passwd</a> post-hat: Permission denied
        <a href="file:/etc/passwd">/etc/passwd</a>:
        $

</pre><h4><b>BUGS</b></h4><pre>
       None known. If you find any, please report them at &lt;https://gitlab.com/apparmor/apparmor/-/issues&gt;.  Note
       that  <b><a href="../man2/aa_change_hat.2.html">aa_change_hat</a></b>(2) provides no memory barriers between different areas of a program; if address space
       separation is required, then separate processes should be used.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/apparmor.7.html">apparmor</a></b>(7),    <b><a href="../man5/apparmor.d.5.html">apparmor.d</a></b>(5),     <b><a href="../man8/apparmor_parser.8.html">apparmor_parser</a></b>(8),     <b><a href="../man2/aa_change_profile.2.html">aa_change_profile</a></b>(2),     <b><a href="../man2/aa_getcon.2.html">aa_getcon</a></b>(2)     and
       &lt;https://wiki.apparmor.net&gt;.

AppArmor 4.1.1                                     2025-07-23                                   <u><a href="../man2/AA_CHANGE_HAT.2.html">AA_CHANGE_HAT</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>