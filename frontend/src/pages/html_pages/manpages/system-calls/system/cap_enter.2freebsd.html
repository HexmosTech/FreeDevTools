<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cap_enter, cap_getmode — Capability mode system calls</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cap_enter, cap_getmode — Capability mode system calls

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/capsicum.h&gt;</b>

       <u>int</u>
       <b>cap_enter</b>(<u>void</u>);

       <u>int</u>
       <b>cap_getmode</b>(<u>u_int</u> <u>*modep</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>cap_enter</b>()  places  the current process into capability mode, a mode of execution in which processes may
       only issue system calls operating on file descriptors or reading limited global system state.  Access  to
       global name spaces, such as file system or IPC name spaces, is prevented.  If the process is already in a
       capability  mode sandbox, the system call is a no-op.  Future process descendants created with <u><a href="../man2/fork.2.html">fork</a></u>(2) or
       <u><a href="../man2/pdfork.2.html">pdfork</a></u>(2) will be placed in capability mode from inception.

       When combined with <u><a href="../man2/cap_rights_limit.2.html">cap_rights_limit</a></u>(2), <u><a href="../man2/cap_ioctls_limit.2.html">cap_ioctls_limit</a></u>(2), <u><a href="../man2/cap_fcntls_limit.2.html">cap_fcntls_limit</a></u>(2), <b>cap_enter</b>() may be used
       to create kernel-enforced sandboxes in which appropriately-crafted applications or application components
       may be run.

       <b>cap_getmode</b>() returns a flag indicating whether or not the process is in a capability mode sandbox.

</pre><h4><b>RUN-TIME</b> <b>SETTINGS</b></h4><pre>
       If the kern.trap_enotcap sysctl MIB is set to a non-zero value, then  for  any  process  executing  in  a
       capability  mode  sandbox,  any  syscall  which  results  in either an ENOTCAPABLE or ECAPMODE error also
       generates the synchronous SIGTRAP signal to the thread on the syscall return.  On  signal  delivery,  the
       <u>si_errno</u>  member  of  the  <u>siginfo</u>  signal  handler  parameter is set to the syscall error value, and the
       <u>si_code</u> member is set to TRAP_CAP.

       See also the PROC_TRAPCAP_CTL and PROC_TRAPCAP_STATUS operations of the <u><a href="../man2/procctl.2.html">procctl</a></u>(2) function  for  similar
       per-process functionality.

</pre><h4><b>CAVEAT</b></h4><pre>
       Creating  effective  process  sandboxes  is a tricky process that involves identifying the least possible
       rights required by the process and then  passing  those  rights  into  the  process  in  a  safe  manner.
       Consumers  of <b>cap_enter</b>() should also be aware of other inherited rights, such as access to VM resources,
       memory contents, and other process properties  that  should  be  considered.   It  is  advisable  to  use
       <u><a href="../man2/fexecve.2.html">fexecve</a></u>(2)  to create a runtime environment inside the sandbox that has as few implicitly acquired rights
       as possible.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>cap_enter</b>() and <b>cap_getmode</b>() functions return the value 0 if successful; otherwise the value  -1  is
       returned and the global variable <u>errno</u> is set to indicate the error.

       When  the  process  is in capability mode, <b>cap_getmode</b>() sets the flag to a non-zero value.  A zero value
       means the process is not in capability mode.

</pre><h4><b>ERRORS</b></h4><pre>
       The <b>cap_enter</b>() and <b>cap_getmode</b>() system calls will fail if:

       [ENOSYS]           The kernel is compiled without:

                          <b>options</b> <b>CAPABILITY_MODE</b>

       The <b>cap_getmode</b>() system call may also return the following error:

       [EFAULT]           Pointer <u>modep</u> points outside the process's allocated address space.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/cap_fcntls_limit.2.html">cap_fcntls_limit</a></u>(2), <u><a href="../man2/cap_ioctls_limit.2.html">cap_ioctls_limit</a></u>(2), <u><a href="../man2/cap_rights_limit.2.html">cap_rights_limit</a></u>(2), <u><a href="../man2/fexecve.2.html">fexecve</a></u>(2), <u><a href="../man2/procctl.2.html">procctl</a></u>(2),  <u><a href="../man3/cap_sandboxed.3.html">cap_sandboxed</a></u>(3),
       <u><a href="../man4/capsicum.4.html">capsicum</a></u>(4), <u><a href="../man9/sysctl.9.html">sysctl</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       The  <b>cap_getmode</b>()  system call first appeared in FreeBSD 8.3.  Support for capabilities and capabilities
       mode was developed as part of the TrustedBSD Project.

</pre><h4><b>AUTHORS</b></h4><pre>
       These functions and the capability facility were created by Robert N. M.  Watson  at  the  University  of
       Cambridge Computer Laboratory with support from a grant from Google, Inc.

Debian                                             May 5, 2020                                      <u><a href="../man2/CAP_ENTER.2.html">CAP_ENTER</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>