<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>intro — introduction to system calls and error numbers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       intro — introduction to system calls and error numbers

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  section provides an overview of the system calls, their error returns, and other common definitions
       and concepts.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Nearly all of the system calls provide an error number referenced  via  the  external  identifier  errno.
       This identifier is defined in &lt;<u>sys/errno.h</u>&gt; as

             <b>extern</b> <b>int</b> <b>*</b> <b>__error();</b>
             <b>#define</b> <b>errno</b> <b>(*</b> <b>__error())</b>

       The  <b>__</b><u>error()</u>  function  returns a pointer to a field in the thread specific structure for threads other
       than the initial thread.  For the initial thread and non-threaded processes, <b>__</b><u>error()</u> returns a  pointer
       to a global <u>errno</u> variable that is compatible with the previous definition.

       When a system call detects an error, it returns an integer value indicating failure (usually -1) and sets
       the variable <u>errno</u> accordingly.  (This allows interpretation of the failure on receiving a -1 and to take
       action  accordingly.)  Successful calls never set <u>errno</u>; once set, it remains until another error occurs.
       It should only be examined after an error.  Note that a number of system calls overload the  meanings  of
       these error numbers, and that the meanings must be interpreted according to the type and circumstances of
       the call.

       The following is a complete list of the errors and their names as given in &lt;<u>sys/errno.h</u>&gt;.

       0 <u>Undefined</u> <u>error:</u> <u>0</u>.  Not used.

       1  EPERM  <u>Operation</u> <u>not</u> <u>permitted</u>.  An attempt was made to perform an operation limited to processes with
               appropriate privileges or to the owner of a file or other resources.

       2 ENOENT <u>No</u> <u>such</u> <u>file</u> <u>or</u> <u>directory</u>.  A component of a specified pathname did not exist, or  the  pathname
               was an empty string.

       3  ESRCH <u>No</u> <u>such</u> <u>process</u>.  No process could be found corresponding to that specified by the given process
               ID.

       4 EINTR <u>Interrupted</u> <u>system</u> <u>call</u>.  An asynchronous signal (such as SIGINT or SIGQUIT) was  caught  by  the
               process  during  the  execution  of  an interruptible function.  If the signal handler performs a
               normal return, the interrupted system call will seem to have returned the error condition.

       5 EIO <u>Input/output</u> <u>error</u>.  Some physical input or output error occurred.  This error will not be reported
               until a subsequent operation on the same file descriptor and may be lost (over  written)  by  any
               subsequent errors.

       6  ENXIO  <u>Device</u>  <u>not</u>  <u>configured</u>.   Input  or output on a special file referred to a device that did not
               exist, or made a request beyond the limits of the device.  This error may also  occur  when,  for
               example, a tape drive is not online or no disk pack is loaded on a drive.

       7  E2BIG  <u>Argument</u>  <u>list</u> <u>too</u> <u>long</u>.  The number of bytes used for the argument and environment list of the
               new process exceeded the current limit (NCARGS in &lt;<u>sys/param.h</u>&gt;).

       8 ENOEXEC <u>Exec</u> <u>format</u> <u>error</u>.  A request was made to execute a file that, although it has the  appropriate
               permissions, was not in the format required for an executable file.

       9 EBADF <u>Bad</u> <u>file</u> <u>descriptor</u>.  A file descriptor argument was out of range, referred to no open file, or a
               read (write) request was made to a file that was only open for writing (reading).

       10  ECHILD  <u>No</u>  <u>child</u>  <u>processes</u>.  A <u><a href="../man2/wait.2.html">wait</a></u>(2) or <u><a href="../man2/waitpid.2.html">waitpid</a></u>(2) function was executed by a process that had no
               existing or unwaited-for child processes.

       11 EDEADLK <u>Resource</u> <u>deadlock</u> <u>avoided</u>.  An attempt was made to lock a  system  resource  that  would  have
               resulted in a deadlock situation.

       12  ENOMEM  <u>Cannot</u>  <u>allocate</u>  <u>memory</u>.  The new process image required more memory than was allowed by the
               hardware or by system-imposed memory management constraints.  A lack of swap  space  is  normally
               temporary;  however,  a lack of core is not.  Soft limits may be increased to their corresponding
               hard limits.

       13 EACCES <u>Permission</u> <u>denied</u>.  An attempt was made to access a file in a way forbidden by its file  access
               permissions.

       14  EFAULT  <u>Bad</u>  <u>address</u>.   The  system detected an invalid address in attempting to use an argument of a
               call.

       15 ENOTBLK <u>Block</u> <u>device</u> <u>required</u>.  A block device operation was attempted on a non-block device or file.

       16 EBUSY <u>Device</u> <u>busy</u>.  An attempt to use a system resource which was in use at the time in a manner which
               would have conflicted with the request.

       17 EEXIST <u>File</u> <u>exists</u>.  An existing file was mentioned in an inappropriate context, for instance, as  the
               new link name in a <u><a href="../man2/link.2.html">link</a></u>(2) system call.

       18 EXDEV <u>Cross-device</u> <u>link</u>.  A hard link to a file on another file system was attempted.

       19 ENODEV <u>Operation</u> <u>not</u> <u>supported</u> <u>by</u> <u>device</u>.  An attempt was made to apply an inappropriate function to a
               device, for example, trying to read a write-only device such as a printer.

       20  ENOTDIR  <u>Not</u> <u>a</u> <u>directory</u>.  A component of the specified pathname existed, but it was not a directory,
               when a directory was expected.

       21 EISDIR <u>Is</u> <u>a</u> <u>directory</u>.  An attempt was made to open a directory with write mode specified.

       22 EINVAL <u>Invalid</u> <u>argument</u>.  Some invalid argument was supplied.  (For example, specifying  an  undefined
               signal to a <u><a href="../man3/signal.3.html">signal</a></u>(3) function or a <u><a href="../man2/kill.2.html">kill</a></u>(2) system call).

       23  ENFILE  <u>Too</u> <u>many</u> <u>open</u> <u>files</u> <u>in</u> <u>system</u>.  Maximum number of open files allowable on the system has been
               reached and requests for an open cannot be satisfied until at least one has been closed.

       24 EMFILE <u>Too</u> <u>many</u> <u>open</u> <u>files</u>.  Maximum number of file descriptors allowable  in  the  process  has  been
               reached  and  requests  for  an open cannot be satisfied until at least one has been closed.  The
               <u><a href="../man2/getdtablesize.2.html">getdtablesize</a></u>(2) system call will obtain the current limit.

       25 ENOTTY <u>Inappropriate</u> <u>ioctl</u> <u>for</u> <u>device</u>.  A control function (see <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2)) was attempted for a file  or
               special device for which the operation was inappropriate.

       26  ETXTBSY  <u>Text</u>  <u>file</u> <u>busy</u>.  The new process was a pure procedure (shared text) file which was open for
               writing by another process, or while the pure procedure file was being executed an  <u><a href="../man2/open.2.html">open</a></u>(2)  call
               requested write access.

       27 EFBIG <u>File</u> <u>too</u> <u>large</u>.  The size of a file exceeded the maximum.

       28  ENOSPC  <u>No</u>  <u>space</u>  <u>left</u>  <u>on</u>  <u>device</u>.   A <u><a href="../man2/write.2.html">write</a></u>(2) to an ordinary file, the creation of a directory or
               symbolic link, or the creation of a directory entry failed  because  no  more  disk  blocks  were
               available  on  the  file  system,  or  the allocation of an inode for a newly created file failed
               because no more inodes were available on the file system.

       29 ESPIPE <u>Illegal</u> <u>seek</u>.  An <u><a href="../man2/lseek.2.html">lseek</a></u>(2) system call was issued on a socket, pipe or FIFO.

       30 EROFS <u>Read-only</u> <u>file</u> <u>system</u>.  An attempt was made to modify a file or directory on a file system  that
               was read-only at the time.

       31  EMLINK  <u>Too</u>  <u>many</u>  <u>links</u>.   Maximum allowable hard links to a single file has been exceeded (limit of
               32767 hard links per file).

       32 EPIPE <u>Broken</u> <u>pipe</u>.  A write on a pipe, socket or FIFO for which there is no process to read the data.

       33 EDOM <u>Numerical</u> <u>argument</u> <u>out</u> <u>of</u> <u>domain</u>.  A numerical input argument was outside the defined  domain  of
               the mathematical function.

       34  ERANGE  <u>Result</u>  <u>too</u>  <u>large</u>.  A numerical result of the function was too large to fit in the available
               space (perhaps exceeded precision).

       35 EAGAIN <u>Resource</u> <u>temporarily</u> <u>unavailable</u>.  This is a temporary condition and later calls  to  the  same
               routine may complete normally.

       36  EINPROGRESS  <u>Operation</u>  <u>now</u>  <u>in</u> <u>progress</u>.  An operation that takes a long time to complete (such as a
               <u><a href="../man2/connect.2.html">connect</a></u>(2)) was attempted on a non-blocking object (see <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2)).

       37 EALREADY <u>Operation</u> <u>already</u> <u>in</u> <u>progress</u>.  An operation was attempted  on  a  non-blocking  object  that
               already had an operation in progress.

       38 ENOTSOCK <u>Socket</u> <u>operation</u> <u>on</u> <u>non-socket</u>.  Self-explanatory.

       39  EDESTADDRREQ  <u>Destination</u>  <u>address</u>  <u>required</u>.   A required address was omitted from an operation on a
               socket.

       40 EMSGSIZE <u>Message</u> <u>too</u> <u>long</u>.  A message sent on a socket was larger than the internal message buffer  or
               some other network limit.

       41  EPROTOTYPE  <u>Protocol</u>  <u>wrong</u>  <u>type</u>  <u>for</u>  <u>socket</u>.   A  protocol was specified that does not support the
               semantics of the socket type requested.  For example,  you  cannot  use  the  ARPA  Internet  UDP
               protocol with type SOCK_STREAM.

       42  ENOPROTOOPT  <u>Protocol</u>  <u>not</u>  <u>available</u>.   A  bad  option  or level was specified in a <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2) or
               <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2) call.

       43 EPROTONOSUPPORT <u>Protocol</u> <u>not</u> <u>supported</u>.  The protocol has not been configured into the  system  or  no
               implementation for it exists.

       44  ESOCKTNOSUPPORT  <u>Socket</u>  <u>type</u> <u>not</u> <u>supported</u>.  The support for the socket type has not been configured
               into the system or no implementation for it exists.

       45 EOPNOTSUPP <u>Operation</u> <u>not</u> <u>supported</u>.  The attempted operation is not supported for the type  of  object
               referenced.   Usually  this  occurs when a file descriptor refers to a file or socket that cannot
               support this operation, for example, trying to <u>accept</u> a connection on a datagram socket.

       46 EPFNOSUPPORT <u>Protocol</u> <u>family</u> <u>not</u> <u>supported</u>.  The protocol family has  not  been  configured  into  the
               system or no implementation for it exists.

       47  EAFNOSUPPORT  <u>Address</u>  <u>family</u>  <u>not</u>  <u>supported</u>  <u>by</u>  <u>protocol</u> <u>family</u>.  An address incompatible with the
               requested protocol was used.  For example, you should not necessarily expect to be able to use NS
               addresses with ARPA Internet protocols.

       48 EADDRINUSE <u>Address</u> <u>already</u> <u>in</u> <u>use</u>.  Only one usage of each address is normally permitted.

       49 EADDRNOTAVAIL <u>Can't</u> <u>assign</u> <u>requested</u> <u>address</u>.  Normally results from an attempt  to  create  a  socket
               with an address not on this machine.

       50 ENETDOWN <u>Network</u> <u>is</u> <u>down</u>.  A socket operation encountered a dead network.

       51 ENETUNREACH <u>Network</u> <u>is</u> <u>unreachable</u>.  A socket operation was attempted to an unreachable network.

       52 ENETRESET <u>Network</u> <u>dropped</u> <u>connection</u> <u>on</u> <u>reset</u>.  The host you were connected to crashed and rebooted.

       53  ECONNABORTED  <u>Software</u>  <u>caused</u> <u>connection</u> <u>abort</u>.  A connection abort was caused internal to your host
               machine.

       54 ECONNRESET <u>Connection</u> <u>reset</u> <u>by</u> <u>peer</u>.  A connection was forcibly  closed  by  a  peer.   This  normally
               results from a loss of the connection on the remote socket due to a timeout or a reboot.

       55  ENOBUFS  <u>No</u>  <u>buffer</u>  <u>space</u> <u>available</u>.  An operation on a socket or pipe was not performed because the
               system lacked sufficient buffer space or because a queue was full.

       56 EISCONN <u>Socket</u> <u>is</u> <u>already</u> <u>connected</u>.  A <u><a href="../man2/connect.2.html">connect</a></u>(2) request was made on an  already  connected  socket;
               or,  a <u><a href="../man2/sendto.2.html">sendto</a></u>(2) or <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2) request on a connected socket specified a destination when already
               connected.

       57 ENOTCONN <u>Socket</u> <u>is</u> <u>not</u> <u>connected</u>.  An request to send or  receive  data  was  disallowed  because  the
               socket was not connected and (when sending on a datagram socket) no address was supplied.

       58  ESHUTDOWN <u>Can't</u> <u>send</u> <u>after</u> <u>socket</u> <u>shutdown</u>.  A request to send data was disallowed because the socket
               had already been shut down with a previous <u><a href="../man2/shutdown.2.html">shutdown</a></u>(2) call.

       60 ETIMEDOUT <u>Operation</u> <u>timed</u> <u>out</u>.  A <u><a href="../man2/connect.2.html">connect</a></u>(2) or <u><a href="../man2/send.2.html">send</a></u>(2) request failed because the connected party did
               not properly respond  after  a  period  of  time.   (The  timeout  period  is  dependent  on  the
               communication protocol.)

       61  ECONNREFUSED  <u>Connection</u>  <u>refused</u>.   No  connection could be made because the target machine actively
               refused it.  This usually results from trying to connect to a service that  is  inactive  on  the
               foreign host.

       62  ELOOP  <u>Too</u>  <u>many</u>  <u>levels</u>  <u>of</u>  <u>symbolic</u> <u>links</u>.  A path name lookup involved more than 32 (MAXSYMLINKS)
               symbolic links.

       63 ENAMETOOLONG <u>File</u> <u>name</u> <u>too</u> <u>long</u>.  A component of a path name exceeded  {NAME_MAX}  characters,  or  an
               entire  path  name  exceeded {PATH_MAX} characters.  (See also the description of _PC_NO_TRUNC in
               <u><a href="../man2/pathconf.2.html">pathconf</a></u>(2).)

       64 EHOSTDOWN <u>Host</u> <u>is</u> <u>down</u>.  A socket operation failed because the destination host was down.

       65 EHOSTUNREACH <u>No</u> <u>route</u> <u>to</u> <u>host</u>.  A socket operation was attempted to an unreachable host.

       66 ENOTEMPTY <u>Directory</u> <u>not</u> <u>empty</u>.  A directory with entries other than ‘.’ and ‘..’  was  supplied  to  a
               remove directory or rename call.

       67 EPROCLIM <u>Too</u> <u>many</u> <u>processes</u>.

       68 EUSERS <u>Too</u> <u>many</u> <u>users</u>.  The quota system ran out of table entries.

       69  EDQUOT  <u>Disc</u> <u>quota</u> <u>exceeded</u>.  A <u><a href="../man2/write.2.html">write</a></u>(2) to an ordinary file, the creation of a directory or symbolic
               link, or the creation of a directory entry failed because the user's quota  of  disk  blocks  was
               exhausted, or the allocation of an inode for a newly created file failed because the user's quota
               of inodes was exhausted.

       70  ESTALE  <u>Stale</u>  <u>NFS</u>  <u>file</u>  <u>handle</u>.  An attempt was made to access an open file (on an NFS file system)
               which is now unavailable as referenced by the file descriptor.  This may indicate  the  file  was
               deleted on the NFS server or some other catastrophic event occurred.

       72 EBADRPC <u>RPC</u> <u>struct</u> <u>is</u> <u>bad</u>.  Exchange of RPC information was unsuccessful.

       73  ERPCMISMATCH  <u>RPC</u>  <u>version</u>  <u>wrong</u>.   The version of RPC on the remote peer is not compatible with the
               local version.

       74 EPROGUNAVAIL <u>RPC</u> <u>prog.</u> <u>not</u> <u>avail</u>.  The requested program is not registered on the remote host.

       75 EPROGMISMATCH <u>Program</u> <u>version</u> <u>wrong</u>.  The requested version of the program is  not  available  on  the
               remote host (RPC).

       76  EPROCUNAVAIL  <u>Bad</u>  <u>procedure</u>  <u>for</u>  <u>program</u>.  An RPC call was attempted for a procedure which does not
               exist in the remote program.

       77 ENOLCK <u>No</u> <u>locks</u> <u>available</u>.  A system-imposed limit on  the  number  of  simultaneous  file  locks  was
               reached.

       78 ENOSYS <u>Function</u> <u>not</u> <u>implemented</u>.  Attempted a system call that is not available on this system.

       79  EFTYPE  <u>Inappropriate</u>  <u>file</u> <u>type</u> <u>or</u> <u>format</u>.  The file was the wrong type for the operation, or a data
               file had the wrong format.

       80 EAUTH <u>Authentication</u> <u>error</u>.  Attempted to use an invalid authentication ticket to  mount  a  NFS  file
               system.

       81  ENEEDAUTH  <u>Need</u>  <u>authenticator</u>.   An authentication ticket must be obtained before the given NFS file
               system may be mounted.

       82 EIDRM <u>Identifier</u> <u>removed</u>.  An IPC identifier was removed while the current process was waiting on it.

       83 ENOMSG <u>No</u> <u>message</u> <u>of</u> <u>desired</u> <u>type</u>.  An IPC message queue does not contain a  message  of  the  desired
               type, or a message catalog does not contain the requested message.

       84 EOVERFLOW <u>Value</u> <u>too</u> <u>large</u> <u>to</u> <u>be</u> <u>stored</u> <u>in</u> <u>data</u> <u>type</u>.  A numerical result of the function was too large
               to be stored in the caller provided space.

       85 ECANCELED <u>Operation</u> <u>canceled</u>.  The scheduled operation was canceled.

       86 EILSEQ <u>Illegal</u> <u>byte</u> <u>sequence</u>.  While decoding a multibyte character the function came along an invalid
               or an incomplete sequence of bytes or the given wide character is invalid.

       87 ENOATTR <u>Attribute</u> <u>not</u> <u>found</u>.  The specified extended attribute does not exist.

       88 EDOOFUS <u>Programming</u> <u>error</u>.  A function or API is being abused in a way which could only be detected at
               run-time.

       89 EBADMSG <u>Bad</u> <u>message</u>.  A corrupted message was detected.

       90  EMULTIHOP  <u>Multihop</u>  <u>attempted</u>.   This error code is unused, but present for compatibility with other
               systems.

       91 ENOLINK <u>Link</u> <u>has</u> <u>been</u> <u>severed</u>.  This error code is unused, but present for  compatibility  with  other
               systems.

       92 EPROTO <u>Protocol</u> <u>error</u>.  A device or socket encountered an unrecoverable protocol error.

       93  ENOTCAPABLE <u>Capabilities</u> <u>insufficient</u>.  An operation on a capability file descriptor requires greater
               privilege than the capability allows.

       94 ECAPMODE <u>Not</u> <u>permitted</u> <u>in</u> <u>capability</u> <u>mode</u>.   The  system  call  or  operation  is  not  permitted  for
               capability mode processes.

       95 ENOTRECOVERABLE <u>State</u> <u>not</u> <u>recoverable</u>.  The state protected by a robust mutex is not recoverable.

       96 EOWNERDEAD <u>Previous</u> <u>owner</u> <u>died</u>.  The owner of a robust mutex terminated while holding the mutex lock.

       97  EINTEGRITY  <u>Integrity</u>  <u>check</u>  <u>failed</u>.  An integrity check such as a check-hash or a cross-correlation
               failed.  The integrity error falls between EINVAL that  identifies  errors  in  parameters  to  a
               system  call  and  EIO that identifies errors with the underlying storage media.  It is typically
               raised by intermediate kernel layers such as a filesystem or an  in-kernel  GEOM  subsystem  when
               they  detect  inconsistencies.   Uses include allowing the <u><a href="../man8/mount.8.html">mount</a></u>(8) command to return a different
               exit value to automate the running of <u><a href="../man8/fsck.8.html">fsck</a></u>(8) during a system boot.

</pre><h4><b>DEFINITIONS</b></h4><pre>
       Process ID.
               Each active process in the system is uniquely identified  by  a  non-negative  integer  called  a
               process ID.  The range of this ID is from 0 to 99999.

       Parent process ID
               A new process is created by a currently active process (see <u><a href="../man2/fork.2.html">fork</a></u>(2)).  The parent process ID of a
               process  is  initially  the process ID of its creator.  If the creating process exits, the parent
               process ID of each child is set to the ID of  the  calling  process's  reaper  (see  <u><a href="../man2/procctl.2.html">procctl</a></u>(2)),
               normally <u><a href="../man8/init.8.html">init</a></u>(8).

       Process Group
               Each  active  process is a member of a process group that is identified by a non-negative integer
               called the process group ID.  This is the process ID of the group leader.  This grouping  permits
               the signaling of related processes (see <u><a href="../man4/termios.4.html">termios</a></u>(4)) and the job control mechanisms of <u><a href="../man1/csh.1.html">csh</a></u>(1).

       Session
               A  session  is a set of one or more process groups.  A session is created by a successful call to
               <u><a href="../man2/setsid.2.html">setsid</a></u>(2), which causes the caller to become the only member of the only process group in the new
               session.

       Session leader
               A process that has created a new session by a successful call to <u><a href="../man2/setsid.2.html">setsid</a></u>(2), is known as a session
               leader.  Only a  session  leader  may  acquire  a  terminal  as  its  controlling  terminal  (see
               <u><a href="../man4/termios.4.html">termios</a></u>(4)).

       Controlling process
               A session leader with a controlling terminal is a controlling process.

       Controlling terminal
               A  terminal  that  is  associated  with  a  session is known as the controlling terminal for that
               session and its members.

       Terminal Process Group ID
               A terminal may be acquired by a session leader as its controlling terminal.  Once a  terminal  is
               associated  with  a  session, any of the process groups within the session may be placed into the
               foreground by setting the terminal process group ID  to  the  ID  of  the  process  group.   This
               facility is used to arbitrate between multiple jobs contending for the same terminal; (see <u><a href="../man1/csh.1.html">csh</a></u>(1)
               and <u><a href="../man4/tty.4.html">tty</a></u>(4)).

       Orphaned Process Group
               A  process  group  is  considered  to be <u>orphaned</u> if it is not under the control of a job control
               shell.  More precisely, a process group is orphaned when none of its members has a parent process
               that is in the same session as the group, but is in a different process group.  Note that when  a
               process exits, the parent process for its children is normally changed to be <u><a href="../man8/init.8.html">init</a></u>(8), which is in
               a  separate  session.   Not  all  members  of  an orphaned process group are necessarily orphaned
               processes (those whose creating process has exited).  The process group of a  session  leader  is
               orphaned by definition.

       Real User ID and Real Group ID
               Each user on the system is identified by a positive integer termed the real user ID.

               Each  user  is  also  a  member of one or more groups.  One of these groups is distinguished from
               others and used in implementing accounting facilities.  The  positive  integer  corresponding  to
               this distinguished group is termed the real group ID.

               All  processes  have a real user ID and real group ID.  These are initialized from the equivalent
               attributes of the process that created it.

       Effective User Id, Effective Group Id, and Group Access List
               Access to system resources is governed by two values: the effective user ID, and the group access
               list.  The first member of the group access list is also known as the effective  group  ID.   (In
               POSIX.1,  the  group  access  list  is  known  as  the  set of supplementary group IDs, and it is
               unspecified whether the effective group ID is a member of the list.)

               The effective user ID and effective group ID are initially the process's real user  ID  and  real
               group ID respectively.  Either may be modified through execution of a set-user-ID or set-group-ID
               file (possibly by one its ancestors) (see <u><a href="../man2/execve.2.html">execve</a></u>(2)).  By convention, the effective group ID (the
               first  member  of  the  group access list) is duplicated, so that the execution of a set-group-ID
               program does not result in the loss of the original (real) group ID.

               The group access list is a set of group IDs used  only  in  determining  resource  accessibility.
               Access checks are performed as described below in ``File Access Permissions''.

       Saved Set User ID and Saved Set Group ID
               When  a process executes a new file, the effective user ID is set to the owner of the file if the
               file is set-user-ID, and the effective group ID (first element of the group access list)  is  set
               to  the  group  of the file if the file is set-group-ID.  The effective user ID of the process is
               then recorded as the saved set-user-ID, and the effective group ID of the process is recorded  as
               the saved set-group-ID.  These values may be used to regain those values as the effective user or
               group  ID after reverting to the real ID (see <u><a href="../man2/setuid.2.html">setuid</a></u>(2)).  (In POSIX.1, the saved set-user-ID and
               saved set-group-ID are optional, and are used in setuid and setgid, but this  does  not  work  as
               desired for the super-user.)

       Super-user
               A  process  is  recognized  as  a  <u>super-user</u>  process  and  is granted special privileges if its
               effective user ID is 0.

       Descriptor
               An integer assigned by the system when a file is referenced by  <u><a href="../man2/open.2.html">open</a></u>(2)  or  <u><a href="../man2/dup.2.html">dup</a></u>(2),  or  when  a
               socket  is  created  by  <u><a href="../man2/pipe.2.html">pipe</a></u>(2), <u><a href="../man2/socket.2.html">socket</a></u>(2) or <u><a href="../man2/socketpair.2.html">socketpair</a></u>(2), which uniquely identifies an access
               path to that file or socket from a given process or any of its children.

       File Name
               Names consisting of up to {NAME_MAX} characters may be used to name  an  ordinary  file,  special
               file, or directory.

               These characters may be arbitrary eight-bit values, excluding NUL (ASCII 0) and the ‘/’ character
               (slash, ASCII 47).

               Note that it is generally unwise to use ‘*’, ‘?’, ‘[’ or ‘]’ as part of file names because of the
               special meaning attached to these characters by the shell.

       Path Name
               A path name is a NUL-terminated character string starting with an optional slash ‘/’, followed by
               zero or more directory names separated by slashes, optionally followed by a file name.  The total
               length  of a path name must be less than {PATH_MAX} characters.  (On some systems, this limit may
               be infinite.)

               If a path name begins with a slash, the path search begins at the <u>root</u> directory.  Otherwise, the
               search begins from the current working directory.  A slash by itself names  the  root  directory.
               An empty pathname refers to the current directory.

       Directory
               A  directory  is a special type of file that contains entries that are references to other files.
               Directory entries are called links.  By convention, a directory contains at least two links,  ‘.’
               and  ‘..’,  referred  to as <u>dot</u> and <u>dot-dot</u> respectively.  Dot refers to the directory itself and
               dot-dot refers to its parent directory.

       Root Directory and Current Working Directory
               Each process has associated with it a concept of a root directory and a current working directory
               for the purpose of resolving path name searches.  A process's root directory need not be the root
               directory of the root file system.

       File Access Permissions
               Every file in the file system has a set of access permissions.  These  permissions  are  used  in
               determining  whether  a  process may perform a requested operation on the file (such as opening a
               file for writing).  Access permissions are established at the time a file is created.   They  may
               be changed at some later time through the <u><a href="../man2/chmod.2.html">chmod</a></u>(2) call.

               File  access  is  broken  down  according  to  whether a file may be: read, written, or executed.
               Directory files use the execute permission to control if the directory may be searched.

               File access permissions are interpreted by the system as they apply to three different classes of
               users: the owner of the file, those users in the file's group, anyone else.  Every  file  has  an
               independent  set  of access permissions for each of these classes.  When an access check is made,
               the system decides if permission should be granted by checking the access information  applicable
               to the caller.

               Read, write, and execute/search permissions on a file are granted to a process if:

               The  process's  effective  user  ID is that of the super-user.  (Note: even the super-user cannot
               execute a non-executable file.)

               The process's effective user ID matches the user ID of the  owner  of  the  file  and  the  owner
               permissions allow the access.

               The  process's  effective user ID does not match the user ID of the owner of the file, and either
               the process's effective group ID matches the group ID of the file, or the group ID of the file is
               in the process's group access list, and the group permissions allow the access.

               Neither the effective user ID nor effective group ID and group access list of the  process  match
               the corresponding user ID and group ID of the file, but the permissions for ``other users'' allow
               access.

               Otherwise, permission is denied.

       Sockets and Address Families
               A  socket is an endpoint for communication between processes.  Each socket has queues for sending
               and receiving data.

               Sockets are typed according to their communications properties.  These properties include whether
               messages sent and received at a socket require the name of the partner, whether communication  is
               reliable, the format used in naming message recipients, etc.

               Each  instance of the system supports some collection of socket types; consult <u><a href="../man2/socket.2.html">socket</a></u>(2) for more
               information about the types available and their properties.

               Each instance of the system supports some number  of  sets  of  communications  protocols.   Each
               protocol  set  supports addresses of a certain format.  An Address Family is the set of addresses
               for a specific group of protocols.  Each socket has an address chosen from the address family  in
               which the socket was created.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/intro.3.html">intro</a></u>(3), <u><a href="../man3/perror.3.html">perror</a></u>(3)

Debian                                          September 8, 2016                                       <u><a href="../man2/INTRO.2.html">INTRO</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>