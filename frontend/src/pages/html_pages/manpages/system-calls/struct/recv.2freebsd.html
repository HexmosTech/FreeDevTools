<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>recv, recvfrom, recvmsg, recvmmsg — receive message(s) from a socket</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       recv, recvfrom, recvmsg, recvmmsg — receive message(s) from a socket

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>

       <u>ssize_t</u>
       <b>recv</b>(<u>int</u> <u>s</u>, <u>void</u> <u>*buf</u>, <u>size_t</u> <u>len</u>, <u>int</u> <u>flags</u>);

       <u>ssize_t</u>
       <b>recvfrom</b>(<u>int</u>   <u>s</u>,   <u>void</u>   <u>*buf</u>,   <u>size_t</u>   <u>len</u>,   <u>int</u>   <u>flags</u>,   <u>struct</u>   <u>sockaddr</u>   <u>*</u>   <u>restrict</u>  <u>from</u>,
           <u>socklen_t</u> <u>*</u> <u>restrict</u> <u>fromlen</u>);

       <u>ssize_t</u>
       <b>recvmsg</b>(<u>int</u> <u>s</u>, <u>struct</u> <u>msghdr</u> <u>*msg</u>, <u>int</u> <u>flags</u>);

       <u>ssize_t</u>
       <b>recvmmsg</b>(<u>int</u>    <u>s</u>,    <u>struct</u>    <u>mmsghdr</u>    <u>*</u>    <u>restrict</u>    <u>msgvec</u>,    <u>size_t</u>    <u>vlen</u>,     <u>int</u>     <u>flags</u>,
           <u>const</u> <u>struct</u> <u>timespec</u> <u>*</u> <u>restrict</u> <u>timeout</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>recvfrom</b>(),  <b>recvmsg</b>(),  and <b>recvmmsg</b>() system calls are used to receive messages from a socket, and
       may be used to receive data on a socket whether or not it is connection-oriented.

       If <u>from</u> is not a null pointer and the socket is  not  connection-oriented,  the  source  address  of  the
       message  is  filled  in.  The <u>fromlen</u> argument is a value-result argument, initialized to the size of the
       buffer associated with <u>from</u>, and modified on return to indicate the actual size  of  the  address  stored
       there.

       The  <b>recv</b>()  function  is  normally  used only on a <u>connected</u> socket (see <u><a href="../man2/connect.2.html">connect</a></u>(2)) and is identical to
       <b>recvfrom</b>() with a null pointer passed as its <u>from</u> argument.

       The <b>recvmmsg</b>() function is used to receive multiple messages at a call.   Their  number  is  supplied  by
       <u>vlen</u>.   The  messages are placed in the buffers described by <u>msgvec</u> vector, after reception.  The size of
       each received message is placed in the <u>msg_len</u> field of each element of the vector.  If <u>timeout</u>  is  NULL
       the  call  blocks  until  the data is available for each supplied message buffer.  Otherwise it waits for
       data for the specified amount of time.  If the timeout expired and there is no data received, a  value  0
       is  returned.   The <u><a href="../man2/ppoll.2.html">ppoll</a></u>(2) system call is used to implement the timeout mechanism, before first receive
       is performed.

       The <b>recv</b>(), <b>recvfrom</b>() and <b>recvmsg</b>() return the length of the message on successful  completion,  whereas
       <b>recvmmsg</b>()  returns  the  number  of  received messages.  If a message is too long to fit in the supplied
       buffer, excess bytes may be discarded depending on the type of socket the message is received  from  (see
       <u><a href="../man2/socket.2.html">socket</a></u>(2)).

       If  no  messages  are available at the socket, the receive call waits for a message to arrive, unless the
       socket is non-blocking (see <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2)) in which case the value -1 is  returned  and  the  global  variable
       <u>errno</u>  is  set  to EAGAIN.  The receive calls except <b>recvmmsg</b>() normally return any data available, up to
       the requested amount, rather than waiting for receipt of the full  amount  requested;  this  behavior  is
       affected  by  the  socket-level  options  SO_RCVLOWAT  and  SO_RCVTIMEO  described in <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2).  The
       <b>recvmmsg</b>() function implements this behaviour for each message in the vector.

       The <u><a href="../man2/select.2.html">select</a></u>(2) system call may be used to determine when more data arrives.

       The <u>flags</u> argument to a <b>recv</b>() function is formed by <u>or</u>'ing one or more of the values:

             MSG_OOB             process out-of-band data
             MSG_PEEK            peek at incoming message
             MSG_WAITALL         wait for full request or error
             MSG_DONTWAIT        do not block
             MSG_CMSG_CLOEXEC    set received fds close-on-exec
             MSG_WAITFORONE      do not block after receiving the first message (only for <b>recvmmsg</b>() )

       The MSG_OOB flag requests receipt of out-of-band data that would not  be  received  in  the  normal  data
       stream.   Some  protocols  place  expedited data at the head of the normal data queue, and thus this flag
       cannot be used with such protocols.  The MSG_PEEK flag causes the receive operation to return  data  from
       the beginning of the receive queue without removing that data from the queue.  Thus, a subsequent receive
       call  will  return  the same data.  The MSG_WAITALL flag requests that the operation block until the full
       request is satisfied.  However, the call may still return less data than requested if a signal is caught,
       an error or disconnect occurs, or the next data to be received is of a different type than that returned.
       The MSG_DONTWAIT flag requests the call to  return  when  it  would  block  otherwise.   If  no  data  is
       available,  <u>errno</u>  is  set  to  EAGAIN.   This  flag is not available in ANSI X3.159-1989 (“ANSI C89”) or
       ISO/IEC 9899:1999 (“ISO C99”) compilation mode.  The MSG_WAITFORONE  flag  sets  MSG_DONTWAIT  after  the
       first message has been received.  This flag is only relevant for <b>recvmmsg</b>().

       The  <b>recvmsg</b>() system call uses a <u>msghdr</u> structure to minimize the number of directly supplied arguments.
       This structure has the following form, as defined in &lt;<u>sys/socket.h</u>&gt;:

       struct msghdr {
               void            *msg_name;      /* optional address */
               socklen_t        msg_namelen;   /* size of address */
               struct iovec    *msg_iov;       /* scatter/gather array */
               int              msg_iovlen;    /* # elements in msg_iov */
               void            *msg_control;   /* ancillary data, see below */
               socklen_t        msg_controllen;/* ancillary data buffer len */
               int              msg_flags;     /* flags on received message */
       };

       Here <u>msg_name</u> and <u>msg_namelen</u> specify the source address if the socket is unconnected;  <u>msg_name</u>  may  be
       given  as  a  null  pointer  if  no  names are desired or required.  The <u>msg_iov</u> and <u>msg_iovlen</u> arguments
       describe scatter gather locations, as discussed in <u><a href="../man2/read.2.html">read</a></u>(2).  The <u>msg_control</u> argument, which  has  length
       <u>msg_controllen</u>,  points  to  a  buffer for other protocol control related messages or other miscellaneous
       ancillary data.  The messages are of the form:

       struct cmsghdr {
               socklen_t  cmsg_len;    /* data byte count, including hdr */
               int        cmsg_level;  /* originating protocol */
               int        cmsg_type;   /* protocol-specific type */
       /* followed by
               u_char     cmsg_data[]; */
       };

       As an example, one could use this to learn of changes in the data-stream in XNS/SPP, or in ISO, to obtain
       user-connection-request data by requesting a <b>recvmsg</b>() with no data buffer provided immediately after  an
       <b>accept</b>() system call.

       With AF_UNIX domain sockets, ancillary data can be used to pass file descriptors and process credentials.
       See <u><a href="../man4/unix.4.html">unix</a></u>(4) for details.

       The <u>msg_flags</u> field is set on return according to the message received.  MSG_EOR indicates end-of-record;
       the  data  returned  completed  a record (generally used with sockets of type SOCK_SEQPACKET).  MSG_TRUNC
       indicates that the trailing portion of a datagram was discarded because the datagram was larger than  the
       buffer  supplied.  MSG_CTRUNC indicates that some control data were discarded due to lack of space in the
       buffer for ancillary data.  MSG_OOB is returned to indicate  that  expedited  or  out-of-band  data  were
       received.

       The <b>recvmmsg</b>() system call uses the <u>mmsghdr</u> structure, defined as follows in the &lt;<u>sys/socket.h</u>&gt; header:

       struct mmsghdr {
               struct msghdr    msg_hdr;       /* message header */
               ssize_t          msg_len;       /* message length */
       };

       On data reception the <u>msg_len</u> field is updated to the length of the received message.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       These  calls  except  <b>recvmmsg</b>()  return  the number of bytes received.  <b>recvmmsg</b>() returns the number of
       messages received.  A value of -1 is returned if an error occurred.

</pre><h4><b>ERRORS</b></h4><pre>
       The calls fail if:

       [EBADF]            The argument <u>s</u> is an invalid descriptor.

       [ECONNRESET]       The remote socket end is forcibly closed.

       [ENOTCONN]         The socket is  associated  with  a  connection-oriented  protocol  and  has  not  been
                          connected (see <u><a href="../man2/connect.2.html">connect</a></u>(2) and <u><a href="../man2/accept.2.html">accept</a></u>(2)).

       [ENOTSOCK]         The argument <u>s</u> does not refer to a socket.

       [EMSGSIZE]         The  <b>recvmsg</b>()  system call was used to receive rights (file descriptors) that were in
                          flight on the connection.  However, the receiving program did  not  have  enough  free
                          file  descriptor  slots  to accept them.  In this case the descriptors are closed, any
                          pending data can be returned by another call to <b>recvmsg</b>().

       [EAGAIN]           The socket is marked non-blocking and the receive operation would block, or a  receive
                          timeout had been set and the timeout expired before data were received.

       [EINTR]            The receive was interrupted by delivery of a signal before any data were available.

       [EFAULT]           The receive buffer pointer(s) point outside the process's address space.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2), <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2), <u><a href="../man2/read.2.html">read</a></u>(2), <u><a href="../man2/select.2.html">select</a></u>(2), <u><a href="../man2/socket.2.html">socket</a></u>(2), <u><a href="../man3/CMSG_DATA.3.html">CMSG_DATA</a></u>(3), <u><a href="../man4/unix.4.html">unix</a></u>(4)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>recv</b>() function appeared in 4.2BSD.  The <b>recvmmsg</b>() function appeared in FreeBSD 11.0.

Debian                                           August 19, 2018                                         <u><a href="../man2/RECV.2.html">RECV</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>