<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>timerfd_create, timerfd_settime, timerfd_gettime - timers that notify via file descriptors</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       timerfd_create, timerfd_settime, timerfd_gettime - timers that notify via file descriptors

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/timerfd.h&gt;</b>

       <b>int</b> <b>timerfd_create(int</b> <u>clockid</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

       <b>int</b> <b>timerfd_settime(int</b> <u>fd</u><b>,</b> <b>int</b> <u>flags</u><b>,</b>
                           <b>const</b> <b>struct</b> <b>itimerspec</b> <b>*</b><u>new_value</u><b>,</b>
                           <b>struct</b> <b>itimerspec</b> <b>*_Nullable</b> <u>old_value</u><b>);</b>
       <b>int</b> <b>timerfd_gettime(int</b> <u>fd</u><b>,</b> <b>struct</b> <b>itimerspec</b> <b>*</b><u>curr_value</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  system calls create and operate on a timer that delivers timer expiration notifications via a file
       descriptor.  They provide an alternative  to  the  use  of  <b><a href="../man2/setitimer.2.html">setitimer</a></b>(2)  or  <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2),  with  the
       advantage that the file descriptor may be monitored by <b><a href="../man2/select.2.html">select</a></b>(2), <b><a href="../man2/poll.2.html">poll</a></b>(2), and <b><a href="../man7/epoll.7.html">epoll</a></b>(7).

       The  use  of  these  three system calls is analogous to the use of <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2), <b><a href="../man2/timer_settime.2.html">timer_settime</a></b>(2), and
       <b><a href="../man2/timer_gettime.2.html">timer_gettime</a></b>(2).  (There is no analog of <b><a href="../man2/timer_getoverrun.2.html">timer_getoverrun</a></b>(2), since that functionality  is  provided  by
       <b><a href="../man2/read.2.html">read</a></b>(2), as described below.)

   <b>timerfd_create()</b>
       <b>timerfd_create</b>()  creates  a  new  timer object, and returns a file descriptor that refers to that timer.
       The <u>clockid</u> argument specifies the clock that is used to mark the progress of the timer, and must be  one
       of the following:

       <b>CLOCK_REALTIME</b>
              A settable system-wide real-time clock.

       <b>CLOCK_MONOTONIC</b>
              A nonsettable monotonically increasing clock that measures time from some unspecified point in the
              past that does not change after system startup.

       <b>CLOCK_BOOTTIME</b> (Since Linux 3.15)
              Like   <b>CLOCK_MONOTONIC</b>,   this   is  a  monotonically  increasing  clock.   However,  whereas  the
              <b>CLOCK_MONOTONIC</b> clock does not measure the time while a system is  suspended,  the  <b>CLOCK_BOOTTIME</b>
              clock does include the time during which the system is suspended.  This is useful for applications
              that  need  to be suspend-aware.  <b>CLOCK_REALTIME</b> is not suitable for such applications, since that
              clock is affected by discontinuous changes to the system clock.

       <b>CLOCK_REALTIME_ALARM</b> (since Linux 3.11)
              This clock is like <b>CLOCK_REALTIME</b>, but will wake the system if it is suspended.  The  caller  must
              have the <b>CAP_WAKE_ALARM</b> capability in order to set a timer against this clock.

       <b>CLOCK_BOOTTIME_ALARM</b> (since Linux 3.11)
              This  clock  is like <b>CLOCK_BOOTTIME</b>, but will wake the system if it is suspended.  The caller must
              have the <b>CAP_WAKE_ALARM</b> capability in order to set a timer against this clock.

       See <b><a href="../man2/clock_getres.2.html">clock_getres</a></b>(2) for some further details on the above clocks.

       The current value of each of these clocks can be retrieved using <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2).

       Starting with Linux 2.6.27, the following values may be bitwise ORed in <u>flags</u> to change the  behavior  of
       <b>timerfd_create</b>():

       <b>TFD_NONBLOCK</b>  Set  the <b>O_NONBLOCK</b> file status flag on the open file description (see <b><a href="../man2/open.2.html">open</a></b>(2)) referred to
                     by the new file descriptor.  Using this flag saves extra calls to <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) to  achieve  the
                     same result.

       <b>TFD_CLOEXEC</b>   Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the new file descriptor.  See the description of
                     the <b>O_CLOEXEC</b> flag in <b><a href="../man2/open.2.html">open</a></b>(2) for reasons why this may be useful.

       In Linux versions up to and including 2.6.26, <u>flags</u> must be specified as zero.

   <b>timerfd_settime()</b>
       <b>timerfd_settime</b>() arms (starts) or disarms (stops) the timer referred to by the file descriptor <u>fd</u>.

       The  <u>new_value</u>  argument  specifies  the  initial  expiration and interval for the timer.  The <u>itimerspec</u>
       structure used for this argument is described in <b><a href="../man3type/itimerspec.3type.html">itimerspec</a></b>(3type).

       <u>new_value.it_value</u> specifies the initial expiration of the timer, in seconds  and  nanoseconds.   Setting
       either  field  of  <u>new_value.it_value</u>  to  a  nonzero  value  arms  the  timer.   Setting  both fields of
       <u>new_value.it_value</u> to zero disarms the timer.

       Setting one or both fields of <u>new_value.it_interval</u> to nonzero values specifies the  period,  in  seconds
       and  nanoseconds,  for  repeated  timer  expirations  after  the  initial  expiration.  If both fields of
       <u>new_value.it_interval</u> are zero, the timer expires just once, at the time specified by <u>new_value.it_value</u>.

       By default, the initial expiration time specified in <u>new_value</u> is interpreted  relative  to  the  current
       time  on the timer's clock at the time of the call (i.e., <u>new_value.it_value</u> specifies a time relative to
       the current value of the clock specified by <u>clockid</u>).  An absolute timeout can be selected via the  <u>flags</u>
       argument.

       The <u>flags</u> argument is a bit mask that can include the following values:

       <b>TFD_TIMER_ABSTIME</b>
              Interpret  <u>new_value.it_value</u>  as  an  absolute value on the timer's clock.  The timer will expire
              when the value of the timer's clock reaches the value specified in <u>new_value.it_value</u>.

       <b>TFD_TIMER_CANCEL_ON_SET</b>
              If this flag  is  specified  along  with  <b>TFD_TIMER_ABSTIME</b>  and  the  clock  for  this  timer  is
              <b>CLOCK_REALTIME</b>  or <b>CLOCK_REALTIME_ALARM</b>, then mark this timer as cancelable if the real-time clock
              undergoes a discontinuous change  (<b><a href="../man2/settimeofday.2.html">settimeofday</a></b>(2),  <b><a href="../man2/clock_settime.2.html">clock_settime</a></b>(2),  or  similar).   When  such
              changes  occur,  a  current  or  future  <b><a href="../man2/read.2.html">read</a></b>(2) from the file descriptor will fail with the error
              <b>ECANCELED</b>.

       If the <u>old_value</u> argument is not NULL, then the <u>itimerspec</u> structure that it points to is used to  return
       the  setting  of  the  timer  that  was  current  at  the  time  of  the  call;  see  the  description of
       <b>timerfd_gettime</b>() following.

   <b>timerfd_gettime()</b>
       <b>timerfd_gettime</b>() returns, in <u>curr_value</u>, an <u>itimerspec</u> structure that contains the  current  setting  of
       the timer referred to by the file descriptor <u>fd</u>.

       The  <u>it_value</u>  field returns the amount of time until the timer will next expire.  If both fields of this
       structure are zero, then the timer is currently disarmed.  This field always contains a  relative  value,
       regardless of whether the <b>TFD_TIMER_ABSTIME</b> flag was specified when setting the timer.

       The <u>it_interval</u> field returns the interval of the timer.  If both fields of this structure are zero, then
       the timer is set to expire just once, at the time specified by <u>curr_value.it_value</u>.

   <b>Operating</b> <b>on</b> <b>a</b> <b>timer</b> <b>file</b> <b>descriptor</b>
       The file descriptor returned by <b>timerfd_create</b>() supports the following additional operations:

       <b><a href="../man2/read.2.html">read</a></b>(2)
              If  the  timer  has  already expired one or more times since its settings were last modified using
              <b>timerfd_settime</b>(), or since the last successful <b><a href="../man2/read.2.html">read</a></b>(2), then the buffer given to <b><a href="../man2/read.2.html">read</a></b>(2)  returns
              an  unsigned  8-byte  integer  (<u>uint64_t</u>) containing the number of expirations that have occurred.
              (The returned value is in host byte orderâ€”that is, the native byte order for integers on the  host
              machine.)

              If  no  timer  expirations  have  occurred at the time of the <b><a href="../man2/read.2.html">read</a></b>(2), then the call either blocks
              until the next timer expiration, or fails with the error <b>EAGAIN</b> if the file  descriptor  has  been
              made nonblocking (via the use of the <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) <b>F_SETFL</b> operation to set the <b>O_NONBLOCK</b> flag).

              A <b><a href="../man2/read.2.html">read</a></b>(2) fails with the error <b>EINVAL</b> if the size of the supplied buffer is less than 8 bytes.

              If  the  associated  clock is either <b>CLOCK_REALTIME</b> or <b>CLOCK_REALTIME_ALARM</b>, the timer is absolute
              (<b>TFD_TIMER_ABSTIME</b>),  and  the   flag   <b>TFD_TIMER_CANCEL_ON_SET</b>   was   specified   when   calling
              <b>timerfd_settime</b>(),  then <b><a href="../man2/read.2.html">read</a></b>(2) fails with the error <b>ECANCELED</b> if the real-time clock undergoes a
              discontinuous change.  (This allows the reading application to discover such discontinuous changes
              to the clock.)

              If the associated clock is either <b>CLOCK_REALTIME</b> or <b>CLOCK_REALTIME_ALARM</b>, the  timer  is  absolute
              (<b>TFD_TIMER_ABSTIME</b>),   and  the  flag  <b>TFD_TIMER_CANCEL_ON_SET</b>  was  <u>not</u>  specified  when  calling
              <b>timerfd_settime</b>(), then a discontinuous negative change to the clock (e.g., <b><a href="../man2/clock_settime.2.html">clock_settime</a></b>(2))  may
              cause  <b><a href="../man2/read.2.html">read</a></b>(2)  to  unblock,  but  return  a value of 0 (i.e., no bytes read), if the clock change
              occurs after the time expired, but before the <b><a href="../man2/read.2.html">read</a></b>(2) on the file descriptor.

       <b><a href="../man2/poll.2.html">poll</a></b>(2)
       <b><a href="../man2/select.2.html">select</a></b>(2)
       (and similar)
              The file descriptor is readable (the <b><a href="../man2/select.2.html">select</a></b>(2) <u>readfds</u> argument; the <b><a href="../man2/poll.2.html">poll</a></b>(2) <b>POLLIN</b> flag)  if  one
              or more timer expirations have occurred.

              The  file  descriptor  also  supports  the  other  file-descriptor  multiplexing APIs: <b><a href="../man2/pselect.2.html">pselect</a></b>(2),
              <b><a href="../man2/ppoll.2.html">ppoll</a></b>(2), and <b><a href="../man7/epoll.7.html">epoll</a></b>(7).

       <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)
              The following timerfd-specific command is supported:

              <b>TFD_IOC_SET_TICKS</b> (since Linux 3.17)
                     Adjust the number of timer expirations that have occurred.  The argument is a pointer to  a
                     nonzero  8-byte  integer  (<u>uint64_t</u>*)  containing  the new number of expirations.  Once the
                     number is set, any waiter on the timer is woken up.  The only purpose of this command is to
                     restore the expirations for the purpose of checkpoint/restore.  This operation is available
                     only if the kernel was configured with the <b>CONFIG_CHECKPOINT_RESTORE</b> option.

       <b><a href="../man2/close.2.html">close</a></b>(2)
              When the file descriptor is no longer required it should be closed.   When  all  file  descriptors
              associated  with  the  same timer object have been closed, the timer is disarmed and its resources
              are freed by the kernel.

   <b><a href="../man2/fork.2.html">fork</a>(2)</b> <b>semantics</b>
       After a <b><a href="../man2/fork.2.html">fork</a></b>(2), the child inherits a copy of the file descriptor created by <b>timerfd_create</b>().  The  file
       descriptor refers to the same underlying timer object as the corresponding file descriptor in the parent,
       and <b><a href="../man2/read.2.html">read</a></b>(2)s in the child will return information about expirations of the timer.

   <b><a href="../man2/execve.2.html">execve</a>(2)</b> <b>semantics</b>
       A  file  descriptor  created by <b>timerfd_create</b>() is preserved across <b><a href="../man2/execve.2.html">execve</a></b>(2), and continues to generate
       timer expirations if the timer was armed.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>timerfd_create</b>() returns a new file descriptor.  On error, -1 is returned and <u>errno</u> is set to
       indicate the error.

       <b>timerfd_settime</b>() and <b>timerfd_gettime</b>() return 0 on success; on error they return -1, and  set  <u>errno</u>  to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>timerfd_create</b>() can fail with the following errors:

       <b>EINVAL</b> The <u>clockid</u> is not valid.

       <b>EINVAL</b> <u>flags</u> is invalid; or, in Linux 2.6.26 or earlier, <u>flags</u> is nonzero.

       <b>EMFILE</b> The per-process limit on the number of open file descriptors has been reached.

       <b>ENFILE</b> The system-wide limit on the total number of open files has been reached.

       <b>ENODEV</b> Could not mount (internal) anonymous inode device.

       <b>ENOMEM</b> There was insufficient kernel memory to create the timer.

       <b>EPERM</b>  <u>clockid</u>  was  <b>CLOCK_REALTIME_ALARM</b>  or  <b>CLOCK_BOOTTIME_ALARM</b>  but  the  caller  did  not  have the
              <b>CAP_WAKE_ALARM</b> capability.

       <b>timerfd_settime</b>() and <b>timerfd_gettime</b>() can fail with the following errors:

       <b>EBADF</b>  <u>fd</u> is not a valid file descriptor.

       <b>EFAULT</b> <u>new_value</u>, <u>old_value</u>, or <u>curr_value</u> is not a valid pointer.

       <b>EINVAL</b> <u>fd</u> is not a valid timerfd file descriptor.

       <b>timerfd_settime</b>() can also fail with the following errors:

       <b>ECANCELED</b>
              See NOTES.

       <b>EINVAL</b> <u>new_value</u> is not properly initialized (one  of  the  <u>tv_nsec</u>  falls  outside  the  range  zero  to
              999,999,999).

       <b>EINVAL</b> <u>flags</u> is invalid.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.25, glibc 2.8.

</pre><h4><b>NOTES</b></h4><pre>
       Suppose  the  following  scenario  for <b>CLOCK_REALTIME</b> or <b>CLOCK_REALTIME_ALARM</b> timer that was created with
       <b>timerfd_create</b>():

       (1)  The   timer   has   been   started    (<b>timerfd_settime</b>())    with    the    <b>TFD_TIMER_ABSTIME</b>    and
            <b>TFD_TIMER_CANCEL_ON_SET</b> flags;

       (2)  A discontinuous change (e.g., <b><a href="../man2/settimeofday.2.html">settimeofday</a></b>(2)) is subsequently made to the <b>CLOCK_REALTIME</b> clock; and

       (3)  the  caller  once  more calls <b>timerfd_settime</b>() to rearm the timer (without first doing a <b><a href="../man2/read.2.html">read</a></b>(2) on
            the file descriptor).

       In this case the following occurs:

       â€¢  The <b>timerfd_settime</b>() returns -1 with <u>errno</u> set to <b>ECANCELED</b>.  (This enables the caller to  know  that
          the previous timer was affected by a discontinuous change to the clock.)

       â€¢  The  timer  <u>is</u>  <u>successfully</u>  <u>rearmed</u> with the settings provided in the second <b>timerfd_settime</b>() call.
          (This was probably an implementation accident, but won't be fixed now, in case there are  applications
          that depend on this behaviour.)

</pre><h4><b>BUGS</b></h4><pre>
       Currently, <b>timerfd_create</b>() supports fewer types of clock IDs than <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2).

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  program  creates a timer and then monitors its progress.  The program accepts up to three
       command-line arguments.  The first argument specifies the number of seconds for the initial expiration of
       the timer.  The second argument specifies the interval for the timer, in  seconds.   The  third  argument
       specifies  the  number  of  times  the  program should allow the timer to expire before terminating.  The
       second and third command-line arguments are optional.

       The following shell session demonstrates the use of the program:

           $ <b>a.out</b> <b>3</b> <b>1</b> <b>100</b>
           0.000: timer started
           3.000: read: 1; total=1
           4.000: read: 1; total=2
           <b>^Z</b>                  # type control-Z to suspend the program
           [1]+  Stopped                 ./timerfd3_demo 3 1 100
           $ <b>fg</b>                # Resume execution after a few seconds
           a.out 3 1 100
           9.660: read: 5; total=7
           10.000: read: 1; total=8
           11.000: read: 1; total=9
           <b>^C</b>                  # type control-C to suspend the program

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/inttypes.h">inttypes.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/timerfd.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       static void
       print_elapsed_time(void)
       {
           int                     secs, nsecs;
           static int              first_call = 1;
           struct timespec         curr;
           static struct timespec  start;

           if (first_call) {
               first_call = 0;
               if (clock_gettime(CLOCK_MONOTONIC, &amp;start) == -1)
                   err(EXIT_FAILURE, "clock_gettime");
           }

           if (clock_gettime(CLOCK_MONOTONIC, &amp;curr) == -1)
               err(EXIT_FAILURE, "clock_gettime");

           secs = curr.tv_sec - start.tv_sec;
           nsecs = curr.tv_nsec - start.tv_nsec;
           if (nsecs &lt; 0) {
               secs--;
               nsecs += 1000000000;
           }
           printf("%d.%03d: ", secs, (nsecs + 500000) / 1000000);
       }

       int
       main(int argc, char *argv[])
       {
           int                fd;
           ssize_t            s;
           uint64_t           exp, tot_exp, max_exp;
           struct timespec    now;
           struct itimerspec  new_value;

           if (argc != 2 &amp;&amp; argc != 4) {
               fprintf(stderr, "%s init-secs [interval-secs max-exp]\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           if (clock_gettime(CLOCK_REALTIME, &amp;now) == -1)
               err(EXIT_FAILURE, "clock_gettime");

           /* Create a CLOCK_REALTIME absolute timer with initial
              expiration and interval as specified in command line. */

           new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);
           new_value.it_value.tv_nsec = now.tv_nsec;
           if (argc == 2) {
               new_value.it_interval.tv_sec = 0;
               max_exp = 1;
           } else {
               new_value.it_interval.tv_sec = atoi(argv[2]);
               max_exp = atoi(argv[3]);
           }
           new_value.it_interval.tv_nsec = 0;

           fd = timerfd_create(CLOCK_REALTIME, 0);
           if (fd == -1)
               err(EXIT_FAILURE, "timerfd_create");

           if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &amp;new_value, NULL) == -1)
               err(EXIT_FAILURE, "timerfd_settime");

           print_elapsed_time();
           printf("timer started\n");

           for (tot_exp = 0; tot_exp &lt; max_exp;) {
               s = read(fd, &amp;exp, sizeof(uint64_t));
               if (s != sizeof(uint64_t))
                   err(EXIT_FAILURE, "read");

               tot_exp += exp;
               print_elapsed_time();
               printf("read: %" PRIu64 "; total=%" PRIu64 "\n", exp, tot_exp);
           }

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/eventfd.2.html">eventfd</a></b>(2), <b><a href="../man2/poll.2.html">poll</a></b>(2), <b><a href="../man2/read.2.html">read</a></b>(2), <b><a href="../man2/select.2.html">select</a></b>(2), <b><a href="../man2/setitimer.2.html">setitimer</a></b>(2),  <b><a href="../man2/signalfd.2.html">signalfd</a></b>(2),  <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2),  <b><a href="../man2/timer_gettime.2.html">timer_gettime</a></b>(2),
       <b><a href="../man2/timer_settime.2.html">timer_settime</a></b>(2), <b><a href="../man3/timespec.3.html">timespec</a></b>(3), <b><a href="../man7/epoll.7.html">epoll</a></b>(7), <b><a href="../man7/time.7.html">time</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                  <u><a href="../man2/timerfd_create.2.html">timerfd_create</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>