<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>timer_create - create a POSIX per-process timer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       timer_create - create a POSIX per-process timer

</pre><h4><b>LIBRARY</b></h4><pre>
       Real-time library (<u>librt</u>, <u>-lrt</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;</b>           /* Definition of <b>SIGEV_*</b> constants */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/time.h">time.h</a>&gt;</b>

       <b>int</b> <b>timer_create(clockid_t</b> <u>clockid</u><b>,</b>
                        <b>struct</b> <b>sigevent</b> <b>*_Nullable</b> <b>restrict</b> <u>sevp</u><b>,</b>
                        <b>timer_t</b> <b>*restrict</b> <u>timerid</u><b>);</b>

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>timer_create</b>():
           _POSIX_C_SOURCE &gt;= 199309L

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>timer_create</b>()  creates  a  new  per-process  interval timer.  The ID of the new timer is returned in the
       buffer pointed to by <u>timerid</u>, which must be a non-null pointer.  This ID is unique  within  the  process,
       until the timer is deleted.  The new timer is initially disarmed.

       The <u>clockid</u> argument specifies the clock that the new timer uses to measure time.  It can be specified as
       one of the following values:

       <b>CLOCK_REALTIME</b>
              A settable system-wide real-time clock.

       <b>CLOCK_MONOTONIC</b>
              A nonsettable monotonically increasing clock that measures time from some unspecified point in the
              past that does not change after system startup.

       <b>CLOCK_PROCESS_CPUTIME_ID</b> (since Linux 2.6.12)
              A  clock  that measures (user and system) CPU time consumed by (all of the threads in) the calling
              process.

       <b>CLOCK_THREAD_CPUTIME_ID</b> (since Linux 2.6.12)
              A clock that measures (user and system) CPU time consumed by the calling thread.

       <b>CLOCK_BOOTTIME</b> (Since Linux 2.6.39)
              Like  <b>CLOCK_MONOTONIC</b>,  this  is  a  monotonically  increasing  clock.    However,   whereas   the
              <b>CLOCK_MONOTONIC</b>  clock  does  not measure the time while a system is suspended, the <b>CLOCK_BOOTTIME</b>
              clock does include the time during which the system is suspended.  This is useful for applications
              that need to be suspend-aware.  <b>CLOCK_REALTIME</b> is not suitable for such applications,  since  that
              clock is affected by discontinuous changes to the system clock.

       <b>CLOCK_REALTIME_ALARM</b> (since Linux 3.0)
              This  clock  is like <b>CLOCK_REALTIME</b>, but will wake the system if it is suspended.  The caller must
              have the <b>CAP_WAKE_ALARM</b> capability in order to set a timer against this clock.

       <b>CLOCK_BOOTTIME_ALARM</b> (since Linux 3.0)
              This clock is like <b>CLOCK_BOOTTIME</b>, but will wake the system if it is suspended.  The  caller  must
              have the <b>CAP_WAKE_ALARM</b> capability in order to set a timer against this clock.

       <b>CLOCK_TAI</b> (since Linux 3.10)
              A system-wide clock derived from wall-clock time but counting leap seconds.

       See <b><a href="../man2/clock_getres.2.html">clock_getres</a></b>(2) for some further details on the above clocks.

       As  well  as  the  above  values,  <u>clockid</u>  can  be  specified  as  the  <u>clockid</u>  returned  by  a call to
       <b><a href="../man3/clock_getcpuclockid.3.html">clock_getcpuclockid</a></b>(3) or <b><a href="../man3/pthread_getcpuclockid.3.html">pthread_getcpuclockid</a></b>(3).

       The <u>sevp</u> argument points to a <u>sigevent</u> structure that specifies how the caller should  be  notified  when
       the timer expires.  For the definition and general details of this structure, see <b><a href="../man3type/sigevent.3type.html">sigevent</a></b>(3type).

       The <u>sevp.sigev_notify</u> field can have the following values:

       <b>SIGEV_NONE</b>
              Don't  asynchronously notify when the timer expires.  Progress of the timer can be monitored using
              <b><a href="../man2/timer_gettime.2.html">timer_gettime</a></b>(2).

       <b>SIGEV_SIGNAL</b>
              Upon timer expiration, generate the signal <u>sigev_signo</u> for the process.  See  <b><a href="../man3type/sigevent.3type.html">sigevent</a></b>(3type)  for
              general  details.   The  <u>si_code</u> field of the <u>siginfo_t</u> structure will be set to <b>SI_TIMER</b>.  At any
              point  in  time,  at  most  one  signal  is  queued  to  the  process  for  a  given  timer;   see
              <b><a href="../man2/timer_getoverrun.2.html">timer_getoverrun</a></b>(2) for more details.

       <b>SIGEV_THREAD</b>
              Upon  timer  expiration,  invoke  <u>sigev_notify_function</u>  as if it were the start function of a new
              thread.  See <b><a href="../man3type/sigevent.3type.html">sigevent</a></b>(3type) for details.

       <b>SIGEV_THREAD_ID</b> (Linux-specific)
              As  for  <b>SIGEV_SIGNAL</b>,  but  the  signal  is  targeted  at  the  thread  whose  ID  is  given   in
              <u>sigev_notify_thread_id</u>,  which  must  be  a  thread  in  the  same  process  as  the  caller.  The
              <u>sigev_notify_thread_id</u> field specifies a kernel thread ID, that is, the value returned by <b><a href="../man2/clone.2.html">clone</a></b>(2)
              or <b><a href="../man2/gettid.2.html">gettid</a></b>(2).  This flag is intended only for use by threading libraries.

       Specifying <u>sevp</u> as NULL is  equivalent  to  specifying  a  pointer  to  a  <u>sigevent</u>  structure  in  which
       <u>sigev_notify</u> is <b>SIGEV_SIGNAL</b>, <u>sigev_signo</u> is <b>SIGALRM</b>, and <u>sigev_value.sival_int</u> is the timer ID.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success, <b>timer_create</b>() returns 0, and the ID of the new timer is placed in <u>*timerid</u>.  On failure, -1
       is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EAGAIN</b> Temporary error during kernel allocation of timer structures.

       <b>EINVAL</b> Clock ID, <u>sigev_notify</u>, <u>sigev_signo</u>, or <u>sigev_notify_thread_id</u> is invalid.

       <b>ENOMEM</b> Could not allocate memory.

       <b>ENOTSUP</b>
              The kernel does not support creating a timer against this <u>clockid</u>.

       <b>EPERM</b>  <u>clockid</u> was  <b>CLOCK_REALTIME_ALARM</b>  or  <b>CLOCK_BOOTTIME_ALARM</b>  but  the  caller  did  not  have  the
              <b>CAP_WAKE_ALARM</b> capability.

</pre><h4><b>VERSIONS</b></h4><pre>
   <b>C</b> <b>library/kernel</b> <b>differences</b>
       Part of the implementation of the POSIX timers API is provided by glibc.  In particular:

       •  Much of the functionality for <b>SIGEV_THREAD</b> is implemented within glibc, rather than the kernel.  (This
          is  necessarily so, since the thread involved in handling the notification is one that must be managed
          by the C library POSIX threads implementation.)  Although the notification delivered to the process is
          via a thread, internally the NPTL implementation uses a <u>sigev_notify</u> value  of  <b>SIGEV_THREAD_ID</b>  along
          with a real-time signal that is reserved by the implementation (see <b><a href="../man7/nptl.7.html">nptl</a></b>(7)).

       •  The  implementation  of  the default case where <u>evp</u> is NULL is handled inside glibc, which invokes the
          underlying system call with a suitably populated <u>sigevent</u> structure.

       •  The timer IDs presented at user level are maintained by glibc, which maps these IDs to the  timer  IDs
          employed by the kernel.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.6.  POSIX.1-2001.

       Prior  to  Linux 2.6, glibc provided an incomplete user-space implementation (<b>CLOCK_REALTIME</b> timers only)
       using POSIX threads, and before glibc 2.17, the implementation falls back to this  technique  on  systems
       running kernels older than Linux 2.6.

</pre><h4><b>NOTES</b></h4><pre>
       A program may create multiple interval timers using <b>timer_create</b>().

       Timers are not inherited by the child of a <b><a href="../man2/fork.2.html">fork</a></b>(2), and are disarmed and deleted during an <b><a href="../man2/execve.2.html">execve</a></b>(2).

       The  kernel  preallocates  a  "queued  real-time  signal"  for  each  timer created using <b>timer_create</b>().
       Consequently, the number of timers is limited by the <b>RLIMIT_SIGPENDING</b> resource limit (see <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2)).

       The timers created by <b>timer_create</b>() are commonly known as "POSIX (interval) timers".  The  POSIX  timers
       API consists of the following interfaces:

       <b>timer_create</b>()
              Create a timer.

       <b><a href="../man2/timer_settime.2.html">timer_settime</a></b>(2)
              Arm (start) or disarm (stop) a timer.

       <b><a href="../man2/timer_gettime.2.html">timer_gettime</a></b>(2)
              Fetch  the time remaining until the next expiration of a timer, along with the interval setting of
              the timer.

       <b><a href="../man2/timer_getoverrun.2.html">timer_getoverrun</a></b>(2)
              Return the overrun count for the last timer expiration.

       <b><a href="../man2/timer_delete.2.html">timer_delete</a></b>(2)
              Disarm and delete a timer.

       Since Linux 3.10, the <u><a href="file:/proc/">/proc/</a></u>pid<u>/timers</u> file can be used to list the POSIX timers for the process with PID
       <u>pid</u>.  See <b><a href="../man5/proc.5.html">proc</a></b>(5) for further information.

       Since Linux 4.10, support for POSIX timers is a configurable option that is enabled by  default.   Kernel
       support can be disabled via the <b>CONFIG_POSIX_TIMERS</b> option.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program  below takes two arguments: a sleep period in seconds, and a timer frequency in nanoseconds.
       The program establishes a handler for the signal it uses for the timer, blocks that signal,  creates  and
       arms  a timer that expires with the given frequency, sleeps for the specified number of seconds, and then
       unblocks the timer signal.  Assuming that the timer expired at least once while the  program  slept,  the
       signal  handler  will be invoked, and the handler displays some information about the timer notification.
       The program terminates after one invocation of the signal handler.

       In the following example run, the program sleeps for  1  second,  after  creating  a  timer  that  has  a
       frequency  of 100 nanoseconds.  By the time the signal is unblocked and delivered, there have been around
       ten million overruns.

           $ <b>./a.out</b> <b>1</b> <b>100</b>
           Establishing handler for signal 34
           Blocking signal 34
           timer ID is 0x804c008
           Sleeping for 1 seconds
           Unblocking signal 34
           Caught signal 34
               sival_ptr = 0xbfb174f4;     *sival_ptr = 0x804c008
               overrun count = 10004886

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       #define CLOCKID CLOCK_REALTIME
       #define SIG SIGRTMIN

       #define <a href="../manmsg/errExit.msg.html">errExit</a>(msg)    do { <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); \
                               } while (0)

       static void
       print_siginfo(siginfo_t *si)
       {
           int      or;
           timer_t  *tidp;

           tidp = si-&gt;si_value.sival_ptr;

           printf("    sival_ptr = %p; ", si-&gt;si_value.sival_ptr);
           printf("    *sival_ptr = %#jx\n", (uintmax_t) *tidp);

           or = timer_getoverrun(*tidp);
           if (or == -1)
               errExit("timer_getoverrun");
           else
               printf("    overrun count = %d\n", or);
       }

       static void
       handler(int sig, siginfo_t *si, void *uc)
       {
           /* Note: calling printf() from a signal handler is not safe
              (and should not be done in production programs), since
              printf() is not async-signal-safe; see <a href="../man7/signal-safety.7.html">signal-safety</a>(7).
              Nevertheless, we use printf() here as a simple way of
              showing that the handler was called. */

           printf("Caught signal %d\n", sig);
           print_siginfo(si);
           signal(sig, SIG_IGN);
       }

       int
       main(int argc, char *argv[])
       {
           timer_t            timerid;
           sigset_t           mask;
           long long          freq_nanosecs;
           struct sigevent    sev;
           struct sigaction   sa;
           struct itimerspec  its;

           if (argc != 3) {
               fprintf(stderr, "Usage: %s &lt;sleep-secs&gt; &lt;freq-nanosecs&gt;\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           /* Establish handler for timer signal. */

           printf("Establishing handler for signal %d\n", SIG);
           sa.sa_flags = SA_SIGINFO;
           sa.sa_sigaction = handler;
           sigemptyset(&amp;sa.sa_mask);
           if (sigaction(SIG, &amp;sa, NULL) == -1)
               errExit("sigaction");

           /* Block timer signal temporarily. */

           printf("Blocking signal %d\n", SIG);
           sigemptyset(&amp;mask);
           sigaddset(&amp;mask, SIG);
           if (sigprocmask(SIG_SETMASK, &amp;mask, NULL) == -1)
               errExit("sigprocmask");

           /* Create the timer. */

           sev.sigev_notify = SIGEV_SIGNAL;
           sev.sigev_signo = SIG;
           sev.sigev_value.sival_ptr = &amp;timerid;
           if (timer_create(CLOCKID, &amp;sev, &amp;timerid) == -1)
               errExit("timer_create");

           printf("timer ID is %#jx\n", (uintmax_t) timerid);

           /* Start the timer. */

           freq_nanosecs = atoll(argv[2]);
           its.it_value.tv_sec = freq_nanosecs / 1000000000;
           its.it_value.tv_nsec = freq_nanosecs % 1000000000;
           its.it_interval.tv_sec = its.it_value.tv_sec;
           its.it_interval.tv_nsec = its.it_value.tv_nsec;

           if (timer_settime(timerid, 0, &amp;its, NULL) == -1)
                errExit("timer_settime");

           /* Sleep for a while; meanwhile, the timer may expire
              multiple times. */

           printf("Sleeping for %d seconds\n", atoi(argv[1]));
           sleep(atoi(argv[1]));

           /* Unlock the timer signal, so that timer notification
              can be delivered. */

           printf("Unblocking signal %d\n", SIG);
           if (sigprocmask(SIG_UNBLOCK, &amp;mask, NULL) == -1)
               errExit("sigprocmask");

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2), <b><a href="../man2/setitimer.2.html">setitimer</a></b>(2), <b><a href="../man2/timer_delete.2.html">timer_delete</a></b>(2), <b><a href="../man2/timer_getoverrun.2.html">timer_getoverrun</a></b>(2), <b><a href="../man2/timer_settime.2.html">timer_settime</a></b>(2),
       <b><a href="../man2/timerfd_create.2.html">timerfd_create</a></b>(2), <b><a href="../man3/clock_getcpuclockid.3.html">clock_getcpuclockid</a></b>(3), <b><a href="../man3/pthread_getcpuclockid.3.html">pthread_getcpuclockid</a></b>(3), <b><a href="../man7/pthreads.7.html">pthreads</a></b>(7), <b><a href="../man3type/sigevent.3type.html">sigevent</a></b>(3type),
       <b><a href="../man7/signal.7.html">signal</a></b>(7), <b><a href="../man7/time.7.html">time</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                    <u><a href="../man2/timer_create.2.html">timer_create</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>