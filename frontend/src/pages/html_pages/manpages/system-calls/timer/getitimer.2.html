<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>getitimer, setitimer - get or set value of an interval timer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       getitimer, setitimer - get or set value of an interval timer

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/time.h&gt;</b>

       <b>int</b> <b>getitimer(int</b> <u>which</u><b>,</b> <b>struct</b> <b>itimerval</b> <b>*</b><u>curr_value</u><b>);</b>
       <b>int</b> <b>setitimer(int</b> <u>which</u><b>,</b> <b>const</b> <b>struct</b> <b>itimerval</b> <b>*restrict</b> <u>new_value</u><b>,</b>
                     <b>struct</b> <b>itimerval</b> <b>*_Nullable</b> <b>restrict</b> <u>old_value</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These system calls provide access to interval timers, that is, timers that initially expire at some point
       in  the  future,  and  (optionally)  at  regular intervals after that.  When a timer expires, a signal is
       generated for the calling process, and the timer is reset to the specified interval (if the  interval  is
       nonzero).

       Three  types  of  timers—specified  via  the  <u>which</u> argument—are provided, each of which counts against a
       different clock and generates a different signal on timer expiration:

       <b>ITIMER_REAL</b>
              This timer counts down in real (i.e., wall clock) time.  At each expiration, a <b>SIGALRM</b>  signal  is
              generated.

       <b>ITIMER_VIRTUAL</b>
              This  timer  counts down against the user-mode CPU time consumed by the process.  (The measurement
              includes CPU time consumed by all threads in the process.)  At each expiration, a <b>SIGVTALRM</b> signal
              is generated.

       <b>ITIMER_PROF</b>
              This timer counts down against the total (i.e., both user and system) CPU  time  consumed  by  the
              process.   (The  measurement  includes  CPU time consumed by all threads in the process.)  At each
              expiration, a <b>SIGPROF</b> signal is generated.

              In conjunction with <b>ITIMER_VIRTUAL</b>, this timer can be used to profile user  and  system  CPU  time
              consumed by the process.

       A process has only one of each of the three types of timers.

       Timer values are defined by the following structures:

           struct itimerval {
               struct timeval it_interval; /* Interval for periodic timer */
               struct timeval it_value;    /* Time until next expiration */
           };

           struct timeval {
               time_t      tv_sec;         /* seconds */
               suseconds_t tv_usec;        /* microseconds */
           };

   <b>getitimer()</b>
       The  function  <b>getitimer</b>() places the current value of the timer specified by <u>which</u> in the buffer pointed
       to by <u>curr_value</u>.

       The <u>it_value</u> substructure is populated with the amount of time remaining until the next expiration of the
       specified timer.  This value changes as the timer counts down, and will be reset to <u>it_interval</u> when  the
       timer expires.  If both fields of <u>it_value</u> are zero, then this timer is currently disarmed (inactive).

       The  <u>it_interval</u>  substructure  is  populated with the timer interval.  If both fields of <u>it_interval</u> are
       zero, then this is a single-shot timer (i.e., it expires just once).

   <b>setitimer()</b>
       The function <b>setitimer</b>() arms or disarms the timer specified by <u>which</u>, by setting the timer to the  value
       specified by <u>new_value</u>.  If <u>old_value</u> is non-NULL, the buffer it points to is used to return the previous
       value of the timer (i.e., the same information that is returned by <b>getitimer</b>()).

       If  either  field  in  <u>new_value.it_value</u>  is nonzero, then the timer is armed to initially expire at the
       specified time.  If both fields in <u>new_value.it_value</u> are zero, then the timer is disarmed.

       The <u>new_value.it_interval</u> field specifies the new interval for the timer; if both of  its  subfields  are
       zero, the timer is single-shot.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, zero is returned.  On error, -1 is returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> <u>new_value</u>, <u>old_value</u>, or <u>curr_value</u> is not valid a pointer.

       <b>EINVAL</b> <u>which</u>  is  not  one of <b>ITIMER_REAL</b>, <b>ITIMER_VIRTUAL</b>, or <b>ITIMER_PROF</b>; or (since Linux 2.6.22) one of
              the <u>tv_usec</u> fields in the structure pointed to by <u>new_value</u> contains a value outside the range [0,
              999999].

</pre><h4><b>VERSIONS</b></h4><pre>
       The standards are silent on the meaning of the call:

           setitimer(which, NULL, &amp;old_value);

       Many systems (Solaris, the BSDs, and perhaps others) treat this as equivalent to:

           getitimer(which, &amp;old_value);

       In Linux, this is treated as being equivalent to a call in which the <u>new_value</u> fields are zero; that  is,
       the timer is disabled.  <u>Don't</u> <u>use</u> <u>this</u> <u>Linux</u> <u>misfeature</u>: it is nonportable and unnecessary.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001,  SVr4,  4.4BSD  (this  call  first appeared in 4.2BSD).  POSIX.1-2008 marks <b>getitimer</b>() and
       <b>setitimer</b>() obsolete, recommending the use of the POSIX timers API  (<b><a href="../man2/timer_gettime.2.html">timer_gettime</a></b>(2),  <b><a href="../man2/timer_settime.2.html">timer_settime</a></b>(2),
       etc.) instead.

</pre><h4><b>NOTES</b></h4><pre>
       Timers  will  never  expire  before the requested time, but may expire some (short) time afterward, which
       depends on the system timer resolution and on the system load; see <b><a href="../man7/time.7.html">time</a></b>(7).  (But see  BUGS  below.)   If
       the  timer  expires  while  the  process  is  active (always true for <b>ITIMER_VIRTUAL</b>), the signal will be
       delivered immediately when generated.

       A child created via <b><a href="../man2/fork.2.html">fork</a></b>(2) does not inherit its parent's interval timers.  Interval timers are preserved
       across an <b><a href="../man2/execve.2.html">execve</a></b>(2).

       POSIX.1 leaves the interaction between <b>setitimer</b>() and  the  three  interfaces  <b><a href="../man2/alarm.2.html">alarm</a></b>(2),  <b><a href="../man3/sleep.3.html">sleep</a></b>(3),  and
       <b><a href="../man3/usleep.3.html">usleep</a></b>(3) unspecified.

</pre><h4><b>BUGS</b></h4><pre>
       The generation and delivery of a signal are distinct, and only one instance of each of the signals listed
       above may be pending for a process.  Under very heavy loading, an <b>ITIMER_REAL</b> timer may expire before the
       signal from a previous expiration has been delivered.  The second signal in such an event will be lost.

       Before  Linux  2.6.16,  timer values are represented in jiffies.  If a request is made set a timer with a
       value whose jiffies representation exceeds <b>MAX_SEC_IN_JIFFIES</b> (defined in <u>include/linux/jiffies.h</u>),  then
       the  timer  is  silently  truncated to this ceiling value.  On Linux/i386 (where, since Linux 2.6.13, the
       default jiffy is 0.004 seconds), this means that the ceiling value for a  timer  is  approximately  99.42
       days.   Since  Linux  2.6.16,  the  kernel  uses  a different internal representation for times, and this
       ceiling is removed.

       On certain systems (including i386), Linux kernels before Linux 2.6.12 have  a  bug  which  will  produce
       premature  timer  expirations  of  up  to one jiffy under some circumstances.  This bug is fixed in Linux
       2.6.12.

       POSIX.1-2001 says that <b>setitimer</b>() should fail if a <u>tv_usec</u> value is specified that  is  outside  of  the
       range  [0, 999999].  However, up to and including Linux 2.6.21, Linux does not give an error, but instead
       silently adjusts the corresponding  seconds  value  for  the  timer.   From  Linux  2.6.22  onward,  this
       nonconformance has been repaired: an improper <u>tv_usec</u> value results in an <b>EINVAL</b> error.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2), <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2), <b><a href="../man2/signal.2.html">signal</a></b>(2), <b><a href="../man2/timer_create.2.html">timer_create</a></b>(2), <b><a href="../man2/timerfd_create.2.html">timerfd_create</a></b>(2), <b><a href="../man7/time.7.html">time</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                       <u><a href="../man2/getitimer.2.html">getitimer</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>