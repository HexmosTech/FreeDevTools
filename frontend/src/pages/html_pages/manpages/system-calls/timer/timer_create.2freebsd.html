<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>timer_create — create a per-process timer (REALTIME)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       timer_create — create a per-process timer (REALTIME)

</pre><h4><b>LIBRARY</b></h4><pre>
       POSIX Real-time Library (librt, -lrt)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/time.h">time.h</a>&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;</b>

       <u>int</u>
       <b>timer_create</b>(<u>clockid_t</u> <u>clockid</u>, <u>struct</u> <u>sigevent</u> <u>*restrict</u> <u>evp</u>, <u>timer_t</u> <u>*restrict</u> <u>timerid</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>timer_create</b>()  system  call creates a per-process timer using the specified clock, <u>clock_id</u>, as the
       timing base.  The <b>timer_create</b>() system call returns, in the location referenced by <u>timerid</u>, a  timer  ID
       of type <u>timer_t</u> used to identify the timer in timer requests.  This timer ID is unique within the calling
       process  until  the timer is deleted.  The particular clock, <u>clock_id</u>, is defined in &lt;<u>time.h</u>&gt;.  The timer
       whose ID is returned is in a disarmed state upon return from <b>timer_create</b>().

       The <u>evp</u> argument, if non-NULL, points  to  a  <u>sigevent</u>  structure.   This  structure,  allocated  by  the
       application, defines the asynchronous notification to occur when the timer expires.

       If  <u>evp-&gt;sigev_notify</u> is SIGEV_SIGNO or SIGEV_THREAD_ID, the signal specified in <u>evp-&gt;sigev_signo</u> will be
       sent to the calling process (SIGEV_SIGNO) or to the thread whose LWP  ID  is  <u>evp-&gt;sigev_notify_thread_id</u>
       (SIGEV_THREAD_ID).  The information for the queued signal will include:

       <b>Member</b>      <b>Value</b>
       <u>si_code</u>     SI_TIMER
       <u>si_value</u>    the value stored in <u>evp-&gt;sigev_value</u>
       <u>si_timerid</u>  timer ID
       <u>si_overrun</u>  timer overrun count
       <u>si_errno</u>    If timer overrun is {DELAYTIMER_MAX}, an error code defined in &lt;<u>errno.h</u>&gt;

       If  the  <u>evp</u>  argument is NULL, the effect is as if the <u>evp</u> argument pointed to a <u>sigevent</u> structure with
       the <u>sigev_notify</u> member having the value SIGEV_SIGNAL, the <u>sigev_signo</u> having  a  default  signal  number
       (SIGALRM), and the <u>sigev_value</u> member having the value of the timer ID.

       This implementation supports a <u>clock_id</u> of CLOCK_REALTIME or CLOCK_MONOTONIC.

       If  <u>evp-&gt;sigev_notify</u>  is  SIGEV_THREAD  and  <u>sev-&gt;sigev_notify_attributes</u>  is not NULL, if the attribute
       pointed  to  by  <u>sev-&gt;sigev_notify_attributes</u>  has  a  thread  stack  address  specified  by  a  call  to
       <b>pthread_attr_setstack</b>()  or  <b>pthread_attr_setstackaddr</b>(),  the  results  are unspecified if the signal is
       generated more than once.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       If the call succeeds, <b>timer_create</b>() returns zero and updates the location referenced  by  <u>timerid</u>  to  a
       <u>timer_t</u>, which can be passed to the per-process timer calls.  If an error occurs, the system call returns
       a  value  of  -1  and  the  global  variable <u>errno</u> is set to indicate the error.  The value of <u>timerid</u> is
       undefined if an error occurs.

</pre><h4><b>ERRORS</b></h4><pre>
       The <b>timer_create</b>() system call will fail if:

       [EAGAIN]           The calling process has already created all of  the  timers  it  is  allowed  by  this
                          implementation.

       [EINVAL]           The specified clock ID is not supported.

       [EINVAL]           The specified asynchronous notification method is not supported.

       [EFAULT]           Any  arguments  point  outside  the  allocated  address  space  or  there  is a memory
                          protection fault.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/clock_getres.2.html">clock_getres</a></u>(2), <u><a href="../man2/timer_delete.2.html">timer_delete</a></u>(2), <u><a href="../man2/timer_getoverrun.2.html">timer_getoverrun</a></u>(2), <u><a href="../man3/sigevent.3.html">sigevent</a></u>(3), <u><a href="../man3/siginfo.3.html">siginfo</a></u>(3)

</pre><h4><b>STANDARDS</b></h4><pre>
       The <b>timer_create</b>() system call conforms to IEEE Std 1003.1-2004 (“POSIX.1”).

</pre><h4><b>HISTORY</b></h4><pre>
       Support for POSIX per-process timer first appeared in FreeBSD 7.0.

Debian                                            July 15, 2016                                  <u><a href="../man2/TIMER_CREATE.2.html">TIMER_CREATE</a></u>(2)
</pre>
 </div>
</div></section>
</div>
</body>
</html>