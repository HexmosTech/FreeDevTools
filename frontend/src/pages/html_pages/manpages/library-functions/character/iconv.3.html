<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iconv - perform character set conversion</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       iconv - perform character set conversion

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/iconv.h">iconv.h</a>&gt;</b>

       <b>size_t</b> <b>iconv(iconv_t</b> <u>cd</u><b>,</b>
                    <b>char</b> <b>**restrict</b> <u>inbuf</u><b>,</b> <b>size_t</b> <b>*restrict</b> <u>inbytesleft</u><b>,</b>
                    <b>char</b> <b>**restrict</b> <u>outbuf</u><b>,</b> <b>size_t</b> <b>*restrict</b> <u>outbytesleft</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>iconv</b>()  function  converts  a  sequence  of  characters  in one character encoding to a sequence of
       characters in another character encoding.  The <u>cd</u> argument is a conversion descriptor, previously created
       by a call to <b><a href="../man3/iconv_open.3.html">iconv_open</a></b>(3); the conversion descriptor defines the character encodings that  <b>iconv</b>()  uses
       for  the  conversion.  The <u>inbuf</u> argument is the address of a variable that points to the first character
       of the input sequence; <u>inbytesleft</u> indicates the number of bytes in that buffer.  The <u>outbuf</u> argument  is
       the  address  of  a  variable  that points to the first byte available in the output buffer; <u>outbytesleft</u>
       indicates the number of bytes available in the output buffer.

       The main case is when <u>inbuf</u> is not NULL and <u>*inbuf</u> is not NULL.   In  this  case,  the  <b>iconv</b>()  function
       converts  the multibyte sequence starting at <u>*inbuf</u> to a multibyte sequence starting at <u>*outbuf</u>.  At most
       <u>*inbytesleft</u> bytes, starting at <u>*inbuf</u>, will be read.  At most <u>*outbytesleft</u> bytes, starting at  <u>*outbuf</u>,
       will be written.

       The  <b>iconv</b>()  function  converts  one multibyte character at a time, and for each character conversion it
       increments <u>*inbuf</u> and decrements <u>*inbytesleft</u> by the number  of  converted  input  bytes,  it  increments
       <u>*outbuf</u>  and  decrements  <u>*outbytesleft</u>  by  the  number  of  converted  output bytes, and it updates the
       conversion state contained in <u>cd</u>.  If the character encoding  of  the  input  is  stateful,  the  <b>iconv</b>()
       function  can  also  convert  a  sequence  of  input  bytes  to an update to the conversion state without
       producing any output bytes; such input is called a <u>shift</u> <u>sequence</u>.  The  conversion  can  stop  for  five
       reasons:

       •  An  invalid multibyte sequence is encountered in the input.  In this case, it sets <u>errno</u> to <b>EILSEQ</b> and
          returns <u>(size_t)</u> <u>-1</u>.  <u>*inbuf</u> is left pointing to the beginning of the invalid multibyte sequence.

       •  A multibyte sequence is encountered that is valid but that  cannot  be  translated  to  the  character
          encoding  of  the  output.   This  condition  depends  on  the  implementation  and  on the conversion
          descriptor.  In the GNU C library and GNU libiconv, if <u>cd</u> was created without the suffix <b>//TRANSLIT</b> or
          <b>//IGNORE</b>, the conversion  is  strict:  lossy  conversions  produce  this  condition.   If  the  suffix
          <b>//TRANSLIT</b>  was  specified,  transliteration  can  avoid  this condition in some cases.  In the musl C
          library, this condition cannot occur because a conversion to <b>'*'</b>  is  used  as  a  fallback.   In  the
          FreeBSD, NetBSD, and Solaris implementations of <b>iconv</b>(), this condition cannot occur either, because a
          conversion to <b>'?'</b> is used as a fallback.  When this condition is met, <b>iconv</b>() sets <u>errno</u> to <b>EILSEQ</b> and
          returns  <u>(size_t)</u> <u>-1</u>.   <u>*inbuf</u>  is  left  pointing  to  the  beginning  of the unconvertible multibyte
          sequence.

       •  The input byte sequence has been entirely converted, that is, <u>*inbytesleft</u> has gone  down  to  0.   In
          this case, <b>iconv</b>() returns the number of nonreversible conversions performed during this call.

       •  An  incomplete  multibyte sequence is encountered in the input, and the input byte sequence terminates
          after it.  In this case, it sets <u>errno</u> to <b>EINVAL</b> and returns <u>(size_t)</u> <u>-1</u>.  <u>*inbuf</u> is left pointing  to
          the beginning of the incomplete multibyte sequence.

       •  The  output  buffer has no more room for the next converted character.  In this case, it sets <u>errno</u> to
          <b>E2BIG</b> and returns <u>(size_t)</u> <u>-1</u>.

       A different case is when <u>inbuf</u> is NULL or <u>*inbuf</u> is NULL, but <u>outbuf</u> is not NULL and <u>*outbuf</u> is not NULL.
       In this case, the <b>iconv</b>() function attempts to set <u>cd</u>'s conversion state to the initial state and store a
       corresponding shift sequence at <u>*outbuf</u>.  At most <u>*outbytesleft</u>  bytes,  starting  at  <u>*outbuf</u>,  will  be
       written.   If  the  output  buffer  has  no more room for this reset sequence, it sets <u>errno</u> to <b>E2BIG</b> and
       returns <u>(size_t)</u> <u>-1</u>.  Otherwise, it increments <u>*outbuf</u> and decrements  <u>*outbytesleft</u>  by  the  number  of
       bytes written.

       A  third  case  is  when <u>inbuf</u> is NULL or <u>*inbuf</u> is NULL, and <u>outbuf</u> is NULL or <u>*outbuf</u> is NULL.  In this
       case, the <b>iconv</b>() function sets <u>cd</u>'s conversion state to the initial state.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <b>iconv</b>() function returns the number of characters converted in a nonreversible way during this  call;
       reversible  conversions are not counted.  In case of error, <b>iconv</b>() returns <u>(size_t)</u> <u>-1</u> and sets <u>errno</u> to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The following errors can occur, among others:

       <b>E2BIG</b>  There is not sufficient room at <u>*outbuf</u>.

       <b>EILSEQ</b> An invalid multibyte sequence has been encountered in the input.

       <b>EINVAL</b> An incomplete multibyte sequence has been encountered in the input.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────┬───────────────┬─────────────────┐
       │ <b>Interface</b>                                                           │ <b>Attribute</b>     │ <b>Value</b>           │
       ├─────────────────────────────────────────────────────────────────────┼───────────────┼─────────────────┤
       │ <b>iconv</b>()                                                             │ Thread safety │ MT-Safe race:cd │
       └─────────────────────────────────────────────────────────────────────┴───────────────┴─────────────────┘

       The <b>iconv</b>() function is MT-Safe, as long as callers arrange for mutual exclusion on the <u>cd</u> argument.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       glibc 2.1.  POSIX.1-2001.

</pre><h4><b>NOTES</b></h4><pre>
       In each series of calls to <b>iconv</b>(), the last should be one with <u>inbuf</u> or <u>*inbuf</u> equal to NULL,  in  order
       to flush out any partially converted input.

       Although  <u>inbuf</u>  and  <u>outbuf</u>  are typed as <u>char</u> <u>**</u>, this does not mean that the objects they point can be
       interpreted as C strings or as arrays of characters: the interpretation of character  byte  sequences  is
       handled  internally by the conversion functions.  In some encodings, a zero byte may be a valid part of a
       multibyte character.

       The caller of <b>iconv</b>() must ensure that the pointers passed to the function  are  suitable  for  accessing
       characters  in the appropriate character set.  This includes ensuring correct alignment on platforms that
       have tight restrictions on alignment.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/iconv_close.3.html">iconv_close</a></b>(3), <b><a href="../man3/iconv_open.3.html">iconv_open</a></b>(3), <b><a href="../man8/iconvconfig.8.html">iconvconfig</a></b>(8)

Linux man-pages 6.9.1                              2024-05-02                                           <u><a href="../man3/iconv.3.html">iconv</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>