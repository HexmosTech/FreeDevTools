<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pthread_cond_init,         pthread_cond_signal,         pthread_cond_broadcast,        pthread_cond_wait,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pthread_cond_init,         pthread_cond_signal,         pthread_cond_broadcast,        pthread_cond_wait,
       pthread_cond_timedwait, pthread_cond_destroy - operations on conditions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;</b>

       <b>pthread_cond_t</b> <u>cond</u> <b>=</b> <b>PTHREAD_COND_INITIALIZER;</b>

       <b>int</b> <b>pthread_cond_init(pthread_cond_t</b> <b>*</b><u>cond</u><b>,</b>
                             <b>pthread_condattr_t</b> <b>*</b><u>cond_attr</u><b>);</b>
       <b>int</b> <b>pthread_cond_signal(pthread_cond_t</b> <b>*</b><u>cond</u><b>);</b>
       <b>int</b> <b>pthread_cond_broadcast(pthread_cond_t</b> <b>*</b><u>cond</u><b>);</b>
       <b>int</b> <b>pthread_cond_wait(pthread_cond_t</b> <b>*</b><u>cond</u><b>,</b> <b>pthread_mutex_t</b> <b>*</b><u>mutex</u><b>);</b>
       <b>int</b> <b>pthread_cond_timedwait(pthread_cond_t</b> <b>*</b><u>cond</u><b>,</b> <b>pthread_mutex_t</b> <b>*</b><u>mutex</u><b>,</b>
                             <b>const</b> <b>struct</b> <b>timespec</b> <b>*</b><u>abstime</u><b>);</b>
       <b>int</b> <b>pthread_cond_destroy(pthread_cond_t</b> <b>*</b><u>cond</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A condition (short for ``condition variable'') is a synchronization device that allows threads to suspend
       execution and relinquish the processors until some predicate on shared  data  is  satisfied.   The  basic
       operations  on  conditions  are: signal the condition (when the predicate becomes true), and wait for the
       condition, suspending the thread execution until another thread signals the condition.

       A condition variable must always be associated with a mutex, to avoid the race condition where  a  thread
       prepares  to  wait on a condition variable and another thread signals the condition just before the first
       thread actually waits on it.

       <b>pthread_cond_init</b> initializes the condition variable <u>cond</u>, using the condition  attributes  specified  in
       <u>cond_attr</u>,  or  default  attributes  if  <u>cond_attr</u>  is <b>NULL</b>.  The LinuxThreads implementation supports no
       attributes for conditions, hence the <u>cond_attr</u> parameter is actually ignored.

       Variables  of  type  <b>pthread_cond_t</b>  can   also   be   initialized   statically,   using   the   constant
       <b>PTHREAD_COND_INITIALIZER</b>.

       <b>pthread_cond_signal</b>  restarts  one of the threads that are waiting on the condition variable <u>cond</u>.  If no
       threads are waiting on <u>cond</u>, nothing happens.  If several threads are waiting on  <u>cond</u>,  exactly  one  is
       restarted, but it is not specified which.

       <b>pthread_cond_broadcast</b> restarts all the threads that are waiting on the condition variable <u>cond</u>.  Nothing
       happens if no threads are waiting on <u>cond</u>.

       <b>pthread_cond_wait</b>  atomically unlocks the <u>mutex</u> (as per <b>pthread_unlock_mutex</b>) and waits for the condition
       variable <u>cond</u> to be signaled.  The thread execution is suspended and does not consume any CPU time  until
       the  condition  variable  is  signaled.   The  <u>mutex</u>  must be locked by the calling thread on entrance to
       <b>pthread_cond_wait</b>.  Before returning to the calling thread, <b>pthread_cond_wait</b> re-acquires <u>mutex</u>  (as  per
       <b>pthread_lock_mutex</b>).

       Unlocking  the  mutex  and suspending on the condition variable is done atomically.  Thus, if all threads
       always acquire the mutex before signaling the condition, this guarantees that  the  condition  cannot  be
       signaled  (and  thus  ignored)  between  the  time  a thread locks the mutex and the time it waits on the
       condition variable.

       <b>pthread_cond_timedwait</b> atomically unlocks <u>mutex</u> and waits on <u>cond</u>, as <b>pthread_cond_wait</b> does, but it also
       bounds the duration of the wait.  If <u>cond</u> has not been signaled within the amount of  time  specified  by
       <u>abstime</u>,  the  mutex  <u>mutex</u>  is  re-acquired and <b>pthread_cond_timedwait</b> returns the error <b>ETIMEDOUT</b>.  The
       <u>abstime</u> parameter specifies an absolute time, with the same origin as  <b><a href="../man2/time.2.html">time</a></b>(2)  and  <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2):  an
       <u>abstime</u> of 0 corresponds to 00:00:00 GMT, January 1, 1970.

       <b>pthread_cond_destroy</b> destroys a condition variable, freeing the resources it might hold.  No threads must
       be  waiting  on  the  condition  variable  on  entrance  to  <b>pthread_cond_destroy</b>.   In  the LinuxThreads
       implementation, no resources are associated with condition variables, thus <b>pthread_cond_destroy</b>  actually
       does nothing except checking that the condition has no waiting threads.

</pre><h4><b>CANCELLATION</b></h4><pre>
       <b>pthread_cond_wait</b>  and  <b>pthread_cond_timedwait</b>  are  cancelation  points.  If a thread is cancelled while
       suspended in one of these functions, the thread immediately resumes execution, then locks again the <u>mutex</u>
       argument  to  <b>pthread_cond_wait</b>  and  <b>pthread_cond_timedwait</b>,  and  finally  executes  the   cancelation.
       Consequently, cleanup handlers are assured that <u>mutex</u> is locked when they are called.

</pre><h4><b>ASYNC-SIGNAL</b> <b>SAFETY</b></h4><pre>
       The  condition  functions  are not async-signal safe, and should not be called from a signal handler.  In
       particular, calling <b>pthread_cond_signal</b> or <b>pthread_cond_broadcast</b> from a signal handler may deadlock  the
       calling thread.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       All condition variable functions return 0 on success and a non-zero error code on error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>pthread_cond_init</b>,  <b>pthread_cond_signal</b>,  <b>pthread_cond_broadcast</b>,  and  <b>pthread_cond_wait</b> never return an
       error code.

       The <b>pthread_cond_timedwait</b> function returns the following error codes on error:

              <b>ETIMEDOUT</b>
                     The condition variable was not signaled until the timeout specified by <u>abstime</u>.

              <b>EINTR</b>  <b>pthread_cond_timedwait</b> was interrupted by a signal.

       The <b>pthread_cond_destroy</b> function returns the following error code on error:

              <b>EBUSY</b>  Some threads are currently waiting on <u>cond</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/pthread_condattr_init.3.html">pthread_condattr_init</a></b>(3), <b><a href="../man3/pthread_mutex_lock.3.html">pthread_mutex_lock</a></b>(3), <b><a href="../man3/pthread_mutex_unlock.3.html">pthread_mutex_unlock</a></b>(3), <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2), <b><a href="../man2/nanosleep.2.html">nanosleep</a></b>(2).

</pre><h4><b>EXAMPLE</b></h4><pre>
       Consider two shared variables <u>x</u> and <u>y</u>, protected by the mutex <u>mut</u>, and a condition variable <u>cond</u> that  is
       to be signaled whenever <u>x</u> becomes greater than <u>y</u>.

              <b>int</b> <b>x,y;</b>
              <b>pthread_mutex_t</b> <b>mut</b> <b>=</b> <b>PTHREAD_MUTEX_INITIALIZER;</b>
              <b>pthread_cond_t</b> <b>cond</b> <b>=</b> <b>PTHREAD_COND_INITIALIZER;</b>

       Waiting until <u>x</u> is greater than <u>y</u> is performed as follows:

              <b>pthread_mutex_lock(&amp;mut);</b>
              <b>while</b> <b>(x</b> <b>&lt;=</b> <b>y)</b> <b>{</b>
                      <b>pthread_cond_wait(&amp;cond,</b> <b>&amp;mut);</b>
              <b>}</b>
              <b>/*</b> <b>operate</b> <b>on</b> <b>x</b> <b>and</b> <b>y</b> <b>*/</b>
              <b>pthread_mutex_unlock(&amp;mut);</b>

       Modifications on <u>x</u> and <u>y</u> that may cause <u>x</u> to become greater than <u>y</u> should signal the condition if needed:

              <b>pthread_mutex_lock(&amp;mut);</b>
              <b>/*</b> <b>modify</b> <b>x</b> <b>and</b> <b>y</b> <b>*/</b>
              <b>if</b> <b>(x</b> <b>&gt;</b> <b>y)</b> <b>pthread_cond_broadcast(&amp;cond);</b>
              <b>pthread_mutex_unlock(&amp;mut);</b>

       If it can be proved that at most one waiting thread needs to be waken up (for instance, if there are only
       two  threads communicating through <u>x</u> and <u>y</u>), <b>pthread_cond_signal</b> can be used as a slightly more efficient
       alternative to <b>pthread_cond_broadcast</b>.  In doubt, use <b>pthread_cond_broadcast</b>.

       To wait for <u>x</u> to become greater than <u>y</u> with a timeout of 5 seconds, do:

              <b>struct</b> <b>timeval</b> <b>now;</b>
              <b>struct</b> <b>timespec</b> <b>timeout;</b>
              <b>int</b> <b>retcode;</b>

              <b>pthread_mutex_lock(&amp;mut);</b>
              <b>gettimeofday(&amp;now);</b>
              <b>timeout.tv_sec</b> <b>=</b> <b>now.tv_sec</b> <b>+</b> <b>5;</b>
              <b>timeout.tv_nsec</b> <b>=</b> <b>now.tv_usec</b> <b>*</b> <b>1000;</b>
              <b>retcode</b> <b>=</b> <b>0;</b>
              <b>while</b> <b>(x</b> <b>&lt;=</b> <b>y</b> <b>&amp;&amp;</b> <b>retcode</b> <b>!=</b> <b>ETIMEDOUT)</b> <b>{</b>
                      <b>retcode</b> <b>=</b> <b>pthread_cond_timedwait(&amp;cond,</b> <b>&amp;mut,</b> <b>&amp;timeout);</b>
              <b>}</b>
              <b>if</b> <b>(retcode</b> <b>==</b> <b>ETIMEDOUT)</b> <b>{</b>
                      <b>/*</b> <b>timeout</b> <b>occurred</b> <b>*/</b>
              <b>}</b> <b>else</b> <b>{</b>
                      <b>/*</b> <b>operate</b> <b>on</b> <b>x</b> <b>and</b> <b>y</b> <b>*/</b>
              <b>}</b>
              <b>pthread_mutex_unlock(&amp;mut);</b>

Linux man-pages 6.9.1                              2024-06-16                               <u><a href="../man3/pthread_cond_init.3.html">pthread_cond_init</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>