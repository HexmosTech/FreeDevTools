<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search::Elasticsearch::Client::2_0::Scroll - A helper module for scrolled searches</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsearch-elasticsearch-client-2-0-perl">libsearch-elasticsearch-client-2-0-perl_6.81-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Search::Elasticsearch::Client::2_0::Scroll - A helper module for scrolled searches

</pre><h4><b>VERSION</b></h4><pre>
       version 6.81

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Search::Elasticsearch;

           my $es     = Search::Elasticsearch-&gt;new;

           my $scroll = $es-&gt;scroll_helper(
               index       =&gt; 'my_index',
               search_type =&gt; 'scan',
               size        =&gt; 500
           );

           say "Total hits: ". $scroll-&gt;total;

           while (my $doc = $scroll-&gt;next) {
               # do something
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A <u>scrolled</u> <u>search</u> is a search that allows you to keep pulling results until there are no more matching
       results, much like a cursor in an SQL database.

       Unlike paginating through results (with the "from" parameter in <b>search()</b>), scrolled searches take a
       snapshot of the current state of the index. Even if you keep adding new documents to the index or
       updating existing documents, a scrolled search will only see the index as it was when the search began.

       This module is a helper utility that wraps the functionality of the <b>search()</b> and <b>scroll()</b> methods to make
       them easier to use.

       <b>IMPORTANT</b>: Deep scrolling can be expensive.  See "DEEP SCROLLING" for more.

       This class does Search::Elasticsearch::Client::2_0::Role::Scroll and
       Search::Elasticsearch::Role::Is_Sync.

</pre><h4><b>USE</b> <b>CASES</b></h4><pre>
       There are two primary use cases:

   <b>Pulling</b> <b>enough</b> <b>results</b>
       Perhaps you want to group your results by some field, and you don't know exactly how many results you
       will need in order to return 10 grouped results.  With a scrolled search you can keep pulling more
       results until you have enough.  For instance, you can search emails in a mailing list, and return results
       grouped by "thread_id":

           my (%groups,@results);

           my $scroll = $es-&gt;scroll_helper(
               index =&gt; 'my_emails',
               type  =&gt; 'email',
               body  =&gt; { query =&gt; {... some query ... }}
           );

           my $doc;
           while (@results &lt; 10 and $doc = $scroll-&gt;next) {

               my $thread = $doc-&gt;{_source}{thread_id};

               unless ($groups{$thread}) {
                   $groups{$thread} = [];
                   push @results, $groups{$thread};
               }
               push @{$groups{$thread}},$doc;

           }

   <b>Extracting</b> <b>all</b> <b>documents</b>
       Often you will want to extract all (or a subset of) documents in an index.  If you want to change your
       type mappings, you will need to reindex all of your data. Or perhaps you want to move a subset of the
       data in one index into a new dedicated index. In these cases, you don't care about sort order, you just
       want to retrieve all documents which match a query, and do something with them. For instance, to retrieve
       all the docs for a particular "client_id":

           my $scroll = $es-&gt;scroll_helper(
               index       =&gt; 'my_index',
               search_type =&gt; 'scan',          # important!
               size        =&gt; 500,
               body        =&gt; {
                   query =&gt; {
                       match =&gt; {
                           client_id =&gt; 123
                       }
                   }
               }
           );

           while (my $doc = $scroll-&gt;next) {
               # do something
           }

       Very often the <u>something</u> that you will want to do with these results involves bulk-indexing them into a
       new index. The easiest way to marry a scrolled search with bulk indexing is to use the "<b>reindex()</b>" in
       Search::Elasticsearch::Client::2_0::Bulk method.

</pre><h4><b>DEEP</b> <b>SCROLLING</b></h4><pre>
       Deep scrolling (and deep pagination) are very expensive in a distributed environment, and the reason they
       are expensive is that results need to be sorted in a global order.

       For example, if we have an index with 5 shards, and we request the first 10 results, each shard has to
       return its top 10, and then the <u>requesting</u> <u>node</u> (the node that is handling the search request) has to
       resort these 50 results to return a global top 10. Now, if we request page 1,000 (ie results 10,001 ..
       10,010), then each shard has to return 10,010 results, and the requesting node has to sort through 50,050
       results just to return 10 of them!

       You can see how this can get very heavy very quickly. This is the reason that web search engines never
       return more than 1,000 results.

   <b>Disable</b> <b>sorting</b> <b>for</b> <b>efficient</b> <b>scrolling</b>
       The problem with deep scrolling is the sorting phase.  If we disable sorting, then we can happily scroll
       through millions of documents efficiently.  The way to do this is to set "search_type" to "scan":

           my $scroll = $es-&gt;scroll_helper(
               search_type =&gt; 'scan',
               size        =&gt; 500,
           );

       Scanning disables sorting and will just return "size" results from each shard until there are no more
       results to return. <b>Note</b>: this means that, when querying an index with 5 shards, the scrolled search will
       pull "size * 5" results at a time. If you have large documents or are memory constrained, you will need
       to take this into account.

</pre><h4><b>METHODS</b></h4><pre>
   <b>"new()"</b>
           use Search::Elasticsearch;

           my $es = Search::Elasticsearch-&gt;new(...);
           my $scroll = $es-&gt;scroll_helper(
               scroll         =&gt; '1m',            # optional
               scroll_in_qs   =&gt; 0|1,             # optional
               %search_params
           );

       The "<b>scroll_helper()</b>" in Search::Elasticsearch::Client::2_0::Direct method loads
       Search::Elasticsearch::Client::2_0::Scroll class and calls "<b>new()</b>", passing in any arguments.

       You can specify a "scroll" duration (which defaults to "1m") and "scroll_in_qs" (which defaults to
       "false"). Any other parameters are passed directly to "<b>search()</b>" in
       Search::Elasticsearch::Client::2_0::Direct.

       The "scroll" duration tells Elasticearch how long it should keep the scroll alive.  <b>Note</b>: this duration
       doesn't need to be long enough to process all results, just long enough to process a single <b>batch</b> of
       results.  The expiry gets renewed for another "scroll" period every time new a new batch of results is
       retrieved from the cluster.

       By default, the "scroll_id" is passed as the "body" to the scroll request.  To send it in the query
       string instead, set "scroll_in_qs" to a true value, but be aware: when querying very many indices, the
       scroll ID can become too long for intervening proxies.

       The "scroll" request uses "GET" by default.  To use "POST" instead, set send_get_body_as to "POST".

   <b>"next()"</b>
           $doc  = $scroll-&gt;next;
           @docs = $scroll-&gt;next($num);

       The "next()" method returns the next result, or the next $num results (pulling more results if required).
       If all results have been exhausted, it returns an empty list.

   <b>"drain_buffer()"</b>
           @docs = $scroll-&gt;drain_buffer;

       The "drain_buffer()" method returns all of the documents currently in the buffer, without fetching any
       more from the cluster.

   <b>"refill_buffer()"</b>
           $total = $scroll-&gt;refill_buffer;

       The "refill_buffer()" method fetches the next batch of results from the cluster, stores them in the
       buffer, and returns the total number of docs currently in the buffer.

   <b>"buffer_size()"</b>
           $total = $scroll-&gt;buffer_size;

       The "buffer_size()" method returns the total number of docs currently in the buffer.

   <b>"finish()"</b>
           $scroll-&gt;finish;

       The "finish()" method clears out the buffer, sets "<b>is_finished()</b>" to "true" and tries to clear the
       "scroll_id" on Elasticsearch.  This API is only supported since v0.90.5, but the call to "clear_scroll"
       is wrapped in an "eval" so the "finish()" method can be safely called with any version of Elasticsearch.

       When the $scroll instance goes out of scope, "<b>finish()</b>" is called automatically if required.

   <b>"is_finished()"</b>
           $bool = $scroll-&gt;is_finished;

       A flag which returns "true" if all results have been processed or "<b>finish()</b>" has been called.

</pre><h4><b>INFO</b> <b>ACCESSORS</b></h4><pre>
       The information from the original search is returned via the following accessors:

   <b>"total"</b>
       The total number of documents that matched your query.

   <b>"max_score"</b>
       The maximum score of any documents in your query.

   <b>"aggregations"</b>
       Any aggregations that were specified, or "undef"

   <b>"facets"</b>
       Any facets that were specified, or "undef"

   <b>"suggest"</b>
       Any suggestions that were specified, or "undef"

   <b>"took"</b>
       How long the original search took, in milliseconds

   <b>"took_total"</b>
       How long the original search plus all subsequent batches took, in milliseconds.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   "<b>reindex()</b>" in Search::Elasticsearch::Client::2_0::Bulk

       •   "<b>search()</b>" in Search::Elasticsearch::Client::2_0::Direct

       •   "<b>scroll()</b>" in Search::Elasticsearch::Client::2_0::Direct

</pre><h4><b>AUTHOR</b></h4><pre>
       Enrico Zimuel &lt;<a href="mailto:enrico.zimuel@elastic.co">enrico.zimuel@elastic.co</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2020 by Elasticsearch BV.

       This is free software, licensed under:

         The Apache License, Version 2.0, January 2004

perl v5.32.0                                       2020-11-25             <u>Search::Elastic...nt::2_0::<a href="../man3pm/Scroll.3pm.html">Scroll</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>