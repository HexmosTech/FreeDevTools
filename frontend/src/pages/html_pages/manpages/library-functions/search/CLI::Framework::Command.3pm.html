<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLI::Framework::Command - CLIF Command superclass</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcli-framework-perl">libcli-framework-perl_0.05-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CLI::Framework::Command - CLIF Command superclass

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # The code below shows a few of the methods your command classes are likely
           # to override...

           package My::Journal::Command::Search;
           use base qw( CLI::Framework::Command );

           sub usage_text { q{
               search [--titles-only] &lt;search regex&gt;: search a journal
           } }

           sub option_spec { (
               [ 'titles-only' =&gt; 'search only journal titles' ],
           ) }

           sub validate {
               my $self, $opts, @args) = @_;
               die "exactly one argument required (search regex)" unless @args == 1;
           }

           sub run {
               my ($self, $opts, @args) = @_;

               my $db = $self-&gt;cache-&gt;get( 'db' )

               # perform search against $db...
               # $search_results = ...

               return $search_results;
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       CLI::Framework::Command (command class for use with CLI::Framework::Application) is the base class for
       CLIF commands.  All CLIF commands inherit from this class.

</pre><h4><b>CONCEPTS</b></h4><pre>
       Subcommands
           Commands can have "subcommands," which are also objects of CLI::Framework::Command.  Subcommands can,
           in turn, have their own subcommands, and this pattern may repeat indefinitely.

           <b>Note</b>  that  in  this  documentation,  the  term  "command"  may be used to refer to both commands and
           subcommands.

       Registration of subcommands
           Subcommands are "registered" with their parent  commands.   The  parent  commands  can  then  forward
           subcommand responsibilities as appropriate.

       File-based commands vs. inline commands
           Command  classes  (which  inherit  from  CLI::Framework::Command) can be defined in their own package
           files or they may be declared inline in another package (e.g. a command package  file  could  include
           the  declaration  of a subcommand package or command packages could be declared inline in the package
           file where the application is declared).  As long as the classes have been loaded (making  their  way
           into the symbol table), CLIF can use the commands.

</pre><h4><b>OBJECT</b> <b>CONSTRUCTION</b></h4><pre>
   <b>manufacture(</b> <b>$command_package</b> <b>)</b>
           # (manufacture MyApp::Command::Go and any subcommand trees beneath it)
           my $go = CLI::Framework::Command-&gt;manufacture( 'MyApp::Command::Go' );

       CLI::Framework::Command is an abstract factory; "manufacture()" is the factory method that constructs and
       returns an object of the specific command class that is requested.

       After  instantiating  an  object  of  the  requested  command  package,  "manufacture()" attempts to load
       subcommands in the following 2 steps:

       1.  Attempt to find package <b>files</b> representing subcommands.  For every subcommand S, S is registered as a
           child of the parent command.  Next, steps 1 and 2 repeat, this time being invoked on S (i.e.  with  S
           as the parent in an attempt to find subcommands of S).

       2.  Attempt  to find and register pre-compiled subcommands defined <b>inline</b>.  Only pre-compiled subcommands
           are considered for registration (i.e. package files are not considered  in  this  step).   For  every
           subcommand  S, any pre-compiled subcommands that inherit <b>directly</b> from S are found and step 2 repeats
           for those classes.

       Note the following rules about command class definition:

       •   If a command class is defined inline, its subcommand classes must be defined inline as well.

       •   If a command class is file-based, each of its subcommand classes can be either file-based or  inline.
           Furthermore, it is not necessary for all of these subcommand classes to be defined in the same way --
           a mixture of file-based and inline styles can be used for the subcommands of a given command.

   <b>new()</b>
           $object = $cli_framework_command_subclass-&gt;new();

       Basic constructor.

</pre><h4><b>SHARED</b> <b>CACHE</b> <b>DATA</b></h4><pre>
       CLIF  commands  may  need to share data with other commands and with their associated application.  These
       methods support those needs.

   <b>set_cache(</b> <b>$cache_object</b> <b>)</b>
       Set the internal cache object for this instance.

       See cache.

   <b>cache()</b>
       Retrieve the internal cache object for this instance.

       See cache for an explanation of how to use this simple cache object.

</pre><h4><b>COMMAND</b> <b>DISPATCHING</b></h4><pre>
   <b>get_default_usage()</b> <b>/</b> <b>set_default_usage(</b> <b>$default_usage_text</b> <b>)</b>
       Get or set the default usage message for the command.  This message is used by usage.

       <b>Note</b>: "get_default_usage()" merely retrieves the usage data that has already been set.   CLIF  only  sets
       the  default  usage  message for a command when processing a run request for the command.  Therefore, the
       default usage message for a command may be empty (if a run request for the command has not been given and
       you have not otherwise set the default usage message).

           $cmd-&gt;set_default_usage( ... );
           $usage_msg = $cmd-&gt;get_default_usage();

   <b>usage(</b> <b>$subcommand_name,</b> <b>@subcommand_chain</b> <b>)</b>
           # Command usage...
           print $cmd-&gt;usage();

           # Subcommand usage (to any level of depth)...
           $subcommand_name = 'list';
           @subcommand_chain = qw( completed );
           print $cmd-&gt;usage( $subcommand_name, @subcommand_chain );

       Attempts to find and return a usage message for a command or subcommand.

       If a subcommand is given, returns a usage message for that subcommand.  If no subcommand is given  or  if
       the subcommand cannot produce a usage message, returns a general usage message for the command.

       Logically, here is how the usage message is produced:

       •   If  registered  subcommand(s)  are given, attempt to get usage message from a subcommand (<b>Note</b> that a
           sequence of subcommands could be given, e.g.  "$cmd-&gt;usage('list' 'completed')", which  would  result
           in  the usage message for the final subcommand, 'completed').  If no usage message is defined for the
           subcommand, the usage message for the command is used instead.

       •   If the command has implemented usage_text, its return value is used as the usage message.

       •   Finally, if no usage message has been found, the default usage message produced by  get_default_usage
           is returned.

   <b>dispatch(</b> <b>$cmd_opts,</b> <b>@args</b> <b>)</b>
       For  the  given  command  request,  "dispatch" performs any applicable validation and initialization with
       respect to supplied options $cmd_opts and arguments @args, then runs the command.

       @args may indicate the request for a subcommand:

           { &lt;subcmd&gt; [subcmd-opts] {...} } [subcmd-args]

       ...as in the following command (where "usage" is the &lt;subcmd&gt;):

           $ gen-report --html stats --role=admin usage --time='2d' '/tmp/stats.html'

       If a subcommand registered under the indicated command is requested, the subcommand  is  initialized  and
       dispatched with its options "[subcmd-opts]" and arguments.  Otherwise, the command itself is run.

       This  means  that  a  request for a subcommand will result in the "run" method of only the deepest-nested
       subcommand (because "dispatch" will keep forwarding to successive subcommands until the  args  no  longer
       indicate  that  a  subcommand  is requested).  Furthermore, the only command that can receive args is the
       final subcommand in the chain (but all commands in the chain can receive options).   However,  <b>Note</b>  that
       each  command  in  the  chain  can affect the execution process through its notify_of_subcommand_dispatch
       method.

</pre><h4><b>COMMAND</b> <b>REGISTRATION</b></h4><pre>
   <b>registered_subcommand_names()</b>
           @registered_subcommands = $cmd-&gt;registered_subcommand_names();

       Return a list of the currently-registered subcommands.

   <b>registered_subcommand_object(</b> <b>$subcommand_name</b> <b>)</b>
           $subcmd_obj = $cmd-&gt;get_registered_subcommand( 'lock' );

       Given the name of a registered  subcommand,  return  a  reference  to  the  subcommand  object.   If  the
       subcommand is not registered, returns undef.

   <b>register_subcommand(</b> <b>$subcmd_obj</b> <b>)</b>
           $cmd-&gt;register_subcommand( $subcmd_obj );

       Register $subcmd_obj as a subcommand under master command $cmd.

       If $subcmd_obj is not a CLI::Framework::Command, returns undef.  Otherwise, returns $subcmd_obj.

   <b>package_is_registered(</b> <b>$package_name</b> <b>)</b>
       Return a true value if the named class is registered as a subcommand.  Returns a false value otherwise.

   <b>name()</b>
           $s = My::Command::Squeak-&gt;new();
           $s-&gt;name();    # =&gt; 'squeak'

       "name()"  takes  no  arguments and returns the name of the command.  This method uses the normalized base
       name  of  the  package   as   the   command   name,   e.g.   the   command   defined   by   the   package
       My::Application::Command::Xyz would be named 'xyz'.

</pre><h4><b>COMMAND</b> <b>SUBCLASS</b> <b>HOOKS</b></h4><pre>
       Just  as  CLIF  Applications  have hooks that subclasses can use, CLIF Commands are able to influence the
       command dispatch process via several hooks.  Except where noted, all hooks are optional -- subclasses may
       choose whether or not to override them.

   <b>option_spec()</b>
       This method  should  return  an  option  specification  as  expected  by  Getopt::Long::Descriptive  (see
       Getopt::Long::Descriptive).   The  option  specification  is  a list of arrayrefs that defines recognized
       options, types, multiplicities, etc. and specifies textual strings that are used as descriptions of  each
       option:

           sub option_spec {
               [ "verbose|v"   =&gt; "be verbose"         ],
               [ "logfile=s"   =&gt; "path to log file"   ],
           }

       Subclasses  should  override  this  method  if  commands  accept options (otherwise, the command will not
       recognize any options).

   <b>subcommand_alias()</b>
           sub subcommand_alias {
               rm  =&gt; 'remove',
               new =&gt; 'create',
               j   =&gt; 'jump',
               r   =&gt; 'run',
           }

       Subcommands can have aliases to support shorthand versions of subcommand names.

       Subclasses should override this method if subcommand aliases are  desired.   Otherwise,  the  subcommands
       will only be recognized by their full command names.

   <b>validate(</b> <b>$cmd_opts,</b> <b>@args</b> <b>)</b>
       To  provide  strict  validation  of  a  command request, a subclass may override this method.  Otherwise,
       validation is skipped.

       $cmd_opts is an options hash with the received command options as keys and their values as hash values.

       @args is a list of the received command arguments.

       "validate()" is called in void context.  It is expected to throw an exception if validation fails.   This
       allows your validation routine to provide a context-specific failure message.

       <b>Note</b>  that  Getop::Long::Descriptive  performs  some  validation  of  its  own  based on the option_spec.
       However, "validate()" allows more flexibility in validating command options and also allows validation of
       arguments.

   <b>notify_of_subcommand_dispatch(</b> <b>$subcommand,</b> <b>$cmd_opts,</b> <b>@args</b> <b>)</b>
       If a request for a subcommand is received, the master command itself  does  not  "run()".   Instead,  its
       "notify_of_subcommand_dispatch()" method is called.  This gives the master command a chance to act before
       the subcommand is run.

       For  example,  suppose  some  (admittedly  contrived)  application, 'queue', has a command hierarchy with
       multiple commands:

           enqueue
           dequeue
           print
           property
               constraint
                   maxlen
               behavior
           ...

       In this case, "$ queue property constraint maxlen" might set the max length property for a queue.  If the
       command hierarchy was built this way, "maxlen" would be the only command to "run"  in  response  to  that
       request.   If  "constraint",  the  master  command  of  "maxlen", needs to hook into this execution path,
       "notify_of_subcommand_dispatch()" could be overridden in the command class that implements  "constraint".
       "notify_of_subcommand_dispatch()" would then be called just before "dispatch"ing "maxlen".

       The "notify_of_subcommand_dispatch()" method is called in void context.

       $subcommand is the subcommand object.

       $cmd_opts is the options hash for the subcommand.

       @args is the argument list for the subcommand.

   <b>usage_text()</b>
           sub usage_text {
               q{
               dequeue: remove item from queue
               }
           }

       If  implemented,  this method should simply return a string containing usage information for the command.
       It is used automatically to provide context-specific help.

       Implementing this method is optional.  See usage for details on how usage information is generated within
       the context of a CLIF application.

       Users are encouraged to override this method.

   <b>run(</b> <b>$cmd_opts,</b> <b>@args</b> <b>)</b>
       This method is responsible for the main execution  of  a  command.   It  is  called  with  the  following
       parameters:

       $cmd_opts  is a pre-validated options hash with command options as keys and their user-provided values as
       hash values.

       @args is a list of the command arguments.

       The default implementation of this method simply calls usage to show help information  for  the  command.
       Therefore,  subclasses  will  usually override "run()" (Occasionally, it is useful to have a command that
       does little or nothing on its own but has subcommands that define the real behavior.  In such  occasional
       cases, it may not be necessary to override "run()").

       If  an  error  occurs  during  the execution of a command via its "run()" method, the "run()" method code
       should throw an exception.  The exception will be caught and handled appropriately by CLIF.

       The return value of "run()" is treated as data to  be  processed  by  the  render  method  in  your  CLIF
       Application  class.  <b>Note</b> <b>that</b> <b>nothing</b> <b>should</b> <b>be</b> <b>printed</b> <b>directly</b> <b>in</b> <b>your</b> <b>implementation</b> <b>of</b> <b>"run"</b>.  If no
       output is to be produced, your "run()" method should return "undef" or empty string.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       "Error: failed to instantiate command package '&lt;command pkg&gt;' via new()"
           manufacture was asked to manufacture an object of class &lt;command pkg&gt;, but  failed  while  trying  to
           invoke its constructor.

       "Error: failed to instantiate subcommand '&lt;class&gt;' via method new()"
           Object  construction  for  the  subcommand  &lt;class&gt; (whose package has already been "require()d") was
           unsuccessful.

       "cannot opendir &lt;dir&gt;"
           While trying to manufacture subcommands in a directory tree, calling "opendir()" on the  subdirectory
           with the name of the parent command failed.

</pre><h4><b>CONFIGURATION</b> <b>&amp;</b> <b>ENVIRONMENT</b></h4><pre>
       No special configuration requirements.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Carp

       Getopt::Long::Descriptive

       Exception::Class::TryCatch

       Class::Inspector

       CLI::Framework::Exceptions

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CLI::Framework

       CLI::Framework::Application

       CLI::Framework::Tutorial

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Karl Erisman (<a href="mailto:kerisman@cpan.org">kerisman@cpan.org</a>). All rights reserved.

       This  is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See
       perlartistic.

</pre><h4><b>AUTHOR</b></h4><pre>
       Karl Erisman (<a href="mailto:kerisman@cpan.org">kerisman@cpan.org</a>)

perl v5.34.0                                       2022-06-11                       <u>CLI::Framework::<a href="../man3pm/Command.3pm.html">Command</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>