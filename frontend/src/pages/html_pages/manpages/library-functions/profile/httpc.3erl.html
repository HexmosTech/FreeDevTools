<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>httpc - An HTTP/1.1 client</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       httpc - An HTTP/1.1 client

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides  the  API  to  an HTTP/1.1 compatible client according to RFC 2616. Caching is not
       supported.

   <b>Note:</b>
       When starting the <u>Inets</u> application, a manager process for the default profile is started. The  functions
       in  this  API that do not explicitly use a profile accesses the default profile. A profile keeps track of
       proxy options, cookies, and other options that can be applied to more than one request.

       If the scheme <u>https</u> is used, the <u>SSL</u> application must be started. When <u>https</u> links need to go  through  a
       proxy,  the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is
       upgraded to TLS. However, "TLS upgrade" according to RFC 2817is not supported.

       Pipelining is only used if the  pipeline  time-out  is  set,  otherwise  persistent  connections  without
       pipelining  are  used. That is, the client always waits for the previous response before sending the next
       request.

       Some examples are provided in the Inets User's Guide.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       Type definitions that are used more than once in this module:

       <u>boolean()</u> <u>=</u> <u>true</u> <u>|</u> <u>false</u>

       <u>http_string()</u> = list of ASCII characters

       <u>request_id()</u> <u>=</u> <u>reference()</u>

       <u>profile()</u> <u>=</u> <u>atom()</u>

       <u>path()</u> <u>=</u> <u>string()</u> representing a file path or directory path

       <u>ip_address()</u> = See the <a href="../man3erl/inet.3erl.html">inet</a>(3erl) manual page in Kernel.

       <u>socket_opt()</u> = See the options used by <a href="../man3erl/gen_tcp.3erl.html">gen_tcp</a>(3erl) <u><a href="../man3erl/gen_tcp.3erl.html">gen_tcp</a>(3erl)</u> and <a href="../man3erl/ssl.3erl.html">ssl</a>(3erl) connect(s)

</pre><h4><b>HTTP</b> <b>DATA</b> <b>TYPES</b></h4><pre>
       Type definitions related to HTTP:

       <u>method()</u> <u>=</u> <u>head</u> <u>|</u> <u>get</u> <u>|</u> <u>put</u> <u>|</u> <u>post</u> <u>|</u> <u>trace</u> <u>|</u> <u>options</u> <u>|</u> <u>delete</u> <u>|</u> <u>patch</u>

         <u>request()</u>:
           = <u>{url(),</u> <u>headers()}</u>

           | <u>{url(),</u> <u>headers(),</u> <u>content_type(),</u> <u>body()}</u>

       <u>url()</u>  <u>=</u>  <u>http_string()</u>  syntax  according  to  the   URI   definition   in   RFC   3986,   for   example
       <u>"<a href="http://www.erlang.org">http://www.erlang.org</a>"</u>

   <b>Warning:</b>
       Please  note  that httpc normalizes input URIs before internal processing and special care shall be taken
       when the URI has percent ("%") characters. A percent serves as the indicator for  percent-encoded  octets
       and it must be percent-encoded as "%25" for that octet to be used as data within the URI.

       For  example,  in  order to send an HTTP GET request with the URI <u><a href="http://localhost/foo">http://localhost/foo</a>%25bar</u>, the percent
       character       must       be       percent-encoded       when        creating        the        request:
       <u>httpc:request("<a href="http://localhost/foo">http://localhost/foo</a>%2525bar").</u>

       <u>status_line()</u> <u>=</u> <u>{http_version(),</u> <u>status_code(),</u> <u>reason_phrase()}</u>

       <u>http_version()</u> <u>=</u> <u>http_string()</u>, for example, <u>"HTTP/1.1"</u>

       <u>status_code()</u> <u>=</u> <u>integer()</u>

       <u>reason_phrase()</u> <u>=</u> <u>string()</u>

       <u>content_type()</u> <u>=</u> <u>http_string()</u>

       <u>headers()</u> <u>=</u> <u>[header()]</u>

       <u>header()</u> <u>=</u> <u>{field(),</u> <u>value()}</u>

       <u>field()</u> <u>=</u> <u>[byte()]</u>

       <u>value()</u> <u>=</u> <u>binary()</u> <u>|</u> <u>iolist()</u>

         <u>body()</u>:
           = <u>http_string()</u> <u>|</u> <u>binary()</u>

           | <u>{fun(accumulator())</u>

            <u>-&gt;</u> <u>body_processing_result(),</u> <u>accumulator()}</u>

           | <u>{chunkify,</u> <u>fun(accumulator())</u>

            <u>-&gt;</u> <u>body_processing_result(),</u> <u>accumulator()}</u>

       <u>body_processing_result()</u> <u>=</u> <u>eof</u> <u>|</u> <u>{ok,</u> <u>iolist(),</u> <u>accumulator()}</u>

       <u>accumulator()</u> <u>=</u> <u>term()</u>

       <u>filename()</u> <u>=</u> <u>string()</u>

       For more information about HTTP, see RFC 2616.

</pre><h4><b>SSL</b> <b>DATA</b> <b>TYPES</b></h4><pre>
       See <a href="../man3erl/ssl.3erl.html">ssl</a>(3erl) for information about <u>SSL</u> options (<u>ssloptions()</u>).

</pre><h4><b>HTTP</b> <b>CLIENT</b> <b>SERVICE</b> <b>START/STOP</b></h4><pre>
       An  HTTP  client can be configured to start when starting the <u>Inets</u> application or started dynamically in
       runtime by calling the <u>Inets</u> application  API  <u>inets:start(httpc,</u>  <u>ServiceConfig)</u>  or  <u>inets:start(httpc,</u>
       <u>ServiceConfig,</u> <u>How)</u>, see <a href="../man3erl/inets.3erl.html">inets</a>(3erl). The configuration options are as follows:

         <b>{profile,</b> <b>profile()}:</b>
           Name of the profile, see DATA TYPES. This option is mandatory.

         <b>{data_dir,</b> <b>path()}:</b>
           Directory  where the profile can save persistent data. If omitted, all cookies are treated as session
           cookies.

       The client can be stopped using <u>inets:stop(httpc,</u> <u>Pid)</u> or <u>inets:stop(httpc,</u> <u>Profile)</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>cancel_request(RequestId)</b> <b>-&gt;</b>
       <b>cancel_request(RequestId,</b> <b>Profile)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 RequestId = request_id() - A unique identifier as returned by request/4
                 Profile = profile() | pid()
                   When started <u>stand_alone</u> only the pid can be used.

              Cancels an asynchronous HTTP request. Notice  that  this  does  not  guarantee  that  the  request
              response is not delivered. Because it is asynchronous, the request can already have been completed
              when the cancellation arrives.

       <b>cookie_header(Url)</b> <b>-&gt;</b>
       <b>cookie_header(Url,</b> <b>Profile</b> <b>|</b> <b>Opts)</b> <b>-&gt;</b> <b>header()</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>cookie_header(Url,</b> <b>Opts,</b> <b>Profile)</b> <b>-&gt;</b> <b>header()</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Url = url()
                 Opts = [cookie_header_opt()]
                 Profile = profile() | pid()
                   When started <u>stand_alone</u>.
                 cookie_header_opt() = {ipv6_host_with_brackets, boolean()}

              Returns  the  cookie  header  that would have been sent when making a request to <u>Url</u> using profile
              <u>Profile</u>. If no profile is specified, the default profile is used.

              Option <u>ipv6_host_with_bracket</u> deals with how to parse IPv6 addresses. For  details,  see  argument
              <u>Options</u> of request/[4,5].

       <b>get_options(OptionItems)</b> <b>-&gt;</b> <b>{ok,</b> <b>Values}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>get_options(OptionItems,</b> <b>Profile)</b> <b>-&gt;</b> <b>{ok,</b> <b>Values}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 OptionItems = all | [option_item()]
                 option_item() = proxy | https_proxy | max_sessions | keep_alive_timeout | max_keep_alive_length
                 |  pipeline_timeout  |  max_pipeline_length  |  cookies  | ipfamily | ip | port | socket_opts |
                 verbose | unix_socket
                 Profile = profile() | pid()
                   When started <u>stand_alone</u> only the pid can used.
                 Values = [{option_item(), term()}]
                 Reason = term()

              Retrieves the options currently used by the client.

       <b>info()</b> <b>-&gt;</b> <b>list()</b>
       <b>info(Profile)</b> <b>-&gt;</b> <b>list()</b>

              Types:

                 Profile = profile() | pid()
                   When started <u>stand_alone</u> only the pid can be used.

              Produces a list of miscellaneous information. Intended for debugging. If no profile is  specified,
              the default profile is used.

       <b>reset_cookies()</b> <b>-&gt;</b> <b>void()</b>
       <b>reset_cookies(Profile)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Profile = profile() | pid()
                   When started <u>stand_alone</u> only the pid can be used.

              Resets  (clears)  the  cookie  database  for the specified <u>Profile</u>. If no profile is specified the
              default profile is used.

       <b>request(Url)</b> <b>-&gt;</b>
       <b>request(Url,</b> <b>Profile)</b> <b>-&gt;</b> <b>{ok,</b> <b>Result}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Url = url()
                 Result = {status_line(), headers(), Body} | {status_code(), Body} | request_id()
                 Body = http_string() | binary()
                 Profile = profile() | pid()
                   When started <u>stand_alone</u> only the pid can be used.
                 Reason = term()

              Equivalent to <u>httpc:request(get,</u> <u>{Url,</u> <u>[]},</u> <u>[],</u> <u>[])</u>.

       <b>request(Method,</b> <b>Request,</b> <b>HTTPOptions,</b> <b>Options)</b> <b>-&gt;</b>
       <b>request(Method,</b> <b>Request,</b> <b>HTTPOptions,</b> <b>Options,</b> <b>Profile)</b> <b>-&gt;</b> <b>{ok,</b> <b>Result}</b> <b>|</b> <b>{ok,</b> <b>saved_to_file}</b>  <b>|</b>  <b>{error,</b>
       <b>Reason}</b>

              Types:

                 Method = method()
                 Request = request()
                 HTTPOptions = http_options()
                 http_options() = [http_option()]
                 http_option()  =  {timeout,  timeout()}  | {connect_timeout, timeout()} | {ssl, ssloptions()} |
                 {essl,   ssloptions()}   |   {autoredirect,   boolean()}    |    {proxy_auth,    {userstring(),
                 passwordstring()}} | {version, http_version()} | {relaxed, boolean()}
                 timeout() = integer() &gt;= 0 | infinity
                 Options = options()
                 options() = [option()]
                 option()  =  {sync,  boolean()}  |  {stream,  stream_to()}  |  {body_format,  body_format()}  |
                 {full_result,  boolean()}  |  {headers_as_is,  boolean()  |  {socket_opts,   socket_opts()}   |
                 {receiver, receiver()} | {ipv6_host_with_brackets, boolean()}
                 stream_to() = none | self | {self, once} | filename()
                 socket_opts() = [socket_opt()]
                 receiver() = pid() | function()/1 | {Module, Function, Args}
                 Module = atom()
                 Function = atom()
                 Args = list()
                 body_format() = string | binary
                 Result = {status_line(), headers(), Body} | {status_code(), Body} | request_id()
                 Body = http_string() | binary()
                 Profile = profile() | pid()
                   When started <u>stand_alone</u> only the pid can be used.
                 Reason = term()

              Sends  an HTTP request. The function can be both synchronous and asynchronous. In the latter case,
              the function returns <u>{ok,</u> <u>RequestId}</u> and  then  the  information  is  delivered  to  the  <u>receiver</u>
              depending on that value.

              HTTP option (<u>http_option()</u>) details:

                <u>timeout</u>:
                  Time-out time for the request.

                  The clock starts ticking when the request is sent.

                  Time is in milliseconds.

                  Default is <u>infinity</u>.

                <u>connect_timeout</u>:
                  Connection  time-out  time,  used during the initial request, when the client is <u>connecting</u> to
                  the server.

                  Time is in milliseconds.

                  Default is the value of option <u>timeout</u>.

                <u>ssl</u>:
                  This is the <u>SSL/TLS</u> connecting configuration option.

                  Defaults to <u>[]</u>. See ssl:connect/[2,3,4] for available options.

                <u>autoredirect</u>:
                  The client automatically retrieves the information from the new URI and returns  that  as  the
                  result, instead of a 30X-result code.

                  For some 30X-result codes, automatic redirect is not allowed. In these cases the 30X-result is
                  always returned.

                  Default is <u>true</u>.

                <u>proxy_auth</u>:
                  A proxy-authorization header using the provided username and password is added to the request.

                <u>version</u>:
                  Can  be  used  to  make  the  client act as an <u>HTTP/1.0</u> client. By default this is an <u>HTTP/1.1</u>
                  client. When using <u>HTTP/1.0</u> persistent connections are not used.

                  Default is the string <u>"HTTP/1.1"</u>.

                <u>relaxed</u>:
                  If set to <u>true</u>, workarounds for known server deviations from the HTTP-standard are enabled.

                  Default is <u>false</u>.

              Option (<u>option()</u>) details:

                <u>sync</u>:
                  Option for the request to be synchronous or asynchronous.

                  Default is <u>true</u>.

                <u>stream</u>:
                  Streams the body of a 200 or 206 response to the calling process or to a file. When  streaming
                  to  the  calling  process  using  option  <u>self</u>, the following stream messages are sent to that
                  process: <u>{http,</u> <u>{RequestId,</u> <u>stream_start,</u> <u>Headers}},</u> <u>{http,</u> <u>{RequestId,</u> <u>stream,</u> <u>BinBodyPart}},</u>
                  <u>and</u> <u>{http,</u> <u>{RequestId,</u> <u>stream_end,</u> <u>Headers}}</u>.

                  When streaming to the calling processes using option <u>{self,</u> <u>once}</u>, the first  message  has  an
                  extra  element,  that is, <u>{http,</u> <u>{RequestId,</u> <u>stream_start,</u> <u>Headers,</u> <u>Pid}}</u>. This is the process
                  id to be used as an argument to <u>httpc:stream_next/1</u> to trigger the next message to be sent  to
                  the calling process.

                  Notice  that chunked encoding can add headers so that there are more headers in the <u>stream_end</u>
                  message than in <u>stream_start</u>. When streaming to a file and the request  is  asynchronous,  the
                  message <u>{http,</u> <u>{RequestId,</u> <u>saved_to_file}}</u> is sent.

                  Default is <u>none</u>.

                <u>body_format</u>:
                  Defines  if  the  body is to be delivered as a string or binary. This option is only valid for
                  the synchronous request.

                  Default is <u>string</u>.

                <u>full_result</u>:
                  Defines if a "full result" is to be returned to the caller (that is, the  body,  the  headers,
                  and the entire status line) or not (the body and the status code).

                  Default is <u>true</u>.

                <u>headers_as_is</u>:
                  Defines  if  the  headers  provided by the user are to be made lower case or to be regarded as
                  case sensitive.

                  The HTTP standard requires them to be case insensitive. Use this feature only if there  is  no
                  other  way to communicate with the server or for testing purpose. When this option is used, no
                  headers are automatically added. All necessary headers must be provided by the user.

                  Default is <u>false</u>.

                <u>socket_opts</u>:
                  Socket options to be used for this request.

                  Overrides any value set by function set_options.

                  The validity of the options is <u>not</u> checked by the HTTP client they are assumed to  be  correct
                  and  passed  on  to  ssl  application  and  inet driver, which may reject them if they are not
                  correct.

            <b>Note:</b>
                Persistent connections are not supported when setting the <u>socket_opts</u> option.  When  <u>socket_opts</u>
                is  not  set  the current implementation assumes the requests to the same host, port combination
                will use the same socket options.

                  By default the socket options set by function set_options/[1,2] are used when  establishing  a
                  connection.

                <u>receiver</u>:
                  Defines  how  the  client  delivers  the result of an asynchronous request (<u>sync</u> has the value
                  <u>false</u>).

                  <u>pid()</u>:
                    Messages are sent to this process in the format <u>{http,</u> <u>ReplyInfo}</u>.

                  <u>function/1</u>:
                    Information  is  delivered  to  the   receiver   through   calls   to   the   provided   fun
                    <u>Receiver(ReplyInfo)</u>.

                  <u>{Module,</u> <u>Function,</u> <u>Args}</u>:
                    Information   is   delivered  to  the  receiver  through  calls  to  the  callback  function
                    <u>apply(Module,</u> <u>Function,</u> <u>[ReplyInfo</u> <u>|</u> <u>Args])</u>.

                  In all of these cases, <u>ReplyInfo</u> has the following structure:

                {RequestId, saved_to_file}
                {RequestId, {error, Reason}}
                {RequestId, Result}
                {RequestId, stream_start, Headers}
                {RequestId, stream_start, Headers, HandlerPid}
                {RequestId, stream, BinBodyPart}
                {RequestId, stream_end, Headers}

                  Default is the <u>pid</u> of the process calling the request function (<u>self()</u>).

                <u>ipv6_host_with_brackets</u>:
                  Defines when parsing the Host-Port part of an URI with an IPv6 address with brackets, if those
                  brackets are to be retained (<u>true</u>) or stripped (<u>false</u>).

                  Default is <u>false</u>.

       <b>set_options(Options)</b> <b>-&gt;</b>
       <b>set_options(Options,</b> <b>Profile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Options = [Option]
                 Option = {proxy, {Proxy, NoProxy}}
                 | {https_proxy, {Proxy, NoProxy}}
                 | {max_sessions, MaxSessions}
                 | {max_keep_alive_length, MaxKeepAlive}
                 | {keep_alive_timeout, KeepAliveTimeout}
                 | {max_pipeline_length, MaxPipeline}
                 | {pipeline_timeout, PipelineTimeout}
                 | {cookies, CookieMode}
                 | {ipfamily, IpFamily}
                 | {ip, IpAddress}
                 | {port, Port}
                 | {socket_opts, socket_opts()}
                 | {verbose, VerboseMode}
                 | {unix_socket, UnixSocket}
                 Proxy = {Hostname, Port}
                 Hostname = http_string()
                   Example: "localhost" or "foo.bar.se"
                 Port = integer()
                   Example: 8080
                 NoProxy = [NoProxyDesc]
                 NoProxyDesc = DomainDesc | HostName | IPDesc
                 DomainDesc = "*.Domain"
                   Example: "*.ericsson.se"
                 IpDesc = http_string()
                   Example: "134.138" or "[FEDC:BA98" (all IP addresses starting  with  134.138  or  FEDC:BA98),
                   "66.35.250.150"  or  "[2010:836B:4179::836B:4179]" (a complete IP address). <u>proxy</u> defaults to
                   <u>{undefined,</u> <u>[]}</u>, that is, no proxy is configured and <u>https_proxy</u> defaults  to  the  value  of
                   <u>proxy</u>.
                 MaxSessions = integer()
                   Maximum number of persistent connections to a host. Default is <u>2</u>.
                 MaxKeepAlive = integer()
                   Maximum number of outstanding requests on the same connection to a host. Default is <u>5</u>.
                 KeepAliveTimeout = integer()
                   If  a  persistent  connection is idle longer than the <u>keep_alive_timeout</u> in milliseconds, the
                   client closes the connection. The server can also have such a time-out but do not  take  that
                   for granted. Default is <u>120000</u> (= 2 min).
                 MaxPipeline = integer()
                   Maximum number of outstanding requests on a pipelined connection to a host. Default is <u>2</u>.
                 PipelineTimeout = integer()
                   If  a  persistent  connection  is  idle longer than the <u>pipeline_timeout</u> in milliseconds, the
                   client closes the connection. Default is <u>0</u>, which results in pipelining not being used.
                 CookieMode = enabled | disabled | verify
                   If cookies are enabled, all valid cookies are automatically saved in the cookie  database  of
                   the  client  manager. If option <u>verify</u> is used, function <u>store_cookies/2</u> has to be called for
                   the cookies to be saved. Default is <u>disabled</u>.
                 IpFamily = inet | inet6 | local
                   Default is <u>inet</u>.
                 IpAddress = ip_address()
                   If the host has several network interfaces, this option  specifies  which  one  to  use.  See
                   gen_tcp:connect/3,4 for details.
                 Port = integer()
                   Local port number to use. See gen_tcp:connect/3,4 for details.
                 socket_opts() = [socket_opt()]
                   The  options  are  appended  to  the socket options used by the client. These are the default
                   values when a new request handler is started (for  the  initial  connect).  They  are  passed
                   directly to the underlying transport (<u>gen_tcp</u> or <u>SSL</u>) <u>without</u> verification.
                 VerboseMode = false | verbose | debug | trace
                   Default  is <u>false</u>. This option is used to switch on (or off) different levels of Erlang trace
                   on the client. It is a debug feature.
                 Profile = profile() | pid()
                   When started <u>stand_alone</u> only the pid can be used.
                 UnixSocket = path()
                    Experimental option for sending HTTP requests over  a  unix  domain  socket.  The  value  of
                   <u>unix_socket</u>  shall  be the full path to a unix domain socket file with read/write permissions
                   for the erlang process. Default is <u>undefined</u>.

              Sets options to be used for subsequent requests.

          <b>Note:</b>
              If possible, the client keeps its connections  alive  and  uses  persistent  connections  with  or
              without  pipeline depending on configuration and current circumstances. The HTTP/1.1 specification
              does not provide a guideline for how many requests that are ideal  to  be  sent  on  a  persistent
              connection. This depends much on the application.

              A  long  queue  of  requests can cause a user-perceived delay, as earlier requests can take a long
              time to complete. The HTTP/1.1 specification suggests a limit of two  persistent  connections  per
              server, which is the default value of option <u>max_sessions</u>.

              The  current  implementation  assumes the requests to the same host, port combination will use the
              same socket options.

       <b>store_cookies(SetCookieHeaders,</b> <b>Url)</b> <b>-&gt;</b>
       <b>store_cookies(SetCookieHeaders,</b> <b>Url,</b> <b>Profile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SetCookieHeaders = headers() - where field = "set-cookie"
                 Url = url()
                 Profile = profile() | pid()
                   When started <u>stand_alone</u> only the pid can be used.

              Saves the cookies defined in <u>SetCookieHeaders</u> in the client profile  cookie  database.  Call  this
              function  if  option  <u>cookies</u> is set to <u>verify</u>. If no profile is specified, the default profile is
              used.

       <b>stream_next(Pid)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Pid = pid()
                   As received in the <u>stream_start</u> <u>message</u>

              Triggers the next message to be streamed, that is, the same behavior as active ones for sockets.

       <b>which_cookies()</b> <b>-&gt;</b> <b>cookies()</b>
       <b>which_cookies(Profile)</b> <b>-&gt;</b> <b>cookies()</b>

              Types:

                 Profile = profile() | pid()
                   When started <u>stand_alone</u> only the pid can be used.
                 cookies() = [cookie_stores()]
                 cookie_stores() = {cookies, cookies()} | {session_cookies, cookies()}
                 cookies() = [cookie()]
                 cookie() = term()

              Produces a list of the entire cookie database. Intended  for  debugging/testing  purposes.  If  no
              profile is specified, the default profile is used.

       <b>which_sessions()</b> <b>-&gt;</b> <b>session_info()</b>
       <b>which_sessions(Profile)</b> <b>-&gt;</b> <b>session_info()</b>

              Types:

                 Profile = profile() | pid()
                   When started <u>stand_alone</u> only the pid can be used.
                 session_info() = {[session()], [term()], [term()]}
                 session() = term() - Internal representation of a session

              This function is intended for debugging only. It produces a slightly processed dump of the session
              database.  The  first list of the session information tuple will contain session information on an
              internal format. The last two lists of the session information tuple should always be empty if the
              code is working as intended. If no profile is specified, the default profile is used.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       RFC 2616, <a href="../man3erl/inets.3erl.html">inets</a>(3erl), <a href="../man3erl/gen_tcp.3erl.html">gen_tcp</a>(3erl), <a href="../man3erl/ssl.3erl.html">ssl</a>(3erl)

Ericsson AB                                         inets 7.5                                        <u><a href="../man3erl/httpc.3erl.html">httpc</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>