<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::OAuth2::Profile::WebServer - OAuth2 for web-server use</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-oauth2-perl">libnet-oauth2-perl_0.67-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::OAuth2::Profile::WebServer - OAuth2 for web-server use

</pre><h4><b>INHERITANCE</b></h4><pre>
        Net::OAuth2::Profile::WebServer
          is a Net::OAuth2::Profile

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # See examples/psgi/
         my $auth = Net::OAuth2::Profile::WebServer-&gt;new
           ( name           =&gt; 'Google Contacts'
           , client_id      =&gt; $id
           , client_secret  =&gt; $secret
           , site           =&gt; 'https://accounts.google.com'
           , scope          =&gt; 'https://www.google.com/m8/feeds/'
           , authorize_path    =&gt; '/o/oauth2/auth'
           , access_token_path =&gt; '/o/oauth2/token'
           , protected_resource_url
               =&gt;  'https://www.google.com/m8/feeds/contacts/default/full'
           );

         # Let user ask for a grant from the resource owner
         print $auth-&gt;authorize_response-&gt;as_string;
         # or, in Plack:   redirect $auth-&gt;authorize;

         # Prove your identity at the authorization server
         # The $info are the parameters from the callback to your service, it
         # will contain a 'code' value.
         my $access_token  = $auth-&gt;get_access_token($info-&gt;{code});

         # communicate with the resource serve
         my $response      = $access_token-&gt;get('/me');
         $response-&gt;is_success
             or die "error: " . $response-&gt;status_line;

         print "Yay, it worked: " . $response-&gt;decoded_content;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Use OAuth2 in a WebServer context.  Read the DETAILS section, far below this man-page before you start
       implementing this interface.

       Extends "DESCRIPTION" in Net::OAuth2::Profile.

</pre><h4><b>METHODS</b></h4><pre>
       Extends "METHODS" in Net::OAuth2::Profile.

   <b>Constructors</b>
       Extends "Constructors" in Net::OAuth2::Profile.

       Net::OAuth2::Profile::WebServer-&gt;<b>new</b>(%options)
            -Option           --Defined in          --Default
             auto_save                                &lt;set token's changed flag&gt;
             client_id          Net::OAuth2::Profile  &lt;required&gt;
             client_secret      Net::OAuth2::Profile  &lt;required&gt;
             grant_type         Net::OAuth2::Profile  'authorization_code'
             hd                 Net::OAuth2::Profile  undef
             redirect_uri                             undef
             referer                                  undef
             scope              Net::OAuth2::Profile  undef
             secrets_in_params  Net::OAuth2::Profile  &lt;true&gt;
             site               Net::OAuth2::Profile  undef
             state              Net::OAuth2::Profile  undef
             token_scheme       Net::OAuth2::Profile  'auth-header:Bearer'
             user_agent         Net::OAuth2::Profile  &lt;created internally&gt;

           auto_save =&gt; CODE
             When  a  new  token is received or refreshed, it usually needs to get save into a database or file.
             The moment you receive a new token is clear, but being aware of refreshes in your main program is a
             hassle.  Read more about configuring this in the "DETAILS" section below.

           client_id =&gt; STRING
           client_secret =&gt; STRING
           grant_type =&gt; STRING
           hd =&gt; STRING
           redirect_uri =&gt; URI
           referer =&gt; URI
             Adds a "Referer" header to each request.  Some servers  check  whether  provided  redirection  uris
             point to the same server the page where the link was found.

           scope =&gt; STRING
           secrets_in_params =&gt; BOOLEAN
           site =&gt; URI
           state =&gt; STRING
           token_scheme =&gt; SCHEME
           user_agent =&gt; LWP::UserAgent object

   <b>Accessors</b>
       Extends "Accessors" in Net::OAuth2::Profile.

       $obj-&gt;<b>auto_save</b>()
       $obj-&gt;<b>bearer_token_scheme</b>()
           Inherited, see "Accessors" in Net::OAuth2::Profile

       $obj-&gt;<b>grant_type</b>()
           Inherited, see "Accessors" in Net::OAuth2::Profile

       $obj-&gt;<b>hd</b>()
           Inherited, see "Accessors" in Net::OAuth2::Profile

       $obj-&gt;<b>id</b>()
           Inherited, see "Accessors" in Net::OAuth2::Profile

       $obj-&gt;<b>redirect_uri</b>()
       $obj-&gt;<b>referer</b>( [$uri] )
       $obj-&gt;<b>scope</b>()
           Inherited, see "Accessors" in Net::OAuth2::Profile

       $obj-&gt;<b>secret</b>()
           Inherited, see "Accessors" in Net::OAuth2::Profile

       $obj-&gt;<b>site</b>()
           Inherited, see "Accessors" in Net::OAuth2::Profile

       $obj-&gt;<b>state</b>()
           Inherited, see "Accessors" in Net::OAuth2::Profile

       $obj-&gt;<b>user_agent</b>()
           Inherited, see "Accessors" in Net::OAuth2::Profile

   <b>Actions</b>
       Extends "Actions" in Net::OAuth2::Profile.

       $obj-&gt;<b>authorize</b>(%options)
           On  initial contact of a new user, you have to redirect to the resource owner.  Somewhere in the near
           future, your application will be contacted again by the same user  but  then  with  an  authorization
           grant code.

           Only  the  most  common  %options  are listed... there may be more: read the docs on what your server
           expects.

            -Option       --Default
             client_id      new(client_id)
             response_type  'code'
             scope          undef
             state          undef

           client_id =&gt; STRING
           response_type =&gt; STRING
           scope =&gt; STRING
           state =&gt; STRING

           example:

             my $auth = Net::OAuth2::Profile::WebServer-&gt;new(...);

             # From the Plack demo, included in this distribution (on CPAN)
             get '/get' =&gt; sub { redirect $auth-&gt;authorize };

             # In generic HTTP, see method authorize_response
             use HTTP::Status 'HTTP_TEMPORARY_REDIRECT';   # 307
             print HTTP::Response-&gt;new
               ( HTTP_TEMPORARY_REDIRECT =&gt; 'Get authorization grant'
               , [ Location =&gt; $auth-&gt;authorize ]
               )-&gt;as_string;

       $obj-&gt;<b>authorize_response</b>( [$request] )
           Convenience wrapper around <b>authorize()</b>, to produce a complete HTTP::Response object to be sent back.

       $obj-&gt;<b>get_access_token</b>(CODE, %options)
            -Option       --Default
             client_id      new(client_id)
             client_secret  new(client_secret)

           client_id =&gt; STRING
           client_secret =&gt; STRING
       $obj-&gt;<b>update_access_token</b>($token, %options)
           Ask the server for a new token.  You may pass additional %options as pairs.  However, this method  is
           often  triggered  automatically,  in  which  case you can to use the "refresh_token_params" option of
           <b>new()</b>.

           example:

             $auth-&gt;update_access_token($token);
             $token-&gt;refresh;   # nicer

   <b>Helpers</b>
       Extends "Helpers" in Net::OAuth2::Profile.

       $obj-&gt;<b>add_token</b>($request, $token, $scheme)
           Inherited, see "Helpers" in Net::OAuth2::Profile

       $obj-&gt;<b>build_request</b>($method, $uri, $params)
           Inherited, see "Helpers" in Net::OAuth2::Profile

       $obj-&gt;<b>params_from_response</b>($response, $reason)
           Inherited, see "Helpers" in Net::OAuth2::Profile

       $obj-&gt;<b>site_url</b>( &lt;$uri|$path&gt;, $params )
           Inherited, see "Helpers" in Net::OAuth2::Profile

</pre><h4><b>DETAILS</b></h4><pre>
       OAuth2 is a server-server protocol, not the usual client-server  set-up.  The  consequence  is  that  the
       protocol  handlers  on  both  sides  will  not wait for another during the communication: the remote uses
       callback urls to pass on the response.  Your side of the communication, your  webservice,  needs  to  re-
       group these separate processing steps into logical sessions.

   <b>The</b> <b>process</b>
       The     client     side     of     the     process    has    three    steps,    nicely    described    in
       &lt;https://tools.ietf.org/html/rfc6749|RFC6749&gt;

       1. Send an authorization request to resource owner
           It needs a "client_id": usually the name of the service where you want get access to.  The answer  is
           a  redirect,  based on the "redirection_uri" which you usually pass on.  Additional "scope", "state",
           and "hd" parameters can be needed or useful.  The redirect  will  provide  you  with  (amongst  other
           things) a "code" parameter.

       2. Translate the code into an access token
           With the code, you go to an authorization server which will validate your existence.  An access token
           (and sometimes a refresh token) are returned.

       3. Address the protected resource
           The  access  token,  usually  a  'bearer' token, is added to each request to the resource you want to
           address.  The token may refresh itself when needed.

   <b>Saving</b> <b>the</b> <b>token</b>
       Your application must implement a persistent session, probably  in  a  database  or  file.   The  session
       information  is  kept  in  an  Net::OAuth2::AccessToken object, and does contain more facts than just the
       access token.

       Let's discuss the three approaches.

       <u>no</u> <u>saving</u>

       The Plack example contained in the CPAN distribution of this module is  a  single  process  server.   The
       tokens are administered in the memory of the process.  It is nice to test your settings, but probably not
       realistic for any real-life application.

       <u>automatic</u> <u>saving</u>

       When your own code is imperative:

         my $auth = Net::OAuth2::Profile::WebServer-&gt;new
           ( ...
           , auto_save =&gt; \&amp;save_session
           );

         sub save_session($$)
         {   my ($profile, $token) = @_;
             ...
         }

       When your own code is object oriented:

         sub init(...)
         {  my ($self, ...) = @_;
            my $auth = Net::OAuth2::Profile::WebServer-&gt;new
              ( ...
              , auto_save =&gt; sub { $self-&gt;save_session(@_) }
              );
         }

         sub save_session($$)
         {   my ($self, $profile, $token) = @_;
             ...
         }

       <u>explicit</u> <u>saving</u>

       In this case, do not use new(auto_save).

</pre><h4><b>COPYRIGHTS</b></h4><pre>
       Copyrights 2013-2019 on the perl code and the related documentation
        by  [Mark  Overmeer  &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]  for  SURFnet  bv,  The Netherlands.  For other contributors see
       "Changes".

       Copyrights 2011-2012 by Keith Grennan.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.32.1                                       2021-10-15               <u>Net::OAuth2::Profile::<a href="../man3pm/WebServer.3pm.html">WebServer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>