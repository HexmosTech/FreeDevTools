<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log::Report::Message - a piece of text to be translated</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblog-report-perl">liblog-report-perl_1.40-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Log::Report::Message - a piece of text to be translated

</pre><h4><b>INHERITANCE</b></h4><pre>
        Log::Report::Message is extended by
          Dancer2::Plugin::LogReport::Message

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # Objects created by Log::Report's __ functions
        # Full feature description in the DETAILS section

        # no interpolation
        __"Hello, World";

        # with interpolation
        __x"age {years}", years =&gt; 12;

        # interpolation for one or many
        my $nr_files = @files;
        __nx"one file", "{_count} files", $nr_files;
        __nx"one file", "{_count} files", \@files;

        # interpolation of arrays
        __x"price-list: {prices%.2f}", prices =&gt; \@prices, _join =&gt; ', ';

        # white-spacing on msgid preserved
        print __"\tCongratulations,\n";
        print "\t", __("Congratulations,"), "\n";  # same

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Any use of a translation function exported by Log::Report, like "__()" (the function is named underscore-
       underscore) or "__x()" (underscore-underscore-x) will result in this object.  It will capture some
       environmental information, and delay the translation until it is needed.

       Creating an object first and translating it later, is slower than translating it immediately.  However,
       on the location where the message is produced, we do not yet know in what language to translate it to:
       that depends on the front-end, the log dispatcher.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Constructors</b>
       $obj-&gt;<b>clone</b>(%options, $variables)
           Returns  a new object which copies info from original, and updates it with the specified %options and
           $variables.  The advantage is that the cached translations are shared between the objects.

           example: use of <b>clone()</b>

            my $s = __x "found {nr} files", nr =&gt; 5;
            my $t = $s-&gt;clone(nr =&gt; 3);
            my $t = $s-&gt;(nr =&gt; 3);      # equivalent
            print $s;     # found 5 files
            print $t;     # found 3 files

       Log::Report::Message-&gt;<b>fromTemplateToolkit</b>($domain, $msgid, $params)
           See Log::Report::Extract::Template on the details how  to  integrate  Log::Report  translations  with
           Template::Toolkit (version 1 and 2)

       Log::Report::Message-&gt;<b>new</b>(%options)
           <b>End-users:</b> <b>do</b> <b>not</b> <b>use</b> <b>this</b> <b>method</b> <b>directly</b>, but use Log::Report::__() and friends.  The %options is a
           mixed list of object initiation parameters (all with a leading underscore) and variables to be filled
           in into the translated "_msgid" string.

            -Option   --Default
             _append    undef
             _category  undef
             _class     []
             _classes   []
             _context   undef
             _count     undef
             _domain    &lt;from "use Log::Report"&gt;
             _expand    false
             _join      $" $LIST_SEPARATOR
             _lang      &lt;from locale&gt;
             _msgctxt   undef
             _msgid     undef
             _plural    undef
             _prepend   undef
             _to        &lt;undef&gt;

           _append =&gt; STRING|MESSAGE
             Text as STRING or MESSAGE object to be displayed after the display of this message.

           _category =&gt; INTEGER
             The category when the real gettext library is used, for instance LC_MESSAGES.

           _class =&gt; STRING|ARRAY
             When messages are used for exception based programming, you add "_class" parameters to the argument
             list.   Later,  with  for instance Log::Report::Dispatcher::Try::wasFatal(class), you can check the
             category of the message.

             One message can be part of multiple classes.  The STRING is used as comma- and/or  blank  separated
             list of class tokens (barewords), the ARRAY lists all tokens separately. See <b>classes()</b>.

           _classes =&gt; STRING|ARRAY
             Alternative for "_class", which cannot be used at the same time.

           _context =&gt; WORDS|ARRAY
             [1.00]  Set  keywords  which  can  be  used  to select alternatives between translations.  Read the
             DETAILS section in Log::Report::Translator::Context

           _count =&gt; INTEGER|ARRAY|HASH
             When defined, the "_plural" need to be defined as well.  When an ARRAY is provided, the  length  of
             the ARRAY is taken.  When a HASH is given, the number of keys in the HASH is used.

           _domain =&gt; STRING
             The text-domain (translation table) to which this "_msgid" belongs.

             With  this  parameter, your can "borrow" translations from other textdomains.  Be very careful with
             this (although there are good use-cases)  The xgettext msgid extractor may add the  used  msgid  to
             this namespace as well.  To avoid that, add a harmless '+':

               print __x(+"errors", _domain =&gt; 'global');

             The  extractor  will  not  take  the  msgid when it is an expression.  The '+' has no effect on the
             string at runtime.

           _expand =&gt; BOOLEAN
             Indicates whether variables are to be filled-in.

           _join =&gt; STRING
             Which STRING to be used then an ARRAY is being filled-in.

           _lang =&gt; ISO
             [1.00] Override language setting from locale, for instance because that is not configured correctly
             (yet).  This does not extend to prepended or appended translated message object.

           _msgctxt =&gt; STRING
             [1.22] Message context in the translation file, the  traditional  use.   Cannot  be  combined  with
             "_context" on the same msgids.

           _msgid =&gt; MSGID
             The  message  label, which refers to some translation information.  Usually a string which is close
             the English version  of  the  message.   This  will  also  be  used  if  there  is  no  translation
             possible/known.

             Leading  white-space  "\s"  will be added to "_prepend".  Trailing white-space will be added before
             "_append".

           _plural =&gt; MSGID
             Can be used together with "_count".  This plural form of the "_msgid" text is used to simplify  the
             work  of  translators,  and  as  fallback when no translation is possible: therefore, this can best
             resemble an English message.

             White-space at the beginning and end of the string are stripped off.  The white-space  provided  by
             the "_msgid" will be used.

           _prepend =&gt; STRING|MESSAGE
             Text as STRING or MESSAGE object to be displayed before the display of this message.

           _to =&gt; NAME
             Specify  the  NAME of a dispatcher as destination explicitly. Short for  "report {to =&gt; NAME}, ..."
             See <b>to()</b>

   <b>Accessors</b>
       $obj-&gt;<b>append</b>()
           Returns the string or Log::Report::Message object which is appended after this one.  Usually "undef".

       $obj-&gt;<b>classes</b>()
           Returns the LIST of classes which are defined for this message; message group  indicators,  as  often
           found in exception-based programming.

       $obj-&gt;<b>context</b>()
           Returns an HASH if there is a context defined for this message.

       $obj-&gt;<b>count</b>()
           Returns the count, which is used to select the translation alternatives.

       $obj-&gt;<b>domain</b>()
           Returns the domain of the first translatable string in the structure.

       $obj-&gt;<b>errno</b>( [$errno] )
           [1.38]  Returns the value of the "_errno" key, to indicate the error number (to be returned from your
           script).  Usually, this method will return undef.  For FAILURE, FAULT, and ALERT,  the  errno  is  by
           default taken from $! and $?.

       $obj-&gt;<b>msgctxt</b>()
           The message context for the translation table lookup.

       $obj-&gt;<b>msgid</b>()
           Returns the msgid which will later be translated.

       $obj-&gt;<b>prepend</b>()
           Returns the string which is prepended to this one.  Usually "undef".

       $obj-&gt;<b>to</b>( [$name] )
           Returns the $name of a dispatcher if explicitly specified with the '_to' key. Can also be used to set
           it.  Usually, this will return undef, because usually all dispatchers get all messages.

       $obj-&gt;<b>valueOf</b>($parameter)
           Lookup  the  named  $parameter  for  the  message.  All pre-defined names have their own method which
           should be used with preference.

           example:

           When the message was produced with

             my @files = qw/one two three/;
             my $msg = __xn "found one file: {file}"
                          , "found {nrfiles} files: {files}"
                          , scalar @files
                          , file    =&gt; $files[0]
                          , files   =&gt; \@files
                          , nrfiles =&gt; @files+0  # or scalar(@files)
                          , _class  =&gt; 'IO, files'
                          , _join   =&gt; ', ';

           then the values can be takes from the produced message as

             my $files = $msg-&gt;valueOf('files');  # returns ARRAY reference
             print @$files;              # 3
             my $count = $msg-&gt;count;    # 3
             my @class = $msg-&gt;classes;  # 'IO', 'files'
             if($msg-&gt;inClass('files'))  # true

           Simplified, the above example can also be written as:

             local $" = ', ';
             my $msg  = __xn "found one file: {files}"
                           , "found {_count} files: {files}"
                           , @files      # has scalar context
                           , files   =&gt; \@files
                           , _class  =&gt; 'IO, files';

   <b>Processing</b>
       $obj-&gt;<b>concat</b>( STRING|$object, [$prepend] )
           This method implements the overloading of concatenation, which is needed to delay  translations  even
           longer.   When  $prepend  is  true,  the  STRING  or  $object (other "Log::Report::Message") needs to
           prepended, otherwise it is appended.

           example: of concatenation

            print __"Hello" . ' ' . __"World!";
            print __("Hello")-&gt;concat(' ')-&gt;concat(__"World!")-&gt;concat("\n");

       $obj-&gt;<b>inClass</b>($class|Regexp)
           Returns true if the message is in the specified $class (string) or matches the  Regexp.   The  trueth
           value is the (first matching) class.

       $obj-&gt;<b>toHTML</b>( [$locale] )
           [1.11] Translate the message, and then entity encode HTML volatile characters.

           [1.20]  When  used  in  combination  with  a  templating system, you may want to use "&lt;content_for ="
           'HTML'&gt;&gt; in Log::Report::Domain::configure(formatter).

           example:

             print $msg-&gt;toHTML('NL');

       $obj-&gt;<b>toString</b>( [$locale] )
           Translate a message.  If not specified, the default locale is used.

       $obj-&gt;<b>untranslated</b>()
           Return the concatenation of the prepend, msgid, and append strings.  Variable expansions  within  the
           msgid is not performed.

</pre><h4><b>DETAILS</b></h4><pre>
   <b>OPTIONS</b> <b>and</b> <b>VARIABLES</b>
       The Log::Report functions which define translation request can all have OPTIONS.  Some can have VARIABLES
       to  be interpolated in the string as well.  To distinguish between the OPTIONS and VARIABLES (both a list
       of key-value pairs), the keys of the OPTIONS start with an underscore "_".  As  result  of  this,  please
       avoid  the  use  of  keys  which  start with an underscore in variable names.  On the other hand, you are
       allowed to interpolate OPTION values in your strings.

       <u>Interpolating</u>

       With the "__x()" or "__nx()", interpolation  will  take  place  on  the  translated  MSGID  string.   The
       translation  can  contain  the  VARIABLE  and  OPTION  names  between curly brackets.  Text between curly
       brackets which is not a known parameter will be left untouched.

        fault __x"cannot open open {filename}", filename =&gt; $fn;

        print __xn"directory {dir} contains one file"
                 ,"directory {dir} contains {nr_files} files"
                 , scalar(@files)            # (1) (2)
                 , nr_files =&gt; scalar @files # (3)
                 , dir      =&gt; $dir;

       (1) this required third parameter is used to switch between the different plural forms.  English has only
       two forms, but some languages have many more.

       (2) the "scalar" keyword is not needed, because the third parameter is in SCALAR context.  You  may  also
       pass  "  \@files  "  there, because ARRAYs will be converted into their length.  A HASH will be converted
       into the number of keys in the HASH.

       (3) the "scalar" keyword is required here, because it is LIST context: otherwise all  filenames  will  be
       filled-in  as  parameters  to  "__xn()".   See  below  for  the available "_count" valure, to see how the
       "nr_files" parameter can disappear.

       <u>Interpolation</u> <u>of</u> <u>VARIABLES</u>

       "Log::Report" uses String::Print to interpolate values in(translated) messages.  This is a very  powerful
       syntax,  and  you  should  certainly read that manual-page.  Here, we only described additional features,
       specific to the usage of "String::Print" in "Log::Report::Message" objects.

       There is no way of checking beforehand whether you have provided all required values, to be  interpolated
       in the translated string.

       For interpolating, the following rules apply:

       •   Simple scalar values are interpolated "as is"

       •   References  to  SCALARs  will  collect  the  value  on  the  moment  that  the  output  is made.  The
           "Log::Report::Message" object which is created with the  "__xn"  can  be  seen  as  a  closure.   The
           translation can be reused.  See example below.

       •   Code  references can be used to create the data "under fly".  The "Log::Report::Message" object which
           is being handled is passed as only argument.  This is a hash in which all OPTIONS and  VARIABLES  can
           be found.

       •   When  the  value  is  an  ARRAY,  all  members  will  be  interpolated  with $" between the elements.
           Alternatively (maybe nicer), you can pass an interpolation parameter via the "_join" OPTION.

        local $" = ', ';
        error __x"matching files: {files}", files =&gt; \@files;

        error __x"matching files: {files}", files =&gt; \@files, _join =&gt; ', ';

       <u>Interpolation</u> <u>of</u> <u>OPTIONS</u>

       You are permitted the interpolate OPTION values in your string.  This  may  simplify  your  coding.   The
       useful names are:

       _msgid
           The MSGID as provided with Log::Report::__() and Log::Report::_<b>_x()</b>

       _plural, _count
           The PLURAL MSGIDs, respectively the COUNT as used with Log::Report::_<b>_n()</b> and Log::Report::_<b>_nx()</b>

       _textdomain
           The label of the textdomain in which the translation takes place.

       _class or _classes
           Are    to    be    used    to    group    reports,    and    can    be    queried   with   <b>inClass()</b>,
           <b>Log::Report::Exception::inClass()</b>, or <b>Log::Report::Dispatcher::Try::wasFatal()</b>.

       <b>.</b> <b>Example:</b> <b>using</b> <b>the</b> <b>_count</b>

       With Locale::TextDomain, you have to do

         use Locale::TextDomain;
         print __nx ( "One file has been deleted.\n"
                    , "{num} files have been deleted.\n"
                    , $num_files
                    , num =&gt; $num_files
                    );

       With "Log::Report", you can do

         use Log::Report;
         print __nx ( "One file has been deleted.\n"
                    , "{_count} files have been deleted.\n"
                    , $num_files
                    );

       Of course, you need to be aware that the name used to reference the counter is fixed  to  "_count".   The
       first example works as well, but is more verbose.

       <u>Handling</u> <u>white-spaces</u>

       In  above examples, the msgid and plural form have a trailing new-line.  In general, it is much easier to
       write

          print __x"Hello, World!\n";

       than

          print __x("Hello, World!") . "\n";

       For the translation tables, however, that trailing new-line is "over information"; it is an layout issue,
       not a translation issue.

       Therefore, the first form will automatically be translated into the second.   All  leading  and  trailing
       white-space  (blanks, new-lines, tabs, ...) are removed from the msgid before the look-up, and then added
       to the translated string.

       Leading and trailing white-space on the plural form will also be removed.  However, after translation the
       spacing of the msgid will be used.

       <u>Avoiding</u> <u>repetative</u> <u>translations</u>

       This way of translating is somewhat expensive, because an object to handle the "__x()"  is  created  each
       time.

        for my $i (1..100_000)
        {   print __x "Hello World {i}\n", i =&gt; $i;
        }

       The  suggestion  that  Locale::TextDomain makes to improve performance, is to get the translation outside
       the loop, which only works without interpolation:

        use Locale::TextDomain;
        my $i = 42;
        my $s = __x("Hello World {i}\n", i =&gt; $i);
        foreach $i (1..100_000)
        {   print $s;
        }

       Oops, not what you mean because the first value of $i is captured in the initial  message  object.   With
       Log::Report, you can do it (except when you use contexts)

        use Log::Report;
        my $i;
        my $s = __x("Hello World {i}\n", i =&gt; \$i);
        foreach $i (1..100_000)
        {   print $s;
        }

       Mind you not to write: "for my $i" in above case!!!!

       You can also write an incomplete translation:

        use Log::Report;
        my $s = __x "Hello World {i}\n";
        foreach my $i (1..100_000)
        {   print $s-&gt;(i =&gt; $i);
        }

       In either case, the translation will be looked-up only once.

</pre><h4><b>OVERLOADING</b></h4><pre>
       overload: <b>as</b> <b>$function</b>
           When the object is used to call as $function, a new object is created with the data from the original
           one but updated with the new parameters.  Implemented in clone().

       overload: <b>concatenation</b>
           An (accidental) use of concatenation (a dot where a comma should be used) would immediately stringify
           the object.  This is avoided by overloading that operation.

       overload: <b>stringification</b>
           When the object is used in string context, it will get translated.  Implemented as <b>toString()</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This  module  is  part  of  Log-Report  distribution  version  1.40,  built  on  April 18, 2025. Website:
       <u><a href="http://perl.overmeer.net/CPAN/">http://perl.overmeer.net/CPAN/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2007-2025 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.1                                       2025-04-20                          <u>Log::Report::<a href="../man3pm/Message.3pm.html">Message</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>