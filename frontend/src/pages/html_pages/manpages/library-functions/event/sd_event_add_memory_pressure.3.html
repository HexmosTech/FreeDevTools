<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sd_event_add_memory_pressure, sd_event_source_set_memory_pressure_type,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsystemd-dev">libsystemd-dev_257.7-1ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sd_event_add_memory_pressure, sd_event_source_set_memory_pressure_type,
       sd_event_source_set_memory_pressure_period, sd_event_trim_memory - Add and configure an event source run
       as result of memory pressure

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;systemd/sd-event.h&gt;</b>

       <b>typedef</b> <b>struct</b> <b>sd_event_source</b> <b>sd_event_source;</b>

       <b>int</b> <b>sd_event_add_memory_pressure(sd_event</b> <b>*</b><u>event</u><b>,</b> <b>sd_event_source</b> <b>**</b><u>ret_source</u><b>,</b>
                                        <b>sd_event_handler_t</b> <u>handler</u><b>,</b> <b>void</b> <b>*</b><u>userdata</u><b>);</b>

       <b>int</b> <b>sd_event_source_set_memory_pressure_type(sd_event_source</b> <b>*</b><u>source</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>type</u><b>);</b>

       <b>int</b> <b>sd_event_source_set_memory_pressure_period(sd_event_source</b> <b>*</b><u>source</u><b>,</b> <b>uint64_t</b> <u>threshold_usec</u><b>,</b>
                                                      <b>uint64_t</b> <u>window_usec</u><b>);</b>

       <b>int</b> <b>sd_event_trim_memory(void);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sd_event_add_memory_pressure()</b> adds a new event source that is triggered whenever memory pressure is
       seen. This functionality is built around the Linux kernel's <b>Pressure</b> <b>Stall</b> <b>Information</b> <b>(PSI)</b>[1] logic.

       Expects an event loop object as first parameter, and returns the allocated event source object in the
       second parameter, on success. The <u>handler</u> parameter is a function to call when memory pressure is seen,
       or <b>NULL</b>. The handler function will be passed the <u>userdata</u> pointer, which may be chosen freely by the
       caller. The handler may return negative to signal an error (see below), other return values are ignored.
       If <u>handler</u> is <b>NULL</b>, a default handler that compacts allocation caches maintained by libsystemd as well as
       glibc (via <b><a href="../man3/malloc_trim.3.html">malloc_trim</a></b>(3)) will be used.

       To destroy an event source object use <b><a href="../man3/sd_event_source_unref.3.html">sd_event_source_unref</a></b>(3), but note that the event source is only
       removed from the event loop when all references to the event source are dropped. To make sure an event
       source does not fire anymore, even if it is still referenced, disable the event source using
       <b><a href="../man3/sd_event_source_set_enabled.3.html">sd_event_source_set_enabled</a></b>(3) with <b>SD_EVENT_OFF</b>.

       If the second parameter of <b>sd_event_add_memory_pressure()</b> is <b>NULL</b> no reference to the event source object
       is returned. In this case, the event source is considered "floating", and will be destroyed implicitly
       when the event loop itself is destroyed.

       The event source will fire according to the following logic:

        1. If the <u>$MEMORY_PRESSURE_WATCH</u>/<u>$MEMORY_PRESSURE_WRITE</u> environment variables are set at the time the
           event source is established, it will watch the file, FIFO or AF_UNIX socket specified via
           <u>$MEMORY_PRESSURE_WATCH</u> (which must contain an absolute path name) for <b>POLLPRI</b> (in case it is a
           regular file) or <b>POLLIN</b> events (otherwise). After opening the inode, it will write the (decoded)
           Base64 data provided via <u>$MEMORY_PRESSURE_WRITE</u> into it before it starts polling on it (the variable
           may be unset in which case this is skipped). Typically, if used, <u>$MEMORY_PRESSURE_WATCH</u> will contain
           a path such as <a href="file:/proc/pressure/memory">/proc/pressure/memory</a> or a path to a specific memory.pressure file in the control
           group file system (cgroupfs).

        2. If these environment variables are not set, the local PSI interface file memory.pressure of the
           control group the invoking process is running in is used.

        3. If that file does not exist, the system-wide PSI interface file <a href="file:/proc/pressure/memory">/proc/pressure/memory</a> is watched
           instead.

       Or in other words: preferably any explicit configuration passed in by an invoking service manager (or
       similar) is used as notification source, before falling back to local notifications of the service, and
       finally to global notifications of the system.

       Well-behaving services and applications are recommended to react to memory pressure events by executing
       one or more of the following operations, in order to ensure optimal behaviour even on loaded and
       resource-constrained systems:

       •   Release allocation caches such as <b>malloc_trim()</b> or similar, both implemented in the libraries
           consumed by the program and in private allocation caches of the program itself.

       •   Release any other form of in-memory caches that can easily be recovered if needed (e.g. browser
           caches).

       •   Terminate idle worker threads or processes, or similar.

       •   Even exit entirely from the program if it is idle and can be automatically started when needed (for
           example via socket or bus activation).

       Any of the suggested operations should help easing memory pressure situations and allowing the system to
       make progress by reclaiming the memory for other purposes.

       This event source typically fires on memory pressure stalls, i.e. when operational latency above a
       configured threshold already has been seen. This should be taken into consideration when discussing
       whether later latency to re-aquire any released resources is acceptable: it is usually more important to
       think of the latencies that already happened than those coming up in future.

       The <b>sd_event_source_set_memory_pressure_type()</b> and <b>sd_event_source_set_memory_pressure_period()</b> functions
       can be used to fine-tune the PSI parameters for pressure notifications. The former takes either "some",
       "full" as second parameter, the latter takes threshold and period times in microseconds as parameters.
       For details about these three parameters see the PSI documentation. Note that these two calls must be
       invoked immediately after allocating the event source, as they must be configured before polling begins.
       Also note that these calls will fail if memory pressure parameterization has been passed in via the
       <u>$MEMORY_PRESSURE_WATCH</u>/<u>$MEMORY_PRESSURE_WRITE</u> environment variables (or in other words: configuration
       supplied by a service manager wins over internal settings).

       The <b>sd_event_trim_memory()</b> function releases various internal allocation caches maintained by libsystemd
       and then invokes glibc's <b><a href="../man3/malloc_trim.3.html">malloc_trim</a></b>(3). This makes the operation executed when the handler function
       parameter of <b>sd_event_add_memory_pressure</b> is passed as <b>NULL</b> directly accessible for invocation at any
       time (see above). This function will log a structured log message at <b>LOG_DEBUG</b> level (with message ID
       f9b0be465ad540d0850ad32172d57c21) about the memory pressure operation.

       For further details see <b>Memory</b> <b>Pressure</b> <b>Handling</b> <b>in</b> <b>systemd</b>[2].

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, these functions return 0 or a positive integer. On failure, they return a negative
       errno-style error code.

   <b>Errors</b>
       Returned errors may indicate the following problems:

       <b>-ENOMEM</b>
           Not enough memory to allocate an object.

           Added in version 254.

       <b>-EINVAL</b>
           An invalid argument has been passed.

           Added in version 254.

       <b>-EHOSTDOWN</b>
           The <u>$MEMORY_PRESSURE_WATCH</u> variable has been set to the literal string /dev/null, in order to
           explicitly disable memory pressure handling.

           Added in version 254.

       <b>-EBADMSG</b>
           The <u>$MEMORY_PRESSURE_WATCH</u> variable has been set to an invalid string, for example a relative rather
           than an absolute path.

           Added in version 254.

       <b>-ENOTTY</b>
           The <u>$MEMORY_PRESSURE_WATCH</u> variable points to a regular file outside of the procfs or cgroupfs file
           systems.

           Added in version 254.

       <b>-EOPNOTSUPP</b>
           No configuration via <u>$MEMORY_PRESSURE_WATCH</u> has been specified and the local kernel does not support
           the PSI interface.

           Added in version 254.

       <b>-EBUSY</b>
           This is returned by <b>sd_event_source_set_memory_pressure_type()</b> and
           <b>sd_event_source_set_memory_pressure_period()</b> if invoked on event sources at a time later than
           immediately after allocating them.

           Added in version 254.

       <b>-ESTALE</b>
           The event loop is already terminated.

           Added in version 254.

       <b>-ECHILD</b>
           The event loop has been created in a different process, library or module instance.

           Added in version 254.

       <b>-EDOM</b>
           The passed event source is not a signal event source.

           Added in version 254.

</pre><h4><b>NOTES</b></h4><pre>
       Functions described here are available as a shared library, which can be compiled against and linked to
       with the <b>libsystemd</b> <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1) file.

       The code described here uses <b><a href="../man3/getenv.3.html">getenv</a></b>(3), which is declared to be not multi-thread-safe. This means that
       the code calling the functions described here must not call <b><a href="../man3/setenv.3.html">setenv</a></b>(3) from a parallel thread. It is
       recommended to only do calls to <b>setenv()</b> from an early phase of the program when no other threads have
       been started.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>sd_event_add_memory_pressure()</b>, <b>sd_event_source_set_memory_pressure_type()</b>,
       <b>sd_event_source_set_memory_pressure_period()</b>, and <b>sd_event_trim_memory()</b> were added in version 254.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man3/sd-event.3.html">sd-event</a></b>(3), <b><a href="../man3/sd_event_new.3.html">sd_event_new</a></b>(3), <b><a href="../man3/sd_event_add_io.3.html">sd_event_add_io</a></b>(3), <b><a href="../man3/sd_event_add_time.3.html">sd_event_add_time</a></b>(3),
       <b><a href="../man3/sd_event_add_child.3.html">sd_event_add_child</a></b>(3), <b><a href="../man3/sd_event_add_inotify.3.html">sd_event_add_inotify</a></b>(3), <b><a href="../man3/sd_event_add_defer.3.html">sd_event_add_defer</a></b>(3), <b><a href="../man3/sd_event_source_set_enabled.3.html">sd_event_source_set_enabled</a></b>(3),
       <b><a href="../man3/sd_event_source_set_description.3.html">sd_event_source_set_description</a></b>(3), <b><a href="../man3/sd_event_source_set_userdata.3.html">sd_event_source_set_userdata</a></b>(3), <b><a href="../man3/sd_event_source_set_floating.3.html">sd_event_source_set_floating</a></b>(3)

</pre><h4><b>NOTES</b></h4><pre>
        1. Pressure Stall Information (PSI)
           https://docs.kernel.org/accounting/psi.html

        2. Memory Pressure Handling in systemd
           https://systemd.io/MEMORY_PRESSURE

systemd 257.7                                                                    <u><a href="../man3/SD_EVENT_ADD_MEMORY_PRESSURE.3.html">SD_EVENT_ADD_MEMORY_PRESSURE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>