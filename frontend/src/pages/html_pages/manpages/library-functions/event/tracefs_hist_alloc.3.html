<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tracefs_hist_alloc, tracefs_hist_alloc_2d, tracefs_hist_alloc_nd, tracefs_hist_alloc_nd_cnt,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtracefs-doc">libtracefs-doc_1.8.1-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tracefs_hist_alloc, tracefs_hist_alloc_2d, tracefs_hist_alloc_nd, tracefs_hist_alloc_nd_cnt,
       tracefs_hist_free, tracefs_hist_add_key, tracefs_hist_add_key_cnt, tracefs_hist_add_value - Create and
       destroy event histograms

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tracefs.h&gt;</b>

       enum <b>tracefs_hist_key_type</b> {
               <b>TRACEFS_HIST_KEY_NORMAL</b> = 0,
               <b>TRACEFS_HIST_KEY_HEX</b>,
               <b>TRACEFS_HIST_KEY_SYM</b>,
               <b>TRACEFS_HIST_KEY_SYM_OFFSET</b>,
               <b>TRACEFS_HIST_KEY_SYSCALL</b>,
               <b>TRACEFS_HIST_KEY_EXECNAME</b>,
               <b>TRACEFS_HIST_KEY_LOG</b>,
               <b>TRACEFS_HIST_KEY_USECS</b>,
               <b>TRACEFS_HIST_KEY_MAX</b>
       };

       struct <b>tracefs_hist_axis</b> {
               const char *<u>key</u>;
               enum tracefs_hist_key_type <u>type</u>;
       };

       struct tracefs_hist *<b>tracefs_hist_alloc</b>(struct tracefs_tep * <u>tep</u>,
                               const char *<u>system</u>, const char *<u>event</u>,
                               const char *<u>key</u>, enum tracefs_hist_key_type <u>type</u>);
       struct tracefs_hist *<b>tracefs_hist_alloc_2d</b>(struct tracefs_tep * <u>tep</u>,
                               const char *<u>system</u>, const char *<u>event</u>,
                               const char *<u>key1</u>, enum tracefs_hist_key_type <u>type1</u>,
                               const char *<u>key2</u>, enum tracefs_hist_key_type <u>type2</u>));
       struct tracefs_hist *<b>tracefs_hist_alloc_nd</b>(struct tracefs_tep * <u>tep</u>,
                               const char *<u>system</u>, const char *<u>event</u>,
                               struct tracefs_hist_axis *<u>axes</u>);
       struct tracefs_hist *<b>tracefs_hist_alloc_nd_cnt</b>(struct tep_handle *<u>tep</u>,
                                 const char *<u>system</u>, const char *<u>event_name</u>,
                                 struct tracefs_hist_axis_cnt *<u>axes</u>);
       void <b>tracefs_hist_free</b>(struct tracefs_hist *<u>hist</u>);

       int <b>tracefs_hist_add_key</b>(struct tracefs_hist *<u>hist</u>, const char *<u>key</u>,
                                enum tracefs_hist_key_type <u>type</u>);
       int <b>tracefs_hist_add_key_cnt</b>(struct tracefs_hist *<u>hist</u>, const char *<u>key</u>,
                                enum tracefs_hist_key_type <u>type</u>, int <u>cnt</u>);
       int <b>tracefs_hist_add_value</b>(struct tracefs_hist *<u>hist</u>, const char *<u>value</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Event histograms are created by the trigger file in the event directory. The syntax can be complex and
       difficult to get correct. This API handles the syntax, and facilitates the creation and interaction with
       the event histograms. See <b>https://www.kernel.org/doc/html/latest/trace/histogram.html</b> for more
       information.

       <b>tracefs_hist_alloc</b>() allocates a "struct tracefs_hist" descriptor of a one-dimensional histogram and
       returns the address of it. This descriptor must be freed by <b>tracefs_hist_free</b>(). The <u>tep</u> is a trace event
       handle (see <b><a href="../man3/tracefs_local_events.3.html">tracefs_local_events</a></b>(3)), that holds the <u>system</u> and <u>event</u> that the histogram will be attached
       to. The <u>system</u> is the system or group of the event. The <u>event</u> is the event to attach the histogram to.
       The <u>key</u> is a field of the event that will be used as the key(dimension) of the histogram. The <u>type</u> is the
       type of the <u>key</u>. See KEY TYPES below.

       <b>tracefs_hist_alloc_2d</b>() allocates a "struct tracefs_hist" descriptor of a two-dimensional histogram and
       returns the address of it. This descriptor must be freed by <b>tracefs_hist_free</b>(). The <u>tep</u> is a trace event
       handle (see <b><a href="../man3/tracefs_local_events.3.html">tracefs_local_events</a></b>(3)), that holds the <u>system</u> and <u>event</u> that the histogram will be attached
       to. The <u>system</u> is the system or group of the event. The <u>event</u> is the event to attach the histogram to.
       The <u>key1</u> is the first field of the event that will be used as the key(dimension) of the histogram. The
       <u>type1</u> is the type of the <u>key1</u>. See KEY TYPES below. The <u>key2</u> is the second field of the event that will
       be used as the key(dimension) of the histogram. The <u>type2</u> is the type of the <u>key2</u>. See KEY TYPES below.

       <b>tracefs_hist_alloc_nd</b>() allocates a "struct tracefs_hist" descriptor of an N-dimensional histogram and
       returns the address of it. This descriptor must be freed by <b>tracefs_hist_free</b>(). The <u>tep</u> is a trace event
       handle (see <b><a href="../man3/tracefs_local_events.3.html">tracefs_local_events</a></b>(3)), that holds the <u>system</u> and <u>event</u> that the histogram will be attached
       to. The <u>system</u> is the system or group of the event. The <u>event</u> is the event to attach the histogram to.
       The <u>axes</u> is an array of <u>key</u> / <u>type</u> pairs, defining the dimensions of the histogram.

       <b>tracefs_hist_alloc_nd_cnt</b>() will initialize a histogram descriptor that will be attached to the
       <u>system</u>/<u>event</u>. This only initializes the descriptor with the given <u>axes</u> keys as primaries. This only
       initializes the descriptor, it does not start the histogram in the kernel. The difference between this
       and <b>tracefs_hist_alloc_nd()</b> is that the <u>axes</u> parameter is of type <b>struct</b> <b>tracefs_hist_axis_cnt</b> and not
       <b>struct</b> <b>tracefs_hist_axis</b>.

       <b>tracefs_hist_free</b>() frees the <u>tracefs_hist</u> descriptor. Note, it does not stop or disable the running
       histogram if it was started. <b>tracefs_hist_destroy</b>() needs to be called to do so.

       <b>tracefs_hist_add_key</b>() Adds a secondary or tertiary key to the histogram. The key passed to
       <b>tracefs_hist_alloc_nd</b>() is the primary key of the histogram. The first time this function is called, it
       will add a secondary key (or two dimensional histogram). If this function is called again on the same
       histogram, it will add a <u>tertiary</u> key (or three dimensional histogram). The <u>hist</u> parameter is the
       histogram descriptor to add the <u>key</u> to. The <u>type</u> is the type of key to add (See KEY TYPES below).

       The <b>tracefs_hist_add_key_cnt</b>() is the same as <b>tracefs_hist_add_key</b>() except that it allows to add a
       counter for the given type. Currently, there’s only the <b>buckets</b> type that requires a counter. When adding
       a key with the buckets type, <b>tracefs_hist_add_key</b>() is not sufficient, as the <b>buckets</b> type requires a
       counter or bucket size. Use <b>tracefs_hist_add_key_cnt</b>() when specifing a key that is broken up into
       buckets, and pass in the size of those buckets into <u>cnt</u>.

       <b>tracefs_hist_add_value</b>() will add a value to record. By default, the value is simply the "hitcount" of
       the number of times a instance of the histogram’s key was hit. The <u>hist</u> is the histogram descriptor to
       add the value to. The <u>value</u> is a field in the histogram to add to when an instance of the key is hit.

</pre><h4><b>KEY</b> <b>TYPES</b></h4><pre>
       <b>tracefs_hist_alloc_nd</b>() and <b>tracefs_hist_add_key</b>() both add a key and requires that key to have a type.
       The types may be:

       <b>TRACEFS_HIST_KEY_NORMAL</b> or zero (0) which is to not modify the type.

       <b>TRACEFS_HIST_KEY_HEX</b> to display the key in hex.

       <b>TRACEFS_HIST_KEY_SYM</b> to display the key as a kernel symbol (if found). If the key is an address, this is
       useful as it will display the function names instead of just a number.

       <b>TRACEFS_HIST_KEY_SYM_OFFSET</b> similar to <b>TRACEFS_HIST_KEY_SYM</b> but will also include the offset of the
       function to match the exact address.

       <b>TRACEFS_HIST_KEY_SYSCALL</b> If the key is a system call "id" (the number passed from user space to the
       kernel to tell it what system call it is calling), then the name of the system call is displayed.

       <b>TRACEFS_HIST_KEY_EXECNAME</b> If "common_pid" is the key (the pid of the executing task), instead of showing
       the number, show the name of the running task.

       <b>TRACEFS_HIST_KEY_LOG</b> will display the key in a binary logarithmic scale.

       <b>TRACEFS_HIST_KEY_USECS</b> for use with "common_timestamp" or TRACEFS_HIST_TIMESTAMP, in which case it will
       show the timestamp in microseconds instead of nanoseconds.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>tracefs_hist_alloc_nd</b>() returns an allocated histogram descriptor which must be freed by
       <b>tracefs_hist_free</b>() or NULL on error.

       All the other functions return zero on success or -1 on error.

       If <b>tracefs_hist_start</b>() returns an error, a message may be displayed in the kernel that can be retrieved
       by <b>tracefs_error_last()</b>.

</pre><h4><b>EXAMPLE</b></h4><pre>
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/ctype.h">ctype.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;tracefs.h&gt;

           enum commands {
                   START,
                   PAUSE,
                   CONT,
                   RESET,
                   DELETE,
                   SHOW,
           };

           static void parse_system_event(char *group, char **system, char **event)
           {
                   *system = strtok(group, "/");
                   *event = strtok(NULL, "/");
                   if (!*event) {
                           *event = *system;
                           *system = NULL;
                   }
           }

           static int parse_keys(char *keys, struct tracefs_hist_axis_cnt **axes)
           {
                   char *sav = NULL;
                   char *key;
                   int cnt = 0;

                   for (key = strtok_r(keys, ",", &amp;sav); key; key = strtok_r(NULL, ",", &amp;sav)) {
                           struct tracefs_hist_axis_cnt *ax;
                           char *att;

                           ax = realloc(*axes, sizeof(*ax) * (cnt + 2));
                           if (!ax) {
                                   perror("Failed to allocate axes");
                                   exit(-1);
                           }
                           ax[cnt].key = key;
                           ax[cnt].type = 0;
                           ax[cnt + 1].key = NULL;
                           ax[cnt + 1].type = 0;

                           *axes = ax;

                           att = strchr(key, '.');
                           if (att) {
                                   *att++ = '\0';
                                   if (strcmp(att, "hex") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_HEX;
                                   else if (strcmp(att, "sym") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_SYM;
                                   else if (strcmp(att, "sym_offset") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_SYM_OFFSET;
                                   else if (strcmp(att, "syscall") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_SYSCALL;
                                   else if (strcmp(att, "exec") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_EXECNAME;
                                   else if (strcmp(att, "log") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_LOG;
                                   else if (strcmp(att, "usecs") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_USECS;
                                   else if (strncmp(att, "buckets", 7) == 0) {
                                           if (att[7] != '=' &amp;&amp; !isdigit(att[8])) {
                                                   fprintf(stderr, "'buckets' key type requires '=&lt;size&gt;'\n");
                                                   exit(-1);
                                           }
                                           ax[cnt].type = TRACEFS_HIST_KEY_BUCKETS;
                                           ax[cnt].cnt = atoi(&amp;att[8]);
                                   } else {
                                           fprintf(stderr, "Undefined attribute '%s'\n", att);
                                           fprintf(stderr,"  Acceptable attributes:\n");
                                           fprintf(stderr,"    hex, sym, sym_offset, syscall, exe, log, usecs\n");
                                           exit(-1);
                                   }
                           }
                           cnt++;
                   }
                   return cnt;
           }

           static void process_hist(enum commands cmd, const char *instance_name,
                                    char *group, char *keys, char *vals, char *sort,
                                    char *ascend, char *desc)
           {
                   struct tracefs_instance *instance = NULL;
                   struct tracefs_hist *hist;
                   struct tep_handle *tep;
                   struct tracefs_hist_axis_cnt *axes = NULL;
                   char *system;
                   char *event;
                   char *sav;
                   char *val;
                   int ret;
                   int cnt;

                   if (instance_name) {
                           instance = tracefs_instance_create(instance_name);
                           if (!instance) {
                                   fprintf(stderr, "Failed instance create\n");
                                   exit(-1);
                           }
                   }

                   tep = tracefs_local_events(NULL);
                   if (!tep) {
                           perror("Could not read events");
                           exit(-1);
                   }

                   parse_system_event(group, &amp;system, &amp;event);

                   if (cmd == SHOW) {
                           char *content;
                           content = tracefs_event_file_read(instance, system, event,
                                                             "hist", NULL);
                           if (!content) {
                                   perror("Reading hist file");
                                   exit(-1);
                           }
                           printf("%s\n", content);
                           free(content);
                           return;
                   }

                   if (!keys) {
                           fprintf(stderr, "Command needs -k option\n");
                           exit(-1);
                   }

                   cnt = parse_keys(keys, &amp;axes);
                   if (!cnt) {
                           fprintf(stderr, "No keys??\n");
                           exit(-1);
                   }

                   /* buckets require the nd_cnt function */
                   switch (cnt) {
                   case 2:
                           if (axes[1].type == TRACEFS_HIST_KEY_BUCKETS)
                                   cnt = -1;
                           /* fall through */
                   case 1:
                           if (axes[0].type == TRACEFS_HIST_KEY_BUCKETS)
                                   cnt = -1;
                   }

                   /* Show examples of hist1d and hist2d */
                   switch (cnt) {
                   case 1:
                           hist = tracefs_hist_alloc(tep, system, event,
                                                     axes[0].key, axes[0].type);
                           break;
                   case 2:
                           hist = tracefs_hist_alloc_2d(tep, system, event,
                                                        axes[0].key, axes[0].type,
                                                        axes[1].key, axes[1].type);
                           break;
                   default:
                           /* Really, 1 and 2 could use this too */
                           hist = tracefs_hist_alloc_nd_cnt(tep, system, event, axes);
                   }
                   if (!hist) {
                           fprintf(stderr, "Failed hist create\n");
                           exit(-1);
                   }

                   if (vals) {
                           sav = NULL;
                           for (val = strtok_r(vals, ",", &amp;sav); val; val = strtok_r(NULL, ",", &amp;sav)) {
                                   ret = tracefs_hist_add_value(hist, val);
                                   if (ret) {
                                           fprintf(stderr, "Failed to add value %s\n", val);
                                           exit(-1);
                                   }
                           }
                   }

                   if (sort) {
                           sav = NULL;
                           for (val = strtok_r(sort, ",", &amp;sav); val; val = strtok_r(NULL, ",", &amp;sav)) {
                                   ret = tracefs_hist_add_sort_key(hist, val);
                                   if (ret) {
                                           fprintf(stderr, "Failed to add sort key/val %s\n", val);
                                           exit(-1);
                                   }
                           }
                   }

                   if (ascend) {
                           sav = NULL;
                           for (val = strtok_r(ascend, ",", &amp;sav); val; val = strtok_r(NULL, ",", &amp;sav)) {
                                   ret = tracefs_hist_sort_key_direction(hist, val, TRACEFS_HIST_SORT_ASCENDING);
                                   if (ret) {
                                           fprintf(stderr, "Failed to add ascending key/val %s\n", val);
                                           exit(-1);
                                   }
                           }
                   }

                   if (desc) {
                           sav = NULL;
                           for (val = strtok_r(desc, ",", &amp;sav); val; val = strtok_r(NULL, ",", &amp;sav)) {
                                   ret = tracefs_hist_sort_key_direction(hist, val, TRACEFS_HIST_SORT_DESCENDING);
                                   if (ret) {
                                           fprintf(stderr, "Failed to add descending key/val %s\n", val);
                                           exit(-1);
                                   }
                           }
                   }

                   tracefs_error_clear(instance);

                   switch (cmd) {
                   case START:
                           ret = tracefs_hist_start(instance, hist);
                           if (ret) {
                                   char *err = tracefs_error_last(instance);
                                   if (err)
                                           fprintf(stderr, "\n%s\n", err);
                           }
                           break;
                   case PAUSE:
                           ret = tracefs_hist_pause(instance, hist);
                           break;
                   case CONT:
                           ret = tracefs_hist_continue(instance, hist);
                           break;
                   case RESET:
                           ret = tracefs_hist_reset(instance, hist);
                           break;
                   case DELETE:
                           ret = tracefs_hist_destroy(instance, hist);
                           break;
                   case SHOW:
                           /* Show was already done */
                           break;
                   }
                   if (ret)
                           fprintf(stderr, "Failed: command\n");
                   exit(ret);
           }

           int main (int argc, char **argv, char **env)
           {
                   enum commands cmd;
                   char *instance = NULL;
                   char *cmd_str;
                   char *event = NULL;
                   char *keys = NULL;
                   char *vals = NULL;
                   char *sort = NULL;
                   char *desc = NULL;
                   char *ascend = NULL;

                   if (argc &lt; 2) {
                           fprintf(stderr, "usage: %s command [-B instance][-e [system/]event][-k keys][-v vals][-s sort]\n", argv[0]);
                           fprintf(stderr, "      [-a ascending][-d descending]\n");
                           exit(-1);
                   }

                   cmd_str = argv[1];

                   if (!strcmp(cmd_str, "start"))
                           cmd = START;
                   else if (!strcmp(cmd_str, "pause"))
                           cmd = PAUSE;
                   else if (!strcmp(cmd_str, "cont"))
                           cmd = CONT;
                   else if (!strcmp(cmd_str, "reset"))
                           cmd = RESET;
                   else if (!strcmp(cmd_str, "delete"))
                           cmd = DELETE;
                   else if (!strcmp(cmd_str, "show"))
                           cmd = SHOW;
                   else {
                           fprintf(stderr, "Unknown command %s\n", cmd_str);
                           exit(-1);
                   }

                   for (;;) {
                           int c;

                           c = getopt(argc - 1, argv + 1, "e:k:v:B:s:d:a:");
                           if (c == -1)
                                   break;

                           switch (c) {
                           case 'e':
                                   event = optarg;
                                   break;
                           case 'k':
                                   keys = optarg;
                                   break;
                           case 'v':
                                   vals = optarg;
                                   break;
                           case 'B':
                                   instance = optarg;
                                   break;
                           case 's':
                                   sort = optarg;
                                   break;
                           case 'd':
                                   desc = optarg;
                                   break;
                           case 'a':
                                   ascend = optarg;
                                   break;
                           }
                   }
                   if (!event) {
                           event = "kmem/kmalloc";
                           if (!keys)
                                   keys = "call_site.sym,bytes_req";
                           if (!vals)
                                   vals = "bytes_alloc";
                           if (!sort)
                                   sort = "bytes_req,bytes_alloc";
                           if (!desc)
                                   desc = "bytes_alloc";
                   }
                   process_hist(cmd, instance, event, keys, vals, sort, ascend, desc);
           }

</pre><h4><b>FILES</b></h4><pre>
           <b>tracefs.h</b>
                   Header file to include in order to have access to the library APIs.
           <b>-ltracefs</b>
                   Linker switch to add when building a program that uses the library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/libtracefs.3.html">libtracefs</a></b>(3), <b><a href="../man3/libtraceevent.3.html">libtraceevent</a></b>(3), <b><a href="../man1/trace-cmd.1.html">trace-cmd</a></b>(1), <b><a href="../man3/tracefs_hist_pause.3.html">tracefs_hist_pause</a></b>(3), <b><a href="../man3/tracefs_hist_continue.3.html">tracefs_hist_continue</a></b>(3),
       <b><a href="../man3/tracefs_hist_reset.3.html">tracefs_hist_reset</a></b>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
           <b>Steven</b> <b>Rostedt</b> &lt;<b><a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a></b>[1]&gt;
           <b>Tzvetomir</b> <b>Stoyanov</b> &lt;<b><a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a></b>[2]&gt;
           <b>sameeruddin</b> <b>shaik</b> &lt;<b><a href="mailto:sameeruddin.shaik8@gmail.com">sameeruddin.shaik8@gmail.com</a></b>[3]&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<b><a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a></b>[4]&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       libtracefs is Free Software licensed under the GNU LGPL 2.1

</pre><h4><b>RESOURCES</b></h4><pre>
       <b>https://git.kernel.org/pub/scm/libs/libtrace/libtracefs.git/</b>

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2020 VMware, Inc. Free use of this software is granted under the terms of the GNU Public
       License (GPL).

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a>
           <a href="mailto:rostedt@goodmis.org">mailto:rostedt@goodmis.org</a>

        2. <a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a>
           <a href="mailto:tz.stoyanov@gmail.com">mailto:tz.stoyanov@gmail.com</a>

        3. <a href="mailto:sameeruddin.shaik8@gmail.com">sameeruddin.shaik8@gmail.com</a>
           <a href="mailto:sameeruddin.shaik8@gmail.com">mailto:sameeruddin.shaik8@gmail.com</a>

        4. <a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a>
           <a href="mailto:linux-trace-devel@vger.kernel.org">mailto:linux-trace-devel@vger.kernel.org</a>

libtracefs 1.8.1                                   06/05/2025                                      <u><a href="../man3/LIBTRACEFS.3.html">LIBTRACEFS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>