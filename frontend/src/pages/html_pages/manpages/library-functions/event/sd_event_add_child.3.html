<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sd_event_add_child, sd_event_add_child_pidfd, sd_event_source_get_child_pid,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsystemd-dev">libsystemd-dev_257.7-1ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sd_event_add_child, sd_event_add_child_pidfd, sd_event_source_get_child_pid,
       sd_event_source_get_child_pidfd, sd_event_source_get_child_pidfd_own,
       sd_event_source_set_child_pidfd_own, sd_event_source_get_child_process_own,
       sd_event_source_set_child_process_own, sd_event_source_send_child_signal, sd_event_child_handler_t - Add
       a child process state change event source to an event loop

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;systemd/sd-event.h&gt;</b>

       <b>typedef</b> <b>struct</b> <b>sd_event_source</b> <b>sd_event_source;</b>

       <b>typedef</b> <b>int</b> <b>(*sd_event_child_handler_t)(sd_event_source</b> <b>*</b><u>s</u><b>,</b> <b>const</b> <b>siginfo_t</b> <b>*</b><u>si</u><b>,</b> <b>void</b> <b>*</b><u>userdata</u><b>);</b>

       <b>int</b> <b>sd_event_add_child(sd_event</b> <b>*</b><u>event</u><b>,</b> <b>sd_event_source</b> <b>**</b><u>source</u><b>,</b> <b>pid_t</b> <u>pid</u><b>,</b> <b>int</b> <u>options</u><b>,</b>
                              <b>sd_event_child_handler_t</b> <u>handler</u><b>,</b> <b>void</b> <b>*</b><u>userdata</u><b>);</b>

       <b>int</b> <b>sd_event_add_child_pidfd(sd_event</b> <b>*</b><u>event</u><b>,</b> <b>sd_event_source</b> <b>**</b><u>source</u><b>,</b> <b>int</b> <u>pidfd</u><b>,</b> <b>int</b> <u>options</u><b>,</b>
                                    <b>sd_event_child_handler_t</b> <u>handler</u><b>,</b> <b>void</b> <b>*</b><u>userdata</u><b>);</b>

       <b>int</b> <b>sd_event_source_get_child_pid(sd_event_source</b> <b>*</b><u>source</u><b>,</b> <b>pid_t</b> <b>*</b><u>ret</u><b>);</b>

       <b>int</b> <b>sd_event_source_get_child_pidfd(sd_event_source</b> <b>*</b><u>source</u><b>);</b>

       <b>int</b> <b>sd_event_source_get_child_pidfd_own(sd_event_source</b> <b>*</b><u>source</u><b>);</b>

       <b>int</b> <b>sd_event_source_set_child_pidfd_own(sd_event_source</b> <b>*</b><u>source</u><b>,</b> <b>int</b> <u>own</u><b>);</b>

       <b>int</b> <b>sd_event_source_get_child_process_own(sd_event_source</b> <b>*</b><u>source</u><b>);</b>

       <b>int</b> <b>sd_event_source_set_child_process_own(sd_event_source</b> <b>*</b><u>source</u><b>,</b> <b>int</b> <u>own</u><b>);</b>

       <b>int</b> <b>sd_event_source_send_child_signal(sd_event_source</b> <b>*</b><u>source</u><b>,</b> <b>int</b> <u>sig</u><b>,</b> <b>const</b> <b>siginfo_t</b> <b>*</b><u>info</u><b>,</b>
                                             <b>unsigned</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sd_event_add_child()</b> adds a new child process state change event source to an event loop. The event loop
       object is specified in the <u>event</u> parameter, the event source object is returned in the <u>source</u> parameter.
       The <u>pid</u> parameter specifies the PID of the process to watch, which must be a direct child process of the
       invoking process. The <u>options</u> parameter determines which state changes will be watched for. It must
       contain an OR-ed mask of <b>WEXITED</b> (watch for the child process terminating), <b>WSTOPPED</b> (watch for the child
       process being stopped by a signal), and <b>WCONTINUED</b> (watch for the child process being resumed by a
       signal). See <b><a href="../man2/waitid.2.html">waitid</a></b>(2) for further information.

       The <u>handler</u> must be a function to call when the process changes state or <b>NULL</b>. The handler function will
       be passed the <u>userdata</u> pointer, which may be chosen freely by the caller. The handler also receives a
       pointer to a siginfo_t structure containing information about the child process event. The handler may
       return negative to signal an error (see below), other return values are ignored. If <u>handler</u> is <b>NULL</b>, a
       default handler that calls <b><a href="../man3/sd_event_exit.3.html">sd_event_exit</a></b>(3) will be used.

       Only a single handler may be installed for a specific child process. The handler is enabled for a single
       event (<b>SD_EVENT_ONESHOT</b>), but this may be changed with <b><a href="../man3/sd_event_source_set_enabled.3.html">sd_event_source_set_enabled</a></b>(3). If the handler
       function returns a negative error code, it will either be disabled after the invocation, even if the
       <b>SD_EVENT_ON</b> mode was requested before, or it will cause the loop to terminate, see
       <b><a href="../man3/sd_event_source_set_exit_on_failure.3.html">sd_event_source_set_exit_on_failure</a></b>(3).

       To destroy an event source object use <b><a href="../man3/sd_event_source_unref.3.html">sd_event_source_unref</a></b>(3), but note that the event source is only
       removed from the event loop when all references to the event source are dropped. To make sure an event
       source does not fire anymore, even when there's still a reference to it kept, consider setting the event
       source to <b>SD_EVENT_OFF</b> with <b><a href="../man3/sd_event_source_set_enabled.3.html">sd_event_source_set_enabled</a></b>(3).

       The <b>SIGCHLD</b> signal must be blocked in all threads before this function is called (using <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2) or
       <b><a href="../man3/pthread_sigmask.3.html">pthread_sigmask</a></b>(3)).

       If the second parameter of <b>sd_event_add_child()</b> is passed as <b>NULL</b> no reference to the event source object
       is returned. In this case, the event source is considered "floating", and will be destroyed implicitly
       when the event loop itself is destroyed.

       Note that the <u>handler</u> function is invoked at a time where the child process is not reaped yet (and thus
       still is exposed as a zombie process by the kernel). However, the child will be reaped automatically
       after the function returns. Child processes for which no child process state change event sources are
       installed will not be reaped by the event loop implementation.

       If the <u>handler</u> parameter to <b>sd_event_add_child()</b> is <b>NULL</b>, and the event source fires, this will be
       considered a request to exit the event loop. In this case, the <u>userdata</u> parameter, cast to an integer, is
       passed as the exit code parameter to <b><a href="../man3/sd_event_exit.3.html">sd_event_exit</a></b>(3).

       If both a child process state change event source and a <b>SIGCHLD</b> signal event source is installed in the
       same event loop, the configured event source priorities decide which event source is dispatched first. If
       the signal handler is processed first, it should leave the child processes for which child process state
       change event sources are installed unreaped.

       <b>sd_event_add_child_pidfd()</b> is similar to <b>sd_event_add_child()</b> but takes a file descriptor referencing the
       process ("pidfd") instead of the numeric PID. A suitable file descriptor may be acquired via
       <b><a href="../man2/pidfd_open.2.html">pidfd_open</a></b>(2) and related calls. The passed file descriptor is not closed when the event source is freed
       again, unless <b>sd_event_source_set_child_pidfd_own()</b> is used to turn this behaviour on. Note that
       regardless which of <b>sd_event_add_child()</b> and <b>sd_event_add_child_pidfd()</b> is used for allocating an event
       source, the watched process has to be a direct child process of the invoking process. Also in both cases
       <b>SIGCHLD</b> has to be blocked in the invoking process.

       <b>sd_event_source_get_child_pid()</b> retrieves the configured PID of a child process state change event source
       created previously with <b>sd_event_add_child()</b>. It takes the event source object as the <u>source</u> parameter
       and a pointer to a <b>pid_t</b> variable to return the process ID in.

       <b>sd_event_source_get_child_pidfd()</b> retrieves the file descriptor referencing the watched process ("pidfd")
       if this functionality is available. On kernels that support the concept the event loop will make use of
       pidfds to watch child processes, regardless if the individual event sources are allocated via
       <b>sd_event_add_child()</b> or <b>sd_event_add_child_pidfd()</b>. If the latter call was used to allocate the event
       source, this function returns the file descriptor used for allocation. On kernels that do not support the
       pidfd concept this function will fail with <b>EOPNOTSUPP</b>. This call takes the event source object as the
       <u>source</u> parameter and returns the numeric file descriptor.

       <b>sd_event_source_get_child_pidfd_own()</b> may be used to query whether the pidfd the event source
       encapsulates shall be closed when the event source is freed. This function returns zero if the pidfd
       shall be left open, and positive if it shall be closed automatically. By default, this setting defaults
       to on if the event source was allocated via <b>sd_event_add_child()</b> and off if it was allocated via
       <b>sd_event_add_child_pidfd()</b>. The <b>sd_event_source_set_child_pidfd_own()</b> function may be used to change the
       setting and takes a boolean parameter with the new setting.

       <b>sd_event_source_get_child_process_own()</b> may be used to query whether the process the event source watches
       shall be killed (with <b>SIGKILL</b>) and reaped when the event source is freed. This function returns zero if
       the process shell be left running, and positive if it shall be killed and reaped automatically. By
       default, this setting defaults to off. The <b>sd_event_source_set_child_process_own()</b> function may be used
       to change the setting and takes a boolean parameter with the new setting. Note that currently if the
       calling process is terminated abnormally the watched process might survive even thought the event source
       ceases to exist. This behaviour might change eventually.

       <b>sd_event_source_send_child_signal()</b> may be used to send a UNIX signal to the watched process. If the
       pidfd concept is supported in the kernel, this is implemented via <b><a href="../man2/pidfd_send_signal.2.html">pidfd_send_signal</a></b>(2) and otherwise via
       <b><a href="../man2/rt_sigqueueinfo.2.html">rt_sigqueueinfo</a></b>(2) (or via <b><a href="../man2/kill.2.html">kill</a></b>(2) in case <u>info</u> is <b>NULL</b>). The specified parameters match those of these
       underlying system calls, except that the <u>info</u> is never modified (and is thus declared constant). Like for
       the underlying system calls, the <u>flags</u> parameter currently must be zero.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, these functions return 0 or a positive integer. On failure, they return a negative
       errno-style error code.

   <b>Errors</b>
       Returned errors may indicate the following problems:

       <b>-ENOMEM</b>
           Not enough memory to allocate an object.

       <b>-EINVAL</b>
           An invalid argument has been passed. This includes specifying an empty mask in <u>options</u> or a mask
           which contains values different than a combination of <b>WEXITED</b>, <b>WSTOPPED</b>, and <b>WCONTINUED</b>.

       <b>-EBUSY</b>
           A handler is already installed for this child process, or <b>SIGCHLD</b> is not blocked.

       <b>-ESTALE</b>
           The event loop is already terminated.

       <b>-ECHILD</b>
           The event loop has been created in a different process, library or module instance.

       <b>-EDOM</b>
           The passed event source is not a child process event source.

       <b>-EOPNOTSUPP</b>
           A pidfd was requested but the kernel does not support this concept.

           Added in version 245.

</pre><h4><b>NOTES</b></h4><pre>
       Functions described here are available as a shared library, which can be compiled against and linked to
       with the <b>libsystemd</b> <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1) file.

       The code described here uses <b><a href="../man3/getenv.3.html">getenv</a></b>(3), which is declared to be not multi-thread-safe. This means that
       the code calling the functions described here must not call <b><a href="../man3/setenv.3.html">setenv</a></b>(3) from a parallel thread. It is
       recommended to only do calls to <b>setenv()</b> from an early phase of the program when no other threads have
       been started.

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>Example</b> <b>1.</b> <b>Exit</b> <b>loop</b> <b>when</b> <b>the</b> <b>child</b> <b>terminates</b>

           /* SPDX-License-Identifier: MIT-0 */

           #define _GNU_SOURCE 1
           #include &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;systemd/sd-event.h&gt;

           int main(int argc, char **argv) {
             pid_t pid = fork();
             assert(pid &gt;= 0);

             /* SIGCHLD signal must be blocked for sd_event_add_child to work */
             sigset_t ss;
             sigemptyset(&amp;ss);
             sigaddset(&amp;ss, SIGCHLD);
             sigprocmask(SIG_BLOCK, &amp;ss, NULL);

             if (pid == 0)  /* child */
               <a href="../man1/sleep.1.html">sleep</a>(1);

             else {         /* parent */
               sd_event *e = NULL;
               int r;

               /* Create the default event loop */
               sd_event_default(&amp;e);
               assert(e);

               /* We create a floating child event source (attached to 'e').
                * The default handler will be called with 666 as userdata, which
                * will become the exit value of the loop. */
               r = sd_event_add_child(e, NULL, pid, WEXITED, NULL, (void*) 666);
               assert(r &gt;= 0);

               r = sd_event_loop(e);
               assert(r == 666);

               sd_event_unref(e);
             }

             return 0;
           }

</pre><h4><b>HISTORY</b></h4><pre>
       <b>sd_event_add_child()</b>, <b>sd_event_child_handler_t()</b>, and <b>sd_event_source_get_child_pid()</b> were added in
       version 217.

       <b>sd_event_add_child_pidfd()</b>, <b>sd_event_source_get_child_pidfd()</b>, <b>sd_event_source_get_child_pidfd_own()</b>,
       <b>sd_event_source_set_child_pidfd_own()</b>, <b>sd_event_source_get_child_process_own()</b>,
       <b>sd_event_source_set_child_process_own()</b>, and <b>sd_event_source_send_child_signal()</b> were added in version
       245.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man3/sd-event.3.html">sd-event</a></b>(3), <b><a href="../man3/sd_event_new.3.html">sd_event_new</a></b>(3), <b><a href="../man3/sd_event_now.3.html">sd_event_now</a></b>(3), <b><a href="../man3/sd_event_add_io.3.html">sd_event_add_io</a></b>(3), <b><a href="../man3/sd_event_add_time.3.html">sd_event_add_time</a></b>(3),
       <b><a href="../man3/sd_event_add_signal.3.html">sd_event_add_signal</a></b>(3), <b><a href="../man3/sd_event_add_inotify.3.html">sd_event_add_inotify</a></b>(3), <b><a href="../man3/sd_event_add_defer.3.html">sd_event_add_defer</a></b>(3), <b><a href="../man3/sd_event_source_set_enabled.3.html">sd_event_source_set_enabled</a></b>(3),
       <b><a href="../man3/sd_event_source_set_priority.3.html">sd_event_source_set_priority</a></b>(3), <b><a href="../man3/sd_event_source_set_userdata.3.html">sd_event_source_set_userdata</a></b>(3), <b><a href="../man3/sd_event_source_set_description.3.html">sd_event_source_set_description</a></b>(3),
       <b><a href="../man3/sd_event_source_set_floating.3.html">sd_event_source_set_floating</a></b>(3), <b><a href="../man2/waitid.2.html">waitid</a></b>(2), <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2), <b><a href="../man3/pthread_sigmask.3.html">pthread_sigmask</a></b>(3), <b><a href="../man2/pidfd_open.2.html">pidfd_open</a></b>(2),
       <b><a href="../man2/pidfd_send_signal.2.html">pidfd_send_signal</a></b>(2), <b><a href="../man2/rt_sigqueueinfo.2.html">rt_sigqueueinfo</a></b>(2), <b><a href="../man2/kill.2.html">kill</a></b>(2)

systemd 257.7                                                                              <u><a href="../man3/SD_EVENT_ADD_CHILD.3.html">SD_EVENT_ADD_CHILD</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>