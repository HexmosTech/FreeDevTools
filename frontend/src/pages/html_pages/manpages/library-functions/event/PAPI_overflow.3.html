<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PAPI_overflow - Set up an event set to begin registering overflows.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpapi-dev">libpapi-dev_7.1.0-5build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PAPI_overflow - Set up an event set to begin registering overflows.

</pre><h4><b>SYNOPSIS</b></h4><pre>
</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       <b>PAPI_overflow()</b> marks a specific EventCode in an EventSet to generate an overflow signal after every
       threshold events are counted. More than one event in an event set can be used to trigger overflows. In
       such cases, the user must call this function once for each overflowing event. To turn off overflow on a
       specified event, call this function with a threshold value of 0.

       Overflows can be implemented in either software or hardware, but the scope is the entire event set. PAPI
       defaults to hardware overflow if it is available. In the case of software overflow, a periodic timer
       interrupt causes PAPI to compare the event counts against the threshold values and call the overflow
       handler if one or more events have exceeded their threshold. In the case of hardware overflow, the
       counters are typically set to the negative of the threshold value and count up to 0. This zero-crossing
       triggers a hardware interrupt that calls the overflow handler. Because of this counter interrupt, the
       counter values for overflowing counters may be very small or even negative numbers, and cannot be relied
       upon as accurate. In such cases the overflow handler can approximate the counts by supplying the
       threshold value whenever an overflow occurs.

       _papi_overflow_handler() is a placeholder for a user-defined function to process overflow events. A
       pointer to this function is passed to the <b>PAPI_overflow</b> routine, where it is invoked whenever a software
       or hardware overflow occurs. This handler receives the EventSet of the overflowing event, the Program
       Counter address when the interrupt occurred, an overflow_vector that can be processed to determined which
       event(s) caused the overflow, and a pointer to the machine context, which can be used in a platform-
       specific manor to extract register information about what was happening when the overflow occurred.

       <b>C</b> <b>Interface:</b>
           #include &lt;<b>papi.h</b>&gt;
           int <b>PAPI_overflow</b> (int EventSet, int EventCode, int threshold, int flags, PAPI_overflow_handler_t
           handler );

           (*PAPI_overflow_handler_t) _papi_overflow_handler (int EventSet, void *address, long_long
           overflow_vector, void *context );

       <b>Fortran</b> <b>Interface:</b>
           Not implemented

       <b>Parameters</b>
           <u>EventSet</u> -- an integer handle to a PAPI event set as created by <b>PAPI_create_eventset</b>
           <u>EventCode</u> -- the preset or native event code to be set for overflow detection. This event must have
           already been added to the EventSet.
           <u>threshold</u> -- the overflow threshold value for this EventCode.
           <u>flags</u> -- bitmap that controls the overflow mode of operation. Set to PAPI_OVERFLOW_FORCE_SW to force
           software overflowing, even if hardware overflow support is available. If hardware overflow support is
           available on a given system, it will be the default mode of operation. There are situations where it
           is advantageous to use software overflow instead. Although software overflow is inherently less
           accurate, with more latency and processing overhead, it does allow for overflowing on derived events,
           and for the accurate recording of overflowing event counts. These two features are typically not
           available with hardware overflow. Only one type of overflow is allowed per event set, so setting one
           event to hardware overflow and another to forced software overflow will result in an error being
           returned.
           <u>handler</u> -- pointer to the user supplied handler function to call upon overflow
           <u>address</u> -- the Program Counter address at the time of the overflow
           <u>overflow_vector</u>
            -- a long long word containing flag bits to indicate which hardware counter(s) caused the overflow
           <u>*context</u> -- pointer to a machine specific structure that defines the register context at the time of
           overflow. This parameter is often unused and can be ignored in the user function.

       <b>Return</b> <b>values</b>
           <u>PAPI_OK</u> On success, <b>PAPI_overflow</b> returns PAPI_OK.

           <u>PAPI_EINVAL</u> One or more of the arguments is invalid.
            Most likely a bad threshold value.
           <u>PAPI_ENOMEM</u> Insufficient memory to complete the operation.
           <u>PAPI_ENOEVST</u> The EventSet specified does not exist.
           <u>PAPI_EISRUN</u> The EventSet is currently counting events.
           <u>PAPI_ECNFLCT</u> The underlying counter hardware cannot count this event and other events in the EventSet
           simultaneously. Also can happen if you are trying to overflow both by hardware and by forced software
           at the same time.
           <u>PAPI_ENOEVNT</u> The PAPI event is not available on the underlying hardware.

       <b>Example</b>

           // Define a simple overflow handler:
           void handler(int EventSet, void *address, long_long overflow_vector, void *context)
           {
              fprintf(stderr,\"Overflow at %p! bit=%#llx \\n\",
                       address,overflow_vector);
           }

           // Call PAPI_overflow for an EventSet containing PAPI_TOT_INS,
           // setting the threshold to 100000. Use the handler defined above.
           retval = PAPI_overflow(EventSet, PAPI_TOT_INS, 100000, 0, handler);

       <b>See</b> <b>also</b>
           <b>PAPI_get_overflow_event_index</b>

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for PAPI from the source code.

Version 7.1.0.0                                  Thu Dec 14 2023                                <u><a href="../man3/PAPI_overflow.3.html">PAPI_overflow</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>