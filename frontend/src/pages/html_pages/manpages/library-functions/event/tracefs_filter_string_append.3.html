<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tracefs_filter_string_append, tracefs_filter_string_verify, tracefs_event_filter_apply,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtracefs-doc">libtracefs-doc_1.8.1-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tracefs_filter_string_append, tracefs_filter_string_verify, tracefs_event_filter_apply,
       tracefs_event_filter_clear - Add, verify and apply event filters

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tracefs.h&gt;</b>

       int <b>tracefs_filter_string_append</b>(struct tep_event *<u>event</u>, char **<u>filter</u>,
                                        struct tracefs_filter <u>type</u>, const char *<u>field</u>,
                                        enum tracefs_synth_compare <u>compare</u>, const char *<u>val</u>);
       int <b>tracefs_filter_string_verify</b>(struct tep_event *<u>event</u>, const char *<u>filter</u>, char **<u>err</u>);
       int <b>tracefs_event_filter_apply</b>(struct tracefs_instance *<u>instance</u>, struct tep_event *<u>event</u>, const char *<u>filter</u>);
       int <b>tracefs_event_filter_clear</b>(struct tracefs_instance *<u>instance</u>, struct tep_event *<u>event</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>tracefs_filter_string_append</b>() is a way to create and verify event filters for a given event. It will
       verify that the <u>field</u> belongs to the event and that the <u>compare</u> option that is used is valid for the type
       of the field, as well as <u>val</u>. For the <u>type</u> that is not of <b>TRACEFS_FILTER_COMPARE</b>, it will build the
       logical string and also make sure that the syntax is correct. For example, there are no more close
       parenthesis than open parenthesis. An AND (&amp;&amp;) or OR (||) is not misplaced, etc.

       <b>tracefs_synth_append_start_filter</b>() creates a filter or appends to it for the starting event. Depending
       on <u>type</u>, it will build a string of tokens for parenthesis or logic statemens, or it may add a comparison
       of <u>field</u> to <u>val</u> based on <u>compare</u>.

       If <u>type</u> is: <b>TRACEFS_FILTER_COMPARE</b> - See below <b>TRACEFS_FILTER_AND</b> - Append "&amp;&amp;" to the filter
       <b>TRACEFS_FILTER_OR</b> - Append "||" to the filter <b>TRACEFS_FILTER_NOT</b> - Append "!" to the filter
       <b>TRACEFS_FILTER_OPEN_PAREN</b> - Append "(" to the filter <b>TRACEFS_FILTER_CLOSE_PAREN</b> - Append ")" to the
       filter

       <u>field</u>, <u>compare</u>, and <u>val</u> are ignored unless <u>type</u> is equal to <b>TRACEFS_FILTER_COMPARE</b>, then _compare will be
       used for the following:

       <b>TRACEFS_COMPARE_EQ</b> - <u>field</u> == <u>val</u>

       <b>TRACEFS_COMPARE_NE</b> - <u>field</u> != <u>val</u>

       <b>TRACEFS_COMPARE_GT</b> - <u>field</u> &gt; <u>val</u>

       <b>TRACEFS_COMPARE_GE</b> - <u>field</u> &gt;= <u>val</u>

       <b>TRACEFS_COMPARE_LT</b> - <u>field</u> &lt; <u>val</u>

       <b>TRACEFS_COMPARE_LE</b> - <u>field</u> &lt;= <u>val</u>

       <b>TRACEFS_COMPARE_RE</b> - <u>field</u> ~ "<u>val</u>" : where <u>field</u> is a string.

       <b>TRACEFS_COMPARE_AND</b> - <u>field</u> &amp; <u>val</u> : where <u>field</u> is a flags field.

       <b>tracefs_filter_string_verify</b>() will parse <u>filter</u> to make sure that the fields are for the <u>event</u>, and that
       the syntax is correct. If thereâ€™s an error in the syntax, and <u>err</u> is not NULL, then it will be allocated
       with an error message stating what was found wrong with the filter. <u>err</u> must be freed with <b>free</b>().

       <b>tracefs_event_filter_apply</b>() applies given <u>filter</u> string on <u>event</u> in given <u>instance</u>.

       <b>tracefs_event_filter_clear</b>() clear all filters on <u>event</u> in given <u>instance</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>tracefs_filter_string_append</b>() returns 0 on success and -1 on error.

       <b>tracefs_filter_string_verify</b>() returns 0 on success and -1 on error. if there is an error, and <u>errno</u> is
       not <b>ENOMEM</b>, then <u>err</u> is allocated and will contain a string describing what was found wrong with <u>filter</u>.
       <u>err</u> must be freed with <b>free</b>().

       <b>tracefs_event_filter_apply</b>() returns 0 on success and -1 on error.

       <b>tracefs_event_filter_clear</b>() returns 0 on success and -1 on error.

</pre><h4><b>EXAMPLE</b></h4><pre>
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/ctype.h">ctype.h</a>&gt;
           #include &lt;tracefs.h&gt;

           static void usage(char **argv)
           {
                   fprintf(stderr, "usage: %s [system] event filter\n", argv[0]);
                   exit(-1);
           }

           int main (int argc, char **argv)
           {
                   struct tep_handle *tep;
                   struct tep_event *event;
                   const char *system = NULL;
                   const char *event_name;
                   const char *filter;
                   char *new_filter = NULL;
                   char *err = NULL;
                   int i;

                   if (argc &lt; 3)
                           usage(argv);

                   if (argc &lt; 4) {
                           event_name = argv[1];
                           filter = argv[2];
                   } else {
                           system = argv[1];
                           event_name = argv[2];
                           filter = argv[3];
                   }

                   /* Load all events from the system */
                   tep = tracefs_local_events(NULL);
                   if (!tep) {
                           perror("tep");
                           exit(-1);
                   }

                   event = tep_find_event_by_name(tep, system, event_name);
                   if (!event) {
                           fprintf(stderr, "Event %s%s%s not found\n",
                                   system ? system : "" , system ? " " : "",
                                   event_name);
                           exit(-1);
                   }

                   if (tracefs_filter_string_verify(event, filter, &amp;err) &lt; 0) {
                           perror("tracecfs_event_verify_filter");
                           if (err)
                                   fprintf(stderr, "%s", err);
                           free(err);
                           exit(-1);
                   }

                   for (i = 0; filter[i]; i++) {
                           char buf[strlen(filter)];
                           char *field = NULL;
                           char *val = NULL;
                           enum tracefs_filter type;
                           enum tracefs_compare compare = 0;
                           int start_i, n;
                           int quote;
                           bool backslash;

                           while (isspace(filter[i]))
                                   i++;

                           switch(filter[i]) {
                           case '(':
                                   type = TRACEFS_FILTER_OPEN_PAREN;
                                   break;
                           case ')':
                                   type = TRACEFS_FILTER_CLOSE_PAREN;
                                   break;
                           case '!':
                                   type = TRACEFS_FILTER_NOT;
                                   break;
                           case '&amp;':
                                   type = TRACEFS_FILTER_AND;
                                   i++;
                                   break;
                           case '|':
                                   type = TRACEFS_FILTER_OR;
                                   i++;
                                   break;
                           default:
                                   type = TRACEFS_FILTER_COMPARE;

                                   while (isspace(filter[i]))
                                           i++;

                                   start_i = i;
                                   for (; filter[i]; i++) {
                                           switch(filter[i]) {
                                           case 'a' ... 'z':
                                           case 'A' ... 'Z':
                                           case '0' ... '9':
                                           case '_':
                                                   continue;
                                           }
                                           break;
                                   }

                                   n = i - start_i;
                                   field = buf;
                                   strncpy(field, filter + start_i, n);
                                   field[n++] = '\0';

                                   val = buf + n;

                                   while (isspace(filter[i]))
                                           i++;

                                   start_i = i;
                                   switch(filter[i++]) {
                                   case '&gt;':
                                           compare = TRACEFS_COMPARE_GT;
                                           if (filter[i] == '=') {
                                                   i++;
                                                   compare = TRACEFS_COMPARE_GE;
                                           }
                                           break;
                                   case '&lt;':
                                           compare = TRACEFS_COMPARE_LT;
                                           if (filter[i] == '=') {
                                                   i++;
                                                   compare = TRACEFS_COMPARE_LE;
                                           }
                                           break;
                                   case '=':
                                           compare = TRACEFS_COMPARE_EQ;
                                           i++;
                                           break;
                                   case '!':
                                           compare = TRACEFS_COMPARE_NE;
                                           i++;
                                           break;
                                   case '~':
                                           compare = TRACEFS_COMPARE_RE;
                                           break;
                                   case '&amp;':
                                           compare = TRACEFS_COMPARE_AND;
                                           break;
                                   }

                                   while (isspace(filter[i]))
                                           i++;

                                   quote = 0;
                                   backslash = false;
                                   start_i = i;
                                   for (; filter[i]; i++) {
                                           if (quote) {
                                                   if (backslash)
                                                           backslash = false;
                                                   else if (filter[i] == '\\')
                                                           backslash = true;
                                                   else if (filter[i] == quote)
                                                           quote = 0;
                                                   continue;
                                           }
                                           switch(filter[i]) {
                                           case '"': case '\'':
                                                   quote = filter[i];
                                                   continue;
                                           case 'a' ... 'z':
                                           case 'A' ... 'Z':
                                           case '0' ... '9':
                                           case '_':
                                                   continue;
                                           }
                                           break;
                                   }
                                   n = i - start_i;
                                   strncpy(val, filter + start_i, n);
                                   val[n] = '\0';
                                   break;
                           }
                           n = tracefs_filter_string_append(event, &amp;new_filter, type,
                                                           field, compare, val);
                           if (n &lt; 0) {
                                   fprintf(stderr, "Failed making new filter:\n'%s'\n",
                                           new_filter ? new_filter : "(null)");
                                   exit(-1);
                           }
                   }

                   if (tracefs_event_filter_apply(NULL, event, new_filter))
                           fprintf(stderr, "Failed to apply filter on event");

                   tep_free(tep);

                   printf("Created new filter: '%s'\n", new_filter);
                   free(new_filter);

                   <a href="../man0/exit.0.html">exit</a>(0);
           }

</pre><h4><b>FILES</b></h4><pre>
           <b>tracefs.h</b>
                   Header file to include in order to have access to the library APIs.
           <b>-ltracefs</b>
                   Linker switch to add when building a program that uses the library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/libtracefs.3.html">libtracefs</a></b>(3), <b><a href="../man3/libtraceevent.3.html">libtraceevent</a></b>(3), <b><a href="../man1/trace-cmd.1.html">trace-cmd</a></b>(1), <b><a href="../man3/tracefs_hist_alloc.3.html">tracefs_hist_alloc</a></b>(3), <b><a href="../man3/tracefs_hist_alloc_2d.3.html">tracefs_hist_alloc_2d</a></b>(3),
       <b><a href="../man3/tracefs_hist_alloc_nd.3.html">tracefs_hist_alloc_nd</a></b>(3), <b><a href="../man3/tracefs_hist_free.3.html">tracefs_hist_free</a></b>(3), <b><a href="../man3/tracefs_hist_add_key.3.html">tracefs_hist_add_key</a></b>(3), <b><a href="../man3/tracefs_hist_add_value.3.html">tracefs_hist_add_value</a></b>(3),
       <b><a href="../man3/tracefs_hist_add_name.3.html">tracefs_hist_add_name</a></b>(3), <b><a href="../man3/tracefs_hist_start.3.html">tracefs_hist_start</a></b>(3), <b><a href="../man3/tracefs_hist_destory.3.html">tracefs_hist_destory</a></b>(3), <b><a href="../man3/tracefs_hist_add_sort_key.3.html">tracefs_hist_add_sort_key</a></b>(3),
       <b><a href="../man3/tracefs_hist_sort_key_direction.3.html">tracefs_hist_sort_key_direction</a></b>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
           <b>Steven</b> <b>Rostedt</b> &lt;<b><a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a></b>[1]&gt;
           <b>Tzvetomir</b> <b>Stoyanov</b> &lt;<b><a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a></b>[2]&gt;
           <b>sameeruddin</b> <b>shaik</b> &lt;<b><a href="mailto:sameeruddin.shaik8@gmail.com">sameeruddin.shaik8@gmail.com</a></b>[3]&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<b><a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a></b>[4]&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       libtracefs is Free Software licensed under the GNU LGPL 2.1

</pre><h4><b>RESOURCES</b></h4><pre>
       <b>https://git.kernel.org/pub/scm/libs/libtrace/libtracefs.git/</b>

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2020 VMware, Inc. Free use of this software is granted under the terms of the GNU Public
       License (GPL).

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a>
           <a href="mailto:rostedt@goodmis.org">mailto:rostedt@goodmis.org</a>

        2. <a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a>
           <a href="mailto:tz.stoyanov@gmail.com">mailto:tz.stoyanov@gmail.com</a>

        3. <a href="mailto:sameeruddin.shaik8@gmail.com">sameeruddin.shaik8@gmail.com</a>
           <a href="mailto:sameeruddin.shaik8@gmail.com">mailto:sameeruddin.shaik8@gmail.com</a>

        4. <a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a>
           <a href="mailto:linux-trace-devel@vger.kernel.org">mailto:linux-trace-devel@vger.kernel.org</a>

libtracefs 1.8.1                                   06/05/2025                                      <u><a href="../man3/LIBTRACEFS.3.html">LIBTRACEFS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>