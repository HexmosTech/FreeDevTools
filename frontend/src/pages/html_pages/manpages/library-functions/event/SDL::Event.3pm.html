<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDL::Event - General event structure</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsdl-perl">libsdl-perl_2.548-5build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SDL::Event - General event structure

   <b>CATEGORY</b>
       Core, Events, Structure

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use SDL::Event;  # for the event object itself
        use SDL::Events; # functions for event queue handling

        SDL::init(SDL_INIT_VIDEO);
        my $event = SDL::Event-&gt;new();

        <a href="../man1/while.1.html">while</a>(1)
        {
            SDL::Events::pump_events();

            if(SDL::Events::poll_event($event))
            {
               if($event-&gt;type == SDL_MOUSEBUTTONDOWN)
               {
                   # now you can handle the details
                   $event-&gt;button_which;
                   $event-&gt;button_button;
                   $event-&gt;button_x;
                   $event-&gt;button_y;
               }

               last if $event-&gt;type == SDL_QUIT;
            }

            # your screen drawing code will be here
        }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Event handling allows your application to receive input from the user.  Event handling is initalised
       (along with video) with a call to:

       "SDL::init(SDL_INIT_VIDEO);"

       Internally, SDL stores all the events waiting to be handled in an event queue.  Using functions like
       SDL::Events::poll_event(), "SDL::Events::peep_events" and SDL::Events::wait_event() you can observe and
       handle waiting input events.

       The key to event handling in SDL is the "SDL::Event" union.  The event queue itself is composed of a
       series of "SDL::Event" unions, one for each waiting event.  "SDL::Event" unions are read from the queue
       with the SDL::Events::poll_event() function and it is then up to the application to process the
       information stored with them.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       "new" creates an empty event-object, which can be used store information.  Either by calling
       poll_event($event) that transfers one event from the queue into our object or by setting all the needed
       data manually in order to push the event to the queue.

        use SDL::Event;

        my $event = SDL::Event-&gt;new();

   <b>type</b>
       SDL::Event is a union of all event structures used in SDL, using it is a simple matter of knowing which
       union member relates to which event "type".

        print 'heureka' if $event-&gt;type == SDL_MOUSEBUTTONDOWN;

       Available type constants:

       •   SDL_ACTIVEEVENT - Application visibility event structure

       •   SDL_KEYDOWN - Keyboard event structure

       •   SDL_KEYUP - Keyboard event structure

       •   SDL_MOUSEMOTION - Mouse motion event structure

       •   SDL_MOUSEBUTTONDOWN - Mouse button event structure

       •   SDL_MOUSEBUTTONUP - Mouse button event structure

       •   SDL_JOYAXISMOTION - Joystick axis motion event structure

       •   SDL_JOYBALLMOTION - Joystick trackball motion event structure

       •   SDL_JOYHATMOTION - Joystick hat position change event structure

       •   SDL_JOYBUTTONDOWN - Joystick button event structure

       •   SDL_JOYBUTTONUP - Joystick button event structure

       •   SDL_VIDEORESIZE - Window resize event structure

       •   SDL_VIDEOEXPOSE - Window expose event

       •   SDL_QUIT - Quit requested event

       •   SDL_USEREVENT - A user-defined event type

       •   SDL_SYSWMEVENT - Platform-dependent window manager event.

       Event types are grouped by masks. SDL_EVENTMASK($type) will return the proper mask for the given "type".

       Available event mask constants:

       •   SDL_ACTIVEEVENTMASK

       •   SDL_KEYDOWNMASK

       •   SDL_KEYUPMASK

       •   SDL_KEYEVENTMASK

       •   SDL_MOUSEMOTIONMASK

       •   SDL_MOUSEBUTTONDOWNMASK

       •   SDL_MOUSEBUTTONUPMASK

       •   SDL_MOUSEEVENTMASK

       •   SDL_JOYAXISMOTIONMASK

       •   SDL_JOYBALLMOTIONMASK

       •   SDL_JOYHATMOTIONMASK

       •   SDL_JOYBUTTONDOWNMASK

       •   SDL_JOYBUTTONUPMASK

       •   SDL_JOYEVENTMASK

       •   SDL_VIDEORESIZEMASK

       •   SDL_VIDEOEXPOSEMASK

       •   SDL_QUITMASK

       •   SDL_SYSWMEVENTMASK

       This way you can check if a given "type" matches a mask:

        (SDL_EVENTMASK(SDL_JOYBUTTONDOWN)   &amp; SDL_MOUSEEVENTMASK) # is false
        (SDL_EVENTMASK(SDL_MOUSEBUTTONDOWN) &amp; SDL_MOUSEEVENTMASK) # is true
        (SDL_EVENTMASK(SDL_MOUSEBUTTONUP)   &amp; SDL_MOUSEEVENTMASK) # is true
        (SDL_EVENTMASK(SDL_MOUSEMOTION)     &amp; SDL_MOUSEEVENTMASK) # is true

        # and also true is:

        (SDL_MOUSEEVENTMASK == SDL_EVENTMASK(SDL_MOUSEBUTTONDOWN)
                             | SDL_EVENTMASK(SDL_MOUSEBUTTONUP)
                             | SDL_EVENTMASK(SDL_MOUSEMOTION))

   <b>Application</b> <b>visibility</b> <b>events</b>
       "active" is used when an event of type "SDL_ACTIVEEVENT" is reported.

       When  the  mouse  leaves or enters the window area a "SDL_APPMOUSEFOCUS" type activation event occurs, if
       the mouse entered the window then <b>gain</b> will be 1, otherwise <b>gain</b> will be 0.

       A "SDL_APPINPUTFOCUS" type activation event occurs when the application loses or  gains  keyboard  focus.
       This usually occurs when another application is made active.

       Finally,  a "SDL_APPACTIVE" type event occurs when the application is either minimised/iconified (<b>gain</b>=0)
       or restored.

       A single event can have multiple values set in <b>state</b>.

       <b>Note:</b> This event does not occur when an application window is first created.

       A new ActiveEvent (to fake focus loss) will be created like this:

        my $event = SDL::Event-&gt;new();
           $event-&gt;type(SDL_ACTIVEEVENT);
           $event-&gt;<a href="../man0/active_gain.0.html">active_gain</a>(0);
           $event-&gt;active_state(SDL_APPMOUSEFOCUS);

        # I think this is wrong, -&gt;active_type() should get SDL_APPMOUSEFOCUS, but what state gets?

       <u>active_gain</u>

       See "active". 0 if the event is a loss or 1 if it is a gain.

       <u>active_state</u>

       A bitmask of the following values: SDL_APPMOUSEFOCUS if mouse focus was gained or lost, SDL_APPINPUTFOCUS
       if input focus was gained or lost, and  SDL_APPACTIVE  if  the  application  was  iconified  (gain=0)  or
       restored(gain=1).

   <b>Keyboard</b> <b>events</b>
       "key" is used when an event of type "SDL_KEYDOWN" or "SDL_KEYUP" is reported.

       The  type  and  state  actually  report the same information, they just use different values to do it.  A
       keyboard event generally occurs when a key is released ("type=SDL_KEYUP" or "key_state=SDL_RELEASED") and
       when a key is pressed ("type=SDL_KEYDOWN" or "key_state=SDL_PRESSED").

       The "SDLK_CAPSLOCK" and "SDLK_NUMLOCK" keys are special cases and  report  an  "SDL_KEYDOWN"  when  first
       pressed,  then  an  "SDL_RELEASED"  when released and pressed again. For these keys "KEYUP" and "KEYDOWN"
       events are therefore analogous to the state of the caps lock and num  lock  LEDs  rather  than  the  keys
       themselves.  These special cases are required for compatibility with Sun workstations.

       <b>Note:</b>    Repeating    "SDL_KEYDOWN"    events    will    occur    if   key   repeat   is   enabled   (see
       SDL::Events::enable_key_repeat).

       <u>key_state</u>

       "SDL_PRESSED" or "SDL_RELEASED"

       <u>key_scancode</u>

       The "scancode" field should generally be left alone, it is the hardware-dependent  scancode  returned  by
       the keyboard.

       <u>key_sym</u>

       The  "sym"  field is extremely useful. It is the SDL-defined value of the key (see the keysym definitions
       in SDLKey).  This field is very useful when you are checking for certain key presses, like so:

        while(poll_event($event))
        {
            switch($event-&gt;type)
            {
                case SDL_KEYDOWN:
                    move_left() if($event-&gt;key_sym == SDLK_LEFT);
                    break;
                .
                .
                .
            }
        }

       <u>key_mod</u>

       "mod" stores the current state of the keyboard modifiers as explained in SDL_GetModState.

       <u>key_unicode</u>

       The "unicode" field is only used when UNICODE translation is  enabled  with  SDL::Events::enable_unicode.
       If "unicode" is non-zero then this is the UNICODE character corresponding to the keypress.  If the high 9
       bits of the character are 0, then this maps to the equivalent ASCII character:

        my $char;
        if(($event-&gt;key_unicode &amp; 0xFF80) == 0)
        {
            $char = $event-&gt;key_unicode &amp; 0x7F;
        }
        else
        {
            print("An International Character.\n");
        }

       UNICODE translation does create a slight overhead so don't enable it unless its needed.

       NOTE:  Key  release  events  (SDL_KEYUP)  won't  necessarily  (ever?)  contain  unicode information.  See
       &lt;<a href="http://lists.libsdl.org/pipermail/sdl-libsdl.org/2005-January/048355.html">http://lists.libsdl.org/pipermail/sdl-libsdl.org/2005-January/048355.html</a>&gt;

   <b>Mouse</b> <b>motion</b> <b>events</b>
       Simply put, a SDL_MOUSEMOTION type event occurs when a user moves the mouse within the application window
       or  when  SDL_WarpMouse  is  called.  Both  the  absolute  ("motion_x"  and  "motion_y")   and   relative
       ("motion_xrel"  and  "motion_yrel")  coordinates  are  reported  along  with  the  current  button states
       ("motion_state").

       <u>motion_state</u>

       The button state can be interpreted using the "SDL_BUTTON" macro (see SDL::Events::get_mouse_state).

       <u>motion_x,</u> <u>motion_y</u>

       The X/Y coordinates of the mouse

       <u>motion_xrel,</u> <u>motion_yrel</u>

       Relative motion in the X/Y direction.

       If the cursor is hidden (<b><a href="../man0/SDL_ShowCursor.0.html">SDL_ShowCursor</a></b>(0)) and the  input  is  grabbed  (SDL_WM_GrabInput(SDL_GRAB_ON)),
       then  the  mouse  will  give  relative motion events even when the cursor reaches the edge of the screen.
       This is currently only implemented on Windows and Linux/Unix-alikes.

   <b>Mouse</b> <b>button</b> <b>events</b>
       When a mouse button press or release is detected, the number of the button pressed (from 1 to 255, with 1
       usually being the left button and 2 the right) is placed into "button_button". The position of the  mouse
       when  this  event  occurred is stored in the "button_x" and the "button_y" fields. Like a keyboard event,
       information on whether the event was a press or a release event is stored in both the  "button_type"  and
       "button_state" fields, but this should be obvious.

       Mouse  wheel  events are reported as buttons 4 (up) and 5 (down). Two events are generated i.e. you get a
       "SDL_MOUSEBUTTONDOWN" followed by a "SDL_MOUSEBUTTONUP" event.

       <u>button_which</u>

       The input device index

       <u>button_button</u>

       The mouse button index ("SDL_BUTTON_LEFT", "SDL_BUTTON_MIDDLE", "SDL_BUTTON_RIGHT", "SDL_BUTTON_WHEELUP",
       "SDL_BUTTON_WHEELDOWN")

       <u>button_state</u>

       "SDL_PRESSED" or "SDL_RELEASED"

       <u>button_x,</u> <u>button_y</u>

       The X/Y coordinates of the mouse at press/release time

   <b>Joystick</b> <b>axis</b> <b>events</b>
       A "SDL_JOYAXISMOTION" event occurs whenever a user moves an axis on the joystick.

       <u>jaxis_which</u>

       The field "jaxis_which" is the index of the joystick that reported the event.

       <u>jaxis_axis</u>

       The "jaxis_axis" is the index of the axis (for a more detailed explanation see the Joystick section).

       <u>jaxis_value</u>

       "jaxis_value" is the current position of the axis (range: -32768 to 32767).

   <b>Joystick</b> <b>button</b> <b>events</b>
       A "SDL_JOYBUTTONDOWN" or "SDL_JOYBUTTONUP" event occurs when ever a user presses or releases a button  on
       a joystick.

       <u>jbutton_which</u>

       The field "jbutton_which" is the index of the joystick that reported the event.

       <u>jbutton_button</u>

       The  "jbutton_button"  is  the  index  of  the  button  (for a more detailed explanation see the Joystick
       section).

       <u>jbutton_state</u>

       "jbutton_state"  is  the  current  state  of  the  button  which  is  either   "jbutton_SDL_PRESSED"   or
       "jbutton_SDL_RELEASED".

   <b>Joystick</b> <b>hat</b> <b>events</b>
       A "SDL_JOYHATMOTION" event occurs when ever a user moves a hat on the joystick.

       <u>jhat_which</u>

       The field "jhat_which" is the index of the joystick that reported the event.

       <u>jhat_hat</u>

       "jhat_hat" is the index of the hat (for a more detailed explanation see the Joystick section).

       <u>jhat_value</u>

       "jhat_value" is the current position of the hat. It is a bitwise OR'd combination of the following values
       (whose meanings should be pretty obvious):

       •   "SDL_HAT_CENTERED"

       •   "SDL_HAT_UP"

       •   "SDL_HAT_RIGHT"

       •   "SDL_HAT_DOWN"

       •   "SDL_HAT_LEFT"

       The following defines are also provided:

       •   "SDL_HAT_RIGHTUP"

       •   "SDL_HAT_RIGHTDOWN"

       •   "SDL_HAT_LEFTUP"

       •   "SDL_HAT_LEFTDOWN"

   <b>Joystick</b> <b>trackball</b> <b>events</b>
       A "SDL_JOYBALLMOTION" event occurs when a user moves a trackball on the joystick.

       <u>jball_which</u>

       The field "jball_which" is the index of the joystick that reported the event.

       <u>jball_ball</u>

       "jball_ball" is the index of the trackball (for a more detailed explanation see the Joystick section).

       <u>jball_xrel,</u> <u>jball_yrel</u>

       Trackballs  only  return  relative  motion,  this is the change in position on the ball since it was last
       polled (last cycle of the event loop) and it is stored in "jball_xrel" and "jball_yrel".

   <b>Window</b> <b>resize</b> <b>events</b>
       <u>resize_w,</u> <u>resize_h</u>

       When "SDL_RESIZABLE" is passed as a flag  to  "SDL_SetVideoMode"  the  user  is  allowed  to  resize  the
       applications  window.  When  the  window is resized an "SDL_VIDEORESIZE" is reported, with the new window
       width  and  height  values  stored  in  the  resize  structure's  "resize_w"  and  "resize_h".   When  an
       "SDL_VIDEORESIZE" is received the window should be resized to the new dimensions using SDL_SetVideoMode.

   <b>Window</b> <b>expose</b> <b>events</b>
       A  "VIDEOEXPOSE" event is triggered when the screen has been modified outside of the application, usually
       by the window manager and needs to be redrawn.

   <b>System</b> <b>window</b> <b>manager</b> <b>events</b>
       The system window manager event contains a  system-specific  information  about  unknown  window  manager
       events.  If  you enable this event using "SDL_EventState", it will be generated whenever unhandled events
       are received from the window manager. This can be used, for example, to implement cut-and-paste  in  your
       application.

       If  you  want to obtain system-specific information about the window manager, you can fill in the version
       member of a SDL_SysWMinfo structure (details can be found in SDL_syswm.h, which must be  included)  using
       the <b>SDL_VERSION()</b> macro found in SDL_version.h, and pass it to the function:

        int SDL_GetWMInfo(SDL_SysWMinfo *info);

       See &lt;<a href="http://www.libsdl.org/cgi/docwiki.cgi/SDL_SysWMEvent">http://www.libsdl.org/cgi/docwiki.cgi/SDL_SysWMEvent</a>&gt;

       <u>syswm_msg</u>

   <b>User</b> <b>defined</b> <b>events</b>
       This  event  is unique, it is never created by SDL but only by the user. The event can be pushed onto the
       event queue using "SDL::Events::push_event". The contents of the structure members are completely  up  to
       the  programmer,  the  only requirement is that type is a value from "SDL_USEREVENT" to "SDL_NUMEVENTS-1"
       (inclusive)

        my $event = SDL::Event-&gt;new();
           $event-&gt;type ( SDL_USEREVENT + 3 );
           $event-&gt;<a href="../man10/user_code.10.html">user_code</a>(10);
           $event-&gt;user_data1('hello event');

        SDL::Events::push_event($event);

       <u>user_code</u>

       User defined event code (integer).

       <u>user_data1,</u> <u>user_data2</u>

       User defined data.

   <b>Quit</b> <b>event</b>
       As can be seen, the "SDL_QuitEvent" structure serves no useful purpose. The event itself,  on  the  other
       hand,  is  very important. If you filter out or ignore a quit event then it is impossible for the user to
       close the window. On the other hand, if you do accept a quit event then the application  window  will  be
       closed,  and  screen  updates  will  still  report  success even though the application will no longer be
       visible.

       <b>Note</b>: The macro SDL_QuitRequested will return non-zero if a quit event is pending

</pre><h4><b>AUTHORS</b></h4><pre>
       See "AUTHORS" in SDL.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       perl

perl v5.40.0                                       2024-10-20                              <u>pods::SDL::<a href="../man3pm/Event.3pm.html">Event</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>