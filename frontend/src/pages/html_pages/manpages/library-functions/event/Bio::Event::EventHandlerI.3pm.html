<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Event::EventHandlerI - An Event Handler Interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Event::EventHandlerI - An Event Handler Interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # do not use this module directly
           # See Bio::SearchIO::SearchResultEventHandler for an example of
           # implementation.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This interface describes the basic methods required for EventHandlers.  These are essentially SAX
       methods.

</pre><h4><b>Developer</b> <b>Notes</b></h4><pre>
       EventHandlerI implementations are used in the BioPerl IO systems to decouple the task of tokenizing the
       input stream into data elements and their attributes, which is format-specific, and the task of
       collecting those elements and attributes into whatever is the result of a parser, which is specific to
       the kind of result to be produced, such as BioPerl objects, a tabular or array data structure, etc.

       You can think of EventHandlerI-compliant parsers as faking a SAX XML parser, making their input
       (typically a non-XML document) behave as if it were XML. The overhead to do this can be quite
       substantial, at the gain of not having to duplicate the parsing code in order to change the parsing
       result, and not having to duplicate the logic of instantiating objects between parsers for different
       formats that all give rise to the same types of objects. This is perhaps best illustrated by the
       Bio::SearchIO system, where many different formats exist for sequence similarity and pairwise sequence
       alignment exist that essentially all result in Bio::Search objects.

       The method names and their invocation semantics follow their XML SAX equivalents, see
       <a href="http://www.saxproject.org/apidoc/">http://www.saxproject.org/apidoc/</a>, especially the org.xml.sax.ContentHandler interface.

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>Lists</b>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to the Bioperl mailing list.  Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

       <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track of the bugs and their resolution.
       Bug reports can be submitted via the web:

         https://github.com/bioperl/bioperl-live/issues

</pre><h4><b>AUTHOR</b> <b>-</b> <b>Jason</b> <b>Stajich</b></h4><pre>
       Email <a href="mailto:jason@bioperl.org">jason@bioperl.org</a>

</pre><h4><b>APPENDIX</b></h4><pre>
       The rest of the documentation details each of the object methods.  Internal methods are usually preceded
       with a _

   <b>will_handle</b>
        Title   : will_handle
        Usage   : if( $handler-&gt;will_handle($event_type) ) { ... }
        Function: Tests if this event builder knows how to process a specific event
        Returns : boolean
        Args    : event type name

   <b>SAX</b> <b>methods</b>
   <b>start_document</b>
        Title   : start_document
        Usage   : $resultObj = $parser-&gt;start_document();
        Function: Receive notification of the beginning of a document (the
                  input file of a parser). The parser will invoke this method
                  only once, before any other event callbacks.

                  Usually, a handler will reset any internal state structures
                  when this method is called.

        Returns : none
        Args    : none

   <b>end_document</b>
        Title   : end_document
        Usage   : $parser-&gt;end_document();
        Function: Receive notification of the end of a document (normally the
                  input file of a parser). The parser will invoke this method
                  only once, and it will be the last method invoked during
                  the parse of the document. The parser shall not invoke this
                  method until it has either abandoned parsing (because of an
                  unrecoverable error) or reached the end of input.

                  Unlike the XML SAX signature of this method, this method is
                  expected to return the object representing the result of
                  parsing the document.

        Returns : The object representing the result of parsing the input
                  stream between the calls to start_document() and this method.
        Args    : none

   <b>start_element</b>
        Title   : start_element
        Usage   : $parser-&gt;start_element

        Function: Receive notification of the beginning of an element. The
                  Parser will invoke this method at the beginning of every
                  element in the input stream; there will be a corresponding
                  end_element() event for every start_element() event (even when
                  the element is empty). All of the element's content will be
                  reported, in order, before the corresponding end_element()
                  event.

        Returns : none
        Args : A hashref with at least 2 keys: 'Data' and 'Name'. The value
               for 'Name' is expected to be the type of element being
               encountered; the understood values will depend on the IO
               parser to which this interface is being applied. Likewise, the
               value for 'Data' will be specific to event handler
               implementions, and the specific data chunking needs of input
               formats to be handled efficiently.

   <b>end_element</b>
        Title   : end_element
        Usage   : $parser-&gt;end_element

        Function: Receive notification of the end of an element. The parser
                  will invoke this method at the end of every element in the
                  input stream; there will be a corresponding start_element()
                  event for every end_element() event (even when the element
                  is empty).

        Returns : none

        Args    : hashref with at least 2 keys, 'Data' and 'Name'. The semantics
                  are the same as for start_element().

   <b>in_element</b>
        Title   : in_element
        Usage   : if( $handler-&gt;in_element($element) ) {}

        Function: Test if we are in a particular element.

                  Normally, in_element() will test for particular attributes,
                  or nested elements, within a containing
                  element. Conversely, the containing element can be queries
                  with within_element(). The names understood as argument
                  should be the same as the ones understood for the 'Name'
                  key in start_element() and end_element().

                  Typically, handler implementations will call this method
                  from within the characters() method to determine the
                  context of the data that were passed to characters().

        Returns : boolean

        Args    : A string, the name of the element (normally an attribute name or nested sub-element name).

   <b>within_element</b>
        Title   : within_element
        Usage   : if( $handler-&gt;within_element($element) ) {}

        Function: Test if we are within a particular kind of element.

                  Normally, the element type names understood as argument
                  values will be for containing elements or data
                  chunks. Conversely, in_element() can be used to test
                  whether an attribute or nested element is the ccurrent
                  context.

                  Typically, a handler will call this method from within the
                  characters() method to determine the context for the data
                  that were passed to characters().

        Returns : boolean
        Args    : string element name

   <b>characters</b>
        Title   : characters
        Usage   : $parser-&gt;characters($str)
        Function: Receive notification of character data. The parser will
                  call this method to report values of attributes, or larger
                  data chunks, depending on the IO subsystem and event
                  handler implementation. Values may be whitespace-padded
                  even if the whitespace is insignificant for the format.

                  The context of the character data being passed can be
                  determined by calling the in_element() and within_element()
                  methods.

        Returns : none
        Args    : string, the character data

perl v5.32.1                                       2021-08-15                     <u>Bio::Event::<a href="../man3pm/EventHandlerI.3pm.html">EventHandlerI</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>