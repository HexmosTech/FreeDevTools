<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>io_wait - wait for events</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libowfat-dev">libowfat-dev_0.32-5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       io_wait - wait for events

</pre><h4><b>SYNTAX</b></h4><pre>
       <b>#include</b> <b>&lt;libowfat/io.h&gt;</b>

       void <b>io_wait</b>();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       io_wait()  checks the descriptors that the program is interested in to see whether any of them are ready.
       If none of them are ready, io_wait() tries to pause until one of them is ready, so that it does not  take
       time away from other programs running on the same computer.

       io_wait pays attention to timeouts: if a descriptor reaches its timeout, and the program is interested in
       reading or writing that descriptor, io_wait will return promptly.

       Under  some  circumstances,  io_wait will return even though no interesting descriptors are ready. Do not
       assume that a descriptor is ready merely because io_wait has returned.

       io_wait is not interrupted by the delivery of a signal. Programs that expect interruption are unreliable:
       they will block if the same signal is delivered a moment  before  io_wait.  The  correct  way  to  handle
       signals is with the self-pipe trick.

</pre><h4><b>NOTE</b></h4><pre>
       Depending  on  the underlying operating system primitive, there is a potential race condition to be aware
       of. Some event notification mechanisms (for example, kqueue on  BSD  and  epoll  on  Linux)  will  return
       multiple events. If your application operates on pairs of file descriptors (a proxy server maybe), and an
       error  on one descriptor can lead to closing the other descriptor, then an outstanding event on the other
       descriptor can still be queued for delivery to you. Be prepared to receive events for a  descriptor  that
       has already been closed.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/io_waituntil.3.html">io_waituntil</a>(3), <a href="../man3/io_check.3.html">io_check</a>(3), <a href="../man3/io_wantread.3.html">io_wantread</a>(3), <a href="../man3/io_wantwrite.3.html">io_wantwrite</a>(3), <a href="../man3/io_fd.3.html">io_fd</a>(3)

                                                                                                      <u><a href="../man3/io_wait.3.html">io_wait</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>