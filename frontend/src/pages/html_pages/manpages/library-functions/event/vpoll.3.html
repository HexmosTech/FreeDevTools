<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vpoll_create, vpoll_ctl, vpoll_close - generate synthetic events for poll/select/ppoll/pselect/epoll</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libvpoll-dev">libvpoll-dev_0.1.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       vpoll_create, vpoll_ctl, vpoll_close - generate synthetic events for poll/select/ppoll/pselect/epoll

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>*vpoll.h*</b>

       <b>int</b> <b>vpoll_create(uint32_t</b> <u>init_events</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

       <b>int</b> <b>vpoll_ctl(int</b> <u>fd</u><b>,</b> <b>int</b> <u>op</u><b>,</b> <b>uint32_t</b> <u>events</u><b>);</b>

       <b>int</b> <b>vpoll_close(int</b> <u>fd</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  library  permits  one  to  create  a  vpoll  file descriptor “vpollfd” that can be used in poll/se‐
       lect/ppoll/pselect/<a href="../man2/epoll.2.html">epoll</a>(2) system calls.  The events reported by  a  can  be  controlled  by  <b>vpoll_ctl</b>.
       <b>vpoll</b> encodes the events using the same flags EPOLL* defined in <b><a href="../man2/epoll_ctl.2.html">epoll_ctl</a>(2)</b>.

       The  library uses the vpoll extension for eventfd if the kernel provides it otherwise it (partially) emu‐
       lates the feature using <a href="../man2/socketpair.2.html">socketpair</a>(2).  The emulation supports only <b>EPOLLIN</b>, <b>EPOLLOUT</b>  flags  and  a  non
       standard version of EPOLLHUP/EPOLLRDHUP.

       <b>vpoll_create</b>
              This  function  creates a “vpollfd”.  The argument <u>init_events</u> is used to set the initial state of
              events.  The following value can be included in <u>flags</u>:

              <b>FD_CLOEXEC</b>: Set the close-on-exec flag on the new file descriptor.  See  the  description  of  the
              O_CLOEXEC flag in <a href="../man2/open.2.html">open</a>(2) for reasons why this may be useful.

       <b>vpoll_ctl</b>
              This function changes the set of pending events reported by a “vpollfd”.  The argument <u>op</u> can take
              the following values:

              <b>VPOLL_CTL_ADDEVENTS</b>: the events set in the argument <u>events</u> are added to the set of pending events.

              <b>VPOLL_CTL_DELEVENTS</b>:  the  events  set  in the argument <u>events</u> are deleted from the set of pending
              events.

              <b>VPOLL_CTL_SETEVENTS</b>: the value of the argument <u>events</u> is assigned to the set of pending events.

       <b>vpoll_close</b>
              This function closes the vpoll file descritor.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>vpoll_create</b> returns the new file descriptor, or -1 if an error occurred (in which case, errno is set ap‐
       propriately)

       <b>vpoll_ctl</b> and <b>vpoll_close</b> return zero in case of success.  On error, -1 is returned, and errno is set ap‐
       propriately.

</pre><h4><b>EXAMPLE</b></h4><pre>
              #define _GNU_SOURCE
              #include *stdio.h*
              #include *stdlib.h*
              #include *unistd.h*
              #include *fcntl.h*
              #include *errno.h*
              #include *sys/epoll.h*
              #include *vpoll.h*

              int main(int argc, char *argv[]) {
                int vpollfd = vpoll_create(0, FD_CLOEXEC);
                int epfd = epoll_create1(EPOLL_CLOEXEC);
                struct epoll_event reqevents={EPOLLIN | EPOLLRDHUP | EPOLLERR |
                    EPOLLOUT | EPOLLHUP | EPOLLPRI};
                epoll_ctl(epfd,  EPOLL_CTL_ADD, vpollfd, &amp;reqevents);
                switch (fork()) {
                    case 0:
                        <a href="../man3/sleep.3.html">sleep</a>(3);
                        vpoll_ctl(vpollfd, VPOLL_CTL_ADDEVENTS,  EPOLLIN);
                        <a href="../man3/sleep.3.html">sleep</a>(3);
                        vpoll_ctl(vpollfd, VPOLL_CTL_ADDEVENTS,  EPOLLIN);
                        <a href="../man3/sleep.3.html">sleep</a>(3);
                        vpoll_ctl(vpollfd, VPOLL_CTL_ADDEVENTS,  EPOLLOUT);
                        <a href="../man3/sleep.3.html">sleep</a>(3);
                        vpoll_ctl(vpollfd, VPOLL_CTL_ADDEVENTS,  EPOLLHUP);
                        <a href="../man3/sleep.3.html">sleep</a>(3);
                        <a href="../man0/exit.0.html">exit</a>(0);
                    default:
                        while (1) {
                            struct epoll_event ev;
                            int n = epoll_wait(epfd, &amp;ev, 1, 1000);
                            if (n * 0) {
                                perror("epoll_wait");
                                break;
                            }
                            if (n * 0) {
                                printf("GOT event %x\n", ev.events);
                                vpoll_ctl(vpollfd, VPOLL_CTL_DELEVENTS, ev.events);
                                if (ev.events &amp; EPOLLHUP)
                                        break;
                            } else {
                                printf("timeout\n");
                            }
                        }
                        break;
                    case -1:
                        printf("fork error\n");
                }
                vpoll_close(vpollfd);
                close(epfd);
                return 0;
              }

       On a machine running a Linux Kernel providing eventfd/vpoll the output of this program is:

              timeout
              timeout
              GOT event 1
              timeout
              timeout
              GOT event 1
              timeout
              timeout
              GOT event 4
              timeout
              timeout
              GOT event 10

       Instead when the demo program runs using the emulation layer the output is:

              timeout
              timeout
              GOT event 1
              timeout
              timeout
              GOT event 1
              timeout
              timeout
              GOT event 4
              timeout
              timeout
              GOT event 2011

       In fact, the emulator uses a socketpair to generate the events.  Hangup is emulated by closing the  other
       end of the socketpair: this generates EPOLLHUP as well as EPOLLIN and EPOLLRDHUP.

</pre><h4><b>AUTHOR</b></h4><pre>
       VirtualSquare.  Project leader: Renzo Davoli.

VirtualSquare                                     December 2022                                         <u><a href="../man3/VPOLL.3.html">VPOLL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>