<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ibv_get_cq_event, ibv_ack_cq_events - get and acknowledge completion queue (CQ) events</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libibverbs-dev">libibverbs-dev_56.1-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ibv_get_cq_event, ibv_ack_cq_events - get and acknowledge completion queue (CQ) events

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;infiniband/verbs.h&gt;</b>

       <b>int</b> <b>ibv_get_cq_event(struct</b> <b>ibv_comp_channel</b> <u>*channel</u><b>,</b>
                            <b>struct</b> <b>ibv_cq</b> <u>**cq</u><b>,</b> <b>void</b> <u>**cq_context</u><b>);</b>

       <b>void</b> <b>ibv_ack_cq_events(struct</b> <b>ibv_cq</b> <u>*cq</u><b>,</b> <b>unsigned</b> <b>int</b> <u>nevents</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>ibv_get_cq_event()</b>  waits  for  the next completion event in the completion event channel <u>channel</u>.  Fills
       the arguments <u>cq</u> with the CQ that got the event and <u>cq_context</u> with the CQ's context.

       <b>ibv_ack_cq_events()</b> acknowledges <u>nevents</u> events on the CQ <u>cq</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>ibv_get_cq_event()</b> returns 0 on success, and -1 on error.

       <b>ibv_ack_cq_events()</b> returns no value.

</pre><h4><b>NOTES</b></h4><pre>
       All completion events that <b>ibv_get_cq_event()</b> returns must be acknowledged using <b>ibv_ack_cq_events()</b>.  To
       avoid races, destroying a CQ will wait for all completion events to be acknowledged;  this  guarantees  a
       one-to-one correspondence between acks and successful gets.

       Calling  <b>ibv_ack_cq_events()</b>  may  be  relatively  expensive in the datapath, since it must take a mutex.
       Therefore it may be better to amortize this cost by keeping a count  of  the  number  of  events  needing
       acknowledgement and acking several completion events in one call to <b>ibv_ack_cq_events()</b>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following code example demonstrates one possible way to work with completion events. It performs the
       following steps:

       Stage I: Preparation
       1. Creates a CQ
       2. Requests for notification upon a new (first) completion event

       Stage II: Completion Handling Routine
       3. Wait for the completion event and ack it
       4. Request for notification upon the next completion event
       5. Empty the CQ

       Note that an extra event may be triggered without having a corresponding  completion  entry  in  the  CQ.
       This  occurs  if  a  completion  entry  is  added to the CQ between Step 4 and Step 5, and the CQ is then
       emptied (polled) in Step 5.

       cq = ibv_create_cq(ctx, 1, ev_ctx, channel, 0);
       if (!cq) {
               fprintf(stderr, "Failed to create CQ\n");
               return 1;
       }

       /* Request notification before any completion can be created */
       if (ibv_req_notify_cq(cq, 0)) {
               fprintf(stderr, "Couldn't request CQ notification\n");
               return 1;
       }

       .
       .
       .

       /* Wait for the completion event */
       if (ibv_get_cq_event(channel, &amp;ev_cq, &amp;ev_ctx)) {
               fprintf(stderr, "Failed to get cq_event\n");
               return 1;
       }

       /* Ack the event */
       ibv_ack_cq_events(ev_cq, 1);

       /* Request notification upon the next completion event */
       if (ibv_req_notify_cq(ev_cq, 0)) {
               fprintf(stderr, "Couldn't request CQ notification\n");
               return 1;
       }

       /* Empty the CQ: poll all of the completions from the CQ (if any exist) */
       do {
               ne = ibv_poll_cq(cq, 1, &amp;wc);
               if (ne &lt; 0) {
                       fprintf(stderr, "Failed to poll completions from the CQ\n");
                       return 1;
               }

               /* there may be an extra event with no completion in the CQ */
               if (ne == 0)
                       continue;

               if (wc.status != IBV_WC_SUCCESS) {
                       fprintf(stderr, "Completion with status 0x%x was found\n", wc.status);
                       return 1;
               }
       } while (ne);

       The following code example demonstrates one possible way to work with completion events  in  non-blocking
       mode.  It performs the following steps:

       1. Set the completion event channel to be non-blocked
       2. Poll the channel until there it has a completion event
       3. Get the completion event and ack it

       /* change the blocking mode of the completion channel */
       flags = fcntl(channel-&gt;fd, F_GETFL);
       rc = fcntl(channel-&gt;fd, F_SETFL, flags | O_NONBLOCK);
       if (rc &lt; 0) {
            fprintf(stderr, "Failed to change file descriptor of completion event channel\n");
            return 1;
       }

       /*
        * poll the channel until it has an event and sleep ms_timeout
        * milliseconds between any iteration
        */
       my_pollfd.fd      = channel-&gt;fd;
       my_pollfd.events  = POLLIN;
       my_pollfd.revents = 0;

       do {
            rc = poll(&amp;my_pollfd, 1, ms_timeout);
       } while (rc == 0);
       if (rc &lt; 0) {
            fprintf(stderr, "poll failed\n");
            return 1;
       }
       ev_cq = cq;

       /* Wait for the completion event */
       if (ibv_get_cq_event(channel, &amp;ev_cq, &amp;ev_ctx)) {
               fprintf(stderr, "Failed to get cq_event\n");
               return 1;
       }

       /* Ack the event */
       ibv_ack_cq_events(ev_cq, 1);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/ibv_create_comp_channel.3.html">ibv_create_comp_channel</a></b>(3), <b><a href="../man3/ibv_create_cq.3.html">ibv_create_cq</a></b>(3), <b><a href="../man3/ibv_req_notify_cq.3.html">ibv_req_notify_cq</a></b>(3), <b><a href="../man3/ibv_poll_cq.3.html">ibv_poll_cq</a></b>(3)

</pre><h4><b>AUTHORS</b></h4><pre>
       Dotan Barak
              &lt;<u><a href="mailto:dotanba@gmail.com">dotanba@gmail.com</a></u>&gt;

libibverbs                                         2006-10-31                                <u><a href="../man3/IBV_GET_CQ_EVENT.3.html">IBV_GET_CQ_EVENT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>