<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ibv_get_async_event, ibv_ack_async_event - get or acknowledge asynchronous events</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libibverbs-dev">libibverbs-dev_56.1-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ibv_get_async_event, ibv_ack_async_event - get or acknowledge asynchronous events

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;infiniband/verbs.h&gt;</b>

       <b>int</b> <b>ibv_get_async_event(struct</b> <b>ibv_context</b> <u>*context</u><b>,</b>
                               <b>struct</b> <b>ibv_async_event</b> <u>*event</u><b>);</b>

       <b>void</b> <b>ibv_ack_async_event(struct</b> <b>ibv_async_event</b> <u>*event</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>ibv_get_async_event()</b>  waits  for  the next async event of the RDMA device context <u>context</u> and returns it
       through the pointer <u>event</u>, which is an ibv_async_event struct, as defined in &lt;infiniband/verbs.h&gt;.

       struct ibv_async_event {
               union {
                       struct ibv_cq  *cq;             /* CQ that got the event */
                       struct ibv_qp  *qp;             /* QP that got the event */
                       struct ibv_srq *srq;            /* SRQ that got the event */
                       struct ibv_wq  *wq;             /* WQ that got the event */
                       int             port_num;       /* port number that got the event */
               } element;
               enum ibv_event_type     event_type;     /* type of the event */
       };

       One member of the element union will be valid, depending on  the  event_type  member  of  the  structure.
       event_type will be one of the following events:

       <u>QP</u> <u>events:</u>

       <b>IBV_EVENT_QP_FATAL</b>  Error occurred on a QP and it transitioned to error state

       <b>IBV_EVENT_QP_REQ_ERR</b>  Invalid Request Local Work Queue Error

       <b>IBV_EVENT_QP_ACCESS_ERR</b>  Local access violation error

       <b>IBV_EVENT_COMM_EST</b>  Communication was established on a QP

       <b>IBV_EVENT_SQ_DRAINED</b>  Send Queue was drained of outstanding messages in progress

       <b>IBV_EVENT_PATH_MIG</b>  A connection has migrated to the alternate path

       <b>IBV_EVENT_PATH_MIG_ERR</b>  A connection failed to migrate to the alternate path

       <b>IBV_EVENT_QP_LAST_WQE_REACHED</b>  Last WQE Reached on a QP associated with an SRQ

       <u>CQ</u> <u>events:</u>

       <b>IBV_EVENT_CQ_ERR</b>  CQ is in error (CQ overrun)

       <u>SRQ</u> <u>events:</u>

       <b>IBV_EVENT_SRQ_ERR</b>  Error occurred on an SRQ

       <b>IBV_EVENT_SRQ_LIMIT_REACHED</b>  SRQ limit was reached

       <u>WQ</u> <u>events:</u>

       <b>IBV_EVENT_WQ_FATAL</b>  Error occurred on a WQ and it transitioned to error state

       <u>Port</u> <u>events:</u>

       <b>IBV_EVENT_PORT_ACTIVE</b>  Link became active on a port

       <b>IBV_EVENT_PORT_ERR</b>  Link became unavailable on a port

       <b>IBV_EVENT_LID_CHANGE</b>  LID was changed on a port

       <b>IBV_EVENT_PKEY_CHANGE</b>  P_Key table was changed on a port

       <b>IBV_EVENT_SM_CHANGE</b>  SM was changed on a port

       <b>IBV_EVENT_CLIENT_REREGISTER</b>  SM sent a CLIENT_REREGISTER request to a port

       <b>IBV_EVENT_GID_CHANGE</b>  GID table was changed on a port

       <u>CA</u> <u>events:</u>

       <b>IBV_EVENT_DEVICE_FATAL</b>  CA is in FATAL state

       <b>ibv_ack_async_event()</b> acknowledge the async event <u>event</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>ibv_get_async_event()</b> returns 0 on success, and -1 on error.

       <b>ibv_ack_async_event()</b> returns no value.

</pre><h4><b>NOTES</b></h4><pre>
       All async events that <b>ibv_get_async_event()</b> returns must be acknowledged using <b>ibv_ack_async_event()</b>.  To
       avoid  races,  destroying an object (CQ, SRQ or QP) will wait for all affiliated events for the object to
       be acknowledged; this avoids an application retrieving an affiliated event after the corresponding object
       has already been destroyed.

       <b>ibv_get_async_event()</b> is a blocking function.  If multiple threads  call  this  function  simultaneously,
       then when an async event occurs, only one thread will receive it, and it is not possible to predict which
       thread will receive it.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following code example demonstrates one possible way to work with async events in non-blocking mode.
       It performs the following steps:

       1. Set the async events queue work mode to be non-blocked
       2. Poll the queue until it has an async event
       3. Get the async event and ack it

       /* change the blocking mode of the async event queue */
       flags = fcntl(ctx-&gt;async_fd, F_GETFL);
       rc = fcntl(ctx-&gt;async_fd, F_SETFL, flags | O_NONBLOCK);
       if (rc &lt; 0) {
               fprintf(stderr, "Failed to change file descriptor of async event queue\n");
               return 1;
       }

       /*
        * poll the queue until it has an event and sleep ms_timeout
        * milliseconds between any iteration
        */
       my_pollfd.fd      = ctx-&gt;async_fd;
       my_pollfd.events  = POLLIN;
       my_pollfd.revents = 0;

       do {
               rc = poll(&amp;my_pollfd, 1, ms_timeout);
       } while (rc == 0);
       if (rc &lt; 0) {
               fprintf(stderr, "poll failed\n");
               return 1;
       }

       /* Get the async event */
       if (ibv_get_async_event(ctx, &amp;async_event)) {
               fprintf(stderr, "Failed to get async_event\n");
               return 1;
       }

       /* Ack the event */
       ibv_ack_async_event(&amp;async_event);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/ibv_open_device.3.html">ibv_open_device</a></b>(3)

</pre><h4><b>AUTHORS</b></h4><pre>
       Dotan Barak &lt;<a href="mailto:dotanba@gmail.com">dotanba@gmail.com</a>&gt;

libibverbs                                         2006-10-31                             <u><a href="../man3/IBV_GET_ASYNC_EVENT.3.html">IBV_GET_ASYNC_EVENT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>