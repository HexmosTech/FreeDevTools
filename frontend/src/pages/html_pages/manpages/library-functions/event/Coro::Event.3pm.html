<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coro::Event - do events the coro-way, with Event</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcoro-perl">libcoro-perl_6.570-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Coro::Event - do events the coro-way, with Event

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Coro;
        use Coro::Event;

        sub keyboard : Coro {
           my $w = Coro::Event-&gt;io(fd =&gt; \*STDIN, poll =&gt; 'r');
           while() {
              print "cmd&gt; ";
              my $ev = $w-&gt;next; my $cmd = &lt;STDIN&gt;;
              unloop unless $cmd ne "";
              print "data&gt; ";
              my $ev = $w-&gt;next; my $data = &lt;STDIN&gt;;
           }
        }

        loop;

        # wait for input on stdin for one second
        Coro::Event::do_io (fd =&gt; \*STDIN, timeout =&gt; 1) &amp; Event::Watcher::R
           or die "no input received";

        # use a separate thread for event processing, if impossible in main:
        Coro::async { Event::loop };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module enables you to create programs using the powerful Event model (and module), while retaining
       the linear style known from simple or threaded programs.

       This module provides a method and a function for every watcher type (<u>flavour</u>) (see Event). The only
       difference between these and the watcher constructors from Event is that you do not specify a callback
       function - it will be managed by this module.

       Your application should just create all necessary threads and then call "Event::loop".

       Please note that even programs or modules (such as Coro::Handle) that use "traditional"
       event-based/continuation style will run more efficient with this module then when using only Event.

</pre><h4><b>WARNING</b></h4><pre>
       Please note that Event does not support multithreading. That means that you <b>MUST</b> <b>NOT</b> block in an event
       callback. Again: In Event callbacks, you <u>must</u> <u>never</u> <u>ever</u> call a Coro function that blocks the current
       thread.

       While this seems to work superficially, it will eventually cause memory corruption and often results in
       deadlocks.

       Best practise is to always use <b>Coro::unblock_sub</b> for your callbacks.

</pre><h4><b>SEMANTICS</b></h4><pre>
       Whenever Event blocks (e.g. in a call to "one_event", "loop" etc.), this module cede's to all other
       threads with the same or higher priority. When any threads of lower priority are ready, it will not block
       but run one of them and then check for events.

       The effect is that coroutines with the same or higher priority than the blocking coroutine will keep
       Event from checking for events, while coroutines with lower priority are being run, but Event checks for
       new events after every cede. Note that for this to work you actually need to run the event loop in some
       thread.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       $w = Coro::Event-&gt;flavour (args...)
           Create and return a watcher of the given type.

           Examples:

             my $reader = Coro::Event-&gt;io (fd =&gt; $filehandle, poll =&gt; 'r');
             $reader-&gt;next;

       $w-&gt;next
           Wait  for  and  return  the  next event of the event queue of the watcher. The returned event objects
           support two methods only: "hits" and "got", both of which return integers: the  number  this  watcher
           was hit for this event, and the mask of poll events received.

       do_flavour args...
           Create a watcher of the given type and immediately call its next method, returning the event.

           This  is less efficient then calling the constructor once and the next method often, but it does save
           typing sometimes.

       sweep
           Similar to Event::one_event and Event::sweep: The idle task is called once (this has  the  effect  of
           jumping back into the Event loop once to serve new events).

           The  reason  this  function exists is that you sometimes want to serve events while doing other work.
           Calling "Coro::cede" does not work because "cede" implies that the current coroutine is runnable  and
           does not call into the Event dispatcher.

</pre><h4><b>AUTHOR/SUPPORT/CONTACT</b></h4><pre>
          Marc A. Lehmann &lt;<a href="mailto:schmorp@schmorp.de">schmorp@schmorp.de</a>&gt;
          <a href="http://software.schmorp.de/pkg/Coro.html">http://software.schmorp.de/pkg/Coro.html</a>

perl v5.40.1                                       2025-03-21                                         <u><a href="../man3pm/Event.3pm.html">Event</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>