<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>termkey_waitkey - wait for and retrieve the next key event</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtermkey-dev">libtermkey-dev_0.22-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       termkey_waitkey - wait for and retrieve the next key event

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;termkey.h&gt;</b>

       <b>TermKeyResult</b> <b>termkey_waitkey(TermKey</b> <b>*</b><u>tk</u><b>,</b> <b>TermKeyKey</b> <b>*</b><u>key</u><b>);</b>

       Link with <u>-ltermkey</u>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>termkey_waitkey</b>()  attempts  to retrieve a single keypress event from the <b><a href="../man7/termkey.7.html">termkey</a></b>(7) instance buffer, and
       put it in the structure referred to by <u>key</u>. If successful it will return <b>TERMKEY_RES_KEY</b> to indicate that
       the structure now contains a new keypress event. If nothing is in the buffer it will block until  one  is
       available.  If no events are ready and the input stream is now closed, will return <b>TERMKEY_RES_EOF</b>. If no
       filehandle is associated with this instance, <b>TERMKEY_RES_ERROR</b> is returned with <u>errno</u> set to <b>EBADF</b>.

       Before returning, this function canonicalises  the  <u>key</u>  structure  according  to  the  rules  given  for
       <b><a href="../man3/termkey_canonicalise.3.html">termkey_canonicalise</a></b>(3).

       Some  keypresses  generate multiple bytes from the terminal. Because there may be network or other delays
       between the terminal and an application using <b>termkey</b>, <b>termkey_waitkey</b>() will attempt  to  wait  for  the
       remaining bytes to arrive if it detects the start of a multibyte sequence. If no more bytes arrive within
       a  certain  time,  then  the bytes will be reported as they stand, even if this results in interpreting a
       partially-complete Escape sequence as a literal Escape key followed  by  some  normal  letters  or  other
       symbols. The amount of time to wait can be set by <b><a href="../man3/termkey_set_waittime.3.html">termkey_set_waittime</a></b>(3).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>termkey_waitkey</b>() returns one of the following constants:

       <b>TERMKEY_RES_KEY</b>
              A key event as been provided.

       <b>TERMKEY_RES_EOF</b>
              No key events are ready and the terminal has been closed, so no more will arrive.

       <b>TERMKEY_RES_ERROR</b>
              An  IO  error  occurred.  <u>errno</u>  will  be  preserved. If the error is <b>EINTR</b> then this will only be
              returned if <b>TERMKEY_FLAG_EINTR</b> flag is not set; if it is then the IO  operation  will  be  retried
              instead. If this is called with terminal IO stopped, due to <b><a href="../man3/termkey_stop.3.html">termkey_stop</a></b>(3) then <u>errno</u> will be set
              to <b>EINVAL</b>.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following example program prints details of every keypress until the user presses <u>Ctrl-C</u>.

           // we want optarg
           #define _XOPEN_SOURCE 600

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;

           #include "termkey.h"

           int main(int argc, char *argv[])
           {
             TERMKEY_CHECK_VERSION;

             int mouse = 0;
             int mouse_proto = 0;
             TermKeyFormat format = TERMKEY_FORMAT_VIM;

             char buffer[50];
             TermKey *tk;

             int opt;
             while((opt = getopt(argc, argv, "m::p:")) != -1) {
               switch(opt) {
               case 'm':
                 if(optarg)
                   mouse = atoi(optarg);
                 else
                   mouse = 1000;

                 break;

               case 'p':
                 mouse_proto = atoi(optarg);
                 break;

               default:
                 fprintf(stderr, "Usage: %s [-m]\n", argv[0]);
                 return 1;
               }
             }

             tk = termkey_new(0, TERMKEY_FLAG_SPACESYMBOL|TERMKEY_FLAG_CTRLC);

             if(!tk) {
               fprintf(stderr, "Cannot allocate termkey instance\n");
               <a href="../man1/exit.1.html">exit</a>(1);
             }

             if(termkey_get_flags(tk) &amp; TERMKEY_FLAG_UTF8)
               printf("Termkey in UTF-8 mode\n");
             else if(termkey_get_flags(tk) &amp; TERMKEY_FLAG_RAW)
               printf("Termkey in RAW mode\n");

             TermKeyResult ret;
             TermKeyKey key;

             <a href="../manmouse/if.mouse.html">if</a>(mouse) {
               printf("\033[?%dhMouse mode active\n", mouse);
               <a href="../manmouse_proto/if.mouse_proto.html">if</a>(mouse_proto)
                 printf("\033[?%dh", mouse_proto);
             }

             while((ret = termkey_waitkey(tk, &amp;key)) != TERMKEY_RES_EOF) {
               if(ret == TERMKEY_RES_KEY) {
                 termkey_strfkey(tk, buffer, sizeof buffer, &amp;key, format);
                 if(key.type == TERMKEY_TYPE_MOUSE) {
                   int line, col;
                   termkey_interpret_mouse(tk, &amp;key, NULL, NULL, &amp;line, &amp;col);
                   printf("%s at line=%d, col=%d\n", buffer, line, col);
                 }
                 else if(key.type == TERMKEY_TYPE_POSITION) {
                   int line, col;
                   termkey_interpret_position(tk, &amp;key, &amp;line, &amp;col);
                   printf("Cursor position report at line=%d, col=%d\n", line, col);
                 }
                 else if(key.type == TERMKEY_TYPE_MODEREPORT) {
                   int initial, mode, value;
                   termkey_interpret_modereport(tk, &amp;key, &amp;initial, &amp;mode, &amp;value);
                   printf("Mode report %s mode %d = %d\n", initial ? "DEC" : "ANSI", mode, value);
                 }
                 else if(key.type == TERMKEY_TYPE_UNKNOWN_CSI) {
                   long args[16];
                   size_t nargs = 16;
                   unsigned long command;
                   termkey_interpret_csi(tk, &amp;key, args, &amp;nargs, &amp;command);
                   printf("Unrecognised CSI %c %ld;%ld %c%c\n", (char)(command &gt;&gt; 8), args[0], args[1], (char)(command &gt;&gt; 16), (char)command);
                 }
                 else {
                   printf("Key %s\n", buffer);
                 }

                 if(key.type == TERMKEY_TYPE_UNICODE &amp;&amp;
                    key.modifiers &amp; TERMKEY_KEYMOD_CTRL &amp;&amp;
                    (key.code.codepoint == 'C' || key.code.codepoint == 'c'))
                   break;

                 if(key.type == TERMKEY_TYPE_UNICODE &amp;&amp;
                    key.modifiers == 0 &amp;&amp;
                    key.code.codepoint == '?') {
                   // printf("\033[?6n"); // DECDSR 6 == request cursor position
                   printf("\033[?1$p"); // DECRQM == request mode, DEC origin mode
                   fflush(stdout);
                 }
               }
               else if(ret == TERMKEY_RES_ERROR) {
                 if(errno != EINTR) {
                   perror("termkey_waitkey");
                   break;
                 }
                 printf("Interrupted by signal\n");
               }
             }

             <a href="../manmouse/if.mouse.html">if</a>(mouse)
               printf("\033[?%dlMouse mode deactivated\n", mouse);

             termkey_destroy(tk);
           }

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       This function is not available on Windows.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/termkey_getkey.3.html">termkey_getkey</a></b>(3), <b><a href="../man3/termkey_set_waittime.3.html">termkey_set_waittime</a></b>(3), <b><a href="../man7/termkey.7.html">termkey</a></b>(7)

                                                                                              <u><a href="../man3/TERMKEY_WAITKEY.3.html">TERMKEY_WAITKEY</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>