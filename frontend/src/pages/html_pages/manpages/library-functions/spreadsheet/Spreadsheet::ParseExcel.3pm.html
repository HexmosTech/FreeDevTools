<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spreadsheet::ParseExcel - Read information from an Excel file.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libspreadsheet-parseexcel-perl">libspreadsheet-parseexcel-perl_0.6600-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Spreadsheet::ParseExcel - Read information from an Excel file.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Spreadsheet::ParseExcel;

           my $parser   = Spreadsheet::ParseExcel-&gt;new();
           my $workbook = $parser-&gt;parse('Book1.xls');

           if ( !defined $workbook ) {
               die $parser-&gt;error(), ".\n";
           }

           for my $worksheet ( $workbook-&gt;worksheets() ) {

               my ( $row_min, $row_max ) = $worksheet-&gt;row_range();
               my ( $col_min, $col_max ) = $worksheet-&gt;col_range();

               for my $row ( $row_min .. $row_max ) {
                   for my $col ( $col_min .. $col_max ) {

                       my $cell = $worksheet-&gt;get_cell( $row, $col );
                       next unless $cell;

                       print "Row, Col    = ($row, $col)\n";
                       print "Value       = ", $cell-&gt;value(),       "\n";
                       print "Unformatted = ", $cell-&gt;unformatted(), "\n";
                       print "\n";
                   }
               }
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Spreadsheet::ParseExcel module can be used to read information from Excel 95-2003 binary files.

       The module cannot read files in the Excel 2007 Open XML XLSX format. See the Spreadsheet::XLSX module
       instead.

</pre><h4><b>Parser</b></h4><pre>
   <b>new()</b>
       The "new()" method is used to create a new "Spreadsheet::ParseExcel" parser object.

           my $parser = Spreadsheet::ParseExcel-&gt;new();

       It is possible to pass a password to decrypt an encrypted file:

           $parser = Spreadsheet::ParseExcel-&gt;new( Password =&gt; 'secret' );

       Only the default Excel encryption scheme is currently supported. See "Decryption".

       As an advanced feature it is also possible to pass a call-back handler to the parser to control the
       parsing of the spreadsheet.

           $parser = Spreadsheet::ParseExcel-&gt;new(
               CellHandler =&gt; \&amp;cell_handler,
               NotSetCell  =&gt; 1,
           );

       The call-back can be used to ignore certain cells or to reduce memory usage. See the section "Reducing
       the memory usage of Spreadsheet::ParseExcel" for more information.

   <b>parse($filename,</b> <b>$formatter)</b>
       The Parser "parse()" method returns a "Workbook" object.

           my $parser   = Spreadsheet::ParseExcel-&gt;new();
           my $workbook = $parser-&gt;parse('Book1.xls');

       If an error occurs "parse()" returns "undef". In general, programs should contain a test for failed
       parsing as follows:

           my $parser   = Spreadsheet::ParseExcel-&gt;new();
           my $workbook = $parser-&gt;parse('Book1.xls');

           if ( !defined $workbook ) {
               die $parser-&gt;error(), ".\n";
           }

       The $filename parameter is generally the file to be parsed. However, it can also be a filehandle or a
       scalar reference.

       The optional $formatter parameter can be an reference to a "Formatter Class" to format the value of
       cells. This is useful for parsing workbooks with Unicode or Asian characters:

           my $parser    = Spreadsheet::ParseExcel-&gt;new();
           my $formatter = Spreadsheet::ParseExcel::FmtJapan-&gt;new();
           my $workbook  = $parser-&gt;parse( 'Book1.xls', $formatter );

       The Spreadsheet::ParseExcel::FmtJapan formatter also supports Unicode. If you encounter any encoding
       problems with the default formatter try that instead.

   <b>error()</b>
       The Parser "error()" method returns an error string if a "parse()" fails:

           my $parser   = Spreadsheet::ParseExcel-&gt;new();
           my $workbook = $parser-&gt;parse('Book1.xls');

           if ( !defined $workbook ) {
               die $parser-&gt;error(), ".\n";
           }

       If you wish to generate you own error string you can use the "error_code()" method instead (see below).
       The "error()" and "error_code()" values are as follows:

           error()                         error_code()
           =======                         ============
           ''                              0
           'File not found'                1
           'No Excel data found in file'   2
           'File is encrypted'             3

       The "error_code()" method is explained below.

       Spreadsheet::ParseExcel will try to decrypt an encrypted Excel file using the default password or a user
       supplied password passed to "new()", see above. If these fail the module will return the 'File is
       encrypted' error. Only the default Excel encryption scheme is currently supported, see "Decryption".

   <b>error_code()</b>
       The Parser "error_code()" method returns an error code if a "parse()" fails:

           my $parser   = Spreadsheet::ParseExcel-&gt;new();
           my $workbook = $parser-&gt;parse('Book1.xls');

           if ( !defined $workbook ) {
               die "Got error code ", $parser-&gt;error_code, ".\n";
           }

       This can be useful if you wish to employ you own error strings or error handling methods.

</pre><h4><b>Workbook</b></h4><pre>
       A "Spreadsheet::ParseExcel::Workbook" is created via the "Spreadsheet::ParseExcel" "parse()" method:

           my $parser   = Spreadsheet::ParseExcel-&gt;new();
           my $workbook = $parser-&gt;parse('Book1.xls');

       The main methods of the Workbook class are:

           $workbook-&gt;worksheets()
           $workbook-&gt;worksheet()
           $workbook-&gt;worksheet_count()
           $workbook-&gt;get_filename()

       These more commonly used methods of the Workbook class are outlined below. The other, less commonly used,
       methods are documented in Spreadsheet::ParseExcel::Worksheet.

   <b>worksheets()</b>
       Returns an array of "Worksheet" objects. This was most commonly used to iterate over the worksheets in a
       workbook:

           for my $worksheet ( $workbook-&gt;worksheets() ) {
               ...
           }

   <b>worksheet()</b>
       The "worksheet()" method returns a single "Worksheet" object using either its name or index:

           $worksheet = $workbook-&gt;worksheet('Sheet1');
           $worksheet = $workbook-&gt;<a href="../man0/worksheet.0.html">worksheet</a>(0);

       Returns "undef" if the sheet name or index doesn't exist.

   <b>worksheet_count()</b>
       The "worksheet_count()" method returns the number of Worksheet objects in the Workbook.

           my $worksheet_count = $workbook-&gt;worksheet_count();

   <b>get_filename()</b>
       The "get_filename()" method returns the name of the Excel file of "undef" if the data was read from a
       filehandle rather than a file.

           my $filename = $workbook-&gt;get_filename();

   <b>Other</b> <b>Workbook</b> <b>Methods</b>
       For full documentation of the methods available via a Workbook object see
       Spreadsheet::ParseExcel::Workbook.

</pre><h4><b>Worksheet</b></h4><pre>
       The "Spreadsheet::ParseExcel::Worksheet" class encapsulates the properties of an Excel worksheet.

       A Worksheet object is obtained via the "<b>worksheets()</b>" or "<b>worksheet()</b>" methods.

           for my $worksheet ( $workbook-&gt;worksheets() ) {
               ...
           }

           # Or:

           $worksheet = $workbook-&gt;worksheet('Sheet1');
           $worksheet = $workbook-&gt;<a href="../man0/worksheet.0.html">worksheet</a>(0);

       The most commonly used methods of the Worksheet class are:

           $worksheet-&gt;get_cell()
           $worksheet-&gt;row_range()
           $worksheet-&gt;col_range()
           $worksheet-&gt;get_name()

       The Spreadsheet::ParseExcel::Worksheet class exposes a lot of methods but in general very few are
       required unless you are writing an advanced filter.

       The most commonly used methods are detailed below. The others are documented in
       Spreadsheet::ParseExcel::Worksheet.

   <b>get_cell($row,</b> <b>$col)</b>
       Return the "Cell" object at row $row and column $col if it is defined. Otherwise returns undef.

           my $cell = $worksheet-&gt;get_cell($row, $col);

   <b>row_range()</b>
       Returns a two-element list "($min, $max)" containing the minimum and maximum defined rows in the
       worksheet. If there is no row defined $max is smaller than $min.

           my ( $row_min, $row_max ) = $worksheet-&gt;row_range();

   <b>col_range()</b>
       Returns a two-element list "($min, $max)" containing the minimum and maximum of defined columns in the
       worksheet. If there is no column defined $max is smaller than $min.

           my ( $col_min, $col_max ) = $worksheet-&gt;col_range();

   <b>get_name()</b>
       The "get_name()" method returns the name of the worksheet, such as 'Sheet1'.

           my $name = $worksheet-&gt;get_name();

   <b>Other</b> <b>Worksheet</b> <b>Methods</b>
       For other, less commonly used, Worksheet methods see Spreadsheet::ParseExcel::Worksheet.

</pre><h4><b>Cell</b></h4><pre>
       The "Spreadsheet::ParseExcel::Cell" class has the following main methods.

           $cell-&gt;value()
           $cell-&gt;unformatted()

   <b>value()</b>
       The "value()" method returns the formatted value of the cell.

           my $value = $cell-&gt;value();

       Formatted in this sense refers to the numeric format of the cell value. For example a number such as
       40177 might be formatted as 40,117, 40117.000 or even as the date 2009/12/30.

       If the cell doesn't contain a numeric format then the formatted and unformatted cell values are the same,
       see the "unformatted()" method below.

       For a defined $cell the "value()" method will always return a value.

       In the case of a cell with formatting but no numeric or string contents the method will return the empty
       string ''.

   <b>unformatted()</b>
       The "unformatted()" method returns the unformatted value of the cell.

           my $unformatted = $cell-&gt;unformatted();

       Returns the cell value without a numeric format. See the "value()" method above.

   <b>Other</b> <b>Cell</b> <b>Methods</b>
       For other, less commonly used, Worksheet methods see Spreadsheet::ParseExcel::Cell.

</pre><h4><b>Format</b></h4><pre>
       The "Spreadsheet::ParseExcel::Format" class has the following properties:

   <b>Format</b> <b>properties</b>
           $format-&gt;{Font}
           $format-&gt;{AlignH}
           $format-&gt;{AlignV}
           $format-&gt;{Indent}
           $format-&gt;{Wrap}
           $format-&gt;{Shrink}
           $format-&gt;{Rotate}
           $format-&gt;{JustLast}
           $format-&gt;{ReadDir}
           $format-&gt;{BdrStyle}
           $format-&gt;{BdrColor}
           $format-&gt;{BdrDiag}
           $format-&gt;{Fill}
           $format-&gt;{Lock}
           $format-&gt;{Hidden}
           $format-&gt;{Style}

       These properties are generally only of interest to advanced users. Casual users can skip this section.

   <b>$format-&gt;{Font}</b>
       Returns the "Font" object for the Format.

   <b>$format-&gt;{AlignH}</b>
       Returns the horizontal alignment of the format where the value has the following meaning:

           0 =&gt; No alignment
           1 =&gt; Left
           2 =&gt; Center
           3 =&gt; Right
           4 =&gt; Fill
           5 =&gt; Justify
           6 =&gt; Center across
           7 =&gt; Distributed/Equal spaced

   <b>$format-&gt;{AlignV}</b>
       Returns the vertical alignment of the format where the value has the following meaning:

           0 =&gt; Top
           1 =&gt; Center
           2 =&gt; Bottom
           3 =&gt; Justify
           4 =&gt; Distributed/Equal spaced

   <b>$format-&gt;{Indent}</b>
       Returns the indent level of the "Left" horizontal alignment.

   <b>$format-&gt;{Wrap}</b>
       Returns true if textwrap is on.

   <b>$format-&gt;{Shrink}</b>
       Returns true if "Shrink to fit" is set for the format.

   <b>$format-&gt;{Rotate}</b>
       Returns the text rotation. In Excel97+, it returns the angle in degrees of the text rotation.

       In Excel95 or earlier it returns a value as follows:

           0 =&gt; No rotation
           1 =&gt; Top down
           2 =&gt; 90 degrees anti-clockwise,
           3 =&gt; 90 clockwise

   <b>$format-&gt;{JustLast}</b>
       Return true if the "justify last" property is set for the format.

   <b>$format-&gt;{ReadDir}</b>
       Returns the direction that the text is read from.

   <b>$format-&gt;{BdrStyle}</b>
       Returns an array ref of border styles as follows:

           [ $left, $right, $top, $bottom ]

   <b>$format-&gt;{BdrColor}</b>
       Returns an array ref of border color indexes as follows:

           [ $left, $right, $top, $bottom ]

   <b>$format-&gt;{BdrDiag}</b>
       Returns an array ref of diagonal border kind, style and color index as follows:

           [$kind, $style, $color ]

       Where kind is:

           0 =&gt; None
           1 =&gt; Right-Down
           2 =&gt; Right-Up
           3 =&gt; Both

   <b>$format-&gt;{Fill}</b>
       Returns an array ref of fill pattern and color indexes as follows:

           [ $pattern, $front_color, $back_color ]

   <b>$format-&gt;{Lock}</b>
       Returns true if the cell is locked.

   <b>$format-&gt;{Hidden}</b>
       Returns true if the cell is Hidden.

   <b>$format-&gt;{Style}</b>
       Returns true if the format is a Style format.

</pre><h4><b>Font</b></h4><pre>
       <u>Spreadsheet::ParseExcel::Font</u>

       Format class has these properties:

</pre><h4><b>Font</b> <b>Properties</b></h4><pre>
           $font-&gt;{Name}
           $font-&gt;{Bold}
           $font-&gt;{Italic}
           $font-&gt;{Height}
           $font-&gt;{Underline}
           $font-&gt;{UnderlineStyle}
           $font-&gt;{Color}
           $font-&gt;{Strikeout}
           $font-&gt;{Super}

   <b>$font-&gt;{Name}</b>
       Returns the name of the font, for example 'Arial'.

   <b>$font-&gt;{Bold}</b>
       Returns true if the font is bold.

   <b>$font-&gt;{Italic}</b>
       Returns true if the font is italic.

   <b>$font-&gt;{Height}</b>
       Returns the size (height) of the font.

   <b>$font-&gt;{Underline}</b>
       Returns true if the font in underlined.

   <b>$font-&gt;{UnderlineStyle}</b>
       Returns the style of an underlined font where the value has the following meaning:

            0 =&gt; None
            1 =&gt; Single
            2 =&gt; Double
           33 =&gt; Single accounting
           34 =&gt; Double accounting

   <b>$font-&gt;{Color}</b>
       Returns the color index for the font. The mapping to an RGB color is defined by each workbook.

       The index can be converted to a RGB string using the "$workbook-"<b>ColorIdxToRGB()</b>&gt; Parser method.

       (Older versions of "Spreadsheet::ParseExcel" provided the "ColorIdxToRGB" class method, which is
       deprecated.)

   <b>$font-&gt;{Strikeout}</b>
       Returns true if the font has the strikeout property set.

   <b>$font-&gt;{Super}</b>
       Returns one of the following values if the superscript or subscript property of the font is set:

           0 =&gt; None
           1 =&gt; Superscript
           2 =&gt; Subscript

</pre><h4><b>Formatter</b> <b>Class</b></h4><pre>
       Formatters can be passed to the "parse()" method to deal with Unicode or Asian formatting.

       Spreadsheet::ParseExcel includes 2 formatter classes. "FmtDefault" and "FmtJapanese". It is also possible
       to create a user defined formatting class.

       The formatter class "Spreadsheet::ParseExcel::Fmt*" should provide the following functions:

   <b>ChkType($self,</b> <b>$is_numeric,</b> <b>$format_index)</b>
       Method to check the type of data in the cell. Should return "Date", "Numeric" or "Text". It is passed the
       following parameters:

       $self
           A scalar reference to the Formatter object.

       $is_numeric
           If true, the value seems to be number.

       $format_index
           The index number for the cell Format object.

   <b>TextFmt($self,</b> <b>$string_data,</b> <b>$string_encoding)</b>
       Converts the string data in the cell into the correct encoding.  It is passed the following parameters:

       $self
           A scalar reference to the Formatter object.

       $string_data
           The original string/text data.

       $string_encoding
           The character encoding of original string/text.

   <b>ValFmt($self,</b> <b>$cell,</b> <b>$workbook)</b>
       Convert  the  original  unformatted  cell value into the appropriate formatted value. For instance turn a
       number into a formatted date.  It is passed the following parameters:

       $self
           A scalar reference to the Formatter object.

       $cell
           A scalar reference to the Cell object.

       $workbook
           A scalar reference to the Workbook object.

   <b>FmtString($self,</b> <b>$cell,</b> <b>$workbook)</b>
       Get the format string for the Cell.  It is passed the following parameters:

       $self
           A scalar reference to the Formatter object.

       $cell
           A scalar reference to the Cell object.

       $workbook
           A scalar reference to the Workbook object.

</pre><h4><b>Reducing</b> <b>the</b> <b>memory</b> <b>usage</b> <b>of</b> <b>Spreadsheet::ParseExcel</b></h4><pre>
       In some cases a "Spreadsheet::ParseExcel" application may consume a lot of memory when processing a large
       Excel file and, as a result, may fail to complete. The following explains why this can occur and  how  to
       resolve it.

       "Spreadsheet::ParseExcel" processes an Excel file in two stages. In the first stage it extracts the Excel
       binary  stream  from  the OLE container file using "OLE::Storage_Lite". In the second stage it parses the
       binary stream to read workbook, worksheet and cell data which it then stores in memory. The  majority  of
       the memory usage is required for storing cell data.

       The  reason  for  this  is  that as the Excel file is parsed and each cell is encountered a cell handling
       function creates a relatively large nested cell object that contains the cell value and all of  the  data
       that  relates to the cell formatting. For large files (a 10MB Excel file on a 256MB system) this overhead
       can cause the system to grind to a halt.

       However, in a lot of cases when an Excel file is being processed the only information  that  is  required
       are  the  cell  values.  In these cases it is possible to avoid most of the memory overhead by specifying
       your own cell handling function and by telling Spreadsheet::ParseExcel not to store the parsed cell data.
       This is achieved by passing a cell handler function to "new()" when creating the parse object. Here is an
       example.

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Spreadsheet::ParseExcel;

           my $parser = Spreadsheet::ParseExcel-&gt;new(
               CellHandler =&gt; \&amp;cell_handler,
               NotSetCell  =&gt; 1
           );

           my $workbook = $parser-&gt;parse('file.xls');

           sub cell_handler {

               my $workbook    = $_[0];
               my $sheet_index = $_[1];
               my $row         = $_[2];
               my $col         = $_[3];
               my $cell        = $_[4];

               # Do something useful with the formatted cell value
               print $cell-&gt;value(), "\n";

           }

       The user specified cell handler is passed as a  code  reference  to  "new()"  along  with  the  parameter
       "NotSetCell"  which  tells  Spreadsheet::ParseExcel not to store the parsed cell. Note, you don't have to
       iterate over the rows and columns, this happens automatically as part of the parsing.

       The  cell  handler  is  passed  5  arguments.   The   first,   $workbook,   is   a   reference   to   the
       "Spreadsheet::ParseExcel::Workbook" object that represent the parsed workbook. This can be used to access
       any  of  the  "Spreadsheet::ParseExcel::Workbook" methods, see "Workbook". The second $sheet_index is the
       zero-based index of the worksheet being parsed. The third and fourth, $row and $col, are  the  zero-based
       row    and    column    number   of   the   cell.   The   fifth,   $cell,   is   a   reference   to   the
       "Spreadsheet::ParseExcel::Cell" object. This is used to extract the data from the cell.  See  "Cell"  for
       more information.

       This  technique  can  be  useful if you are writing an Excel to database filter since you can put your DB
       calls in the cell handler.

       If you don't want all of the data in the spreadsheet you can add some control logic to the cell  handler.
       For  example we can extend the previous example so that it only prints the first 10 rows of the first two
       worksheets in the parsed workbook by adding some "if()" statements to the cell handler:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Spreadsheet::ParseExcel;

           my $parser = Spreadsheet::ParseExcel-&gt;new(
               CellHandler =&gt; \&amp;cell_handler,
               NotSetCell  =&gt; 1
           );

           my $workbook = $parser-&gt;parse('file.xls');

           sub cell_handler {

               my $workbook    = $_[0];
               my $sheet_index = $_[1];
               my $row         = $_[2];
               my $col         = $_[3];
               my $cell        = $_[4];

               # Skip some worksheets and rows (inefficiently).
               return if $sheet_index &gt;= 3;
               return if $row &gt;= 10;

               # Do something with the formatted cell value
               print $cell-&gt;value(), "\n";

           }

       However, this still processes the entire workbook. If you wish to save some  additional  processing  time
       you  can  abort  the  parsing after you have read the data that you want, using the workbook "ParseAbort"
       method:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Spreadsheet::ParseExcel;

           my $parser = Spreadsheet::ParseExcel-&gt;new(
               CellHandler =&gt; \&amp;cell_handler,
               NotSetCell  =&gt; 1
           );

           my $workbook = $parser-&gt;parse('file.xls');

           sub cell_handler {

               my $workbook    = $_[0];
               my $sheet_index = $_[1];
               my $row         = $_[2];
               my $col         = $_[3];
               my $cell        = $_[4];

               # Skip some worksheets and rows (more efficiently).
               if ( $sheet_index &gt;= 1 and $row &gt;= 10 ) {
                   $workbook-&gt;<a href="../man1/ParseAbort.1.html">ParseAbort</a>(1);
                   return;
               }

               # Do something with the formatted cell value
               print $cell-&gt;value(), "\n";

           }

</pre><h4><b>Decryption</b></h4><pre>
       If a workbook is "protected" then Excel will encrypt the file whether a password is supplied or  not.  As
       of  version  0.59  Spreadsheet::ParseExcel  supports  decrypting  Excel workbooks using a default or user
       supplied password. However, only the following encryption scheme is supported:

           Office 97/2000 Compatible encryption

       The following encryption methods are not supported:

           Weak Encryption (XOR)
           RC4, Microsoft Base Cryptographic Provider v1.0
           RC4, Microsoft Base DSS and Diffie-Hellman Cryptographic Provider
           RC4, Microsoft DH SChannel Cryptographic Provider
           RC4, Microsoft Enhanced Cryptographic Provider v1.0
           RC4, Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider
           RC4, Microsoft Enhanced RSA and AES Cryptographic Provider
           RC4, Microsoft RSA SChannel Cryptographic Provider
           RC4, Microsoft Strong Cryptographic Provider

       See      the      following       for       more       information       on       Excel       encryption:
       &lt;<a href="http://office.microsoft.com/en-us/office-2003-resource-kit/important-aspects-of-password-and-encryption-protection-HA001140311.aspx">http://office.microsoft.com/en-us/office-2003-resource-kit/important-aspects-of-password-and-encryption-protection-HA001140311.aspx</a>&gt;.

</pre><h4><b>KNOWN</b> <b>PROBLEMS</b></h4><pre>
       •   This module cannot read the values of formulas from files created with Spreadsheet::WriteExcel unless
           the  user  specified  the values when creating the file (which is generally not the case). The reason
           for this is that Spreadsheet::WriteExcel writes the formula but not the formula result since it isn't
           in a position to calculate arbitrary Excel formulas without access to Excel's formula engine.

       •   If Excel has date fields where the specified format is equal to the system-default for the short-date
           locale, Excel does not store the  format,  but  defaults  to  an  internal  format  which  is  system
           dependent. In these cases ParseExcel uses the date format 'yyyy-mm-dd'.

</pre><h4><b>REPORTING</b> <b>A</b> <b>BUG</b></h4><pre>
       Please report bugs on GitHub with a complete, working, sample application and a test xls file.

       &lt;https://github.com/jmcnamara/spreadsheet-parseexcel/issues&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   xls2csv by Ken Prows &lt;<a href="http://search.cpan.org/~ken/xls2csv-1.06/script/xls2csv">http://search.cpan.org/~ken/xls2csv-1.06/script/xls2csv</a>&gt;.

       •   xls2csv and xlscat by H.Merijn Brand (these utilities are part of Spreadsheet::Read, see below).

       •   excel2txt  by  Ken  Youens-Clark,  &lt;<a href="http://search.cpan.org/~kclark/excel2txt/excel2txt">http://search.cpan.org/~kclark/excel2txt/excel2txt</a>&gt;.  This  is an
           excellent example of  an  Excel  filter  using  Spreadsheet::ParseExcel.  It  can  produce  CSV,  Tab
           delimited, Html, XML and Yaml.

       •   XLSperl  by Jon Allen &lt;<a href="http://search.cpan.org/~jonallen/XLSperl/bin/XLSperl">http://search.cpan.org/~jonallen/XLSperl/bin/XLSperl</a>&gt;. This application allows
           you to use Perl "one-liners" with Microsoft Excel files.

       •   Spreadsheet::XLSX &lt;<a href="http://search.cpan.org/~dmow/Spreadsheet-XLSX/lib/Spreadsheet/XLSX.pm">http://search.cpan.org/~dmow/Spreadsheet-XLSX/lib/Spreadsheet/XLSX.pm</a>&gt;  by  Dmitry
           Ovsyanko.  A  module  with a similar interface to Spreadsheet::ParseExcel for parsing Excel 2007 XLSX
           OpenXML files.

       •   Spreadsheet::Read &lt;<a href="http://search.cpan.org/~hmbrand/Spreadsheet-Read/Read.pm">http://search.cpan.org/~hmbrand/Spreadsheet-Read/Read.pm</a>&gt;  by  H.Merijn  Brand.  A
           single interface for reading several different spreadsheet formats.

       •   Spreadsheet::WriteExcel
           &lt;<a href="http://search.cpan.org/~jmcnamara/Spreadsheet-WriteExcel/lib/Spreadsheet/WriteExcel.pm">http://search.cpan.org/~jmcnamara/Spreadsheet-WriteExcel/lib/Spreadsheet/WriteExcel.pm</a>&gt;.    A   perl
           module for creating new Excel files.

       •   Spreadsheet::ParseExcel::SaveParser
           &lt;<a href="http://search.cpan.org/~jmcnamara/Spreadsheet-ParseExcel/lib/Spreadsheet/ParseExcel/SaveParser.pm">http://search.cpan.org/~jmcnamara/Spreadsheet-ParseExcel/lib/Spreadsheet/ParseExcel/SaveParser.pm</a>&gt;.
           This is a combination of Spreadsheet::ParseExcel and Spreadsheet::WriteExcel and  it  allows  you  to
           "rewrite"         an         Excel        file.        See        the        following        example
           &lt;<a href="http://search.cpan.org/~jmcnamara/Spreadsheet-WriteExcel/lib/Spreadsheet/WriteExcel.pm">http://search.cpan.org/~jmcnamara/Spreadsheet-WriteExcel/lib/Spreadsheet/WriteExcel.pm</a>#MODIFYING_AND_REWRITING_EXCEL_FILES&gt;.
           It is part of the Spreadsheet::ParseExcel distro.

       •   Text::CSV_XS &lt;<a href="http://search.cpan.org/~hmbrand/Text-CSV_XS/CSV_XS.pm">http://search.cpan.org/~hmbrand/Text-CSV_XS/CSV_XS.pm</a>&gt; by H.Merijn Brand.  A  fast  and
           rigorous  module  for reading and writing CSV data. Don't consider rolling your own CSV handling, use
           this module instead.

</pre><h4><b>DONATIONS</b></h4><pre>
       If  you'd  care  to  donate  to  the  Spreadsheet::ParseExcel  project,  you  can  do  so   via   PayPal:
       &lt;<a href="http://tinyurl.com/7ayes">http://tinyurl.com/7ayes</a>&gt;

</pre><h4><b>TODO</b></h4><pre>
       •   The  current maintenance work is directed towards making the documentation more useful, improving and
           simplifying the API, and improving the maintainability of the code base. After that new features will
           be added.

       •   Fix open bugs and documentation for SaveParser.

       •   Add Formula support, Hyperlink support, Named Range support.

       •   Improve Spreadsheet::ParseExcel::SaveParser compatibility with Spreadsheet::WriteExcel.

       •   Improve Unicode and other encoding support. This will probably require  dropping  support  for  perls
           prior to 5.8+.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       From Kawai Takanori:

       First  of  all,  I  would  like  to  acknowledge  the  following  valuable  programs  and modules: XHTML,
       OLE::Storage and Spreadsheet::WriteExcel.

       In no particular order: Yamaji Haruna, Simamoto Takesi, Noguchi Harumi, Ikezawa Kazuhiro, Suwazono Shugo,
       Hirofumi Morisada, Michael Edwards, Kim Namusk, Slaven Rezic, Grant Stevens, H.Merijn Brand and many many
       people + Kawai Mikako.

       Alexey Mazurin added the decryption facility.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       Because this software is licensed free of charge, there is no warranty for the software,  to  the  extent
       permitted  by  applicable law. Except when otherwise stated in writing the copyright holders and/or other
       parties provide the software "as  is"  without  warranty  of  any  kind,  either  expressed  or  implied,
       including,  but  not  limited  to, the implied warranties of merchantability and fitness for a particular
       purpose. The entire risk as to the quality and performance of  the  software  is  with  you.  Should  the
       software prove defective, you assume the cost of all necessary servicing, repair, or correction.

       In  no  event unless required by applicable law or agreed to in writing will any copyright holder, or any
       other party who may modify and/or redistribute the software as permitted by the above licence, be  liable
       to  you  for damages, including any general, special, incidental, or consequential damages arising out of
       the use or inability to use the software (including but not  limited  to  loss  of  data  or  data  being
       rendered  inaccurate  or losses sustained by you or third parties or a failure of the software to operate
       with any other software), even if such holder or other party has been advised of the possibility of  such
       damages.

</pre><h4><b>LICENSE</b></h4><pre>
       Either    the   Perl   Artistic   Licence   &lt;<a href="http://dev.perl.org/licenses/artistic.html">http://dev.perl.org/licenses/artistic.html</a>&gt;   or   the   GPL
       &lt;<a href="http://www.opensource.org/licenses/gpl-license.php">http://www.opensource.org/licenses/gpl-license.php</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Current maintainer 0.60+: Douglas Wilson <a href="mailto:dougw@cpan.org">dougw@cpan.org</a>

       Maintainer 0.40-0.59: John McNamara <a href="mailto:jmcnamara@cpan.org">jmcnamara@cpan.org</a>

       Maintainer 0.27-0.33: Gabor Szabo <a href="mailto:szabgab@cpan.org">szabgab@cpan.org</a>

       Original author: Kawai Takanori (Hippo2000) <a href="mailto:kwitknr@cpan.org">kwitknr@cpan.org</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2014 Douglas Wilson

       Copyright (c) 2009-2013 John McNamara

       Copyright (c) 2006-2008 Gabor Szabo

       Copyright (c) 2000-2006 Kawai Takanori

       All rights reserved. This is free software. You may distribute under the terms of either the GNU  General
       Public License or the Artistic License.

perl v5.36.0                                       2024-01-01                       <u>Spreadsheet::<a href="../man3pm/ParseExcel.3pm.html">ParseExcel</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>