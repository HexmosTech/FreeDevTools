<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel::Writer::XLSX - Create a new file in the Excel 2007+ XLSX format.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libexcel-writer-xlsx-perl">libexcel-writer-xlsx-perl_1.11-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Excel::Writer::XLSX - Create a new file in the Excel 2007+ XLSX format.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       To write a string, a formatted string, a number and a formula to the first worksheet in an Excel workbook
       called perl.xlsx:

           use Excel::Writer::XLSX;

           # Create a new Excel workbook
           my $workbook = Excel::Writer::XLSX-&gt;new( 'perl.xlsx' );

           # Add a worksheet
           $worksheet = $workbook-&gt;add_worksheet();

           #  Add and define a format
           $format = $workbook-&gt;add_format();
           $format-&gt;set_bold();
           $format-&gt;set_color( 'red' );
           $format-&gt;set_align( 'center' );

           # Write a formatted and unformatted string, row and column notation.
           $col = $row = 0;
           $worksheet-&gt;write( $row, $col, 'Hi Excel!', $format );
           $worksheet-&gt;write( 1, $col, 'Hi Excel!' );

           # Write a number and a formula using A1 notation
           $worksheet-&gt;write( 'A3', 1.2345 );
           $worksheet-&gt;write( 'A4', '=SIN(PI()/4)' );

           $workbook-&gt;close();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "Excel::Writer::XLSX" module can be used to create an Excel file in the 2007+ XLSX format.

       Multiple worksheets can be added to a workbook and formatting can be applied to cells. Text, numbers, and
       formulas can be written to the cells.

</pre><h4><b>Excel::Writer::XLSX</b> <b>and</b> <b>Spreadsheet::WriteExcel</b></h4><pre>
       "Excel::Writer::XLSX" uses the same interface as the Spreadsheet::WriteExcel module which produces an
       Excel file in binary XLS format.

</pre><h4><b>QUICK</b> <b>START</b></h4><pre>
       Excel::Writer::XLSX tries to provide an interface to as many of Excel's features as possible. As a result
       there is a lot of documentation to accompany the interface and it can be difficult at first glance to see
       what it important and what is not. So for those of you who prefer to assemble Ikea furniture first and
       then read the instructions, here are four easy steps:

       1. Create a new Excel <u>workbook</u> (i.e. file) using "new()".

       2. Add a worksheet to the new workbook using "add_worksheet()".

       3. Write to the worksheet using "write()".

       4. "close()" the file.

       Like this:

           use Excel::Writer::XLSX;                                   # Step 0

           my $workbook = Excel::Writer::XLSX-&gt;new( 'perl.xlsx' );    # Step 1
           $worksheet = $workbook-&gt;add_worksheet();                   # Step 2
           $worksheet-&gt;write( 'A1', 'Hi Excel!' );                    # Step 3

           $workbook-&gt;close();                                        # Step 4

       This will create an Excel file called "perl.xlsx" with a single worksheet and the text 'Hi Excel!' in the
       relevant cell. And that's it. Okay, so there is actually a zeroth step as well, but "use module" goes
       without saying. There are many examples that come with the distribution and which you can use to get you
       started. See "EXAMPLES".

       Those of you who read the instructions first and assemble the furniture afterwards will know how to
       proceed. ;-)

</pre><h4><b>WORKBOOK</b> <b>METHODS</b></h4><pre>
       The Excel::Writer::XLSX module provides an object oriented interface to a new Excel workbook. The
       following methods are available through a new workbook.

           new()
           add_worksheet()
           add_format()
           add_chart()
           add_shape()
           add_vba_project()
           set_vba_name()
           close()
           set_properties()
           set_custom_property()
           define_name()
           set_tempdir()
           set_custom_color()
           sheets()
           get_worksheet_by_name()
           set_1904()
           set_optimization()
           set_calc_mode()
           get_default_url_format()
           read_only_recommended()

       If you are unfamiliar with object oriented interfaces or the way that they are implemented in Perl have a
       look at "perlobj" and "perltoot" in the main Perl documentation.

   <b>new()</b>
       A new Excel workbook is created using the "new()" constructor which accepts either a filename or a
       filehandle as a parameter. The following example creates a new Excel file based on a filename:

           my $workbook  = Excel::Writer::XLSX-&gt;new( 'filename.xlsx' );
           my $worksheet = $workbook-&gt;add_worksheet();
           $worksheet-&gt;write( 0, 0, 'Hi Excel!' );
           $workbook-&gt;close();

       Here are some other examples of using "new()" with filenames:

           my $workbook1 = Excel::Writer::XLSX-&gt;new( $filename );
           my $workbook2 = Excel::Writer::XLSX-&gt;new( '/tmp/filename.xlsx' );
           my $workbook3 = Excel::Writer::XLSX-&gt;new( "c:\\tmp\\filename.xlsx" );
           my $workbook4 = Excel::Writer::XLSX-&gt;new( 'c:\tmp\filename.xlsx' );

       The last two examples demonstrates how to create a file on DOS or Windows where it is necessary to either
       escape the directory separator "\" or to use single quotes to ensure that it isn't interpolated. For more
       information see "perlfaq5: Why can't I use "C:\temp\foo" in DOS paths?".

       It is recommended that the filename uses the extension ".xlsx" rather than ".xls" since the latter causes
       an Excel warning when used with the XLSX format.

       The "new()" constructor returns a Excel::Writer::XLSX object that you can use to add worksheets and store
       data. It should be noted that although "my" is not specifically required it defines the scope of the new
       workbook variable and, in the majority of cases, ensures that the workbook is closed properly without
       explicitly calling the "close()" method.

       If the file cannot be created, due to file permissions or some other reason,  "new" will return "undef".
       Therefore, it is good practice to check the return value of "new" before proceeding. As usual the Perl
       variable $! will be set if there is a file creation error. You will also see one of the warning messages
       detailed in "DIAGNOSTICS":

           my $workbook = Excel::Writer::XLSX-&gt;new( 'protected.xlsx' );
           die "Problems creating new Excel file: $!" unless defined $workbook;

       You can also pass a valid filehandle to the "new()" constructor. For example in a CGI program you could
       do something like this:

           binmode( STDOUT );
           my $workbook = Excel::Writer::XLSX-&gt;new( \*STDOUT );

       The requirement for "binmode()" is explained below.

       See also, the "cgi.pl" program in the "examples" directory of the distro.

       In "mod_perl" programs where you will have to do something like the following:

           # mod_perl 1
           ...
           tie *XLSX, 'Apache';
           binmode( XLSX );
           my $workbook = Excel::Writer::XLSX-&gt;new( \*XLSX );
           ...

           # mod_perl 2
           ...
           tie *XLSX =&gt; $r;    # Tie to the Apache::RequestRec object
           binmode( *XLSX );
           my $workbook = Excel::Writer::XLSX-&gt;new( \*XLSX );
           ...

       See also, the "mod_perl1.pl" and "mod_perl2.pl" programs in the "examples" directory of the distro.

       Filehandles can also be useful if you want to stream an Excel file over a socket or if you want to store
       an Excel file in a scalar.

       For example here is a way to write an Excel file to a scalar:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Excel::Writer::XLSX;

           open my $fh, '&gt;', \my $str or die "Failed to open filehandle: $!";

           my $workbook  = Excel::Writer::XLSX-&gt;new( $fh );
           my $worksheet = $workbook-&gt;add_worksheet();

           $worksheet-&gt;write( 0, 0, 'Hi Excel!' );

           $workbook-&gt;close();

           # The Excel file in now in $str. Remember to binmode() the output
           # filehandle before printing it.
           binmode STDOUT;
           print $str;

       See also the "write_to_scalar.pl" and "filehandle.pl" programs in the "examples" directory of the distro.

       <b>Note</b> <b>about</b> <b>the</b> <b>requirement</b> <b>for</b> "binmode()". An Excel file is comprised of binary data. Therefore, if you
       are using a filehandle you should ensure that you "binmode()" it prior to passing it to "new()".You
       should do this regardless of whether you are on a Windows platform or not.

       You don't have to worry about "binmode()" if you are using filenames instead of filehandles.
       Excel::Writer::XLSX performs the "binmode()" internally when it converts the filename to a filehandle.
       For more information about "binmode()" see "perlfunc" and "perlopentut" in the main Perl documentation.

   <b>add_worksheet(</b> <b>$sheetname</b> <b>)</b>
       At least one worksheet should be added to a new workbook. A worksheet is used to write data into cells:

           $worksheet1 = $workbook-&gt;add_worksheet();               # Sheet1
           $worksheet2 = $workbook-&gt;add_worksheet( 'Foglio2' );    # Foglio2
           $worksheet3 = $workbook-&gt;add_worksheet( 'Data' );       # Data
           $worksheet4 = $workbook-&gt;add_worksheet();               # Sheet4

       If $sheetname is not specified the default Excel convention will be followed, i.e. Sheet1, Sheet2, etc.

       The worksheet name must be a valid Excel worksheet name, i.e:

       •   It must be less than 32 characters.

       •   It cannot contain any of the following characters: "[ ] : * ? / \"

       •   It cannot start or end with an apostrophe.

       •   It cannot be the same as an existing worksheet name (or a case insensitive variant).

       Note,  the  sheetname  should  not  be "History" (case insensitive) which is reserved in English language
       versions of Excel. Non-English versions may have restrictions on the equivalent word.

       See            the            Excel            worksheet            naming            rules            at
       &lt;https://support.office.com/en-ie/article/rename-a-worksheet-3f1f7148-ee83-404d-8ef0-9ff99fbad1f9&gt;.

   <b>add_format(</b> <b>%properties</b> <b>)</b>
       The  "add_format()" method can be used to create new Format objects which are used to apply formatting to
       a cell. You can either define the properties at creation time via a hash of property values or later  via
       method calls.

           $format1 = $workbook-&gt;add_format( %props );    # Set properties at creation
           $format2 = $workbook-&gt;add_format();            # Set properties later

       See the "CELL FORMATTING" section for more details about Format properties and how to set them.

   <b>add_chart(</b> <b>%properties</b> <b>)</b>
       This  method  is  use  to  create  a  new  chart  either as a standalone worksheet (the default) or as an
       embeddable object that can be inserted into a worksheet via the "insert_chart()" Worksheet method.

           my $chart = $workbook-&gt;add_chart( type =&gt; 'column' );

       The properties that can be set are:

           type     (required)
           subtype  (optional)
           name     (optional)
           embedded (optional)

       •   "type"

           This is a required parameter. It defines the type of chart that will be created.

               my $chart = $workbook-&gt;add_chart( type =&gt; 'line' );

           The available types are:

               area
               bar
               column
               line
               pie
               doughnut
               scatter
               stock

       •   "subtype"

           Used to define a chart subtype where available.

               my $chart = $workbook-&gt;add_chart( type =&gt; 'bar', subtype =&gt; 'stacked' );

           See the Excel::Writer::XLSX::Chart documentation for a list of available chart subtypes.

       •   "name"

           Set the name for the chart sheet. The name property is optional and if it isn't supplied will default
           to "Chart1 .. n". The name must be a valid Excel  worksheet  name.  See  "add_worksheet()"  for  more
           details on valid sheet names. The "name" property can be omitted for embedded charts.

               my $chart = $workbook-&gt;add_chart( type =&gt; 'line', name =&gt; 'Results Chart' );

       •   "embedded"

           Specifies  that  the  Chart object will be inserted in a worksheet via the "insert_chart()" Worksheet
           method. It is an error to try insert a Chart that doesn't have this flag set.

               my $chart = $workbook-&gt;add_chart( type =&gt; 'line', embedded =&gt; 1 );

               # Configure the chart.
               ...

               # Insert the chart into the a worksheet.
               $worksheet-&gt;insert_chart( 'E2', $chart );

       See Excel::Writer::XLSX::Chart for details on how to configure the chart object once it is  created.  See
       also the "chart_*.pl" programs in the examples directory of the distro.

   <b>add_shape(</b> <b>%properties</b> <b>)</b>
       The "add_shape()" method can be used to create new shapes that may be inserted into a worksheet.

       You  can  either define the properties at creation time via a hash of property values or later via method
       calls.

           # Set properties at creation.
           $plus = $workbook-&gt;add_shape(
               type   =&gt; 'plus',
               id     =&gt; 3,
               width  =&gt; $pw,
               height =&gt; $ph
           );

           # Default rectangle shape. Set properties later.
           $rect =  $workbook-&gt;add_shape();

       See Excel::Writer::XLSX::Shape for details on how to configure the shape object once it is created.

       See also the "shape*.pl" programs in the examples directory of the distro.

   <b>add_vba_project(</b> <b>'vbaProject.bin'</b> <b>)</b>
       The "add_vba_project()" method can be used to add macros or  functions  to  an  Excel::Writer::XLSX  file
       using a binary VBA project file that has been extracted from an existing Excel "xlsm" file.

           my $workbook  = Excel::Writer::XLSX-&gt;new( 'file.xlsm' );

           $workbook-&gt;add_vba_project( './vbaProject.bin' );

       The  supplied  "extract_vba"  utility  can  be used to extract the required "vbaProject.bin" file from an
       existing Excel file:

           $ extract_vba file.xlsm
           Extracted 'vbaProject.bin' successfully

       Macros can be tied to buttons using the worksheet "insert_button()" method (see the  "WORKSHEET  METHODS"
       section for details):

           $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'my_macro' } );

       Note,  Excel  uses  the  file  extension  "xlsm"  instead  of "xlsx" for files that contain macros. It is
       advisable to follow the same convention.

       See also the "macros.pl" example file and the "WORKING WITH VBA MACROS".

   <b>set_vba_name()</b>
       The "set_vba_name()" method can be used to set the VBA codename  for  the  workbook.  This  is  sometimes
       required  when  a "vbaProject macro" included via "add_vba_project()" refers to the workbook. The default
       Excel VBA name of "ThisWorkbook" is used if a user defined name isn't specified. See also  "WORKING  WITH
       VBA MACROS".

   <b>close()</b>
       In  general  your  Excel  file  will  be closed automatically when your program ends or when the Workbook
       object goes out of scope. However it is recommended to explicitly call the  "close()"  method  close  the
       Excel file and avoid the potential issues outlined below. The "close()" method is called like this:

           $workbook-&gt;close();

       The  return  value  of  "close()" is the same as that returned by perl when it closes the file created by
       "new()". This allows you to handle error conditions in the usual way:

           $workbook-&gt;close() or die "Error closing file: $!";

       An explicit "close()" is required if the file must be closed prior to performing some external action  on
       it such as copying it, reading its size or attaching it to an email.

       In  addition,  "close()"  may  be  required  to  prevent  perl's  garbage collector from disposing of the
       Workbook, Worksheet and Format objects in the wrong order. Situations where this can occur are:

       •   If "my()" was not used to declare the scope of a workbook variable created using "new()".

       •   If the "new()", "add_worksheet()" or "add_format()" methods are called in subroutines.

       The reason for this  is  that  Excel::Writer::XLSX  relies  on  Perl's  "DESTROY"  mechanism  to  trigger
       destructor methods in a specific sequence. This may not happen in cases where the Workbook, Worksheet and
       Format variables are not lexically scoped or where they have different lexical scopes.

       To  avoid  these  issues it is recommended that you always close the Excel::Writer::XLSX filehandle using
       "close()".

   <b>set_size(</b> <b>$width,</b> <b>$height</b> <b>)</b>
       The "set_size()" method can be used to set the size of a workbook window.

           $workbook-&gt;set_size(1200, 800);

       The Excel window size was used in Excel 2007 to define the width and height of a workbook  window  within
       the Multiple Document Interface (MDI). In later versions of Excel for Windows this interface was dropped.
       This  method  is  currently only useful when setting the window size in Excel for Mac 2011. The units are
       pixels and the default size is 1073 x 644.

       Note, this doesn't equate exactly to the Excel for Mac pixel size since it is based on the original Excel
       2007 for Windows sizing.

   <b>set_tab_ratio(</b> <b>$tab_ratio</b> <b>)</b>
       The "set_tab_ratio()" method can be used to set the ratio  between  worksheet  tabs  and  the  horizontal
       slider  at  the  bottom  of a workbook. This can be increased to give more room to the tabs or reduced to
       increase the size of the horizontal slider:

           $workbook-&gt;<a href="../man75/set_tab_ratio.75.html">set_tab_ratio</a>(75);

       The default value in Excel is 60.

   <b>set_properties()</b>
       The "set_properties" method can be used to set the document properties  of  the  Excel  file  created  by
       "Excel::Writer::XLSX".  These  properties  are  visible  when  you  use  the "Office Button -&gt; Prepare -&gt;
       Properties" option in Excel and are also available to external applications that read  or  index  Windows
       files.

       The properties should be passed in hash format as follows:

           $workbook-&gt;set_properties(
               title    =&gt; 'This is an example spreadsheet',
               author   =&gt; 'John McNamara',
               comments =&gt; 'Created with Perl and Excel::Writer::XLSX',
           );

       The properties that can be set are:

           title
           subject
           author
           manager
           company
           category
           keywords
           comments
           status
           hyperlink_base
           created - File create date. Should be an aref of gmtime() values.

       See also the "properties.pl" program in the examples directory of the distro.

   <b>set_custom_property(</b> <b>$name,</b> <b>$value,</b> <b>$type)</b>
       The "set_custom_property" method can be used to set one of more custom document properties not covered by
       the  "set_properties()"  method  above.  These  properties are visible when you use the "Office Button -&gt;
       Prepare -&gt; Properties -&gt; Advanced Properties -&gt; Custom"  option  in  Excel  and  are  also  available  to
       external applications that read or index Windows files.

       The "set_custom_property" method takes 3 parameters:

           $workbook-&gt; set_custom_property( $name, $value, $type);

       Where the available types are:

           text
           date
           number
           bool

       For example:

           $workbook-&gt;set_custom_property( 'Checked by',      'Eve',                  'text'   );
           $workbook-&gt;set_custom_property( 'Date completed',  '2016-12-12T23:00:00Z', 'date'   );
           $workbook-&gt;set_custom_property( 'Document number', '12345' ,               'number' );
           $workbook-&gt;set_custom_property( 'Reference',       '1.2345',               'number' );
           $workbook-&gt;set_custom_property( 'Has review',      1,                      'bool'   );
           $workbook-&gt;set_custom_property( 'Signed off',      0,                      'bool'   );
           $workbook-&gt;set_custom_property( 'Department',      $some_string,           'text'   );
           $workbook-&gt;set_custom_property( 'Scale',           '1.2345678901234',      'number' );

       Dates should by in ISO8601 "yyyy-mm-ddThh:mm:ss.sssZ" date format in Zulu time, as shown above.

       The "text" and "number" types are optional since they can usually be inferred from the data:

           $workbook-&gt;set_custom_property( 'Checked by', 'Eve'    );
           $workbook-&gt;set_custom_property( 'Reference',  '1.2345' );

       The $name and $value parameters are limited to 255 characters by Excel.

   <b>define_name()</b>
       This  method is used to defined a name that can be used to represent a value, a single cell or a range of
       cells in a workbook.

       For example to set a global/workbook name:

           # Global/workbook names.
           $workbook-&gt;define_name( 'Exchange_rate', '=0.96' );
           $workbook-&gt;define_name( 'Sales',         '=Sheet1!$G$1:$H$10' );

       It is also possible to define a local/worksheet name by prefixing the name with the sheet name using  the
       syntax "sheetname!definedname":

           # Local/worksheet name.
           $workbook-&gt;define_name( 'Sheet2!Sales',  '=Sheet2!$G$1:$G$10' );

       If  the  sheet  name  contains  spaces or special characters you must enclose it in single quotes like in
       Excel:

           $workbook-&gt;define_name( "'New Data'!Sales",  '=Sheet2!$G$1:$G$10' );

       See the defined_name.pl program in the examples dir of the distro.

       Refer    to    the    following    to    see    Excel's    syntax    rules     for     defined     names:
       &lt;<a href="http://office.microsoft.com/en-001/excel-help/define-and-use-names-in-formulas-HA010147120.aspx">http://office.microsoft.com/en-001/excel-help/define-and-use-names-in-formulas-HA010147120.aspx</a>#BMsyntax_rules_for_names&gt;

   <b>set_tempdir()</b>
       "Excel::Writer::XLSX" stores worksheet data in temporary files prior to assembling the final workbook.

       The  "File::Temp"  module  is  used  to  create  these  temporary  files. File::Temp uses "File::Spec" to
       determine an appropriate location for these files such as "<a href="file:/tmp">/tmp</a>" or "c:\windows\temp". You can  find  out
       which directory is used on your system as follows:

           perl -MFile::Spec -le "print File::Spec-&gt;tmpdir()"

       If  the  default temporary file directory isn't accessible to your application, or doesn't contain enough
       space, you can specify an alternative location using the "set_tempdir()" method:

           $workbook-&gt;set_tempdir( '/tmp/writeexcel' );
           $workbook-&gt;set_tempdir( 'c:\windows\temp\writeexcel' );

       The directory for the temporary file must exist, "set_tempdir()" will not create a new directory.

   <b>set_custom_color(</b> <b>$index,</b> <b>$red,</b> <b>$green,</b> <b>$blue</b> <b>)</b>
       The method is maintained for backward  compatibility  with  Spreadsheet::WriteExcel.  Excel::Writer::XLSX
       programs  don't  require this method and colours can be specified using a Html style "#RRGGBB" value, see
       "WORKING WITH COLOURS".

   <b>sheets(</b> <b>0,</b> <b>1,</b> <b>...</b> <b>)</b>
       The "sheets()" method returns a list, or a sliced list, of the worksheets in a workbook.

       If no arguments are passed the method returns a list of all the  worksheets  in  the  workbook.  This  is
       useful if you want to repeat an operation on each worksheet:

           for $worksheet ( $workbook-&gt;sheets() ) {
               print $worksheet-&gt;get_name();
           }

       You can also specify a slice list to return one or more worksheet objects:

           $worksheet = $workbook-&gt;sheets( 0 );
           $worksheet-&gt;write( 'A1', 'Hello' );

       Or  since  the  return value from "sheets()" is a reference to a worksheet object you can write the above
       example as:

           $workbook-&gt;sheets( 0 )-&gt;write( 'A1', 'Hello' );

       The following example returns the first and last worksheet in a workbook:

           for $worksheet ( $workbook-&gt;sheets( 0, -1 ) ) {
               # Do something
           }

       Array slices are explained in the "perldata" manpage.

   <b>get_worksheet_by_name()</b>
       The "get_worksheet_by_name()" function return a worksheet or chartsheet object in the workbook using  the
       sheetname:

           $worksheet = $workbook-&gt;get_worksheet_by_name('Sheet1');

   <b>set_1904()</b>
       Excel  stores  dates as real numbers where the integer part stores the number of days since the epoch and
       the fractional part stores the percentage of the day. The epoch can be either 1900  or  1904.  Excel  for
       Windows  uses  1900  and  Excel  for  Macintosh uses 1904. However, Excel on either platform will convert
       automatically between one system and the other.

       Excel::Writer::XLSX stores dates in the 1900 format by default. If you wish to change this you  can  call
       the  "set_1904()"  workbook  method. You can query the current value by calling the "get_1904()" workbook
       method. This returns 0 for 1900 and 1 for 1904.

       See also "DATES AND TIME IN EXCEL" for more information about working with Excel's date system.

       In general you probably won't need to use "set_1904()".

   <b>set_optimization()</b>
       The "set_optimization()" method is used to turn  on  optimizations  in  the  Excel::Writer::XLSX  module.
       Currently there is only one optimization available and that is to reduce memory usage.

           $workbook-&gt;set_optimization();

       See "SPEED AND MEMORY USAGE" for more background information.

       Note,  that with this optimization turned on a row of data is written and then discarded when a cell in a
       new row is added via one of the Worksheet  "write_*()"  methods.  As  such  data  should  be  written  in
       sequential row order once the optimization is turned on.

       This method must be called before any calls to "add_worksheet()".

   <b>set_calc_mode(</b> <b>$mode</b> <b>)</b>
       Set  the  calculation  mode  for  formulas in the workbook. This is mainly of use for workbooks with slow
       formulas where you want to allow the user to calculate them manually.

       The mode parameter can be one of the following strings:

       "auto"
           The default. Excel will re-calculate formulas when  a  formula  or  a  value  affecting  the  formula
           changes.

       "manual"
           Only re-calculate formulas when the user requires it. Generally by pressing F9.

       "auto_except_tables"
           Excel will automatically re-calculate formulas except for tables.

   <b>get_default_url_format()</b>
       The  "get_default_url_format()"  method  gets  a  copy of the default url format used when a user defined
       format isn't specified with the worksheet "write_url()" method. The format is the hyperlink style defined
       by Excel for the default theme:

           my $url_format = $workbook-&gt;get_default_url_format();

   <b>read_only_recommended()</b>
       The "read_only_recommended()" method can be used to set the Excel "Read-only Recommended" option that  is
       available when saving a file. This presents the user of the file with an option to open it in "read-only"
       mode. This means that any changes to the file can't be saved back to the same file and must be saved to a
       new file. It can be set as follows:

           $workbook-&gt;read_only_recommended();

</pre><h4><b>WORKSHEET</b> <b>METHODS</b></h4><pre>
       A new worksheet is created by calling the "add_worksheet()" method from a workbook object:

           $worksheet1 = $workbook-&gt;add_worksheet();
           $worksheet2 = $workbook-&gt;add_worksheet();

       The following methods are available through a new worksheet:

           write()
           write_number()
           write_string()
           write_rich_string()
           keep_leading_zeros()
           write_blank()
           write_row()
           write_col()
           write_date_time()
           write_url()
           write_url_range()
           write_formula()
           write_boolean()
           write_comment()
           show_comments()
           set_comments_author()
           add_write_handler()
           insert_image()
           insert_chart()
           insert_shape()
           insert_button()
           data_validation()
           conditional_formatting()
           add_sparkline()
           add_table()
           get_name()
           activate()
           select()
           hide()
           set_first_sheet()
           protect()
           unprotect_range()
           set_selection()
           set_top_left_cell()
           set_row()
           set_row_pixels()
           set_default_row()
           set_column()
           set_column_pixels()
           outline_settings()
           freeze_panes()
           split_panes()
           merge_range()
           merge_range_type()
           set_zoom()
           right_to_left()
           hide_zero()
           set_background()
           set_tab_color()
           autofilter()
           filter_column()
           filter_column_list()
           set_vba_name()
           ignore_errors()

   <b>Cell</b> <b>notation</b>
       Excel::Writer::XLSX  supports  two  forms  of  notation  to  designate  the position of cells: Row-column
       notation and A1 notation.

       Row-column notation uses a zero based index for both row and column while A1 notation uses  the  standard
       Excel alphanumeric sequence of column letter and 1-based row. For example:

           (0, 0)      # The top left cell in row-column notation.
           ('A1')      # The top left cell in A1 notation.

           (1999, 29)  # Row-column notation.
           ('AD2000')  # The same cell in A1 notation.

       Row-column notation is useful if you are referring to cells programmatically:

           for my $i ( 0 .. 9 ) {
               $worksheet-&gt;write( $i, 0, 'Hello' );    # Cells A1 to A10
           }

       A1 notation is useful for setting up a worksheet manually and for working with formulas:

           $worksheet-&gt;write( 'H1', 200 );
           $worksheet-&gt;write( 'H2', '=H1+1' );

       In formulas and applicable methods you can also use the "A:A" column notation:

           $worksheet-&gt;write( 'A1', '=SUM(B:B)' );

       The  "Excel::Writer::XLSX::Utility"  module  that is included in the distro contains helper functions for
       dealing with A1 notation, for example:

           use Excel::Writer::XLSX::Utility;

           ( $row, $col ) = xl_cell_to_rowcol( 'C2' );    # (1, 2)
           $str           = xl_rowcol_to_cell( 1, 2 );    # C2

       For simplicity, the parameter lists for the worksheet method calls in the following sections are given in
       terms of row-column notation. In all cases it is also possible to use A1 notation.

       Note: in Excel it is also possible to use a R1C1 notation. This is not supported by Excel::Writer::XLSX.

   <b>write(</b> <b>$row,</b> <b>$column,</b> <b>$token,</b> <b>$format</b> <b>)</b>
       Excel makes a distinction between data types such as strings, numbers, blanks, formulas  and  hyperlinks.
       To  simplify  the  process  of writing data the "write()" method acts as a general alias for several more
       specific methods:

           write_string()
           write_number()
           write_blank()
           write_formula()
           write_url()
           write_row()
           write_col()

       The general rule is that if the data looks like a <u>something</u> then a <u>something</u> is written.  Here  are  some
       examples in both row-column and A1 notation:

                                                               # Same as:
           $worksheet-&gt;write( 0, 0, 'Hello'                 ); # write_string()
           $worksheet-&gt;write( 1, 0, 'One'                   ); # write_string()
           $worksheet-&gt;write( 2, 0,  2                      ); # write_number()
           $worksheet-&gt;write( 3, 0,  3.00001                ); # write_number()
           $worksheet-&gt;write( 4, 0,  ""                     ); # write_blank()
           $worksheet-&gt;write( 5, 0,  ''                     ); # write_blank()
           $worksheet-&gt;write( 6, 0,  undef                  ); # write_blank()
           $worksheet-&gt;write( 7, 0                          ); # write_blank()
           $worksheet-&gt;write( 8, 0,  '<a href="http://www.perl.com/">http://www.perl.com/</a>' ); # write_url()
           $worksheet-&gt;write( 'A9',  '<a href="ftp://ftp.cpan.org/">ftp://ftp.cpan.org/</a>'  ); # write_url()
           $worksheet-&gt;write( 'A10', 'internal:Sheet1!A1'   ); # write_url()
           $worksheet-&gt;write( 'A11', 'external:c:\foo.xlsx' ); # write_url()
           $worksheet-&gt;write( 'A12', '=A3 + 3*A4'           ); # write_formula()
           $worksheet-&gt;write( 'A13', '=SIN(PI()/4)'         ); # write_formula()
           $worksheet-&gt;write( 'A14', \@array                ); # write_row()
           $worksheet-&gt;write( 'A15', [\@array]              ); # write_col()

           # And if the keep_leading_zeros property is set:
           $worksheet-&gt;write( 'A16', '2'                    ); # write_number()
           $worksheet-&gt;write( 'A17', '02'                   ); # write_string()
           $worksheet-&gt;write( 'A18', '00002'                ); # write_string()

           # Write an array formula. Not available in Spreadsheet::WriteExcel.
           $worksheet-&gt;write( 'A19', '{=SUM(A1:B1*A2:B2)}'  ); # write_formula()

       The "looks like" rule is defined by regular expressions:

       "write_number()"    if    $token   is   a   number   based   on   the   following   regex:   "$token   =~
       /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/".

       "write_string()" if "keep_leading_zeros()" is set and $token is an integer with leading  zeros  based  on
       the following regex: "$token =~ /^0\d+$/".

       "write_blank()" if $token is undef or a blank string: "undef", "" or ''.

       "write_url()"  if  $token  is a http, https, ftp or mailto URL based on the following regexes: "$token =~
       m|^[fh]tt?ps?://|" or "$token =~ m|^mailto:|".

       "write_url()" if $token is an internal or external sheet reference based on the following regex:  "$token
       =~ m[^(in|ex)ternal:]".

       "write_formula()" if the first character of $token is "=".

       "write_array_formula()" if the $token matches "/^{=.*}$/".

       "write_row()" if $token is an array ref.

       "write_col()" if $token is an array ref of array refs.

       "write_string()" if none of the previous conditions apply.

       The $format parameter is optional. It should be a valid Format object, see "CELL FORMATTING":

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_bold();
           $format-&gt;set_color( 'red' );
           $format-&gt;set_align( 'center' );

           $worksheet-&gt;write( 4, 0, 'Hello', $format );    # Formatted string

       The  <b>write()</b> method will ignore empty strings or "undef" tokens unless a format is also supplied. As such
       you needn't worry about special handling for  empty  or  "undef"  values  in  your  data.  See  also  the
       "write_blank()" method.

       One problem with the "write()" method is that occasionally data looks like a number but you don't want it
       treated  as  a number. For example, zip codes or ID numbers often start with a leading zero. If you write
       this data as a number then the leading zero(s) will be stripped. You can change this default behaviour by
       using the "keep_leading_zeros()" method. While this property is in place any integers with leading  zeros
       will  be treated as strings and the zeros will be preserved. See the "keep_leading_zeros()" section for a
       full discussion of this issue.

       You can also add your own data handlers to the "write()" method using "add_write_handler()".

       The "write()" method will also handle Unicode strings in "UTF-8" format.

       The "write" methods return:

           0 for success.
          -1 for insufficient number of arguments.
          -2 for row or column out of bounds.
          -3 for string too long.

   <b>write_number(</b> <b>$row,</b> <b>$column,</b> <b>$number,</b> <b>$format</b> <b>)</b>
       Write an integer or a float to the cell specified by $row and $column:

           $worksheet-&gt;write_number( 0, 0, 123456 );
           $worksheet-&gt;write_number( 'A2', 2.3451 );

       See the note about "Cell notation". The $format parameter is optional.

       In general it is sufficient to use the "write()" method.

       <b>Note</b>: some versions of  Excel  2007  do  not  display  the  calculated  values  of  formulas  written  by
       Excel::Writer::XLSX. Applying all available Service Packs to Excel should fix this.

   <b>write_string(</b> <b>$row,</b> <b>$column,</b> <b>$string,</b> <b>$format</b> <b>)</b>
       Write a string to the cell specified by $row and $column:

           $worksheet-&gt;write_string( 0, 0, 'Your text here' );
           $worksheet-&gt;write_string( 'A2', 'or here' );

       The maximum string size is 32767 characters. However the maximum string segment that Excel can display in
       a cell is 1000. All 32767 characters can be displayed in the formula bar.

       The $format parameter is optional.

       The  "write()" method will also handle strings in "UTF-8" format. See also the "unicode_*.pl" programs in
       the examples directory of the distro.

       In general it is sufficient to use the "write()" method. However, you  may  sometimes  wish  to  use  the
       "write_string()"  method  to  write  data  that  looks like a number but that you don't want treated as a
       number. For example, zip codes or phone numbers:

           # Write as a plain string
           $worksheet-&gt;write_string( 'A1', '01209' );

       However, if the user edits this string Excel may convert it back to a number. To get around this you  can
       use the Excel text format "@":

           # Format as a string. Doesn't change to a number when edited
           my $format1 = $workbook-&gt;add_format( num_format =&gt; '@' );
           $worksheet-&gt;write_string( 'A2', '01209', $format1 );

       See also the note about "Cell notation".

   <b>write_rich_string(</b> <b>$row,</b> <b>$column,</b> <b>$format,</b> <b>$string,</b> <b>...,</b> <b>$cell_format</b> <b>)</b>
       The "write_rich_string()" method is used to write strings with multiple formats. For example to write the
       string "This is <b>bold</b> and this is <u>italic</u>" you would use the following:

           my $bold   = $workbook-&gt;add_format( bold   =&gt; 1 );
           my $italic = $workbook-&gt;add_format( italic =&gt; 1 );

           $worksheet-&gt;write_rich_string( 'A1',
               'This is ', $bold, 'bold', ' and this is ', $italic, 'italic' );

       The  basic  rule  is to break the string into fragments and put a $format object before the fragment that
       you want to format. For example:

           # Unformatted string.
             'This is an example string'

           # Break it into fragments.
             'This is an ', 'example', ' string'

           # Add formatting before the fragments you want formatted.
             'This is an ', $format, 'example', ' string'

           # In Excel::Writer::XLSX.
           $worksheet-&gt;write_rich_string( 'A1',
               'This is an ', $format, 'example', ' string' );

       String fragments that don't have a format are given a default format. So for  example  when  writing  the
       string "Some <b>bold</b> text" you would use the first example below but it would be equivalent to the second:

           # With default formatting:
           my $bold    = $workbook-&gt;add_format( bold =&gt; 1 );

           $worksheet-&gt;write_rich_string( 'A1',
               'Some ', $bold, 'bold', ' text' );

           # Or more explicitly:
           my $bold    = $workbook-&gt;add_format( bold =&gt; 1 );
           my $default = $workbook-&gt;add_format();

           $worksheet-&gt;write_rich_string( 'A1',
               $default, 'Some ', $bold, 'bold', $default, ' text' );

       As  with  Excel,  only the font properties of the format such as font name, style, size, underline, color
       and effects are applied to the string fragments. Other features such as border, background, text wrap and
       alignment must be applied to the cell.

       The "write_rich_string()" method allows you to do this by using the last argument as a cell format (if it
       is a format object). The following example centers a rich string in the cell:

           my $bold   = $workbook-&gt;add_format( bold  =&gt; 1 );
           my $center = $workbook-&gt;add_format( align =&gt; 'center' );

           $worksheet-&gt;write_rich_string( 'A5',
               'Some ', $bold, 'bold text', ' centered', $center );

       See the "rich_strings.pl" example in the distro for more examples.

           my $bold   = $workbook-&gt;add_format( bold        =&gt; 1 );
           my $italic = $workbook-&gt;add_format( italic      =&gt; 1 );
           my $red    = $workbook-&gt;add_format( color       =&gt; 'red' );
           my $blue   = $workbook-&gt;add_format( color       =&gt; 'blue' );
           my $center = $workbook-&gt;add_format( align       =&gt; 'center' );
           my $super  = $workbook-&gt;add_format( font_script =&gt; 1 );

           # Write some strings with multiple formats.
           $worksheet-&gt;write_rich_string( 'A1',
               'This is ', $bold, 'bold', ' and this is ', $italic, 'italic' );

           $worksheet-&gt;write_rich_string( 'A3',
               'This is ', $red, 'red', ' and this is ', $blue, 'blue' );

           $worksheet-&gt;write_rich_string( 'A5',
               'Some ', $bold, 'bold text', ' centered', $center );

           $worksheet-&gt;write_rich_string( 'A7',
               $italic, 'j = k', $super, '(n-1)', $center );

       As with "write_sting()" the maximum string size is 32767  characters.  See  also  the  note  about  "Cell
       notation".

   <b>keep_leading_zeros()</b>
       This method changes the default handling of integers with leading zeros when using the "write()" method.

       The  "write()"  method  uses  regular  expressions  to  determine  what type of data to write to an Excel
       worksheet. If the data looks like a number it writes a number using "write_number()".  One  problem  with
       this approach is that occasionally data looks like a number but you don't want it treated as a number.

       Zip  codes  and  ID  numbers,  for  example, often start with a leading zero. If you write this data as a
       number then the leading zero(s) will be stripped. This is the also the default behaviour when  you  enter
       data manually in Excel.

       To  get  around  this  you  can use one of three options. Write a formatted number, write the number as a
       string or use the "keep_leading_zeros()" method to change the default behaviour of "write()":

           # Implicitly write a number, the leading zero is removed: 1209
           $worksheet-&gt;write( 'A1', '01209' );

           # Write a zero padded number using a format: 01209
           my $format1 = $workbook-&gt;add_format( num_format =&gt; '00000' );
           $worksheet-&gt;write( 'A2', '01209', $format1 );

           # Write explicitly as a string: 01209
           $worksheet-&gt;write_string( 'A3', '01209' );

           # Write implicitly as a string: 01209
           $worksheet-&gt;keep_leading_zeros();
           $worksheet-&gt;write( 'A4', '01209' );

       The above code would generate a worksheet that looked like the following:

            -----------------------------------------------------------
           |   |     A     |     B     |     C     |     D     | ...
            -----------------------------------------------------------
           | 1 |      1209 |           |           |           | ...
           | 2 |     01209 |           |           |           | ...
           | 3 | 01209     |           |           |           | ...
           | 4 | 01209     |           |           |           | ...

       The examples are on different sides of the cells due to the fact that Excel displays strings with a  left
       justification and numbers with a right justification by default. You can change this by using a format to
       justify the data, see "CELL FORMATTING".

       It should be noted that if the user edits the data in examples "A3" and "A4" the strings will revert back
       to numbers. Again this is Excel's default behaviour. To avoid this you can use the text format "@":

           # Format as a string (01209)
           my $format2 = $workbook-&gt;add_format( num_format =&gt; '@' );
           $worksheet-&gt;write_string( 'A5', '01209', $format2 );

       The  "keep_leading_zeros()" property is off by default. The "keep_leading_zeros()" method takes 0 or 1 as
       an argument. It defaults to 1 if an argument isn't specified:

           $worksheet-&gt;keep_leading_zeros();       # Set on
           $worksheet-&gt;keep_leading_zeros( 1 );    # Set on
           $worksheet-&gt;keep_leading_zeros( 0 );    # Set off

       See also the "add_write_handler()" method.

   <b>write_blank(</b> <b>$row,</b> <b>$column,</b> <b>$format</b> <b>)</b>
       Write a blank cell specified by $row and $column:

           $worksheet-&gt;write_blank( 0, 0, $format );

       This method is used to add formatting to a cell which doesn't contain a string or number value.

       Excel differentiates between an "Empty" cell and a "Blank" cell. An "Empty" cell is a cell which  doesn't
       contain  data  whilst  a  "Blank"  cell is a cell which doesn't contain data but does contain formatting.
       Excel stores "Blank" cells but ignores "Empty" cells.

       As such, if you write an empty cell without formatting it is ignored:

           $worksheet-&gt;write( 'A1', undef, $format );    # write_blank()
           $worksheet-&gt;write( 'A2', undef );             # Ignored

       This seemingly uninteresting fact means that you can write arrays of data without special  treatment  for
       "undef" or empty string values.

       See the note about "Cell notation".

   <b>write_row(</b> <b>$row,</b> <b>$column,</b> <b>$array_ref,</b> <b>$format</b> <b>)</b>
       The  "write_row()"  method  can  be  used to write a 1D or 2D array of data in one go. This is useful for
       converting the results of a database query into an Excel worksheet. You must  pass  a  reference  to  the
       array  of  data rather than the array itself. The "write()" method is then called for each element of the
       data. For example:

           @array = ( 'awk', 'gawk', 'mawk' );
           $array_ref = \@array;

           $worksheet-&gt;write_row( 0, 0, $array_ref );

           # The above example is equivalent to:
           $worksheet-&gt;write( 0, 0, $array[0] );
           $worksheet-&gt;write( 0, 1, $array[1] );
           $worksheet-&gt;write( 0, 2, $array[2] );

       Note: For convenience the "write()" method behaves in the same way as "write_row()" if it  is  passed  an
       array reference. Therefore the following two method calls are equivalent:

           $worksheet-&gt;write_row( 'A1', $array_ref );    # Write a row of data
           $worksheet-&gt;write(     'A1', $array_ref );    # Same thing

       As  with  all  of  the  write  methods  the $format parameter is optional. If a format is specified it is
       applied to all the elements of the data array.

       Array references within the data will be treated as columns. This allows you to write 2D arrays  of  data
       in one go. For example:

           @eec =  (
                       ['maggie', 'milly', 'molly', 'may'  ],
                       [13,       14,      15,      16     ],
                       ['shell',  'star',  'crab',  'stone']
                   );

           $worksheet-&gt;write_row( 'A1', \@eec );

       Would produce a worksheet as follows:

            -----------------------------------------------------------
           |   |    A    |    B    |    C    |    D    |    E    | ...
            -----------------------------------------------------------
           | 1 | maggie  | 13      | shell   | ...     |  ...    | ...
           | 2 | milly   | 14      | star    | ...     |  ...    | ...
           | 3 | molly   | 15      | crab    | ...     |  ...    | ...
           | 4 | may     | 16      | stone   | ...     |  ...    | ...
           | 5 | ...     | ...     | ...     | ...     |  ...    | ...
           | 6 | ...     | ...     | ...     | ...     |  ...    | ...

       To write the data in a row-column order refer to the "write_col()" method below.

       Any  "undef"  values  in the data will be ignored unless a format is applied to the data, in which case a
       formatted blank cell will be written. In either case the appropriate row or column value  will  still  be
       incremented.

       To  find  out  more  about  array  references  refer  to  "perlref"  and  "perlreftut"  in  the main Perl
       documentation. To find out more about 2D arrays or "lists of lists" refer to "perllol".

       The "write_row()" method returns the first error encountered when writing the elements  of  the  data  or
       zero if no errors were encountered. See the return values described for the "write()" method above.

       The "write_row()" method allows the following idiomatic conversion of a text file to an Excel file:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Excel::Writer::XLSX;

           my $workbook  = Excel::Writer::XLSX-&gt;new( 'file.xlsx' );
           my $worksheet = $workbook-&gt;add_worksheet();

           open INPUT, 'file.txt' or die "Couldn't open file: $!";

           $worksheet-&gt;write( $. -1, 0, [split] ) while &lt;INPUT&gt;;

           $workbook-&gt;close();

   <b>write_col(</b> <b>$row,</b> <b>$column,</b> <b>$array_ref,</b> <b>$format</b> <b>)</b>
       The  "write_col()"  method  can  be  used to write a 1D or 2D array of data in one go. This is useful for
       converting the results of a database query into an Excel worksheet. You must  pass  a  reference  to  the
       array  of  data rather than the array itself. The "write()" method is then called for each element of the
       data. For example:

           @array = ( 'awk', 'gawk', 'mawk' );
           $array_ref = \@array;

           $worksheet-&gt;write_col( 0, 0, $array_ref );

           # The above example is equivalent to:
           $worksheet-&gt;write( 0, 0, $array[0] );
           $worksheet-&gt;write( 1, 0, $array[1] );
           $worksheet-&gt;write( 2, 0, $array[2] );

       As with all of the write methods the $format parameter is optional.  If  a  format  is  specified  it  is
       applied to all the elements of the data array.

       Array  references  within the data will be treated as rows. This allows you to write 2D arrays of data in
       one go. For example:

           @eec =  (
                       ['maggie', 'milly', 'molly', 'may'  ],
                       [13,       14,      15,      16     ],
                       ['shell',  'star',  'crab',  'stone']
                   );

           $worksheet-&gt;write_col( 'A1', \@eec );

       Would produce a worksheet as follows:

            -----------------------------------------------------------
           |   |    A    |    B    |    C    |    D    |    E    | ...
            -----------------------------------------------------------
           | 1 | maggie  | milly   | molly   | may     |  ...    | ...
           | 2 | 13      | 14      | 15      | 16      |  ...    | ...
           | 3 | shell   | star    | crab    | stone   |  ...    | ...
           | 4 | ...     | ...     | ...     | ...     |  ...    | ...
           | 5 | ...     | ...     | ...     | ...     |  ...    | ...
           | 6 | ...     | ...     | ...     | ...     |  ...    | ...

       To write the data in a column-row order refer to the "write_row()" method above.

       Any "undef" values in the data will be ignored unless a format is applied to the data, in  which  case  a
       formatted  blank  cell  will be written. In either case the appropriate row or column value will still be
       incremented.

       As noted above the "write()" method can be used as a synonym for "write_row()" and "write_row()"  handles
       nested  array refs as columns. Therefore, the following two method calls are equivalent although the more
       explicit call to "write_col()" would be preferable for maintainability:

           $worksheet-&gt;write_col( 'A1', $array_ref     ); # Write a column of data
           $worksheet-&gt;write(     'A1', [ $array_ref ] ); # Same thing

       To find out  more  about  array  references  refer  to  "perlref"  and  "perlreftut"  in  the  main  Perl
       documentation. To find out more about 2D arrays or "lists of lists" refer to "perllol".

       The  "write_col()"  method  returns  the first error encountered when writing the elements of the data or
       zero if no errors were encountered. See the return values described for the "write()" method above.

   <b>write_date_time(</b> <b>$row,</b> <b>$col,</b> <b>$date_string,</b> <b>$format</b> <b>)</b>
       The "write_date_time()" method can be used to write a date or time to the  cell  specified  by  $row  and
       $column:

           $worksheet-&gt;write_date_time( 'A1', '2004-05-13T23:20', $date_format );

       The $date_string should be in the following format:

           yyyy-mm-ddThh:mm:ss.sss

       This  conforms  to  an ISO8601 date but it should be noted that the full range of ISO8601 formats are not
       supported.

       The following variations on the $date_string parameter are permitted:

           yyyy-mm-ddThh:mm:ss.sss         # Standard format
           yyyy-mm-ddT                     # No time
                     Thh:mm:ss.sss         # No date
           yyyy-mm-ddThh:mm:ss.sssZ        # Additional Z (but not time zones)
           yyyy-mm-ddThh:mm:ss             # No fractional seconds
           yyyy-mm-ddThh:mm                # No seconds

       Note that the "T" is required in all cases.

       A date should always have a $format, otherwise it will appear as a number, see "DATES AND TIME IN  EXCEL"
       and "CELL FORMATTING". Here is a typical example:

           my $date_format = $workbook-&gt;add_format( num_format =&gt; 'mm/dd/yy' );
           $worksheet-&gt;write_date_time( 'A1', '2004-05-13T23:20', $date_format );

       Valid  dates  should  be  in  the  range  1900-01-01  to 9999-12-31, for the 1900 epoch and 1904-01-01 to
       9999-12-31, for the 1904 epoch. As with Excel, dates outside these ranges will be written as a string.

       See also the date_time.pl program in the "examples" directory of the distro.

   <b>write_url(</b> <b>$row,</b> <b>$col,</b> <b>$url,</b> <b>$format,</b> <b>$label</b> <b>)</b>
       Write a hyperlink to a URL in the cell specified by $row and $column. The hyperlink is comprised  of  two
       elements:  the  visible label and the invisible link. The visible label is the same as the link unless an
       alternative label is specified. The $label  parameter  is  optional.  The  label  is  written  using  the
       "write()" method. Therefore it is possible to write strings, numbers or formulas as labels.

       The  $format  parameter  is  also optional and the default Excel hyperlink style will be used if it isn't
       specified. If required you can access the default url format using the Workbook  "get_default_url_format"
       method:

           my $url_format = $workbook-&gt;get_default_url_format();

       There are four web style URI's supported: "http://", "https://", "ftp://" and "mailto:":

           $worksheet-&gt;write_url( 0, 0, '<a href="ftp://www.perl.org/">ftp://www.perl.org/</a>' );
           $worksheet-&gt;write_url( 'A3', '<a href="http://www.perl.com/">http://www.perl.com/</a>' );
           $worksheet-&gt;write_url( 'A4', '<a href="mailto:jmcnamara@cpan.org">mailto:jmcnamara@cpan.org</a>' );

       You can display an alternative string using the $label parameter:

           $worksheet-&gt;write_url( 1, 0, '<a href="http://www.perl.com/">http://www.perl.com/</a>', undef, 'Perl' );

       If  you  wish to have some other cell data such as a number or a formula you can overwrite the cell using
       another call to "write_*()":

           $worksheet-&gt;write_url( 'A1', '<a href="http://www.perl.com/">http://www.perl.com/</a>' );

           # Overwrite the URL string with a formula. The cell is still a link.
           # Note the use of the default url format for consistency with other links.
           my $url_format = $workbook-&gt;get_default_url_format();
           $worksheet-&gt;write_formula( 'A1', '=1+1', $url_format );

       There are two local URIs supported: "internal:"  and  "external:".  These  are  used  for  hyperlinks  to
       internal worksheet references or external workbook and worksheet references:

           $worksheet-&gt;write_url( 'A6',  'internal:Sheet2!A1' );
           $worksheet-&gt;write_url( 'A7',  'internal:Sheet2!A1' );
           $worksheet-&gt;write_url( 'A8',  'internal:Sheet2!A1:B2' );
           $worksheet-&gt;write_url( 'A9',  q{internal:'Sales Data'!A1} );
           $worksheet-&gt;write_url( 'A10', 'external:c:\temp\foo.xlsx' );
           $worksheet-&gt;write_url( 'A11', 'external:c:\foo.xlsx#Sheet2!A1' );
           $worksheet-&gt;write_url( 'A12', 'external:..\foo.xlsx' );
           $worksheet-&gt;write_url( 'A13', 'external:..\foo.xlsx#Sheet2!A1' );
           $worksheet-&gt;write_url( 'A13', 'external:\\\\NET\share\foo.xlsx' );

       All of the these URI types are recognised by the "write()" method, see above.

       Worksheet references are typically of the form "Sheet1!A1". You can also refer to a worksheet range using
       the standard Excel notation: "Sheet1!A1:B2".

       In   external   links  the  workbook  and  worksheet  name  must  be  separated  by  the  "#"  character:
       "external:Workbook.xlsx#Sheet1!A1'".

       You can also link to a named range in the target worksheet. For example say you have a named range called
       "my_name" in the workbook "c:\temp\foo.xlsx" you could link to it as follows:

           $worksheet-&gt;write_url( 'A14', 'external:c:\temp\foo.xlsx#my_name' );

       Excel requires that worksheet names containing spaces or non alphanumeric characters are single quoted as
       follows "'Sales Data'!A1". If you need to do this in a single quoted string then you  can  either  escape
       the  single  quotes  "\'"  or  use  the  quote  operator  "q{}" as described in "perlop" in the main Perl
       documentation.

       Links to network files are also supported. MS/Novell Network files normally begin with two  back  slashes
       as  follows  "\\NETWORK\etc". In order to generate this in a single or double quoted string you will have
       to escape the backslashes,  '\\\\NETWORK\etc'.

       If you are using double quote strings then you should be careful to escape anything  that  looks  like  a
       metacharacter. For more information see "perlfaq5: Why can't I use "C:\temp\foo" in DOS paths?".

       Finally,  you  can  avoid  most  of these quoting problems by using forward slashes. These are translated
       internally to backslashes:

           $worksheet-&gt;write_url( 'A14', "external:c:/temp/foo.xlsx" );
           $worksheet-&gt;write_url( 'A15', 'external://NETWORK/share/foo.xlsx' );

       Note: Excel::Writer::XLSX will escape the following characters in URLs as required by Excel: "\s " &lt; &gt;  \
       [  ] ` ^ { }" unless the URL already contains %xx style escapes. In which case it is assumed that the URL
       was escaped correctly by the user and will by passed directly to Excel.

       Versions  of  Excel  prior  to  Excel 2015 limited hyperlink links and anchor/locations to 255 characters
       each. Versions after that support urls up to  2079  characters.  Excel::Writer::XLSX  versions  &gt;=  1.0.2
       support the new longer limit by default.

       See also, the note about "Cell notation".

   <b>write_formula(</b> <b>$row,</b> <b>$column,</b> <b>$formula,</b> <b>$format,</b> <b>$value</b> <b>)</b>
       Write a formula or function to the cell specified by $row and $column:

           $worksheet-&gt;write_formula( 0, 0, '=$B$3 + B4' );
           $worksheet-&gt;write_formula( 1, 0, '=SIN(PI()/4)' );
           $worksheet-&gt;write_formula( 2, 0, '=SUM(B1:B5)' );
           $worksheet-&gt;write_formula( 'A4', '=IF(A3&gt;1,"Yes", "No")' );
           $worksheet-&gt;write_formula( 'A5', '=AVERAGE(1, 2, 3, 4)' );
           $worksheet-&gt;write_formula( 'A6', '=DATEVALUE("1-Jan-2001")' );

       Array formulas are also supported:

           $worksheet-&gt;write_formula( 'A7', '{=SUM(A1:B1*A2:B2)}' );

       See also the "write_array_formula()" method below.

       See  the  note about "Cell notation". For more information about writing Excel formulas see "FORMULAS AND
       FUNCTIONS IN EXCEL"

       If required, it is also possible to specify the calculated value of the  formula.  This  is  occasionally
       necessary  when  working  with  non-Excel applications that don't calculate the value of the formula. The
       calculated $value is added at the end of the argument list:

           $worksheet-&gt;write( 'A1', '=2+2', $format, 4 );

       However, this probably isn't something that you will ever need to do. If you do use this feature then  do
       so with care.

   <b>write_array_formula($first_row,</b> <b>$first_col,</b> <b>$last_row,</b> <b>$last_col,</b> <b>$formula,</b> <b>$format,</b> <b>$value)</b>
       Write  an  array  formula  to  a  cell  range.  In  Excel  an  array formula is a formula that performs a
       calculation on a set of values. It can return a single value or a range of values.

       An array formula is indicated by a pair of braces around  the  formula:  "{=SUM(A1:B1*A2:B2)}".   If  the
       array formula returns a single value then the $first_ and $last_ parameters should be the same:

           $worksheet-&gt;write_array_formula('A1:A1', '{=SUM(B1:C1*B2:C2)}');

       It this case however it is easier to just use the "write_formula()" or "write()" methods:

           # Same as above but more concise.
           $worksheet-&gt;write( 'A1', '{=SUM(B1:C1*B2:C2)}' );
           $worksheet-&gt;write_formula( 'A1', '{=SUM(B1:C1*B2:C2)}' );

       For  array  formulas that return a range of values you must specify the range that the return values will
       be written to:

           $worksheet-&gt;write_array_formula( 'A1:A3',    '{=TREND(C1:C3,B1:B3)}' );
           $worksheet-&gt;write_array_formula( 0, 0, 2, 0, '{=TREND(C1:C3,B1:B3)}' );

       If required, it is also possible to specify the calculated value of the  formula.  This  is  occasionally
       necessary  when  working  with  non-Excel  applications  that  don't  calculate the value of the formula.
       However, using this parameter only writes a single value to the upper left cell in the result array.  For
       a  multi-cell  array  formula where the results are required, the other result values can be specified by
       using "write_number()" to write to the appropriate cell:

           # Specify the result for a single cell range.
           $worksheet-&gt;write_array_formula( 'A1:A3', '{=SUM(B1:C1*B2:C2)}, $format, 2005 );

           # Specify the results for a multi cell range.
           $worksheet-&gt;write_array_formula( 'A1:A3', '{=TREND(C1:C3,B1:B3)}', $format, 105 );
           $worksheet-&gt;write_number( 'A2', 12, format );
           $worksheet-&gt;write_number( 'A3', 14, format );

       In addition, some early versions of Excel 2007 don't calculate the values of  array  formulas  when  they
       aren't supplied. Installing the latest Office Service Pack should fix this issue.

       See also the "array_formula.pl" program in the "examples" directory of the distro.

       Note: Array formulas are not supported by Spreadsheet::WriteExcel.

   <b>write_boolean(</b> <b>$row,</b> <b>$column,</b> <b>$value,</b> <b>$format</b> <b>)</b>
       Write an Excel boolean value to the cell specified by $row and $column:

           $worksheet-&gt;write_boolean( 'A1', 1          );  # TRUE
           $worksheet-&gt;write_boolean( 'A2', 0          );  # FALSE
           $worksheet-&gt;write_boolean( 'A3', undef      );  # FALSE
           $worksheet-&gt;write_boolean( 'A3', 0, $format );  # FALSE, with format.

       A  $value  that is true or false using Perl's rules will be written as an Excel boolean "TRUE" or "FALSE"
       value.

       See the note about "Cell notation".

   <b>store_formula(</b> <b>$formula</b> <b>)</b>
       Deprecated. This is a Spreadsheet::WriteExcel method that is no longer required  by  Excel::Writer::XLSX.
       See below.

   <b>repeat_formula(</b> <b>$row,</b> <b>$col,</b> <b>$formula,</b> <b>$format</b> <b>)</b>
       Deprecated. This is a Spreadsheet::WriteExcel method that is no longer required by Excel::Writer::XLSX.

       In Spreadsheet::WriteExcel it was computationally expensive to write formulas since they were parsed by a
       recursive  descent  parser.  The  "store_formula()"  and "repeat_formula()" methods were used as a way of
       avoiding the overhead of repeated formulas by reusing a pre-parsed formula.

       In Excel::Writer::XLSX this is no longer necessary since it is just as quick to write a formula as it  is
       to write a string or a number.

       The methods remain for backward compatibility but new Excel::Writer::XLSX programs shouldn't use them.

   <b>write_comment(</b> <b>$row,</b> <b>$column,</b> <b>$string,</b> <b>...</b> <b>)</b>
       The  "write_comment()" method is used to add a comment to a cell. A cell comment is indicated in Excel by
       a small red triangle in the upper right-hand corner of the cell. Moving the cursor over the red  triangle
       will reveal the comment.

       The following example shows how to add a comment to a cell:

           $worksheet-&gt;write        ( 2, 2, 'Hello' );
           $worksheet-&gt;write_comment( 2, 2, 'This is a comment.' );

       As  usual you can replace the $row and $column parameters with an "A1" cell reference. See the note about
       "Cell notation".

           $worksheet-&gt;write        ( 'C3', 'Hello');
           $worksheet-&gt;write_comment( 'C3', 'This is a comment.' );

       The "write_comment()" method will also handle strings in "UTF-8" format.

           $worksheet-&gt;write_comment( 'C3', "\x{263a}" );       # Smiley
           $worksheet-&gt;write_comment( 'C4', 'Comment ca va?' );

       In addition to the basic 3 argument form of "write_comment()" you can pass in several optional  key/value
       pairs to control the format of the comment. For example:

           $worksheet-&gt;write_comment( 'C3', 'Hello', visible =&gt; 1, author =&gt; 'Perl' );

       Most  of these options are quite specific and in general the default comment behaves will be all that you
       need. However, should you need greater control over the format of the cell comment the following  options
       are available:

           author
           visible
           x_scale
           width
           y_scale
           height
           color
           start_cell
           start_row
           start_col
           x_offset
           y_offset
           font
           font_size

       Option: author
           This  option  is used to indicate who is the author of the cell comment. Excel displays the author of
           the comment in the status bar at the bottom  of  the  worksheet.  This  is  usually  of  interest  in
           corporate environments where several people might review and provide comments to a workbook.

               $worksheet-&gt;write_comment( 'C3', 'Atonement', author =&gt; 'Ian McEwan' );

           The  default  author  for  all cell comments can be set using the "set_comments_author()" method (see
           below).

               $worksheet-&gt;set_comments_author( 'Perl' );

       Option: visible
           This option is used to make a cell  comment  visible  when  the  worksheet  is  opened.  The  default
           behaviour  in  Excel  is that comments are initially hidden. However, it is also possible in Excel to
           make individual or all comments visible. In  Excel::Writer::XLSX  individual  comments  can  be  made
           visible as follows:

               $worksheet-&gt;write_comment( 'C3', 'Hello', visible =&gt; 1 );

           It  is  possible  to  make  all comments in a worksheet visible using the "show_comments()" worksheet
           method (see below). Alternatively, if all of the cell comments have been made visible  you  can  hide
           individual comments:

               $worksheet-&gt;write_comment( 'C3', 'Hello', visible =&gt; 0 );

       Option: x_scale
           This option is used to set the width of the cell comment box as a factor of the default width.

               $worksheet-&gt;write_comment( 'C3', 'Hello', x_scale =&gt; 2 );
               $worksheet-&gt;write_comment( 'C4', 'Hello', x_scale =&gt; 4.2 );

       Option: width
           This option is used to set the width of the cell comment box explicitly in pixels.

               $worksheet-&gt;write_comment( 'C3', 'Hello', width =&gt; 200 );

       Option: y_scale
           This option is used to set the height of the cell comment box as a factor of the default height.

               $worksheet-&gt;write_comment( 'C3', 'Hello', y_scale =&gt; 2 );
               $worksheet-&gt;write_comment( 'C4', 'Hello', y_scale =&gt; 4.2 );

       Option: height
           This option is used to set the height of the cell comment box explicitly in pixels.

               $worksheet-&gt;write_comment( 'C3', 'Hello', height =&gt; 200 );

       Option: color
           This  option  is  used to set the background colour of cell comment box. You can use one of the named
           colours recognised by Excel::Writer::XLSX or  a  Html  style  "#RRGGBB"  colour.  See  "WORKING  WITH
           COLOURS".

               $worksheet-&gt;write_comment( 'C3', 'Hello', color =&gt; 'green' );
               $worksheet-&gt;write_comment( 'C4', 'Hello', color =&gt; '#FF6600' ); # Orange

       Option: start_cell
           This  option  is  used  to  set  the cell in which the comment will appear. By default Excel displays
           comments one cell to the right and one cell above the cell to which the comment relates. However, you
           can change this behaviour if you wish. In the following example the comment  which  would  appear  by
           default in cell "D2" is moved to "E2".

               $worksheet-&gt;write_comment( 'C3', 'Hello', start_cell =&gt; 'E2' );

       Option: start_row
           This  option  is  used  to  set the row in which the comment will appear. See the "start_cell" option
           above. The row is zero indexed.

               $worksheet-&gt;write_comment( 'C3', 'Hello', start_row =&gt; 0 );

       Option: start_col
           This option is used to set the column in which the comment will appear. See the  "start_cell"  option
           above. The column is zero indexed.

               $worksheet-&gt;write_comment( 'C3', 'Hello', start_col =&gt; 4 );

       Option: x_offset
           This option is used to change the x offset, in pixels, of a comment within a cell:

               $worksheet-&gt;write_comment( 'C3', $comment, x_offset =&gt; 30 );

       Option: y_offset
           This option is used to change the y offset, in pixels, of a comment within a cell:

               $worksheet-&gt;write_comment('C3', $comment, x_offset =&gt; 30);

       Option: font
           This option is used to change the font used in the comment from 'Tahoma' which is the default.

               $worksheet-&gt;write_comment('C3', $comment, font =&gt; 'Calibri');

       Option: font_size
           This option is used to change the font size used in the comment from 8 which is the default.

               $worksheet-&gt;write_comment('C3', $comment, font_size =&gt; 20);

       You can apply as many of these options as you require.

       <b>Note</b>  <b>about</b>  <b>using</b>  <b>options</b>  <b>that</b>  <b>adjust</b> <b>the</b> <b>position</b> <b>of</b> <b>the</b> <b>cell</b> <b>comment</b> <b>such</b> <b>as</b> <b>start_cell,</b> <b>start_row,</b>
       <b>start_col,</b> <b>x_offset</b> <b>and</b> <b>y_offset</b>: Excel only displays offset cell comments when  they  are  displayed  as
       "visible". Excel does <b>not</b> display hidden cells as moved when you mouse over them.

       <b>Note</b>  <b>about</b>  <b>row</b>  <b>height</b>  <b>and</b>  <b>comments</b>.  If you specify the height of a row that contains a comment then
       Excel::Writer::XLSX will adjust the height of the comment to  maintain  the  default  or  user  specified
       dimensions.  However,  the  height  of a row can also be adjusted automatically by Excel if the text wrap
       property is set or large fonts are used in the cell. This means that the height of the row is unknown  to
       the  module at run time and thus the comment box is stretched with the row. Use the "set_row()" method to
       specify the row height explicitly and avoid this problem.

   <b>show_comments()</b>
       This method is used to make all cell comments visible when a worksheet is opened.

           $worksheet-&gt;show_comments();

       Individual comments can be made visible using the "visible" parameter of the "write_comment" method  (see
       above):

           $worksheet-&gt;write_comment( 'C3', 'Hello', visible =&gt; 1 );

       If all of the cell comments have been made visible you can hide individual comments as follows:

           $worksheet-&gt;show_comments();
           $worksheet-&gt;write_comment( 'C3', 'Hello', visible =&gt; 0 );

   <b>set_comments_author()</b>
       This method is used to set the default author of all cell comments.

           $worksheet-&gt;set_comments_author( 'Perl' );

       Individual  comment  authors  can  be set using the "author" parameter of the "write_comment" method (see
       above).

       The default comment author is an empty string, '', if no author is specified.

   <b>add_write_handler(</b> <b>$re,</b> <b>$code_ref</b> <b>)</b>
       This method is used to extend the Excel::Writer::XLSX <b>write()</b> method to handle user defined data.

       If you refer to the section on "write()" above you will see that it acts as an  alias  for  several  more
       specific "write_*" methods. However, it doesn't always act in exactly the way that you would like it to.

       One  solution  is  to  filter  the input data yourself and call the appropriate "write_*" method. Another
       approach is to use the "add_write_handler()" method to add your own automated behaviour to "write()".

       The "add_write_handler()" method take two arguments, $re, a regular expression to match incoming data and
       $code_ref a callback function to handle the matched data:

           $worksheet-&gt;add_write_handler( qr/^\d\d\d\d$/, \&amp;my_write );

       (In the these examples the "qr" operator is used to quote the regular expression strings, see perlop  for
       more details).

       The method is used as follows. say you wished to write 7 digit ID numbers as a string so that any leading
       zeros were preserved*, you could do something like the following:

           $worksheet-&gt;add_write_handler( qr/^\d{7}$/, \&amp;write_my_id );

           sub write_my_id {
               my $worksheet = shift;
               return $worksheet-&gt;write_string( @_ );
           }

       * You could also use the "keep_leading_zeros()" method for this.

       Then if you call "write()" with an appropriate string it will be handled automatically:

           # Writes 0000000. It would normally be written as a number; 0.
           $worksheet-&gt;write( 'A1', '0000000' );

       The  callback  function  will receive a reference to the calling worksheet and all of the other arguments
       that were passed to "write()". The callback will see an @_ argument list that looks like the following:

           $_[0]   A ref to the calling worksheet. *
           $_[1]   Zero based row number.
           $_[2]   Zero based column number.
           $_[3]   A number or string or token.
           $_[4]   A format ref if any.
           $_[5]   Any other arguments.
           ...

           *  It is good style to shift this off the list so the @_ is the same
              as the argument list seen by write().

       Your callback should "return()" the return value of the "write_*" method that was called  or  "undef"  to
       indicate that you rejected the match and want "write()" to continue as normal.

       So  for  example  if  you  wished  to apply the previous filter only to ID values that occur in the first
       column you could modify your callback function as follows:

           sub write_my_id {
               my $worksheet = shift;
               my $col       = $_[1];

               if ( $col == 0 ) {
                   return $worksheet-&gt;write_string( @_ );
               }
               else {
                   # Reject the match and return control to write()
                   return undef;
               }
           }

       Now, you will get different behaviour for the first column and other columns:

           $worksheet-&gt;write( 'A1', '0000000' );    # Writes 0000000
           $worksheet-&gt;write( 'B1', '0000000' );    # Writes 0

       You may add more than one handler in which case they will be called in the order that they were added.

       Note, the "add_write_handler()" method is particularly suited for handling dates.

       See the "write_handler 1-4" programs in the "examples" directory for further examples.

   <b>insert_image(</b> <b>$row,</b> <b>$col,</b> <b>$filename,</b> <b>{</b> <b>%options</b> <b>}</b> <b>)</b>
       This method can be used to insert a image into a worksheet. The image can be in PNG,  JPEG,  GIF  or  BMP
       format.

           $worksheet1-&gt;insert_image( 'A1', 'perl.bmp' );
           $worksheet2-&gt;insert_image( 'A1', '../images/perl.bmp' );
           $worksheet3-&gt;insert_image( 'A1', '.c:\images\perl.bmp' );

       The  optional  "options"  hash/hashref  parameter  can  be used to set various options for the image. The
       defaults are:

           %options = (
               x_offset        =&gt; 0,
               y_offset        =&gt; 0,
               x_scale         =&gt; 1,
               y_scale         =&gt; 1,
               object_position =&gt; 2,
               url             =&gt; undef,
               tip             =&gt; undef,
               description     =&gt; $filename,
               decorative      =&gt; 0,
           );

       The parameters "x_offset" and "y_offset" can be used to specify an offset from the top left  hand  corner
       of the cell specified by $row and $col. The offset values are in pixels.

           $worksheet1-&gt;insert_image('A1', 'perl.bmp', { x_offset =&gt;32, y_offset =&gt; 10 });

       The  offsets  can  be  greater  than the width or height of the underlying cell. This can be occasionally
       useful if you wish to align two or more images relative to the same cell.

       The parameters "x_scale" and "y_scale"  can  be  used  to  scale  the  inserted  image  horizontally  and
       vertically:

           # Scale the inserted image: width x 2.0, height x 0.8
           $worksheet-&gt;insert_image( 'A1', 'perl.bmp', { y_scale =&gt; 2, y_scale =&gt; 0.8 } );

       The positioning of the image when cells are resized can be set with the "object_position" parameter:

           $worksheet-&gt;insert_image( 'A1', 'perl.bmp', { object_position =&gt; 1 } );

       The "object_position" parameter can have one of the following allowable values:

           1. Move and size with cells.
           2. Move but don't size with cells.
           3. Don't move or size with cells.
           4. Same as Option 1, see below.

       Option  4  appears  in  Excel  as Option 1. However, the worksheet object is sized to take hidden rows or
       columns into account. This allows the user to hide an image in a cell, possibly as part of an autofilter.

       The "url" option can be use to used to add a hyperlink to an image:

           $worksheet-&gt;insert_image( 'A1', 'logo.png',
               { url =&gt; 'https://github.com/jmcnamara' } );

       The supported url formats are the same as those supported  by  the  "write_url()"  method  and  the  same
       rules/limits apply.

       The "tip" option can be use to used to add a mouseover tip to the hyperlink:

           $worksheet-&gt;insert_image( 'A1', 'logo.png',
               {
                   url =&gt; 'https://github.com/jmcnamara',
                   tip =&gt; 'GitHub'
               }
           );

       The  "description"  parameter can be used to specify a description or "alt text" string for the image. In
       general this would be used to provide a text description of the image to help  accessibility.  It  is  an
       optional parameter and defaults to the filename of the image. It can be used as follows:

           $worksheet-&gt;insert_image( 'E9', 'logo.png',
                                     {description =&gt; "This is some alternative text"} );

       The  optional  "decorative" parameter is also used to help accessibility. It is used to mark the image as
       decorative, and thus uninformative, for automated screen readers. As in Excel, if this  parameter  is  in
       use the "description" field isn't written. It is used as follows:

           $worksheet-&gt;insert_image( 'E9', 'logo.png', {decorative =&gt; 1} );

       Note:  you  must  call  "set_row()"  or  "set_column()" before "insert_image()" if you wish to change the
       default dimensions of any of the rows or columns that the image occupies. The height of a  row  can  also
       change  if  you  use a font that is larger than the default. This in turn will affect the scaling of your
       image. To avoid this you should explicitly set the height of the row using "set_row()" if it  contains  a
       font size that will change the row height.

       BMP  images  must  be  24 bit, true colour, bitmaps. In general it is best to avoid BMP images since they
       aren't compressed.

   <b>insert_chart(</b> <b>$row,</b> <b>$col,</b> <b>$chart,</b> <b>{</b> <b>%options</b> <b>}</b> <b>)</b>
       This method can be used to insert a Chart object into a worksheet. The  Chart  must  be  created  by  the
       "add_chart()" Workbook method and it must have the "embedded" option set.

           my $chart = $workbook-&gt;add_chart( type =&gt; 'line', embedded =&gt; 1 );

           # Configure the chart.
           ...

           # Insert the chart into the a worksheet.
           $worksheet-&gt;insert_chart( 'E2', $chart );

       See  "add_chart()"  for  details  on  how  to  create the Chart object and Excel::Writer::XLSX::Chart for
       details on how to configure it. See also the "chart_*.pl" programs  in  the  examples  directory  of  the
       distro.

       The  optional  "options"  hash/hashref  parameter  can  be used to set various options for the chart. The
       defaults are:

           %options = (
               x_offset        =&gt; 0,
               y_offset        =&gt; 0,
               x_scale         =&gt; 1,
               y_scale         =&gt; 1,
               object_position =&gt; 1,
               description     =&gt; undef,
               decorative      =&gt; 0,
           );

       The parameters "x_offset" and "y_offset" can be used to specify an offset from the top left  hand  corner
       of the cell specified by $row and $col. The offset values are in pixels.

           $worksheet1-&gt;insert_chart( 'E2', $chart, { x_offset =&gt;10, y_offset =&gt; 20 });

       The  parameters  "x_scale"  and  "y_scale"  can  be  used  to  scale  the inserted chart horizontally and
       vertically:

           # Scale the width by 120% and the height by 150%
           $worksheet-&gt;insert_chart( 'E2', $chart, { y_scale =&gt; 1.2, y_scale =&gt; 1.5 } );

       The positioning of the chart when cells are resized can be set with the "object_position" parameter:

           $worksheet-&gt;insert_chart( 'E2', $chart, { object_position =&gt; 2 } );

       The "object_position" parameter can have one of the following allowable values:

           1. Move and size with cells.
           2. Move but don't size with cells.
           3. Don't move or size with cells.
           4. Same as Option 1, see below.

       Option 4 appears in Excel as Option 1. However, the worksheet object is sized  to  take  hidden  rows  or
       columns into account. This is generally only useful for images and not for charts.

       The  "description"  parameter can be used to specify a description or "alt text" string for the chart. In
       general this would be used to provide a text description of the chart to help  accessibility.  It  is  an
       optional parameter and has no default. It can be used as follows:

           $worksheet-&gt;insert_chart( 'E9', $chart, {description =&gt; 'Some alternative text'} );

       The  optional  "decorative" parameter is also used to help accessibility. It is used to mark the chart as
       decorative, and thus uninformative, for automated screen readers. As in Excel, if this  parameter  is  in
       use the "description" field isn't written. It is used as follows:

           $worksheet-&gt;insert_chart( 'E9', $chart, {decorative =&gt; 1} );

   <b>insert_shape(</b> <b>$row,</b> <b>$col,</b> <b>$shape,</b> <b>$x,</b> <b>$y,</b> <b>$x_scale,</b> <b>$y_scale</b> <b>)</b>
       This  method  can  be  used  to  insert a Shape object into a worksheet. The Shape must be created by the
       "add_shape()" Workbook method.

           my $shape = $workbook-&gt;add_shape( name =&gt; 'My Shape', type =&gt; 'plus' );

           # Configure the shape.
           $shape-&gt;set_text('foo');
           ...

           # Insert the shape into the a worksheet.
           $worksheet-&gt;insert_shape( 'E2', $shape );

       See "add_shape()" for details on how to  create  the  Shape  object  and  Excel::Writer::XLSX::Shape  for
       details on how to configure it.

       The $x, $y, $x_scale and $y_scale parameters are optional.

       The  parameters  $x  and  $y  can  be used to specify an offset from the top left hand corner of the cell
       specified by $row and $col. The offset values are in pixels.

           $worksheet1-&gt;insert_shape( 'E2', $chart, 3, 3 );

       The parameters $x_scale and $y_scale can be used to scale the inserted shape horizontally and vertically:

           # Scale the width by 120% and the height by 150%
           $worksheet-&gt;insert_shape( 'E2', $shape, 0, 0, 1.2, 1.5 );

       See also the "shape*.pl" programs in the examples directory of the distro.

   <b>insert_button(</b> <b>$row,</b> <b>$col,</b> <b>{</b> <b>%options</b> <b>})</b>
       The "insert_button()" method can be used to insert an Excel form button into a worksheet.

       This method is generally only useful when used  in  conjunction  with  the  Workbook  "add_vba_project()"
       method to tie the button to a macro from an embedded VBA project:

           my $workbook  = Excel::Writer::XLSX-&gt;new( 'file.xlsm' );
           ...
           $workbook-&gt;add_vba_project( './vbaProject.bin' );

           $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'my_macro' } );

       The properties of the button that can be set are:

           macro
           caption
           width
           height
           x_scale
           y_scale
           x_offset
           y_offset
           description

       Option: macro
           This  option  is  used  to  set the macro that the button will invoke when the user clicks on it. The
           macro should be included using the Workbook "add_vba_project()" method shown above.

               $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'my_macro' } );

           The default macro is "ButtonX_Click" where X is the button number.

       Option: caption
           This option is used to set the caption on the button. The default is "Button X" where X is the button
           number.

               $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'my_macro', caption =&gt; 'Hello' } );

       Option: width
           This option is used to set the width of the button in pixels.

               $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'my_macro', width =&gt; 128 } );

           The default button width is 64 pixels which is the width of a default cell.

       Option: height
           This option is used to set the height of the button in pixels.

               $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'my_macro', height =&gt; 40 } );

           The default button height is 20 pixels which is the height of a default cell.

       Option: x_scale
           This option is used to set the width of the button as a factor of the default width.

               $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'my_macro', x_scale =&gt; 2.0 );

       Option: y_scale
           This option is used to set the height of the button as a factor of the default height.

               $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'my_macro', y_scale =&gt; 2.0 );

       Option: x_offset
           This option is used to change the x offset, in pixels, of a button within a cell:

               $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'my_macro', x_offset =&gt; 2 );

       Option: y_offset
           This option is used to change the y offset, in pixels, of a comment within a cell.

       Option: description
           The option is used to specify a description or "alt text" string for the button.

       Note: Button is the only Excel form element that  is  available  in  Excel::Writer::XLSX.  Form  elements
       represent a lot of work to implement and the underlying VML syntax isn't very much fun.

   <b>data_validation()</b>
       The  "data_validation()"  method is used to construct an Excel data validation or to limit the user input
       to a dropdown list of values.

           $worksheet-&gt;data_validation('B3',
               {
                   validate =&gt; 'integer',
                   criteria =&gt; '&gt;',
                   value    =&gt; 100,
               });

           $worksheet-&gt;data_validation('B5:B9',
               {
                   validate =&gt; 'list',
                   value    =&gt; ['open', 'high', 'close'],
               });

       This method contains a lot of parameters  and  is  described  in  detail  in  a  separate  section  "DATA
       VALIDATION IN EXCEL".

       See also the "data_validate.pl" program in the examples directory of the distro

   <b>conditional_formatting()</b>
       The "conditional_formatting()" method is used to add formatting to a cell or range of cells based on user
       defined criteria.

           $worksheet-&gt;conditional_formatting( 'A1:J10',
               {
                   type     =&gt; 'cell',
                   criteria =&gt; '&gt;=',
                   value    =&gt; 50,
                   format   =&gt; $format1,
               }
           );

       This  method  contains  a lot of parameters and is described in detail in a separate section "CONDITIONAL
       FORMATTING IN EXCEL".

       See also the "conditional_format.pl" program in the examples directory of the distro

   <b>add_sparkline()</b>
       The "add_sparkline()" worksheet method is used to add sparklines to a cell or a range of cells.

           $worksheet-&gt;add_sparkline(
               {
                   location =&gt; 'F2',
                   range    =&gt; 'Sheet1!A2:E2',
                   type     =&gt; 'column',
                   style    =&gt; 12,
               }
           );

       This method contains a lot of parameters and is described in detail in a separate section "SPARKLINES  IN
       EXCEL".

       See  also  the  "sparklines1.pl" and "sparklines2.pl" example programs in the "examples" directory of the
       distro.

       <b>Note:</b> Sparklines are a feature of Excel 2010+ only. You can write them to an XLSX file that can  be  read
       by Excel 2007 but they won't be displayed.

   <b>add_table()</b>
       The "add_table()" method is used to group a range of cells into an Excel Table.

           $worksheet-&gt;add_table( 'B3:F7', { ... } );

       This  method  contains  a  lot  of parameters and is described in detail in a separate section "TABLES IN
       EXCEL".

       See also the "tables.pl" program in the examples directory of the distro

   <b>get_name()</b>
       The "get_name()" method is used to retrieve the name of a worksheet. For example:

           for my $sheet ( $workbook-&gt;sheets() ) {
               print $sheet-&gt;get_name();
           }

       For reasons related to the design of Excel::Writer::XLSX and to  the  internals  of  Excel  there  is  no
       "set_name()" method. The only way to set the worksheet name is via the "add_worksheet()" method.

   <b>activate()</b>
       The  "activate()"  method  is  used  to  specify  which  worksheet  is initially visible in a multi-sheet
       workbook:

           $worksheet1 = $workbook-&gt;add_worksheet( 'To' );
           $worksheet2 = $workbook-&gt;add_worksheet( 'the' );
           $worksheet3 = $workbook-&gt;add_worksheet( 'wind' );

           $worksheet3-&gt;activate();

       This is similar to the Excel VBA activate method. More  than  one  worksheet  can  be  selected  via  the
       "select()" method, see below, however only one worksheet can be active.

       The default active worksheet is the first worksheet.

   <b>select()</b>
       The "select()" method is used to indicate that a worksheet is selected in a multi-sheet workbook:

           $worksheet1-&gt;activate();
           $worksheet2-&gt;select();
           $worksheet3-&gt;select();

       A  selected worksheet has its tab highlighted. Selecting worksheets is a way of grouping them together so
       that, for example, several worksheets could be printed in one go. A worksheet that has been activated via
       the "activate()" method will also appear as selected.

   <b>hide()</b>
       The "hide()" method is used to hide a worksheet:

           $worksheet2-&gt;hide();

       You may wish to hide a  worksheet  in  order  to  avoid  confusing  a  user  with  intermediate  data  or
       calculations.

       A  hidden  worksheet  can  not  be  activated  or  selected so this method is mutually exclusive with the
       "activate()" and "select()" methods. In addition, since the first worksheet will  default  to  being  the
       active worksheet, you cannot hide the first worksheet without activating another sheet:

           $worksheet2-&gt;activate();
           $worksheet1-&gt;hide();

   <b>set_first_sheet()</b>
       The  "activate()"  method determines which worksheet is initially selected. However, if there are a large
       number of worksheets the selected worksheet may not appear on the screen. To avoid this  you  can  select
       which is the leftmost visible worksheet using "set_first_sheet()":

           for ( 1 .. 20 ) {
               $workbook-&gt;add_worksheet;
           }

           $worksheet21 = $workbook-&gt;add_worksheet();
           $worksheet22 = $workbook-&gt;add_worksheet();

           $worksheet21-&gt;set_first_sheet();
           $worksheet22-&gt;activate();

       This method is not required very often. The default value is the first worksheet.

   <b>protect(</b> <b>$password,</b> <b>\%options</b> <b>)</b>
       The "protect()" method is used to protect a worksheet from modification:

           $worksheet-&gt;protect();

       The  "protect()" method also has the effect of enabling a cell's "locked" and "hidden" properties if they
       have been set. A <u>locked</u> cell cannot be edited and this property is on by default for all cells. A  <u>hidden</u>
       cell will display the results of a formula but not the formula itself.

       See  the  "protection.pl" program in the examples directory of the distro for an illustrative example and
       the "set_locked" and "set_hidden" format methods in "CELL FORMATTING".

       You can optionally add a password to the worksheet protection:

           $worksheet-&gt;protect( 'drowssap' );

       The password should be an ASCII string. Passing the empty string '' is the same as turning on  protection
       without a password.

       Note,  the worksheet level password in Excel provides very weak protection. It does not encrypt your data
       and is very easy to deactivate. Full workbook encryption is not supported by "Excel::Writer::XLSX"  since
       it requires a completely different file format and would take several man months to implement.

       You can specify which worksheet elements you wish to protect by passing a hash_ref with any or all of the
       following keys:

           # Default shown.
           %options = (
               objects               =&gt; 0,
               scenarios             =&gt; 0,
               format_cells          =&gt; 0,
               format_columns        =&gt; 0,
               format_rows           =&gt; 0,
               insert_columns        =&gt; 0,
               insert_rows           =&gt; 0,
               insert_hyperlinks     =&gt; 0,
               delete_columns        =&gt; 0,
               delete_rows           =&gt; 0,
               select_locked_cells   =&gt; 1,
               sort                  =&gt; 0,
               autofilter            =&gt; 0,
               pivot_tables          =&gt; 0,
               select_unlocked_cells =&gt; 1,
           );

       The default boolean values are shown above. Individual elements can be protected as follows:

           $worksheet-&gt;protect( 'drowssap', { insert_rows =&gt; 1 } );

       For chartsheets the allowable options and default values are:

           %options = (
               objects               =&gt; 1,
               content               =&gt; 1,
           );

   <b>unprotect_range(</b> <b>$cell_range,</b> <b>$range_name</b> <b>)</b>
       The  "unprotect_range()"  method  is used to unprotect ranges in a protected worksheet. It can be used to
       set a single range or multiple ranges:

           $worksheet-&gt;unprotect_range( 'A1' );
           $worksheet-&gt;unprotect_range( 'C1' );
           $worksheet-&gt;unprotect_range( 'E1:E3' );
           $worksheet-&gt;unprotect_range( 'G1:K100' );

       As in Excel the ranges are given sequential names like "Range1" and "Range2" but a user defined name  can
       also be specified:

           $worksheet-&gt;unprotect_range( 'G4:I6', 'MyRange' );

   <b>set_selection(</b> <b>$first_row,</b> <b>$first_col,</b> <b>$last_row,</b> <b>$last_col</b> <b>)</b>
       This  method  can  be  used  to  specify which cell or cells are selected in a worksheet. The most common
       requirement is to select a single cell, in which case $last_row and $last_col can be omitted. The  active
       cell  within  a  selected range is determined by the order in which $first and $last are specified. It is
       also possible to specify a cell or a range using A1 notation. See the note about "Cell notation".

       Examples:

           $worksheet1-&gt;set_selection( 3, 3 );          # 1. Cell D4.
           $worksheet2-&gt;set_selection( 3, 3, 6, 6 );    # 2. Cells D4 to G7.
           $worksheet3-&gt;set_selection( 6, 6, 3, 3 );    # 3. Cells G7 to D4.
           $worksheet4-&gt;set_selection( 'D4' );          # Same as 1.
           $worksheet5-&gt;set_selection( 'D4:G7' );       # Same as 2.
           $worksheet6-&gt;set_selection( 'G7:D4' );       # Same as 3.

       The default cell selections is (0, 0), 'A1'.

   <b>set_top_left_cell(</b> <b>$row,</b> <b>$col</b> <b>)</b>
       This method can be used to set the top leftmost visible cell in the worksheet:

           $worksheet-&gt;set_top_left_cell( 31, 26 );

           # Same as:
           $worksheet-&gt;set_top_left_cell( 'AA32' );

       You can also use A1 notation, as shown above, see the note about "Cell notation".

   <b>set_row(</b> <b>$row,</b> <b>$height,</b> <b>$format,</b> <b>$hidden,</b> <b>$level,</b> <b>$collapsed</b> <b>)</b>
       This method can be used to change the default properties of a row. All parameters  apart  from  $row  are
       optional.

       The most common use for this method is to change the height of a row.

           $worksheet-&gt;set_row( 0, 20 );    # Row 1 height set to 20

       Note:  the row height is in Excel character units. To set the height in pixels use the "set_row_pixels()"
       method, see below.

       If you wish to set the format without changing the height you can pass "undef" as the height parameter:

           $worksheet-&gt;set_row( 0, undef, $format );

       The $format parameter will be applied to any cells in the row that don't have a format. For example

           $worksheet-&gt;set_row( 0, undef, $format1 );    # Set the format for row 1
           $worksheet-&gt;write( 'A1', 'Hello' );           # Defaults to $format1
           $worksheet-&gt;write( 'B1', 'Hello', $format2 ); # Keeps $format2

       If you wish to define a row format in this way you should call the method before any calls to  "write()".
       Calling it afterwards will overwrite any format that was previously specified.

       The  $hidden  parameter  should  be set to 1 if you wish to hide a row. This can be used, for example, to
       hide intermediary steps in a complicated calculation:

           $worksheet-&gt;set_row( 0, 20,    $format, 1 );
           $worksheet-&gt;set_row( 1, undef, undef,   1 );

       The $level parameter is used to set the outline level of the row. Outlines are described in "OUTLINES AND
       GROUPING IN EXCEL". Adjacent rows with the same outline level are grouped together into a single outline.

       The following example sets an outline level of 1 for rows 2 and 3 (zero-indexed):

           $worksheet-&gt;set_row( 1, undef, undef, 0, 1 );
           $worksheet-&gt;set_row( 2, undef, undef, 0, 1 );

       The $hidden parameter can also be used to hide collapsed outlined rows when used in conjunction with  the
       $level parameter.

           $worksheet-&gt;set_row( 1, undef, undef, 1, 1 );
           $worksheet-&gt;set_row( 2, undef, undef, 1, 1 );

       For collapsed outlines you should also indicate which row has the collapsed "+" symbol using the optional
       $collapsed parameter.

           $worksheet-&gt;set_row( 3, undef, undef, 0, 0, 1 );

       For  a  more  complete  example  see the "outline.pl" and "outline_collapsed.pl" programs in the examples
       directory of the distro.

       Excel allows up to 7 outline levels. Therefore the $level parameter should be in the range "0  &lt;=  $level
       &lt;= 7".

   <b>set_row_pixels(</b> <b>$row,</b> <b>$height,</b> <b>$format,</b> <b>$hidden,</b> <b>$level,</b> <b>$collapsed</b> <b>)</b>
       This method is the same as "set_row()" except that $height is in pixels.

           $worksheet-&gt;set_row       ( 0, 24 );    # Set row height in character units
           $worksheet-&gt;set_row_pixels( 1, 18 );    # Set row to same height in pixels

   <b>set_column(</b> <b>$first_col,</b> <b>$last_col,</b> <b>$width,</b> <b>$format,</b> <b>$hidden,</b> <b>$level,</b> <b>$collapsed</b> <b>)</b>
       This  method  can  be used to change the default properties of a single column or a range of columns. All
       parameters apart from $first_col and $last_col are optional.

       If "set_column()" is applied to a single column the value of $first_col and $last_col should be the same.
       In the case where $last_col is zero it is set to the same value as $first_col.

       It is also possible, and generally clearer, to specify a column range using the form of A1 notation  used
       for columns. See the note about "Cell notation".

       Examples:

           $worksheet-&gt;set_column( 0, 0, 20 );    # Column  A   width set to 20
           $worksheet-&gt;set_column( 1, 3, 30 );    # Columns B-D width set to 30
           $worksheet-&gt;set_column( 'E:E', 20 );   # Column  E   width set to 20
           $worksheet-&gt;set_column( 'F:H', 30 );   # Columns F-H width set to 30

       The  width corresponds to the column width value that is specified in Excel. It is approximately equal to
       the length of a string in the  default  font  of  Calibri  11.  To  set  the  width  in  pixels  use  the
       "set_column_pixels()" method, see below.

       Unfortunately,  there  is no way to specify "AutoFit" for a column in the Excel file format. This feature
       is only available at runtime from within Excel.

       As usual the $format parameter is optional, for additional information, see  "CELL  FORMATTING".  If  you
       wish to set the format without changing the width you can pass "undef" as the width parameter:

           $worksheet-&gt;set_column( 0, 0, undef, $format );

       The $format parameter will be applied to any cells in the column that don't have a format. For example

           $worksheet-&gt;set_column( 'A:A', undef, $format1 );    # Set format for col 1
           $worksheet-&gt;write( 'A1', 'Hello' );                  # Defaults to $format1
           $worksheet-&gt;write( 'A2', 'Hello', $format2 );        # Keeps $format2

       If  you  wish  to  define  a  column  format  in  this way you should call the method before any calls to
       "write()". If you call it afterwards it won't have any effect.

       A default row format takes precedence over a default column format

           $worksheet-&gt;set_row( 0, undef, $format1 );           # Set format for row 1
           $worksheet-&gt;set_column( 'A:A', undef, $format2 );    # Set format for col 1
           $worksheet-&gt;write( 'A1', 'Hello' );                  # Defaults to $format1
           $worksheet-&gt;write( 'A2', 'Hello' );                  # Defaults to $format2

       The $hidden parameter should be set to 1 if you wish to hide a column. This can be used, for example,  to
       hide intermediary steps in a complicated calculation:

           $worksheet-&gt;set_column( 'D:D', 20,    $format, 1 );
           $worksheet-&gt;set_column( 'E:E', undef, undef,   1 );

       The  $level parameter is used to set the outline level of the column. Outlines are described in "OUTLINES
       AND GROUPING IN EXCEL". Adjacent columns with the same outline level are grouped together into  a  single
       outline.

       The following example sets an outline level of 1 for columns B to G:

           $worksheet-&gt;set_column( 'B:G', undef, undef, 0, 1 );

       The  $hidden  parameter can also be used to hide collapsed outlined columns when used in conjunction with
       the $level parameter.

           $worksheet-&gt;set_column( 'B:G', undef, undef, 1, 1 );

       For collapsed outlines you should also indicate which row has the collapsed "+" symbol using the optional
       $collapsed parameter.

           $worksheet-&gt;set_column( 'H:H', undef, undef, 0, 0, 1 );

       For a more complete example see the "outline.pl" and  "outline_collapsed.pl"  programs  in  the  examples
       directory of the distro.

       Excel  allows  up to 7 outline levels. Therefore the $level parameter should be in the range "0 &lt;= $level
       &lt;= 7".

   <b>set_column_pixels(</b> <b>$first_col,</b> <b>$last_col,</b> <b>$width,</b> <b>$format,</b> <b>$hidden,</b> <b>$level,</b> <b>$collapsed</b> <b>)</b>
       This method is the same as "set_column()" except that $width is in pixels.

           $worksheet-&gt;set_column( 0, 0, 10 );    # Column A width set to 20 in character units
           $worksheet-&gt;set_column( 1, 1, 75 );    # Column B set to the same width in pixels

   <b>set_default_row(</b> <b>$height,</b> <b>$hide_unused_rows</b> <b>)</b>
       The "set_default_row()" method is used to set the limited number of default  row  properties  allowed  by
       Excel. These are the default height and the option to hide unused rows.

           $worksheet-&gt;set_default_row( 24 );  # Set the default row height to 24.

       The  option  to  hide  unused  rows is used by Excel as an optimisation so that the user can hide a large
       number of rows without generating a very large file with an entry for each hidden row.

           $worksheet-&gt;set_default_row( undef, 1 );

       See the "hide_row_col.pl" example program.

   <b>outline_settings(</b> <b>$visible,</b> <b>$symbols_below,</b> <b>$symbols_right,</b> <b>$auto_style</b> <b>)</b>
       The "outline_settings()" method is used to control the appearance of  outlines  in  Excel.  Outlines  are
       described in "OUTLINES AND GROUPING IN EXCEL".

       The  $visible parameter is used to control whether or not outlines are visible. Setting this parameter to
       0 will cause all outlines on the worksheet to be hidden. They can be unhidden in Excel by  means  of  the
       "Show Outline Symbols" command button. The default setting is 1 for visible outlines.

           $worksheet-&gt;outline_settings( 0 );

       The $symbols_below parameter is used to control whether the row outline symbol will appear above or below
       the outline level bar. The default setting is 1 for symbols to appear below the outline level bar.

       The $symbols_right parameter is used to control whether the column outline symbol will appear to the left
       or the right of the outline level bar. The default setting is 1 for symbols to appear to the right of the
       outline level bar.

       The  $auto_style  parameter  is  used  to  control  whether the automatic outline generator in Excel uses
       automatic  styles  when  creating  an  outline.  This  has   no   effect   on   a   file   generated   by
       "Excel::Writer::XLSX"  but  it  does have an effect on how the worksheet behaves after it is created. The
       default setting is 0 for "Automatic Styles" to be turned off.

       The default settings for all of these parameters correspond to Excel's default parameters.

       The worksheet parameters controlled by "outline_settings()" are rarely used.

   <b>freeze_panes(</b> <b>$row,</b> <b>$col,</b> <b>$top_row,</b> <b>$left_col</b> <b>)</b>
       This method can be used to divide a worksheet into horizontal or vertical regions known as panes  and  to
       also  "freeze"  these  panes  so  that  the  splitter  bars  are  not  visible.  This  is the same as the
       "Window-&gt;Freeze Panes" menu command in Excel

       The parameters $row and $col are used to specify the location of the split. It should be noted  that  the
       split  is  specified at the top or left of a cell and that the method uses zero based indexing. Therefore
       to freeze the first row of a worksheet it is necessary to specify the split at row 2 (which is 1  as  the
       zero-based  index).  This  might lead you to think that you are using a 1 based index but this is not the
       case.

       You can set one of the $row and $col parameters as  zero  if  you  do  not  want  either  a  vertical  or
       horizontal split.

       Examples:

           $worksheet-&gt;freeze_panes( 1, 0 );    # Freeze the first row
           $worksheet-&gt;freeze_panes( 'A2' );    # Same using A1 notation
           $worksheet-&gt;freeze_panes( 0, 1 );    # Freeze the first column
           $worksheet-&gt;freeze_panes( 'B1' );    # Same using A1 notation
           $worksheet-&gt;freeze_panes( 1, 2 );    # Freeze first row and first 2 columns
           $worksheet-&gt;freeze_panes( 'C2' );    # Same using A1 notation

       The  parameters  $top_row  and $left_col are optional. They are used to specify the top-most or left-most
       visible row or column in the scrolling region of the panes. For example to freeze the first  row  and  to
       have the scrolling region begin at row twenty:

           $worksheet-&gt;freeze_panes( 1, 0, 20, 0 );

       You cannot use A1 notation for the $top_row and $left_col parameters.

       See also the "panes.pl" program in the "examples" directory of the distribution.

   <b>split_panes(</b> <b>$y,</b> <b>$x,</b> <b>$top_row,</b> <b>$left_col</b> <b>)</b>
       This  method  can  be used to divide a worksheet into horizontal or vertical regions known as panes. This
       method is different from the "freeze_panes()" method in that the splits between the panes will be visible
       to the user and each pane will have its own scroll bars.

       The parameters $y and $x are used to specify the vertical and horizontal position of the split. The units
       for $y and $x are the same as those used by Excel to specify row height and column  width.  However,  the
       vertical  and  horizontal  units  are different from each other. Therefore you must specify the $y and $x
       parameters in terms of the row heights and column widths that you have set or the  default  values  which
       are 15 for a row and 8.43 for a column.

       You  can  set  one of the $y and $x parameters as zero if you do not want either a vertical or horizontal
       split. The parameters $top_row and $left_col are optional. They are used to specify the top-most or left-
       most visible row or column in the bottom-right pane.

       Example:

           $worksheet-&gt;split_panes( 15, 0,   );    # First row
           $worksheet-&gt;split_panes( 0,  8.43 );    # First column
           $worksheet-&gt;split_panes( 15, 8.43 );    # First row and column

       You cannot use A1 notation with this method.

       See also the "freeze_panes()" method and the "panes.pl"  program  in  the  "examples"  directory  of  the
       distribution.

   <b>merge_range(</b> <b>$first_row,</b> <b>$first_col,</b> <b>$last_row,</b> <b>$last_col,</b> <b>$token,</b> <b>$format</b> <b>)</b>
       The "merge_range()" method allows you to merge cells that contain other types of alignment in addition to
       the merging:

           my $format = $workbook-&gt;add_format(
               border =&gt; 6,
               valign =&gt; 'vcenter',
               align  =&gt; 'center',
           );

           $worksheet-&gt;merge_range( 'B3:D4', 'Vertical and horizontal', $format );

       "merge_range()" writes its $token argument using the worksheet "write()" method. Therefore it will handle
       numbers,  strings,  formulas  or urls as required. If you need to specify the required "write_*()" method
       use the "merge_range_type()" method, see below.

       The full possibilities of this method are shown  in  the  "merge3.pl"  to  "merge6.pl"  programs  in  the
       "examples" directory of the distribution.

   <b>merge_range_type(</b> <b>$type,</b> <b>$first_row,</b> <b>$first_col,</b> <b>$last_row,</b> <b>$last_col,</b> <b>...</b> <b>)</b>
       The "merge_range()" method, see above, uses "write()" to insert the required data into to a merged range.
       However,  there may be times where this isn't what you require so as an alternative the "merge_range_type
       ()" method allows you to specify the type of data you wish to write. For example:

           $worksheet-&gt;merge_range_type( 'number',  'B2:C2', 123,    $format1 );
           $worksheet-&gt;merge_range_type( 'string',  'B4:C4', 'foo',  $format2 );
           $worksheet-&gt;merge_range_type( 'formula', 'B6:C6', '=1+2', $format3 );

       The $type must be one of the following, which corresponds to a "write_*()" method:

           'number'
           'string'
           'formula'
           'array_formula'
           'blank'
           'rich_string'
           'date_time'
           'url'

       Any arguments after the range should be whatever the appropriate method accepts:

           $worksheet-&gt;merge_range_type( 'rich_string', 'B8:C8',
                                         'This is ', $bold, 'bold', $format4 );

       Note, you must always pass a $format object as an argument, even if it is a default format.

   <b>set_zoom(</b> <b>$scale</b> <b>)</b>
       Set the worksheet zoom factor in the range "10 &lt;= $scale &lt;= 400":

           $worksheet1-&gt;set_zoom( 50 );
           $worksheet2-&gt;set_zoom( 75 );
           $worksheet3-&gt;set_zoom( 300 );
           $worksheet4-&gt;set_zoom( 400 );

       The default zoom factor is 100. You cannot zoom to "Selection" because it is calculated by Excel at  run-
       time.

       Note,   "set_zoom()"  does  not  affect  the  scale  of  the  printed  page.  For  that  you  should  use
       "set_print_scale()".

   <b>right_to_left()</b>
       The "right_to_left()" method is used to change the default direction of the worksheet from left-to-right,
       with the A1 cell in the top left, to right-to-left, with the A1 cell in the top right.

           $worksheet-&gt;right_to_left();

       This is useful when creating Arabic, Hebrew or other near or far eastern worksheets  that  use  right-to-
       left as the default direction.

   <b>hide_zero()</b>
       The "hide_zero()" method is used to hide any zero values that appear in cells.

           $worksheet-&gt;hide_zero();

       In Excel this option is found under Tools-&gt;Options-&gt;View.

   <b>set_background(</b> <b>$filename</b> <b>)</b>
       The "set_background()" method can be used to set the background image for the worksheet:

           $worksheet-&gt;set_background( 'logo.png' )

       The "set_background()" method supports all the image formats supported by "insert_image()".

       Some  people  use  this  method  to  add  a  watermark  background  to their document. However, Microsoft
       recommends using a header image to  set  a  watermark  &lt;https://support.microsoft.com/en-us/office/add-a-
       watermark-in-excel-a372182a-d733-484e-825c-18ddf3edf009&gt;.  The  choice  of  method depends on whether you
       want the watermark to be  visible  in  normal  viewing  mode  or  just  when  the  file  is  printed.  In
       Excel::Writer::XLSX you can get the header watermark effect using "set_header()":

           $worksheet-&gt;set_header( '&amp;C&amp;G', undef, { image_center =&gt; 'watermark.png' } )

   <b>set_tab_color()</b>
       The  "set_tab_color()"  method  is used to change the colour of the worksheet tab. You can use one of the
       standard colour names provided by the Format object or a Html style "#RRGGBB" colour. See  "WORKING  WITH
       COLOURS".

           $worksheet1-&gt;set_tab_color( 'red' );
           $worksheet2-&gt;set_tab_color( '#FF6600' );

       See the "tab_colors.pl" program in the examples directory of the distro.

   <b>autofilter(</b> <b>$first_row,</b> <b>$first_col,</b> <b>$last_row,</b> <b>$last_col</b> <b>)</b>
       This  method  allows an autofilter to be added to a worksheet. An autofilter is a way of adding drop down
       lists to the headers of a 2D range of worksheet data. This allows users  to  filter  the  data  based  on
       simple criteria so that some data is shown and some is hidden.

       To add an autofilter to a worksheet:

           $worksheet-&gt;autofilter( 0, 0, 10, 3 );
           $worksheet-&gt;autofilter( 'A1:D11' );    # Same as above in A1 notation.

       Filter conditions can be applied using the "filter_column()" or "filter_column_list()" method.

       See the "autofilter.pl" program in the examples directory of the distro for a more detailed example.

   <b>filter_column(</b> <b>$column,</b> <b>$expression</b> <b>)</b>
       The  "filter_column"  method  can  be  used  to  filter  columns  in  a  autofilter range based on simple
       conditions.

       <b>NOTE:</b> It isn't sufficient to just specify the filter condition. You must also hide any  rows  that  don't
       match   the   filter   condition.   Rows   are   hidden   using   the  "set_row()"  "visible"  parameter.
       "Excel::Writer::XLSX" cannot do this automatically since it isn't  part  of  the  file  format.  See  the
       "autofilter.pl" program in the examples directory of the distro for an example.

       The conditions for the filter are specified using simple expressions:

           $worksheet-&gt;filter_column( 'A', 'x &gt; 2000' );
           $worksheet-&gt;filter_column( 'B', 'x &gt; 2000 and x &lt; 5000' );

       The $column parameter can either be a zero indexed column number or a string column name.

       The following operators are available:

           Operator        Synonyms
              ==           =   eq  =~
              !=           &lt;&gt;  ne  !=
              &gt;
              &lt;
              &gt;=
              &lt;=

              and          &amp;&amp;
              or           ||

       The  operator synonyms are just syntactic sugar to make you more comfortable using the expressions. It is
       important to remember that the expressions will be interpreted by Excel and not by perl.

       An expression can comprise a single  statement  or  two  statements  separated  by  the  "and"  and  "or"
       operators. For example:

           'x &lt;  2000'
           'x &gt;  2000'
           'x == 2000'
           'x &gt;  2000 and x &lt;  5000'
           'x == 2000 or  x == 5000'

       Filtering  of  blank or non-blank data can be achieved by using a value of "Blanks" or "NonBlanks" in the
       expression:

           'x == Blanks'
           'x == NonBlanks'

       Excel also allows some simple string matching operations:

           'x =~ b*'   # begins with b
           'x !~ b*'   # doesn't begin with b
           'x =~ *b'   # ends with b
           'x !~ *b'   # doesn't end with b
           'x =~ *b*'  # contains b
           'x !~ *b*'  # doesn't contains b

       You can also use "*" to match any character or number and "?" to match any single character or number. No
       other regular  expression  quantifier  is  supported  by  Excel's  filters.  Excel's  regular  expression
       characters can be escaped using "~".

       The  placeholder  variable  "x"  in  the  above examples can be replaced by any simple string. The actual
       placeholder name is ignored internally so the following are all equivalent:

           'x     &lt; 2000'
           'col   &lt; 2000'
           'Price &lt; 2000'

       Also, note that a filter condition can only  be  applied  to  a  column  in  a  range  specified  by  the
       "autofilter()" Worksheet method.

       See the "autofilter.pl" program in the examples directory of the distro for a more detailed example.

       <b>Note</b>  Spreadsheet::WriteExcel  supports  Top  10  style  filters.  These  aren't  currently  supported by
       Excel::Writer::XLSX but may be added later.

   <b>filter_column_list(</b> <b>$column,</b> <b>@matches</b> <b>)</b>
       Prior to Excel 2007 it was only possible to have either 1 or 2 filter conditions such as the  ones  shown
       above in the "filter_column" method.

       Excel  2007  introduced  a  new  list  style  filter where it is possible to specify 1 or more 'or' style
       criteria. For example if your column contained data for the first six months the initial  data  would  be
       displayed  as  all  selected  as  shown on the left. Then if you selected 'March', 'April' and 'May' they
       would be displayed as shown on the right.

           No criteria selected      Some criteria selected.

           [/] (Select all)          [X] (Select all)
           [/] January               [ ] January
           [/] February              [ ] February
           [/] March                 [/] March
           [/] April                 [/] April
           [/] May                   [/] May
           [/] June                  [ ] June

       The "filter_column_list()" method can be used to represent these types of filters:

           $worksheet-&gt;filter_column_list( 'A', 'March', 'April', 'May' );

       The $column parameter can either be a zero indexed column number or a string column name.

       One or more criteria can be selected:

           $worksheet-&gt;filter_column_list( 0, 'March' );
           $worksheet-&gt;filter_column_list( 1, 100, 110, 120, 130 );

       <b>NOTE:</b> It isn't sufficient to just specify the filter condition. You must also hide any  rows  that  don't
       match   the   filter   condition.   Rows   are   hidden   using   the  "set_row()"  "visible"  parameter.
       "Excel::Writer::XLSX" cannot do this automatically since it isn't  part  of  the  file  format.  See  the
       "autofilter.pl" program in the examples directory of the distro for an example.

   <b>convert_date_time(</b> <b>$date_string</b> <b>)</b>
       The  "convert_date_time()"  method  is  used internally by the "write_date_time()" method to convert date
       strings to a number that represents an Excel date and time.

       It is exposed as a public method for utility purposes.

       The $date_string format is detailed in the "write_date_time()" method.

   <b>set_vba_name()</b>
       The Worksheet "set_vba_name()" method can be used to set the VBA codename for the worksheet (there  is  a
       similar  method for the workbook VBA name). This is sometimes required when a "vbaProject" macro included
       via "add_vba_project()" refers to the worksheet. The default Excel VBA name of "Sheet1", etc., is used if
       a user defined name isn't specified.

       See also "WORKING WITH VBA MACROS".

   <b>ignore_errors()</b>
       The "ignore_errors()" method can be used to ignore various worksheet cell  errors/warnings.  For  example
       the following code writes a string that looks like a number:

           $worksheet-&gt;write_string('D2', '123');

       This  causes  Excel to display a small green triangle in the top left hand corner of the cell to indicate
       an error/warning.

       Sometimes these warnings are useful indicators that there is an issue in the spreadsheet but sometimes it
       is preferable to turn them off. Warnings can be turned off at the  Excel  level  for  all  workbooks  and
       worksheets  by using the using "Excel options -&gt; Formulas -&gt; Error checking rules". Alternatively you can
       turn them off for individual cells in a worksheet, or ranges of cells, using the "ignore_errors()" method
       with a hashref of options and ranges like this:

           $worksheet-&gt;ignore_errors({number_stored_as_text =&gt; 'A1:H50'});

           # Or for more than one option:
           $worksheet-&gt;ignore_errors({number_stored_as_text =&gt; 'A1:H50',
                                      eval_error =&gt;            'A1:H50'});

       The range can be a single cell, a range of cells, or multiple cells and ranges separated by spaces:

           # Single cell.
           $worksheet-&gt;ignore_errors({eval_error =&gt; 'C6'});

           # Or a single range:
           $worksheet-&gt;ignore_errors({eval_error =&gt; 'C6:G8'});

           # Or multiple cells and ranges:
           $worksheet-&gt;ignore_errors({eval_error =&gt; 'C6 E6 G1:G20 J2:J6'});

       Note: calling "ignore_errors" multiple times will overwrite the previous settings.

       You can turn off warnings for an entire column by specifying the range from the first cell in the  column
       to the last cell in the column:

           $worksheet-&gt;ignore_errors({number_stored_as_text =&gt; 'A1:A1048576'});

       Or for the entire worksheet by specifying the range from the first cell in the worksheet to the last cell
       in the worksheet:

           $worksheet-&gt;ignore_errors({number_stored_as_text =&gt; 'A1:XFD1048576'});

       The worksheet errors/warnings that can be ignored are:

       •   "number_stored_as_text": Turn off errors/warnings for numbers stores as text.

       •   "eval_error": Turn off errors/warnings for formula errors (such as divide by zero).

       •   "formula_differs": Turn off errors/warnings for formulas that differ from surrounding formulas.

       •   "formula_range": Turn off errors/warnings for formulas that omit cells in a range.

       •   "formula_unlocked": Turn off errors/warnings for unlocked cells that contain formulas.

       •   "empty_cell_reference": Turn off errors/warnings for formulas that refer to empty cells.

       •   "list_data_validation":  Turn  off  errors/warnings  for  cells  in  a  table that do not comply with
           applicable data validation rules.

       •   "calculated_column": Turn off errors/warnings for cell formulas that differ from the column formula.

       •   "two_digit_text_year":  Turn  off  errors/warnings  for  formulas  that  contain  a  two  digit  text
           representation of a year.

</pre><h4><b>PAGE</b> <b>SET-UP</b> <b>METHODS</b></h4><pre>
       Page  set-up methods affect the way that a worksheet looks when it is printed. They control features such
       as page headers and footers and margins. These methods are really just standard worksheet  methods.  They
       are documented here in a separate section for the sake of clarity.

       The following methods are available for page set-up:

           set_landscape()
           set_portrait()
           set_page_view()
           set_paper()
           center_horizontally()
           center_vertically()
           set_margins()
           set_header()
           set_footer()
           repeat_rows()
           repeat_columns()
           hide_gridlines()
           print_row_col_headers()
           print_area()
           print_across()
           fit_to_pages()
           set_start_page()
           set_print_scale()
           print_black_and_white()
           set_h_pagebreaks()
           set_v_pagebreaks()

       A  common  requirement when working with Excel::Writer::XLSX is to apply the same page set-up features to
       all of the worksheets in a workbook. To do this you can use the "sheets()" method of the "workbook" class
       to access the array of worksheets in a workbook:

           for $worksheet ( $workbook-&gt;sheets() ) {
               $worksheet-&gt;set_landscape();
           }

   <b>set_landscape()</b>
       This method is used to set the orientation of a worksheet's printed page to landscape:

           $worksheet-&gt;set_landscape();    # Landscape mode

   <b>set_portrait()</b>
       This method is used to set the orientation of  a  worksheet's  printed  page  to  portrait.  The  default
       worksheet orientation is portrait, so you won't generally need to call this method.

           $worksheet-&gt;set_portrait();    # Portrait mode

   <b>set_page_view()</b>
       This method is used to display the worksheet in "Page View/Layout" mode.

           $worksheet-&gt;set_page_view();

   <b>set_paper(</b> <b>$index</b> <b>)</b>
       This  method  is  used to set the paper format for the printed output of a worksheet. The following paper
       styles are available:

           Index   Paper format            Paper size
           =====   ============            ==========
             0     Printer default         -
             1     Letter                  8 1/2 x 11 in
             2     Letter Small            8 1/2 x 11 in
             3     Tabloid                 11 x 17 in
             4     Ledger                  17 x 11 in
             5     Legal                   8 1/2 x 14 in
             6     Statement               5 1/2 x 8 1/2 in
             7     Executive               7 1/4 x 10 1/2 in
             8     A3                      297 x 420 mm
             9     A4                      210 x 297 mm
            10     A4 Small                210 x 297 mm
            11     A5                      148 x 210 mm
            12     B4                      250 x 354 mm
            13     B5                      182 x 257 mm
            14     Folio                   8 1/2 x 13 in
            15     Quarto                  215 x 275 mm
            16     -                       10x14 in
            17     -                       11x17 in
            18     Note                    8 1/2 x 11 in
            19     Envelope  9             3 7/8 x 8 7/8
            20     Envelope 10             4 1/8 x 9 1/2
            21     Envelope 11             4 1/2 x 10 3/8
            22     Envelope 12             4 3/4 x 11
            23     Envelope 14             5 x 11 1/2
            24     C size sheet            -
            25     D size sheet            -
            26     E size sheet            -
            27     Envelope DL             110 x 220 mm
            28     Envelope C3             324 x 458 mm
            29     Envelope C4             229 x 324 mm
            30     Envelope C5             162 x 229 mm
            31     Envelope C6             114 x 162 mm
            32     Envelope C65            114 x 229 mm
            33     Envelope B4             250 x 353 mm
            34     Envelope B5             176 x 250 mm
            35     Envelope B6             176 x 125 mm
            36     Envelope                110 x 230 mm
            37     Monarch                 3.875 x 7.5 in
            38     Envelope                3 5/8 x 6 1/2 in
            39     Fanfold                 14 7/8 x 11 in
            40     German Std Fanfold      8 1/2 x 12 in
            41     German Legal Fanfold    8 1/2 x 13 in

       Note, it is likely that not all of these paper types will be available to the  end  user  since  it  will
       depend  on the paper formats that the user's printer supports. Therefore, it is best to stick to standard
       paper types.

           $worksheet-&gt;set_paper( 1 );    # US Letter
           $worksheet-&gt;set_paper( 9 );    # A4

       If you do not specify a paper type the worksheet will print using the printer's default paper.

   <b>center_horizontally()</b>
       Center the worksheet data horizontally between the margins on the printed page:

           $worksheet-&gt;center_horizontally();

   <b>center_vertically()</b>
       Center the worksheet data vertically between the margins on the printed page:

           $worksheet-&gt;center_vertically();

   <b>set_margins(</b> <b>$inches</b> <b>)</b>
       There are several methods available for setting the worksheet margins on the printed page:

           set_margins()        # Set all margins to the same value
           set_margins_LR()     # Set left and right margins to the same value
           set_margins_TB()     # Set top and bottom margins to the same value
           set_margin_left();   # Set left margin
           set_margin_right();  # Set right margin
           set_margin_top();    # Set top margin
           set_margin_bottom(); # Set bottom margin

       All of these methods take a distance in inches as a parameter. Note: 1 inch = 25.4mm. ";-)"  The  default
       left  and  right margin is 0.7 inch. The default top and bottom margin is 0.75 inch. Note, these defaults
       are different from the defaults used in the binary file format by Spreadsheet::WriteExcel.

   <b>set_header(</b> <b>$string,</b> <b>$margin</b> <b>)</b>
       Headers and footers are generated using a $string which is  a  combination  of  plain  text  and  control
       characters. The $margin parameter is optional.

       The available control character are:

           Control             Category            Description
           =======             ========            ===========
           &amp;L                  Justification       Left
           &amp;C                                      Center
           &amp;R                                      Right

           &amp;P                  Information         Page number
           &amp;N                                      Total number of pages
           &amp;D                                      Date
           &amp;T                                      Time
           &amp;F                                      File name
           &amp;A                                      Worksheet name
           &amp;Z                                      Workbook path

           &amp;fontsize           Font                Font size
           &amp;"font,style"                           Font name and style
           &amp;U                                      Single underline
           &amp;E                                      Double underline
           &amp;S                                      Strikethrough
           &amp;X                                      Superscript
           &amp;Y                                      Subscript

           &amp;[Picture]          Images              Image placeholder
           &amp;G                                      Same as &amp;[Picture]

           &amp;&amp;                  Miscellaneous       Literal ampersand &amp;

       Text  in  headers  and  footers can be justified (aligned) to the left, center and right by prefixing the
       text with the control characters &amp;L, &amp;C and &amp;R.

       For example (with ASCII art representation of the results):

           $worksheet-&gt;set_header('&amp;LHello');

            ---------------------------------------------------------------
           |                                                               |
           | Hello                                                         |
           |                                                               |

           $worksheet-&gt;set_header('&amp;CHello');

            ---------------------------------------------------------------
           |                                                               |
           |                          Hello                                |
           |                                                               |

           $worksheet-&gt;set_header('&amp;RHello');

            ---------------------------------------------------------------
           |                                                               |
           |                                                         Hello |
           |                                                               |

       For simple text, if you do not specify any justification the text will  be  centred.  However,  you  must
       prefix the text with &amp;C if you specify a font name or any other formatting:

           $worksheet-&gt;set_header('Hello');

            ---------------------------------------------------------------
           |                                                               |
           |                          Hello                                |
           |                                                               |

       You can have text in each of the justification regions:

           $worksheet-&gt;set_header('&amp;LCiao&amp;CBello&amp;RCielo');

            ---------------------------------------------------------------
           |                                                               |
           | Ciao                     Bello                          Cielo |
           |                                                               |

       The  information  control characters act as variables that Excel will update as the workbook or worksheet
       changes. Times and dates are in the users default format:

           $worksheet-&gt;set_header('&amp;CPage &amp;P of &amp;N');

            ---------------------------------------------------------------
           |                                                               |
           |                        Page 1 of 6                            |
           |                                                               |

           $worksheet-&gt;set_header('&amp;CUpdated at &amp;T');

            ---------------------------------------------------------------
           |                                                               |
           |                    Updated at 12:30 PM                        |
           |                                                               |

       Images can be inserted using the options shown below. Each image must have a placeholder in header string
       using the "&amp;[Picture]" or &amp;G control characters:

           $worksheet-&gt;set_header( '&amp;L&amp;G', 0.3, { image_left =&gt; 'logo.jpg' });

       You can specify the font size of a section of the text by prefixing it  with  the  control  character  &amp;n
       where "n" is the font size:

           $worksheet1-&gt;set_header( '&amp;C&amp;30Hello Big' );
           $worksheet2-&gt;set_header( '&amp;C&amp;10Hello Small' );

       You  can  specify  the  font  of  a  section  of  the  text  by  prefixing  it  with the control sequence
       "&amp;"font,style"" where "fontname" is a font name such as "Courier New" or "Times New Roman" and "style" is
       one of the standard Windows font descriptions: "Regular", "Italic", "Bold" or "Bold Italic":

           $worksheet1-&gt;set_header( '&amp;C&amp;"Courier New,Italic"Hello' );
           $worksheet2-&gt;set_header( '&amp;C&amp;"Courier New,Bold Italic"Hello' );
           $worksheet3-&gt;set_header( '&amp;C&amp;"Times New Roman,Regular"Hello' );

       It is possible to combine all of these features together to create sophisticated headers and footers.  As
       an aid to setting up complicated headers and footers you can record a page set-up as a macro in Excel and
       look  at  the  format  strings  that VBA produces. Remember however that VBA uses two double quotes "" to
       indicate a single double quote. For the last example above the equivalent VBA code looks like this:

           .LeftHeader   = ""
           .CenterHeader = "&amp;""Times New Roman,Regular""Hello"
           .RightHeader  = ""

       To include a single literal ampersand "&amp;" in a header or footer you should use a double ampersand "&amp;&amp;":

           $worksheet1-&gt;set_header('&amp;CCuriouser &amp;&amp; Curiouser - Attorneys at Law');

       As stated above the margin parameter is optional. As with the  other  margins  the  value  should  be  in
       inches.  The default header and footer margin is 0.3 inch. Note, the default margin is different from the
       default used in the binary file format by Spreadsheet::WriteExcel. The header and footer margin size  can
       be set as follows:

           $worksheet-&gt;set_header( '&amp;CHello', 0.75 );

       The header and footer margins are independent of the top and bottom margins.

       The available options are:

       •   "image_left" The path to the image. Requires a &amp;G or "&amp;[Picture]" placeholder.

       •   "image_center" Same as above.

       •   "image_right" Same as above.

       •   "scale_with_doc" Scale header with document. Defaults to true.

       •   "align_with_margins" Align header to margins. Defaults to true.

       The image options must have an accompanying "&amp;[Picture]" or &amp;G control character in the header string:

           $worksheet-&gt;set_header(
               '&amp;L&amp;[Picture]&amp;C&amp;[Picture]&amp;R&amp;[Picture]',
               undef, # If you don't want to change the margin.
               {
                   image_left   =&gt; 'red.jpg',
                   image_center =&gt; 'blue.jpg',
                   image_right  =&gt; 'yellow.jpg'
               }
             );

       Note,  the header or footer string must be less than 255 characters. Strings longer than this will not be
       written and a warning will be generated.

       The "set_header()" method can also handle Unicode strings in "UTF-8" format.

           $worksheet-&gt;set_header( "&amp;C\x{263a}" )

       See, also the "headers.pl" program in the "examples" directory of the distribution.

   <b>set_footer(</b> <b>$string,</b> <b>$margin</b> <b>)</b>
       The syntax of the "set_footer()" method is the same as "set_header()",  see above.

   <b>repeat_rows(</b> <b>$first_row,</b> <b>$last_row</b> <b>)</b>
       Set the number of rows to repeat at the top of each printed page.

       For large Excel documents it is often desirable to have the first row or rows of the worksheet print  out
       at  the  top  of  each  page.  This  can  be achieved by using the "repeat_rows()" method. The parameters
       $first_row and $last_row are zero based. The $last_row parameter is optional if you only wish to  specify
       one row:

           $worksheet1-&gt;repeat_rows( 0 );    # Repeat the first row
           $worksheet2-&gt;repeat_rows( 0, 1 ); # Repeat the first two rows

   <b>repeat_columns(</b> <b>$first_col,</b> <b>$last_col</b> <b>)</b>
       Set the columns to repeat at the left hand side of each printed page.

       For  large  Excel  documents  it  is often desirable to have the first column or columns of the worksheet
       print out at the left hand side of each page. This  can  be  achieved  by  using  the  "repeat_columns()"
       method.  The  parameters  $first_column  and  $last_column  are zero based. The $last_column parameter is
       optional if you only wish to specify one column. You  can  also  specify  the  columns  using  A1  column
       notation, see the note about "Cell notation".

           $worksheet1-&gt;repeat_columns( 0 );        # Repeat the first column
           $worksheet2-&gt;repeat_columns( 0, 1 );     # Repeat the first two columns
           $worksheet3-&gt;repeat_columns( 'A:A' );    # Repeat the first column
           $worksheet4-&gt;repeat_columns( 'A:B' );    # Repeat the first two columns

   <b>hide_gridlines(</b> <b>$option</b> <b>)</b>
       This  method  is  used to hide the gridlines on the screen and printed page. Gridlines are the lines that
       divide the cells on a worksheet. Screen and printed gridlines are  turned  on  by  default  in  an  Excel
       worksheet. If you have defined your own cell borders you may wish to hide the default gridlines.

           $worksheet-&gt;hide_gridlines();

       The following values of $option are valid:

           0 : Don't hide gridlines
           1 : Hide printed gridlines only
           2 : Hide screen and printed gridlines

       If  you  don't supply an argument or use "undef" the default option is 1, i.e. only the printed gridlines
       are hidden.

   <b>print_row_col_headers()</b>
       Set the option to print the row and column headers on the printed page.

       An Excel worksheet looks something like the following;

            ------------------------------------------
           |   |   A   |   B   |   C   |   D   |  ...
            ------------------------------------------
           | 1 |       |       |       |       |  ...
           | 2 |       |       |       |       |  ...
           | 3 |       |       |       |       |  ...
           | 4 |       |       |       |       |  ...
           |...|  ...  |  ...  |  ...  |  ...  |  ...

       The headers are the letters and numbers at the top and the left of the  worksheet.  Since  these  headers
       serve  mainly  as  a  indication of position on the worksheet they generally do not appear on the printed
       page. If you wish to have them printed you can use the "print_row_col_headers()" method:

           $worksheet-&gt;print_row_col_headers();

       Do not confuse these headers with page headers as described in the "set_header()" section above.

   <b>hide_row_col_headers()</b>
       Similar to "print_row_col_headers()" above but set the option to hide the row and column  headers  within
       Excel so that they aren't visible to the user:

           $worksheet-&gt;hide_row_col_headers();

   <b>print_area(</b> <b>$first_row,</b> <b>$first_col,</b> <b>$last_row,</b> <b>$last_col</b> <b>)</b>
       This  method  is used to specify the area of the worksheet that will be printed. All four parameters must
       be specified. You can also use A1 notation, see the note about "Cell notation".

           $worksheet1-&gt;print_area( 'A1:H20' );    # Cells A1 to H20
           $worksheet2-&gt;print_area( 0, 0, 19, 7 ); # The same
           $worksheet2-&gt;print_area( 'A:H' );       # Columns A to H if rows have data

   <b>print_across()</b>
       The "print_across" method is used to change the default print direction. This is referred to by Excel  as
       the sheet "page order".

           $worksheet-&gt;print_across();

       The  default  page  order  is  shown below for a worksheet that extends over 4 pages. The order is called
       "down then across":

           [1] [3]
           [2] [4]

       However, by using the "print_across" method the print order will be changed to "across then down":

           [1] [2]
           [3] [4]

   <b>fit_to_pages(</b> <b>$width,</b> <b>$height</b> <b>)</b>
       The "fit_to_pages()" method is used to fit the printed area to a specific number of pages both vertically
       and horizontally. If the printed area exceeds the specified number of pages it will  be  scaled  down  to
       fit.  This  guarantees  that the printed area will always appear on the specified number of pages even if
       the page size or margins change.

           $worksheet1-&gt;fit_to_pages( 1, 1 );    # Fit to 1x1 pages
           $worksheet2-&gt;fit_to_pages( 2, 1 );    # Fit to 2x1 pages
           $worksheet3-&gt;fit_to_pages( 1, 2 );    # Fit to 1x2 pages

       The print area can be defined using the "print_area()" method as described above.

       A common requirement is to fit the printed output to <u>n</u> pages wide but have  the  height  be  as  long  as
       necessary. To achieve this set the $height to zero:

           $worksheet1-&gt;fit_to_pages( 1, 0 );    # 1 page wide and as long as necessary

       Note that although it is valid to use both "fit_to_pages()" and "set_print_scale()" on the same worksheet
       only one of these options can be active at a time. The last method call made will set the active option.

       Note that "fit_to_pages()" will override any manual page breaks that are defined in the worksheet.

       Note:  When  using  "fit_to_pages()"  it  may  also  be  required  to  set  the  printer paper size using
       "set_paper()" or else Excel will default to "US Letter".

   <b>set_start_page(</b> <b>$start_page</b> <b>)</b>
       The "set_start_page()" method is used to set the number of  the  starting  page  when  the  worksheet  is
       printed out. The default value is 1.

           $worksheet-&gt;set_start_page( 2 );

   <b>set_print_scale(</b> <b>$scale</b> <b>)</b>
       Set the scale factor of the printed page. Scale factors in the range "10 &lt;= $scale &lt;= 400" are valid:

           $worksheet1-&gt;set_print_scale( 50 );
           $worksheet2-&gt;set_print_scale( 75 );
           $worksheet3-&gt;set_print_scale( 300 );
           $worksheet4-&gt;set_print_scale( 400 );

       The  default scale factor is 100. Note, "set_print_scale()" does not affect the scale of the visible page
       in Excel. For that you should use "set_zoom()".

       Note also that although it is valid to use both "fit_to_pages()"  and  "set_print_scale()"  on  the  same
       worksheet  only  one  of  these  options  can be active at a time. The last method call made will set the
       active option.

   <b>print_black_and_white()</b>
       Set the option to print the worksheet in black and white:

           $worksheet-&gt;print_black_and_white();

   <b>set_h_pagebreaks(</b> <b>@breaks</b> <b>)</b>
       Add horizontal page breaks to a worksheet. A page break causes all the data that follows it to be printed
       on the next page. Horizontal page breaks act between rows. To create a page break between rows 20 and  21
       you  must specify the break at row 21. However in zero index notation this is actually row 20. So you can
       pretend for a small while that you are using 1 index notation:

           $worksheet1-&gt;set_h_pagebreaks( 20 );    # Break between row 20 and 21

       The "set_h_pagebreaks()" method will accept a list of page breaks and you can call it more than once:

           $worksheet2-&gt;set_h_pagebreaks( 20,  40,  60,  80,  100 );    # Add breaks
           $worksheet2-&gt;set_h_pagebreaks( 120, 140, 160, 180, 200 );    # Add some more

       Note: If you specify the "fit to page" option via the "fit_to_pages()" method it will override all manual
       page breaks.

       There is a silent limitation of about 1000 horizontal page breaks per worksheet in  line  with  an  Excel
       internal limitation.

   <b>set_v_pagebreaks(</b> <b>@breaks</b> <b>)</b>
       Add  vertical  page breaks to a worksheet. A page break causes all the data that follows it to be printed
       on the next page. Vertical page breaks act between columns. To create a page break between columns 20 and
       21 you must specify the break at column 21. However in zero index notation this is actually column 20. So
       you can pretend for a small while that you are using 1 index notation:

           $worksheet1-&gt;<a href="../man20/set_v_pagebreaks.20.html">set_v_pagebreaks</a>(20); # Break between column 20 and 21

       The "set_v_pagebreaks()" method will accept a list of page breaks and you can call it more than once:

           $worksheet2-&gt;set_v_pagebreaks( 20,  40,  60,  80,  100 );    # Add breaks
           $worksheet2-&gt;set_v_pagebreaks( 120, 140, 160, 180, 200 );    # Add some more

       Note: If you specify the "fit to page" option via the "fit_to_pages()" method it will override all manual
       page breaks.

</pre><h4><b>CELL</b> <b>FORMATTING</b></h4><pre>
       This section describes the methods and properties that are available for formatting cells in  Excel.  The
       properties  of  a  cell  that  can be formatted include: fonts, colours, patterns, borders, alignment and
       number formatting.

   <b>Creating</b> <b>and</b> <b>using</b> <b>a</b> <b>Format</b> <b>object</b>
       Cell formatting is defined through a Format object. Format objects are created by  calling  the  workbook
       "add_format()" method as follows:

           my $format1 = $workbook-&gt;add_format();            # Set properties later
           my $format2 = $workbook-&gt;add_format( %props );    # Set at creation

       The  format  object holds all the formatting properties that can be applied to a cell, a row or a column.
       The process of setting these properties is discussed in the next section.

       Once a Format object has been constructed and its properties have  been  set  it  can  be  passed  as  an
       argument to the worksheet "write" methods as follows:

           $worksheet-&gt;write( 0, 0, 'One', $format );
           $worksheet-&gt;write_string( 1, 0, 'Two', $format );
           $worksheet-&gt;write_number( 2, 0, 3, $format );
           $worksheet-&gt;write_blank( 3, 0, $format );

       Formats  can also be passed to the worksheet "set_row()" and "set_column()" methods to define the default
       property for a row or column.

           $worksheet-&gt;set_row( 0, 15, $format );
           $worksheet-&gt;set_column( 0, 0, 15, $format );

   <b>Format</b> <b>methods</b> <b>and</b> <b>Format</b> <b>properties</b>
       The following table shows the Excel format categories, the formatting properties that can be applied  and
       the equivalent object method:

           Category   Description       Property        Method Name
           --------   -----------       --------        -----------
           Font       Font type         font            set_font()
                      Font size         size            set_size()
                      Font color        color           set_color()
                      Bold              bold            set_bold()
                      Italic            italic          set_italic()
                      Underline         underline       set_underline()
                      Strikeout         font_strikeout  set_font_strikeout()
                      Super/Subscript   font_script     set_font_script()
                      Outline           font_outline    set_font_outline()
                      Shadow            font_shadow     set_font_shadow()

           Number     Numeric format    num_format      set_num_format()

           Protection Lock cells        locked          set_locked()
                      Hide formulas     hidden          set_hidden()

           Alignment  Horizontal align  align           set_align()
                      Vertical align    valign          set_align()
                      Rotation          rotation        set_rotation()
                      Text wrap         text_wrap       set_text_wrap()
                      Justify last      text_justlast   set_text_justlast()
                      Center across     center_across   set_center_across()
                      Indentation       indent          set_indent()
                      Shrink to fit     shrink          set_shrink()

           Pattern    Cell pattern      pattern         set_pattern()
                      Background color  bg_color        set_bg_color()
                      Foreground color  fg_color        set_fg_color()

           Border     Cell border       border          set_border()
                      Bottom border     bottom          set_bottom()
                      Top border        top             set_top()
                      Left border       left            set_left()
                      Right border      right           set_right()
                      Border color      border_color    set_border_color()
                      Bottom color      bottom_color    set_bottom_color()
                      Top color         top_color       set_top_color()
                      Left color        left_color      set_left_color()
                      Right color       right_color     set_right_color()
                      Diagonal type     diag_type       set_diag_type()
                      Diagonal border   diag_border     set_diag_border()
                      Diagonal color    diag_color      set_diag_color()

       There  are  two ways of setting Format properties: by using the object method interface or by setting the
       property directly. For example, a typical use of the method interface would be as follows:

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_bold();
           $format-&gt;set_color( 'red' );

       By comparison the properties can be  set  directly  by  passing  a  hash  of  properties  to  the  Format
       constructor:

           my $format = $workbook-&gt;add_format( bold =&gt; 1, color =&gt; 'red' );

       or after the Format has been constructed by means of the "set_format_properties()" method as follows:

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_format_properties( bold =&gt; 1, color =&gt; 'red' );

       You can also store the properties in one or more named hashes and pass them to the required method:

           my %font = (
               font  =&gt; 'Calibri',
               size  =&gt; 12,
               color =&gt; 'blue',
               bold  =&gt; 1,
           );

           my %shading = (
               bg_color =&gt; 'green',
               pattern  =&gt; 1,
           );

           my $format1 = $workbook-&gt;add_format( %font );            # Font only
           my $format2 = $workbook-&gt;add_format( %font, %shading );  # Font and shading

       The  provision  of  two  ways  of  setting properties might lead you to wonder which is the best way. The
       method mechanism may be better if you prefer setting properties via method calls (which  the  author  did
       when  the  code  was  first  written)  otherwise passing properties to the constructor has proved to be a
       little more flexible and self documenting in practice. An additional advantage of working  with  property
       hashes is that it allows you to share formatting between workbook objects as shown in the example above.

       The Perl/Tk style of adding properties is also supported:

           my %font = (
               -font  =&gt; 'Calibri',
               -size  =&gt; 12,
               -color =&gt; 'blue',
               -bold  =&gt; 1,
           );

   <b>Working</b> <b>with</b> <b>formats</b>
       The default format is Calibri 11 with all other properties off.

       Each  unique  format in Excel::Writer::XLSX must have a corresponding Format object. It isn't possible to
       use a Format with a <b>write()</b> method and then redefine the Format for use at a later stage. This is because
       a Format is applied to a cell not in its current state but in its final  state.  Consider  the  following
       example:

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_bold();
           $format-&gt;set_color( 'red' );
           $worksheet-&gt;write( 'A1', 'Cell A1', $format );
           $format-&gt;set_color( 'green' );
           $worksheet-&gt;write( 'B1', 'Cell B1', $format );

       Cell  A1  is assigned the Format $format which is initially set to the colour red. However, the colour is
       subsequently set to green. When Excel displays Cell A1 it will display the  final  state  of  the  Format
       which in this case will be the colour green.

       In general a method call without an argument will turn a property on, for example:

           my $format1 = $workbook-&gt;add_format();
           $format1-&gt;set_bold();       # Turns bold on
           $format1-&gt;set_bold( 1 );    # Also turns bold on
           $format1-&gt;set_bold( 0 );    # Turns bold off

</pre><h4><b>FORMAT</b> <b>METHODS</b></h4><pre>
       The Format object methods are described in more detail in the following sections. In addition, there is a
       Perl program called "formats.pl" in the "examples" directory of the WriteExcel distribution. This program
       creates an Excel workbook called "formats.xlsx" which contains examples of almost all the format types.

       The following Format methods are available:

           set_font()
           set_size()
           set_color()
           set_bold()
           set_italic()
           set_underline()
           set_font_strikeout()
           set_font_script()
           set_font_outline()
           set_font_shadow()
           set_num_format()
           set_locked()
           set_hidden()
           set_align()
           set_rotation()
           set_text_wrap()
           set_text_justlast()
           set_center_across()
           set_indent()
           set_shrink()
           set_pattern()
           set_bg_color()
           set_fg_color()
           set_border()
           set_bottom()
           set_top()
           set_left()
           set_right()
           set_border_color()
           set_bottom_color()
           set_top_color()
           set_left_color()
           set_right_color()
           set_diag_type()
           set_diag_border()
           set_diag_color()

       The  above  methods  can  also  be  applied  directly as properties. For example "$format-&gt;set_bold()" is
       equivalent to "$workbook-&gt;add_format(bold =&gt; 1)".

   <b>set_format_properties(</b> <b>%properties</b> <b>)</b>
       The properties of an existing Format object can be also be set by means of "set_format_properties()":

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_format_properties( bold =&gt; 1, color =&gt; 'red' );

       However, this method is here mainly for legacy reasons. It is preferable to set  the  properties  in  the
       format constructor:

           my $format = $workbook-&gt;add_format( bold =&gt; 1, color =&gt; 'red' );

   <b>set_font(</b> <b>$fontname</b> <b>)</b>
           Default state:      Font is Calibri
           Default action:     None
           Valid args:         Any valid font name

       Specify the font used:

           $format-&gt;set_font('Times New Roman');

       Excel can only display fonts that are installed on the system that it is running on. Therefore it is best
       to  use  the fonts that come as standard such as 'Calibri', 'Times New Roman' and 'Courier New'. See also
       the Fonts worksheet created by formats.pl

   <b>set_size()</b>
           Default state:      Font size is 10
           Default action:     Set font size to 1
           Valid args:         Integer values from 1 to as big as your screen.

       Set the font size. Excel adjusts the height of a row to accommodate the largest font size in the row. You
       can also explicitly specify the height of a row using the <b>set_row()</b> worksheet method.

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_size( 30 );

   <b>set_color()</b>
           Default state:      Excels default color, usually black
           Default action:     Set the default color
           Valid args:         Integers from 8..63 or the following strings:
                               'black'
                               'blue'
                               'brown'
                               'cyan'
                               'gray'
                               'green'
                               'lime'
                               'magenta'
                               'navy'
                               'orange'
                               'pink'
                               'purple'
                               'red'
                               'silver'
                               'white'
                               'yellow'

       Set the font colour. The "set_color()" method is used as follows:

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_color( 'red' );
           $worksheet-&gt;write( 0, 0, 'wheelbarrow', $format );

       Note: The "set_color()" method is used to set the colour of the font in a cell. To set the  colour  of  a
       cell use the "set_bg_color()" and "set_pattern()" methods.

       For  additional examples see the 'Named colors' and 'Standard colors' worksheets created by formats.pl in
       the examples directory.

       See also "WORKING WITH COLOURS".

   <b>set_bold()</b>
           Default state:      bold is off
           Default action:     Turn bold on
           Valid args:         0, 1

       Set the bold property of the font:

           $format-&gt;set_bold();  # Turn bold on

   <b>set_italic()</b>
           Default state:      Italic is off
           Default action:     Turn italic on
           Valid args:         0, 1

       Set the italic property of the font:

           $format-&gt;set_italic();  # Turn italic on

   <b>set_underline()</b>
           Default state:      Underline is off
           Default action:     Turn on single underline
           Valid args:         0  = No underline
                               1  = Single underline
                               2  = Double underline
                               33 = Single accounting underline
                               34 = Double accounting underline

       Set the underline property of the font.

           $format-&gt;set_underline();   # Single underline

   <b>set_font_strikeout()</b>
           Default state:      Strikeout is off
           Default action:     Turn strikeout on
           Valid args:         0, 1

       Set the strikeout property of the font.

   <b>set_font_script()</b>
           Default state:      Super/Subscript is off
           Default action:     Turn Superscript on
           Valid args:         0  = Normal
                               1  = Superscript
                               2  = Subscript

       Set the superscript/subscript property of the font.

   <b>set_font_outline()</b>
           Default state:      Outline is off
           Default action:     Turn outline on
           Valid args:         0, 1

       Macintosh only.

   <b>set_font_shadow()</b>
           Default state:      Shadow is off
           Default action:     Turn shadow on
           Valid args:         0, 1

       Macintosh only.

   <b>set_num_format()</b>
           Default state:      General format
           Default action:     Format index 1
           Valid args:         See the following table

       This method is used to define the numerical format of a number in Excel. It controls whether a number  is
       displayed  as  an  integer,  a floating point number, a date, a currency value or some other user defined
       format.

       The numerical format of a cell can be specified by using a format string or an index to  one  of  Excel's
       built-in formats:

           my $format1 = $workbook-&gt;add_format();
           my $format2 = $workbook-&gt;add_format();
           $format1-&gt;set_num_format( 'd mmm yyyy' );    # Format string
           $format2-&gt;set_num_format( 0x0f );            # Format index

           $worksheet-&gt;write( 0, 0, 36892.521, $format1 );    # 1 Jan 2001
           $worksheet-&gt;write( 0, 0, 36892.521, $format2 );    # 1-Jan-01

       Using format strings you can define very sophisticated formatting of numbers.

           $format01-&gt;set_num_format( '0.000' );
           $worksheet-&gt;write( 0, 0, 3.1415926, $format01 );    # 3.142

           $format02-&gt;set_num_format( '#,##0' );
           $worksheet-&gt;write( 1, 0, 1234.56, $format02 );      # 1,235

           $format03-&gt;set_num_format( '#,##0.00' );
           $worksheet-&gt;write( 2, 0, 1234.56, $format03 );      # 1,234.56

           $format04-&gt;set_num_format( '$0.00' );
           $worksheet-&gt;write( 3, 0, 49.99, $format04 );        # $49.99

           # Note you can use other currency symbols such as the pound or yen as well.
           # Other currencies may require the use of Unicode.

           $format07-&gt;set_num_format( 'mm/dd/yy' );
           $worksheet-&gt;write( 6, 0, 36892.521, $format07 );    # 01/01/01

           $format08-&gt;set_num_format( 'mmm d yyyy' );
           $worksheet-&gt;write( 7, 0, 36892.521, $format08 );    # Jan 1 2001

           $format09-&gt;set_num_format( 'd mmmm yyyy' );
           $worksheet-&gt;write( 8, 0, 36892.521, $format09 );    # 1 January 2001

           $format10-&gt;set_num_format( 'dd/mm/yyyy hh:mm AM/PM' );
           $worksheet-&gt;write( 9, 0, 36892.521, $format10 );    # 01/01/2001 12:30 AM

           $format11-&gt;set_num_format( '0 "dollar and" .00 "cents"' );
           $worksheet-&gt;write( 10, 0, 1.87, $format11 );        # 1 dollar and .87 cents

           # Conditional numerical formatting.
           $format12-&gt;set_num_format( '[Green]General;[Red]-General;General' );
           $worksheet-&gt;write( 11, 0, 123, $format12 );         # &gt; 0 Green
           $worksheet-&gt;write( 12, 0, -45, $format12 );         # &lt; 0 Red
           $worksheet-&gt;write( 13, 0, 0,   $format12 );         # = 0 Default colour

           # Zip code
           $format13-&gt;set_num_format( '00000' );
           $worksheet-&gt;write( 14, 0, '01209', $format13 );

       The number system used for dates is described in "DATES AND TIME IN EXCEL".

       The colour format should have one of the following values:

           [Black] [Blue] [Cyan] [Green] [Magenta] [Red] [White] [Yellow]

       Alternatively  you  can  specify the colour based on a colour index as follows: "[Color n]", where n is a
       standard Excel colour index - 7. See the 'Standard colors' worksheet created by formats.pl.

       For more  information  refer  to  the  documentation  on  formatting  in  the  "docs"  directory  of  the
       Excel::Writer::XLSX          distro,          the          Excel          on-line         help         or
       &lt;<a href="http://office.microsoft.com/en-gb/assistance/HP051995001033.aspx">http://office.microsoft.com/en-gb/assistance/HP051995001033.aspx</a>&gt;.

       You should ensure that the format string is valid in Excel prior to using it in WriteExcel.

       Excel's built-in formats are shown in the following table:

           Index   Index   Format String
           0       0x00    General
           1       0x01    0
           2       0x02    0.00
           3       0x03    #,##0
           4       0x04    #,##0.00
           5       0x05    ($#,##0_);($#,##0)
           6       0x06    ($#,##0_);[Red]($#,##0)
           7       0x07    ($#,##0.00_);($#,##0.00)
           8       0x08    ($#,##0.00_);[Red]($#,##0.00)
           9       0x09    0%
           10      0x0a    0.00%
           11      0x0b    0.00E+00
           12      0x0c    # ?/?
           13      0x0d    # ??/??
           14      0x0e    m/d/yy
           15      0x0f    d-mmm-yy
           16      0x10    d-mmm
           17      0x11    mmm-yy
           18      0x12    h:mm AM/PM
           19      0x13    h:mm:ss AM/PM
           20      0x14    h:mm
           21      0x15    h:mm:ss
           22      0x16    m/d/yy h:mm
           ..      ....    ...........
           37      0x25    (#,##0_);(#,##0)
           38      0x26    (#,##0_);[Red](#,##0)
           39      0x27    (#,##0.00_);(#,##0.00)
           40      0x28    (#,##0.00_);[Red](#,##0.00)
           41      0x29    _(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)
           42      0x2a    _($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)
           43      0x2b    _(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)
           44      0x2c    _($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)
           45      0x2d    mm:ss
           46      0x2e    [h]:mm:ss
           47      0x2f    mm:ss.0
           48      0x30    ##0.0E+0
           49      0x31    @

       For examples of these formatting codes see the 'Numerical formats' worksheet created by  formats.pl.  See
       also  the  number_formats1.html  and  the  number_formats2.html  documents in the "docs" directory of the
       distro.

       Note 1. Numeric formats 23 to 36 are  not  documented  by  Microsoft  and  may  differ  in  international
       versions.

       Note  2.  The  built-in  formats  are  localised  according  to the locale settings (regional settings on
       Windows) of the user when opening the file in Excel:

       •   The dot appears as the defined local decimal separator.

       •   The comma appears as the defined local digit groups separator.

       •   The dollar sign appears as the defined local currency symbol.

       •   The date, time and duration formats appear as the local equivalent date or time format.

   <b>set_locked()</b>
           Default state:      Cell locking is on
           Default action:     Turn locking on
           Valid args:         0, 1

       This property can be used to prevent modification of a cells contents. Following Excel's convention, cell
       locking is turned on by default. However, it only has an effect if the worksheet has been protected,  see
       the worksheet "protect()" method.

           my $locked = $workbook-&gt;add_format();
           $locked-&gt;set_locked( 1 );    # A non-op

           my $unlocked = $workbook-&gt;add_format();
           $unlocked-&gt;set_locked( 0 );

           # Enable worksheet protection
           $worksheet-&gt;protect();

           # This cell cannot be edited.
           $worksheet-&gt;write( 'A1', '=1+2', $locked );

           # This cell can be edited.
           $worksheet-&gt;write( 'A2', '=1+2', $unlocked );

       Note:  This  offers  weak  protection  even  with a password, see the note in relation to the "protect()"
       method.

   <b>set_hidden()</b>
           Default state:      Formula hiding is off
           Default action:     Turn hiding on
           Valid args:         0, 1

       This property is used to hide a formula while still displaying its result. This is generally used to hide
       complex calculations from end users who are only interested in the result. It only has an effect  if  the
       worksheet has been protected, see the worksheet "protect()" method.

           my $hidden = $workbook-&gt;add_format();
           $hidden-&gt;set_hidden();

           # Enable worksheet protection
           $worksheet-&gt;protect();

           # The formula in this cell isn't visible
           $worksheet-&gt;write( 'A1', '=1+2', $hidden );

       Note:  This  offers  weak  protection  even  with a password, see the note in relation to the "protect()"
       method.

   <b>set_align()</b>
           Default state:      Alignment is off
           Default action:     Left alignment
           Valid args:         'left'              Horizontal
                               'center'
                               'right'
                               'fill'
                               'justify'
                               'center_across'

                               'top'               Vertical
                               'vcenter'
                               'bottom'
                               'vjustify'

       This method is used to set the horizontal and  vertical  text  alignment  within  a  cell.  Vertical  and
       horizontal alignments can be combined. The method is used as follows:

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_align( 'center' );
           $format-&gt;set_align( 'vcenter' );
           $worksheet-&gt;set_row( 0, 30 );
           $worksheet-&gt;write( 0, 0, 'X', $format );

       Text  can  be  aligned across two or more adjacent cells using the "center_across" property. However, for
       genuine merged cells it is better to use the "merge_range()" worksheet method.

       The "vjustify" (vertical justify) option can be used to provide automatic text wrapping in  a  cell.  The
       height  of the cell will be adjusted to accommodate the wrapped text. To specify where the text wraps use
       the "set_text_wrap()" method.

       For further examples see the 'Alignment' worksheet created by formats.pl.

   <b>set_center_across()</b>
           Default state:      Center across selection is off
           Default action:     Turn center across on
           Valid args:         1

       Text can be aligned across two or more adjacent cells using the "set_center_across()" method. This is  an
       alias for the "set_align('center_across')" method call.

       Only one cell should contain the text, the other cells should be blank:

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_center_across();

           $worksheet-&gt;write( 1, 1, 'Center across selection', $format );
           $worksheet-&gt;write_blank( 1, 2, $format );

       See  also  the  "merge1.pl"  to  "merge6.pl" programs in the "examples" directory and the "merge_range()"
       method.

   <b>set_text_wrap()</b>
           Default state:      Text wrap is off
           Default action:     Turn text wrap on
           Valid args:         0, 1

       Here is an example using the text wrap property, the escape character "\n" is used to indicate the end of
       line:

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_text_wrap();
           $worksheet-&gt;write( 0, 0, "It's\na bum\nwrap", $format );

       Excel will adjust the height of the row to accommodate the wrapped text. A similar effect can be obtained
       without newlines  using  the  "set_align('vjustify')"  method.  See  the  "textwrap.pl"  program  in  the
       "examples" directory.

   <b>set_rotation()</b>
           Default state:      Text rotation is off
           Default action:     None
           Valid args:         Integers in the range -90 to 90 and 270

       Set the rotation of the text in a cell. The rotation can be any angle in the range -90 to 90 degrees.

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_rotation( 30 );
           $worksheet-&gt;write( 0, 0, 'This text is rotated', $format );

       The angle 270 is also supported. This indicates text where the letters run from top to bottom.

   <b>set_indent()</b>
           Default state:      Text indentation is off
           Default action:     Indent text 1 level
           Valid args:         Positive integers

       This  method  can be used to indent text. The argument, which should be an integer, is taken as the level
       of indentation:

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_indent( 2 );
           $worksheet-&gt;write( 0, 0, 'This text is indented', $format );

       Indentation is a horizontal alignment property. It will override any other horizontal properties  but  it
       can be used in conjunction with vertical properties.

   <b>set_shrink()</b>
           Default state:      Text shrinking is off
           Default action:     Turn "shrink to fit" on
           Valid args:         1

       This method can be used to shrink text so that it fits in a cell.

           my $format = $workbook-&gt;add_format();
           $format-&gt;set_shrink();
           $worksheet-&gt;write( 0, 0, 'Honey, I shrunk the text!', $format );

   <b>set_text_justlast()</b>
           Default state:      Justify last is off
           Default action:     Turn justify last on
           Valid args:         0, 1

       Only applies to Far Eastern versions of Excel.

   <b>set_pattern()</b>
           Default state:      Pattern is off
           Default action:     Solid fill is on
           Valid args:         0 .. 18

       Set the background pattern of a cell.

       Examples  of the available patterns are shown in the 'Patterns' worksheet created by formats.pl. However,
       it is unlikely that you will ever need anything other than Pattern  1  which  is  a  solid  fill  of  the
       background color.

   <b>set_bg_color()</b>
           Default state:      Color is off
           Default action:     Solid fill.
           Valid args:         See set_color()

       The  "set_bg_color()"  method can be used to set the background colour of a pattern. Patterns are defined
       via the "set_pattern()" method. If a pattern hasn't been defined then a solid fill pattern is used as the
       default.

       Here is an example of how to set up a solid fill in a cell:

           my $format = $workbook-&gt;add_format();

           $format-&gt;set_pattern();    # This is optional when using a solid fill

           $format-&gt;set_bg_color( 'green' );
           $worksheet-&gt;write( 'A1', 'Ray', $format );

       For further examples see the 'Patterns' worksheet created by formats.pl.

   <b>set_fg_color()</b>
           Default state:      Color is off
           Default action:     Solid fill.
           Valid args:         See set_color()

       The "set_fg_color()" method can be used to set the foreground colour of a pattern.

       For further examples see the 'Patterns' worksheet created by formats.pl.

   <b>set_border()</b>
           Also applies to:    set_bottom()
                               set_top()
                               set_left()
                               set_right()

           Default state:      Border is off
           Default action:     Set border type 1
           Valid args:         0-13, See below.

       A cell border is comprised of a border on the bottom, top, left and right. These can be set to  the  same
       value using "set_border()" or individually using the relevant method calls shown above.

       The following shows the border styles sorted by Excel::Writer::XLSX index number:

           Index   Name            Weight   Style
           =====   =============   ======   ===========
           0       None            0
           1       Continuous      1        -----------
           2       Continuous      2        -----------
           3       Dash            1        - - - - - -
           4       Dot             1        . . . . . .
           5       Continuous      3        -----------
           6       Double          3        ===========
           7       Continuous      0        -----------
           8       Dash            2        - - - - - -
           9       Dash Dot        1        - . - . - .
           10      Dash Dot        2        - . - . - .
           11      Dash Dot Dot    1        - . . - . .
           12      Dash Dot Dot    2        - . . - . .
           13      SlantDash Dot   2        / - . / - .

       The following shows the borders sorted by style:

           Name            Weight   Style         Index
           =============   ======   ===========   =====
           Continuous      0        -----------   7
           Continuous      1        -----------   1
           Continuous      2        -----------   2
           Continuous      3        -----------   5
           Dash            1        - - - - - -   3
           Dash            2        - - - - - -   8
           Dash Dot        1        - . - . - .   9
           Dash Dot        2        - . - . - .   10
           Dash Dot Dot    1        - . . - . .   11
           Dash Dot Dot    2        - . . - . .   12
           Dot             1        . . . . . .   4
           Double          3        ===========   6
           None            0                      0
           SlantDash Dot   2        / - . / - .   13

       The following shows the borders in the order shown in the Excel Dialog.

           Index   Style             Index   Style
           =====   =====             =====   =====
           0       None              12      - . . - . .
           7       -----------       13      / - . / - .
           4       . . . . . .       10      - . - . - .
           11      - . . - . .       8       - - - - - -
           9       - . - . - .       2       -----------
           3       - - - - - -       5       -----------
           1       -----------       6       ===========

       Examples of the available border styles are shown in the 'Borders' worksheet created by formats.pl.

   <b>set_border_color()</b>
           Also applies to:    set_bottom_color()
                               set_top_color()
                               set_left_color()
                               set_right_color()

           Default state:      Color is off
           Default action:     Undefined
           Valid args:         See set_color()

       Set  the  colour of the cell borders. A cell border is comprised of a border on the bottom, top, left and
       right. These can be set to the same colour using "set_border_color()" or individually using the  relevant
       method  calls shown above. Examples of the border styles and colours are shown in the 'Borders' worksheet
       created by formats.pl.

   <b>set_diag_type()</b>
           Default state:      Diagonal border is off.
           Default action:     None.
           Valid args:         1-3, See below.

       Set the diagonal border type for the cell. Three types of diagonal borders are available in Excel:

          1: From bottom left to top right.
          2: From top left to bottom right.
          3: Same as 1 and 2 combined.

       For example:

           $format-&gt;set_diag_type( 3 );

   <b>set_diag_border()</b>
           Default state:      Border is off
           Default action:     Set border type 1
           Valid args:         0-13, See below.

       Set the diagonal border style. Same as the parameter to "set_border()" above.

   <b>set_diag_color()</b>
           Default state:      Color is off
           Default action:     Undefined
           Valid args:         See set_color()

       Set the colour of the diagonal cell border:

           $format-&gt;set_diag_type( 3 );
           $format-&gt;set_diag_border( 7 );
           $format-&gt;set_diag_color( 'red' );

   <b>set_quote_prefix()</b>
           Default state:      quote prefix is off
           Default action:     Turn quote prefix on
           Valid args:         0, 1

       Set the quote prefix property of a format to ensure a string is treated as a string after  editing.  This
       is  the same as prefixing the string with a single quote in Excel. You don't need to add the quote to the
       string but you do need to add the format.

       Set the quote prefix property of the format:

           $format-&gt;set_quote_prefix();  # Turn quote prefix on

   <b>copy(</b> <b>$format</b> <b>)</b>
       This method is used to copy all of the properties from one Format object to another:

           my $lorry1 = $workbook-&gt;add_format();
           $lorry1-&gt;set_bold();
           $lorry1-&gt;set_italic();
           $lorry1-&gt;set_color( 'red' );    # lorry1 is bold, italic and red

           my $lorry2 = $workbook-&gt;add_format();
           $lorry2-&gt;copy( $lorry1 );
           $lorry2-&gt;set_color( 'yellow' );    # lorry2 is bold, italic and yellow

       The "copy()" method is only useful if you are  using  the  method  interface  to  Format  properties.  It
       generally isn't required if you are setting Format properties directly using hashes.

       Note: this is not a copy constructor, both objects must exist prior to copying.

</pre><h4><b>UNICODE</b> <b>IN</b> <b>EXCEL</b></h4><pre>
       The following is a brief introduction to handling Unicode in "Excel::Writer::XLSX".

       <u>For</u> <u>a</u> <u>more</u> <u>general</u> <u>introduction</u> <u>to</u> <u>Unicode</u> <u>handling</u> <u>in</u> <u>Perl</u> <u>see</u> perlunitut and perluniintro.

       Excel::Writer::XLSX  writer  differs from Spreadsheet::WriteExcel in that it only handles Unicode data in
       "UTF-8" format and doesn't try to handle legacy UTF-16 Excel formats.

       If the data is in "UTF-8" format then Excel::Writer::XLSX will handle it automatically.

       If you are dealing with non-ASCII characters that aren't in "UTF-8" then perl provides  useful  tools  in
       the guise of the "Encode" module to help you to convert to the required format. For example:

           use Encode 'decode';

           my $string = 'some string with koi8-r characters';
              $string = decode('koi8-r', $string); # koi8-r to utf8

       Alternatively you can read data from an encoded file and convert it to "UTF-8" as you read it in:

           my $file = 'unicode_koi8r.txt';
           open FH, '&lt;:encoding(koi8-r)', $file or die "Couldn't open $file: $!\n";

           my $row = 0;
           while ( &lt;FH&gt; ) {
               # Data read in is now in utf8 format.
               chomp;
               $worksheet-&gt;write( $row++, 0, $_ );
           }

       These methodologies are explained in more detail in perlunitut, perluniintro and perlunicode.

       If the program contains UTF-8 text then you will also need to add "use utf8" to the includes:

           use utf8;

           ...

           $worksheet-&gt;write( 'A1', 'Some UTF-8 string' );

       See also the "unicode_*.pl" programs in the examples directory of the distro.

</pre><h4><b>WORKING</b> <b>WITH</b> <b>COLOURS</b></h4><pre>
       Throughout  Excel::Writer::XLSX  colours can be specified using a Html style "#RRGGBB" value. For example
       with a Format object:

           $format-&gt;set_color( '#FF0000' );

       For backward compatibility a limited number of color names are supported:

           $format-&gt;set_color( 'red' );

       The color names supported are:

           black
           blue
           brown
           cyan
           gray
           green
           lime
           magenta
           navy
           orange
           pink
           purple
           red
           silver
           white
           yellow

       See also "colors.pl" in the "examples" directory.

</pre><h4><b>DATES</b> <b>AND</b> <b>TIME</b> <b>IN</b> <b>EXCEL</b></h4><pre>
       There are two important things to understand about dates and times in Excel:

       1 A date/time in Excel is a real number plus an Excel number format.
       2 Excel::Writer::XLSX doesn't automatically convert date/time strings in "write()" to an Excel date/time.

       These two points are explained in more detail below along with some suggestions on how to  convert  times
       and dates to the required format.

   <b>An</b> <b>Excel</b> <b>date/time</b> <b>is</b> <b>a</b> <b>number</b> <b>plus</b> <b>a</b> <b>format</b>
       If you write a date string with "write()" then all you will get is a string:

           $worksheet-&gt;write( 'A1', '02/03/04' );   # !! Writes a string not a date. !!

       Dates  and  times  in  Excel  are  represented  by  real  numbers,  for  example "Jan 1 2001 12:30 AM" is
       represented by the number 36892.521.

       The integer part of the number stores the number of days since the epoch and the fractional  part  stores
       the percentage of the day.

       A  date  or  time  in  Excel is just like any other number. To have the number display as a date you must
       apply an Excel number format to it. Here are some examples.

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Excel::Writer::XLSX;

           my $workbook  = Excel::Writer::XLSX-&gt;new( 'date_examples.xlsx' );
           my $worksheet = $workbook-&gt;add_worksheet();

           $worksheet-&gt;set_column( 'A:A', 30 );    # For extra visibility.

           my $number = 39506.5;

           $worksheet-&gt;write( 'A1', $number );             #   39506.5

           my $format2 = $workbook-&gt;add_format( num_format =&gt; 'dd/mm/yy' );
           $worksheet-&gt;write( 'A2', $number, $format2 );    #  28/02/08

           my $format3 = $workbook-&gt;add_format( num_format =&gt; 'mm/dd/yy' );
           $worksheet-&gt;write( 'A3', $number, $format3 );    #  02/28/08

           my $format4 = $workbook-&gt;add_format( num_format =&gt; 'd-m-yyyy' );
           $worksheet-&gt;write( 'A4', $number, $format4 );    #  28-2-2008

           my $format5 = $workbook-&gt;add_format( num_format =&gt; 'dd/mm/yy hh:mm' );
           $worksheet-&gt;write( 'A5', $number, $format5 );    #  28/02/08 12:00

           my $format6 = $workbook-&gt;add_format( num_format =&gt; 'd mmm yyyy' );
           $worksheet-&gt;write( 'A6', $number, $format6 );    # 28 Feb 2008

           my $format7 = $workbook-&gt;add_format( num_format =&gt; 'mmm d yyyy hh:mm AM/PM' );
           $worksheet-&gt;write('A7', $number , $format7);     #  Feb 28 2008 12:00 PM

           $workbook-&gt;close();

   <b>Excel::Writer::XLSX</b> <b>doesn't</b> <b>automatically</b> <b>convert</b> <b>date/time</b> <b>strings</b>
       Excel::Writer::XLSX doesn't automatically convert input date strings into Excel's formatted date  numbers
       due to the large number of possible date formats and also due to the possibility of misinterpretation.

       For example, does "02/03/04" mean March 2 2004, February 3 2004 or even March 4 2002.

       Therefore,  in  order to handle dates you will have to convert them to numbers and apply an Excel format.
       Some methods for converting dates are listed in the next section.

       The most direct way is to convert your dates to the ISO8601 "yyyy-mm-ddThh:mm:ss.sss" date format and use
       the "write_date_time()" worksheet method:

           $worksheet-&gt;write_date_time( 'A2', '2001-01-01T12:20', $format );

       See the "write_date_time()" section of the documentation for more details.

       A general methodology for handling date strings with "write_date_time()" is:

           1. Identify incoming date/time strings with a regex.
           2. Extract the component parts of the date/time using the same regex.
           3. Convert the date/time to the ISO8601 format.
           4. Write the date/time using write_date_time() and a number format.

       Here is an example:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Excel::Writer::XLSX;

           my $workbook  = Excel::Writer::XLSX-&gt;new( 'example.xlsx' );
           my $worksheet = $workbook-&gt;add_worksheet();

           # Set the default format for dates.
           my $date_format = $workbook-&gt;add_format( num_format =&gt; 'mmm d yyyy' );

           # Increase column width to improve visibility of data.
           $worksheet-&gt;set_column( 'A:C', 20 );

           # Simulate reading from a data source.
           my $row = 0;

           while ( &lt;DATA&gt; ) {
               chomp;

               my $col  = 0;
               my @data = split ' ';

               for my $item ( @data ) {

                   # Match dates in the following formats: d/m/yy, d/m/yyyy
                   if ( $item =~ qr[^(\d{1,2})/(\d{1,2})/(\d{4})$] ) {

                       # Change to the date format required by write_date_time().
                       my $date = sprintf "%4d-%02d-%02dT", $3, $2, $1;

                       $worksheet-&gt;write_date_time( $row, $col++, $date,
                           $date_format );
                   }
                   else {

                       # Just plain data
                       $worksheet-&gt;write( $row, $col++, $item );
                   }
               }
               $row++;
           }

           $workbook-&gt;close();

           __DATA__
           Item    Cost    Date
           Book    10      1/9/2007
           Beer    4       12/9/2007
           Bed     500     5/10/2007

       For a slightly more advanced solution you can modify the "write()" method to handle date formats of  your
       choice  via  the  "add_write_handler()" method. See the "add_write_handler()" section of the docs and the
       write_handler3.pl and write_handler4.pl programs in the examples directory of the distro.

   <b>Converting</b> <b>dates</b> <b>and</b> <b>times</b> <b>to</b> <b>an</b> <b>Excel</b> <b>date</b> <b>or</b> <b>time</b>
       The "write_date_time()" method above is just one way of handling dates and times.

       You can also use the "convert_date_time()" worksheet method to convert from an ISO8601 style date  string
       to an Excel date and time number.

       The Excel::Writer::XLSX::Utility module which is included in the distro has date/time handling functions:

           use Excel::Writer::XLSX::Utility;

           $date           = xl_date_list(2002, 1, 1);         # 37257
           $date           = xl_parse_date("11 July 1997");    # 35622
           $time           = xl_parse_time('3:21:36 PM');      # 0.64
           $date           = xl_decode_date_EU("13 May 2002"); # 37389

       Note: some of these functions require additional CPAN modules.

       For    date    conversions    using   the   CPAN   "DateTime"   framework   see   DateTime::Format::Excel
       &lt;<a href="http://search.cpan.org/search">http://search.cpan.org/search</a>?dist=DateTime-Format-Excel&gt;.

</pre><h4><b>OUTLINES</b> <b>AND</b> <b>GROUPING</b> <b>IN</b> <b>EXCEL</b></h4><pre>
       Excel allows you to group rows or columns so that they can be hidden or displayed  with  a  single  mouse
       click. This feature is referred to as outlines.

       Outlines can reduce complex data down to a few salient sub-totals or summaries.

       This  feature  is  best  viewed in Excel but the following is an ASCII representation of what a worksheet
       with three outlines might look like. Rows 3-4 and rows 7-8 are grouped at level 2. Rows 2-9  are  grouped
       at level 1. The lines at the left hand side are called outline level bars.

                   ------------------------------------------
            1 2 3 |   |   A   |   B   |   C   |   D   |  ...
                   ------------------------------------------
             _    | 1 |   A   |       |       |       |  ...
            |  _  | 2 |   B   |       |       |       |  ...
            | |   | 3 |  (C)  |       |       |       |  ...
            | |   | 4 |  (D)  |       |       |       |  ...
            | -   | 5 |   E   |       |       |       |  ...
            |  _  | 6 |   F   |       |       |       |  ...
            | |   | 7 |  (G)  |       |       |       |  ...
            | |   | 8 |  (H)  |       |       |       |  ...
            | -   | 9 |   I   |       |       |       |  ...
            -     | . |  ...  |  ...  |  ...  |  ...  |  ...

       Clicking  the  minus sign on each of the level 2 outlines will collapse and hide the data as shown in the
       next figure. The minus sign changes to a plus sign to indicate that the data in the outline is hidden.

                   ------------------------------------------
            1 2 3 |   |   A   |   B   |   C   |   D   |  ...
                   ------------------------------------------
             _    | 1 |   A   |       |       |       |  ...
            |     | 2 |   B   |       |       |       |  ...
            | +   | 5 |   E   |       |       |       |  ...
            |     | 6 |   F   |       |       |       |  ...
            | +   | 9 |   I   |       |       |       |  ...
            -     | . |  ...  |  ...  |  ...  |  ...  |  ...

       Clicking on the minus sign on the level 1 outline will collapse the remaining rows as follows:

                   ------------------------------------------
            1 2 3 |   |   A   |   B   |   C   |   D   |  ...
                   ------------------------------------------
                  | 1 |   A   |       |       |       |  ...
            +     | . |  ...  |  ...  |  ...  |  ...  |  ...

       Grouping in "Excel::Writer::XLSX" is achieved by setting  the  outline  level  via  the  "set_row()"  and
       "set_column()" worksheet methods:

           set_row( $row, $height, $format, $hidden, $level, $collapsed )
           set_column( $first_col, $last_col, $width, $format, $hidden, $level, $collapsed )

       The  following example sets an outline level of 1 for rows 2 and 3 (zero-indexed) and columns B to G. The
       parameters $height and $XF are assigned default values since they are undefined:

           $worksheet-&gt;set_row( 1, undef, undef, 0, 1 );
           $worksheet-&gt;set_row( 2, undef, undef, 0, 1 );
           $worksheet-&gt;set_column( 'B:G', undef, undef, 0, 1 );

       Excel allows up to 7 outline levels. Therefore the $level parameter should be in the range "0  &lt;=  $level
       &lt;= 7".

       Rows and columns can be collapsed by setting the $hidden flag for the hidden rows/columns and setting the
       $collapsed flag for the row/column that has the collapsed "+" symbol:

           $worksheet-&gt;set_row( 1, undef, undef, 1, 1 );
           $worksheet-&gt;set_row( 2, undef, undef, 1, 1 );
           $worksheet-&gt;set_row( 3, undef, undef, 0, 0, 1 );          # Collapsed flag.

           $worksheet-&gt;set_column( 'B:G', undef, undef, 1, 1 );
           $worksheet-&gt;set_column( 'H:H', undef, undef, 0, 0, 1 );   # Collapsed flag.

       Note:  Setting  the  $collapsed  flag is particularly important for compatibility with OpenOffice.org and
       Gnumeric.

       For a more complete example see the "outline.pl" and  "outline_collapsed.pl"  programs  in  the  examples
       directory of the distro.

       Some additional outline properties can be set via the "outline_settings()" worksheet method, see above.

</pre><h4><b>DATA</b> <b>VALIDATION</b> <b>IN</b> <b>EXCEL</b></h4><pre>
       Data validation is a feature of Excel which allows you to restrict the data that a users enters in a cell
       and  to  display help and warning messages. It also allows you to restrict input to values in a drop down
       list.

       A typical use case might be to restrict data in a cell to integer values in a certain range, to provide a
       help message to indicate the required value and to issue a warning if the input  data  doesn't  meet  the
       stated criteria. In Excel::Writer::XLSX we could do that as follows:

           $worksheet-&gt;data_validation('B3',
               {
                   validate        =&gt; 'integer',
                   criteria        =&gt; 'between',
                   minimum         =&gt; 1,
                   maximum         =&gt; 100,
                   input_title     =&gt; 'Input an integer:',
                   input_message   =&gt; 'Between 1 and 100',
                   error_message   =&gt; 'Sorry, try again.',
               });

       For  more  information  on  data  validation see the following Microsoft support article "Description and
       examples of data validation in Excel": &lt;<a href="http://support.microsoft.com/kb/211485">http://support.microsoft.com/kb/211485</a>&gt;.

       The following sections describe how to use the "data_validation()" method and its various options.

   <b>data_validation(</b> <b>$row,</b> <b>$col,</b> <b>{</b> <b>parameter</b> <b>=&gt;</b> <b>'value',</b> <b>...</b> <b>}</b> <b>)</b>
       The "data_validation()" method is used to construct an Excel data validation.

       It can be applied to a single cell or a range of cells. You can pass 3 parameters such as  "($row,  $col,
       {...})" or 5 parameters such as "($first_row, $first_col, $last_row, $last_col, {...})". You can also use
       "A1" style notation. For example:

           $worksheet-&gt;data_validation( 0, 0,       {...} );
           $worksheet-&gt;data_validation( 0, 0, 4, 1, {...} );

           # Which are the same as:

           $worksheet-&gt;data_validation( 'A1',       {...} );
           $worksheet-&gt;data_validation( 'A1:B5',    {...} );

       See also the note about "Cell notation" for more information.

       The  last parameter in "data_validation()" must be a hash ref containing the parameters that describe the
       type and style of the data validation. The allowable parameters are:

           validate
           criteria
           value | minimum | source
           maximum
           ignore_blank
           dropdown

           input_title
           input_message
           show_input

           error_title
           error_message
           error_type
           show_error

       These parameters are explained in the following sections. Most of the parameters are  optional,  however,
       you will generally require the three main options "validate", "criteria" and "value".

           $worksheet-&gt;data_validation('B3',
               {
                   validate =&gt; 'integer',
                   criteria =&gt; '&gt;',
                   value    =&gt; 100,
               });

       The "data_validation" method returns:

            0 for success.
           -1 for insufficient number of arguments.
           -2 for row or column out of bounds.
           -3 for incorrect parameter or value.

   <b>validate</b>
       This parameter is passed in a hash ref to "data_validation()".

       The "validate" parameter is used to set the type of data that you wish to validate. It is always required
       and it has no default value. Allowable values are:

           any
           integer
           decimal
           list
           date
           time
           length
           custom

       •   <b>any</b>  is  used  to  specify  that the type of data is unrestricted. This is useful to display an input
           message without restricting the data that can be entered.

       •   <b>integer</b> restricts the cell to integer values. Excel refers to this as 'whole number'.

               validate =&gt; 'integer',
               criteria =&gt; '&gt;',
               value    =&gt; 100,

       •   <b>decimal</b> restricts the cell to decimal values.

               validate =&gt; 'decimal',
               criteria =&gt; '&gt;',
               value    =&gt; 38.6,

       •   <b>list</b> restricts the cell to a set of user specified values. These can be passed in an array ref or  as
           a cell range (named ranges aren't currently supported):

               validate =&gt; 'list',
               value    =&gt; ['open', 'high', 'close'],
               # Or like this:
               value    =&gt; 'B1:B3',

           Excel requires that range references are only to cells on the same worksheet.

       •   <b>date</b>  restricts  the  cell to date values. Dates in Excel are expressed as integer values but you can
           also pass an ISO8601 style string as used in "write_date_time()". See also "DATES AND TIME IN  EXCEL"
           for more information about working with Excel's dates.

               validate =&gt; 'date',
               criteria =&gt; '&gt;',
               value    =&gt; 39653, # 24 July 2008
               # Or like this:
               value    =&gt; '2008-07-24T',

       •   <b>time</b>  restricts  the  cell to time values. Times in Excel are expressed as decimal values but you can
           also pass an ISO8601 style string as used in "write_date_time()". See also "DATES AND TIME IN  EXCEL"
           for more information about working with Excel's times.

               validate =&gt; 'time',
               criteria =&gt; '&gt;',
               value    =&gt; 0.5, # Noon
               # Or like this:
               value    =&gt; 'T12:00:00',

       •   <b>length</b>  restricts  the  cell  data  based  on an integer string length. Excel refers to this as 'Text
           length'.

               validate =&gt; 'length',
               criteria =&gt; '&gt;',
               value    =&gt; 10,

       •   <b>custom</b> restricts the cell based on an external Excel formula that returns a "TRUE/FALSE" value.

               validate =&gt; 'custom',
               value    =&gt; '=IF(A10&gt;B10,TRUE,FALSE)',

   <b>criteria</b>
       This parameter is passed in a hash ref to "data_validation()".

       The "criteria" parameter is used to set the criteria by which the data in the cell is  validated.  It  is
       almost  always  required  except  for  the "list" and "custom" validate options. It has no default value.
       Allowable values are:

           'between'
           'not between'
           'equal to'                  |  '=='  |  '='
           'not equal to'              |  '!='  |  '&lt;&gt;'
           'greater than'              |  '&gt;'
           'less than'                 |  '&lt;'
           'greater than or equal to'  |  '&gt;='
           'less than or equal to'     |  '&lt;='

       You can either use Excel's textual description strings, in the first column above,  or  the  more  common
       symbolic alternatives. The following are equivalent:

           validate =&gt; 'integer',
           criteria =&gt; 'greater than',
           value    =&gt; 100,

           validate =&gt; 'integer',
           criteria =&gt; '&gt;',
           value    =&gt; 100,

       The  "list"  and  "custom"  validate  options  don't  require a "criteria". If you specify one it will be
       ignored.

           validate =&gt; 'list',
           value    =&gt; ['open', 'high', 'close'],

           validate =&gt; 'custom',
           value    =&gt; '=IF(A10&gt;B10,TRUE,FALSE)',

   <b>value</b> <b>|</b> <b>minimum</b> <b>|</b> <b>source</b>
       This parameter is passed in a hash ref to "data_validation()".

       The "value" parameter is used to set the limiting value to which the "criteria" is applied. It is  always
       required  and  it  has  no default value. You can also use the synonyms "minimum" or "source" to make the
       validation a little clearer and closer to Excel's description of the parameter:

           # Use 'value'
           validate =&gt; 'integer',
           criteria =&gt; '&gt;',
           value    =&gt; 100,

           # Use 'minimum'
           validate =&gt; 'integer',
           criteria =&gt; 'between',
           minimum  =&gt; 1,
           maximum  =&gt; 100,

           # Use 'source'
           validate =&gt; 'list',
           source   =&gt; '$B$1:$B$3',

   <b>maximum</b>
       This parameter is passed in a hash ref to "data_validation()".

       The "maximum" parameter is used to set the upper limiting value when the "criteria" is  either  'between'
       or 'not between':

           validate =&gt; 'integer',
           criteria =&gt; 'between',
           minimum  =&gt; 1,
           maximum  =&gt; 100,

   <b>ignore_blank</b>
       This parameter is passed in a hash ref to "data_validation()".

       The  "ignore_blank"  parameter  is  used to toggle on and off the 'Ignore blank' option in the Excel data
       validation dialog. When the option is on the data validation is not applied to blank data in the cell. It
       is on by default.

           ignore_blank =&gt; 0,  # Turn the option off

   <b>dropdown</b>
       This parameter is passed in a hash ref to "data_validation()".

       The "dropdown" parameter is used to toggle on and off the 'In-cell dropdown' option  in  the  Excel  data
       validation  dialog.  When the option is on a dropdown list will be shown for "list" validations. It is on
       by default.

           dropdown =&gt; 0,      # Turn the option off

   <b>input_title</b>
       This parameter is passed in a hash ref to "data_validation()".

       The "input_title" parameter is used to set the title of the input message that is displayed when  a  cell
       is  entered.  It  has  no  default value and is only displayed if the input message is displayed. See the
       "input_message" parameter below.

           input_title   =&gt; 'This is the input title',

       The maximum title length is 32 characters.

   <b>input_message</b>
       This parameter is passed in a hash ref to "data_validation()".

       The "input_message" parameter is used to set the input message that is displayed when a cell is  entered.
       It has no default value.

           validate      =&gt; 'integer',
           criteria      =&gt; 'between',
           minimum       =&gt; 1,
           maximum       =&gt; 100,
           input_title   =&gt; 'Enter the applied discount:',
           input_message =&gt; 'between 1 and 100',

       The message can be split over several lines using newlines, "\n" in double quoted strings.

           input_message =&gt; "This is\na test.",

       The maximum message length is 255 characters.

   <b>show_input</b>
       This parameter is passed in a hash ref to "data_validation()".

       The  "show_input"  parameter  is used to toggle on and off the 'Show input message when cell is selected'
       option in the Excel data validation dialog. When the option is off an input message is not displayed even
       if it has been set using "input_message". It is on by default.

           show_input =&gt; 0,      # Turn the option off

   <b>error_title</b>
       This parameter is passed in a hash ref to "data_validation()".

       The "error_title" parameter is used to set the title of the error message that is displayed when the data
       validation criteria is not met. The default error title is 'Microsoft Excel'.

           error_title   =&gt; 'Input value is not valid',

       The maximum title length is 32 characters.

   <b>error_message</b>
       This parameter is passed in a hash ref to "data_validation()".

       The "error_message" parameter is used to set the error message that is displayed when a cell is  entered.
       The  default error message is "The value you entered is not valid.\nA user has restricted values that can
       be entered into the cell.".

           validate      =&gt; 'integer',
           criteria      =&gt; 'between',
           minimum       =&gt; 1,
           maximum       =&gt; 100,
           error_title   =&gt; 'Input value is not valid',
           error_message =&gt; 'It should be an integer between 1 and 100',

       The message can be split over several lines using newlines, "\n" in double quoted strings.

           input_message =&gt; "This is\na test.",

       The maximum message length is 255 characters.

   <b>error_type</b>
       This parameter is passed in a hash ref to "data_validation()".

       The "error_type" parameter is used to specify the type of error dialog that is  displayed.  There  are  3
       options:

           'stop'
           'warning'
           'information'

       The default is 'stop'.

   <b>show_error</b>
       This parameter is passed in a hash ref to "data_validation()".

       The  "show_error"  parameter  is  used  to  toggle on and off the 'Show error alert after invalid data is
       entered' option in the Excel data validation dialog. When the option is  off  an  error  message  is  not
       displayed even if it has been set using "error_message". It is on by default.

           show_error =&gt; 0,      # Turn the option off

   <b>Data</b> <b>Validation</b> <b>Examples</b>
       Example 1. Limiting input to an integer greater than a fixed value.

           $worksheet-&gt;data_validation('A1',
               {
                   validate        =&gt; 'integer',
                   criteria        =&gt; '&gt;',
                   value           =&gt; 0,
               });

       Example  2.  Limiting input to an integer greater than a fixed value where the value is referenced from a
       cell.

           $worksheet-&gt;data_validation('A2',
               {
                   validate        =&gt; 'integer',
                   criteria        =&gt; '&gt;',
                   value           =&gt; '=E3',
               });

       Example 3. Limiting input to a decimal in a fixed range.

           $worksheet-&gt;data_validation('A3',
               {
                   validate        =&gt; 'decimal',
                   criteria        =&gt; 'between',
                   minimum         =&gt; 0.1,
                   maximum         =&gt; 0.5,
               });

       Example 4. Limiting input to a value in a dropdown list.

           $worksheet-&gt;data_validation('A4',
               {
                   validate        =&gt; 'list',
                   source          =&gt; ['open', 'high', 'close'],
               });

       Example 5. Limiting input to a value in a dropdown list where the list is specified as a cell range.

           $worksheet-&gt;data_validation('A5',
               {
                   validate        =&gt; 'list',
                   source          =&gt; '=$E$4:$G$4',
               });

       Example 6. Limiting input to a date in a fixed range.

           $worksheet-&gt;data_validation('A6',
               {
                   validate        =&gt; 'date',
                   criteria        =&gt; 'between',
                   minimum         =&gt; '2008-01-01T',
                   maximum         =&gt; '2008-12-12T',
               });

       Example 7. Displaying a message when the cell is selected.

           $worksheet-&gt;data_validation('A7',
               {
                   validate      =&gt; 'integer',
                   criteria      =&gt; 'between',
                   minimum       =&gt; 1,
                   maximum       =&gt; 100,
                   input_title   =&gt; 'Enter an integer:',
                   input_message =&gt; 'between 1 and 100',
               });

       See also the "data_validate.pl" program in the examples directory of the distro.

</pre><h4><b>CONDITIONAL</b> <b>FORMATTING</b> <b>IN</b> <b>EXCEL</b></h4><pre>
       Conditional formatting is a feature of Excel which allows you to apply a format to a cell or a  range  of
       cells based on a certain criteria.

       For example the following criteria is used to highlight cells &gt;= 50 in red in the "conditional_format.pl"
       example from the distro:

           # Write a conditional format over a range.
           $worksheet-&gt;conditional_formatting( 'B3:K12',
               {
                   type     =&gt; 'cell',
                   criteria =&gt; '&gt;=',
                   value    =&gt; 50,
                   format   =&gt; $format1,
               }
           );

   <b>conditional_formatting(</b> <b>$row,</b> <b>$col,</b> <b>{</b> <b>parameter</b> <b>=&gt;</b> <b>'value',</b> <b>...</b> <b>}</b> <b>)</b>
       The  "conditional_formatting()"  method is used to apply formatting  based on user defined criteria to an
       Excel::Writer::XLSX file.

       It can be applied to a single cell or a range of cells. You can pass 3 parameters such as  "($row,  $col,
       {...})" or 5 parameters such as "($first_row, $first_col, $last_row, $last_col, {...})". You can also use
       "A1" style notation. For example:

           $worksheet-&gt;conditional_formatting( 0, 0,       {...} );
           $worksheet-&gt;conditional_formatting( 0, 0, 4, 1, {...} );

           # Which are the same as:

           $worksheet-&gt;conditional_formatting( 'A1',       {...} );
           $worksheet-&gt;conditional_formatting( 'A1:B5',    {...} );

       See also the note about "Cell notation" for more information.

       Using  "A1"  style  notation is also possible to specify non-contiguous ranges, separated by a comma. For
       example:

           $worksheet-&gt;conditional_formatting( 'A1:D5,A8:D12', {...} );

       The last parameter in "conditional_formatting()" must be  a  hash  ref  containing  the  parameters  that
       describe the type and style of the data validation. The main parameters are:

           type
           format
           criteria
           value
           minimum
           maximum

       Other, less commonly used parameters are:

           min_type
           mid_type
           max_type
           min_value
           mid_value
           max_value
           min_color
           mid_color
           max_color
           bar_color
           bar_only
           bar_solid
           bar_negative_color
           bar_border_color
           bar_negative_border_color
           bar_negative_color_same
           bar_negative_border_color_same
           bar_no_border
           bar_direction
           bar_axis_position
           bar_axis_color
           data_bar_2010
           icon_style
           icons
           reverse_icons
           icons_only
           stop_if_true
           multi_range

       Additional  parameters  which  are  used  for specific conditional format types are shown in the relevant
       sections below.

   <b>type</b>
       This parameter is passed in a hash ref to "conditional_formatting()".

       The "type" parameter is used to set the type of conditional formatting that you  wish  to  apply.  It  is
       always required and it has no default value. Allowable "type" values and their associated parameters are:

           Type            Parameters
           ====            ==========
           cell            criteria
                           value
                           minimum
                           maximum
                           format

           date            criteria
                           value
                           minimum
                           maximum
                           format

           time_period     criteria
                           format

           text            criteria
                           value
                           format

           average         criteria
                           format

           duplicate       format

           unique          format

           top             criteria
                           value
                           format

           bottom          criteria
                           value
                           format

           blanks          format

           no_blanks       format

           errors          format

           no_errors       format

           formula         criteria
                           format

           2_color_scale   min_type
                           max_type
                           min_value
                           max_value
                           min_color
                           max_color

           3_color_scale   min_type
                           mid_type
                           max_type
                           min_value
                           mid_value
                           max_value
                           min_color
                           mid_color
                           max_color

           data_bar        min_type
                           max_type
                           min_value
                           max_value
                           bar_only
                           bar_color
                           bar_solid*
                           bar_negative_color*
                           bar_border_color*
                           bar_negative_border_color*
                           bar_negative_color_same*
                           bar_negative_border_color_same*
                           bar_no_border*
                           bar_direction*
                           bar_axis_position*
                           bar_axis_color*
                           data_bar_2010*

           icon_set        icon_style
                           reverse_icons
                           icons
                           icons_only

       Data  bar  parameters  marked  with  (*) are only available in Excel 2010 and later. Files that use these
       properties can still be opened in Excel 2007 but the data bars will be displayed without them.

   <b>type</b> <b>=&gt;</b> <b>'cell'</b>
       This is the most common conditional formatting type. It is used when a format is applied to a cell  based
       on a simple criterion. For example:

           $worksheet-&gt;conditional_formatting( 'A1',
               {
                   type     =&gt; 'cell',
                   criteria =&gt; 'greater than',
                   value    =&gt; 5,
                   format   =&gt; $red_format,
               }
           );

       Or, using the "between" criteria:

           $worksheet-&gt;conditional_formatting( 'C1:C4',
               {
                   type     =&gt; 'cell',
                   criteria =&gt; 'between',
                   minimum  =&gt; 20,
                   maximum  =&gt; 30,
                   format   =&gt; $green_format,
               }
           );

   <b>criteria</b>
       The  "criteria" parameter is used to set the criteria by which the cell data will be evaluated. It has no
       default value. The most common criteria as applied to "{ type =&gt; 'cell' }" are:

           'between'
           'not between'
           'equal to'                  |  '=='  |  '='
           'not equal to'              |  '!='  |  '&lt;&gt;'
           'greater than'              |  '&gt;'
           'less than'                 |  '&lt;'
           'greater than or equal to'  |  '&gt;='
           'less than or equal to'     |  '&lt;='

       You can either use Excel's textual description strings, in the first column above,  or  the  more  common
       symbolic alternatives.

       Additional  criteria  which  are  specific  to  other  conditional format types are shown in the relevant
       sections below.

   <b>value</b>
       The "value" is generally used along with the "criteria" parameter to set the rule by which the cell  data
       will be evaluated.

           type     =&gt; 'cell',
           criteria =&gt; '&gt;',
           value    =&gt; 5
           format   =&gt; $format,

       The "value" property can also be an cell reference.

           type     =&gt; 'cell',
           criteria =&gt; '&gt;',
           value    =&gt; '$C$1',
           format   =&gt; $format,

   <b>format</b>
       The  "format"  parameter  is  used  to  specify  the  format  that  will  be applied to the cell when the
       conditional formatting criterion is met. The format is created using the  "add_format()"  method  in  the
       same way as cell formats:

           $format = $workbook-&gt;add_format( bold =&gt; 1, italic =&gt; 1 );

           $worksheet-&gt;conditional_formatting( 'A1',
               {
                   type     =&gt; 'cell',
                   criteria =&gt; '&gt;',
                   value    =&gt; 5
                   format   =&gt; $format,
               }
           );

       The  conditional  format  follows  the  same rules as in Excel: it is superimposed over the existing cell
       format and not all font and border properties can be modified. Font properties that can't be modified are
       font name, font size, superscript and subscript. The border property that cannot be modified is  diagonal
       borders.

       Excel specifies some default formats to be used with conditional formatting. You can replicate them using
       the following Excel::Writer::XLSX formats:

           # Light red fill with dark red text.

           my $format1 = $workbook-&gt;add_format(
               bg_color =&gt; '#FFC7CE',
               color    =&gt; '#9C0006',
           );

           # Light yellow fill with dark yellow text.

           my $format2 = $workbook-&gt;add_format(
               bg_color =&gt; '#FFEB9C',
               color    =&gt; '#9C6500',
           );

           # Green fill with dark green text.

           my $format3 = $workbook-&gt;add_format(
               bg_color =&gt; '#C6EFCE',
               color    =&gt; '#006100',
           );

   <b>minimum</b>
       The  "minimum"  parameter is used to set the lower limiting value when the "criteria" is either 'between'
       or 'not between':

           validate =&gt; 'integer',
           criteria =&gt; 'between',
           minimum  =&gt; 1,
           maximum  =&gt; 100,

   <b>maximum</b>
       The "maximum" parameter is used to set the upper limiting value when the "criteria" is  either  'between'
       or 'not between'. See the previous example.

   <b>type</b> <b>=&gt;</b> <b>'date'</b>
       The  "date"  type is the same as the "cell" type and uses the same criteria and values. However it allows
       the "value", "minimum" and "maximum" properties to be specified in the ISO8601  "yyyy-mm-ddThh:mm:ss.sss"
       date format which is detailed in the "write_date_time()" method.

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'date',
                   criteria =&gt; 'greater than',
                   value    =&gt; '2011-01-01T',
                   format   =&gt; $format,
               }
           );

   <b>type</b> <b>=&gt;</b> <b>'time_period'</b>
       The "time_period" type is used to specify Excel's "Dates Occurring" style conditional format.

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'time_period',
                   criteria =&gt; 'yesterday',
                   format   =&gt; $format,
               }
           );

       The period is set in the "criteria" and can have one of the following values:

               criteria =&gt; 'yesterday',
               criteria =&gt; 'today',
               criteria =&gt; 'last 7 days',
               criteria =&gt; 'last week',
               criteria =&gt; 'this week',
               criteria =&gt; 'next week',
               criteria =&gt; 'last month',
               criteria =&gt; 'this month',
               criteria =&gt; 'next month'

   <b>type</b> <b>=&gt;</b> <b>'text'</b>
       The  "text"  type  is  used to specify Excel's "Specific Text" style conditional format. It is used to do
       simple string matching using the "criteria" and "value" parameters:

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'text',
                   criteria =&gt; 'containing',
                   value    =&gt; 'foo',
                   format   =&gt; $format,
               }
           );

       The "criteria" can have one of the following values:

           criteria =&gt; 'containing',
           criteria =&gt; 'not containing',
           criteria =&gt; 'begins with',
           criteria =&gt; 'ends with',

       The "value" parameter should be a string or single character.

   <b>type</b> <b>=&gt;</b> <b>'average'</b>
       The "average" type is used to specify Excel's "Average" style conditional format.

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'average',
                   criteria =&gt; 'above',
                   format   =&gt; $format,
               }
           );

       The type of average for the conditional format range is specified by the "criteria":

           criteria =&gt; 'above',
           criteria =&gt; 'below',
           criteria =&gt; 'equal or above',
           criteria =&gt; 'equal or below',
           criteria =&gt; '1 std dev above',
           criteria =&gt; '1 std dev below',
           criteria =&gt; '2 std dev above',
           criteria =&gt; '2 std dev below',
           criteria =&gt; '3 std dev above',
           criteria =&gt; '3 std dev below',

   <b>type</b> <b>=&gt;</b> <b>'duplicate'</b>
       The "duplicate" type is used to highlight duplicate cells in a range:

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'duplicate',
                   format   =&gt; $format,
               }
           );

   <b>type</b> <b>=&gt;</b> <b>'unique'</b>
       The "unique" type is used to highlight unique cells in a range:

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'unique',
                   format   =&gt; $format,
               }
           );

   <b>type</b> <b>=&gt;</b> <b>'top'</b>
       The "top" type is used to specify the top "n" values by number or percentage in a range:

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'top',
                   value    =&gt; 10,
                   format   =&gt; $format,
               }
           );

       The "criteria" can be used to indicate that a percentage condition is required:

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'top',
                   value    =&gt; 10,
                   criteria =&gt; '%',
                   format   =&gt; $format,
               }
           );

   <b>type</b> <b>=&gt;</b> <b>'bottom'</b>
       The "bottom" type is used to specify the bottom "n" values by number or percentage in a range.

       It takes the same parameters as "top", see above.

   <b>type</b> <b>=&gt;</b> <b>'blanks'</b>
       The "blanks" type is used to highlight blank cells in a range:

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'blanks',
                   format   =&gt; $format,
               }
           );

   <b>type</b> <b>=&gt;</b> <b>'no_blanks'</b>
       The "no_blanks" type is used to highlight non blank cells in a range:

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'no_blanks',
                   format   =&gt; $format,
               }
           );

   <b>type</b> <b>=&gt;</b> <b>'errors'</b>
       The "errors" type is used to highlight error cells in a range:

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'errors',
                   format   =&gt; $format,
               }
           );

   <b>type</b> <b>=&gt;</b> <b>'no_errors'</b>
       The "no_errors" type is used to highlight non error cells in a range:

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'no_errors',
                   format   =&gt; $format,
               }
           );

   <b>type</b> <b>=&gt;</b> <b>'formula'</b>
       The "formula" type is used to specify a conditional format based on a user defined formula:

           $worksheet-&gt;conditional_formatting( 'A1:A4',
               {
                   type     =&gt; 'formula',
                   criteria =&gt; '=$A$1 &gt; 5',
                   format   =&gt; $format,
               }
           );

       The formula is specified in the "criteria".

   <b>type</b> <b>=&gt;</b> <b>'2_color_scale'</b>
       The "2_color_scale" type is used to specify Excel's "2 Color Scale" style conditional format.

           $worksheet-&gt;conditional_formatting( 'A1:A12',
               {
                   type  =&gt; '2_color_scale',
               }
           );

       This conditional type can be modified with "min_type", "max_type", "min_value", "max_value",  "min_color"
       and "max_color", see below.

   <b>type</b> <b>=&gt;</b> <b>'3_color_scale'</b>
       The "3_color_scale" type is used to specify Excel's "3 Color Scale" style conditional format.

           $worksheet-&gt;conditional_formatting( 'A1:A12',
               {
                   type  =&gt; '3_color_scale',
               }
           );

       This  conditional type can be modified with "min_type", "mid_type", "max_type", "min_value", "mid_value",
       "max_value", "min_color", "mid_color" and "max_color", see below.

   <b>type</b> <b>=&gt;</b> <b>'data_bar'</b>
       The "data_bar" type is used to specify Excel's "Data Bar" style conditional format.

           $worksheet-&gt;conditional_formatting( 'A1:A12',
               {
                   type  =&gt; 'data_bar',
               }
           );

       This data bar conditional type can be modified with the following parameters, which are explained in  the
       sections  below.  These  properties  were available in the original xlsx file specification used in Excel
       2007::

           min_type
           max_type
           min_value
           max_value
           bar_color
           bar_only

       In Excel 2010 additional data bar properties were added such as solid  (non-gradient)  bars  and  control
       over how negative values are displayed. These properties can be set using the following parameters:

           bar_solid
           bar_negative_color
           bar_border_color
           bar_negative_border_color
           bar_negative_color_same
           bar_negative_border_color_same
           bar_no_border
           bar_direction
           bar_axis_position
           bar_axis_color
           data_bar_2010

       Files  that  use  these Excel 2010 properties can still be opened in Excel 2007 but the data bars will be
       displayed without them.

   <b>type</b> <b>=&gt;</b> <b>'icon_set'</b>
       The "icon_set" type is used to specify a conditional format with a set of icons such as traffic lights or
       arrows:

           $worksheet-&gt;conditional_formatting( 'A1:C1',
               {
                   type         =&gt; 'icon_set',
                   icon_style   =&gt; '3_traffic_lights',
               }
           );

       The icon set style is specified by the "icon_style" parameter. Valid options are:

           3_arrows
           3_arrows_gray
           3_flags
           3_signs
           3_symbols
           3_symbols_circled
           3_traffic_lights
           3_traffic_lights_rimmed

           4_arrows
           4_arrows_gray
           4_ratings
           4_red_to_black
           4_traffic_lights

           5_arrows
           5_arrows_gray
           5_quarters
           5_ratings

       The criteria, type and value of each icon can be specified using the  "icon"  array  of  hash  refs  with
       optional "criteria", "type" and "value" parameters:

           $worksheet-&gt;conditional_formatting( 'A1:D1',
               {
                   type         =&gt; 'icon_set',
                   icon_style   =&gt; '4_red_to_black',
                   icons        =&gt; [ {criteria =&gt; '&gt;',  type =&gt; 'number',     value =&gt; 90},
                                     {criteria =&gt; '&gt;=', type =&gt; 'percentile', value =&gt; 50},
                                     {criteria =&gt; '&gt;',  type =&gt; 'percent',    value =&gt; 25},
                                   ],
               }
           );

       The "icons criteria" parameter should be either "&gt;=" or "&gt;". The default "criteria" is "&gt;=".

       The "icons type" parameter should be one of the following values:

           number
           percentile
           percent
           formula

       The default "type" is "percent".

       The "icons value" parameter can be a value or formula:

           $worksheet-&gt;conditional_formatting( 'A1:D1',
               {
                   type         =&gt; 'icon_set',
                   icon_style   =&gt; '4_red_to_black',
                   icons        =&gt; [ {value =&gt; 90},
                                     {value =&gt; 50},
                                     {value =&gt; 25},
                                   ],
               }
           );

       Note:  The  "icons"  parameters  should  start  with the highest value and with each subsequent one being
       lower. The default "value" is "(n * 100) / number_of_icons". The lowest number icon in an  icon  set  has
       properties defined by Excel. Therefore in a "n" icon set, there is no "n-1" hash of parameters.

       The order of the icons can be reversed using the "reverse_icons" parameter:

           $worksheet-&gt;conditional_formatting( 'A1:C1',
               {
                   type          =&gt; 'icon_set',
                   icon_style    =&gt; '3_arrows',
                   reverse_icons =&gt; 1,
               }
           );

       The icons can be displayed without the cell value using the "icons_only" parameter:

           $worksheet-&gt;conditional_formatting( 'A1:C1',
               {
                   type         =&gt; 'icon_set',
                   icon_style   =&gt; '3_flags',
                   icons_only   =&gt; 1,
               }
           );

   <b>min_type,</b> <b>mid_type,</b> <b>max_type</b>
       The  "min_type"  and  "max_type"  properties  are  available  when  the  conditional  formatting  type is
       "2_color_scale", "3_color_scale" or "data_bar". The "mid_type"  is  available  for  "3_color_scale".  The
       properties are used as follows:

           $worksheet-&gt;conditional_formatting( 'A1:A12',
               {
                   type      =&gt; '2_color_scale',
                   min_type  =&gt; 'percent',
                   max_type  =&gt; 'percent',
               }
           );

       The available min/mid/max types are:

           min        (for min_type only)
           num
           percent
           percentile
           formula
           max        (for max_type only)

   <b>min_value,</b> <b>mid_value,</b> <b>max_value</b>
       The  "min_value"  and  "max_value"  properties  are  available  when  the  conditional formatting type is
       "2_color_scale", "3_color_scale" or "data_bar". The "mid_value" is  available  for  "3_color_scale".  The
       properties are used as follows:

           $worksheet-&gt;conditional_formatting( 'A1:A12',
               {
                   type       =&gt; '2_color_scale',
                   min_value  =&gt; 10,
                   max_value  =&gt; 90,
               }
           );

   <b>min_color,</b> <b>mid_color,</b>  <b>max_color,</b> <b>bar_color</b>
       The  "min_color"  and  "max_color"  properties  are  available  when  the  conditional formatting type is
       "2_color_scale", "3_color_scale" or "data_bar". The "mid_color" is  available  for  "3_color_scale".  The
       properties are used as follows:

           $worksheet-&gt;conditional_formatting( 'A1:A12',
               {
                   type      =&gt; '2_color_scale',
                   min_color =&gt; "#C5D9F1",
                   max_color =&gt; "#538ED5",
               }
           );

       The  color  can be specified as an Excel::Writer::XLSX color index or, more usefully, as a HTML style RGB
       hex number, as shown above.

   <b>bar_only</b>
       The "bar_only" parameter property displays a bar data but not the data in the cells:

           $worksheet-&gt;conditional_formatting( 'D3:D14',
               {
                   type     =&gt; 'data_bar',
                   bar_only =&gt; 1
               }
           );

   <b>bar_solid</b>
       The "bar_solid" parameter turns on a solid (non-gradient) fill for data bars:

           $worksheet-&gt;conditional_formatting( 'H3:H14',
               {
                   type      =&gt; 'data_bar',
                   bar_solid =&gt; 1
               }
           );

       Note, this property is only visible in Excel 2010 and later.

   <b>bar_negative_color</b>
       The "bar_negative_color" parameter is used to set the color fill for the negative portion of a data bar.

       The color can be specified as an Excel::Writer::XLSX color index or as a HTML style RGB  hex  number,  as
       shown in the other examples.

       Note, this property is only visible in Excel 2010 and later.

   <b>bar_border_color</b>
       The "bar_border_color" parameter is used to set the border color of a data bar.

       The  color  can  be specified as an Excel::Writer::XLSX color index or as a HTML style RGB hex number, as
       shown in the other examples.

       Note, this property is only visible in Excel 2010 and later.

   <b>bar_negative_border_color</b>
       The "bar_negative_border_color" parameter is used to set the border color of the negative  portion  of  a
       data bar.

       The  color  can  be specified as an Excel::Writer::XLSX color index or as a HTML style RGB hex number, as
       shown in the other examples.

       Note, this property is only visible in Excel 2010 and later.

   <b>bar_negative_color_same</b>
       The "bar_negative_color_same" parameter sets the fill color for the negative portion of a data bar to  be
       the same as the fill color for the positive portion of the data bar:

           $worksheet-&gt;conditional_formatting( 'N3:N14',
               {
                   type                           =&gt; 'data_bar',
                   bar_negative_color_same        =&gt; 1,
                   bar_negative_border_color_same =&gt; 1
               }
           );

       Note, this property is only visible in Excel 2010 and later.

   <b>bar_negative_border_color_same</b>
       The  "bar_negative_border_color_same"  parameter sets the border color for the negative portion of a data
       bar to be the same as the border color for the positive portion of the data bar.

       Note, this property is only visible in Excel 2010 and later.

   <b>bar_no_border</b>
       The "bar_no_border" parameter turns off the border of a data bar.

       Note, this property is only visible in Excel 2010 and later, however the default in Excel 2007 is not  to
       have a border.

   <b>bar_direction</b>
       The  "bar_direction"  parameter  sets the direction for data bars. This property can be either "left" for
       left-to-right or "right" for right-to-left. If the property isn't set then Excel will adjust the position
       automatically based on the context:

           $worksheet-&gt;conditional_formatting( 'J3:J14',
               {
                   type          =&gt; 'data_bar',
                   bar_direction =&gt; 'right'
               }
           );

       Note, this property is only visible in Excel 2010 and later.

   <b>bar_axis_position</b>
       The "bar_axis_position" parameter sets the position within the cells for the axis that is shown  in  data
       bars  when  there  are  negative values to display. The property can be either "middle" or "none". If the
       property isn't set then Excel will position the axis based on the range of positive and negative values.

       Note, this property is only visible in Excel 2010 and later.

   <b>bar_axis_color</b>
       The "bar_axis_color" parameter sets the color for the axis that is shown in  data  bars  when  there  are
       negative values to display.

       The  color  can  be specified as an Excel::Writer::XLSX color index or as a HTML style RGB hex number, as
       shown in the other examples.

       Note, this property is only visible in Excel 2010 and later.

   <b>data_bar_2010</b>
       The "data_bar_2010" parameter sets Excel 2010 style data bars even when Excel  2010  specific  properties
       aren't used. This can be used to create consistency across all the data bar formatting in a worksheet:

           $worksheet-&gt;conditional_formatting( 'L3:L14',
               {
                   type          =&gt; 'data_bar',
                   data_bar_2010 =&gt; 1
               }
           );

       Note, this property is only visible in Excel 2010 and later.

   <b>stop_if_true</b>
       The  "stop_if_true"  parameter,  if  set  to  a true value, will enable the "stop if true" feature on the
       conditional formatting rule, so that subsequent rules  are  not  examined  for  any  cell  on  which  the
       conditions for this rule are met.

   <b>Conditional</b> <b>Formatting</b> <b>Examples</b>
       Example 1. Highlight cells greater than an integer value.

           $worksheet-&gt;conditional_formatting( 'A1:F10',
               {
                   type     =&gt; 'cell',
                   criteria =&gt; 'greater than',
                   value    =&gt; 5,
                   format   =&gt; $format,
               }
           );

       Example 2. Highlight cells greater than a value in a reference cell.

           $worksheet-&gt;conditional_formatting( 'A1:F10',
               {
                   type     =&gt; 'cell',
                   criteria =&gt; 'greater than',
                   value    =&gt; '$H$1',
                   format   =&gt; $format,
               }
           );

       Example 3. Highlight cells greater than a certain date:

           $worksheet-&gt;conditional_formatting( 'A1:F10',
               {
                   type     =&gt; 'date',
                   criteria =&gt; 'greater than',
                   value    =&gt; '2011-01-01T',
                   format   =&gt; $format,
               }
           );

       Example 4. Highlight cells with a date in the last seven days:

           $worksheet-&gt;conditional_formatting( 'A1:F10',
               {
                   type     =&gt; 'time_period',
                   criteria =&gt; 'last 7 days',
                   format   =&gt; $format,
               }
           );

       Example 5. Highlight cells with strings starting with the letter "b":

           $worksheet-&gt;conditional_formatting( 'A1:F10',
               {
                   type     =&gt; 'text',
                   criteria =&gt; 'begins with',
                   value    =&gt; 'b',
                   format   =&gt; $format,
               }
           );

       Example 6. Highlight cells that are 1 std deviation above the average for the range:

           $worksheet-&gt;conditional_formatting( 'A1:F10',
               {
                   type     =&gt; 'average',
                   format   =&gt; $format,
               }
           );

       Example 7. Highlight duplicate cells in a range:

           $worksheet-&gt;conditional_formatting( 'A1:F10',
               {
                   type     =&gt; 'duplicate',
                   format   =&gt; $format,
               }
           );

       Example 8. Highlight unique cells in a range.

           $worksheet-&gt;conditional_formatting( 'A1:F10',
               {
                   type     =&gt; 'unique',
                   format   =&gt; $format,
               }
           );

       Example 9. Highlight the top 10 cells.

           $worksheet-&gt;conditional_formatting( 'A1:F10',
               {
                   type     =&gt; 'top',
                   value    =&gt; 10,
                   format   =&gt; $format,
               }
           );

       Example 10. Highlight blank cells.

           $worksheet-&gt;conditional_formatting( 'A1:F10',
               {
                   type     =&gt; 'blanks',
                   format   =&gt; $format,
               }
           );

       Example 11. Set traffic light icons in 3 cells:

           $worksheet-&gt;conditional_formatting( 'A1:C1',
               {
                   type         =&gt; 'icon_set',
                   icon_style   =&gt; '3_traffic_lights',
               }
           );

       See also the "conditional_format.pl" example program in "EXAMPLES".

</pre><h4><b>SPARKLINES</b> <b>IN</b> <b>EXCEL</b></h4><pre>
       Sparklines  are  a  feature of Excel 2010+ which allows you to add small charts to worksheet cells. These
       are useful for showing visual trends in data in a compact format.

       In Excel::Writer::XLSX Sparklines can be added to cells using the "add_sparkline()" worksheet method:

           $worksheet-&gt;add_sparkline(
               {
                   location =&gt; 'F2',
                   range    =&gt; 'Sheet1!A2:E2',
                   type     =&gt; 'column',
                   style    =&gt; 12,
               }
           );

       <b>Note:</b> Sparklines are a feature of Excel 2010+ only. You can write them to an XLSX file that can  be  read
       by Excel 2007 but they won't be displayed.

   <b>add_sparkline(</b> <b>{</b> <b>parameter</b> <b>=&gt;</b> <b>'value',</b> <b>...</b> <b>}</b> <b>)</b>
       The "add_sparkline()" worksheet method is used to add sparklines to a cell or a range of cells.

       The parameters to "add_sparkline()" must be passed in a hash ref. The main sparkline parameters are:

           location        (required)
           range           (required)
           type
           style

           markers
           negative_points
           axis
           reverse

       Other, less commonly used parameters are:

           high_point
           low_point
           first_point
           last_point
           max
           min
           empty_cells
           show_hidden
           date_axis
           weight

           series_color
           negative_color
           markers_color
           first_color
           last_color
           high_color
           low_color

       These parameters are explained in the sections below:

   <b>location</b>
       This is the cell where the sparkline will be displayed:

           location =&gt; 'F1'

       The "location" should be a single cell. (For multiple cells see "Grouped Sparklines" below).

       To  specify  the  location  in  row-column  notation  use  the  "xl_rowcol_to_cell()"  function  from the
       Excel::Writer::XLSX::Utility module.

           use Excel::Writer::XLSX::Utility ':rowcol';
           ...
           location =&gt; xl_rowcol_to_cell( 0, 5 ), # F1

   <b>range</b>
       This specifies the cell data range that the sparkline will plot:

           $worksheet-&gt;add_sparkline(
               {
                   location =&gt; 'F1',
                   range    =&gt; 'A1:E1',
               }
           );

       The "range" should be a 2D array. (For 3D arrays of cells see "Grouped Sparklines" below).

       If "range" is not on the same worksheet you can specify its location using the usual Excel notation:

                   range =&gt; 'Sheet1!A1:E1',

       If the worksheet contains spaces or special characters you should quote the worksheet name  in  the  same
       way that Excel does:

                   range =&gt; q('Monthly Data'!A1:E1),

       To  specify  the  location  in row-column notation use the "xl_range()" or "xl_range_formula()" functions
       from the Excel::Writer::XLSX::Utility module.

           use Excel::Writer::XLSX::Utility ':rowcol';
           ...
           range =&gt; xl_range( 1, 1,  0, 4 ),                   # 'A1:E1'
           range =&gt; xl_range_formula( 'Sheet1', 0, 0,  0, 4 ), # 'Sheet1!A2:E2'

   <b>type</b>
       Specifies the type of sparkline. There are 3 available sparkline types:

           line    (default)
           column
           win_loss

       For example:

           {
               location =&gt; 'F1',
               range    =&gt; 'A1:E1',
               type     =&gt; 'column',
           }

   <b>style</b>
       Excel provides 36 built-in Sparkline styles in 6 groups of 6.  The  "style"  parameter  can  be  used  to
       replicate these and should be a corresponding number from 1 .. 36.

           {
               location =&gt; 'A14',
               range    =&gt; 'Sheet2!A2:J2',
               style    =&gt; 3,
           }

       The style number starts in the top left of the style grid and runs left to right. The default style is 1.
       It is possible to override colour elements of the sparklines using the *_color parameters below.

   <b>markers</b>
       Turn on the markers for "line" style sparklines.

           {
               location =&gt; 'A6',
               range    =&gt; 'Sheet2!A1:J1',
               markers  =&gt; 1,
           }

       Markers aren't shown in Excel for "column" and "win_loss" sparklines.

   <b>negative_points</b>
       Highlight negative values in a sparkline range. This is usually required with "win_loss" sparklines.

           {
               location        =&gt; 'A21',
               range           =&gt; 'Sheet2!A3:J3',
               type            =&gt; 'win_loss',
               negative_points =&gt; 1,
           }

   <b>axis</b>
       Display a horizontal axis in the sparkline:

           {
               location =&gt; 'A10',
               range    =&gt; 'Sheet2!A1:J1',
               axis     =&gt; 1,
           }

   <b>reverse</b>
       Plot the data from right-to-left instead of the default left-to-right:

           {
               location =&gt; 'A24',
               range    =&gt; 'Sheet2!A4:J4',
               type     =&gt; 'column',
               reverse  =&gt; 1,
           }

   <b>weight</b>
       Adjust the default line weight (thickness) for "line" style sparklines.

            weight =&gt; 0.25,

       The weight value should be one of the following values allowed by Excel:

           0.25  0.5   0.75
           1     1.25
           2.25
           3
           4.25
           6

   <b>high_point,</b> <b>low_point,</b> <b>first_point,</b> <b>last_point</b>
       Highlight points in a sparkline range.

               high_point  =&gt; 1,
               low_point   =&gt; 1,
               first_point =&gt; 1,
               last_point  =&gt; 1,

   <b>max,</b> <b>min</b>
       Specify the maximum and minimum vertical axis values:

               max         =&gt; 0.5,
               min         =&gt; -0.5,

       As a special case you can set the maximum and minimum to be for a group of sparklines rather than one:

               max         =&gt; 'group',

       See "Grouped Sparklines" below.

   <b>empty_cells</b>
       Define how empty cells are handled in a sparkline.

           empty_cells =&gt; 'zero',

       The available options are:

           gaps   : show empty cells as gaps (the default).
           zero   : plot empty cells as 0.
           connect: Connect points with a line ("line" type  sparklines only).

   <b>show_hidden</b>
       Plot data in hidden rows and columns:

           show_hidden =&gt; 1,

       Note, this option is off by default.

   <b>date_axis</b>
       Specify  an  alternative  date  axis for the sparkline. This is useful if the data being plotted isn't at
       fixed width intervals:

           {
               location  =&gt; 'F3',
               range     =&gt; 'A3:E3',
               date_axis =&gt; 'A4:E4',
           }

       The number of cells in the date range should correspond to the number of cells in the data range.

   <b>series_color</b>
       It is possible to override the colour of a sparkline style using the following parameters:

           series_color
           negative_color
           markers_color
           first_color
           last_color
           high_color
           low_color

       The color should be specified as a HTML style "#rrggbb" hex value:

           {
               location     =&gt; 'A18',
               range        =&gt; 'Sheet2!A2:J2',
               type         =&gt; 'column',
               series_color =&gt; '#E965E0',
           }

   <b>Grouped</b> <b>Sparklines</b>
       The "add_sparkline()" worksheet method can be used multiple times to write  as  many  sparklines  as  are
       required in a worksheet.

       However, it is sometimes necessary to group contiguous sparklines so that changes that are applied to one
       are applied to all. In Excel this is achieved by selecting a 3D range of cells for the data "range" and a
       2D range of cells for the "location".

       In  Excel::Writer::XLSX,  you  can  simulate  this  by  passing an array refs of values to "location" and
       "range":

           {
               location =&gt; [ 'A27',          'A28',          'A29'          ],
               range    =&gt; [ 'Sheet2!A5:J5', 'Sheet2!A6:J6', 'Sheet2!A7:J7' ],
               markers  =&gt; 1,
           }

   <b>Sparkline</b> <b>examples</b>
       See the "sparklines1.pl" and "sparklines2.pl" example programs in the "examples" directory of the distro.

</pre><h4><b>TABLES</b> <b>IN</b> <b>EXCEL</b></h4><pre>
       Tables in Excel are a way of grouping a range of cells into a single entity that has common formatting or
       that can be referenced from formulas. Tables can have column headers,  autofilters,  total  rows,  column
       formulas and default formatting.

       For        more        information        see       "An       Overview       of       Excel       Tables"
       &lt;<a href="http://office.microsoft.com/en-us/excel-help/overview-of-excel-tables-HA010048546.aspx">http://office.microsoft.com/en-us/excel-help/overview-of-excel-tables-HA010048546.aspx</a>&gt;.

       Note, tables don't work in Excel::Writer::XLSX when "set_optimization()" mode in on.

   <b>add_table(</b> <b>$row1,</b> <b>$col1,</b> <b>$row2,</b> <b>$col2,</b> <b>{</b> <b>parameter</b> <b>=&gt;</b> <b>'value',</b> <b>...</b> <b>})</b>
       Tables are added to a worksheet using the "add_table()" method:

           $worksheet-&gt;add_table( 'B3:F7', { %parameters } );

       The data range can be specified in 'A1' or 'row/col' notation (see also the note  about  "Cell  notation"
       for more information):

           $worksheet-&gt;add_table( 'B3:F7' );
           # Same as:
           $worksheet-&gt;add_table(  2, 1, 6, 5 );

       The  last  parameter  in  "add_table()"  should be a hash ref containing the parameters that describe the
       table options and data. The available parameters are:

               data
               autofilter
               header_row
               banded_columns
               banded_rows
               first_column
               last_column
               style
               total_row
               columns
               name

       The table parameters are detailed below. There are no required parameters and the hash ref isn't required
       if no options are specified.

   <b>data</b>
       The "data" parameter can be used to specify the data in the cells of the table.

           my $data = [
               [ 'Apples',  10000, 5000, 8000, 6000 ],
               [ 'Pears',   2000,  3000, 4000, 5000 ],
               [ 'Bananas', 6000,  6000, 6500, 6000 ],
               [ 'Oranges', 500,   300,  200,  700 ],

           ];

           $worksheet-&gt;add_table( 'B3:F7', { data =&gt; $data } );

       Table data can also be written separately, as an array or individual cells.

           # These two statements are the same as the single statement above.
           $worksheet-&gt;add_table( 'B3:F7' );
           $worksheet-&gt;write_col( 'B4', $data );

       Writing the cell data separately is occasionally required when you need to control the "write_*()" method
       used to populate the cells or if you wish to tweak the cell formatting.

       The "data" structure should be an array ref of array refs holding row data as shown above.

   <b>header_row</b>
       The "header_row" parameter can be used to turn on or off the header  row  in  the  table.  It  is  on  by
       default.

           $worksheet-&gt;add_table( 'B4:F7', { header_row =&gt; 0 } ); # Turn header off.

       The  header row will contain default captions such as "Column 1", "Column 2",  etc. These captions can be
       overridden using the "columns" parameter below.

   <b>autofilter</b>
       The "autofilter" parameter can be used to turn on or off the autofilter in the header row. It  is  on  by
       default.

           $worksheet-&gt;add_table( 'B3:F7', { autofilter =&gt; 0 } ); # Turn autofilter off.

       The "autofilter" is only shown if the "header_row" is on. Filters within the table are not supported.

   <b>banded_rows</b>
       The  "banded_rows" parameter can be used to used to create rows of alternating colour in the table. It is
       on by default.

           $worksheet-&gt;add_table( 'B3:F7', { banded_rows =&gt; 0 } );

   <b>banded_columns</b>
       The "banded_columns" parameter can be used to used to create columns of alternating colour in the  table.
       It is off by default.

           $worksheet-&gt;add_table( 'B3:F7', { banded_columns =&gt; 1 } );

   <b>first_column</b>
       The  "first_column"  parameter  can  be  used  to  highlight  the  first column of the table. The type of
       highlighting will depend on the "style" of the table. It may be bold text or a different  colour.  It  is
       off by default.

           $worksheet-&gt;add_table( 'B3:F7', { first_column =&gt; 1 } );

   <b>last_column</b>
       The  "last_column"  parameter  can  be  used  to  highlight  the  last  column  of the table. The type of
       highlighting will depend on the "style" of the table. It may be bold text or a different  colour.  It  is
       off by default.

           $worksheet-&gt;add_table( 'B3:F7', { last_column =&gt; 1 } );

   <b>style</b>
       The "style" parameter can be used to set the style of the table. Standard Excel table format names should
       be used (with matching capitalisation):

           $worksheet11-&gt;add_table(
               'B3:F7',
               {
                   data      =&gt; $data,
                   style     =&gt; 'Table Style Light 11',
               }
           );

       The default table style is 'Table Style Medium 9'.

       You can also turn the table style off by setting it to 'None':

           $worksheet11-&gt;add_table( 'B3:F7', { style =&gt; 'None' } );

   <b>name</b>
       By  default tables are named "Table1", "Table2", etc. The "name" parameter can be used to set the name of
       the table:

           $worksheet-&gt;add_table( 'B3:F7', { name =&gt; 'SalesData' } );

       If you override the table name you must ensure that it doesn't clash with an existing table name and that
       it          follows          Excel's           requirements           for           table           names
       &lt;<a href="http://office.microsoft.com/en-001/excel-help/define-and-use-names-in-formulas-HA010147120.aspx">http://office.microsoft.com/en-001/excel-help/define-and-use-names-in-formulas-HA010147120.aspx</a>#BMsyntax_rules_for_names&gt;.

       If you need to know the name of the table, for example to use it in a formula, you can get it as follows:

           my $table      = $worksheet2-&gt;add_table( 'B3:F7' );
           my $table_name = $table-&gt;{_name};

   <b>total_row</b>
       The  "total_row"  parameter  can  be  used  to  turn  on  the total row in the last row of a table. It is
       distinguished from the other rows by a different formatting and also with dropdown "SUBTOTAL" functions.

           $worksheet-&gt;add_table( 'B3:F7', { total_row =&gt; 1 } );

       The default total row doesn't have any captions or functions. These must by specified via  the  "columns"
       parameter below.

   <b>columns</b>
       The "columns" parameter can be used to set properties for columns within the table.

       The sub-properties that can be set are:

           header
           formula
           total_string
           total_function
           total_value
           format
           header_format

       The  column  data  must  be  specified  as an array ref of hash refs. For example to override the default
       'Column n' style table headers:

           $worksheet-&gt;add_table(
               'B3:F7',
               {
                   data    =&gt; $data,
                   columns =&gt; [
                       { header =&gt; 'Product' },
                       { header =&gt; 'Quarter 1' },
                       { header =&gt; 'Quarter 2' },
                       { header =&gt; 'Quarter 3' },
                       { header =&gt; 'Quarter 4' },
                   ]
               }
           );

       If you don't wish to specify properties for a specific column you pass an empty hash ref and the defaults
       will be applied:

                   ...
                   columns =&gt; [
                       { header =&gt; 'Product' },
                       { header =&gt; 'Quarter 1' },
                       { },                        # Defaults to 'Column 3'.
                       { header =&gt; 'Quarter 3' },
                       { header =&gt; 'Quarter 4' },
                   ]
                   ...

       Column formulas can by applied using the "formula" column property:

           $worksheet8-&gt;add_table(
               'B3:G7',
               {
                   data    =&gt; $data,
                   columns =&gt; [
                       { header =&gt; 'Product' },
                       { header =&gt; 'Quarter 1' },
                       { header =&gt; 'Quarter 2' },
                       { header =&gt; 'Quarter 3' },
                       { header =&gt; 'Quarter 4' },
                       {
                           header  =&gt; 'Year',
                           formula =&gt; '=SUM(Table8[@[Quarter 1]:[Quarter 4]])'
                       },
                   ]
               }
           );

       The Excel 2007 "[#This Row]" and Excel 2010 "@" structural references are supported within the formula.

       As stated above the "total_row" table parameter turns on the "Total" row in  the  table  but  it  doesn't
       populate  it with any defaults. Total captions and functions must be specified via the "columns" property
       and the "total_string", "total_function" and "total_value" sub properties:

           $worksheet10-&gt;add_table(
               'B3:F8',
               {
                   data      =&gt; $data,
                   total_row =&gt; 1,
                   columns   =&gt; [
                       { header =&gt; 'Product',   total_string   =&gt; 'Totals' },
                       { header =&gt; 'Quarter 1', total_function =&gt; 'sum' },
                       { header =&gt; 'Quarter 2', total_function =&gt; 'sum' },
                       { header =&gt; 'Quarter 3', total_function =&gt; 'sum' },
                       { header =&gt; 'Quarter 4', total_function =&gt; 'sum' },
                   ]
               }
           );

       The supported totals row "SUBTOTAL" functions are:

               average
               count_nums
               count
               max
               min
               std_dev
               sum
               var

       User defined functions or formulas aren't supported.

       It is also possible to set a calculated value  for  the  "total_function"  using  the  "total_value"  sub
       property. This is only necessary when creating workbooks for applications that cannot calculate the value
       of formulas automatically. This is similar to setting the "value" optional property in "write_formula()":

           $worksheet10-&gt;add_table(
               'B3:F8',
               {
                   data      =&gt; $data,
                   total_row =&gt; 1,
                   columns   =&gt; [
                       { total_string   =&gt; 'Totals' },
                       { total_function =&gt; 'sum', total_value =&gt; 100 },
                       { total_function =&gt; 'sum', total_value =&gt; 200 },
                       { total_function =&gt; 'sum', total_value =&gt; 100 },
                       { total_function =&gt; 'sum', total_value =&gt; 400 },
                   ]
               }
           );

       Formatting  can  also  be  applied  to columns, to the column data using "format" and to the header using
       "header_format":

           my $currency_format = $workbook-&gt;add_format( num_format =&gt; '$#,##0' );

           $worksheet-&gt;add_table(
               'B3:D8',
               {
                   data      =&gt; $data,
                   total_row =&gt; 1,
                   columns   =&gt; [
                       { header =&gt; 'Product', total_string =&gt; 'Totals' },
                       {
                           header         =&gt; 'Quarter 1',
                           total_function =&gt; 'sum',
                           format         =&gt; $currency_format,
                       },
                       {
                           header         =&gt; 'Quarter 2',
                           header_format  =&gt; $bold,
                           total_function =&gt; 'sum',
                           format         =&gt; $currency_format,
                       },
                   ]
               }
           );

       Standard Excel::Writer::XLSX format objects can be used. However, they should  be  limited  to  numerical
       formats  for  the  columns  and  simple formatting like text wrap for the headers. Overriding other table
       formatting may produce inconsistent results.

</pre><h4><b>FORMULAS</b> <b>AND</b> <b>FUNCTIONS</b> <b>IN</b> <b>EXCEL</b></h4><pre>
   <b>Introduction</b>
       The following is a brief introduction to formulas and functions in Excel and Excel::Writer::XLSX.

       A formula is a string that begins with an equals sign:

           '=A1+B1'
           '=AVERAGE(1, 2, 3)'

       The formula can contain numbers, strings, boolean values, cell references,  cell  ranges  and  functions.
       Named  ranges  are  not  supported. Formulas should be written as they appear in Excel, that is cells and
       functions must be in uppercase.

       Cells in Excel are referenced using the A1 notation system where the column is designated by a letter and
       the row by a number. Columns range from A to XFD i.e. 0 to 16384, rows  range  from  1  to  1048576.  The
       "Excel::Writer::XLSX::Utility"  module  that  is  included  in  the  distro contains helper functions for
       dealing with A1 notation, for example:

           use Excel::Writer::XLSX::Utility;

           ( $row, $col ) = xl_cell_to_rowcol( 'C2' );    # (1, 2)
           $str = xl_rowcol_to_cell( 1, 2 );              # C2

       The Excel "$" notation in cell references is also supported. This allows you to specify whether a row  or
       column  is  relative  or  absolute. This only has an effect if the cell is copied. The following examples
       show relative and absolute values.

           '=A1'   # Column and row are relative
           '=$A1'  # Column is absolute and row is relative
           '=A$1'  # Column is relative and row is absolute
           '=$A$1' # Column and row are absolute

       Formulas can also refer to cells in other worksheets of the current workbook. For example:

           '=Sheet2!A1'
           '=Sheet2!A1:A5'
           '=Sheet2:Sheet3!A1'
           '=Sheet2:Sheet3!A1:A5'
           q{='Test Data'!A1}
           q{='Test Data1:Test Data2'!A1}

       The sheet reference and the cell reference are separated by "!" the exclamation mark symbol. If worksheet
       names contain spaces, commas or parentheses then Excel requires that  the  name  is  enclosed  in  single
       quotes  as  shown  in the last two examples above. In order to avoid using a lot of escape characters you
       can use the quote operator "q{}" to protect the quotes. See "perlop" in the main Perl documentation. Only
       valid sheet names that have been added using the "add_worksheet()" method can be used  in  formulas.  You
       cannot reference external workbooks.

       The  following  table  lists  the  operators  that are available in Excel's formulas. The majority of the
       operators are the same as Perl's, differences are indicated:

           Arithmetic operators:
           =====================
           Operator  Meaning                   Example
              +      Addition                  1+2
              -      Subtraction               2-1
              *      Multiplication            2*3
              /      Division                  1/4
              ^      Exponentiation            2^3      # Equivalent to **
              -      Unary minus               -(1+2)
              %      Percent (Not modulus)     13%

           Comparison operators:
           =====================
           Operator  Meaning                   Example
               =     Equal to                  A1 =  B1 # Equivalent to ==
               &lt;&gt;    Not equal to              A1 &lt;&gt; B1 # Equivalent to !=
               &gt;     Greater than              A1 &gt;  B1
               &lt;     Less than                 A1 &lt;  B1
               &gt;=    Greater than or equal to  A1 &gt;= B1
               &lt;=    Less than or equal to     A1 &lt;= B1

           String operator:
           ================
           Operator  Meaning                   Example
               &amp;     Concatenation             "Hello " &amp; "World!" # [1]

           Reference operators:
           ====================
           Operator  Meaning                   Example
               :     Range operator            A1:A4               # [2]
               ,     Union operator            SUM(1, 2+2, B3)     # [3]

           Notes:
           [1]: Equivalent to "Hello " . "World!" in Perl.
           [2]: This range is equivalent to cells A1, A2, A3 and A4.
           [3]: The comma behaves like the list separator in Perl.

       The range and comma operators can have different symbols in non-English versions of Excel, see below.

       For a general introduction to Excel's formulas and an explanation of the syntax of the function refer  to
       the             Excel            help            files            or            the            following:
       &lt;<a href="http://office.microsoft.com/en-us/assistance/CH062528031033.aspx">http://office.microsoft.com/en-us/assistance/CH062528031033.aspx</a>&gt;.

       In most cases a formula in Excel can be used directly in the "write_formula" method. However, there are a
       few potential issues and differences that the user should  be  aware  of.  These  are  explained  in  the
       following sections.

   <b>Non</b> <b>US</b> <b>Excel</b> <b>functions</b> <b>and</b> <b>syntax</b>
       Excel  stores  formulas  in the format of the US English version, regardless of the language or locale of
       the end-user's version of Excel. Therefore all formula function names written  using  Excel::Writer::XLSX
       must be in English:

           worksheet-&gt;write_formula('A1', '=SUM(1, 2, 3)');   # OK
           worksheet-&gt;write_formula('A2', '=SOMME(1, 2, 3)'); # French. Error on load.

       Also,  formulas  must  be  written with the US style separator/range operator which is a comma (not semi-
       colon). Therefore a formula with multiple values should be written as follows:

           worksheet-&gt;write_formula('A1', '=SUM(1, 2, 3)'); # OK
           worksheet-&gt;write_formula('A2', '=SUM(1; 2; 3)'); # Semi-colon. Error on load.

       If you have a non-English version of Excel you can use the  following  multi-lingual  Formula  Translator
       (&lt;<a href="http://en.excel-translator.de/language/">http://en.excel-translator.de/language/</a>&gt;)  to  help  you convert the formula. It can also replace semi-
       colons with commas.

   <b>Formulas</b> <b>added</b> <b>in</b> <b>Excel</b> <b>2010</b> <b>and</b> <b>later</b>
       Excel 2010 and later added functions which weren't defined in  the  original  file  specification.  These
       functions  are  referred  to  by  Microsoft  as <u>future</u> functions. Examples of these functions are "ACOT",
       "CHISQ.DIST.RT" , "CONFIDENCE.NORM", "STDEV.P", "STDEV.S" and "WORKDAY.INTL".

       When written using "write_formula()" these functions need to be  fully  qualified  with  a  "_xlfn."  (or
       other) prefix as they are shown the list below. For example:

           worksheet-&gt;write_formula('A1', '=_xlfn.STDEV.S(B1:B10)')

       They will appear without the prefix in Excel.

       The   following   list  is  taken  from  the  MS  XLSX  extensions  documentation  on  future  functions:
       &lt;<a href="http://msdn.microsoft.com/en-us/library/dd907480">http://msdn.microsoft.com/en-us/library/dd907480</a>%28v=office.12%29.aspx&gt;:

           _xlfn.ACOT
           _xlfn.ACOTH
           _xlfn.AGGREGATE
           _xlfn.ARABIC
           _xlfn.BASE
           _xlfn.BETA.DIST
           _xlfn.BETA.INV
           _xlfn.BINOM.DIST
           _xlfn.BINOM.DIST.RANGE
           _xlfn.BINOM.INV
           _xlfn.BITAND
           _xlfn.BITLSHIFT
           _xlfn.BITOR
           _xlfn.BITRSHIFT
           _xlfn.BITXOR
           _xlfn.CEILING.MATH
           _xlfn.CEILING.PRECISE
           _xlfn.CHISQ.DIST
           _xlfn.CHISQ.DIST.RT
           _xlfn.CHISQ.INV
           _xlfn.CHISQ.INV.RT
           _xlfn.CHISQ.TEST
           _xlfn.COMBINA
           _xlfn.CONFIDENCE.NORM
           _xlfn.CONFIDENCE.T
           _xlfn.COT
           _xlfn.COTH
           _xlfn.COVARIANCE.P
           _xlfn.COVARIANCE.S
           _xlfn.CSC
           _xlfn.CSCH
           _xlfn.DAYS
           _xlfn.DECIMAL
           ECMA.CEILING
           _xlfn.ERF.PRECISE
           _xlfn.ERFC.PRECISE
           _xlfn.EXPON.DIST
           _xlfn.F.DIST
           _xlfn.F.DIST.RT
           _xlfn.F.INV
           _xlfn.F.INV.RT
           _xlfn.F.TEST
           _xlfn.FILTERXML
           _xlfn.FLOOR.MATH
           _xlfn.FLOOR.PRECISE
           _xlfn.FORECAST.ETS
           _xlfn.FORECAST.ETS.CONFINT
           _xlfn.FORECAST.ETS.SEASONALITY
           _xlfn.FORECAST.ETS.STAT
           _xlfn.FORECAST.LINEAR
           _xlfn.FORMULATEXT
           _xlfn.GAMMA
           _xlfn.GAMMA.DIST
           _xlfn.GAMMA.INV
           _xlfn.GAMMALN.PRECISE
           _xlfn.GAUSS
           _xlfn.HYPGEOM.DIST
           _xlfn.IFNA
           _xlfn.IMCOSH
           _xlfn.IMCOT
           _xlfn.IMCSC
           _xlfn.IMCSCH
           _xlfn.IMSEC
           _xlfn.IMSECH
           _xlfn.IMSINH
           _xlfn.IMTAN
           _xlfn.ISFORMULA
           ISO.CEILING
           _xlfn.ISOWEEKNUM
           _xlfn.LOGNORM.DIST
           _xlfn.LOGNORM.INV
           _xlfn.MODE.MULT
           _xlfn.MODE.SNGL
           _xlfn.MUNIT
           _xlfn.NEGBINOM.DIST
           NETWORKDAYS.INTL
           _xlfn.NORM.DIST
           _xlfn.NORM.INV
           _xlfn.NORM.S.DIST
           _xlfn.NORM.S.INV
           _xlfn.NUMBERVALUE
           _xlfn.PDURATION
           _xlfn.PERCENTILE.EXC
           _xlfn.PERCENTILE.INC
           _xlfn.PERCENTRANK.EXC
           _xlfn.PERCENTRANK.INC
           _xlfn.PERMUTATIONA
           _xlfn.PHI
           _xlfn.POISSON.DIST
           _xlfn.QUARTILE.EXC
           _xlfn.QUARTILE.INC
           _xlfn.QUERYSTRING
           _xlfn.RANK.AVG
           _xlfn.RANK.EQ
           _xlfn.RRI
           _xlfn.SEC
           _xlfn.SECH
           _xlfn.SHEET
           _xlfn.SHEETS
           _xlfn.SKEW.P
           _xlfn.STDEV.P
           _xlfn.STDEV.S
           _xlfn.T.DIST
           _xlfn.T.DIST.2T
           _xlfn.T.DIST.RT
           _xlfn.T.INV
           _xlfn.T.INV.2T
           _xlfn.T.TEST
           _xlfn.UNICHAR
           _xlfn.UNICODE
           _xlfn.VAR.P
           _xlfn.VAR.S
           _xlfn.WEBSERVICE
           _xlfn.WEIBULL.DIST
           WORKDAY.INTL
           _xlfn.XOR
           _xlfn.Z.TEST

   <b>Using</b> <b>Tables</b> <b>in</b> <b>Formulas</b>
       Worksheet tables can be added with Excel::Writer::XLSX using the "add_table()" method:

           worksheet-&gt;add_table('B3:F7', {options});

       By default tables are named "Table1", "Table2", etc., in the order that they are added.  However  it  can
       also be set by the user using the "name" parameter:

           worksheet-&gt;add_table('B3:F7', {'name': 'SalesData'});

       If you need to know the name of the table, for example to use it in a formula, you can get it as follows:

           table = worksheet-&gt;add_table('B3:F7');
           table_name = table-&gt;{_name};

       When  used  in  a  formula a table name such as "TableX" should be referred to as "TableX[]" (like a Perl
       array):

           worksheet-&gt;write_formula('A5', '=VLOOKUP("Sales", Table1[], 2, FALSE');

   <b>Dealing</b> <b>with</b> <b>#NAME?</b> <b>errors</b>
       If there is an error in the syntax of a formula it is usually displayed in  Excel  as  "#NAME?".  If  you
       encounter an error like this you can debug it as follows:

       1. Ensure the formula is valid in Excel by copying and pasting it into a cell. Note, this should be done
       in Excel and not other applications such as OpenOffice or LibreOffice since they may have slightly
       different syntax.
       2. Ensure the formula is using comma separators instead of semi-colons, see "Non US Excel functions and
       syntax" above.
       3. Ensure the formula is in English, see "Non US Excel functions and syntax" above.
       4. Ensure that the formula doesn't contain an Excel 2010+ future function as listed in "Formulas added in
       Excel 2010 and later" above. If it does then ensure that the correct prefix is used.

       Finally  if  you  have  completed all the previous steps and still get a "#NAME?" error you can examine a
       valid Excel file to see what the correct syntax should be. To do this you should create a  valid  formula
       in Excel and save the file. You can then examine the XML in the unzipped file.

       The    following    shows    how    to    do    that   using   Linux   "unzip"   and   libxml's   xmllint
       &lt;<a href="http://xmlsoft.org/xmllint.html">http://xmlsoft.org/xmllint.html</a>&gt; to format the XML for clarity:

           $ unzip myfile.xlsx -d myfile
           $ xmllint --format myfile/xl/worksheets/sheet1.xml | grep '&lt;f&gt;'

                   &lt;f&gt;SUM(1, 2, 3)&lt;/f&gt;

   <b>Formula</b> <b>Results</b>
       Excel::Writer::XLSX doesn't calculate the result of a formula and instead  stores  the  value  0  as  the
       formula result. It then sets a global flag in the XLSX file to say that all formulas and functions should
       be recalculated when the file is opened.

       This  is  the method recommended in the Excel documentation and in general it works fine with spreadsheet
       applications. However, applications that don't have a facility to calculate formulas  will  only  display
       the  0  results.  Examples  of such applications are Excel Viewer, PDF Converters, and some mobile device
       applications.

       If required, it is also possible to specify the calculated result of the formula using the optional  last
       "value" parameter in "write_formula":

           worksheet-&gt;write_formula('A1', '=2+2', num_format, 4);

       The  "value"  parameter  can  be  a  number,  a string, a boolean sting ('TRUE' or 'FALSE') or one of the
       following Excel error codes:

           #DIV/0!
           #N/A
           #NAME?
           #NULL!
           #NUM!
           #REF!
           #VALUE!

       It  is  also  possible  to  specify  the  calculated  result   of   an   array   formula   created   with
       "write_array_formula":

           # Specify the result for a single cell range.
           worksheet-&gt;write_array_formula('A1:A1', '{=SUM(B1:C1*B2:C2)}', format, 2005);

       However,  using this parameter only writes a single value to the upper left cell in the result array. For
       a multi-cell array formula where the results are required, the other result values can  be  specified  by
       using "write_number()" to write to the appropriate cell:

           # Specify the results for a multi cell range.
           worksheet-&gt;write_array_formula('A1:A3', '{=TREND(C1:C3,B1:B3)}', format, 15);
           worksheet-&gt;write_number('A2', 12, format);
           worksheet-&gt;write_number('A3', 14, format);

</pre><h4><b>WORKING</b> <b>WITH</b> <b>VBA</b> <b>MACROS</b></h4><pre>
       An  Excel  "xlsm"  file  is  exactly  the  same  as  a  "xlsx" file except that is includes an additional
       "vbaProject.bin" file which contains functions  and/or  macros.  Excel  uses  a  different  extension  to
       differentiate  between  the  two  file  formats  since  files  containing  macros  are usually subject to
       additional security checks.

       The "vbaProject.bin" file is a binary OLE COM container. This was the format used in older "xls" versions
       of Excel prior to Excel 2007. Unlike all of the other components of an  xlsx/xlsm  file  the  data  isn't
       stored  in XML format. Instead the functions and macros as stored as pre-parsed binary format. As such it
       wouldn't be feasible to define macros and create a "vbaProject.bin" file from scratch (at  least  not  in
       the remaining lifespan and interest levels of the author).

       Instead  a  workaround  is  used  to extract "vbaProject.bin" files from existing xlsm files and then add
       these to Excel::Writer::XLSX files.

   <b>The</b> <b>extract_vba</b> <b>utility</b>
       The "extract_vba" utility is used to extract the "vbaProject.bin" binary from an Excel 2007+  xlsm  file.
       The  utility  is  included in the Excel::Writer::XLSX bin directory and is also installed as a standalone
       executable file:

           $ extract_vba macro_file.xlsm
           Extracted: vbaProject.bin

   <b>Adding</b> <b>the</b> <b>VBA</b> <b>macros</b> <b>to</b> <b>a</b> <b>Excel::Writer::XLSX</b> <b>file</b>
       Once the "vbaProject.bin" file has been extracted it can be added  to  the  Excel::Writer::XLSX  workbook
       using the "add_vba_project()" method:

           $workbook-&gt;add_vba_project( './vbaProject.bin' );

       If the VBA file contains functions you can then refer to them in calculations using "write_formula":

           $worksheet-&gt;write_formula( 'A1', '=MyMortgageCalc(200000, 25)' );

       Excel  files that contain functions and macros should use an "xlsm" extension or else Excel will complain
       and possibly not open the file:

           my $workbook  = Excel::Writer::XLSX-&gt;new( 'file.xlsm' );

       It is also possible to assign a  macro  to  a  button  that  is  inserted  into  a  worksheet  using  the
       "insert_button()" method:

           my $workbook  = Excel::Writer::XLSX-&gt;new( 'file.xlsm' );
           ...
           $workbook-&gt;add_vba_project( './vbaProject.bin' );

           $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'my_macro' } );

       It may be necessary to specify a more explicit macro name prefixed by the workbook VBA name as follows:

           $worksheet-&gt;insert_button( 'C2', { macro =&gt; 'ThisWorkbook.my_macro' } );

       See the "macros.pl" from the examples directory for a working example.

       Note:  Button  is  the  only  VBA  Control  supported  by Excel::Writer::XLSX. Due to the large effort in
       implementation (1+ man months) it is unlikely that any other form elements will be added in the future.

   <b>Setting</b> <b>the</b> <b>VBA</b> <b>codenames</b>
       VBA macros generally refer to workbook and worksheet objects. If the VBA codenames aren't specified  then
       Excel::Writer::XLSX will use the Excel defaults of "ThisWorkbook" and "Sheet1", "Sheet2" etc.

       If  the  macro  uses  other  codenames you can set them using the workbook and worksheet "set_vba_name()"
       methods as follows:

             $workbook-&gt;set_vba_name( 'MyWorkbook' );
             $worksheet-&gt;set_vba_name( 'MySheet' );

       You can find the names that are used in the VBA editor or by unzipping the "xlsm" file and  grepping  the
       files.  The  following  shows  how to do that using libxml's xmllint &lt;<a href="http://xmlsoft.org/xmllint.html">http://xmlsoft.org/xmllint.html</a>&gt; to
       format the XML for clarity:

           $ unzip myfile.xlsm -d myfile
           $ xmllint --format `find myfile -name "*.xml" | xargs` | grep "Pr.*codeName"

             &lt;workbookPr codeName="MyWorkbook" defaultThemeVersion="124226"/&gt;
             &lt;sheetPr codeName="MySheet"/&gt;

       Note: This step is particularly important for macros created with non-English versions of Excel.

   <b>What</b> <b>to</b> <b>do</b> <b>if</b> <b>it</b> <b>doesn't</b> <b>work</b>
       This feature should be considered experimental and there is no guarantee that it will work in all  cases.
       Some  effort may be required and some knowledge of VBA will certainly help. If things don't work out here
       are some things to try:

       •   Start with a simple macro file, ensure that it works and then add complexity.

       •   Try to extract the macros from an Excel 2007 file. The method should  work  with  macros  from  later
           versions  (it  was  also  tested  with Excel 2010 macros). However there may be features in the macro
           files of more recent version of Excel that aren't backward compatible.

       •   Check the code names that macros use to refer to  the  workbook  and  worksheets  (see  the  previous
           section  above).  In  general VBA uses a code name of "ThisWorkbook" to refer to the current workbook
           and the sheet name (such as "Sheet1") to refer to the worksheets. These  are  the  defaults  used  by
           Excel::Writer::XLSX.  If the macro uses other names then you can specify these using the workbook and
           worksheet "set_vba_name()" methods:

                 $workbook&gt;set_vba_name( 'MyWorkbook' );
                 $worksheet-&gt;set_vba_name( 'MySheet' );

</pre><h4><b>EXAMPLES</b></h4><pre>
       See Excel::Writer::XLSX::Examples for a full list of examples.

   <b>Example</b> <b>1</b>
       The following example shows some of the basic features of Excel::Writer::XLSX.

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Excel::Writer::XLSX;

           # Create a new workbook called simple.xlsx and add a worksheet
           my $workbook  = Excel::Writer::XLSX-&gt;new( 'simple.xlsx' );
           my $worksheet = $workbook-&gt;add_worksheet();

           # The general syntax is write($row, $column, $token). Note that row and
           # column are zero indexed

           # Write some text
           $worksheet-&gt;write( 0, 0, 'Hi Excel!' );

           # Write some numbers
           $worksheet-&gt;write( 2, 0, 3 );
           $worksheet-&gt;write( 3, 0, 3.00000 );
           $worksheet-&gt;write( 4, 0, 3.00001 );
           $worksheet-&gt;write( 5, 0, 3.14159 );

           # Write some formulas
           $worksheet-&gt;write( 7, 0, '=A3 + A6' );
           $worksheet-&gt;write( 8, 0, '=IF(A5&gt;3,"Yes", "No")' );

           # Write a hyperlink
           my $hyperlink_format = $workbook-&gt;add_format(
               color     =&gt; 'blue',
               underline =&gt; 1,
           );

           $worksheet-&gt;write( 10, 0, '<a href="http://www.perl.com/">http://www.perl.com/</a>', $hyperlink_format );

           $workbook-&gt;close();

   <b>Example</b> <b>2</b>
       The following is a general example which demonstrates some features of working with multiple worksheets.

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Excel::Writer::XLSX;

           # Create a new Excel workbook
           my $workbook = Excel::Writer::XLSX-&gt;new( 'regions.xlsx' );

           # Add some worksheets
           my $north = $workbook-&gt;add_worksheet( 'North' );
           my $south = $workbook-&gt;add_worksheet( 'South' );
           my $east  = $workbook-&gt;add_worksheet( 'East' );
           my $west  = $workbook-&gt;add_worksheet( 'West' );

           # Add a Format
           my $format = $workbook-&gt;add_format();
           $format-&gt;set_bold();
           $format-&gt;set_color( 'blue' );

           # Add a caption to each worksheet
           for my $worksheet ( $workbook-&gt;sheets() ) {
               $worksheet-&gt;write( 0, 0, 'Sales', $format );
           }

           # Write some data
           $north-&gt;write( 0, 1, 200000 );
           $south-&gt;write( 0, 1, 100000 );
           $east-&gt;write( 0, 1, 150000 );
           $west-&gt;write( 0, 1, 100000 );

           # Set the active worksheet
           $south-&gt;activate();

           # Set the width of the first column
           $south-&gt;set_column( 0, 0, 20 );

           # Set the active cell
           $south-&gt;set_selection( 0, 1 );

           $workbook-&gt;close();

   <b>Example</b> <b>3</b>
       Example of how to add conditional formatting to an Excel::Writer::XLSX file. The example below highlights
       cells that have a value greater than or equal to 50 in red and cells below that value in green.

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>

           use strict;
           use warnings;
           use Excel::Writer::XLSX;

           my $workbook  = Excel::Writer::XLSX-&gt;new( 'conditional_format.xlsx' );
           my $worksheet = $workbook-&gt;add_worksheet();

           # This example below highlights cells that have a value greater than or
           # equal to 50 in red and cells below that value in green.

           # Light red fill with dark red text.
           my $format1 = $workbook-&gt;add_format(
               bg_color =&gt; '#FFC7CE',
               color    =&gt; '#9C0006',

           );

           # Green fill with dark green text.
           my $format2 = $workbook-&gt;add_format(
               bg_color =&gt; '#C6EFCE',
               color    =&gt; '#006100',

           );

           # Some sample data to run the conditional formatting against.
           my $data = [
               [ 34, 72,  38, 30, 75, 48, 75, 66, 84, 86 ],
               [ 6,  24,  1,  84, 54, 62, 60, 3,  26, 59 ],
               [ 28, 79,  97, 13, 85, 93, 93, 22, 5,  14 ],
               [ 27, 71,  40, 17, 18, 79, 90, 93, 29, 47 ],
               [ 88, 25,  33, 23, 67, 1,  59, 79, 47, 36 ],
               [ 24, 100, 20, 88, 29, 33, 38, 54, 54, 88 ],
               [ 6,  57,  88, 28, 10, 26, 37, 7,  41, 48 ],
               [ 52, 78,  1,  96, 26, 45, 47, 33, 96, 36 ],
               [ 60, 54,  81, 66, 81, 90, 80, 93, 12, 55 ],
               [ 70, 5,   46, 14, 71, 19, 66, 36, 41, 21 ],
           ];

           my $caption = 'Cells with values &gt;= 50 are in light red. '
             . 'Values &lt; 50 are in light green';

           # Write the data.
           $worksheet-&gt;write( 'A1', $caption );
           $worksheet-&gt;write_col( 'B3', $data );

           # Write a conditional format over a range.
           $worksheet-&gt;conditional_formatting( 'B3:K12',
               {
                   type     =&gt; 'cell',
                   criteria =&gt; '&gt;=',
                   value    =&gt; 50,
                   format   =&gt; $format1,
               }
           );

           # Write another conditional format over the same range.
           $worksheet-&gt;conditional_formatting( 'B3:K12',
               {
                   type     =&gt; 'cell',
                   criteria =&gt; '&lt;',
                   value    =&gt; 50,
                   format   =&gt; $format2,
               }
           );

           $workbook-&gt;close();

   <b>Example</b> <b>4</b>
       The following is a simple example of using functions.

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Excel::Writer::XLSX;

           # Create a new workbook and add a worksheet
           my $workbook  = Excel::Writer::XLSX-&gt;new( 'stats.xlsx' );
           my $worksheet = $workbook-&gt;add_worksheet( 'Test data' );

           # Set the column width for columns 1
           $worksheet-&gt;set_column( 0, 0, 20 );

           # Create a format for the headings
           my $format = $workbook-&gt;add_format();
           $format-&gt;set_bold();

           # Write the sample data
           $worksheet-&gt;write( 0, 0, 'Sample', $format );
           $worksheet-&gt;write( 0, 1, 1 );
           $worksheet-&gt;write( 0, 2, 2 );
           $worksheet-&gt;write( 0, 3, 3 );
           $worksheet-&gt;write( 0, 4, 4 );
           $worksheet-&gt;write( 0, 5, 5 );
           $worksheet-&gt;write( 0, 6, 6 );
           $worksheet-&gt;write( 0, 7, 7 );
           $worksheet-&gt;write( 0, 8, 8 );

           $worksheet-&gt;write( 1, 0, 'Length', $format );
           $worksheet-&gt;write( 1, 1, 25.4 );
           $worksheet-&gt;write( 1, 2, 25.4 );
           $worksheet-&gt;write( 1, 3, 24.8 );
           $worksheet-&gt;write( 1, 4, 25.0 );
           $worksheet-&gt;write( 1, 5, 25.3 );
           $worksheet-&gt;write( 1, 6, 24.9 );
           $worksheet-&gt;write( 1, 7, 25.2 );
           $worksheet-&gt;write( 1, 8, 24.8 );

           # Write some statistical functions
           $worksheet-&gt;write( 4, 0, 'Count', $format );
           $worksheet-&gt;write( 4, 1, '=COUNT(B1:I1)' );

           $worksheet-&gt;write( 5, 0, 'Sum', $format );
           $worksheet-&gt;write( 5, 1, '=SUM(B2:I2)' );

           $worksheet-&gt;write( 6, 0, 'Average', $format );
           $worksheet-&gt;write( 6, 1, '=AVERAGE(B2:I2)' );

           $worksheet-&gt;write( 7, 0, 'Min', $format );
           $worksheet-&gt;write( 7, 1, '=MIN(B2:I2)' );

           $worksheet-&gt;write( 8, 0, 'Max', $format );
           $worksheet-&gt;write( 8, 1, '=MAX(B2:I2)' );

           $worksheet-&gt;write( 9, 0, 'Standard Deviation', $format );
           $worksheet-&gt;write( 9, 1, '=STDEV(B2:I2)' );

           $worksheet-&gt;write( 10, 0, 'Kurtosis', $format );
           $worksheet-&gt;write( 10, 1, '=KURT(B2:I2)' );

           $workbook-&gt;close();

   <b>Example</b> <b>5</b>
       The following example converts  a  tab  separated  file  called  "tab.txt"  into  an  Excel  file  called
       "tab.xlsx".

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           use strict;
           use Excel::Writer::XLSX;

           open( TABFILE, 'tab.txt' ) or die "tab.txt: $!";

           my $workbook  = Excel::Writer::XLSX-&gt;new( 'tab.xlsx' );
           my $worksheet = $workbook-&gt;add_worksheet();

           # Row and column are zero indexed
           my $row = 0;

           while ( &lt;TABFILE&gt; ) {
               chomp;

               # Split on single tab
               my @fields = split( '\t', $_ );

               my $col = 0;
               for my $token ( @fields ) {
                   $worksheet-&gt;write( $row, $col, $token );
                   $col++;
               }
               $row++;
           }

           $workbook-&gt;close();

       NOTE:  This  is  a  simple conversion program for illustrative purposes only. For converting a CSV or Tab
       separated or any other type of delimited text file to Excel I recommend the more rigorous csv2xls program
       that is part of H.Merijn Brand's Text::CSV_XS module distro.

       See the examples/csv2xls link here: &lt;<a href="http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST">http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST</a>&gt;.

   <b>Additional</b> <b>Examples</b>
       The following is a description of the example files that are provided in the standard Excel::Writer::XLSX
       distribution.  They   demonstrate   the   different   features   and   options   of   the   module.   See
       Excel::Writer::XLSX::Examples for more details.

           Getting started
           ===============
           a_simple.pl             A simple demo of some of the features.
           bug_report.pl           A template for submitting bug reports.
           demo.pl                 A demo of some of the available features.
           formats.pl              All the available formatting on several worksheets.
           regions.pl              A simple example of multiple worksheets.
           stats.pl                Basic formulas and functions.

           Intermediate
           ============
           autofit.pl              Examples of simulated worksheet autofit.
           autofilter.pl           Examples of worksheet autofilters.
           array_formula.pl        Examples of how to write array formulas.
           cgi.pl                  A simple CGI program.
           chart_area.pl           A demo of area style charts.
           chart_bar.pl            A demo of bar (vertical histogram) style charts.
           chart_column.pl         A demo of column (histogram) style charts.
           chart_line.pl           A demo of line style charts.
           chart_pie.pl            A demo of pie style charts.
           chart_doughnut.pl       A demo of doughnut style charts.
           chart_radar.pl          A demo of radar style charts.
           chart_scatter.pl        A demo of scatter style charts.
           chart_secondary_axis.pl A demo of a line chart with a secondary axis.
           chart_combined.pl       A demo of a combined column and line chart.
           chart_pareto.pl         A demo of a combined Pareto chart.
           chart_stock.pl          A demo of stock style charts.
           chart_data_table.pl     A demo of a chart with a data table on the axis.
           chart_data_tools.pl     A demo of charts with data highlighting options.
           chart_data_labels.pl    A demo of standard and custom chart data labels.
           chart_clustered.pl      A demo of a chart with a clustered axis.
           chart_styles.pl         A demo of the available chart styles.
           chart_gauge.pl          A demo of a gauge style chart.
           colors.pl               A demo of the colour palette and named colours.
           comments1.pl            Add comments to worksheet cells.
           comments2.pl            Add comments with advanced options.
           conditional_format.pl   Add conditional formats to a range of cells.
           data_validate.pl        An example of data validation and dropdown lists.
           date_time.pl            Write dates and times with write_date_time().
           defined_name.pl         Example of how to create defined names.
           diag_border.pl          A simple example of diagonal cell borders.
           dynamic_arrays.pl       Example of using new Excel 365 dynamic functions.
           filehandle.pl           Examples of working with filehandles.
           headers.pl              Examples of worksheet headers and footers.
           hide_row_col.pl         Example of hiding rows and columns.
           hide_sheet.pl           Simple example of hiding a worksheet.
           hyperlink1.pl           Shows how to create web hyperlinks.
           hyperlink2.pl           Examples of internal and external hyperlinks.
           indent.pl               An example of cell indentation.
           ignore_errors.pl        An example of turning off worksheet cells errors/warnings.
           lambda.pl               Example of using the Excel 365 LAMBDA() function.
           macros.pl               An example of adding macros from an existing file.
           merge1.pl               A simple example of cell merging.
           merge2.pl               A simple example of cell merging with formatting.
           merge3.pl               Add hyperlinks to merged cells.
           merge4.pl               An advanced example of merging with formatting.
           merge5.pl               An advanced example of merging with formatting.
           merge6.pl               An example of merging with Unicode strings.
           mod_perl1.pl            A simple mod_perl 1 program.
           mod_perl2.pl            A simple mod_perl 2 program.
           outline.pl              An example of outlines and grouping.
           outline_collapsed.pl    An example of collapsed outlines.
           panes.pl                An example of how to create panes.
           properties.pl           Add document properties to a workbook.
           protection.pl           Example of cell locking and formula hiding.
           rich_strings.pl         Example of strings with multiple formats.
           right_to_left.pl        Change default sheet direction to right to left.
           sales.pl                An example of a simple sales spreadsheet.
           shape1.pl               Insert shapes in worksheet.
           shape2.pl               Insert shapes in worksheet. With properties.
           shape3.pl               Insert shapes in worksheet. Scaled.
           shape4.pl               Insert shapes in worksheet. With modification.
           shape5.pl               Insert shapes in worksheet. With connections.
           shape6.pl               Insert shapes in worksheet. With connections.
           shape7.pl               Insert shapes in worksheet. One to many connections.
           shape8.pl               Insert shapes in worksheet. One to many connections.
           shape_all.pl            Demo of all the available shape and connector types.
           sparklines1.pl          Simple sparklines demo.
           sparklines2.pl          Sparklines demo showing formatting options.
           stats_ext.pl            Same as stats.pl with external references.
           stocks.pl               Demonstrates conditional formatting.
           watermark.pl            Example of how to set a watermark image for a worksheet.
           background.pl           Example of how to set the background image for a worksheet.
           tab_colors.pl           Example of how to set worksheet tab colours.
           tables.pl               Add Excel tables to a worksheet.
           write_handler1.pl       Example of extending the write() method. Step 1.
           write_handler2.pl       Example of extending the write() method. Step 2.
           write_handler3.pl       Example of extending the write() method. Step 3.
           write_handler4.pl       Example of extending the write() method. Step 4.
           write_to_scalar.pl      Example of writing an Excel file to a Perl scalar.

           Unicode
           =======
           unicode_2022_jp.pl      Japanese: ISO-2022-JP.
           unicode_8859_11.pl      Thai:     ISO-8859_11.
           unicode_8859_7.pl       Greek:    ISO-8859_7.
           unicode_big5.pl         Chinese:  BIG5.
           unicode_cp1251.pl       Russian:  CP1251.
           unicode_cp1256.pl       Arabic:   CP1256.
           unicode_cyrillic.pl     Russian:  Cyrillic.
           unicode_koi8r.pl        Russian:  KOI8-R.
           unicode_polish_utf8.pl  Polish :  UTF8.
           unicode_shift_jis.pl    Japanese: Shift JIS.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       The following limits are imposed by Excel 2007+:

           Description                                Limit
           --------------------------------------     ------
           Maximum number of chars in a string        32,767
           Maximum number of columns                  16,384
           Maximum number of rows                     1,048,576
           Maximum chars in a sheet name              31
           Maximum chars in a header/footer           254

           Maximum characters in hyperlink url (1)    2079
           Maximum number of unique hyperlinks (2)    65,530

       (1)  Versions of Excel prior to Excel 2015 limited hyperlink links and anchor/locations to 255 characters
       each. Versions after that support urls up to  2079  characters.  Excel::Writer::XLSX  versions  &gt;=  1.0.2
       support the new longer limit by default.

       (2)  Per worksheet. Excel allows a greater number of non-unique hyperlinks if they are contiguous and can
       be grouped into a single range. This isn't supported by Excel::Writer::XLSX.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       &lt;<a href="http://search.cpan.org/search">http://search.cpan.org/search</a>?dist=Archive-Zip/&gt;.

       Perl 5.8.2.

</pre><h4><b>SPEED</b> <b>AND</b> <b>MEMORY</b> <b>USAGE</b></h4><pre>
       "Spreadsheet::WriteExcel" was written to optimise speed and reduce memory usage.  However,  these  design
       goals  meant  that  it  wasn't  easy  to  implement  features  that  many users requested such as writing
       formatting and data separately.

       As a result "Excel::Writer::XLSX" takes a different design approach and holds a lot more data  in  memory
       so that it is functionally more flexible.

       The  effect of this is that Excel::Writer::XLSX is about 30% slower than Spreadsheet::WriteExcel and uses
       5 times more memory.

       In addition the extended row and column ranges in Excel 2007+ mean that it is  possible  to  run  out  of
       memory creating large files. This was almost never an issue with Spreadsheet::WriteExcel.

       This memory usage can be reduced almost completely by using the Workbook "set_optimization()" method:

           $workbook-&gt;set_optimization();

       The  trade-off is that you won't be able to take advantage of features that manipulate cell data after it
       is written. One such feature is Tables.

</pre><h4><b>DOWNLOADING</b></h4><pre>
       The      latest      version      of      this      module      is       always       available       at:
       &lt;<a href="http://search.cpan.org/search">http://search.cpan.org/search</a>?dist=Excel-Writer-XLSX/&gt;.

</pre><h4><b>INSTALLATION</b></h4><pre>
       The module can be installed using the standard Perl procedure:

                   perl Makefile.PL
                   make
                   make test
                   make install    # You may need to be sudo/root

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Filename required by Excel::Writer::XLSX-&gt;<b>new()</b>
           A filename must be given in the constructor.

       Can't open filename. It may be in use or protected.
           The  file cannot be opened for writing. The directory that you are writing to may be protected or the
           file may be in use by another program.

       Can't call method "XXX" on an undefined value at someprogram.pl.
           On Windows this is usually caused by the file that you are trying to create clashing with  a  version
           that is already open and locked by Excel.

       The file you are trying to open 'file.xls' is in a different format than specified by the file extension.
           This warning occurs when you create an XLSX file but give it an xls extension.

</pre><h4><b>WRITING</b> <b>EXCEL</b> <b>FILES</b></h4><pre>
       Depending  on your requirements, background and general sensibilities you may prefer one of the following
       methods of getting data into Excel:

       •   Spreadsheet::WriteExcel

           This module is the precursor to Excel::Writer::XLSX and uses the same interface. It produces files in
           the Excel Biff xls format that was used in Excel versions 97-2003. These files can still be  read  by
           Excel  2007  but  have some limitations in relation to the number of rows and columns that the format
           supports.

           Spreadsheet::WriteExcel.

       •   Win32::OLE module and office automation

           This requires a Windows platform and an installed copy of  Excel.  This  is  the  most  powerful  and
           complete method for interfacing with Excel.

           Win32::OLE

       •   CSV, comma separated variables or text

           Excel will open and automatically convert files with a "csv" extension.

           To create CSV files refer to the Text::CSV_XS module.

       •   DBI with DBD::ADO or DBD::ODBC

           Excel  files  contain an internal index table that allows them to act like a database file. Using one
           of the standard Perl database modules you can connect to an Excel file as a database.

       For        other        Perl-Excel        modules        try        the         following         search:
       &lt;<a href="http://search.cpan.org/search">http://search.cpan.org/search</a>?mode=module&amp;query=excel&gt;.

</pre><h4><b>READING</b> <b>EXCEL</b> <b>FILES</b></h4><pre>
       To read data from Excel files try:

       •   Spreadsheet::ParseXLSX

           A  module  for  reading data from XLSX files. It also imports most, if not all, of the metadata to be
           found  in  Excel  XLSX  files.   As  its  author  describes  it:  "This  module  is  an  adaptor  for
           Spreadsheet::ParseExcel  that reads XLSX files. For documentation about the various data that you can
           retrieve from these classes, please see  Spreadsheet::ParseExcel,  Spreadsheet::ParseExcel::Workbook,
           Spreadsheet::ParseExcel::Worksheet, and Spreadsheet::ParseExcel::Cell."

       •   Spreadsheet::XLSX

           A module for reading formatted or unformatted data from XLSX files.

           Spreadsheet::XLSX

       •   SimpleXlsx

           A lightweight module for reading data from XLSX files.

           SimpleXlsx

       •   Spreadsheet::ParseExcel

           This module can read data from an Excel XLS file but it doesn't support the XLSX format.

           Spreadsheet::ParseExcel

       •   Win32::OLE module and office automation (reading)

           See above.

       •   DBI with DBD::ADO or DBD::ODBC.

           See above.

       For         other         Perl-Excel        modules        try        the        following        search:
       &lt;<a href="http://search.cpan.org/search">http://search.cpan.org/search</a>?mode=module&amp;query=excel&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       •   Memory usage is very high for large worksheets.

           If you run out of memory creating large worksheets use the "set_optimization()"  method.  See  "SPEED
           AND MEMORY USAGE" for more information.

       •   Perl packaging programs can't find chart modules.

           When  using  Excel::Writer::XLSX charts with Perl packagers such as PAR or Cava you should explicitly
           include the chart that you are trying to create in your "use" statements. This isn't a  bug  as  such
           but it might help someone from banging their head off a wall:

               ...
               use Excel::Writer::XLSX;
               use Excel::Writer::XLSX::Chart::Column;
               ...

       If  you  wish  to  submit a bug report run the "bug_report.pl" program in the "examples" directory of the
       distro.

       The bug tracker is on Github: &lt;https://github.com/jmcnamara/excel-writer-xlsx/issues&gt;.

</pre><h4><b>REPOSITORY</b></h4><pre>
       The Excel::Writer::XLSX source code in host on github: &lt;<a href="http://github.com/jmcnamara/excel-writer-xlsx">http://github.com/jmcnamara/excel-writer-xlsx</a>&gt;.

</pre><h4><b>DONATIONS</b> <b>and</b> <b>SPONSORSHIP</b></h4><pre>
       If you'd care to donate to the Excel::Writer::XLSX project or sponsor a new feature, you can  do  so  via
       PayPal: &lt;<a href="http://tinyurl.com/7ayes">http://tinyurl.com/7ayes</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Spreadsheet::WriteExcel: &lt;<a href="http://search.cpan.org/dist/Spreadsheet-WriteExcel">http://search.cpan.org/dist/Spreadsheet-WriteExcel</a>&gt;.

       Spreadsheet::ParseExcel: &lt;<a href="http://search.cpan.org/dist/Spreadsheet-ParseExcel">http://search.cpan.org/dist/Spreadsheet-ParseExcel</a>&gt;.

       Spreadsheet::XLSX: &lt;<a href="http://search.cpan.org/dist/Spreadsheet-XLSX">http://search.cpan.org/dist/Spreadsheet-XLSX</a>&gt;.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       The following people contributed to the debugging, testing or enhancement of Excel::Writer::XLSX:

       Rob  Messer  of  IntelliSurvey  gave  me  the  initial prompt to port Spreadsheet::WriteExcel to the XLSX
       format. IntelliSurvey (&lt;<a href="http://www.intellisurvey.com">http://www.intellisurvey.com</a>&gt;) also sponsored large files optimisations  and  the
       charting feature.

       Bariatric Advantage (&lt;<a href="http://www.bariatricadvantage.com">http://www.bariatricadvantage.com</a>&gt;) sponsored work on chart formatting.

       Eric   Johnson   provided   the   ability   to  use  secondary  axes  with  charts.   Thanks  to  Foxtons
       (&lt;<a href="http://foxtons.co.uk">http://foxtons.co.uk</a>&gt;) for sponsoring this work.

       BuildFax (&lt;<a href="http://www.buildfax.com">http://www.buildfax.com</a>&gt;) sponsored the Tables feature and the Chart point formatting feature.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       Because this software is licensed free of charge, there is no warranty for the software,  to  the  extent
       permitted  by  applicable law. Except when otherwise stated in writing the copyright holders and/or other
       parties provide the software "as  is"  without  warranty  of  any  kind,  either  expressed  or  implied,
       including,  but  not  limited  to, the implied warranties of merchantability and fitness for a particular
       purpose. The entire risk as to the quality and performance of  the  software  is  with  you.  Should  the
       software prove defective, you assume the cost of all necessary servicing, repair, or correction.

       In  no  event unless required by applicable law or agreed to in writing will any copyright holder, or any
       other party who may modify and/or redistribute the software as permitted by the above licence, be  liable
       to  you  for damages, including any general, special, incidental, or consequential damages arising out of
       the use or inability to use the software (including but not  limited  to  loss  of  data  or  data  being
       rendered  inaccurate  or losses sustained by you or third parties or a failure of the software to operate
       with any other software), even if such holder or other party has been advised of the possibility of  such
       damages.

</pre><h4><b>LICENSE</b></h4><pre>
       The Perl Artistic Licence &lt;<a href="http://dev.perl.org/licenses/artistic.html">http://dev.perl.org/licenses/artistic.html</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       John McNamara <a href="mailto:jmcnamara@cpan.org">jmcnamara@cpan.org</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright MM-MMXXIII, John McNamara.

       All  Rights  Reserved.  This module is free software. It may be used, redistributed and/or modified under
       the same terms as Perl itself.

perl v5.36.0                                       2023-04-12                           <u>Excel::Writer::<a href="../man3pm/XLSX.3pm.html">XLSX</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>