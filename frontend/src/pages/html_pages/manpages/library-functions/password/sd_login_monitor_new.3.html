<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sd_login_monitor_new, sd_login_monitor_unref, sd_login_monitor_unrefp, sd_login_monitor_flush,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsystemd-dev">libsystemd-dev_257.7-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sd_login_monitor_new, sd_login_monitor_unref, sd_login_monitor_unrefp, sd_login_monitor_flush,
       sd_login_monitor_get_fd, sd_login_monitor_get_events, sd_login_monitor_get_timeout, sd_login_monitor -
       Monitor login sessions, seats, users and virtual machines/containers

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;systemd/sd-login.h&gt;</b>

       <b>int</b> <b>sd_login_monitor_new(const</b> <b>char</b> <b>*</b><u>category</u><b>,</b> <b>sd_login_monitor</b> <b>**</b><u>ret</u><b>);</b>

       <b>sd_login_monitor</b> <b>*sd_login_monitor_unref(sd_login_monitor</b> <b>*</b><u>m</u><b>);</b>

       <b>void</b> <b>sd_login_monitor_unrefp(sd_login_monitor</b> <b>**</b><u>m</u><b>);</b>

       <b>int</b> <b>sd_login_monitor_flush(sd_login_monitor</b> <b>*</b><u>m</u><b>);</b>

       <b>int</b> <b>sd_login_monitor_get_fd(sd_login_monitor</b> <b>*</b><u>m</u><b>);</b>

       <b>int</b> <b>sd_login_monitor_get_events(sd_login_monitor</b> <b>*</b><u>m</u><b>);</b>

       <b>int</b> <b>sd_login_monitor_get_timeout(sd_login_monitor</b> <b>*</b><u>m</u><b>,</b> <b>uint64_t</b> <b>*</b><u>timeout_usec</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sd_login_monitor_new()</b> may be used to monitor login sessions, users, seats, and virtual
       machines/containers. Via a monitor object a file descriptor can be integrated into an application defined
       event loop which is woken up each time a user logs in, logs out or a seat is added or removed, or a
       session, user, seat or virtual machine/container changes state otherwise. The first parameter takes a
       string which can be "seat" (to get only notifications about seats being added, removed or changed),
       "session" (to get only notifications about sessions being created or removed or changed), "uid" (to get
       only notifications when a user changes state in respect to logins) or "machine" (to get only
       notifications when a virtual machine or container is started or stopped). If notifications shall be
       generated in all these conditions, <b>NULL</b> may be passed. Note that in the future additional categories may
       be defined. The second parameter returns a monitor object and needs to be freed with the
       <b>sd_login_monitor_unref()</b> call after use.

       <b>sd_login_monitor_unref()</b> may be used to destroy a monitor object. Note that this will invalidate any file
       descriptor returned by <b>sd_login_monitor_get_fd()</b>.

       <b>sd_login_monitor_unrefp()</b> is similar to <b>sd_login_monitor_unref()</b> but takes a pointer to a pointer to an
       <b>sd_login_monitor</b> object. This call is useful in conjunction with GCC's and LLVM's <b>Clean-up</b> <b>Variable</b>
       <b>Attribute</b>[1]. Note that this function is defined as inline function. Use a declaration like the
       following, in order to allocate a login monitor object that is freed automatically as the code block is
       left:

           {
             __attribute__((cleanup(sd_login_monitor_unrefp))) sd_login_monitor *m = NULL;
             int r;
             ...
             r = sd_login_monitor_new(NULL, &amp;m);
             if (r &lt; 0) {
               errno = -r;
               fprintf(stderr, "Failed to allocate login monitor object: %m\n");
             }
             ...
           }

       <b>sd_login_monitor_flush()</b> may be used to reset the wakeup state of the monitor object. Whenever an event
       causes the monitor to wake up the event loop via the file descriptor this function needs to be called to
       reset the wake-up state. If this call is not invoked, the file descriptor will immediately wake up the
       event loop again.

       <b>sd_login_monitor_unref()</b> and <b>sd_login_monitor_unrefp()</b> execute no operation if the passed in monitor
       object is <b>NULL</b>.

       <b>sd_login_monitor_get_fd()</b> may be used to retrieve the file descriptor of the monitor object that may be
       integrated in an application defined event loop, based around <b><a href="../man2/poll.2.html">poll</a></b>(2) or a similar interface. The
       application should include the returned file descriptor as wake-up source for the events mask returned by
       <b>sd_login_monitor_get_events()</b>. It should pass a timeout value as returned by
       <b>sd_login_monitor_get_timeout()</b>. Whenever a wake-up is triggered the file descriptor needs to be reset via
       <b>sd_login_monitor_flush()</b>. An application needs to reread the login state with a function like
       <b><a href="../man3/sd_get_seats.3.html">sd_get_seats</a></b>(3) or similar to determine what changed.

       <b>sd_login_monitor_get_events()</b> will return the <b>poll()</b> mask to wait for. This function will return a
       combination of <b>POLLIN</b>, <b>POLLOUT</b> and similar to fill into the ".events" field of <u>struct</u> <u>pollfd</u>.

       <b>sd_login_monitor_get_timeout()</b> will return a timeout value for usage in <b>poll()</b>. This returns a value in
       microseconds since the epoch of <b>CLOCK_MONOTONIC</b> for timing out <b>poll()</b> in <u>timeout_usec</u>. See
       <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2) for details about <b>CLOCK_MONOTONIC</b>. If there is no timeout to wait for this will fill in
       <b>(uint64_t)</b> <b>-1</b> instead. Note that <b>poll()</b> takes a relative timeout in milliseconds rather than an absolute
       timeout in microseconds. To convert the absolute 'Î¼s' timeout into relative 'ms', use code like the
       following:

           uint64_t t;
           int msec;
           sd_login_monitor_get_timeout(m, &amp;t);
           if (t == (uint64_t) -1)
             msec = -1;
           else {
             struct timespec ts;
             uint64_t n;
             clock_gettime(CLOCK_MONOTONIC, &amp;ts);
             n = (uint64_t) ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
             msec = t &gt; n ? (int) ((t - n + 999) / 1000) : 0;
           }

       The code above does not do any error checking for brevity's sake. The calculated <u>msec</u> integer can be
       passed directly as <b>poll()</b>'s timeout parameter.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>sd_login_monitor_new()</b>, <b>sd_login_monitor_flush()</b> and <b>sd_login_monitor_get_timeout()</b> return 0
       or a positive integer. On success, <b>sd_login_monitor_get_fd()</b> returns a Unix file descriptor. On success,
       <b>sd_login_monitor_get_events()</b> returns a combination of <b>POLLIN</b>, <b>POLLOUT</b> and suchlike. On failure, these
       calls return a negative errno-style error code.

       <b>sd_login_monitor_unref()</b> always returns <b>NULL</b>.

   <b>Errors</b>
       Returned errors may indicate the following problems:

       <b>-EINVAL</b>
           An input parameter was invalid (out of range, or <b>NULL</b>, where that is not accepted). The specified
           category to watch is not known.

       <b>-ENOMEM</b>
           Memory allocation failed.

</pre><h4><b>NOTES</b></h4><pre>
       Functions described here are available as a shared library, which can be compiled against and linked to
       with the <b>libsystemd</b> <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1) file.

       The code described here uses <b><a href="../man3/getenv.3.html">getenv</a></b>(3), which is declared to be not multi-thread-safe. This means that
       the code calling the functions described here must not call <b><a href="../man3/setenv.3.html">setenv</a></b>(3) from a parallel thread. It is
       recommended to only do calls to <b>setenv()</b> from an early phase of the program when no other threads have
       been started.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>sd_login_monitor_get_events()</b> and <b>sd_login_monitor_get_timeout()</b> were added in version 201.

       <b>sd_login_monitor_unrefp()</b> was added in version 229.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man3/sd-login.3.html">sd-login</a></b>(3), <b><a href="../man3/sd_get_seats.3.html">sd_get_seats</a></b>(3), <b><a href="../man2/poll.2.html">poll</a></b>(2), <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2)

</pre><h4><b>NOTES</b></h4><pre>
        1. Clean-up Variable Attribute
           https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html

systemd 257.7                                                                            <u><a href="../man3/SD_LOGIN_MONITOR_NEW.3.html">SD_LOGIN_MONITOR_NEW</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>