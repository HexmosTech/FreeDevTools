<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zipfs - Mount and work with ZIP files within Tcl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zipfs - Mount and work with ZIP files within Tcl

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>zipfs</b> <b>canonical</b> ?<u>mountpoint</u>? <u>filename</u>
       <b>zipfs</b> <b>exists</b> <u>filename</u>
       <b>zipfs</b> <b>find</b> <u>directoryName</u>
       <b>zipfs</b> <b>info</b> <u>filename</u>
       <b>zipfs</b> <b>list</b> ?(<b>-glob</b>|<b>-regexp</b>)? ?<u>pattern</u>?
       <b>zipfs</b> <b>lmkimg</b> <u>outfile</u> <u>inlist</u> ?<u>password</u>? ?<u>infile</u>?
       <b>zipfs</b> <b>lmkzip</b> <u>outfile</u> <u>inlist</u> ?<u>password</u>?
       <b>zipfs</b> <b>mkimg</b> <u>outfile</u> <u>indir</u> ?<u>strip</u>? ?<u>password</u>? ?<u>infile</u>?
       <b>zipfs</b> <b>mkkey</b> <u>password</u>
       <b>zipfs</b> <b>mkzip</b> <u>outfile</u> <u>indir</u> ?<u>strip</u>? ?<u>password</u>?
       <b>zipfs</b> <b>mount</b> ?<u>zipfile</u>? ?<u>mountpoint</u>? ?<u>password</u>?
       <b>zipfs</b> <b>mountdata</b> <u>data</u> <u>mountpoint</u>
       <b>zipfs</b> <b>root</b>
       <b>zipfs</b> <b>unmount</b> <u>mountpoint</u>
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>zipfs</b> command provides Tcl with the ability to mount the contents of a ZIP archive file as a virtual
       file system. Tcl's ZIP archive support is limited to  basic  features  and  options.   Supported  storage
       methods  include  only  STORE  and  DEFLATE with optional simple encryption, sufficient to prevent casual
       inspection of their contents but not able to prevent access by even  a  moderately  determined  attacker.
       Strong  encryption,  multi-part  archives, platform metadata, zip64 formats and other compression methods
       like bzip2 are not supported.

       Files within mounted archives can be written to but new files or directories cannot be created.  Further,
       modifications to files are limited to the mounted archive in memory and are not persisted to disk.

       Paths in mounted archives are case-sensitive on all platforms.

       <b>zipfs</b> <b>canonical</b> ?<u>mountpoint</u>? <u>filename</u>
              This  takes the name of a file, <u>filename</u>, and produces where it would be mapped into a zipfs mount
              as its result. If specified, <u>mountpoint</u> says within which mount  the  mapping  will  be  done;  if
              omitted, the main root of the zipfs system is used.

       <b>zipfs</b> <b>exists</b> <u>filename</u>
              Return 1 if the given filename exists in the mounted zipfs and 0 if it does not.

       <b>zipfs</b> <b>find</b> <u>directoryName</u>
              Returns  the  list of paths under directory <u>directoryName</u> which need not be within a zipfs mounted
              archive. The paths are prefixed with <u>directoryName</u>.  This command is also used by the <b>zipfs</b>  <b>mkzip</b>
              and <b>zipfs</b> <b>mkimg</b> commands.

       <b>zipfs</b> <b>info</b> <u>file</u>
              Return information about the given <u>file</u> in the mounted zipfs.  The information consists of:

              (1)    the name of the ZIP archive file that contains the file,

              (2)    the size of the file after decompressions,

              (3)    the compressed size of the file, and

              (4)    the offset of the compressed data in the ZIP archive file.

              As  a special case, querying the mount point gives the start of the zip data as the offset in (4),
              which can be used to truncate the zip information from an executable. Querying an  ancestor  of  a
              mount point will raise an error.

       <b>zipfs</b> <b>list</b> ?(<b>-glob</b>|<b>-regexp</b>)? ?<u>pattern</u>?
              If  <u>pattern</u>  is  not  specified,  the  command  returns  a  list of files across all zipfs mounted
              archives. If <u>pattern</u> is specified, only those paths matching the pattern are returned. By default,
              or with the <b>-glob</b> option, the pattern is treated as  a  glob  pattern  and  matching  is  done  as
              described  for  the <b>string</b> <b>match</b> command. Alternatively, the <b>-regexp</b> option may be used to specify
              matching <b>pattern</b> as a regular expression. The file names are returned  in  arbitrary  order.  Note
              that  path  separators  are  treated  as ordinary characters in the matching. Thus forward slashes
              should be used as path separators in the pattern. The returned paths only include  those  actually
              in the archive and does not include intermediate directories in mount paths.

       <b>zipfs</b> <b>mount</b>

       <b>zipfs</b> <b>mount</b> <u>mountpoint</u>

       <b>zipfs</b> <b>mount</b> <u>zipfile</u> <u>mountpoint</u> ?<u>password</u>?

              The  <b>zipfs</b>  <b>mount</b>  command mounts ZIP archives as Tcl virtual file systems and returns information
              about current mounts.

              With no arguments, the command returns a dictionary mapping  mount  points  to  the  path  of  the
              corresponding ZIP archive.

              In  the  single argument form, the command returns the file path of the ZIP archive mounted at the
              specified mount point.

              In the third form, the command mounts the ZIP archive <u>zipfile</u>  as  a  Tcl  virtual  filesystem  at
              <u>mountpoint</u>.   After  this  command  executes,  files contained in <u>zipfile</u> will appear to Tcl to be
              regular files at the mount point. If <u>mountpoint</u> is specified as an empty string, it  is  defaulted
              to the <b>[zipfs</b> <b>root]</b>.  The command returns the normalized mount point path.

              If not under the zipfs file system root, <u>mountpoint</u> is normalized with respect to it. For example,
              a mount point passed as either <b>mt</b> or <b>/mt</b> would be normalized to <b>//zipfs:/mt</b> (given that <b>zipfs</b> <b>root</b>
              returns “//zipfs:/”).  An error is raised if the mount point includes a drive or UNC volume.

              <b>NB:</b>  because  the current working directory is a concept maintained by the operating system, using
              <b>cd</b> into a mounted  archive  will  only  work  in  the  current  process,  and  then  not  entirely
              consistently  (e.g.,  if  a  shared library uses direct access to the OS rather than through Tcl's
              filesystem API, it will not see the current directory as being inside the mount and  will  not  be
              able to access the files inside the mount).

       <b>zipfs</b> <b>mountdata</b> <u>data</u> <u>mountpoint</u>
              Mounts the ZIP archive content <u>data</u> as a Tcl virtual filesystem at <u>mountpoint</u>.

       <b>zipfs</b> <b>root</b>
              Returns  a  constant  string  which  indicates  the  mount point for zipfs volumes for the current
              platform. User should not rely on  the  mount  point  being  the  same  constant  string  for  all
              platforms.

       <b>zipfs</b> <b>unmount</b> <u>mountpoint</u>
              Unmounts  a  previously  mounted ZIP archive mounted to <u>mountpoint</u>.  The command will fail with an
              error exception if there are any files within the mounted archive are open.

   <b>ZIP</b> <b>CREATION</b> <b>COMMANDS</b>
       This package also provides several commands to aid the creation of ZIP archives as Tcl applications.

       <b>zipfs</b> <b>mkzip</b> <u>outfile</u> <u>indir</u> ?<u>strip</u>? ?<u>password</u>?
              Creates a ZIP archive file named <u>outfile</u> from the contents of the input directory <u>indir</u> (contained
              regular files only) with optional ZIP password <u>password</u>. While processing the  files  below  <u>indir</u>
              the  optional file name prefix given in <u>strip</u> is stripped off the beginning of the respective file
              name if non-empty.  When stripping, it is common to remove either the whole source directory  name
              or the name of its parent directory.

              <b>Caution:</b>  the  choice  of  the  <u>indir</u> parameter (less the optional stripped prefix) determines the
              later root name of the archive's content.

       <b>zipfs</b> <b>mkimg</b> <u>outfile</u> <u>indir</u> ?<u>strip</u>? ?<u>password</u>? ?<u>infile</u>?
              Creates an image (potentially a new executable file) similar to <b>zipfs</b> <b>mkzip</b>; see that command  for
              a  description  of  most  parameters  to this command, as they behave identically here. If <u>outfile</u>
              exists, it will be silently overwritten.

              If the <u>infile</u> parameter is specified, this  file  is  prepended  in  front  of  the  ZIP  archive,
              otherwise  the  file  returned  by <b>info</b> <b>nameofexecutable</b> (i.e., the executable file of the running
              process, typically <b>wish</b> or <b>tclsh</b>) is used. If the <u>password</u> parameter is not the empty  string,  an
              obfuscated  version  of that password (see <b>zipfs</b> <b>mkkey</b>) is placed between the image and ZIP chunks
              of the output file and the contents of the ZIP chunk are protected with  that  password.   If  the
              starting  image  has  a ZIP archive already attached to it, it is removed from the copy in <u>outfile</u>
              before the new ZIP archive is added.

              If there is a file, <b>main.tcl</b>, in the root directory of the resulting archive and  the  image  file
              that  the  archive  is  attached to is a <b>tclsh</b> (or <b>wish</b>) instance (true by default, but depends on
              your configuration), then the resulting image is an executable that will <b>source</b> the script in that
              <b>main.tcl</b> after mounting the ZIP archive, and will <b>exit</b> once that script has been executed.

              <b>Note:</b> <b>tclsh</b> and <b>wish</b> can be built using either dynamic binding  or  static  binding  of  the  core
              implementation  libraries.  With  a dynamic binding, the base application Tcl_Library contents are
              attached to the <b>libtcl</b> and  <b>libtk</b>  shared  library,  respectively.  With  a  static  binding,  the
              Tcl_Library  contents, etc., are attached to the application, <b>tclsh</b> or <b>wish</b>. When using <b>mkimg</b> with
              a statically built tclsh, it is the user's responsibility to  preserve  the  attached  archive  by
              first  extracting  it  to  a  temporary  location, and then add whatever additional files desired,
              before creating and attaching the new archive to the new application.

       <b>zipfs</b> <b>mkkey</b> <u>password</u>
              Given the clear text <u>password</u> argument, an obfuscated string version is  returned  with  the  same
              format used in the <b>zipfs</b> <b>mkimg</b> command.

       <b>zipfs</b> <b>lmkimg</b> <u>outfile</u> <u>inlist</u> ?<u>password</u>? ?<u>infile</u>?
              This  command  is  like  <b>zipfs</b> <b>mkimg</b>, but instead of an input directory, <u>inlist</u> must be a Tcl list
              where the odd elements are the names of files to be copied into the archive in the image, and  the
              even elements are their respective names within that archive.

       <b>zipfs</b> <b>lmkzip</b> <u>outfile</u> <u>inlist</u> ?<u>password</u>?
              This  command  is  like  <b>zipfs</b> <b>mkzip</b>, but instead of an input directory, <u>inlist</u> must be a Tcl list
              where the odd elements are the names of files to be copied into the archive, and the even elements
              are their respective names within that archive.

</pre><h4><b>NOTE</b></h4><pre>
       The current syntax for certain subcommands using multiple optional parameters might change in the  future
       to  support  an  <u>?-option</u>  <u>value?</u> pattern instead.  Therfore, the current syntax should not be considered
       stable.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Mounting an ZIP archive as an application directory and running code  out  of  it  before  unmounting  it
       again:

              set zip myApp.zip
              set base [file join [<b>zipfs</b> <b>root</b>] myApp]

              <b>zipfs</b> <b>mount</b> $zip $base
              # $base now has the contents of myApp.zip

              source [file join $base app.tcl]
              # use the contents, load libraries from it, etc...

              <b>zipfs</b> <b>unmount</b> $base

       Creating  a ZIP archive, given that a directory exists containing the content to put in the archive. Note
       that the source directory is given twice, in order  to  strip  the  exterior  directory  name  from  each
       filename in the archive.

              set sourceDirectory [file normalize myApp]
              set targetZip myApp.zip

              <b>zipfs</b> <b>mkzip</b> $targetZip $sourceDirectory $sourceDirectory

       Encryption can be applied to ZIP archives by providing a password when building the ZIP and when mounting
       it.

              set zip myApp.zip
              set sourceDir [file normalize myApp]
              set password "hunter2"
              set base [file join [<b>zipfs</b> <b>root</b>] myApp]

              # Create with password
              <b>zipfs</b> <b>mkzip</b> $targetZip $sourceDir $sourceDir $password

              # Mount with password
              <b>zipfs</b> <b>mount</b> $zip $base $password

       The  following  example creates an executable application by appending a ZIP archive to the tclsh file it
       was called from and storing  the  resulting  executable  in  the  file  “myApp.bin”.   When  creating  an
       executable image with a password, the password is placed within the executable in a shrouded form so that
       the application can read files inside the embedded ZIP archive yet casual inspection cannot read it.

              set appDir [file normalize myApp]
              set img "myApp.bin"
              set password "hunter2"

              # Create some simple content to define a basic application
              file mkdir $appDir
              set f [open $appDir/main.tcl w]
              puts $f {
                  puts "Hi. This is [info script]"
              }
              close $f

              # Create the executable application
              <b>zipfs</b> <b>mkimg</b> $img $appDir $appDir $password

              # remove the now obsolete temporary appDir folder
              file delete -force $appDir

              # Launch the executable, printing its output to stdout
              exec $img &gt;@stdout
              # prints the following line assuming [zipfs root] returns "//zipfs:/":
              # <u>Hi.</u> <u>This</u> <u>is</u> <u>//zipfs:/app/main.tcl</u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/tclsh.1.html">tclsh</a>(1), <a href="../man3tcl/file.3tcl.html">file</a>(3tcl), <a href="../man3/zipfs.3.html">zipfs</a>(3), <a href="../man3tcl/zlib.3tcl.html">zlib</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       compress, filesystem, zip

Zipfs                                                  1.0                                           <u><a href="../man3tcl/zipfs.3tcl.html">zipfs</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>