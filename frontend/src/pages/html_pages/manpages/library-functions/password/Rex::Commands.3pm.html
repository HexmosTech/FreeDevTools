<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rex::Commands - All the basic commands</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/rex">rex_1.16.0-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Rex::Commands - All the basic commands

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is the core commands module.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        desc "Task description";

        task "taskname", sub { ... };
        task "taskname", "server1", ..., "server20", sub { ... };

        group "group" =&gt; "server1", "server2", ...;

        user "user";

        password "password";

        environment live =&gt; sub {
          user "root";
          password "foobar";
          pass_auth;
          group frontend =&gt; "www01", "www02";
        };

</pre><h4><b>COMMANDLIST</b></h4><pre>
       •   Augeas config file management library Rex::Commands::Augeas

       •   Cloud Management Rex::Commands::Cloud

       •   Cron Management Rex::Commands::Cron

       •   Database Commands Rex::Commands::DB

       •   SCP Up- and Download Rex::Commands::Upload, Rex::Commands::Download

       •   File Manipulation Rex::Commands::File

       •   Filesystem Manipulation Rex::Commands::Fs

       •   Information Gathering Rex::Commands::Gather

       •   Manipulation of <a href="file:/etc/hosts">/etc/hosts</a> Rex::Commands::Host

       •   Get an inventory of your Hardware Rex::Commands::Inventory

       •   Manage your iptables rules Rex::Commands::Iptables

       •   Kernel Commands Rex::Commands::Kernel

       •   LVM Commands Rex::Commands::LVM

       •   MD5 checksums Rex::Commands::MD5

       •   Network commands Rex::Commands::Network

       •   Notify resources to execute Rex::Commands::Notify

       •   Package Commands Rex::Commands::Pkg

       •   Partition your storage device(s) Rex::Commands::Partition

       •   Configure packages (via debconf) Rex::Commands::PkgConf

       •   Process Management Rex::Commands::Process

       •   Rsync Files Rex::Commands::Rsync

       •   Run Remote Commands Rex::Commands::Run

       •   Source control via Subversion/Git Rex::Commands::SCM

       •   Manage System Services (sysvinit) Rex::Commands::Service

       •   Simple TCP/alive checks Rex::Commands::SimpleCheck

       •   Sync directories Rex::Commands::Sync

       •   Sysctl Commands Rex::Commands::Sysctl

       •   Live Tail files Rex::Commands::Tail

       •   Upload local file to remote server Rex::Commands::Upload

       •   Manage user and group accounts Rex::Commands::User

       •   Manage your virtual environments Rex::Commands::Virtualization

</pre><h4><b>EXPORTED</b> <b>FUNCTIONS</b></h4><pre>
   <b>no_ssh([$task])</b>
       Disable ssh for all tasks or a specified task.

       If  you  want  to  disable  ssh  connection  for your complete tasks (for example if you only want to use
       libVirt) put this in the main section of your Rexfile.

        no_ssh;

       If you want to disable ssh connection for a given task, put <u>no_ssh</u> in front of the task definition.

        no_ssh task "mytask", "myserver", sub {
          say "Do something without a ssh connection";
        };

   <b>task($name</b> <b>[,</b> <b>@servers],</b> <b>$funcref)</b>
       This function will create a new task.

       Create a local task (a server independent task)
            task "mytask", sub {
              say "Do something";
            };

           If you call this task with (R)?ex it will run on your local machine. You can explicit run  this  task
           on other machines if you specify the <u>-H</u> command line parameter.

       Create a server bound task.
            task "mytask", "server1", sub {
              say "Do something";
            };

           You can also specify more than one server.

            task "mytask", "server1", "server2", "server3", sub {
              say "Do something";
            };

           Or you can use some expressions to define more than one server.

            task "mytask", "server[1..3]", sub {
              say "Do something";
            };

           If you want, you can overwrite the servers with the <u>-H</u> command line parameter.

       Create a group bound task.
           You can define server groups with the <u>group</u> function.

            group "allserver" =&gt; "server[1..3]", "workstation[1..10]";

            task "mytask", group =&gt; "allserver", sub {
              say "Do something";
            };

   <b>desc($description)</b>
       Set the description of the task, batch, or environment following it.

        desc 'This is the description of the following task';
        task 'mytask', sub {
          say 'Do something';
        };

        desc 'This is the description of the following batch';
        batch mybatch =&gt; 'task1', 'task2', 'task3';

        desc 'This is the description of the following environment';
        environment production =&gt; sub {
          ...
        };

   <b>group($name,</b> <b>@servers)</b>
       With this function you can group servers, so that you don't need to write too much ;-)

        group "servergroup", "www1", "www2", "www3", "memcache01", "memcache02", "memcache03";

       Or with the expression syntax:

        group "servergroup", "www[1..3]", "memcache[01..03]";

       If the "use_server_auth" feature flag is enabled, you can also specify server options after a server name
       with a hash reference:

        use Rex -feature =&gt; ['use_server_auth'];

        group "servergroup", "www1" =&gt; { user =&gt; "other" }, "www2";

       These expressions are allowed:

       •   \d+..\d+ (range)

           The first number is the start and the second number is the end for numbering the servers.

            group "name", "www[1..3]"; # www1, www2, www3

       •   \d+..\d+/\d+ (range with step)

           Just like the range notation, but with an additional "step" defined.  If step is omitted, it defaults
           to 1 (i.e. it behaves like a simple range expression).

            group "name", "www[1..5/2]";      # www1, www3, www5
            group "name", "www[111..133/11]"; # www111, www122, www133

       •   \d+,\d+,\d+ (list)

           With this variant you can define fixed values.

            group "name", "www[1,3,7,01]"; # www1, www3, www7, www01

       •   Mixed list, range and range with step

           You can mix the three variants above

            www[1..3,5,9..21/3]; # www1, www2, www3, www5, www9, www12, www15, www18, www21

   <b>batch($name,</b> <b>@tasks)</b>
       With the batch function you can call tasks in a batch.

        batch "name", "task1", "task2", "task3";

       And call it with the <u>-b</u> console parameter. <u>rex</u> <u>-b</u> <u>name</u>

   <b>user($user)</b>
       Set the user for the ssh connection.

   <b>password($password)</b>
       Set the password for the ssh connection (or for the private key file).

   <b>auth(for</b> <b>=&gt;</b> <b>$entity,</b> <b>%data)</b>
       With this command you can set or modify authentication parameters for tasks and groups. (Please note this
       is  different than setting authentication details for the members of a host group. If you are looking for
       that, please check out the group &lt;https://metacpan.org/pod/Rex::Commands#group&gt; command.)

       If you want to set special login information for a group you have to enable at  least  the  0.31  feature
       flag, and ensure the "group" is declared before the "auth" command.

       Command  line  options  to  set  locality  or authentication details are still taking precedence, and may
       override these settings.

        # auth for groups

        use Rex -feature =&gt; ['0.31']; # activate setting auth for a group

        group frontends =&gt; "web[01..10]";
        group backends =&gt; "be[01..05]";

        auth for =&gt; "frontends" =&gt;
                   user =&gt; "root",
                   password =&gt; "foobar";

        auth for =&gt; "backends" =&gt;
                   user =&gt; "admin",
                   private_key =&gt; "/path/to/id_rsa",
                   public_key =&gt; "/path/to/id_rsa.pub",
                   sudo =&gt; TRUE;

        # auth for tasks

        task "prepare", group =&gt; ["frontends", "backends"], sub {
          # do something
        };

        auth for =&gt; "prepare" =&gt;
                   user =&gt; "root";

        # auth for multiple tasks with regular expression

        task "step_1", sub {
         # do something
        };

        task "step_2", sub {
         # do something
        };

        auth for =&gt; qr/step/ =&gt;
          user     =&gt; $user,
          password =&gt; $password;

        # fallback auth
        auth fallback =&gt; {
          user        =&gt; "fallback_user1",
          password    =&gt; "fallback_pw1",
          public_key  =&gt; "",
          private_key =&gt; "",
        }, {
          user        =&gt; "fallback_user2",
          password    =&gt; "fallback_pw2",
          public_key  =&gt; "keys/public.key",
          private_key =&gt; "keys/private.key",
          sudo        =&gt; TRUE,
        };

   <b>port($port)</b>
       Set the port where the ssh server is listening.

   <b>sudo_password($password)</b>
       Set the password for the sudo command.

   <b>timeout($seconds)</b>
       Set the timeout for the ssh connection and other network related stuff.

   <b>max_connect_retries($count)</b>
       Set the maximum number of connection retries.

   <b>get_random($count,</b> <b>@chars)</b>
       Returns a random string of $count characters on the basis of @chars.

        my $rnd = get_random(8, 'a' .. 'z');

   <b>do_task($task)</b>
       Call $task from another task. It will establish a new connection to the server defined in $task and  then
       execute $task there.

        task "task1", "server1", sub {
          say "Running on server1";
          do_task "task2";
        };

        task "task2", "server2", sub {
          say "Running on server2";
        };

       You may also use an arrayRef for $task if you want to call multiple tasks.

        do_task [ qw/task1 task2 task3/ ];

   <b>run_task($task_name,</b> <b>%option)</b>
       Run a task on a given host.

        my $return = run_task "taskname", on =&gt; "192.168.3.56";

       Do something on server5 if memory is less than 100 MB free on server3.

        task "prepare", "server5", sub {
          my $free_mem = run_task "get_free_mem", on =&gt; "server3";
          if($free_mem &lt; 100) {
            say "Less than 100 MB free mem on server3";
            # create a new server instance on server5 to unload server3
          }
        };

        task "get_free_mem", sub {
           return memory-&gt;{free};
        };

       If called without a hostname the task is run localy.

        # this task will run on server5
        task "prepare", "server5", sub {
          # this will call task check_something. but this task will run on localhost.
          my $check = run_task "check_something";
        }

        task "check_something", "server4", sub {
          return "foo";
        };

       If you want to add custom parameters for the task you can do it this way.

        task "prepare", "server5", sub {
         run_task "check_something", on =&gt; "foo", params =&gt; { param1 =&gt; "value1", param2 =&gt; "value2" };
        };

   <b>run_batch($batch_name,</b> <b>%option)</b>
       Run a batch on a given host.

        my @return = run_batch "batchname", on =&gt; "192.168.3.56";

       It calls internally run_task, and passes it any option given.

   <b>public_key($key)</b>
       Set the public key.

   <b>private_key($key)</b>
       Set the private key.

   <b>pass_auth</b>
       If you want to use password authentication, then you need to call <u>pass_auth</u>.

        user "root";
        password "root";

        pass_auth;

   <b>key_auth</b>
       If you want to use pubkey authentication, then you need to call <u>key_auth</u>.

        user "bob";
        private_key "/home/bob/.ssh/id_rsa"; # passphrase-less key
        public_key "/home/bob/.ssh/id_rsa.pub";

        key_auth;

   <b>krb5_auth</b>
       If  you  want  to  use  kerberos  authentication,  then  you need to call <u>krb5_auth</u>.  This authentication
       mechanism is only available if you use Net::OpenSSH.

        set connection =&gt; "OpenSSH";
        user "root";
        krb5_auth;

   <b>parallelism($count)</b>
       Will execute the tasks in parallel on the given servers. $count is the thread count to be used:

        parallelism '2'; # set parallelism to 2

       Alternatively, the following notation can be used to set thread count more dynamically:

        parallelism 'max';     # set parallelism to the number of servers a task is asked to run on
        parallelism 'max/3';   # set parallelism to 1/3 of the number of servers
        parallelism 'max 10%'; # set parallelism to 10% of the number of servers

       If an unrecognized value is passed, or the calculated thread count would be less than 1, Rex  falls  back
       to use a single thread.

   <b>proxy_command($cmd)</b>
       Set a proxy command to use for the connection. This is only possible with OpenSSH connection method.

        set connection =&gt; "OpenSSH";
        proxy_command "ssh user@jumphost nc %h %p 2&gt;/dev/null";

   <b>set_distributor($distributor)</b>
       This sets the task distribution module. Default is "Base".

       Possible values are: Base, Gearman, Parallel_ForkManager

   <b>template_function(sub</b> <b>{</b> <b>...</b> <b>})</b>
       This function sets the template processing function. So it is possible to change the template engine. For
       example to Template::Toolkit.

   <b>logging</b>
       With this function you can define the logging behaviour of (R)?ex.

       Logging to a file
            logging to_file =&gt; "rex.log";

       Logging to syslog
            logging to_syslog =&gt; $facility;

   <b>needs($package</b> <b>[,</b> <b>@tasks])</b>
       With  <u>needs</u>  you  can  define dependencies between tasks. The "needed" tasks will be called with the same
       server configuration as the calling task.

       <u>needs</u> will not execute before, around and after hooks.

       Depend on all tasks in a given package.
           Depend on all tasks in the package MyPkg. All tasks will be called with the server <u>server1</u>.

            task "mytask", "server1", sub {
              needs MyPkg;
            };

       Depend on a single task in a given package.
           Depend on the <u>uname</u> task in the package MyPkg. The <u>uname</u> task will be called with the server <u>server1</u>.

            task "mytask", "server1", sub {
              needs MyPkg "uname";
            };

       To call tasks defined in the Rexfile from within a module
            task "mytask", "server1", sub {
              needs main "uname";
            };

   <b>include</b> <b>Module::Name</b>
       Include a module without registering its tasks.

         include qw/
           Module::One
           Module::Two
         /;

   <b>environment($name</b> <b>=&gt;</b> <b>$code)</b>
       Define an environment. With environments one can use the same task for different hosts.  For  example  if
       you want to use the same task on your integration-, test- and production servers.

        # define default user/password
        user "root";
        password "foobar";
        pass_auth;

        # define default frontend group containing only testwww01.
        group frontend =&gt; "testwww01";

        # define live environment, with different user/password
        # and a frontend server group containing www01, www02 and www03.
        environment live =&gt; sub {
          user "root";
          password "livefoo";
          pass_auth;

          group frontend =&gt; "www01", "www02", "www03";
        };

        # define stage environment with default user and password. but with
        # a own frontend group containing only stagewww01.
        environment stage =&gt; sub {
          group frontend =&gt; "stagewww01";
        };

        task "prepare", group =&gt; "frontend", sub {
           say run "hostname";
        };

       Calling this task <u>rex</u> <u>prepare</u> will execute on testwww01.  Calling this task with <u>rex</u> <u>-E</u> <u>live</u> <u>prepare</u> will
       execute on www01, www02, www03.  Calling this task <u>rex</u> <u>-E</u> <u>stage</u> <u>prepare</u> will execute on stagewww01.

       You can call the function within a task to get the current environment.

        task "prepare", group =&gt; "frontend", sub {
          if(environment() eq "dev") {
            say "i'm in the dev environment";
          }
        };

       If no <u>-E</u> option is passed on the command line, the default environment (named 'default') will be used.

   <b>LOCAL(&amp;)</b>
       With  the  LOCAL  function  you  can  do  local  commands within a task that is defined to work on remote
       servers.

        task "mytask", "server1", "server2", sub {
           # this will call 'uptime' on the servers 'server1' and 'server2'
           say run "uptime";

           # this will call 'uptime' on the local machine.
           LOCAL {
             say run "uptime";
           };
        };

   <b>path(@path)</b>
       Set the execution path for all commands.

        path "<a href="file:/bin">/bin</a>", "<a href="file:/sbin">/sbin</a>", "<a href="file:/usr/bin">/usr/bin</a>", "<a href="file:/usr/sbin">/usr/sbin</a>", "/usr/pkg/bin", "/usr/pkg/sbin";

       It's a convenience wrapper for the set_path configuration option.

   <b>set($key,</b> <b>$value)</b>
       Set a configuration parameter. These variables can be used in templates as well.

        set database =&gt; "db01";

        task "prepare", sub {
          my $db = get "database";
        };

       Or in a template

        DB: &lt;%= $::database %&gt;

       The following list of configuration parameters are Rex specific:

   <b>get($key,</b> <b>$value)</b>
       Get a configuration parameter.

        set database =&gt; "db01";

        task "prepare", sub {
          my $db = get "database";
        };

       Or in a template

        DB: &lt;%= $::database %&gt;

   <b>before($task</b> <b>=&gt;</b> <b>sub</b> <b>{})</b>
       Run code before executing the specified task.

       The task name is a regular expression to find all tasks with a matching name. The special task name 'ALL'
       can also be used to run code before all tasks.

       If called repeatedly, each sub will be appended to a list of 'before' functions.

       In this hook you can overwrite the server to which the task will connect to. The  second  argument  is  a
       reference to the server object that will be used for the connection.

       Please note, this must come after the definition of the specified task.

        before mytask =&gt; sub {
         my ($server, $server_ref, $cli_args) = @_;
         run "vzctl start vm$server";
        };

   <b>after($task</b> <b>=&gt;</b> <b>sub</b> <b>{})</b>
       Run code after executing the specified task.

       The task name is a regular expression to find all tasks with a matching name. The special task name 'ALL'
       can be used to run code after all tasks.

       If called repeatedly, each sub will be appended to a list of 'after' functions.

       Please note, this must come after the definition of the specified task.

        after mytask =&gt; sub {
         my ($server, $failed, $cli_args) = @_;
         if($failed) { say "Connection to $server failed."; }

         run "vzctl stop vm$server";
        };

   <b>around($task</b> <b>=&gt;</b> <b>sub</b> <b>{})</b>
       Run code around the specified task (that is both before and after executing it).

       The task name is a regular expression to find all tasks with a matching name. The special task name 'ALL'
       can be used to run code around all tasks.

       If called repeatedly, each sub will be appended to a list of 'around' functions.

       In  this  hook  you  can overwrite the server to which the task will connect to. The second argument is a
       reference to the server object that will be used for the connection.

       Please note, this must come after the definition of the specified task.

        around mytask =&gt; sub {
         my ($server, $server_ref, $cli_args, $position) = @_;

         unless($position) {
           say "Before Task\n";
         }
         else {
           say "After Task\n";
         }
        };

   <b>before_task_start($task</b> <b>=&gt;</b> <b>sub</b> <b>{})</b>
       Run code before executing the specified task. This gets executed only once for a task.

       The task name is a regular expression to find all tasks with a matching name. The special task name 'ALL'
       can be used to run code before all tasks.

       If called repeatedly, each sub will be appended to a list of 'before_task_start' functions.

       Please note, this must come after the definition of the specified task.

        before_task_start mytask =&gt; sub {
          # do some things
        };

   <b>after_task_finished($task</b> <b>=&gt;</b> <b>sub</b> <b>{})</b>
       Run code after the task is finished (and after the ssh connection is terminated). This gets executed only
       once for a task.

       The task name is a regular expression to find all tasks with a matching name. The special task name 'ALL'
       can be used to run code after all tasks.

       If called repeatedly, each sub will be appended to a list of 'after_task_finished' functions.

       Please note, this must come after the definition of the specified task.

        after_task_finished mytask =&gt; sub {
          # do some things
        };

   <b>logformat($format)</b>
       You can define the logging format with the following parameters.

       %D - Appends the current date yyyy-mm-dd HH:mm:ss

       %h - The target host

       %p - The pid of the running process

       %l - Loglevel (INFO or DEBUG)

       %s - The Logstring

       Default is: [%D] %l - %s

   <b>connection</b>
       This function returns the current connection object.

        task "foo", group =&gt; "baz", sub {
          say "Current Server: " . connection-&gt;server;
        };

   <b>cache</b>
       This function returns the current cache object.

   <b>profiler</b>
       Returns the profiler object for the current connection.

   <b>report($switch,</b> <b>$type)</b>
       This function will initialize the reporting.

        report -on =&gt; "YAML";

   <b>source_global_profile(0|1)</b>
       If this option is set, every <b>run()</b> command will first source <a href="file:/etc/profile">/etc/profile</a> before getting executed.

   <b>last_command_output</b>
       This function returns the output of the last "run" command.

       On a debian system this example will return the output of <u>apt-get</u> <u>install</u> <u>foobar</u>.

        task "mytask", "myserver", sub {
          install "foobar";
          say last_command_output();
        };

   <b>case($compare,</b> <b>$option)</b>
       This is a function to compare a string with some given options.

        task "mytask", "myserver", sub {
          my $ntp_service = case operating_system, {
                        Debian  =&gt; "ntp",
                        default =&gt; "ntpd",
                      };

          my $ntp_service = case operating_system, {
                        qr{debian}i =&gt; "ntp",
                        default    =&gt; "ntpd",
                      };

          my $ntp_service = case operating_system, {
                        qr{debian}i =&gt; "ntp",
                        default    =&gt; sub { return "foo"; },
                      };
        };

   <b>set_executor_for($type,</b> <b>$executor)</b>
       Set the executor for a special type. This is primary used for the upload_and_run helper function.

        set_executor_for perl =&gt; "/opt/local/bin/perl";

   <b>tmp_dir($tmp_dir)</b>
       Set the tmp directory on the remote host to store temporary files.

   <b>inspect($varRef)</b>
       This function dumps the contents of a variable to STDOUT.

        task "mytask", "myserver", sub {
          my $myvar = {
            name =&gt; "foo",
            sys  =&gt; "bar",
          };

          inspect $myvar;
        };

   <b>sayformat($format)</b>
       You can define the format of the <b>say()</b> function.

       %D - The current date yyyy-mm-dd HH:mm:ss

       %h - The target host

       %p - The pid of the running process

       %s - The Logstring

       You can also define the following values:

       default - the default behaviour.

       asis - will print every single parameter in its own line. This is useful if you want to print the  output
       of a command.

perl v5.40.0                                       2025-02-06                                 <u>Rex::<a href="../man3pm/Commands.3pm.html">Commands</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>