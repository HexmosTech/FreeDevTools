<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pg - Distributed named process groups.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pg - Distributed named process groups.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module implements process groups. A message can be sent to one, some, or all group members.

       Up  until  OTP 17 there used to exist an experimental <u>pg</u> module in <u>stdlib</u>. This <u>pg</u> module is not the same
       module as that experimental <u>pg</u> module, and only share the same module name.

       A group of processes can be accessed by a common name. For example, if there is  a  group  named  <u>foobar</u>,
       there  can  be  a  set of processes (which can be located on different nodes) that are all members of the
       group <u>foobar</u>. There are no special functions  for  sending  a  message  to  the  group.  Instead,  client
       functions  are  to be written with the functions <u>get_members/1</u> and <u>get_local_members/1</u> to determine which
       processes are members of the group. Then the message can be sent to one or more group members.

       If a member terminates, it is automatically removed from the group.

       A process may join multiple groups. It may join the same group multiple times. It is only allowed to join
       processes running on local node.

       Process Groups implement strong eventual consistency. Process  Groups  membership  view  may  temporarily
       diverge.  For  example,  when processes on <u>node1</u> and <u>node2</u> join concurrently, <u>node3</u> and <u>node4</u> may receive
       updates in a different order.

       Membership view is not transitive. If <u>node1</u> is not directly connected to <u>node2</u>, they will  not  see  each
       other groups. But if both are connected to <u>node3</u>, <u>node3</u> will have the full view.

       Groups  are  automatically  created  when any process joins, and are removed when all processes leave the
       group. Non-existing group is considered empty (containing no processes).

       Process groups can be organised into multiple scopes. Scopes are completely independent of each other.  A
       process  may  join  any  number of groups in any number of scopes. Scopes are designed to decouple single
       mesh into a set of overlay networks, reducing amount of traffic required to  propagate  group  membership
       information. Default scope <u>pg</u> is started automatically when <u><a href="../man7/kernel.7.html">kernel</a>(7)</u> is configured to do so.

   <b>Note:</b>
       Scope  name  is  used  to register process locally, and to name an ETS table. If there is another process
       registered under this name, or another ETS table exists, scope fails to start.

       Local membership is not preserved if scope process exits and restarts.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>group()</b> = any()

              The identifier of a process group.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>start_link()</b> <b>-&gt;</b> <b>{ok,</b> <b>pid()}</b> <b>|</b> <b>{error,</b> <b>any()}</b>

              Starts the default  <u>pg</u>  scope  within  supervision  tree.  Kernel  may  be  configured  to  do  it
              automatically, see <u><a href="../man7/kernel.7.html">kernel</a>(7)</u> configuration manual.

       <b>start(Scope</b> <b>::</b> <b>atom())</b> <b>-&gt;</b> <b>{ok,</b> <b>pid()}</b> <b>|</b> <b>{error,</b> <b>any()}</b>

       <b>start_link(Scope</b> <b>::</b> <b>atom())</b> <b>-&gt;</b> <b>{ok,</b> <b>pid()}</b> <b>|</b> <b>{error,</b> <b>any()}</b>

              Starts additional scope.

       <b>join(Group</b> <b>::</b> <b>group(),</b> <b>PidOrPids</b> <b>::</b> <b>pid()</b> <b>|</b> <b>[pid()])</b> <b>-&gt;</b> <b>ok</b>

       <b>join(Scope</b> <b>::</b> <b>atom(),</b>
            Group :: group(),
            PidOrPids :: pid() | [pid()]) -&gt;
               ok

              Joins  single  process  or  multiple processes to the group <u>Group</u>. A process can join a group many
              times and must then leave the group the same number of times.

              <u>PidOrPids</u> may contain the same process multiple times.

       <b>leave(Group</b> <b>::</b> <b>group(),</b> <b>PidOrPids</b> <b>::</b> <b>pid()</b> <b>|</b> <b>[pid()])</b> <b>-&gt;</b> <b>ok</b>

       <b>leave(Scope</b> <b>::</b> <b>atom(),</b>
             Group :: group(),
             PidOrPids :: pid() | [pid()]) -&gt;
                ok | not_joined

              Makes the process <u>PidOrPids</u> leave the group <u>Group</u>. If the process is not a member  of  the  group,
              <u>not_joined</u> is returned.

              When list of processes is passed as <u>PidOrPids</u>, function returns <u>not_joined</u> only when all processes
              of the list are not joined.

       <b>get_local_members(Group</b> <b>::</b> <b>group())</b> <b>-&gt;</b> <b>[pid()]</b>

       <b>get_local_members(Scope</b> <b>::</b> <b>atom(),</b> <b>Group</b> <b>::</b> <b>group())</b> <b>-&gt;</b> <b>[pid()]</b>

              Returns  all  processes running on the local node in the group <u>Group</u>. Processes are returned in no
              specific order. This function is optimised for speed.

       <b>get_members(Group</b> <b>::</b> <b>group())</b> <b>-&gt;</b> <b>[pid()]</b>

       <b>get_members(Scope</b> <b>::</b> <b>atom(),</b> <b>Group</b> <b>::</b> <b>group())</b> <b>-&gt;</b> <b>[pid()]</b>

              Returns all processes in the group <u>Group</u>. Processes  are  returned  in  no  specific  order.  This
              function is optimised for speed.

       <b>which_groups()</b> <b>-&gt;</b> <b>[Group</b> <b>::</b> <b>group()]</b>

       <b>which_groups(Scope</b> <b>::</b> <b>atom())</b> <b>-&gt;</b> <b>[Group</b> <b>::</b> <b>group()]</b>

              Returns a list of all known groups.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man7/kernel.7.html">kernel</a>(7)</u>

Maxim Fedorov, WhatsApp Inc.                       kernel 8.2                                           <u><a href="../man3erl/pg.3erl.html">pg</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>