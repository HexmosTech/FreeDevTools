<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG - Perl extension for generating Scalable Vector Graphics (SVG) documents.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsvg-perl">libsvg-perl_2.87-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SVG - Perl extension for generating Scalable Vector Graphics (SVG) documents.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
           use strict;
           use warnings;
           use SVG;

           # create an SVG object
           my $svg= SVG-&gt;new( width =&gt; 200, height =&gt; 200);

           # use explicit element constructor to generate a group element
           my $y = $svg-&gt;group(
               id =&gt; 'group_y',
               style =&gt; {
                   stroke =&gt; 'red',
                   fill   =&gt; 'green'
               },
           );

           # add a circle to the group
           $y-&gt;circle( cx =&gt; 100, cy =&gt; 100, r =&gt; 50, id =&gt; 'circle_in_group_y' );

           # or, use the generic 'tag' method to generate a group element by name
           my $z = $svg-&gt;tag('g',
                           id    =&gt; 'group_z',
                           style =&gt; {
                               stroke =&gt; 'rgb(100,200,50)',
                               fill   =&gt; 'rgb(10,100,150)'
                           }
                       );

           # create and add a circle using the generic 'tag' method
           $z-&gt;tag('circle', cx =&gt; 50, cy =&gt; 50, r =&gt; 100, id =&gt; 'circle_in_group_z');

           # create an anchor on a rectangle within a group within the group z
           my $k = $z-&gt;anchor(
               id      =&gt; 'anchor_k',
               -href   =&gt; '<a href="http://test.hackmare.com/">http://test.hackmare.com/</a>',
               target =&gt; 'new_window_0'
           )-&gt;rectangle(
               x     =&gt; 20, y      =&gt; 50,
               width =&gt; 20, height =&gt; 30,
               rx    =&gt; 10, ry     =&gt; 5,
               id    =&gt; 'rect_k_in_anchor_k_in_group_z'
           );

           # now render the SVG object, implicitly use svg namespace
           print $svg-&gt;xmlify;

           # or render a child node of the SVG object without rendering the entire object
           print $k-&gt;xmlify; #renders the anchor $k above containing a rectangle, but does not
                             #render any of the ancestor nodes of $k

           # or, explicitly use svg namespace and generate a document with its own DTD
           print $svg-&gt;xmlify(-namespace=&gt;'svg');

           # or, explicitly use svg namespace and generate an inline docunent
           print $svg-&gt;xmlify(
               -namespace =&gt; "svg",
               -pubid =&gt; "-//W3C//DTD SVG 1.0//EN",
               -inline   =&gt; 1
           );

       See the other modules in this distribution: SVG::DOM, SVG::XML, SVG::Element, and SVG::Extension.

       See SVG::Parser for reading SVG files as "SVG" objects.

   <b>Converting</b> <b>SVG</b> <b>to</b> <b>PNG</b> <b>and</b> <b>other</b> <b>raster</b> <b>image</b> <b>formats</b>
       The <b>convert</b> command of &lt;<a href="http://www.imagemagick.org/">http://www.imagemagick.org/</a>&gt; (also via Image::Magick ) can convert SVG files to
       PNG and other formats.

       Image::LibRSVG can convert SVG to other format.

</pre><h4><b>EXAMPLES</b></h4><pre>
       examples/circle.pl generates the following image:

         &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
         &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "<a href="http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd</a>"&gt;
         &lt;svg height="200" width="200" xmlns="<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>" xmlns:svg="<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>" xmlns:xlink="<a href="http://www.w3.org/1999/xlink">http://www.w3.org/1999/xlink</a>"&gt;
         &lt;title &gt;I am a title&lt;/title&gt;
         &lt;g id="group_y" style="fill: green; stroke: red"&gt;
         &lt;circle cx="100" cy="100" id="circle_in_group_y" r="50" /&gt;
         &lt;!-- This is a comment --&gt;
         &lt;/g&gt;
         &lt;/svg&gt;

       That you can either embed directly into HTML or can include it using:

          &lt;object data="file.svg" type="image/svg+xml"&gt;&lt;/object&gt;

       (The image was converted to png using Image::LibRSVG. See the svg2png.pl script in the examples
       directory.)

       See also the <b>examples</b> directory in this distribution which contains several fully documented examples.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       SVG is a 100% Perl module which generates a nested data structure containing the DOM representation of an
       SVG (Scalable Vector Graphics) image. Using SVG, you can generate SVG objects, embed other SVG instances
       into it, access the DOM object, create and access javascript, and generate SMIL animation content.

   <b>General</b> <b>Steps</b> <b>to</b> <b>generating</b> <b>an</b> <b>SVG</b> <b>document</b>
       Generating SVG is a simple three step process:

       1 Construct a new SVG object with "new".
       2 Call element constructors such as "circle" and "path" to create SVG elements.
       3 Render the SVG object into XML using the "xmlify" method.

       The  "xmlify"  method  takes  a number of optional arguments that control how SVG renders the object into
       XML, and in particular determine whether a standalone SVG document or an inline SVG document fragment  is
       generated:

   <b>-standalone</b>
       A  complete  SVG document with its own associated DTD. A namespace for the SVG elements may be optionally
       specified.

   <b>-inline</b>
       An inline SVG document fragment with no DTD that is embedded within other XML content. As with standalone
       documents, an alternate namespace may be specified.

       No XML content is generated until the third step is reached. Up until this point, all constructed element
       definitions reside in a DOM-like data structure from which they can be accessed and modified.

   <b>EXPORTS</b>
       None. However, SVG permits both options and additional element methods to  be  specified  in  the  import
       list. These options and elements are then available for all SVG instances that are created with the "new"
       constructor. For example, to change the indent string to two spaces per level:

           use SVG (-indent =&gt; "  ");

       With  the  exception  of -auto, all options may also be specified to the "new" constructor. The currently
       supported options and their default value are:

           # processing options
           -auto       =&gt; 0,       # permit arbitrary autoloading of all unrecognised elements
           -printerror =&gt; 1,       # print error messages to STDERR
           -raiseerror =&gt; 1,       # die on errors (implies -printerror)

           # rendering options
           -indent     =&gt; "\t",    # what to indent with
           -elsep      =&gt; "\n",    # element line (vertical) separator
                                   #     (note that not all agents ignor trailing blanks)
           -nocredits  =&gt; 0,       # enable/disable credit note comment
           -namespace  =&gt; '',      # The root element's (and it's children's) namespace prefix

           # XML and Doctype declarations
           -inline     =&gt; 0,       # inline or stand alone
           -docroot    =&gt; 'svg',   # The document's root element
           -version    =&gt; '1.0',
           -extension  =&gt; '',
           -encoding   =&gt; 'UTF-8',
           -xml_svg    =&gt; '<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>',   # the svg xmlns attribute
           -xml_xlink  =&gt; '<a href="http://www.w3.org/1999/xlink">http://www.w3.org/1999/xlink</a>', # the svg tag xmlns:xlink attribute
           -standalone =&gt; 'yes',
           -pubid      =&gt; "-//W3C//DTD SVG 1.0//EN",      # formerly -identifier
           -sysid      =&gt; '<a href="http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd</a>', # the system id

       SVG also allows additional element generation methods to be specified in the import list. For example  to
       generate 'star' and 'planet' element methods:

           use SVG qw(star planet);

       or:

           use SVG ("star","planet");

       This  will  add  'star'  to  the  list  of  elements  supported  by  SVG.pm  (but not of course other SVG
       parsers...). Alternatively the '-auto' option will allow any unknown method call to generate  an  element
       of the same name:

           use SVG (-auto =&gt; 1, "star", "planet");

       Any  elements  specified explicitly (as 'star' and 'planet' are here) are predeclared; other elements are
       defined as and when they are seen by Perl. Note that enabling '-auto' effectively  disables  compile-time
       syntax checking for valid method names.

           use SVG (
               -auto       =&gt; 0,
               -indent     =&gt; "  ",
               -raiseerror  =&gt; 0,
               -printerror =&gt; 1,
               "star", "planet", "moon"
           );

   <b>Default</b> <b>SVG</b> <b>tag</b>
       The Default SVG tag will generate the following XML:

         $svg = SVG-&gt;new;
         print $svg-&gt;xmlify;

       Resulting XML snippet:

         &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
         &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "<a href="http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd</a>"&gt;
         &lt;svg height="100%" width="100%" xmlns="<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>" xmlns:svg="<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>" xmlns:xlink="<a href="http://www.w3.org/1999/xlink">http://www.w3.org/1999/xlink</a>"&gt;
             &lt;!--
               Generated using the Perl SVG Module V2.50
                 by Ronan Oger
             --&gt;

</pre><h4><b>METHODS</b></h4><pre>
       SVG  provides  both  explicit  and generic element constructor methods. Explicit generators are generally
       (with a few exceptions) named for the element they generate. If a  tag  method  is  required  for  a  tag
       containing  hyphens,  the  method  name  replaces  the  hyphen  with  an  underscore. ie: to generate tag
       &lt;column-heading id="new"&gt; you would use method $svg-&gt;column_heading(id=&gt;'new').

       All element constructors take a hash of element attributes and options; element attributes such  as  'id'
       or  'border'  are  passed  by  name,  while  options  for the method (such as the type of an element that
       supports multiple alternate forms) are passed preceded by a hyphen, e.g '-type'. Both types may be freely
       intermixed; see the "fe" method and code examples throughout the documentation for more examples.

   <b>new</b> <b>(constructor)</b>
       $svg = SVG-&gt;new(%attributes)

       Creates a new SVG object. Attributes of the document SVG element be passed as an  optional  list  of  key
       value pairs. Additionally, SVG options (prefixed with a hyphen) may be set on a per object basis:

           my $svg1 = SVG-&gt;new;

           my $svg2 = SVG-&gt;new(id =&gt; 'document_element');

           my $svg3 = SVG-&gt;new(
               -printerror =&gt; 1,
               -raiseerror =&gt; 0,
               -indent     =&gt; '  ',
               -docroot =&gt; 'svg', #default document root element (SVG specification assumes svg). Defaults to 'svg' if undefined
               -sysid      =&gt; 'abc', #optional system identifyer
               -pubid      =&gt; "-//W3C//DTD SVG 1.0//EN", #public identifyer default value is "-//W3C//DTD SVG 1.0//EN" if undefined
               -namespace =&gt; 'mysvg',
               -inline   =&gt; 1
               id          =&gt; 'document_element',
               width       =&gt; 300,
               height      =&gt; 200,
           );

       <b>SVG</b> <b>instance</b> <b>represents</b> <b>the</b> <b>document</b> <b>and</b> <b>not</b> <b>the</b> <b>"&lt;svg&gt;"</b> <b>root</b> <b>element.</b>

       Default  SVG  options  may  also be set in the import list. See "EXPORTS" above for more on the available
       options.

       Furthermore, the following options:

           -version
           -encoding
           -standalone
           -namespace Defines the document or element level namespace. The order of assignment priority is element,document .
           -inline
           -identifier
           -nostub
           -dtd (standalone)

       may also be set in xmlify, overriding any corresponding values set in the SVG-&gt;new declaration

   <b>xmlify</b> <b>(alias:</b> <b>to_xml</b> <b>render</b> <b>serialise</b> <b>serialize)</b>
           $string = $svg-&gt;xmlify(%attributes);

       Returns xml representation of svg document.

       <b>XML</b> <b>Declaration</b>

           Name               Default Value
           -version           '1.0'
           -encoding          'UTF-8'
           -standalone        'yes'
           -namespace         'svg'                - namespace for elements
           -inline            '0' - If '1', then this is an inline document.
           -pubid             '-//W3C//DTD SVG 1.0//EN';
           -dtd (standalone)  '<a href="http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd</a>'

   <b>tag</b> <b>(alias:</b> <b>element)</b>
           $tag = $svg-&gt;tag($name, %attributes)

       Generic element generator. Creates the element named $name with the attributes specified in  %attributes.
       This method is the basis of most of the explicit element generators.

           my $tag = $svg-&gt;tag('g', transform=&gt;'rotate(-45)');

   <b>anchor</b>
           $tag = $svg-&gt;anchor(%attributes)

       Generate  an  anchor  element.  Anchors  are  put around objects to make them 'live' (i.e. clickable). It
       therefore requires a drawn object or group element as a child.

       <u>optional</u> <u>anchor</u> <u>attributes</u>

       The following attributes are expected for anchor tags (any any tags which use -href links):

   <b>-href</b>    <b>required</b>
   <b>-type</b>    <b>optional</b>
   <b>-role</b>    <b>optional</b>
   <b>-title</b>   <b>optional</b>
   <b>-show</b>    <b>optional</b>
   <b>-arcrole</b> <b>optional</b>
   <b>-actuate</b> <b>optional</b>
   <b>target</b>   <b>optional</b>
       For   more   information   on   the   options,   refer   to    the    w3c    XLink    specification    at
       &lt;<a href="http://www.w3.org/TR/xlink/">http://www.w3.org/TR/xlink/</a>&gt;

       <b>Example:</b>

           # generate an anchor
           $tag = $SVG-&gt;anchor(
                -href=&gt;'<a href="http://here.com/some/simpler/SVG.SVG">http://here.com/some/simpler/SVG.SVG</a>'
                -title =&gt; 'new window 2 example title',
                -actuate =&gt; 'onLoad',
                -show=&gt; 'embed',

           );

       For  more  information  about  the  options  above,  refer  to  Link   section in the SVG recommendation:
       &lt;<a href="http://www.w3.org/TR/SVG11/linking.html">http://www.w3.org/TR/SVG11/linking.html</a>#Links&gt;

           # add a circle to the anchor. The circle can be clicked on.
           $tag-&gt;circle(cx =&gt; 10, cy =&gt; 10, r =&gt; 1);

           # more complex anchor with both URL and target
           $tag = $SVG-&gt;anchor(
                 -href   =&gt; '<a href="http://somewhere.org/some/other/page.html">http://somewhere.org/some/other/page.html</a>',
                 target =&gt; 'new_window'
           );

           # generate an anchor
           $tag = $svg-&gt;anchor(
               -href=&gt;'<a href="http://here.com/some/simpler/svg.svg">http://here.com/some/simpler/svg.svg</a>'
           );
           # add a circle to the anchor. The circle can be clicked on.
           $tag-&gt;circle(cx =&gt; 10, cy =&gt; 10, r =&gt; 1);

           # more complex anchor with both URL and target
           $tag = $svg-&gt;anchor(
                 -href   =&gt; '<a href="http://somewhere.org/some/other/page.html">http://somewhere.org/some/other/page.html</a>',
                 target =&gt; 'new_window'
           );

   <b>circle</b>
           $tag = $svg-&gt;circle(%attributes)

       Draw a circle at (cx,cy) with radius r.

           my $tag = $svg-&gt;circle(cx =&gt; 4, cy =&gt; 2, r =&gt; 1);

   <b>ellipse</b>
           $tag = $svg-&gt;ellipse(%attributes)

       Draw an ellipse at (cx,cy) with radii rx,ry.

           use SVG;

           # create an SVG object
           my $svg= SVG-&gt;new( width =&gt; 200, height =&gt; 200);

           my $tag = $svg-&gt;ellipse(
               cx =&gt; 10,
               cy =&gt; 10,
               rx =&gt; 5,
               ry =&gt; 7,
               id =&gt; 'ellipse',
               style =&gt; {
                   'stroke'         =&gt; 'red',
                   'fill'           =&gt; 'green',
                   'stroke-width'   =&gt; '4',
                   'stroke-opacity' =&gt; '0.5',
                   'fill-opacity'   =&gt; '0.2',
               }
           );

       See The <b>example/ellipse.pl</b>

   <b>rectangle</b> <b>(alias:</b> <b>rect)</b>
       $tag = $svg-&gt;rectangle(%attributes)

       Draw a rectangle at (x,y) with width 'width' and height 'height' and side radii 'rx' and 'ry'.

           $tag = $svg-&gt;rectangle(
               x      =&gt; 10,
               y      =&gt; 20,
               width  =&gt; 4,
               height =&gt; 5,
               rx     =&gt; 5.2,
               ry     =&gt; 2.4,
               id     =&gt; 'rect_1'
           );

   <b>image</b>
           $tag = $svg-&gt;image(%attributes)

       Draw an image at (x,y) with width 'width' and height 'height' linked to image resource '-href'. See  also
       "use".

           $tag = $svg-&gt;image(
               x       =&gt; 100,
               y       =&gt; 100,
               width   =&gt; 300,
               height  =&gt; 200,
               '-href' =&gt; "image.png", #may also embed SVG, e.g. "image.svg"
               id      =&gt; 'image_1'
           );

       <b>Output:</b>

           &lt;image xlink:href="image.png" x="100" y="100" width="300" height="200"/&gt;

   <b>use</b>
           $tag = $svg-&gt;use(%attributes)

       Retrieve  the  content from an entity within an SVG document and apply it at (x,y) with width 'width' and
       height 'height' linked to image resource '-href'.

           $tag = $svg-&gt;use(
               x       =&gt; 100,
               y       =&gt; 100,
               width   =&gt; 300,
               height  =&gt; 200,
               '-href' =&gt; "pic.svg#image_1",
               id      =&gt; 'image_1'
           );

       <b>Output:</b>

           &lt;use xlink:href="pic.svg#image_1" x="100" y="100" width="300" height="200"/&gt;

       According to the SVG specification, the 'use' element in SVG can point to  a  single  element  within  an
       external SVG file.

   <b>polygon</b>
           $tag = $svg-&gt;polygon(%attributes)

       Draw  an  n-sided  polygon with vertices at points defined by a string of the form 'x1,y1,x2,y2,x3,y3,...
       xy,yn'. The "get_path" method is provided as a convenience to generate a suitable string from  coordinate
       data.

           # a five-sided polygon
           my $xv = [0, 2, 4, 5, 1];
           my $yv = [0, 0, 2, 7, 5];

           my $points = $svg-&gt;get_path(
               x     =&gt;  $xv,
               y     =&gt;  $yv,
               -type =&gt;'polygon'
           );

           my $poly = $svg-&gt;polygon(
               %$points,
               id    =&gt; 'pgon1',
               style =&gt; \%polygon_style
           );

       SEE ALSO:

       "polyline", "path", "get_path".

   <b>polyline</b>
           $tag = $svg-&gt;polyline(%attributes)

       Draw  an  n-point polyline with points defined by a string of the form 'x1,y1,x2,y2,x3,y3,... xy,yn'. The
       "get_path" method is provided as a convenience to generate a suitable string from coordinate data.

           # a 10-pointsaw-tooth pattern
           my $xv = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
           my $yv = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1];

           my $points = $svg-&gt;get_path(
               x       =&gt; $xv,
               y       =&gt; $yv,
               -type   =&gt; 'polyline',
               -closed =&gt; 'true' #specify that the polyline is closed.
           );

           my $tag = $svg-&gt;polyline (
               %$points,
               id    =&gt;'pline_1',
               style =&gt; {
                   'fill-opacity' =&gt; 0,
                   'stroke'       =&gt; 'rgb(250,123,23)'
               }
           );

   <b>line</b>
           $tag = $svg-&gt;line(%attributes)

       Draw a straight line between two points (x1,y1) and (x2,y2).

           my $tag = $svg-&gt;line(
               id =&gt; 'l1',
               x1 =&gt;  0,
               y1 =&gt; 10,
               x2 =&gt; 10,
               y2 =&gt;  0,
           );

       To draw multiple connected lines, use "polyline".

   <b>text</b>
           $text = $svg-&gt;text(%attributes)-&gt;cdata();

           $text_path = $svg-&gt;text(-type=&gt;'path');
           $text_span = $text_path-&gt;text(-type=&gt;'span')-&gt;cdata('A');
           $text_span = $text_path-&gt;text(-type=&gt;'span')-&gt;cdata('B');
           $text_span = $text_path-&gt;text(-type=&gt;'span')-&gt;cdata('C');

       Define the container for a text string to be drawn in the image.

       <b>Input:</b>

           -type     = path type (path | polyline | polygon)
           -type     = text element type  (path | span | normal [default])

           my $text1 = $svg-&gt;text(
               id =&gt; 'l1',
               x  =&gt; 10,
               y  =&gt; 10
           )-&gt;cdata('hello, world');

           my $text2 = $svg-&gt;text(
               id     =&gt; 'l1',
               x      =&gt; 10,
               y      =&gt; 10,
               -cdata =&gt; 'hello, world',
           );

           my $text = $svg-&gt;text(
               id    =&gt; 'tp',
               x     =&gt; 10,
               y     =&gt; 10,
               -type =&gt; path,
           )
             -&gt;text(id=&gt;'ts' -type=&gt;'span')
             -&gt;cdata('hello, world');

       SEE ALSO:

       "desc", "cdata".

   <b>title</b>
           $tag = $svg-&gt;title(%attributes)

       Generate the title of the image.

           my $tag = $svg-&gt;title(id=&gt;'document-title')-&gt;cdata('This is the title');

   <b>desc</b>
           $tag = $svg-&gt;desc(%attributes)

       Generate the description of the image.

           my $tag = $svg-&gt;desc(id=&gt;'document-desc')-&gt;cdata('This is a description');

   <b>comment</b>
           $tag = $svg-&gt;comment(@comments)

       Generate the description of the image.

           my $tag = $svg-&gt;comment('comment 1','comment 2','comment 3');

   <b>pi</b> <b>(Processing</b> <b>Instruction)</b>
           $tag = $svg-&gt;pi(@pi)

       Generate a set of processing instructions

           my $tag = $svg-&gt;pi('instruction one','instruction two','instruction three');

           returns:
             &lt;lt&gt;?instruction one?&lt;gt&gt;
             &lt;lt&gt;?instruction two?&lt;gt&gt;
             &lt;lt&gt;?instruction three?&lt;gt&gt;

   <b>script</b>
           $tag = $svg-&gt;script(%attributes)

       Generate a script container for dynamic (client-side) scripting using  ECMAscript,  Javascript  or  other
       compatible scripting language.

           my $tag = $svg-&gt;script(-type=&gt;"text/ecmascript");
           #or my $tag = $svg-&gt;script();
           #note that type ecmascript is not Mozilla compliant

           # populate the script tag with cdata
           # be careful to manage the javascript line ends.
           # Use qq{text} or q{text} as appropriate.
           # make sure to use the CAPITAL CDATA to poulate the script.
           $tag-&gt;CDATA(qq{
               function d() {
               //simple display function
                 for(cnt = 0; cnt &lt; d.length; cnt++)
                   document.write(d[cnt]);//end for loop
               document.write("&lt;BR&gt;");//write a line break
               }
           });

   <b>path</b>
           $tag = $svg-&gt;path(%attributes)

       Draw  a path element. The path vertices may be provided as a parameter or calculated using the "get_path"
       method.

           # a 10-pointsaw-tooth pattern drawn with a path definition
           my $xv = [0,1,2,3,4,5,6,7,8,9];
           my $yv = [0,1,0,1,0,1,0,1,0,1];

           $points = $svg-&gt;get_path(
               x =&gt; $xv,
               y =&gt; $yv,
               -type   =&gt; 'path',
               -closed =&gt; 'true'  #specify that the polyline is closed
           );

           $tag = $svg-&gt;path(
               %$points,
               id    =&gt; 'pline_1',
               style =&gt; {
                   'fill-opacity' =&gt; 0,
                   'fill'   =&gt; 'green',
                   'stroke' =&gt; 'rgb(250,123,23)'
               }
           );

       SEE ALSO: "get_path".

   <b>get_path</b>
           $path = $svg-&gt;get_path(%attributes)

       Returns the text string of points correctly formatted to be incorporated into the multi-point SVG drawing
       object definitions (path, polyline, polygon)

       <b>Input:</b> attributes including:

           -type     = path type (path | polyline | polygon)
           x         = reference to array of x coordinates
           y         = reference to array of y coordinates

       <b>Output:</b> a hash reference consisting of the following key-value pair:

           points    = the appropriate points-definition string
           -type     = path|polygon|polyline
           -relative = 1 (define relative position rather than absolute position)
           -closed   = 1 (close the curve - path and polygon only)

           #generate an open path definition for a path.
           my ($points,$p);
           $points = $svg-&gt;get_path(x=&amp;gt\@x,y=&amp;gt\@y,-relative=&amp;gt1,-type=&amp;gt'path');

           #add the path to the SVG document
           my $p = $svg-&gt;path(%$path, style=&gt;\%style_definition);

           #generate an closed path definition for a a polyline.
           $points = $svg-&gt;get_path(
               x=&gt;\@x,
               y=&gt;\@y,
               -relative=&gt;1,
               -type=&gt;'polyline',
               -closed=&gt;1
           ); # generate a closed path definition for a polyline

           # add the polyline to the SVG document
           $p = $svg-&gt;polyline(%$points, id=&gt;'pline1');

       <b>Aliases:</b> get_path set_path

   <b>animate</b>
           $tag = $svg-&gt;animate(%attributes)

       Generate an SMIL animation tag. This is allowed within any nonempty tag. Refer to the  W3C  for  detailed
       information on the subtleties of the animate SMIL commands.

       <b>Inputs:</b> -method = Transform | Motion | Color

         my $an_ellipse = $svg-&gt;ellipse(
             cx     =&gt; 30,
             cy     =&gt; 150,
             rx     =&gt; 10,
             ry     =&gt; 10,
             id     =&gt; 'an_ellipse',
             stroke =&gt; 'rgb(130,220,70)',
             fill   =&gt;'rgb(30,20,50)'
         );

         $an_ellipse-&gt; animate(
             attributeName =&gt; "cx",
             values        =&gt; "20; 200; 20",
             dur           =&gt; "10s",
             repeatDur     =&gt; 'indefinite'
         );

         $an_ellipse-&gt; animate(
             attributeName =&gt; "rx",
             values        =&gt; "10;30;20;100;50",
             dur           =&gt; "10s",
             repeatDur     =&gt; 'indefinite',
         );

         $an_ellipse-&gt; animate(
             attributeName =&gt; "ry",
             values        =&gt; "30;50;10;20;70;150",
             dur           =&gt; "15s",
             repeatDur     =&gt; 'indefinite',
         );

         $an_ellipse-&gt; animate(
             attributeName=&gt;"rx",values=&gt;"30;75;10;100;20;20;150",
             dur=&gt;"20s", repeatDur=&gt;'indefinite');

         $an_ellipse-&gt; animate(
             attributeName=&gt;"fill",values=&gt;"red;green;blue;cyan;yellow",
             dur=&gt;"5s", repeatDur=&gt;'indefinite');

         $an_ellipse-&gt; animate(
             attributeName=&gt;"fill-opacity",values=&gt;"0;1;0.5;0.75;1",
             dur=&gt;"20s",repeatDur=&gt;'indefinite');

         $an_ellipse-&gt; animate(
             attributeName=&gt;"stroke-width",values=&gt;"1;3;2;10;5",
             dur=&gt;"20s",repeatDur=&gt;'indefinite');

   <b>group</b>
           $tag = $svg-&gt;group(%attributes)

       Define  a  group  of  objects  with  common  properties.  Groups  can  have  style,  animation,  filters,
       transformations, and mouse actions assigned to them.

           $tag = $svg-&gt;group(
               id        =&gt; 'xvs000248',
               style     =&gt; {
                   'font'      =&gt; [ qw( Arial Helvetica sans ) ],
                   'font-size' =&gt; 10,
                   'fill'      =&gt; 'red',
               },
               transform =&gt; 'rotate(-45)'
           );

   <b>defs</b>
           $tag = $svg-&gt;defs(%attributes)

       define a definition segment. A Defs requires children when defined using SVG.pm

           $tag = $svg-&gt;defs(id  =&gt;  'def_con_one',);

   <b>style</b>
           $svg-&gt;tag('style', %styledef);

       Sets/adds style-definition for the following objects being created.

       Style definitions apply to an object and all its children for all properties for which the value  of  the
       property is not redefined by the child.

           $tag = $SVG-&gt;style(%attributes)

       Generate a style container for inline or xlink:href based styling instructions

           my $tag = $SVG-&gt;style(type=&gt;"text/css");

           # Populate the style tag with cdata.
           # Be careful to manage the line ends.
           # Use qq{text}, where text is the script

           $tag1-&gt;CDATA(qq{
               rect     fill:red;stroke:green;
               circle   fill:red;stroke:orange;
               ellipse  fill:none;stroke:yellow;
               text     fill:black;stroke:none;
           });

           # Create a external CSS stylesheet reference
           my $tag2 = $SVG-&gt;style(type=&gt;"text/css", -href="/resources/example.css");

   <b>mouseaction</b>
           $svg-&gt;mouseaction(%attributes)

       Sets/Adds mouse action definitions for tag

   <b>attrib</b>
           $svg-&gt;attrib($name, $value)

       Sets/adds attributes of an element.

       Retrieve an attribute:

           $svg-&gt;attrib($name);

       Set a scalar attribute:

           $SVG-&gt;attrib $name, $value

       Set a list attribute:

           $SVG-&gt;attrib $name, \@value

       Set a hash attribute (i.e. style definitions):

           $SVG-&gt;attrib $name, \%value

       Remove an attribute:

           $svg-&gt;attrib($name,undef);

       <b>Aliases:</b> attr attribute

       Sets/replaces attributes for a tag.

   <b>cdata</b>
           $svg-&gt;cdata($text)

       Sets  cdata to $text. SVG.pm allows you to set cdata for any tag. If the tag is meant to be an empty tag,
       SVG.pm will not complain, but the rendering agent will fail. In the SVG  DTD,  cdata  is  generally  only
       meant for adding text or script content.

           $svg-&gt;text(
               style =&gt; {
                   'font'      =&gt; 'Arial',
                   'font-size' =&gt; 20
               })-&gt;cdata('SVG.pm is a perl module on CPAN!');

           my $text = $svg-&gt;text( style =&gt; { 'font' =&gt; 'Arial', 'font-size' =&gt; 20 } );
           $text-&gt;cdata('SVG.pm is a perl module on CPAN!');

       <b>Result:</b>

           &lt;text style="font: Arial; font-size: 20"&gt;SVG.pm is a perl module on CPAN!&lt;/text&gt;

       SEE ALSO:

       "CDATA", "desc", "title", "text", "script".

   <b>cdata_noxmlesc</b>
           $script = $svg-&gt;script();
           $script-&gt;cdata_noxmlesc($text);

       Generates  cdata content for text and similar tags which do not get xml-escaped.  In othe words, does not
       parse the content and inserts the exact string into the cdata location.

   <b>CDATA</b>
           $script = $svg-&gt;script();
           $script-&gt;CDATA($text);

       Generates a &lt;![CDATA[ ... ]]&gt; tag with the contents of $text rendered exactly as supplied. SVG.pm  allows
       you  to  set cdata for any tag. If the tag is meant to be an empty tag, SVG.pm will not complain, but the
       rendering agent will fail. In the SVG DTD, cdata is generally  only  meant  for  adding  text  or  script
       content.

             my $text = qq{
               var SVGDoc;
               var groups = new Array();
               var last_group;

               /*****
               *
               *   init
               *
               *   Find this SVG's document element
               *   Define members of each group by id
               *
               *****/
               function init(e) {
                   SVGDoc = e.getTarget().getOwnerDocument();
                   append_group(1, 4, 6); // group 0
                   append_group(5, 4, 3); // group 1
                   append_group(2, 3);    // group 2
               }};
               $svg-&gt;script()-&gt;CDATA($text);

       <b>Result:</b>

           E&lt;lt&gt;script E&lt;gt&gt;
             &lt;gt&gt;![CDATA[
               var SVGDoc;
               var groups = new Array();
               var last_group;

               /*****
               *
               *   init
               *
               *   Find this SVG's document element
               *   Define members of each group by id
               *
               *****/
               function init(e) {
                   SVGDoc = e.getTarget().getOwnerDocument();
                   append_group(1, 4, 6); // group 0
                   append_group(5, 4, 3); // group 1
                   append_group(2, 3);    // group 2
               }
               ]]E&lt;gt&gt;

       SEE ALSO: "cdata", "script".

   <b>xmlescp</b> <b>and</b> <b>xmlescape</b>
           $string = $svg-&gt;xmlescp($string)
           $string = $svg-&gt;xmlesc($string)
           $string = $svg-&gt;xmlescape($string)

       SVG  module  does not xml-escape characters that are incompatible with the XML specification. <b>xmlescp</b> and
       <b>xmlescape</b> provides this functionality. It is a helper function which generates an XML-escaped string  for
       reserved characters such as ampersand, open and close brackets, etcetera.

       The behaviour of xmlesc is to apply the following transformation to the input string $s:

           $s=~s/&amp;(?!#(x\w\w|\d+?);)/&amp;amp;/g;
           $s=~s/&gt;/&amp;gt;/g;
           $s=~s/&lt;/&amp;lt;/g;
           $s=~s/\"/&amp;quot;/g;
           $s=~s/\'/&amp;apos;/g;
           $s=~s/([\x00-\x08\x0b\x1f])/''/eg;
           $s=~s/([\200-\377])/'&amp;#'.ord($1).';'/ge;

   <b>filter</b>
           $tag = $svg-&gt;filter(%attributes)

       Generate a filter. Filter elements contain "fe" filter sub-elements.

           my $filter = $svg-&gt;filter(
               filterUnits=&gt;"objectBoundingBox",
               x=&gt;"-10%",
               y=&gt;"-10%",
               width=&gt;"150%",
               height=&gt;"150%",
               filterUnits=&gt;'objectBoundingBox'
           );

           $filter-&gt;fe();

       SEE ALSO: "fe".

   <b>fe</b>
           $tag = $svg-&gt;fe(-type=&gt;'type', %attributes)

       Generate a filter sub-element. Must be a child of a "filter" element.

           my $fe = $svg-&gt;fe(
               -type     =&gt; 'DiffuseLighting'  # required - element name omitting 'fe'
               id        =&gt; 'filter_1',
               style     =&gt; {
                   'font'      =&gt; [ qw(Arial Helvetica sans) ],
                   'font-size' =&gt; 10,
                   'fill'      =&gt; 'red',
               },
               transform =&gt; 'rotate(-45)'
           );

       Note  that the following filter elements are currently supported: Also note that the elelemts are defined
       in lower case in the module, but as of version 2.441, any case combination is allowed.

   <b>*</b> <b>feBlend</b>
   <b>*</b> <b>feColorMatrix</b>
   <b>*</b> <b>feComponentTransfer</b>
   <b>*</b> <b>feComposite</b>
   <b>*</b> <b>feConvolveMatrix</b>
   <b>*</b> <b>feDiffuseLighting</b>
   <b>*</b> <b>feDisplacementMap</b>
   <b>*</b> <b>feDistantLight</b>
   <b>*</b> <b>feFlood</b>
   <b>*</b> <b>feFuncA</b>
   <b>*</b> <b>feFuncB</b>
   <b>*</b> <b>feFuncG</b>
   <b>*</b> <b>feFuncR</b>
   <b>*</b> <b>feGaussianBlur</b>
   <b>*</b> <b>feImage</b>
   <b>*</b> <b>feMerge</b>
   <b>*</b> <b>feMergeNode</b>
   <b>*</b> <b>feMorphology</b>
   <b>*</b> <b>feOffset</b>
   <b>*</b> <b>fePointLight</b>
   <b>*</b> <b>feSpecularLighting</b>
   <b>*</b> <b>feSpotLight</b>
   <b>*</b> <b>feTile</b>
   <b>*</b> <b>feTurbulence</b>
       SEE ALSO: "filter".

   <b>pattern</b>
           $tag = $svg-&gt;pattern(%attributes)

       Define a pattern for later reference by url.

           my $pattern = $svg-&gt;pattern(
               id     =&gt; "Argyle_1",
               width  =&gt; "50",
               height =&gt; "50",
               patternUnits        =&gt; "userSpaceOnUse",
               patternContentUnits =&gt; "userSpaceOnUse"
           );

   <b>set</b>
           $tag = $svg-&gt;set(%attributes)

       Set a definition for an SVG object in one section, to be referenced in other sections as needed.

           my $set = $svg-&gt;set(
               id     =&gt; "Argyle_1",
               width  =&gt; "50",
               height =&gt; "50",
               patternUnits        =&gt; "userSpaceOnUse",
               patternContentUnits =&gt; "userSpaceOnUse"
           );

   <b>stop</b>
           $tag = $svg-&gt;stop(%attributes)

       Define a stop boundary for "gradient"

          my $pattern = $svg-&gt;stop(
              id     =&gt; "Argyle_1",
              width  =&gt; "50",
              height =&gt; "50",
              patternUnits        =&gt; "userSpaceOnUse",
              patternContentUnits =&gt; "userSpaceOnUse"
          );

   <b>gradient</b>
           $tag = $svg-&gt;gradient(%attributes)

       Define a color gradient. Can be of type <b>linear</b> or <b>radial</b>

           my $gradient = $svg-&gt;gradient(
               -type =&gt; "linear",
               id    =&gt; "gradient_1"
           );

</pre><h4><b>GENERIC</b> <b>ELEMENT</b> <b>METHODS</b></h4><pre>
       The following elements are generically supported by SVG:

   <b>*</b> <b>altGlyph</b>
   <b>*</b> <b>altGlyphDef</b>
   <b>*</b> <b>altGlyphItem</b>
   <b>*</b> <b>clipPath</b>
   <b>*</b> <b>color-profile</b>
   <b>*</b> <b>cursor</b>
   <b>*</b> <b>definition-src</b>
   <b>*</b> <b>font-face-format</b>
   <b>*</b> <b>font-face-name</b>
   <b>*</b> <b>font-face-src</b>
   <b>*</b> <b>font-face-url</b>
   <b>*</b> <b>foreignObject</b>
   <b>*</b> <b>glyph</b>
   <b>*</b> <b>glyphRef</b>
   <b>*</b> <b>hkern</b>
   <b>*</b> <b>marker</b>
   <b>*</b> <b>mask</b>
   <b>*</b> <b>metadata</b>
   <b>*</b> <b>missing-glyph</b>
   <b>*</b> <b>mpath</b>
   <b>*</b> <b>switch</b>
   <b>*</b> <b>symbol</b>
   <b>*</b> <b>tref</b>
   <b>*</b> <b>view</b>
   <b>*</b> <b>vkern</b>
       See e.g. "pattern" for an example of the use of these methods.

</pre><h4><b>METHODS</b> <b>IMPORTED</b> <b>BY</b> <b>SVG::DOM</b></h4><pre>
       The following SVG::DOM elements are accessible through SVG:

   <b>*</b> <b>getChildren</b>
   <b>*</b> <b>getFirstChild</b>
   <b>*</b> <b>getNextChild</b>
   <b>*</b> <b>getLastChild</b>
   <b>*</b> <b>getParent</b>
   <b>*</b> <b>getParentElement</b>
   <b>*</b> <b>getSiblings</b>
   <b>*</b> <b>getElementByID</b>
   <b>*</b> <b>getElementID</b>
   <b>*</b> <b>getElements</b>
   <b>*</b> <b>getElementName</b>
   <b>*</b> <b>getType</b>
   <b>*</b> <b>getAttributes</b>
   <b>*</b> <b>getAttribute</b>
   <b>*</b> <b>setAttributes</b>
   <b>*</b> <b>setAttribute</b>
   <b>*</b> <b>insertBefore</b>
   <b>*</b> <b>insertAfter</b>
   <b>*</b> <b>insertSiblingBefore</b>
   <b>*</b> <b>insertSiblingAfter</b>
   <b>*</b> <b>replaceChild</b>
   <b>*</b> <b>removeChild</b>
   <b>*</b> <b>cloneNode</b>
</pre><h4><b>Methods</b></h4><pre>
       SVG provides both explicit and generic element constructor methods.  Explicit  generators  are  generally
       (with  a  few  exceptions)  named  for  the  element they generate. If a tag method is required for a tag
       containing hyphens, the method name  replaces  the  hyphen  with  an  underscore.  ie:  to  generate  tag
       &lt;column-heading id="new"&gt; you would use method $svg-&gt;column_heading(id=&gt;'new').

       All  element  constructors take a hash of element attributes and options; element attributes such as 'id'
       or 'border' are passed by name, while options for the method  (such  as  the  type  of  an  element  that
       supports multiple alternate forms) are passed preceded by a hyphen, e.g '-type'. Both types may be freely
       intermixed; see the "fe" method and code examples throughout the documentation for more examples.

   <b>new</b> <b>(constructor)</b>
       $svg = SVG-&gt;new(%attributes)

       Creates  a  new  SVG  object. Attributes of the document SVG element be passed as an optional list of key
       value pairs. Additionally, SVG options (prefixed with a hyphen) may be set on a per object basis:

           my $svg1 = SVG-&gt;new;

           my $svg2 = SVG-&gt;new(id =&gt; 'document_element');

           my $svg3 = SVG-&gt;new(
               -printerror =&gt; 1,
               -raiseerror =&gt; 0,
               -indent     =&gt; '  ',
               -elsep      =&gt; "\n",  # element line (vertical) separator
               -docroot    =&gt; 'svg', # default document root element (SVG specification assumes svg). Defaults to 'svg' if undefined
               -xml_xlink  =&gt; '<a href="http://www.w3.org/1999/xlink">http://www.w3.org/1999/xlink</a>', # required by Mozilla's embedded SVG engine
               -sysid      =&gt; 'abc', # optional system identifier
               -pubid      =&gt; "-//W3C//DTD SVG 1.0//EN", # public identifier default value is "-//W3C//DTD SVG 1.0//EN" if undefined
               -namespace  =&gt; 'mysvg',
               -inline     =&gt; 1
               id          =&gt; 'document_element',
               width       =&gt; 300,
               height      =&gt; 200,
           );

       Default SVG options may also be set in the import list. See "EXPORTS" above for  more  on  the  available
       options.

       Furthermore, the following options:

           -version
           -encoding
           -standalone
           -namespace
           -inline
           -pubid (formerly -identifier)
           -sysid (standalone)

       may also be set in xmlify, overriding any corresponding values set in the SVG-&gt;new declaration

   <b>xmlify</b>  <b>(alias:</b> <b>to_xml</b> <b>render</b> <b>serialize</b> <b>serialise</b> <b>)</b>
       $string = $svg-&gt;xmlify(%attributes);

       Returns xml representation of svg document.

       <b>XML</b> <b>Declaration</b>

           Name               Default Value
           -version           '1.0'
           -encoding          'UTF-8'
           -standalone        'yes'
           -namespace         'svg' - namespace prefix for elements.
                                      Can also be used in any element method to over-ride
                                      the current namespace prefix. Make sure to have
                                      declared the prefix before using it.
           -inline            '0' - If '1', then this is an inline document.
           -pubid             '-//W3C//DTD SVG 1.0//EN';
           -sysid             '<a href="http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd</a>'

   <b>perlify</b> <b>()</b>
       return the perl code which generates the SVG document as it currently exists.

   <b>toperl</b> <b>()</b>
       Alias for method <b>perlify()</b>

</pre><h4><b>AUTHOR</b></h4><pre>
       Ronan Oger, RO IT Systemms GmbH, <a href="mailto:cpan@roitsystems.com">cpan@roitsystems.com</a>

</pre><h4><b>MAINTAINER</b></h4><pre>
       Gabor Szabo &lt;<a href="http://szabgab.com/">http://szabgab.com/</a>&gt;

</pre><h4><b>CREDITS</b></h4><pre>
       I  would  like  to  thank  the  following  people  for contributing to this module with patches, testing,
       suggestions, and other nice tidbits:

       Peter Wainwright, Excellent ideas, beta-testing,  writing  SVG::Parser  and  much  of  SVG::DOM.   Fredo,
       <a href="http://www.penguin.at0.net/~fredo/">http://www.penguin.at0.net/~fredo/</a> - provided example code and initial feedback for early SVG.pm versions
       and the idea of a simplified svg generator.  Adam Schneider Brial Pilpr√© Ian Hickson Steve Lihn Allen Day
       Martin Owens - SVG::DOM improvements in version 3.34

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2001- Ronan Oger

       The modules in the SVG distribution are distributed under the same license as Perl itself. It is provided
       free of warranty and may be re-used freely.

</pre><h4><b>ARTICLES</b></h4><pre>
       SVG using Perl &lt;<a href="http://szabgab.com/svg-using-perl.html">http://szabgab.com/svg-using-perl.html</a>&gt;

       SVG - Scalable Vector Graphics with Perl &lt;<a href="http://perlmaven.com/scalable-vector-graphics-with-perl">http://perlmaven.com/scalable-vector-graphics-with-perl</a>&gt;

       Combining SVG and PSGI &lt;<a href="http://perlmaven.com/combining-svg-and-psgi">http://perlmaven.com/combining-svg-and-psgi</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       SVG::DOM, SVG::XML, SVG::Element, SVG::Parser, SVG::Extension

       For   Commercial   Perl/SVG   development,   refer   to   the   following   sites:   SVG   at   the   W3C
       &lt;<a href="http://www.w3c.org/Graphics/SVG/">http://www.w3c.org/Graphics/SVG/</a>&gt;.

perl v5.34.0                                       2022-05-21                                           <u><a href="../man3pm/SVG.3pm.html">SVG</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>