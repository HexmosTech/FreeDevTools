<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::XPath - Parse and evaluate XPath statements.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-xpath-perl">libxml-xpath-perl_1.48-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::XPath - Parse and evaluate XPath statements.

</pre><h4><b>VERSION</b></h4><pre>
       Version 1.48

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module aims to comply exactly to the XPath specification at <a href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a> and yet allow
       extensions to be added in the form of functions.Modules such as XSLT and XPointer may need to do this as
       they support functionality beyond XPath.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use XML::XPath;
           use XML::XPath::XMLParser;

           my $xp = XML::XPath-&gt;new(filename =&gt; 'test.xhtml');

           my $nodeset = $xp-&gt;find('/html/body/p'); # find all paragraphs

           foreach my $node ($nodeset-&gt;get_nodelist) {
               print "FOUND\n\n",
                   XML::XPath::XMLParser::as_string($node),
                   "\n\n";
           }

</pre><h4><b>DETAILS</b></h4><pre>
       There is an awful lot to  all  of  this, so bear with it - if you stick it out it should be worth it.
       Please get a good understanding of XPath by reading  the spec before asking me questions. All of the
       classes and parts  herein are named to  be synonymous  with  the  names in  the  specification, so
       consult that if you don't understand why I'm doing something in the code.

       Currently, it supports XPath 1.0 with a small number of XPath 2.0 functions. See XML::XPath::Function for
       the complete list of predefined functions.

</pre><h4><b>METHODS</b></h4><pre>
       The API of XML::XPath itself is extremely simple to allow you to get going almost immediately. The deeper
       API's are more complex, but you  shouldn't  have to touch most of that.

   <b>new()</b>
       This  constructor follows  the often seen named parameter method call. Parameters you can use are:
       filename, parser, xml, ioref and context. The filename parameter specifies  an  XML  file to parse. The
       xml parameter specifies a string to parse, and the ioref parameter specifies  an ioref to  parse. The
       context  option allows you to specify a context node. The context node has to be in the format of a node
       as specified in XML::XPath::XMLParser. The 4  parameters  filename, xml, ioref and context are mutually
       exclusive - you should only  specify one (if you specify anything other than context, the context node is
       the root of your document).  The parser  option  allows  you to pass in an already prepared XML::Parser
       object, to save you having to create more than one in your application (if, for example, you are doing
       more than just XPath).

           my $xp = XML::XPath-&gt;new( context =&gt; $node );

       It is very much recommended that you use only 1 XPath object  throughout the life of  your  application.
       This is because the object (and it's sub-objects) maintain certain  bits  of state information that will
       be useful (such as XPath variables) to later  calls  to <b>find()</b>.  It's also a good idea because you'll use
       less memory this way.

   <b>find($path,</b> <b>[$context])</b>
       The find function takes an XPath expression (a string) and returns either an XML::XPath::NodeSet object
       containing the nodes it found (or empty if no nodes matched the path), or one of XML::XPath::Literal (a
       string), XML::XPath::Number or XML::XPath::Boolean.  It should always return something - and you can use
       -&gt;<b>isa()</b>  to find out  what it returned. If you need to check how many nodes it found you should check
       $nodeset-&gt;size.  See XML::XPath::NodeSet. An optional second parameter of a context node allows you to
       use this method repeatedly, for example XSLT needs to do this.

   <b>findnodes($path,</b> <b>[$context])</b>
       Returns a list of nodes found by $path, optionally in context $context. In scalar context returns an
       XML::XPath::NodeSet object.

   <b>matches($node,</b> <b>$path,</b> <b>[$context])</b>
       Returns true if the node matches the path (optionally in context $context).

   <b>findnodes_as_string($path,</b> <b>[$context])</b>
       Returns the nodes found reproduced as XML.The result isn't guaranteed to be valid XML though.

   <b>findvalue($path,</b> <b>[$context])</b>
       Returns either a "XML::XPath::Literal", a "XML::XPath::Boolean" or a "XML::XPath::Number" object.If the
       path returns a NodeSet,$nodeset-&gt;to_literal is called automatically for you (and thus a
       "XML::XPath::Literal" is returned).Note that for each of the objects stringification is overloaded, so
       you can just print the  value found, or manipulate it in the ways you would a normal perl value (e.g.
       using regular expressions).

   <b>exists($path,</b> <b>[$context])</b>
       Returns true if the given path exists.

   <b>getNodeText($path)</b>
       Returns the XML::XPath::Literal for a particular XML node. Returns a string if exists or '' (empty
       string) if the node doesn't exist.

   <b>setNodeText($path,</b> <b>$text)</b>
       Sets the text string for a particular XML node.  The node can be an element or an attribute. If the node
       to be set is an attribute, and the attribute node does not exist, it will be created automatically.

   <b>createNode($path)</b>
       Creates the node matching the $path given. If part of the path given or all of the path do not exist, the
       necessary nodes will be created automatically.

   <b>set_namespace($prefix,</b> <b>$uri)</b>
       Sets the namespace prefix mapping to the uri.

       Normally in "XML::XPath" the prefixes in XPath node test take their context from the current node. This
       means that foo:bar will always match an element  &lt;foo:bar&gt; regardless  of  the  namespace that the prefix
       foo is mapped to (which might even change  within  the document, resulting  in unexpected results). In
       order to make prefixes in XPath node tests actually map  to a real URI, you need to enable that via a
       call to the set_namespace method of your "XML::XPath" object.

   <b>clear_namespaces()</b>
       Clears all previously set namespace mappings.

   <b>$XML::XPath::Namespaces</b>
       Set this to 0  if you <u>don't</u> want namespace processing to occur. This will make everything a little (tiny)
       bit faster, but you'll suffer for it, probably.

</pre><h4><b>Node</b> <b>Object</b> <b>Model</b></h4><pre>
       See XML::XPath::Node, XML::XPath::Node::Element, XML::XPath::Node::Text, XML::XPath::Node::Comment,
       XML::XPath::Node::Attribute, XML::XPath::Node::Namespace, and XML::XPath::Node::PI.

</pre><h4><b>On</b> <b>Garbage</b> <b>Collection</b></h4><pre>
       XPath nodes  work in a special way that allows circular references, and yet still lets Perl's reference
       counting garbage collector to clean up the nodes after use.  This should  be  totally  transparent to the
       user, with one caveat: <b>If</b> <b>you</b> <b>free</b> <b>your</b> <b>tree</b> <b>before</b> <b>letting</b> <b>go</b> <b>of</b> <b>a</b> <b>sub-tree,consider</b> <b>that</b> <b>playing</b> <b>with</b>
       <b>fire</b> <b>and</b> <b>you</b> <b>may</b> <b>get</b> <b>burned</b>. What does this mean to the average user?  Not much. Provided you don't free
       (or let go out of scope) either the tree you passed to XML::XPath-&gt;new, or if you didn't  pass a tree,
       and passed a filename or IO-ref, then provided you don't  let the XML::XPath object go out of scope
       before you let results of <b>find()</b> and its  friends  go out of scope, then you'll be fine. Even if you <b>do</b>
       let the tree go out of scope before results, you'll probably still be fine. The only case where  you  may
       get  stung is when the last part of your path/query is either an ancestor or parent axis. In that case
       the worst that will happen is you'll end up with  a  circular  reference that won't get cleared until
       interpreter destruction time.You can get around that by explicitly calling $node-&gt;DESTROY on each of your
       result nodes, if you really need to do that.

       Mail me direct if that's not clear. Note that it's not doom and gloom. It's by no means perfect,but the
       worst that will happen is a long running process could leak memory. Most  long  running  processes  will
       therefore  be able to explicitly be careful not to free the tree (or XML::XPath object) before freeing
       results.AxKit, an application  that  uses XML::XPath,  does  this  and I didn't have to make any changes
       to the code - it's already sensible programming.

       If you <u>really</u> don't want all this to happen, then set the variable $XML::XPath::SafeMode, and call
       $xp-&gt;<b>cleanup()</b> on the XML::XPath object when you're finished, or $tree-&gt;<b>dispose()</b> if you have a tree
       instead.

</pre><h4><b>Example</b></h4><pre>
       Please see the test files in t/ for examples on how to use XPath.

</pre><h4><b>AUTHOR</b></h4><pre>
       Original author Matt Sergeant, "&lt;matt at sergeant.org&gt;"

       Currently maintained by Mohammad S Anwar, "&lt;mohammad.anwar at yahoo.com&gt;"

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::XPath::Function, XML::XPath::Literal, XML::XPath::Boolean, XML::XPath::Number,
       XML::XPath::XMLParser, XML::XPath::NodeSet, XML::XPath::PerlSAX, XML::XPath::Builder.

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This module is  copyright  2000 AxKit.com Ltd. This is free software, and as such comes with NO WARRANTY.
       No dates are used in this module. You may distribute this module under the terms  of either the Gnu GPL,
       or the Artistic License (the same terms as Perl itself).

       For support, please subscribe to the Perl-XML &lt;<a href="http://listserv.activestate.com/mailman/listinfo/perl-xml">http://listserv.activestate.com/mailman/listinfo/perl-xml</a>&gt;
       mailing list at the URL

perl v5.34.0                                       2022-08-13                                    <u>XML::<a href="../man3pm/XPath.3pm.html">XPath</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>